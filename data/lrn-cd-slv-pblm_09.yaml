- en: '9'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '9'
- en: DESIGNING ALGORITHMS WITH COMPLETE SEARCH
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 设计完全搜索算法
- en: '![image](Images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/common.jpg)'
- en: An *algorithm* is a sequence of steps that solves a problem. For each problem
    in this book, we solved it by writing an algorithm in the form of Python code.
    We’ll focus in this chapter on designing algorithms. When faced with a new problem,
    sometimes it’s hard to know what to do to solve it. What algorithm should we write?
    Fortunately, we don’t need to start from scratch each time. Computer scientists
    and programmers have identified several general types of algorithms, and it’s
    likely that at least one of them can be used to solve our problem.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*算法* 是解决问题的步骤序列。对于本书中的每个问题，我们通过编写 Python 代码的形式来解决它。我们将在本章中重点讨论算法设计。当面对一个新问题时，有时很难知道该怎么做才能解决它。我们应该编写什么算法？幸运的是，我们不需要每次都从零开始。计算机科学家和程序员已经确定了几种通用算法类型，而且其中至少有一种可以用来解决我们的问题。'
- en: One type of algorithm is called a *complete search* algorithm; it involves trying
    all candidate solutions and choosing the best one. For example, if the problem
    asks us to find a maximum, we try all solutions and choose the largest; if the
    problem asks us to find a minimum, we try all solutions and choose the smallest.
    Complete-search algorithms are also known as *brute-force* algorithms, but I’ll
    avoid that term. It’s true that the computer is powering its way through, checking
    solution after solution, but there’s nothing brute force about what we’re doing
    as algorithm designers.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 一种算法叫做 *完全搜索* 算法；它涉及尝试所有候选解决方案并选择最好的。例如，如果问题要求我们找到最大值，我们会尝试所有解决方案并选择最大的；如果问题要求我们找到最小值，我们会尝试所有解决方案并选择最小的。完全搜索算法也被称为
    *暴力破解* 算法，但我会避免使用这个术语。的确，计算机在不断地检查一个又一个解决方案，但作为算法设计者，我们做的并不算是暴力破解。
- en: We used a complete-search algorithm to solve Village Neighborhood in [Chapter
    5](ch05.xhtml#ch05). We were asked to find the smallest size of the neighborhoods,
    and we did that by looking at each neighborhood and remembering the size of the
    smallest one. In this chapter, we’ll use complete-search algorithms to solve other
    problems. We’ll see that it can take considerable ingenuity to determine what
    exactly to search.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用完全搜索算法解决了 [第 5 章](ch05.xhtml#ch05)中的《村庄邻里》问题。我们被要求找到最小的邻里大小，我们通过查看每个邻里并记住最小的那个来解决这个问题。在本章中，我们将使用完全搜索算法解决其他问题。我们将看到，确定究竟搜索什么可能需要相当的创意。
- en: 'We’ll solve two problems using complete search: determining which lifeguard
    to fire and identifying the minimum cost to meet ski training camp requirements.
    Then we’ll see a third problem, counting triples of cows that meet given observations,
    that requires we go a little further.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过完全搜索解决两个问题：确定解雇哪名救生员，以及识别满足滑雪训练营要求的最低成本。然后我们将看到第三个问题，统计符合特定观察条件的奶牛三元组，这需要我们进一步探索。
- en: 'Problem #21: Lifeguards'
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '问题 #21：救生员'
- en: In this problem, we’ll need to determine which lifeguard to fire that leaves
    us with the maximum schedule coverage of a pool. We’ll try separately firing each
    one and observing the results—that’s a complete-search algorithm!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个问题中，我们需要确定解雇哪名救生员，以便在解雇后最大化游泳池的时间覆盖率。我们将分别尝试解雇每一名救生员并观察结果——这就是一个完全搜索算法！
- en: This is USACO 2018 January Bronze Contest problem Lifeguards.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 USACO 2018 年 1 月的铜奖竞赛问题《救生员》。
- en: The Challenge
  id: totrans-10
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战
- en: Farmer John has purchased a swimming pool for his cows. The pool is open from
    time 0 to time 1000.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 农场主约翰为他的奶牛购买了一个游泳池。这个游泳池从时间 0 开放到时间 1000。
- en: Farmer John hires *n* lifeguards to monitor the pool. Each lifeguard monitors
    the pool for a given interval of time. For example, a lifeguard might start at
    time 2 and end at time 7\. I’ll denote such an interval as 2–7\. The number of
    units of time covered by an interval is the ending time minus the starting time.
    For example, the lifeguard whose time interval is 2–7 covers 7 – 2 = 5 units of
    time. Those time units are from time 2 to 3, 3 to 4, 4 to 5, 5 to 6, and 6 to
    7.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 农场主约翰雇佣了 *n* 名救生员来监视游泳池。每名救生员监视游泳池的时间是一个给定的时间区间。例如，一名救生员可能从时间 2 开始，到时间 7 结束。我会用
    2–7 来表示这样的区间。一个区间所覆盖的时间单位数是结束时间减去开始时间。例如，时间区间为 2–7 的救生员覆盖了 7 – 2 = 5 个时间单位。这些时间单位分别是从时间
    2 到 3、从 3 到 4、从 4 到 5、从 5 到 6 和从 6 到 7。
- en: Unfortunately, Farmer John only has enough money to pay for *n* – 1 lifeguards,
    not *n* lifeguards, so he must fire one lifeguard.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，农场主约翰只有足够的钱支付 *n* – 1 名救生员的工资，而不是 *n* 名救生员，所以他必须解雇一名救生员。
- en: Determine the maximum number of units of time that can still be covered after
    firing one lifeguard.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 确定解雇一个救生员后，仍然能覆盖的最大时间单位数。
- en: Input
  id: totrans-15
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输入
- en: Read input from the file named *lifeguards.in*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 从名为 *lifeguards.in* 的文件中读取输入。
- en: 'The input consists of the following lines:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 输入由以下几行组成：
- en: A line containing *n*, the number of lifeguards who were hired. *n* is between
    1 and 100.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一行包含 *n*，即被雇佣的救生员数量。*n* 介于 1 和 100 之间。
- en: '*n* lines, one per lifeguard. Each line gives the time when the lifeguard starts,
    a space, and the time when the lifeguard ends. The start and end times are all
    integers between 0 and 1,000 and are all distinct.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*n* 行，每行对应一个救生员。每行给出救生员的开始时间、一个空格和结束时间。开始时间和结束时间都是介于 0 和 1,000 之间的整数，并且都是唯一的。'
- en: Output
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输出
- en: Write output to the file named *lifeguards.out*.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 将输出写入名为 *lifeguards.out* 的文件。
- en: Output the maximum number of units of time that can be covered by *n* – 1 of
    the lifeguards.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 输出可以由 *n* – 1 个救生员覆盖的最大时间单位数。
- en: The time limit for solving each test case is four seconds.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 每个测试用例的解题时间限制是四秒。
- en: Exploring a Test Case
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探索一个测试用例
- en: 'Let’s explore a test case to help justify why a complete-search algorithm makes
    sense for this problem. Here’s the test case:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个测试用例来探索为什么完整搜索算法对于这个问题是有意义的。以下是这个测试用例：
- en: '4'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: 5 8
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 5 8
- en: 10 15
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 10 15
- en: 17 25
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 17 25
- en: 9 20
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 9 20
- en: One simple rule you might try to use to solve this problem is to fire the lifeguard
    with the shortest time interval. That makes some intuitive sense, because it seems
    as though that lifeguard contributes the least to covering the pool.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能尝试用来解决这个问题的一个简单规则是解雇时间间隔最短的救生员。这看起来直观合理，因为这个救生员似乎对覆盖游泳池的贡献最小。
- en: Does this rule give us a correct algorithm? Let’s see. It tells us to fire the
    5–8 lifeguard, since that lifeguard has the shortest time interval. That leaves
    us with the three lifeguards whose time intervals are 10–15, 17–25, and 9–20\.
    These three remaining lifeguards cover exactly the interval 9–25, which consists
    of 25 – 9 = 16 units of time. Is 16 the correct answer?
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规则能给我们一个正确的算法吗？让我们来看看。它告诉我们解雇 5–8 的救生员，因为这个救生员的时间间隔最短。这样剩下的三个救生员的时间间隔分别是 10–15、17–25
    和 9–20。这三个剩余的救生员正好覆盖了 9–25 的时间段，其中 25 – 9 = 16 个时间单位。16 是正确答案吗？
- en: 'Unfortunately, no. It turns out that what we should have done is fire the 10–15
    lifeguard. If we do that, then we’re left with the three lifeguards whose time
    intervals are 5–8, 17–25, and 9–20\. These three remaining lifeguards cover the
    intervals 5–8 and 9–25\. (Careful: they don’t cover the unit of time from 8 to
    9.) The first of these intervals covers 8 – 5 = 3 units of time, and the second
    covers 25 – 9 = 16 units of time, for a total of 19 units of time.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，不对。事实证明我们应该解雇 10–15 的救生员。如果我们这么做，剩下的三个救生员的时间间隔将是 5–8、17–25 和 9–20。这三个剩余的救生员覆盖了
    5–8 和 9–25 的时间段。（小心：它们并没有覆盖 8 到 9 之间的时间。）这两个时间段分别覆盖了 8 – 5 = 3 个时间单位和 25 – 9 =
    16 个时间单位，总共覆盖了 19 个时间单位。
- en: The correct answer is 19, not 16\. Firing the lifeguard with the shortest time
    interval didn’t work.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 正确答案是 19，而不是 16。解雇时间间隔最短的救生员并没有成功。
- en: 'It’s not easy to come up with a simple rule that always works to solve this
    problem. We don’t need to worry, though: with a complete-search algorithm, we
    dodge this requirement entirely.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 想出一个总是有效的简单规则来解决这个问题并不容易。不过不用担心：通过完整搜索算法，我们可以完全避免这个要求。
- en: 'Here’s what our complete-search algorithm will do to solve our test case:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们的完整搜索算法用来解决测试用例的过程：
- en: First, it will ignore the first lifeguard and determine the number of units
    of time that the three remaining lifeguards cover. It will obtain an answer of
    16\. It will remember 16 as the score to beat.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，算法会忽略第一个救生员，并计算剩下三个救生员覆盖的时间单位数。它得到的答案是 16。它会记住 16 作为新的目标得分。
- en: Next, it will ignore the second lifeguard and determine the number of units
    of time that the three remaining lifeguards cover. It will obtain an answer of
    19\. Since 19 is greater than 16, it will remember 19 as the score to beat.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，算法会忽略第二个救生员，并计算剩下三个救生员覆盖的时间单位数。它得到的答案是 19。由于 19 大于 16，它会记住 19 作为新的目标得分。
- en: Next, it will ignore the third lifeguard and determine the number of units of
    time that the three remaining lifeguards cover. It will obtain an answer of 14\.
    The score to beat is still 19.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，算法会忽略第三个救生员，并计算剩下三个救生员覆盖的时间单位数。它得到的答案是 14。目标得分依然是 19。
- en: Finally, it will ignore the fourth lifeguard and determine the number of units
    of time that the three remaining lifeguards cover. It will obtain an answer of
    16\. The score to beat is still 19.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，它将忽略第四个救生员，并确定其余三个救生员所覆盖的时间单位数。最终得到的答案是 16。仍然需要超过的分数是 19。
- en: Having considered the ramifications of firing each lifeguard, the algorithm
    concludes that 19 is the correct answer. There can be no better answer than this,
    because we tried every option! We performed a complete search of the possible
    solutions.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑了解雇每个救生员的后果之后，算法得出 19 是正确的答案。因为我们已经尝试了所有的选项，所以没有比这更好的答案了！我们对所有可能的解进行了完全搜索。
- en: Solving the Problem
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决问题
- en: To use complete search, it’s often helpful to begin by writing a function that
    solves the problem for a particular candidate solution. We can then call that
    function many times, once for each candidate solution.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用完全搜索时，通常从为特定候选解编写一个解决问题的函数开始会比较有帮助。然后我们可以多次调用该函数，每次使用一个候选解。
- en: Firing One Lifeguard
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解雇一个救生员
- en: Let’s write a function to determine the number of time units that are covered
    when one particular lifeguard is fired. [Listing 9-1](ch09.xhtml#ch09ex01) shows
    the code.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们写一个函数来确定当某个特定的救生员被解雇时，所覆盖的时间单位数。[Listing 9-1](ch09.xhtml#ch09ex01)展示了代码。
- en: 'def num_covered(intervals, fired):'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 'def num_covered(intervals, fired):'
- en: '"""'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: intervals is a list of lifeguard intervals;
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: intervals 是一个救生员时间间隔的列表；
- en: each interval is a [start, end] list.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 每个时间间隔是一个 [start, end] 列表。
- en: fired is the index of the lifeguard to fire.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: fired 是要解雇的救生员的索引。
- en: Return the number of time units covered by all lifeguards
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 返回所有救生员所覆盖的时间单位数
- en: except the one fired.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 除了被解雇的救生员。
- en: '"""'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: ❶ covered = set()
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ covered = set()
- en: 'for i in range(len(intervals)):'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(len(intervals)):'
- en: 'if i != fired:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 'if i != fired:'
- en: interval = intervals[i]
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: interval = intervals[i]
- en: '❷ for j in range(interval[0], interval[1]):'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '❷ for j in range(interval[0], interval[1]):'
- en: ❸ covered.add(j)
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ covered.add(j)
- en: return len(covered)
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: return len(covered)
- en: '*Listing 9-1: Solving when one particular lifeguard is fired*'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 9-1: 解决某个特定救生员被解雇时的问题*'
- en: 'The first parameter is a list of lifeguard time intervals; the second is the
    index of the lifeguard to fire. Enter the code into the Python shell. Here are
    two sample calls of the function:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是一个救生员时间间隔的列表；第二个参数是要解雇的救生员的索引。将代码输入到 Python Shell 中。以下是该函数的两个示例调用：
- en: '>>> num_covered([[5, 8], [10, 15], [9, 20], [17, 25]], 0)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> num_covered([[5, 8], [10, 15], [9, 20], [17, 25]], 0)'
- en: '16'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '16'
- en: '>>> num_covered([[5, 8], [10, 15], [9, 20], [17, 25]], 1)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> num_covered([[5, 8], [10, 15], [9, 20], [17, 25]], 1)'
- en: '19'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '19'
- en: These calls confirm that we can cover 16 units of time if we fire lifeguard
    0 and can cover 19 units of time if we fire lifeguard 1.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这些调用确认，如果解雇救生员 0，我们可以覆盖 16 个时间单位；如果解雇救生员 1，我们可以覆盖 19 个时间单位。
- en: Now let’s understand how the function operates. We begin by creating a set that
    will hold the units of time that are covered ❶. Whenever a unit of time is covered,
    the code will add the start of that unit of time to the set. For example, if the
    unit of time from 0 to 1 is covered, then the code will add 0 to the set; if the
    unit of time from 4 to 5 is covered, it will add 4 to the set.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们理解这个函数是如何操作的。我们首先创建一个集合来保存已覆盖的时间单位 ❶。每当一个时间单位被覆盖时，代码将该时间单位的开始时间添加到集合中。例如，如果从
    0 到 1 的时间单位被覆盖，代码会将 0 添加到集合中；如果从 4 到 5 的时间单位被覆盖，它将把 4 添加到集合中。
- en: We loop through the lifeguard time intervals. If a lifeguard isn’t fired, then
    we loop through this lifeguard’s time interval ❷ to consider each unit of covered
    time. We add each of these time units to the set ❸, as promised. Recall that sets
    don’t retain duplicate values; we don’t have to worry if we try to add the same
    unit of time multiple times. We’ve gone through all of the nonfired lifeguards
    and added to the set all units of time that are covered. We therefore simply return
    the number of values in the set.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遍历救生员的时间间隔。如果某个救生员没有被解雇，那么我们会遍历该救生员的时间间隔 ❷ 来考虑每个覆盖的时间单位。我们将这些时间单位添加到集合中 ❸，正如之前所承诺的那样。回想一下，集合不保留重复的值；如果我们多次尝试添加相同的时间单位也不需要担心。我们已经遍历了所有未解雇的救生员，并将它们所覆盖的所有时间单位添加到集合中。因此，我们只需返回集合中值的数量。
- en: The Main Program
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 主程序
- en: The main part of our program is in [Listing 9-2](ch09.xhtml#ch09ex02). It uses
    the num_covered function to determine the number of units of time that are covered
    when separately firing each lifeguard. Be sure to enter our num_covered function
    ([Listing 9-1](ch09.xhtml#ch09ex01)) before this code for a complete solution
    to the problem.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们程序的主要部分在[Listing 9-2](ch09.xhtml#ch09ex02)中。它使用num_covered函数来确定开除每个救生员时能够覆盖的时间单位数。确保在这段代码之前输入我们的num_covered函数([Listing
    9-1](ch09.xhtml#ch09ex01))，以便完整地解决问题。
- en: input_file = open('lifeguards.in', 'r')
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: input_file = open('lifeguards.in', 'r')
- en: output_file = open('lifeguards.out', 'w')
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: output_file = open('lifeguards.out', 'w')
- en: n = int(input_file.readline())
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: n = int(input_file.readline())
- en: intervals = []
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: intervals = []
- en: 'for i in range(n):'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(n):'
- en: ❶ interval = input_file.readline().split()
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ interval = input_file.readline().split()
- en: interval[0] = int(interval[0])
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: interval[0] = int(interval[0])
- en: interval[1] = int(interval[1])
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: interval[1] = int(interval[1])
- en: intervals.append(interval)
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: intervals.append(interval)
- en: max_covered = 0
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: max_covered = 0
- en: '❷ for fired in range(n):'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '❷ for fired in range(n):'
- en: ❸ result = num_covered(intervals, fired)
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ result = num_covered(intervals, fired)
- en: 'if result > max_covered:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 'if result > max_covered:'
- en: max_covered = result
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: max_covered = result
- en: output_file.write(str(max_covered) + '\n')
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: output_file.write(str(max_covered) + '\n')
- en: input_file.close()
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: input_file.close()
- en: output_file.close()
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: output_file.close()
- en: '*Listing 9-2: Main program*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 9-2: 主程序*'
- en: We’re working with files here, not standard input and standard output.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这里处理的是文件，而不是标准输入和标准输出。
- en: The program begins by reading the number of lifeguards and then uses a range
    for loop to read each lifeguard’s time interval. We read each time interval from
    the input ❶, convert each of its components to an integer, and append it as a
    two-value list to our list of intervals.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 程序首先读取救生员的数量，然后使用for循环读取每个救生员的时间区间。我们从输入❶读取每个时间区间，将它的每个部分转换为整数，并将其作为一个包含两个值的列表追加到我们的区间列表中。
- en: We use the max_covered variable to track the maximum number of time units that
    can be covered.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用max_covered变量来追踪能够覆盖的最大时间单位数。
- en: Now we separately fire each lifeguard using a range for loop ❷. We call num_covered
    ❸ to determine the number of time units that are covered given the firing of one
    lifeguard. We update max_covered whenever we’re able to cover a greater number
    of time units.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们使用for循环❷逐个开除每个救生员。我们调用num_covered ❸来确定开除一个救生员后能够覆盖的时间单位数。每当我们能够覆盖更多的时间单位时，就更新max_covered。
- en: When that loop completes, we’ll have checked the number of units of time that
    can be covered by firing each lifeguard, and we’ll have remembered the maximum.
    We output this maximum to solve the problem.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当那个循环完成时，我们将已经检查了每个救生员的开除情况能够覆盖的时间单位数，并记住了其中的最大值。我们输出这个最大值来解决问题。
- en: Feel free to submit our code to the USACO judge. For Python code, this judge
    uses a time limit per test case of four seconds, but our solution shouldn’t come
    close to that limit. For example, I just ran the code here, and each test case
    finished in no more than 130 milliseconds.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎将我们的代码提交给USACO评审。对于Python代码，评审为每个测试用例设定了四秒的时间限制，但我们的解决方案应该不会接近这个限制。例如，我刚才运行了这段代码，每个测试用例的完成时间都不超过130毫秒。
- en: Efficiency of Our Program
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 我们程序的效率
- en: The reason our code is so fast is because there are so few lifeguards—only at
    most 100 of them. If there were a large number of lifeguards, then our code would
    no longer solve the problem within the time limit. We’d be fine if there were
    a few hundred lifeguards. We might squeak through if we had as many as 3,000 or
    4,000 lifeguards. Any more than that, though, and our code would be too slow.
    We probably couldn’t make it in time with 5,000 lifeguards, for example. We’d
    need to design a new algorithm, likely one that uses something faster than complete
    search.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们代码运行如此之快的原因是因为救生员数量非常少——最多只有100个。如果救生员的数量很多，那么我们的代码就无法在时间限制内解决问题。如果有几百个救生员，我们应该没问题。如果有3000或4000个救生员，可能还能勉强通过。但是超过这个数量，我们的代码就会变得太慢。例如，如果有5000个救生员，我们可能就无法在规定时间内完成了。我们需要设计一个新的算法，可能是利用比完全搜索更快的方法。
- en: You might think that 5,000 is a huge number of lifeguards and that it’s okay
    that our algorithm can’t go that high. But it’s not! Think back to the Email Addresses
    problem in [Chapter 8](ch08.xhtml#ch08). There, we had to contend with up to 100,000
    email addresses. And think back to the Cities and States problem in the same chapter.
    There, we had to contend with up to 200,000 cities. By comparison, 5,000 is not
    a lot of lifeguards.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能认为5,000是一个庞大的救生员数量，认为我们的算法无法处理这么高的数字也没关系。但事实并非如此！回想一下[第8章](ch08.xhtml#ch08)中的电子邮件地址问题。那里，我们需要处理多达100,000个电子邮件地址。再想想同一章中的城市和州问题。那里，我们需要处理多达200,000个城市。相比之下，5,000个救生员并不算多。
- en: A complete-search solution often works fine for a small amount of input. Large
    test cases are often where complete-search solutions break down.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 完全搜索解决方案通常适用于少量输入。大规模测试用例往往是完全搜索解决方案失败的地方。
- en: The reason that our complete-search solution for Lifeguards doesn’t work well
    with large test cases is because it does a lot of repeated work. Imagine that
    we’re solving a test case with 5,000 lifeguards. We’ll fire lifeguard 0 and call
    num_covered to determine the number of units of time covered by the remaining
    lifeguards. Then, we’ll fire lifeguard 1 and call num_covered again. Now, what
    num_covered does this time is similar to what it did on the previous call. After
    all, things haven’t changed much. The only change is that lifeguard 0 is back
    and lifeguard 1 is fired. The other 4,998 lifeguards are the same as they were!
    But num_covered doesn’t know that. It grinds through all of the lifeguards again.
    That same thing happens when we fire lifeguard 2, then lifeguard 3, and so on.
    Each time, num_covered does all of its work from scratch, without learning anything
    about what it did previously.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的救生员问题的完全搜索解决方案在处理大规模测试用例时效果不佳，原因是它做了大量重复的工作。假设我们在处理一个有5,000个救生员的测试用例。我们解雇救生员0，并调用num_covered来确定剩余救生员覆盖的时间单位数。然后，我们解雇救生员1，再次调用num_covered。这次num_covered所做的工作与上次类似。毕竟，情况并没有发生太大变化。唯一的变化是救生员0回来了，而救生员1被解雇了。其他4,998个救生员和之前一样！但是num_covered并不知道这一点。它又重新计算了所有救生员的工作。当我们解雇救生员2、救生员3，依此类推时，同样的情况会发生。每次，num_covered都从头开始做所有工作，而没有学习之前做过的事情。
- en: Remember that, while useful, complete-search algorithms do have limitations.
    Given a new problem that we want to solve, a complete-search algorithm is a useful
    starting point, even if it ultimately turns out to be too inefficient. That’s
    because the act of designing that algorithm may deepen our appreciation of the
    problem and lead to new ideas for solving it.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，虽然有用，完全搜索算法也有局限性。面对一个新的问题，我们想要解决时，完全搜索算法是一个有用的起点，即使最终证明它效率太低。因为设计该算法的过程可能加深我们对问题的理解，并激发新的解决思路。
- en: In the next section, we’ll see another problem where we’ll be able to use complete
    search.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一部分，我们将看到另一个可以使用完全搜索的问题。
- en: '**CONCEPT CHECK**'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念检查**'
- en: Is the following version of num_covered correct?
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以下版本的num_covered是否正确？
- en: 'def num_covered(intervals, fired):'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 'def num_covered(intervals, fired):'
- en: '"""'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: intervals is a list of lifeguard intervals;
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: intervals是一个救生员时间段的列表；
- en: each interval is a [start, end] list.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 每个时间段是一个[start, end]的列表。
- en: fired is the index of the lifeguard to fire.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: fired是要解雇的救生员的索引。
- en: Return the number of time units covered by all lifeguards
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 返回所有救生员覆盖的时间单位数
- en: except the one fired.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 除了被解雇的那个。
- en: '"""'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: covered = set()
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: covered = set()
- en: intervals.pop(fired)
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: intervals.pop(fired)
- en: 'for interval in intervals:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 'for interval in intervals:'
- en: 'for j in range(interval[0], interval[1]):'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 'for j in range(interval[0], interval[1]):'
- en: covered.add(j)
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: covered.add(j)
- en: return len(covered)
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: return len(covered)
- en: A. Yes
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: A. 是的
- en: B. No
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: B. 不
- en: 'Answer: B. This function removes the fired lifeguard from the list of lifeguards.
    That’s not allowed, because the docstring doesn’t say anything about the function
    modifying the list. With this version of the function, our program will fail many
    test cases because lifeguard information is lost over time. For example, when
    we test firing lifeguard 0, lifeguard 0 is removed from the list. When we later
    test firing lifeguard 1, lifeguard 0 is unfortunately still gone! If you want
    to use a version of the function where the fired lifeguard is removed from the
    list, you need to work with a copy of the list rather than the original.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：B。这个函数从救生员列表中删除被解雇的救生员。这是不允许的，因为文档字符串没有说明该函数会修改列表。使用这个版本的函数时，我们的程序将在许多测试用例中失败，因为救生员信息会随着时间丢失。例如，当我们测试开除救生员0时，救生员0被从列表中删除。后来我们测试开除救生员1时，救生员0不幸仍然被删除！如果你想使用一个删除被解雇救生员的函数版本，你需要操作列表的副本，而不是原始列表。
- en: 'Problem #22: Ski Hills'
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '问题 #22: 滑雪场'
- en: Sometimes, the problem description makes it clear what we should search through
    in a complete-search solution. For example, in Lifeguards, we were asked to fire
    one lifeguard, so it made sense to try firing each one. Other times, we’ll have
    to be more creative to determine what to search through. As you read this next
    problem, think about what you would search in a complete-search solution.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，问题描述会明确说明在完全搜索解决方案中应该搜索什么。例如，在救生员问题中，我们被要求开除一名救生员，因此尝试开除每个救生员是合理的。而其他时候，我们需要更具创造性地确定应该搜索什么。当你阅读下一个问题时，思考一下在完全搜索解决方案中你会搜索什么。
- en: This is USACO 2014 January Bronze Contest problem Ski Course Design.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这是USACO 2014年1月的青铜奖竞赛问题：滑雪课程设计。
- en: The Challenge
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战
- en: Farmer John has *n* hills on his farm, each with a height between 0 and 100\.
    He would like to register his farm as a ski training camp.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 农场主约翰的农场上有*n*座山丘，每座山丘的高度在0到100之间。他希望将农场注册为滑雪训练营。
- en: A farm can be registered as a ski training camp only if the difference in height
    between the highest and lowest hills is 17 or less. Farmer John may therefore
    need to increase the heights of some of his hills and decrease the heights of
    others. He is able to change the heights only by integer amounts.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当最高和最低山丘的高度差不超过17时，农场才能注册为滑雪训练营。因此，农场主约翰可能需要增加一些山丘的高度并降低其他山丘的高度。他只能以整数的方式更改山丘的高度。
- en: The cost of changing a hill’s height by *x* units is *x*². For example, changing
    a hill from height 1 to height 4 costs (4 – 1)² = 9.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 改变山丘高度*x*单位的费用是*x*²。例如，将山丘从高度1改为高度4的费用是(4 - 1)² = 9。
- en: Determine the minimum amount that Farmer John will need to pay to change the
    heights of hills so that he can register his farm as a ski training camp.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 确定农场主约翰需要支付的最小金额，以便他能将农场注册为滑雪训练营。
- en: Input
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输入
- en: Read input from the file named *skidesign.in*.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 从名为*skidesign.in*的文件中读取输入。
- en: 'The input consists of the following lines:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 输入包括以下几行：
- en: A line containing integer *n*, the number of hills on the farm. *n* is between
    1 and 1,000.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一行包含整数*n*，表示农场上的山丘数量。*n*的范围是1到1000。
- en: '*n* lines, each of which gives the height of a hill. Each height is an integer
    between 0 and 100.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*n*行，每行给出一座山丘的高度。每个高度是0到100之间的整数。'
- en: Output
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输出
- en: Write output to the file named *skidesign.out*.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 将输出写入名为*skidesign.out*的文件。
- en: Output the minimum amount that Farmer John will need to pay to change the heights
    of hills.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 输出农场主约翰需要支付的最小金额，用于改变山丘的高度。
- en: The time limit for solving each test case is four seconds.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 每个测试用例的时间限制是四秒。
- en: Exploring a Test Case
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探索一个测试用例
- en: Let’s see if we can apply what we learned from Lifeguards to this problem. To
    solve Lifeguards, we separately fired each lifeguard to figure out the lifeguard
    that we should fire. To solve Ski Hills, perhaps there’s something analogous that
    we can do with each hill? For example, perhaps we can use each hill’s height as
    the low end in an allowed height range?
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看是否可以将从救生员问题中学到的知识应用到这个问题中。在解决救生员问题时，我们分别开除了每个救生员，以找出我们应该开除的救生员。解决滑雪场问题时，也许我们可以对每个山丘做类似的处理？例如，也许我们可以将每个山丘的高度作为允许高度范围的低端？
- en: 'We’ll give this a try using the following test case:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将尝试使用以下测试用例：
- en: '4'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: '23'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '23'
- en: '40'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '40'
- en: '16'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '16'
- en: '2'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: The smallest height of these four hills is 2, and the biggest height is 40\.
    The difference between 40 and 2 is 38, greater than 17\. Farmer John is going
    to have to pay to fix these hills!
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这四座山丘的最小高度为2，最大高度为40。40与2的差为38，大于17。农场主约翰将不得不支付费用来修复这些山丘！
- en: The first hill is height 23\. If we use 23 as the low end of the range, then
    the high end is 23 + 17 = 40\. We need to calculate the cost to bring all hills
    into the range 23–40\. There are two hills that are out of this range, the ones
    of heights 16 and 2\. Bringing them up to height 23 costs (23 – 16)² + (23 – 2)²
    = 490\. A cost of 490 is the cost to beat.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 第一座山的高度是23。如果我们使用23作为范围的低端，那么高端就是23 + 17 = 40。我们需要计算将所有山调整到23–40范围内的成本。有两座山超出了这个范围，它们的高度分别为16和2。将它们调整到高度23的成本是(23
    – 16)² + (23 – 2)² = 490。490是需要超越的成本。
- en: The second hill is height 40\. The high end of this range is 40 + 17 = 57, so
    we’re looking to get all hills into the range 40–57\. The other three hills are
    out of this range, so each of them contributes to the total cost. That total is
    (40 – 23)² + (40 – 16)² + (40 – 2)² = 2,309\. This is greater than 490, our current
    minimum cost, so 490 is still the cost to beat. (Remember that in this problem
    we’re trying to *minimize* Farmer John’s cost, whereas in Lifeguards we were trying
    to *maximize* coverage.)
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 第二座山的高度是40。这个范围的高端是40 + 17 = 57，所以我们希望将所有的山都调整到40–57的范围内。其他三座山超出了这个范围，因此它们每座都会增加总成本。这个总成本是(40
    – 23)² + (40 – 16)² + (40 – 2)² = 2,309。这个值大于490，即当前的最小成本，因此490仍然是需要超越的成本。（记住，在这个问题中，我们的目标是*最小化*农夫约翰的成本，而在救生员问题中，我们的目标是*最大化*覆盖范围。）
- en: The third hill is height 16, which gives us the range 16–33\. There are two
    hills that are out of this range, the ones of heights 40 and 2\. The total cost
    for this range is therefore (40 – 33)² + (16 – 2)² = 245\. The new cost to beat
    is 245!
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 第三座山的高度是16，这给我们提供了范围16–33。范围外有两座山，分别是高度为40和2的山。因此，这个范围的总成本是(40 – 33)² + (16
    – 2)² = 245。新的超越成本是245！
- en: The fourth hill is height 2, which gives us the range 2–19\. If you calculate
    the cost for this range, you should obtain a cost of 457.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 第四座山的高度是2，这给我们提供了范围2–19。如果你计算这个范围的成本，你应该得到457的成本。
- en: The minimum cost we obtained using that algorithm is 245\. Is 245 the answer?
    Are we done?
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 使用该算法得到的最小成本是245。245就是答案吗？我们完成了吗？
- en: 'No and no! It turns out that the minimum cost is 221\. There are two ranges
    that give us this minimum cost: 12–29 and 13–30\. There is no hill whose height
    is 12\. Similarly, there is no hill whose height is 13\. We therefore can’t use
    hill heights as the possible low ends of ranges.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 不，不行！事实证明，最小成本是221。我们获得这个最小成本的两个范围是12–29和13–30。没有任何一座山的高度是12。同样，也没有任何一座山的高度是13。因此，我们不能将山的高度作为范围的可能低端。
- en: Think about what a correct complete-search algorithm could look like, one that’s
    guaranteed not to miss any ranges.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 想一想一个正确的完整搜索算法会是什么样子，确保不会漏掉任何范围。
- en: Here’s a plan that’s guaranteed to get us the correct answer. We start by calculating
    the cost for range 0–17\. Then we calculate the cost for range 1–18\. Then 2–19\.
    Then 3–20\. Then 4–21, and so on. We test every possible range, one by one, and
    remember the minimum cost that we obtain. The ranges we test have nothing to do
    with the heights of the hills. Since we’re testing every possible range, there’s
    no way we’ll miss finding the best one.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个保证能得到正确答案的计划。我们首先计算范围0–17的成本。然后我们计算范围1–18的成本。接着是2–19，3–20，4–21，依此类推。我们逐一测试每个可能的范围，并记下得到的最小成本。我们测试的范围与山的高度无关。由于我们正在测试所有可能的范围，因此没有任何方法能让我们错过找到最佳范围。
- en: Which ranges should we test? How high should we go? Should we test the range
    50–67? Yes. How about the range 71–88? Yes again. How about 115–132? No! Not that
    one.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该测试哪些范围？我们要测试到多高？应该测试50–67的范围吗？是的。那71–88的范围呢？也是的。那115–132呢？不！不是这个。
- en: The final range that we’ll check is 100–117\. The reason has to do with the
    guarantee from the problem description that the height of any hill is at most
    100.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将检查的最终范围是100–117。原因与问题描述中的保证有关，即任何一座山的高度最多为100。
- en: Suppose we figure out the cost for range 101–118\. Without even knowing the
    heights of the hills, we know for sure that none of the hills is in this range.
    The maximum height of a hill, after all, is 100, and our range starts at 101\.
    Now slide our range from 101–118 down to 100–117\. This 100–117 range costs less
    than the 101–118 range! That’s because 100 is closer to the hills than 101 is.
    For example, consider a hill of height 80\. This hill would cost us 21² = 441
    to raise it to height 101, but only 20² = 400 to raise it to height 100\. This
    shows that 101–118 cannot be the best range to use. There’s no point trying it.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们计算范围101–118的成本。即使不知道这些山丘的高度，我们也可以确定这些山丘不在这个范围内。毕竟，山丘的最大高度是100，而我们的范围从101开始。现在将我们的范围从101–118滑动到100–117。这个100–117的范围比101–118的范围成本更低！这是因为100比101更接近这些山丘。例如，考虑一个高度为80的山丘。将这个山丘的高度提升到101需要的成本是21²
    = 441，而提升到100只需要20² = 400。这表明101–118不能是最优的范围，没必要尝试它。
- en: Similar logic explains why it’s pointless to try any higher range such as 102–119,
    103–120, and so on. We can always slide these ranges down to make them cost less.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的逻辑解释了为什么尝试更高的范围（例如102–119、103–120等）是没有意义的。我们总是可以将这些范围滑动下来，使其成本更低。
- en: 'In summary, we are going to test exactly 101 ranges: 0–17, 1–18, 2–19, and
    so on, all the way up to 100–117\. We’ll remember the cost of the best one. Let’s
    do this!'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，我们将测试恰好101个范围：0–17，1–18，2–19，以此类推，一直到100–117。我们会记住最优的成本。让我们开始吧！
- en: Solving the Problem
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 求解问题
- en: We’ll take the solution in two steps, just as we did when solving Lifeguards.
    We’ll start with a function to determine the cost of a single range. Then we’ll
    write a main program to call this function once for each range.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将分两步来解决这个问题，就像解决《救生员》问题时一样。我们将从一个函数开始，用来确定单个范围的成本。然后，我们将写一个主程序，每次调用这个函数，处理每个范围。
- en: Determining the Cost of One Range
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 确定单一范围的成本
- en: '[Listing 9-3](ch09.xhtml#ch09ex03) gives the code for the function that determines
    the cost of a given range.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 9-3](ch09.xhtml#ch09ex03)给出了确定给定范围成本的函数代码。'
- en: MAX_DIFFERENCE = 17
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: MAX_DIFFERENCE = 17
- en: MAX_HEIGHT = 100
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: MAX_HEIGHT = 100
- en: 'def cost_for_range(heights, low, high):'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 'def cost_for_range(heights, low, high):'
- en: '"""'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: heights is a list of hill heights.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: heights是一个山丘高度的列表。
- en: low is an integer giving the low end of the range.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: low是给定范围下限的整数。
- en: high is an integer giving the high end of a range.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: high是给定范围上限的整数。
- en: Return the cost of changing all heights of hills to be
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 返回将所有山丘的高度更改为
- en: between low and high.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 介于low和high之间。
- en: '"""'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: cost = 0
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: cost = 0
- en: '❶ for height in heights:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '❶ for height in heights:'
- en: '❷ if height < low:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '❷ if height < low:'
- en: ❸ cost = cost + (low - height) ** 2
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ cost = cost + (low - height) ** 2
- en: '❹ elif height > high:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '❹ elif height > high:'
- en: ❺ cost = cost + (height - high) ** 2
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ cost = cost + (height - high) ** 2
- en: return cost
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 返回成本
- en: '*Listing 9-3: Solving for one particular range*'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-3：求解一个特定范围*'
- en: I’ve included two constants that we’ll use later. The MAX_DIFFERENCE constant
    records the maximum difference allowed between the heights of the highest and
    lowest hills. The MAX_HEIGHT constant records the maximum height of a hill.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我已包含两个常量，我们稍后会用到。MAX_DIFFERENCE常量记录了最高和最低山丘高度之间允许的最大差异。MAX_HEIGHT常量记录了山丘的最大高度。
- en: Now let’s turn to the cost_for_range function. It takes a list of hill heights
    and a desired range specified by its low end and high end. It returns the cost
    of changing hill heights so that all hills are in the desired range. I encourage
    you to enter the code for the function into the Python shell so that you can try
    it before continuing.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看cost_for_range函数。它接受一个山丘高度的列表和一个由其下限和上限指定的目标范围。它返回将所有山丘高度更改为所需范围的成本。我鼓励你将这个函数的代码输入到Python
    shell中，在继续之前先试一下。
- en: The function loops through the height of each hill ❶, adding up the cost to
    bring that hill into the desired range. There are two cases we need to account
    for. First, the height of the current hill might be out of range by being less
    than low ❷. The expression low - height gives us the amount of height that we
    need to add to this hill, and we square that result to get the cost ❸. Second,
    the height of the current hill might be out of range by being greater than high
    ❹. The expression height - high gives us the amount of height that we need to
    subtract from this hill, and we square that result to get the cost ❺. Notice that
    we don’t do anything if the height is already in the low-high range. Once we’ve
    gone through all of the heights, we return the total cost.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数循环遍历每个山的高度❶，将成本累加到将该山调整到期望范围的过程中。我们需要考虑两种情况。首先，当前山的高度可能低于low❷。表达式low - height给我们提供了需要添加到这座山的高度量，我们将该结果平方以得到成本❸。其次，当前山的高度可能高于high❹。表达式height
    - high给我们提供了需要从这座山减去的高度量，我们同样将该结果平方以得到成本❺。注意，如果高度已经在low-high范围内，我们不会做任何事情。遍历完所有高度后，我们返回总成本。
- en: The Main Program
  id: totrans-186
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 主程序
- en: The main part of our program is in [Listing 9-4](ch09.xhtml#ch09ex04). It uses
    the cost_for_range function to determine the cost for each range. Be sure to enter
    our cost_for_range function ([Listing 9-3](ch09.xhtml#ch09ex03)) before this code
    for a complete solution to the problem.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们程序的主要部分在[列表 9-4](ch09.xhtml#ch09ex04)中。它使用cost_for_range函数来确定每个范围的成本。为了完整地解决这个问题，请确保在这段代码之前输入我们的cost_for_range函数（[列表
    9-3](ch09.xhtml#ch09ex03)）。
- en: input_file = open('skidesign.in', 'r')
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: input_file = open('skidesign.in', 'r')
- en: output_file = open('skidesign.out', 'w')
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: output_file = open('skidesign.out', 'w')
- en: n = int(input_file.readline())
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: n = int(input_file.readline())
- en: heights = []
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: heights = []
- en: 'for i in range(n):'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 对于i从0到n的范围：
- en: heights.append(int(input_file.readline()))
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: heights.append(int(input_file.readline()))
- en: ❶ min_cost = cost_for_range(heights, 0, MAX_DIFFERENCE)
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ min_cost = cost_for_range(heights, 0, MAX_DIFFERENCE)
- en: '❷ for low in range(1, MAX_HEIGHT + 1):'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 对于low从1到MAX_HEIGHT + 1的范围：
- en: result = cost_for_range(heights, low, low + MAX_DIFFERENCE)
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: result = cost_for_range(heights, low, low + MAX_DIFFERENCE)
- en: 'if result < min_cost:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果结果 < 最小成本：
- en: min_cost = result
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: min_cost = result
- en: output_file.write(str(min_cost) + '\n')
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: output_file.write(str(min_cost) + '\n')
- en: input_file.close()
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: input_file.close()
- en: output_file.close()
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: output_file.close()
- en: '*Listing 9-4: Main program*'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-4：主程序*'
- en: We start by reading the number of hills and then read each height into the heights
    list.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先读取山的数量，然后将每个高度读入heights列表。
- en: We use the min_cost variable to remember the minimum cost that we’ve discovered
    so far. We set min_cost to the cost for range 0–17 ❶. Then, in a range for loop
    ❷, we try every other range cost, updating min_cost every time we find a smaller
    cost. When we’re done with this loop, we output the minimum cost that we found.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用min_cost变量来记住到目前为止发现的最小成本。我们将min_cost设置为范围0–17的成本❶。然后，在一个范围的for循环中❷，我们尝试其他每个范围的成本，每当找到更小的成本时就更新min_cost。完成这个循环后，我们输出找到的最小成本。
- en: It’s time to submit our code to the judge. Our complete-search solution should
    solve the problem well under the time limit.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候将我们的代码提交给评审了。我们的完全搜索解决方案应该能在时间限制内很好地解决问题。
- en: In the next problem, we’ll see an example where a straight complete-search solution
    is not efficient enough.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个问题中，我们将看到一个例子，其中简单的完全搜索解决方案效率不足。
- en: '**CONCEPT CHECK**'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念检查**'
- en: 'Here’s a proposed change to the code in [Listing 9-4](ch09.xhtml#ch09ex04).
    Take this line:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对[列表 9-4](ch09.xhtml#ch09ex04)中代码的建议更改。看这一行：
- en: 'for low in range(1, MAX_HEIGHT + 1):'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 对于low从1到MAX_HEIGHT + 1的范围：
- en: 'And change it to the following:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 并将其更改为以下内容：
- en: 'for low in range(1, MAX_HEIGHT - MAX_DIFFERENCE + 1):'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 对于low从1到MAX_HEIGHT - MAX_DIFFERENCE + 1的范围：
- en: Is the code still correct?
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 代码仍然正确吗？
- en: A. Yes
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: A. 是的
- en: B. No
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: B. 不
- en: 'Answer: A. The last range that the code now checks is 83–100, so we have to
    argue that the ranges we no longer check—84–101, 85–102, and so on—don’t matter.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：A。代码现在检查的最后一个范围是83–100，所以我们必须证明我们不再检查的范围——84–101、85–102等——是无关紧要的。
- en: Consider the range 84–101\. If we can argue that the range 83–100 is at least
    as good as 84–101, then we would have no reason to check range 84–101.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑范围84–101。如果我们能证明范围83–100至少和84–101一样好，那么我们就没有理由检查范围84–101。
- en: 'The range 84–101 includes height 101\. But that’s pointless: the highest hill
    has height 100, so height 101 may as well not even be there. We can remove 101
    without making the range worse. If we remove it, we’re left with the range 84–100\.
    Aha—but 100–84 is only 16, and we’re allowed to have a difference of 17\. So we
    can extend the range by one on the left, giving us a range of 83–100\. Surely,
    making the range bigger like this can’t make the range any worse. It might even
    make the range better, since it’s now one unit closer to any hill whose height
    is 83 or less.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 范围84–101包括了高度101。但这是没有意义的：最高的山丘只有100，所以101的高度几乎可以忽略不计。我们可以去掉101而不影响范围。如果我们去掉它，剩下的范围就是84–100。啊哈——但是100–84仅为16，而我们允许的差值是17。所以我们可以将范围向左延伸一个单位，得到83–100的范围。显然，像这样扩大范围不会让范围变得更糟。它甚至可能让范围变得更好，因为它现在离任何高度为83或更低的山丘更近了。
- en: We started with range 84–101 and showed that range 83–100 is at least as good.
    We can make this same argument for range 85–102, 86–103, and so on. There’s no
    point going any higher than 83–100!
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从范围84–101开始，并展示了84–100范围至少是一样好的。我们可以对85–102、86–103等范围做出相同的论证。没有必要再往更高的范围去！
- en: Before continuing, you might like to try solving exercises 1 and 2 from “Chapter
    Exercises” on [page 263](ch09.xhtml#ch09lev1sec14).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，你可能想尝试解决《章节练习》中第1题和第2题，详见[第263页](ch09.xhtml#ch09lev1sec14)。
- en: 'Problem #23: Cow Baseball'
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '问题 #23：奶牛棒球'
- en: To end this chapter, I’ve chosen a problem where we’ll need to bump up our algorithm
    design skills beyond complete search. As you read the problem, notice that there’s
    not all that much input. That generally signals the effectiveness of a complete-search
    algorithm. But not this time, because of the amount of searching that such an
    algorithm has to do through this input. The difficulty boils down to having too
    many nested loops. Why do the nested loops bite us here? What can we do about
    it? Read on!
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结束这一章，我选择了一个问题，在这个问题中我们需要提升我们的算法设计技能，超越完全搜索。阅读这个问题时，请注意输入其实不多。通常这意味着完全搜索算法的有效性。但这次不一样，因为这样的算法需要在这个输入中进行大量的搜索。困难的关键在于嵌套循环太多。为什么嵌套循环在这里会给我们带来问题？我们该怎么做呢？继续阅读！
- en: This is USACO 2013 December Bronze Contest problem Cow Baseball.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这是USACO 2013年12月青铜级比赛问题——奶牛棒球。
- en: The Challenge
  id: totrans-223
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战
- en: Farmer John has *n* cows. They are standing in a row, each at a distinct integer
    position. They are having fun throwing a baseball around.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 农夫约翰有*n*只奶牛。它们排成一排，每只奶牛都有一个不同的位置。它们正在开心地玩着投接棒球的游戏。
- en: Farmer John is watching the antics. He observes that cow *x* throws the ball
    to some cow *y* to its right, and then that cow *y* throws the ball to some cow
    *z* to its right. He also knows that the distance of the second throw is at least
    the distance of the first throw and at most twice the distance of the first throw.
    (For example, if the first throw is distance 5, then the second throw is at least
    distance 5 and at most distance 10.)
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 农夫约翰正在观察这些滑稽的行为。他发现奶牛*x*将球扔给其右边的某只奶牛*y*，然后奶牛*y*又将球扔给其右边的某只奶牛*z*。他还知道第二次投掷的距离至少是第一次投掷的距离，最多是第一次投掷距离的两倍。（例如，如果第一次投掷的距离是5，那么第二次投掷的距离至少是5，最多是10。）
- en: Determine the number of (*x*, *y*, *z*) triples of cows that satisfy Farmer
    John’s observations.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 确定满足农夫约翰观察的奶牛三元组(*x*, *y*, *z*)的数量。
- en: Input
  id: totrans-227
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输入
- en: Read input from the file named *baseball.in*.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 从名为*baseball.in*的文件中读取输入。
- en: 'The input consists of the following lines:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 输入包含以下几行：
- en: A line containing *n*, the number of cows. *n* is between 3 and 1,000.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一行包含*n*，即奶牛的数量。*n*的值介于3到1,000之间。
- en: '*n* lines, each of which gives the position of a cow. All positions are unique,
    and each is between 1 and 100,000,000.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*n*行，每行给出一只奶牛的位置。所有位置都是唯一的，且每个位置的数值介于1和100,000,000之间。'
- en: Output
  id: totrans-232
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输出
- en: Write output to the file named *baseball.out*.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 将输出写入名为*baseball.out*的文件。
- en: Output the number of triples of cows that satisfy Farmer John’s observations.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 输出满足农夫约翰观察的奶牛三元组的数量。
- en: The time limit for solving each test case is four seconds.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 每个测试用例的时间限制为四秒。
- en: Using Three Nested Loops
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用三个嵌套循环
- en: We can use three nested loops to consider all possible triples. We’ll start
    by looking at the code and then discuss its efficiency.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用三个嵌套的循环来考虑所有可能的三元组。我们将先查看代码，然后讨论它的效率。
- en: The Code
  id: totrans-238
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 代码
- en: 'In “Nesting” in [Chapter 3](ch03.xhtml#ch03), we learned that we can loop through
    all pairs of values using two nested loops. Doing so looks like this:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在《第3章的“嵌套”》中，我们学会了如何使用两个嵌套循环遍历所有的值对。这样做的代码如下所示：
- en: '>>> lst = [1, 9]'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> lst = [1, 9]'
- en: '>>> for num1 in lst:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> for num1 in lst:'
- en: '...     for num2 in lst:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '...     for num2 in lst:'
- en: '...         print(num1, num2)'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '...         print(num1, num2)'
- en: '...'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: 1 1
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 1 1
- en: 1 9
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 1 9
- en: 9 1
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 9 1
- en: 9 9
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 9 9
- en: 'We can similarly loop through all triples of values using three nested loops,
    like this:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过类似的方法，使用三个嵌套的循环遍历所有的三元组，如下所示：
- en: '>>> for num1 in lst:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> for num1 in lst:'
- en: '...     for num2 in lst:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '...     for num2 in lst:'
- en: '...         for num3 in lst:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '...         for num3 in lst:'
- en: '...             print(num1, num2, num3)'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '...             print(num1, num2, num3)'
- en: '...'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: 1 1 1
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 1 1 1
- en: 1 1 9
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 1 1 9
- en: 1 9 1
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 1 9 1
- en: 1 9 9
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 1 9 9
- en: 9 1 1
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 9 1 1
- en: 9 1 9
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 9 1 9
- en: 9 9 1
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 9 9 1
- en: 9 9 9
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 9 9 9
- en: Using three nested loops like this gives us a starting point for solving the
    Cow Baseball problem. For each triple, we can check whether it matches Farmer
    John’s observations. See [Listing 9-5](ch09.xhtml#ch09ex05) for the code.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这样三个嵌套的循环为我们解决“牛棒球”问题提供了一个起点。对于每一组三元组，我们可以检查它是否符合 Farmer John 的观察结果。请参见 [Listing
    9-5](ch09.xhtml#ch09ex05) 获取代码。
- en: input_file = open('baseball.in', 'r')
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: input_file = open('baseball.in', 'r')
- en: output_file = open('baseball.out', 'w')
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: output_file = open('baseball.out', 'w')
- en: n = int(input_file.readline())
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: n = int(input_file.readline())
- en: positions = []
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: positions = []
- en: 'for i in range(n):'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(n):'
- en: ❶ positions.append(int(input_file.readline()))
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ positions.append(int(input_file.readline()))
- en: total = 0
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: total = 0
- en: '❷ for position1 in positions:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '❷ for position1 in positions:'
- en: '❸ for position2 in positions:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '❸ for position2 in positions:'
- en: first_two_diff = position2 - position1
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: first_two_diff = position2 - position1
- en: '❹ if first_two_diff > 0:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '❹ if first_two_diff > 0:'
- en: low = position2 + first_two_diff
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: low = position2 + first_two_diff
- en: high = position2 + first_two_diff * 2
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: high = position2 + first_two_diff * 2
- en: '❺ for position3 in positions:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '❺ for position3 in positions:'
- en: 'if position3 >= low and position3 <= high:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 'if position3 >= low and position3 <= high:'
- en: total = total + 1
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: total = total + 1
- en: output_file.write(str(total) + '\n')
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: output_file.write(str(total) + '\n')
- en: input_file.close()
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: input_file.close()
- en: output_file.close()
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: output_file.close()
- en: '*Listing 9-5: Using three nested* for *loops*'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 9-5: 使用三个嵌套* for *循环*'
- en: We read all of the cow positions into the positions list ❶. We then loop over
    all positions in the list using a for loop ❷. For each of these positions, we
    loop through all positions in the list using a nested for loop ❸. At this point,
    position1 and position2 refer to two positions from the list. We need a third
    nested loop, yes, but not yet. We first need to calculate the difference between
    position1 and position2 because that tells us the range of position3s that we’ll
    be looking for.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将所有牛的位置读取到 positions 列表中 ❶。然后我们使用 for 循环 ❷ 遍历列表中的所有位置。对于每一个位置，我们使用嵌套的 for
    循环 ❸ 遍历列表中的所有位置。在这一点上，position1 和 position2 分别表示列表中的两个位置。我们需要一个第三个嵌套循环，是的，但现在还不需要。我们首先需要计算
    position1 和 position2 之间的差异，因为这告诉我们将要查找的 position3 的范围。
- en: We require from the problem description that position2 be on the right of position1.
    If it is ❹, then we calculate the low end and high end of the range for position3
    and store them using low and high, respectively. For example, if position1 is
    1 and position2 is 6, then we’ll calculate 6 + 5 = 11 for low and 6 + 5 * 2 =
    16 for high. Then we loop through the list with a third nested for loop ❺, looking
    for positions that are between low and high. For each such position3, we increase
    our total by 1.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从问题描述中要求 position2 在 position1 的右侧。如果它是 ❹，那么我们计算 position3 的范围的低端和高端，并分别用
    low 和 high 存储它们。例如，如果 position1 是 1 且 position2 是 6，那么我们将计算 6 + 5 = 11 为低端，6 +
    5 * 2 = 16 为高端。然后我们通过第三个嵌套的 for 循环 ❺ 遍历列表，寻找介于 low 和 high 之间的位置。对于每个这样的 position3，我们将总数加
    1。
- en: Following the three nested loops, we have calculated the total number of triples.
    We finish up by outputting that number to the output file.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成三个嵌套的循环后，我们计算了三元组的总数。最后，我们将该数字输出到输出文件中。
- en: 'Let’s try our program on a small test case to make sure nothing weird is happening.
    Here it is:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在一个小的测试用例上运行我们的程序，确保没有发生奇怪的事情。代码如下：
- en: '7'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '7'
- en: '16'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '16'
- en: '14'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '14'
- en: '23'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '23'
- en: '18'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '18'
- en: '1'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '6'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: '11'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '11'
- en: 'The correct answer for this test case is 11\. The 11 satisfying triples are
    as follows:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 该测试用例的正确答案是 11。满足条件的 11 个三元组如下：
- en: 14, 16, 18
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 14, 16, 18
- en: 14, 18, 23
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 14, 18, 23
- en: 1, 6, 16
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1, 6, 16
- en: 1, 6, 14
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1, 6, 14
- en: 1, 6, 11
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1, 6, 11
- en: 1, 11, 23
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1, 11, 23
- en: 6, 14, 23
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 6, 14, 23
- en: 6, 11, 16
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 6, 11, 16
- en: 6, 11, 18
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 6, 11, 18
- en: 11, 16, 23
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 11, 16, 23
- en: 11, 14, 18
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 11, 14, 18
- en: 'Good news: our program outputs 11 for this test case! It does so because it
    eventually finds each satisfying triple. For example, at some point, position1
    will be 14, position2 will be 16, and position3 will be 18. That triple satisfies
    the distance requirements, so our program will count it in our total. Don’t be
    worried about what will happen, later, when position1 is 18, position2 is 16,
    and position3 is 14. We definitely don’t want to count that one, because these
    throws are not going to the right. We’re fine, though: the if statement ❹ prevents
    these triples from being processed.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息：我们的程序在这个测试用例中输出了11！它之所以这样做，是因为它最终找到了每一个满足条件的三元组。例如，在某个时刻，position1 会是 14，position2
    会是 16，position3 会是 18。这个三元组满足距离要求，因此我们的程序会将其计入总数。不要担心，后面当 position1 是 18，position2
    是 16，position3 是 14 时会发生什么。我们绝对不想计入这个三元组，因为这些投掷并没有投向正确的方向。不过没关系：if 语句 ❹ 会阻止这些三元组被处理。
- en: Our program is correct. But as you’ll see if you submit it to the judge, it
    is not efficient enough. For this problem, and many competitive programming problems,
    the first few test cases are small—just a few cows, a few lifeguards, or a few
    ski hills. Our program should be able to solve those in time. The remaining test
    cases test our program closer and closer to the limit of acceptable input. Our
    program does not solve those in time. It’s too slow.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序是正确的。但正如你在提交给评测系统时会看到的，它的效率不够高。对于这个问题以及许多竞赛编程问题，前几个测试用例是小的——只有几头牛、几个救生员或几个滑雪坡。我们的程序应该能够在规定时间内解决这些问题。而剩下的测试用例则会将我们的程序推向可接受输入的极限。我们的程序无法在规定时间内解决这些问题。它太慢了。
- en: Efficiency of Our Program
  id: totrans-310
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 我们程序的效率
- en: 'To understand why our program is so slow, it helps to think about the number
    of triples that it must go through. Think back to the test case we just studied,
    which had seven cows. How many triples will our program check? Well, for the first
    cow, there are seven choices: 16, 14, 23, and so on. There are also seven choices
    for the second cow, and seven choices for the third cow. Multiplying these together,
    we see that our program checks 7 * 7 * 7 = 343 triples.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解为什么我们的程序如此缓慢，考虑它必须遍历的三元组数量会有所帮助。回想一下我们刚刚研究的测试用例，它有七头牛。我们的程序会检查多少个三元组？首先，对于第一头牛，有七个选择：16、14、23，等等。第二头牛也有七个选择，第三头牛也有七个选择。将这些数相乘，我们可以看到我们的程序会检查
    7 * 7 * 7 = 343 个三元组。
- en: What if we had eight cows instead of seven? Then our program would check 8 *
    8 * 8 = 512 triples.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有八头牛而不是七头牛呢？那我们的程序将会检查 8 * 8 * 8 = 512 个三元组。
- en: We can give an expression for the number of triples that works for any number
    of cows. Let’s use *n* for the number of cows; it could be 7, 8, 50, 1,000, and
    so on, depending on the test case. Then we can say that the number of triples
    our program checks is *n* * *n* * *n*, or *n*³.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以给出一个适用于任意数量牛的三元组数量表达式。我们用 *n* 表示牛的数量；它可以是 7、8、50、1000 等，具体取决于测试用例。然后我们可以说，程序检查的三元组数量是
    *n* * *n* * *n*，即 *n*³。
- en: We can substitute any number of cows for *n* to determine the number of triples
    that we check. For example, we can verify that the number of triples for seven
    cows is 7³ = 343 and that the number of triples for eight cows is 8³ = 512\. These
    numbers—343 and 512—are tiny. It would take any computer no more than a few milliseconds
    to check those many triples. As a conservative guide, you can think of a Python
    program as being able to check or do about 5,000,000 things per second. The time
    limit for this problem is four seconds per test case, so we’ll be able to check
    about 20,000,000 triples.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将任何数量的牛代入 *n* 来确定我们检查的三元组数量。例如，我们可以验证七头牛的三元组数量是 7³ = 343，八头牛的三元组数量是 8³ =
    512。这些数字——343 和 512——很小。任何计算机都需要不到几毫秒的时间来检查这么多三元组。作为保守的参考，你可以认为一个 Python 程序每秒能够检查或执行约
    500 万次操作。这个问题的时间限制是每个测试用例 4 秒，所以我们能检查大约 20,000,000 个三元组。
- en: 'Let’s substitute larger numbers for *n* and see what happens. For 50 cows,
    we have 50³ = 125,000 triples. No big deal: checking 125,000 things is easy for
    today’s computers. For 100 cows, we have 100³ = 1,000,000 triples. Again, no problem.
    We can check a million things in less than a second. For 200 cows, we have 200³
    = 8,000,000 triples. We’re still OK for four seconds, but I hope you’re starting
    to get a little worried. The number of triples is shooting up pretty quickly here,
    and we’re only at 200 cows. Remember that we need to be able to support up to
    1,000 cows.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用更大的数字替代 *n*，看看会发生什么。对于 50 头牛，我们有 50³ = 125,000 个三元组。没什么大不了的：检查 125,000 个东西对于今天的计算机来说很容易。对于
    100 头牛，我们有 100³ = 1,000,000 个三元组。同样没问题。我们可以在不到一秒的时间内检查一百万个东西。对于 200 头牛，我们有 200³
    = 8,000,000 个三元组。我们在四秒内仍然能处理，但我希望你开始有点担心了。三元组的数量上升得相当快，而我们现在仅仅是 200 头牛。记住，我们需要支持最多
    1,000 头牛。
- en: For 400 cows, we have 400³ = 64,000,000 triples. That’s too many for us to process
    in four seconds. To add insult to injury, let’s try 1,000 cows, the maximum we’ll
    ever get. For 1,000 cows, we have 1,000³ = 1,000,000,000 triples. That’s one billion.
    Nope. There’s no way we’re ever going to be able to check that many triples in
    four seconds. We’ll need to make our program more efficient.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 400 头牛，我们有 400³ = 64,000,000 个三元组。这对于我们在四秒内处理来说太多了。更糟糕的是，让我们试试 1,000 头牛，这是我们能得到的最大值。对于
    1,000 头牛，我们有 1,000³ = 1,000,000,000 个三元组。那就是十亿。没戏了。在四秒内，我们根本不可能检查这么多三元组。我们需要让程序更高效。
- en: Sorting First
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 首先排序
- en: Sorting is helpful here. Let’s look at how to use sorting and then discuss the
    efficiency of our resulting solution.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 排序在这里是有帮助的。让我们先看看如何使用排序，然后讨论我们得到的解决方案的效率。
- en: The Code
  id: totrans-319
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 代码
- en: Our cow positions can come in any order—there’s certainly no guarantee from
    the problem description that they’re sorted. Unfortunately, this leads our program
    to check many triples that have no chance of satisfying the requirements. For
    example, checking the triple 18, 16, 14 is pointless, because the numbers aren’t
    in increasing order. If we sorted the cow positions at the outset, then we could
    avoid ever checking these out-of-order triples.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的牛的位置可以是任何顺序——问题描述中并没有保证它们是排序的。不幸的是，这导致我们的程序检查了许多不可能满足要求的三元组。例如，检查三元组 18、16、14
    是没有意义的，因为这些数字不是按递增顺序排列的。如果我们在一开始就对牛的位置进行排序，那么就可以避免检查这些不按顺序的三元组。
- en: There’s another benefit to sorting. Suppose that position1 refers to some cow
    position and position2 refers to another. For this pair of positions, we know
    the smallest value of position3 and largest value of position3 that we care about.
    We can use the fact that the positions are sorted to cut down on the number of
    values that we need to check for this range. Before continuing, think about why
    this is the case. How can we use the fact that the positions are sorted to look
    at fewer values?
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 排序还有另一个好处。假设 position1 指的是某个牛的位置，position2 指的是另一个牛的位置。对于这一对位置，我们知道我们关心的 position3
    的最小值和最大值。我们可以利用位置已排序这一事实，减少我们需要检查的值的数量。在继续之前，想一想为什么会这样。我们如何利用排序的事实来检查更少的值？
- en: When you’re ready, see [Listing 9-6](ch09.xhtml#ch09ex06) for our code that
    uses sorting.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 当你准备好时，可以参考 [清单 9-6](ch09.xhtml#ch09ex06)，查看我们使用排序的代码。
- en: input_file = open('baseball.in', 'r')
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: input_file = open('baseball.in', 'r')
- en: output_file = open('baseball.out', 'w')
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: output_file = open('baseball.out', 'w')
- en: n = int(input_file.readline())
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: n = int(input_file.readline())
- en: positions = []
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: positions = []
- en: 'for i in range(n):'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(n):'
- en: positions.append(int(input_file.readline()))
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: positions.append(int(input_file.readline()))
- en: ❶ positions.sort()
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ positions.sort()
- en: total = 0
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: total = 0
- en: '❷ for i in range(n):'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 对于 i 在 range(n) 之间的每个值，执行：
- en: '❸ for j in range(i + 1, n):'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 对于 j 在 i + 1 到 n 之间的每个值，执行：
- en: first_two_diff = positions[j] - positions[i]
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: first_two_diff = positions[j] - positions[i]
- en: low = positions[j] + first_two_diff
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: low = positions[j] + first_two_diff
- en: high = positions[j] + first_two_diff * 2
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: high = positions[j] + first_two_diff * 2
- en: left = j + 1
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: left = j + 1
- en: '❹ while left < n and positions[left] < low:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 当 left < n 且 positions[left] < low 时，执行：
- en: left = left + 1
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: left = left + 1
- en: right = left
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: right = left
- en: '❺ while right < n and positions[right] <= high:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 当 right < n 且 positions[right] <= high 时，执行：
- en: right = right + 1
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: right = right + 1
- en: ❻ total = total + right - left
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ total = total + right - left
- en: output_file.write(str(total) + '\n')
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: output_file.write(str(total) + '\n')
- en: input_file.close()
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: input_file.close()
- en: output_file.close()
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: output_file.close()
- en: '*Listing 9-6: Using sorting*'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-6：使用排序*'
- en: Before we start looking for triples, we sort the positions ❶.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始寻找三元组之前，我们先对 positions 进行排序 ❶。
- en: Our first loop goes through all positions using the loop variable i ❷. It’s
    a range for loop this time, not a for loop, so that we can keep track of which
    index we’re at. That’s useful because we can use the value of i + 1 as the starting
    index for our second loop ❸. The second loop will now never waste time looking
    at positions that are to the left of the first position.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个循环使用循环变量 i 遍历所有位置 ❷。这次是一个范围 `for` 循环，而不是传统的 `for` 循环，这样我们就可以跟踪当前的位置索引。这很有用，因为我们可以将
    i + 1 的值作为第二个循环 ❸ 的起始索引。这样，第二个循环就再也不会浪费时间去查看第一个位置左边的那些位置。
- en: We next calculate the low and high ends of the range of values for our third
    position.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们计算第三个位置的值范围的上下边界。
- en: Rather than increase total by 1 each time we find a suitable third position,
    we can instead find the left and right borders of suitable positions and then
    increase total in one shot. We can only do it this way because the list of positions
    is sorted. We find each of the borders using a while loop. The first while loop
    finds the left border ❹. It keeps going as long as the positions are less than
    low. When it’s done, left will be the leftmost index whose position is greater
    than or equal to low. The second while loop finds the right border ❺. It keeps
    going as long as the positions are less than or equal to high. When it’s done,
    right is the rightmost index whose position is greater than high. Each of the
    positions from left up to but not including right can serve as the third position
    in a triple involving the positions at indices i and j. We add right - left to
    total to account for these positions ❻.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以不再在每次找到合适的第三个位置时将 total 加 1，而是可以找到合适位置的左右边界，然后一次性将 total 增加。我们之所以能这样做，是因为位置列表已经排序。我们通过
    `while` 循环找到每个边界。第一个 `while` 循环找到左边界 ❹。只要位置小于低值，它就会继续进行。完成后，left 就是第一个位置大于或等于低值的索引。第二个
    `while` 循环找到右边界 ❺。只要位置小于等于高值，它就会继续进行。完成后，right 就是第一个位置大于高值的右侧索引。从 left 到 right
    之间（不包括 right）的每个位置都可以作为与 i 和 j 索引位置组成三元组的第三个位置。我们通过将 right - left 加到 total 中来考虑这些位置
    ❻。
- en: 'The two while loops in this program are quite tricky. Let’s make sure we know
    exactly what they’re doing by working through an example. We’ll use the following
    list of positions; they’re the same as those we used in the previous section,
    but sorted:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序中的两个 `while` 循环相当棘手。为了确保我们完全理解它们的工作原理，让我们通过一个示例来进行推演。我们将使用以下位置列表；这些位置与我们在前一部分使用的列表相同，只不过是已排序的：
- en: '[1, 6, 11, 14, 16, 18, 23]'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '[1, 6, 11, 14, 16, 18, 23]'
- en: Suppose that i is 1 and j is 2 so that the two positions in prospective triples
    are 6 and 11. For the third position, we’re therefore looking for positions greater
    than or equal to 16 and less than or equal to 21. The first while loop will set
    left to 4, the leftmost index whose position is greater than or equal to 16. The
    second while loop will set right to 6, the leftmost index whose position is greater
    than 21. Subtracting left from right, we obtain 6 – 4 = 2, which means that there
    are two triples involving positions 6 and 11. Before continuing, I encourage you
    to convince yourself that these while loops work just fine in “special” cases,
    such as when there are no suitable third positions or when there is one suitable
    third position.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 i 是 1，j 是 2，这样预期三元组中的两个位置就是 6 和 11。那么，对于第三个位置，我们寻找的是大于或等于 16 并且小于或等于 21 的位置。第一个
    `while` 循环会将 left 设置为 4，即第一个位置大于或等于 16 的索引。第二个 `while` 循环会将 right 设置为 6，即第一个位置大于
    21 的索引。将 left 从 right 中减去，我们得到 6 - 4 = 2，这意味着有两个三元组包含了位置 6 和 11。在继续之前，我建议你自己验证一下这些
    `while` 循环在“特殊”情况下也能正常工作，比如当没有合适的第三个位置或只有一个合适的第三个位置时。
- en: We’ve made strong progress in this section. Our code here is certainly more
    efficient than the code we gave in [Listing 9-5](ch09.xhtml#ch09ex05). However,
    it still isn’t efficient enough. If you submit to the judge, you’ll see that it
    doesn’t get much further than we got last time. It still times out on most of
    the test cases.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们已经取得了显著进展。我们这里的代码显然比我们在[列表 9-5](ch09.xhtml#ch09ex05)中给出的代码更高效。然而，它仍然不够高效。如果你提交给评测系统，你会看到它并没有比我们上次得到的结果好多少。它仍然会在大部分测试用例中超时。
- en: Efficiency of Our Program
  id: totrans-355
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 我们程序的效率
- en: The problem with our program is that finding the third position can still take
    a long time. Those while loops still have some inefficiency. I can demonstrate
    this with a new list of positions, namely, the positions from 1 to 32.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 我们程序的问题在于，找到第三个位置仍然可能需要很长时间。这些 `while` 循环仍然存在一些低效之处。我可以用一个新的位置列表来演示这一点，具体来说，就是从
    1 到 32 的位置。
- en: '[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,'
- en: 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32]
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32]
- en: Let’s focus on when i is 0 and j is 7; these are the positions 1 and 8. For
    the third position, we’re looking for positions that are greater than or equal
    to 15 and less than or equal to 22\. To find the 15, the first while loop scans
    to the right, one position at a time. It scans the 9, then the 10, then the 11,
    then the 12, then the 13, then the 14, and finally the 15. Then the second while
    loop takes over, doing a similarly large amount of scanning, one position at a
    time, all the way until it finds the 23.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们专注于当 i 为 0 且 j 为 7 时，这些是位置 1 和 8。对于第三个位置，我们寻找的是大于或等于 15 且小于或等于 22 的位置。为了找到
    15，第一个 while 循环从右向左逐个位置扫描。它扫描 9，然后是 10，再是 11，再是 12，再是 13，再是 14，最后是 15。然后第二个 while
    循环接管，逐个位置扫描，直到找到 23。
- en: Each while loop implements what’s known as a *linear search*. A linear search
    is a technique that searches through a collection one value at a time. It’s a
    lot of work, scanning through all those values! And there are many other values
    of i and j that lead to a similar amount of work. For example, try tracing what
    happens when i is 0 and j is 8, or when i is 1 and j is 11.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 while 循环实现了所谓的*线性搜索*。线性搜索是一种逐个搜索集合中每个值的技术。这是一个繁琐的过程，需要扫描所有这些值！并且有很多其他的 i
    和 j 值也会导致类似的工作量。例如，试着追踪当 i 为 0 且 j 为 8，或者当 i 为 1 且 j 为 11 时会发生什么。
- en: How can we improve on this? How can we avoid scanning through a huge chunk of
    the list, looking for the appropriate left and right indices?
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何改进这个方法呢？我们如何避免扫描整个列表，寻找合适的左索引和右索引？
- en: Suppose I give you a book with a thousand sorted integers, one integer per line.
    I ask you to find me the first integer that’s greater or equal to 300\. Are you
    going to look through the numbers one by one? Are you going to look at the 1,
    then the 3, then the 4, then the 7? Still a long way to go—will you look at the
    8, then the 12, then the 17? Probably not! It’d be much faster if you just flipped
    to the middle of the book. Maybe you find number 450 there. Since 450 is greater
    than 300, now you know that the number is in the first half of the book. It can’t
    be in the second half, because those numbers are even bigger than 450\. You’ve
    reduced your work by half by checking only one number! You can now repeat this
    process on the first half of the book, flipping halfway between the beginning
    and middle of the book. You might find the number 200 there. Now you know that
    the 300 is on a later page, somewhere in the second quarter of the book. You can
    repeat this process until you find 300—and it won’t take long at all. This technique—repeatedly
    dividing the problem in half—is known as *binary search*. It’s shockingly fast.
    It blows away the linear search technique of searching one by one. Python has
    a binary search function that will put the finishing touches on Cow Baseball.
    That function, though, is inside of something called a *module*; we’ll need to
    discuss them first.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我给你一本书，里面有一千个已排序的整数，每行一个整数。我让你找到第一个大于或等于 300 的整数。你会一个一个地查看这些数字吗？你会先看 1，然后是
    3，再是 4，接着是 7？还是说你会直接翻到书的中间？可能更快！也许你在那里找到数字 450。由于 450 大于 300，你现在知道这个数字位于书的前半部分。它不可能在后半部分，因为后半部分的数字都比
    450 还大。通过只检查一个数字，你就将工作量减少了一半！现在，你可以在书的前半部分重复这个过程，翻到书的开始和中间之间的一半。你可能会在那里找到数字 200。现在你知道
    300 在后面的某个位置，位于书的四分之一部分。你可以重复这个过程，直到找到 300——而且很快就能找到。这种技术——反复将问题一分为二——称为*二分查找*。它非常迅速。它彻底击败了逐个搜索的线性搜索技术。Python
    提供了一个二分查找函数，它将为 Cow Baseball 做最后的修饰。但是，这个函数在一个叫做*模块*的东西里面；我们需要先讨论它们。
- en: Python Modules
  id: totrans-363
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python 模块
- en: A *module* is a self-contained collection of Python code. A module generally
    contains several functions that we can call.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '*模块*是一个自包含的 Python 代码集合。一个模块通常包含多个函数，我们可以调用这些函数。'
- en: Python comes with a variety of modules that we can use to add functionality
    to our programs. There are modules for working with random numbers, dates and
    times, statistics, emails, web pages, audio files, and much more. It would take
    a separate book to cover them all! There are even modules that you can download
    should Python not come with the module that you need.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: Python附带了各种各样的模块，我们可以用来为程序添加功能。有用于处理随机数、日期和时间、统计数据、电子邮件、网页、音频文件等等的模块。要覆盖所有这些内容，可能需要一本单独的书！如果Python没有提供你需要的模块，甚至还有可以下载的模块。
- en: I’ll focus in this section on one module—the random module. We’ll use it to
    learn what we need to know about modules. Then we’ll be all set for the binary
    search module in the next section.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 本节我将重点介绍一个模块——random模块。我们将用它来学习模块的相关知识。接下来，我们就可以为下一节的二分查找模块做好准备。
- en: Have you ever wondered how people make computer games where things happen at
    random? Maybe it’s a game where you draw cards, where you roll dice, or where
    enemies spawn unpredictably. The key is the use of random numbers. Python gives
    us access to random-number generation through its random module.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否曾经想过人们是如何制作那些让事情随机发生的电脑游戏的？也许是一个抽卡的游戏，一个掷骰子的游戏，或者是敌人不可预测地生成的游戏。关键在于使用随机数。Python通过其random模块为我们提供了生成随机数的功能。
- en: 'Before we can use what’s in a module, we must *import* it. One way to do this
    is to import the entire module using the import keyword, like this:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用模块中的内容之前，我们必须先*导入*它。一个方法是使用import关键字导入整个模块，如下所示：
- en: '>>> import random'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> import random'
- en: 'What’s in there? To find out, you can use dir(random):'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 那里面有什么？为了找出答案，你可以使用dir(random)：
- en: '>>> dir(random)'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> dir(random)'
- en: '[stuff to ignore'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '[忽略的内容'
- en: '''betavariate'', ''choice'', ''choices'', ''expovariate'','
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '''betavariate'', ''choice'', ''choices'', ''expovariate'','
- en: '''gammavariate'', ''gauss'', ''getrandbits'', ''getstate'','
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '''gammavariate'', ''gauss'', ''getrandbits'', ''getstate'','
- en: '''lognormvariate'', ''normalvariate'', ''paretovariate'','
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '''lognormvariate'', ''normalvariate'', ''paretovariate'','
- en: '''randint'', ''random'', ''randrange'', ''sample'', ''seed'','
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '''randint'', ''random'', ''randrange'', ''sample'', ''seed'','
- en: '''setstate'', ''shuffle'', ''triangular'', ''uniform'','
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '''setstate'', ''shuffle'', ''triangular'', ''uniform'','
- en: '''vonmisesvariate'', ''weibullvariate'']'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '''vonmisesvariate'', ''weibullvariate'']'
- en: One function that’s offered by the random module is randint. We pass it the
    low and high ends of a range, and Python gives us a random integer in the range
    (including both endpoints).
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: random模块提供的一个函数是randint。我们传入一个范围的下限和上限，Python会返回该范围内的一个随机整数（包括两个端点）。
- en: 'We can’t just call it like a regular function, though. If we try, we get an
    error:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们不能像调用普通函数一样直接调用它。如果尝试这样做，我们会得到一个错误：
- en: '>>> randint(2, 10)'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> randint(2, 10)'
- en: 'Traceback (most recent call last):'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 最近的调用栈（追踪）：
- en: File "<stdin>", line 1, in <module>
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 "<stdin>"，第 1 行，在 <module> 中
- en: 'NameError: name ''randint'' is not defined'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 'NameError: name ''randint'' is not defined'
- en: 'We need to tell Python that the randint function is housed in the random module.
    To do that, we prefix randint with the name of the module and a dot, like this:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要告诉Python，randint函数位于random模块中。为此，我们需要在randint前加上模块名和一个点，如下所示：
- en: '>>> random.randint(2, 10)'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> random.randint(2, 10)'
- en: '7'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '7'
- en: '>>> random.randint(2, 10)'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> random.randint(2, 10)'
- en: '10'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '10'
- en: '>>> random.randint(2, 10)'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> random.randint(2, 10)'
- en: '6'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: 'To get help on the randint function, you can type help(random.randint):'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取randint函数的帮助，你可以输入help(random.randint)：
- en: '>>> help(random.randint)'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> help(random.randint)'
- en: 'Help on method randint in module random:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 获取模块random中方法randint的帮助：
- en: randint(a, b) method of random.Random instance
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: randint(a, b) 方法来自random.Random实例
- en: Return random integer in range [a, b], including both end points.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 返回范围[a, b]内的随机整数，包括两个端点。
- en: 'Another useful function in the random module is choice. We pass it a sequence,
    and it returns one of its values at random:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: random模块中的另一个有用函数是choice。我们传入一个序列，它会随机返回其中的一个值：
- en: '>>> random.choice([''win'', ''lose''])'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> random.choice([''win'', ''lose''])'
- en: '''lose'''
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '''lose'''
- en: '>>> random.choice([''win'', ''lose''])'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> random.choice([''win'', ''lose''])'
- en: '''lose'''
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '''lose'''
- en: '>>> random.choice([''win'', ''lose''])'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> random.choice([''win'', ''lose''])'
- en: '''win'''
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '''win'''
- en: 'If we frequently use a small number of functions from a module, it can be tedious
    to type the module name and a dot each time. There’s another way to import these
    functions that lets us call them like any other nonmodule function. Here’s how
    we can import only the randint function:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们经常使用模块中的少数几个函数，每次都输入模块名和点号会变得很麻烦。还有另一种导入这些函数的方法，可以让我们像调用其他非模块函数一样调用它们。下面是如何仅导入randint函数的方式：
- en: '>>> from random import randint'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> from random import randint'
- en: 'Now we can call randint without the random. in front:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以直接调用randint，而无需在前面加上random.：
- en: '>>> randint(2, 10)'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> randint(2, 10)'
- en: '10'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '10'
- en: 'If we need randint and choice, we can import them both:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要randint和choice，可以同时导入它们：
- en: '>>> from random import randint, choice'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> from random import randint, choice'
- en: We won’t do so in this book, but we can create our own modules containing whatever
    functions we like. For example, if we designed a few Python functions related
    to playing a game, we could place them all in a file named *game_functions.py*.
    We could then import that module using import game_functions and then access the
    functions within.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中我们不会这样做，但我们可以创建自己的模块，包含我们喜欢的任何函数。例如，如果我们设计了一些与玩游戏相关的Python函数，我们可以将它们全部放在一个名为*game_functions.py*的文件中。然后，我们可以使用`import
    game_functions`导入该模块，之后访问其中的函数。
- en: 'The Python programs we’ve written in this book are not designed to be imported
    as modules. The reason is that they all read input as soon as they start running.
    A module shouldn’t do that. Rather, a module should wait for its functions to
    be called before it does anything. The random module is an example of a well-behaved
    module: it only starts giving us random things when we ask for them.'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中我们编写的Python程序并不打算作为模块导入。原因是它们一开始就会读取输入。而模块不应该这样做。模块应该等待其函数被调用后才执行任何操作。random模块就是一个行为良好的模块：只有当我们请求它时，它才开始给我们提供随机的内容。
- en: The bisect Module
  id: totrans-413
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: bisect模块
- en: 'Now we’re ready to play around with binary search. In [Listing 9-6](ch09.xhtml#ch09ex06),
    we had two while loops. They’re slow, so we want to get rid of them. To do that,
    we’re going to replace each one with a call to a binary search function: bisect_left
    for the first while loop and bisect_right for the second.'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备开始尝试二分查找了。在[Listing 9-6](ch09.xhtml#ch09ex06)中，我们有两个while循环。它们运行得很慢，所以我们希望去除它们。为此，我们将用二分查找函数替换每个while循环：第一个while循环使用bisect_left，第二个while循环使用bisect_right。
- en: 'Both of these functions are in the bisect module. Let’s import them:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数都在bisect模块中。我们来导入它们：
- en: '>>> from bisect import bisect_left, bisect_right'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> from bisect import bisect_left, bisect_right'
- en: Let’s first discuss bisect_left. We call it by providing a list sorted from
    smallest to largest and a value x. It returns to us the index of the leftmost
    value in the list that’s greater than or equal to x.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们讨论一下bisect_left。我们通过提供一个从小到大的排序列表和一个值x来调用它。它会返回列表中第一个大于或等于x的值的索引。
- en: 'If the value is in the list, we get the index of its leftmost occurrence:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 如果该值在列表中，我们将得到它最左侧出现的位置的索引：
- en: '>>> bisect_left([10, 50, 80, 80, 100], 10)'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> bisect_left([10, 50, 80, 80, 100], 10)'
- en: '0'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '>>> bisect_left([10, 50, 80, 80, 100], 80)'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> bisect_left([10, 50, 80, 80, 100], 80)'
- en: '2'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: 'If the value isn’t in the list, then we get the index of the first value that’s
    greater:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 如果该值不在列表中，那么返回的是第一个大于该值的元素的索引：
- en: '>>> bisect_left([10, 50, 80, 80, 100], 15)'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> bisect_left([10, 50, 80, 80, 100], 15)'
- en: '1'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '>>> bisect_left([10, 50, 80, 80, 100], 81)'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> bisect_left([10, 50, 80, 80, 100], 81)'
- en: '4'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: 'If we search for something that’s greater than every value in the list, we
    get the list’s length:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们搜索一个比列表中所有值都大的元素，返回的将是列表的长度：
- en: '>>> bisect_left([10, 50, 80, 80, 100], 986)'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> bisect_left([10, 50, 80, 80, 100], 986)'
- en: '5'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: 'Let’s use bisect_left on our list of seven positions from “Sorting First” earlier
    in this chapter. We’ll find the index of the leftmost position that’s greater
    than or equal to 16:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在前面章节中“排序优先”的七个位置列表上使用bisect_left。我们将找到大于或等于16的最左侧位置的索引：
- en: '>>> positions = [1, 6, 11, 14, 16, 18, 23]'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> positions = [1, 6, 11, 14, 16, 18, 23]'
- en: '>>> bisect_left(positions, 16)'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> bisect_left(positions, 16)'
- en: '4'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: 'Perfect: that’s exactly what we need to replace the first while loop in [Listing
    9-6](ch09.xhtml#ch09ex06).'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 完美：这正是我们需要的，能够替换[Listing 9-6](ch09.xhtml#ch09ex06)中第一个while循环的功能。
- en: 'To replace the second while loop, we’ll use bisect_right rather than bisect_left.
    We call bisect_right just as we called bisect_left : with a sorted list and a
    value x. Rather than returning the index of the leftmost value in the list that’s
    *greater than or equal to* x, it returns the index of the leftmost value that’s
    *greater than* x.'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 为了替换第二个while循环，我们将使用bisect_right而不是bisect_left。我们调用bisect_right的方式和调用bisect_left一样：提供一个排序好的列表和一个值x。不同之处在于，bisect_right返回的是第一个大于x的值的索引，而不是大于或等于x的索引。
- en: 'Let’s compare bisect_left and bisect_right. For a value that’s in the list,
    bisect_right returns an index greater than that returned by bisect_left:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们比较一下bisect_left和bisect_right。对于一个在列表中的值，bisect_right返回的索引大于bisect_left返回的索引：
- en: '>>> bisect_left([10, 50, 80, 80, 100], 10)'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> bisect_left([10, 50, 80, 80, 100], 10)'
- en: '0'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '>>> bisect_right([10, 50, 80, 80, 100], 10)'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> bisect_right([10, 50, 80, 80, 100], 10)'
- en: '1'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '>>> bisect_left([10, 50, 80, 80, 100], 80)'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> bisect_left([10, 50, 80, 80, 100], 80)'
- en: '2'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '>>> bisect_right([10, 50, 80, 80, 100], 80)'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> bisect_right([10, 50, 80, 80, 100], 80)'
- en: '4'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: 'For a value that isn’t in the list, bisect_left and bisect_right return the
    same index:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不在列表中的值，`bisect_left` 和 `bisect_right` 返回相同的索引：
- en: '>>> bisect_left([10, 50, 80, 80, 100], 15)'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> bisect_left([10, 50, 80, 80, 100], 15)'
- en: '1'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '>>> bisect_right([10, 50, 80, 80, 100], 15)'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> bisect_right([10, 50, 80, 80, 100], 15)'
- en: '1'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '>>> bisect_left([10, 50, 80, 80, 100], 81)'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> bisect_left([10, 50, 80, 80, 100], 81)'
- en: '4'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: '>>> bisect_right([10, 50, 80, 80, 100], 81)'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> bisect_right([10, 50, 80, 80, 100], 81)'
- en: '4'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: '>>> bisect_left([10, 50, 80, 80, 100], 986)'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> bisect_left([10, 50, 80, 80, 100], 986)'
- en: '5'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: '>>> bisect_right([10, 50, 80, 80, 100], 986)'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> bisect_right([10, 50, 80, 80, 100], 986)'
- en: '5'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: 'Let’s use bisect_right on our list of seven positions from “Sorting First”
    earlier in this chapter. We’ll find the index of the leftmost position that’s
    greater than 21:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在本章前面“排序”部分使用 `bisect_right` 来操作我们七个位置的列表。我们将找到第一个大于 21 的位置的索引：
- en: '>>> positions = [1, 6, 11, 14, 16, 18, 23]'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> positions = [1, 6, 11, 14, 16, 18, 23]'
- en: '>>> bisect_right(positions, 21)'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> bisect_right(positions, 21)'
- en: '6'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: 'There we go: that’s what we can use to replace the second while loop in [Listing
    9-6](ch09.xhtml#ch09ex06).'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样：这就是我们可以用来替换 [列表 9-6](ch09.xhtml#ch09ex06) 中第二个 while 循环的方法。
- en: The stunning speed of binary search is hard to appreciate using these tiny examples.
    Time to get real. We’ll search one million times for the rightmost value in a
    list of length 1000000. Don’t look away when you run this code. You might miss
    it.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 二分查找的惊人速度，用这些小例子很难体现出来。是时候实际操作一下了。我们将搜索一百万次，找到一个长度为 1000000 的列表中最右边的值。运行这段代码时别移开眼睛，你可能会错过它。
- en: '>>> lst = list(range(1, 1000001))'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> lst = list(range(1, 1000001))'
- en: '>>> for i in range(1000000):'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> for i in range(1000000):'
- en: '...     where = bisect_left(lst, 1000000)'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '...     where = bisect_left(lst, 1000000)'
- en: '...'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: On my computer, that takes about a second. You might be wondering what would
    happen if you replaced the binary search with a call to the list index method.
    If you try it, you’ll literally wait hours for the code to run. That’s because
    index, like the in operator, does a linear search through the list. (See “Efficiency
    of Searching a List” in [Chapter 8](ch08.xhtml#ch08) for more on this.) It has
    no guarantee that the list is sorted, so it can’t perform a blazing-fast binary
    search. It has to go through the values one by one, comparing each of them to
    the value we’re searching for. If you have a sorted list and you want to find
    values in it, binary search is unstoppable.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的计算机上，这大约需要一秒钟。你可能会想，如果将二分查找替换为调用列表的 `index` 方法会怎么样。如果你尝试，代码会运行几个小时才完成。因为
    `index` 方法像 `in` 运算符一样，进行的是线性查找。（关于这一点，请参见 [第 8 章](ch08.xhtml#ch08) 中的“查找列表的效率”）它无法保证列表已经排序，因此无法执行快速的二分查找。它必须逐个比较每个值，才能找到我们要搜索的值。如果你有一个排序好的列表，二分查找无敌。
- en: Solving the Problem
  id: totrans-470
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决问题
- en: We’re ready to solve Cow Baseball using binary search. See [Listing 9-7](ch09.xhtml#ch09ex07)
    for the code.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好使用二分查找来解决“牛仔棒球”问题了。见 [列表 9-7](ch09.xhtml#ch09ex07) 了解代码。
- en: ❶ from bisect import bisect_left, bisect_right
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ from bisect import bisect_left, bisect_right
- en: input_file = open('baseball.in', 'r')
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: input_file = open('baseball.in', 'r')
- en: output_file = open('baseball.out', 'w')
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: output_file = open('baseball.out', 'w')
- en: n = int(input_file.readline())
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: n = int(input_file.readline())
- en: positions = []
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: positions = []
- en: 'for i in range(n):'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(n):'
- en: positions.append(int(input_file.readline()))
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: positions.append(int(input_file.readline()))
- en: positions.sort()
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: positions.sort()
- en: total = 0
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: total = 0
- en: 'for i in range(n):'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(n):'
- en: 'for j in range(i + 1, n):'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 'for j in range(i + 1, n):'
- en: first_two_diff = positions[j] - positions[i]
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: first_two_diff = positions[j] - positions[i]
- en: low = positions[j] + first_two_diff
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: low = positions[j] + first_two_diff
- en: high = positions[j] + first_two_diff * 2
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: high = positions[j] + first_two_diff * 2
- en: ❷ left = bisect_left(positions, low)
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ left = bisect_left(positions, low)
- en: ❸ right = bisect_right(positions, high)
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ right = bisect_right(positions, high)
- en: total = total + right - left
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: total = total + right - left
- en: output_file.write(str(total) + '\n')
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: output_file.write(str(total) + '\n')
- en: input_file.close()
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: input_file.close()
- en: output_file.close()
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: output_file.close()
- en: '*Listing 9-7: Using binary search*'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-7：使用二分查找*'
- en: To begin, we import the bisect_left and bisect_right functions from the bisect
    module so that we can call them ❶. The only other difference compared to [Listing
    9-6](ch09.xhtml#ch09ex06) is that we now use bisect_left ❷ and bisect_right ❸
    instead of the while loops.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从 bisect 模块导入 `bisect_left` 和 `bisect_right` 函数，以便可以调用它们 ❶。与 [列表 9-6](ch09.xhtml#ch09ex06)
    相比的唯一不同之处是，现在我们使用 `bisect_left` ❷ 和 `bisect_right` ❸ 代替了 while 循环。
- en: If you submit our code to the judge now, you should pass all test cases within
    the time limit.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在将我们的代码提交给评测系统，应该能在时间限制内通过所有测试用例。
- en: The arc that we followed in this section is typical of that required to solve
    hard problems. We might start with a complete-search solution that is correct
    but, alas, is also too slow, not meeting the judge’s time limits. We then make
    improvements, leading us away from complete search and toward a more refined approach.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这一部分遵循的路径典型地体现了解决难题所需要的过程。我们可能从一个正确但效率过低的完整搜索解决方案开始，这种方案无法满足裁判的时间限制。然后，我们进行改进，逐步摆脱完整搜索，朝着更加精细的解决方案迈进。
- en: '**CONCEPT CHECK**'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念检查**'
- en: 'Suppose we start with [Listing 9-7](ch09.xhtml#ch09ex07) and use bisect_left
    in place of bisect_right. That is, we take this line:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们从[清单 9-7](ch09.xhtml#ch09ex07)开始，并将 bisect_left 替换为 bisect_right。也就是说，我们将这一行：
- en: right = bisect_right(positions, high)
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: right = bisect_right(positions, high)
- en: 'And we change it to the following:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将其修改为以下内容：
- en: right = bisect_left(positions, high)
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: right = bisect_left(positions, high)
- en: Does the program still produce the correct answers?
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 程序是否仍然产生正确的答案？
- en: A. It always produces the correct answer, just as before.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: A. 它总是产生正确答案，就像之前一样。
- en: B. It sometimes produces the correct answer; it depends on the test case.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: B. 它有时能产生正确答案，取决于测试用例。
- en: C. It never produces the correct answer.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: C. 它从未产生正确答案。
- en: 'Answer: B. There are test cases for which the modified code does produce the
    correct answer. Here’s one:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：B。有些测试用例修改后的代码确实能产生正确答案。以下是一个例子：
- en: '3'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: '2'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '4'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: '9'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: '9'
- en: The correct answer is 0, and that’s what our program produces.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 正确答案是 0，这也是我们的程序所产生的结果。
- en: 'Be careful, though, because there are other test cases for which the modified
    code produces the wrong answer. Here’s one:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 不过要小心，因为也有其他测试用例，修改后的代码会产生错误答案。这里有一个例子：
- en: '3'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: '2'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '4'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: '8'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: '8'
- en: The correct answer is 1, but our program produces 0. When i is 0 and j is 1,
    the program is supposed to set left to 2 and set right to 3. Unfortunately, using
    bisect_left causes right to be set to 2, because the position at index 2 is the
    leftmost position that’s greater than or equal to 8.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 正确答案是 1，但我们的程序产生了 0。当 i 为 0 且 j 为 1 时，程序应当将 left 设置为 2，将 right 设置为 3。不幸的是，使用
    bisect_left 会导致 right 被设置为 2，因为索引 2 位置是大于或等于 8 的最左位置。
- en: Given this counterexample, you might be surprised to know that there *is* a
    way to use bisect_left rather than bisect_right. To do it, we need to alter what
    we search for in the call to bisect_left. If you’re curious, give it a try!
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这个反例，你可能会惊讶地发现，*确实*有一种方法可以使用 bisect_left 替代 bisect_right。为了做到这一点，我们需要修改 bisect_left
    调用中搜索的内容。如果你感兴趣，可以试试看！
- en: Summary
  id: totrans-518
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned about complete-search algorithms, algorithms that
    search through all options to find the best one. To determine the lifeguard that
    we should fire, we try firing each lifeguard and choose the best one. To determine
    the minimum cost to fix ski hills, we try all valid ranges and choose the best
    one. To determine the number of relevant triples of cows, we check each triple
    and add the ones that meet the requirements.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了完整搜索算法，这是一种通过搜索所有选项来找到最佳方案的算法。为了确定我们应该解雇哪个救生员，我们尝试解雇每个救生员并选择最佳的一个。为了确定修复滑雪山丘的最小成本，我们尝试所有有效的范围并选择最好的一个。为了确定相关的牛三元组数量，我们检查每个三元组，并将符合要求的三元组添加到结果中。
- en: Sometimes, complete-search algorithms are efficient enough as they are. We solved
    the Lifeguards and Ski Hills problems with unadorned complete-search code. Other
    times, however, we’ll need to make our complete-search algorithm more efficient.
    We did that when solving Cow Baseball by replacing complete-search while loops
    by much faster binary searches.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，完整搜索算法本身就足够高效。我们用简单的完整搜索代码解决了“救生员”和“滑雪山丘”问题。然而，在其他情况下，我们需要提高完整搜索算法的效率。我们在解决“牛棒球”问题时就是这样，通过用更快速的二分查找替代完整搜索的
    while 循环来提高效率。
- en: How do programmers and computer scientists discuss efficiency? How do you know
    whether an algorithm is going to be efficient enough? And can you avoid implementing
    algorithms that are simply too slow? [Chapter 10](ch10.xhtml#ch10) awaits.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员和计算机科学家如何讨论算法的效率？你如何知道一个算法是否足够高效？你能避免实现那些太慢的算法吗？[第10章](ch10.xhtml#ch10)将为你揭晓答案。
- en: Chapter Exercises
  id: totrans-522
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 章节练习
- en: Here are some exercises for you to try. For each, use complete search. If your
    solution is not efficient enough, think about how you can make it more efficient
    while still producing the right answer.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些练习供你尝试。对于每一个，使用完整搜索。如果你的解决方案效率不够高，想想如何在保持正确答案的前提下提高效率。
- en: 'For each exercise, double-check the judge that the problem comes from: some
    are on the DMOJ judge, while others are on the USACO judge.'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个练习，请仔细检查问题的来源判定器：有些问题来自DMOJ判定器，有些来自USACO判定器。
- en: USACO 2019 January Bronze Contest problem Shell Game
  id: totrans-525
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: USACO 2019年1月铜奖竞赛问题《壳游戏》
- en: USACO 2016 US Open Bronze Contest problem Diamond Collector
  id: totrans-526
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: USACO 2016年美国公开赛铜奖竞赛问题《钻石收藏家》
- en: DMOJ problem coci20c1p1, Patkice
  id: totrans-527
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ问题coci20c1p1，《Patkice》
- en: DMOJ problem ccc09j2, Old Fishin’ Hole
  id: totrans-528
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ问题ccc09j2，《老渔洞》
- en: DMOJ problem ecoo16r1p2, Spindie
  id: totrans-529
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ问题ecoo16r1p2，《Spindie》
- en: DMOJ problem cco96p2, SafeBreaker
  id: totrans-530
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ问题cco96p2，《SafeBreaker》
- en: USACO 2019 December Bronze Contest problem Where Am I
  id: totrans-531
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: USACO 2019年12月铜奖竞赛问题《我在哪里》
- en: USACO 2016 January Bronze Contest problem Angry Cows
  id: totrans-532
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: USACO 2016年1月铜奖竞赛问题《愤怒的奶牛》
- en: USACO 2016 December Silver Contest problem Counting Haybales
  id: totrans-533
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: USACO 2016年12月银奖竞赛问题《数干草堆》
- en: DMOJ problem crci06p3, Firefly
  id: totrans-534
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ问题crci06p3，《萤火虫》
- en: Notes
  id: totrans-535
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释
- en: Lifeguards is originally from the USACO 2018 January Bronze Contest. Ski Hills
    is originally from the USACO 2014 January Bronze Contest. Cow Baseball is originally
    from the USACO 2013 December Bronze Contest.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 《救生员》最初来自USACO 2018年1月铜奖竞赛，《滑雪山丘》最初来自USACO 2014年1月铜奖竞赛，《奶牛棒球》最初来自USACO 2013年12月铜奖竞赛。
- en: There are other types of algorithms beyond complete search, such as *greedy
    algorithms* and *dynamic-programming algorithms*. If a problem cannot be solved
    by complete search, then it’s worth thinking through whether it can be solved
    using one of these other types.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 除了完全搜索算法，还有其他类型的算法，如*贪心算法*和*动态规划算法*。如果一个问题不能通过完全搜索解决，那么值得思考它是否可以通过这些其他类型的算法解决。
- en: If you’re interested in learning more about these and other algorithms topics
    using Python, I recommend *Python Algorithms*, 2nd edition by Magnus Lie Hetland
    (Apress, 2014).
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有兴趣通过Python学习更多算法方面的内容，我推荐Magnus Lie Hetland的《Python算法》（第二版，Apress，2014）。
- en: 'I’ve also written a book about algorithm design: *Algorithmic Thinking: A Problem-Based
    Introduction* (No Starch Press, 2021). It follows the same problem-based format
    as this book; as a result, its style and pacing will be familiar to you. However,
    it uses the C programming language, not the Python programming language, so to
    make the most of it, you’ll want to learn some C beforehand.'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 我还写了一本关于算法设计的书：《算法思维：基于问题的入门》（No Starch Press，2021）。它采用了与本书相同的基于问题的格式，因此，它的风格和节奏对你来说应该很熟悉。然而，它使用的是C编程语言，而不是Python编程语言，所以为了最大化利用这本书，你可能需要提前学习一些C语言。
- en: In this chapter, we called preexisting Python functions to perform binary searches.
    If we like, we can write our own binary-search code instead of relying on those
    functions. The idea of dividing a list in half until we find the value that we
    want is intuitive, but the code to implement this is surprisingly tricky. Equally
    surprising is the vast range of problems that can be solved using variations of
    binary search. My book mentioned earlier, *Algorithmic Thinking*, contains an
    entire chapter on binary search and what it can do.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们调用了预先存在的Python函数来执行二分查找。如果我们愿意，我们也可以编写自己的二分查找代码，而不依赖于这些函数。将列表一分为二，直到找到我们想要的值，这个思路很直观，但实现这段代码却出奇的复杂。同样令人惊讶的是，可以通过二分查找的变体来解决广泛的问题。我之前提到的书《算法思维》中，包含了关于二分查找及其应用的整整一章内容。
