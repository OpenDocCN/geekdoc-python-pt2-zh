- en: '[10](nsp-venkitachalam503045-0008.xhtml#rch10)'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[10](nsp-venkitachalam503045-0008.xhtml#rch10)'
- en: Conway’s Game of Life on a Torus
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 圆环上的康威生命游戏
- en: '![](images/nsp-venkitachalam503045-circle-image.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-circle-image.jpg)'
- en: 'In [Chapter 3](nsp-venkitachalam503045-0015.xhtml#ch03), we implemented Conway’s
    Game of Life using Python and the `matplotlib` library. You may recall one interesting
    aspect of that project: it used toroidal boundary conditions. [Figure 3-2](nsp-venkitachalam503045-0015.xhtml#fig3-2)
    on [page 48](nsp-venkitachalam503045-0015.xhtml#p48) showed how we were effectively
    treating the flat, 2D grid of the simulation as a 3D toroidal surface, thanks
    to how the boundary conditions stitched the edges together. In the [previous chapter](nsp-venkitachalam503045-0023.xhtml#ch09),
    you were introduced to OpenGL and learned how to render 3D objects. Let’s now
    put together your experience with the Game of Life and OpenGL to re-create the
    Conway’s simulation in 3D, on an actual torus.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](nsp-venkitachalam503045-0015.xhtml#ch03)中，我们使用Python和`matplotlib`库实现了康威的生命游戏。你可能还记得那个项目中的一个有趣方面：它使用了环形边界条件。[图3-2](nsp-venkitachalam503045-0015.xhtml#fig3-2)在[第48页](nsp-venkitachalam503045-0015.xhtml#p48)展示了我们如何有效地将平面的2D网格视为一个3D环形表面，这要归功于边界条件如何将边缘连接起来。在[前一章](nsp-venkitachalam503045-0023.xhtml#ch09)，你接触了OpenGL并学会了如何渲染3D对象。现在，让我们将你在生命游戏和OpenGL中的经验结合起来，重新创建康威的3D生命游戏模拟，并展示在实际的圆环上。
- en: In this project, you’ll start by computing the 3D geometry of a torus. Then
    you’ll arrange the vertices of the torus in a way that’s easy to draw and color
    in OpenGL. You’ll set up a revolving camera to view the torus from all sides and
    also implement some basic lighting in the shaders. Finally, you’ll adapt the Game
    of Life code from [Chapter 3](nsp-venkitachalam503045-0015.xhtml#ch03) to color
    the grid on the torus. As the simulation proceeds, you’ll see the Game of Life
    come alive on the surface of the torus!
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本项目中，你将首先计算圆环的3D几何形状。然后，你将以一种易于在OpenGL中绘制和着色的方式排列圆环的顶点。你将设置一个旋转摄像机，从各个角度查看圆环，并在着色器中实现一些基本的光照。最后，你将改编[第3章](nsp-venkitachalam503045-0015.xhtml#ch03)中的生命游戏代码，用来在圆环的网格上进行着色。随着模拟的进行，你将看到生命游戏在圆环表面上“复活”！
- en: 'Here are the main topics covered in this project:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本项目涉及的主要内容：
- en: • Using matrix math to construct the 3D geometry of a torus
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用矩阵运算构建圆环的3D几何形状
- en: • Implementing a coloring scheme for the Game of Life grid on the torus
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 在圆环上实现生命游戏网格的着色方案
- en: • Implementing a revolving camera in OpenGL
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 在OpenGL中实现旋转摄像机
- en: • Implementing simple lighting in OpenGL
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 在OpenGL中实现简单的光照
- en: '[How It Works](nsp-venkitachalam503045-0008.xhtml#rah1201)'
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[工作原理](nsp-venkitachalam503045-0008.xhtml#rah1201)'
- en: Before getting into the code, let’s consider how you can render, light, and
    view a 3D torus using OpenGL. It all begins with computing the vertices that make
    up the torus.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入代码之前，让我们考虑一下如何使用OpenGL渲染、照明和查看一个3D圆环。首先要做的是计算组成圆环的顶点。
- en: '[Computing Vertices](nsp-venkitachalam503045-0008.xhtml#rbh1201)'
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[计算顶点](nsp-venkitachalam503045-0008.xhtml#rbh1201)'
- en: A torus is essentially a collection of circles, or rings, arranged in a circle
    around a central point. However, you can’t actually draw circles with OpenGL;
    they need to be *discretized*, or represented as a series of vertices connected
    by straight lines. The simplified model in [Figure 10-1](nsp-venkitachalam503045-0024.xhtml#fig10-1)
    illustrates how you can begin defining the torus as a collection of vertices.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 圆环本质上是一些圆形或环形的集合，这些圆形按顺序围绕一个中心点排列。然而，在OpenGL中无法直接绘制圆形；它们需要被*离散化*，或者表示为由直线连接的顶点序列。[图10-1](nsp-venkitachalam503045-0024.xhtml#fig10-1)中的简化模型展示了如何将圆环定义为一组顶点。
- en: '![](images/nsp-venkitachalam503045-f10001.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f10001.jpg)'
- en: 'Figure 10-1: A torus rendering model. The simplified torus is on the left.
    An individual “ring” that makes up the torus is on the right.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-1：圆环渲染模型。简化的圆环在左侧，组成圆环的单个“环”在右侧。
- en: The right side of [Figure 10-1](nsp-venkitachalam503045-0024.xhtml#fig10-1)
    shows a ring with radius *r* discretized to have *M* = 5 points. The left side
    of [Figure 10-1](nsp-venkitachalam503045-0024.xhtml#fig10-1) models a simple torus
    with major radius *R* by arranging *N* = 6 such discretized rings (labeled 0 through 5)
    around a central point. (The *major radius* is the distance from the center of
    the torus’s hole to the center of its outer ring.) Don’t worry about the blocky
    nature of the torus shown in the figure. It gets smoother as you increase the
    values of *N* and *M*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[图10-1](nsp-venkitachalam503045-0024.xhtml#fig10-1)的右侧显示了一个半径为*r*的环，并将其离散化为*M*
    = 5个点。图10-1的左侧则展示了一个简单的环面，主半径为*R*，通过将*N* = 6个离散化的环（标记为0到5）围绕一个中心点排列来构建。（*主半径*是环面孔的中心到外环中心的距离。）不要担心图中环面的方块感，随着*N*和*M*值的增加，环面会变得更加平滑。'
- en: The torus is filled out by drawing bands to connect adjacent rings. You’ll draw
    the bands using `GL_TRIANGLE_STRIP` primitives, and each cell in the Game of Life
    simulation will consist of two adjacent triangles on a strip, which together form
    a *quad*, or quadrilateral. When a cell is ON you’ll color its quad black, and
    when a cell is OFF you’ll color it white.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 通过绘制带子连接相邻的环来填充环面。你将使用`GL_TRIANGLE_STRIP`原语来绘制这些带子，并且每个生命游戏模拟中的单元格将由带上的两个相邻三角形组成，这些三角形共同形成一个*四边形*。当单元格为开启状态时，你将其四边形涂成黑色，当单元格为关闭状态时，你将其四边形涂成白色。
- en: To compute the vertices of the torus, you first need to define a coordinate
    system for it. Let’s assume that the torus is on the XY plane, centered at the
    origin, with the line through the center of the torus aligned along the z-axis,
    as shown in [Figure 10-2](nsp-venkitachalam503045-0024.xhtml#fig10-2).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算环面的顶点，你首先需要为其定义一个坐标系。假设环面位于XY平面上，且以原点为中心，穿过环面中心的线与z轴对齐，如[图10-2](nsp-venkitachalam503045-0024.xhtml#fig10-2)所示。
- en: '![](images/nsp-venkitachalam503045-f10002.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f10002.jpg)'
- en: 'Figure 10-2: The rendering strategy for the torus'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-2：环面渲染策略
- en: 'The vertices for a circle *C*[3] on the torus at an angle θ relative to the
    x-axis can be computed as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在与x轴成θ角度的环面上，圆*C*[3]的顶点可以按如下方式计算：
- en: 1\. Compute the vertices for a circle *C*[1] of radius *r* in the XZ plane and
    with the center at the origin.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1\. 计算XZ平面上圆*C*[1]的顶点，该圆的半径为*r*，并且圆心位于原点。
- en: 2\. Rotate the circle *C*[1] around the z-axis by the angle θ. This gives you
    the circle *C*[2].
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将圆*C*[1]围绕z轴旋转θ角度。这会得到圆*C*[2]。
- en: 3\. Translate the circle *C*[2] by *R* amount along the angle θ to get the circle
    *C*[3] in the correct position on the torus.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3\. 将圆*C*[2]沿角度θ方向平移*R*的距离，得到位于环面正确位置的圆*C*[3]。
- en: 'You may recall the use of parametric equations to define a circle in the spirograph
    project in [Chapter 2](nsp-venkitachalam503045-0013.xhtml#ch02). We’re going to
    use the same concept here. The vertices marking the circumference of a circle
    *C*[1] of radius *r* on the XZ plane centered at the origin are given by:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得在[第2章](nsp-venkitachalam503045-0013.xhtml#ch02)的陀螺图形项目中使用参数方程来定义一个圆。在这里我们将使用相同的概念。标记XZ平面上圆*C*[1]（半径为*r*，以原点为中心）周长的顶点由以下公式给出：
- en: '*P* = (*r* cos(α), 0, *r* sin(α))'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*P* = (*r* cos(α), 0, *r* sin(α))'
- en: Here, α is the angle made by the point *P* with respect to the x-axis. As α
    varies from 0 to 360 degrees (or 2π radians), a circle will be formed by the *P* points.
    Notice that the y-coordinates of the points are zero in the previous equation.
    This is expected, since the circle is on the XZ plane.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，α是点*P*与x轴之间的角度。当α从0变化到360度（或2π弧度）时，*P*点将形成一个圆。请注意，在前面的方程中，点的y坐标为零。这是可以预期的，因为圆位于XZ平面上。
- en: 'You must now rotate the points around the z-axis by angle θ. The rotation matrix
    for this operation is given by:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你必须将这些点绕z轴旋转θ角度。此操作的旋转矩阵如下所示：
- en: '![](images/nsp-venkitachalam503045-m10001.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-m10001.jpg)'
- en: Once you rotate the points, you need to translate them to the right place. This
    is done using the following translation matrix. (This format was discussed in
    [Chapter 9](nsp-venkitachalam503045-0023.xhtml#ch09).)
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦旋转了这些点，你需要将它们平移到正确的位置。这是通过以下平移矩阵完成的。（该格式在[第9章](nsp-venkitachalam503045-0023.xhtml#ch09)中有讨论。）
- en: '![](images/nsp-venkitachalam503045-m10002.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-m10002.jpg)'
- en: 'Thus, the transformed points on a ring on the torus are given by:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，环形体上的变换点由以下公式给出：
- en: '*P*ʹ = *T* × *R* [θ,Z] × *P*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*P*ʹ = *T* × *R* [θ,Z] × *P*'
- en: 'which is the same as:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这与以下内容相同：
- en: '![](images/nsp-venkitachalam503045-m10003.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-m10003.jpg)'
- en: In the previous equation, *P* is first multiplied by the rotation matrix, which
    aligns it correctly, and is then multiplied by the translation matrix, which “pushes”
    the points to the right place on the torus. Notice that *P* is represented with
    *homogeneous* coordinates (*x*, *y*, *z*, 1.0), discussed in the [previous chapter](nsp-venkitachalam503045-0023.xhtml#ch09).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的方程中，*P*首先与旋转矩阵相乘，这样它就能正确对齐，然后与平移矩阵相乘，这样“推动”点到达环面上的正确位置。注意，*P*使用*齐次*坐标（*x*，*y*，*z*，1.0）表示，这在[上一章](nsp-venkitachalam503045-0023.xhtml#ch09)中有讨论。
- en: '[Computing Normals for Lighting](nsp-venkitachalam503045-0008.xhtml#rbh1202)'
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[计算光照法向量](nsp-venkitachalam503045-0008.xhtml#rbh1202)'
- en: For the torus to look nice, you’ll need to apply lighting to the geometry, which
    in turn means you’ll need to compute the *normal vectors* for the points *P* calculated
    in the previous section. The lighting on a surface depends on the orientation
    of the surface to the incoming light, and the orientation can be quantified by
    the normal vector, which is the vector perpendicular to the surface at a particular
    point. Take a look at [Figure 10-3](nsp-venkitachalam503045-0024.xhtml#fig10-3)
    to see an example.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让环面看起来更加美观，你需要对几何体应用光照，这意味着你需要计算前一节中计算的点*P*的*法向量*。表面上的光照取决于表面与入射光之间的方向，而方向可以通过法向量来量化，法向量是指在特定点上垂直于表面的向量。请查看[图10-3](nsp-venkitachalam503045-0024.xhtml#fig10-3)以查看示例。
- en: '![](images/nsp-venkitachalam503045-f10003.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f10003.jpg)'
- en: 'Figure 10-3: Computing normal vectors'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-3：计算法向量
- en: 'Because of the geometry of the torus, the normal vector for point *s* on a
    ring is in the same direction as the line connecting point *s* to the center of
    the ring. This means that the normal vectors are the same as rotated points. The
    translation doesn’t matter, as the direction of the normals is unaffected by it.
    You can therefore compute the normals as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 由于环面的几何形状，环上点*s*的法向量与连接点*s*和环中心的线方向相同。这意味着法向量与旋转后的点相同。平移矩阵不影响法向量的方向，因此你可以按如下方式计算法向量：
- en: '*N* = *R*[θ,Z] × *P*'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*N* = *R*[θ,Z] × *P*'
- en: Note that you need to *normalize* the normal vectors before doing any lighting
    computations. You do this by dividing the normal by its magnitude.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你需要在进行任何光照计算之前*归一化*法向量。你可以通过将法向量除以其大小来实现这一点。
- en: The actual lighting will come from a single light source at a fixed position.
    This will be defined in the vertex shader.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的光照将来自一个固定位置的单一光源。光照将在顶点着色器中定义。
- en: '[Rendering](nsp-venkitachalam503045-0008.xhtml#rbh1203)'
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[渲染](nsp-venkitachalam503045-0008.xhtml#rbh1203)'
- en: Now that you have the vertices and normals for the torus, let’s talk about how
    to render it using OpenGL. You first need to split it up into bands, as shown
    in [Figure 10-4](nsp-venkitachalam503045-0024.xhtml#fig10-4). Each band is the
    region between two adjacent rings on the torus.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经拥有了环面的顶点和法向量，接下来我们来讨论如何使用OpenGL渲染它。首先，你需要将环面划分成带状区域，如[图10-4](nsp-venkitachalam503045-0024.xhtml#fig10-4)所示。每个带状区域是两个相邻环之间的区域。
- en: '![](images/nsp-venkitachalam503045-f10004.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f10004.jpg)'
- en: 'Figure 10-4: Rendering the torus with triangle strips'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-4：使用三角带渲染环面
- en: 'Each of the bands is rendered using OpenGL as a `GL_TRIANGLE_STRIP` primitive.
    Besides forming the building blocks of the torus, these triangle strips also provide
    a convenient way to create the Game of Life simulation grid: each cell in the
    grid is represented by a quad formed from two adjacent triangles in the strip.
    [Figure 10-5](nsp-venkitachalam503045-0024.xhtml#fig10-5) gives a closer look
    at one band in the torus.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 每个带状区域都是使用OpenGL的`GL_TRIANGLE_STRIP`原语进行渲染的。除了构成环面的基础构件外，这些三角带还提供了一种方便的方式来创建“生命游戏”模拟网格：网格中的每个单元格由由两个相邻三角形组成的四边形表示。[图10-5](nsp-venkitachalam503045-0024.xhtml#fig10-5)展示了环面中一个带状区域的详细信息。
- en: '![](images/nsp-venkitachalam503045-f10005.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f10005.jpg)'
- en: 'Figure 10-5: Rendering a band from triangle strips'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-5：使用三角带渲染带状区域
- en: 'The band is formed by the adjacent rings *C*⁰ and *C*¹. Each ring has *M* vertices.
    The triangle strip making up the band is formed as *M* pairs of vertices that
    zigzag back and forth between the rings:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 该带状区域由相邻的*C*⁰和*C*¹环组成。每个环有*M*个顶点。构成该带状区域的三角带由*M*对顶点组成，顶点在两个环之间来回交错：
- en: '![](images/nsp-venkitachalam503045-m10004.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-m10004.jpg)'
- en: 'But there’s one additional pair of vertices you need to add: ![](images/nsp-venkitachalam503045-m10005.jpg).
    You need to repeat the first two vertices to close out the gap at the end of the
    band. Hence, the total number of vertices in the triangle strip that forms the
    band is given by 2 × *M* + 2.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 但还有一对额外的顶点需要添加：![](images/nsp-venkitachalam503045-m10005.jpg)。你需要重复前两个顶点来关闭带子末端的间隙。因此，形成该带子的三角形带中的顶点总数为
    2 × *M* + 2。
- en: 'The band shown in [Figure 10-5](nsp-venkitachalam503045-0024.xhtml#fig10-5)
    was composed of rings ![](images/nsp-venkitachalam503045-m10006.jpg). The torus
    is divided into *N* bands, where *N* is the number of rings:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10-5](nsp-venkitachalam503045-0024.xhtml#fig10-5) 中显示的带子是由环 ![](images/nsp-venkitachalam503045-m10006.jpg)
    组成的。圆环被分为 *N* 条带，其中 *N* 是环的数量：'
- en: '![](images/nsp-venkitachalam503045-m10007.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-m10007.jpg)'
- en: Notice how the last band wraps around by coming back to the first ring, *C*⁰.
    This means the total number of vertices needed to render the torus is given by
    *N* × (2 × *M* + 2). You’ll see more details of the implementation as you look
    at the code.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，最后一条带子是如何通过回到第一个环来绕一圈的，*C*⁰。这意味着渲染圆环所需的顶点总数由 *N* × (2 × *M* + 2) 给出。你将在查看代码时看到更多实现的细节。
- en: Now let’s take a look at the coloring scheme for the torus.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下圆环的着色方案。
- en: '[Coloring the Triangle Strips](nsp-venkitachalam503045-0008.xhtml#rbh1204)'
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[给三角形带着色](nsp-venkitachalam503045-0008.xhtml#rbh1204)'
- en: 'You need to color the cells in the Game of Life simulation individually. You
    know that each cell is a quad—two triangles that are part of a larger triangle
    strip. As an example, the quad made of vertices ![](images/nsp-venkitachalam503045-m10008.jpg)
    is composed of two triangles: ![](images/nsp-venkitachalam503045-m10009.jpg) and
    ![](images/nsp-venkitachalam503045-m10010.jpg). Each vertex has a corresponding
    color associated with it, which is a triplet of the form (*r*, *g*, *b*), denoting
    the red, green, and blue components of the color. By default, the color of the
    first vertex in the quad (in this case, ![](images/nsp-venkitachalam503045-m10011.jpg))
    sets the value for the first triangle in the quad, and the color of the second
    vertex (![](images/nsp-venkitachalam503045-m10012.jpg)) sets the value for the
    second triangle in the quad. As long as you set these two colors to be identical,
    you’ll color the quad uniformly. We’ll discuss OpenGL’s vertex color convention
    further when we look at the code.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要单独为《生命游戏》模拟中的每个格子着色。你知道每个格子是一个四边形——由两个三角形组成，属于一个更大的三角形带。例如，顶点组成的四边形 ![](images/nsp-venkitachalam503045-m10008.jpg)
    由两个三角形组成：![](images/nsp-venkitachalam503045-m10009.jpg) 和 ![](images/nsp-venkitachalam503045-m10010.jpg)。每个顶点都有一个对应的颜色，该颜色是一个三元组，形式为
    (*r*, *g*, *b*)，表示红色、绿色和蓝色的分量。默认情况下，四边形中第一个顶点（在这种情况下是 ![](images/nsp-venkitachalam503045-m10011.jpg)）的颜色为四边形中第一个三角形设置颜色，而第二个顶点（![](images/nsp-venkitachalam503045-m10012.jpg)）的颜色为四边形中第二个三角形设置颜色。只要你将这两种颜色设置为相同，你就能均匀地给四边形上色。我们将在查看代码时进一步讨论
    OpenGL 的顶点颜色约定。
- en: NOTE The OpenGL function called `glProvokingVertex()` changes the convention
    of which color value is mapped to the vertex.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，OpenGL 函数 `glProvokingVertex()` 改变了哪一个颜色值被映射到顶点的约定。
- en: '[Controlling the Camera](nsp-venkitachalam503045-0008.xhtml#rbh1205)'
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[控制相机](nsp-venkitachalam503045-0008.xhtml#rbh1205)'
- en: To view the torus, you’ll create a camera that revolves around the origin of
    the 3D scene and looks down at an angle from above. [Figure 10-6](nsp-venkitachalam503045-0024.xhtml#fig10-6)
    shows the camera setup.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看圆环，你需要创建一个围绕 3D 场景原点旋转的相机，并从上方以一定角度俯视。[图 10-6](nsp-venkitachalam503045-0024.xhtml#fig10-6)
    展示了相机的设置。
- en: '![](images/nsp-venkitachalam503045-f10006.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f10006.jpg)'
- en: 'Figure 10-6: Implementing a revolving camera'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-6：实现一个旋转相机
- en: 'Think of the camera, represented by point *E*, as being placed on a cylinder
    of radius *R* at a height *H* from the origin. The camera points toward the origin
    *O*. The camera is defined by the mutually perpendicular vectors *V*, *U*, and
    *N*, where *V* is the *view vector* that points from *E* to *O*; *U* is the *up
    vector*, which is up relative to the camera; and *N* is a vector perpendicular
    to both *V* and *U*. For every time step, you move the camera by a constant distance
    along the rim of the cylinder. This movement is parameterized by the angle β,
    as shown in [Figure 10-6](nsp-venkitachalam503045-0024.xhtml#fig10-6). As you
    learned in [Chapter 9](nsp-venkitachalam503045-0023.xhtml#ch09), you use a `lookAt()`
    method to set up the view, which takes three parameters: the eye, the center,
    and the up vector. The center is just the origin: (0, 0, 0). The 3D coordinates
    of the eye are given by:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 将相机视为点*E*，它被放置在一个半径为*R*，高度为*H*的圆柱体上，朝向原点*O*。相机由相互垂直的向量*V*、*U*和*N*定义，其中*V*是从*E*指向*O*的*视线向量*；*U*是相机的*上向量*；*N*是与*V*和*U*都垂直的向量。每个时间步，你会让相机沿着圆柱体的边缘以恒定的距离移动。这一运动由角度β来参数化，如[图
    10-6](nsp-venkitachalam503045-0024.xhtml#fig10-6)所示。正如你在[第9章](nsp-venkitachalam503045-0023.xhtml#ch09)中学到的，你使用`lookAt()`方法来设置视图，它接受三个参数：眼睛、中心和上向量。中心就是原点：(0,
    0, 0)。眼睛的三维坐标为：
- en: '*E* = (*R* cos(β), *R* sin(β), *H*)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*E* = (*R* cos(β), *R* sin(β), *H*)'
- en: 'As the camera moves along the rim of the cylinder, it will keep its direction
    pointed to *O*, and the up vector *U* will keep changing as well. To compute the
    up vector *U*, start with an initial guess *U*ʹ that’s parallel to the z-axis.
    Then find *N*, the vector perpendicular to the plane given by *U*ʹ and *V*. It
    can be calculated as:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当相机沿着圆柱体的边缘移动时，它会始终朝向*O*，并且上向量*U*也会不断变化。要计算上向量*U*，首先从一个初始猜测*U*ʹ开始，它与z轴平行。然后找到*N*，即垂直于*U*ʹ和*V*所定义平面的向量。可以通过以下方式计算：
- en: '*N* = *V* × *U*ʹ'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*N* = *V* × *U*ʹ'
- en: '*N* is given by the cross product of *V* and *U*ʹ. Now, what happens if you
    take the cross product of *N* and *V*? You get a vector perpendicular to the NV
    plane, which is the up vector *U* that you’re looking for!'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*N*由*V*和*U*ʹ的叉积给出。那么，如果你将*N*和*V*进行叉积，会发生什么呢？你将得到一个垂直于NV平面的向量，也就是你要找的上向量*U*！'
- en: '*U* = *N* × *V* = (*V* × *U*ʹ) × *V*'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*U* = *N* × *V* = (*V* × *U*ʹ) × *V*'
- en: 'Once *U* is calculated, make sure that it’s normalized before use. Once that’s
    done, you’ll have everything you need to set up the camera with `lookAt()`: *E*
    (the eye), *O* (the center), and *U* (the up vector).'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦计算出*U*，请确保在使用之前将其标准化。完成后，你就可以用`lookAt()`方法来设置相机：*E*（眼睛）、*O*（中心）和*U*（上向量）。
- en: '[Mapping the Grid to the Torus](nsp-venkitachalam503045-0008.xhtml#rbh1206)'
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[将网格映射到环面](nsp-venkitachalam503045-0008.xhtml#rbh1206)'
- en: Finally, let’s look at how the 2D Game of Life simulation grid maps to the 3D
    torus because of the grid’s toroidal boundary conditions. [Figure 10-7](nsp-venkitachalam503045-0024.xhtml#fig10-7)
    shows the mapping.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看二维生命游戏的模拟网格是如何映射到三维环面上的，因为该网格具有环形边界条件。[图 10-7](nsp-venkitachalam503045-0024.xhtml#fig10-7)展示了这一映射。
- en: '![](images/nsp-venkitachalam503045-f10007.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f10007.jpg)'
- en: 'Figure 10-7: Mapping the simulation grid to a torus'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-7：将模拟网格映射到环面
- en: 'The two-dimensional Game of Life grid has *NX* columns and *NY* rows. You can
    see on the right of the figure how the *NX* points that divide each row wrap around
    the tube of the torus. The point indices go from 0 to *NX* − 1\. The next index,
    *NX*, is the same as 0 because of the wrap. A similar wrap happens in the y-direction,
    where you have *NY* cells: the point with index *NY* is the same as the point
    with index 0.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 二维生命游戏网格有*NX*列和*NY*行。你可以在图的右侧看到，划分每一行的*NX*个点是如何绕着环面圆柱体的管道展开的。点的索引从0到*NX* − 1。下一个索引*NX*与0相同，因为存在绕回。y方向也会发生类似的绕回，你有*NY*个单元格：索引为*NY*的点与索引为0的点相同。
- en: You saw earlier how each ring in the torus is discretized to have *M* points.
    To go from the two-dimensional grid to the torus, set *NX* = *M*. Similarly, set
    *NY* = *N*, where *N* is the number of bands on the torus.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你之前已经看到，每个环面环的离散化包含了*M*个点。为了将二维网格映射到环面，设置*NX* = *M*。类似地，设置*NY* = *N*，其中*N*是环面上的带数。
- en: '[Requirements](nsp-venkitachalam503045-0008.xhtml#rah1202)'
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[需求](nsp-venkitachalam503045-0008.xhtml#rah1202)'
- en: We’ll use `PyOpenGL` and GLFW for OpenGL rendering, as in [Chapter 9](nsp-venkitachalam503045-0023.xhtml#ch09),
    and `numpy` for matrix/vector computations.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`PyOpenGL`和GLFW进行OpenGL渲染，正如在[第9章](nsp-venkitachalam503045-0023.xhtml#ch09)中所示，并使用`numpy`进行矩阵/向量计算。
- en: '[The Code](nsp-venkitachalam503045-0008.xhtml#rah1203)'
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[代码](nsp-venkitachalam503045-0008.xhtml#rah1203)'
- en: 'The code for this project is organized into several files:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目的代码分为多个文件：
- en: torus.py This contains the geometry computation and rendering code for the torus.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: torus.py 这个文件包含了环面几何计算和渲染代码。
- en: gol.py This implements Conway’s Game of Life, adapted from [Chapter 3](nsp-venkitachalam503045-0015.xhtml#ch03).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: gol.py 这个文件实现了康威的生命游戏，改编自[第3章](nsp-venkitachalam503045-0015.xhtml#ch03)。
- en: camera.py This contains the implementation for the revolving camera for viewing
    the torus.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: camera.py 这个文件包含了旋转相机的实现，用于查看环面。
- en: gol_torus.py This is the main file that sets up OpenGL and GLFW and calls the
    rendering code from other modules.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: gol_torus.py 这是主文件，用于设置OpenGL和GLFW，并调用其他模块中的渲染代码。
- en: The full project code is available online at [https://github.com/mkvenkit/pp2e/blob/main/gol_torus](https://github.com/mkvenkit/pp2e/blob/main/gol_torus).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的项目代码可以在线访问，链接：[https://github.com/mkvenkit/pp2e/blob/main/gol_torus](https://github.com/mkvenkit/pp2e/blob/main/gol_torus)。
- en: '[Rendering the Torus](nsp-venkitachalam503045-0008.xhtml#rbh1207)'
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[渲染环面](nsp-venkitachalam503045-0008.xhtml#rbh1207)'
- en: We’ll first consider the code for rendering the torus, which is encapsulated
    in a class called `Torus` defined in the file *torus.py*. To see the complete
    code listing, skip ahead to [“The Complete Torus Rendering Code”](nsp-venkitachalam503045-0024.xhtml#ah1207)
    on [page 203](nsp-venkitachalam503045-0024.xhtml#p203).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先考虑渲染环面的代码，它封装在一个名为`Torus`的类中，定义在文件*torus.py*中。要查看完整的代码列表，请跳转到[“完整的环面渲染代码”](nsp-venkitachalam503045-0024.xhtml#ah1207)，见[第203页](nsp-venkitachalam503045-0024.xhtml#p203)。
- en: Defining the Shaders
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 定义着色器
- en: 'First, define the GLSL shaders for the torus. Here’s the vertex shader, which
    takes the per-vertex attributes of position, color, and normal and computes the
    transformed inputs for the fragment shader:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，定义环面的GLSL着色器。以下是顶点着色器，它获取每个顶点的属性（位置、颜色、法线）并计算传递给片段着色器的变换输入：
- en: '[PRE0]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You define the vertex shader code as a string stored in `strVS`. The attribute
    variables for the shader are `aVert`, `aColor`, and `aNormal`, representing the
    coordinates, color, and normal vector for each vertex. Notice the `flat` qualifier
    when you initialize `vColor`, one of the outputs of the vertex shader ❶, indicating
    that this variable won’t be interpolated in the fragment shader. In effect, we’re
    saying that this variable will remain constant across the primitive (one of the
    triangles in a triangle strip). This ensures that every Game of Life cell will
    be a single color. This type of shading across a primitive is called *flat shading*.
    The next vertex shader output is `vNormal` ❷, which by default will be interpolated
    in the fragment shader. You need this so you can compute lighting across a primitive,
    but later you’ll see how to modify this shader code to support flat shading. The
    other output is called `fragPos` ❸. In the main shader code, you set this output
    to `aVert` ❹ so it can be passed into the fragment shader for lighting calculations.
    The shader also computes `gl_Position` and passes to the fragment shader the color
    and normal data as it is received.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你将顶点着色器代码定义为一个存储在`strVS`中的字符串。着色器的属性变量有`aVert`、`aColor`和`aNormal`，分别表示每个顶点的坐标、颜色和法向量。注意在初始化`vColor`时使用了`flat`限定符，❶
    表示该变量在片段着色器中不会进行插值。实际上，我们是在说这个变量将在整个图元（一个三角形带中的三角形之一）上保持不变。这确保了每个“生命游戏”单元格将呈现单一颜色。这种类型的图元着色被称为*平面着色*。接下来的顶点着色器输出是`vNormal`
    ❷，默认情况下它将在片段着色器中进行插值。你需要这个输出，以便计算图元上的光照，但稍后你将看到如何修改这个着色器代码来支持平面着色。另一个输出叫做`fragPos`
    ❸。在主着色器代码中，你将这个输出设置为`aVert` ❹，以便将其传递到片段着色器进行光照计算。着色器还计算`gl_Position`，并将接收到的颜色和法线数据传递给片段着色器。
- en: Here’s the fragment shader, which applies lighting and computes the final color
    of the fragment. It’s defined as another string, called `strFS`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这是片段着色器，应用光照并计算片段的最终颜色。它作为另一个字符串定义，叫做`strFS`。
- en: '[PRE1]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice that the color, normal, and fragment position variables, which were outputs
    from the vertex shader, are now inputs to the fragment shader. In the main shader
    code, you define the position ❶ and color ❷ for a light source. Then you compute
    the light direction ❸. The resulting color ❹ is a mix of ambient and diffuse components
    of the light and is set as the output from the fragment shader.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，颜色、法线和片段位置变量，这些是顶点着色器的输出，现在作为片段着色器的输入。在主着色器代码中，你定义了光源的位置❶和颜色❷。接着你计算了光源的方向❸。最终的颜色❹是环境光和漫反射光的混合，并作为片段着色器的输出。
- en: Keep in mind that `fragPos` and `vNormal` are computed for each fragment via
    interpolation, whereas `vColor` is constant for a given primitive. The net effect
    is that the intrinsic color of a primitive (a triangle strip, in this case) remains
    constant, while the perceived color varies across the primitive based on its orientation
    with respect to the light source. This is exactly what you need to set each Game
    of Life cell to a solid color, while varying that color to create the appearance
    of lighting.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`fragPos`和`vNormal`是通过插值为每个片段计算的，而`vColor`对于给定的原语是常量。其净效果是，原语（在此情况下是三角形条带）的内在颜色保持不变，而感知到的颜色则根据原语相对于光源的朝向而变化。这正是你需要的效果，可以让每个生命游戏单元显示为固色，同时通过改变颜色来创建光照效果。
- en: Initializing the Torus Class
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 初始化Torus类
- en: 'Now let’s look at the initialization code in the `Torus` class constructor:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下`Torus`类构造函数中的初始化代码：
- en: '[PRE2]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `Torus` class has the following parameters in its constructor ❶: the radius
    `R` of the outer ring of the torus, the radius `r` of the torus tube, and `NX`
    and `NY` for the number of Game of Life simulation cells in the x- and y-directions.
    The constructor’s first order of business is to load the shaders. You use the
    `loadShaders()` method ❷ defined in the common *glutils.py* file. In the subsequent
    lines, you store the variables passed into the `Torus` constructor in instance
    variables such as `self.R` so they can be accessed later from other methods. Then
    you set `N`, the number of points on the outer circle of the torus, to be `NX`,
    the number of cells in the x-direction ❸. You similarly set `M`, the number of
    points along the smaller radius `r` of the torus, to `NY`. This scheme is discussed
    in the [“Mapping the Grid to the Torus”](nsp-venkitachalam503045-0024.xhtml#bh1206)
    section.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`Torus`类在其构造函数❶中包含以下参数：外环的半径`R`、圆环管道的半径`r`，以及`NX`和`NY`，分别表示生命游戏模拟单元在x和y方向上的数量。构造函数的首要任务是加载着色器。你使用在公共*glutils.py*文件中定义的`loadShaders()`方法❷。在接下来的几行代码中，你将传递给`Torus`构造函数的变量存储在实例变量中，例如`self.R`，以便可以在其他方法中访问。然后，你将外环圆上的点数`N`设置为`NX`，即x方向上的单元数❸。同样，你将圆环较小半径`r`上的点数`M`设置为`NY`。这个方案在[“将网格映射到圆环”](nsp-venkitachalam503045-0024.xhtml#bh1206)部分中进行了讨论。'
- en: Next, you do some additional preparation for rendering the triangle strips that
    will form the bands along the outer ring of the torus. You’ll eventually be using
    the `glMultiDrawArrays()` OpenGL method to render all the triangle strips at once.
    This method is an efficient way to draw multiple triangle strip primitives using
    just one function call. As you saw in the [“Rendering”](nsp-venkitachalam503045-0024.xhtml#bh1203)
    section, each triangle strip has 2*M* + 2 vertices, and you have *N* of these
    strips. So, the starting indices for these triangle strips will be [0, (2*M* +
    2), (2*M* + 2) × 2, . . . , (2*M* + 2) × *N*]. Accordingly, you set `first_indices`
    and `counts` ❹, which will be required parameters when you call `glMultiDrawArrays()`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要做一些额外的准备工作，以渲染将形成圆环外缘带状三角形条带的几何图形。你最终将使用`glMultiDrawArrays()` OpenGL方法一次性渲染所有三角形条带。该方法是一种高效的方式，允许你通过一次函数调用绘制多个三角形条带原语。如在[“渲染”](nsp-venkitachalam503045-0024.xhtml#bh1203)部分所述，每个三角形条带有2*M*
    + 2个顶点，而你有*N*个这样的条带。因此，这些三角形条带的起始索引将是[0, (2*M* + 2), (2*M* + 2) × 2, . . . , (2*M*
    + 2) × *N*]。因此，你设置了`first_indices`和`counts`❹，它们将是调用`glMultiDrawArrays()`时需要的参数。
- en: The `init_colors()` method ❺ initializes `color_dict`, which maps each grid
    cell to a color—black or white. We’ll look at the details of the `init_colors()`
    method soon. You initialize the `numpy` array `colors` to zeros ❻. You’ll later
    populate this array with the correct values. You conclude the constructor by computing
    the vertices and normals for the torus ❼, as well as the colors ❽, and by setting
    up the vertex array object (VAO) for rendering the torus ❾.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`init_colors()`方法❺初始化了`color_dict`，它将每个网格单元映射到一个颜色——黑色或白色。我们很快会详细讲解`init_colors()`方法的内容。你将`numpy`数组`colors`初始化为零❻。稍后，你会将正确的值填充到这个数组中。你通过计算圆环的顶点和法线❼，以及颜色❽，并设置顶点数组对象（VAO）来渲染圆环❾，来结束构造函数。'
- en: 'Now let’s look at the `Torus` class’s `init_colors()` method that was just
    mentioned:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下刚刚提到的`Torus`类中的`init_colors()`方法：
- en: '[PRE3]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `init_colors()` method creates a dictionary called `colors` mapping from
    simulation cell index (*i*, *j*) to the color that should be applied to the cell.
    To begin, you simply set all the cell color values to `c1`, which is just plain
    white ❶. As the Game of Life simulation unfolds, the values in this dictionary
    will be updated to turn cells on and off.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`init_colors()`方法创建了一个名为`colors`的字典，映射从仿真单元索引（*i*, *j*）到应应用于该单元的颜色。首先，你将所有单元的颜色值设置为`c1`，即纯白色❶。随着生命游戏仿真进展，字典中的值将被更新，以开启或关闭单元格。'
- en: Calculating the Vertices
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 计算顶点
- en: 'The next few methods we’ll consider work together to compute all the torus
    vertices. We begin with the `compute_vertices()` method:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来几个方法将一起工作，用来计算所有圆环的顶点。我们从`compute_vertices()`方法开始：
- en: '[PRE4]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `compute_vertices()` method begins by creating empty lists to store the
    vertices and normals. Then you compute the vertices and normals for the torus,
    using a nested loop to implement the strategy we discussed in the [“Rendering”](nsp-venkitachalam503045-0024.xhtml#bh1203)
    section. The outer loop iterates over the `N` rings that make up the torus. The
    inner loop iterates over the `M` points on each of those rings. Within the loops,
    you first compute the angle `theta` subtended by a point on the ring with index
    `j` ❶. You use `j % M` and have the inner loop iterate over range `[0, M+1)` so
    that when *j* is equal to `M`, `(j % M)` rolls back to `0`. This is to complete
    the last segment of the ring.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`compute_vertices()`方法首先创建空列表来存储顶点和法线。然后，你通过使用嵌套循环来实现我们在[“渲染”](nsp-venkitachalam503045-0024.xhtml#bh1203)部分讨论的策略，来计算圆环的顶点和法线。外层循环遍历构成圆环的`N`个环。内层循环遍历每个环上的`M`个点。在循环内部，你首先计算角度`theta`，它是索引`j`的环上某一点所形成的角度❶。你使用`j
    % M`，并让内层循环遍历范围`[0, M+1)`，这样当*j*等于`M`时，`(j % M)`就会回到`0`。这是为了完成圆环的最后一个部分。'
- en: The torus is rendered as a set of bands (triangle strips), and each band consists
    of two adjacent rings of points. You compute `alpha1`, the angle subtended by
    the first ring in a band, at index `i` ❷, and use `alpha1` to compute the rotation
    and translation matrices for this first ring using the `compute_rt()` method ❸.
    Then you pass these matrices to the `compute_pt()` method to calculate the vertex
    and normal for the point on the ring at angle `theta` ❹. We’ll look at how the
    `compute_rt()` and `compute_pt()` methods work soon.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 圆环以一组带（平面三角带）呈现，每个带由两个相邻的圆环组成。你计算`alpha1`，即带中第一个环的角度，它在索引`i`处❷，然后使用`alpha1`通过`compute_rt()`方法计算这个第一个环的旋转和位移矩阵❸。接着，你将这些矩阵传递给`compute_pt()`方法，以计算角度`theta`处环上点的顶点和法线❹。我们稍后将了解`compute_rt()`和`compute_pt()`方法的具体实现。
- en: Next, you move on to the adjacent ring at index `i+1`, using `ip1 = (i+1) %
    N` to ensure that you roll back to zero at the end ❺. You compute the angle `alpha2`
    of the ring at index `ip1` ❻ and then compute the vertex and normal for the point
    on the `ip1` ring at angle `theta`, just as you did for the first ring.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要移动到索引为`i+1`的相邻环，使用`ip1 = (i+1) % N`来确保在结束时回到零❺。你计算索引`ip1`处环的角度`alpha2`❻，然后像对待第一个环一样，计算`ip1`环上角度`theta`处的顶点和法线。
- en: Beginning at ❼, you append the vertices and normals for the adjacent rings to
    the lists you created at the beginning of the method. You pick only the first
    three coordinates of each vertex and normal, as in `Pt1[0:3]`, since all the matrix
    transformations are done with homogeneous coordinates in the form (*x*, *y*, *z*,
    *w*), and you need only (*x*, *y*, *z*). This action stores the vertices and normals
    in a Python list of triplets of the form `[[x1, y1, z1], [x2, y2, z2], ...]`.
    However, OpenGL expects vertex attributes to be provided in a flat array with
    a known size. Therefore, you convert the `vertices` and `normals` lists into `numpy`
    arrays of 32-bit floats ❽, using `reshape(-1)` to ensure that they’re flat arrays
    of the form `[x1, y1, z1, x2, y2, z2, ...]`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 从❼开始，你将相邻圆环的顶点和法线附加到方法开始时创建的列表中。你只选择每个顶点和法线的前三个坐标，如`Pt1[0:3]`，因为所有矩阵变换都使用齐次坐标（*x*,
    *y*, *z*, *w*）形式进行，并且只需要(*x*, *y*, *z*)。此操作将顶点和法线存储为一个Python列表，列表中的元素是`[[x1, y1,
    z1], [x2, y2, z2], ...]`格式的三元组。然而，OpenGL期望顶点属性以已知大小的扁平数组提供。因此，你将`vertices`和`normals`列表转换为32位浮点数的`numpy`数组❽，并使用`reshape(-1)`确保它们是扁平数组，形式为`[x1,
    y1, z1, x2, y2, z2, ...]`。
- en: 'Now let’s look at the `compute_rt()` and `compute_pt()` methods that helped
    you compute the vertices and normals. We’ll start with `compute_rt()`, which calculates
    the rotation and translation matrices needed to render a given ring in the torus:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下帮助你计算顶点和法线的`compute_rt()`和`compute_pt()`方法。我们将从`compute_rt()`开始，它计算渲染圆环所需的旋转和平移矩阵：
- en: '[PRE5]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You first calculate the translation components of the matrix ❶, using parametric
    equations. Then you create the rotation matrix ❷ and translation matrix ❸ as `numpy`
    arrays. You’ve seen these matrices before in the [“Computing Vertices”](nsp-venkitachalam503045-0024.xhtml#bh1201)
    section. You return the arrays at the end of the method.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先使用参数方程计算矩阵的平移分量❶。然后，你创建旋转矩阵❷和平移矩阵❸，作为`numpy`数组。你在[“计算顶点”](nsp-venkitachalam503045-0024.xhtml#bh1201)部分见过这些矩阵。你在方法结束时返回这些数组。
- en: 'Here’s the other helper method, `compute_pt()`, which uses the translation
    and rotation matrices to determine the vertex and normal vector of a given point
    on a ring of the torus:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个辅助方法`compute_pt()`，它使用平移和旋转矩阵来确定圆环上某个点的顶点和法向量：
- en: '[PRE6]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You compute the point `P` at angle `theta` on a ring lying on the XZ plane ❶.
    Then you apply a rotation to this point by multiplying it by the rotation matrix
    ❷. This also gives you the point’s normal vector. You multiply the normal by the
    translation matrix to give you the vertex on the torus ❸.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你计算圆环上角度为`theta`的点`P`，该点位于XZ平面❶上。然后，你通过将其与旋转矩阵❷相乘来对该点进行旋转。这也给出了该点的法向量。你将法向量与平移矩阵相乘，得到圆环上的顶点❸。
- en: Managing Cell Colors
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 管理单元格颜色
- en: Now we’ll examine some methods that help set the colors of the cells on the
    torus. First is the `compute_colors()` method, which we originally called as part
    of the `Torus` class’s constructor. It sets the color of each triangle in the
    triangle strips that make up the torus, based on the values determined by the
    Game of Life simulation.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看一些有助于设置圆环上单元格颜色的方法。首先是`compute_colors()`方法，我们最初在`Torus`类的构造函数中调用过。它根据“生命游戏”模拟确定的值，设置组成圆环的三角带中每个三角形的颜色。
- en: '[PRE7]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This method follows the logic described in [“Coloring the Triangle Strips”](nsp-venkitachalam503045-0024.xhtml#bh1204)
    on [page 185](nsp-venkitachalam503045-0024.xhtml#p185) to update the values in
    the `colors` array, which was initialized as an array of all zeros. You retrieve
    the color for cell `(i, jj)` from `colors_dict`, the dictionary mapping cells
    to colors that you created earlier ❶. (You define `jj = j % M` so it rolls over
    to zero at the end.) Then you compute the index into the `colors` array at which
    you should update the new computed values ❷. Each pair of rings that makes up
    a band has `2*(M+1)` vertices, and there are `N` of these pairs. Starting at each
    location in the array, you store three sequential values (the RGB components of
    a cell’s color). Hence, the index of the *j*th color in a ring for the *i*th segment
    of the torus will be given by `3*(2*i*(M+1) + 2*j)`. Note that you use `j` and
    not `jj` in computing the index, since you’re storing the computed values here
    and you don’t want the index to roll over to zero. Now that you have the index,
    you update the `colors` array with the new computed values. You update the array
    both at `[index:index+3]` ❸ and at `[index+3:index+6]` ❹ since each cell on the
    torus is a quad, made of two adjacent triangles.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法遵循在[“为三角形条纹着色”](nsp-venkitachalam503045-0024.xhtml#bh1204)中描述的逻辑，在[第185页](nsp-venkitachalam503045-0024.xhtml#p185)更新`colors`数组中的值，该数组初始化为全零的数组。你从`colors_dict`中获取单元格`(i,
    jj)`的颜色，`colors_dict`是你之前创建的将单元格与颜色映射的字典❶。（你定义`jj = j % M`，使其在结束时回滚为零。）然后你计算应更新新计算值的`colors`数组中的索引❷。组成带的每对环有`2*(M+1)`个顶点，且共有`N`对这些环。从数组中的每个位置开始，你存储三个连续的值（单元格颜色的RGB分量）。因此，环中第*j*个颜色在*第i*段圆环中的索引将由`3*(2*i*(M+1)
    + 2*j)`给出。注意，在计算索引时你使用的是`j`而非`jj`，因为你在此处存储的是计算出的值，不希望索引回滚为零。现在你得到了索引，你就可以用新的计算值更新`colors`数组。你同时在`[index:index+3]`❸和`[index+3:index+6]`❹处更新该数组，因为圆环上的每个单元格是一个四边形，由两个相邻的三角形组成。
- en: 'Let’s now look at `recalc_colors()`, a method for updating the color values
    stored on the GPU at each step in the Game of Life simulation:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下`recalc_colors()`方法，这是在生命游戏模拟的每一步更新GPU上存储的颜色值的方法：
- en: '[PRE8]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: For every step of the simulation, the colors of the cells are updated, which
    means you need to update the colors of all the triangle strips on the torus, and
    you need to do it efficiently so you don’t slow down the rendering. The `recalc_colors()`
    method does this using the OpenGL `glBufferSubData()` method ❶. The vertices,
    normals, and colors are stored in attribute arrays on the GPU. The vertices and
    normals don’t change, so you computed them only once in the beginning, with a
    call to `compute_vertices()` in the class’s constructor method. When the colors
    change, `glBufferSubData()` updates the color attribute arrays rather than creating
    them afresh.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在每一步模拟中，单元格的颜色都会更新，这意味着你需要更新圆环上所有三角形条纹的颜色，并且你需要高效地完成这一操作，以免拖慢渲染速度。`recalc_colors()`方法通过使用OpenGL的`glBufferSubData()`方法❶来完成这一操作。顶点、法线和颜色被存储在GPU上的属性数组中。由于顶点和法线不会变化，因此你只需在开始时通过调用类构造方法中的`compute_vertices()`计算一次。当颜色发生变化时，`glBufferSubData()`会更新颜色属性数组，而不是重新创建它们。
- en: Drawing the Torus
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 绘制圆环
- en: 'Finally, here’s the `render()` method that draws the torus:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是绘制圆环的`render()`方法：
- en: '[PRE9]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This method is similar to the render methods you saw in the [previous chapter](nsp-venkitachalam503045-0023.xhtml#ch09).
    You make a call to use the shader program ❶ and set the projection ❷ and modelview
    ❸ matrix uniform variables. Then you bind to the vertex array object ❹, which
    you created by calling `setup_vao()` in the class’s constructor. The VAO has all
    the attribute array buffers you need. Next, you use the `glMultiDrawArrays()`
    method to draw `N` triangle strips ❺. You already computed `first_indices` and
    `counts` in the `Torus` constructor.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法类似于你在[上一章](nsp-venkitachalam503045-0023.xhtml#ch09)中看到的渲染方法。你首先调用使用着色器程序❶，并设置投影❷和模型视图❸矩阵的统一变量。然后，你绑定到顶点数组对象❹，这是你通过在类的构造函数中调用`setup_vao()`创建的。VAO包含了你所需的所有属性数组缓冲区。接下来，你使用`glMultiDrawArrays()`方法绘制`N`个三角形条纹❺。你已经在`Torus`构造函数中计算了`first_indices`和`counts`。
- en: '[Implementing the Game of Life Simulation](nsp-venkitachalam503045-0008.xhtml#rbh1208)'
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[实现生命游戏模拟](nsp-venkitachalam503045-0008.xhtml#rbh1208)'
- en: In [Chapter 3](nsp-venkitachalam503045-0015.xhtml#ch03), you implemented Conway’s
    Game of Life (GOL) by using `matplotlib` to visualize the updated values of the
    simulation grid. Here you’ll adapt the earlier implementation to update a dictionary
    of cell colors instead, which will be used to update the colors of the torus.
    The relevant code is encapsulated in a class called `GOL`, declared in the file
    *gol.py*. To see the complete code listing, skip ahead to [“The Complete Game
    of Life Simulation Code”](nsp-venkitachalam503045-0024.xhtml#ah1208) on [page
    209](nsp-venkitachalam503045-0024.xhtml#p209).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](nsp-venkitachalam503045-0015.xhtml#ch03)中，你通过使用`matplotlib`来可视化更新后的模拟网格值，来实现了康威的《生命游戏》(GOL)。在这里，你将之前的实现改编为更新单元格颜色的字典，而不是更新网格值，该字典将用于更新环面的颜色。相关代码封装在一个名为`GOL`的类中，该类在文件*gol.py*中声明。要查看完整的代码清单，请跳到[“完整的生命游戏模拟代码”](nsp-venkitachalam503045-0024.xhtml#ah1208)在[第209页](nsp-venkitachalam503045-0024.xhtml#p209)。
- en: The Class Constructor
  id: totrans-133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 类的构造函数
- en: 'First, let’s look at the `GOL` class constructor:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看一下`GOL`类的构造函数：
- en: '[PRE10]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `GOL` constructor takes as input the grid dimensions `NX` and `NY`, as well
    as a Boolean flag `glider` ❶. If this flag is set, you initialize the simulation
    grid with the “glider” pattern using the `addGlider()` method ❷. Since we already
    discussed this method in [Chapter 3](nsp-venkitachalam503045-0015.xhtml#ch03),
    we won’t examine it here. If the `glider` flag isn’t set, you just initialize
    the grid to random ones and zeros ❸.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`GOL`构造函数接受网格尺寸`NX`和`NY`作为输入，以及一个布尔标志`glider`❶。如果设置了该标志，你将使用`addGlider()`方法❷初始化带有“滑翔机”图案的模拟网格。由于我们已经在[第3章](nsp-venkitachalam503045-0015.xhtml#ch03)中讨论了此方法，这里不再详细说明。如果没有设置`glider`标志，你将只初始化一个随机的零和一的网格❸。'
- en: The `GOL` class uses an `update()` method to update the simulation grid at each
    time step. Again, this is identical to the previous implementation.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`GOL`类使用`update()`方法在每个时间步更新模拟网格。同样，这与之前的实现完全相同。'
- en: The get_colors() Method
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`get_colors()` 方法'
- en: 'The `get_colors()` method is what distinguishes this chapter’s Game of Life
    implementation from that of [Chapter 3](nsp-venkitachalam503045-0015.xhtml#ch03).
    The method builds up a dictionary mapping of each Game of Life cell to its color
    value at a given step in the simulation: black for ON or white for OFF. This dictionary
    is passed to the `Torus` object when the scene is updated.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_colors()` 方法是本章《生命游戏》实现与[第3章](nsp-venkitachalam503045-0015.xhtml#ch03)的不同之处。该方法构建了一个字典，将每个《生命游戏》单元格映射到模拟中某一步的颜色值：开启时为黑色，关闭时为白色。这个字典将在场景更新时传递给`Torus`对象。'
- en: '[PRE11]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here you iterate through all the cells in the simulation grid and set the RGB
    colors based on whether the grid value is `0` or `1`. The possible colors are
    defined as `c1` for white ❶ or `c2` for black ❷. These colors will be used while
    rendering the torus.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你遍历模拟网格中的所有单元格，并根据网格值是`0`还是`1`来设置RGB颜色。可能的颜色定义为`c1`表示白色❶，`c2`表示黑色❷。这些颜色将在渲染环面时使用。
- en: '[Creating the Camera](nsp-venkitachalam503045-0008.xhtml#rbh1209)'
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[创建相机](nsp-venkitachalam503045-0008.xhtml#rbh1209)'
- en: In [“Controlling the Camera”](nsp-venkitachalam503045-0024.xhtml#bh1205) on
    [page 185](nsp-venkitachalam503045-0024.xhtml#p185), we discussed how to build
    a camera that orbits around the torus. Now let’s look at the implementation. The
    code is encapsulated in the class `OrbitCamera`, which is declared in the file
    *camera.py*. To see the complete code listing, skip ahead to [“The Complete Camera
    Code”](nsp-venkitachalam503045-0024.xhtml#ah1209) on [page 211](nsp-venkitachalam503045-0024.xhtml#p211).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在[“控制相机”](nsp-venkitachalam503045-0024.xhtml#bh1205)中，位于[第185页](nsp-venkitachalam503045-0024.xhtml#p185)，我们讨论了如何构建一个环绕环面旋转的相机。现在让我们来看一下其实现。代码封装在名为`OrbitCamera`的类中，该类在文件*camera.py*中声明。要查看完整的代码清单，请跳到[“完整的相机代码”](nsp-venkitachalam503045-0024.xhtml#ah1209)在[第211页](nsp-venkitachalam503045-0024.xhtml#p211)。
- en: Constructing the Class
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 构造类
- en: 'Here’s the constructor for the `OrbitCamera` class:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`OrbitCamera`类的构造函数：
- en: '[PRE12]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You start by setting the camera parameters passed into the `OrbitCamera` constructor.
    These include the camera’s orbit radius ❶ and `beta`, the angle that the view
    vector (projected on the XY plane) makes with the x-axis ❷. You also set the amount
    `beta` should increment with each time step of the camera rotation ❸ and the height
    of the camera from the XY plane ❹.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先设置传递给`OrbitCamera`构造函数的相机参数。这些参数包括相机的轨道半径❶和`beta`，即视角向量（投影在XY平面上）与x轴的夹角❷。你还设置`beta`在每个相机旋转时间步长中的增量❸以及相机距离XY平面的高度❹。
- en: 'Next, you set the initial value of the eye position to be midway between the
    positive x- and positive y-axis, at a distance `R` from the origin, suspended
    at the specified `height` ❺. You can calculate this as:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将眼睛位置的初始值设置为位于正 x 轴和正 y 轴之间的中点，距离原点 `R`，并悬停在指定的 `height` 处 ❺。你可以通过以下公式计算出这个位置：
- en: '![](images/nsp-venkitachalam503045-m10013.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-m10013.jpg)'
- en: Finally, you compute the camera’s up vector ❻ and set the center as the origin
    (0, 0, 0) ❼. Remember that these are the pieces of information, along with the
    eye position, that OpenGL needs to model a camera.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你计算相机的向上向量 ❻ 并将中心设置为原点 (0, 0, 0) ❼。请记住，这些信息是 OpenGL 在模拟相机时所需要的，连同眼睛位置一起。
- en: Calculating the Up Vector
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 计算向上向量
- en: 'Here’s the method that you call in the `OrbitCamera` class constructor to compute
    the up vector:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你在 `OrbitCamera` 类的构造函数中调用的方法，用于计算向上向量：
- en: '[PRE13]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `__compute_up_vector()` method calculates the up vector `U` based on the
    method we discussed earlier in [“Controlling the Camera”](nsp-venkitachalam503045-0024.xhtml#bh1205)
    on [page 185](nsp-venkitachalam503045-0024.xhtml#p185). Specifically, you use
    cross products and the initial up vector guess of (0, 0, 1) to compute the correct
    up vector ❶. Then you normalize the up vector ❷ before returning it.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`__compute_up_vector()` 方法根据我们在 [“控制相机”](nsp-venkitachalam503045-0024.xhtml#bh1205)
    中讨论的方式，计算出向上向量 `U`，该内容位于 [第 185 页](nsp-venkitachalam503045-0024.xhtml#p185)。具体来说，你通过叉积运算和初始的向上向量猜测值
    (0, 0, 1) 来计算正确的向上向量 ❶。然后，在返回之前，你对向上向量 ❷ 进行归一化处理。'
- en: Rotating the Camera
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 旋转相机
- en: 'The `OrbitCamera` class’s `rotate()` method is called every time you need to
    rotate the camera around the torus by one step. Here’s the method’s definition:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你需要围绕圆环旋转相机一步时，都会调用 `OrbitCamera` 类的 `rotate()` 方法。以下是该方法的定义：
- en: '[PRE14]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You increase the angle `beta` by the increment `beta_step`, using the `%` operator
    to ensure that the angle rolls over to 0 when it reaches 360 degrees ❶. Then you
    use the new `beta` value to compute the updated eye position ❷, and you use the
    new eye position to compute the new up vector with the `__compute_up_vector()`
    method ❸.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过增加增量 `beta_step` 来增加角度 `beta`，并使用 `%` 运算符确保当角度达到 360 度时会回绕到 0 ❶。然后，你使用新的
    `beta` 值来计算更新后的眼睛位置 ❷，并用新的眼睛位置来通过 `__compute_up_vector()` 方法计算新的向上向量 ❸。
- en: '[Putting Everything Together](nsp-venkitachalam503045-0008.xhtml#rbh1210)'
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[将一切组合在一起](nsp-venkitachalam503045-0008.xhtml#rbh1210)'
- en: You’ve built all the classes necessary for rendering the torus. Now you need
    some code to bring those classes together, create and manage the OpenGL window,
    and coordinate the rendered objects. Create the class `RenderWindow` (defined
    in *gol_torus.py*) for this purpose. It’s similar to the `RenderWindow` class
    used in [Chapter 9](nsp-venkitachalam503045-0023.xhtml#ch09), so we’ll discuss
    only the parts of the code that are unique to the current project. To see the
    complete code listing, skip ahead to [“The Complete RenderWindow Code”](nsp-venkitachalam503045-0024.xhtml#ah1210)
    on [page 211](nsp-venkitachalam503045-0024.xhtml#p211).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经构建了渲染圆环所需的所有类。现在，你需要一些代码将这些类连接起来，创建和管理 OpenGL 窗口，并协调渲染的对象。为此，创建 `RenderWindow`
    类（定义在 *gol_torus.py* 中）。它类似于 [第 9 章](nsp-venkitachalam503045-0023.xhtml#ch09)
    中使用的 `RenderWindow` 类，因此我们只讨论与当前项目独特的代码部分。要查看完整的代码清单，请跳至 [“完整的 RenderWindow 代码”](nsp-venkitachalam503045-0024.xhtml#ah1210)
    在 [第 211 页](nsp-venkitachalam503045-0024.xhtml#p211)。
- en: The main() Function
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: main() 函数
- en: Before we examine the `RenderWindow` class, let’s look the program’s `main()`
    function, which sets the whole simulation in motion. This function is also defined
    in *gol_torus.py*.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们检查 `RenderWindow` 类之前，先来看一下程序的 `main()` 函数，它启动了整个仿真。这个函数也定义在 *gol_torus.py*
    中。
- en: '[PRE15]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You add a command line argument called `--glider` so you can bring up the torus
    with just a glider pattern on it ❶ and set the corresponding flag ❷. Then you
    create a `RenderWindow` object ❸, which initializes all the other objects needed
    for the program, and start the rendering with a call to the `RenderWindow` object’s
    `run()` method ❹.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你添加了一个名为 `--glider` 的命令行参数，这样你就可以通过仅带有滑翔模式的圆环来启动 ❶，并设置相应的标志 ❷。然后你创建一个 `RenderWindow`
    对象 ❸，它初始化了程序所需的所有其他对象，并通过调用 `RenderWindow` 对象的 `run()` 方法 ❹ 来启动渲染。
- en: The RenderWindow Constructor
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: RenderWindow 构造函数
- en: 'The constructor on the `RenderWindow` class starts with the standard GLFW OpenGL
    setup you saw in [Chapter 9](nsp-venkitachalam503045-0023.xhtml#ch09), including
    setting the window size, calling the render methods, and handling window and keyboard
    events. Then the constructor goes on with the following Game of Life–specific
    initializations:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`RenderWindow`类的构造函数以你在[第9章](nsp-venkitachalam503045-0023.xhtml#ch09)中看到的标准GLFW
    OpenGL设置开始，包括设置窗口大小、调用渲染方法以及处理窗口和键盘事件。然后，构造函数继续进行以下生命游戏（Game of Life）特定的初始化：'
- en: '[PRE16]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: First you set some parameters for the simulation, including the number of cells
    in the grid and the inner and outer radiuses of the torus. Then you create the
    `Torus` object using these parameters ❶, as well as the `GOL` object that will
    manage the simulation ❷. You also create the orbiting camera at a radius of 5
    units from the origin and a height of 10 units from the XY plane ❸.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你为模拟设置一些参数，包括网格中细胞的数量以及环面的内外半径。然后，你使用这些参数❶创建`Torus`对象，并创建将管理模拟的`GOL`对象❷。你还创建了一个环绕相机，距离原点5个单位，距离XY平面10个单位❸。
- en: Next, you set the exit flag used to quit the program ❹, and you initialize the
    rotation flag to `True` ❺. Finally, you set a `skip` variable ❻, which you’ll
    use to control the frequency at which the simulation updates. You’ll see how the
    `skip` variable works later in this section.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你设置退出标志以退出程序❹，并将旋转标志初始化为`True`❺。最后，你设置一个`skip`变量❻，它将用于控制模拟更新的频率。你将在本节后面看到`skip`变量是如何工作的。
- en: The run() and step() Methods
  id: totrans-170
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`run()`和`step()`方法'
- en: 'The `run()` method of the `RenderWindow` object is responsible for running
    the simulation, with help from the `step()` method. Let’s take a look at the `run()`
    method first:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`RenderWindow`对象的`run()`方法负责运行模拟，并借助`step()`方法。我们首先来看一下`run()`方法：'
- en: '[PRE17]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The rendering scheme is designed to keep rendering frames in a loop until the
    window is closed or the ESC key is pressed ❶. Before you proceed, you check whether
    the time elapsed since the last render is greater than 0.05 seconds ❷. This helps
    maintain a maximum frame rate. Starting at ❸, you perform some standard OpenGL
    operations, such as setting the viewport, clearing the screen, and computing the
    current transformation that needs to be set into the vertex shader. Then you render
    the torus ❹ and call the `step()` method ❺, which will rotate the camera and update
    the Game of Life simulation by one time step. Once the rendering is done, you
    swap the OpenGL buffers and poll for further window events. If you exit the loop,
    you call the `glfwTerminate()` method for cleanup.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染方案的设计是保持渲染帧循环，直到窗口关闭或按下ESC键❶。在继续之前，你会检查自上次渲染以来是否经过了超过0.05秒❷。这有助于维持最大帧率。从❸开始，你执行一些标准的OpenGL操作，比如设置视口、清除屏幕以及计算需要设置到顶点着色器中的当前变换。然后，你渲染环面❹并调用`step()`方法❺，它会旋转相机并更新生命游戏模拟一步。渲染完成后，你交换OpenGL缓冲区并轮询进一步的窗口事件。如果退出循环，你会调用`glfwTerminate()`方法进行清理。
- en: 'Here’s the `step()` method that increments the camera and the simulation:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`step()`方法，它会增加相机和模拟的步进：
- en: '[PRE18]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Every time this method is called, it rotates the camera by one step ❽. You also
    want to update the Game of Life simulation, but doing so at the same rate that
    the camera moves would not be visually pleasing. You therefore use the `skip`
    variable to slow down the simulation by a factor of 9 relative to the camera motion.
    This variable starts from `0` and is incremented each time the `step()` method
    is called ❼. When `skip` gets to `9` ❶, you update the simulation by one time
    step. To do this, you first call the `GOL` class’s `update()` method ❷, which
    turns cells on or off according to the Conway’s Game of Life rules. Then you get
    the updated cell colors from the simulation ❸, set them to the torus ❹, and call
    `torus.step()` ❺, which will update the attribute buffers with the new colors.
    Finally, you reset the `skip` variable to `0` so the process can repeat ❻.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用此方法时，它会将相机旋转一步❽。你还想更新生命游戏模拟，但以相同的速度更新模拟与相机的移动相比视觉效果会不太理想。因此，你使用`skip`变量来将模拟的速度减慢到相对于相机运动的1/9。该变量从`0`开始，每次调用`step()`方法时递增❼。当`skip`达到`9`❶时，你将更新模拟的时间步长。为此，你首先调用`GOL`类的`update()`方法❷，该方法根据康威的生命游戏规则打开或关闭细胞。然后，你从模拟中获取更新后的细胞颜色❸，将它们设置到环面（torus）❹中，并调用`torus.step()`❺，这将更新属性缓冲区中的新颜色。最后，你将`skip`变量重置为`0`，以便该过程可以重复❻。
- en: '[Running the 3D Game of Life Simulation](nsp-venkitachalam503045-0008.xhtml#rah1204)'
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[运行3D生命游戏模拟](nsp-venkitachalam503045-0008.xhtml#rah1204)'
- en: 'Now we’re ready to run the code. Enter the following at the terminal:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备好运行代码了。在终端中输入以下内容：
- en: '[PRE19]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[Figure 10-8](nsp-venkitachalam503045-0024.xhtml#fig10-8) shows the output.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10-8](nsp-venkitachalam503045-0024.xhtml#fig10-8)展示了输出结果。'
- en: '![](images/nsp-venkitachalam503045-f10008.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f10008.jpg)'
- en: 'Figure 10-8: A rendering of the Game of Life on a torus'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-8：环面上的生命游戏渲染
- en: The program will open a window that shows the torus you meticulously constructed,
    with the Game of Life simulation running on its surface! As the simulation evolves,
    try to find some of the familiar Game of Life patterns you saw in [Chapter 3](nsp-venkitachalam503045-0015.xhtml#ch03).
    Notice that the light direction remains constant while the camera orbits the torus.
    As the camera turns, you’ll be able to see the light and dark portions of the
    torus.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 程序会打开一个窗口，显示你精心构建的环面，并在其表面运行生命游戏模拟！随着模拟的演变，试着找到你在[第3章](nsp-venkitachalam503045-0015.xhtml#ch03)中看到的一些熟悉的生命游戏模式。注意，光照方向保持不变，而摄像头绕环面旋转。当摄像头转动时，你将能够看到环面的明暗部分。
- en: 'Now let’s try the glider option:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试一下滑行器选项：
- en: '[PRE20]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[Figure 10-9](nsp-venkitachalam503045-0024.xhtml#fig10-9) shows the output.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10-9](nsp-venkitachalam503045-0024.xhtml#fig10-9)展示了输出结果。'
- en: '![](images/nsp-venkitachalam503045-f10009.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f10009.jpg)'
- en: 'Figure 10-9: A Game of Life glider on a torus'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-9：环面上的生命游戏滑行器
- en: Sit back and enjoy watching the lone glider make its way along the surface of
    the torus!
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 放轻松，享受观看孤独的滑行器在环面表面上移动吧！
- en: '[Summary](nsp-venkitachalam503045-0008.xhtml#rah1205)'
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[摘要](nsp-venkitachalam503045-0008.xhtml#rah1205)'
- en: In this chapter, you implemented Conway’s Game of Life on a torus. You learned
    how to compute the vertices of a torus and how to render it using OpenGL, and
    you saw how code can be adapted from one context (a flat rendering of the Game
    of Life simulation) to another (a 3D rendering of the same simulation). In the
    process, I hope you’ve gotten a more intuitive feeling for how the toroidal boundary
    conditions we discussed in [Chapter 3](nsp-venkitachalam503045-0015.xhtml#ch03) work.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你实现了康威生命游戏在环面上的运行。你学习了如何计算环面的顶点，如何使用OpenGL渲染它，并且你看到了代码如何从一个上下文（生命游戏模拟的平面渲染）适配到另一个上下文（同一模拟的3D渲染）。在这个过程中，我希望你对我们在[第3章](nsp-venkitachalam503045-0015.xhtml#ch03)讨论的环面边界条件有了更直观的理解。
- en: '[Experiments!](nsp-venkitachalam503045-0008.xhtml#rah1206)'
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[实验！](nsp-venkitachalam503045-0008.xhtml#rah1206)'
- en: 'Here are a few experiments you can try with this project:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你可以尝试的一些实验：
- en: 1\. In this chapter’s implementation, the torus is lit by a single light source.
    Try adding another light source in the shader code. Now the computed color of
    a vertex will be the sum of contributions from both light sources. Try changing
    the positions and colors of the light sources and see the effect on the torus
    lighting.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1. 在本章的实现中，环面由一个光源照亮。尝试在着色器代码中添加另一个光源。现在，计算得到的顶点颜色将是两个光源贡献的总和。尝试改变光源的位置和颜色，看看它们对环面照明的影响。
- en: 2\. To get a representative view of the simulation, you defined a camera that
    revolves around the z-axis of the torus, in a plane parallel to the XY plane.
    Now create a camera that flies over the torus instead. Your camera will start
    by looking down at the torus along the negative z-axis and will move in a circle
    along the XZ plane, at a fixed distance from the center of the torus. Think about
    how you will compute the eye point, view direction, and up vector for each step
    of the movement.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2. 为了获得模拟的代表性视图，你定义了一个围绕环面z轴旋转的摄像头，摄像头运动在一个与XY平面平行的平面上。现在，创建一个摄像头，让它飞越环面。你的摄像头将从负z轴方向向下看环面，并沿XZ平面以固定的距离绕着环面的中心旋转。思考一下如何计算每一步运动的眼点、视线方向和上向量。
- en: '[The Complete Torus Rendering Code](nsp-venkitachalam503045-0008.xhtml#rah1207)'
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[完整的环面渲染代码](nsp-venkitachalam503045-0008.xhtml#rah1207)'
- en: 'Here’s the complete listing for the file *torus.py*:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是文件*torus.py*的完整代码列表：
- en: '[PRE21]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[The Complete Game of Life Simulation Code](nsp-venkitachalam503045-0008.xhtml#rah1208)'
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[完整的生命游戏模拟代码](nsp-venkitachalam503045-0008.xhtml#rah1208)'
- en: Here’s the full code listing for the file *gol.py*.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是文件*gol.py*的完整代码列表。
- en: '"""'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: gol.py
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: gol.py
- en: Implements Conway's Game of Life.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 实现康威生命游戏。
- en: 'Author: Mahesh Venkitachalam'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 作者：Mahesh Venkitachalam
- en: '"""'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: import numpy as np
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: import numpy as np
- en: 'class GOL:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 'class GOL:'
- en: '"""GOL - class that implements Conway''s Game of Life'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '"""GOL - 实现康威生命游戏的类'
- en: '"""'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: 'def __init__(self, NX, NY, glider):'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, NX, NY, glider):'
- en: '"""GOL constructor"""'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '"""GOL 构造函数"""'
- en: '# a grid of NX x NY random values'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '# 一个NX x NY的随机值网格'
- en: self.NX, self.NY = NX, NY
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: self.NX, self.NY = NX, NY
- en: 'if glider:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 'if glider:'
- en: self.addGlider(1, 1, NX, NY)
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: self.addGlider(1, 1, NX, NY)
- en: 'else:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: self.grid = np.random.choice([1, 0], NX * NY, p=[0.2, 0.8]).reshape(NX, NY)
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: self.grid = np.random.choice([1, 0], NX * NY, p=[0.2, 0.8]).reshape(NX, NY)
- en: 'def addGlider(self, i, j, NX, NY):'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 'def addGlider(self, i, j, NX, NY):'
- en: '"""adds a glider with top left cell at (i, j)"""'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '"""在(i, j)处添加一个滑翔机，左上角的单元格为(i, j)"""'
- en: self.grid = np.zeros(NX * NY).reshape(NX, NY)
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: self.grid = np.zeros(NX * NY).reshape(NX, NY)
- en: glider = np.array([[0,    0, 1],
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: glider = np.array([[0,    0, 1],
- en: '[1,  0, 1],'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '[1,  0, 1],'
- en: '[0,  1, 1]])'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '[0,  1, 1]])'
- en: self.grid[i:i+3, j:j+3] = glider
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: self.grid[i:i+3, j:j+3] = glider
- en: 'def update(self):'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 'def update(self):'
- en: '"""update the GOL simulation by one time step"""'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '"""更新 GOL 模拟的一个时间步骤"""'
- en: '# copy grid since we require 8 neighbors for calculation'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '# 复制网格，因为我们需要8个邻居来计算'
- en: '# and we go line by line'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '# 然后逐行进行'
- en: newGrid = self.grid.copy()
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: newGrid = self.grid.copy()
- en: NX, NY = self.NX, self.NY
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: NX, NY = self.NX, self.NY
- en: 'for i in range(NX):'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(NX):'
- en: 'for j in range(NY):'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 'for j in range(NY):'
- en: '# compute 8-neighbor sum'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '# 计算8个邻居的和'
- en: '# using toroidal boundary conditions - x and y wrap around'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '# 使用环面边界条件 - x和y会环绕'
- en: '# so that the simulation takes place on a toroidal surface'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '# 使得模拟在环面上进行'
- en: total = (self.grid[i, (j-1) % NY] + self.grid[i, (j+1) % NY] +
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: total = (self.grid[i, (j-1) % NY] + self.grid[i, (j+1) % NY] +
- en: self.grid[(i-1) % NX, j] + self.grid[(i+1) % NX, j] +
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: self.grid[(i-1) % NX, j] + self.grid[(i+1) % NX, j] +
- en: self.grid[(i-1) % NX, (j-1) % NY] + self.grid[(i-1) % NX, (j+1) % NY] +
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: self.grid[(i-1) % NX, (j-1) % NY] + self.grid[(i-1) % NX, (j+1) % NY] +
- en: self.grid[(i+1) % NX, (j-1) % NY] + self.grid[(i+1) % NX, (j+1) % NY])
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: self.grid[(i+1) % NX, (j-1) % NY] + self.grid[(i+1) % NX, (j+1) % NY])
- en: '# apply Conway''s rules'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '# 应用康威的规则'
- en: 'if self.grid[i, j]  == 1:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 'if self.grid[i, j]  == 1:'
- en: 'if (total < 2) or (total > 3):'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 'if (total < 2) or (total > 3):'
- en: newGrid[i, j] = 0
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: newGrid[i, j] = 0
- en: 'else:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: 'if total == 3:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 'if total == 3:'
- en: newGrid[i, j] = 1
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: newGrid[i, j] = 1
- en: '# update data'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '# 更新数据'
- en: self.grid[:] = newGrid[:]
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: self.grid[:] = newGrid[:]
- en: 'def get_colors(self):'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 'def get_colors(self):'
- en: '"""returns a dictionary of colors"""'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '"""返回颜色字典"""'
- en: colors = {}
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: colors = {}
- en: c1 = np.array([1.0, 1.0, 1.0], np.float32)
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: c1 = np.array([1.0, 1.0, 1.0], np.float32)
- en: c2 = np.array([0.0, 0.0, 0.0], np.float32)
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: c2 = np.array([0.0, 0.0, 0.0], np.float32)
- en: 'for i in range(self.NX):'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(self.NX):'
- en: 'for j in range (self.NY):'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 'for j in range(self.NY):'
- en: 'if self.grid[i, j] == 1:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 'if self.grid[i, j] == 1:'
- en: colors[(i, j)] = c2
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: colors[(i, j)] = c2
- en: 'else :'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 'else :'
- en: colors[(i, j)] = c1
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: colors[(i, j)] = c1
- en: return colors
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: return colors
- en: '[The Complete Camera Code](nsp-venkitachalam503045-0008.xhtml#rah1209)'
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[完整的相机代码](nsp-venkitachalam503045-0008.xhtml#rah1209)'
- en: 'Here’s the complete code in the file *camera.py*:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这是文件*camera.py*中的完整代码：
- en: '[PRE22]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[The Complete RenderWindow Code](nsp-venkitachalam503045-0008.xhtml#rah1210)'
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[完整的RenderWindow代码](nsp-venkitachalam503045-0008.xhtml#rah1210)'
- en: The complete code listing for *gol_torus.py*, including the `RenderWindow` class
    and the `main()` function, follows.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 完整代码清单对于*gol_torus.py*，包括`RenderWindow`类和`main()`函数，如下所示。
- en: '"""'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: gol_torus.py
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: gol_torus.py
- en: Python OpenGL program that displays a torus.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 一个显示环面图形的Python OpenGL程序。
- en: 'Author: Mahesh Venkitachalam'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 作者：Mahesh Venkitachalam
- en: '"""'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: import OpenGL
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: import OpenGL
- en: from OpenGL.GL import *
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 OpenGL.GL 导入 *
- en: import numpy, math, sys, os
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: import numpy, math, sys, os
- en: import argparse
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: import argparse
- en: import glutils
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: import glutils
- en: import glfw
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: import glfw
- en: from torus import Torus
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 torus 的 Torus
- en: from camera import OrbitCamera
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 camera 的 OrbitCamera
- en: from gol import GOL
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 gol 的 GOL
- en: 'class RenderWindow:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 'class RenderWindow:'
- en: '"""GLFW Rendering window class"""'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '"""GLFW 渲染窗口类"""'
- en: 'def __init__(self, glider):'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, glider):'
- en: '# save current working directory'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '# 保存当前工作目录'
- en: cwd = os.getcwd()
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: cwd = os.getcwd()
- en: '# initialize glfw - this changes cwd'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '# 初始化glfw - 这会改变cwd'
- en: glfw.glfwInit()
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: glfw.glfwInit()
- en: '# restore cwd'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '# 恢复cwd'
- en: os.chdir(cwd)
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: os.chdir(cwd)
- en: '# version hints'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '# 版本提示'
- en: glfw.glfwWindowHint(glfw.GLFW_CONTEXT_VERSION_MAJOR, 3)
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: glfw.glfwWindowHint(glfw.GLFW_CONTEXT_VERSION_MAJOR, 3)
- en: glfw.glfwWindowHint(glfw.GLFW_CONTEXT_VERSION_MINOR, 3)
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: glfw.glfwWindowHint(glfw.GLFW_CONTEXT_VERSION_MINOR, 3)
- en: glfw.glfwWindowHint(glfw.GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE)
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: glfw.glfwWindowHint(glfw.GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE)
- en: glfw.glfwWindowHint(glfw.GLFW_OPENGL_PROFILE, glfw.GLFW_OPENGL_CORE_PROFILE)
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: glfw.glfwWindowHint(glfw.GLFW_OPENGL_PROFILE, glfw.GLFW_OPENGL_CORE_PROFILE)
- en: '# make a window'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '# 创建一个窗口'
- en: self.width, self.height = 640, 480
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: self.width, self.height = 640, 480
- en: self.aspect = self.width/float(self.height)
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: self.aspect = self.width/float(self.height)
- en: self.win = glfw.glfwCreateWindow(self.width, self.height, b'gol_torus')
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: self.win = glfw.glfwCreateWindow(self.width, self.height, b'gol_torus')
- en: '# make context current'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '# 使上下文当前'
- en: glfw.glfwMakeContextCurrent(self.win)
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: glfw.glfwMakeContextCurrent(self.win)
- en: '# initialize GL'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '# 初始化GL'
- en: glViewport(0, 0, self.width, self.height)
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: glViewport(0, 0, self.width, self.height)
- en: glEnable(GL_DEPTH_TEST)
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: glEnable(GL_DEPTH_TEST)
- en: '#glClearColor(0.2, 0.2, 0.2, 1.0)'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '#glClearColor(0.2, 0.2, 0.2, 1.0)'
- en: glClearColor(0.11764706, 0.11764706, 0.11764706, 1.0)
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: glClearColor(0.11764706, 0.11764706, 0.11764706, 1.0)
- en: '# set window callbacks'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置窗口回调'
- en: glfw.glfwSetMouseButtonCallback(self.win, self.onMouseButton)
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: glfw.glfwSetMouseButtonCallback(self.win, self.onMouseButton)
- en: glfw.glfwSetKeyCallback(self.win, self.onKeyboard)
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: glfw.glfwSetKeyCallback(self.win, self.onKeyboard)
- en: '# create 3D'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '# 创建 3D'
- en: NX = 64
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: NX = 64
- en: NY = 64
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: NY = 64
- en: R = 4.0
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: R = 4.0
- en: r = 1.0
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: r = 1.0
- en: self.torus = Torus(R, r, NX, NY)
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: self.torus = Torus(R, r, NX, NY)
- en: self.gol = GOL(NX, NY, glider)
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: self.gol = GOL(NX, NY, glider)
- en: '# create a camera'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '# 创建相机'
- en: self.camera = OrbitCamera(5.0, 10.0)
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: self.camera = OrbitCamera(5.0, 10.0)
- en: '# exit flag'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '# 退出标志'
- en: self.exitNow = False
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: self.exitNow = False
- en: '# rotation flag'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '# 旋转标志'
- en: self.rotate = True
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: self.rotate = True
- en: '# skip count'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '# 跳过计数'
- en: self.skip = 0
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: self.skip = 0
- en: 'def onMouseButton(self, win, button, action, mods):'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 'def onMouseButton(self, win, button, action, mods):'
- en: '# print ''mouse button: '', win, button, action, mods'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '# 打印 ''mouse button: '', win, button, action, mods'
- en: pass
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: pass
- en: 'def onKeyboard(self, win, key, scancode, action, mods):'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 'def onKeyboard(self, win, key, scancode, action, mods):'
- en: '# print ''keyboard: '', win, key, scancode, action, mods'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '# 打印 ''keyboard: '', win, key, scancode, action, mods'
- en: 'if action == glfw.GLFW_PRESS:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 'if action == glfw.GLFW_PRESS:'
- en: '# ESC to quit'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '# 按 ESC 退出'
- en: 'if key == glfw.GLFW_KEY_ESCAPE:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 'if key == glfw.GLFW_KEY_ESCAPE:'
- en: self.exitNow = True
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: self.exitNow = True
- en: 'elif key == glfw.GLFW_KEY_R:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif key == glfw.GLFW_KEY_R:'
- en: self.rotate = not self.rotate
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: self.rotate = not self.rotate
- en: 'def run(self):'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 'def run(self):'
- en: '# initializer timer'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '# 初始化计时器'
- en: glfw.glfwSetTime(0)
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: glfw.glfwSetTime(0)
- en: t = 0.0
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: t = 0.0
- en: 'while not glfw.glfwWindowShouldClose(self.win) and not self.exitNow:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 'while not glfw.glfwWindowShouldClose(self.win) and not self.exitNow:'
- en: '# update every x seconds'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '# 每 x 秒更新'
- en: currT = glfw.glfwGetTime()
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: currT = glfw.glfwGetTime()
- en: 'if currT - t > 0.05:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 'if currT - t > 0.05:'
- en: '# update time'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '# 更新时间'
- en: t = currT
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: t = currT
- en: '# set viewport'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置视口'
- en: self.width, self.height = glfw.glfwGetFramebufferSize(self.win)
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: self.width, self.height = glfw.glfwGetFramebufferSize(self.win)
- en: self.aspect = self.width/float(self.height)
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: self.aspect = self.width/float(self.height)
- en: glViewport(0, 0, self.width, self.height)
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: glViewport(0, 0, self.width, self.height)
- en: '# clear'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '# 清理'
- en: glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
- en: '# build projection matrix'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '# 构建投影矩阵'
- en: pMatrix = glutils.perspective(60.0, self.aspect, 0.1, 100.0)
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: pMatrix = glutils.perspective(60.0, self.aspect, 0.1, 100.0)
- en: mvMatrix = glutils.lookAt(self.camera.eye, self.camera.center, self.camera.up)
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: mvMatrix = glutils.lookAt(self.camera.eye, self.camera.center, self.camera.up)
- en: '# render'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '# 渲染'
- en: self.torus.render(pMatrix, mvMatrix)
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: self.torus.render(pMatrix, mvMatrix)
- en: '# step'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '# 步骤'
- en: 'if self.rotate:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 'if self.rotate:'
- en: self.step()
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: self.step()
- en: glfw.glfwSwapBuffers(self.win)
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: glfw.glfwSwapBuffers(self.win)
- en: '# poll for and process events'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '# 轮询并处理事件'
- en: glfw.glfwPollEvents()
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: glfw.glfwPollEvents()
- en: '# end'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '# 结束'
- en: glfw.glfwTerminate()
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: glfw.glfwTerminate()
- en: 'def step(self):'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 'def step(self):'
- en: 'if self.skip == 9:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 'if self.skip == 9:'
- en: '# update GOL'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '# 更新 GOL'
- en: self.gol.update()
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: self.gol.update()
- en: colors = self.gol.get_colors()
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: colors = self.gol.get_colors()
- en: self.torus.set_colors(colors)
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: self.torus.set_colors(colors)
- en: '# step'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '# 步骤'
- en: self.torus.step()
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: self.torus.step()
- en: '# reset'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '# 重置'
- en: self.skip = 0
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: self.skip = 0
- en: '# update skip'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '# 更新跳过'
- en: self.skip += 1
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: self.skip += 1
- en: '# rotate camera'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '# 旋转相机'
- en: self.camera.rotate()
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: self.camera.rotate()
- en: main() function
  id: totrans-377
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: main() 函数
- en: 'def main():'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 'def main():'
- en: print("Starting GOL. Press ESC to quit.")
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: print("开始 GOL。按 ESC 退出。")
- en: '# parse arguments'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '# 解析参数'
- en: parser = argparse.ArgumentParser(description="Runs Conway's Game of Life simulation
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: parser = argparse.ArgumentParser(description="运行康威的生命游戏模拟")
- en: on a Torus.")
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Torus 上。)
- en: '# add arguments'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '# 添加参数'
- en: parser.add_argument('--glider', action='store_true', required=False)
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: parser.add_argument('--glider', action='store_true', required=False)
- en: args = parser.parse_args()
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: args = parser.parse_args()
- en: '# set args'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置参数'
- en: glider = False
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: glider = False
- en: 'if args.glider:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 'if args.glider:'
- en: glider = True
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: glider = True
- en: rw = RenderWindow(glider)
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: rw = RenderWindow(glider)
- en: rw.run()
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: rw.run()
- en: call main
  id: totrans-392
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用 main
- en: 'if __name__ == ''__main__'':'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: main()
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: main()
