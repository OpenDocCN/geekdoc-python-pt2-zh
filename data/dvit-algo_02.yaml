- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Maximizing and Minimizing
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 最大化与最小化
- en: '![](Images/circleart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/circleart.png)'
- en: Goldilocks preferred the middle, but in the world of algorithms we’re usually
    more interested in the extreme highs and lows. Some powerful algorithms enable
    us to reach maxima (for example, maximum revenue, maximum profits, maximum efficiency,
    maximum productivity) and minima (for example, minimum cost, minimum error, minimum
    discomfort, and minimum loss). This chapter covers gradient ascent and gradient
    descent, two simple but effective methods to efficiently find maxima and minima
    of functions. We also discuss some of the issues that come with maximization and
    minimization problems, and how to deal with them. Finally, we discuss how to know
    whether a particular algorithm is appropriate to use in a given situation. We’ll
    start with a hypothetical scenario—trying to set optimal tax rates to maximize
    a government’s revenues—and we’ll see how to use an algorithm to find the right
    solution.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 金发姑娘偏爱中间的选项，但在算法的世界里，我们通常更关心极端的高值和低值。一些强大的算法能够帮助我们找到极值（例如，最大收入、最大利润、最大效率、最大生产力）和极小值（例如，最小成本、最小错误、最小不适、最小损失）。本章介绍了梯度上升和梯度下降两种简单但有效的方法，用于高效地找到函数的极值点。我们还讨论了最大化和最小化问题中出现的一些问题，以及如何处理这些问题。最后，我们讨论了如何判断某个算法是否适合在特定情况下使用。我们将从一个假设场景开始——尝试设定最优税率以最大化政府收入——并看看如何使用算法找到正确的解决方案。
- en: Setting Tax Rates
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置税率
- en: Imagine that you’re elected prime minister of a small country. You have ambitious
    goals, but you don’t feel like you have the budget to achieve them. So your first
    order of business after taking office is to maximize the tax revenues your government
    brings in.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你被选为一个小国的总理。你有雄心勃勃的目标，但你觉得自己的预算不足以实现它们。所以你上任后的第一项工作就是最大化政府的税收收入。
- en: It’s not obvious what taxation rate you should choose to maximize revenues.
    If your tax rate is 0 percent, you will get zero revenue. At 100 percent, it seems
    likely that taxpayers would avoid productive activity and assiduously seek tax
    shelters to the point that revenue would be quite close to zero. Optimizing your
    revenue will require finding the right balance between rates that are so high
    that they discourage productive activity and rates that are so low that they undercollect.
    To achieve that balance is, you’ll need to know more about the way tax rates relate
    to revenue.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 要最大化收入，选择什么样的税率并不显而易见。如果税率为0%，你将获得零收入。如果税率为100%，看起来纳税人很可能会避免生产性活动，拼命寻找避税工具，以至于收入可能接近零。优化收入将需要找到一个正确的平衡点，在这个平衡点上，税率既不会高到让生产性活动受到抑制，也不会低到导致收入不足。要实现这种平衡，你需要了解税率与收入之间的关系。
- en: Steps in the Right Direction
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 正确方向的步骤
- en: Suppose that you discuss this with your team of economists. They see your point
    and retire to their research office, where they consult the apparatuses used by
    top-level research economists everywhere—mostly test tubes, hamsters running on
    wheels, astrolabes, and dowsing rods—to determine the precise relationship between
    tax rates and revenues.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你和你的经济学团队讨论了这个问题。他们理解你的观点后，便回到他们的研究办公室，在那里他们使用了顶级研究经济学家们普遍使用的工具——主要是试管、在跑步机上跑的仓鼠、星盘和占卜棒——来确定税率和收入之间的确切关系。
- en: 'After some time thus sequestered, the team tells you that they’ve determined
    a function that relates the taxation rate to the revenue collected, and they’ve
    been kind enough to write it in Python for you. Maybe the function looks like
    the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一段时间的隔离后，团队告诉你他们已经确定了一个将税率与税收收入相关联的函数，并且他们很友好地用Python为你编写了这个函数。也许这个函数看起来如下所示：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is a Python function that takes `tax` as its argument and returns a numeric
    output. The function itself is stored in a variable called `revenue`. You fire
    up Python to generate a simple graph of this curve, entering the following in
    the console. Just as in Chapter 1, we’ll use the `matplotlib` module for its plotting
    capabilities.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个Python函数，它以`tax`为参数并返回一个数值输出。这个函数本身存储在一个名为`revenue`的变量中。你启动Python来生成这个曲线的简单图表，在控制台中输入以下内容。就像在第一章中一样，我们将使用`matplotlib`模块来绘制图表。
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This plot shows the revenues (in billions of your country’s currency) that
    your team of economists expects for each tax rate between 0 and 1 (where 1 represents
    a 100 percent tax rate). If your country currently has a flat 70 percent tax on
    all income, we can add two lines to our code to plot that point on the curve as
    follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图表展示了你们经济学家团队预计在0到1之间各个税率下的收入（单位为你国家的货币，单位为十亿）。其中1代表100%的税率。如果你们国家当前对所有收入实行70%的统一税率，我们可以在代码中添加两行来将该点绘制在曲线上，代码如下：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The final output is the simple plot in [Figure 3-1](#figure3-1).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 最终输出是图 [Figure 3-1](#figure3-1) 中的简单图表。
- en: '![figure_3-1](Images/figure_3-1.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![figure_3-1](Images/figure_3-1.png)'
- en: '[Figure 3-1:](#figureanchor3-1) The relationship between tax rates and revenue,
    with a dot representing your country’s current situation'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[Figure 3-1:](#figureanchor3-1) 税率与收入之间的关系，图中的点表示你们国家当前的情况'
- en: Your country’s current tax rate, according to the economists’ formula, is not
    quite maximizing the government’s revenue. Although a simple visual inspection
    of the plot will indicate approximately what level corresponds to the maximum
    revenue, you are not satisfied with loose approximations and you want to find
    a more precise figure for the optimal tax rate. It’s apparent from the plot of
    the curve that any increase from the current 70 percent rate should decrease total
    revenues, and some amount of decrease from the current 70 percent rate should
    increase total revenues, so in this situation, revenue maximization will require
    a decrease in the overall tax rate.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 根据经济学家的公式，你们国家当前的税率并没有完全最大化政府的收入。尽管通过简单地视觉检查图表，可以大致判断哪个税率对应最大收入，但你不满足于粗略的估算，想要找到更精确的最优税率。通过曲线图可以明显看出，从当前70%的税率开始，任何增加都将导致总收入下降，而任何减少都会增加总收入，因此，在这种情况下，收入最大化需要降低总体税率。
- en: 'We can verify whether this is true more formally by taking the derivative of
    the economists’ revenue formula. A *derivative* is a measurement of the slope
    of a tangent line, with large values denoting steepness and negative values denoting
    downward motion. You can see an illustration of a derivative in [Figure 3-2](#figure3-2):
    it’s just a way to measure how quickly a function is growing or shrinking.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过更正式的方式验证这一点，即求经济学家收入公式的导数。*导数*是切线的斜率度量，较大的值表示陡峭，负值表示向下运动。你可以在 [Figure
    3-2](#figure3-2) 中看到导数的示意图：它只是用来衡量一个函数增长或收缩的速度。
- en: '![figure_3-2](Images/figure_3-2.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![figure_3-2](Images/figure_3-2.png)'
- en: '[Figure 3-2:](#figureanchor3-2) To calculate a derivative, we take a tangent
    line to a curve at a point and find its slope.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '[Figure 3-2:](#figureanchor3-2) 为了计算导数，我们在曲线的某个点上取切线并找出其斜率。'
- en: 'We can create a function in Python that specifies this derivative as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 Python 中创建一个函数来指定这个导数，代码如下：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We used four rules of calculus to derive that function. First, we used the
    rule that the derivative of *log*(*x*) is 1/*x*. That’s why the derivative of
    *log*(*tax* + 1) is 1/(*tax* + 1). Another rule is that the derivative of *x*²
    is 2*x*. That’s why the derivative of (*tax* – 0.2)² is 2(*tax* – 0.2). Two more
    rules are that the derivative of a constant number is always 0, and the derivative
    of 100*f*(*x*) is 100 times the derivative of *f*(*x*). If you combine all these
    rules, you’ll find that our tax-revenue function, 100(*log*(*tax* + 1) – (*tax*
    – 0.2)² + 0.04), has a derivative equal to the following, as described in the
    Python function:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了四条微积分规则来推导这个函数。首先，我们使用了*log*(*x*)的导数是1/*x*的规则。正因为如此，*log*(*tax* + 1)的导数是1/(*tax*
    + 1)。另一个规则是*x*²的导数是2*x*。因此，(*tax* – 0.2)²的导数是2(*tax* – 0.2)。另外还有两个规则：常数的导数永远是0，100*f*(*x*)的导数是100乘以*f*(*x*)的导数。将这些规则结合起来，你会发现我们的税收-收入函数，100(*log*(*tax*
    + 1) – (*tax* – 0.2)² + 0.04)，其导数如下所示，正如Python函数中所描述的那样：
- en: '![c03eq001](Images/c03eq001.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![c03eq001](Images/c03eq001.png)'
- en: 'We can check that the derivative is indeed negative at the country’s current
    taxation rate:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以检查该国当前税率下的导数确实是负值：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This gives us the output `-41.17647`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给我们输出`-41.17647`。
- en: A negative derivative means that an increase in tax rate leads to a decrease
    in revenue. By the same token, a decrease in tax rate should lead to an increase
    in revenue. While we are not yet sure of the precise tax rate corresponding to
    the maximum of the curve, we can at least be sure that if we take a small step
    from where are in the direction of decreased taxation, revenue should increase.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 负导数意味着提高税率会导致收入减少。反之，降低税率应该会导致收入增加。虽然我们还不确定与曲线最大值对应的准确税率，但我们可以至少确信，如果我们从当前位置朝着减少税收的方向迈出一小步，收入应该会增加。
- en: 'To take a step toward the revenue maximum, we should first specify a step size.
    We can store a prudently small step size in a variable in Python as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了朝着收入最大值迈出一步，我们首先应当指定一个步长。在 Python 中，我们可以将一个适当小的步长存储在一个变量中，如下所示：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, we can take a step in the direction of the maximum by finding a new rate
    that is proportional to one step size away from our current rate, in the direction
    of the maximum:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以通过找到一个新的税率，使得它与当前税率之间的差距与一个步长成比例，从而朝着最大值的方向迈出一步：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Our process so far is that we start at our current tax rate and take a step
    toward the maximum whose size is proportional to the `step_size` we chose and
    whose direction is determined by the derivative of the tax-revenue function at
    the current rate.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的过程是从当前的税率开始，朝着最大值迈出一步，这一步的大小与我们选择的`step_size`成正比，方向由当前税率下税收函数的导数决定。
- en: 'We can verify that after this step, the new `current_rate` is `0.6588235` (about
    a 66 percent tax rate), and the revenue corresponding to this new rate is `33.55896`.
    But while we have taken a step toward the maximum and increased the revenue, but
    we find ourselves in essentially the same situation as before: we are not yet
    at the maximum, but we know the derivative of the function and the general direction
    in which we should travel to get there. So we simply need to take another step,
    exactly as before but with the values representing the new rate. Yet again we
    set:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以验证，在这一步之后，新的`current_rate`是`0.6588235`（大约是 66%的税率），对应的新税率的收入是`33.55896`。但是，虽然我们朝着最大值迈出了步伐并增加了收入，但我们发现自己基本上处于与之前相同的情况：我们还没有到达最大值，但我们知道了函数的导数以及我们应该朝哪个方向走才能达到最大值。所以，我们只需要再迈出一步，就像之前一样，不过这次是使用代表新税率的值。再次设置：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: After running this again, we find that the new `current_rate` is `0.6273425`,
    and the revenue corresponding to this new rate is `34.43267`. We have taken another
    step in the right direction. But we are still not at the maximum revenue rate,
    and we will have to take another step to get closer.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行后，我们发现新的`current_rate`是`0.6273425`，对应的新税率的收入是`34.43267`。我们在正确的方向上迈出了另一 步。但我们仍然没有到达最大收入税率，我们还需要再迈出一步才能更接近。
- en: Turning the Steps into an Algorithm
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将步骤转化为算法
- en: 'You can see the pattern that is emerging. We’re following these steps repeatedly:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到正在出现的模式。我们正在重复执行以下步骤：
- en: Start with a `current_rate` and a `step_size`.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从一个`current_rate`和`step_size`开始。
- en: Calculate the derivative of the function you are trying to maximize at the `current_rate`.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算你试图最大化的函数在`current_rate`处的导数。
- en: Add `step_size``*``revenue_derivative`(`current_rate`) to the current rate,
    to get a new `current_rate`.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`step_size` * `revenue_derivative`(`current_rate`)加到当前税率，得到新的`current_rate`。
- en: Repeat steps 2 and 3.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复步骤 2 和 3。
- en: 'The only thing that’s missing is a rule for when to stop, a rule that triggers
    when we have reached the maximum. In practice, it’s quite likely that we’ll be
    *asymptotically* approaching the maximum: getting closer and closer to it but
    always remaining microscopically distant. So although we may never reach the maximum,
    we can get close enough that we match it up to 3 or 4 or 20 decimal places. We
    will know when we are sufficiently close to the asymptote when the amount by which
    we change our rate is very small. We can specify a threshold for this in Python:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一缺少的就是一个停止规则，一个在达到最大值时触发的规则。实际上，我们很可能会*渐近*地接近最大值：越来越接近它，但始终保持微小的距离。因此，虽然我们可能永远无法达到最大值，但我们可以接近它，精确到
    3 位、4 位或 20 位小数。当我们离渐近线足够近时，我们就知道停止了，这时我们改变税率的幅度非常小。我们可以在 Python 中为此指定一个阈值：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Our plan is to stop our process when we are changing the rate by less than this
    amount at each iteration of our process. It’s possible that our step-taking process
    will never converge to the maximum we are seeking, so if we set up a loop, we’ll
    get stuck in an infinite loop. To prepare for this possibility, we’ll specify
    a number of “maximum iterations,” and if we take a number of steps equal to this
    maximum, we’ll simply give up and stop.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的计划是，当我们每次迭代中税率变化的幅度小于某个量时停止过程。可能我们的步骤过程永远无法收敛到我们期望的最大值，所以如果我们设置一个循环，可能会陷入无限循环。为此，我们会指定一个“最大迭代次数”，如果我们达到这个最大次数，就会放弃并停止。
- en: Now, we can put all these steps together ([Listing 3-1](#listing3-1)).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将所有这些步骤汇总在一起（[清单 3-1](#listing3-1)）。
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[Listing 3-1:](#listinganchor3-1) Implementing gradient ascent'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 3-1:](#listinganchor3-1) 实现梯度上升法'
- en: 'After running this code, you’ll find that the revenue-maximizing tax rate is
    about `0.528`. What we’ve done in [Listing 3-1](#listing3-1) is something called
    *gradient ascent*. It’s called that because it’s used to ascend to a maximum,
    and it determines the direction of movement by taking the gradient. (In a two-dimensional
    case like ours, a gradient is simply called a derivative.) We can write out a
    full list of the steps we followed here, including a description of our stopping
    criteria:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这段代码后，你会发现收入最大化的税率大约是`0.528`。我们在[清单 3-1](#listing3-1)中做的就是所谓的*梯度上升法*。之所以这么叫，是因为它被用来“上升”到一个最大值，并通过计算梯度来确定移动的方向。（在像我们这样二维的情况下，梯度就叫做导数。）我们可以将我们遵循的步骤完整列出，包括停止标准的描述：
- en: Start with a `current_rate` and a `step_size`.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从一个`current_rate`和`step_size`开始。
- en: Calculate the derivative of the function you are trying to maximize at the `current_rate`.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算你试图最大化的函数在`current_rate`处的导数。
- en: Add `step_size * revenue_derivative`(`current_rate`) to the current rate, to
    get a new `current_rate`.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`step_size * revenue_derivative`(`current_rate`)加到当前税率上，得到一个新的`current_rate`。
- en: Repeat steps 2 and 3 until you are so close to the maximum that your current
    tax rate is changing less than a very small threshold at each step, or until you
    have reached a number of iterations that is sufficiently high.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复步骤 2 和 3，直到你接近最大值，使得每次步骤中当前税率的变化小于一个非常小的阈值，或者直到你达到足够高的迭代次数。
- en: Our process can be written out simply, with only four steps. Though humble in
    appearance and simple in concept, gradient ascent is an algorithm, just like the
    algorithms described in previous chapters. Unlike most of those algorithms, though,
    gradient ascent is in common use today and is a key part of many of the advanced
    machine learning methods that professionals use daily.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的过程可以简单地用四个步骤来写。尽管它外观简朴、概念简单，梯度上升法依然是一个算法，就像前几章中描述的算法一样。然而，与大多数这些算法不同，梯度上升法今天被广泛应用，并且是许多专业人员日常使用的高级机器学习方法的关键部分。
- en: Objections to Gradient Ascent
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对梯度上升法的反对意见
- en: 'We’ve just performed gradient ascent to maximize the revenues of a hypothetical
    government. Many people who learn gradient ascent have practical if not moral
    objections to it. Here are some of the arguments that people raise about gradient
    ascent:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚通过梯度上升法来最大化假设政府的收入。许多学习梯度上升法的人对此有实际的，甚至是道德上的反对。以下是人们对梯度上升法提出的一些论点：
- en: It’s unnecessary because we can do a visual inspection to find the maximum.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这没有必要，因为我们可以通过视觉检查来找到最大值。
- en: It’s unnecessary because we can do repeated guesses, a guess-and-check strategy,
    to find the maximum.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这没有必要，因为我们可以通过反复猜测、一种猜测与检查的策略来找到最大值。
- en: It’s unnecessary because we can solve the first-order conditions.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这没有必要，因为我们可以解一阶条件。
- en: 'Let’s consider each of these objections in turn. We discussed visual inspection
    previously. For our taxation/revenue curve, it’s easy to get an approximate idea
    of the location of a maximum through visual inspection. But visual inspection
    of a plot does not enable high precision. More importantly, our curve is extremely
    simple: it can be plotted in two dimensions and obviously has only one maximum
    on the range that interests us. If you imagine more complex functions, you can
    start to see why visual inspection is not a satisfactory way to find the maximum
    value of a function.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们依次考虑这些反对意见。我们之前讨论过视觉检查。对于我们的税收/收入曲线，通过视觉检查很容易大致判断出最大值的位置。但对图表的视觉检查并不能提供高精度的结果。更重要的是，我们的曲线非常简单：它可以在二维中绘制，并且在我们关心的范围内显然只有一个最大值。如果你想象更复杂的函数，就会明白为什么视觉检查不能作为找到函数最大值的有效方法。
- en: For example, consider a multidimensional case. If our economists had concluded
    that revenue depended not only on tax rates but also on tariff rates, then our
    curve would have to be drawn in three dimensions, and if it were a complex function,
    it could be harder to see where the maximum lies. If our economists had created
    a function that related 10 or 20 or a 100 predictors to expected revenue, it would
    not be possible to draw a plot of all of them simultaneously given the limitations
    of our universe, our eyes, and our brains. If we couldn’t even draw the tax/revenue
    curve, then there’s no way visual inspection could enable us to find its maximum.
    Visual inspection works for simple toy examples like the tax/revenue curve, but
    not for highly complex multidimensional problems. Besides all of that, plotting
    a curve itself requires calculating the function’s value at every single point
    of interest, so it always takes longer than a well-written algorithm.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个多维的情况。如果我们的经济学家得出结论，认为收入不仅依赖于税率，还依赖于关税率，那么我们的曲线就必须在三维中绘制。如果它是一个复杂的函数，可能会更难看出最大值的位置。如果我们的经济学家构造了一个将10个、20个甚至100个预测变量与预期收入相关联的函数，那么根据我们宇宙、眼睛和大脑的局限性，我们就无法同时绘制所有这些函数图。如果我们甚至无法绘制税收/收入曲线，那么视觉检查就不可能帮助我们找到它的最大值。视觉检查适用于像税收/收入曲线这样简单的示例，但不适用于高度复杂的多维问题。除此之外，绘制曲线本身需要计算每一个感兴趣点的函数值，因此总是比一个写得好的算法花费更多的时间。
- en: It may seem that gradient ascent is overcomplicating the issue, and that a guess-and-check
    strategy is sufficient for finding the maximum. A guess-and-check strategy would
    consist of guessing a potential maximum and checking whether it is higher than
    all previously guessed candidate maxima until we are confident that we have found
    the maximum. One potential reply to this is to point out that, just as with visual
    inspections, with high-complexity multidimensional functions, guess-and-check
    could be prohibitively difficult to successfully implement in practice. But the
    best reply to the idea of guessing and checking to find maxima is that this is
    exactly what gradient ascent is *already doing*. Gradient ascent already is a
    guess-and-check strategy, but one that is “guided” by moving guesses in the direction
    of the gradient rather than by guessing randomly. Gradient ascent is just a more
    efficient version of guess-and-check.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 可能看起来梯度上升使问题变得过于复杂，而猜测检查策略就足以找到最大值。猜测检查策略包括猜测一个潜在的最大值，并检查它是否高于所有先前猜测的候选最大值，直到我们确信找到了最大值。对此，一种可能的回应是指出，就像视觉检查一样，对于高复杂度的多维函数，猜测检查在实践中可能会变得过于困难。然而，针对猜测检查法来找最大值的最好回应是，这正是梯度上升*已经在做的事*。梯度上升本质上就是一种猜测检查策略，但它是通过沿着梯度的方向移动猜测，而不是随机猜测，从而“引导”猜测。梯度上升只是猜测检查的一个更高效的版本。
- en: 'Finally, consider the idea of solving the first-order conditions to find a
    maximum. This is a method that is taught in calculus classes all around the world.
    It could be called an algorithm, and its steps are:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，考虑通过求解一阶条件来找到最大值的思路。这是世界各地微积分课程中教授的一种方法。它可以被称为一种算法，其步骤是：
- en: Find the derivative of the function you are trying to maximize.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到你要最大化的函数的导数。
- en: Set that derivative equal to zero.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将该导数设为零。
- en: Solve for the point at which the derivative is equal to zero.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 求解使导数为零的点。
- en: Make sure that point is a maximum rather than a minimum.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保该点是最大值而不是最小值。
- en: (In multiple dimensions, we can work with a gradient instead of a derivative
    and perform an analogous process.) This optimization algorithm is fine as far
    as it goes, but it could be difficult or impossible to find a closed-form solution
    for which a derivative is equal to zero (step 2), and it could be harder to find
    that solution than it would be to simply perform gradient ascent. Besides that,
    it could take huge computing resources, including space, processing power, or
    time, and not all software has symbolic algebra capabilities. In that sense, gradient
    ascent is more robust than this algorithm.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: （在多维空间中，我们可以使用梯度而不是导数，并执行类似的过程。）这个优化算法在其适用范围内是有效的，但可能很难或者无法找到一个闭式解，使得导数为零（步骤
    2），而且找到这个解可能比简单地执行梯度上升更为困难。此外，它可能需要大量的计算资源，包括空间、处理能力或时间，并且并非所有软件都具有符号代数能力。从这个角度来看，梯度上升比这个算法更为稳健。
- en: The Problem of Local Extrema
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 局部极值问题
- en: 'Every algorithm that tries to find a maximum or minimum faces a very serious
    potential problem with local extrema (local maximums and minimums). We may perform
    gradient ascent perfectly, but realize that the peak we have reached at the end
    is only a “local” peak—it’s higher than every point around it, but not higher
    than some faraway global maximum. This could happen in real life as well: you
    try to climb a mountain, you reach a summit where you are higher than all of your
    immediate surroundings, but you realize that you’re only on the foothill and the
    real summit is far away and much higher. Paradoxically, you may have to walk down
    a little to eventually get to that higher summit, so the “naive” strategy that
    gradient ascent follows, always stepping to a slightly higher point in one’s immediate
    neighborhood, fails to get to the global maximum.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 任何尝试寻找最大值或最小值的算法都面临着局部极值（局部最大值和最小值）的严重潜在问题。我们可能完美地执行了梯度上升，但最终意识到我们达到的顶点只是一个“局部”峰值——它比周围的每个点都高，但比某个远处的全局最大值要低。这种情况在现实生活中也可能发生：你尝试攀登一座山峰，虽然你到达的山顶比周围所有地方都高，但你意识到你只是在山脚下，真正的山顶还远远在上方，而且更高。具有讽刺意味的是，你可能需要稍微下山一点才能到达更高的山顶，因此梯度上升所遵循的“天真”策略——始终向稍微更高的邻近点迈进——无法达到全局最大值。
- en: Education and Lifetime Income
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 教育与终身收入
- en: 'Local extrema are a very serious problem in gradient ascent. As an example,
    consider trying to maximize lifelong income by choosing the optimal level of education.
    In this case, we might suppose that lifelong earnings relate to years of education
    according to the following formula:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 局部极值是梯度上升中的一个非常严重的问题。举个例子，假设我们尝试通过选择最优的教育水平来最大化终身收入。在这种情况下，我们可能假设终身收入与教育年限之间存在如下公式关系：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here, `edu_yrs` is a variable expressing how many years of education one has
    received, and `income` is a measurement of one’s lifetime income. We can plot
    this curve as follows, including a point for a person who has 12.5 years of formal
    education—that is, someone who has graduated from high school (12 years of formal
    education) and is half a year into a bachelor’s degree program:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`edu_yrs`是一个变量，表示一个人接受了多少年的教育，而`income`是衡量一个人终身收入的标准。我们可以按照以下方式绘制这条曲线，包括一个拥有12.5年正式教育的人的数据点——也就是一个高中毕业生（12年正式教育），并且已经完成了半年的本科学位课程：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We get the graph in [Figure 3-3](#figure3-3).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[图 3-3](#figure3-3)中得到了这个图。
- en: '![figure_3-3](Images/figure_3-3.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![figure_3-3](Images/figure_3-3.png)'
- en: '[Figure 3-3:](#figureanchor3-3) The relationship between formal education and
    lifetime income'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3-3:](#figureanchor3-3) 正式教育与终身收入的关系'
- en: This graph, and the income function used to generate it, is not based on empirical
    research but is used only as an illustrative, purely hypothetical example. It
    shows what might be intuitive relationships between education and income. Lifetime
    income is likely to be low for someone who does not graduate from high school
    (has fewer than 12 years of formal education). Graduation from high school—12
    years—is an important milestone and should correspond to higher earnings than
    dropping out. In other words, it’s a maximum, but importantly it’s only a local
    maximum. Getting more than 12 years of education is helpful, but not at first.
    Someone who has completed only a few months of college education is not likely
    to get jobs that differ from those available to a high school graduate, but by
    going to school for extra months, they’ve missed an opportunity to earn in those
    months, so their lifetime earnings are actually lower than the earnings of people
    who enter the workforce directly after high school graduation and remain there.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这张图，以及用于生成它的收入函数，并非基于实证研究，而仅作为一个说明性的、纯粹假设性的例子。它展示了教育与收入之间可能的直观关系。对于那些没有高中毕业的人（拥有不到12年正式教育的人），他们的一生收入可能会很低。高中毕业（12年教育）是一个重要的里程碑，应当对应着比辍学者更高的收入。换句话说，这是一个最大值，但值得注意的是，它只是一个局部最大值。获得超过12年的教育是有帮助的，但一开始并不显著。只完成了几个月大学教育的人，可能不会获得与高中毕业生有太大区别的工作机会，但因为多上了几个月的学，他们错过了那些几个月的收入机会，因此他们的终生收入实际上低于那些高中毕业后直接进入职场并一直待在那里的人的收入。
- en: 'Only after several years of college education does someone acquire skills that
    enable them to earn more over a lifetime than a high school graduate after we
    take into account the lost earning potential of the years spent at school. Then,
    college graduates (at 16 years of education) are at another earnings peak higher
    than the local high school peak. Once again, it’s only a local one. Getting a
    little more education after earning a bachelor’s degree leads to the same situation
    as getting a little more education after a high school diploma: you don’t immediately
    acquire enough skills to compensate for the time not spent earning. Eventually,
    that’s reversed, and you reach what looks like another peak after obtaining a
    postgraduate degree. It’s hard to speculate much further beyond that, but this
    simplistic view of education and earnings will suffice for our purposes.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 只有经过几年的大学教育，才能获得那些能够使一个人在一生中赚取比高中毕业生更多的技能——这还考虑到了在学校度过的几年所失去的收入潜力。然后，大学毕业生（拥有16年教育）的收入达到了比本地高中毕业生更高的收入峰值。再次强调，这只是一个局部的峰值。在获得本科学位之后再接受一些教育，和高中毕业后接受更多教育的情况类似：你并不会立即获得足够的技能来弥补那段未能赚取收入的时间。最终，这种情况会发生逆转，在获得研究生学位后，你会达到看似另一个收入峰值。很难再对这个问题做出更多推测，但这个简单的教育与收入的关系可以满足我们的目的。
- en: Climbing the Education Hill—the Right Way
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 攀登教育山丘——正确的方式
- en: For the individual we’ve imagined, drawn at 12.5 years of education on our graph,
    we can perform gradient ascent exactly as outlined previously. [Listing 3-2](#listing3-2)
    has a slightly altered version of the gradient ascent code we introduced in [Listing
    3-1](#listing3-1).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们所想象的个体，其在图表中所代表的是12.5年的教育，我们可以像之前所述的那样执行梯度上升。[列表 3-2](#listing3-2)是我们在[列表
    3-1](#listing3-1)中介绍的梯度上升代码的稍微修改版。
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[Listing 3-2:](#listinganchor3-2) An implementation of gradient ascent that
    climbs an income hill instead of a revenue hill'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 3-2:](#listinganchor3-2) 一种爬升收入山丘而非收入山丘的梯度上升实现'
- en: 'The code in [Listing 3-2](#listing3-2) follows exactly the same gradient ascent
    algorithm as the revenue-maximization process we implemented previously. The only
    difference is the curve we are working with. Our taxation/revenue curve had one
    global maximum value that was also the only local maximum. Our education/income
    curve, by contrast, is more complicated: it has a global maximum, but also several
    local maximum values (local peaks or maxima) that are lower than the global maximum.
    We have to specify the derivative of this education/income curve (in the first
    lines of [Listing 3-2](#listing3-2)), we have a different initial value (12.5
    years of education instead of 70 percent taxation), and we have different names
    for the variables (`current_education` instead of `current_rate`). But these differences
    are superficial; fundamentally we are doing the same thing: taking small steps
    in the direction of the gradient toward a maximum until we reach an appropriate
    stopping point.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 3-2](#listing3-2)中的代码完全遵循了与我们之前实现的收入最大化过程相同的梯度上升算法。唯一的区别是我们所处理的曲线不同。我们的税收/收入曲线有一个全局最大值，同时也是唯一的局部最大值。与此相比，我们的教育/收入曲线更为复杂：它有一个全局最大值，但也有多个局部最大值（局部峰值或极大值），这些局部最大值都低于全局最大值。我们必须指定这条教育/收入曲线的导数（在[Listing
    3-2](#listing3-2)的前几行），我们有不同的初始值（12.5年的教育而不是70%的税率），变量的名称也不同（`current_education`而不是`current_rate`）。但这些差异是表面的；从根本上说，我们做的事情是一样的：在梯度方向上采取小步骤，朝着最大值前进，直到我们达到适当的停止点。'
- en: 'The outcome of this gradient ascent process is that we conclude that this person
    is overeducated, and actually about 12 years is the income-maximizing number of
    years of education. If we are naive and trust the gradient ascent algorithm too
    much, we might recommend that college freshmen drop out and join the workforce
    immediately to maximize earnings at this local maximum. This is a conclusion that
    some college students have come to in the past, as they see their high school–graduate
    friends making more money than them as they work toward an uncertain future. Obviously,
    this is not right: our gradient ascent process has found the top of a local hill,
    but not the global maximum. The gradient ascent process is depressingly local:
    it climbs only the hill it’s on, and it isn’t capable of taking temporary steps
    downward for the sake of eventually getting to another hill with a higher peak.
    There are some analogues to this in real life, as with people who fail to complete
    a university degree because it will prevent them from earning in the near term.
    They don’t consider that their long-term earnings will be improved if they push
    through a local minimum to another hill to climb (their next, more valuable degree).'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这个梯度上升过程的结果是我们得出结论：这个人受教育程度过高，实际上，约12年是收入最大化的教育年限。如果我们过于天真，过度依赖梯度上升算法，我们可能会建议大学新生立刻辍学并加入工作市场，以在这个局部最大值下最大化收入。过去确实有一些大学生得出过这样的结论，因为他们看到自己高中毕业的朋友比他们挣得多，而他们则在为一个不确定的未来努力。显然，这是不对的：我们的梯度上升过程找到了局部山顶，但并没有找到全局最大值。梯度上升过程令人沮丧地局限于局部：它只爬上它所在的山丘，并且无法为了最终到达更高的山顶而暂时向下走一步。生活中也有类似的例子，比如那些因为短期内无法赚到钱而未能完成大学学位的人。他们没有考虑到，如果他们通过局部最低点，继续爬向另一个更高的山丘（他们的下一个、更有价值的学位），长期收入将会提高。
- en: The local extrema problem is a serious one, and there’s no silver bullet for
    resolving it. One way to attack the problem is to attempt multiple initial guesses
    and perform gradient ascent for each of them. For example, if we performed gradient
    ascent for 12.5, 15.5, and 18.5 years of education, we would get different results
    each time, and we could compare these results to see that in fact the global maximum
    comes from maximizing years of education (at least on this scale).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 局部极值问题是一个严峻的问题，并没有什么灵丹妙药来解决它。一种解决问题的方法是尝试多个初始猜测，并对每个初始值执行梯度上升。例如，如果我们对12.5年、15.5年和18.5年的教育年限执行梯度上升，我们每次都会得到不同的结果，然后可以比较这些结果，发现实际上全局最大值是通过最大化教育年限来获得的（至少在这个尺度上）。
- en: This is a reasonable way to deal with the local extremum problem, but it can
    take too long to perform gradient ascent enough times to get the right maximum,
    and we’re never guaranteed to get the right answer even after hundreds of attempts.
    An apparently better way to avoid the problem is to introduce some degree of randomness
    into the process, so that we can sometimes step in a way that leads to a locally
    worse solution, but which in the long term can lead us to better maxima. An advanced
    version of gradient ascent, called *stochastic gradient ascent*, incorporates
    randomness for this reason, and other algorithms, like simulated annealing, do
    the same. We’ll discuss simulated annealing and the issues related to advanced
    optimization in Chapter 6\. For now, just keep in mind that as powerful as gradient
    ascent is, it will always face difficulties with the local extrema problem.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这是处理局部极值问题的一种合理方法，但它可能需要花费过长的时间进行足够多次的梯度上升才能找到正确的最大值，而且即便尝试了数百次，我们也无法保证得到正确的答案。一种看似更好的方法是向过程引入一定程度的随机性，这样我们有时可能会朝着一个局部较差的解迈进，但从长远来看，这样的做法可能会帮助我们找到更好的最大值。梯度上升的高级版本，称为*随机梯度上升*，正是因为这个原因引入了随机性，其他算法，如模拟退火，也采取了类似的做法。我们将在第六章讨论模拟退火和与高级优化相关的问题。现在，只需记住，尽管梯度上升非常强大，但它始终面临局部极值问题的挑战。
- en: From Maximization to Minimization
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从最大化到最小化
- en: 'So far we’ve sought to maximize revenue: to climb a hill and to ascend. It’s
    reasonable to wonder whether we would ever want to go down a hill, to descend
    and to minimize something (like cost or error). You might think that a whole new
    set of techniques is required for minimization or that our existing techniques
    need to be flipped upside down, turned inside out, or run in reverse.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在寻求最大化收入：爬上山顶，向上攀登。合理的疑问是，我们是否曾经想过要下山，下降并最小化某些东西（比如成本或误差）。你可能认为最小化需要一整套新技巧，或者我们现有的技巧需要完全翻转、内外调换，或者反向运行。
- en: 'In fact, moving from maximization to minimization is quite simple. One way
    to do it is to “flip” our function or, more precisely, to take its negative. Going
    back to our tax/revenue curve example, it is as simple as defining a new flipped
    function like so:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，从最大化到最小化是非常简单的。一种方法是“翻转”我们的函数，或者更准确地说，取它的负值。以我们的税收/收入曲线为例，定义一个新的翻转函数就像这样简单：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can then plot the flipped curve as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按如下方式绘制翻转后的曲线：
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[Figure 3-4](#figure3-4) shows the flipped curve.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3-4](#figure3-4) 显示了翻转后的曲线。'
- en: '![figure_3-4](Images/figure_3-4.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![figure_3-4](Images/figure_3-4.png)'
- en: '[Figure 3-4:](#figureanchor3-4) The negative or “flipped” version of the tax/revenue
    curve'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3-4:](#figureanchor3-4) 税收/收入曲线的负值或“翻转”版本'
- en: So if we want to maximize the tax/revenue curve, one option is to minimize the
    flipped tax/revenue curve. If we want to minimize the flipped tax/revenue curve,
    one option is to maximize the flipped flipped curve—in other words, the original
    curve. Every minimization problem is a maximization problem of a flipped function,
    and every maximization problem is a minimization of a flipped function. If you
    can do one, you can do the other (after flipping). Instead of learning to minimize
    functions, you can just learn to maximize them, and every time you are asked to
    minimize, maximize the flipped function instead and you’ll get the right answer.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们想最大化税收/收入曲线，一种选择是最小化翻转后的税收/收入曲线。如果我们想最小化翻转后的税收/收入曲线，一种选择是最大化翻转后的翻转曲线——换句话说，就是原始曲线。每个最小化问题都是翻转函数的最大化问题，每个最大化问题都是翻转函数的最小化问题。如果你能解决一个，你也能解决另一个（在翻转后）。与其学习最小化函数，不如直接学习最大化它们，每次需要最小化时，就去最大化翻转后的函数，你就会得到正确的答案。
- en: 'Flipping is not the only solution. The actual process of minimization is very
    similar to the process of maximization: we can use *gradient descent* instead
    of gradient ascent. The only difference is the direction of movement at each step;
    in gradient descent, we go down instead of up. Remember that to find the maximum
    of the tax/revenue curve, we move in the direction of the gradient. In order to
    minimize, we move in the opposite direction of the gradient. This means we can
    alter our original gradient ascent code as in [Listing 3-3](#listing3-3).'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 翻转并不是唯一的解决方案。实际的最小化过程与最大化过程非常相似：我们可以使用*梯度下降*代替梯度上升。唯一的区别是每一步的移动方向；在梯度下降中，我们是向下而不是向上。记住，为了找到税收/收入曲线的最大值，我们是沿着梯度的方向移动。为了最小化，我们则沿着梯度的反方向移动。这意味着我们可以按照[清单
    3-3](#listing3-3)中的方式修改我们原有的梯度上升代码。
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[Listing 3-3:](#listinganchor3-3) Implementating gradient descent'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 3-3：](#listinganchor3-3) 实现梯度下降'
- en: Here everything is the same except we have changed a `+` to a `-` when we change
    the `current_rate`. By making this very small change, we’ve converted gradient
    ascent code to gradient descent code. In a way, they’re essentially the same thing;
    they use a gradient to determine a direction, and then they move in that direction
    toward a definite goal. In fact, the most common convention today is to speak
    of gradient descent, and to refer to gradient ascent as a slightly altered version
    of gradient descent, the opposite of how this chapter has introduced it.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这里一切相同，只是当我们改变`current_rate`时，将一个`+`改成了`-`。通过这个微小的改变，我们将梯度上升代码转换为梯度下降代码。从某种意义上来说，它们本质上是相同的；它们使用梯度来确定方向，然后朝着这个方向朝着一个确定的目标前进。事实上，现在最常见的惯例是讲梯度下降，而将梯度上升称为梯度下降的稍微修改版本，这与本章介绍的方式相反。
- en: Hill Climbing in General
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一般的爬山算法
- en: 'Being elected prime minister is a rare occurrence, and setting taxation rates
    to maximize government revenue is not an everyday activity even for prime ministers.
    (For the real-life version of the taxation/revenue discussion at the beginning
    of the chapter, I encourage you to look up the Laffer curve.) However, the idea
    of maximizing or minimizing something is extremely common. Businesses attempt
    to choose prices to maximize profits. Manufacturers attempt to choose practices
    that maximize efficiency and minimize defects. Engineers attempt to choose design
    features that maximize performance or minimize drag or cost. Economics is largely
    structured around maximization and minimization problems: maximizing utility especially,
    and also maximizing dollar amounts like GDP and revenue, and minimizing estimation
    error. Machine learning and statistics rely on minimization for the bulk of their
    methods; they minimize a “loss function” or an error metric. For each of these,
    there is the potential to use a hill-climbing solution like gradient ascent or
    descent to get to an optimal solution.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 被选为总理是一个罕见的事件，即使是总理，设定税率以最大化政府收入也不是日常事务。（对于本章开头关于税收/收入讨论的现实版本，我鼓励你查阅拉弗曲线。）然而，最大化或最小化某事的思想是非常常见的。企业试图选择价格以最大化利润。制造商试图选择能够最大化效率并最小化缺陷的做法。工程师试图选择能够最大化性能或最小化阻力或成本的设计特性。经济学在很大程度上是围绕最大化和最小化问题构建的：尤其是最大化效用，也包括最大化像GDP和收入这样的货币金额，以及最小化估计误差。机器学习和统计学的核心方法依赖于最小化；它们最小化一个“损失函数”或误差指标。对于这些问题，都有可能使用类似爬山算法的解决方案，如梯度上升或下降，来获得最优解。
- en: Even in everyday life, we choose how much money to spend to maximize achievement
    of our financial goals. We strive to maximize happiness and joy and peace and
    love and minimize pain and discomfort and sadness.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在日常生活中，我们也会选择花费多少钱，以最大化实现我们的财务目标。我们努力最大化幸福、快乐、和平与爱，同时最小化痛苦、不适和悲伤。
- en: For a vivid and relatable example, think of being at a buffet and seeking, as
    all of us do, to eat the right amount to maximize satisfaction. If you eat too
    little, you will walk out hungry and you may feel that by paying the full buffet
    price for only a little food, you haven’t gotten your money’s worth. If you eat
    too much, you will feel uncomfortable and maybe even sick, and maybe you will
    violate your self-imposed diet. There is a sweet spot, like the peak of the tax/revenue
    curve, that is the exact amount of buffet consumption that maximizes satisfaction.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 举一个生动且容易理解的例子，想象你正在自助餐厅，像我们所有人一样，试图吃到适量的食物以最大化满足感。如果你吃得太少，你会饿着离开，并且可能会觉得花了自助餐的全价却只吃了很少的食物，觉得没物有所值。如果你吃得太多，你会感到不适，甚至可能会生病，可能还会违反你自己制定的饮食计划。总会有一个最佳的平衡点，就像税收/收入曲线的顶点一样，它是最大化满足感的最佳自助餐消费量。
- en: We humans can feel and interpret sensory input from our stomachs that tells
    us whether we’re hungry or full, and this is something like a physical equivalent
    of taking a gradient of a curve. If we’re too hungry, we take some step with a
    predecided size, like one bite, toward reaching the sweet spot of satisfaction.
    If we’re too full, we stop eating; we can’t “un-eat” something we have already
    eaten. If our step size is small enough, we can be confident that we will not
    overstep the sweet spot by much. The process we go through when we are deciding
    how much to eat at a buffet is an iterative process involving repeated direction
    checks and small steps in adjustable directions—in other words, it’s essentially
    the same as the gradient ascent algorithm we studied in this chapter.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们人类能够感知并解读来自我们胃部的感官输入，这些输入告诉我们是饿了还是饱了，这有点像物理上对曲线求梯度的过程。如果我们太饿了，我们就会采取某个预先决定的步伐，比如吃一口，朝着满足的最佳状态迈进。如果我们吃得太饱了，我们就停止进食；我们不能“吃回”已经吃过的东西。如果我们的步伐足够小，我们就能确信自己不会大大超过那个最佳状态。我们在自助餐时决定吃多少的过程是一个迭代过程，涉及反复的方向检查和小步调整——换句话说，它本质上与我们在本章学习的梯度上升算法是一样的。
- en: Just as with the example of catching balls, we see in this buffet example that
    algorithms like gradient ascent are natural to human life and decision-making.
    They are natural to us even if we have never taken a math class or written a line
    of code. The tools in this chapter are merely meant to formalize and make precise
    the intuitions you already have.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 就像捕捉球的例子一样，我们可以在这个自助餐的例子中看到，像梯度上升这样的算法在人的生活和决策中是自然的。即使我们从未上过数学课或写过一行代码，它们对我们来说也是自然的。本章中的工具仅仅是为了使你已经拥有的直觉更加形式化和精确。
- en: When Not to Use an Algorithm
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时不使用算法
- en: Often, learning an algorithm fills us with a feeling of power. We feel that
    if we are ever in a situation that requires maximization or minimization, we should
    immediately apply gradient ascent or descent and implicitly trust whatever results
    we find. However, sometimes more important than knowing an algorithm is knowing
    when not to use it, when it’s inappropriate or insufficient for the task at hand,
    or when there is something better that we should try instead.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 学习一个算法常常让我们感到强大。我们觉得，只要遇到需要最大化或最小化的情况，就应该立刻应用梯度上升或下降，并盲目相信我们找到的任何结果。然而，有时候，比了解一个算法更重要的是知道何时不使用它，何时它不适合当前任务，或者何时有其他更好的方法可以尝试。
- en: 'When should we use gradient ascent (and descent), and when should we not? Gradient
    ascent works well if we start with the right ingredients:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们什么时候应该使用梯度上升（或下降），什么时候又不该使用呢？如果我们从正确的因素开始，梯度上升通常效果很好：
- en: A mathematical function to maximize
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个数学函数来最大化
- en: Knowledge of where we currently are
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解我们当前所处的位置
- en: An unequivocal goal to maximize the function
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个明确的目标来最大化该函数
- en: Ability to alter where we are
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改变我们所处位置的能力
- en: There are many situations in which one or more of these ingredients is missing.
    In the case of setting taxation rates, we used a hypothetical function relating
    tax rates to revenue. However, there’s no consensus among economists about what
    that relationship is and what functional form it takes. So we can perform gradient
    ascent and descent all we like, but until we can all agree on what function we
    need to maximize, we cannot rely on the results we find.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多情况下，其中一个或多个因素是缺失的。在设定税率的案例中，我们使用了一个假设函数，描述税率与收入之间的关系。然而，经济学家们并没有就这种关系及其功能形式达成共识。因此，我们可以尽情地进行梯度上升和下降，但直到我们能够就需要最大化的函数达成一致，我们无法依赖我们所找到的结果。
- en: In other situations, we may find that gradient ascent isn’t very useful because
    we don’t have the ability to take action to optimize our situation. For example,
    suppose that we derived an equation relating a person’s height to their happiness.
    Maybe this function expresses how people who are too tall suffer because they
    cannot get comfortable on airplanes, and people who are too short suffer because
    they cannot excel at pickup basketball games, but some sweet spot in the middle
    of too tall and too short tends to maximize happiness. Even if we can express
    this function perfectly and apply gradient ascent to find the maximum, it will
    not be useful to us, because we do not have control over our height.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他情况下，我们可能会发现梯度上升并不是非常有用，因为我们没有采取行动来优化我们状况的能力。例如，假设我们推导出一个公式，关联了一个人的身高与他们的幸福感。也许这个函数表达了那些身高过高的人因为无法在飞机上舒适地坐着而感到痛苦，而身高过矮的人则因为无法在街头篮球比赛中脱颖而出而感到痛苦，但身高不太高也不太矮的“黄金区间”往往能最大化幸福感。即使我们能够完美地表达这个函数并应用梯度上升找到最大值，这对我们也没有用，因为我们无法控制自己的身高。
- en: If we zoom out even further, we may have all the ingredients required for gradient
    ascent (or any other algorithm) and still wish to refrain for deeper philosophical
    reasons. For example, suppose you can precisely determine a tax-revenue function
    and you’re elected prime minister with full control over the taxation rate in
    your country. Before you apply gradient ascent and climb to the revenue-maximizing
    peak, you may want to ask yourself if maximizing your tax revenue is the right
    goal to pursue in the first place. It could be that you are more concerned with
    freedom or economic dynamism or redistributive justice or even opinion polls than
    you are with state revenues. Even if you have decided that you want to maximize
    revenues, it’s not clear that maximizing revenues in the short term (that is,
    this year) will lead to maximization of revenues in the long term.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们进一步放大视野，可能会发现我们拥有梯度上升（或任何其他算法）所需的所有要素，但仍然因为更深层的哲学原因而选择放弃。例如，假设你能精确地确定税收收入函数，并且你当选为总理，完全控制国家的税率。在你应用梯度上升并攀登到收入最大化的峰值之前，你可能需要问问自己，最大化税收收入是否是一个值得追求的目标。也许你更关心的是自由、经济活力、再分配正义，甚至是民意调查，而不是国家收入。即使你已经决定要最大化收入，最大化短期收入（也就是今年）也不一定能带来长期收入的最大化。
- en: Algorithms are powerful for practical purposes, enabling us to achieve goals
    like catching baseballs and finding revenue-maximizing taxation rates. But though
    algorithms can achieve goals effectively, they’re not as suited to the more philosophical
    task of deciding which goals are worth pursuing in the first place. Algorithms
    can make us clever, but they cannot make us wise. It’s important to remember that
    the great power of algorithms is useless or even harmful if it is used for the
    wrong ends.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 算法在实际应用中非常强大，使我们能够实现诸如接住棒球和寻找最大化税收收入的税率等目标。但尽管算法可以有效地达成目标，它们并不适合用于决定哪些目标值得追求这个更具哲学性的问题。算法可以让我们聪明，但它们无法让我们变得智慧。重要的是要记住，如果算法的巨大力量被用于错误的目的，它是无用的，甚至可能是有害的。
- en: Summary
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter introduced gradient ascent and gradient descent as simple and powerful
    algorithms used to find the maxima and minima of functions, respectively. We also
    talked about the serious potential problem of local extrema, and some philosophical
    considerations about when to use algorithms and when to gracefully refrain.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了梯度上升和梯度下降，作为简单且强大的算法，用于分别找到函数的最大值和最小值。我们还讨论了局部极值可能带来的严重问题，以及在何时使用算法、何时优雅地避免使用算法的一些哲学思考。
- en: Hang on tight, because in the next chapter we discuss a variety of searching
    and sorting algorithms. Searching and sorting are fundamental and important in
    the world of algorithms. We’ll also talk about “big O” notation and the standard
    ways to evaluate algorithm performance.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 紧紧抓住，因为在下一章我们将讨论各种搜索和排序算法。搜索和排序在算法的世界中是基础且重要的内容。我们还会讨论“大 O”符号和评估算法性能的标准方法。
