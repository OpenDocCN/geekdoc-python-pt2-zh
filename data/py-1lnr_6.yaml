- en: '**6'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**6'
- en: ALGORITHMS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**算法**'
- en: '![Image](Images/comm-1.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/comm-1.jpg)'
- en: 'Algorithms are ancient concepts. An *algorithm* is nothing more than a set
    of instructions, much like a cooking recipe. However, the *role* algorithms play
    in society is increasing drastically in importance: algorithms and algorithmic
    decision-making are ubiquitous as computers become a larger and larger part of
    our lives.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 算法是古老的概念。一个*算法*不过是一组指令，就像一份烹饪食谱。然而，*算法*在社会中所扮演的角色正在急剧增加：随着计算机在我们生活中的作用越来越大，算法和算法决策在各个领域无处不在。
- en: A 2018 study highlights that “Data, in the form of observations about our world,
    permeate modern society. . . . This information can in turn be used to make informed—and
    in some cases even fully automated—decisions. . . . It seems likely that such
    algorithms will interface with human decision-making, a development necessary
    to gain societal acceptance and thus wide-scale use.”
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 2018年的一项研究强调了“数据以我们对世界的观察的形式渗透到现代社会中……这些信息反过来可以用来做出有根据的——在某些情况下甚至完全自动化的——决策……看起来这样的算法可能会与人类决策相结合，这是获得社会接受并因此广泛使用的必要发展。”
- en: '**NOTE**'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*For more information on this study, see “The Growing Ubiquity of Algorithms
    in Society: Implications, Impacts, and Innovations” by S. C. Olhede and P. J.
    Wolfe at* [https://royalsocietypublishing.org/doi/full/10.1098/rsta.2017.0364#d2696064e1](https://royalsocietypublishing.org/doi/full/10.1098/rsta.2017.0364#d2696064e1).'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*欲了解更多关于这项研究的信息，请参阅S. C. Olhede和P. J. Wolfe的《算法在社会中的日益普及：影响、冲击与创新》一书，网址为* [https://royalsocietypublishing.org/doi/full/10.1098/rsta.2017.0364#d2696064e1](https://royalsocietypublishing.org/doi/full/10.1098/rsta.2017.0364#d2696064e1)。'
- en: As society undergoes major trends in automation, artificial intelligence, and
    ubiquitous computing, the societal gap between those who understand algorithms
    and those who don’t grows rapidly. For example, the logistics sector undergoes
    a major trend toward automation—with self-driving cars and trucks on the rise—and
    professional drivers face the fact that algorithms take over their jobs.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 随着社会在自动化、人工智能和无处不在的计算的重大趋势下发展，理解算法与不了解算法的人之间的社会差距正在迅速扩大。例如，物流行业正在朝着自动化的方向发展——自动驾驶汽车和卡车的崛起——而专业司机面临着算法接管他们工作的事实。
- en: The constantly shifting landscape of sought-after skills and jobs in the 21st
    century makes it imperative for young people to understand, control, and manipulate
    basic algorithms. While the only constant is change, the concepts and basics of
    algorithms and algorithmic theory form the basis upon which much of the upcoming
    changes are built. Roughly speaking, understand algorithms and you’ll be well
    equipped to thrive in the upcoming decades.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 21世纪不断变化的热门技能和工作岗位使得年轻人必须理解、掌握并操作基本的算法。虽然唯一不变的就是变化，但算法和算法理论的概念与基础构成了即将到来的变化的基础。粗略地说，理解算法，你就能为未来几十年的发展做好充分准备。
- en: This chapter aims to improve your understanding of algorithms, focusing more
    on your intuition and a well-rounded understanding of concepts and practical implementations
    than on theory. While algorithmic theory is as important as practical implementations
    and conceptual understanding, many great books focus on the theory part. After
    reading this chapter, you will intuitively understand some of the most popular
    algorithms in computer science—and improve your practical Python implementation
    skills. This may provide you a strong foundation for the upcoming technological
    breakthroughs.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章旨在提高你对算法的理解，更侧重于直觉和全面理解概念及实际应用，而非理论。虽然算法理论与实际应用和概念理解同样重要，但许多优秀的书籍都专注于理论部分。阅读本章后，你将直观地理解一些计算机科学中最受欢迎的算法——并提高你的Python实际编程技能。这为即将到来的技术突破提供了坚实的基础。
- en: '**NOTE**'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The book* Introduction to Algorithms *by Thomas Cormen et al. (MIT Press,
    2009) is an excellent follow-up resource on algorithmic theory.*'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*《算法导论》*（作者：Thomas Cormen等，MIT出版社，2009年）是一本关于算法理论的极好参考书。'
- en: Let’s start with a small algorithm to solve a simple problem that is relevant
    for programmers who want to find good jobs.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个小算法开始，解决一个对想要找到好工作的程序员来说相关的简单问题。
- en: '**Finding Anagrams with Lambda Functions and Sorting**'
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用Lambda函数和排序查找字谜**'
- en: Anagrams are a popular topic in programming interviews to test your computer
    science vocabulary and how good you are at developing your own simple algorithms.
    In this section, you’ll learn about a simple algorithm to find anagrams in Python.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 变位词是编程面试中常见的题目，用来测试你的计算机科学词汇和编写简单算法的能力。在本节中，你将学习如何在 Python 中使用简单算法查找变位词。
- en: '***The Basics***'
  id: totrans-15
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基础知识***'
- en: 'Two words are *anagrams* if they consist of the same characters and if every
    character of the first word appears in the second word exactly once. This is illustrated
    in [Figure 6-1](#ch06fig01) and in the following examples:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个词由相同的字符组成，并且第一个词中的每个字符在第二个词中恰好出现一次，那么这两个词是*变位词*。这一点在[图 6-1](#ch06fig01)以及以下示例中有说明：
- en: “listen” → “silent”
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “listen” → “silent”
- en: “funeral ” → “real fun”
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “funeral ” → “real fun”
- en: “elvis” → “lives”
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “elvis” → “lives”
- en: '![images](Images/fig6-1.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![images](Images/fig6-1.jpg)'
- en: '*Figure 6-1: The word* elvis *is an anagram of the word* lives.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-1：单词* elvis *是单词* lives *的变位词。*'
- en: We’ll now work on this problem and arrive at a concise Pythonic solution to
    figuring out whether two words are anagrams. Let’s start coding.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将着手解决这个问题，并得出一个简洁的 Pythonic 解决方案来判断两个单词是否是变位词。让我们开始编写代码吧。
- en: '***The Code***'
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: Our goal is to write a function `is_anagram()` that takes two strings `x1` and
    `x2` and returns `True` if those are anagrams! Before you read on, pause for a
    moment and think about the problem. How would you approach it in Python? [Listing
    6-1](#list6-1) shows one solution.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是编写一个函数 `is_anagram()`，该函数接收两个字符串 `x1` 和 `x2`，并在它们是变位词时返回 `True`！在继续阅读之前，请暂停片刻思考一下这个问题。你会如何在
    Python 中处理这个问题呢？[清单 6-1](#list6-1)展示了一个解决方案。
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 6-1: One-liner solution to check whether two strings are anagrams*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-1：检查两个字符串是否是变位词的一行代码解决方案*'
- en: This code prints three lines. What are they?
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码打印了三行。它们分别是什么？
- en: '***How It Works***'
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***工作原理***'
- en: 'Two strings are anagrams if they have the same sorted character sequence, so
    our method is to sort both strings and then make an element-wise comparison. It’s
    that easy. There is no need for external dependencies. You simply create a function
    `is_anagram()` ➊ by using the lambda function definition (see [Chapter 1](ch01.xhtml#ch01))
    with two arguments `x1` and `x2`. The function returns the result of the expression
    `sorted(x1) == sorted(x2)`, which is `True` if the sorted character sequences
    consist of the same characters. Here’s the output of the two sorted character
    sequences:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个字符串具有相同的排序字符序列，那么它们就是变位词，因此我们的方法是对两个字符串进行排序，然后进行逐元素比较。就是这么简单。无需外部依赖。你只需通过使用
    Lambda 函数定义（参见[第 1 章](ch01.xhtml#ch01)）并传入两个参数 `x1` 和 `x2` 来创建一个 `is_anagram()`
    函数 ➊。该函数返回表达式 `sorted(x1) == sorted(x2)` 的结果，如果排序后的字符序列由相同的字符组成，则返回 `True`。以下是两个排序后字符序列的输出：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Both strings `''elvis''` and `''lives''` consist of the same characters, so
    the sorted list representation is the same. The result of the three print statements
    is the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 两个字符串 `'elvis'` 和 `'lives'` 由相同的字符组成，因此它们的排序列表表示是相同的。三条打印语句的结果如下：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As a small side note for advanced coders: the runtime complexity of sorting
    a sequence of *n* elements in Python grows asymptotically like the function *n
    log(n)*. That means our one-liner algorithm is more efficient than the naive solution
    of checking whether every character exists in both strings and removing the character
    if this is the case. The naive algorithm grows asymptotically like the quadratic
    function *n**2*.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 给高级程序员的小提示：在 Python 中对 *n* 个元素进行排序的运行时间复杂度是随着 *n log(n)* 函数渐近增长的。这意味着我们的这一行代码算法比那种检查每个字符是否都出现在两个字符串中并在相同字符存在时删除它们的天真算法更高效。天真算法的渐近增长复杂度是
    *n**2*。
- en: However, there’s another efficient way, called *histogramming*, whereby you
    create a histogram for both strings that counts the number of occurrences of all
    characters in that string, and then compare the two histograms. Assuming a constant-sized
    alphabet, the runtime complexity of histogramming is linear; it grows asymptotically
    like the function *n*. Feel free to implement this algorithm as a small exercise!
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有一种高效的方法，叫做 *直方图法*，即为两个字符串创建一个直方图，统计该字符串中所有字符的出现次数，然后比较两个直方图。假设字母表大小是常数，直方图法的运行时复杂度是线性的；它的渐近增长复杂度是
    *n*。不妨把这个算法当作一个小练习来实现！
- en: '**Finding Palindromes with Lambda Functions and Negative Slicing**'
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用 Lambda 函数和负切片查找回文**'
- en: 'This section introduces another computer science term that’s popular in interview
    questions: palindromes. You’ll use a one-liner to check whether two words are
    palindromes of each other.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了另一个在面试问题中流行的计算机科学术语：回文。你将使用一个单行代码来检查两个单词是否是彼此的回文。
- en: '***The Basics***'
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基础知识***'
- en: 'First things first: what is a palindrome? A *palindrome* can be defined as
    a sequence of elements (for example, a string or a list) that reads the same backward
    as it does forward. Here are a few fun examples that are palindromes if you take
    out the whitespace:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要弄清楚的是：什么是回文？*回文*可以定义为一种元素序列（例如字符串或列表），它从前向后和从后向前读取都是一样的。以下是一些有趣的例子，如果你去掉空格，它们就是回文：
- en: “Mr Owl ate my metal worm”
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “Mr Owl ate my metal worm”
- en: “Was it a car or a cat I saw?”
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “Was it a car or a cat I saw?”
- en: “Go hang a salami, I’m a lasagna hog”
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “Go hang a salami, I’m a lasagna hog”
- en: “Rats live on no evil star”
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “老鼠生活在没有邪恶之星上”
- en: “Hannah”
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “Hannah”
- en: “Anna”
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “Anna”
- en: “Bob”
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “Bob”
- en: Our one-liner solution will require your basic understanding of slicing. As
    you know from [Chapter 2](ch02.xhtml#ch02), slicing is a Python-specific concept
    for carving out a range of values from sequence types such as lists or strings.
    Slicing uses the concise notation `[start:stop:step]` to slice a sequence starting
    at index `start` (inclusive) and ending at index `stop` (exclusive). The third
    parameter `step` allows you to define the *step size*, which is how many characters
    from the original sequence your slice will skip before taking the next character
    (for example, `step=2` means that your slice will consist of only every other
    character). When using a negative step size, the string is traversed in reverse
    order.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的单行解决方案将需要你对切片有基本的理解。正如你在[第2章](ch02.xhtml#ch02)中所学，切片是 Python 特有的概念，用于从序列类型（如列表或字符串）中截取一段范围的值。切片使用简洁的表示法`[start:stop:step]`来截取一个从索引`start`（包含）开始并在索引`stop`（不包含）结束的序列。第三个参数`step`允许你定义*步长*，即在截取下一个字符之前，原始序列中跳过多少个字符（例如，`step=2`意味着你的切片将只包含每隔一个字符的元素）。当使用负的步长时，字符串会反向遍历。
- en: This is everything you need to know to come up with a short and concise one-liner
    solution in Python.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你需要知道的所有内容，以便用 Python 提出一个简短而简洁的单行解决方案。
- en: '***The Code***'
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: When given a string, you want your code to check whether the reverse sequence
    of characters equals the original sequence, to determine whether the string is
    a palindrome. [Listing 6-2](#list6-2) shows the solution.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个字符串时，你希望你的代码检查反转后的字符序列是否等于原始序列，以确定该字符串是否是回文。[列表6-2](#list6-2)展示了解决方案。
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 6-2: One-liner solution to check whether a phrase is a palindrome*'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表6-2：检查一个短语是否是回文的单行解决方案*'
- en: '***How It Works***'
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***它是如何工作的***'
- en: The simple one-liner solution does not depend on any external library. You define
    a lambda function that takes a single argument `phrase`—the string to be tested—and
    returns a Boolean value that says whether the sequence of characters remains unchanged
    when reversed. To reverse the string, you use slicing (see [Chapter 2](ch02.xhtml#ch02)).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的单行解决方案不依赖于任何外部库。你定义了一个 lambda 函数，它接受一个参数`phrase`——即需要测试的字符串——并返回一个布尔值，表示当字符串反转时，字符序列是否保持不变。为了反转字符串，你使用切片（请参见[第2章](ch02.xhtml#ch02)）。
- en: 'The result of the one-liner code snippet is the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 单行代码片段的结果如下：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The first and third strings are palindromes, but the second isn’t. Next let’s
    dive into another popular computer science concept: permutations.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个和第三个字符串是回文，而第二个不是。接下来，让我们深入探讨另一个流行的计算机科学概念：排列。
- en: '**Counting Permutations with Recursive Factorial Functions**'
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**通过递归阶乘函数计数排列数**'
- en: This section explains a simple and effective way of computing the factorial
    in a single line of code to figure out the maximum number of possible permutations
    in a data set.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了一种简单而有效的方法，通过一行代码计算阶乘，以便找出数据集中可能的最大排列数。
- en: '***The Basics***'
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基础知识***'
- en: 'Consider the following problem: England’s Premier League has 20 soccer teams,
    each of which can reach any of the 20 ranks at the end of the season. Given 20
    fixed teams, you can calculate how many possible versions of these rankings exist.
    Note that the question is not how many rankings a single team can achieve (the
    answer would be 20) but how many total rankings of all teams exist. [Figure 6-2](#ch06fig02)
    shows just three possible rankings.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下问题：英格兰超级联赛有20支足球队，每支队伍在赛季结束时都可以达到20个排名中的任何一个。给定20支固定的队伍，您可以计算这些排名的所有可能版本的数量。注意，这个问题不是问单个队伍可以达到多少个排名（答案是20），而是问所有队伍的排名总数有多少种。[图6-2](#ch06fig02)展示了仅仅三种可能的排名。
- en: '![images](Images/fig6-2.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![images](Images/fig6-2.jpg)'
- en: '*Figure 6-2: Three possible rankings of the soccer teams in England’s Premier
    League*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-2：英格兰超级联赛足球队的三种可能排名*'
- en: In computer science terminology, you would denote each ranking as a *permutation*,
    defined as a specific order of set elements. Our goal is to find the number of
    possible permutations of a given set. The number of those permutations has important
    implications for programs involved in betting applications, match prediction,
    and game analysis. For example, if each of 100 different rankings has the same
    initial probability, the probability of a specific ranking is 1/100 = 1 percent.
    This can be used as a base probability (*a priori probability*) for game-prediction
    algorithms. Under these assumptions, a randomly guessed ranking has a 1 percent
    probability of being the correct outcome after one season.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学术语中，您会将每个排名表示为一个*排列*，它被定义为一组元素的特定顺序。我们的目标是找出给定集合的所有可能排列的数量。这些排列的数量对涉及投注应用程序、比赛预测和游戏分析的程序具有重要意义。例如，如果100个不同的排名每个都有相同的初始概率，那么某个特定排名的概率是1/100
    = 1%。这可以作为游戏预测算法的基础概率（*先验概率*）。在这些假设下，随机猜测的排名在一个赛季结束后有1%的概率是正确的结果。
- en: 'To calculate the number of permutations of a given set of *n* elements, you
    can use the factorial function *n!*. In the next few paragraphs, you’ll learn
    why this is the case. The factorial is defined as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算给定*n*个元素的排列数量，您可以使用阶乘函数*n!*。在接下来的几段中，您将了解为什么是这样的。阶乘的定义如下：
- en: '*n! = n × (n – 1) × (n – 2) × . . . × 1*'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*n! = n × (n – 1) × (n – 2) × . . . × 1*'
- en: 'For example:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '*1! = 1*'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*1! = 1*'
- en: '*3! = 3 × 2 × 1 = 6*'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*3! = 3 × 2 × 1 = 6*'
- en: '*10! = 10 × 9 × 8 × 7 × 6 × 5 × 4 × 3 × 2 × 1 = 3,628,800*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*10! = 10 × 9 × 8 × 7 × 6 × 5 × 4 × 3 × 2 × 1 = 3,628,800*'
- en: '*20! = 20 × 19 × 18 × . . . × 3 × 2 × 1 = 2,432,902,008,176,640,000*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*20! = 20 × 19 × 18 × . . . × 3 × 2 × 1 = 2,432,902,008,176,640,000*'
- en: Let’s take a look at how this works. Say you have a set of 10 elements *S* = {*s*0,
    *s*1, *s*2, . . . , *s*9} and 10 buckets *B* = {*b*0, *b*1, *b*2, . . . , *b*9}.
    You want to place exactly one element from *S* into each bucket. In the soccer
    example, the 20 teams are the elements, and the 20 table ranks are the buckets.
    To get one specific permutation of *S*, you simply place all elements into all
    buckets. The number of different ways of assigning elements to buckets is the
    total number of permutations of elements in *S*.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下这个是如何工作的。假设您有一个包含10个元素的集合*S* = {*s*0, *s*1, *s*2, . . . , *s*9} 和10个桶*B*
    = {*b*0, *b*1, *b*2, . . . , *b*9}。您希望将集合*S*中的每个元素放入一个桶中。在足球的例子中，20支队伍就是元素，20个排名就是桶。为了得到*S*的一个特定排列，您只需要将所有元素放入所有桶中。将元素分配给桶的不同方式数量即为*S*中元素的排列总数。
- en: 'The following algorithm determines the number of permutations for a set with
    10 elements (which need to be placed into 10 buckets):'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 以下算法确定了一个包含10个元素的集合的排列数量（这些元素需要放入10个桶中）：
- en: Take the first element from the set *S*. There are *10 empty buckets* so you
    have *10 options* for where you can place the element. You place one element in
    a bucket.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从集合*S*中取出第一个元素。现在有*10个空桶*，所以你有*10个选择*来放置元素。你将一个元素放入一个桶中。
- en: Now one bucket is occupied. Take the second element from the set. There now
    remain *9 empty buckets* so you have *9 options*.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在一个桶已经被占用了。取出集合中的第二个元素。现在剩下*9个空桶*，因此你有*9个选择*。
- en: Finally, take the 10th (last) element from the set. Nine buckets are now occupied.
    There is only *one empty bucket*, so you have *one option*.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，从集合中取出第10个（最后一个）元素。现在有九个桶已经占用。只剩下*一个空桶*，因此你有*一个选择*。
- en: In total, you have 10 × 9 × 8 × 7 × 6 × 5 × 4 × 3 × 2 × 1 = 10! options. Each
    potential placement of an element in a bucket represents one permutation of the
    set elements. The number of permutations of a set with *n* elements is therefore
    *n!*.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 总共，你有 10 × 9 × 8 × 7 × 6 × 5 × 4 × 3 × 2 × 1 = 10! 种选项。每一个元素在桶中的潜在放置方式代表着集合元素的一种排列。因此，具有
    *n* 个元素的集合的排列数就是 *n!*。
- en: 'Recursively, the factorial function can also be defined as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 递归地，阶乘函数也可以这样定义：
- en: '*n! = n × (n – 1)!*'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*n! = n × (n – 1)!*'
- en: 'The recursion base cases are defined as shown here:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 递归的基本情况如下所示：
- en: '*1! = 0! = 1*'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*1! = 0! = 1*'
- en: The intuition behind these base cases is that a set with one element has one
    permutation, and a set with zero elements has one permutation (there is one way
    of assigning zero elements to zero buckets).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这些基本情况背后的直觉是，具有一个元素的集合有一种排列，具有零个元素的集合也有一种排列（将零个元素分配到零个桶中只有一种方式）。
- en: '***The Code***'
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: The one-liner in [Listing 6-3](#list6-3) will compute the number of permutations
    *n!* of a set with *n* elements.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 6-3](#list6-3) 中的单行代码将计算具有 *n* 个元素的集合的排列数 *n!*。'
- en: '[PRE5]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 6-3: One-liner solution defining the factorial function recursively*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-3：定义阶乘函数的单行递归解法*'
- en: Try figuring out what the output of this code would be.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试弄清楚这段代码的输出结果是什么。
- en: '***How It Works***'
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***它是如何工作的***'
- en: 'In the code, you use the recursive definition of the factorial. Let’s quickly
    improve our intuitive understanding of recursion. Stephen Hawking came up with
    a concise way to explain recursion: “To understand recursion, one must first understand
    recursion.”'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，你使用了阶乘的递归定义。让我们快速提升对递归的直观理解。斯蒂芬·霍金提出了一种简明的方式来解释递归：“要理解递归，必须首先理解递归。”
- en: The Merriam-Webster dictionary defines recursion as “a computer programming
    technique involving the use of a . . . function . . . that calls itself one or
    more times until a specified condition is met, at which time the rest of each
    repetition is processed from the last one called to the first.” At the heart of
    this definition is the *recursive function*, which is simply a function that calls
    itself. But if the function keeps calling itself, it would never stop.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 《梅里亚姆-韦伯斯特词典》将递归定义为“计算机编程技术，涉及使用一个……函数……多次调用自身，直到满足指定条件，此时每次重复的其余部分会从最后一次调用处理到第一次。”该定义的核心是*递归函数*，即一个调用自身的函数。但是，如果函数一直调用自身，它将永远不会停止。
- en: 'For this reason, we set a certain base case. When the base case is met, the
    last function call terminates and returns a solution to the second-to-last function
    call. The second-to-last function call also returns the solution to the third-to-last
    function call. This causes a chain reaction of propagating the results to the
    higher recursion level until the first function call returns the final result.
    This may feel difficult to grasp in a few lines of English text, but stay with
    me: we will discuss this with the aid of the given one-liner example next.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这个原因，我们设置了一个特定的基本情况。当满足基本情况时，最后一次函数调用终止并返回给倒数第二次函数调用一个解答。倒数第二次函数调用也会将解答返回给倒数第三次函数调用。这引发了一个链式反应，将结果传递到更高的递归层级，直到第一次函数调用返回最终结果。几行英文文本可能让人难以理解这一点，但请跟着我走：我们将在接下来的单行示例中讨论这一点。
- en: 'In general, you create a recursive function *f* in four steps:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，你可以通过四个步骤创建一个递归函数*f*：
- en: Break the original problem into smaller problem instances.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将原问题拆解成更小的问题实例。
- en: Take the smaller problem instances as the input of function *f* (which will
    then break the smaller input into even smaller problem instances and so on).
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将较小的问题实例作为函数*f*的输入（该函数随后将较小的输入拆解成更小的问题实例，以此类推）。
- en: Define a *base case*, which is the smallest possible input that can be solved
    directly without any further call of the function *f*.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个*基本情况*，即可以直接解决的最小输入，无需再调用函数*f*。
- en: Specify how you can recombine the obtained smaller solutions into the larger
    solution.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定如何将获得的较小解重新组合成较大的解。
- en: You create a lambda function with one argument `n` and assign the lambda function
    to the name `factorial`. Finally, you call the named function `factorial(n-1)`
    to calculate the result of the function call `factorial(n)`. The value `n` could
    be the number of soccer teams in the Premier League (`n=20`) or any other value
    such as the one in [Listing 6-3](#list6-3) (`n=5`).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你创建了一个带有一个参数 `n` 的 lambda 函数，并将这个 lambda 函数赋值给名称 `factorial`。最后，你调用命名函数 `factorial(n-1)`
    来计算函数调用 `factorial(n)` 的结果。值 `n` 可以是英超联赛的球队数量（`n=20`），或者是其他值，如[清单 6-3](#list6-3)中的值（`n=5`）。
- en: Roughly speaking, you can use the simpler solution for `factorial(n-1)` to construct
    the solution of the harder problem `factorial(n)` by multiplying the former with
    the input argument `n`. As soon as you reach the recursion base case `n <= 1`,
    you simply return the hardcoded solution `factorial(1) =` `factorial(0) = 1`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 大致来说，你可以使用 `factorial(n-1)` 的简化解决方案，通过将前者与输入参数 `n` 相乘，来构建更难问题 `factorial(n)`
    的解决方案。只要你达到递归的基本情况 `n <= 1`，你只需返回硬编码的解决方案 `factorial(1) =` `factorial(0) = 1`。
- en: This algorithm shows how you can often find a simple, concise, and efficient
    way of solving problems by thoroughly understanding the problem first. Choosing
    the simplest solution idea is one of the most important things you can do when
    creating your own algorithms. Beginners often find they write cluttered and unnecessarily
    complicated code.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法展示了如何通过彻底理解问题，通常能够找到解决问题的简单、简洁和高效的方法。在创建自己的算法时，选择最简单的解决方案是你可以做的最重要的事情之一。初学者通常发现自己编写的代码混乱且不必要地复杂。
- en: In this case, the recursive (one-liner) definition of the factorial is shorter
    than an iterative (one-liner) definition without recursion. As an exercise, try
    rewriting this one-liner without using a recursive definition and without external
    libraries—it’s not trivial and certainly not that concise!
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，阶乘的递归（单行）定义比没有递归的迭代（单行）定义要简短。作为一个练习，试着重写这个单行代码，不使用递归定义，也不使用外部库——这并不简单，当然也没有那么简洁！
- en: '**Finding the Levenshtein Distance**'
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**计算 Levenshtein 距离**'
- en: In this section, you’ll learn about an important practical algorithm to calculate
    the Levenshtein distance. Understanding this algorithm is more complicated than
    previous algorithms, so you’ll also train yourself to think through a problem
    clearly.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习一种重要的实际算法，用于计算 Levenshtein 距离。理解这个算法比之前的算法要复杂，所以你也将训练自己清晰地思考问题。
- en: '***The Basics***'
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基础知识***'
- en: 'The *Levenshtein distance* is a metric to calculate the distance between two
    strings; in other words, it’s used to quantify the similarity of two strings.
    Its alternate name, the *edit distance*, describes precisely what it measures:
    the number of character edits (insertions, removals, or substitutions) needed
    to transform one string into another. The smaller the Levenshtein distance, the
    more similar the strings.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*Levenshtein 距离* 是一种计算两个字符串之间距离的度量；换句话说，它用于量化两个字符串的相似性。它的另一个名称 *编辑距离* 精确地描述了它所测量的内容：将一个字符串转换为另一个字符串所需的字符编辑次数（插入、删除或替换）。Levenshtein
    距离越小，字符串越相似。'
- en: The Levenshtein distance has important applications in things like the autocorrection
    functionality on your smartphone. If you type *helo* in your WhatsApp messenger,
    your smartphone detects a word outside its library and selects several high-probability
    words as potential replacements, and then sorts them by Levenshtein distance.
    For example, the word with minimal Levenshtein distance and, hence, maximal similarity
    is the string `'hello'`, so your phone may automatically correct *helo* to *hello*.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Levenshtein 距离在许多领域中有着重要的应用，比如智能手机上的自动纠正功能。如果你在 WhatsApp 消息中输入 *helo*，你的手机会检测到该单词不在其词库中，并选择几个高概率的单词作为潜在替换项，然后按
    Levenshtein 距离对它们进行排序。例如，Levenshtein 距离最小的单词，因而最大相似度的单词是字符串 `'hello'`，因此你的手机可能会自动将
    *helo* 修正为 *hello*。
- en: Let’s consider an example with the two less similar strings `'cat'` and `'chello'`.
    Knowing that the Levenshtein distance computes the minimal number of edits required
    to reach the second string starting from the first string, [Table 6-1](#ch06tab01)
    shows the minimal sequence.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个例子，其中有两个不太相似的字符串 `'cat'` 和 `'chello'`。知道 Levenshtein 距离计算从第一个字符串到达第二个字符串所需的最小编辑次数，[表
    6-1](#ch06tab01) 显示了最小的序列。
- en: '**Table 6-1:** The Minimal Sequence Needed to Change `''cat''` to `''chello''`'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 6-1：** 将 `''cat''` 转换为 `''chello''` 所需的最小序列'
- en: '| **Current word** | **Edit made** |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| **当前单词** | **所做编辑** |'
- en: '| --- | --- |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| **cat** | **—** |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| **cat** | **—** |'
- en: '| cht | Replace *a* with *h* |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| cht | 用 *h* 替换 *a* |'
- en: '| che | Replace *t* with *e* |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| che | 用 *e* 替换 *t* |'
- en: '| chel | Insert *l* at position 3 |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| chel | 在位置 3 插入 *l* |'
- en: '| chell | Insert *l* at position 4 |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| chell | 在位置 4 插入 *l* |'
- en: '| chello | Insert *o* at position 5 |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| chello | 在位置 5 插入 *o* |'
- en: '[Table 6-1](#ch06tab01) transforms the string `''cat''` to the string `''chello''`
    in five editing steps, meaning the Levenshtein distance is 5.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 6-1](#ch06tab01) 将字符串 `''cat''` 转换为字符串 `''chello''`，需要五步编辑，这意味着 Levenshtein
    距离是 5。'
- en: '***The Code***'
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: Now let’s write a Python one-liner that calculates the Levenshtein distance
    of strings `a` and `b`, `a` and `c`, and `b` and `c` (see [Listing 6-4](#list6-4)).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们编写一个 Python 单行代码来计算字符串 `a` 和 `b`，`a` 和 `c`，以及 `b` 和 `c` 的 Levenshtein 距离（见
    [清单 6-4](#list6-4)）。
- en: '[PRE6]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 6-4: Calculating the Levenshtein distance of two strings in one line*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-4：用一行代码计算两个字符串的 Levenshtein 距离*'
- en: Based on what you know so far, try to calculate the output before running the
    program.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 基于你目前所知道的，尝试在运行程序之前计算输出结果。
- en: '***How It Works***'
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***原理***'
- en: 'Before diving into the code, let’s quickly explore an important Python trick
    heavily used in this one-liner. In Python, *every* object has a truth value and
    is either `True` or `False`. Most objects are in fact `True` and, intuitively,
    you can probably guess the few objects that are `False`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入代码之前，让我们快速探索一下一个在这个单行代码中大量使用的 Python 技巧。在 Python 中，*每个*对象都有一个布尔值，并且是 `True`
    或 `False`。大多数对象实际上是 `True`，直观上，你可能能猜到一些是 `False` 的对象：
- en: The numerical value `0` is `False`.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数值 `0` 为 `False`。
- en: The empty string `''` is `False`.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空字符串 `''` 为 `False`。
- en: The empty list `[]` is `False`.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空列表 `[]` 为 `False`。
- en: The empty set `set()` is `False`.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空集合 `set()` 为 `False`。
- en: The empty dictionary `{}` is `False`.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空字典 `{}` 为 `False`。
- en: 'As a rule of thumb, Python objects are considered `False` if they are empty
    or zero. Equipped with this information, let’s look at the first part of the Levenshtein
    function: you create a lambda function that takes two strings `a` and `b` and
    returns the number of edits required to transform string `a` into string `b` ➊.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个经验法则，如果 Python 对象是空的或零，它们被认为是 `False`。掌握了这一点后，让我们来看 Levenshtein 函数的第一部分：你创建了一个
    lambda 函数，接受两个字符串 `a` 和 `b`，并返回将字符串 `a` 转换为字符串 `b` 所需的编辑次数 ➊。
- en: 'There are two trivial cases: if string `a` is empty, the minimal edit distance
    is `len(b)`, since you would just need to insert each character of string `b`.
    Similarly, if string `b` is empty, the minimal edit distance is `len(a)`. That
    means if either string is empty, you can directly return the correct edit distance.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个简单的情况：如果字符串 `a` 为空，最小的编辑距离是 `len(b)`，因为你只需要插入字符串 `b` 中的每个字符。同样，如果字符串 `b`
    为空，最小的编辑距离是 `len(a)`。也就是说，如果其中一个字符串为空，你可以直接返回正确的编辑距离。
- en: Let’s say both strings are non-empty. You can simplify the problem by calculating
    the Levenshtein distance of smaller suffixes of the original strings `a` and `b`,
    as shown in [Figure 6-3](#ch06fig03).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 假设两个字符串都非空。你可以通过计算原始字符串 `a` 和 `b` 的较小后缀的 Levenshtein 距离来简化问题，如 [图 6-3](#ch06fig03)
    所示。
- en: '![images](Images/fig6-3.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![images](Images/fig6-3.jpg)'
- en: '*Figure 6-3: Calculating the Levenshtein distance of the words `''cat''` and
    `''chello''` recursively by solving the smaller problem instances first*'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-3：通过递归解决较小的问题实例，计算单词 `''cat''` 和 `''chello''` 的 Levenshtein 距离*'
- en: 'To compute the Levenshtein distance between the strings `''cat''` and `''chello''`
    in a recursive manner, you solve the easier problems first (recursively):'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要以递归方式计算字符串 `'cat'` 和 `'chello'` 之间的 Levenshtein 距离，你首先解决较容易的问题（递归地）：
- en: You calculate the distance between the suffixes `at` and `hello` because if
    you know how to transform `at` into `hello`, you can easily transform `cat` into
    `chello` by modifying the first character (or by keeping the first character if
    both strings start with the same character). Assuming this distance is 5, you
    can now conclude that the distance between `cat` and `chello` is also at most
    5 because you can reuse the exact same sequence of edits (both words begin with
    the character `c` and you don’t have to edit this character).
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你计算后缀 `at` 和 `hello` 之间的距离，因为如果你知道如何将 `at` 转换为 `hello`，那么你可以通过修改第一个字符（或者如果两个字符串都以相同的字符开头，则保持第一个字符不变）轻松地将
    `cat` 转换为 `chello`。假设这个距离是 5，你现在可以得出结论，`cat` 和 `chello` 之间的距离也最多是 5，因为你可以重用完全相同的编辑序列（两个词都以字符
    `c` 开头，且你不需要编辑这个字符）。
- en: You calculate the distance between `at` and `chello`. Assuming this distance
    is 6, you can now conclude that the distance between `cat` and `chello` is at
    most 6 + 1 = 7 because you can simply remove the character `c` at the beginning
    of the first word (one additional operation). From there, you can reuse the exact
    same solution to come from `at` to `chello`.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你计算`at`和`chello`之间的距离。假设这个距离是6，那么你现在可以得出结论：`cat`和`chello`之间的距离至多是6 + 1 = 7，因为你只需删除第一个单词的字符`c`（一个额外操作）。从此，你可以重用相同的解法从`at`变换到`chello`。
- en: You calculate the distance between `cat` and `hello`. Assuming this distance
    is 5, you can now conclude that the distance between `cat` and `chello` is at
    most 5 + 1 because you need to insert the character `c` at the beginning of the
    second word (one additional operation).
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你计算`cat`和`hello`之间的距离。假设这个距离是5，那么你现在可以得出结论：`cat`和`chello`之间的距离至多是5 + 1，因为你需要在第二个单词的开头插入字符`c`（一个额外操作）。
- en: As these are all possible cases of what you can do with the first character
    (substitution, removal, insertion), the Levenshtein distance between `cat` and
    `chello` is the minimum of the three cases 1, 2, and 3\. Let’s now further examine
    the three cases in [Listing 6-4](#list6-4).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些是你可以对首字符所做的所有可能操作（替换、删除、插入），`cat`和`chello`之间的Levenshtein距离是三种情况1、2和3中的最小值。现在让我们进一步分析[列表6-4](#list6-4)中的三种情况。
- en: First, you calculate the edit distance from `a[1:]` to `b[1:]` in a recursive
    manner ➋. If the leading characters `a[0]` and `b[0]` are different, you have
    to fix it by *replacing* `a[0]` by `b[0]`, so you increment the edit distance
    by one. If the leading characters are the same, the solution of the simpler problem
    `ls(a[1:], b[1:])` is also a solution to the more complex problem `ls(a, b)`,
    as you’ve seen in [Figure 6-3](#ch06fig03).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你以递归方式计算从`a[1:]`到`b[1:]`的编辑距离 ➋。如果首字符`a[0]`和`b[0]`不同，你必须通过*替换*`a[0]`为`b[0]`来修正，因此你将编辑距离加一。如果首字符相同，较简单问题`ls(a[1:],
    b[1:])`的解也就是较复杂问题`ls(a, b)`的解，正如你在[图6-3](#ch06fig03)中所见。
- en: Second, you calculate the distance from `a[1:]` to `b` in a recursive manner
    ➌. Say you know the result of this distance (going from `a[1:]` to `b`)—how can
    you calculate the distance one step further from `a` to `b`? The answer is to
    simply *remove* the first character `a[0]` from the beginning of `a`, which is
    one additional operation. With this, you have reduced the more complicated problem
    to the easier one.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，你以递归方式计算从`a[1:]`到`b`的距离 ➌。假设你已经知道这个距离的结果（从`a[1:]`到`b`）——那么如何计算从`a`到`b`的距离呢？答案是，只需*删除*`a`开头的第一个字符`a[0]`，这就是一个额外的操作。这样，你就将更复杂的问题简化为更简单的问题。
- en: Third, you calculate the distance from `a` to `b[1:]` in a recursive manner
    ➍. Say you know the result of this distance (going from `a` to `b[1:]`). How can
    you calculate the distance from `a` to `b`? In this case, you can simply go one
    step further (from `a` to `b[1:]` to `b`) by *inserting* the character `b[0]`
    at the beginning of the word `b[1:]`, which would increment the distance by one.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，你以递归方式计算从`a`到`b[1:]`的距离 ➍。假设你已经知道这个距离的结果（从`a`到`b[1:]`）。那么你如何计算从`a`到`b`的距离呢？在这种情况下，你只需再走一步（从`a`到`b[1:]`再到`b`），通过*插入*字符`b[0]`到单词`b[1:]`的开头，这样距离就增加了一。
- en: Finally, you simply take the minimum edit distance of all three results (replace
    the first character, remove the first character, insert the first character).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你只需选择所有三种结果的最小编辑距离（替换第一个字符、删除第一个字符、插入第一个字符）。
- en: This one-liner solution demonstrates once again the importance of training your
    recursion skills. Recursion may not come naturally to you, but rest assured that
    it will after studying many recursive problems like this one.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简洁的一行代码再次证明了训练递归技能的重要性。递归可能对你来说并不自然，但请放心，在像这样的递归问题学习之后，它会变得更加顺手。
- en: '**Calculating the Powerset by Using Functional Programming**'
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用函数式编程计算幂集**'
- en: 'In this section, you’ll learn about an important mathematical concept known
    as the powerset: the set of all subsets. You’ll need powersets in statistics,
    set theory, functional programming, probability theory, and algorithmic analysis.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，你将学习一个重要的数学概念——幂集：所有子集的集合。你将在统计学、集合论、函数式编程、概率论和算法分析中用到幂集。
- en: '***The Basics***'
  id: totrans-145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基础知识***'
- en: The *powerset* is the set of all subsets of the given set `s`. It includes the
    empty set `{}`, the original set `s`, and all other possible subsets of the original
    set. Here are a few examples.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*幂集* 是给定集合 `s` 的所有子集的集合。它包括空集 `{}`、原始集合 `s` 和所有其他可能的子集。以下是几个示例。'
- en: 'Example 1:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 1:'
- en: 'Given set: `s = {1}`'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定集合：`s = {1}`
- en: 'Powerset: `P = {{},{1}}`'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '幂集: `P = {{},{1}}`'
- en: 'Example 2:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 2:'
- en: 'Given set: `s = {1, 2}`'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定集合：`s = {1, 2}`
- en: 'Powerset: `P = {{},{1},{2},{1,2}}`'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '幂集: `P = {{},{1},{2},{1,2}}`'
- en: 'Example 3:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 3:'
- en: 'Given set: `s = {1, 2, 3}`'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定集合：`s = {1, 2, 3}`
- en: 'Powerset: `P = {{},{1},{2},{3},{1,2},{1,3},{2,3},{1,2,3}}`'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '幂集: `P = {{},{1},{2},{3},{1,2},{1,3},{2,3},{1,2,3}}`'
- en: To calculate a powerset *P**[n]* of a set *s* with *n* elements, you use the
    smaller powerset *P**[n]*[–1] of a subset of *s* with (*n* – 1) elements. Say
    you want to calculate the powerset of set *s* = {1, 2, 3}.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算一个包含 *n* 个元素的集合 *s* 的幂集 *P*[n]*，你需要使用 *s* 中一个包含 (*n* – 1) 个元素的子集的较小幂集 *P*[n]*[–1]。假设你要计算集合
    *s* = {1, 2, 3} 的幂集。
- en: Initialize the powerset *P*[0] with zero elements as *P*[0] = {{}}. In other
    words, this is the powerset of the empty set. It contains only the empty set itself.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用零个元素初始化幂集 *P*[0]，即 *P*[0] = {{}}。换句话说，这是空集的幂集，它只包含空集本身。
- en: 'To create the powerset *P**[n]* with *n* elements from the powerset *P**[n]*[–1]
    with (*n* – 1) elements, you take one (arbitrary) element *x* from the set *s*
    and incorporate all arising subsets into the larger powerset *P**[n]* by using
    the following procedure:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要从包含 (*n* – 1) 个元素的幂集 *P*[n]*[–1] 创建包含 *n* 个元素的幂集 *P*[n]*，你需要从集合 *s* 中取出一个（任意）元素
    *x*，并使用以下过程将所有生成的子集并入更大的幂集 *P*[n]*：
- en: Go over all sets *p* in *P**[n]*[–1] and create a new subset that consists of
    the union of *x* and *p*. This results in a new temporary set of sets *T*. For
    example, if *P*[2] = {{}, {1}, {2}, {1,2}}, you’ll create the temporary set of
    sets *T* = {{3}, {1,3}, {2,3}, {1,2,3}} by adding the element *x* = 3 to all sets
    in *P*[2].
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历 *P*[n]*[–1] 中的所有集合 *p*，并创建一个新子集，该子集由 *x* 和 *p* 的并集组成。这将产生一个新的临时集合 *T*。例如，如果
    *P*[2] = {{}, {1}, {2}, {1,2}}，你通过将元素 *x* = 3 添加到 *P*[2] 中的所有集合，会创建临时集合 *T* =
    {{3}, {1,3}, {2,3}, {1,2,3}}。
- en: 'Merge the new set of sets *T* with the powerset *P**[n]*[–1] to obtain powerset
    *P**[n]*. For example, you obtain powerset *P*[3] by merging the temporary set
    *T* with the powerset *P*[2] as follows: *P*[3] = *T union P*[2].'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的集合 *T* 与幂集 *P*[n]*[–1] 合并，得到幂集 *P*[n]*。例如，你可以通过将临时集合 *T* 与幂集 *P*[2] 合并，得到幂集
    *P*[3]，合并过程如下： *P*[3] = *T union P*[2]。
- en: Go to 2 until original set *s* is empty.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一直进行到原始集合 *s* 为空为止。
- en: I’ll explain this strategy in more detail in the following section.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在接下来的部分更详细地解释这一策略。
- en: '**The reduce() Function**'
  id: totrans-163
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**reduce() 函数**'
- en: 'But first, you need to properly understand an important Python function that
    you’ll use in the one-liner: the `reduce()` function. The `reduce()` function
    is built into Python 2, but the developers decided it was used little enough that
    they didn’t include it in Python 3, so you’ll need to import it first from the
    functools library.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，你需要正确理解一个你将在一行代码中使用的重要 Python 函数：`reduce()` 函数。`reduce()` 函数内置于 Python 2
    中，但开发者认为它的使用频率较低，因此没有将其包含在 Python 3 中，所以你需要先从 functools 库中导入它。
- en: 'The `reduce()` function takes three arguments: `reduce(function, iterable,
    initializer)`. The `function` arguments define how two values `x` and `y` are
    reduced to a single value (for example, `lambda x, y: x + y`). This way, you can
    iteratively reduce two values of an `iterable` (the second argument) to a single
    value—until only a single value is left in the `iterable`. The `initializer` argument
    is optional—if you don’t set it, Python assumes the first value of the `iterable`
    as a default.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`reduce()` 函数接受三个参数：`reduce(function, iterable, initializer)`。`function` 参数定义了如何将两个值
    `x` 和 `y` 合并成一个值（例如，`lambda x, y: x + y`）。这样，你可以迭代地将 `iterable`（第二个参数）中的两个值合并为一个值，直到
    `iterable` 中只剩下一个值。`initializer` 参数是可选的——如果没有设置，Python 会默认将 `iterable` 的第一个值作为初始值。'
- en: 'For example, calling `reduce(lambda x, y: x + y, [0, 1, 2, 3])` performs the
    following computation: `(((0 + 1)+ 2)+ 3) = 6`. In other words, you first reduce
    the two values `x=0` and `y=1` to the sum `x + y = 0 + 1 = 1`. Then, you use this
    result of the first call of the lambda function as input to the second call of
    the lambda function: `x=1` and `y=2`. The result is the sum `x + y = 1 + 2 = 3`.
    Finally, we use the result of this second call of the lambda `function` as input
    to the third call of the lambda `function` by setting `x=3` and `y=3`. The result
    is the sum `x + y = 3 + 3 = 6`.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '例如，调用`reduce(lambda x, y: x + y, [0, 1, 2, 3])`会执行以下计算：`(((0 + 1)+ 2)+ 3) =
    6`。换句话说，你首先将两个值`x=0`和`y=1`减少为和`x + y = 0 + 1 = 1`。然后，将这个lambda函数第一次调用的结果作为输入传递给第二次调用：`x=1`和`y=2`。结果是和`x
    + y = 1 + 2 = 3`。最后，我们将lambda`function`第二次调用的结果作为输入传递给第三次调用，通过设置`x=3`和`y=3`。结果是和`x
    + y = 3 + 3 = 6`。'
- en: In the last example, you have seen that the value `x` always carries the result
    of the previous (lambda) `function`. The argument `x` serves as the accumulated
    value, while the argument `y` serves as the *update* value from the `iterable`.
    This is the intended behavior to iteratively “reduce” all values in the `iterable`
    argument to a single one. The optional third parameter `initializer` specifies
    the initial input for `x`. This allows you to define a *sequence aggregator* as
    shown in [Listing 6-5](#list6-5).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个例子中，你已经看到值`x`始终携带前一个（lambda）`function`的结果。参数`x`作为累积值，而参数`y`作为来自`iterable`的*更新*值。这是预期的行为，旨在通过迭代地“减少”`iterable`参数中的所有值为单一值。可选的第三个参数`initializer`指定`x`的初始输入。这使得你可以定义一个*序列聚合器*，如[列表
    6-5](#list6-5)所示。
- en: '**List Arithmetic**'
  id: totrans-168
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**列表算术**'
- en: Before diving into the one-liner, you need to understand two more list operators.
    The first is the list concatenation operator `+`, which glues together two lists.
    For example, the result of the expression `[1, 2] + [3, 4]` is the new list `[1,
    2, 3, 4]`. The second is the union operator `|`, which performs a simple union
    operation on two sets. For example, the result of the expression `{1, 2} | {3,
    4}` is the new set `{1, 2, 3, 4}`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究一行代码之前，你需要理解另外两个列表运算符。第一个是列表连接运算符`+`，它将两个列表拼接在一起。例如，表达式`[1, 2] + [3, 4]`的结果是新的列表`[1,
    2, 3, 4]`。第二个是并集运算符`|`，它对两个集合执行简单的并集操作。例如，表达式`{1, 2} | {3, 4}`的结果是新的集合`{1, 2,
    3, 4}`。
- en: '***The Code***'
  id: totrans-170
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: '[Listing 6-5](#list6-5) provides a one-liner solution that calculates the powerset
    of a given set *s*.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 6-5](#list6-5)提供了一个一行代码的解决方案，用于计算给定集合*s*的幂集。'
- en: '[PRE7]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 6-5: One-liner solution to calculate the powerset of a given set*'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-5：计算给定集合的幂集的一行代码解决方案*'
- en: Guess the output of this code snippet!
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 猜猜这个代码片段的输出是什么！
- en: '***How It Works***'
  id: totrans-175
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***工作原理***'
- en: The idea of this one-liner is to start the powerset as an empty set ➋ and repeatedly
    add subsets to it ➊ until no more subsets can be found.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这个一行代码的思想是将幂集从空集合开始 ➋，并不断向其中添加子集 ➊，直到无法再找到子集。
- en: 'Initially, the powerset contains only the empty set. In each step, you take
    one element `x` out of the data set `s` and create new subsets that naturally
    emerge by adding `x` to all subsets that are already in the powerset ➋. As you’ve
    seen in the introduction of this section, the size of the powerset therefore doubles
    each time you consider an additional element `x` from the data set `s`. In this
    way, you can grow the powerset with *n* subsets one data set element at a time
    (but by *n* subsets at a time). Note that the powerset grows exponentially: for
    any new data set element *x*, you double the size of the powerset. This is an
    inherent property of powersets: they quickly overwhelm any storage capacity—even
    for relatively small data sets with only a few dozen of elements.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，幂集只包含空集合。在每一步，你从数据集`s`中取出一个元素`x`，并通过将`x`添加到幂集中已经存在的所有子集中来创建新的子集 ➋。正如你在本节介绍部分所看到的，每次考虑数据集`s`中的一个额外元素`x`时，幂集的大小都会翻倍。这样，你可以通过一次增加一个数据集元素（但每次增加*n*个子集）来扩展幂集。请注意，幂集的增长是指数级的：对于任何新的数据集元素`x`，你都会使幂集的大小翻倍。这是幂集的一个固有特性：它们会迅速超过任何存储容量——即使对于只有几十个元素的小型数据集也是如此。
- en: 'You use the `reduce()` function to maintain the current powerset in the variable
    `P` (which initially contains only the empty set). Using list comprehension, the
    `reduce``()` function creates new subsets—one for each existing subset—and adds
    them to the powerset `P`. In particular, it adds the value `x` from the data set
    to each subset and thus doubles the size of the powerset (containing the subsets
    *with* and *without* the data set element `x`). In this way, the `reduce()` function
    repeatedly “merges” two elements: the powerset `P` and an element `x` from the
    data set.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用`reduce()`函数来维护当前的幂集变量`P`（最初只包含空集）。通过列表推导，`reduce()`函数为每个现有子集创建新的子集，并将其添加到幂集`P`中。具体而言，它将数据集中的值`x`添加到每个子集中，从而将幂集的大小翻倍（包含带有和不带有数据集元素`x`的子集）。通过这种方式，`reduce()`函数反复“合并”两个元素：幂集`P`和数据集中的元素`x`。
- en: 'Hence, the result of the one-liner is the following:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这行代码的结果如下：
- en: '[PRE8]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This one-liner nicely demonstrates how important it is that you have a thorough
    understanding of lambda functions, list comprehension, and set operations.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码很好地展示了理解lambda函数、列表推导和集合操作的重要性。
- en: '**Caesar’s Cipher Encryption Using Advanced Indexing and List Comprehension**'
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**凯撒密码加密使用高级索引和列表推导**'
- en: In this section, you’ll learn about an ancient encryption technique called *Caesar’s
    cipher*, used by Julius Caesar himself to obfuscate his private conversations.
    Unfortunately, Caesar’s cipher is extremely simple to crack and offers no real
    protection, but it’s still used for fun and obfuscation of forum content that
    should be protected from naive readers’ eyes.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习一种古老的加密技术——*凯撒密码*，这也是尤利乌斯·凯撒自己用来掩盖私人对话的工具。不幸的是，凯撒密码非常简单，很容易破解，无法提供真正的保护，但它仍然被用于娱乐和遮掩那些应该保护的论坛内容，以免被天真的读者看到。
- en: '***The Basics***'
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基础知识***'
- en: Caesar’s cipher is based on the idea of shifting characters to be encrypted
    by a fixed number of positions in the alphabet. We’ll look at a particular case
    of Caesar’s cipher called the ROT13 algorithm.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 凯撒密码的核心思想是将需要加密的字符按固定的位置数进行偏移。我们将特别看一种凯撒密码的变种——ROT13算法。
- en: 'The *ROT13* algorithm is a simple encryption algorithm used in many forums
    (for example, Reddit) to prevent spoilers or hide the semantics of a conversation
    from newbies. The ROT13 algorithm is easy to decrypt—an attacker can crack your
    code by running a probabilistic analysis on the distribution of the letters in
    your encrypted text—even if the attacker doesn’t know by how many positions you
    shifted each character. You should never rely on this algorithm to actually encrypt
    your messages! Still, there are many light applications of the ROT13 algorithm:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '*ROT13*算法是一种简单的加密算法，广泛用于许多论坛（例如Reddit），用以防止剧透或隐藏对话的语义，避免新手看到。ROT13算法容易破解——攻击者可以通过对加密文本中字母分布的概率分析来破解代码，即使攻击者不知道每个字符移动了多少位置。你不应该依赖这个算法来加密消息！尽管如此，ROT13算法还是有很多轻度应用：'
- en: Obscure the result of puzzles in online forums.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模糊化在线论坛中的谜题结果。
- en: Obscure possible spoilers for movies or books.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模糊化电影或书籍中的潜在剧透内容。
- en: 'Make fun of other weak encryption algorithms: “56-bit DES is at least stronger
    than ROT13.”'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嘲笑其他弱加密算法：“56位DES至少比ROT13强。”
- en: Obscure email addresses on websites against 99.999 percent of email spam bots.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在网站上模糊化电子邮件地址可以防止99.999%的电子邮件垃圾机器人。
- en: So ROT13 is more of a popular running gag in internet culture and an educational
    tool than a serious cipher.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，ROT13更像是互联网文化中的一个流行笑话和教育工具，而不是一个严肃的加密方法。
- en: 'The algorithm can be explained in one sentence: *ROT13 = Rotate the string
    to be encrypted by 13 positions (modulo 26) in the alphabet of 26 characters*
    (see [Figure 6-4](#ch06fig04)).'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法可以用一句话来解释：*ROT13 = 将要加密的字符串在26个字母的字母表中旋转13个位置（模26）*（见[图6-4](#ch06fig04)）。
- en: '![images](Images/fig6-4.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![images](Images/fig6-4.jpg)'
- en: '*Figure 6-4: The table shows how each character in the alphabet is encrypted
    and decrypted under the ROT13 algorithm.*'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-4：该表显示了字母表中的每个字符在ROT13算法下的加密和解密方式。*'
- en: In other words, you shift each character by 13 positions in the alphabet. When
    shifting over the last character, *z*, you start over at the first position in
    the alphabet, *a*.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，你将每个字符在字母表中向后移动13个位置。当移动到最后一个字符*z*时，你会从字母表的第一个位置*a*重新开始。
- en: '***The Code***'
  id: totrans-196
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: '[Listing 6-6](#list6-6) creates a one-liner to encrypt the string `s` by using
    the ROT13 algorithm!'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 6-6](#list6-6)创建了一个单行代码，用来通过ROT13算法加密字符串`s`！'
- en: '[PRE9]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 6-6: One-liner solution encrypting string `s` with the ROT13 algorithm*'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-6：使用ROT13算法加密字符串`s`的单行代码解决方案*'
- en: 'Use [Figure 6-4](#ch06fig04) to crack this code: what’s the output of this
    code snippet?'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[图 6-4](#ch06fig04)来破解这段代码：这段代码的输出是什么？
- en: '***How It Works***'
  id: totrans-201
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***原理***'
- en: The one-liner solution encrypts each character separately by moving it 13 positions
    to the right in the alphabet stored in `abc`, and then creates a list of these
    encrypted characters and joins the elements in this list to get the encrypted
    phrase `x`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 该单行代码解决方案通过将每个字符分别向右移动13个位置，使用存储在`abc`中的字母表加密每个字符，然后创建这些加密字符的列表，并将这些元素连接起来以得到加密后的短语`x`。
- en: 'Let’s take a closer look at how to encrypt each character. You use list comprehension
    (see [Chapter 2](ch02.xhtml#ch02)) to create the list of encrypted characters
    by replacing each character `c` with the character 13 positions to the right in
    the alphabet. It’s crucial to prevent overshooting for all characters in the alphabet
    with *index >= 13*. For instance, when shifting character `z` with index 25 by
    13 positions, you obtain index 25 + 13 = 38, which is not a valid index of the
    alphabet. To fix this, you use the modulo operator to ensure that when shifting
    a character beyond the maximum index 25 for character `z`, you restart our calculation
    of the final position of the character to be encrypted with *index == 0* (character
    `a`). Then, you proceed shifting to the right for the remaining of the 13 positions
    that have not already been applied before the restart (see [Figure 6-5](#ch06fig05)).
    For example, character `z` is shifted by 13 positions to index 38 modulo 26 (in
    Python code: `38%26`), which is index 12 or character `m`.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看如何加密每个字符。你使用列表推导（参见[第2章](ch02.xhtml#ch02)）通过将每个字符`c`替换为字母表中右移13个位置的字符来创建加密字符的列表。至关重要的是，要防止所有字母表中*索引
    >= 13*的字符出现溢出。例如，将字符`z`（索引25）向右移动13个位置，你会得到索引25 + 13 = 38，但38不是字母表中的有效索引。为了解决这个问题，你使用模运算符来确保当字符超出字母表最大索引25（字符`z`）时，重新计算字符的最终位置，且*索引
    == 0*（字符`a`）。然后，继续向右移动剩余的13个位置，这些位置在重新开始前还没有应用过（参见[图 6-5](#ch06fig05)）。例如，字符`z`被右移13个位置到索引38取模26（在Python代码中：`38%26`），结果是索引12，即字符`m`。
- en: '![images](Images/fig6-5.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![images](Images/fig6-5.jpg)'
- en: '*Figure 6-5: Preventing overshooting by restarting the shift operation at index
    0, which results in the following shift sequence: 25 > 0 > 1 > . . . > 12*'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-5：通过从索引0重新开始移位操作来防止过度移位， resulting in the following shift sequence: 25
    > 0 > 1 > . . . > 12*'
- en: 'Here’s the critical part of the code that shows exactly how each character
    `c` is shifted by 13 positions:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是代码的关键部分，展示了如何将每个字符`c`移动13个位置：
- en: '[PRE10]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: First, you find character `c`’s index in the alphabet `abc`. Second, you shift
    the index by adding the integer 13 to character `c`’s index in the alphabet `abc`
    considering our modulo 26 trick (as explained in the previous paragraphs).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你找到字符`c`在字母表`abc`中的索引。接着，你通过将整数13加到字符`c`的索引上来移动该索引，并考虑到我们之前提到的模26技巧。
- en: 'The result of the one-liner code snippet is the following:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这段单行代码的结果如下：
- en: '[PRE11]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: To summarize, you’ve learned the special variant of Caesar’s cipher, the ROT13
    algorithm, which shifts each character in a string by 13 positions in the alphabet.
    Shifting it twice by 13 + 13 = 26 index positions results in the original character,
    meaning encryption and decryption use the same algorithm.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，你已经学会了凯撒密码的特殊变体——ROT13算法，它将字符串中的每个字符在字母表中移动13个位置。将字符移动两次13 + 13 = 26个位置，结果得到原始字符，这意味着加密和解密使用相同的算法。
- en: '**Finding Prime Numbers with the Sieve of Eratosthenes**'
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用厄拉托斯特尼筛法寻找质数**'
- en: Finding prime numbers is of critical importance for practical applications such
    as cryptography. Many public-key methods are safe (from a cryptographic point
    of view) only because computation of prime factors of large numbers is generally
    inefficient and slow. We’ll make a one-liner that uses an ancient algorithm to
    root out all prime numbers from a range of numbers.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 找到质数对于加密等实际应用至关重要。许多公钥方法（从密码学的角度来看）之所以安全，是因为计算大数的质因数通常效率低下且缓慢。我们将制作一个单行代码，使用一种古老的算法从一个数字范围中找出所有质数。
- en: '***The Basics***'
  id: totrans-214
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基础知识***'
- en: 'A prime number *n* is an integer that’s not divisible without a remainder by
    any other integer, except for *i* and *n*. In other words, for a prime number,
    there are no two integers *a>1* and *b>1* whose product equals the prime number:
    *a**^b**=n*.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 质数 *n* 是一个整数，除了 *i* 和 *n* 外，不能被任何其他整数整除而没有余数。换句话说，对于一个质数，不存在两个整数 *a>1* 和 *b>1*
    使得它们的乘积等于该质数：*a**^b**=n*。
- en: Say you want to check whether your given number *n* is a prime number. Let’s
    start with a naive algorithm to determine prime numbers (see [Listing 6-7](#list6-7)).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想检查给定的数字 *n* 是否为质数。让我们从一个简单的算法开始来确定质数（参见 [清单6-7](#list6-7)）。
- en: '[PRE12]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 6-7: Naive implementation to check whether a given number `n` is prime*'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单6-7：检查给定数字 `n` 是否为质数的简单实现*'
- en: The algorithm checks all numbers between `2` and `n-1` ➊ to see whether the
    number `n` will divide evenly into it with no remainders ➋. For example, when
    determining whether number `n = 10` is a prime number, the algorithm quickly realizes
    that the expression `n % i == 0` evaluates to `True` for `i = 2`. It has found
    a number `i` that is a divisor of `n`, so `n` cannot be a prime number. In this
    case, the algorithm aborts any further computation and returns `False`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 算法检查 `2` 到 `n-1` 之间的所有数字 ➊，看看数字 `n` 是否能整除它而没有余数 ➋。例如，当确定数字 `n = 10` 是否是质数时，算法会迅速发现，表达式
    `n % i == 0` 对于 `i = 2` 计算结果为 `True`。它找到了一个能整除 `n` 的数字 `i`，因此 `n` 不能是质数。在这种情况下，算法会中止进一步的计算并返回
    `False`。
- en: 'The time complexity for checking a single number is the same as the input `n`:
    in the worst case, the algorithm needs `n` loop iterations to check whether number
    `n` is a prime number.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 检查一个数字的时间复杂度与输入的 `n` 相同：在最坏情况下，算法需要 `n` 次循环迭代来检查数字 `n` 是否为质数。
- en: Say you want to calculate all prime numbers from `2` to a certain maximal number
    `m`. You could simply repeat the prime test from [Listing 6-7](#list6-7) `m-1`
    times (see [Listing 6-8](#list6-8)). However, this comes at huge processing cost.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想计算从 `2` 到某个最大数字 `m` 之间的所有质数。你可以简单地重复 [清单6-7](#list6-7) 中的质数测试 `m-1` 次（参见
    [清单6-8](#list6-8)）。然而，这会带来巨大的处理成本。
- en: '[PRE13]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 6-8: Finding all prime numbers up to a maximal number `m`*'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单6-8：找出所有小于最大数字 `m` 的质数*'
- en: Here we use list comprehension (see [Chapter 2](ch02.xhtml#ch02)) to create
    a list with all prime numbers smaller than `m`. We introduce a `for` loop, meaning
    the algorithm requires `m` function calls of `is_prime(n)` and so the time complexity
    is bounded by `m**2`. The number of operations grows quadratically with the input
    `m`. To find all prime numbers smaller than `m = 100` takes up to `m**2 = 10000`
    operations!
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们使用列表推导式（参见 [第2章](ch02.xhtml#ch02)）来创建一个包含所有小于 `m` 的质数的列表。我们引入了一个 `for` 循环，这意味着算法需要
    `m` 次调用 `is_prime(n)` 函数，因此时间复杂度为 `m**2`。操作次数随输入 `m` 的增加呈平方增长。要找出所有小于 `m = 100`
    的质数，需要进行最多 `m**2 = 10000` 次操作！
- en: We’ll build a one-liner to drastically reduce this time cost.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个单行代码，显著减少这个时间成本。
- en: '***The Code***'
  id: totrans-226
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: With this one-liner, we’ll write an algorithm to find all prime numbers up to
    a maximal integer number `m` that is more time efficient than our naive implementation.
    The one-liner in [Listing 6-9](#list6-9) is inspired by an ancient algorithm called
    the Sieve of Eratosthenes, which I’ll explain in this section.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这行单行代码，我们将编写一个算法，找出所有小于最大整数 `m` 的质数，且该算法比我们的简单实现更高效。清单 [6-9](#list6-9) 中的单行代码灵感来自一种古老的算法——厄拉托斯特尼筛法，我将在本节中解释该算法。
- en: '[PRE14]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 6-9: One-liner solution implementing the Sieve of Eratosthenes*'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单6-9：实现厄拉托斯特尼筛法的单行代码解决方案*'
- en: You’ll likely need some additional background knowledge to understand what happens
    here.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这里发生了什么，您可能需要一些额外的背景知识。
- en: '***How It Works***'
  id: totrans-231
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***它是如何工作的***'
- en: To be frank, I was hesitant to include this one-liner in the book. It’s confusing,
    complex, and unreadable. Still, this is the type of code you face in practice,
    and with this book, I want to ensure you’re able to understand every single line
    of code—even if it takes some time. I stumbled upon a version of this one-liner
    at StackOverflow. It is loosely based on an ancient algorithm called the *Sieve
    of Eratosthenes* that was designed to calculate prime numbers.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 坦白说，我曾犹豫是否将这行代码包括在书中。它令人困惑、复杂且难以阅读。然而，这正是你在实践中会遇到的代码类型，借助这本书，我希望确保你能理解每一行代码——即使需要一些时间。我在
    StackOverflow 上偶然看到了这个单行代码版本。它大致基于一种古老的算法——*厄拉托斯特尼筛法*，该算法用于计算质数。
- en: '**NOTE**'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*I modified the original StackOverflow one-liner for clarity. The original
    one-liner can be found at* [https://stackoverflow.com/questions/10639861/python-prime-generator-in-one-line/](https://stackoverflow.com/questions/10639861/python-prime-generator-in-one-line/)
    *at the time of this writing.*'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '*为了清晰起见，我修改了原始的StackOverflow一行代码。原始的一行代码可以在* [https://stackoverflow.com/questions/10639861/python-prime-generator-in-one-line/](https://stackoverflow.com/questions/10639861/python-prime-generator-in-one-line/)
    *找到，截止到本文撰写时。*'
- en: '**The Sieve of Eratosthenes Algorithm**'
  id: totrans-235
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**埃拉托斯特尼筛法**'
- en: The algorithm creates (conceptually) a huge array of numbers from `2` to `m`,
    the maximal integer number. All the numbers in the array are *prime candidates*,
    which means that the algorithm considers them to be prime numbers *potentially*
    (but not *necessarily*). During the algorithm, you sieve out the candidates that
    cannot be prime. Only the ones that remain after this filtering process are the
    final prime numbers.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 算法（概念上）创建了一个包含从`2`到*m*，最大整数值的巨大数字数组。数组中的所有数字都是*质数候选者*，意味着算法认为它们可能是质数（但不一定）。在算法的执行过程中，你会筛选掉不能是质数的候选者。只有在这个筛选过程中留下的数字，才是最终的质数。
- en: To accomplish this, the algorithm calculates and marks the numbers in this array
    that are not prime numbers. At the end, all unmarked numbers are prime numbers.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，算法会计算并标记数组中不是质数的数字。最后，所有未标记的数字就是质数。
- en: 'The algorithm repeats the following steps:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 算法重复以下步骤：
- en: Start with the first number 2 and increment it in every step of the process
    until you find a prime number *x*. You know that *x* is prime if it is unmarked
    because the fact that *x* is unmarked means that no smaller number than *x* is
    a divisor of *x*—the definition of a prime number.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从第一个数字2开始，并在每一步中递增，直到找到一个质数*x*。你知道*x*是质数，如果它未被标记，因为*x*未被标记意味着没有任何小于*x*的数字是它的除数——这就是质数的定义。
- en: 'Mark all multiples of number *x* because they are also not prime: number *x*
    is a divisor of all those numbers.'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 标记所有数字*x*的倍数，因为它们也不是质数：数字*x*是所有这些数字的除数。
- en: 'Perform simple optimization: start marking multiples from number *x × x* instead
    of *2x* because all numbers between *2x* and *x × x* are already marked. There
    is a simple mathematical argument for this that I will describe later. For now,
    know that you can start marking from *x × x*.'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进行简单优化：从数字*x × x*开始标记倍数，而不是从*2x*开始，因为所有在*2x*和*x × x*之间的数字已经被标记。这个优化有一个简单的数学推导，我稍后会描述。现在，只需知道你可以从*x
    × x*开始标记。
- en: '[Figures 6-6](#ch06fig06) to [6-11](#ch06fig11) explain this algorithm step-by-step.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-6](#ch06fig06)到[6-11](#ch06fig11)逐步解释了这个算法。'
- en: '![images](Images/fig6-6.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![images](Images/fig6-6.jpg)'
- en: '*Figure 6-6: Initializing the Sieve of Eratosthenes algorithm*'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-6：初始化埃拉托斯特尼筛法算法*'
- en: Initially, all numbers between 2 and *m* = 100 are unmarked (white cells). The
    first unmarked number 2 is a prime number.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，所有2到*m* = 100之间的数字都未标记（白色单元格）。第一个未标记的数字2是一个质数。
- en: '![images](Images/fig6-7.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![images](Images/fig6-7.jpg)'
- en: '*Figure 6-7: Mark all multiples of 2 because they are not prime. Ignore the
    marked numbers for the rest of the algorithm.*'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-7：标记所有2的倍数，因为它们不是质数。忽略接下来算法中的已标记数字。*'
- en: '![images](Images/fig6-8.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![images](Images/fig6-8.jpg)'
- en: '*Figure 6-8: Mark multiples of 3 as “non-prime.”*'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-8：标记3的倍数为“非质数”。*'
- en: Increment to the next unmarked number, 3\. Because it is unmarked at this point,
    it is a prime number. Because you have marked all multiples of numbers smaller
    than the current number 3, no smaller number is a divisor of 3\. By definition,
    number 3 must be prime. Mark all multiples of 3 because they are not prime. Start
    marking from number 3 × 3 because all multiples of 3 between 3 and 3 × 3 = 9 are
    already marked.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 增加到下一个未标记的数字3。由于此时它未被标记，它是一个质数。由于你已经标记了所有小于当前数字3的倍数，因此没有任何小于3的数字是它的除数。根据定义，数字3必须是质数。标记所有3的倍数，因为它们不是质数。从数字3
    × 3开始标记，因为在3和3 × 3 = 9之间的所有3的倍数已经被标记。
- en: '![images](Images/fig6-9.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![images](Images/fig6-9.jpg)'
- en: '*Figure 6-9: Mark multiples of 5 as “non-prime.”*'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-9：标记5的倍数为“非质数”。*'
- en: Go to the next unmarked number, 5 (which is a prime number). Mark all multiples
    of 5\. Start marking from number 5 × 5 because all multiples of 5 between 5 and
    5 × 5 = 25 are already marked.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 转到下一个未标记的数字5（它是一个质数）。标记所有5的倍数。从数字5 × 5开始标记，因为在5和5 × 5 = 25之间的所有5的倍数已经被标记。
- en: '![images](Images/fig6-10.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![images](Images/fig6-10.jpg)'
- en: '*Figure 6-10: Mark multiples of 7 as “non-prime.”*'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-10：标记7的倍数为“非质数”。*'
- en: Increment to the next unmarked number, 7 (which is a prime number). Mark all
    multiples of 7\. Start marking from number 7 × 7 because all multiples of 7 between
    7 and 7 × 7 = 49 are already marked.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 增加到下一个未标记的数字7（它是一个素数）。标记所有7的倍数。从7 × 7开始标记，因为7到7 × 7 = 49之间的所有7的倍数已经被标记过。
- en: '![images](Images/fig6-11.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![images](Images/fig6-11.jpg)'
- en: '*Figure 6-11: Mark multiples of 11 as “non-prime.”*'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-11：将11的倍数标记为“非素数”。*'
- en: Increment to the next unmarked number, 11 (which is a prime number). Mark all
    multiples of 11\. Because you would start marking from number 11 × 11=121, you
    realize that this is already larger than our maximal number *m* = 100\. This causes
    the algorithm to terminate. All remaining unmarked numbers are not divisible by
    any number and are, therefore, prime numbers.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 增加到下一个未标记的数字11（它是一个素数）。标记所有11的倍数。因为你将从数字11 × 11 = 121开始标记，你会发现它已经大于我们的最大值*m*
    = 100。这使得算法终止。所有剩余的未标记数字都不能被任何数字整除，因此它们是素数。
- en: 'The Sieve of Eratosthenes is much more efficient than the naive algorithm because
    the naive algorithm checks each number *independently*, ignoring all previous
    computations. The Sieve of Eratosthenes, on the other hand, *reuses* results from
    previous computational steps—a common idea in many areas of algorithmic optimization.
    Each time we cross out multiples of a prime number, we essentially save ourselves
    the tedious work of checking whether this multiple is a prime number: we already
    know that it isn’t.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 埃拉托斯特尼筛法比朴素算法高效得多，因为朴素算法会*独立*地检查每个数字，忽略了之前的所有计算。而埃拉托斯特尼筛法则*重用*前面计算步骤的结果——这是许多算法优化领域中的一个常见思路。每次我们划去一个素数的倍数时，实际上是节省了检查这个倍数是否为素数的繁琐工作：我们已经知道它不是素数。
- en: 'You may wonder why we start marking from the squared prime number instead of
    the prime number itself. For example, in the algorithm in [Figure 6-10](#ch06fig10),
    you just found prime number 7 and start marking from number 7 × 7 = 49\. The reason
    is that you already marked all other multiples in previous iterations 7 × 2, 7
    × 3, 7 × 4, 7 × 5, 7 × 6 because you marked all multiples of numbers smaller than
    the current prime number 7: 2, 3, 4, 5, 6.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会疑惑，为什么我们从平方的素数开始标记，而不是从素数本身开始。举例来说，在[图6-10](#ch06fig10)中的算法中，你刚刚找到了素数7，并从7
    × 7 = 49开始标记。原因是，你已经在之前的迭代中标记了所有其他倍数，如7 × 2、7 × 3、7 × 4、7 × 5、7 × 6，因为你已经标记了所有比当前素数7小的数字的倍数：2、3、4、5、6。
- en: '**One-Liner Explained**'
  id: totrans-262
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**单行代码解析**'
- en: 'Equipped with a thorough conceptual understanding of the algorithm, you can
    now start investigating the one-liner solution:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 具备了对算法的全面概念理解后，你可以开始研究单行代码的解决方案：
- en: '[PRE15]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This one-liner uses the `reduce()` function to remove, one step at a time,
    all marked numbers from the initial set of all numbers between `2` and `n` (in
    the one-liner: `set(range(2, n))`).'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这个单行代码使用`reduce()`函数一步一步地从初始的所有数字集合中移除已标记的数字（在单行代码中：`set(range(2, n))`）。
- en: 'You take this set as the initial value for the set of unmarked values `r` because,
    initially, all values are unmarked. Now the one-liner goes over all numbers `x`
    between `2` and the square root of `n` (in the one-liner: `range(2, int(n**0.5)
    + 1)`) and removes the multiples of `x` from the set `r` (starting at `x**2`)—but
    only if the number `x` is a prime number, known because it is not removed from
    the set `r` at the current time.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个集合作为未标记值`r`的初始值，因为最开始时，所有的值都是未标记的。现在，这个单行代码会遍历所有`2`到`n`平方根之间的数字`x`（在单行代码中：`range(2,
    int(n**0.5) + 1)`），并从集合`r`中移除`x`的倍数（从`x**2`开始）——但仅当数字`x`是素数时，因为它在当前时刻没有从集合`r`中移除。
- en: Spend 5–15 minutes rereading this explanation and study the different parts
    of the one-liner carefully. I promise you’ll find this exercise worthwhile, as
    it will significantly improve your Python code understanding skills.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 花5到15分钟重新阅读这段解释，仔细研究单行代码的不同部分。我保证你会觉得这个练习值得，因为它将显著提高你对Python代码的理解能力。
- en: '**Calculating the Fibonacci Series with the reduce() Function**'
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用reduce()函数计算斐波那契数列**'
- en: 'The popular Italian mathematician Fibonacci (original name: Leonardo of Pisa)
    introduced the Fibonacci numbers in the year 1202 with the surprising observation
    that these numbers have significance in fields as various as math, art, and biology.
    This section will show you how to compute the Fibonacci numbers in a single line
    of code.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 受欢迎的意大利数学家斐波那契（原名：比萨的莱昂纳多）在1202年引入了斐波那契数，并令人惊讶地观察到这些数字在数学、艺术和生物学等多个领域都有重要意义。本节将向你展示如何用一行代码计算斐波那契数。
- en: '***The Basics***'
  id: totrans-270
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基础知识***'
- en: The Fibonacci series starts with the numbers 0 and 1, and then, each element
    that follows is the sum of the two previous series elements. The Fibonacci series
    has the algorithm built in!
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 斐波那契数列从0和1开始，然后，每个后续的元素是前两个元素的和。斐波那契数列的算法是内置的！
- en: '***The Code***'
  id: totrans-272
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: '[Listing 6-10](#list6-10) calculates a list of the *n* first Fibonacci numbers
    starting with the numbers 0 and 1.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 6-10](#list6-10)计算了从0和1开始的前*n*个斐波那契数的列表。'
- en: '[PRE16]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 6-10: Calculating the Fibonacci series in one line of Python code*'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-10：用一行Python代码计算斐波那契数列*'
- en: Study this code and take a guess at the output.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 研究这段代码并猜测输出结果。
- en: '***How It Works***'
  id: totrans-277
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***原理解析***'
- en: You’ll again use the powerful `reduce()` function. In general, this function
    is useful if you want to aggregate state information that’s computed on the fly;
    for example, when you use the previous two Fibonacci numbers just computed to
    compute the next Fibonacci number. This is difficult to achieve with list comprehension
    (see [Chapter 2](ch02.xhtml#ch02)), which can’t generally access the values that
    have been newly created from the list comprehension.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 你将再次使用强大的`reduce()`函数。一般来说，当你需要聚合实时计算的状态信息时，这个函数非常有用；例如，当你使用前两个计算出的斐波那契数来计算下一个斐波那契数时。这是使用列表推导式难以实现的（参见[第2章](ch02.xhtml#ch02)），因为列表推导式通常无法访问从中新创建的值。
- en: You use the `reduce()` function with three arguments that correspond to `reduce(function,
    iterable, initializer)` to consecutively add the new Fibonacci number to an aggregator
    object that incorporates one value at a time from the `iterable` object as specified
    by the `function`.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用`reduce()`函数，并传入三个参数，分别对应`reduce(function, iterable, initializer)`，依次将新的斐波那契数添加到聚合器对象中，`function`指定了如何将`iterable`对象中的每一个值依次合并到该聚合器对象中。
- en: Here, you use a simple list as the aggregator object with the two initial Fibonacci
    numbers `[0, 1]`. Remember that the aggregator object is handed as the first argument
    to the `function` (in our example, `x`).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你使用一个简单的列表作为聚合器对象，初始斐波那契数为`[0, 1]`。记住，聚合器对象作为第一个参数传递给`function`（在我们的示例中是`x`）。
- en: The second argument is the next element from the `iterable`. However, you initialized
    the `iterable` with `(n-2)` dummy values in order to force the `reduce()` function
    to execute `function` `(n-2)` times (the goal is to find the first `n` Fibonacci
    numbers—but you already have the first two, 0 and 1) You use the throwaway parameter
    `_` to indicate that you are not interested in the dummy values of the `iterable`.
    Instead, you simply append the new Fibonacci number to the aggregator list `x`,
    calculated as the sum of the previous two Fibonacci numbers.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数是来自`iterable`的下一个元素。然而，你通过初始化`iterable`为`(n-2)`个虚拟值来强制`reduce()`函数执行`function`
    `(n-2)`次（目标是找到前`n`个斐波那契数——但你已经有了前两个，0和1）。你使用丢弃参数`_`表示你对`iterable`的虚拟值不感兴趣。相反，你只需将新计算的斐波那契数附加到聚合器列表`x`中，这个新数是前两个斐波那契数之和。
- en: '**AN ALTERNATIVE MULTILINE SOLUTION**'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '**另一种多行解决方案**'
- en: Repeatedly summing two Fibonacci numbers was already the simple idea of the
    one-liner in [Listing 6-10](#list6-10). [Listing 6-11](#list6-11) gives a beautiful
    alternative solution.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 反复求和两个斐波那契数已经是[清单 6-10](#list6-10)中单行代码的简单思路。[清单 6-11](#list6-11)提供了一种美丽的替代方案。
- en: '[PRE17]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 6-11: One-liner solution to find the Fibonacci numbers in an iterative
    manner*'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-11：以迭代方式查找斐波那契数的单行代码解决方案*'
- en: 'This code snippet was submitted by one of my email subscribers (feel free to
    join us at [https://blog.finxter.com/subscribe/](https://blog.finxter.com/subscribe/))
    and uses list comprehension with side effects: the variable x is updated `n-2`
    times with the new Fibonacci series element. Note that the `append()` function
    has no return value, but returns None, which evaluates to `False`. Thus, the list
    comprehension statement generates a list of integers using the following idea:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码片段是由我的一位电子邮件订阅者提交的（欢迎加入我们，访问 [https://blog.finxter.com/subscribe/](https://blog.finxter.com/subscribe/)），它使用了带有副作用的列表推导式：变量x被更新`n-2`次，获取新的斐波那契数列元素。请注意，`append()`函数没有返回值，而是返回None，这在布尔值上下文中被视为`False`。因此，列表推导式通过以下思路生成一个整数列表：
- en: '[PRE18]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: It doesn’t seem correct to perform the `or` operation on two integers, but remember
    that the Boolean type is based on the integer type. Every integer value other
    than 0 is interpreted as True. Thus, the `or` operation simply uses the second
    integer value as a return value instead of converting it to an explicit Boolean
    value of True. A fine piece of Python code!
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个整数之间执行`or`运算似乎不太正确，但请记住，布尔类型是基于整数类型的。除了0之外的每个整数值都被解释为True。因此，`or`操作只是将第二个整数值作为返回值，而不是将其转换为显式的布尔值True。这是一段精妙的Python代码！
- en: 'In summary, you’ve improved your understanding of another important pattern
    for Python one-liners: using the `reduce()` function to create a list that dynamically
    uses the freshly updated or added list elements to compute new list elements.
    You will find this useful pattern quite often in practice.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，你已经提高了对Python一行代码中的另一个重要模式的理解：使用`reduce()`函数创建一个列表，该列表动态地使用新更新或添加的元素来计算新的列表元素。你在实践中会经常遇到这个有用的模式。
- en: '**A Recursive Binary Search Algorithm**'
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**一个递归二分查找算法**'
- en: 'In this section, you’ll learn about a basic algorithm every computer scientist
    must know: the binary search algorithm. Binary search has important practical
    applications in many implementations of basic data structures such as sets, trees,
    dictionaries, hash sets, hash tables, maps, and arrays. You use these data structures
    in every single nontrivial program.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，你将学习每个计算机科学家必须掌握的基本算法：二分查找算法。二分查找在许多基本数据结构的实现中有着重要的实际应用，比如集合、树、字典、哈希集合、哈希表、映射和数组。你在每个非平凡的程序中都会使用到这些数据结构。
- en: '***The Basics***'
  id: totrans-292
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基础知识***'
- en: 'In brief, the *binary search algorithm* searches a sorted sequence of values
    `l` for a particular value `x` by repeatedly reducing the size of the sequence
    by half until only a single value is left: either it’s the searched value or it
    doesn’t exist in the sequence. In the following, you will examine this general
    idea in detail.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，*二分查找算法*通过不断将序列的大小减半，来查找排序后的值序列`l`中的特定值`x`，直到只剩下一个值：它要么是要查找的值，要么在序列中不存在。接下来，你将详细了解这一通用思想。
- en: For example, say you want to search a sorted list for value 56\. A naive algorithm
    would start with the first list element, check whether it’s equal to the value
    56, and move on to the next list element until it has checked all elements or
    found its value. In the worst case, the algorithm goes over every list element.
    A sorted list with 10,000 elements would take approximately 10,000 operations
    to check each list element for equality with the searched value. In algorithmic
    theory language, we say that the runtime complexity is *linear* in the number
    of list elements. The algorithm does not leverage all the available information
    to achieve the greatest efficiency.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你想在一个已排序的列表中查找值56。一个简单的算法会从列表的第一个元素开始，检查它是否等于56，并继续检查下一个元素，直到检查完所有元素或者找到该值。在最坏的情况下，算法会遍历每一个列表元素。一个包含10,000个元素的已排序列表，需要大约10,000次操作来检查每个元素是否等于要查找的值。在算法理论中，我们说运行时间的复杂度是*线性*的，即与列表元素的数量成正比。这个算法没有利用所有可用信息来实现最大效率。
- en: The first piece of useful information is that the list is sorted! Using this
    fact, you can create an algorithm that touches only a few elements in the list
    and still knows with absolute certainty whether an element exists in the list.
    The binary search algorithm traverses only *log2(n)* elements (logarithm of base
    2). You can search the same list of 10,000 elements by using only *log2*(10,000)
    < 14 operations!
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个有用的信息是，列表是已排序的！利用这一点，你可以创建一个只接触少量元素的算法，并且仍然能绝对确定某个元素是否存在于列表中。二分查找算法只遍历*log2(n)*个元素（以2为底的对数）。你只需要进行*log2*(10,000)
    < 14次操作，就能查找一个包含10,000个元素的列表！
- en: For a binary search, you assume the list is sorted in an ascending manner. The
    algorithm starts by checking the middle element. If the middle value is bigger
    than the value you want, you know that all elements between the middle and the
    last list elements are larger than the value you want. The value you want won’t
    exist in this half of the list, so you can immediately reject half of the list
    elements with a single operation.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 对于二分查找，你假设列表按升序排列。算法从检查中间元素开始。如果中间值大于你想要的值，你知道中间和列表最后部分之间的所有元素都大于你想要的值。你想要的值不会出现在这一半的列表中，所以你可以通过一次操作立即排除掉这一半的元素。
- en: Similarly, if the searched value is larger than the middle element, you can
    reject the first half of the list elements. You then simply repeat the procedure
    of halving the effective list size of elements to be checked in each step of the
    algorithm. [Figure 6-12](#ch06fig12) shows a visual example.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，如果搜索的值大于中间元素，你可以排除列表的前半部分元素。然后，只需重复每一步将有效列表大小减半的过程来检查元素。 [图 6-12](#ch06fig12)
    展示了一个可视化示例。
- en: '![images](Images/fig6-12.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/fig6-12.jpg)'
- en: '*Figure 6-12: Example run of the binary search algorithm*'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-12：二分查找算法的示例运行*'
- en: If the sublist contains an even number of elements, there’s no obvious middle
    element. In this case, you round down the index of the middle element.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 如果子列表包含偶数个元素，则没有明显的中间元素。在这种情况下，你需要向下取整中间元素的索引。
- en: 'You want to find the value 56 in the sorted list of eight integer values while
    touching as few elements as possible. The binary search algorithm checks middle
    element *x* (rounding down), then discards the half of the list that 56 cannot
    possibly be in. There are three general results of this check:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 你想在一个排序的八个整数值的列表中找到值 56，并且尽量减少触碰的元素。二分查找算法检查中间元素 *x*（向下取整），然后丢弃列表中不可能包含 56 的那一半。这个检查有三种一般结果：
- en: Element *x* is larger than 56\. The algorithm ignores the right part of the
    list.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元素 *x* 大于 56\。算法忽略了列表的右半部分。
- en: Element *x* is smaller than value 56\. The algorithm ignores the left part of
    the list.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元素 *x* 小于 56\。算法忽略了列表的左半部分。
- en: Element *x* is equal to value 56, as in the last line in [Figure 6-12](#ch06fig12).
    Congratulations—you have just found desired value!
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元素 *x* 等于 56，如 [图 6-12](#ch06fig12) 中的最后一行所示。恭喜你——你刚刚找到了所需的值！
- en: '[Listing 6-12](#list6-12) shows a practical implementation of the binary search
    algorithm.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 6-12](#list6-12) 展示了二分查找算法的实际实现。'
- en: '[PRE19]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 6-12: The binary search algorithm*'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-12：二分查找算法*'
- en: 'This algorithm takes as arguments a list and a value to search for. It then
    repeatedly halves the search space by using the two variables `lo` and `hi`, which
    define the interval of possible list elements in which the desired value could
    exist: `lo` defines the start index, and `hi` defines the end index of the interval.
    You check which of the cases the mid element falls in and adapt the interval of
    potential elements accordingly by modifying the `lo` and `hi` values as described.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法接受一个列表和一个待查找的值作为参数。然后，它通过使用两个变量 `lo` 和 `hi` 来反复将搜索空间减半，这两个变量定义了可能包含所需值的列表元素区间：`lo`
    定义了起始索引，`hi` 定义了区间的结束索引。你检查中间元素落在哪种情况中，并通过调整 `lo` 和 `hi` 的值来适应潜在元素的区间，如所描述的那样。
- en: While this is a perfectly valid, readable, and efficient implementation of the
    binary search algorithm, it’s not a one-liner solution, yet!
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一个完全有效、可读且高效的二分查找算法实现，但它还不是一个真正的一行解决方案！
- en: '***The Code***'
  id: totrans-310
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: Now you’ll implement the binary search algorithm in a single line of code (see
    [Listing 6-13](#list6-13))!
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你将用一行代码实现二分查找算法（见 [清单 6-13](#list6-13)）！
- en: '[PRE20]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 6-13: One-liner solution to implement binary search*'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-13：实现二分查找的单行解决方案*'
- en: Guess the output of this code snippet!
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 猜猜这段代码的输出是什么！
- en: '***How It Works***'
  id: totrans-315
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***它是如何工作的***'
- en: Because binary search lends itself naturally to a recursive approach, studying
    this one-liner will strengthen your intuitive understanding of this important
    computer science concept. Note that I’ve broken this one-liner solution into four
    lines for readability, though you can, of course, write it in a single line of
    code. In this one-liner, I’ve used a recursive way of defining the binary search
    algorithm.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 因为二分查找天然适合递归方法，学习这段一行代码将增强你对这一重要计算机科学概念的直观理解。注意，尽管我为了可读性将这段一行代码拆分成四行，你当然可以将它写成一行代码。在这段一行代码中，我采用了递归的方式定义二分查找算法。
- en: 'You create a new function `bs` by using the `lambda` operator with four arguments:
    `l`, `x`, `lo`, and `hi` ➊. The first two arguments `l` and `x` are variables
    with the sorted list and the value to search for. The `lo` and `hi` arguments
    define the minimal and the maximal index of the current sublist to be searched
    for the value `x`. At each recursion level, the code checks a sublist specified
    by the indices `hi` and `lo`, which becomes smaller and smaller by increasing
    the index `lo` and decreasing the index `hi`. After a finite number of steps,
    the condition `lo>hi` holds `True`. The searched sublist is empty—and you haven’t
    found the value `x`. This is the base case of our recursion. Because you haven’t
    found element `x`, you return `-1`, indicating that no such element exists.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过使用 `lambda` 运算符和四个参数：`l`、`x`、`lo` 和 `hi` ➊ 创建了一个新的函数 `bs`。前两个参数 `l` 和 `x`
    是变量，分别表示排序后的列表和要查找的值。`lo` 和 `hi` 参数定义了当前子列表中要查找值 `x` 的最小和最大索引。在每一层递归中，代码会检查由 `hi`
    和 `lo` 指定的子列表，随着索引 `lo` 增大和索引 `hi` 减小，子列表会越来越小。经过有限的步骤后，条件 `lo>hi` 为 `True`，此时搜索的子列表为空——你没有找到值
    `x`。这是我们递归的基准情况。因为你没有找到元素 `x`，所以返回 `-1`，表示没有此元素。
- en: You use the calculation `(lo+hi)//2` to find the middle element of the sublist.
    If this happens to be your desired value, you return the index of that mid element
    ➋. Note that you use integer division to round down to the next integer value
    that can be used as a list index.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用计算 `(lo+hi)//2` 来找到子列表的中间元素。如果这个元素恰好是你想要的值，你就返回该中间元素的索引 ➋。请注意，你使用整数除法来向下取整到下一个可用的整数值，该值可以作为列表的索引。
- en: If the mid element is larger than the desired value, it means the elements on
    the right are also larger, so you call the function recursively but adapt the
    `hi` index to consider only list elements on the left of the mid element ➌.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 如果中间元素大于所需值，意味着右侧的元素也较大，因此你会递归调用该函数，但将 `hi` 索引调整为仅考虑中间元素左侧的列表元素 ➌。
- en: Similarly, if the mid element is smaller than the desired value, there is no
    need to search all elements on the left of the mid element, so you call the function
    recursively but adapt the `lo` index to consider only list elements on the right
    of the mid element ➍.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果中间元素小于所需值，那么就没有必要搜索中间元素左边的所有元素，因此你会递归调用该函数，但将 `lo` 索引调整为仅考虑中间元素右侧的列表元素
    ➍。
- en: When searching for the value `33` in the list `[3, 6, 14, 16, 33, 55, 56, 89]`,
    the result is the index `4`.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表 `[3, 6, 14, 16, 33, 55, 56, 89]` 中查找值 `33` 时，结果是索引 `4`。
- en: This one-liner section has strengthened your general code understanding regarding
    features such as conditional execution, basic keywords, and arithmetic operations,
    as well as the important topic of programmatic sequence indexing. More important,
    you’ve learned how to use recursion to make complex problems easier.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行代码的部分加强了你对一些基本编程特性的理解，如条件执行、基础关键字、算术运算以及程序化序列索引等重要主题。更重要的是，你学会了如何利用递归使复杂的问题变得更简单。
- en: '**A Recursive Quicksort Algorithm**'
  id: totrans-323
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**递归快速排序算法**'
- en: Now you’ll build a one-liner to use the popular algorithm *Quicksort*, a sorting
    algorithm that, as the name suggests, quickly sorts the data.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你将构建一个一行代码来使用这种流行的算法 *快速排序*，顾名思义，它能快速地对数据进行排序。
- en: '***The Basics***'
  id: totrans-325
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基础知识***'
- en: Quicksort is both a popular question in many code interviews (asked by Google,
    Facebook, and Amazon) and a practical sorting algorithm that’s fast, concise,
    and readable. Because of its elegance, most introductory algorithm classes cover
    Quicksort.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 快速排序是许多编程面试中的常见问题（谷歌、Facebook 和亚马逊都会问），同时它也是一种高效、简洁、易读的实际排序算法。由于其优雅性，大多数入门级算法课程都会讲解快速排序。
- en: Quicksort sorts a list by recursively dividing the big problem into smaller
    problems and combining the solutions from the smaller problems in a way that it
    solves the big problem.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 快速排序通过递归地将大问题分解为更小的问题，并以合并小问题的解决方案的方式解决大问题，从而对列表进行排序。
- en: 'To solve each smaller problem, the same strategy is used recursively: the smaller
    problems are divided into even smaller subproblems, solved separately, and combined,
    placing Quicksort in the class of *Divide and Conquer* algorithms.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 为了求解每个更小的问题，同样的策略会递归使用：将更小的问题进一步分解成更小的子问题，单独求解并合并，从而将快速排序归类为 *分治法* 算法。
- en: 'Quicksort selects a *pivot* element and then places all elements that are larger
    than the pivot to the right, and all elements that are smaller than or equal to
    the pivot to the left. This divides the big problem of sorting the list into two
    smaller subproblems: sorting two smaller lists. You then repeat this procedure
    recursively until you obtain a list with zero elements that, being sorted, causes
    the recursion to terminate.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 快速排序选择一个*枢轴*元素，然后将所有大于枢轴的元素放到右侧，将所有小于或等于枢轴的元素放到左侧。这将排序列表的巨大问题分解为两个较小的子问题：排序两个更小的列表。然后，你递归地重复这一过程，直到获得一个包含零个元素的列表，该列表已排序，因此递归终止。
- en: '[Figure 6-13](#ch06fig13) shows the Quicksort algorithm in action.'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '[Figure 6-13](#ch06fig13)展示了快速排序算法的实际运行。'
- en: '![images](Images/fig6-13.jpg)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![images](Images/fig6-13.jpg)'
- en: '*Figure 6-13: Example run of the Quicksort algorithm*'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '*Figure 6-13：快速排序算法的示例运行*'
- en: '[Figure 6-13](#ch06fig13) shows the Quicksort algorithm on a list of unsorted
    integers [4, 1, 8, 9, 3, 8, 1, 9, 4]. First, it selects 4 as the pivot element,
    splits up the list into an unsorted sublist [1, 3, 1, 4] with all elements that
    are smaller than or equal to the pivot, and an unsorted sublist [8, 9, 8, 9] with
    all elements that are larger than the pivot.'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '[Figure 6-13](#ch06fig13)展示了快速排序算法在一个无序整数列表[4, 1, 8, 9, 3, 8, 1, 9, 4]上的应用。首先，它选择4作为枢轴元素，将列表分成一个无序子列表[1,
    3, 1, 4]（其中所有元素小于或等于枢轴）和一个无序子列表[8, 9, 8, 9]（其中所有元素大于枢轴）。'
- en: Next, the Quicksort algorithm is called recursively on the two unsorted sublists
    to sort them. As soon as the sublists contain maximally one element, they are
    sorted by definition, and the recursion ends.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，快速排序算法递归地对这两个无序子列表进行排序。一旦子列表最多只包含一个元素，它们就被认为已排序，递归结束。
- en: At every recursion level, the three sublists (left, pivot, right) are concatenated
    before the resulting list is handed to the higher recursion level.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在每一层递归中，三个子列表（左子列表、枢轴、右子列表）会被连接起来，然后将结果列表传递给更高一层的递归。
- en: '***The Code***'
  id: totrans-336
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: You’ll create a function `q` that implements the Quicksort algorithm in a single
    line of Python and sorts any argument given as a list of integers (see [Listing
    6-14](#list6-14)).
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 你将创建一个`q`函数，在一行Python代码中实现快速排序算法，并对任何作为整数列表传递的参数进行排序（见[Listing 6-14](#list6-14)）。
- en: '[PRE21]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 6-14: One-liner solution for the Quicksort algorithm using recursion*'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 6-14：使用递归实现快速排序算法的单行解决方案*'
- en: Now, can you guess—one last time—the output of the code?
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你能猜到——最后一次——这段代码的输出吗？
- en: '***How It Works***'
  id: totrans-341
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***工作原理***'
- en: 'The one-liner directly resembles the algorithm we just discussed. First, you
    create a new lambda function `q` that takes one list argument `l` to sort. From
    a high-level perspective, the lambda function has the following basic structure:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码直接类似于我们刚才讨论的算法。首先，你创建一个新的`q` lambda函数，它接收一个列表参数`l`用于排序。从高层次来看，lambda函数具有以下基本结构：
- en: '[PRE22]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the recursion base case—that is, the case that the list is empty and, therefore,
    trivially sorted—the lambda function returns the empty list `[]`.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在递归的基本情况中——即列表为空，因此可以被认为已经排序——lambda函数返回空列表`[]`。
- en: 'In any other case, the function selects the pivot element as the first element
    of list `l`, and divides all elements into two sublists (`left` and `right`) based
    on whether they are smaller or larger than the pivot. To achieve this, you use
    simple list comprehension (see [Chapter 2](ch02.xhtml#ch02)). As the two sublists
    are not necessarily sorted, you recursively execute the Quicksort algorithm on
    them too. Finally, you combine all three lists and return the sorted list. Therefore,
    the result is as follows:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他任何情况下，函数将列表`l`的第一个元素作为枢轴元素，并根据元素是否小于或大于枢轴来将所有元素分为两个子列表（`left`和`right`）。为了实现这一点，你使用了简单的列表推导（见[第2章](ch02.xhtml#ch02)）。由于两个子列表未必已经排序，你也会对它们递归地执行快速排序算法。最后，你将三个子列表合并并返回排序后的列表。因此，结果如下：
- en: '[PRE23]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '**Summary**'
  id: totrans-347
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter, you’ve learned important algorithms in computer science addressing
    a wide range of topics including anagrams, palindromes, powersets, permutations,
    factorials, prime numbers, Fibonacci numbers, obfuscation, searching, and sorting.
    Many of these form the basis of more advanced algorithms and contain the seeds
    of a thorough algorithmic education. Advancing your knowledge of algorithms and
    algorithmic theory is one of the most effective ways to improve as a coder. I
    would even say that the lack of algorithmic understanding is the number one reason
    most intermediate coders feel stuck in their learning progress.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学习了计算机科学中的重要算法，涵盖了包括变位词、回文、幂集、排列、阶乘、质数、斐波那契数、混淆、搜索和排序等广泛主题。许多这些算法构成了更高级算法的基础，并包含了全面算法教育的种子。提升你对算法和算法理论的理解，是提高编程能力的最有效途径之一。我甚至可以说，缺乏算法理解是大多数中级程序员在学习进程中感到困惑的首要原因。
- en: To help you get unstuck, I regularly explain new algorithms in my “Coffee Break
    Python” email series for continuous improvement (visit [*https://blog.finxter.com/subscribe/*](https://blog.finxter.com/subscribe/)).
    I appreciate you spending your valuable time and effort studying all the one-liner
    code snippets and explanations, and I hope you can already see how your skills
    have improved. Based on my experience teaching thousands of Python learners, more
    than half the intermediate coders struggle with understanding basic Python one-liners.
    With commitment and persistence, you have a good chance of leaving the intermediate
    coders behind and becoming a Python master (or at least a top 10 percent coder).
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你突破瓶颈，我在我的“Coffee Break Python”电子邮件系列中定期解释新的算法，旨在持续改进（访问 [*https://blog.finxter.com/subscribe/*](https://blog.finxter.com/subscribe/)）。感谢你花费宝贵的时间和精力研究所有的单行代码片段和解释，我希望你已经能够看到自己的技能有所提升。根据我教授成千上万名Python学习者的经验，超过一半的中级程序员在理解基础的Python单行代码时会遇到困难。只要你保持坚持不懈，就有很大的机会超越中级程序员，成为Python大师（或者至少是前10%的优秀程序员）。
