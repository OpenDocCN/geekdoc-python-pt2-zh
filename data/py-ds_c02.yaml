- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Python Data Structures
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Python 数据结构
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: 'Data structures organize and store data, making it easier to access the data.
    Python ships with four data structures: lists, tuples, dictionaries, and sets.
    These structures are easy to work with, yet they can be used to tackle complex
    data operations, making Python one of the most popular languages for data analysis.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 数据结构组织和存储数据，使得数据更容易访问。Python 提供了四种数据结构：列表、元组、字典和集合。这些结构易于使用，但也可以用于处理复杂的数据操作，使得
    Python 成为数据分析中最受欢迎的语言之一。
- en: This chapter will cover Python’s four built-in data structures, with an emphasis
    on the features that allow you to easily build functional data-centric applications
    with minimal coding. You’ll also learn how to combine the basic structures into
    more complex structures, such as a list of dictionaries, to more accurately represent
    real-world objects. You’ll apply this knowledge to the field of natural language
    processing and in a short introduction to processing photographs.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍 Python 的四种内置数据结构，重点讲解如何利用这些特性，轻松构建功能性数据驱动应用程序，减少编码量。你还将学习如何将这些基本结构组合成更复杂的结构，如字典列表，从而更准确地表示现实世界中的对象。你将在自然语言处理领域和照片处理的简要介绍中应用这些知识。
- en: Lists
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列表
- en: 'A Python *list* is an ordered collection of objects. The elements in a list
    are separated by commas, and the entire list is enclosed in square brackets, as
    shown here:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的*列表*是一个有序的对象集合。列表中的元素由逗号分隔，整个列表被方括号括起来，如下所示：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Lists are mutable, meaning you can add, remove, and modify a list’s elements.
    Unlike sets, which we’ll discuss later in the chapter, lists can have duplicate
    elements.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 列表是可变的，这意味着你可以添加、删除和修改列表的元素。与后面会讨论的集合不同，列表可以包含重复元素。
- en: Lists contain elements that represent series of usually related, similar things
    that can be logically grouped together. A typical list contains only elements
    belonging to a single category (that is, homogeneous data, such as people’s names,
    article titles, or participant numbers). Understanding this point is essential
    when it comes to choosing the right tool for the task at hand. If you need a structure
    to include objects with different properties, consider using a tuple or a dictionary.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 列表包含表示通常相关、相似事物的元素，这些元素可以被逻辑地分组在一起。典型的列表只包含属于同一类别的元素（即同质数据，如人名、文章标题或参与者编号）。理解这一点对于选择适合任务的工具至关重要。如果你需要一个包含具有不同属性对象的结构，可以考虑使用元组或字典。
- en: Creating a List
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建列表
- en: 'To create a basic list, simply place a sequence of elements inside square brackets
    and assign the sequence to a variable name:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个基本列表，只需将一系列元素放入方括号中，并将该序列赋值给一个变量名：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In practice, however, lists are commonly populated dynamically from scratch,
    often using a loop that calculates one item per iteration. In such cases, your
    first step is to create an empty list, as illustrated here:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在实际应用中，列表通常是通过动态方式从零开始填充的，通常使用一个循环，在每次迭代中计算出一个项目。在这种情况下，你的第一步是创建一个空列表，如下所示：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Once you’ve created a list, you can add, remove, and sort items in that list
    as needed. You can perform these and other tasks using Python’s various list object
    methods.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了一个列表，就可以根据需要添加、删除和排序列表中的项目。你可以使用 Python 的各种列表对象方法来执行这些操作以及其他任务。
- en: Using Common List Object Methods
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用常见的列表对象方法
- en: 'List object methods are functions that implement particular behaviors within
    lists. In this section we’ll look at some common list object methods, including
    `append()`, `index()`, `insert()`, and `count()`. To practice using them, start
    by creating a blank list. You’ll build it into a to-do list as you go along, filling
    it with chores and organizing it:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 列表对象方法是实现特定行为的函数。在本节中，我们将介绍一些常见的列表对象方法，包括`append()`、`index()`、`insert()`和`count()`。为了练习使用它们，可以从创建一个空列表开始。接下来，你将逐步将其构建为一个待办事项列表，填充其中的任务并进行整理：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Perhaps the most common list object method is `append()`. It adds an item to
    the end of the list. You can use `append()` to add some chores to your to-do list,
    as shown here:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 也许最常见的列表对象方法是`append()`。它将一个项目添加到列表的末尾。你可以使用`append()`将一些待办事项添加到你的待办列表中，如下所示：
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The list now contains four items, in the order in which they were appended:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 该列表现在包含四个项目，按照它们被添加的顺序：
- en: '[PRE5]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Each item in a list has a numeric key known as an *index*. This feature enables
    a list to keep its items in a specified order. Python uses zero-based indexing,
    meaning the initial item of a sequence is assigned the index 0.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的每个项都有一个数字键，称为 *索引*。这个特性使得列表能够保持项的特定顺序。Python 使用零基索引，这意味着序列中的第一个项被分配为索引 0。
- en: 'To access an individual item from a list, specify the name of the list, followed
    by the index of the desired item in square brackets. For example, here’s how to
    print just the first item of your to-do list:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问列表中的单个项，指定列表的名称，后跟所需项的索引，并用方括号括起来。例如，以下是如何打印你的待办事项列表中的第一个项：
- en: '[PRE6]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `print()` function yields the following output:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`print()` 函数输出如下内容：'
- en: '[PRE7]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can use a list’s indices not only to access a required item but also to
    insert a new item at a certain position in the list. Say you want to add a new
    chore to your to-do list between walking the dog and cooking dinner. To make this
    insertion, you first use the `index()` method to determine the index of the item
    before which you want to insert the new item. Here, you’ll store it in the variable
    `i`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅可以使用列表的索引来访问所需的项，还可以在列表中的某个位置插入新项。假设你想在遛狗和做晚餐之间添加一个新任务。要进行这个插入，你首先使用 `index()`
    方法确定要插入新项的位置之前的项的索引。这里，你将其存储在变量 `i` 中：
- en: '[PRE8]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This will become the index for the new chore, which you can now add using the
    `insert()` method, as shown here:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这将成为新任务的索引，你现在可以使用 `insert()` 方法将其添加，如下所示：
- en: '[PRE9]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The new chore is added to the list at the specified index, shifting all subsequent
    chores down by one. This is what the updated list looks like:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 新任务被添加到列表的指定索引位置，所有后续任务的索引向后移动一位。更新后的列表如下所示：
- en: '[PRE10]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Because lists allow for duplicate items, you may need to check how many times
    a certain item appears in a list. This can be done with the `count()` method,
    as illustrated in the following example:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 因为列表允许重复项，你可能需要检查某个项在列表中出现的次数。可以使用 `count()` 方法来实现，如以下示例所示：
- en: '[PRE11]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `print()` function reveals only one instance of `'Tidy up'` in the list,
    but it might be a good idea to include this item in your daily list more than
    once!
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`print()` 函数只会显示列表中 `''Tidy up''` 的一个实例，但你可能会想把这个任务在你的每日列表中多次列出！'
- en: Using Slice Notation
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用切片表示法
- en: 'It’s possible to access a range of items from a sequential data type such as
    a list by using *slice notation*. To take a slice of a list, specify the index
    of the starting position and the index of the ending position plus 1\. Separate
    the two indices with a colon, and enclose them in square brackets. For example,
    you can print the first three items from your to-do list as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 *切片表示法* 从顺序数据类型（如列表）中访问一系列项。要获取列表的切片，需要指定起始位置的索引和结束位置的索引加 1。用冒号分隔这两个索引，并将它们括在方括号中。例如，你可以按如下方式打印你的待办事项列表中的前三个项：
- en: '[PRE12]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The result is a list of the items with indices 0 through 2:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个包含索引从 0 到 2 的项的列表：
- en: '[PRE13]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Both the start and end indices in a slice are optional. If you omit the start
    index, the slice will start at the beginning of the list. This means that the
    slice in the preceding example can be safely changed to:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 切片中的起始和结束索引都是可选的。如果省略起始索引，切片将从列表的开头开始。这意味着前面的示例中的切片可以安全地改为：
- en: '[PRE14]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If you omit the end index, the slice will continue through the end of the list.
    Here’s how to print the items with indices of 3 and higher:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果省略结束索引，切片将一直延续到列表的末尾。以下是如何打印索引为 3 或更高的项：
- en: '[PRE15]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The result is the last two items in your to-do list:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是你待办事项列表中的最后两项：
- en: '[PRE16]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, you can omit both indices, in which case you’ll get a copy of the
    whole list:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以省略两个索引，在这种情况下，你将得到整个列表的副本：
- en: '[PRE17]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The result is:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是：
- en: '[PRE18]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Slice notation is not limited to extracting a subsequence from a list. You
    can also use it instead of the `append()` and `insert()` methods to populate a
    list with data. Here, for example, you add two items to the end of your list:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 切片表示法不仅限于从列表中提取子序列。你还可以使用它来代替 `append()` 和 `insert()` 方法，将数据填充到列表中。例如，在这里，你将两个项添加到列表的末尾：
- en: '[PRE19]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `len()` function returns the number of items in the list, which is also
    the index of the first unused position outside the list. You can safely add new
    items starting from this index. Here’s how the list looks now:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`len()` 函数返回列表中项的数量，这也是列表之外第一个未使用位置的索引。你可以从这个索引开始安全地添加新项。现在列表如下所示：'
- en: '[PRE20]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Similarly, you can remove items using the `del` command and slicing as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，你可以使用`del`命令和切片来移除项目，如下所示：
- en: '[PRE21]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This removes the items with indices 5 and above, thus returning the list to
    its previous form:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这会移除索引为 5 及以上的项，从而将列表恢复到之前的状态：
- en: '[PRE22]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Using a List as a Queue
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用列表作为队列
- en: 'A *queue* is an abstract data type that can be implemented using the list data
    structure. One end of a queue is always used to insert items (*enqueue*), and
    the other is used to remove them (*dequeue*), thus following the *first-in, first-out
    (FIFO)* methodology. In practice, the FIFO methodology is often used in warehousing:
    the first products that arrive at the warehouse are the first products to leave.
    Organizing the sale of goods in this way can help prevent product expiration by
    ensuring that the older products are the first to be sold.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*队列*是一种抽象数据类型，可以使用列表数据结构来实现。队列的一端总是用于插入元素（*入队*），另一端用于移除元素（*出队*），因此遵循*先进先出（FIFO）*方法论。在实际应用中，FIFO
    方法论常用于仓储：最早到达仓库的商品是最先离开的商品。以这种方式组织商品销售有助于防止商品过期，确保先销售较旧的商品。'
- en: It’s easy to turn a Python list into a queue using Python’s `deque` object (short
    for *double-ended queue*). In this section, we’ll explore how this works using
    your to-do list. For a list to function as a queue, completed tasks should drop
    off the beginning while new tasks appear at the end of the list, as illustrated
    in [Figure 2-1](#figure2-1).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Python 的`deque`对象（*双端队列*的缩写）将 Python 列表转变为队列非常简单。在这一部分，我们将通过使用你的待办事项列表来探索这一方法。为了让列表像队列一样工作，已完成的任务应该从列表的开头移除，而新任务则出现在列表的末尾，正如[图
    2-1](#figure2-1)所示。
- en: '![To-do list tasks arranged in a block diagram from left to right. New tasks
    are added on the right; completed tasks are removed on the left.](image_fi/502208c02/f02001.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![待办事项任务从左到右排列成框图。新任务添加到右侧；已完成的任务从左侧移除。](image_fi/502208c02/f02001.png)'
- en: 'Figure 2-1: An example of using a list as a queue'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-1：使用列表作为队列的示例
- en: 'Here’s how to implement the process shown in the figure:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何实现图中所示的过程：
- en: '[PRE23]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In this script, you first turn the `my_list` object from the previous examples
    into a `deque` object, which is part of Python’s `collections` module. The `deque()`
    object constructor adds a set of methods to the list object being passed into
    it, making it easier to use that list as a queue. In this particular example,
    you add a new element to the right side of the queue with the `append()` method,
    then you remove an item from the left side of the queue using the `popleft()`
    method. This method not only removes the leftmost item but also returns it, thus
    feeding it into your printed message. You should see the following message as
    a result:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个脚本中，你首先将之前示例中的`my_list`对象转换为`deque`对象，它是 Python `collections`模块的一部分。`deque()`对象构造器为传入的列表对象添加了一些方法，使得该列表更容易用作队列。在这个特定的示例中，你使用`append()`方法向队列的右侧添加了一个新元素，然后使用`popleft()`方法从队列的左侧移除一个元素。这个方法不仅移除最左边的元素，还会返回该元素，从而将它传入打印消息中。你应该看到以下消息作为结果：
- en: '[PRE24]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'After being converted back from a `deque` object to a list in the last line
    of the script, the updated to-do list appears as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本的最后一行将`deque`对象转换回列表后，更新后的待办事项列表如下所示：
- en: '[PRE25]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As you can see, the first item has been pushed out of the list, while a new
    one has been appended.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，列表中的第一个元素已经被推出，而一个新的元素被附加到了列表中。
- en: Using a List as a Stack
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用列表作为栈
- en: 'Like a queue, a *stack* is an abstract data structure that you can organize
    on top of a list. A stack implements the *last-in, first-out (LIFO)* methodology,
    where the last item added is the first item retrieved. For your to-do list to
    function as a stack, you would complete the tasks in reverse order, starting with
    the rightmost task. Here’s how to implement this concept in Python:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 像队列一样，*栈*是一种抽象数据结构，你可以在列表上组织它。栈实现了*后进先出（LIFO）*方法论，最后加入的元素是第一个被取出的元素。为了让你的待办事项列表像栈一样工作，你需要按反向顺序完成任务，从最右边的任务开始。以下是如何在
    Python 中实现这一概念：
- en: '[PRE26]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the `for` loop, you push the tasks from the to-do list into a stack defined
    as another list, starting from the first task. This is an example of using `append()`
    in a loop to dynamically populate an empty list. Then, in the `while` loop, you
    remove the tasks from the stack, starting from the last one. You do this with
    the `pop()` method, which removes the last item from a list and returns the removed
    item. The stack’s output will look like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在`for`循环中，你将待办事项列表中的任务逐一推入一个作为栈定义的另一个列表，从第一个任务开始。这是一个在循环中使用`append()`动态填充空列表的示例。然后，在`while`循环中，你从栈中移除任务，从最后一个任务开始。你通过`pop()`方法完成这项操作，该方法移除列表中的最后一个项目并返回被移除的项目。栈的输出将如下所示：
- en: '[PRE27]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Using Lists and Stacks for Natural Language Processing
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用列表和栈进行自然语言处理
- en: Lists and stacks have many real-world applications, including in the field of
    NLP. For example, you can use lists and stacks to extract all the noun chunks
    from a text. A noun chunk consists of a noun and its left syntactic children (that
    is, all those words to the noun’s left that are syntactically dependent on the
    noun, such as adjectives or determiners). Thus, to extract the noun chunks from
    a text, you’ll need to search the text for all the nouns and the nouns’ left syntactic
    children. This can be implemented with a stack-based algorithm, as illustrated
    in [Figure 2-2](#figure2-2).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 列表和栈在许多现实世界的应用中都有广泛应用，包括自然语言处理领域。例如，你可以使用列表和栈来从文本中提取所有名词短语。一个名词短语由一个名词和其左侧句法子节点组成（即所有在名词左侧且句法依赖于名词的单词，如形容词或限定词）。因此，要从文本中提取名词短语，你需要搜索文本中的所有名词及其左侧句法子节点。这可以通过基于栈的算法来实现，如[图
    2-2](#figure2-2)所示。
- en: '![The phrase “a ubiquitous data structure” is added to a stack one word at
    a time, from left to right, and words are removed from right to left. a parsing
    of the phrase  shows  arrows  going  from “structure” to each of the other words.](image_fi/502208c02/f02002.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![短语“一个普遍存在的数据结构”是一个一个单词地添加到栈中的，从左到右，单词从右到左被移除。对短语的解析展示了箭头从“structure”指向其他每个单词。](image_fi/502208c02/f02002.png)'
- en: 'Figure 2-2: An example of using a list as a stack'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-2：使用列表作为栈的示例
- en: The figure uses a single noun chunk as an example, *A ubiquitous data structure*.
    The arrows in the syntactic tree on the right illustrate how the words *A*, *ubiquitous*,
    and *data* are syntactic children of the noun *structure*, which is known as the
    *head* of those syntactic children. The algorithm analyzes the text from left
    to right, one word at a time, pushing the word to the stack if it’s a noun or
    the left syntactic child of a noun. When the algorithm encounters a word that
    doesn’t fit that description, or if there are no words left in the text, an entire
    noun chunk has been found, and the chunk is extracted from the stack.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 该图使用一个单一的名词短语作为示例，*一个普遍存在的数据结构*。右侧句法树中的箭头展示了如何将单词*A*、*ubiquitous*和*data*作为名词*structure*的句法子节点，*structure*是这些句法子节点的*头*。该算法从左到右逐个单词地分析文本，如果遇到名词或名词的左句法子节点，就将单词推入栈中。当算法遇到一个不符合此描述的单词，或者文本中没有剩余单词时，就找到了一个完整的名词短语，该短语会从栈中提取出来。
- en: 'To implement this stack-based algorithm for noun chunk extraction, you’ll need
    to install spaCy, the leading open source Python library for natural language
    processing, as well as one of its English models. Use these commands:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个基于栈的名词短语提取算法，你需要安装spaCy，领先的开源Python自然语言处理库，以及其中的一个英语模型。使用以下命令：
- en: '[PRE28]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The following script uses spaCy to implement the leading open source Python
    library for natural language processing:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 以下脚本使用spaCy实现领先的开源Python自然语言处理库：
- en: '[PRE29]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The first few lines of the script go through the standard setup process for
    analyzing a text phrase with spaCy. You import the spaCy library, define a sentence
    to be processed, and load spaCy’s English model. After that, you apply the `nlp`
    pipeline to the sentence, instructing spaCy to generate the sentence’s syntactic
    structure, which is needed for tasks like noun chunk extraction.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的前几行通过标准设置过程来分析一个使用spaCy处理的文本短语。你导入spaCy库，定义要处理的句子，并加载spaCy的英语模型。之后，你将`nlp`管道应用于句子，指示spaCy生成该句子的句法结构，这是进行名词短语提取等任务所必需的。
- en: Next, you implement the algorithm described previously, iterating through each
    word of the text. If you find either a noun ❶ or one of its left syntactic children
    ❷, you send it to the stack using the `append()` operation. You make these determinations
    using spaCy’s built-in properties, such as `w.head.lefts`, which allow you to
    navigate across the sentence’s syntactic structure and find desired words in it.
    Thus, with `w in w.head.lefts`, you look up the head of a word (`w.head`), then
    look up the left syntactic children of that head (`.lefts`) and determine whether
    the word in question is one of them. To illustrate, when evaluating the word *ubiquitous*,
    `w.head` would yield *structure*, the syntactic head of *ubiquitous*, and `.lefts`
    of *structure* would yield the words *a*, *ubiquitous*, and *data*, demonstrating
    that *ubiquitous* is indeed a left child of *structure*.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你实现之前描述的算法，遍历文本中的每个单词。如果你找到一个名词❶或其左语法子节点之一❷，你就通过`append()`操作将其加入栈中。你通过使用spaCy内置的属性来做出这些判断，例如`w.head.lefts`，它们允许你遍历句子的语法结构并在其中查找所需的单词。因此，使用`w
    in w.head.lefts`，你查找单词的主语（`w.head`），然后查找该主语的左语法子节点（`.lefts`），并确定该单词是否是其中之一。例如，在评估单词*ubiquitous*时，`w.head`会得到*structure*，它是*ubiquitous*的语法主语，而*structure*的`.lefts`会得到单词*a*、*ubiquitous*和*data*，这表明*ubiquitous*确实是*structure*的左孩子。
- en: 'Finishing up the algorithm, once you determine that the next word in the text
    isn’t part of the noun chunk at hand (neither a noun nor a left child of a noun)
    ❸, you have a complete noun chunk, and you extract the words from the stack ❹.
    This script finds and outputs the following three noun chunks:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 完成算法后，一旦你确定文本中的下一个单词不属于当前名词短语（既不是名词，也不是名词的左孩子）❸，你就得到了一个完整的名词短语，并从栈中提取出单词❹。该脚本会找到并输出以下三个名词短语：
- en: '[PRE30]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Making Improvements with List Comprehensions
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用列表推导式进行改进
- en: In Chapter 1, you saw an example of creating a list using the list comprehension
    feature. In this section, we’ll use list comprehensions to improve our noun chunk
    extraction algorithm. Improving the functionality of a solution often requires
    you to make significant enhancements to existing code. In this case, however,
    since list comprehensions are involved, the enhancements to be made will be quite
    compact.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章中，你看到过一个使用列表推导式创建列表的例子。在这一节中，我们将使用列表推导式来改进我们的名词短语提取算法。改进解决方案的功能通常需要对现有代码进行显著增强。然而，在这个案例中，由于涉及到列表推导式，所做的增强将非常简洁。
- en: Looking at the syntactic dependency tree shown in [Figure 2-2](#figure2-2),
    you may notice that each element of the phrase depicted there is directly related
    by a syntactic arc to the noun *structure*. However, a noun chunk can also follow
    another pattern, where some words are not connected to the phrase’s noun by a
    direct syntactic relationship. [Figure 2-3](#figure2-3) illustrates what the dependency
    tree of such a phrase might look like. Notice that the adverb *most* is the child
    of the adjective *useful*, not the noun *type*, yet it’s still part of the noun
    chunk that has *type* as its head.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下[图 2-2](#figure2-2)中显示的语法依赖树，你可能会注意到那里所展示的每个短语元素都与名词*structure*通过语法弧线直接关联。然而，名词短语也可以遵循另一种模式，其中一些单词并未通过直接的语法关系与短语的名词连接。[图
    2-3](#figure2-3)说明了这种短语的依赖树可能是什么样的。请注意副词*most*是形容词*useful*的孩子，而不是名词*type*的孩子，但它仍然是以*type*为主语的名词短语的一部分。
- en: '![Parsing the phrase “the most useful type.” Arrows  go  from “type” to “the,”
    from “type” to “useful,” and from “useful” to “most.”](image_fi/502208c02/f02003.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![解析短语“the most useful type.” 箭头从“type”指向“the”，从“type”指向“useful”，从“useful”指向“most。”](image_fi/502208c02/f02003.png)'
- en: 'Figure 2-3: The syntactic dependency tree of a more complex noun chunk'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-3：一个更复杂的名词短语的语法依赖树
- en: 'We need to improve the script from the previous section so that it can also
    extract noun chunks like the one shown in [Figure 2-3](#figure2-3), where some
    words in a chunk are not connected to the phrase’s noun directly. To refine our
    algorithm, let’s first compare the syntactic dependency trees depicted in Figures
    2-2 and 2-3 to find what they have in common. The important similarity is that
    in both trees, the head of each word that is dependent in a noun chunk can be
    found to the right of the word. However, the noun that forms the phrase may not
    follow this pattern. For example, in the sentence “List is a ubiquitous data structure
    in the Python programming language,” the word *structure* is the head of a noun
    chunk, but its own head, the verb *is*, is located to its left. To make sure it
    is so, you can run the following script that outputs the head for each word in
    the sentence:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要改进上一节中的脚本，以便它也能提取像[图 2-3](#figure2-3)中所示的名词短语，其中一些词并未直接连接到短语的名词。为了优化我们的算法，我们首先通过比较图2-2和图2-3中展示的句法依赖树，找出它们的相似之处。重要的相似之处在于，在这两棵树中，作为名词短语依赖的每个单词的词头都可以在该单词的右侧找到。然而，构成短语的名词可能不遵循这个模式。例如，在句子“List
    is a ubiquitous data structure in the Python programming language.”中，单词*structure*是名词短语的词头，但它的词头*is*位于其左侧。为了确保这一点，你可以运行以下脚本，输出句子中每个单词的词头：
- en: '[PRE31]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Our new algorithm needs to scan a text looking for words whose heads are to
    their right, thus indicating potential noun chunks. The idea is to create a kind
    of matrix for a sentence that indicates whether the head of a word is to its right
    or not. For readability, the words whose heads are on the right could be included
    in the matrix as they are in the sentence, while all the others could be replaced
    with zeros. Thus, for the following sentence:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新算法需要扫描文本，寻找其右侧有词头的单词，从而指示潜在的名词短语。其思路是为句子创建一种矩阵，指示一个单词的词头是否在其右侧。为了提高可读性，词头在右侧的单词可以按照它们在句子中的顺序包含在矩阵中，而其他所有单词则用零替代。因此，对于以下句子：
- en: '[PRE32]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'you would have the following matrix:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到以下矩阵：
- en: '[PRE33]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'You can create this matrix using a list comprehension:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过列表推导式来创建这个矩阵：
- en: '[PRE34]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Here, you iterate over the words of the submitted sentence in the loop within
    the list comprehension, substituting zeros for those words whose heads are not
    to the right ❶.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你在列表推导式中的循环中遍历所提交句子的单词，对那些词头不在右侧的单词用零进行替换❶。
- en: 'The generated list looks as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的列表如下所示：
- en: '[PRE35]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: You may notice that the list contains one more element than there are words
    in the sentence. This is because spaCy actually breaks the text up into tokens,
    which may be words or punctuation marks. The final `0` in the list represents
    the period at the end of the sentence.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，列表中包含的元素比句子中的单词数量多一个。这是因为spaCy实际上将文本拆分成标记（tokens），这些标记可能是单词或标点符号。列表中的最终`0`表示句子末尾的句号。
- en: 'Now you need a way to move through this list in order to find and extract noun
    chunks. You’ll need to create a series of text fragments, where each fragment
    starts at a certain position and continues until the end of the text. In the following
    snippet, you move word by word from the start through the rest of the text, generating
    a matrix of the sides of the heads in each iteration:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你需要一种方法来遍历这个列表，以便找到并提取名词短语。你需要创建一系列文本片段，每个片段从某个位置开始，并一直延续到文本的末尾。在下面的代码片段中，你从开始处逐词遍历文本的其余部分，在每次迭代中生成一个矩阵，用于表示每个单词词头的左右位置：
- en: '[PRE36]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'You use slice notation in the `doc` object to get the fragment that is needed
    ❶. This mechanism allows you to shift the leftmost position of the resulting slice
    one word to the right at each iteration of the `for` loop. The code generates
    the following set of matrices:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用`doc`对象中的切片表示法来获取所需的文本片段❶。这个机制允许你在每次`for`循环迭代中，将结果切片的最左边位置向右移动一个单词。代码生成了以下矩阵集合：
- en: '[PRE37]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You must analyze each fragment next, looking for the first zero. The words
    up to and including that zero could potentially be a noun chunk. Here’s the code
    for this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你必须分析每个片段，寻找第一个零。到达该零并包括该零的所有单词可能构成一个名词短语。以下是实现这一点的代码：
- en: '[PRE38]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: You set `i0` equal to `head_lefts.index(0)` to find the index of the first zero
    in the fragment ❶. If there are multiple zero elements, `head_lefts.index(0)`
    returns the index of the first element. Then, you check whether `i0 > 0` to weed
    out fragments that don’t start with a head-left element.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你将`i0`设置为`head_lefts.index(0)`，以查找片段中第一个零的索引 ❶。如果有多个零元素，`head_lefts.index(0)`返回第一个元素的索引。然后，你检查`i0
    > 0`，以筛选出那些不以头部左侧元素开始的片段。
- en: You then use another list comprehension to process the elements of the noun
    chunks to be sent to the stack. In this second list comprehension, you look for
    a noun or a proper noun within each fragment that could potentially be a noun
    chunk. You loop over the fragment in reverse order to first pick up the noun or
    proper noun that forms the chunk and which, therefore, is supposed to appear in
    the last position of the fragment ❷. What you actually send to the list when any
    noun or proper noun is found is a `1`, and you send a `0` for every other element.
    Thus, the first `1` found in the list indicates the position of the main noun
    in the fragment relative to the fragment’s end ❸. You’ll need it when calculating
    the slice of the text representing the noun chunk ❹.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你使用另一个列表推导式来处理要发送到堆栈的名词短语元素。在这个第二个列表推导式中，你会查找每个片段中可能是名词短语的名词或专有名词。你逆序遍历片段，首先选取构成名词短语的名词或专有名词，因此它应该出现在片段的最后位置
    ❷。当你找到名词或专有名词时，实际发送到列表的是`1`，其他元素则发送`0`。因此，列表中找到的第一个`1`表示片段中主名词相对于片段末尾的位置 ❸。在计算表示名词短语的文本切片时，你需要用到它
    ❹。
- en: 'For now, you simply output the generated fragments along with the nouns found
    within them. You will see the following output:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，你只需输出生成的片段以及其中找到的名词。你将看到以下输出：
- en: '[PRE39]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now you can incorporate the new code into the solution introduced in the previous
    section. Putting it all together, you arrive at the following script:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以将新代码融入到前一节中介绍的解决方案中。将所有内容结合在一起，你将得到以下脚本：
- en: '[PRE40]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: You iterate over the tokens in the submitted sentence ❶, generating a `head_lefts`
    list in each iteration ❷. Recall that this list is a matrix containing zeros for
    those words in the sentence whose syntactic heads are to their left. These matrices
    are used to identify noun chunks. For each chunk you identify, you send each noun
    or proper noun to the stack ❸, as well as any other word that belongs to the chunk
    but is not a noun ❹. Once you reach the end of the chunk, you extract the tokens
    from the stack, forming a phrase ❺.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你遍历提交的句子中的标记 ❶，在每次迭代中生成一个`head_lefts`列表 ❷。回想一下，这个列表是一个矩阵，其中包含那些句子中其句法主语位于其左侧的单词的零。这些矩阵用于识别名词短语。对于你识别的每个名词短语，你将每个名词或专有名词发送到堆栈
    ❸，以及属于该短语但不是名词的其他单词 ❹。一旦到达名词短语的末尾，你从堆栈中提取标记，形成一个短语 ❺。
- en: 'The script will produce the following output:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本将产生以下输出：
- en: '[PRE41]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Tuples
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元组
- en: 'Like a list, a *tuple* is an ordered collection of objects. Unlike lists, however,
    tuples are immutable. Once a tuple is created, it cannot be changed. The items
    in a tuple are separated by commas and can optionally be enclosed in parentheses,
    as shown here:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 像列表一样，*元组*是一个有序的对象集合。然而，与列表不同的是，元组是不可变的。一旦创建了一个元组，它就不能被更改。元组中的项由逗号分隔，并可以选择性地用括号括起来，如下所示：
- en: '[PRE42]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Tuples are typically used to store collections of heterogeneous data; that is,
    data of different types, such as the make, model, and year of a car. As this example
    illustrates, they are especially useful when you need a structure to hold the
    properties of a real-world object.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 元组通常用于存储异构数据集合；也就是说，存储不同类型的数据，例如汽车的品牌、型号和年份。正如这个例子所示，当你需要一个结构来保存现实世界对象的属性时，元组特别有用。
- en: A List of Tuples
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 元组列表
- en: 'It’s common to nest Python data structures inside each other. For example,
    you can have a list where each element is a tuple, which lets you assign more
    than one attribute to each element in the list. Say you want to assign a start
    time to each task in the to-do list you created earlier in the chapter. Each item
    in the list will become a data structure unto itself, consisting of two elements:
    the description of a task and its scheduled start time.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，将数据结构嵌套在一起是常见的做法。例如，你可以有一个列表，每个元素是一个元组，这让你能够为列表中的每个元素分配多个属性。假设你想为之前章节中创建的待办事项列表中的每个任务分配一个开始时间。列表中的每个项目将成为一个数据结构，由两个元素组成：任务描述和计划的开始时间。
- en: 'To implement such a structure, tuples are an ideal choice, since they are intended
    to collect heterogeneous data in a single structure. Your list of tuples might
    look as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这样的结构，元组是理想的选择，因为它们旨在将异构数据收集到一个结构中。你的元组列表可能如下所示：
- en: '[PRE43]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You can build this list of tuples from the following two simple lists:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从以下两个简单的列表构建这个元组列表：
- en: '[PRE44]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'As you can see, the first list is the original `my_list`, and the second one
    is a list containing the corresponding start times. The easiest way to combine
    them into a list of tuples is to use a list comprehension, as shown here:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，第一个列表是原始的 `my_list`，第二个是包含对应开始时间的列表。将它们组合成元组列表的最简单方法是使用列表推导式，如下所示：
- en: '[PRE45]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Within the list comprehension, you use Python’s `zip()` function, which iterates
    over the two simple lists simultaneously, combining the corresponding times and
    tasks into tuples.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表推导式中，你使用了 Python 的 `zip()` 函数，它同时遍历这两个简单的列表，将相应的时间和任务组合成元组。
- en: 'Just as with lists, to access an item in a tuple you specify the item’s index
    enclosed in square brackets following the name of the tuple. Note, however, that
    tuples nested within a list are not assigned names. To access an item in a nested
    tuple, you first need to specify the name of the list, then the index of the tuple
    in the list, and finally the index of the item in the tuple. For example, to see
    the time assigned to the second task in your to-do list, you would use the following
    syntax:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 与列表一样，要访问元组中的元素，你需要在元组名称后面指定元素的索引，并将其用方括号括起来。然而，值得注意的是，嵌套在列表中的元组没有名称。要访问嵌套元组中的元素，你首先需要指定列表的名称，然后是列表中元组的索引，最后是元组中元素的索引。例如，要查看待办事项列表中第二个任务分配的时间，你可以使用以下语法：
- en: '[PRE46]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This generates the following output:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成以下输出：
- en: '[PRE47]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Immutability
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不可变性
- en: 'An important thing to remember about tuples is that they’re immutable. That
    is, you can’t modify them. For example, if you try to change the start time for
    one of your chores:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的一个重要点是，元组是不可变的。也就是说，你不能修改它们。例如，如果你尝试更改某个任务的开始时间：
- en: '[PRE48]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'you’ll get the following error:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你会收到以下错误：
- en: '[PRE49]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Because they’re immutable, tuples are not suitable for holding data values that
    need to be updated periodically.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 由于元组是不可变的，它们不适合存储需要定期更新的数据值。
- en: Dictionaries
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字典
- en: 'The *dictionary* is another widely used built-in data structure in Python.
    Dictionaries are mutable, unordered collections of *key-value pairs*, where each
    *key* is a unique name that identifies an item of data, the *value*. A dictionary
    is delimited by curly brackets. Each key is separated from its value by a colon,
    and key-value pairs are separated by commas, as shown here:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典* 是 Python 中另一种广泛使用的内置数据结构。字典是可变的、无序的 *键值对* 集合，其中每个 *键* 是一个唯一的名称，用于标识数据项，即
    *值*。字典由大括号界定。每个键与其值之间由冒号分隔，键值对之间由逗号分隔，如下所示：'
- en: '[PRE50]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Dictionaries, like tuples, are useful for storing heterogeneous data about real-world
    objects. As this example illustrates, dictionaries have the added benefit of assigning
    a label to each item of data.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 字典和元组一样，适用于存储关于现实世界对象的异构数据。正如这个示例所展示的，字典具有为每个数据项分配标签的额外好处。
- en: A List of Dictionaries
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字典列表
- en: 'Like other data structures, dictionaries can be nested inside other structures.
    Your to-do list, when implemented as a list of dictionaries, might look like this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 像其他数据结构一样，字典可以嵌套在其他结构中。将待办事项列表实现为字典的列表时，可能会如下所示：
- en: '[PRE51]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Unlike tuples, dictionaries are mutable, which means that you can easily change
    the value in a key-value pair:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 与元组不同，字典是可变的，这意味着你可以轻松更改键值对中的值：
- en: '[PRE52]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This example also illustrates how to access values in a dictionary: unlike
    with lists and tuples, you use key names rather than numeric indices.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例还展示了如何访问字典中的值：与列表和元组不同，你使用的是键名而非数字索引。
- en: Adding to a Dictionary with setdefault()
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `setdefault()` 向字典添加数据
- en: 'The `setdefault()` method provides a convenient way to add new data to a dictionary.
    It takes a key-value pair as its parameter. If the specified key already exists,
    the method simply returns the current value of that key. If the key doesn’t exist,
    `setdefault()` inserts the key with the specified value. To see an example, first
    create a dictionary called `car` where the model is `Jetta`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`setdefault()` 方法提供了一种便捷的方式向字典添加新数据。它以键值对作为参数。如果指定的键已经存在，方法会直接返回该键的当前值。如果该键不存在，`setdefault()`
    会插入该键并赋予指定的值。要查看示例，首先创建一个名为 `car` 的字典，其中模型是 `Jetta`：'
- en: '[PRE53]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now try adding a new `model` key with a value of `Passat` using `setdefault()`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，尝试使用`setdefault()`添加一个新的`model`键，并将其值设置为`Passat`：
- en: '[PRE54]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This produces the following output, showing that the value of the `model` key
    has remained the same:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出，显示`model`键的值保持不变：
- en: '[PRE55]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'However, if you specify a new key, `setdefault()` inserts the key-value pair
    and returns the value:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你指定一个新的键，`setdefault()`会插入键值对并返回值：
- en: '[PRE56]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The output will be as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE57]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'If you now print the entire dictionary:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在打印整个字典：
- en: '[PRE58]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'this is what you see:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你所看到的：
- en: '[PRE59]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: As you can see, the `setdefault()` method relieves you from having to manually
    check whether the key in the key-value pair you want to insert is already in the
    dictionary. You can safely try to insert a key-value pair into a dictionary without
    the risk of overwriting the value of a key that already exists.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`setdefault()`方法使你无需手动检查要插入的键值对中的键是否已经存在于字典中。你可以安全地尝试将一个键值对插入字典，而不用担心覆盖已存在键的值。
- en: 'Now that you know how `setdefault()` works, let’s look at a practical example.
    Counting the number of occurrences of each word in a text phrase is a common task
    in NLP. The following example demonstrates how this can be accomplished, with
    the help of a dictionary, using the `setdefault()` method. Here’s the text that
    you’ll process:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了`setdefault()`的工作原理，接下来我们来看一个实际的例子。统计文本中每个单词出现的次数是自然语言处理（NLP）中的常见任务。以下示例演示了如何借助字典，使用`setdefault()`方法来完成这个任务。以下是你需要处理的文本：
- en: '[PRE60]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The first step is to remove the punctuation from the text. Without this step,
    `''languages''` and `''languages.''` would count as two separate words. Here,
    you remove the periods and commas:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是去除文本中的标点符号。如果不这样做，`'languages'`和`'languages.'`会被算作两个不同的单词。这里，我们去掉句号和逗号：
- en: '[PRE61]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Next, you split the text into words, putting them into a list:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将文本分割成单词，并将它们放入一个列表中：
- en: '[PRE62]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The generated list of words is as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的单词列表如下：
- en: '[PRE63]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Now you can count the occurrences of each word in the list. This can be implemented
    with a dictionary using the `setdefault()` method as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以计算列表中每个单词的出现次数。可以使用字典和`setdefault()`方法来实现，代码如下：
- en: '[PRE64]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: First, you create an empty dictionary. Then you add key-value pairs to it, using
    the words from the list as the keys. The `setdefault()` method sets the initial
    value for each key to `0`. The value is then increased by 1 for the first occurrence
    of each word, yielding a count of 1\. On subsequent occurrences of that word,
    `setdefault()` will leave the previous count value intact, but the count value
    will be incremented by 1 with the `+=` operator, producing an accurate count.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你创建一个空字典。然后，你将列表中的单词作为键，使用`setdefault()`方法将每个键的初始值设置为`0`。当每个单词第一次出现时，值会增加1，得到计数1。对于该单词的后续出现，`setdefault()`会保持之前的计数值不变，但会通过`+=`运算符将计数值增加1，从而得到准确的计数。
- en: 'Before outputting the dictionary, you might want to sort the words by number
    of occurrences:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出字典之前，你可能想根据单词出现的次数对其进行排序：
- en: '[PRE65]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Using the dictionary’s `items()` method, you can convert this dictionary into
    a list of tuples, where each tuple contains a key and its value. Thus, when you
    specify `x[1]` in `lambda` for the `key` parameter of the `sorted()` function,
    you’re sorting according to the items in the tuples with index `1`—that is, the
    values (word counts) from the original dictionary. The resulting dictionary appears
    as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 使用字典的`items()`方法，你可以将该字典转换为一个元组列表，其中每个元组包含一个键及其值。因此，当你在`sorted()`函数的`key`参数中为`lambda`指定`x[1]`时，你实际上是按照元组中索引为`1`的项（即原字典中的值，表示单词计数）进行排序。排序后的字典如下所示：
- en: '[PRE66]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Loading JSON into a Dictionary
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将JSON加载到字典中
- en: 'With the help of dictionaries, you can easily convert Python data structures
    into JSON strings and vice versa. Here’s how to load a string representing a JSON
    document into a dictionary using only the assignment operator:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 借助字典，你可以轻松地将Python数据结构转换为JSON字符串，反之亦然。以下是如何仅使用赋值运算符将表示JSON文档的字符串加载到字典中的方法：
- en: '[PRE67]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: As you might notice, this dictionary has a complex structure. The value of the
    `ShippingInstructions` key is itself a dictionary, in which the value of the `Address`
    key is yet another dictionary and the value of the `Phone` key is a list of dictionaries.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能注意到的，这个字典具有复杂的结构。`ShippingInstructions`键的值本身是一个字典，其中`Address`键的值又是一个字典，而`Phone`键的值是一个字典列表。
- en: 'You can save the dictionary directly to a JSON file with Python’s `json` module
    using the `json.dump()` method:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用Python的`json`模块通过`json.dump()`方法将字典直接保存到JSON文件中：
- en: '[PRE68]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Similarly, you can use the `json.load()` method to load the contents of a JSON
    file directly into a Python dictionary:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，你可以使用`json.load()`方法将JSON文件的内容直接加载到Python字典中：
- en: '[PRE69]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: As a result, you get the same dictionary that was shown at the beginning of
    this section. We’ll discuss working with files in more detail in Chapter 4.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是你得到的字典与本节开始时展示的字典相同。我们将在第4章详细讨论文件操作。
- en: Sets
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合
- en: 'A Python *set* is an unordered collection of unique items. Duplicate items
    are not allowed in a set. A set is defined with curly brackets containing items
    separated by commas, as illustrated here:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的*集合*是一个无序的唯一项集合。集合中不允许有重复项。集合通过花括号定义，其中包含由逗号分隔的项，如下所示：
- en: '[PRE70]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Removing Duplicates from Sequences
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从序列中删除重复项
- en: 'Since members of a set must be unique, sets are useful when you need to remove
    duplicate items from a list or a tuple. Suppose a business wants to see a list
    of its customers. You might obtain such a list by deriving customers’ names from
    the orders they’ve placed. Since a customer may have placed more than one order,
    the list may have duplicate names. The duplicates can be removed with the help
    of a set as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 由于集合的成员必须是唯一的，因此集合在需要从列表或元组中删除重复项时非常有用。假设某个企业想查看其客户的列表。你可能通过从他们所下的订单中提取客户的名字来获得这样的列表。由于一个客户可能下了多个订单，列表中可能会有重复的名字。可以通过使用集合来删除这些重复项，如下所示：
- en: '[PRE71]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'You simply convert the original list to a set and then back to a list. The
    set constructor automatically deletes the duplicates. The updated list looks something
    like this:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需将原始列表转换为集合，再转换回列表。集合构造函数会自动删除重复项。更新后的列表大致如下：
- en: '[PRE72]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: A drawback of this approach is that it does not preserve the initial order of
    elements. This is due to the fact that a set is an unordered collection of items.
    Indeed, if you run the preceding code two or three times, the order of the output
    might be different each time.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个缺点是它不能保留元素的初始顺序。这是因为集合是无序的项集合。实际上，如果你运行前面的代码两到三次，输出的顺序可能每次都不同。
- en: 'To perform the same operation without losing the initial order, use Python’s
    `sorted()` function, as shown here:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在不丢失初始顺序的情况下执行相同的操作，可以使用Python的`sorted()`函数，如下所示：
- en: '[PRE73]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'This sorts the set by the indices of the original list, thus preserving the
    order. The updated list is as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这会根据原始列表的索引对集合进行排序，从而保留顺序。更新后的列表如下：
- en: '[PRE74]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Performing Common Set Operations
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行常见的集合操作
- en: Set objects come with methods for performing common math operations on sequences,
    like unions and intersections. These methods let you easily combine sets or extract
    the elements shared by multiple sets.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 集合对象带有用于对序列执行常见数学操作的方法，如并集和交集。这些方法使你可以轻松地合并集合或提取多个集合之间共享的元素。
- en: Imagine that you need to classify a huge number of photos into groups based
    on what’s in the photos. To automate this task, you might start with a visual
    recognition tool like Clarifai API that will generate a set of descriptive tags
    for each photo. The sets of tags can then be compared with each other using the
    `intersection()` method. This method compares two sets and creates a new set containing
    all of the elements that are in both. In this particular case, the more tags that
    there are in both sets, the more similar the two images are with respect to their
    theme.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你需要根据照片中的内容将大量照片分类。为了自动化这个任务，你可能会使用像Clarifai API这样的视觉识别工具，它会为每张照片生成一组描述性标签。然后，可以使用`intersection()`方法对这些标签集合进行比较。这个方法比较两个集合，并创建一个新集合，包含两个集合中都存在的所有元素。在这个特定的案例中，两个集合中标签数量越多，说明这两张照片的主题越相似。
- en: 'For simplicity, the following example uses just two photos. Using their corresponding
    sets of descriptive tags, you can determine the extent to which the subject matter
    of the two photos coincides:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 为简便起见，以下示例仅使用两张照片。通过它们对应的描述性标签集合，你可以确定两张照片的主题内容重合的程度：
- en: '[PRE75]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: In this code, you perform the intersection operation to find the items shared
    by both sets. If the number of the items that the sets have in common is equal
    to or greater than two, you can conclude that the photos have a similar theme
    and, therefore, can be grouped together.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，你执行交集操作来找到两个集合之间共享的项。如果两个集合中共同的项的数量大于或等于两个，则可以得出结论：这些照片具有相似的主题，因此可以将它们分组在一起。
- en: Summary
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: 'This chapter has covered Python’s four built-in data structures: lists, tuples,
    dictionaries, and sets. You saw a wide range of examples showing how these structures
    can represent real-world objects, and you learned how they can be combined into
    nested structures, including a list of tuples, a list of dictionaries, and a dictionary
    whose values are lists.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了 Python 的四种内置数据结构：列表、元组、字典和集合。你看到了大量的示例，展示了这些结构如何表示现实世界中的对象，同时你还学习了如何将它们组合成嵌套结构，包括元组的列表、字典的列表，以及值为列表的字典。
- en: The chapter also explored features that allow you to easily build functional
    data analysis applications in Python. For example, you learned how to use list
    comprehensions to create new lists from existing ones and how to use the `setdefault()`
    method to efficiently access and manipulate the data in a dictionary. Through
    examples, you saw how these features are transferable to common challenges like
    text processing and photo analysis.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还探讨了让你能够轻松构建功能性数据分析应用程序的特性。例如，你学习了如何使用列表推导式从现有列表创建新列表，以及如何使用 `setdefault()`
    方法高效地访问和操作字典中的数据。通过示例，你看到了这些特性如何应用于常见的挑战，如文本处理和照片分析。
