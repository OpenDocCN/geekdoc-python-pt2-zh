- en: '1'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '1'
- en: GETTING STARTED
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 开始
- en: '![image](Images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/common.jpg)'
- en: Programming involves writing code to solve a problem. As such, I want to solve
    problems with you from the outset. That is, rather than learning Python concept
    by concept and then solving a problem, we’re going to use a problem to dictate
    the concepts we need to learn.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 编程就是编写代码来解决问题。因此，我希望从一开始就和你一起解决问题。也就是说，我们不是一个个地学习 Python 的概念，然后再解决问题，而是通过问题来决定我们需要学习的概念。
- en: 'In this chapter, we’ll solve two problems: determining the number of words
    in a line (like the word-count feature in a word processor) and calculating the
    volume of a cone. Solving these problems requires a tour of quite a few Python
    concepts. You may feel that you need more details to fully understand some of
    what I introduce here and how it all fits together in the design of a Python program.
    Don’t worry: we’ll revisit and elaborate on the most important concepts in later
    chapters.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将解决两个问题：确定一行中的单词数（类似于文字处理软件中的字数统计功能）和计算圆锥体的体积。解决这些问题需要我们了解一些 Python
    的概念。你可能会觉得要完全理解我在这里介绍的某些内容以及它们如何在 Python 程序设计中结合起来，你需要更多的细节。别担心：我们将在后续章节中重新访问并详细阐述最重要的概念。
- en: What We’ll Be Doing
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们将做什么
- en: As described in the introduction, we’ll be solving competitive programming problems
    using the Python programming language. The competitive programming problems can
    each be found on an online judge website. I assume that you’ve followed the instructions
    in the introduction to install Python and make your judge accounts.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如介绍中所述，我们将使用 Python 编程语言来解决竞赛编程问题。每个竞赛编程问题都可以在一个在线评测网站上找到。我假设你已经按照介绍中的说明安装了
    Python，并且创建了评测平台账号。
- en: For each problem, we’ll write a program to solve it. Each problem specifies
    the kind of *input* that our program will be provided, and the kind of *output*
    (or result) that is expected. Our program correctly solves the problem if it can
    take any valid input and produce the correct output.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个问题，我们将编写一个程序来解决它。每个问题都会指定程序将接收到的*输入*类型和期望的*输出*（或结果）类型。如果我们的程序能接受任何有效输入并产生正确的输出，那么它就能正确解决该问题。
- en: In general, there will be millions or billions of possible inputs. Each such
    input is referred to as a *problem instance*. For example, in the first problem
    that we’ll solve, the input is a line of text, like hello there or bbaabbb aa
    abab. Our task will be to output the number of words in the line. One of the most
    powerful ideas in programming is that often a small amount of general-purpose
    code can solve a seemingly endless number of problem instances. Whether the line
    has 2 words or 3 or 50, it won’t matter. Our program will get it right every time.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，可能有数百万或数十亿个可能的输入。每个这样的输入被称为*问题实例*。例如，在我们要解决的第一个问题中，输入是一个文本行，如 hello there
    或 bbaabbb aa abab。我们的任务是输出该行中的单词数。编程中最强大的一个概念就是，通常少量通用代码可以解决看似无尽的多个问题实例。无论这行文字有
    2 个单词、3 个单词，还是 50 个单词，都无关紧要。我们的程序每次都能正确处理。
- en: 'Our programs will perform three tasks:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序将执行三个任务：
- en: '**Read input** We need to determine the specific instance of the problem that
    we’re solving, so we first read the provided input.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**读取输入** 我们需要确定我们要解决的问题的具体实例，因此我们首先读取提供的输入。'
- en: '**Process** We process the input to determine the correct output.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**处理** 我们处理输入，确定正确的输出。'
- en: '**Write output** Having solved the problem, we produce the desired output.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出结果** 解决问题后，我们生成所需的输出。'
- en: The boundaries between these steps may not always be crisp—we might have to
    interleave some processing with producing some output, for example—but it will
    be helpful to keep these three broad steps in mind.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤之间的界限可能并不总是很清晰——例如，我们可能需要在生成输出的同时进行一些处理——但牢记这三个大致的步骤会很有帮助。
- en: 'You likely use programs on a daily basis that follow this input-process-output
    model. Consider a calculator program: you type in a formula (the input), the program
    crunches your numbers (process), and the program displays the answer (output).
    Or consider a web search engine: you type in a search query (input), the search
    engine determines the most relevant results (process), and it displays them (output).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能每天都在使用遵循这种输入-处理-输出模型的程序。考虑一下计算器程序：你输入一个公式（输入），程序进行计算（处理），然后显示答案（输出）。或者考虑一下网页搜索引擎：你输入一个搜索查询（输入），搜索引擎确定最相关的结果（处理），然后显示它们（输出）。
- en: Contrast these kinds of programs with *interactive* programs, which fuse input,
    processing, and output. For example, I’m typing this book using a text editor.
    When I type a character, the editor responds by adding that character to my document.
    It doesn’t wait for me to type the entire document before displaying it to me;
    it interactively displays it as I build it. We won’t be writing interactive programs
    in this book. If you’re interested in writing such programs after studying this
    book, you’ll be happy to hear that Python is certainly up for the task.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些程序与*交互式*程序进行对比，后者将输入、处理和输出结合在一起。例如，我正在使用文本编辑器编写这本书。当我输入一个字符时，编辑器会响应并将该字符添加到文档中。它不会等我输入完整个文档才显示给我，而是随着我的输入实时显示。我们在本书中不会编写交互式程序。如果你在学习完本书后有兴趣编写此类程序，你会很高兴地得知
    Python 完全能够胜任这项任务。
- en: 'The text for each problem is found both here and on the online judge. However,
    the text won’t match, because I’ve rewritten it for purposes of consistency throughout
    the book. Don’t worry: what I’ve written conveys the same information as the official
    problem statement.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 每个问题的文本内容都可以在这里和在线评测系统中找到。然而，文本内容并不完全一致，因为我已根据书中的一致性要求重新编写了内容。别担心：我写的内容传达了与官方问题陈述相同的信息。
- en: The Python Shell
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python Shell
- en: For each problem in the book, we want to write a program and save it in a file.
    But that assumes we know what program to write! For many of the problems in the
    book, we’ll need to learn some new Python features before we can solve the problem.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于书中的每个问题，我们都想编写一个程序并将其保存在文件中。但这要求我们知道该编写什么程序！对于书中的许多问题，我们需要学习一些新的 Python 特性，才能解决问题。
- en: The best way to experiment with Python features is by using the Python shell.
    It’s an interactive environment where you type some Python code and press ENTER,
    and Python shows you the result. Once we learn enough to solve the current problem,
    we’ll stop using the shell and start typing our solution in a text file instead.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 实验 Python 特性最好的方式是使用 Python Shell。它是一个交互式环境，你输入一些 Python 代码并按下 ENTER，Python
    会显示结果。当我们学到足够的知识来解决当前的问题时，我们就会停止使用 Shell，而开始将解决方案输入到文本文件中。
- en: To begin, create a new folder on your desktop called *programming*. We’ll use
    that folder to store all of the work that we do for this book.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在桌面上创建一个名为*programming*的新文件夹。我们将使用这个文件夹来存储本书中所有的工作文件。
- en: Now, we’ll navigate to this *programming* folder and launch the Python shell.
    Follow these steps for your operating system whenever you’d like to start the
    Python shell.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将进入*programming*文件夹并启动 Python Shell。根据你的操作系统，按照以下步骤操作，每当你想启动 Python Shell
    时，都可以参考。
- en: Windows
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Windows
- en: 'On Windows, do the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，执行以下操作：
- en: Hold down SHIFT and right-click your **programming** folder.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按住 SHIFT 并右键点击你的**programming**文件夹。
- en: From the resulting menu, click **Open PowerShell window here**. If that choice
    isn’t there, click **Open command window here**.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从出现的菜单中，点击**在此处打开 PowerShell 窗口**。如果该选项不存在，请点击**在此处打开命令窗口**。
- en: At the bottom of the resulting window, you’ll see a line that ends with a greater-than
    sign (>). This is your operating system *prompt*, and it’s waiting for you to
    type a command. You type operating system commands here, *not* Python code. Be
    sure to press ENTER after each command.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在结果窗口的底部，你会看到一行以大于号（>）结尾的内容。这是你的操作系统*提示符*，它在等待你输入命令。你在这里输入的是操作系统命令，而*不是* Python
    代码。每次输入命令后，记得按下 ENTER。
- en: You’re now in your *programming* folder. You can type dir (for *directory*)
    if you’d like to see what’s there. You shouldn’t see any files yet, because we
    haven’t created any.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在在你的*programming*文件夹中。如果你想查看文件夹中的内容，可以输入 dir（*目录*）。你现在应该看不到任何文件，因为我们还没有创建任何文件。
- en: Now, enter python to start the Python shell.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，输入 python 启动 Python Shell。
- en: 'When you start the Python shell, you should see something like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当你启动 Python Shell 时，你应该会看到类似如下的内容：
- en: Python 3.9.2 (tags/v3.9.2:1a79785, Feb 19 2021, 13:30:23)
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3.9.2 (tags/v3.9.2:1a79785, 2021年2月19日，13:30:23)
- en: '[MSC v.1928 32 bit (Intel)] on win32'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '[MSC v.1928 32位（Intel）] 在 win32 上'
- en: Type "help", "copyright", "credits" or "license" for more information.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 输入 "help"、"copyright"、"credits" 或 "license" 获取更多信息。
- en: '>>>'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '>>>'
- en: What’s important here is that you see a Python version of at least 3.6 in the
    first line. If you have an older version, especially 2.*x*, or if Python doesn’t
    load at all, please install a recent version of Python following the instructions
    in the introduction.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这里重要的是，你在第一行看到的 Python 版本至少是 3.6。如果你使用的是较老的版本，尤其是 2.*x*，或者如果 Python 根本无法加载，请按照引言中的说明安装一个最新版本的
    Python。
- en: At the bottom of this window, you’ll see a >>> Python prompt. This is where
    you type Python code. Never type the >>> symbols yourself. Once you’re done programming,
    you can press CTRL-Z and then press ENTER to quit.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个窗口的底部，你会看到一个>>> Python提示符。在这里你输入Python代码。不要自己输入>>>符号。编程完成后，你可以按CTRL-Z，然后按ENTER退出。
- en: macOS
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: macOS
- en: 'On macOS, do the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在macOS上，请执行以下操作：
- en: Open Terminal. You can do that by pressing COMMAND-spacebar, typing **terminal**,
    and then double-clicking the result.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端。你可以通过按COMMAND-空格键，输入**terminal**，然后双击结果来打开。
- en: In the resulting window, you’ll see a line that ends with a dollar symbol ($).
    This is your operating system *prompt*, and it’s waiting for you to type a command.
    You type operating system commands here, *not* Python code. Be sure to press ENTER
    after each command.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在结果窗口中，你会看到一行以美元符号（$）结尾。这是你的操作系统*提示符*，它在等待你输入命令。你在这里输入操作系统命令，*不是*Python代码。确保每输入一条命令后按ENTER键。
- en: You can enter the ls command to obtain a list of what’s in the current folder.
    Your *Desktop* should be listed there.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以输入ls命令来查看当前文件夹中的内容。你的*桌面*应该会列在其中。
- en: Enter cd Desktop to navigate to your *Desktop* folder. The cd command stands
    for *change directory*; *directory* is another name for folder.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入cd桌面以导航到你的*桌面*文件夹。cd命令代表*更改目录*；*目录*是文件夹的另一种说法。
- en: Enter cd programming to navigate to your *programming* folder.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入cd编程以导航到你的*编程*文件夹。
- en: Now, enter python3 to start the Python shell. (You could also try entering python,
    without the 3, but that might start up an older version of Python 2\. Python 2
    is not suitable for working through this book.)
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，输入python3启动Python shell。（你也可以尝试输入python，没有3，但那可能会启动Python 2的旧版本。Python 2不适合用来学习本书内容。）
- en: 'When you start the Python shell, you should see something like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当你启动Python shell时，你应该看到类似这样的内容：
- en: Python 3.9.2 (default, Mar 15 2021, 17:23:44)
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3.9.2（默认，2021年3月15日，17:23:44）
- en: '[Clang 11.0.0 (clang-1100.0.33.17)] on darwin'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[Clang 11.0.0 (clang-1100.0.33.17)] 在Darwin上'
- en: Type "help", "copyright", "credits" or "license" for more information.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 输入"help"、"copyright"、"credits"或"license"获取更多信息。
- en: '>>>'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '>>>'
- en: What’s important here is that you see a Python version of at least 3.6 in the
    first line. If you have an older version, especially 2.*x*, or if Python doesn’t
    load at all, please install a recent version of Python following the instructions
    in the introduction.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这里重要的是，你应该在第一行看到至少3.6版本的Python。如果你使用的是旧版本，尤其是2.*x*，或者如果Python根本没有加载，请按照介绍中的说明安装一个较新的Python版本。
- en: At the bottom of this window, you’ll see a >>> Python prompt. This is where
    you type Python code. Never type the >>> symbols yourself. Once you’re done programming,
    you can press CTRL-D to quit.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个窗口的底部，你会看到一个>>> Python提示符。在这里你输入Python代码。不要自己输入>>>符号。编程完成后，你可以按CTRL-D退出。
- en: Linux
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Linux
- en: 'On Linux, do the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上，请执行以下操作：
- en: Right-click your *programming* folder.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右击你的*编程*文件夹。
- en: In the resulting menu, click *Open in Terminal*. (You can also open the terminal
    and navigate to your *programming* folder if you’re more comfortable with that.)
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在弹出的菜单中，点击*在终端中打开*。（如果你更习惯的话，也可以先打开终端并导航到你的*编程*文件夹。）
- en: At the bottom of the resulting window, you’ll see a line that ends with a dollar
    sign ($). This is your operating system *prompt*, and it’s waiting for you to
    type a command. You type operating system commands here, *not* Python code. Be
    sure to press ENTER after each command.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在结果窗口的底部，你会看到一行以美元符号（$）结尾。这是你的操作系统*提示符*，它在等待你输入命令。你在这里输入操作系统命令，*不是*Python代码。确保每输入一条命令后按ENTER键。
- en: You’re now in your *programming* folder. You can type ls if you’d like to see
    what’s there. You shouldn’t see any files yet, because we haven’t created any.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在在你的*编程*文件夹中。如果你想查看文件夹里的内容，可以输入ls命令。你应该还看不见任何文件，因为我们还没有创建文件。
- en: Now, enter python3 to start the Python shell. (You could also try entering python,
    without the 3, but that might start up an older version of Python 2\. Python 2
    is not suitable for working through this book.)
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，输入python3启动Python shell。（你也可以尝试输入python，没有3，但那可能会启动Python 2的旧版本。Python 2不适合用来学习本书内容。）
- en: 'When you start the Python shell, you should see something like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当你启动Python shell时，你应该看到类似这样的内容：
- en: Python 3.9.2 (default, Feb 20 2021, 20:57:50)
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3.9.2（默认，2021年2月20日，20:57:50）
- en: '[GCC 7.5.0] on linux'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[GCC 7.5.0] 在Linux上'
- en: Type "help", "copyright", "credits" or "license" for more information.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 输入"help"、"copyright"、"credits"或"license"获取更多信息。
- en: '>>>'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '>>>'
- en: What’s important here is that you see a Python version of at least 3.6 in the
    first line. If you have an older version, especially 2.*x*, or if Python doesn’t
    load at all, please install a recent version of Python following the instructions
    in the introduction.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这里最重要的是你看到的 Python 版本至少是 3.6。如果你使用的是旧版本，尤其是 2.*x*，或者 Python 根本没有加载，请按照介绍中的说明安装一个最新版本的
    Python。
- en: At the bottom of this window, you’ll see a >>> Python prompt. This is where
    you type Python code. Never type the >>> symbols yourself. Once you’re done programming,
    you can press CTRL-D to quit.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个窗口的底部，你会看到一个 >>> Python 提示符。这是你输入 Python 代码的地方。切记不要自己输入 >>> 符号。一旦编程完成，你可以按
    CTRL-D 退出。
- en: 'Problem #1: Word Count'
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '问题 #1：单词计数'
- en: Now it’s time for our first problem! We’re going to use Python to write a little
    word-count program. We’ll learn how to read input from the user, process the input
    to solve the problem, and output the result. We’ll also learn how to manipulate
    text and numbers in our programs, make use of built-in Python operations, and
    store intermediate results on our way to the solution.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候解决第一个问题了！我们将使用 Python 编写一个简单的单词计数程序。我们将学习如何从用户那里读取输入，处理输入以解决问题，并输出结果。我们还将学习如何在程序中操作文本和数字，利用
    Python 的内置操作，并在解决问题的过程中存储中间结果。
- en: This is DMOJ problem dmopc15c7p2.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 DMOJ 问题 dmopc15c7p2。
- en: The Challenge
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战
- en: Count the number of words provided. For this problem, a *word* is any sequence
    of lowercase letters. For example, hello is a word, but so are non-English “words”
    like bbaabbb.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 计算提供的单词数。对于这个问题，*单词*是任何一串小写字母。例如，hello 是一个单词，但像 bbaabbb 这样的非英语“单词”也算。
- en: Input
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输入
- en: The input is one line of text, consisting of lowercase letters and spaces. There
    is exactly one space between each pair of words, and there are no spaces before
    the first word or after the last word.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 输入是一行文本，由小写字母和空格组成。每对单词之间正好有一个空格，且第一个单词前和最后一个单词后没有空格。
- en: The maximum length of the line is 80 characters.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 该行的最大长度为 80 个字符。
- en: Output
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输出
- en: Output the number of words in the input line.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 输出输入行中的单词数量。
- en: Strings
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串
- en: '*Values* are a fundamental building block of Python programs. Each value has
    a *type*, and the type determines the operations that can be performed on the
    value. In the Word Count problem, we’re working with a line of text. Text is stored
    as a string value in Python, so we’ll need to learn about strings. To solve the
    problem, we output the number of words in the text, so we also need to learn about
    numeric values. Let’s begin with strings.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*值*是 Python 程序的基本构建块。每个值都有一个 *类型*，而类型决定了可以对该值执行哪些操作。在单词计数问题中，我们正在处理一行文本。文本在
    Python 中作为字符串值存储，所以我们需要了解字符串。为了解决问题，我们需要输出文本中的单词数量，因此我们还需要了解数值。让我们从字符串开始。'
- en: Representing Strings
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 字符串的表示
- en: 'A *string* is the Python type that’s used to store and manipulate text. To
    write a string value, we place its characters between single quotes. Follow along
    in the Python shell:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*字符串*是 Python 中用于存储和处理文本的类型。要写一个字符串值，我们将它的字符放在单引号之间。可以在 Python shell 中跟着操作：'
- en: '>>> ''hello'''
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> ''hello'''
- en: '''hello'''
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '''hello'''
- en: '>>> ''a bunch of words'''
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> ''一堆词'''
- en: '''a bunch of words'''
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '''一堆词'''
- en: The Python shell echoes each string that I’ve typed.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Python shell 会回显我输入的每个字符串。
- en: What happens when our string contains a single quote as one of its characters?
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的字符串包含单引号作为其中一个字符时，会发生什么？
- en: '>>> ''don''t say that'''
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> ''别这么说'''
- en: File "<stdin>", line 1
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 "<stdin>"，第 1 行
- en: '''don''t say that'''
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '''别这么说'''
- en: ^
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ^
- en: 'SyntaxError: invalid syntax'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 'SyntaxError: 无效的语法'
- en: The single quote in the word don't terminates the string. The rest of the line,
    t say that', therefore doesn’t make sense, and that’s what generates the syntax
    error. A *syntax error* means that we have violated the rules of Python and have
    not written valid Python code.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 单引号在单词 don’t 中终止了字符串。剩下的部分，t say that'，因此没有意义，这就导致了语法错误。*语法错误*意味着我们违反了 Python
    的规则，写出了无效的 Python 代码。
- en: 'To fix this, we can take advantage of the fact that double quotes can also
    be used to delimit strings:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们可以利用双引号也可以用来界定字符串的事实：
- en: '>>> "don''t say that"'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> "别这么说"'
- en: '"don''t say that"'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '"别这么说"'
- en: Unless the string in question has a single quote, I won’t use double quotes
    in this book.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 除非字符串中包含单引号，否则我在这本书中不会使用双引号。
- en: String Operators
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 字符串操作符
- en: We can use a string to hold the text whose words we want to count. To count
    the words—or to do anything else with strings—we need to learn how to work with
    strings.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一个字符串来保存我们想要计数的单词文本。要统计单词数——或者对字符串做任何其他操作——我们需要学习如何处理字符串。
- en: 'Strings come with a rich variety of operations that we can perform. Some of
    them use special symbols between their operands. For example, the + operator is
    used for string concatenation:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串提供了丰富多样的操作，我们可以进行各种操作。其中一些操作在操作数之间使用特殊符号。例如，+ 运算符用于字符串连接：
- en: '>>> ''hello'' + ''there'''
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> ''hello'' + ''there'''
- en: '''hellothere'''
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '''hellothere'''
- en: 'Oops—we need a space between those two words. Let’s add one to the end of the
    first string:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀——我们需要在这两个单词之间加个空格。让我们在第一个字符串的末尾加一个空格：
- en: '>>> ''hello '' + ''there'''
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> ''hello '' + ''there'''
- en: '''hello there'''
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '''hello there'''
- en: 'There’s also the * operator, which replicates a string a specified number of
    times:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 还有 * 运算符，它会将字符串复制指定的次数：
- en: '>>> ''-'' * 30'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> ''-'' * 30'
- en: '''------------------------------'''
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '''------------------------------'''
- en: That 30 there is an integer value. I’ll have more to say about integers shortly.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 那个 30 是一个整数值。稍后我会详细讲解整数。
- en: '**CONCEPT CHECK**'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念检查**'
- en: What is the output of the following code?
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码的输出是什么？
- en: '>>> '''' * 3'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> '''' * 3'
- en: A. ''''''
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: A. ''''''
- en: B. ''
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: B. ''
- en: C. This code produces a syntax error (invalid Python code)
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: C. 这段代码会产生语法错误（无效的 Python 代码）
- en: 'Answer: B. '''' is the empty string—a string of zero characters. Repeating
    an empty string three times is still an empty string!'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：B. '' 是空字符串——一个零字符的字符串。重复三次空字符串仍然是空字符串！
- en: String Methods
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 字符串方法
- en: 'A *method* is an operation specific to a type of value. Strings have a large
    number of methods. For example, there’s a method called upper, which produces
    the uppercase version of a string:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*方法* 是特定于某种类型值的操作。字符串有大量的方法。例如，有一个名为 upper 的方法，它返回字符串的大写版本：'
- en: '>>> ''hello''.upper()'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> ''hello''.upper()'
- en: '''HELLO'''
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '''HELLO'''
- en: The information we get back from a method is known as the method’s *return value*.
    For example, we could say for the previous example that upper returned the string
    'HELLO'.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从方法中得到的结果叫做方法的 *返回值*。例如，对于之前的例子，我们可以说 upper 返回了字符串 'HELLO'。
- en: Performing a method on a value is known as *calling* the method. Calling a method
    involves placing the *dot operator* (.) between the value and the method name.
    It also requires parentheses after the method name. For some methods, we leave
    those parentheses empty, as when calling upper.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 对一个值调用方法叫做 *调用* 方法。调用方法时，我们需要在值和方法名称之间加上 *点运算符* (.)，并且方法名称后面还需要有括号。对于一些方法，我们可以保持括号为空，比如调用
    upper 方法时。
- en: For other methods, we can optionally include information there. Still other
    methods require information and won’t work at all without it. Information we include
    when calling a method is referred to as the method’s *arguments*.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他方法，我们可以选择性地在其中包含信息。还有一些方法需要信息，并且没有它就无法正常工作。我们在调用方法时包含的信息被称为方法的 *参数*。
- en: 'For example, strings have a strip method. If called with no arguments, strip
    removes all leading and trailing spaces from a string:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，字符串有一个 strip 方法。如果不带参数调用 strip，它会删除字符串的所有前导和尾随空格：
- en: '>>> ''   abc''.strip()'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> ''   abc''.strip()'
- en: '''abc'''
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '''abc'''
- en: '>>> ''   abc       ''.strip()'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> ''   abc       ''.strip()'
- en: '''abc'''
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '''abc'''
- en: '>>> ''abc''.strip()'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> ''abc''.strip()'
- en: '''abc'''
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '''abc'''
- en: 'But we can also call it with a string as the argument. If we do, that argument
    determines which characters are stripped from the beginning and the end:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们也可以将其与字符串作为参数一起调用。如果这样做，参数决定了从字符串的开头和结尾去除哪些字符：
- en: '>>> ''abc''.strip(''a'')'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> ''abc''.strip(''a'')'
- en: '''bc'''
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '''bc'''
- en: '>>> ''abca''.strip(''a'')'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> ''abca''.strip(''a'')'
- en: '''bc'''
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '''bc'''
- en: '>>> ''abca''.strip(''ac'')'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> ''abca''.strip(''ac'')'
- en: '''b'''
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '''b'''
- en: 'Let’s talk about one more string method: count. We pass it a string argument,
    and it tells us how many occurrences of that argument are found in our string:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再谈谈一个字符串方法：count。我们传入一个字符串参数，它会告诉我们该参数在字符串中出现的次数：
- en: '>>> ''abc''.count(''a'')'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> ''abc''.count(''a'')'
- en: '1'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '>>> ''abc''.count(''q'')'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> ''abc''.count(''q'')'
- en: '0'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '>>> ''aaabcaa''.count(''a'')'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> ''aaabcaa''.count(''a'')'
- en: '5'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: '>>> ''aaabcaa''.count(''ab'')'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> ''aaabcaa''.count(''ab'')'
- en: '1'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: 'If occurrences of the argument overlap, only the first counts:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果参数的出现重叠，那么只有第一次的出现会被计算：
- en: '>>> ''ababa''.count(''aba'')'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> ''ababa''.count(''aba'')'
- en: '1'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: Unlike the other methods I’ve described, count is directly useful to our Word
    Count problem.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 与我之前描述的其他方法不同，count 方法对我们的字数统计问题直接有用。
- en: 'Think of a string like ''this is a string with a few words''. Notice that a
    space comes after each word. In fact, if you had to count the number of words
    by hand, you might use the spaces to tell you where each word ends. What if we
    count the number of spaces in a string? To do that, we can pass a string consisting
    of a single space character to count. It looks like this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个字符串，比如'this is a string with a few words'。注意每个单词后面都有一个空格。事实上，如果你需要手动计算单词的数量，可能会使用空格来告诉你每个单词的结束位置。如果我们数一下字符串中的空格数量呢？为此，我们可以传入一个由单个空格字符组成的字符串来计数。它看起来是这样的：
- en: '>>> ''this is a string with a few words''.count('' '')'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> ''this is a string with a few words''.count('' '')'
- en: '7'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '7'
- en: We get a value of 7. That’s not quite the number of words—the string has eight
    words—but we’re close. Why are we getting 7 instead of 8?
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了7这个值。虽然这不是准确的单词数——字符串有八个单词——但我们已经接近了。为什么我们得到的是7而不是8呢？
- en: The reason is that each word has a space after it except the last word. Counting
    the spaces therefore fails to account for the final word. To remedy that, we need
    to learn how to handle numbers.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 原因在于每个单词后面都有一个空格，除了最后一个单词。因此，计数空格无法计算最后一个单词。为了解决这个问题，我们需要学习如何处理数字。
- en: Integer and Floating-Point Numbers
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 整数和浮点数
- en: An *expression* is made up of values and operators. We’ll now see how to write
    numeric values and combine them with operators.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*表达式*由值和运算符组成。现在我们将看到如何编写数值并将它们与运算符结合。
- en: 'There are two different Python types that represent numbers: integers (with
    no decimal part) and floating-point numbers (with a decimal part).'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Python有两种不同的数字类型：整数（没有小数部分）和浮点数（有小数部分）。
- en: 'We write integer values as numbers with no decimal point. Here are some examples:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将整数值写成没有小数点的数字。以下是一些例子：
- en: '>>> 30'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 30'
- en: '30'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '30'
- en: '>>> 7'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 7'
- en: '7'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '7'
- en: '>>> 1000000'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 1000000'
- en: '1000000'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '1000000'
- en: '>>> -9'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> -9'
- en: '-9'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '-9'
- en: A value on its own is the simplest kind of expression.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 独立的值是最简单的表达式形式。
- en: The familiar mathematical operators work on integers. We have + for addition,
    - for subtraction, and * for multiplication. We can use these operators to write
    more complicated expressions.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的数学运算符作用于整数。我们有+表示加法，-表示减法，*表示乘法。我们可以使用这些运算符编写更复杂的表达式。
- en: '>>> 8 + 10'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 8 + 10'
- en: '18'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '18'
- en: '>>> 8 - 10'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 8 - 10'
- en: '-2'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '-2'
- en: '>>> 8 * 10'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 8 * 10'
- en: '80'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '80'
- en: Notice the spaces around the operators. While 8+10 and 8 + 10 are the same as
    far as Python is concerned, the latter makes the expression easier for us humans
    to read.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 注意运算符两边的空格。虽然8+10和8 + 10在Python看来是一样的，但后者让我们人类更容易阅读这个表达式。
- en: 'Python has two division operators, not one! The // operator performs integer
    division, which throws away any remainder and rounds the result down:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Python有两个除法运算符，而不是一个！//运算符执行整数除法，它会舍弃余数并向下舍入结果：
- en: '>>> 8 // 2'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 8 // 2'
- en: '4'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: '>>> 9 // 5'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 9 // 5'
- en: '1'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '>>> -9 // 5'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> -9 // 5'
- en: '-2'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '-2'
- en: 'If you want the remainder of the division, use the mod operator, written as
    %. For example, dividing 8 by 2 leaves no remainder:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要除法的余数，可以使用取模运算符，写作%。例如，8除以2没有余数：
- en: '>>> 8 % 2'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 8 % 2'
- en: '0'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: 'Dividing 8 by 3 leaves a remainder of 2:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 8除以3留下余数2：
- en: '>>> 8 % 3'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 8 % 3'
- en: '2'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: 'The / operator, in contrast to //, doesn’t do any rounding:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 与//运算符不同，/运算符不会做任何四舍五入：
- en: '>>> 8 / 2'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 8 / 2'
- en: '4.0'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '4.0'
- en: '>>> 9 / 5'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 9 / 5'
- en: '1.8'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '1.8'
- en: '>>> -9 / 5'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> -9 / 5'
- en: '-1.8'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '-1.8'
- en: 'These result values are not integers! They have a decimal point and belong
    to a different Python type called *float* (for “floating-point numbers”). You
    can write float values by including a decimal point:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这些结果值不是整数！它们有小数点，并且属于另一种Python类型，叫做*float*（浮点数）。你可以通过包含小数点来写浮点值：
- en: '>>> 12.5 * 2'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 12.5 * 2'
- en: '25.0'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '25.0'
- en: We’ll focus on integers for now and return to floating-point numbers when we
    solve Cone Volume later in this chapter.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将专注于整数，并在本章稍后的圆锥体体积问题中再回到浮点数。
- en: 'When we use multiple operators in an expression, Python uses precedence rules
    to determine the order that operators are applied. Each operator has a precedence.
    Just like when we evaluate a mathematical expression on paper, Python performs
    multiplications and divisions (higher precedence) before additions and subtractions
    (lower precedence):'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在一个表达式中使用多个运算符时，Python会根据优先级规则来确定运算符应用的顺序。每个运算符都有一个优先级。就像我们在纸上计算数学表达式时一样，Python会先进行乘法和除法（优先级高），再进行加法和减法（优先级低）：
- en: '>>> 50 + 10 * 2'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 50 + 10 * 2'
- en: '70'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '70'
- en: 'Again, like on paper, operations inside parentheses have the highest precedence.
    We can use this to force Python to perform operations in our desired order:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的，和在纸上计算一样，括号内的操作有最高的优先级。我们可以利用这一点强制Python按照我们期望的顺序执行操作：
- en: '>>> (50 + 10) * 2'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> (50 + 10) * 2'
- en: '120'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '120'
- en: Programmers often add parentheses even when not technically required. That’s
    because Python has many operators, as we’ll see, and keeping track of their precedence
    is error-prone and not something that programmers typically do.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员经常即使在技术上不需要时也加上括号。这是因为 Python 有许多操作符，正如我们将看到的那样，跟踪它们的优先级容易出错，而程序员通常不会这么做。
- en: 'If you’re wondering whether integer values and float values have methods, just
    like strings, they do! But they aren’t all that useful. For example, there’s a
    method that tells us how much of the computer’s memory is taken up by an integer.
    The bigger the integer, the more memory it requires:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在想整数值和浮点值是否也有方法，就像字符串一样，它们是有的！但它们并不总是非常有用。例如，有一个方法告诉我们一个整数占用了多少计算机内存。整数越大，它所需的内存就越多：
- en: '>>> (5).bit_length()'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> (5).bit_length()'
- en: '3'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: '>>> (100).bit_length()'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> (100).bit_length()'
- en: '7'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '7'
- en: '>>> (99999).bit_length()'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> (99999).bit_length()'
- en: '17'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '17'
- en: We need the parentheses around the integers; otherwise, the dot operator gets
    confused with a decimal point, and we get a syntax error.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在整数周围加上括号，否则点操作符会被误认为是小数点，导致语法错误。
- en: Variables
  id: totrans-213
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 变量
- en: We now know how to write string and numeric values. We’ll also find it valuable
    to be able to store them so we can access them later. In Word Count, it would
    be convenient to be able to store the line of words somewhere and then count the
    number of words.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道如何编写字符串和数字值。我们还会发现能够存储它们，以便以后访问会很有用。在“字数统计”中，能够把一行文字存储起来，然后统计单词数将非常方便。
- en: Assignment Statement
  id: totrans-215
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 赋值语句
- en: 'A *variable* is a name that refers to a value. Whenever we later use a variable’s
    name, it gets substituted by what that variable refers to. To make a variable
    refer to a value, we use the *assignment statement*. An assignment statement consists
    of a variable, an equal sign (=), and an expression. Python evaluates the expression
    and makes the variable refer to the result. Here’s an example assignment statement:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*变量*是一个表示值的名称。每当我们使用变量名称时，它会被替换为该变量所表示的值。为了使变量指向一个值，我们使用*赋值语句*。赋值语句由一个变量、一个等号（=）和一个表达式组成。Python
    会评估表达式并使变量指向结果。以下是一个赋值语句的示例：
- en: '>>> dollars = 250'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> dollars = 250'
- en: 'Now, dollars is substituted by 250 whenever we use it:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当我们使用 dollars 时，它都会被替换为 250：
- en: '>>> dollars'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> dollars'
- en: '250'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '250'
- en: '>>> dollars + 10'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> dollars + 10'
- en: '260'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '260'
- en: '>>> dollars'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> dollars'
- en: '250'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '250'
- en: 'A variable refers to only one value at a time. Once we use an assignment statement
    to make a variable refer to another value, it no longer refers to the old value:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 一个变量一次只指向一个值。一旦我们使用赋值语句使变量指向另一个值，它就不再指向旧值：
- en: '>>> dollars = 250'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> dollars = 250'
- en: '>>> dollars'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> dollars'
- en: '250'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '250'
- en: '>>> dollars = 300'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> dollars = 300'
- en: '>>> dollars'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> dollars'
- en: '300'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '300'
- en: 'We can have as many variables as we like. Large programs typically use hundreds
    of variables. Here’s an example of using two variables:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以有任意数量的变量。大型程序通常使用数百个变量。以下是使用两个变量的示例：
- en: '>>> purchase_price1 = 58'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> purchase_price1 = 58'
- en: '>>> purchase_price2 = 9'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> purchase_price2 = 9'
- en: '>>> purchase_price1 + purchase_price2'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> purchase_price1 + purchase_price2'
- en: '67'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '67'
- en: Notice that I’ve chosen variable names that give some sense of what they’re
    storing. These two variables, for example, have to do with the prices of two purchases.
    Using variable names p1 and p2 would be easier to type, but in a few days we’d
    probably forget what the names mean!
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我选择的变量名称能够大致说明它们存储的内容。例如，这两个变量与两项购买的价格有关。使用 p1 和 p2 这样的变量名可能更容易输入，但几天后我们可能就会忘记这些名称代表什么！
- en: 'We can make variables refer to strings, too:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以让变量指向字符串：
- en: '>>> start = ''Monday'''
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> start = ''Monday'''
- en: '>>> end = ''Friday'''
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> end = ''Friday'''
- en: '>>> start'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 开始'
- en: '''Monday'''
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '''Monday'''
- en: '>>> end'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 结束'
- en: '''Friday'''
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '''Friday'''
- en: 'As with variables that refer to numbers, we can use these in larger expressions:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 与指向数字的变量一样，我们也可以在更大的表达式中使用它们：
- en: '>>> start + ''-'' + end'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> start + ''-'' + end'
- en: '''Monday-Friday'''
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '''Monday-Friday'''
- en: Python variable names should start with a lowercase letter and then can contain
    additional letters, underscores to separate words, and numbers.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: Python 变量名应该以小写字母开头，然后可以包含额外的字母、下划线分隔单词以及数字。
- en: Changing Variable Values
  id: totrans-249
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 变量值的改变
- en: 'Suppose we have a variable dollars that refers to value 250:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个名为 dollars 的变量，它表示值 250：
- en: '>>> dollars = 250'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> dollars = 250'
- en: 'Now we want to increase the value so that dollars refers to 251\. This won’t
    work:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想增加值，使 dollars 指向 251。这样做是行不通的：
- en: '>>> dollars + 1'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> dollars + 1'
- en: '251'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '251'
- en: 'The result is 251, but that value is gone, not stored anywhere:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是 251，但该值已消失，并未存储在任何地方：
- en: '>>> dollars'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> dollars'
- en: '250'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '250'
- en: 'What we need is an assignment statement that captures the result of dollars
    + 1:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的是一个赋值语句，它捕捉到dollars + 1的结果：
- en: '>>> dollars = dollars + 1'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> dollars = dollars + 1'
- en: '>>> dollars'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 美元'
- en: '251'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '251'
- en: '>>> dollars = dollars + 1'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> dollars = dollars + 1'
- en: '>>> dollars'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> dollars'
- en: '252'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '252'
- en: It’s common for learners to think of the assignment symbol = as equality. But
    don’t do that! The assignment statement is a command to make a variable refer
    to the value of an expression, not a claim that two entities are equal.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 学习者常常把赋值符号 = 当作等式来理解。但千万不要那样想！赋值语句是一个命令，它使得一个变量指向一个表达式的值，而不是声明两个实体相等。
- en: '**CONCEPT CHECK**'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念检查**'
- en: What is the value of y after the execution of the following code?
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码后，y 的值是多少？
- en: '>>> x = 37'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x = 37'
- en: '>>> y = x + 2'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> y = x + 2'
- en: '>>> x = 20'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x = 20'
- en: A. 39
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: A. 39
- en: B. 22
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: B. 22
- en: C. 35
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: C. 35
- en: D. 20
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: D. 20
- en: E. 18
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: E. 18
- en: 'Answer: A. There’s only one assignment to y, and it makes y refer to the value
    39. The x = 20 assignment statement changes what x refers to, from 37 to 20, but
    this has no impact on the value referred to by y.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：A. y 只被赋值一次，并且它指向值 39。x = 20 的赋值语句改变了 x 的值，从 37 变为 20，但这对 y 的值没有影响。
- en: Counting the Words Using a Variable
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用变量计数单词
- en: 'Let’s take stock of our progress toward solving the Word Count problem:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下在解决单词计数问题中的进展：
- en: We know about strings, and we can use a string to store the line of words.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们了解字符串，可以使用字符串存储一行单词。
- en: We know about the string count method, which we can use to count the number
    of spaces in the line of words. That gives us one less than the output value that
    we need.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们了解字符串的 count 方法，可以用它来计算一行单词中的空格数量。这样会给我们比需要的输出值少 1 的结果。
- en: We know about integers, whose + operator we can use to add 1 to a number.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们了解整数，可以使用其 + 操作符给一个数字加 1。
- en: We know about variables and the assignment statement, which help us hold on
    to values so that we don’t lose them.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们了解变量和赋值语句，它们帮助我们保留值，防止丢失。
- en: 'Putting all of this together, we can make a variable refer to a string and
    then count the number of words:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 把这些都放在一起，我们可以让一个变量指向一个字符串，然后计算单词的数量：
- en: '>>> line = ''this is a string with a few words'''
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> line = ''this is a string with a few words'''
- en: '>>> total_words = line.count('' '') + 1'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> total_words = line.count('' '') + 1'
- en: '>>> total_words'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> total_words'
- en: '8'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '8'
- en: 'The line and total_words variables aren’t required here; here’s how we could
    do it without them:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这里不需要line 和 total_words 变量；我们可以不使用它们，直接这样做：
- en: '>>> ''this is a string with a few words''.count('' '') + 1'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> ''this is a string with a few words''.count('' '') + 1'
- en: '8'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '8'
- en: But using variables to capture intermediate results is a good practice for keeping
    code readable. Once our programs get longer than a few lines, variables will be
    indispensable.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 但是使用变量来捕捉中间结果是保持代码可读性的好习惯。一旦我们的程序超过几行，变量将变得不可或缺。
- en: Reading Input
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 读取输入
- en: One problem with the code that we’ve written is that it works only on the particular
    string that we’ve typed in. It tells us that there are eight words in 'this is
    a string with a few words', but that’s all it can do. If we want to know how many
    words are in a different string, we’ll have to replace the current string with
    a new one. To solve Word Count, though, we need our program to work on *any* string
    provided as input to our program.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们写的代码的一个问题是，它只对我们输入的特定字符串有效。它告诉我们'this is a string with a few words'中有八个单词，但它只能做到这一点。如果我们想知道另一个字符串中有多少个单词，我们就必须替换当前字符串为一个新的字符串。然而，为了完成单词计数，我们需要我们的程序能够处理*任何*作为输入提供给程序的字符串。
- en: 'To read a line of input, we use the input function. A *function* is similar
    to a method: we call it, perhaps with some arguments, and it returns a value to
    us. One difference between a method and a function is that a function does not
    use the dot operator. All information passed to functions is through arguments.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 要读取一行输入，我们使用输入函数。*函数*类似于方法：我们调用它，可能带有一些参数，然后它会返回一个值。方法和函数的区别在于，函数不使用点操作符。所有传递给函数的信息都是通过参数传递的。
- en: 'Here’s an example of calling the input function and then typing some input—in
    this case, the word testing:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个调用输入函数并输入内容的示例——在这个例子中，输入的是单词 testing：
- en: '>>> input()'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> input()'
- en: testing
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: testing
- en: '''testing'''
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '''testing'''
- en: 'When you type input() and press ENTER, you don’t get a >>> prompt back. Instead,
    Python waits for you to type something on the keyboard and press ENTER. The input
    function then returns the string you typed. As usual, if we don’t store that string
    anywhere, then it’s lost. Let’s use an assignment statement to store what we type:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 当你输入 input() 并按下 ENTER 时，你不会看到 >>> 提示符。相反，Python 会等待你在键盘上输入内容并按 ENTER。然后 input
    函数会返回你输入的字符串。像往常一样，如果我们没有把这个字符串存储起来，它就会丢失。让我们使用赋值语句来存储我们输入的内容：
- en: '>>> result = input()'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> result = input()'
- en: testing
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 测试
- en: '>>> result'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> result'
- en: '''testing'''
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '''testing'''
- en: '>>> result.upper()'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> result.upper()'
- en: '''TESTING'''
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '''TESTING'''
- en: Notice in the last line that I’ve used the upper method on the value returned
    by input. This is allowed because input returns a string, and upper is a string
    method.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在最后一行中，我对 input 返回的值使用了 upper 方法。之所以可以这样做，是因为 input 返回的是一个字符串，而 upper 是一个字符串方法。
- en: Writing Output
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 写入输出
- en: 'You’ve seen that typing expressions at the Python shell causes their values
    to be displayed:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到，在 Python shell 中输入表达式会导致显示其值：
- en: '>>> ''abc'''
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> ''abc'''
- en: '''abc'''
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '''abc'''
- en: '>>> ''abc''.upper()'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> ''abc''.upper()'
- en: '''ABC'''
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '''ABC'''
- en: '>>> 45 + 9'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 45 + 9'
- en: '54'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '54'
- en: 'That’s just a convenience provided by the Python shell. It assumes that if
    you type an expression, then you probably want to see its value. But when running
    a Python program outside of the Python shell, this convenience is gone. Instead,
    we must explicitly use the print function whenever we want to output something.
    The print function works from the shell, too:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是 Python shell 提供的一种便利。它假设你输入一个表达式时，可能想要看到其值。但是在 Python shell 之外运行 Python
    程序时，这种便利就消失了。相反，我们必须在每次想要输出内容时明确使用 print 函数。print 函数在 shell 中也能工作：
- en: '>>> print(''abc'')'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> print(''abc'')'
- en: abc
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: abc
- en: '>>> print(''abc''.upper())'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> print(''abc''.upper())'
- en: ABC
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: ABC
- en: '>>> print(45 + 9)'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> print(45 + 9)'
- en: '54'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '54'
- en: Notice that strings output by print don’t have quotes around them. That’s good—we
    probably don’t want to include quotes when communicating with users of our programs
    anyway!
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，print 输出的字符串没有引号。这很好——因为我们大概不希望在与程序用户交流时包括引号！
- en: 'One nice feature of print is that you can supply as many arguments as you like,
    and they all get output with separating spaces:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: print 的一个不错的功能是，你可以提供任意多个参数，它们都会用空格分隔并输出：
- en: '>>> print(''abc'', 45 + 9)'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> print(''abc'', 45 + 9)'
- en: abc 54
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: abc 54
- en: 'Solving the Problem: A Complete Python Program'
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决问题：一个完整的 Python 程序
- en: We’re now ready to solve Word Count by writing a complete Python program. Exit
    the Python shell and you’ll be back at your operating system command prompt.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备通过编写一个完整的 Python 程序来解决 Word Count 问题。退出 Python shell 后，你将回到操作系统的命令提示符。
- en: Launching a Text Editor
  id: totrans-328
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 启动文本编辑器
- en: We’ll use a text editor to write our code. Follow the steps for your operating
    system.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用文本编辑器来编写代码。按照你的操作系统的步骤进行。
- en: Windows
  id: totrans-330
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Windows
- en: On Windows, we’ll use Notepad, a bare-bones text editor. At the operating system
    command prompt, navigate to your *programming* folder if you’re not already there.
    Then type notepad word_count.py and press ENTER. Since the *word_count.py* file
    doesn’t exist, Notepad will ask you whether you’d like to create a new *word_count.py*
    file. Click **Yes** and you’ll be ready to type your Python program.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，我们将使用 Notepad，一个简易文本编辑器。在操作系统命令提示符下，如果你还不在*编程*文件夹中，请导航到该文件夹。然后输入
    notepad word_count.py 并按 ENTER。由于*word_count.py*文件不存在，Notepad 会询问你是否要创建一个新的*word_count.py*文件。点击**是**，你就可以开始输入你的
    Python 程序了。
- en: macOS
  id: totrans-332
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: macOS
- en: 'On macOS, you can use whichever text editor you like. One editor that you likely
    already have installed is TextEdit. At the operating system command prompt, navigate
    to your *programming* folder if you’re not already there. Then type the following
    two commands, pressing ENTER after each one:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在 macOS 上，你可以使用任何你喜欢的文本编辑器。你可能已经安装的一个编辑器是 TextEdit。在操作系统的命令提示符下，如果你还不在*编程*文件夹中，请导航到该文件夹。然后输入以下两个命令，每输入一个命令后按
    ENTER：
- en: $ touch word_count.py
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: $ touch word_count.py
- en: $ open -a TextEdit word_count.py
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: $ open -a TextEdit word_count.py
- en: The touch command creates an empty file so that your text editor can open it.
    Now you’re ready to type your Python program.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: touch 命令创建一个空文件，供文本编辑器打开。现在你可以开始输入你的 Python 程序了。
- en: Linux
  id: totrans-337
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Linux
- en: On Linux, you can use whichever text editor you like. One editor that you likely
    already have installed is gedit. At the operating system command prompt, navigate
    to your *programming* folder if you’re not already there. Then type gedit word_count.py
    and press ENTER. Now you’re ready to type your Python program.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 上，你可以使用任何你喜欢的文本编辑器。你可能已经安装的一个编辑器是 gedit。在操作系统的命令提示符下，如果你还没有在那里，请导航到你的*编程*文件夹。然后输入
    gedit word_count.py 并按回车键。现在你可以输入你的 Python 程序了。
- en: The Program
  id: totrans-339
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 程序
- en: With your text editor loaded, you can type the code of our Python program. The
    code is in [Listing 1-1](ch01.xhtml#ch01ex01).
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载好文本编辑器后，你可以输入我们的 Python 程序代码。代码位于[清单 1-1](ch01.xhtml#ch01ex01)。
- en: ❶ line = input()
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ line = input()
- en: ❷ total_words = line.count(' ') + 1
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ total_words = line.count(' ') + 1
- en: ❸ print(total_words)
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ print(total_words)
- en: '*Listing 1-1: Solving Word Count*'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 1-1：解决单词计数*'
- en: When entering that code, don’t enter the ❶, ❷, or ❸. Those are there to help
    us walk through the code and are not part of the code itself.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 输入代码时，请不要输入 ❶、❷ 或 ❸。它们是用来帮助我们逐步讲解代码的，不是代码的一部分。
- en: We begin by acquiring the line of text from the input and assigning it to a
    variable ❶. That gives us a string, on which we can use the count method. We add
    1 to the count of spaces to account for the final word in the string, and we use
    the variable total_words to refer to that result ❷. The last thing to do is output
    the value referred to by total_words ❸.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先从输入中获取一行文本，并将其赋值给变量 ❶。这将得到一个字符串，我们可以在其上使用 count 方法。我们将空格的计数加 1，以考虑字符串中的最后一个单词，并使用变量
    total_words 来引用这个结果 ❷。最后一步是输出 total_words 所引用的值 ❸。
- en: Be sure to save the file once you’ve finished typing the code.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 完成代码输入后，请务必保存文件。
- en: Running the Program
  id: totrans-348
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 运行程序
- en: To run the program, we’ll use the python command from our operating system command
    prompt. As we’ve seen, entering python by itself runs the Python shell, but we
    don’t want that this time. Instead, we want to tell Python to run the program
    in *word_count.py*. To do that, navigate to your *programming* folder, and enter
    python word_count.py. Here and throughout the book, please use the python3 command
    instead of the python command if needed.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行程序，我们将在操作系统命令提示符下使用 python 命令。正如我们之前看到的，单独输入 python 会运行 Python shell，但这次我们不想这样做。相反，我们要告诉
    Python 运行 *word_count.py* 程序。为此，导航到你的 *编程* 文件夹，输入 python word_count.py。这里以及在全书中，如果需要，请使用
    python3 命令，而不是 python 命令。
- en: 'Your program is now waiting at the input prompt for you to type something.
    Type a few words, press ENTER, and you should see our program working correctly.
    For example, type the following:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你的程序在输入提示符下等待你输入内容。输入几个单词，按回车键，你应该能看到程序正确运行。例如，输入以下内容：
- en: this is my first python program
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我的第一个 Python 程序
- en: You should see the program produce 6 as the output.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到程序输出 6 作为结果。
- en: If instead you see a Python error, go back over the code and make sure you’ve
    typed it in exactly. Python requires precision. Even a missing parenthesis or
    single quote will lead to an error.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到 Python 错误，请仔细检查代码，确保你完全输入正确。Python 要求精确。即使缺少一个括号或单引号，也会导致错误。
- en: Don’t be frustrated if it takes you some time to get this program to run. Getting
    a first program to run can require a lot of work. We have to be able to type a
    program into a file, invoke Python to run that program, and fix any errors resulting
    from an incorrect program. But the procedure for running programs doesn’t change,
    no matter how complex the program, so time you spend here will be well worth it
    as you work through the rest of the book.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你花一些时间才让程序运行，不要感到沮丧。让第一个程序运行可能需要做很多工作。我们必须能够将程序输入到文件中，调用 Python 运行该程序，并修复由于程序错误导致的问题。但运行程序的过程是固定的，无论程序多复杂，所以在这里花的时间会为你完成书中的其余内容打下坚实的基础。
- en: Submitting to the Judge
  id: totrans-355
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 提交给评测系统
- en: Congratulations! I hope it was satisfying to run your first Python program on
    your computer. But how do we know this program is correct? Does it work for all
    possible strings? We can test it on a few more strings, but the way we’ll gain
    even more confidence in the correctness of our code is by submitting it to the
    online judge. The judge automatically runs a bunch of tests on our code and tells
    us whether we passed the tests or if something is wrong.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！希望你运行第一个 Python 程序时感到满足。但我们怎么知道这个程序是正确的呢？它对所有可能的字符串都有效吗？我们可以再对几个字符串进行测试，但我们将通过将代码提交给在线评测来更有信心地判断它的正确性。评测系统会自动对我们的代码进行一系列测试，并告诉我们是否通过了测试，或者是否有错误。
- en: Go to *[https://dmoj.ca/](https://dmoj.ca/)* and log in. (If you don’t have
    a DMOJ account, please create one following the instructions in the introduction.)
    Click **Problems**, and search for the Word Count problem code dmopc15c7p2. Click
    the search result to load the problem—it’s called Not a Wall of Text rather than
    Word Count.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 *[https://dmoj.ca/](https://dmoj.ca/)* 并登录。（如果你没有 DMOJ 账户，请按照介绍中的说明创建一个。）点击
    **Problems**，并搜索 Word Count 问题代码 dmopc15c7p2。点击搜索结果加载问题——它被称为 "Not a Wall of Text"
    而不是 Word Count。
- en: You should then see the text of the problem, as written by the problem author.
    Click **Submit Solution**, and paste our code into the text area. Be sure to select
    Python 3 as the programming language. Finally, click the **Submit** button.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你应该看到问题的描述，正如问题作者所写的那样。点击 **Submit Solution**，并将我们的代码粘贴到文本区域。确保选择 Python 3
    作为编程语言。最后，点击 **Submit** 按钮。
- en: DMOJ runs tests on our code and shows us the results. For each test case, you’ll
    see a status code. *AC* stands for *accepted* and is what you want to see for
    each test case. Other codes include *WA* (*wrong answer*) and *TLE* (*time limit
    exceeded*). If you see one of these, double-check the code that you pasted, making
    sure it exactly matches the code from your text editor.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: DMOJ 会对我们的代码进行测试并显示结果。对于每个测试用例，你会看到一个状态代码。*AC* 代表 *accepted*（接受），这是你希望看到的每个测试用例的状态。其他状态代码包括
    *WA*（错误答案）和 *TLE*（超时）。如果你看到这些，请再次检查你粘贴的代码，确保它与文本编辑器中的代码完全一致。
- en: Assuming all test cases are accepted, we should see that our score is 100/100
    and that we’ve earned 3 points for our work.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 假设所有测试用例都通过，我们应该能看到我们的得分为 100/100，并且我们为此获得了 3 分。
- en: For each problem, we’ll follow the approach that we used to solve Word Count.
    First, we’ll explore using the Python shell, learning new Python features as needed.
    Then, we’ll write a program that solves the problem. We’ll test that program on
    our computer by supplying our own test cases. Finally, we’ll submit the code to
    the judge. If any test cases fail, we’ll look over our code again and fix the
    problem.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个问题，我们将遵循解决 Word Count 时使用的方法。首先，我们将探索使用 Python Shell，根据需要学习新的 Python 特性。然后，我们将编写一个解决问题的程序。我们将在自己的计算机上测试该程序，提供我们自己的测试用例。最后，我们将代码提交给评测系统。如果任何测试用例失败，我们将再次检查代码并修复问题。
- en: 'Problem #2: Cone Volume'
  id: totrans-362
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '问题 #2：圆锥体积'
- en: In Word Count, we needed to read a string from the input. In this problem, we’ll
    need to read integers from the input. Doing so requires an extra step to produce
    an integer from a string. We’ll also learn a little more about doing math in Python.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Word Count 中，我们需要从输入中读取一个字符串。在这个问题中，我们需要从输入中读取整数。这样做需要一个额外的步骤，将字符串转换为整数。我们还将学习如何在
    Python 中进行数学运算。
- en: This is DMOJ problem dmopc14c5p1.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 DMOJ 的问题 dmopc14c5p1。
- en: The Challenge
  id: totrans-365
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战
- en: Calculate the volume of a right circular cone.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 计算一个直圆锥的体积。
- en: Input
  id: totrans-367
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输入
- en: The input consists of two lines of text. The first line contains integer *r*,
    the radius of the cone. The second line contains integer *h*, the height of the
    cone. Both *r* and *h* are between 1 and 100\. (That is, the minimum value for
    *r* and *h* is 1, and the maximum value is 100.)
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 输入由两行文本组成。第一行包含整数 *r*，表示圆锥的半径。第二行包含整数 *h*，表示圆锥的高度。*r* 和 *h* 的值在 1 到 100 之间。（也就是说，*r*
    和 *h* 的最小值是 1，最大值是 100。）
- en: Output
  id: totrans-369
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输出
- en: Output the volume of the right circular cone with radius *r* and height *h*.
    The formula to calculate the volume is (*πr*²*h*)/3.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 输出具有半径 *r* 和高度 *h* 的直圆锥的体积。计算体积的公式是 (*πr*²*h*)/3。
- en: More Math in Python
  id: totrans-371
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Python 中更多的数学运算
- en: 'Say we have r and h variables referring to a radius and height, respectively:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有表示半径和高度的变量 r 和 h：
- en: '>>> r = 4'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> r = 4'
- en: '>>> h = 6'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> h = 6'
- en: Now we want to evaluate (*πr*²*h*)/3\. Substituting a radius of 4 and height
    of 6, we have (*π* * 4² * 6)/3\. Using a value of 3.14159 for *π*, a calculator
    gives a result of 100.531. How can we do this in Python?
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们要计算 (*πr*²*h*)/3。将半径 4 和高度 6 代入公式，我们得到 (*π* * 4² * 6)/3。使用 3.14159 作为 *π*
    的值，计算器给出的结果是 100.531。我们如何在 Python 中实现这个计算呢？
- en: Accessing Pi
  id: totrans-376
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 访问 Pi
- en: 'To access the value of *π*, we’ll use a suitable variable. Here’s an assignment
    statement to PI with a lot of accuracy in its value:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 为了访问 *π* 的值，我们将使用一个合适的变量。下面是一个赋值语句，将 PI 赋予一个非常精确的值：
- en: PI = 3.141592653589793
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: PI = 3.141592653589793
- en: This is more a *constant* than a variable, since we’ll never want to change
    the value of PI in our code. It’s Python convention to use uppercase letters for
    such variables, as I’ve done here.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 这更像是一个 *常量* 而不是变量，因为我们永远不希望在代码中更改 PI 的值。根据 Python 的惯例，对于这样的变量，我们使用大写字母，就像我这里做的那样。
- en: Exponents
  id: totrans-380
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 指数
- en: Looking back at our formula, (*πr*²*h*)/3, the only thing we haven’t talked
    about yet is how to perform the *r*² part. Since *r*² is the same as *r* * *r*,
    we can use multiplication rather than exponentiation.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾我们的公式，(*πr*²*h*)/3，唯一还没讨论的是如何计算 *r*² 部分。因为 *r*² 等同于 *r* * *r*，所以我们可以使用乘法而非指数运算。
- en: '>>> r'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> r'
- en: '4'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: '>>> r * r'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> r * r'
- en: '16'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '16'
- en: 'But it’s more transparent to use exponentiation directly. We always want to
    write code that’s as clear as possible. Besides, one day you might have to calculate
    larger exponents, where repeated multiplication becomes increasingly unwieldy.
    Python’s exponentiation operator is **:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 但直接使用指数运算更加直观。我们总是希望写出尽可能清晰的代码。而且，某一天你可能需要计算更大的指数，这时候重复的乘法会变得越来越难以处理。Python
    的指数运算符是 **：
- en: '>>> r ** 2'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> r ** 2'
- en: '16'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '16'
- en: 'Here’s the complete formula:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 这是完整的公式：
- en: '>>> (PI * r ** 2 * h) / 3'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> (π * r ** 2 * h) / 3'
- en: '100.53096491487338'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '100.53096491487338'
- en: Great—that’s close to the 100.531 result we expected!
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了——这接近我们预期的 100.531 结果！
- en: Notice that we’re producing a floating-point number here. As we discussed in
    “Integer and Floating-Point Numbers” in this chapter, the / division operator
    produces a floating-point result.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在这里产生的是一个浮点数。正如我们在本章“整数和浮点数”中讨论的那样，/ 除法运算符会产生浮点数结果。
- en: Converting Between Strings and Integers
  id: totrans-394
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串与整数之间的转换
- en: 'We’re ultimately going to have to read the radius and height as input. We’ll
    then use those values to calculate the volume. Let’s give it a try:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 最终我们将不得不读取半径和高度作为输入。然后我们将使用这些值来计算体积。让我们尝试一下：
- en: '>>> r = input()'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> r = input()'
- en: '4'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: '>>> h = input()'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> h = input()'
- en: '6'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: 'The input function always returns a string, even if the user types an integer:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '`input` 函数总是返回一个字符串，即使用户输入的是整数：'
- en: '>>> r'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> r'
- en: '''4'''
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '''4'''
- en: '>>> h'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> h'
- en: '''6'''
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '''6'''
- en: 'The single quotes confirm that these values are strings. Strings cannot be
    used to perform mathematical calculations. If we try, we get an error:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 单引号确认这些值是字符串。字符串不能用于执行数学运算。如果我们尝试，就会得到错误：
- en: '>>> (PI * r ** 2 * h) / 3'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> (π * r ** 2 * h) / 3'
- en: 'Traceback (most recent call last):'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 'Traceback (most recent call last):'
- en: File "<stdin>", line 1, in <module>
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 "<stdin>"，第 1 行，在 <module> 中
- en: 'TypeError: unsupported operand type(s) for ** or pow(): ''str'' and ''int'''
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 'TypeError: 不支持 ** 或 pow() 运算符的操作数类型：''str'' 和 ''int'''
- en: A TypeError is generated when we use values of the wrong type. Python is objecting
    to us using the ** operator on the string referred to by r and the integer 2.
    The ** operator is purely mathematical and has no meaning when used with strings.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用错误类型的值时，会生成 TypeError。Python 不允许我们在 r 字符串和整数 2 之间使用 ** 运算符。** 运算符是纯数学运算符，当与字符串一起使用时没有意义。
- en: 'To convert our strings to integers, we can use Python’s int function:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将我们的字符串转换为整数，我们可以使用 Python 的 `int` 函数：
- en: '>>> r'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> r'
- en: '''4'''
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '''4'''
- en: '>>> h'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> h'
- en: '''6'''
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '''6'''
- en: '>>> r = int(r)'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> r = int(r)'
- en: '>>> h = int(h)'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> h = int(h)'
- en: '>>> r'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> r'
- en: '4'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: '>>> h'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> h'
- en: '6'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: 'Now we can once again use these values in our formula:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以再次使用这些值代入我们的公式：
- en: '>>> (PI * r ** 2 * h) / 3'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> (π * r ** 2 * h) / 3'
- en: '100.53096491487338'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '100.53096491487338'
- en: 'Whenever you have a string whose characters represent an integer, you can use
    the int function to convert it to a value whose type is integer. It can cope with
    leading and trailing spaces, but not non-numeric characters:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你有一个表示整数的字符串时，你可以使用`int`函数将其转换为整数类型的值。它可以处理前后空格，但不能处理非数字字符：
- en: '>>> int(''  12  '')'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> int(''  12  '')'
- en: '12'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '12'
- en: '>>> int(''12x'')'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> int(''12x'')'
- en: 'Traceback (most recent call last):'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 'Traceback (most recent call last):'
- en: File "<stdin>", line 1, in <module>
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 "<stdin>"，第 1 行，在 <module> 中
- en: 'ValueError: invalid literal for int() with base 10: ''12x'''
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 'ValueError: int() 的参数 ''12x'' 不是有效的数字字符串'
- en: 'When converting a string returned by input to an integer, we can take it in
    two steps, first assigning the return value of input to a variable and then converting
    that value to an integer:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 当将 `input` 返回的字符串转换为整数时，我们可以分两步进行，首先将 `input` 的返回值赋给一个变量，然后再将这个值转换为整数：
- en: '>>> num = input()'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> num = input()'
- en: '82'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '82'
- en: '>>> num = int(num)'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> num = int(num)'
- en: '>>> num'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> num'
- en: '82'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '82'
- en: 'Or we can combine the input and int calls:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可以将输入和 `int` 调用结合起来：
- en: '>>> num = int(input())'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> num = int(input())'
- en: '82'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '82'
- en: '>>> num'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> num'
- en: '82'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '82'
- en: Here, the argument passed to int is the string returned by input. The int function
    takes this string and returns it as an integer.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，传递给 `int` 的参数是 `input` 返回的字符串。`int` 函数将这个字符串转换为整数类型的值。
- en: 'If we ever need to convert the other way, from an integer to a string, we can
    do that with the str function:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要将整数转换为字符串，可以使用 `str` 函数：
- en: '>>> num = 82'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> num = 82'
- en: '>>> ''my number is '' + num'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> ''my number is '' + num'
- en: 'Traceback (most recent call last):'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 'Traceback (most recent call last):'
- en: File "<stdin>", line 1, in <module>
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 "<stdin>"，第 1 行，在 <模块> 中
- en: 'TypeError: can only concatenate str (not "int") to str'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 'TypeError: 只能将 str（而不是 "int"）与 str 连接'
- en: '>>> str(num)'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> str(num)'
- en: '''82'''
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '''82'''
- en: '>>> ''my number is '' + str(num)'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> ''我的数字是 '' + str(num)'
- en: '''my number is 82'''
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '''我的数字是 82'''
- en: We can’t concatenate a string and an integer. The str function returns '82'
    from 82 so that it can be used in a string concatenation.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能将字符串和整数连接在一起。`str` 函数将 82 转换为 '82'，这样它就可以用于字符串连接。
- en: Solving the Problem
  id: totrans-455
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题解决
- en: We’re ready to solve Cone Volume. Create a text file called *cone_volume.py*
    and type the code in [Listing 1-2](ch01.xhtml#ch01ex02).
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 我们准备好解决圆锥体积问题了。创建一个名为 *cone_volume.py* 的文本文件，并输入 [列表 1-2](ch01.xhtml#ch01ex02)
    中的代码。
- en: ❶ PI = 3.141592653589793
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ PI = 3.141592653589793
- en: ❷ radius = int(input())
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ radius = int(input())
- en: ❸ height = int(input())
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ height = int(input())
- en: ❹ volume = (PI * radius ** 2 * height) / 3
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ volume = (PI * radius ** 2 * height) / 3
- en: ❺ print(volume)
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ print(volume)
- en: '*Listing 1-2: Solving Cone Volume*'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 1-2：求解圆锥体积*'
- en: I’ve included blank lines to separate the code into its logical pieces. Python
    ignores these blank lines, but such blank lines can make it easier for us to read
    and chunk the code.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 我在代码中添加了空行，将其分为逻辑块。Python 会忽略这些空行，但它们可以让我们更容易阅读和分块代码。
- en: 'Notice that I’ve used descriptive variable names: radius instead of r, height
    instead of h, and volume. Single-letter variable names are the norm in math formulas,
    but when writing code, we can use variable names that convey more information.'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我使用了描述性的变量名：radius 代替 r，height 代替 h，以及 volume。单字母变量名在数学公式中很常见，但在编写代码时，我们可以使用更具描述性的变量名。
- en: We begin by making a variable called PI refer to an approximation of pi ❶. We
    then read the radius ❷ and height ❸ from the input, converting both from strings
    to integers. We use the formula for the volume of a right circular cone to compute
    the volume ❹. Lastly, we output the volume ❺.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义一个变量 PI 来表示 pi 的近似值 ❶。然后我们从输入中读取半径 ❷ 和高度 ❸，将它们从字符串转换为整数。我们使用圆锥体积公式来计算体积
    ❹。最后，输出体积 ❺。
- en: Save your *cone_volume.py* file.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 保存你的 *cone_volume.py* 文件。
- en: Run your program by typing python cone_volume.py and then type a value for the
    radius and a value for the height. Use a calculator to verify that your program
    produces the correct output!
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 通过输入 python cone_volume.py 运行你的程序，然后输入半径和高度的值。使用计算器验证你的程序输出是否正确！
- en: 'What happens if you type garbage for the radius or height? For example, run
    your program and type the following:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你输入无效的半径或高度会发生什么？例如，运行程序并输入以下内容：
- en: xyz
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: xyz
- en: 'You should see an error:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到一个错误：
- en: 'Traceback (most recent call last):'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 最近的调用堆栈（Traceback）：
- en: File "cone_volume.py", line 3, in <module>
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 "cone_volume.py"，第 3 行，在 <模块> 中
- en: radius = int(input())
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: radius = int(input())
- en: 'ValueError: invalid literal for int() with base 10: ''xyz'''
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 'ValueError: int() 的参数无效，不能将 ''xyz'' 转换为整数'
- en: It is not user-friendly at all, that’s for sure. But for purposes of learning
    to program, we won’t worry about this. All of the test cases on the judge will
    be valid according to the problem’s input specification, so we’ll never have to
    worry about what to do with invalid input.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 这肯定不够用户友好。但为了学习编程，我们不需要担心这个问题。裁判上的所有测试用例都会符合问题的输入规范，所以我们不必担心如何处理无效输入。
- en: Speaking of the judge, DMOJ owes us three points, because we’ve finished writing
    correct code for this problem. Go ahead and submit your work!
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 说到裁判，DMOJ 欠我们三分，因为我们已经写好了这道题目的正确代码。继续提交你的代码吧！
- en: Summary
  id: totrans-477
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: And we’re off! We’ve just solved our first two problems by writing Python code.
    We learned about the fundamentals of programming, including values, types, strings,
    integers, methods, variables, the assignment statement, and input and output.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始了！通过编写 Python 代码，我们解决了前两个问题。我们学习了编程的基础，包括值、类型、字符串、整数、方法、变量、赋值语句、输入和输出。
- en: Once you’re comfortable with this material—perhaps by working on some of the
    following exercises—it’s on to [Chapter 2](ch02.xhtml#ch02). There, we’ll learn
    how our programs can make decisions. We’ll no longer be writing programs that
    invariably run from top to bottom. They’ll be more flexible, doing what’s needed
    for the specific problem instance being solved.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你掌握了这部分内容——也许通过做一些接下来的练习——就可以进入 [第 2 章](ch02.xhtml#ch02)。在那里，我们将学习如何让程序做出决策。我们将不再编写单纯从上到下运行的程序。它们将更加灵活，能够根据解决的特定问题实例做出相应的处理。
- en: Chapter Exercises
  id: totrans-480
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 章节练习
- en: Each chapter ends with some exercises for you to try. I encourage you to complete
    as many exercises as you can.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 每一章结尾都有一些习题供你尝试。我鼓励你完成尽可能多的习题。
- en: Some exercises may take you a long time. You might get frustrated with repeated
    Python errors. Like with any skill worth learning, focused practice is needed.
    When you’re starting to work on an exercise, I recommend solving a few examples
    by hand. That way you know what the problem is asking and what your program is
    supposed to do. Otherwise, you might be writing code without a plan, contending
    both with organizing your thoughts and with writing the program at the same time.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 有些习题可能会花费你很多时间。你可能会因为重复的 Python 错误感到沮丧。就像任何值得学习的技能一样，需要专注的练习。当你开始做一个习题时，我建议先手动解决几个例子。这样你就能知道问题的要求是什么，以及你的程序应该做什么。否则，你可能在没有计划的情况下编写代码，同时还要面对组织思路和编写程序的双重挑战。
- en: 'If your code isn’t working, ask: what, precisely, is the behavior that you
    want? What are the lines of code that are likely culprits for the error that you’re
    getting? Is there another, perhaps simpler, approach you could try?'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的代码没有运行，问问自己：你到底想要什么样的行为？哪些代码行可能是导致错误的罪魁祸首？有没有其他可能更简单的方法可以尝试？
- en: I’ve included solutions to the exercises on the book website (*[https://nostarch.com/learn-code-solving-problems/](https://nostarch.com/learn-code-solving-problems/)*).
    But don’t peek at those until you’ve given your chosen exercise an honest try.
    Or two. Or three. If you do look at a solution and learn how one might solve the
    problem, take a break and then try solving it yourself from scratch. There’s often
    more than one way to solve a problem. If your solution does the right thing but
    is different from mine, it doesn’t mean that one of us is wrong. Rather, it serves
    as an opportunity for you to compare your code to mine, perhaps learning alternate
    techniques in the process.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经在书籍网站上提供了习题的解答 (*[https://nostarch.com/learn-code-solving-problems/](https://nostarch.com/learn-code-solving-problems/)*)。但在你没有诚实地尝试过你选择的习题之前，别偷看答案。或许试试两次，三次。如果你确实查看了解答并了解了其中的一种解法，休息一下，然后尝试从头开始自己解决问题。通常解决一个问题的方法不止一种。如果你的解决方案与我的不同，但也能做到正确的事情，这并不意味着我们其中一个错了。相反，这为你提供了一个机会，比较你的代码和我的代码，可能会在这个过程中学到其他的技术。
- en: DMOJ problem wc16c1j1, A Spooky Season
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ 问题 wc16c1j1, 恐怖季节
- en: DMOJ problem wc15c2j1, A New Hope
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ 问题 wc15c2j1, 新希望
- en: DMOJ problem ccc13j1, Next in Line
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ 问题 ccc13j1, 排队中的下一个
- en: DMOJ problem wc17c1j2, How’s the Weather? (Be careful with the direction of
    conversion!)
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ 问题 wc17c1j2, 今天天气怎么样？（小心转换的方向！）
- en: 'DMOJ problem wc18c3j1, An Honest Day’s Work (Hint: how can you determine the
    number of bottle caps and the total paint required by those bottle caps?)'
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ 问题 wc18c3j1, 一个诚实的工作日（提示：你如何确定瓶盖的数量以及这些瓶盖所需的总油漆量？）
- en: Notes
  id: totrans-490
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: Word Count is originally from the DMOPC ’15 April Contest. Cone Volume is originally
    from the DMOPC ’14 March Contest.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: Word Count 原本来自于 DMOPC ’15年4月比赛。Cone Volume 原本来自于 DMOPC ’14年3月比赛。
