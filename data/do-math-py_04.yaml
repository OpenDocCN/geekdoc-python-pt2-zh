- en: '**4**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**4**'
- en: '**Algebra and Symbolic Math with SymPy**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**代数与符号数学与SymPy**'
- en: '![image](images/common-01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/common-01.jpg)'
- en: The mathematical problems and solutions in our programs so far have all involved
    the manipulation of numbers. But there’s another way math is taught, learned,
    and practiced, and that’s in terms of symbols and the operations between them.
    Just think of all the *x*s and *y*s in a typical algebra problem. We refer to
    this type of math as *symbolic math*. I’m sure you remember those dreaded “factorize
    *x*³ + 3*x*² + 3*x* + 1” problems in your math class. Fear no more, for in this
    chapter, we learn how to write programs that can solve such problems and much
    more. To do so, we’ll use *SymPy*—a Python library that lets you write expressions
    containing symbols and perform operations on them. Because this is a third-party
    library, you’ll need to install it before you can use it in your programs. The
    installation instructions are described in [Appendix A](app01.html#app01).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们程序中的数学问题和解决方案都涉及了数字的运算。但是，数学的另一种教学、学习和实践方式是通过符号及其运算。想想看，典型代数问题中那些* x
    *和* y *。我们将这种类型的数学称为*符号数学*。我相信你还记得数学课上那些让人头疼的“因式分解 *x*³ + 3*x*² + 3*x* + 1”问题吧。别害怕，在这一章中，我们将学习如何编写程序来解决这些问题，甚至更多。为此，我们将使用*SymPy*——一个允许你编写包含符号的表达式并对其进行运算的Python库。由于这是一个第三方库，你需要在使用它之前进行安装。安装说明在[附录A](app01.html#app01)中有描述。
- en: '**Defining Symbols and Symbolic Operations**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**定义符号与符号运算**'
- en: '*Symbols* form the building blocks of symbolic math. The term *symbol* is just
    a general name for the *x*s, *y*s, *a*s, and *b*s you use in equations and algebraic
    expressions. Creating and using symbols will let us do things differently than
    before. Consider the following statements:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*符号*是符号数学的构建块。术语*符号*只是一个通用名称，指代你在方程式和代数表达式中使用的*x*、*y*、*a*和*b*。创建和使用符号将使我们以不同的方式进行操作。考虑以下语句：'
- en: '>>> x = 1'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x = 1'
- en: '>>> x + x + 1'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x + x + 1'
- en: '3'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: Here we create a label, x, to refer to the number 1\. Then, when we write the
    statement x + x + 1, it’s evaluated for us, and the result is 3\. What if you
    wanted the result in terms of the symbol *x*? That is, if instead of 3, you wanted
    Python to tell you that the result is 2*x* + 1? You couldn’t just write x + x
    + 1 *without* the statement x = 1 because Python wouldn’t know what x refers to.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个标签x，来表示数字1。然后，当我们写出语句x + x + 1时，它会自动为我们计算，结果是3。假设你希望结果以符号*x*的形式表示呢？也就是说，如果你希望Python告诉你结果是2*x*
    + 1，而不是3呢？你不能仅仅写x + x + 1*而不*声明x = 1，因为Python不知道x指的是什么。
- en: 'SymPy lets us write programs where we can express and evaluate mathematical
    expressions in terms of such symbols. To use a symbol in your program, you have
    to create an object of the Symbol class, like this:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy让我们编写程序，能够用符号来表示和计算数学表达式。要在程序中使用符号，必须像这样创建Symbol类的一个对象：
- en: '>>> from sympy import Symbol'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> from sympy import Symbol'
- en: '>>> x = Symbol(''x'')'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x = Symbol(''x'')'
- en: 'First, we import the Symbol class from the sympy library. Then, we create an
    object of this class passing ''x'' as a parameter. Note that this ''x'' is written
    as a string within quotes. We can now define expressions and equations in terms
    of this symbol. For example, here’s the earlier expression:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从sympy库导入Symbol类。然后，我们创建此类的一个对象，并传递'x'作为参数。注意，这个'x'是作为字符串在引号中写的。现在，我们可以用这个符号来定义表达式和方程式。例如，以下是之前的表达式：
- en: '>>> from sympy import Symbol'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> from sympy import Symbol'
- en: '>>> x = Symbol(''x'')'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x = Symbol(''x'')'
- en: '>>> x + x + 1'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x + x + 1'
- en: 2*x + 1
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 2*x + 1
- en: 'Now the result is given in terms of the symbol *x*. In the statement x = Symbol(''x''),
    the x on the left side is the Python label. This is the same kind of label we’ve
    used before, except this time it refers to the symbol *x* instead of a number—more
    specifically, a Symbol object representing the symbol ''x''. This label doesn’t
    necessarily have to match the symbol either— we could have used a label like a
    or var1 instead. So, it’s perfectly fine to write the preceding statements as
    follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在结果是以符号*x*的形式给出的。在语句x = Symbol('x')中，左边的x是Python的标签。这个标签与我们以前使用的标签相同，只不过这次它表示的是符号*x*，而不是数字——更具体地说，是表示符号'x'的Symbol对象。这个标签不一定非要与符号相匹配——我们也可以使用像a或var1这样的标签。所以，完全可以将前面的语句写成如下：
- en: '>>> a = Symbol(''x'')'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a = Symbol(''x'')'
- en: '>>> a + a + 1'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a + a + 1'
- en: 2*x + 1
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 2*x + 1
- en: Using a non-matching label can be confusing, however, so I would recommend choosing
    a label that’s the same letter as the symbol it refers to.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不匹配的标签可能会导致混淆，因此我建议选择与符号所代表的字母相同的标签。
- en: '**FINDING THE SYMBOL REPRESENTED BY A SYMBOL OBJECT**'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**查找符号对象表示的符号**'
- en: 'For any Symbol object, its name attribute is a string that is the actual symbol
    it represents:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何符号对象，其 name 属性是一个字符串，表示它所代表的实际符号：
- en: '>>> x = Symbol(''x'')'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x = Symbol(''x'')'
- en: '>>> x.name'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x.name'
- en: '''x'''
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '''x'''
- en: '>>> a = Symbol(''x'')'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a = Symbol(''x'')'
- en: '>>> a.name'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a.name'
- en: '''x'''
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '''x'''
- en: You can use .name on a label to retrieve the symbol that it is storing.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 .name 属性来检索标签存储的符号。
- en: Just to be clear, the symbol you create has to be specified as a string. For
    example, you can’t create the symbol *x* using x = Symbol(x)—you must define it
    as x = Symbol('x').
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更清楚地说明，您创建的符号必须作为字符串指定。例如，你不能使用 x = Symbol(x) 来创建符号 *x* ——你必须将其定义为 x = Symbol('x')。
- en: 'To define multiple symbols, you can either create separate Symbol objects or
    use the symbols() function to define them more concisely. Let’s say you wanted
    to use three symbols—*x*, *y*, and *z*—in your program. You could define them
    individually, as we did earlier:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义多个符号，你可以创建单独的 Symbol 对象，或者使用 symbols() 函数更简洁地定义它们。假设你想在程序中使用三个符号——*x*、*y*
    和 *z*——你可以像我们之前那样单独定义它们：
- en: '>>> x = Symbol(''x'')'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x = Symbol(''x'')'
- en: '>>> y = Symbol(''y'')'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> y = Symbol(''y'')'
- en: '>>> z = Symbol(''z'')'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> z = Symbol(''z'')'
- en: 'But a shorter method would be to use the symbols() function to define all three
    at once:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 但有一种更简便的方法，可以使用 symbols() 函数一次性定义所有三个符号：
- en: '>>> from sympy import symbols'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> from sympy import symbols'
- en: '>>> x,y,z = symbols(''x,y,z'')'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x,y,z = symbols(''x,y,z'')'
- en: First, we import the symbols() function from SymPy. Then, we call it with the
    three symbols we want to create, written as a string with commas separating them.
    After this statement is executed, x, y, and z will refer to the three symbols
    'x', 'y', and 'z'.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从 SymPy 导入 symbols() 函数。然后，使用逗号分隔的字符串传递我们要创建的三个符号。执行这条语句后，x、y 和 z 将分别表示符号
    'x'、'y' 和 'z'。
- en: 'Once you’ve defined symbols, you can carry out basic mathematical operations
    on them, using the same operators you learned in [Chapter 1](ch01.html#ch01) (+,
    -, /, *, and **). For example, you might do the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了符号，你就可以使用你在 [第一章](ch01.html#ch01) 中学到的运算符 (+, -, /, *, 和 **) 对其进行基本的数学运算。例如，你可能会这样做：
- en: '>>> from sympy import Symbol'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> from sympy import Symbol'
- en: '>>> x = Symbol(''x'')'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x = Symbol(''x'')'
- en: '>>> y = Symbol(''y'')'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> y = Symbol(''y'')'
- en: '>>> s = x*y + x*y'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s = x*y + x*y'
- en: '>>> s'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s'
- en: 2*x*y
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 2*x*y
- en: 'Let’s see whether we can find the product of x(x + x):'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看能否找到 x(x + x) 的积：
- en: '>>> p = x*(x + x)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> p = x*(x + x)'
- en: '>>> p'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> p'
- en: 2*x**2
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 2*x**2
- en: 'SymPy will automatically make these simple addition and multiplication calculations,
    but if we enter a more complex expression, it will remain unchanged. Let’s see
    what happens when we enter the expression (x + 2)*(x + 3):'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy 会自动进行这些简单的加法和乘法计算，但如果我们输入一个更复杂的表达式，它将保持不变。让我们来看一下当我们输入表达式 (x + 2)*(x +
    3) 时会发生什么：
- en: '>>> p = (x + 2)*(x + 3)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> p = (x + 2)*(x + 3)'
- en: '>>> p'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> p'
- en: (x + 2)*(x + 3)
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: (x + 2)*(x + 3)
- en: You may have expected SymPy to multiply everything out and output x**2 + 5*x
    + 6. Instead, the expression was printed exactly how we entered it. SymPy automatically
    simplifies only the most basic of expressions and leaves it to the programmer
    to explicitly require simplification in cases such as the preceding one. If you
    want to multiply out the expression to get the expanded version, you’ll have to
    use the expand() function, which we’ll see in a moment.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能期待 SymPy 会将所有内容乘开并输出 x**2 + 5*x + 6。但实际上，表达式被打印成我们输入的样子。SymPy 只会自动简化最基础的表达式，并且需要程序员在遇到像前面的情况时显式要求进行简化。如果你想将表达式乘开并得到展开版，你需要使用
    expand() 函数，我们稍后会看到。
- en: '**Working with Expressions**'
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**操作表达式**'
- en: Now that we know how to define our own symbolic expressions, let’s learn more
    about using them in our programs.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道如何定义自己的符号表达式，让我们进一步了解如何在程序中使用它们。
- en: '***Factorizing and Expanding Expressions***'
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***因式分解与展开表达式***'
- en: 'The factor() function decomposes an expression into its factors, and the expand()
    function expands an expression, expressing it as a sum of individual terms. Let’s
    test out these functions with the basic algebraic identity *x*² – *y*² = (*x*
    + *y*)(*x* – *y*). The left side of the identity is the expanded version, and
    the right side depicts the corresponding factorization. Because we have two symbols
    in the identity, we’ll create two Symbol objects:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: factor() 函数将一个表达式分解成因式，而 expand() 函数则展开一个表达式，将其表示为单个项的和。让我们用基本的代数恒等式 *x*² –
    *y*² = (*x* + *y*)(*x* – *y*) 来测试这些函数。恒等式的左侧是展开式，右侧是相应的因式分解。由于该恒等式中有两个符号，我们将创建两个
    Symbol 对象：
- en: '>>> from sympy import Symbol'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> from sympy import Symbol'
- en: '>>> x = Symbol(''x'')'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x = Symbol(''x'')'
- en: '>>> y = Symbol(''y'')'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> y = Symbol(''y'')'
- en: 'Next, we import the factor() function and use it to convert the expanded version
    (on the left side of the identity) to the factored version (on the right side):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们导入 factor() 函数，并使用它将展开式（等式左侧）转换为因式分解后的形式（等式右侧）：
- en: '>>> from sympy import factor'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> from sympy import factor'
- en: '>>> expr = x**2 - y**2'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> expr = x**2 - y**2'
- en: '>>> factor(expr)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> factor(expr)'
- en: (x - y)*(x + y)
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: (x - y)*(x + y)
- en: 'As expected, we get the factored version of the expression. Now let’s expand
    the factors to get back the original expanded version:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，我们得到了该表达式的因式分解形式。现在让我们展开因式，回到原来的展开式：
- en: '>>> factors = factor(expr)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> factors = factor(expr)'
- en: '>>> expand(factors)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> expand(factors)'
- en: x**2 - y**2
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: x**2 - y**2
- en: 'We store the factorized expression in a new label, factors, and then call the
    expand() function with it. When we do this, we receive the original expression
    we started with. Let’s try it with the more complicated identity *x*³ + 3*x*²*y*
    + 3*xy*² + *y*³ = (*x* + *y*)³:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将因式分解后的表达式存储在一个新标签 factors 中，然后使用 expand() 函数调用它。这样，我们就能得到我们开始时的原始表达式。让我们试试更复杂的恒等式
    *x*³ + 3*x*²*y* + 3*xy*² + *y*³ = (*x* + *y*)³：
- en: '>>> expr = x**3 + 3*x**2*y + 3*x*y**2 + y**3'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> expr = x**3 + 3*x**2*y + 3*x*y**2 + y**3'
- en: '>>> factors = factor(expr)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> factors = factor(expr)'
- en: '>>> factors'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> factors'
- en: (x + y)**3
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: (x + y)**3
- en: '>>> expand(factors)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> expand(factors)'
- en: x**3 + 3*x**2*y + 3*x*y**2 + y**3
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: x**3 + 3*x**2*y + 3*x*y**2 + y**3
- en: The factor() function is able to factorize the expression, and then the expand()
    function expands the factorized expression to return to the original expression.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: factor() 函数能够对表达式进行因式分解，然后 expand() 函数展开分解后的表达式，返回原来的表达式。
- en: 'If you try to factorize an expression for which there’s no possible factorization,
    the original expression is returned by the factor() function. For example, see
    the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试对一个没有可能因式分解的表达式进行因式分解，factor() 函数将返回原始表达式。例如，见下例：
- en: '>>> expr = x + y + x*y'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> expr = x + y + x*y'
- en: '>>> factor(expr)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> factor(expr)'
- en: x*y + x + y
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: x*y + x + y
- en: Similarly, if you pass in an expression to expand() that can’t be expanded further,
    it returns the same expression.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，如果你传递一个无法再展开的表达式给 expand()，它将返回相同的表达式。
- en: '***Pretty Printing***'
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***漂亮打印***'
- en: 'If you want the expressions we’ve been working with to look a bit nicer when
    you print them, you can use the pprint() function. This function will print the
    expression in a way that more closely resembles how we’d normally write it on
    paper. For example, here’s an expression:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望我们一直使用的表达式在打印时看起来更漂亮，可以使用 pprint() 函数。这个函数会以一种更接近我们在纸上书写的方式打印表达式。例如，这是一个表达式：
- en: '>>> expr = x*x + 2*x*y + y*y'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> expr = x*x + 2*x*y + y*y'
- en: 'If we print it as we’ve been doing so far or use the print() function, this
    is how it looks:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们像之前那样打印，或者使用 print() 函数，结果将如下所示：
- en: '>>> expr'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> expr'
- en: x**2 + 2*x*y + y**2
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: x**2 + 2*x*y + y**2
- en: 'Now, let’s use the pprint() function to print the preceding expression:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用 pprint() 函数打印前面的表达式：
- en: '>>> from sympy import pprint'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> from sympy import pprint'
- en: '>>> pprint(expr)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> pprint(expr)'
- en: x² + 2·x·y + y²
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: x² + 2·x·y + y²
- en: The expression now looks much cleaner—for example, instead of having a bunch
    of ugly asterisks, exponents appear above the rest of the numbers.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在表达式看起来更简洁了——例如，指数出现在其余数字的上方，而不再是一些难看的星号。
- en: 'You can also change the order of the terms when you print an expression. Consider
    the expression 1 + 2*x* + 2*x*²:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在打印表达式时更改项的顺序。考虑表达式 1 + 2*x* + 2*x*²：
- en: '>>> expr = 1 + 2*x + 2*x**2'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> expr = 1 + 2*x + 2*x**2'
- en: '>>> pprint(expr)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> pprint(expr)'
- en: 2·x² + 2·x + 1
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 2·x² + 2·x + 1
- en: 'The terms are arranged in the order of powers of *x*, from highest to lowest.
    If you want the expression in the opposite order, with the highest power of *x*
    last, you can make that happen with the init_printing() function, as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这些术语按 *x* 的幂次从高到低排列。如果你希望按相反的顺序，即将 *x* 的最高次幂放在最后，可以使用 `init_printing()` 函数来实现，具体如下：
- en: '>>> from sympy import init_printing'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> from sympy import init_printing'
- en: '>>> init_printing(order=''rev-lex'')'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> init_printing(order=''rev-lex'')'
- en: '>>> pprint(expr)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> pprint(expr)'
- en: 1 + 2·x + 2·x²
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 1 + 2·x + 2·x²
- en: The init_printing() function is first imported and called with the keyword argument
    order='rev-lex'. This indicates that we want SymPy to print the expressions so
    that they’re in *reverse lexicographical order*. In this case, the keyword argument
    tells Python to print the lower-power terms first.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 首先导入并调用 init_printing() 函数，并使用关键字参数 order='rev-lex'。这表示我们希望 SymPy 打印表达式时采用 *反向字典顺序*。在这种情况下，关键字参数告诉
    Python 先打印低次项。
- en: '**NOTE**'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Although we used the* init_printing() *function here to set the printed order
    of the expressions, this function can be used in many other ways to configure
    how an expression is printed. For more options and to learn more about printing
    in SymPy, see the documentation at* [http://docs.sympy.org/latest/tutorial/printing.html](http://docs.sympy.org/latest/tutorial/printing.html).'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*虽然我们在这里使用了* init_printing() *函数来设置表达式的打印顺序，但这个函数可以以多种方式配置如何打印表达式。有关更多选项以及了解
    SymPy 打印功能的更多信息，请参阅文档：[http://docs.sympy.org/latest/tutorial/printing.html](http://docs.sympy.org/latest/tutorial/printing.html)。'
- en: Let’s apply what we’ve learned so far to implement a series printing program.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将迄今所学应用到实现一个系列打印程序。
- en: '**Printing a Series**'
  id: totrans-110
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**打印一个级数**'
- en: 'Consider the following series:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下级数：
- en: '![image](images/e0099-01.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/e0099-01.jpg)'
- en: Let’s write a program that will ask a user to input a number, *n*, and print
    this series for that number. In the series, *x* is a symbol and *n* is an integer
    input by the program’s user. The *n*th term in this series is given by
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个程序，要求用户输入一个数字 *n*，并为该数字打印这个级数。在这个级数中，*x* 是一个符号，*n* 是程序用户输入的整数。该级数中的第
    *n* 项由以下公式给出：
- en: '![image](images/e0099-02.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/e0099-02.jpg)'
- en: 'We can print this series using the following program:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下程序打印这个级数：
- en: ''''''''
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ''''''''
- en: 'Print the series:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 打印该级数：
- en: x + x**2 + x**3 + ... + x**n
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: x + x**2 + x**3 + ... + x**n
- en: ____  _____         _____
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ____  _____         _____
- en: 2    3              n
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 2    3              n
- en: ''''''''
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ''''''''
- en: from sympy import Symbol, pprint, init_printing
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: from sympy import Symbol, pprint, init_printing
- en: 'def print_series(n):'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 'def print_series(n):'
- en: '# Initialize printing system with reverse order'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '# 初始化打印系统，采用逆序'
- en: init_printing(order='rev-lex')
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: init_printing(order='rev-lex')
- en: x = Symbol('x')
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: x = Symbol('x')
- en: ➊     series = x
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ➊     series = x
- en: '➋         for i in range(2, n+1):'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '➋         for i in range(2, n+1):'
- en: ➌         series = series + (x**i)/i
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: ➌         series = series + (x**i)/i
- en: pprint(series)
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: pprint(series)
- en: 'if __name__ == ''__main__'':'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: n = input('Enter the number of terms you want in the series: ')
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: n = input('请输入级数项数：')
- en: ➍     print_series(int(n))
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ➍     print_series(int(n))
- en: The print_series() function accepts an integer, n, as a parameter that is the
    number of terms in the series that will be printed. Note that we convert the input
    to an integer using the int() function when calling the function at ➍. We then
    call the init_printing() function to set the series to print in reverse lexicographical
    order.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: print_series() 函数接受一个整数 n 作为参数，表示要打印的级数项数。请注意，在调用函数时，我们使用 int() 函数将输入转换为整数，如
    ➍ 处所示。然后，我们调用 init_printing() 函数设置级数按反向字典顺序打印。
- en: 'At ➊, we create the label, series, and set its initial value as x. Then, we
    define a for loop that will iterate over the integers from 2 to n at ➋. Each time
    the loop iterates, it adds each term to series at ➌, as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们创建标签 series，并将其初始值设为 x。然后，在 ➋ 处定义一个 for 循环，该循环将从 2 到 n 的整数进行迭代。每次迭代时，它将每个项加到
    series 中，如 ➌ 所示：
- en: i = 2, series = x + x**2 / 2
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: i = 2, series = x + x**2 / 2
- en: i = 3, series = x + x**2/2 + x**3/3
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: i = 3, series = x + x**2/2 + x**3/3
- en: --snip--
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: --snip--
- en: The value of series starts off as just plain x, but with each iteration, x**i/i
    gets added to the value of series until the series we want is completed. You can
    see SymPy addition put to good use here. Finally, the pprint() function is used
    to print the series.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: series 的初始值只是简单的 x，但每次迭代时，x**i/i 会被添加到 series 中，直到我们得到所需的级数。你可以在这里看到 SymPy 加法的实际应用。最后，使用
    pprint() 函数打印这个级数。
- en: 'When you run the program, it asks you to input a number and then prints the
    series up to that term:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行程序时，它会要求你输入一个数字，并打印该级数直到该项：
- en: Enter the number of terms you want in the series: 5
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 输入你想要的项数：5
- en: x² x³ x⁴ x⁵
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: x² x³ x⁴ x⁵
- en: x + -- + -- + -- + --
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: x + -- + -- + -- + --
- en: 2    3    4    5
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 2    3    4    5
- en: Try this out with a different number of terms every time. Next, we’ll see how
    to calculate the sum of this series for a certain value of *x*.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 每次尝试时，可以使用不同的项数。接下来，我们将看看如何为某个特定值的*x*计算此级数的和。
- en: '***Substituting in Values***'
  id: totrans-146
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代入值***'
- en: 'Let’s see how we can use SymPy to plug values into an algebraic expression.
    This will let us calculate the value of the expression for certain values of the
    variables. Consider the mathematical expression *x*² + 2*xy* + *y*², which can
    be defined as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用SymPy将值代入代数表达式。这将使我们能够计算特定变量值下的表达式值。考虑数学表达式*x*² + 2*xy* + *y*²，它可以定义如下：
- en: '>>> x = Symbol(''x'')'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x = Symbol(''x'')'
- en: '>>> y = Symbol(''y'')'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> y = Symbol(''y'')'
- en: '>>> x*x + x*y + x*y + y*y'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x*x + x*y + x*y + y*y'
- en: x**2 + 2*x*y + y**2
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: x**2 + 2*x*y + y**2
- en: 'If you want to evaluate this expression, you can substitute numbers in for
    the symbols using the subs() method:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想评估这个表达式，可以使用subs()方法将数字代入符号：
- en: ➊ >>> expr = x*x + x*y + x*y + y*y
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ >>> expr = x*x + x*y + x*y + y*y
- en: '>>> res = expr.subs({x:1, y:2})'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> res = expr.subs({x:1, y:2})'
- en: 'First, we create a new label to refer to the expression at ➊, and then we call
    the subs() method. The argument to the subs() method is a Python *dictionary*,
    which contains the two symbol labels and the numerical values we want to substitute
    in for each symbol. Let’s check out the result:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个新的标签来引用➊处的表达式，然后我们调用subs()方法。subs()方法的参数是一个Python *字典*，其中包含我们要代入的两个符号标签和对应的数值。让我们看看结果：
- en: '>>> res'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> res'
- en: '9'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '9'
- en: 'You can also express one symbol in terms of another and substitute accordingly,
    using the subs() method. For example, if you knew that *x* = 1 – *y*, here’s how
    you could evaluate the preceding expression:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过subs()方法将一个符号表示成另一个符号，并相应地进行代入。例如，如果你知道*x* = 1 – *y*，那么你可以按照如下方式评估前面的表达式：
- en: '>>> expr.subs({x:1-y})'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> expr.subs({x:1-y})'
- en: y**2 + 2*y*(-y + 1) + (-y + 1)**2
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: y**2 + 2*y*(-y + 1) + (-y + 1)**2
- en: '**PYTHON DICTIONARIES**'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**PYTHON字典**'
- en: 'A dictionary is another type of data structure in Python (lists and tuples
    are other examples of data structures, which you’ve seen earlier). Dictionaries
    contain key-value pairs inside curly braces, where each key is matched up with
    a value, separated by a colon. In the preceding code listing, we entered the dictionary
    {x:1, y:2} as an argument to the subs() method. This dictionary has two key-value
    pairs—x:1 and y:2, where x and y are the keys and 1 and 2 are the corresponding
    values. You can retrieve a value from a dictionary by entering its associated
    key in brackets, much as we would retrieve an element from a list using its index.
    For example, here we create a simple dictionary and then retrieve the value corresponding
    to key1:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 字典是Python中的另一种数据结构（列表和元组是你之前见过的其他数据结构的例子）。字典包含键值对，这些键值对被放在花括号中，其中每个键都与一个值匹配，键和值之间用冒号分隔。在上面的代码中，我们将字典{x:1,
    y:2}作为subs()方法的参数。这个字典有两个键值对—x:1和y:2，其中x和y是键，1和2是对应的值。你可以通过在方括号中输入关联的键来从字典中检索值，就像我们通过索引从列表中检索元素一样。例如，这里我们创建一个简单的字典，然后检索与key1对应的值：
- en: '>>> sampledict = {"key1": 5, "key2": 20}'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> sampledict = {"key1": 5, "key2": 20}'
- en: '>>> sampledict["key1"]'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> sampledict["key1"]'
- en: '5'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: To learn more about dictionaries, see [Appendix B](app02.html#app02).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于字典的内容，请参见[附录B](app02.html#app02)。
- en: 'If you want the result to be simplified further—for example, if there are terms
    that cancel each other out, we can use SymPy’s simplify() function, as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望结果进一步简化——例如，如果有项相互抵消，我们可以使用SymPy的simplify()函数，如下所示：
- en: ➊ >>> expr_subs = expr.subs({x:1-y})
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ >>> expr_subs = expr.subs({x:1-y})
- en: '>>> from sympy import simplify'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> from sympy import simplify'
- en: ➋ >>> simplify(expr_subs)
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ >>> simplify(expr_subs)
- en: '1'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: At ➊, we create a new label, expr_subs, to refer to the result of substituting
    *x* = 1 – *y* in the expression. We then import the simplify() function from SymPy
    and call it at ➋. The result turns out to be 1 because the other terms of the
    expression cancel each other.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们创建一个新标签expr_subs，来引用将*x* = 1 – *y*代入表达式后的结果。然后我们从SymPy导入simplify()函数，并在➋处调用它。结果是1，因为表达式中的其他项相互抵消。
- en: Although there was a simplified version of the expression in the preceding example,
    you had to ask SymPy to simplify it using the simplify() function. Once again,
    this is because SymPy won’t do any simplification without being asked to.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在前面的示例中有一个简化版的表达式，但你必须要求 SymPy 使用 simplify() 函数来简化它。再次说明，这是因为 SymPy 不会主动进行任何简化，除非你明确要求。
- en: The simplify() function can also simplify complicated expressions, such as those
    including logarithms and trigonometric functions, but we won’t get into that here.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: simplify() 函数还可以简化复杂的表达式，例如包含对数和三角函数的表达式，但我们在这里不讨论这个。
- en: '**Calculating the Value of a Series**'
  id: totrans-175
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**计算级数的值**'
- en: 'Let’s revisit the series-printing program. In addition to printing the series,
    we want our program to be able to find the value of the series for a particular
    value of *x*. That is, our program will now take two inputs from the user—the
    number of terms in the series and the value of *x* for which the value of the
    series will be calculated. Then, the program will output both the series and the
    sum. The following program extends the series printing program to include these
    enhancements:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新审视这个打印级数的程序。除了打印级数，我们还希望我们的程序能够计算出给定 *x* 值时级数的值。也就是说，程序现在将接受两个用户输入——级数中的项数和计算级数值时的
    *x* 值。然后，程序将输出级数和它的和。以下程序扩展了打印级数程序，加入了这些增强功能：
- en: ''''''''
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ''''''''
- en: 'Print the series:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 打印级数：
- en: x + x**2 + x**3 + ... + x**n
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: x + x**2 + x**3 + ... + x**n
- en: ____  _____         _____
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: ____  _____         _____
- en: 2     3             n
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 2     3             n
- en: ''''''''
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: ''''''''
- en: from sympy import Symbol, pprint, init_printing
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: from sympy import Symbol, pprint, init_printing
- en: 'def print_series(n, x_value):'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 'def print_series(n, x_value):'
- en: '# Initialize printing system with reverse order'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '# 初始化打印系统，使用反向顺序'
- en: init_printing(order='rev-lex')
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: init_printing(order='rev-lex')
- en: x = Symbol('x')
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: x = Symbol('x')
- en: series = x
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: series = x
- en: 'for i in range(2, n+1):'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(2, n+1):'
- en: series = series + (x**i)/i
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: series = series + (x**i)/i
- en: pprint(series)
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: pprint(series)
- en: '# Evaluate the series at x_value'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '# 在 x_value 处评估级数'
- en: ➊     series_value = series.subs({x:x_value})
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: ➊     series_value = series.subs({x:x_value})
- en: print('Value of the series at {0}: {1}'.format(x_value, series_value))
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: print('级数在 {0} 处的值为：{1}'.format(x_value, series_value))
- en: 'if __name__ == ''__main__'':'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: n = input('Enter the number of terms you want in the series: ')
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: n = input('请输入你希望级数中项数的数量：')
- en: ➋     x_value = input('Enter the value of x at which you want to evaluate the series: ')
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ➋     x_value = input('请输入你希望评估级数时x的值：')
- en: print_series(int(n), float(x_value))
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: print_series(int(n), float(x_value))
- en: The print_series() function now takes an additional argument, x_value, which
    is the value of x for which the series should be evaluated. At ➊, we use the subs()
    method to perform the evaluation and the label series_value to refer to the result.
    In the next line, we display the result.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: print_series() 函数现在接受一个额外的参数 x_value，这是你希望评估级数的 x 值。在 ➊ 处，我们使用 subs() 方法执行评估，并使用标签
    series_value 来引用结果。在下一行中，我们显示结果。
- en: The additional input statement at ➋ asks the user to enter the value of x using
    the label x_value to refer to it. Before we call the print_series() function,
    we convert this value into its floating point equivalent using the float() function.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➋ 处的额外输入语句要求用户输入 x 的值，并用标签 x_value 来引用它。在调用 print_series() 函数之前，我们使用 float()
    函数将此值转换为浮动小数。
- en: 'If you execute the program now, it will ask you for the two inputs and print
    out the series and the series value:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在执行这个程序，它将要求你输入这两个值，并打印出级数和级数值：
- en: Enter the number of terms you want in the series: 5
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 请输入你希望级数中项数的数量：5
- en: Enter the value of x at which you want to evaluate the series: 1.2
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 请输入你希望评估级数时x的值：1.2
- en: x² x³ x⁴ x⁵
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: x² x³ x⁴ x⁵
- en: x + -- + -- + -- + --
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: x + -- + -- + -- + --
- en: 2    3    4    5
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 2    3    4    5
- en: Value of the series at 1.2: 3.51206400000000
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在 1.2 处的级数值：3.51206400000000
- en: In this sample run, we ask for five terms in the series, with x set to 1.2,
    and the program prints and evaluates the series.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例运行中，我们要求级数有五项，x 设置为 1.2，程序将打印并计算级数。
- en: '***Converting Strings to Mathematical Expressions***'
  id: totrans-209
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***将字符串转换为数学表达式***'
- en: 'So far, we’ve been writing out individual expressions each time we want to
    do something with them. However, what if you wanted to write a more general program
    that could manipulate any expression provided by the user? For that, we need a
    way to convert a user’s input, which is a string, into something we can perform
    mathematical operations on. SymPy’s sympify() function helps us do exactly that.
    The function is so called because it converts the string into a SymPy object that
    makes it possible to apply SymPy’s functions to the input. Let’s see an example:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们每次想处理表达式时，都在单独编写表达式。但是，如果你想编写一个更通用的程序，能够处理用户提供的任何表达式，该怎么办呢？为此，我们需要一种方法，将用户的输入（一个字符串）转换为我们可以进行数学运算的内容。SymPy的 sympify() 函数正好可以帮我们实现这一点。这个函数之所以这样命名，是因为它将字符串转换为一个 SymPy 对象，从而可以对输入应用 SymPy 的各种函数。我们来看一个例子：
- en: ➊ >>> from sympy import sympify
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ >>> from sympy import sympify
- en: '>>> expr = input(''Enter a mathematical expression: '')'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> expr = input(''输入一个数学表达式：'')'
- en: Enter a mathematical expression: x**2 + 3*x + x**3 + 2*x
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 输入一个数学表达式： x**2 + 3*x + x**3 + 2*x
- en: ➋ >>> expr = sympify(expr)
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ >>> expr = sympify(expr)
- en: We first import the sympify() function at ➊. We then use the input() function
    to ask for a mathematical expression as input, using the label expr to refer to
    it. Next, we call the sympify() function with expr as its argument at ➋ and use
    the same label to refer to the converted expression.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在 ➊ 处导入了 sympify() 函数。然后，我们使用 input() 函数请求输入一个数学表达式，并使用标签 expr 来引用它。接着，我们在 ➋ 处调用 sympify() 函数，将 expr 作为参数，并使用相同的标签来引用转换后的表达式。
- en: 'You can perform various operations on this expression. For example, let’s try
    multiplying the expression by 2:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以对这个表达式进行各种操作。例如，我们尝试将该表达式乘以 2：
- en: '>>> 2*expr'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 2*expr'
- en: 2*x**3 + 2*x**2 + 10*x
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 2*x**3 + 2*x**2 + 10*x
- en: 'What happens when the user supplies an invalid expression? Let’s see:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户输入无效的表达式会发生什么？我们来看看：
- en: '>>> expr = input(''Enter a mathematical expression: '')'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> expr = input(''输入一个数学表达式：'')'
- en: Enter a mathematical expression: x**2 + 3*x + x**3 + 2x
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 输入一个数学表达式： x**2 + 3*x + x**3 + 2x
- en: '>>> expr = sympify(expr)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> expr = sympify(expr)'
- en: 'Traceback (most recent call last):'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 回溯（最近的调用最先显示）：
- en: File "<pyshell#146>", line 1, in <module>
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 "<pyshell#146>"，第 1 行，在 <module>中
- en: expr = sympify(expr)
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: expr = sympify(expr)
- en: File "/usr/lib/python3.3/site-packages/sympy/core/sympify.py", line 180, in sympify
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 "/usr/lib/python3.3/site-packages/sympy/core/sympify.py"，第 180 行，在 sympify
- en: raise SympifyError('could not parse %r' % a)
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: raise SympifyError('无法解析 %r' % a)
- en: sympy.core.sympify.SympifyError: SympifyError: "could not parse 'x**2 + 3*x + x**3 + 2x'"
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: sympy.core.sympify.SympifyError: SympifyError: "无法解析 'x**2 + 3*x + x**3 + 2x'"
- en: 'The last line tells us that sympify() isn’t able to convert the supplied input
    expression. Because this user didn’t add an operator between 2 and x, SymPy doesn’t
    understand what it means. Your program should expect such invalid input and print
    an error message if it comes up. Let’s see how we can do that by catching the
    SympifyError exception:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行告诉我们，sympify() 无法转换提供的输入表达式。因为用户没有在 2 和 x 之间添加运算符，SymPy 无法理解它的含义。你的程序应该能够预料到这种无效输入，并在出现时打印错误信息。我们来看看如何通过捕获 SympifyError 异常来处理这个问题：
- en: '>>> from sympy import sympify'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> from sympy import sympify'
- en: '>>> from sympy.core.sympify import SympifyError'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> from sympy.core.sympify import SympifyError'
- en: '>>> expr = input(''Enter a mathematical expression: '')'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> expr = input(''输入一个数学表达式：'')'
- en: Enter a mathematical expression: x**2 + 3*x + x**3 + 2x
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 输入一个数学表达式： x**2 + 3*x + x**3 + 2x
- en: '>>> try:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> try:'
- en: expr = sympify(expr)
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: expr = sympify(expr)
- en: 'except SympifyError:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 'except SympifyError:'
- en: print('Invalid input')
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: print('无效输入')
- en: Invalid input
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 无效输入
- en: The two changes in the preceding program are that we import the SympifyError
    exception class from the sympy.core.sympify module and call the sympify() function
    in a try...except block. Now if there’s a SympifyError exception, an error message
    is printed.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 上述程序中的两个变化是：我们从 sympy.core.sympify 模块导入了 SympifyError 异常类，并在 try...except 块中调用了 sympify() 函数。现在，如果出现 SympifyError 异常，将会打印错误信息。
- en: '**Expression Multiplier**'
  id: totrans-240
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**表达式乘法器**'
- en: 'Let’s apply the sympify() function to write a program that calculates the product
    of two expressions:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来应用 sympify() 函数，编写一个程序，计算两个表达式的乘积：
- en: ''''''''
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: ''''''''
- en: Product of two expressions
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 两个表达式的乘积
- en: ''''''''
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: ''''''''
- en: from sympy import expand, sympify
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: from sympy import expand, sympify
- en: from sympy.core.sympify import SympifyError
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: from sympy.core.sympify import SympifyError
- en: 'def product(expr1, expr2):'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 'def product(expr1, expr2):'
- en: prod = expand(expr1*expr2)
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: prod = expand(expr1*expr2)
- en: print(prod)
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: print(prod)
- en: 'if __name__==''__main__'':'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 __name__=='__main__'：
- en: ➊     expr1 = input('Enter the first expression: ')
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: ➊     expr1 = input('输入第一个表达式：')
- en: ➋     expr2 = input('Enter the second expression: ')
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: ➋     expr2 = input('输入第二个表达式：')
- en: 'try:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 'try:'
- en: expr1 = sympify(expr1)
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: expr1 = sympify(expr1)
- en: expr2 = sympify(expr2)
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: expr2 = sympify(expr2)
- en: 'except SympifyError:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 'except SympifyError:'
- en: print('Invalid input')
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: print('无效输入')
- en: 'else:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: ➌         product(expr1, expr2)
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: ➌         product(expr1, expr2)
- en: At ➊ and ➋, we ask the user to enter the two expressions. Then, we convert them
    into a form understood by SymPy using the sympify() function in a try...except
    block. If the conversion succeeds (indicated by the else block), we call the product()
    function at ➌. In this function, we calculate the product of the two expressions
    and print it. Note how we use the expand() function to print the product so that
    all its terms are expressed as a sum of its constituent terms.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊和➋处，我们让用户输入两个表达式。然后，使用sympify()函数在try...except块中将它们转换为SymPy可以理解的形式。如果转换成功（由else块指示），我们在➌调用product()函数。在这个函数中，我们计算两个表达式的乘积并打印出来。注意，我们如何使用expand()函数来打印乘积，以便所有的项都以组成项的和的形式表示。
- en: 'Here’s a sample execution of the program:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这是程序的一个示例执行：
- en: Enter the first expression: x**2 + x*2 + x
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 输入第一个表达式：x**2 + x*2 + x
- en: Enter the second expression: x**3 + x*3 + x
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 输入第二个表达式：x**3 + x*3 + x
- en: x**5 + 3*x**4 + 4*x**3 + 12*x**2
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: x**5 + 3*x**4 + 4*x**3 + 12*x**2
- en: 'The last line displays the product of the two expressions. The input can also
    have more than one symbol in any of the expressions:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行显示了两个表达式的乘积。输入中也可以包含多个符号：
- en: Enter the first expression: x*y+x
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 输入第一个表达式：x*y + x
- en: Enter the second expression: x*x+y
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 输入第二个表达式：x*x + y
- en: x**3*y + x**3 + x*y**2 + x*y
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: x**3*y + x**3 + x*y**2 + x*y
- en: '**Solving Equations**'
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**求解方程**'
- en: 'SymPy’s solve() function can be used to find solutions to equations. When you
    input an expression with a symbol representing a variable, such as *x*, solve()
    calculates the value of that symbol. This function always makes its calculation
    by assuming the expression you enter is equal to zero—that is, it prints the value
    that, when substituted for the symbol, makes the entire expression equal zero.
    Let’s start with the simple equation *x* – 5 = 7\. If we want to use solve() to
    find the value of x, we first have to make one side of the equation equal zero
    (*x* – 5 – 7 = 0). Then, we’re ready to use solve(), as follows:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy的solve()函数可以用来求解方程。当你输入一个包含变量符号的表达式，比如*x*，solve()会计算该符号的值。这个函数总是通过假设你输入的表达式等于零来进行计算——也就是说，它返回一个值，当这个值代入符号时，会使整个表达式等于零。我们从简单的方程*x*
    – 5 = 7开始。如果我们想使用solve()来找到x的值，首先要把方程的一边设为零（*x* – 5 – 7 = 0）。然后，我们就可以使用solve()，如下所示：
- en: '>>> from sympy import Symbol, solve'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> from sympy import Symbol, solve'
- en: '>>> x = Symbol(''x'')'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x = Symbol(''x'')'
- en: '>>> expr = x - 5 - 7'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> expr = x - 5 - 7'
- en: '>>> solve(expr)'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> solve(expr)'
- en: '[12]'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '[12]'
- en: When we use solve(), it calculates the value of 'x' as 12 because that’s the
    value that makes the expression (*x* – 5 – 7) equal to zero.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用solve()时，它计算出'x'的值为12，因为这是使得表达式(*x* – 5 – 7)等于零的值。
- en: Note that the result 12 is returned in a list. An equation can have multiple
    solutions—for example, a quadratic equation has two solutions. In that case, the
    list will have all the solutions as its members. You can also ask the solve()
    function to return the result so that each member is dictionary instead. Each
    dictionary is composed of the symbol (variable name) and its value (the solution).
    This is especially useful when solving simultaneous equations where we have more
    than one variable to solve for because when the solution is returned as a dictionary,
    we know which solution corresponds to which variable.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，结果12以列表的形式返回。一个方程可能有多个解——例如，二次方程有两个解。在这种情况下，列表将包含所有解。你还可以要求solve()函数返回结果，以便每个成员都是字典。每个字典由符号（变量名）和它的值（解）组成。这在求解含有多个变量的联立方程时尤其有用，因为当解以字典的形式返回时，我们可以知道哪个解对应哪个变量。
- en: '***Solving Quadratic Equations***'
  id: totrans-278
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***求解二次方程***'
- en: 'In [Chapter 1](ch01.html#ch01), we found the roots of the quadratic equation
    *ax*² + *bx* + *c* = 0 by writing the formulas for the two roots and then substituting
    the values of the constants *a*, *b*, and *c*. Now, we’ll learn how we can use
    SymPy’s solve() function to find the roots without needing to write out the formulas.
    Let’s see an example:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html#ch01)中，我们通过编写两个根的公式并代入常数*a*、*b*、*c*的值，求解了二次方程*ax*² + *bx* +
    *c* = 0。现在，我们将学习如何使用SymPy的solve()函数找到根，而无需编写公式。我们来看一个示例：
- en: ➊ >>> from sympy import solve
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ >>> from sympy import solve
- en: '>>> x = Symbol(''x'')'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x = Symbol(''x'')'
- en: ➋ >>> expr = x**2 + 5*x + 4
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ >>> expr = x**2 + 5*x + 4
- en: ➌ >>> solve(expr, dict=True)
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ >>> solve(expr, dict=True)
- en: ➍ [{x: -4}, {x: -1}]
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ [{x: -4}, {x: -1}]
- en: The solve() function is first imported at ➊. We then define a symbol, x, and
    an expression corresponding to the quadratic equation, x**2 + 5*x + 4, at ➋. Then,
    we call the solve() function with the preceding expression at ➌. The second argument
    to the solve() function (dict=True) specifies that we want the result to be returned
    as a list of Python dictionaries.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: solve() 函数在 ➊ 被首次导入。然后，我们在 ➋ 定义了符号 x 和与二次方程 x**2 + 5*x + 4 对应的表达式。接着，在 ➌ 调用
    solve() 函数来处理前面的表达式。solve() 函数的第二个参数（dict=True）指定我们希望结果以 Python 字典列表的形式返回。
- en: Each solution in the returned list is a dictionary using the symbol as a key
    matched with its corresponding value. If the solution is empty, an empty list
    will be returned. The roots of the preceding equation are –4 and –1, as you can
    see at ➍.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的每个解都以字典的形式呈现，使用符号作为键，并与其对应的值匹配。如果解集为空，将返回一个空列表。前面方程的根为 -4 和 -1，正如你在 ➍ 所看到的。
- en: We found out in the first chapter that the roots of the equation
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第一章中发现，该方程的根为
- en: '*x*² + *x* + 1 = 0'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '*x*² + *x* + 1 = 0'
- en: 'are complex numbers. Let’s attempt to find those using solve():'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这些解是复数。让我们尝试通过 solve() 找出这些解：
- en: '>>> x=Symbol(''x'')'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x=Symbol(''x'')'
- en: '>>> expr = x**2 + x + 1'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> expr = x**2 + x + 1'
- en: '>>> solve(expr, dict=True)'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> solve(expr, dict=True)'
- en: '[{x: -1/2 - sqrt(3)*I/2}, {x: -1/2 + sqrt(3)*I/2}]'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '[{x: -1/2 - sqrt(3)*I/2}, {x: -1/2 + sqrt(3)*I/2}]'
- en: Both the roots are imaginary, as expected with the imaginary component indicated
    by the I symbol.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 两个根都是虚数，正如预期的那样，虚部通过 I 符号表示。
- en: '***Solving for One Variable in Terms of Others***'
  id: totrans-295
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***求解单变量与其他变量的关系***'
- en: 'In addition to finding the roots of equations, we can take advantage of symbolic
    math to use the solve() function to express one variable in an equation in terms
    of the others. Let’s take a look at finding the roots for the generic quadratic
    equation *ax*² + *bx* + *c* = 0\. To do so, we’ll define *x* and three additional
    symbols—*a*, *b*, and *c*, which correspond to the three constants:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 除了找到方程的根，我们还可以利用符号数学，通过 solve() 函数将方程中的一个变量表示为其他变量的函数。让我们来看一下如何解通用的二次方程 *ax*²
    + *bx* + *c* = 0 的根。为此，我们将定义 *x* 和三个额外的符号——*a*、*b* 和 *c*，它们分别对应三个常数：
- en: '>>> x = Symbol(''x'')'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x = Symbol(''x'')'
- en: '>>> a = Symbol(''a'')'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a = Symbol(''a'')'
- en: '>>> b = Symbol(''b'')'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> b = Symbol(''b'')'
- en: '>>> c = Symbol(''c'')'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> c = Symbol(''c'')'
- en: 'Next, we write the expression corresponding to the equation and use the solve()
    function on it:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们写出对应方程的表达式，并对其使用 solve() 函数：
- en: '>>> expr = a*x*x + b*x + c'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> expr = a*x*x + b*x + c'
- en: '>>> solve(expr, x, dict=True)'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> solve(expr, x, dict=True)'
- en: '[{x: (-b + sqrt(-4*a*c + b**2))/(2*a)}, {x: -(b + sqrt(-4*a*c + b**2))/(2*a)}]'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '[{x: (-b + sqrt(-4*a*c + b**2))/(2*a)}, {x: -(b + sqrt(-4*a*c + b**2))/(2*a)}]'
- en: 'Here, we have to include an additional argument, x, to the solve() function.
    Because there’s more than one symbol in the equation, we need to tell solve()
    which symbol it should solve for, which is what we indicate by passing in x as
    the second argument. As we’d expect, solve() prints the quadratic formula: the
    generic formula for finding the value(s) of *x* in a polynomial expression.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们需要向 solve() 函数传入一个额外的参数 x。由于方程中有多个符号，我们需要告诉 solve() 应该解哪个符号，这就是我们通过将 x
    作为第二个参数传入来指定的。正如我们预期的那样，solve() 输出了二次方程的解：寻找多项式表达式中 *x* 值的通用公式。
- en: To be clear, when we use solve() on an equation with more than one symbol, we
    specify the symbol to solve for as the second argument (and now the third argument
    specifies how we want the results to be returned).
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 为了明确，当我们对一个包含多个符号的方程使用 solve() 时，我们需要将要解的符号作为第二个参数指定（现在第三个参数则指定了结果返回的形式）。
- en: Next, let’s consider an example from physics. According to one of the equations
    of motion, the distance traveled by a body moving with a constant acceleration
    *a*, with an initial velocity *u*, in time *t*, is given by
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看一个物理学中的例子。根据运动方程之一，一个物体在恒定加速度 *a* 下，从初速度 *u* 开始，经过时间 *t* 后所行进的距离 *s*
    由以下公式给出：
- en: '![image](images/e0107-01.jpg)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/e0107-01.jpg)'
- en: 'Given *u* and *a*, however, if you wanted to find the time required to travel
    a given distance, *s*, you’d have to first express *t* in terms of the other variables.
    Here’s how you could do that using SymPy’s solve() function:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 给定 *u* 和 *a*，然而，如果你想要找出完成某个特定距离 *s* 所需的时间 *t*，你必须先将 *t* 表示为其他变量的函数。你可以使用 SymPy
    的 solve() 函数来实现这一点：
- en: '>>> from sympy import Symbol, solve, pprint'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> from sympy import Symbol, solve, pprint'
- en: '>>> s = Symbol(''s'')'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s = Symbol(''s'')'
- en: '>>> u = Symbol(''u'')'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> u = Symbol(''u'')'
- en: '>>> t = Symbol(''t'')'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> t = Symbol(''t'')'
- en: '>>> a = Symbol(''a'')'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a = Symbol(''a'')'
- en: '>>> expr = u*t + (1/2)*a*t*t - s'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> expr = u*t + (1/2)*a*t*t - s'
- en: '>>> t_expr = solve(expr,t, dict=True)'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> t_expr = solve(expr,t, dict=True)'
- en: '>>> pprint(t_expr)'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> pprint(t_expr)'
- en: 'The result looks like this:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下所示：
- en: '![image](images/f0107-01.jpg)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f0107-01.jpg)'
- en: Now that we have the expression for *t* (referred to by the label t_expr), we
    can use the subs() method to replace the values of *s*, *u*, and *a* to find the
    two possible values of *t*.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了 *t* 的表达式（用标签 t_expr 表示），我们可以使用 subs() 方法来替换 *s*、*u* 和 *a* 的值，从而找到 *t*
    的两个可能值。
- en: '***Solving a System of Linear Equations***'
  id: totrans-321
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***求解线性方程组***'
- en: 'Consider the following two equations:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下两个方程：
- en: 2*x* + 3*y* = 6
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 2*x* + 3*y* = 6
- en: 3*x* + 2*y* = 12
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 3*x* + 2*y* = 12
- en: Say we want to find the pair of values (*x*, *y*) that satisfies both the equations.
    We can use the solve() function to find the solution for a system of equations
    like this one.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要找到满足两个方程的值对 (*x*, *y*)。我们可以使用 solve() 函数来求解这样的方程组。
- en: 'First, we define the two symbols and create the two equations:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义这两个符号并创建两个方程：
- en: '>>> x = Symbol(''x'')'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x = Symbol(''x'')'
- en: '>>> y = Symbol(''y'')'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> y = Symbol(''y'')'
- en: '>>> expr1 = 2*x + 3*y - 6'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> expr1 = 2*x + 3*y - 6'
- en: '>>> expr2 = 3*x + 2*y – 12'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> expr2 = 3*x + 2*y – 12'
- en: 'The two equations are defined by the expressions expr1 and expr2, respectively.
    Note how we’ve rearranged the expressions so they both equal zero (we moved the
    right side of the given equations to the left side). To find the solution, we
    call the solve() function with the two expressions forming a tuple:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个方程由表达式 expr1 和 expr2 定义。注意我们如何将表达式重新排列，使它们都等于零（我们将给定方程的右侧移到了左侧）。为了找到解，我们调用
    solve() 函数，传入这两个组成元组的表达式：
- en: '>>> solve((expr1, expr2), dict=True)'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> solve((expr1, expr2), dict=True)'
- en: '[{y: -6/5, x: 24/5}]'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '[{y: -6/5, x: 24/5}]'
- en: 'As I mentioned earlier, getting the solution back as a dictionary is useful
    here. We can see that the value of x is 24/5 and the value of y is –6/5\. Let’s
    verify whether the solution we got really satisfies the equations. To do so, we’ll
    first create a label, soln, to refer to the solution we got and then use the subs()
    method to substitute the corresponding values of x and y in the two expressions:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，将解返回为字典格式在这里非常有用。我们可以看到 x 的值为 24/5，y 的值为 –6/5。让我们验证一下我们得到的解是否真正满足这两个方程。为此，我们首先创建一个标签
    soln 来引用我们得到的解，然后使用 subs() 方法将 x 和 y 对应的值代入这两个表达式：
- en: '>>> soln = solve((expr1, expr2), dict=True)'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> soln = solve((expr1, expr2), dict=True)'
- en: '>>> soln = soln[0]'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> soln = soln[0]'
- en: '>>> expr1.subs({x:soln[x], y:soln[y]})'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> expr1.subs({x:soln[x], y:soln[y]})'
- en: '0'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '>>> expr2.subs({x:soln[x], y:soln[y]})'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> expr2.subs({x:soln[x], y:soln[y]})'
- en: '0'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: The result of substituting the values of x and y corresponding to the solution
    in the two expressions is zero.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 将解对应的 x 和 y 值代入两个表达式后的结果为零。
- en: '**Plotting Using SymPy**'
  id: totrans-342
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用SymPy绘制图表**'
- en: 'In [Chapter 2](ch02.html#ch02), we learned to make graphs where we explicitly
    specified the numbers we wanted to plot. For example, to plot the graph of the
    gravitational force against the distance between two bodies, you had to calculate
    the gravitational force for each distance value and supply the lists of distances
    and forces to matplotlib. With SymPy, on the other hand, you can just tell SymPy
    the equation of the line you want to plot, and the graph will be created for you.
    Let’s plot a line whose equation is given by *y* = 2*x* + 3:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html#ch02)中，我们学习了如何绘制图表，其中我们显式指定了要绘制的数字。例如，要绘制重力与两物体之间距离的图表，你需要为每个距离值计算重力，并将距离和重力的列表传递给matplotlib。而使用SymPy时，你只需要告诉SymPy你想绘制的方程式，图表就会自动生成。让我们绘制一个方程为
    *y* = 2*x* + 3 的直线：
- en: '>>> from sympy.plotting import plot'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> from sympy.plotting import plot'
- en: '>>> from sympy import Symbol'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> from sympy import Symbol'
- en: '>>> x = Symbol(''x'')'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x = Symbol(''x'')'
- en: '>>> plot(2*x+3)'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> plot(2*x+3)'
- en: All we had to do was import plot and Symbol from sympy.plotting, create a symbol,
    x, and call the plot() function with the expression 2*x+3. SymPy takes care of
    everything else and plots the graph of the function, as shown in [Figure 4-1](ch04.html#ch4fig1).
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所需要做的只是从 sympy.plotting 中导入 plot 和 Symbol，创建一个符号 x，然后调用 plot() 函数并传入表达式 2*x+3。SymPy
    会处理其他所有事项，并绘制出该函数的图表，如[图4-1](ch04.html#ch4fig1)所示。
- en: '![image](images/f04-01.jpg)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f04-01.jpg)'
- en: '*Figure 4-1: Plot of the line* y = *2*x + *3*'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-1：y = 2*x + 3 的直线图*'
- en: 'The graph shows that a default range of *x* values was automatically chosen:
    –10 to 10\. You may notice that the graph window looks very similar to those you
    saw in [Chapters 2](ch02.html#ch02) and [3](ch03.html#ch03). That’s because SymPy
    uses matplotlib behind the scenes to draw the graphs. Also note that we didn’t
    have to call the show() function to show the graphs because this is done automatically
    by SymPy.'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 图表显示了一个默认范围的*x*值被自动选择：–10到10。你可能会注意到，图表窗口看起来和你在[第二章](ch02.html#ch02)和[第三章](ch03.html#ch03)中看到的非常相似。这是因为SymPy在后台使用matplotlib来绘制图表。还要注意，我们不需要调用show()函数来显示图表，因为SymPy会自动完成这项操作。
- en: 'Now, let’s say that you wanted to limit the values of ''x'' in the preceding
    graph to lie in the range –5 to 5 (instead of –10 to 10). You’d do that as follows:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设你想将前面图表中'x'的值限制在–5到5的范围内（而不是–10到10）。你可以按如下方式操作：
- en: '>>> plot((2*x + 3), (x, -5, 5))'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> plot((2*x + 3), (x, -5, 5))'
- en: Here, a tuple consisting of the symbol, the lower bound, and the upper bound
    of the range—(x, -5, 5)—is specified as the second argument to the plot() function.
    Now, the graph displays only the values of *y* corresponding to the values of
    *x* between –5 and 5 (see [Figure 4-2](ch04.html#ch4fig2)).
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，作为plot()函数第二个参数的一个元组，指定了符号、下界和上界范围——(x, -5, 5)。现在，图表仅显示在–5到5之间的*x*值对应的*y*值（参见[图
    4-2](ch04.html#ch4fig2)）。
- en: '![image](images/f04-02.jpg)'
  id: totrans-355
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f04-02.jpg)'
- en: '*Figure 4-2: Plot of the line* y = *2*x + *3 with the values of* x *restricted
    to the range –5 to 5*'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-2：绘制的直线* y = *2*x + *3，*x*的值限制在–5到5的范围内*'
- en: 'You can use other keyword arguments in the plot() function, such as title to
    enter a title or xlabel and ylabel to label the *x*-axis and the *y*-axis, respectively.
    The following plot() function specifies the preceding three keyword arguments
    (see the corresponding graph in [Figure 4-3](ch04.html#ch4fig3)):'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在plot()函数中使用其他关键字参数，例如title来输入标题，xlabel和ylabel分别用于标记*x*-轴和*y*-轴。以下plot()函数指定了前面提到的三个关键字参数（参见[图
    4-3](ch04.html#ch4fig3)中的相应图表）：
- en: '>>> plot(2*x + 3, (x, -5, 5), title=''A Line'', xlabel=''x'', ylabel=''2x+3'')'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> plot(2*x + 3, (x, -5, 5), title=''一条直线'', xlabel=''x'', ylabel=''2x+3'')'
- en: '![image](images/f04-03.jpg)'
  id: totrans-359
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f04-03.jpg)'
- en: '*Figure 4-3: Plot of the line* y = *2*x + *3 with the range of* x *and other
    attributes specified*'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-3：绘制的直线* y = *2*x + *3，*x*的范围和其他属性已指定*'
- en: 'The plot shown in [Figure 4-3](ch04.html#ch4fig3) now has a title and labels
    on the *x*-axis and the *y*-axis. You can specify a number of other keyword arguments
    to the plot() function to customize the behavior of the function as well as the
    graph itself. The show keyword argument allows us to specify whether we want the
    graph to be displayed. Passing show=False will cause the graph to not be displayed
    when you call the plot() function:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 4-3](ch04.html#ch4fig3)中显示的图表现在有了标题和*x*-轴以及*y*-轴的标签。你可以为plot()函数指定其他许多关键字参数，以自定义函数的行为以及图表本身的样式。show关键字参数允许我们指定是否显示图表。传递show=False会使图表在调用plot()函数时不显示：
- en: '>>> p = plot(2*x + 3, (x, -5, 5), title=''A Line'', xlabel=''x'', ylabel=''2x+3'', show=False)'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> p = plot(2*x + 3, (x, -5, 5), title=''一条直线'', xlabel=''x'', ylabel=''2x+3'',
    show=False)'
- en: 'You will see that no graph is shown. The label p refers to the plot that is
    created, so you can now call p.show() to display the graph. You can also save
    the graph as an image file using the save() method, as follows:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到没有图表显示。标签p指的是创建的图表，所以你可以现在调用p.show()来显示图表。你还可以使用save()方法将图表保存为图像文件，方法如下：
- en: '>>> p.save(''line.png'')'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> p.save(''line.png'')'
- en: This will save the plot to a file *line.png* in the current directory.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把图表保存为当前目录下的文件*line.png*。
- en: '***Plotting Expressions Input by the User***'
  id: totrans-366
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***用户输入的表达式绘图***'
- en: 'The expression that you pass to the plot() function must be expressed in terms
    of *x* only. For example, earlier we plotted *y* = 2*x* + 3, which we entered
    to the plot function as simply 2*x* + 3\. If the expression were not originally
    in this form, we’d have to rewrite it. Of course, we could do this manually, outside
    the program. But what if you want to write a program that allows its users to
    graph any expression? If the user enters an expression in the form of 2*x* + 3*y*
    – 6, say, we have to first convert it. The solve() function will help us here.
    Let’s see an example:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 你传递给plot()函数的表达式必须仅以*x*表示。例如，之前我们绘制了*y* = 2*x* + 3，我们将其作为2*x* + 3直接传入plot函数。如果表达式不是这种形式，我们就需要重新写它。当然，我们可以在程序外手动完成这一步。但如果你想编写一个程序，允许用户绘制任何表达式的图形呢？比如用户输入的表达式是2*x*
    + 3*y* - 6，我们就需要首先转换它。solve()函数将在这里帮助我们。来看一个例子：
- en: '>>> expr = input(''Enter an expression: '')'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> expr = input(''请输入一个表达式: '')'
- en: Enter an expression: 2*x + 3*y - 6
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '请输入一个表达式: 2*x + 3*y - 6'
- en: ➊ >>> expr = sympify(expr)
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ >>> expr = sympify(expr)
- en: ➋ >>> y = Symbol('y')
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ >>> y = Symbol('y')
- en: '>>> solve(expr, y)'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> solve(expr, y)'
- en: ➌ [-2*x/3 + 2]
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ [-2*x/3 + 2]
- en: At ➊, we use the sympify() function to convert the input expression to a SymPy
    object. At ➋, we create a Symbol object to represent 'y' so that we can tell SymPy
    which variable we want to solve the equation for. Then we solve the expression
    to find y in terms of x by specifying y as the second argument to the solve()
    function. At ➌, this returns the equation in terms of x, which is what we need
    for plotting.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊，我们使用sympify()函数将输入的表达式转换为SymPy对象。在➋，我们创建一个Symbol对象来表示‘y’，这样我们就可以告诉SymPy我们希望为哪个变量求解方程。然后，我们通过将‘y’作为第二个参数传递给solve()函数，求解表达式以找出y关于x的表达式。在➌，这会返回以x为变量的方程，这是我们绘图所需要的形式。
- en: 'Notice that this final expression is stored in a list, so before we can use
    it, we’ll have to extract it from the list:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个最终的表达式被存储在一个列表中，因此在使用之前，我们需要从列表中提取它：
- en: '>>> solutions = solve(expr, ''y'')'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> solutions = solve(expr, ''y'')'
- en: ➍ >>> expr_y = solutions[0]
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ >>> expr_y = solutions[0]
- en: '>>> expr_y'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> expr_y'
- en: -2*x/3 + 2
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: -2*x/3 + 2
- en: 'We create a label, solutions, to refer to the result returned by the solve()
    function, which is a list with only one item. Then, we extract that item at ➍.
    Now, we can call the plot() function to graph the expression. The next listing
    shows a full graph-drawing program:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个标签solutions来引用solve()函数返回的结果，它是一个只有一个项的列表。然后，我们在➔提取这个项。现在，我们可以调用plot()函数来绘制这个表达式的图形。下面的代码展示了一个完整的绘图程序：
- en: ''''''''
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: ''''''''
- en: Plot the graph of an input expression
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制输入表达式的图形
- en: ''''''''
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: ''''''''
- en: from sympy import Symbol, sympify, solve
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: from sympy import Symbol, sympify, solve
- en: from sympy.plotting import plot
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: from sympy.plotting import plot
- en: 'def plot_expression(expr):'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 'def plot_expression(expr):'
- en: y = Symbol('y')
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: y = Symbol('y')
- en: solutions = solve(expr, y)
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: solutions = solve(expr, y)
- en: expr_y = solutions[0]
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: expr_y = solutions[0]
- en: plot(expr_y)
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: plot(expr_y)
- en: 'if __name__==''__main__'':'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__==''__main__'':'
- en: expr = input('Enter your expression in terms of x and y: ')
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 'expr = input(''请输入你的表达式，包含x和y: '')'
- en: 'try:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 'try:'
- en: expr = sympify(expr)
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: expr = sympify(expr)
- en: 'except SympifyError:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 'except SympifyError:'
- en: print('Invalid input')
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: print('无效输入')
- en: 'else:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: plot_expression(expr)
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: plot_expression(expr)
- en: Note that the preceding program includes a try...except block to check for invalid
    input, as we’ve done with sympify() earlier. When you run the program, it asks
    you to input an expression, and it will create the corresponding graph.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前面的程序包含了一个try...except块，用来检查无效输入，就像我们之前对sympify()的处理一样。当你运行程序时，它会要求你输入一个表达式，然后创建相应的图形。
- en: '***Plotting Multiple Functions***'
  id: totrans-400
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***绘制多条函数图像***'
- en: 'You can enter multiple expressions when calling the SymPy plot function to
    plot more than one expression on the same graph. For example, the following code
    plots two lines at once (see [Figure 4-4](ch04.html#ch4fig4)):'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在调用SymPy的绘图函数时输入多个表达式，这样可以在同一图上绘制多个表达式。例如，下面的代码一次性绘制两条直线（参见[图4-4](ch04.html#ch4fig4)）：
- en: '>>> from sympy.plotting import plot'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> from sympy.plotting import plot'
- en: '>>> from sympy import Symbol'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> from sympy import Symbol'
- en: '>>> x = Symbol(''x'')'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x = Symbol(''x'')'
- en: '>>> plot(2*x+3, 3*x+1)'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> plot(2*x+3, 3*x+1)'
- en: '![image](images/f04-04.jpg)'
  id: totrans-406
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f04-04.jpg)'
- en: '*Figure 4-4: Plotting two lines on the same graph*'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-4：在同一图上绘制两条直线*'
- en: 'This example brings out another difference between plotting in matplotlib and
    in SymPy. Here, using SymPy, both lines are the same color, whereas matplotlib
    would have automatically made the lines different colors. To set different colors
    for each line with SymPy, we’ll need to perform some extra steps, as shown in
    the following code, which also adds a legend to the graph:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例展示了在 matplotlib 和 SymPy 中绘图的另一个区别。在 SymPy 中，两个线条是相同的颜色，而在 matplotlib 中，系统会自动将线条设置为不同的颜色。要在
    SymPy 中为每条线设置不同的颜色，我们需要执行一些额外的步骤，如以下代码所示，它还为图形添加了图例：
- en: '>>> from sympy.plotting import plot'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> from sympy.plotting import plot'
- en: '>>> from sympy import Symbol'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> from sympy import Symbol'
- en: '>>> x = Symbol(''x'')'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x = Symbol(''x'')'
- en: ➊ >>> p = plot(2*x+3, 3*x+1, legend=True, show=False)
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ >>> p = plot(2*x+3, 3*x+1, legend=True, show=False)
- en: ➋ >>> p[0].line_color = 'b'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ >>> p[0].line_color = 'b'
- en: ➌ >>> p[1].line_color = 'r'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ >>> p[1].line_color = 'r'
- en: '>>> p.show()'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> p.show()'
- en: At ➊, we call the plot() function with the equations for the two lines but pass
    two additional keyword arguments—legend and show. By setting the legend argument
    to True, we add a legend to the graph, as we saw in [Chapter 2](ch02.html#ch02).
    Note, however, that the text that appears in the legend will match the expressions
    you plotted—you can’t specify any other text. We also set show=False because we
    want to set the color of the lines before we draw the graph. The statement at
    ➋, p[0], refers to the first line, 2*x* + 3, and we set its attribute line_color
    to 'b', meaning that we want this line to be blue. Similarly, we set the color
    of the second plot to red using the string 'r' ➌. Finally, we call the show()
    to display the graph (see [Figure 4-5](ch04.html#ch4fig5)).
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们调用了 plot() 函数并传入了两个线条的方程，同时传递了两个额外的关键字参数——legend 和 show。通过将 legend 参数设置为
    True，我们向图形添加了图例，如我们在[第2章](ch02.html#ch02)中看到的那样。不过需要注意，图例中显示的文本将与您绘制的表达式一致，您不能指定其他文本。我们还将
    show=False，因为我们希望在绘制图形之前设置线条的颜色。在 ➋ 处，p[0] 指的是第一条线 2*x* + 3，并将其属性 line_color 设置为
    'b'，这意味着我们希望该线条为蓝色。同样，我们使用字符串 'r' 将第二条线的颜色设置为红色 ➌。最后，我们调用 show() 来显示图形（见[图 4-5](ch04.html#ch4fig5)）。
- en: '![image](images/f04-05.jpg)'
  id: totrans-417
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f04-05.jpg)'
- en: '*Figure 4-5: Plot of the two lines with each line drawn in a different color*'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-5: 两条线的图形，每条线的颜色不同*'
- en: In addition to red and blue, you can plot the lines in green, cyan, magenta,
    yellow, black, and white (using the first letter of the color in each case).
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 除了红色和蓝色，你还可以将线条绘制为绿色、青色、品红色、黄色、黑色和白色（在每种情况下使用颜色的首字母）。
- en: '**What You Learned**'
  id: totrans-420
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned the basics of symbolic math using SymPy. You learned
    about declaring symbols, constructing expressions using symbols and mathematical
    operators, solving equations, and plotting graphs. You will be learning more features
    of SymPy in later chapters.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学习了使用 SymPy 进行符号计算的基础知识。你了解了如何声明符号，使用符号和数学运算符构造表达式，求解方程，以及绘制图形。在后续的章节中，你将学习更多
    SymPy 的功能。
- en: '**Programming Challenges**'
  id: totrans-422
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**编程挑战**'
- en: Here are a few programming challenges that should help you further apply what
    you’ve learned. You can find sample solutions at *[http://www.nostarch.com/doingmathwithpython/](http://www.nostarch.com/doingmathwithpython/)*.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些编程挑战，帮助你进一步应用所学的内容。你可以在 *[http://www.nostarch.com/doingmathwithpython/](http://www.nostarch.com/doingmathwithpython/)*
    找到示例解答。
- en: '***#1: Factor Finder***'
  id: totrans-424
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***#1: 因数查找器***'
- en: You learned about the factor() function, which prints the factors of an expression.
    Now that you know how your program can handle expressions input by a user, write
    a program that will ask the user to input an expression, calculate its factors,
    and print them. Your program should be able to handle invalid input by making
    use of exception handling.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 你学习了 factor() 函数，它可以打印一个表达式的因数。现在你知道了如何处理用户输入的表达式，编写一个程序，要求用户输入一个表达式，计算其因数并打印出来。你的程序应该能够通过异常处理来应对无效输入。
- en: '***#2: Graphical Equation Solver***'
  id: totrans-426
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***#2: 图形方程求解器***'
- en: 'Earlier, you learned how to write a program that prompts the user to input
    an expression such as 3*x* + 2*y* – 6 and create the corresponding graph. Write
    a program that asks the user for two expressions and then graphs them both, as
    follows:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，你学习了如何编写一个程序，提示用户输入一个表达式，例如 3*x* + 2*y* – 6，并创建相应的图形。编写一个程序，要求用户输入两个表达式，然后将它们都绘制出来，如下所示：
- en: '>>> expr1 = input(''Enter your first expression in terms of x and y: '')'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> expr1 = input(''请输入第一个关于 x 和 y 的表达式：'')'
- en: '>>> expr2 = input(''Enter your second expression in terms of x and y: '')'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> expr2 = input(''请输入第二个关于 x 和 y 的表达式：'')'
- en: Now, expr1 and expr2 will store the two expressions input by the user. You should
    convert both of these into SymPy objects using the sympify() step in a try...except
    block.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，expr1 和 expr2 将存储用户输入的两个表达式。你应该使用 sympify() 步骤将这两个表达式转换为 SymPy 对象，并放入 try...except
    块中。
- en: All you need to do from here is plot these two expressions instead of one.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里开始，你只需要绘制这两个表达式，而不是一个。
- en: 'Once you’ve completed this, enhance your program to print the solution—the
    pair of *x* and *y* values that satisfies both equations. This will also be the
    spot where the two lines on the graph intersect. (Hint: Refer to how we used the
    solve() function earlier to find the solution of a system of two linear equations.)'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此步骤后，增强你的程序，使其打印解决方案——即满足两个方程的 *x* 和 *y* 值。这也将是图上两条线交点的位置。（提示：参考我们之前如何使用 solve()
    函数来求解一组线性方程组的解。）
- en: '***#3: Summing a Series***'
  id: totrans-433
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***#3: 求和一个序列***'
- en: 'We saw how to find the sum of a series in “[Printing a Series](ch04.html#ch04lev3sec01)”
    on [page 99](ch04.html#page_99). There, we manually added the terms of the series
    by looping over all the terms. Here’s a snippet from that program:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 “[打印序列](ch04.html#ch04lev3sec01)” 中看到了如何求解序列的和，在 [第 99 页](ch04.html#page_99)。在那里，我们通过遍历所有项手动添加了序列的项。以下是该程序的一个片段：
- en: 'for i in range(2, n+1):'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(2, n + 1):'
- en: series = series + (x**i)/i
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: series = series + (x ** i) / i
- en: 'SymPy’s summation() function can be directly used to find such summations.
    The following example prints the sum of the first five terms of the series we
    considered earlier:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy 的 summation() 函数可以直接用于求解此类求和。以下示例打印了我们之前考虑的序列的前五项的和：
- en: '>>> from sympy import Symbol, summation, pprint'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> from sympy import Symbol, summation, pprint'
- en: '>>> x = Symbol(''x'')'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x = Symbol(''x'')'
- en: '>>> n = Symbol(''n'')'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> n = Symbol(''n'')'
- en: ➊ >>> s = summation(x**n/n, (n, 1, 5))
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ >>> s = summation(x ** n / n, (n, 1, 5))
- en: '>>> pprint(s)'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> pprint(s)'
- en: x⁵   x⁴   x³   x²
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: x⁵   x⁴   x³   x²
- en: -- + -- + -- + -- + x
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: --  +  --  +  --  +  --  + x
- en: 5     4   3     2
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 5     4   3     2
- en: We call the summation() function at ➊, with the first argument being the *n*th
    term of the series and the second argument being a tuple that states the range
    of *n*. We want the sum of the first five terms here, so the second argument is
    (n, 1, 5).
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 ➊ 调用了 summation() 函数，第一个参数是序列的 *n* 项，第二个参数是一个元组，表示 *n* 的范围。我们这里要求的是前五项的和，因此第二个参数是
    (n, 1, 5)。
- en: 'Once you have the sum, you can use the subs() method to substitute a value
    for *x* to find the numerical value of the sum:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你得到了和，你可以使用 subs() 方法为 *x* 替换一个值，来找到和的数值：
- en: '>>> s.subs({x:1.2})'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s.subs({x: 1.2})'
- en: '3.51206400000000'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '3.51206400000000'
- en: 'Your challenge is to write a program that’s capable of finding the sum of an
    arbitrary series when you supply the *n*th term of the series and the number of
    terms in it. Here’s an example of how the program would work:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 你的挑战是编写一个程序，能够在你提供系列的 *n* 项和项数时，找到一个任意系列的和。以下是程序如何工作的示例：
- en: Enter the nth term: a+(n-1)*d
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 输入第 n 项：a + (n - 1) * d
- en: Enter the number of terms: 3
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 输入项数：3
- en: 3·a + 3·d
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 3·a + 3·d
- en: In this example, the *n*th term supplied is that of an *arithmetic progression*.
    Starting with a and d as the *common difference*, the number of terms up to which
    the sum is to be calculated is 3\. The sum turns out to be 3a + 3d, which agrees
    with the known formula for the same.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，所提供的 *n* 项是一个 *等差数列* 的项。从 a 和 d 作为 *公差* 开始，计算和的项数是 3。结果和为 3a + 3d，这与已知的公式一致。
- en: '***#4: Solving Single-Variable Inequalities***'
  id: totrans-455
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***#4: 求解单变量不等式***'
- en: You’ve seen how to solve an equation using SymPy’s solve() function. But SymPy
    is also capable of solving single-variable inequalities, such as *x* + 5 > 3 and
    sin*x* – 0.6 > 0\. That is, SymPy can solve relations besides equality, like >,
    <, and so on. For this challenge, create a function, isolve(), that will take
    any inequality, solve it, and then return the solution.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到如何使用 SymPy 的 solve() 函数解方程。但 SymPy 还能够解单变量不等式，例如 *x* + 5 > 3 和 sin*x* –
    0.6 > 0。也就是说，SymPy 可以解除了等式外的其他关系，比如 >、< 等等。为了这个挑战，创建一个函数 isolve()，它将接受任何不等式，求解它，然后返回解决方案。
- en: First, let’s learn about the SymPy functions that will help you implement this.
    The inequality-solving functions are available as three separate functions for
    polynomial, rational, and all other inequalities. We’ll need to pick the right
    function to solve various inequalities, or we’ll get an error.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们了解一些 SymPy 函数，这些函数将帮助你实现这一点。解不等式的函数有三个不同的函数，分别用于多项式、不等式和其他所有类型的不等式。我们需要选择合适的函数来解决不同的不等式，否则会报错。
- en: A *polynomial* is an algebraic expression consisting of a variable and coefficients
    and involving only the operations of addition, subtraction, and multiplication
    and only positive powers of the variable. An example of a polynomial inequality
    is *x*² + 4 < 0.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '*多项式*是一个代数表达式，由一个变量、系数以及只涉及加法、减法、乘法运算和变量的正整数次方构成。一个多项式不等式的例子是 *x*² + 4 < 0。'
- en: 'To solve a polynomial inequality, use the solve_poly_inequality() function:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 要求解一个多项式不等式，使用solve_poly_inequality()函数：
- en: '>>> from sympy import Poly, Symbol, solve_poly_inequality'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> from sympy import Poly, Symbol, solve_poly_inequality'
- en: '>>> x = Symbol(''x'')'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x = Symbol(''x'')'
- en: ➊ >>> ineq_obj = -x**2 + 4 < 0
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ >>> ineq_obj = -x**2 + 4 < 0
- en: ➋ >>> lhs = ineq_obj.lhs
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ >>> lhs = ineq_obj.lhs
- en: ➌ >>> p = Poly(lhs, x)
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ >>> p = Poly(lhs, x)
- en: ➍ >>> rel = ineq_obj.rel_op
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ >>> rel = ineq_obj.rel_op
- en: '>>> solve_poly_inequality(p, rel)'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> solve_poly_inequality(p, rel)'
- en: '[(-oo, -2), (2, oo)]'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '[(-∞, -2), (2, ∞)]'
- en: First, create the expression representing an inequality, –*x*² + 4 < 0, at ➊
    and refer to this expression with the label ineq_obj. Then, extract the left side
    of the inequality—that is, the algebraic expression –*x*² + 4—using the lhs attribute
    at ➋. Next, create a Poly object at ➌ to represent the polynomial we extracted
    at ➋. The second argument passed when creating the object is the symbol object
    that represents the variable, x. At ➍, extract the relational operator from the
    inequality object using the rel attribute. Finally, call the solve_poly_inequality()
    function with the polynomial object, p, and rel as the two arguments. The program
    returns the solution as a list of tuples, with each tuple representing a solution
    for the inequality as the lower limit and the upper limit of the range of numbers.
    For this inequality, the solution is all numbers less than –2 and all numbers
    greater than 2.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在 ➊ 创建表示不等式的表达式 –*x*² + 4 < 0，并使用标签 ineq_obj 引用该表达式。然后，使用 ➋ 的lhs属性提取不等式的左侧，即代数表达式
    –*x*² + 4。接下来，在 ➌ 创建一个Poly对象，以表示在 ➋ 提取的多项式。创建对象时传入的第二个参数是表示变量 x 的符号对象。然后，在 ➍ 使用
    rel 属性从不等式对象中提取关系运算符。最后，调用solve_poly_inequality()函数，传入多项式对象 p 和关系运算符 rel 作为两个参数。程序将返回一个包含元组的解，元组中的每个元素表示该不等式的解，即数值范围的下限和上限。对于此不等式，解为所有小于
    –2 的数和所有大于 2 的数。
- en: 'A *rational expression* is an algebraic expression in which the numerator and
    denominator are both polynomials. Here’s an example of a rational inequality:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '*有理表达式*是一个代数表达式，其中分子和分母都是多项式。以下是一个有理不等式的例子：'
- en: '![image](images/e0117-01.jpg)'
  id: totrans-470
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/e0117-01.jpg)'
- en: 'For rational inequalities, use the solve_rational_inequalities() function:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 对于有理不等式，使用 solve_rational_inequalities() 函数：
- en: '>>> from sympy import Symbol, Poly, solve_rational_inequalities'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> from sympy import Symbol, Poly, solve_rational_inequalities'
- en: '>>> x = Symbol(''x'')'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x = Symbol(''x'')'
- en: ➊ >>> ineq_obj = ((x-1)/(x+2)) > 0
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ >>> ineq_obj = ((x-1)/(x+2)) > 0
- en: '>>> lhs = ineq_obj.lhs'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> lhs = ineq_obj.lhs'
- en: ➋ >>> numer, denom = lhs.as_numer_denom()
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ >>> numer, denom = lhs.as_numer_denom()
- en: '>>> p1 = Poly(numer)'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> p1 = Poly(numer)'
- en: '>>> p2 = Poly(denom)'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> p2 = Poly(denom)'
- en: '>>> rel = ineq_obj.rel_op'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> rel = ineq_obj.rel_op'
- en: ➌ >>> solve_rational_inequalities([[((p1, p2), rel)]])
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ >>> solve_rational_inequalities([[((p1, p2), rel)]])
- en: (-oo, -2) U (1, oo)
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: (-∞, -2) ∪ (1, ∞)
- en: Create an inequality object representing our example rational inequality at
    ➊ and then extract the rational expression using the lhs attribute. Separate out
    the numerator and the denominator into the labels numer and denom using the as_numer_denom()
    method at ➋, which returns a tuple with the numerator and denominator as the two
    members. Then, create two polynomial objects, p1 and p2, representing the numerator
    and denominator, respectively. Retrieve the relational operator and call the solve_rational_inequalities()
    function, passing it the two polynomial objects—p1 and p2—and the relational operator.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 创建表示我们示例有理不等式的不等式对象，并在 ➊ 使用 lhs 属性提取有理表达式。然后，通过 as_numer_denom() 方法在 ➋ 将分子和分母分别分离到
    numer 和 denom 标签中，该方法返回一个包含分子和分母的元组。接着，创建两个多项式对象 p1 和 p2，分别表示分子和分母。获取关系运算符并调用
    solve_rational_inequalities() 函数，传入两个多项式对象 p1 和 p2 以及关系运算符。
- en: The program returns the solution (-oo, -2) U (1, oo), where U denotes that the
    solution is a *union* of the two *sets* of solutions consisting of all numbers
    less than –2 and all numbers greater than 1\. (We’ll learn about sets in [Chapter
    5](ch05.html#ch05).)
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 程序返回解 (-∞, -2) ∪ (1, ∞)，其中 ∪ 表示解是两个 *集合* 的 *并集*，这些集合分别包含所有小于 –2 和大于 1 的数。（我们将在[第
    5 章](ch05.html#ch05)学习集合。）
- en: 'Finally, sin*x* – 0.6 > 0 is an example of an inequality that belongs to neither
    the polynomial nor rational expression categories. If you have such an inequality
    to solve, use the solve_univariate_inequality() function:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，sin*x* – 0.6 > 0 是一个既不属于多项式也不属于有理表达式类别的不等式。如果你有这样的不等式需要求解，可以使用 solve_univariate_inequality()
    函数：
- en: '>>> from sympy import Symbol, solve, solve_univariate_inequality, sin'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> from sympy import Symbol, solve, solve_univariate_inequality, sin'
- en: '>>> x = Symbol(''x'')'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x = Symbol(''x'')'
- en: '>>> ineq_obj = sin(x) - 0.6 > 0'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> ineq_obj = sin(x) - 0.6 > 0'
- en: '>>> solve_univariate_inequality(ineq_obj, x, relational=False)'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> solve_univariate_inequality(ineq_obj, x, relational=False)'
- en: (0.643501108793284, 2.49809154479651)
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: (0.643501108793284, 2.49809154479651)
- en: Create an inequality object representing the inequality sin(x) – 0.6 > 0 and
    then call the solve_univariate_inequality() function with the first two arguments
    as the inequality object, ineq_obj, and the symbol object, x. The keyword argument
    relational=False specifies to the function that we want the solution to be returned
    as a *set*. The solution for this inequality turns out to be all numbers lying
    between the first and second members of the tuple the program returns.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个表示不等式 sin(x) – 0.6 > 0 的不等式对象，然后调用 solve_univariate_inequality() 函数，前两个参数分别是这个不等式对象
    ineq_obj 和符号对象 x。关键字参数 relational=False 指定我们希望函数返回的是一个 *集合*。这个不等式的解就是程序返回的元组中的第一和第二个成员之间的所有数字。
- en: '**Hints: Handy Functions**'
  id: totrans-491
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**提示：常用函数**'
- en: Now remember—your challenge is (1) to create a function, isolve(), that will
    take any inequality and (2) to choose one of the appropriate functions discussed
    in this section to solve it and return the solution. The following hints may be
    useful to implement this function.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 现在记住——你的挑战是（1）创建一个函数 isolve()，它将接受任何不等式，并（2）选择本节讨论的适当函数来解决它并返回解。以下提示可能对实现此函数有所帮助。
- en: 'The is_polynomial() method can be used to check whether an expression is a
    polynomial or not:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: is_polynomial() 方法可以用来检查一个表达式是否是多项式：
- en: '>>> x = Symbol(''x'')'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x = Symbol(''x'')'
- en: '>>> expr = x**2 - 4'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> expr = x**2 - 4'
- en: '>>> expr.is_polynomial()'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> expr.is_polynomial()'
- en: 'True'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 'True'
- en: '>>> expr = 2*sin(x) + 3'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> expr = 2*sin(x) + 3'
- en: '>>> expr.is_polynomial()'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> expr.is_polynomial()'
- en: 'False'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 'False'
- en: 'The is_rational_function() can be used to check whether an expression is a
    rational expression:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: is_rational_function() 可以用来检查一个表达式是否是有理表达式：
- en: '>>> expr = (2+x)/(3+x)'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> expr = (2+x)/(3+x)'
- en: '>>> expr.is_rational_function()'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> expr.is_rational_function()'
- en: 'True'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 'True'
- en: '>>> expr = 2+x'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> expr = 2+x'
- en: '>>> expr.is_rational_function()'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> expr.is_rational_function()'
- en: 'True'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 'True'
- en: '>>> expr = 2+sin(x)'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> expr = 2+sin(x)'
- en: '>>> expr.is_rational_function()'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> expr.is_rational_function()'
- en: 'False'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 'False'
- en: 'The sympify() function can convert an inequality expressed as a string to an
    inequality object:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: sympify() 函数可以将以字符串形式表示的不等式转换为不等式对象：
- en: '>>> from sympy import sympify'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> from sympy import sympify'
- en: '>>> sympify(''x+3>0'')'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> sympify(''x+3>0'')'
- en: x + 3 > 0
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: x + 3 > 0
- en: When you run your program, it should ask the user to input an inequality expression
    and print back the solution.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行程序时，它应该会要求用户输入一个不等式表达式，并打印出解决方案。
