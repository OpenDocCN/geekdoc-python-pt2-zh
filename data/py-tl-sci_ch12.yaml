- en: '**12'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**12'
- en: FILES AND FOLDERS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件和文件夹**'
- en: '![image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common.jpg)'
- en: Files let you store data in a persistent and sharable manner. It’s all but impossible
    to do any real work without them. Python comes with many modules and methods for
    working with files, folders, and directory paths. These let you read and write
    text files; preserve complex data after you exit your program; create, move, and
    delete folders; and perform other system-level tasks.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 文件让你能够以持久化和可共享的方式存储数据。没有它们，几乎不可能完成任何实际工作。Python 提供了许多模块和方法来处理文件、文件夹和目录路径。这些方法可以让你读取和写入文本文件；在退出程序后保存复杂数据；创建、移动和删除文件夹；以及执行其他系统级任务。
- en: In this chapter, we’ll use the built-in operating system (`os`), path library
    (`pathlib`), and shell utilities (`shutil`) modules to work with files, folders,
    and directory paths. We’ll then use built-in functions to open, read, write, and
    close text files, and the built-in `pickle`, `shelve`, and `json` modules to preserve
    and store more complex data types such as Python lists and dictionaries. Finally,
    we’ll look at ways to handle exceptions when opening files.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用内置的操作系统模块（`os`）、路径库模块（`pathlib`）和 shell 工具模块（`shutil`）来处理文件、文件夹和目录路径。然后，我们将使用内置函数打开、读取、写入和关闭文本文件，并使用内置的
    `pickle`、`shelve` 和 `json` 模块来保存和存储更复杂的数据类型，如 Python 列表和字典。最后，我们将学习在打开文件时如何处理异常。
- en: '**Creating a New Spyder Project**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**创建一个新的 Spyder 项目**'
- en: Let’s make a new Spyder project to use in this chapter. If you need a refresher
    on Spyder projects, see “Using Project Files and Folders” on [page 68](ch04.xhtml#ch00lev1sec25).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的 Spyder 项目来用于本章。如果你需要复习 Spyder 项目的使用，请参阅第 68 页的“使用项目文件和文件夹”部分（[第 68
    页](ch04.xhtml#ch00lev1sec25)）。
- en: To begin, start Spyder (either from the Start menu or from Anaconda Navigator)
    and then, in the top toolbar, click **Projects** ▸ **New Project**. In the Create
    New Project dialog that opens ([Figure 12-1](ch12.xhtml#ch012fig1)), make sure
    the Location box includes your home directory, set the Project name to **file_play**,
    and then click the **Create** button.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，启动 Spyder（可以从开始菜单或 Anaconda Navigator 中启动），然后在顶部工具栏中点击 **项目** ▸ **新建项目**。在打开的创建新项目对话框中（[图
    12-1](ch12.xhtml#ch012fig1)），确保“位置”框中包含你的主目录，将项目名称设置为 **file_play**，然后点击 **创建**
    按钮。
- en: '![Image](../images/12fig01.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/12fig01.jpg)'
- en: '*Figure 12-1: The Spyder Create New Project dialog*'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-1：Spyder 创建新项目对话框*'
- en: You should now see this new folder in Spyder’s File Explorer pane.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该能在 Spyder 的文件资源管理器面板中看到这个新文件夹。
- en: '**Working with Directory Paths**'
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**处理目录路径**'
- en: Before you can work with files and folders (also called *directories*), you’ll
    need to know how to find them and where to save them. And to do that, you’ll need
    an address, otherwise known as a *directory path*.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始处理文件和文件夹（也称为 *目录*）之前，你需要知道如何找到它们以及将它们保存在哪里。为此，你需要一个地址，也就是 *目录路径*。
- en: A directory path is a string of characters used to uniquely identify a location
    in a directory structure. A path starts with a root directory designated by a
    letter (such as *C:\*) in Windows and a forward slash (*/*) in Unix-based systems.
    Additional drives in Windows are assigned a different letter than *C*, those in
    macOS are placed under */volume*, and those in Unix under */mnt* (for “mount”).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 目录路径是用来唯一标识目录结构中某个位置的字符字符串。路径以根目录开始，在 Windows 中用一个字母（如 *C:\*）表示，在基于 Unix 的系统中用正斜杠（/*）表示。在
    Windows 中，其他驱动器会被分配一个不同于 *C* 的字母，macOS 中的驱动器位于 */volume* 下，而 Unix 中的驱动器位于 */mnt*
    下（表示“挂载”）。
- en: Pathnames appear differently depending on the operating system. Windows separates
    folders with a backslash (*\*), whereas macOS and Unix systems use a forward slash
    (*/*). Folders and filenames are also case sensitive in Unix.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 路径名在不同的操作系统中表现不同。Windows 使用反斜杠（*\*）分隔文件夹，而 macOS 和 Unix 系统则使用正斜杠（/*）。在 Unix
    系统中，文件夹和文件名对大小写敏感。
- en: These differences between operating systems can pose problems if you’re trying
    to write code that can run on any system. If you’re writing a program in Windows
    and enter pathnames with backslashes, other platforms won’t recognize the paths.
    Fortunately, Python provides standard library modules such as `os` and `pathlib`
    to help you deal with this.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统之间的这些差异可能会导致问题，特别是当你尝试编写可以在任何系统上运行的代码时。如果你在 Windows 中编写程序并使用反斜杠表示路径，其他平台将无法识别这些路径。幸运的是，Python
    提供了标准库模块，如 `os` 和 `pathlib`，来帮助你解决这个问题。
- en: '***The Operating System Module***'
  id: totrans-16
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***操作系统模块***'
- en: The operating system (`os`) module has been described as a “junk drawer for
    system-related stuff.” [Table 12-1](ch12.xhtml#ch012tab1) summarizes some of the
    most used methods in this module. For a complete list of the methods and details
    about their use, visit the documentation at *[https://docs.python.org/3/library/os.html](https://docs.python.org/3/library/os.html)*.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统（`os`）模块被描述为“系统相关事项的杂物抽屉”。[表 12-1](ch12.xhtml#ch012tab1)总结了该模块中一些最常用的方法。要查看完整的方法列表及其使用详情，请访问文档
    *[https://docs.python.org/3/library/os.html](https://docs.python.org/3/library/os.html)*。
- en: '**Table 12-1:** Useful `os` Module Methods'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 12-1：** 有用的 `os` 模块方法'
- en: '| **Method** | **Description** |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** |'
- en: '| --- | --- |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `os.getcwd()` | Return location of the current working directory (cwd) |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `os.getcwd()` | 返回当前工作目录 (cwd) 的位置 |'
- en: '| `os.chdir()` | Change cwd to a specified path |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `os.chdir()` | 将 cwd 更改为指定路径 |'
- en: '| `os.getsize()` | Return the size of a file in bytes |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `os.getsize()` | 返回文件的大小（以字节为单位） |'
- en: '| `os.listdir()` | Return list of files and folders inside specified directory
    (defaults to cwd) |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `os.listdir()` | 返回指定目录内的文件和文件夹列表（默认为 cwd） |'
- en: '| `os.mkdir()` | Create a new directory based on a specified path |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `os.mkdir()` | 根据指定路径创建新目录 |'
- en: '| `os.makedirs()` | Create multiple nested directories based on a specified
    path |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `os.makedirs()` | 根据指定路径创建多个嵌套目录 |'
- en: '| `os.rename()` | Rename a specified file or directory |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `os.rename()` | 重命名指定的文件或目录 |'
- en: '| `os.rmdir()` | Delete an empty directory |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `os.rmdir()` | 删除一个空目录 |'
- en: '| `os.walk()` | Generate filenames in a directory tree |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `os.walk()` | 生成目录树中的文件名 |'
- en: '| `os.path.join()` | Join path components and return a string that contains
    a concatenated path |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `os.path.join()` | 连接路径组件并返回包含拼接路径的字符串 |'
- en: '| `os.path.split()` | Split a pathname into a head and tail (tail=last pathname
    component) |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `os.path.split()` | 将路径名拆分为头部和尾部（尾部=最后一个路径组件） |'
- en: '| `os.path.abspath()` | Return a normalized absolute version of a specified
    path |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `os.path.abspath()` | 返回指定路径的规范化绝对版本 |'
- en: '| `os.path.normpath()` | Correct path separators for the system in use |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `os.path.normpath()` | 根据当前系统修正路径分隔符 |'
- en: '| `os.path.isdir()` | Check whether a specified path corresponds to an existing
    directory |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `os.path.isdir()` | 检查指定路径是否对应现有目录 |'
- en: '| `os.path.isfile()` | Check whether a specified path corresponds to an existing
    file |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `os.path.isfile()` | 检查指定路径是否对应现有文件 |'
- en: '| `os.path.isabs()` | Check whether a specified path is absolute or not |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `os.path.isabs()` | 检查指定路径是否为绝对路径 |'
- en: '| `os.path.exists()` | Check whether a specified path exists or not |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `os.path.exists()` | 检查指定路径是否存在 |'
- en: 'Several of these `os` methods are helpful for discovering pathnames you didn’t
    already know. For example, to determine the name of the directory in which you’re
    currently working (called the *current working directory*, or *cwd*), import the
    `os` module and enter the following in the console:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 `os` 方法中的几个对于发现你之前未知道的路径非常有帮助。例如，要确定你当前工作的目录名称（即*当前工作目录*，或 *cwd*），可以导入 `os`
    模块并在控制台中输入以下内容：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this example, you used the `os.getcwd()` method to get the path to your current
    working directory (your path will be different). This is a Windows example, so
    backslashes separate directory names, and, because this is a string, the backslashes
    must be escaped with a backslash (see “Escape Sequences” on [page 190](ch07.xhtml#ch00lev3sec16)
    for a refresher on the escape sequence). The `os.getcwd()` method will insert
    these backslashes for you, but they will cause problems if you try to use this
    path with another operating system.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你使用了 `os.getcwd()` 方法来获取当前工作目录的路径（你的路径会有所不同）。这是一个 Windows 示例，因此使用反斜杠来分隔目录名称，而且因为这是一个字符串，反斜杠必须通过另一个反斜杠进行转义（有关转义序列的复习，请参见
    [第 190 页](ch07.xhtml#ch00lev3sec16)）。`os.getcwd()` 方法会为你插入这些反斜杠，但如果你尝试在其他操作系统中使用这个路径，可能会遇到问题。
- en: The current working directory is assigned to a *process* (a running instance
    of a program) when that process starts up. For a Python program, the current working
    directory is always the folder that contains the running program.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当前工作目录在进程启动时会分配给该进程（即程序的运行实例）。对于 Python 程序，当前工作目录始终是包含该程序的文件夹。
- en: 'You can use `os.chdir()` to move from the current working directory to another
    directory, as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `os.chdir()` 从当前工作目录切换到另一个目录，示例如下：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, this new directory becomes the current working directory.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这个新目录变成了当前工作目录。
- en: 'If you work in Windows and don’t want to type the double backslash, you can
    enter an `r` before the pathname argument string to convert it to a raw string:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在Windows上工作并且不想输入双反斜杠，可以在路径名称前输入`r`，将其转换为原始字符串：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To make your program compatible with all operating systems, use the `os.path.join()`
    method and pass it the folder names and filenames without a separator character,
    as separate strings. The `os.path` methods are aware of the system you’re using
    and return the proper separators. This allows for platform-independent manipulation
    of file and folder names. Here’s an example:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使你的程序兼容所有操作系统，请使用`os.path.join()`方法，将文件夹名称和文件名作为独立的字符串传入，而不加分隔符字符。`os.path`方法会根据你使用的系统返回正确的分隔符。这使得文件和文件夹名的操作与平台无关。下面是一个示例：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this snippet, you assigned a pathname, as a string, to the `path` variable.
    Notice how you can safely use forward slashes in Windows. Next, you made a new
    path variable (`path2`) using the `os.path.join()` method. Even though the output
    in line `Out[15]` looks messy, the `os.path.join()` method knows which operating
    system you’re using and corrects the separators as needed (lines `In[16]` - `Out[17])`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，你将一个路径名作为字符串赋值给`path`变量。注意，你可以在Windows中安全地使用正斜杠。接下来，你使用`os.path.join()`方法创建了一个新的路径变量（`path2`）。即使在`Out[15]`行中的输出看起来有点乱，`os.path.join()`方法会根据你使用的操作系统自动修正分隔符（见`In[16]`
    - `Out[17]`行）。
- en: 'You can also take an existing path with the wrong separators and *normalize*
    it to the system you’re using with `os.normpath()`. Here’s an example in which
    Unix forward slashes are changed to Windows backslashes:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将一个使用错误分隔符的现有路径通过`os.normpath()`转换为你正在使用的系统路径。下面是一个示例，其中Unix的正斜杠被转换为Windows的反斜杠：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '***Absolute vs. Relative Paths***'
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***绝对路径与相对路径***'
- en: The full directory path, from the drive to the current file or folder, is called
    the *absolute path*. You can use shortcuts, called *relative paths*, to make working
    with directories easier.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 从驱动器到当前文件或文件夹的完整目录路径被称为*绝对路径*。你可以使用被称为*相对路径*的快捷方式，使得目录操作更加简便。
- en: 'Relative paths are interpreted from the perspective of the current working
    directory. Whereas absolute paths start with a forward slash or drive label, relative
    paths do not. In the following code snippet, you can change directories without
    entering an absolute path because Python is aware of folders within the current
    working directory:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 相对路径是从当前工作目录的视角进行解析的。而绝对路径是以正斜杠或驱动器标签开始的，相对路径则不是。在以下代码片段中，你可以在不输入绝对路径的情况下切换目录，因为Python知道当前工作目录中的文件夹：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Behind the scenes, the relative path is joined to the path leading to the current
    working directory to make the complete absolute path shown in line `Out[23]`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，相对路径被连接到指向当前工作目录的路径，以形成完整的绝对路径，该路径显示在`Out[23]`行中。
- en: 'In Windows, macOS, and Linux, you can identify folders and save yourself some
    typing by using dot (`.`) and dot-dot (`..`). For example, in Windows, `.\` refers
    to the current working directory, and `..\` refers to the parent directory that
    holds the current working directory. You can also use a dot to get the absolute
    path to your current working directory:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows、macOS和Linux中，你可以通过使用点号（`.`）和点点（`..`）来识别文件夹，减少输入。例如，在Windows中，`.\`表示当前工作目录，`..\`表示包含当前工作目录的父目录。你也可以使用点号获取当前工作目录的绝对路径：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If a file, folder, or user-defined module that you need to access is stored
    in the same folder as your code, you can simply refer to the item’s name in your
    code, without the need for a path or a “dot” shortcut. Following is an example
    in which we create multiple nested folders within the *file_play* folder. Because
    *file_play* is the current working directory and these folders will exist within
    it, there’s no need to include a file path:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要访问的文件、文件夹或用户自定义模块存储在与你的代码相同的文件夹中，你可以直接在代码中引用该项目的名称，而无需路径或“点”快捷方式。以下是一个示例，我们在*file_play*文件夹内创建多个嵌套文件夹。因为*file_play*是当前工作目录，这些文件夹将位于其中，所以不需要包含文件路径：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this example, the `os.makedirs()` method created three nested folders (*test1*,
    *test2*, and *test3*) using a raw string. You should now see three folders in
    your Spyder project in the File Explorer pane ([Figure 12-2](ch12.xhtml#ch012fig2)).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，`os.makedirs()`方法使用原始字符串创建了三个嵌套文件夹（*test1*、*test2*和*test3*）。现在你应该能在Spyder项目的文件资源管理器窗格中看到这三个文件夹（[图12-2](ch12.xhtml#ch012fig2)）。
- en: '![Image](../images/12fig02.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/12fig02.jpg)'
- en: '*Figure 12-2: The three new folders in the Spyder project*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-2：Spyder项目中的三个新文件夹*'
- en: '***The pathlib Module***'
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***pathlib模块***'
- en: The `os` module is widely used, and you should familiarize yourself with its
    methods and syntax. But it treats paths as strings, which can be cumbersome and
    requires you to use functionality from across the standard library (it takes three
    modules just to gather and move files between directories).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`os`模块被广泛使用，你应该熟悉它的各种方法和语法。但它将路径视为字符串，这可能会变得繁琐，并且需要你使用标准库中其他模块的功能（仅仅为了收集和移动文件，跨目录操作就需要三个模块）。'
- en: An alternative is to use the smaller and more focused `pathlib` module. This
    module treats paths as objects rather than strings, and gathers the necessary
    path functionality in one place. It’s also agnostic to the operating system, making
    it useful for writing cross-platform programs.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是使用更小且更集中的`pathlib`模块。该模块将路径视为对象而非字符串，并将所需的路径功能集中在一个地方。它与操作系统无关，使得它在编写跨平台程序时非常有用。
- en: 'The module’s `Path` and `PurePath` classes not only help you work with directory
    paths, they also duplicate useful `os` module methods for tasks like the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块的`Path`和`PurePath`类不仅帮助你处理目录路径，它们还复制了`os`模块中的一些有用方法，用于以下任务：
- en: 'Getting the current working directory: `Path.cwd()`'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取当前工作目录：`Path.cwd()`
- en: 'Making directories: `Path.mkdir()`'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建目录：`Path.mkdir()`
- en: 'Renaming directories: `Path.rename()`'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重命名目录：`Path.rename()`
- en: 'Removing directories: `Path.rmdir()`'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除目录：`Path.rmdir()`
- en: '**NOTE**'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Path classes in pathlib are divided into *pure* paths and concrete paths.
    PurePath objects act like strings and provide path-handling operations such as
    editing the path, joining paths, finding the parent path, and so on, but they
    don’t access a filesystem. Concrete paths inherit from PurePath and provide both
    pure path operations and new methods to do system calls on path objects. Concrete
    paths let you access the filesystem to search directories, remove directories,
    write to files, and so on.*'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*pathlib中的Path类分为*纯路径*和具体路径。PurePath对象像字符串一样作用，提供路径处理操作，如编辑路径、连接路径、查找父路径等，但它们不会访问文件系统。具体路径继承自PurePath，提供了纯路径操作和新的方法，用于对路径对象进行系统调用。具体路径让你可以访问文件系统，进行目录搜索、删除目录、写入文件等操作。*'
- en: '[Table 12-2](ch12.xhtml#ch012tab2) summarizes some of the more useful methods
    available through the `pathlib` module. For the full list, visit the documentation
    at *[https://docs.python.org/3/library/pathlib.html](https://docs.python.org/3/library/pathlib.html)*.
    This documentation also includes a complete mapping of various `os` methods to
    their corresponding `Path` and `PurePath` equivalents.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[表12-2](ch12.xhtml#ch012tab2)总结了`pathlib`模块中一些较为有用的方法。欲了解完整列表，请访问文档 *[https://docs.python.org/3/library/pathlib.html](https://docs.python.org/3/library/pathlib.html)*。该文档还包括了`os`方法与其对应的`Path`和`PurePath`方法的完整映射。'
- en: '**Table 12-2:** Useful `Path` and `PurePath` Methods for Working with Paths'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**表12-2：** 用于路径操作的有用`Path`和`PurePath`方法'
- en: '| **Method** | **Description** |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** |'
- en: '| --- | --- |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Path.cwd()` | Return path object for the cwd |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `Path.cwd()` | 返回当前工作目录的路径对象 |'
- en: '| `Path.exists()` | Return Boolean that indicates whether path points to existing
    file or folder |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `Path.exists()` | 返回布尔值，指示路径是否指向一个现有的文件或文件夹 |'
- en: '| `Path.home()` | Return path object representing the user’s home directory
    |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `Path.home()` | 返回表示用户主目录的路径对象 |'
- en: '| `PurePath.is_absolute()` | Return Boolean that indicates whether the path
    is absolute or not |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `PurePath.is_absolute()` | 返回布尔值，指示路径是否为绝对路径 |'
- en: '| `Path.is_dir()` | Return `True` if the given path points to a directory (or
    symbolic link) |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `Path.is_dir()` | 如果给定路径指向一个目录（或符号链接），返回`True` |'
- en: '| `Path.iterdir()` | Yield contents of a given directory |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `Path.iterdir()` | 生成给定目录的内容 |'
- en: '| `PurePath.joinpath()` | Combine a given path with each of the other arguments
    in turn |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `PurePath.joinpath()` | 将给定路径与其他参数逐个连接 |'
- en: '| `Path.mkdir()` | Create a new directory at the given path |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `Path.mkdir()` | 在给定路径创建一个新目录 |'
- en: '| `Path.readlink()` | Return path for given symbolic link |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `Path.readlink()` | 返回给定符号链接的路径 |'
- en: '| `Path.resolve()` | Make path absolute, resolving any symbolic links; return
    new path |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `Path.resolve()` | 将路径转换为绝对路径，解析任何符号链接；返回新路径 |'
- en: '| `Path.rmdir()` | Remove an empty directory |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `Path.rmdir()` | 删除空目录 |'
- en: '| `Path.unlink()` | Remove a file or symbolic link |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `Path.unlink()` | 删除一个文件或符号链接 |'
- en: 'Here’s how to make a path variable using `Path`. Start by importing the class
    from the module, as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何使用`Path`创建路径变量。首先从模块中导入类，如下所示：
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Note that `Path` returned a `WindowsPath` object. If you’re using macOS or
    Linux, you should see a `PosixPath` object. Also note that although the `WindowsPath`
    object displays with forward slashes, it employs proper Windows backslashes behind
    the scenes:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`Path`返回了一个`WindowsPath`对象。如果你使用的是macOS或Linux，你应该看到一个`PosixPath`对象。还要注意，尽管`WindowsPath`对象显示的是正斜杠，但实际上它在后台使用的是正确的Windows反斜杠：
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`Path` includes methods that can make your code more readable and convenient
    to write. Suppose that you want to append a path to your home directory. Rather
    than type in the full path, you can just use the `home()` method to get the path:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`Path` 包含可以让你的代码更具可读性且更方便编写的方法。假设你想将一个路径追加到你的主目录。你可以使用`home()`方法来获取路径，而无需输入完整的路径：'
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Alternatively, you can do all this in one line and use forward slashes rather
    than commas to separate path components:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以将所有操作放在一行中，并使用正斜杠而不是逗号来分隔路径组件：
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Don’t worry about those forward slashes if you’re using Windows. As demonstrated
    previously, the path object is aware of the platform in use and will return the
    correct format for that system.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是Windows，不必担心那些正斜杠。如前所示，路径对象会根据使用的系统自动识别并返回正确的格式。
- en: 'Each `Path` object includes handy attributes for working with files and folders.
    These let you get information like the `stem` of a path or a file’s `name` or
    extension (`suffix`). The `parent` attribute, for example, returns the most immediate
    ancestor of a given file path. In the following example, we get the path *leading
    up to* the text file in the `another_path` variable:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`Path`对象都包含用于处理文件和文件夹的有用属性。这些属性可以让你获取像路径的`stem`、文件的`name`或扩展名（`suffix`）等信息。例如，`parent`属性返回给定文件路径的最直接的父级。在以下示例中，我们获取到`another_path`变量中文本文件的路径*直到*该文件：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can access this attribute multiple times to walk up the ancestry tree of
    a given file, like so:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以多次访问此属性，以沿着给定文件的祖先树向上遍历，像这样：
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As mentioned previously, `pathlib` gives you access to basic filesystem operations
    like moving, renaming, and removing files and folders. These methods don’t warn
    you or wait for confirmation before executing, so you’ll want to be very careful
    when using them. Otherwise, you could easily delete or overwrite data that you
    want to keep.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`pathlib`提供了对基本文件系统操作的访问，如移动、重命名和删除文件和文件夹。这些方法不会在执行前提醒你或等待确认，所以在使用它们时你需要非常小心。否则，你可能会轻易删除或覆盖你想保留的数据。
- en: '***The Shell Utilities Module***'
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Shell工具模块***'
- en: The built-in shell utilities module (`shutil`) provides high-level functions
    for working with files and folders, such as copying, moving, and deleting. [Table
    12-3](ch12.xhtml#ch012tab3) summarizes a few of the most popular methods. For
    a list of all of the available methods, along with detailed instructions for their
    use, visit the documentation at *[https://docs.python.org/3/library/shutil.html](https://docs.python.org/3/library/shutil.html)*.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 内建的shell工具模块（`shutil`）提供了用于处理文件和文件夹的高级函数，如复制、移动和删除。[表12-3](ch12.xhtml#ch012tab3)总结了一些最常用的方法。有关所有可用方法的列表及其详细使用说明，请访问文档：*[https://docs.python.org/3/library/shutil.html](https://docs.python.org/3/library/shutil.html)*。
- en: '**Table 12-3:** Useful `shutil` Module Methods'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**表12-3：** 有用的`shutil`模块方法'
- en: '| **Method** | **Description** |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** |'
- en: '| --- | --- |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `copy()` | Copy a file (if path is included, will copy to a new directory)
    |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `copy()` | 复制文件（如果包括路径，则会复制到新目录） |'
- en: '| `copy2()` | Same as `copy()` but preserves all the metadata of the source
    file |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `copy2()` | 与`copy()`相同，但会保留源文件的所有元数据 |'
- en: '| `copytree()` | Recursively copy an entire directory tree rooted at a source
    directory to a new destination directory and return the destination directory
    path |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `copytree()` | 递归地将源目录下的整个目录树复制到新的目标目录，并返回目标目录路径 |'
- en: '| `disk_usage()` | Return disk usage statistics about a file system as a named
    tuple with the attributes total, used, and free, in bytes |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `disk_usage()` | 返回文件系统的磁盘使用统计信息，作为一个命名元组，包含 total、used 和 free 属性，单位为字节 |'
- en: '| `move()` | Move a file or directory to another location and return the destination
    |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `move()` | 将文件或目录移动到另一个位置并返回目标位置 |'
- en: '| `rmtree()` | Delete an entire directory tree (very dangerous) |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `rmtree()` | 删除整个目录树（非常危险） |'
- en: '| `make_archive()` | Create an archive file (zip or tar) and return its name
    |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `make_archive()` | 创建一个归档文件（zip 或 tar），并返回其名称 |'
- en: 'Here’s an example in which I get the current disk usage on my system using
    a dot to represent the absolute path:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例，我通过使用点（.）表示绝对路径来获取系统的当前磁盘使用情况：
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the next example, we move the *test2* folder to a new location under the
    *file_play* folder. To accomplish this, we pass the current path (with the current
    working directory represented by a dot folder), followed by the target path, to
    the `move()` method (note that the path is configured for Windows):'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们将 *test2* 文件夹移动到 *file_play* 文件夹下的新位置。为此，我们将当前路径（当前工作目录用点文件夹表示）和目标路径传递给
    `move()` 方法（注意路径已为 Windows 配置）：
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You should see this update reflected in Spyder’s File Explorer (compare [Figure
    12-2](ch12.xhtml#ch012fig2) to [Figure 12-3](ch12.xhtml#ch012fig3)). Child folders
    move with parent folders, so the *test3* folder remains beneath *test2*.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在 Spyder 的文件资源管理器中看到此更新（比较 [图 12-2](ch12.xhtml#ch012fig2) 和 [图 12-3](ch12.xhtml#ch012fig3)）。子文件夹会随着父文件夹移动，所以
    *test3* 文件夹会保持在 *test2* 文件夹下。
- en: '![Image](../images/12fig03.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/12fig03.jpg)'
- en: '*Figure 12-3: The test2 folder moved beneath the file_play folder*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-3：test2 文件夹已移至 file_play 文件夹下*'
- en: '**NOTE**'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Always be careful when using shutil methods; no warnings are provided, and
    unexpected behavior can result. The rmtree() method is especially dangerous because
    it permanently deletes folders and their contents. You can wipe much of your system,
    lose important documents unrelated to Python projects, and break your computer!*'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用 shutil 方法时一定要小心；没有警告信息，可能会导致意外行为。rmtree() 方法尤其危险，因为它会永久删除文件夹及其内容。你可能会清除系统的大部分内容，丢失与
    Python 项目无关的重要文档，甚至可能会损坏电脑！*'
- en: Now that you have a feel for manipulating files and folders using Python, it’s
    time to start writing and reading files. We’ll begin with simple text files and
    then move on to more sophisticated data structures.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经对使用 Python 操作文件和文件夹有了一些了解，是时候开始写入和读取文件了。我们将从简单的文本文件开始，然后再转向更复杂的数据结构。
- en: '**TEST YOUR KNOWLEDGE**'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试你的知识**'
- en: '1.  The ''.'' folder represents:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  '.' 文件夹表示：
- en: a.  The current working directory
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: a.  当前工作目录
- en: b.  The parent directory for the current working directory
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: b.  当前工作目录的父目录
- en: c.  The absolute path
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: c.  绝对路径
- en: d.  The child directory for the current working directory
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: d.  当前工作目录的子目录
- en: 2.  Which method should you be particularly careful about using?
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  你应该特别小心使用哪种方法？
- en: a.  `shutil.move()`
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: a.  `shutil.move()`
- en: b.  `shutil.copytree()`
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: b.  `shutil.copytree()`
- en: c.  `Path.resolve()`
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: c.  `Path.resolve()`
- en: d.  `shutil.rmtree()`
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: d.  `shutil.rmtree()`
- en: '3.  True or false: a relative directory path is relative with respect to the
    root directory.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  对还是错：相对目录路径是相对于根目录的。
- en: '4.  You can use the `os.path.join()` method to:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 4.  你可以使用 `os.path.join()` 方法来：
- en: a.  Return a directory path as an object rather than a string
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: a.  返回目录路径作为对象而不是字符串
- en: b.  Return a directory path as a list rather than a string
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: b.  返回目录路径作为列表而不是字符串
- en: c.  Return the proper path separators for your operating system
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: c.  返回适合你操作系统的路径分隔符
- en: d.  Correct existing path separators for your operating system
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: d.  为你的操作系统修正现有的路径分隔符
- en: 5.  The `pathlib` module treats paths as ___________ .
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 5.  `pathlib` 模块将路径视为 ___________ 。
- en: '**Working with Text Files**'
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**处理文本文件**'
- en: A *plaintext* file consists of human-readable characters encoded using some
    standard such as ASCII, with no formatting information other than space, tab,
    and newline characters. Some examples of plaintext files are text files (*.txt*),
    Python files (*.py*), and comma-separated values files (*.csv*). Plaintext files
    are cross-platform. You can open and read one using both Window’s Notepad and
    macOS’s TextEdit app.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*纯文本* 文件由可读字符组成，这些字符使用一些标准（如 ASCII）进行编码，除了空格、制表符和换行符外没有其他格式信息。纯文本文件的示例有文本文件
    (*.txt*)、Python 文件 (*.py*) 和逗号分隔值文件 (*.csv*)。纯文本文件是跨平台的。你可以使用 Windows 的记事本和 macOS
    的 TextEdit 应用程序打开并阅读它。'
- en: Python’s standard library includes built-in functions for reading and writing
    text files. The `pathlib` module also includes methods for working with text files.
    In the sections that follow, we’ll first use the built-in functions, and then
    we’ll look at the `pathlib` alternatives.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的标准库包括用于读取和写入文本文件的内置函数。`pathlib` 模块也包含处理文本文件的方法。在接下来的部分中，我们将首先使用内置函数，然后再看
    `pathlib` 的替代方法。
- en: '***Reading a Text File***'
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***读取文本文件***'
- en: 'Using Python, you can read strings from a text file in multiple ways. For example,
    you can read individual characters, complete lines, the whole file, and so on.
    To demonstrate, open your system’s text editor and enter the following. Be sure
    to press ENTER after the first two lines:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Python，你可以通过多种方式从文本文件中读取字符串。例如，你可以读取单个字符、完整的行、整个文件等等。为了演示，打开你的系统文本编辑器并输入以下内容。确保在前两行后按回车键：
- en: '[PRE16]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Save the file in the *file_play* folder as *lines.txt*.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 将文件保存在*file_play*文件夹中，命名为*lines.txt*。
- en: '**NOTE**'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You can double-click a text file in the Spyder File Explorer to edit and review
    its contents. You can also generate text files using File ▸ New file on the top
    toolbar. Use the Save as command to choose the .txt extension.*'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可以在 Spyder 文件资源管理器中双击文本文件以编辑和查看其内容。你也可以通过顶部工具栏的“文件 ▸ 新建文件”来生成文本文件。使用“另存为”命令选择
    .txt 扩展名。*'
- en: 'Now, in the console, enter the following to open, read, and close the file:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在控制台中输入以下内容以打开、读取和关闭文件：
- en: '[PRE17]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the first line, we used the built-in `open()` function to open the file and
    assign its contents to the `f` variable (short for “file”). The `open()` function
    took two arguments. The first was the name of the text file. Because this file
    is in the current working directory, you didn’t need to include a path. For files
    not in the current working directory, you would need to pass either an absolute
    or relative path.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我们使用内置的 `open()` 函数打开文件，并将其内容赋给 `f` 变量（代表“文件”）。`open()` 函数接受两个参数，第一个是文本文件的名称。由于该文件位于当前工作目录中，因此无需包含路径。对于不在当前工作目录中的文件，你需要传递绝对路径或相对路径。
- en: The second argument was an *access mode*, which sets the type of operations
    possible in the opened file, such as read, write, append, and so on. The `'r'`
    informs Python that you want to open the file as *read-only*. This protects the
    file from modification. Although read-only is the default mode, explicitly including
    the `'r'` argument makes your intention clear. [Table 12-4](ch12.xhtml#ch012tab4)
    includes some common file access modes in Python.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数是*访问模式*，它设置了在打开文件时可以执行的操作类型，例如读取、写入、追加等等。`'r'`告诉 Python 你想要以*只读*模式打开文件。这可以保护文件不被修改。尽管只读模式是默认模式，但明确地包括`'r'`参数可以让你的意图更加清晰。[表
    12-4](ch12.xhtml#ch012tab4)列出了 Python 中一些常见的文件访问模式。
- en: '**Table 12-4:** Selected Text File Access Modes'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 12-4:** 选定的文本文件访问模式'
- en: '| **Mode** | **Description** |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| **模式** | **描述** |'
- en: '| --- | --- |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `''r''` | Read from a text file. Raise an exception if the file doesn’t exist.
    |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `''r''` | 从文本文件读取。如果文件不存在，抛出异常。 |'
- en: '| `''w''` | Write to a text file. Creates a new file, else overwrites existing
    files. |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `''w''` | 写入文本文件。创建一个新文件，否则覆盖现有文件。 |'
- en: '| `''x''` | Write to a text file but return an error if the file already exists.
    |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `''x''` | 写入文本文件，但如果文件已经存在，则返回错误。 |'
- en: '| `''a''` | Append to a text file. Create a new file if one doesn’t exist.
    |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `''a''` | 追加到文本文件。如果文件不存在，创建一个新文件。 |'
- en: '| `''r+''` | Permit read and write mode. |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `''r+''` | 允许读写模式。 |'
- en: '| `''b''` | Add to mode for binary files (such as `''rb''`). |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `''b''` | 为二进制文件（如 `''rb''`）添加模式。 |'
- en: The `open()` function returned a `File` object of type `_io.TextIOWrapper`.
    This is a type of object like a list or a tuple.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`open()` 函数返回了一个类型为 `_io.TextIOWrapper` 的 `File` 对象。这是一种类似于列表或元组的对象类型。'
- en: Now, let’s look at some of the file object methods for reading files ([Table
    12-5](ch12.xhtml#ch012tab5)). These are called on a file object using dot notation.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下读取文件的一些文件对象方法（[表 12-5](ch12.xhtml#ch012tab5)）。这些方法通过点号表示法调用文件对象。
- en: '**Table 12-5:** Selected File Object Methods and Attributes'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 12-5:** 选定的文件对象方法和属性'
- en: '| **Method** | **Description** |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** |'
- en: '| --- | --- |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `close()` | Close a file. |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `close()` | 关闭文件。 |'
- en: '| `closed` | Attribute that returns `True` if a file is closed. |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `closed` | 如果文件已关闭，则返回 `True`。 |'
- en: '| `read()` | Read the specified number of characters from a file and return
    a string. |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `read()` | 从文件中读取指定数量的字符并返回一个字符串。 |'
- en: '| `readline()` | Read the specified number of characters from a file and return
    a string. By default, return all characters from the current position to the end
    of a line. |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `readline()` | 从文件中读取指定数量的字符并返回一个字符串。默认情况下，从当前位置读取直到行末的所有字符。 |'
- en: '| `readlines()` | Read all the lines in a file and return them as items in
    a list. |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `readlines()` | 读取文件中的所有行并将它们作为列表项返回。 |'
- en: '| `seek()` | Change the position of the file pointer to a specific position
    within the file. |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `seek()` | 将文件指针的位置更改为文件中的特定位置。 |'
- en: '| `tell()` | Return the current position of the file read/write pointer within
    a file. |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `tell()` | 返回文件读/写指针在文件中的当前位置。 |'
- en: '| `write()` | Write the specified string to a file. |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `write()` | 将指定的字符串写入文件。 |'
- en: '| `writelines()` | Write the strings in a specified list to a file. |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `writelines()` | 将指定列表中的字符串写入文件。 |'
- en: Among the most important methods is `close()`. Closing files before terminating
    the process is a good practice. If you don’t close files, you could run out of
    file descriptors (numbers that uniquely identify open files in a computer’s operating
    system), lock the files from further access in Windows, corrupt the files, or
    lose data if you are writing to the files.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的方法之一是`close()`。在终止进程之前关闭文件是一种良好的实践。如果不关闭文件，可能会耗尽文件描述符（在计算机操作系统中唯一标识打开文件的数字），在Windows中锁定文件以防止进一步访问，导致文件损坏，或者在写入文件时丢失数据。
- en: 'To close a file, call `close()` using dot notation:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 要关闭文件，可以使用点符号调用`close()`方法：
- en: '[PRE18]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You can work with file objects only while they’re open. After a file object
    is closed, you can no longer work with it.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你只能在文件对象打开时进行操作。文件对象关闭后，不能再对其进行操作。
- en: 'Now, let’s look at ways to get the file contents. In the following console
    snippet, open the file again and use the `read()` method to read the first character.
    This method returns a `string` data type (remember, in the console you can use
    the up and down arrow keys to retrieve previous commands):'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下获取文件内容的方法。在下面的控制台代码片段中，再次打开文件并使用`read()`方法读取第一个字符。该方法返回一个`string`数据类型（记住，在控制台中你可以使用上下箭头键来检索之前的命令）：
- en: '[PRE19]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Passing the `read()` method the value `1` returned the first character in the
    file. But passing it `10` did not return the first 10 characters in the file.
    That’s because `read()` remembers where it left off. To find the current position
    in the file, use the `tell()` method:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 将`read()`方法传入`1`会返回文件中的第一个字符。但传入`10`却没有返回文件中的前10个字符。这是因为`read()`会记住它上次读取的位置。要查找文件中的当前位置，可以使用`tell()`方法：
- en: '[PRE20]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To manually change the position of the pointer in the file, pass the `seek()`
    method a number, as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 要手动改变文件中指针的位置，可以将一个数字传递给`seek()`方法，如下所示：
- en: '[PRE21]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: To restart at the beginning, you must either close and reopen the file or use
    `seek()` to return to the beginning.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 要从头开始，必须关闭并重新打开文件，或者使用`seek()`方法返回到文件的开头。
- en: 'If you don’t specify the number of characters to read, Python returns the entire
    file. This is not a problem for small files, but it can become an issue with very
    large files. To demonstrate reading the entire file, reopen the file and call
    the `read()` method with no arguments:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有指定要读取的字符数，Python会返回整个文件。这对于小文件来说没问题，但对于非常大的文件可能会成为问题。为了演示如何读取整个文件，请重新打开文件并调用没有参数的`read()`方法：
- en: '[PRE22]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Note that the file object includes the newline escape sequence (`\n`). This
    lets it know how to print the lines correctly:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，文件对象包含换行符转义序列（`\n`）。这让它知道如何正确地打印每一行：
- en: '[PRE23]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You can use the `readline()` method to read a line at a time, as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`readline()`方法一次读取一行，如下所示：
- en: '[PRE24]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this case, “lines” are defined by the presence of the newline escape sequence
    (`\n`). Like the `read()` function, `readline()` remembers where it left off,
    so to start back at the beginning, you must close and reopen the file.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，“行”由换行符转义序列（`\n`）定义。与`read()`函数类似，`readline()`会记住它上次读取的位置，因此要从头开始，必须关闭并重新打开文件。
- en: 'Be careful when you’re using `readline()`. Don’t assume that the value you
    pass it represents a line; it actually represents a character, just as with the
    `read()` method. In fact, you can duplicate the results from lines `In[48]-In[49]`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`readline()`时要小心。不要假设你传递给它的值代表一行；它实际上代表的是一个字符，就像`read()`方法一样。事实上，你可以重复`In[48]-In[49]`行的结果：
- en: '[PRE25]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To read in a whole file at once, you can use the `readlines()` method. Unlike
    the previous methods, which return strings, this method reads the file into a
    list. Each line in the file becomes a separate item in the list. Here’s an example:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 要一次性读取整个文件，可以使用`readlines()`方法。与之前的方法不同，它返回一个包含文件中每一行的列表，而不是字符串。文件中的每一行会成为列表中的一个单独项。以下是一个示例：
- en: '[PRE26]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Because the output is a list, you can get its length, iterate over it, and
    so on, as with any list:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 因为输出是一个列表，你可以获取它的长度，遍历它，等等，就像对待任何其他列表一样：
- en: '[PRE27]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the preceding methods, the end-of-line (EOL) markers are preserved. These
    are control characters used by character-encoding specifications such as ASCII
    to signify the end of a line of text. If you don’t want these, you can strip them
    out using list comprehension:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述方法中，行尾（EOL）标记被保留。这些是字符编码规范（如ASCII）使用的控制字符，用来表示一行文本的结束。如果你不希望保留这些标记，可以使用列表推导式将其去除：
- en: '[PRE28]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Compare the previous output to that in line `Out[71`.] The newline characters
    (`\n`) are gone. The `rstrip()` string method removes specified trailing characters
    from the right side of a string. If no character is specified, it removes any
    newline characters or whitespace at the end of a line.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 将之前的输出与`Out[71]`中的输出进行比较。换行符（`\n`）已经消失。`rstrip()`字符串方法会移除字符串右侧指定的尾随字符。如果没有指定字符，它会移除行尾的换行符或空白字符。
- en: '***Closing Files Using the with Statement***'
  id: totrans-207
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用with语句关闭文件***'
- en: 'Because closing files is so important (and easily overlooked), Python provides
    the `with` statement, which automatically closes files after a nested block of
    code. In this example, we load the text file using the `with` statement and the
    `open()` function, and then we use the `read()` method to get the complete contents
    of the file and assign them to the `lines` variable:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 由于关闭文件非常重要（且容易被忽视），Python提供了`with`语句，它在嵌套代码块执行完毕后会自动关闭文件。在这个示例中，我们使用`with`语句和`open()`函数加载文本文件，然后使用`read()`方法获取文件的完整内容，并将其赋值给`lines`变量：
- en: '[PRE29]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Whenever possible, try to use a `with` statement when opening files to ensure
    that the file is closed properly. To check that a file is closed, you can use
    its closed attribute, which returns `True` or `False`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 每当可能时，尝试在打开文件时使用`with`语句，以确保文件能够正确关闭。要检查文件是否关闭，可以使用它的`closed`属性，返回`True`或`False`：
- en: '[PRE30]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '***Writing to a Text File***'
  id: totrans-212
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***写入文本文件***'
- en: You can write a string to a text file using the `write()` and `writelines()`
    file object methods ([Table 12-5](ch12.xhtml#ch012tab5)). Let’s try this out using
    a haiku poem by yours truly.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`write()`和`writelines()`文件对象方法将字符串写入文本文件（参见[表12-5](ch12.xhtml#ch012tab5)）。让我们通过一首由我创作的俳句诗来试试这个方法。
- en: 'To write to a file, you first must open it using the write (`''w''`) file access
    mode (see [Table 12-4](ch12.xhtml#ch012tab4)). Enter the following in the console:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 要写入文件，首先必须使用写入（`'w'`）文件访问模式打开它（参见[表12-4](ch12.xhtml#ch012tab4)）。在控制台中输入以下内容：
- en: '[PRE31]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Calling `open()` on a file in write mode either creates a new file with the
    specified name (if one doesn’t exist) or completely overwrites an existing file
    with the same name, erasing its contents. In this case, we need only to enter
    a filename because we’re writing to the current working directory. To write elsewhere,
    you need to either change directories using the `chdir()` method or include a
    directory path with the filename.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在写入模式下调用`open()`打开文件时，如果指定的文件不存在，它将创建一个新文件；如果文件已经存在，它会完全覆盖该文件，删除其中的内容。在这种情况下，我们只需要输入文件名，因为我们是写入当前工作目录。如果要写入其他地方，你需要使用`chdir()`方法更改目录，或在文件名中包含目录路径。
- en: 'Now that we have a file object, we can write strings to it, using a newline
    character where we want carriage returns:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个文件对象，可以向其写入字符串，使用换行符来指定回车位置：
- en: '[PRE32]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The output represents the number of characters in each string, including the
    newline character. Closing the file at the end frees up system resources and prevents
    you from accidently writing more data to the file.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 输出表示每个字符串中的字符数，包括换行符。关闭文件可以释放系统资源，防止不小心向文件写入更多数据。
- en: 'Let’s check that it worked by using the `read()` method:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用`read()`方法来检查是否成功：
- en: '[PRE33]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Remember, when you open a file using the `with` statement, it closes automatically.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，当你使用`with`语句打开文件时，它会自动关闭。
- en: 'Entering lines one by one is tedious. The `writelines()` method lets you *write*
    a list of strings into a file, much like the `readlines()` method offers the ability
    to *read* a text file into a list. The following example creates a new haiku as
    a list, overwrites the existing *haiku.txt* file, writes the list to the file
    and then reads the file:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 一行一行地输入非常繁琐。`writelines()`方法允许你*写入*一个字符串列表到文件，就像`readlines()`方法提供了将文本文件*读取*为列表的能力。以下示例创建了一个新的俳句列表，覆盖了现有的*haiku.txt*文件，将该列表写入文件，然后读取该文件：
- en: '[PRE34]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Oops, we forgot to attribute the haiku to the master Issa. No problem. With
    the append (`''a''`) file access mode, you can add strings to an existing text
    file without overwriting the original contents:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀，我们忘记给俳句注明出处了——是大诗人一茶。没关系，使用追加（`'a'`）文件访问模式，您可以将字符串添加到现有的文本文件中，而不会覆盖原有内容：
- en: '[PRE35]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You can also use `writelines()` to generate new file contents on the fly, as
    follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用 `writelines()` 来动态生成新的文件内容，如下所示：
- en: '[PRE36]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In this example, we filtered the `poem` list so that only lines beginning with
    `C` were written to the new file.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们过滤了 `poem` 列表，仅将以 `C` 开头的行写入新文件。
- en: '***Reading and Writing Text Files Using pathlib***'
  id: totrans-230
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 pathlib 读取和写入文本文件***'
- en: The `Path` class of the `pathlib` module also provides methods for working with
    files and folders ([Table 12-6](ch12.xhtml#ch012tab6)). These methods incorporate
    built-in functions like `open()` and can make simple reading and writing exercises
    more convenient (assuming that you like working with path objects).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`pathlib` 模块的 `Path` 类还提供了处理文件和文件夹的方法（见 [表12-6](ch12.xhtml#ch012tab6)）。这些方法结合了像
    `open()` 这样的内置函数，可以让简单的读写操作变得更方便（假设您喜欢使用路径对象）。'
- en: '**Table 12-6:** Some Useful `Path` Methods for Working with Files and Folders'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '**表12-6：** 一些用于处理文件和文件夹的有用 `Path` 方法'
- en: '| **Method** | **Description** |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** |'
- en: '| --- | --- |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Path.glob()` | Yield all matchings files for a given pattern (such as *.py)
    |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| `Path.glob()` | 根据给定模式（如 *.py）返回所有匹配的文件 |'
- en: '| `Path.is_file()` | Return `True` if given path points to a regular file (or
    symbolic link) |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| `Path.is_file()` | 如果给定路径指向常规文件（或符号链接），则返回 `True` |'
- en: '| `Path.open()` | Open a file based on name or path + name |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| `Path.open()` | 根据文件名或路径+文件名打开文件 |'
- en: '| `Path.read_bytes()` | Return the contents of a given file as a bytes object
    |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| `Path.read_bytes()` | 返回给定文件的内容作为字节对象 |'
- en: '| `Path.read_text()` | Return the contents of a given file as a string and
    close the file |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| `Path.read_text()` | 返回给定文件的内容作为字符串并关闭文件 |'
- en: '| `Path.rename()` | Rename a file or directory and return new path |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| `Path.rename()` | 重命名文件或目录并返回新路径 |'
- en: '| `Path.replace()` | Rename a file or directory unconditionally and return
    new path |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| `Path.replace()` | 无条件重命名文件或目录并返回新路径 |'
- en: '| `Path.touch()` | Create a file at the given path |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| `Path.touch()` | 在给定路径创建一个文件 |'
- en: '| `Path.write_text()` | Open a specified file in text mode, write to it, and
    then close the file |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| `Path.write_text()` | 以文本模式打开指定文件，写入内容，然后关闭文件 |'
- en: 'The `Path.read_text()` method calls `open()` behind the scenes and returns
    a file’s contents as a string. It also closes the file automatically, like the
    `with` statement. Here’s an example in the console using the *lines.txt* file
    from earlier in the chapter:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`Path.read_text()` 方法在后台调用 `open()`，并将文件的内容作为字符串返回。它还会像 `with` 语句一样自动关闭文件。以下是使用章节中早些时候提到的
    *lines.txt* 文件的控制台示例：'
- en: '[PRE37]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note that you first must create a path object (`p`). For users unfamiliar with
    `pathlib`, this can be confusing compared to the more tradition file-opening techniques
    reviewed in the previous section.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您必须首先创建一个路径对象（`p`）。对于不熟悉 `pathlib` 的用户来说，相较于上一节回顾的传统文件打开方法，这可能会让人感到困惑。
- en: 'Now, let’s create a file in the `test1` folder and write to it using `Path`.
    In the console, enter the following:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在 `test1` 文件夹中创建一个文件并使用 `Path` 向其中写入内容。在控制台中输入以下内容：
- en: '[PRE38]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `Path.write_text()` method takes a string as an argument. Like `open()`,
    it will overwrite an existing file with the same name. Unlike `open()`, it doesn’t
    permit use of an append mode. It will, however, close the file automatically.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`Path.write_text()` 方法接受一个字符串作为参数。与 `open()` 类似，它会覆盖具有相同名称的现有文件。与 `open()`
    不同，它不允许使用追加模式。然而，它会自动关闭文件。'
- en: You can read more about `pathlib` at *[https://docs.python.org/3/library/pathlib.html](https://docs.python.org/3/library/pathlib.html)*.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 *[https://docs.python.org/3/library/pathlib.html](https://docs.python.org/3/library/pathlib.html)*
    上阅读更多关于 `pathlib` 的内容。
- en: '**TEST YOUR KNOWLEDGE**'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试你的知识**'
- en: 6.  Which statements or methods close a text file?
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 6.  哪些语句或方法会关闭文本文件？
- en: a.  The `with` statement
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: a.  `with` 语句
- en: b.  The `Path.read_text()` method
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: b.  `Path.read_text()` 方法
- en: c.  The `Path.write_text()` method
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: c.  `Path.write_text()` 方法
- en: d.  The `close()` method
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: d.  `close()` 方法
- en: e.  All of the above
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: e.  上述所有方法
- en: 7.  Rename the *another_haiku.txt* file created in the previous section to *haiku_2.txt*.
    Use either the `os` or `pathlib` modules.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 7.  将上一节中创建的 *another_haiku.txt* 文件重命名为 *haiku_2.txt*。使用 `os` 或 `pathlib` 模块。
- en: 8.  Print the *haiku.txt* file starting at the 15th character.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 8.  从第15个字符开始打印 *haiku.txt* 文件。
- en: 9.  Which file-access mode is used to add text to an existing text file?
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 9.  用于向现有文本文件添加文本的文件访问模式是什么？
- en: a.  `w`
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: a.  `w`
- en: b.  `r`
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: b.  `r`
- en: c.  `a`
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: c.  `a`
- en: d.  `b`
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: d.  `b`
- en: '10.  True or false: The `os.writelines()` method writes a list to a file; the
    `Path.write_text()` method writes a string to a file.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 10.  真或假：`os.writelines()`方法将列表写入文件；`Path.write_text()`方法将字符串写入文件。
- en: '**Working with Complex Data**'
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**处理复杂数据**'
- en: Text files are convenient and popular, but they’re hardly the only game in town.
    The various file-writing methods we’ve reviewed so far accept only strings, or
    lists of strings, as input. But Python includes many different data types, such
    as dictionaries, that you’ll use in your everyday work, and you’ll need a way
    to save these, as well.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 文本文件方便且流行，但这并不是唯一的选择。我们迄今为止审查的各种文件写入方法仅接受字符串或字符串列表作为输入。但Python包含许多不同的数据类型，例如字典，在您的日常工作中会用到，因此您需要一种方法来保存这些数据。
- en: To save these other data types, you need to use *data serialization*. This process
    converts structured data such as a Python dictionary into a storable and sharable
    format. This format retains the information needed to reconstruct the object in
    memory when it’s read from storage or transmitted. This process is called *de-serialization*.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 要保存这些其他数据类型，您需要使用*数据序列化*。此过程将结构化数据（例如Python字典）转换为可存储和共享的格式。当从存储中读取时，此格式保留了重建对象所需的信息。这个过程称为*反序列化*。
- en: In this section, we’ll look at modules, like `pickle` and `json`, that serialize
    and deserialize data. The `pickle` module is Python’s native serialization module.
    It converts objects into an ordered sequence of bytes (0s and 1s) known as a *byte
    stream*. Pickling and unpickling allow us to easily transfer data from one server
    or system to another and then store it in a file or database.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看像`pickle`和`json`这样的模块，这些模块用于序列化和反序列化数据。`pickle`模块是Python的本地序列化模块。它将对象转换为一系列有序的字节（0和1），称为*字节流*。通过pickling和unpickling，我们可以轻松地将数据从一个服务器或系统传输到另一个，并将其存储在文件或数据库中。
- en: The `json` module converts Python objects to a serialized representation known
    as *JavaScript Object Notation*, or *JSON* for short, and deserializes them on
    demand. We used `json` for pretty-printing dictionaries back in [Chapter 9](ch09.xhtml).
    It works with just about every language.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`json`模块将Python对象转换为一种称为*JavaScript对象表示法*（简称*JSON*）的序列化表示形式，并根据需要进行反序列化。我们在[第9章](ch09.xhtml)中用`json`来美化打印字典。它适用于几乎所有的编程语言。'
- en: These two modules have their strengths and weaknesses ([Table 12-7](ch12.xhtml#ch012tab7)).
    Pickling works on most Python objects and data types, whereas JSON is limited
    to certain objects and data types.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个模块各有其优势和劣势（见[表12-7](ch12.xhtml#ch012tab7)）。Pickling适用于大多数Python对象和数据类型，而JSON仅限于某些对象和数据类型。
- en: '**Table 12-7:** Pickle vs. JSON for Serialization'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '**表12-7：** Pickle vs. JSON序列化比较'
- en: '| **Characteristic** | **Pickle** | **JSON** |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| **特性** | **Pickle** | **JSON** |'
- en: '| --- | --- | --- |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Storage format | Byte stream | Human-readable string object |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| 存储格式 | 字节流 | 人类可读的字符串对象 |'
- en: '| Python objects | All objects | Limited to certain objects |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| Python对象 | 所有对象 | 仅限于某些对象 |'
- en: '| Python data types | Almost every data type | Only lists, dictionaries, nulls,
    Booleans, numbers, strings, arrays, and JSON objects |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| Python数据类型 | 几乎所有数据类型 | 仅限于列表、字典、空值、布尔值、数字、字符串、数组和JSON对象 |'
- en: '| Compatibility | Python only | Language independent |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| 兼容性 | 仅限Python | 语言无关 |'
- en: '| Speed | Relatively Slow | Relatively fast |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| 速度 | 相对较慢 | 相对较快 |'
- en: '| Security | Has security issues | Safe and secure |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| 安全性 | 存在安全问题 | 安全可靠 |'
- en: '**NOTE**'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Pickling is less secure than using JSON. You should be very careful about
    unpickling data from an unknown source, as it may contain malicious data. Pickling
    is also intended for relatively short-term data storage because revisions to the
    module might not always be backward compatible.*'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '*Pickling不如使用JSON安全。您应该非常小心地从未知来源unpickle数据，因为它可能包含恶意数据。Pickling也适用于相对短期的数据存储，因为模块的修订可能不总是向后兼容的。*'
- en: '***Pickling Data***'
  id: totrans-283
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Pickling数据***'
- en: To pickle something means to preserve it. The `pickle` module (*[https://docs.python.org/3/library/pickle.html](https://docs.python.org/3/library/pickle.html)*)
    pickles Python data objects in binary files. Unlike text files, humans cannot
    read binary files.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: Pickle意味着保存某物。`pickle`模块（*[https://docs.python.org/3/library/pickle.html](https://docs.python.org/3/library/pickle.html)*）将Python数据对象pickle成二进制文件。与文本文件不同，人类无法读取二进制文件。
- en: Pickling is a lot like writing strings to a file, only you write pickled objects.
    The access modes are the same except for the addition of a `'b'` for “binary”
    ([Table 12-8](ch12.xhtml#ch012tab8)).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化就像将字符串写入文件，只不过你写的是序列化对象。访问模式是相同的，只是增加了一个`'b'`表示“二进制”（[表 12-8](ch12.xhtml#ch012tab8)）。
- en: '**Table 12-8:** Selected Binary File Access Modes'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 12-8:** 选择的二进制文件访问模式'
- en: '| **Mode** | **Description** |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| **模式** | **描述** |'
- en: '| --- | --- |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `''rb''` | Read from a binary file. |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| `''rb''` | 从二进制文件中读取。 |'
- en: '| `''wb''` | Write to a binary file. Create or overwrite file, as required.
    |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| `''wb''` | 写入二进制文件。根据需要创建或覆盖文件。 |'
- en: '| `''ab''` | Append to a binary file. Create or modify file, as required. |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| `''ab''` | 追加到二进制文件。根据需要创建或修改文件。 |'
- en: 'Let’s pickle some lists. In the console, enter the following:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来序列化一些列表。在控制台中输入以下内容：
- en: '[PRE39]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: After importing the `pickle` module and creating two dragon lists, we opened
    a new binary file called *dragons.dat*. Next, we stored the two lists in this
    file using the `pickle.dump()` function, passing it the name of the list and the
    name of the file object as arguments. Finally, we closed the file (you should
    see it in your *file_play* folder).
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入`pickle`模块并创建了两个龙的列表后，我们打开了一个名为*dragons.dat*的新二进制文件。接着，我们使用`pickle.dump()`函数将这两个列表存储到该文件中，传递给它列表的名称和文件对象的名称作为参数。最后，我们关闭了文件（你应该能在*file_play*文件夹中看到它）。
- en: 'The `pickle.dump()` function wrote each list to the file as a separate object.
    To retrieve these objects, we open the file again, in binary mode, and call the
    `pickle.load()` function, as follows:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`pickle.dump()`函数将每个列表作为单独的对象写入文件。为了检索这些对象，我们再次以二进制模式打开文件，并调用`pickle.load()`函数，如下所示：'
- en: '[PRE40]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `pickle.load()` function accepts the file object as an argument and returns
    (or unpickles) the first pickled object, assigning it to the variable `dragon_prefix`.
    The next call to `pickle.load()` returns the next pickled object. One thing to
    note here is that you don’t need to know the original names of the lists (like
    “dragon_prefix”) to extract the data. You could have called these “poodledoodle”
    and “snickerdoodle,” and you would have retrieved the same lists in the same order.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`pickle.load()`函数接受文件对象作为参数，并返回（或反序列化）第一个序列化对象，将其赋值给变量`dragon_prefix`。下一次调用`pickle.load()`将返回下一个序列化对象。这里需要注意的一点是，你不需要知道列表的原始名称（如“dragon_prefix”）就可以提取数据。你可以将它们命名为“poodledoodle”和“snickerdoodle”，你依然会以相同的顺序检索到相同的列表。'
- en: But what if you want to retrieve the pickled objects in some other order, such
    as retrieving only the dragon suffixes? For that, you’ll need the `shelve` module,
    which takes pickling a step further.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果你想按其他顺序检索序列化的对象，例如只检索龙的后缀怎么办？为此，你需要使用`shelve`模块，它将序列化进一步扩展。
- en: '***Shelving Pickled Data***'
  id: totrans-299
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***存储序列化数据***'
- en: A *database* is a special file for storing data. Most databases resemble Python
    dictionaries, in that they map keys to values. Unlike a dictionary, however, databases
    persist after a program ends.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '*数据库*是一个用于存储数据的特殊文件。大多数数据库类似于Python字典，因为它们将键映射到值。然而，与字典不同的是，数据库在程序结束后依然会保持数据。'
- en: Python comes with the `dbm` module for creating and updating database files.
    This module has a limitation, though, as its keys and values must be either strings
    or bytes. The pickle module helps overcome this limitation by transforming multiple
    data types into strings suitable for use in a database.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: Python配有`dbm`模块，用于创建和更新数据库文件。然而，这个模块有一个限制，它的键和值必须是字符串或字节。`pickle`模块通过将多种数据类型转换为适合在数据库中使用的字符串，帮助克服了这个限制。
- en: Because the need to store non-string objects in a database is so common, the
    functionality has been incorporated into a module called `shelve` that helps you
    store and access pickled objects in a file. It builds on `pickle` and implements
    a serialization dictionary in which objects are pickled with an associated key,
    composed of strings. The keys let you load your shelved data file and randomly
    access the values, composed of pickled objects.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 由于需要在数据库中存储非字符串对象的需求非常常见，这一功能已被整合到一个名为`shelve`的模块中，帮助你在文件中存储和访问被序列化的对象。它建立在`pickle`的基础上，实现了一个序列化字典，其中对象通过一个与之关联的键（由字符串组成）进行序列化。这些键让你能够加载已存储的数据文件，并随机访问由序列化对象组成的值。
- en: The `shelve` module produces a *shelf*, which is a persistent, dictionary-like
    object. Although it’s possible to directly pickle a dictionary, using the `shelve`
    module is more memory efficient.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`shelve`模块生成一个*架子*，它是一个持久化的、类似字典的对象。尽管可以直接序列化字典，但使用`shelve`模块在内存使用上更高效。'
- en: '**NOTE**'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Because this process involves the pickle module, loading a shelf can execute
    unexpected code, so it’s unsafe to load a shelf from an untrusted source.*'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '*因为这个过程涉及到 pickle 模块，加载一个架子可能会执行意外的代码，所以从不可信来源加载架子是非常不安全的。*'
- en: 'Let’s look at how shelving works using the dragon data from the previous section:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下如何使用上一节的龙数据来实现数据存储：
- en: '[PRE41]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: After importing the module, we used the `shelve.open()` method to create a new
    shelf named `dragon_shelf` in the current working directory, assigned it to the
    variable `s`, and then got the data type of `s`. To create the shelf, we used
    the `'c'` access mode. Other `shelve` access modes are listed in [Table 12-9](ch12.xhtml#ch012tab9).
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入模块后，我们使用了 `shelve.open()` 方法，在当前工作目录中创建了一个名为 `dragon_shelf` 的新架子，并将其赋值给变量
    `s`，然后获取了 `s` 的数据类型。为了创建这个架子，我们使用了 `'c'` 访问模式。其他 `shelve` 访问模式可以在 [表 12-9](ch12.xhtml#ch012tab9)
    中查看。
- en: '**Table 12-9:** Shelve Access Modes'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 12-9：** Shelve 访问模式'
- en: '| **Mode** | **Description** |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| **模式** | **描述** |'
- en: '| --- | --- |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `''c''` | Open a shelf for reading and writing, creating it if necessary
    |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| `''c''` | 打开一个架子，支持读写操作，必要时创建该架子 |'
- en: '| `''n''` | Create a new, empty shelf open for reading and writing, overwriting
    if needed |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| `''n''` | 创建一个新的、空的架子，支持读写操作，如果需要可以覆盖 |'
- en: '| `''r''` | Open an existing shelf for reading only |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| `''r''` | 打开一个现有的架子，仅支持读取操作 |'
- en: '| `''w''` | Open an existing shelf for reading and writing |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| `''w''` | 打开一个现有的架子，支持读写操作 |'
- en: Now, let’s add the dragon data to the shelf using a key-value combination. This
    will pickle the data behind the scenes. Although we create the list here, we could
    just as easily use a variable name assigned to a list, as we did in the earlier
    `pickle.dump()` example.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过键值组合将龙的数据添加到架子上。这会在后台对数据进行序列化。虽然我们在这里创建了列表，但我们也可以像在前面的 `pickle.dump()`
    示例中那样，直接使用赋值给列表的变量名。
- en: '[PRE42]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Closing the shelf *synchronizes* the data by ensuring that any data in the memory
    cache, or buffer, is written to the disk. It then releases system resources by
    clearing the cache.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭架子会 *同步* 数据，确保任何在内存缓存或缓冲区中的数据被写入磁盘。然后，它通过清除缓存来释放系统资源。
- en: Two things to note here are that `shelve` will automatically add a *.dat* extension
    to the filename, and it will create additional files that support the shelf (highlighted
    in gray in [Figure 12-4](ch12.xhtml#ch012fig4)). These additional files are operating
    system specific. On macOS, for example, you might see only a file named *dragon_shelf.db*.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两点需要注意：`shelve` 会自动在文件名后添加 *.dat* 扩展名，并且会创建额外的支持文件（在 [图 12-4](ch12.xhtml#ch012fig4)
    中以灰色高亮显示）。这些额外的文件是操作系统特定的。例如，在 macOS 上，你可能只会看到一个名为 *dragon_shelf.db* 的文件。
- en: '![Image](../images/12fig04.jpg)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/12fig04.jpg)'
- en: '*Figure 12-4: Files related to dragon_shelf in Windows*'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-4：Windows 中与 dragon_shelf 相关的文件*'
- en: '**NOTE**'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Binary files in Spyder’s File Explorer include “01” on the file icon. The
    text file icon uses two straight lines.*'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '*在 Spyder 的文件资源管理器中，二进制文件图标会显示 “01”。文本文件图标则使用两条直线。*'
- en: 'Now, let’s reopen the shelf and retrieve some data:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们重新打开架子并检索一些数据：
- en: '[PRE43]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: After opening the *dragon_shelf* file in read-only mode, you can see that the
    `prefix` key refers to a `list` object. You can also print the `suffix` list first,
    despite it being the second list loaded into the shelf. Compare this to the `pickle.load()`
    method from the previous section, which returns pickled objects in order.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在以只读模式打开 *dragon_shelf* 文件后，你可以看到 `prefix` 键对应的是一个 `list` 对象。你还可以先打印出 `suffix`
    列表，尽管它是第二个加载到架子上的列表。将这个与前一节中的 `pickle.load()` 方法进行比较，后者按顺序返回被序列化的对象。
- en: '**Closing Shelves Using the with Statement**'
  id: totrans-327
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用 with 语句关闭架子**'
- en: 'Shelving a large volume of data can use a lot of memory, so it’s important
    to close a shelf when you’re finished. Because this easily can be overlooked,
    Python lets you use the `with` statement when opening shelves so that the files
    automatically close after some action. Here’s an example:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 储存大量数据可能会占用很多内存，因此在完成操作后，关闭架子是非常重要的。由于这很容易被忽视，Python 允许你在打开架子时使用 `with` 语句，以便在某些操作后自动关闭文件。下面是一个示例：
- en: '[PRE44]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Because the `with` statement closed the shelf after its block executed, subsequent
    actions on `s` will raise a `ValueError`:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `with` 语句在代码块执行后关闭了架子，后续对 `s` 的操作将会抛出 `ValueError` 错误：
- en: '[PRE45]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '**Using Shelve Methods**'
  id: totrans-332
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用 Shelve 方法**'
- en: Shelf objects support most of methods and operations supported by dictionaries
    ([Table 12-10](ch12.xhtml#ch012tab10)). This is by design and is intended to ease
    the transition from dictionary-based scripts to those requiring persistent storage.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 架子对象支持字典支持的大多数方法和操作（[表 12-10](ch12.xhtml#ch012tab10)）。这是设计使然，旨在简化从基于字典的脚本过渡到需要持久存储的脚本。
- en: 'If you forget the key names in a shelf or if you’re using a shelf that you
    didn’t create, you can use the `keys()` method to retrieve the names. Note that
    you need to convert the output into a list with the `list()` function:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您忘记了架子中的键名称，或者使用的是您未创建的架子，您可以使用`keys()`方法来检索这些名称。请注意，您需要使用`list()`函数将输出转换为列表：
- en: '[PRE46]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '**Table 12-10:** Shelve Module Methods'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 12-10：** Shelve模块方法'
- en: '| **Method** | **Description** |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** |'
- en: '| --- | --- |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `close()` | Synchronize and close the shelf object |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '| `close()` | 同步并关闭架子对象 |'
- en: '| `get()` | Return shelf values associated with a key |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '| `get()` | 返回与键相关的架子值 |'
- en: '| `items()` | Return shelf key-value pairs as tuples |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '| `items()` | 返回架子的键值对元组 |'
- en: '| `keys()` | Return list of shelf keys |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '| `keys()` | 返回架子的键列表 |'
- en: '| `pop()` | Remove specified shelf key and return associated shelf value |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '| `pop()` | 删除指定的架子键并返回关联的架子值 |'
- en: '| `sync()` | Write back all entries in the cache if shelf was opened with writeback
    set to `True` |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| `sync()` | 如果架子（shelf）在开启时设置了`True`的写回（writeback），则将所有缓存中的条目写回 |'
- en: '| `update()` | Update shelf from another dict or iterable |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| `update()` | 从另一个字典或可迭代对象更新架子 |'
- en: '| `values()` | Return list of shelf values |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| `values()` | 返回架子的所有值列表 |'
- en: 'Some other methods return an iterable that you can loop over. Here’s an example
    using the `items()` method, which returns the key-value pairs as tuples:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 其他一些方法会返回一个可迭代对象，您可以循环遍历。以下是一个使用`items()`方法的示例，该方法返回键值对元组：
- en: '[PRE47]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Printing the output yielded an object name, not the key-value pairs that you
    probably expected. To get the key-value tuples, loop over the output, as follows:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 打印输出时显示的是一个对象名称，而不是您可能预期的键值对。要获取键值元组，请循环遍历输出，如下所示：
- en: '[PRE48]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: You can read more about `shelve` and its methods at *[https://docs.python.org/3/library/shelve.html](https://docs.python.org/3/library/shelve.html)*.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在*[https://docs.python.org/3/library/shelve.html](https://docs.python.org/3/library/shelve.html)*上阅读更多关于`shelve`及其方法的内容。
- en: '***Storing Data with JSON***'
  id: totrans-352
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用JSON存储数据***'
- en: 'Using the `json` module (*[https://docs.python.org/3/library/json.html](https://docs.python.org/3/library/json.html)*),
    you can store data as a single human-readable string. Here’s an example of a Python
    dictionary stored in JSON format:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`json`模块（*[https://docs.python.org/3/library/json.html](https://docs.python.org/3/library/json.html)*），您可以将数据存储为一个单一的人类可读的字符串。以下是一个以JSON格式存储的Python字典示例：
- en: '′{″key1″: ″value1″, ″key2″: ″value2″, ″key3″: ″value3″}′'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '′{″key1″: ″value1″, ″key2″: ″value2″, ″key3″: ″value3″}′'
- en: 'It looks just like a regular Python dictionary except for one thing: it’s enclosed
    in single quotes, making the whole thing a string.'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来就像一个常规的Python字典，唯一的不同是：它被单引号包围，这使得整个内容成为一个字符串。
- en: Compared to `pickle` and `shelve`, the `json` module offers a faster and more
    secure way to store and retrieve complex Python data types. It supports fewer
    data types than `pickle`, however, because it’s limited to dictionaries, lists,
    nulls, Boolean values, numbers (integers and floats), strings, and JSON objects.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 与`pickle`和`shelve`相比，`json`模块提供了一种更快速且更安全的方式来存储和检索复杂的Python数据类型。然而，它支持的数据类型比`pickle`少，因为它仅限于字典、列表、空值、布尔值、数字（整数和浮点数）、字符串和JSON对象。
- en: JSON will also help you access information on the worldwide web. As a lightweight
    data-interchange format that’s easy for humans to read and for machines to parse,
    the application programming interfaces (APIs) for many websites pass data using
    JSON format.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: JSON还可以帮助您访问全球范围内的信息。作为一种轻量级的数据交换格式，既便于人类阅读，又便于机器解析，许多网站的应用程序接口（API）使用JSON格式传递数据。
- en: '**Saving Data in JSON Format**'
  id: totrans-358
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**以JSON格式保存数据**'
- en: 'To see how `json` works, let’s create a Python dictionary for the crew capacity
    of three famous spacecraft and save it in JSON format. Enter the following in
    the console:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看`json`如何工作，首先创建一个包含三艘著名宇宙飞船乘员容量的Python字典，并以JSON格式保存。请在控制台输入以下内容：
- en: '[PRE49]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `json.dumps()` method turns the dictionary into a JSON string. You can write
    JSON strings to persistent files using the `open()` function in write mode, as
    you’ve done before. The new *capsules_data.json* file should show up in the Spyder
    File Explorer pane ([Figure 12-5](ch12.xhtml#ch012fig5)).
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '`json.dumps()` 方法将字典转换为 JSON 字符串。你可以像之前一样使用 `open()` 函数以写入模式将 JSON 字符串写入持久化文件。新的
    *capsules_data.json* 文件应该会出现在 Spyder 文件资源管理器窗格中（[图 12-5](ch12.xhtml#ch012fig5)）。'
- en: '![Image](../images/12fig05.jpg)'
  id: totrans-362
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/12fig05.jpg)'
- en: '*Figure 12-5: The capsules_data.json file in the File Explorer pane*'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-5：文件资源管理器窗格中的 capsules_data.json 文件*'
- en: Note how Spyder uses a special icon to denote the file. Because it’s human-readable,
    you can open it and read its contents just like a text file.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意 Spyder 如何使用特殊图标表示文件。由于它是人类可读的，你可以像打开文本文件一样打开它并阅读其内容。
- en: '**Loading Data in JSON Format**'
  id: totrans-365
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**以 JSON 格式加载数据**'
- en: 'Now, let’s open, load, and use the JSON file. We’ll continue to work in the
    console, but this following example could easily be done in a saved program written
    in a text editor or Jupyter Notebook:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们打开、加载并使用 JSON 文件。我们将继续在控制台中工作，但以下示例也可以很容易地在文本编辑器或 Jupyter Notebook 中编写的已保存程序中完成：
- en: '[PRE50]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '**Saving Tuples in JSON Format**'
  id: totrans-368
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**以 JSON 格式保存元组**'
- en: 'There is no concept of a tuple in the JSON format. If you save a tuple in JSON
    format, you’ll receive a list. In the console, enter the following to see an example:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JSON 格式中没有元组的概念。如果你将元组保存为 JSON 格式，你将得到一个列表。在控制台中，输入以下内容来查看示例：
- en: '[PRE51]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In simple cases, you can handle this by converting the output back into a tuple:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在简单的情况下，你可以通过将输出转换回元组来处理：
- en: '[PRE52]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: For more sophisticated cases, you’ll want to do an online search for using tuples
    with JSON.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更复杂的情况，你可能需要在线搜索如何在 JSON 中使用元组。
- en: '***Catching Exceptions When Opening Files***'
  id: totrans-374
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***打开文件时捕获异常***'
- en: Reading and writing files falls under the category of user interactions, and
    as we saw in [Chapter 10](ch10.xhtml), a lot of things can go wrong when users
    get involved. For working with files, these include trying to open files or use
    paths that don’t exist, trying to open files or folders without the proper permissions,
    trying to open a folder instead of a file, and so on.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 读取和写入文件属于用户交互范畴，正如我们在[第 10 章](ch10.xhtml)中看到的，用户参与时很多事情可能会出错。处理文件时，这些错误包括尝试打开不存在的文件或路径、没有适当权限尝试打开文件或文件夹、尝试打开文件夹而不是文件等等。
- en: These problems can’t be fixed within your code, but you can catch these exceptions
    and provide the user with some helpful advice, rather than allow the program to
    crash and spew gobbledygook all over the screen.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题无法在你的代码中修复，但你可以捕获这些异常并提供一些有用的建议，而不是让程序崩溃并在屏幕上乱七八糟地输出错误信息。
- en: Most of the common file-loading errors fall under the operating system exception
    class called `OSError`. These include the errors shown in [Table 12-11](ch12.xhtml#ch012tab11).
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数常见的文件加载错误属于操作系统异常类 `OSError`。这些错误包括[表 12-11](ch12.xhtml#ch012tab11)中显示的错误。
- en: '**Table 12-11:** Common Errors Associated with File Loading'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 12-11：** 与文件加载相关的常见错误'
- en: '| **Class** | **Subclass** |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
  zh: '| **类别** | **子类** |'
- en: '| --- | --- |'
  id: totrans-380
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `BlockingIOError` |  |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
  zh: '| `BlockingIOError` |  |'
- en: '| `ChildProcessError` |  |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
  zh: '| `ChildProcessError` |  |'
- en: '| `ConnectionError` | `BrokenPipeError` |'
  id: totrans-383
  prefs: []
  type: TYPE_TB
  zh: '| `ConnectionError` | `BrokenPipeError` |'
- en: '| `ConnectionError` | `ConnectionAbortedError` |'
  id: totrans-384
  prefs: []
  type: TYPE_TB
  zh: '| `ConnectionError` | `ConnectionAbortedError` |'
- en: '| `ConnectionError` | `ConnectionRefusedError` |'
  id: totrans-385
  prefs: []
  type: TYPE_TB
  zh: '| `ConnectionError` | `ConnectionRefusedError` |'
- en: '| `ConnectionError` | `ConnectionResetError` |'
  id: totrans-386
  prefs: []
  type: TYPE_TB
  zh: '| `ConnectionError` | `ConnectionResetError` |'
- en: '| `FileExistsError` |  |'
  id: totrans-387
  prefs: []
  type: TYPE_TB
  zh: '| `FileExistsError` |  |'
- en: '| `FileNotFoundError` |  |'
  id: totrans-388
  prefs: []
  type: TYPE_TB
  zh: '| `FileNotFoundError` |  |'
- en: '| `InterruptedError` |  |'
  id: totrans-389
  prefs: []
  type: TYPE_TB
  zh: '| `InterruptedError` |  |'
- en: '| `IsADirectoryError` |  |'
  id: totrans-390
  prefs: []
  type: TYPE_TB
  zh: '| `IsADirectoryError` |  |'
- en: '| `NotADirectoryError` |  |'
  id: totrans-391
  prefs: []
  type: TYPE_TB
  zh: '| `NotADirectoryError` |  |'
- en: '| `PermissionError` |  |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
  zh: '| `PermissionError` |  |'
- en: '| `ProcessLookupError` |  |'
  id: totrans-393
  prefs: []
  type: TYPE_TB
  zh: '| `ProcessLookupError` |  |'
- en: '| `TimeOutError` |  |'
  id: totrans-394
  prefs: []
  type: TYPE_TB
  zh: '| `TimeOutError` |  |'
- en: Here’s an example in which we use `OSError` to catch the exception thrown by
    a nonexistent file (*fluffybunnyfeet.lol*). For a refresher on using `try` and
    `except`, see [Chapter 10](ch10.xhtml).
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例，我们使用 `OSError` 捕获一个不存在的文件（*fluffybunnyfeet.lol*）引发的异常。有关使用 `try` 和 `except`
    的复习，请参见[第 10 章](ch10.xhtml)。
- en: '[PRE53]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The `except` clause printed a useful message informing the user that the file
    doesn’t exist (as this was a `FileNotFoundError`). The `finally` clause let the
    user know that the file loading process has terminated. Note that the `finally`
    block executes regardless of the outcome, whereas the `else` code block executes
    only for a successful outcome.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '`except` 子句打印了一条有用的信息，告知用户文件不存在（这是一个 `FileNotFoundError`）。`finally` 子句则通知用户文件加载过程已经结束。请注意，`finally`
    块无论结果如何都会执行，而 `else` 代码块只会在操作成功时执行。'
- en: 'Here’s an example of a successful outcome using the *haiku.txt* file that we
    created earlier:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个成功使用我们之前创建的*haiku.txt*文件的示例：
- en: '[PRE54]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: For more on Python’s built-in exceptions, visit the documentation at *[https://docs.python.org/3/library/exceptions.html](https://docs.python.org/3/library/exceptions.html).*
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多关于 Python 内置异常的内容，请访问文档：[https://docs.python.org/3/library/exceptions.html](https://docs.python.org/3/library/exceptions.html)。
- en: '***Other Storage Solutions***'
  id: totrans-401
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***其他存储解决方案***'
- en: If your data is sufficiently complex, it might require more powerful storage
    solutions. The *eXtensible Markup Language (XML)* is designed to store and transport
    small to medium amounts of data and is widely used for sharing structured information.
    *YAML* is another human-readable data-serialization language used for configuration
    files and in applications where data is being stored or transmitted. It has a
    minimal syntax compared to XML. *SQLite* is a lightweight database that can provide
    a relational database management system with zero-configuration. *Hierarchical
    Data Format (HDF5)* is for storing large volumes of scientific array data. Covering
    these storage systems is beyond the scope of this book, but you can find copious
    information for each online.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的数据足够复杂，可能需要更强大的存储解决方案。*可扩展标记语言（XML）* 旨在存储和传输小到中等规模的数据，并广泛用于共享结构化信息。*YAML*
    是另一种人类可读的数据序列化语言，常用于配置文件和数据存储或传输的应用中。与 XML 相比，它具有更简洁的语法。*SQLite* 是一种轻量级数据库，提供零配置的关系型数据库管理系统。*层次数据格式（HDF5）*
    用于存储大量科学阵列数据。涉及这些存储系统超出了本书的范围，但你可以在线找到关于每种方法的大量信息。
- en: '**TEST YOUR KNOWLEDGE**'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试你的知识**'
- en: '11.  True or false: The `shelve` module helps you to store and access pickled
    objects in a file.'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 11.  对错判断：`shelve` 模块帮助你在文件中存储和访问被序列化的对象。
- en: '12.  Of the methods for saving and loading complex data discussed in this chapter,
    the most secure is:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 12.  在本章讨论的保存和加载复杂数据的方法中，最安全的是：
- en: a.  Pickling
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: a.  序列化
- en: b.  Syncing
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: b.  同步
- en: c.  JSON format
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: c.  JSON 格式
- en: d.  Shelving
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: d.  存储
- en: 13.  Rewrite the crew capacity program from the “Storing Data with JSON” section
    of this chapter so that it automatically prints the name of the capsule and the
    grammatically correct version of “seat” (*seat* or *seats*) depending on the number
    of crew members.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 13.  重写本章“使用 JSON 存储数据”部分的船员容量程序，使其根据船员数量自动打印舱体名称和语法正确的“座位”（*seat* 或 *seats*）。
- en: 14.  Use the console to investigate how JSON handles quotation marks. Use the
    lists `["don't", "do"]` and `['don\'t', 'do']`.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 14.  使用控制台调查 JSON 如何处理引号。使用列表 `["don't", "do"]` 和 `['don\'t', 'do']`。
- en: 15.  Built-in Python exceptions for opening and closing files fall under which
    exception class?
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 15.  打开和关闭文件的 Python 内置异常属于哪个异常类？
- en: a.  `IOError`
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: a.  `IOError`
- en: b.  `FileNotFoundError`
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: b.  `FileNotFoundError`
- en: c.  `PermissionError`
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: c.  `PermissionError`
- en: d.  `OSError`
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: d.  `OSError`
- en: 16.  Use Python modules to move a copy of the *lines.txt* file to the *test1*
    folder and then archive it as a ZIP file.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 16.  使用 Python 模块将*lines.txt*文件的副本移动到*test1*文件夹中，然后将其归档为 ZIP 文件。
- en: '**Summary**'
  id: totrans-418
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: Files let you save your work—including variables you assign in a program—in
    a persistent and sharable manner. To work with files, you need a base understanding
    of how your computer’s filesystem works, how to manipulate directory paths, and
    how to open, read, and write files.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 文件使你能够以持久和可共享的方式保存你的工作，包括你在程序中分配的变量。要使用文件，你需要基本了解计算机文件系统的工作原理，如何操作目录路径，以及如何打开、读取和写入文件。
- en: The *absolute* directory path refers to the full directory path, starting with
    the root directory (such as *C:\* on windows). The *relative* directory is defined
    relative to the current working directory. You can use shortcuts, such as “*.*”
    for the absolute directory and “*.\*” for the current working directory, to make
    working with directories easier.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '*绝对*目录路径是指完整的目录路径，从根目录开始（例如Windows上的*C:\*）。*相对*目录是相对于当前工作目录定义的。您可以使用快捷方式，例如“*.*”表示绝对目录，“*.\*”表示当前工作目录，以便更轻松地处理目录。'
- en: Python’s built-in `os`, `pathlib`, and `shutil` modules include useful high-level
    methods for working with files and folders. These methods execute without warning,
    however, so you’ll need to be careful when moving, renaming, or deleting data.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: Python的内置`os`，`pathlib`和`shutil`模块包含用于处理文件和文件夹的有用高级方法。但是，这些方法执行时没有警告，因此在移动、重命名或删除数据时需要小心。
- en: Python has other built-in tools for working with human-readable text files.
    To read a file, you first must open it as a file object using the `open()`function.
    Methods such as `read()` and `readlines()` can then be called on this object.
    To write to a file, you must open it in write mode and then call methods like
    `write()` and `writelines()`. To add data to an existing file without overwriting
    its contents, you must open it in append mode.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: Python还有其他内置工具，用于处理人类可读的文本文件。要读取文件，首先必须使用`open()`函数将其作为文件对象打开。然后可以在此对象上调用`read()`和`readlines()`等方法。要写入文件，必须以写入模式打开它，然后调用`write()`和`writelines()`等方法。要向现有文件添加数据而不覆盖其内容，必须以追加模式打开它。
- en: You should always close files when you’re through with them to release system
    resources and protect the file from being accidently overwritten. You can manually
    close files using the `close()` method, or automatically by opening the file using
    a `with` statement.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 使用完文件后，应始终关闭文件以释放系统资源并防止文件意外被覆盖。您可以使用`close()`方法手动关闭文件，或者通过使用`with`语句自动关闭文件。
- en: More complex data, such as Python dictionaries and lists, can be saved in binary
    format using the `pickle` module, or as human-readable strings using the `json`
    module. The `shelve` module helps you to store and access pickled objects in a
    *shelf* file, which is a persistent, dictionary-like object that assigns each
    pickled object a unique *key* name. Using the JSON format is faster and more secure
    than pickling, but not all Python objects and data types can be stored with JSON.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂的数据，如Python字典和列表，可以使用`pickle`模块保存为二进制格式，或者使用`json`模块保存为人类可读的字符串。`shelve`模块帮助您将pickled对象存储和访问在*shelf*文件中，这是一个持久化的类似字典的对象，为每个pickled对象分配唯一的*key*名称。使用JSON格式比pickling更快速和安全，但并非所有Python对象和数据类型都可以存储在JSON中。
- en: Although it’s important to understand the basic tools for file and folder management
    with Python, if much of your work involves data stored on disk, you’ll want to
    read about the *Python Data Analysis Library*, otherwise known as *pandas*. This
    library contains high-level tools for moving data from disk into Python data structures
    and back again. Many file formats are accommodated, including Excel, CSV, TXT,
    SQL, HTML, JSON, Pickle, and HDF5\. We look at pandas in [Chapters 15](ch15.xhtml)
    and [20](ch20.xhtml).
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管理解Python文件和文件夹管理的基本工具很重要，但如果你的工作涉及大量存储在磁盘上的数据，你可能需要阅读关于*Python数据分析库*的内容，也称为*pandas*。这个库包含高级工具，可以将数据从磁盘导入Python数据结构，然后再导出。许多文件格式都被支持，包括Excel，CSV，TXT，SQL，HTML，JSON，Pickle和HDF5。我们将在[第15章](ch15.xhtml)和[第20章](ch20.xhtml)中讨论pandas。
