- en: '15'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '15'
- en: Generating Data
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 生成数据
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: '*Data visualization* is the use of visual representations to explore and present
    patterns in datasets. It’s closely associated with *data analysis*, which uses
    code to explore the patterns and connections in a dataset. A dataset can be a
    small list of numbers that fits in a single line of code, or it can be terabytes
    of data that include many different kinds of information.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*数据可视化* 是利用视觉表示来探索和展示数据集中的模式。它与 *数据分析* 密切相关，数据分析使用代码来探索数据集中的模式和联系。一个数据集可以是一个简单的数字列表，可以用一行代码表示，或者它也可以是包含多种信息的数太字节数据。'
- en: Creating effective data visualizations is about more than just making information
    look nice. When a representation of a dataset is simple and visually appealing,
    its meaning becomes clear to viewers. People will see patterns and significance
    in your datasets that they never knew existed.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 创建有效的数据可视化不仅仅是让信息看起来好看。当数据集的表示形式简单且具有视觉吸引力时，它的含义会变得对观众更为清晰。人们会在你的数据集中看到以前从未意识到的模式和意义。
- en: Fortunately, you don’t need a supercomputer to visualize complex data. Python
    is so efficient that with just a laptop, you can quickly explore datasets containing
    millions of individual data points. These data points don’t have to be numbers;
    with the basics you learned in the first part of this book, you can analyze non-numerical
    data as well.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，你不需要超级计算机就能可视化复杂的数据。Python 非常高效，使用一台笔记本电脑，你就可以快速探索包含数百万个数据点的数据集。这些数据点不一定是数字；利用你在本书第一部分学到的基础知识，你也可以分析非数字数据。
- en: People use Python for data-intensive work in genetics, climate research, political
    and economic analysis, and much more. Data scientists have written an impressive
    array of visualization and analysis tools in Python, many of which are available
    to you as well. One of the most popular tools is Matplotlib, a mathematical plotting
    library. In this chapter, we’ll use Matplotlib to make simple plots, such as line
    graphs and scatter plots. Then we’ll create a more interesting dataset based on
    the concept of a random walk—a visualization generated from a series of random
    decisions.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 人们使用 Python 进行基因学、气候研究、政治与经济分析等数据密集型工作。数据科学家们为 Python 编写了令人印象深刻的可视化和分析工具，其中许多工具也可以供你使用。最流行的工具之一是
    Matplotlib，一个数学绘图库。在本章中，我们将使用 Matplotlib 制作简单的图表，如折线图和散点图。接下来，我们将基于随机游走的概念创建一个更有趣的数据集——这是通过一系列随机决策生成的可视化。
- en: We’ll also use a package called Plotly, which creates visualizations that work
    well on digital devices, to analyze the results of rolling dice. Plotly generates
    visualizations that automatically resize to fit a variety of display devices.
    These visualizations can also include a number of interactive features, such as
    emphasizing particular aspects of the dataset when users hover over different
    parts of the visualization. Learning to use Matplotlib and Plotly will help you
    get started visualizing the kinds of data you’re most interested in.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用一个名为 Plotly 的包，它可以创建在数字设备上效果良好的可视化，来分析掷骰子的结果。Plotly 生成的可视化会自动调整大小，以适应各种显示设备。这些可视化还可以包括一些交互功能，例如当用户将鼠标悬停在可视化的不同部分时，突出显示数据集的某些方面。学习使用
    Matplotlib 和 Plotly 将帮助你开始可视化你最感兴趣的数据类型。
- en: Installing Matplotlib
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Matplotlib
- en: To use Matplotlib for your initial set of visualizations, you’ll need to install
    it using pip, just like we did with pytest in Chapter 11 (see “Installing pytest
    with pip” on page 210).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Matplotlib 进行初步的可视化，你需要像在第 11 章中安装 pytest（见“使用 pip 安装 pytest”，第 210 页）一样，使用
    pip 安装它。
- en: 'To install Matplotlib, enter the following command at a terminal prompt:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 Matplotlib，在终端提示符下输入以下命令：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you use a command other than `python` to run programs or start a terminal
    session, such as `python3`, your command will look like this:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的命令不是 `python` 来运行程序或启动终端会话，比如 `python3`，那么你的命令应该像这样：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To see the kinds of visualizations you can make with Matplotlib, visit the Matplotlib
    home page at [https://matplotlib.org](https://matplotlib.org) and click **Plot
    types**. When you click a visualization in the gallery, you’ll see the code used
    to generate the plot.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看你可以使用 Matplotlib 制作的可视化类型，访问 Matplotlib 官网 [https://matplotlib.org](https://matplotlib.org)，然后点击
    **Plot types**。当你点击画廊中的某个可视化时，你将看到生成该图表所使用的代码。
- en: Plotting a Simple Line Graph
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制简单的折线图
- en: Let’s plot a simple line graph using Matplotlib and then customize it to create
    a more informative data visualization. We’ll use the square number sequence 1,
    4, 9, 16, and 25 as the data for the graph.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 Matplotlib 绘制一个简单的线性图，然后对其进行自定义，创建一个更具信息量的数据可视化图表。我们将使用平方数序列 1、4、9、16
    和 25 作为图表的数据。
- en: 'To make a simple line graph, specify the numbers you want to work with and
    let Matplotlib do the rest:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要制作一个简单的线性图，只需指定你要使用的数字，让 Matplotlib 来完成剩下的工作：
- en: '**mpl_squares.py**'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**mpl_squares.py**'
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We first import the `pyplot` module using the alias `plt` so we don’t have to
    type `pyplot` repeatedly. (You’ll see this convention often in online examples,
    so we’ll use it here.) The `pyplot` module contains a number of functions that
    help generate charts and plots.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入 `pyplot` 模块，并使用别名 `plt`，这样就不需要重复输入 `pyplot` 了。（你会在在线示例中经常看到这种约定，所以我们也在这里使用它。）`pyplot`
    模块包含许多函数，帮助生成图表和图形。
- en: We create a list called `squares` to hold the data that we’ll plot. Then we
    follow another common Matplotlib convention by calling the `subplots()` function
    ❶. This function can generate one or more plots in the same figure. The variable
    `fig` represents the entire *figure*, which is the collection of plots that are
    generated. The variable `ax` represents a single plot in the figure; this is the
    variable we’ll use most of the time when defining and customizing a single plot.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个名为 `squares` 的列表来保存我们要绘制的数据。接着，我们遵循 Matplotlib 中的另一个常见约定，调用 `subplots()`
    函数 ❶。这个函数可以在同一图形中生成一个或多个子图。变量 `fig` 代表整个*图形*，即生成的所有子图集合。变量 `ax` 代表图形中的一个单独子图；这是我们大多数时候用来定义和自定义单个图表的变量。
- en: We then use the `plot()` method, which tries to plot the data it’s given in
    a meaningful way. The function `plt.show()` opens Matplotlib’s viewer and displays
    the plot, as shown in [Figure 15-1](#figure15-1). The viewer allows you to zoom
    and navigate the plot, and you can save any plot images you like by clicking the
    disk icon.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`plot()`方法，它会尝试以有意义的方式绘制给定的数据。函数`plt.show()`打开 Matplotlib 的查看器并显示图表，如[图
    15-1](#figure15-1)所示。查看器允许你缩放和浏览图表，并且你可以通过点击磁盘图标保存你喜欢的任何图表图像。
- en: '![](image_fi/502703c15/f15001.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502703c15/f15001.png)'
- en: 'Figure 15-1: One of the simplest plots you can make in Matplotlib'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15-1：在 Matplotlib 中，你可以制作的最简单的图表之一
- en: Changing the Label Type and Line Thickness
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更改标签类型和线条粗细
- en: Although the plot in [Figure 15-1](#figure15-1) shows that the numbers are increasing,
    the label type is too small and the line is a little thin to read easily. Fortunately,
    Matplotlib allows you to adjust every feature of a visualization.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管[图 15-1](#figure15-1)中的图表显示数字在增加，但标签类型太小，线条也有些细，难以轻松阅读。幸运的是，Matplotlib 允许你调整可视化的每一个特性。
- en: 'We’ll use a few of the available customizations to improve this plot’s readability.
    Let’s start by adding a title and labeling the axes:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一些可用的自定义选项来提高图表的可读性。让我们从添加标题和标注坐标轴开始：
- en: '**mpl_squares.py**'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**mpl_squares.py**'
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `linewidth` parameter controls the thickness of the line that `plot()` generates
    ❶. Once a plot has been generated, there are many methods available to modify
    the plot before it’s presented. The `set_title()` method sets an overall title
    for the chart ❷. The `fontsize` parameters, which appear repeatedly throughout
    the code, control the size of the text in various elements on the chart.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`linewidth` 参数控制 `plot()` 生成的线条的粗细 ❶。一旦图表生成，仍然有许多方法可以修改图表，直到它被展示出来。`set_title()`
    方法为整个图表设置标题 ❷。`fontsize` 参数（在代码中反复出现）控制图表中各个元素的文字大小。'
- en: The `set_xlabel()` and `set_ylabel()` methods allow you to set a title for each
    of the axes ❸, and the method `tick_params()` styles the tick marks ❹. Here `tick_params()`
    sets the font size of the tick mark labels to 14 on both axes.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`set_xlabel()` 和 `set_ylabel()` 方法允许你为每个坐标轴设置标题 ❸，而 `tick_params()` 方法用于设置刻度线样式
    ❹。这里，`tick_params()` 将两个坐标轴上的刻度标签字体大小设置为 14。'
- en: As you can see in [Figure 15-2](#figure15-2), the resulting chart is much easier
    to read. The label type is bigger, and the line graph is thicker. It’s often worth
    experimenting with these values to see what works best in the resulting graph.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图 15-2](#figure15-2)所示，生成的图表更容易阅读了。标签字体更大，线条图更粗了。通常，值得尝试调整这些值，看看在最终图表中哪些效果最好。
- en: '![](image_fi/502703c15/f15002.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502703c15/f15002.png)'
- en: 'Figure 15-2: The chart is much easier to read now.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15-2：现在图表更容易阅读了。
- en: Correcting the Plot
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修正图表
- en: Now that we can read the chart better, we can see that the data is not plotted
    correctly. Notice at the end of the graph that the square of 4.0 is shown as 25!
    Let’s fix that.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能更清晰地阅读图表，发现数据并没有正确绘制。注意在图表的末尾，4.0的平方被错误地显示为25！让我们来修正这个问题。
- en: 'When you give `plot()` a single sequence of numbers, it assumes the first data
    point corresponds to an *x*-value of 0, but our first point corresponds to an
    *x*-value of 1\. We can override the default behavior by giving `plot()` both
    the input and output values used to calculate the squares:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当你给`plot()`传递一个数字序列时，它会假设第一个数据点对应的*x*值为0，但我们的第一个点对应的*x*值是1。我们可以通过给`plot()`提供用于计算平方的输入和输出值来覆盖默认行为：
- en: '**mpl_squares.py**'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**mpl_squares.py**'
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now `plot()` doesn’t have to make any assumptions about how the output numbers
    were generated. The resulting plot, shown in [Figure 15-3](#figure15-3), is correct.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`plot()`不需要假设输出的数字是如何生成的。生成的图表，如[图 15-3](#figure15-3)所示，是正确的。
- en: '![](image_fi/502703c15/f15003.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502703c15/f15003.png)'
- en: 'Figure 15-3: The data is now plotted correctly.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15-3：数据现在已经正确绘制。
- en: You can specify a number of arguments when calling `plot()` and use a number
    of methods to customize your plots after generating them. We’ll continue to explore
    these approaches to customization as we work with more interesting datasets throughout
    this chapter.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在调用`plot()`时指定多个参数，并在生成图表后使用多种方法来定制图表。我们将在本章中继续探索这些定制方法，并与更有趣的数据集一起工作。
- en: Using Built-in Styles
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用内置样式
- en: 'Matplotlib has a number of predefined styles available. These styles contain
    a variety of default settings for background colors, gridlines, line widths, fonts,
    font sizes, and more. They can make your visualizations appealing without requiring
    much customization. To see the full list of available styles, run the following
    lines in a terminal session:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib有许多预定义的样式可供使用。这些样式包含各种默认设置，涵盖背景颜色、网格线、线宽、字体、字号等。它们可以让你的可视化效果更具吸引力，而无需太多的自定义。要查看所有可用样式的完整列表，请在终端会话中运行以下命令：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To use any of these styles, add one line of code before calling `subplots()`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这些样式中的任何一个，只需在调用`subplots()`之前添加一行代码：
- en: '**mpl_squares.py**'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**mpl_squares.py**'
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This code generates the plot shown in [Figure 15-4](#figure15-4). A wide variety
    of styles is available; play around with these styles to find some that you like.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码生成了如[图 15-4](#figure15-4)所示的图表。提供了多种样式；可以尝试这些样式，找到你喜欢的样式。
- en: '![](image_fi/502703c15/f15004.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502703c15/f15004.png)'
- en: 'Figure 15-4: The built-in seaborn style'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15-4：内置的seaborn样式
- en: Plotting and Styling Individual Points with scatter()
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`scatter()`绘制和样式化单个点
- en: Sometimes, it’s useful to plot and style individual points based on certain
    characteristics. For example, you might plot small values in one color and larger
    values in a different color. You could also plot a large dataset with one set
    of styling options and then emphasize individual points by replotting them with
    different options.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，根据某些特征绘制和样式化单个点是很有用的。例如，你可以用一种颜色绘制较小的值，另一种颜色绘制较大的值。你还可以用一组样式选项绘制大型数据集，然后通过重新绘制个别点并使用不同的选项来强调它们。
- en: 'To plot a single point, pass the single *x*- and *y*-values of the point to
    `scatter()`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要绘制一个单独的点，可以将该点的单个*x*和*y*值传递给`scatter()`：
- en: '**scatter_squares.py**'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**scatter_squares.py**'
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let’s style the output to make it more interesting. We’ll add a title, label
    the axes, and make sure all the text is large enough to read:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为输出添加样式，使其更有趣。我们将添加标题，标记坐标轴，并确保所有文本都足够大以便阅读：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We call `scatter()` and use the `s` argument to set the size of the dots used
    to draw the graph ❶. When you run *scatter_squares.py* now, you should see a single
    point in the middle of the chart, as shown in [Figure 15-5](#figure15-5).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用`scatter()`并使用`s`参数设置绘制图表时使用的点的大小❶。现在运行*scatter_squares.py*，你应该能看到图表中心有一个单独的点，如[图
    15-5](#figure15-5)所示。
- en: '![](image_fi/502703c15/f15005.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502703c15/f15005.png)'
- en: 'Figure 15-5: Plotting a single point'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15-5：绘制一个单独的点
- en: Plotting a Series of Points with scatter()
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`scatter()`绘制一系列点
- en: 'To plot a series of points, we can pass `scatter()` separate lists of *x*-
    and *y*-values, like this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要绘制一系列点，我们可以将独立的*x*和*y*值列表传递给`scatter()`，像这样：
- en: '**scatter_squares.py**'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**scatter_squares.py**'
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `x_values` list contains the numbers to be squared, and `y_values` contains
    the square of each number. When these lists are passed to `scatter()`, Matplotlib
    reads one value from each list as it plots each point. The points to be plotted
    are (1, 1), (2, 4), (3, 9), (4, 16), and (5, 25); [Figure 15-6](#figure15-6) shows
    the result.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`x_values`列表包含待平方的数字，而`y_values`包含每个数字的平方。当这些列表传递给`scatter()`时，Matplotlib会在绘制每个点时从每个列表中读取一个值。待绘制的点为（1，1），（2，4），（3，9），（4，16）和（5，25）；图[15-6](#figure15-6)显示了结果。'
- en: '![](image_fi/502703c15/f15006.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502703c15/f15006.png)'
- en: 'Figure 15-6: A scatter plot with multiple points'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图15-6：具有多个点的散点图
- en: Calculating Data Automatically
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动计算数据
- en: Writing lists by hand can be inefficient, especially when we have many points.
    Rather than writing out each value, let’s use a loop to do the calculations for
    us.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 手动编写列表可能效率低下，尤其是当我们有很多点时。与其逐个写出每个值，不如使用循环来进行计算。
- en: 'Here’s how this would look with 1,000 points:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用1,000个点时的效果：
- en: '**scatter_squares.py**'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**scatter_squares.py**'
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We start with a range of *x*-values containing the numbers 1 through 1,000 ❶.
    Next, a list comprehension generates the *y*-values by looping through the *x*-values
    (`for x in x_values`), squaring each number (`x**2`), and assigning the results
    to `y_values`. We then pass the input and output lists to `scatter()` ❷. Because
    this is a large dataset, we use a smaller point size.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个包含1到1,000的数字范围的*x*值开始❶。接下来，列表推导通过循环遍历*x*值（`for x in x_values`），将每个数字平方（`x**2`），并将结果赋值给`y_values`。然后，我们将输入和输出列表传递给`scatter()`❷。由于这是一个大数据集，我们使用较小的点大小。
- en: 'Before showing the plot, we use the `axis()` method to specify the range of
    each axis ❸. The `axis()` method requires four values: the minimum and maximum
    values for the *x*-axis and the *y*-axis. Here, we run the *x*-axis from 0 to
    1,100 and the *y*-axis from 0 to 1,100,000\. [Figure 15-7](#figure15-7) shows
    the result.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在显示图表之前，我们使用`axis()`方法指定每个轴的范围❸。`axis()`方法需要四个值：*x*轴和*y*轴的最小值和最大值。在这里，我们将*x*轴范围设置为0到1,100，*y*轴范围设置为0到1,100,000。图[15-7](#figure15-7)显示了结果。
- en: '![](image_fi/502703c15/f15007.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502703c15/f15007.png)'
- en: 'Figure 15-7: Python can plot 1,000 points as easily as it plots 5 points.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图15-7：Python绘制1,000个点和绘制5个点一样容易。
- en: Customizing Tick Labels
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义刻度标签
- en: When the numbers on an axis get large enough, Matplotlib defaults to scientific
    notation for tick labels. This is usually a good thing, because larger numbers
    in plain notation take up a lot of unnecessary space on a visualization.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当轴上的数字足够大时，Matplotlib默认使用科学计数法表示刻度标签。这通常是一个好事，因为用常规表示法表示大数字会占用可视化中大量不必要的空间。
- en: 'Almost every element of a chart is customizable, so you can tell Matplotlib
    to keep using plain notation if you prefer:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个图表元素都可以自定义，因此如果你更喜欢常规表示法，可以告诉Matplotlib继续使用普通表示法：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `ticklabel_format()` method allows you to override the default tick label
    style for any plot.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`ticklabel_format()`方法允许你覆盖任何图表的默认刻度标签样式。'
- en: Defining Custom Colors
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义自定义颜色
- en: 'To change the color of the points, pass the argument `color` to `scatter()`
    with the name of a color to use in quotation marks, as shown here:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改点的颜色，将`color`参数传递给`scatter()`，并使用引号括起颜色名称，如下所示：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can also define custom colors using the RGB color model. To define a color,
    pass the `color` argument a tuple with three float values (one each for red, green,
    and blue, in that order), using values between 0 and 1\. For example, the following
    line creates a plot with light-green dots:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用RGB颜色模型定义自定义颜色。要定义颜色，将`color`参数传递一个包含三个浮动值的元组（分别代表红色、绿色和蓝色），这些值的范围是0到1。例如，以下代码行创建一个包含浅绿色点的图：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Values closer to 0 produce darker colors, and values closer to 1 produce lighter
    colors.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 靠近0的值会产生较暗的颜色，而靠近1的值会产生较浅的颜色。
- en: Using a Colormap
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用色彩图
- en: A *colormap* is a sequence of colors in a gradient that moves from a starting
    to an ending color. In visualizations, colormaps are used to emphasize patterns
    in data. For example, you might make low values a light color and high values
    a darker color. Using a colormap ensures that all points in the visualization
    vary smoothly and accurately along a well-designed color scale.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*色彩图*是一个渐变的颜色序列，从起始颜色到结束颜色。在可视化中，色彩图用于强调数据中的模式。例如，你可以将低值设为浅色，将高值设为深色。使用色彩图可以确保可视化中的所有点在一个精心设计的颜色尺度上平滑、准确地变化。'
- en: 'The `pyplot` module includes a set of built-in colormaps. To use one of these
    colormaps, you need to specify how `pyplot` should assign a color to each point
    in the dataset. Here’s how to assign a color to each point, based on its *y*-value:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`pyplot` 模块包含一组内置的颜色映射。要使用这些颜色映射之一，你需要指定 `pyplot` 如何根据数据集中的每个点的 *y* 值来分配颜色。以下是如何根据每个点的
    *y* 值来为其分配颜色：'
- en: '**scatter_squares.py**'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**scatter_squares.py**'
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `c` argument is similar to `color`, but it’s used to associate a sequence
    of values with a color mapping. We pass the list of *y*-values to `c`, and then
    tell `pyplot` which colormap to use with the `cmap` argument. This code colors
    the points with lower *y*-values light blue and the points with higher *y*-values
    dark blue. [Figure 15-8](#figure15-8) shows the resulting plot.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`c` 参数类似于 `color`，但它用于将一系列值与颜色映射关联。我们将 *y* 值列表传递给 `c`，然后通过 `cmap` 参数告诉 `pyplot`
    使用哪种颜色映射。此代码将较低 *y* 值的点颜色设置为浅蓝色，将较高 *y* 值的点颜色设置为深蓝色。[图 15-8](#figure15-8) 显示了结果图。'
- en: '![](image_fi/502703c15/f15008.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502703c15/f15008.png)'
- en: 'Figure 15-8: A plot using the `Blues` colormap'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15-8：使用 `Blues` 颜色映射的图像
- en: Saving Your Plots Automatically
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动保存你的图像
- en: 'If you want to save the plot to a file instead of showing it in the Matplotlib
    viewer, you can use `plt.savefig()` instead of `plt.show()`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想将图像保存到文件而不是在 Matplotlib 查看器中显示它，可以使用 `plt.savefig()` 替代 `plt.show()`：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The first argument is a filename for the plot image, which will be saved in
    the same directory as *scatter_squares.py*. The second argument trims extra whitespace
    from the plot. If you want the extra whitespace around the plot, you can omit
    this argument. You can also call `savefig()` with a `Path` object, and write the
    output file anywhere you want on your system.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是图像文件的文件名，图像将保存在与 *scatter_squares.py* 相同的目录中。第二个参数用于修剪图像周围的额外空白。如果你希望保留图像周围的空白，可以省略此参数。你也可以使用
    `Path` 对象调用 `savefig()`，并将输出文件保存到系统中的任何位置。
- en: Random Walks
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 随机漫步
- en: In this section, we’ll use Python to generate data for a random walk and then
    use Matplotlib to create a visually appealing representation of that data. A *random
    walk* is a path that’s determined by a series of simple decisions, each of which
    is left entirely to chance. You might imagine a random walk as the path a confused
    ant would take if it took every step in a random direction.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用 Python 生成随机漫步的数据，并使用 Matplotlib 创建该数据的视觉表示。*随机漫步* 是由一系列简单决策决定的路径，每个决策完全依赖于随机性。你可以把随机漫步想象成一只迷失的蚂蚁，如果它每走一步都是随机选择方向的话，它走的路径就是随机漫步。
- en: Random walks have practical applications in nature, physics, biology, chemistry,
    and economics. For example, a pollen grain floating on a drop of water moves across
    the surface of the water because it’s constantly pushed around by water molecules.
    Molecular motion in a water drop is random, so the path a pollen grain traces
    on the surface is a random walk. The code we’ll write next models many real-world
    situations.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 随机漫步在自然界、物理学、生物学、化学和经济学中有许多实际应用。例如，漂浮在水滴上的花粉粒子因不断受到水分子推动而在水面上移动。水滴中的分子运动是随机的，因此花粉粒子在水面上留下的轨迹就是一个随机漫步。我们接下来编写的代码将模拟许多现实世界的情况。
- en: Creating the RandomWalk Class
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建 RandomWalk 类
- en: 'To create a random walk, we’ll create a `RandomWalk` class, which will make
    random decisions about which direction the walk should take. The class needs three
    attributes: one variable to track the number of points in the walk, and two lists
    to store the *x*- and *y*-coordinates of each point in the walk.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个随机漫步，我们将创建一个 `RandomWalk` 类，该类将做出关于漫步方向的随机决定。这个类需要三个属性：一个变量来跟踪漫步中的点数，两个列表用来存储漫步中每个点的
    *x* 和 *y* 坐标。
- en: 'We’ll only need two methods for the `RandomWalk` class: the `__init__()` method
    and `fill_walk()`, which will calculate the points in the walk. Let’s start with
    the `__init__()` method:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要为 `RandomWalk` 类编写两个方法：`__init__()` 方法和 `fill_walk()` 方法，后者将计算漫步中的各个点。我们先从
    `__init__()` 方法开始：
- en: '**random_walk.py**'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**random_walk.py**'
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: To make random decisions, we’ll store possible moves in a list and use the `choice()`
    function (from the `random` module) to decide which move to make each time a step
    is taken ❶. We set the default number of points in a walk to `5000`, which is
    large enough to generate some interesting patterns but small enough to generate
    walks quickly ❷. Then we make two lists to hold the *x*- and *y*-values, and we
    start each walk at the point (0, 0) ❸.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做出随机决策，我们将在一个列表中存储可能的移动，并使用`choice()`函数（来自`random`模块）来决定每次走一步时的移动方向❶。我们将默认的步数设置为`5000`，这个值足够大，可以生成一些有趣的图案，同时又足够小，可以快速生成游走❷。然后我们创建两个列表来保存*
    x *和* y *的值，并将每次游走的起点设为(0, 0)❸。
- en: Choosing Directions
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择方向
- en: 'We’ll use the `fill_walk()` method to determine the full sequence of points
    in the walk. Add this method to *random_walk.py*:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`fill_walk()`方法来确定游走中的完整点序列。将此方法添加到*random_walk.py*中：
- en: '**random_walk.py**'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**random_walk.py**'
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We first set up a loop that runs until the walk is filled with the correct
    number of points ❶. The main part of `fill_walk()` tells Python how to simulate
    four random decisions: Will the walk go right or left? How far will it go in that
    direction? Will it go up or down? How far will it go in that direction?'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先设置一个循环，直到游走填充了正确数量的点❶。`fill_walk()`的主要部分告诉Python如何模拟四个随机决策：游走是向右还是向左？在该方向上将移动多远？游走是向上还是向下？在该方向上将移动多远？
- en: We use `choice([1, -1])` to choose a value for `x_direction`, which returns
    either 1 for movement to the right or −1 for movement to the left ❷. Next, `choice([0,
    1, 2, 3, 4])` randomly selects a distance to move in that direction. We assign
    this value to `x_distance`. The inclusion of a 0 allows for the possibility of
    steps that have movement along only one axis.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`choice([1, -1])`来为`x_direction`选择一个值，返回值为1表示向右移动，返回值为−1表示向左移动❷。接着，`choice([0,
    1, 2, 3, 4])`会随机选择一个距离来决定在该方向上移动的步数。我们将该值赋给`x_distance`。包括0的选择允许步伐仅在一个轴上移动。
- en: We determine the length of each step in the *x-* and *y-*directions by multiplying
    the direction of movement by the distance chosen ❸ ❹. A positive result for `x_step`
    means move to the right, a negative result means move to the left, and 0 means
    move vertically. A positive result for `y_step` means move up, negative means
    move down, and 0 means move horizontally. If the values of both `x_step` and `y_step`
    are 0, the walk doesn’t go anywhere; when this happens, we continue the loop ❺.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将运动方向与选定的距离相乘来确定每一步在* x *和* y *方向上的步长❸❹。`x_step`为正值表示向右移动，负值表示向左移动，0表示垂直移动。`y_step`为正值表示向上移动，负值表示向下移动，0表示水平移动。如果`x_step`和`y_step`的值都为0，则表示游走没有前进；在这种情况下，我们会继续循环❺。
- en: To get the next *x*-value for the walk, we add the value in `x_step` to the
    last value stored in `x_values` ❻ and do the same for the *y*-values. When we
    have the new point’s coordinates, we append them to `x_values` and `y_values`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得下一个游走的* x *值，我们将`x_step`中的值加到`x_values`中最后存储的值❻，* y *值同理。获得新的点的坐标后，我们将它们附加到`x_values`和`y_values`中。
- en: Plotting the Random Walk
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绘制随机游走
- en: 'Here’s the code to plot all the points in the walk:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是绘制游走中所有点的代码：
- en: '**rw_visual.py**'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**rw_visual.py**'
- en: '[PRE18]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We begin by importing `pyplot` and `RandomWalk`. We then create a random walk
    and assign it to `rw` ❶, making sure to call `fill_walk()`. To visualize the walk,
    we feed the walk’s *x*- and *y*-values to `scatter()` and choose an appropriate
    dot size ❷. By default, Matplotlib scales each axis independently. But that approach
    would stretch most walks out horizontally or vertically. Here we use the `set_aspect()`
    method to specify that both axes should have equal spacing between tick marks
    ❸.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入`pyplot`和`RandomWalk`。然后我们创建一个随机游走并将其赋值给`rw`❶，确保调用`fill_walk()`。为了可视化游走，我们将游走的*
    x *和* y *值传递给`scatter()`并选择合适的点大小❷。默认情况下，Matplotlib会独立缩放每个坐标轴。但这种方式会使大多数游走在水平方向或垂直方向上拉伸。这里我们使用`set_aspect()`方法来指定两个坐标轴之间的刻度间距应保持相等❸。
- en: '[Figure 15-9](#figure15-9) shows the resulting plot with 5,000 points. The
    images in this section omit Matplotlib’s viewer, but you’ll continue to see it
    when you run *rw_visual.py*.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[图15-9](#figure15-9)展示了生成的包含5,000个点的图表。本节中的图像省略了Matplotlib的查看器，但当你运行*rw_visual.py*时，你仍然会看到它。'
- en: '![](image_fi/502703c15/f15009.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502703c15/f15009.png)'
- en: 'Figure 15-9: A random walk with 5,000 points'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图15-9：一个包含5,000个点的随机游走
- en: Generating Multiple Random Walks
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成多个随机游走
- en: 'Every random walk is different, and it’s fun to explore the various patterns
    that can be generated. One way to use the preceding code to make multiple walks
    without having to run the program several times is to wrap it in a `while` loop,
    like this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 每次随机漫步都是不同的，探索生成的各种模式非常有趣。使用前面的代码生成多个漫步而不需要多次运行程序的一种方式是将其包装在`while`循环中，如下所示：
- en: '**rw_visual.py**'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**rw_visual.py**'
- en: '[PRE19]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This code generates a random walk, displays it in Matplotlib’s viewer, and pauses
    with the viewer open. When you close the viewer, you’ll be asked whether you want
    to generate another walk. If you generate a few walks, you should see some that
    stay near the starting point, some that wander off mostly in one direction, some
    that have thin sections connecting larger groups of points, and many other kinds
    of walks. When you want to end the program, press N.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码生成一个随机漫步，将其显示在Matplotlib的查看器中，并暂停等待查看器关闭。当你关闭查看器时，系统会询问你是否要生成另一个漫步。如果你生成几个漫步，你应该会看到一些漫步保持在起点附近，一些漫步主要朝一个方向走，某些漫步有细长的部分连接着多个点，还有很多其他种类的漫步。当你想结束程序时，按N键。
- en: Styling the Walk
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 漫步的样式
- en: In this section, we’ll customize our plots to emphasize the important characteristics
    of each walk and deemphasize distracting elements. To do so, we identify the characteristics
    we want to emphasize, such as where the walk began, where it ended, and the path
    taken. Next, we identify the characteristics to deemphasize, such as tick marks
    and labels. The result should be a simple visual representation that clearly communicates
    the path taken in each random walk.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将自定义我们的图表，突出显示每次随机漫步的关键特征，并淡化干扰元素。为此，我们确定需要强调的特征，如漫步的起点、终点以及所走的路径。接下来，我们确定需要淡化的特征，如刻度标记和标签。最终结果应该是一个简单的视觉表示，清晰地传达每次随机漫步的路径。
- en: Coloring the Points
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 给点着色
- en: 'We’ll use a colormap to show the order of the points in the walk, and remove
    the black outline from each dot so the color of the dots will be clearer. To color
    the points according to their position in the walk, we pass the `c` argument a
    list containing the position of each point. Because the points are plotted in
    order, this list just contains the numbers from 0 to 4,999:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用颜色图来展示漫步中各点的顺序，并去除每个点的黑色轮廓，使点的颜色更加清晰。为了根据点在漫步中的位置为其着色，我们将包含每个点位置的列表传递给`c`参数。由于这些点是按顺序绘制的，这个列表只包含从0到4,999的数字：
- en: '**rw_visual.py**'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**rw_visual.py**'
- en: '[PRE20]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We use `range()` to generate a list of numbers equal to the number of points
    in the walk ❶. We assign this list to `point_numbers`, which we’ll use to set
    the color of each point in the walk. We pass `point_numbers` to the `c` argument,
    use the `Blues` colormap, and then pass `edgecolors='none'` to get rid of the
    black outline around each point. The result is a plot that varies from light to
    dark blue, showing exactly how the walk moves from its starting point to its ending
    point. This is shown in [Figure 15-10](#figure15-10).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`range()`生成一个与漫步点数相等的数字列表❶。我们将这个列表赋值给`point_numbers`，并将其用于设置每个点的颜色。我们将`point_numbers`传递给`c`参数，使用`Blues`颜色图，然后传递`edgecolors='none'`来去除每个点周围的黑色轮廓。结果是一个从浅蓝到深蓝变化的图表，准确地显示了漫步从起点到终点的过程。如[图
    15-10](#figure15-10)所示。
- en: '![](image_fi/502703c15/f15010.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502703c15/f15010.png)'
- en: 'Figure 15-10: A random walk colored with the `Blues` colormap'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '图 15-10: 使用`Blues`颜色图着色的随机漫步'
- en: Plotting the Starting and Ending Points
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 绘制起点和终点
- en: 'In addition to coloring points to show their position along the walk, it would
    be useful to see exactly where each walk begins and ends. To do so, we can plot
    the first and last points individually after the main series has been plotted.
    We’ll make the end points larger and color them differently to make them stand
    out:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 除了通过颜色来标识每个点在漫步中的位置外，显示每次漫步的起点和终点也是很有用的。为此，我们可以在主要序列绘制完成后，单独绘制第一个和最后一个点。我们将使终点的点更大，并使用不同的颜色使其更加突出：
- en: '**rw_visual.py**'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**rw_visual.py**'
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: To show the starting point, we plot the point (0, 0) in green and in a larger
    size (`s=100`) than the rest of the points. To mark the end point, we plot the
    last *x*- and *y*-values in red with a size of 100 as well. Make sure you insert
    this code just before the call to `plt.show()` so the starting and ending points
    are drawn on top of all the other points.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示起点，我们将点(0, 0)以绿色和比其他点更大的尺寸（`s=100`）绘制。为了标记终点，我们也将最后的 *x* 和 *y* 值以红色绘制，尺寸为100。确保将这段代码插入到`plt.show()`调用之前，以便起点和终点能够绘制在所有其他点的上面。
- en: When you run this code, you should be able to spot exactly where each walk begins
    and ends. If these end points don’t stand out clearly enough, adjust their color
    and size until they do.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这段代码时，你应该能够准确找到每次漫步的开始和结束位置。如果这些端点不够显眼，可以调整它们的颜色和大小，直到它们清晰可见。
- en: Cleaning Up the Axes
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 清理坐标轴
- en: 'Let’s remove the axes in this plot so they don’t distract from the path of
    each walk. Here’s how to hide the axes:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们移除此图中的坐标轴，以避免它们分散每次漫步的注意力。以下是隐藏坐标轴的方法：
- en: '**rw_visual.py**'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**rw_visual.py**'
- en: '[PRE22]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: To modify the axes, we use the `ax.get_xaxis()` and `ax.get_yaxis()` methods
    to get each axis, and then chain the `set_visible()` method to make each axis
    invisible. As you continue to work with visualizations, you’ll frequently see
    this chaining of methods to customize different aspects of a visualization.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修改坐标轴，我们使用 `ax.get_xaxis()` 和 `ax.get_yaxis()` 方法来获取每个坐标轴，然后通过链式调用 `set_visible()`
    方法使每个坐标轴变得不可见。随着你继续进行可视化工作，你将经常看到这种方法链的使用，用来定制可视化的不同方面。
- en: Run *rw_visual.py* now; you should see a series of plots with no axes.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行 *rw_visual.py*；你应该能看到一系列没有坐标轴的图表。
- en: Adding Plot Points
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加绘图点
- en: 'Let’s increase the number of points, to give us more data to work with. To
    do so, we increase the value of `num_points` when we make a `RandomWalk` instance
    and adjust the size of each dot when drawing the plot:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们增加点的数量，以便为我们提供更多的数据来处理。为此，我们在创建 `RandomWalk` 实例时增加 `num_points` 的值，并在绘制图表时调整每个点的大小：
- en: '**rw_visual.py**'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**rw_visual.py**'
- en: '[PRE23]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This example creates a random walk with 50,000 points and plots each point at
    size `s=1`. The resulting walk is wispy and cloudlike, as shown in [Figure 15-11](#figure15-11).
    We’ve created a piece of art from a simple scatter plot!
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子创建了一个包含 50,000 个点的随机漫步，并且将每个点的大小设置为 `s=1`。最终的随机漫步呈现出云雾状，如 [图 15-11](#figure15-11)
    所示。我们已经从一个简单的散点图中创造出了一幅艺术作品！
- en: Experiment with this code to see how much you can increase the number of points
    in a walk before your system starts to slow down significantly or the plot loses
    its visual appeal.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试调整此代码，看看你可以在系统开始显著变慢或图表失去视觉吸引力之前，增加多少步数。
- en: '![](image_fi/502703c15/f15011.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502703c15/f15011.png)'
- en: 'Figure 15-11: A walk with 50,000 points'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15-11：50,000 个点的随机漫步
- en: Altering the Size to Fill the Screen
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 调整大小以填充屏幕
- en: 'A visualization is much more effective at communicating patterns in data if
    it fits nicely on the screen. To make the plotting window better fit your screen,
    you can adjust the size of Matplotlib’s output. This is done in the `subplots()`
    call:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可视化能够很好地适应屏幕，它在传达数据模式时会更加有效。为了使绘图窗口更好地适应屏幕，你可以调整 Matplotlib 输出的大小。这是在 `subplots()`
    调用中完成的：
- en: '[PRE24]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: When creating a plot, you can pass `subplots()` a `figsize` argument, which
    sets the size of the figure. The `figsize` parameter takes a tuple that tells
    Matplotlib the dimensions of the plotting window in inches.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建图表时，你可以将 `subplots()` 的 `figsize` 参数传递进去，这样可以设置图形的大小。`figsize` 参数接受一个元组，告诉
    Matplotlib 绘图窗口的尺寸（单位为英寸）。
- en: 'Matplotlib assumes your screen resolution is 100 pixels per inch; if this code
    doesn’t give you an accurate plot size, adjust the numbers as necessary. Or, if
    you know your system’s resolution, you can pass `subplots()` the resolution using
    the `dpi` parameter:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib 假设你的屏幕分辨率为每英寸 100 像素；如果这段代码没有给出准确的图表大小，请根据需要调整数字。或者，如果你知道系统的分辨率，可以使用
    `dpi` 参数将分辨率传递给 `subplots()`：
- en: '[PRE25]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This should help make the most efficient use of the space available on your
    screen.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该有助于更有效地利用屏幕上可用的空间。
- en: Rolling Dice with Plotly
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Plotly 掷骰子
- en: In this section, we’ll use Plotly to produce interactive visualizations. Plotly
    is particularly useful when you’re creating visualizations that will be displayed
    in a browser, because the visualizations will scale automatically to fit the viewer’s
    screen. These visualizations are also interactive; when the user hovers over certain
    elements on the screen, information about those elements is highlighted. We’ll
    build our initial visualization in just a couple lines of code using *Plotly Express*,
    a subset of Plotly that focuses on generating plots with as little code as possible.
    Once we know our plot is correct, we’ll customize the output just as we did with
    Matplotlib.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用 Plotly 来制作交互式可视化。Plotly 特别适用于在浏览器中显示的可视化，因为这些可视化会自动缩放以适应查看者的屏幕。它们也是交互式的；当用户将鼠标悬停在屏幕上的某些元素上时，这些元素的信息会被高亮显示。我们将使用
    *Plotly Express* 来构建最初的可视化，Plotly Express 是 Plotly 的一个子集，专注于以尽可能少的代码生成图表。一旦确认我们的图表正确无误，我们将像使用
    Matplotlib 一样自定义输出。
- en: In this project, we’ll analyze the results of rolling dice. When you roll one
    regular, six-sided die, you have an equal chance of rolling any of the numbers
    from 1 through 6\. However, when you use two dice, you’re more likely to roll
    certain numbers than others. We’ll try to determine which numbers are most likely
    to occur by generating a dataset that represents rolling dice. Then we’ll plot
    the results of a large number of rolls to determine which results are more likely
    than others.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将分析投掷骰子的结果。当你投掷一个普通的六面骰时，每个数字从 1 到 6 出现的概率是相等的。然而，当你使用两个骰子时，某些数字比其他数字更可能出现。我们将尝试通过生成一个代表投掷骰子的
    数据集来确定哪些数字最有可能出现。然后我们将绘制大量投掷的结果，以确定哪些结果比其他结果更有可能。
- en: This work helps model games involving dice, but the core ideas also apply to
    games that involve chance of any kind, such as card games. It also relates to
    many real-world situations where randomness plays a significant factor.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这项工作有助于建模涉及骰子的游戏，但其核心思想也适用于任何形式的机会游戏，如扑克牌游戏。它还与许多现实世界中的情况相关，这些情况中的随机性扮演着重要角色。
- en: Installing Plotly
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装 Plotly
- en: 'Install Plotly using pip, just as you did for Matplotlib:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 pip 安装 Plotly，就像安装 Matplotlib 一样：
- en: '[PRE26]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Plotly Express depends on *pandas*, which is a library for working efficiently
    with data, so we need to install that as well. If you used `python3` or something
    else when installing Matplotlib, make sure you use the same command here.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Plotly Express 依赖于 *pandas*，这是一个高效处理数据的库，因此我们也需要安装它。如果在安装 Matplotlib 时使用了 `python3`
    或其他版本，确保在这里使用相同的命令。
- en: To see what kind of visualizations are possible with Plotly, visit the gallery
    of chart types at [https://plotly.com/python](https://plotly.com/python). Each
    example includes source code, so you can see how Plotly generates the visualizations.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看 Plotly 能实现哪些可视化，请访问 [https://plotly.com/python](https://plotly.com/python)
    上的图表类型画廊。每个示例都包括源代码，您可以查看 Plotly 如何生成这些可视化。
- en: Creating the Die Class
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建 Die 类
- en: 'We’ll create the following `Die` class to simulate the roll of one die:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建以下 `Die` 类来模拟投掷一个骰子：
- en: '**die.py**'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**die.py**'
- en: '[PRE27]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `__init__()` method takes one optional argument ❶. With the `Die` class,
    when an instance of our die is created, the number of sides will be six if no
    argument is included. If an argument *is* included, that value will set the number
    of sides on the die. (Dice are named for their number of sides: a six-sided die
    is a D6, an eight-sided die is a D8, and so on.)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__()` 方法接受一个可选参数 ❶。在 `Die` 类中，当创建骰子的实例时，如果没有传入参数，骰子的面数默认为六个。如果传入了参数，则该值将设置骰子的面数。（骰子的命名取决于面数：六面骰为
    D6，八面骰为 D8，依此类推。）'
- en: The `roll()` method uses the `randint()` function to return a random number
    between 1 and the number of sides ❷. This function can return the starting value
    (1), the ending value (`num_sides`), or any integer between the two.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`roll()` 方法使用 `randint()` 函数返回一个介于 1 和面数之间的随机数 ❷。此函数可以返回起始值（1）、结束值（`num_sides`）或介于两者之间的任何整数。'
- en: Rolling the Die
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 投掷骰子
- en: 'Before creating a visualization based on the `Die` class, let’s roll a D6,
    print the results, and check that the results look reasonable:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建基于 `Die` 类的可视化之前，让我们先投掷一个 D6，打印结果，并检查这些结果是否合理：
- en: '**die_visual.py**'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**die_visual.py**'
- en: '[PRE28]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We create an instance of `Die` with the default six sides ❶. Then we roll the
    die `100` times ❷ and store the result of each roll in the list `results`. Here’s
    a sample set of results:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个 `Die` 类的实例，默认有六个面 ❶。然后我们投掷骰子 `100` 次 ❷，并将每次投掷的结果存储在 `results` 列表中。以下是一个结果示例：
- en: '[PRE29]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: A quick scan of these results shows that the `Die` class seems to be working.
    We see the values 1 and 6, so we know the smallest and largest possible values
    are being returned, and because we don’t see 0 or 7, we know all the results are
    in the appropriate range. We also see each number from 1 through 6, which indicates
    that all possible outcomes are represented. Let’s determine exactly how many times
    each number appears.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 快速扫描这些结果表明 `Die` 类似乎在正常工作。我们看到了 1 和 6，因此我们知道返回的最小值和最大值是正确的，而且因为没有看到 0 或 7，我们知道所有结果都在正确的范围内。我们还看到了从
    1 到 6 的每个数字，这表示所有可能的结果都有出现。接下来，我们将确定每个数字出现的具体次数。
- en: Analyzing the Results
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分析结果
- en: 'We’ll analyze the results of rolling one D6 by counting how many times we roll
    each number:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过统计每个数字出现的次数来分析投掷一个 D6 骰子的结果：
- en: '**die_visual.py**'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '**die_visual.py**'
- en: '[PRE30]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Because we’re no longer printing the results, we can increase the number of
    simulated rolls to `1000` ❶. To analyze the rolls, we create the empty list `frequencies`
    to store the number of times each value is rolled. We then generate all the possible
    results we could get; in this example, that’s all the numbers from `1` to however
    many sides `die` has ❷. We loop through the possible values, count how many times
    each number appears in `results` ❸, and then append this value to `frequencies`
    ❹. We print this list before making a visualization:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们不再打印结果，所以我们可以将模拟掷骰的次数增加到`1000` ❶。为了分析这些掷骰结果，我们创建了一个空列表`frequencies`来存储每个结果出现的次数。接着，我们生成所有可能的结果；在这个例子中，这些结果是从`1`到骰子面数的所有数字
    ❷。我们遍历这些可能的值，统计每个数字在`results`中出现的次数 ❸，然后将此值添加到`frequencies`中 ❹。我们在生成可视化之前先打印出这个列表：
- en: '[PRE31]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'These results look reasonable: we see six frequencies, one for each possible
    number when you roll a D6\. We also see that no frequency is significantly higher
    than any other. Now let’s visualize these results.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这些结果看起来是合理的：我们看到六个频率，每个频率对应掷D6骰子时的一个可能数字。我们还看到没有任何一个频率显著高于其他频率。现在让我们将这些结果可视化。
- en: Making a Histogram
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建直方图
- en: 'Now that we have the data we want, we can generate a visualization in just
    a couple lines of code using Plotly Express:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有所需的数据，我们可以仅通过几行代码使用Plotly Express生成可视化图表：
- en: '**die_visual.py**'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**die_visual.py**'
- en: '[PRE32]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We first import the `plotly.express` module, using the conventional alias `px`.
    We then use the `px.bar()` function to create a bar graph. In the simplest use
    of this function, we only need to pass a set of *x-*values and a set of *y-*values.
    Here the *x*-values are the possible results from rolling a single die, and the
    *y*-values are the frequencies for each possible result.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入`plotly.express`模块，使用传统别名`px`。然后，我们使用`px.bar()`函数创建条形图。在该函数的最简单使用中，我们只需要传入一组*x-*值和一组*y-*值。这里的*x-*值是掷单个骰子可能的结果，而*y-*值是每个可能结果的频率。
- en: The final line calls `fig.show()`, which tells Plotly to render the resulting
    chart as an HTML file and open that file in a new browser tab. The result is shown
    in [Figure 15-12](#figure15-12).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行调用了`fig.show()`，这告诉Plotly渲染结果图表为HTML文件，并在新浏览器标签页中打开该文件。结果如[图15-12](#figure15-12)所示。
- en: This is a really simple chart, and it’s certainly not complete. But this is
    exactly how Plotly Express is meant to be used; you write a couple lines of code,
    look at the plot, and make sure it represents the data the way you want it to.
    If you like what you see, you can move on to customizing elements of the chart
    such as labels and styles. But if you want to explore other possible chart types,
    you can do so now, without having spent extra time on customization work. Feel
    free to try this now by changing `px.bar()` to something like `px.scatter()` or
    `px.line()`. You can find a full list of available chart types at [https://plotly.com/python/plotly-express](https://plotly.com/python/plotly-express).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个非常简单的图表，当然也不完整。但这正是Plotly Express的设计初衷；你写几行代码，查看图表，确保它准确地表示了你的数据。如果你喜欢看到的效果，可以继续自定义图表的标签和样式。如果你想探索其他可能的图表类型，你可以在没有花费额外时间进行自定义的情况下尝试。现在就可以通过将`px.bar()`更改为`px.scatter()`或`px.line()`等来试试。你可以在[https://plotly.com/python/plotly-express](https://plotly.com/python/plotly-express)找到所有可用图表类型的完整列表。
- en: This chart is dynamic and interactive. If you change the size of your browser
    window, the chart will resize to match the available space. If you hover over
    any of the bars, you’ll see a pop-up highlighting the specific data related to
    that bar.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 该图表是动态且交互式的。如果你调整浏览器窗口的大小，图表会自动调整大小以适应可用空间。如果你将鼠标悬停在任何一个柱状条上，你将看到一个弹出窗口，突出显示与该柱状条相关的特定数据。
- en: '![](image_fi/502703c15/f15012.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502703c15/f15012.png)'
- en: 'Figure 15-12: The initial plot produced by Plotly Express'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图15-12：Plotly Express生成的初始图表
- en: Customizing the Plot
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义图表
- en: Now that we know we have the correct kind of plot and our data is being represented
    accurately, we can focus on adding the appropriate labels and styles for the chart.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道图表类型正确，数据也被准确地呈现出来，我们可以专注于为图表添加适当的标签和样式。
- en: 'The first way to customize a plot with Plotly is to use some optional parameters
    in the initial call that generates the plot, in this case, `px.bar()`. Here’s
    how to add an overall title and a label for each axis:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Plotly自定义图表的第一种方式是在初始生成图表时使用一些可选参数，这里是`px.bar()`。以下是如何添加一个总体标题和每个轴的标签：
- en: '**die_visual.py**'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**die_visual.py**'
- en: '[PRE33]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We first define the title that we want, here assigned to `title` ❶. To define
    axis labels, we write a dictionary ❷. The keys in the dictionary refer to the
    labels we want to customize, and the values are the custom labels we want to use.
    Here we give the *x*-axis the label `Result` and the *y*-axis the label `Frequency
    of Result`. The call to `px.bar()` now includes the optional arguments `title`
    and `labels`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义了我们想要的标题，这里赋值给 `title` ❶。为了定义轴标签，我们写了一个字典 ❷。字典中的键是我们想要自定义的标签，值是我们想使用的自定义标签。这里，我们为
    *x* 轴赋予了 `Result` 标签，为 *y* 轴赋予了 `Frequency of Result` 标签。调用 `px.bar()` 时，现在包括了可选参数
    `title` 和 `labels`。
- en: Now when the plot is generated it includes an appropriate title and a label
    for each axis, as shown in [Figure 15-13](#figure15-13).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当绘图生成时，它包括了适当的标题和每个轴的标签，如[图 15-13](#figure15-13)所示。
- en: '![](image_fi/502703c15/f15013.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502703c15/f15013.png)'
- en: 'Figure 15-13: A simple bar chart created with Plotly'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15-13：使用 Plotly 创建的简单柱状图
- en: Rolling Two Dice
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 掷两个骰子
- en: 'Rolling two dice results in larger numbers and a different distribution of
    results. Let’s modify our code to create two D6 dice to simulate the way we roll
    a pair of dice. Each time we roll the pair, we’ll add the two numbers (one from
    each die) and store the sum in `results`. Save a copy of *die_visual.py* as *dice_visual.py*
    and make the following changes:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 掷两个骰子会得到更大的数字，并且结果的分布也不同。让我们修改代码，创建两个 D6 骰子，模拟我们掷一对骰子的方式。每次掷骰子时，我们将两个数字（每个骰子上的一个数字）相加，并将和存储在
    `results` 中。将 *die_visual.py* 保存为 *dice_visual.py*，并进行如下更改：
- en: '**dice_visual.py**'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**dice_visual.py**'
- en: '[PRE34]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: After creating two instances of `Die`, we roll the dice and calculate the sum
    of the two dice for each roll ❶. The smallest possible result (2) is the sum of
    the smallest number on each die. The largest possible result (12) is the sum of
    the largest number on each die, which we assign to `max_result` ❷. The variable
    `max_result` makes the code for generating `poss_results` much easier to read
    ❸. We could have written `range(2, 13)`, but this would work only for two D6 dice.
    When modeling real-world situations, it’s best to write code that can easily model
    a variety of situations. This code allows us to simulate rolling a pair of dice
    with any number of sides.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建了两个 `Die` 实例后，我们掷骰子并计算每次掷骰子的和 ❶。最小的可能结果（2）是每个骰子上的最小数字之和。最大的可能结果（12）是每个骰子上的最大数字之和，我们将其赋值给
    `max_result` ❷。变量 `max_result` 使得生成 `poss_results` 的代码更容易阅读 ❸。我们本可以写 `range(2,
    13)`，但这只适用于两个 D6 骰子。在模拟现实世界情况时，最好编写能轻松模拟多种情况的代码。这段代码允许我们模拟掷一对具有任意面数的骰子。
- en: After running this code, you should see a chart that looks like [Figure 15-14](#figure15-14).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码后，您应该会看到一个类似于[图 15-14](#figure15-14)的图表。
- en: '![](image_fi/502703c15/f15014.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502703c15/f15014.png)'
- en: 'Figure 15-14: Simulated results of rolling two six-sided dice 1,000 times'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15-14：模拟掷两个六面骰子 1,000 次的结果
- en: 'This graph shows the approximate distribution of results you’re likely to get
    when you roll a pair of D6 dice. As you can see, you’re least likely to roll a
    2 or a 12 and most likely to roll a 7\. This happens because there are six ways
    to roll a 7: 1 and 6, 2 and 5, 3 and 4, 4 and 3, 5 and 2, and 6 and 1.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 该图展示了您掷一对 D6 骰子时，可能得到的结果的大致分布。正如您所见，掷出 2 或 12 的可能性最小，而掷出 7 的可能性最大。之所以这样，是因为掷出
    7 有六种方式：1 和 6，2 和 5，3 和 4，4 和 3，5 和 2，6 和 1。
- en: Further Customizations
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 进一步自定义
- en: There’s one issue that we should address with the plot we just generated. Now
    that there are 11 bars, the default layout settings for the *x*-axis leave some
    of the bars unlabeled. While the default settings work well for most visualizations,
    this chart would look better with all of the bars labeled.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚生成的图表有一个问题需要解决。由于现在有 11 根柱子，*x* 轴的默认布局设置导致一些柱子没有标签。虽然默认设置适用于大多数可视化，但这个图表如果将所有柱子标注上，会看起来更好。
- en: 'Plotly has an `update_layout()` method that can be used to make a wide variety
    of updates to a figure after it’s been created. Here’s how to tell Plotly to give
    each bar its own label:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Plotly 有一个 `update_layout()` 方法，可以在图形创建后对其进行各种更新。以下是告诉 Plotly 给每个柱子添加标签的方法：
- en: '**dice_visual.py**'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '**dice_visual.py**'
- en: '[PRE35]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `update_layout()` method acts on the `fig` object, which represents the
    overall chart. Here we use the `xaxis_dtick` argument, which specifies the distance
    between tick marks on the *x*-axis. We set that spacing to `1`, so that every
    bar is labeled. When you run *dice_visual.py* again, you should see a label on
    each bar.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`update_layout()`方法作用于`fig`对象，该对象表示整个图表。在这里，我们使用了`xaxis_dtick`参数，该参数指定了*x*轴上刻度线之间的间距。我们将间距设置为`1`，这样每个条形图上都会有标签。当你再次运行*dice_visual.py*时，你应该能看到每个条形图上都有标签。'
- en: Rolling Dice of Different Sizes
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 掷不同大小的骰子
- en: 'Let’s create a six-sided die and a ten-sided die, and see what happens when
    we roll them 50,000 times:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个六面骰和一个十面骰，看看当我们掷它们50,000次时会发生什么：
- en: '**dice_visual_d6d10.py**'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '**dice_visual_d6d10.py**'
- en: '[PRE36]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: To make a D10, we pass the argument `10` when creating the second `Die` instance
    ❶ and change the first loop to simulate 50,000 rolls instead of 1,000\. We change
    the title of the graph as well ❷.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 为了制作D10，我们在创建第二个`Die`实例时传递参数`10` ❶，并将第一个循环更改为模拟50,000次掷骰，而不是1,000次。我们还更改了图表的标题
    ❷。
- en: '[Figure 15-15](#figure15-15) shows the resulting chart. Instead of one most
    likely result, there are five such results. This happens because there’s still
    only one way to roll the smallest value (1 and 1) and the largest value (6 and
    10), but the smaller die limits the number of ways you can generate the middle
    numbers. There are six ways to roll a 7, 8, 9, 10, or 11, these are the most common
    results, and you’re equally likely to roll any one of them.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '[图15-15](#figure15-15)显示了结果图表。与只有一个最可能结果的情况不同，这里有五个这样的结果。这是因为掷出最小值（1和1）和最大值（6和10）的方法只有一种，但较小的骰子限制了生成中间数字的方式。掷出7、8、9、10或11有六种方式，这些是最常见的结果，你有相同的概率掷出其中的任何一个。'
- en: '![](image_fi/502703c15/f15015.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502703c15/f15015.png)'
- en: 'Figure 15-15: The results of rolling a six-sided die and a ten-sided die 50,000
    times'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图15-15：掷一个六面骰和一个十面骰50,000次的结果
- en: Our ability to use Plotly to model the rolling of dice gives us considerable
    freedom in exploring this phenomenon. In just minutes, you can simulate a tremendous
    number of rolls using a large variety of dice.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Plotly模拟骰子掷出的能力，给了我们相当大的自由度来探索这一现象。在短短几分钟内，你可以使用各种骰子模拟大量的掷骰结果。
- en: Saving Figures
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保存图形
- en: 'When you have a figure you like, you can always save the chart as an HTML file
    through your browser. But you can also do so programmatically. To save your chart
    as an HTML file, replace the call to `fig.show()` with a call to `fig.write_html()`:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 当你得到一个喜欢的图形时，你可以通过浏览器将图表保存为HTML文件。但你也可以通过编程方式实现这一点。要将图表保存为HTML文件，只需将对`fig.show()`的调用替换为对`fig.write_html()`的调用：
- en: '[PRE37]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `write_html()` method requires one argument: the name of the file to write
    to. If you only provide a filename, the file will be saved in the same directory
    as the *.py* file. You can also call `write_html()` with a `Path` object, and
    write the output file anywhere you want on your system.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`write_html()`方法需要一个参数：要写入的文件名。如果你只提供文件名，文件将保存在与*.py*文件相同的目录中。你也可以通过`Path`对象调用`write_html()`，并将输出文件保存到系统中的任何位置。'
- en: Summary
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned to generate datasets and create visualizations
    of that data. You created simple plots with Matplotlib and used a scatter plot
    to explore random walks. You also created a histogram with Plotly, and used it
    to explore the results of rolling dice of different sizes.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了生成数据集并创建数据的可视化。你使用Matplotlib创建了简单的图表，并使用散点图探索了随机游走。你还使用Plotly创建了一个直方图，并用它来探索掷不同大小骰子的结果。
- en: Generating your own datasets with code is an interesting and powerful way to
    model and explore a wide variety of real-world situations. As you continue to
    work through the data visualization projects that follow, keep an eye out for
    situations you might be able to model with code. Look at the visualizations you
    see in news media, and see if you can identify those that were generated using
    methods similar to the ones you’re learning in these projects.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 使用代码生成自己的数据集是一种有趣且强大的方式，可以模拟和探索各种现实世界的情况。在接下来的数据可视化项目中，保持警觉，看看你是否能找到可以通过代码模拟的情景。观察新闻媒体中的可视化内容，看看你能否识别出那些是使用类似于你在这些项目中学习的方式生成的。
- en: In Chapter 16, you’ll download data from online sources and continue to use
    Matplotlib and Plotly to explore that data.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在第16章中，你将从在线源下载数据，并继续使用Matplotlib和Plotly探索这些数据。
