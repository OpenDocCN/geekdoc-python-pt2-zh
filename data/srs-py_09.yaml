- en: '**9**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**9**'
- en: '**THE ABSTRACT SYNTAX TREE, HY, AND LISP-LIKE ATTRIBUTES**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**抽象语法树、Hy 和类似 Lisp 的属性**'
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: The *abstract syntax tree (AST)* is a representation of the structure of the
    source code of any programming language. Every language, including Python, has
    a specific AST; Python’s AST is built by parsing a Python source file. Like any
    tree, this one is made of nodes linked together. A node can represent an operation,
    a statement, an expression, or even a module. Each node can contain references
    to other nodes that make up the tree.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*抽象语法树（AST）* 是任何编程语言源代码结构的表示。每种语言，包括 Python，都有一个特定的 AST；Python 的 AST 通过解析 Python
    源文件来构建。像任何树一样，它由相互连接的节点构成。一个节点可以表示一个操作、一个语句、一个表达式，甚至是一个模块。每个节点都可以包含指向构成树的其他节点的引用。'
- en: Python’s AST is not heavily documented and is thus hard to deal with at first
    glance, but understanding some deeper aspects of how Python is constructed can
    help you master its usage.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的 AST 并没有被充分文档化，因此乍一看可能很难处理，但理解 Python 构建的一些更深层次的方面有助于你掌握它的使用。
- en: This chapter will examine the AST of some simple Python commands to get you
    familiar with the structure and how it’s used. Once you’re familiar with the AST,
    we’ll build a program that can check for wrongly declared methods using `flake8`
    and the AST. Finally, we’ll look at Hy, a Python-Lisp hybrid language built on
    the Python AST.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将检查一些简单的 Python 命令的 AST，以帮助你熟悉其结构和使用方式。熟悉 AST 后，我们将构建一个程序，使用 `flake8` 和 AST
    来检查错误声明的方法。最后，我们将介绍 Hy，这是一种基于 Python AST 构建的 Python-Lisp 混合语言。
- en: '**Looking at the AST**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**查看 AST**'
- en: The easiest way to view the Python AST is to parse some Python code and dump
    the generated AST. For that, the Python `ast` module provides everything you need,
    as shown in [Listing 9-1](ch09.xhtml#ch9list1).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 Python AST 最简单的方法是解析一些 Python 代码并转储生成的 AST。为此，Python 的 `ast` 模块提供了你所需的一切，如
    [清单 9-1](ch09.xhtml#ch9list1) 所示。
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 9-1: Using the ast module to dump the AST generated by parsing code*'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-1：使用 ast 模块转储解析代码生成的 AST*'
- en: 'The `ast.parse()` function parses any string that contains Python code and
    returns an `_ast.Module` object. That object is actually the root of the tree:
    you can browse it to discover every node making up the tree. To visualize what
    the tree looks like, you can use the `ast.dump()` function, which will return
    a string representation of the whole tree.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`ast.parse()` 函数解析包含 Python 代码的任何字符串，并返回一个 `_ast.Module` 对象。这个对象实际上是树的根节点：你可以浏览它来发现构成树的每个节点。为了可视化树的结构，你可以使用
    `ast.dump()` 函数，它将返回整个树的字符串表示。'
- en: In [Listing 9-1](ch09.xhtml#ch9list1), the code `x = 42` is parsed with `ast.parse()`,
    and the result is printed using `ast.dump()`. This abstract syntax tree can be
    rendered as shown in [Figure 9-1](ch09.xhtml#ch9fig1), which shows the structure
    of the Python `assign` command.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [清单 9-1](ch09.xhtml#ch9list1) 中，代码 `x = 42` 使用 `ast.parse()` 进行解析，并使用 `ast.dump()`
    打印结果。这个抽象语法树可以渲染为 [图 9-1](ch09.xhtml#ch9fig1) 所示，展示了 Python `assign` 命令的结构。
- en: '![image](../images/f09-01.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f09-01.jpg)'
- en: '*Figure 9-1: The AST of the assign command in Python*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-1：Python 中赋值命令的 AST*'
- en: The AST always starts with a root element, which is usually an _`ast.Module`
    object. This module object contains a list of statements or expressions to evaluate
    in its *body* attribute and usually represents the content of a file.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: AST 总是从根元素开始，通常是一个 _`ast.Module` 对象。这个模块对象包含一个要在其 *body* 属性中评估的语句或表达式列表，通常表示文件的内容。
- en: As you can probably guess, the `ast.Assign` object shown in [Figure 9-1](ch09.xhtml#ch9fig1)
    represents an *assignment*, which is mapped to the `=` sign in the Python syntax.
    An `ast.Assign` object has a list of *targets* and a *value* to set the targets
    to. The list of targets in this case consists of one object, `ast.Name`, which
    represents a variable whose ID is *x*. The value is a number *n* with a value
    (in this case) 42\. The ctx attribute stores a *context*, either `ast.Store` or
    `ast.Load`, depending on whether the variable is being used for reading or writing.
    In this case, the variable is being assigned a value, so an `ast.Store` context
    is used.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能猜到的，[图 9-1](ch09.xhtml#ch9fig1) 中展示的 `ast.Assign` 对象表示一个 *赋值*，它映射到 Python
    语法中的 `=` 符号。`ast.Assign` 对象有一个 *targets* 列表和一个 *value*，用于将目标设置为相应的值。在这个例子中，目标列表包含一个对象
    `ast.Name`，它表示一个变量，其 ID 是 *x*。值是一个数字 *n*，它的值为（在此例中）42。ctx 属性存储一个 *context*，它可以是
    `ast.Store` 或 `ast.Load`，取决于变量是用于读取还是写入。在此例中，变量正在被赋值，因此使用了 `ast.Store` 上下文。
- en: We could pass this AST to Python to be compiled and evaluated via the built-in
    `compile()` function. This function takes an AST as argument, the source filename,
    and a mode (either `'exec'`, `'eval'`, or `'single'`). The source filename can
    be any name that you want your AST to appear to be from; it is common to use the
    string `<input>` as the source filename if the data does not come from a stored
    file, as shown in [Listing 9-2](ch09.xhtml#ch9list2).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个 AST 传递给 Python，通过内置的 `compile()` 函数进行编译和求值。该函数接受一个 AST 作为参数、源文件名以及模式（可以是
    `'exec'`、`'eval'` 或 `'single'`）。源文件名可以是任何你希望给 AST 起的名字；如果数据不是来自存储的文件，通常会使用字符串
    `<input>` 作为源文件名，如 [Listing 9-2](ch09.xhtml#ch9list2) 所示。
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 9-2: Using the compile() function to compile data that is not from
    a stored file*'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 9-2: 使用 compile() 函数编译来自非存储文件的数据*'
- en: The modes stand for execute (`exec`), evaluate (`eval`), and single statement
    (`single`). The mode should match what has been given to `ast.parse()`, whose
    default is `exec`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 模式分别代表执行（`exec`）、求值（`eval`）和单个语句（`single`）。模式应与传递给 `ast.parse()` 的内容匹配，默认模式是
    `exec`。
- en: The `exec` mode is the normal Python mode, used when an _`ast.Module` is the
    root of the tree.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exec` 模式是正常的 Python 模式，当 _`ast.Module` 是树的根时使用此模式。'
- en: The `eval` mode is a special mode that expects a single `ast.Expression` as
    the tree.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eval` 模式是一种特殊模式，期望树的根是单个 `ast.Expression`。'
- en: Finally, `single` is another special mode that expects a single statement or
    expression. If it gets an expression, `sys.displayhook()` will be called with
    the result, as when code is run in the interactive shell.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，`single` 是另一种特殊模式，它期望一个单一的语句或表达式。如果它得到一个表达式，`sys.displayhook()` 会被调用并显示结果，就像在交互式命令行中执行代码一样。
- en: The root of the AST is `ast.Interactive`, and its `body` attribute is a list
    of nodes.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: AST 的根是 `ast.Interactive`，其 `body` 属性是节点的列表。
- en: We could build an AST manually using the classes provided in the `ast` module.
    Obviously, this is a very long way to write Python code and not a method I would
    recommend! Nonetheless, it’s fun to do and helpful for learning about the AST.
    Let’s see what programming with the AST would look like.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `ast` 模块提供的类手动构建 AST。显然，这是一种非常繁琐的编写 Python 代码的方式，并不是我推荐的方法！尽管如此，这样做很有趣，而且对学习
    AST 有帮助。让我们看看使用 AST 编程会是什么样子。
- en: '***Writing a Program Using the AST***'
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 AST 编写程序***'
- en: Let’s write a good old `"Hello world!"` program in Python by building an abstract
    syntax tree manually.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过手动构建抽象语法树（AST）来写一个经典的 `"Hello world!"` Python 程序。
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 9-3: Writing hello world! using the AST*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 9-3: 使用 AST 编写 hello world！*'
- en: In [Listing 9-3](ch09.xhtml#ch9list3), we build the tree one leaf at a time,
    where each leaf is an element (whether a value or an instruction) of the program.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [Listing 9-3](ch09.xhtml#ch9list3) 中，我们一次构建一个叶子，每个叶子都是程序的一个元素（无论是值还是指令）。
- en: 'The first leaf is a simple string ➊: the `ast.Str` represents a literal string,
    which here contains the `hello world!` text. The `print_name` variable ➋ contains
    an `ast.Name` object, which refers to a variable—in this case, the `print` variable
    that points to the `print()` function.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个叶子是一个简单的字符串 ➊：`ast.Str` 代表一个字面量字符串，这里包含了 `hello world!` 文本。`print_name` 变量
    ➋ 包含一个 `ast.Name` 对象，它指向一个变量——在此案例中，指向 `print` 变量，该变量指向 `print()` 函数。
- en: The `print_call` variable ➌ contains a function call. It refers to the function
    name to call, the regular arguments to pass to the function call, and the keyword
    arguments. Which arguments are used depend on the functions being called. In this
    case, since it’s the `print()` function, we’ll pass the string we made and stored
    in `hello_world`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`print_call` 变量 ➌ 包含一个函数调用。它指向要调用的函数名、传递给函数调用的常规参数和关键字参数。使用哪些参数取决于调用的函数。在这种情况下，由于它是
    `print()` 函数，我们将传递我们制作并存储在 `hello_world` 中的字符串。'
- en: At last, we create an _`ast.Module` object ➍ to contain all this code as a list
    of one expression. We can compile _`ast.Module` objects using the `compile()`
    function ➎, which parses the tree and generates a native `code` object. These
    `code` objects are compiled Python code and can finally be executed by a Python
    virtual machine using `eval`!
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建一个 _`ast.Module` 对象 ➍ 来将所有这些代码作为一个表达式的列表。我们可以使用 `compile()` 函数 ➎ 编译 _`ast.Module`
    对象，该函数会解析树并生成一个本地的 `code` 对象。这些 `code` 对象是编译后的 Python 代码，最终可以通过 Python 虚拟机使用 `eval`
    执行！
- en: 'This whole process is exactly what happens when you run Python on a *.py* file:
    once the text tokens are parsed, they are converted into a tree of `ast` objects,
    compiled, and evaluated.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 整个过程正是你运行Python时在*.py*文件上发生的事情：一旦文本令牌被解析，它们会转换成`ast`对象的树，然后被编译并执行。
- en: '**NOTE**'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The arguments lineno and col_offset represent the line number and column offset,
    respectively, of the source code that has been used to generate the AST. It doesn’t
    make much sense to set these values in this context since we are not parsing a
    source file, but it can be useful to be able to find the position of the code
    that generated the AST. For example, Python uses this information when generating
    backtraces. Indeed, Python refuses to compile an AST object that doesn’t provide
    this information, so we pass fake values to these. You could also use the ast.fix_missing_locations()
    function to set the missing values to the ones set on the parent node.*'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*参数lineno和col_offset分别表示用于生成AST的源代码的行号和列偏移。由于我们没有解析源文件，因此在此上下文中设置这些值没有太大意义，但能够找到生成AST的代码的位置是有用的。例如，Python在生成回溯信息时会使用这些信息。事实上，Python会拒绝编译不提供这些信息的AST对象，因此我们向这些值传递假数据。你还可以使用`ast.fix_missing_locations()`函数将缺失的值设置为父节点上设置的值。*'
- en: '***The AST Objects***'
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***AST对象***'
- en: You can view the whole list of objects available in the AST by reading the `_ast`
    module documentation (note the underscore).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过阅读`_ast`模块的文档（注意下划线）查看AST中所有可用的对象列表。
- en: 'The objects are organized into two main categories: statements and expressions.
    *Statements* include types such as `assert`, assignment (`=`), augmented assignment
    (`+=`, `/=`, etc.), `global`, `def`, `if`, `return`, `for`, `class`, `pass`, `import`,
    `raise`, and so forth. Statements inherit from `ast.stmt`; they influence the
    control flow of a program and are often composed of expressions.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对象分为两大类：语句和表达式。*语句*包括`assert`、赋值（`=`）、增量赋值（`+=`、`/=`等）、`global`、`def`、`if`、`return`、`for`、`class`、`pass`、`import`、`raise`等类型。语句继承自`ast.stmt`；它们影响程序的控制流，并且通常由表达式组成。
- en: '*Expressions* include types such as `lambda`, `number`, `yield`, `name` (variable),
    `compare`, and `call`. Expressions inherit from `ast.expr`; they differ from statements
    in that they usually produce a value and have no impact on the program flow.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*表达式*包括`lambda`、`number`、`yield`、`name`（变量）、`compare`和`call`等类型。表达式继承自`ast.expr`；它们与语句不同，通常会产生一个值并且不会影响程序的流程。'
- en: There are also a few smaller categories, such as the `ast.operator` class, which
    defines standard operators such as *add* (`+`), *div* (`/`), and *right shift*
    (`>>`), and the `ast.cmpop` module, which defines comparisons operators.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些更小的类别，如`ast.operator`类，它定义了标准的运算符，如*加法* (`+`)、*除法* (`/`)和*右移* (`>>`)，以及`ast.cmpop`模块，它定义了比较运算符。
- en: The simple example here should give you an idea of how to build an AST from
    scratch. It’s easy to then imagine how you might leverage this AST to construct
    a compiler that would parse strings and generate code, allowing you to implement
    your own syntax to Python! This is exactly what led to the development of the
    Hy project, which we’ll discuss later in this chapter.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的简单示例应该能让你了解如何从零开始构建AST。然后，你可以很容易地想象如何利用这个AST构建一个解析字符串并生成代码的编译器，从而实现你自己的Python语法！这正是促使Hy项目发展的原因，稍后我们将在本章中讨论它。
- en: '***Walking Through an AST***'
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***遍历AST***'
- en: To follow how a tree is built or access particular nodes, you sometimes need
    to walk through your tree, browsing it and iterating over the nodes. You can do
    this with the `ast.walk()` function. Alternatively, the `ast` module also provides
    `NodeTransformer`, a class that you can subclass to walk through an AST and modify
    particular nodes. Using `NodeTransformer` makes it easy to change code dynamically,
    as shown in [Listing 9-4](ch09.xhtml#ch9list4).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟踪树的构建过程或访问特定节点，你有时需要遍历树，浏览并迭代节点。你可以使用`ast.walk()`函数来完成这项工作。或者，`ast`模块还提供了`NodeTransformer`类，你可以通过继承它来遍历AST并修改特定节点。使用`NodeTransformer`可以轻松地动态改变代码，如[示例9-4](ch09.xhtml#ch9list4)所示。
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 9-4: Walking a tree with NodeTransformer to alter a node*'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例9-4：使用NodeTransformer遍历树以更改节点*'
- en: The first `tree` object built ➊ is an AST that represents the expression `x
    = 1/3`. Once this is compiled and evaluated, the result of printing `x` at the
    end of the function ➋ is `0.33333`, the expected result of `1/3`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`tree`对象➊是一个抽象语法树（AST），它表示表达式`x = 1/3`。一旦这段代码被编译和执行，函数结束时打印`x`的结果➋是`0.33333`，即`1/3`的预期结果。
- en: The second `tree` object ➌ is an instance of `ReplaceBinOp`, which inherits
    from `ast.NodeTransformer`. It implements its own version of the `ast.NodeTransformer.visit()`
    method and changes any `ast.BinOp` operation to an `ast.BinOp` that executes `ast.Add`.
    Concretely, this changes any binary operator (`+`, `-`, `/`, and so on) to the
    `+` operator. When this second tree is compiled and evaluated ➍, the result is
    now `4`, which is the result of `1 + 3`, because the `/` in the first object is
    replaced with `+`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个`tree`对象➌是`ReplaceBinOp`的一个实例，它继承自`ast.NodeTransformer`。它实现了自己版本的`ast.NodeTransformer.visit()`方法，并将任何`ast.BinOp`操作改为执行`ast.Add`的`ast.BinOp`。具体来说，这将任何二元操作符（`+`、`-`、`/`等）替换为`+`操作符。当第二棵树被编译和执行后➍，结果现在是`4`，这是`1
    + 3`的结果，因为第一个对象中的`/`被替换成了`+`。
- en: 'You can see the execution of the program here:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里看到程序的执行：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**NOTE**'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you need to evaluate a string that should return a simple data type, you
    can use ast.literal_eval. As a safer alternative to eval, it prevents the input
    string from executing any code.*'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你需要评估一个应返回简单数据类型的字符串，可以使用`ast.literal_eval`。作为`eval`的更安全替代，它防止输入的字符串执行任何代码。*'
- en: '**Extending flake8 with AST Checks**'
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**通过AST检查扩展flake8**'
- en: In [Chapter 7](ch07.xhtml#ch07), you learned that methods that do not rely on
    the object state should be declared static with the `@staticmethod` decorator.
    The problem is that a lot of developers simply forget to do so. I’ve personally
    spent too much time reviewing code and asking people to fix this problem.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](ch07.xhtml#ch07)中，你学到了不依赖于对象状态的方法应当使用`@staticmethod`装饰器声明为静态方法。问题在于，很多开发者常常忘记这么做。我个人也花了太多时间审查代码并要求别人修复这个问题。
- en: We’ve seen how to use `flake8` to do some automatic checking in the code. In
    fact, `flake8` is extensible and can provide even more checks. We’ll write a `flake8`
    extension that checks for static method declaration omission by analyzing the
    AST.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何使用`flake8`进行一些自动代码检查。实际上，`flake8`是可扩展的，可以提供更多的检查。我们将编写一个`flake8`扩展，利用AST检查是否省略了静态方法声明。
- en: '[Listing 9-5](ch09.xhtml#ch9list5) shows an example of one class that omits
    the static declaration and one that correctly includes it. Write this program
    out and save it as *ast_ext.py*; we’ll use it in a moment to write our extension.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 9-5](ch09.xhtml#ch9list5)展示了一个省略静态声明的类和一个正确包含静态声明的类。将此程序写出并保存为*ast_ext.py*；我们稍后将在其中编写扩展程序。'
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 9-5: Omitting and including @staticmethod*'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-5：省略和包含@staticmethod*'
- en: 'Though the `Bad.foo` method works fine, strictly speaking it is more correct
    to write it as `OK.foo` (turn back to [Chapter 7](ch07.xhtml#ch07) for more detail
    on why). To check whether all the methods in a Python file are correctly declared,
    we need to do the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`Bad.foo`方法可以正常工作，但严格来说，写成`OK.foo`更为正确（有关原因，请返回查看[第7章](ch07.xhtml#ch07)）。为了检查Python文件中的所有方法是否都已正确声明，我们需要执行以下操作：
- en: Iterate over all the statement nodes of the AST.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历AST的所有语句节点。
- en: Check that the statement is a class definition (`ast.ClassDef`).
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查语句是否是类定义（`ast.ClassDef`）。
- en: Iterate over all the function definitions (`ast.FunctionDef`) of that class
    statement to check whether it is already declared with `@staticmethod`.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历该类语句的所有函数定义（`ast.FunctionDef`），检查它们是否已用`@staticmethod`声明。
- en: If the method is not declared static, check whether the first argument (`self`)
    is used somewhere in the method. If `self` is not used, the method can be tagged
    as potentially miswritten.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果方法没有声明为静态方法，检查方法中是否使用了第一个参数（`self`）。如果`self`未被使用，则该方法可能被标记为写错了。
- en: The name of our project will be `ast_ext`. To register a new plugin in `flake8`,
    we need to create a packaged project with the usual *setup.py* and *setup.cfg*
    files. Then, we just need to add an entry point in the *setup.cfg* of our `ast_ext`
    project.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们项目的名称将是`ast_ext`。为了在`flake8`中注册一个新插件，我们需要创建一个包含常规*setup.py*和*setup.cfg*文件的打包项目。然后，我们只需要在`ast_ext`项目的*setup.cfg*中添加一个入口点。
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 9-6: Allowing flake8 plugins for our chapter*'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-6：允许flake8插件用于我们的章节*'
- en: In [Listing 9-6](ch09.xhtml#ch9list6), we also register two `flake8` error codes.
    As you’ll notice later, we are actually going to add an extra check to our code
    while we’re at it!
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [清单 9-6](ch09.xhtml#ch9list6) 中，我们还注册了两个 `flake8` 错误代码。正如你稍后会注意到的，我们在此过程中实际上会为我们的代码添加一个额外的检查！
- en: The next step is to write the plugin.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是编写插件。
- en: '***Writing the Class***'
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***编写类***'
- en: Since we are writing a `flake8` check of the AST, the plugin needs to be a class
    following a certain signature, as shown in [Listing 9-7](ch09.xhtml#ch9list7).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在编写一个针对 AST 的 `flake8` 检查，插件需要是一个遵循特定签名的类，如 [清单 9-7](ch09.xhtml#ch9list7)
    所示。
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 9-7: The class for checking the AST*'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-7：用于检查 AST 的类*'
- en: 'The default template is easy to understand: it stores the tree locally for
    use in the `run()` method, which will *yield* the problems that are discovered.
    The value that will be yielded must follow the expected PEP 8 signature: a tuple
    of the form `(lineno`, col_offset, error_string, code).'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 默认模板很容易理解：它将树本地存储以便在 `run()` 方法中使用，该方法将 *生成* 发现的问题。生成的值必须遵循预期的 PEP 8 签名：一个元组，形式为
    `(lineno`, col_offset, error_string, code)`。
- en: '***Ignoring Irrelevant Code***'
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***忽略无关的代码***'
- en: As indicated earlier, the `ast` module provides the `walk()` function, which
    allows you to iterate easily on a tree. We’ll use that to walk through the AST
    and find out what to check and what not to check.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面所述，`ast` 模块提供了 `walk()` 函数，允许你轻松地遍历树。我们将使用它来遍历 AST，找出需要检查的内容和不需要检查的内容。
- en: First, let’s write a loop that ignores the statements that are not class definitions.
    Add this to your `ast_ext` project, as shown in [Listing 9-8](ch09.xhtml#ch9list8);
    code that should stay the same is grayed out.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们编写一个循环，忽略那些不是类定义的语句。将此代码添加到你的 `ast_ext` 项目中，如 [清单 9-8](ch09.xhtml#ch9list8)
    所示；应该保持不变的代码会被灰色标出。
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 9-8: Ignoring statements that are not class definitions*'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-8：忽略不是类定义的语句*'
- en: The code in [Listing 9-8](ch09.xhtml#ch9list8) is still not checking for anything,
    but now it knows how to ignore statements that are not class definitions. The
    next step is to set our checker to ignore anything that is not a function definition.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 9-8](ch09.xhtml#ch9list8) 中的代码仍然没有进行任何检查，但现在它知道如何忽略不是类定义的语句。下一步是将我们的检查器设置为忽略任何不是函数定义的语句。'
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 9-9: Ignoring statements that are not function definitions*'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-9：忽略不是函数定义的语句*'
- en: In [Listing 9-9](ch09.xhtml#ch9list9), we ignore irrelevant statements by iterating
    over the attributes of the class definition.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [清单 9-9](ch09.xhtml#ch9list9) 中，我们通过遍历类定义的属性来忽略无关的语句。
- en: '***Checking for the Correct Decorator***'
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***检查正确的装饰器***'
- en: We’re all set to write the checking method, which is stored in the `body_item`
    attribute. First, we need to check whether the method that’s being checked is
    already declared as static. If it is, we don’t have to do any further checking
    and can bail out.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已准备好编写检查方法，该方法存储在 `body_item` 属性中。首先，我们需要检查被检查的方法是否已经声明为静态方法。如果是，则不需要进一步检查，可以直接退出。
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 9-10: Checking for the static decorator*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-10：检查静态装饰器*'
- en: Note that in [Listing 9-10](ch09.xhtml#ch9list10), we use the special `for/else`
    form of Python, where the `else` is evaluated unless we use `break` to exit the
    `for` loop. At this point, we’re able to detect whether a method is declared static.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在 [清单 9-10](ch09.xhtml#ch9list10) 中，我们使用 Python 的特殊 `for/else` 形式，其中 `else`
    会被评估，除非我们使用 `break` 退出 `for` 循环。到目前为止，我们已经能够检测方法是否被声明为静态方法。
- en: '***Looking for self***'
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***寻找自我***'
- en: The next step is to check whether the method that *isn’t* declared as static
    uses the `self` argument. First, check whether the method includes any arguments
    at all, as shown in [Listing 9-11](ch09.xhtml#ch9list11).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是检查没有声明为静态方法的方法是否使用了 `self` 参数。首先，检查方法是否包含任何参数，如 [清单 9-11](ch09.xhtml#ch9list11)
    所示。
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 9-11: Checking the method for arguments*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-11：检查方法的参数*'
- en: 'We finally added a check! This `try` statement in [Listing 9-11](ch09.xhtml#ch9list11)
    grabs the first argument from the method signature. If the code fails to retrieve
    the first argument from the signature because a first argument doesn’t exist,
    we already know there’s a problem: you can’t have a bound method without the `self`
    argument. If the plugin detects that case, it raises the `H905` error code we
    set earlier, signaling a method that misses its first argument.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于添加了一个检查！[清单9-11](ch09.xhtml#ch9list11)中的`try`语句会从方法签名中获取第一个参数。如果代码无法从签名中获取第一个参数，因为没有第一个参数，我们就知道出现了问题：没有`self`参数，就不能有绑定方法。如果插件检测到这种情况，它会引发我们之前设置的`H905`错误代码，表示方法缺少第一个参数。
- en: '**NOTE**'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*PEP 8 codes follow a particular format for error codes (a letter followed
    by a number), but there are no rules as to which code to pick. You could come
    up with any other code for this error, as long as it’s not already used by PEP
    8 or another extension.*'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*PEP 8错误代码遵循特定格式（字母后跟数字），但并没有规定应该选择哪个代码。你可以为这个错误创建任何其他代码，只要它没有被PEP 8或其他扩展使用。*'
- en: 'Now you know why we registered two error codes in *setup.cfg*: we had a good
    opportunity to kill two birds with one stone.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道为什么我们在*setup.cfg*中注册了两个错误代码：我们有一个很好的机会一箭双雕。
- en: The next step is to check whether the `self` argument is used in the code of
    the method.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是检查方法代码中是否使用了`self`参数。
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 9-12: Checking the method for the self argument*'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单9-12：检查方法中的self参数*'
- en: To check whether the `self` argument is used in the method’s body, the plugin
    in [Listing 9-12](ch09.xhtml#ch9list12) iterates recursively, using `ast.walk`
    on the body and looking for the use of the variable named `self`. If the variable
    isn’t found, the program finally yields the `H904` error code. Otherwise, nothing
    happens, and the code is considered sane.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查方法体中是否使用了`self`参数，[清单9-12](ch09.xhtml#ch9list12)中的插件会递归地使用`ast.walk`遍历方法体，查找名为`self`的变量。如果未找到该变量，程序最终会返回`H904`错误代码。否则，什么都不会发生，代码被认为是有效的。
- en: '**NOTE**'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*As you may have noticed, the code walks over the module AST definition several
    times. There might be some degree of optimization to browsing the AST in only
    one pass, but I’m not sure it’s worth it, given how the tool is actually used.
    I’ll leave that exercise to you, dear reader.*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*正如你可能已经注意到的，代码多次遍历模块的AST定义。虽然可能有一定程度的优化空间，可以只遍历一次AST，但考虑到工具的实际使用方式，我不确定这样做是否值得。我把这个练习留给你，亲爱的读者。*'
- en: Knowing the Python AST is not strictly necessary for using Python, but it does
    give powerful insight into how the language is built and how it works. It thus
    gives you a better understanding of how the code you write is being used under
    the hood.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 了解Python AST并非使用Python的必需知识，但它确实能提供关于语言构建和工作原理的强大洞察力。它让你更好地理解你写的代码是如何在幕后被使用的。
- en: '**A Quick Introduction to Hy**'
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Hy简介**'
- en: Now that you have a good understanding of how Python AST works, you can start
    dreaming of creating a new syntax for Python. You could parse this new syntax,
    build an AST out of it, and compile it down to Python code.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经对Python AST的工作原理有了很好的理解，你可以开始构思为Python创建一种新的语法。你可以解析这种新语法，构建出一个AST，并将其编译成Python代码。
- en: 'This is exactly what Hy does. *Hy* is a Lisp dialect that parses a Lisp-like
    language and converts it to regular Python AST, making it fully compatible with
    the Python ecosystem. You could compare it to what Clojure is to Java. Hy could
    fill a book by itself, so we will only skim over it. Hy uses the syntax and some
    features of the Lisp family of languages: it’s functionally oriented, provides
    macros, and is easily extensible.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是Hy所做的。*Hy*是一个Lisp方言，它解析类似Lisp的语言并将其转换为常规的Python AST，使其与Python生态系统完全兼容。你可以把它与Clojure对Java的作用进行比较。Hy本身可以填满一本书，所以我们只会略过它。Hy使用Lisp家族语言的语法和一些特性：它是面向函数的，提供宏，并且易于扩展。
- en: If you’re not already familiar with Lisp—and you should be—the Hy syntax will
    look familiar. Once you install Hy (by running `pip install hy`), launching the
    `hy` interpreter will give you a standard REPL prompt from which you can start
    to interact with the interpreter, as shown in [Listing 9-13](ch09.xhtml#ch9list13).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还不熟悉Lisp——你应该了解一下——Hy的语法会显得很熟悉。一旦你安装了Hy（通过运行`pip install hy`），启动`hy`解释器会给你一个标准的REPL提示符，你可以从这里开始与解释器进行交互，如[清单9-13](ch09.xhtml#ch9list13)所示。
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 9-13: Interacting with the Hy interpreter*'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单9-13：与Hy解释器交互*'
- en: 'For those not familiar with the Lisp syntax, parentheses are used to construct
    lists. If a list is unquoted, it is evaluated: the first element must be a function,
    and the rest of the items from the list are passed as arguments. Here the code
    `(+ 1 2)` is equivalent to `1 + 2` in Python.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些不熟悉 Lisp 语法的人，括号用于构造列表。如果列表没有加引号，它会被求值：第一个元素必须是一个函数，列表中的其余项作为参数传递。在这里，代码`(+
    1 2)`相当于 Python 中的`1 + 2`。
- en: In Hy, most constructs, such as function definitions, are mapped from Python
    directly.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Hy 中，大多数构造（如函数定义）都是直接从 Python 映射而来的。
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 9-14: Mapping a function definition from Python*'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 9-14：从 Python 映射函数定义*'
- en: 'As shown in [Listing 9-14](ch09.xhtml#ch9list14), internally Hy parses the
    code provided, converts it to a Python AST, compiles it, and evaluates it. Fortunately,
    Lisp is an easy tree to parse: each pair of parentheses represents a node of the
    tree, meaning the conversion is actually easier than for the native Python syntax!'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如[示例 9-14](ch09.xhtml#ch9list14)所示，Hy 内部解析提供的代码，将其转换为 Python 的 AST，进行编译并执行。幸运的是，Lisp
    是一种易于解析的树结构：每一对括号代表树的一个节点，这意味着转换实际上比原生 Python 语法要容易！
- en: Class definition is supported through the `defclass` construct, which is inspired
    by the Common Lisp Object System (CLOS).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 类定义通过`defclass`构造函数来支持，这一构造灵感来源于通用 Lisp 对象系统（CLOS）。
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 9-15: Defining a class with defclass*'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 9-15：使用 defclass 定义类*'
- en: '[Listing 9-15](ch09.xhtml#ch9list15) defines a class named `A`, which inherits
    from `object`, with a class attribute `x` whose value is 42; then a method `y`
    returns the `x` attribute plus a value passed as argument.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 9-15](ch09.xhtml#ch9list15)定义了一个名为 `A` 的类，它继承自 `object`，并且有一个类属性 `x`，其值为
    42；接着，方法 `y` 返回 `x` 属性加上作为参数传递的值。'
- en: What’s really wonderful is that you can import *any Python library* directly
    into Hy and use it with no penalty. Use the `import()` function to import a module,
    as shown in [Listing 9-16](ch09.xhtml#ch9list16), just as you would with regular
    Python.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 真正令人惊叹的是，你可以直接将 *任何 Python 库* 导入到 Hy 中，并且毫无性能损失地使用它。使用`import()`函数导入模块，如[示例
    9-16](ch09.xhtml#ch9list16)所示，就像在常规 Python 中一样。
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 9-16: Importing regular Python modules*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 9-16：导入常规 Python 模块*'
- en: Hy also has more advanced constructs and macros. In [Listing 9-17](ch09.xhtml#ch9list17),
    admire what the `cond()` function can do for you instead of the classic but verbose
    `if`/`elif`/`else`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Hy 还具有更高级的构造和宏。在[示例 9-17](ch09.xhtml#ch9list17)中，看看`cond()`函数是如何替代经典而冗长的`if`/`elif`/`else`的。
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 9-17: Using cond instead of if/elif/else*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 9-17：使用 cond 替代 if/elif/else*'
- en: 'The `cond` macro has the following signature: `(cond [condition_expression
    return_expression`] ...). Each condition expression is evaluated, starting with
    the first: as soon as one of the condition expressions returns a true value, the
    return expression is evaluated and returned. If no return expression is provided,
    then the value of the condition expression is returned. Thus, `cond` is equivalent
    to an `if`/`elif` construct, except that it can return the value of the condition
    expression without having to evaluate it twice or store it in a temporary variable!'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`cond` 宏具有以下签名：`(cond [condition_expression return_expression] ...)`。每个条件表达式都从第一个开始被求值：一旦某个条件表达式返回了一个真值，对应的返回表达式就会被求值并返回。如果没有提供返回表达式，则返回条件表达式的值。因此，`cond`
    相当于 `if`/`elif` 结构，不同之处在于它可以返回条件表达式的值，而不必进行两次求值或存储在临时变量中！'
- en: Hy allows you to jump into the Lisp world without leaving your comfort zone
    too far behind you, since you’re still writing Python. The `hy2py` tool can even
    show you what your Hy code would look like once translated into Python. While
    Hy is not widely used, it is a great tool to show the potential of the Python
    language. If you’re interested in learning more, I suggest you check out the online
    documentation and join the community.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Hy 让你在不离开舒适区的情况下进入 Lisp 世界，因为你依然在编写 Python 代码。`hy2py` 工具甚至可以向你展示你的 Hy 代码在转换为
    Python 后的样子。虽然 Hy 使用不广泛，但它是一个展示 Python 语言潜力的好工具。如果你有兴趣了解更多，建议你查看在线文档并加入社区。
- en: '**Summary**'
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: Just like any other programming language, Python source code can be represented
    using an abstract tree. You’ll rarely use the AST directly, but when you understand
    how it works, it can provide a helpful perspective.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 就像其他任何编程语言一样，Python 源代码可以使用抽象语法树表示。你很少会直接使用 AST，但当你了解它是如何工作的时，它能为你提供有益的视角。
- en: '**Paul Tagliamonte on the AST and Hy**'
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Paul Tagliamonte 论 AST 和 Hy**'
- en: Paul created Hy in 2013, and, as a Lisp lover, I joined him in this fabulous
    adventure. Paul is currently a developer at Sunlight Foundation.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Paul 在 2013 年创建了 Hy，作为一个 Lisp 爱好者，我加入了他一起踏上了这段奇妙的冒险。Paul 目前是 Sunlight Foundation
    的一名开发者。
- en: '**How did you learn to use the AST correctly, and do you have any advice for
    people looking at it?**'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**你是如何正确使用 AST 的？对于想要了解它的人，你有什么建议吗？**'
- en: The AST is extremely underdocumented, so most knowledge comes from generated
    ASTs that have been reverse engineered. By writing up simple Python scripts, one
    can use something similar to `import ast; ast.dump(ast.parse("print foo"))` to
    generate an equivalent AST to help with the task. With a bit of guesswork, and
    some persistence, it’s not untenable to build up a basic understanding this way.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: AST 的文档非常不足，所以大多数知识来自于被逆向工程生成的 AST。通过编写简单的 Python 脚本，像 `import ast; ast.dump(ast.parse("print
    foo"))` 这样的方法可以生成一个等效的 AST 来帮助完成任务。凭借一些猜测和一定的坚持，通过这种方式建立一个基础的理解是完全可以做到的。
- en: At some point, I’ll take on the task of documenting my understanding of the
    AST module, but I find writing code is the best way to learn the AST.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时候，我会承担起记录我对 AST 模块理解的任务，但我发现写代码是学习 AST 的最好方式。
- en: '**How does Python’s AST differ between versions and uses?**'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python 的 AST 在不同版本和用途中有什么区别？**'
- en: Python’s AST is not private, but it’s not a public interface either. No stability
    is guaranteed from version to version—in fact, there are some rather annoying
    differences between Python 2 and 3 and even within different Python 3 releases.
    In addition, different implementations may interpret the AST differently or even
    have a unique AST. Nothing says Jython, PyPy, or CPython must deal with the Python
    AST in the same way.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的 AST 不是私有的，但它也不是一个公共接口。不同版本之间没有稳定性保证——实际上，Python 2 和 3 之间以及不同的 Python
    3 版本之间都有一些相当烦人的差异。此外，不同的实现可能会以不同的方式解读 AST，甚至可能拥有独特的 AST。没有任何规定 Jython、PyPy 或 CPython
    必须以相同的方式处理 Python AST。
- en: For instance, CPython can handle slightly out-of-order AST entries (by the `lineno`
    and `col_offset`), whereas PyPy will throw an assertion error. Though sometimes
    annoying, the AST is generally sane. It’s not impossible to build an AST that
    works on a vast number of Python instances. With a conditional or two, it’s only
    mildly annoying to create an AST that works on CPython 2.6 through 3.3 and PyPy,
    making this tool quite handy.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 比如，CPython 可以处理略微乱序的 AST 条目（通过 `lineno` 和 `col_offset`），而 PyPy 会抛出断言错误。尽管有时会让人烦恼，AST
    通常还是合理的。构建一个能在大量 Python 实例上工作的 AST 并非不可能。通过几个条件判断，创建一个能在 CPython 2.6 到 3.3 和 PyPy
    上都能工作的 AST 也并不会太麻烦，因此这个工具相当方便。
- en: '**What was your process in creating Hy?**'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**你创建 Hy 的过程是什么样的？**'
- en: I started on Hy following a conversation about how useful it would be to have
    a Lisp that compiles to Python rather than Java’s JVM (Clojure). A few short days
    later, and I had the first version of Hy. This version resembled a Lisp and even
    worked like a proper Lisp in some ways, but it was slow. I mean, really slow.
    It was about an order of magnitude slower than native Python, since the Lisp runtime
    itself was implemented in Python.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我在一次关于如果有一个编译到 Python 而不是 Java 的 JVM（类似 Clojure） Lisp 的对话后，开始了 Hy 项目的开发。几天之后，我就有了
    Hy 的第一个版本。这个版本看起来像一个 Lisp，甚至在某些方面像一个真正的 Lisp，但它非常慢。我的意思是，真的非常慢。它的运行速度比原生 Python
    慢了大约一个数量级，因为 Lisp 运行时本身是用 Python 实现的。
- en: Frustrated, I almost gave up, but then a coworker suggested using the AST to
    implement the runtime, rather than implementing the runtime in Python. This suggestion
    was the catalyst for the entire project. I spent my entire holiday break in 2012
    hacking on Hy. A week or so later, I had something that resembled the current
    Hy codebase.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我感到沮丧，几乎想要放弃，但这时一个同事建议使用 AST 来实现运行时，而不是直接在 Python 中实现运行时。这个建议成为了整个项目的催化剂。我在
    2012 年的整个假期里都在狂热地编写 Hy 代码。大约一周后，我有了一个类似当前 Hy 代码库的东西。
- en: Just after getting enough of Hy working to implement a basic Flask app, I gave
    a talk at Boston Python about the project, and the reception was incredibly warm—so
    warm, in fact, that I start to view Hy as a good way to teach people about Python
    internals, such as how the REPL works, PEP 302 import hooks, and the Python AST.
    This was a good introduction to the concept of code that writes code.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在将 Hy 开发到足以实现一个基本的 Flask 应用后，我在波士顿的 Python 会议上讲解了这个项目，受到了热烈的欢迎——如此热烈，实际上让我开始把
    Hy 看作是一个很好的工具，可以帮助人们了解 Python 的内部机制，比如 REPL 的工作原理、PEP 302 的导入钩子和 Python 的 AST。这是代码生成代码概念的一个很好的介绍。
- en: I rewrote chunks of the compiler to fix some philosophical issues in the process,
    leading us to the current iteration of the codebase—which has stood up quite well!
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我重写了编译器的部分代码，以解决过程中一些哲学上的问题，从而得到了当前版本的代码库——它表现得相当稳健！
- en: Learning Hy is also a good way to begin understanding how to read Lisp. Users
    can get comfortable with s-expressions in an environment they know and even use
    libraries they’re already using, easing the transition to other Lisps, such as
    Common Lisp, Scheme, or Clojure.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 学习 Hy 也是理解如何阅读 Lisp 的好方法。用户可以在他们熟悉的环境中，利用已经在用的库，舒适地学习 s 表达式，从而平滑过渡到其他 Lisp，如
    Common Lisp、Scheme 或 Clojure。
- en: '**How interoperable with Python is Hy?**'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**Hy 与 Python 的互操作性如何？**'
- en: Hy is amazingly interoperable. So much so that `pdb` can properly debug Hy without
    you having to make any changes at all. I’ve written Flask apps, Django apps, and
    modules of all sorts with Hy. Python can import Python, Hy can import Hy, Hy can
    import Python, and Python can import Hy. This is what really makes Hy unique;
    other Lisp variants like Clojure are purely unidirectional. Clojure can import
    Java, but Java has one hell of a time importing Clojure.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Hy 的互操作性非常强。强到 `pdb` 可以在不做任何修改的情况下正确调试 Hy。我已经用 Hy 写过 Flask 应用、Django 应用以及各种模块。Python
    可以导入 Python，Hy 可以导入 Hy，Hy 可以导入 Python，Python 也可以导入 Hy。这才是 Hy 真正与众不同的地方；其他 Lisp
    变种，比如 Clojure，都是单向的。Clojure 可以导入 Java，但 Java 却很难导入 Clojure。
- en: Hy works by translating Hy code (in s-expressions) into the Python AST almost
    directly. This compilation step means the generated bytecode is fairly sane stuff,
    which means Python has a very hard time of even telling the module isn’t written
    in Python at all.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Hy 的工作方式是将 Hy 代码（以 s 表达式的形式）几乎直接转换为 Python 的抽象语法树（AST）。这个编译步骤意味着生成的字节码相当合理，这也使得
    Python 很难判断该模块根本不是用 Python 编写的。
- en: Common Lisp-isms, such as `*earmuffs*` or `using-dashes` are fully supported
    by translating them into a Python equivalent (in this case, `*earmuffs*` becomes
    `EARMUFFS`, and `using-dashes` becomes `using_dashes`), which means Python doesn’t
    have a hard time using them at all.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的 Lisp 风格，比如 `*earmuffs*` 或 `using-dashes`，通过将其转换为 Python 等价物（在这个例子中，`*earmuffs*`
    转变为 `EARMUFFS`，`using-dashes` 转变为 `using_dashes`）得到了完全支持，这意味着 Python 根本不会对它们使用有任何困难。
- en: Ensuring that we have really good interoperability is one of our highest priorities,
    so if you see any bugs—file them!
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 确保我们有非常好的互操作性是我们最优先的任务之一，所以如果你发现任何 bug——请提交！
- en: '**What are the advantages and disadvantages of choosing Hy?**'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**选择 Hy 的优缺点是什么？**'
- en: One advantage of Hy is that it has a full macro system, which Python struggles
    with. Macros are special functions that alter the code during the compile step.
    This makes it easy to create new domain-specific languages, which are composed
    of the base language (in this case, Hy/Python) along with many macros that allow
    uniquely expressive and succinct code.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Hy 的一个优势是它拥有完整的宏系统，而这是 Python 所难以实现的。宏是特殊的函数，在编译步骤中修改代码。这使得创建新的领域特定语言变得容易，这些语言由基础语言（在本例中为
    Hy/Python）和许多宏组成，宏可以使代码更具表现力和简洁性。
- en: As for downsides, Hy, by virtue of being a Lisp written in s-expressions, suffers
    from the stigma of being hard to learn, read, or maintain. People might be averse
    to working on projects using Hy for fear of its complexity.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 至于缺点，Hy 作为一个以 s 表达式书写的 Lisp，承受着学习、阅读或维护困难的偏见。人们可能会因为其复杂性而不愿参与使用 Hy 的项目。
- en: Hy is the Lisp everyone loves to hate. Python folks may not enjoy its syntax,
    and Lispers may avoid it because Hy uses Python objects directly, meaning the
    behavior of fundamental objects can sometimes be surprising to the seasoned Lisper.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Hy 是每个人都爱恨交加的 Lisp。Python 使用者可能不喜欢它的语法，而 Lisp 使用者可能会回避它，因为 Hy 直接使用 Python 对象，这意味着一些基础对象的行为对于经验丰富的
    Lisp 用户来说有时会让人感到意外。
- en: Hopefully people will look past its syntax and consider exploring parts of Python
    previously untouched.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 希望人们能超越它的语法，考虑探索 Python 之前未曾触及的部分。
