- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Motion and Transformation
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 运动与变换
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: Applying movement to graphics of both living and inanimate objects instills
    them with character. Bouncy animation suggests playfulness; precise movement implies
    intensity, while slow motion can suggest heaviness. These techniques are applied
    in film, animation, dance choreography, and, of course, your favorite Pixar flick.
    But that’s not all. Motion is prevalent in interface design, such as subtle button-hover
    effects or elaborate spinning graphics that appear while your content is loading.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 将运动应用于生物和无生命物体的图形，可以赋予它们个性。弹跳的动画暗示着俏皮；精确的运动意味着强度，而慢动作则可以暗示沉重。这些技巧被广泛应用于电影、动画、舞蹈编排，当然，还有你最喜欢的皮克斯动画片。但这还不是全部，运动在界面设计中也非常普遍，比如微妙的按钮悬停效果，或者在内容加载时出现的复杂旋转图形。
- en: In this chapter, you’ll make things move by coding with motion and transformation
    functions. You’ll learn how to manipulate the coordinate system with transformation
    functions, making it simpler to move, rotate, and scale your elements. In addition,
    you’ll learn how to structure an animated Processing sketch by using the `setup()`
    and `draw()` functions. Motion literally adds a new dimension—time—to your Processing
    sketches.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将通过编写运动和变换函数的代码让物体动起来。你将学习如何使用变换函数操控坐标系统，使得移动、旋转和缩放元素变得更加简单。此外，你还将学习如何通过使用`setup()`和`draw()`函数来构建一个动画的Processing草图。运动从字面上为你的Processing草图增加了一个新的维度——时间。
- en: Perceiving Motion
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 感知运动
- en: First, consider how motion is perceived. The brain is fed a snapshot from your
    retina many times each second. Provided that their screen can display a sequence
    of static images at a rate exceeding roughly 10 to 12 frames per second, the viewer
    will experience the illusion of smooth, flowing movement. Higher frame rates will
    appear even smoother.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，考虑一下运动是如何被感知的。大脑每秒钟从视网膜获取许多次快照。只要显示屏每秒能够显示超过大约10到12帧的静态图像，观众就会体验到平滑流畅的运动错觉。更高的帧率会显得更加平滑。
- en: Take a moment to note the two circles in [Figure 6-1](#figure6-1).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 稍作停顿，注意[图6-1](#figure6-1)中的两个圆圈。
- en: '![f06001](image_fi/500969c06/f06001.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![f06001](image_fi/500969c06/f06001.png)'
- en: 'Figure 6-1: Two circles (positioned left and right)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-1：两个圆圈（左侧和右侧定位）
- en: If you displayed only the left circle for four seconds, followed by only the
    right circle for another four seconds, looping the sequence indefinitely ([Figure
    6-2](#figure6-2)), this would be an effective frame rate of 0.25 frames per second
    (or 0.25 *fps*). The result, most observers would agree, is a pair of alternating
    images depicting circles in two different positions.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仅展示左边的圆圈四秒钟，再展示右边的圆圈四秒钟，循环这个序列无限次（见[图6-2](#figure6-2)），这将是一个有效的帧率，约为每秒0.25帧（即0.25
    *fps*）。结果，大多数观察者会同意，这将呈现出一对交替出现的图像，显示圆圈在两个不同位置之间变化。
- en: '![f06002](image_fi/500969c06/f06002.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![f06002](image_fi/500969c06/f06002.png)'
- en: 'Figure 6-2: Displaying alternating circles'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-2：显示交替的圆圈
- en: However, speed up the frame rate to around 2.5 fps (10 times faster), and the
    observer will begin to interpret the sequence as a single circle bouncing between
    two points—as if the circle were moving across the gap in the middle. The illusion
    is referred to as *beta movement*. Increase the frame rate further, and the two
    circles will appear to flicker in sync with one another. From this experiment,
    you can see how frame rate doesn’t affect only how fast or slow something moves,
    but also how you perceive the object’s motion.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当帧率加速到大约2.5帧每秒（快10倍）时，观察者将开始将序列解读为一个在两个点之间弹跳的圆圈——就好像圆圈在中间的空隙中移动一样。这种错觉被称为*贝塔运动*。进一步提高帧率时，两个圆圈将同步闪烁。从这个实验中，你可以看到帧率不仅影响物体的移动速度，还影响你对物体运动的感知。
- en: Note the numbering of the circles shown in [Figure 6-3](#figure6-3).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意[图6-3](#figure6-3)中圆圈的编号。
- en: Now, suppose you want to animate this. Using the numbering to dictate the order,
    remove a single circle on each frame. On the first frame, remove just the circle
    labeled 0\. On the second frame, replace circle 0 and remove only circle 1\. Continue
    this process around the ring, and loop the animation indefinitely. Removing successive
    circles from each frame results in a gap that moves around the ring in a clockwise
    progression ([Figure 6-4](#figure6-4)).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设你想要为此做动画。按照编号来确定顺序，每一帧移除一个圆圈。在第一帧，移除标记为0的圆圈。在第二帧，替换圆圈0并只移除圆圈1。继续围绕环形路径进行此操作，并使动画循环播放。每一帧移除一个连续的圆圈，结果是一个以顺时针方向移动的间隙（[图6-4](#figure6-4)）。
- en: '![f06003](image_fi/500969c06/f06003.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![f06003](image_fi/500969c06/f06003.png)'
- en: 'Figure 6-3: A ring of circles numbered in a clockwise sequence'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-3：按顺时针顺序编号的圆圈环
- en: '![f06004](image_fi/500969c06/f06004.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![f06004](image_fi/500969c06/f06004.png)'
- en: 'Figure 6-4: Animating the ring of circles'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-4：动画中的圆圈环
- en: If you run the animation at 1 fps, the circle just ahead of a gap appears to
    jump into the void left by the vacant circle ([Figure 6-5](#figure6-5)).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你以1帧每秒（fps）的速度运行动画，圆圈刚好出现在间隙前面，似乎跳入了空缺的圆圈位置（[图6-5](#figure6-5)）。
- en: '![f06005](image_fi/500969c06/f06005.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![f06005](image_fi/500969c06/f06005.png)'
- en: 'Figure 6-5: At 1 fps, the next circle seems to leap into the gap.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-5：以1 fps的速度，接下来的圆圈似乎跳进了空缺中。
- en: At 25 fps, however, a rapidly moving phantom white dot seems to obscure the
    circles beneath it as it races around the ring—an illusion called the *phi phenomenon*
    ([Figure 6-6](#figure6-6)).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在25帧每秒（fps）下，一个快速移动的虚拟白点似乎遮挡了其下方的圆圈，因为它在环形路径上疾驰——这种现象被称为*菲现象*（[图6-6](#figure6-6)）。
- en: Now you’re ready to build a Processing sketch that, in addition to introducing
    Processing’s animation functions, will allow you to experiment with these phenomena.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经准备好构建一个Processing草图，除了引入Processing的动画功能外，还可以让你实验这些现象。
- en: '![f06006](image_fi/500969c06/f06006.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![f06006](image_fi/500969c06/f06006.png)'
- en: 'Figure 6-6: At 25 fps, a phantom white dot seems to obscure the circles.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-6：以25 fps的速度，一个虚拟的白点似乎遮挡了圆圈。
- en: Adding Motion to Processing Sketches
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为Processing草图添加运动
- en: Processing gives you the option to draw to the display window a single time
    or multiple times over. For animation, you use the latter approach. To make an
    object move, you adjust its position with each frame drawn—and if you do it rapidly
    enough, in small enough increments, the result is smooth, flowing motion.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Processing 允许你选择在显示窗口中绘制一次或多次。对于动画，你会使用后者的方法。为了让一个对象移动，你需要在每一帧中调整它的位置——如果调整得足够迅速、增量足够小，结果就是平滑、流畅的运动。
- en: The draw() and setup() Functions
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`draw()` 和 `setup()` 函数'
- en: To make Processing draw something multiple times, you’ll need to structure your
    code by using the `setup()` and `draw()` functions. Beneath those two functions,
    you can nest any of the functions or statements covered in the book so far. As
    indicated in [Figure 6-7](#figure6-7), where you place your code depends on when
    you want it to execute.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要让Processing多次绘制某个对象，你需要通过使用`setup()`和`draw()`函数来构建你的代码。在这两个函数下面，你可以嵌套书中到目前为止讲解的任何函数或语句。正如[图6-7](#figure6-7)所示，你的代码放置位置取决于你希望它执行的时机。
- en: '![f06007](image_fi/500969c06/f06007.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![f06007](image_fi/500969c06/f06007.png)'
- en: 'Figure 6-7: Structuring code for motion'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-7：为运动构建代码结构
- en: Any `def` keyword is followed by a function name, parentheses, and a colon.
    Chapter 9 covers `def` in more detail, but for now, just be aware that any code
    indented beneath a `def` belongs to that respective function.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 任何`def`关键字后面都会跟着函数名、括号和冒号。第9章会更详细地介绍`def`，但现在只需知道，任何缩进在`def`下方的代码都属于该函数。
- en: 'The `setup()` code runs once at startup, and it typically includes things like
    your `size()` function and other lines that define your environmental properties.
    I’ll get to `draw()` in more detail shortly, but first, create a new sketch, save
    it as *perceiving_motion*, and then add the following code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`setup()`代码在启动时只运行一次，通常包括像`size()`函数这样的内容以及定义环境属性的其他代码。我稍后会更详细地讲解`draw()`，但首先，创建一个新的草图，保存为*perceiving_motion*，然后添加以下代码：'
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This code resembles just about every other sketch you’ve set up so far, except
    for the `def setup()` line. Whenever you intend to use a `draw()` function, you
    have to use `setup()` too. Now add the `draw()` function:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码几乎与你之前设置的每一个草图相似，唯一不同的是`def setup()`这一行。每当你打算使用`draw()`函数时，你也必须使用`setup()`。现在添加`draw()`函数：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Processing invokes the code indented beneath the `draw()` function with each
    new frame. The `frameCount` is a system variable containing the number of frames
    displayed since starting the sketch. With each new frame, the `draw()` function
    calls the `print()` function, which in turn displays the current frame count in
    the console.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Processing在每个新的帧下调用`draw()`函数中的代码。`frameCount`是一个系统变量，包含自开始草图以来显示的帧数。每当新帧到来时，`draw()`函数会调用`print()`函数，从而在控制台显示当前的帧计数。
- en: 'By default, `draw()` executes at approximately 60 fps. However, as the complexity
    of an animation increases, the frame rate is likely to drop as your computer struggles
    to accommodate the demands placed on it. Adjust the frame rate by using the `frameRate()`
    function (within the `setup()` block), and add a condition to `draw()` to print
    on even-numbered frames only:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`draw()`以大约60帧每秒（fps）执行。然而，随着动画复杂度的增加，帧率可能会下降，因为你的计算机需要应对更高的需求。通过使用`frameRate()`函数（在`setup()`块内）调整帧率，并向`draw()`添加条件，仅在偶数帧上进行打印：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: With the `frameRate` set to `2.5`, the draw line runs two and a half times every
    second; this means that each frame is 400 milliseconds (0.4 of a second) in duration.
    Because the `print` line executes on every second frame, a new line appears in
    the console every 800 milliseconds ([Figure 6-8](#figure6-8)).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 将`frameRate`设置为`2.5`，表示每秒绘制两次半线；这意味着每一帧的持续时间是400毫秒（0.4秒）。由于`print`行在每一秒的第2帧执行，因此每800毫秒（[图6-8](#figure6-8)）控制台中会出现一行新的输出。
- en: '![f06008](image_fi/500969c06/f06008.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![f06008](image_fi/500969c06/f06008.png)'
- en: 'Figure 6-8: Printing the frame count on every even-numbered frame'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-8：在每个偶数帧上打印帧计数
- en: 'To draw a circle on every even frame instead, use the following `circle()`
    line:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 若要仅在每个偶数帧上绘制圆形，可以使用以下`circle()`行：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now run the sketch. You may be surprised to find that the circle does not flash
    on and off ([Figure 6-9](#figure6-9)).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行草图。你可能会惊讶地发现，圆形并没有闪烁开关（[图6-9](#figure6-9)）。
- en: '![f06009](image_fi/500969c06/f06009.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![f06009](image_fi/500969c06/f06009.png)'
- en: 'Figure 6-9: The circle does not “blink.”'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-9：圆形不会“闪烁”。
- en: The reason the circle does not disappear on odd frames is that everything in
    Processing persists after it’s drawn. On every even frame, the program draws another
    circle atop the existing “pile.” The `background()` color within the `setup()`
    function runs once at the start, filling the display window in blue to form the
    bottommost layer of this persistent arrangement. To “wipe” each frame before drawing
    the next, you can redraw a background over everything.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 圆形在奇数帧上不消失的原因是，在Processing中，绘制的内容会保持不变。每个偶数帧时，程序会在现有的“堆叠”上绘制另一个圆。`setup()`函数中的`background()`颜色在程序开始时执行一次，填充显示窗口为蓝色，形成这个持久性排列的最底层。为了在绘制下一个帧之前“擦除”每一帧，你可以在绘制所有内容之前重新绘制背景。
- en: 'Copy the `background(''#004477'')` line into the `draw()` section of your sketch:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 将`background('#004477')`行复制到你的草图的`draw()`部分：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The new `background()` line clears every frame before it. Be sure you have placed
    it above the `if` statement. In most instances, a `background()` function will
    sit somewhere near the top of `draw()` to avoid clearing other shapes in the current
    frame.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`background()`行在每一帧之前清除画面。确保它位于`if`语句之前。在大多数情况下，`background()`函数通常位于`draw()`的顶部，以避免清除当前帧中的其他形状。
- en: Test the code. The result should be a blinking circle.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 测试代码。结果应该是一个闪烁的圆。
- en: 'To recreate the ring of circles experiment from earlier ([Figure 6-3](#figure6-3)),
    replace the existing `if` statement with a series of `if` statements:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了重新创建之前的圆环实验（[图6-3](#figure6-3)），将现有的`if`语句替换为一系列的`if`语句：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The current frame count is divided by `8` 1, and the remainder is assigned to
    the `hide` variable. Each `if` statement will draw a separate circle provided
    it hasn’t been flagged as the one to hide. For instance, on the 16th frame, `hide`
    is equal to `0` because 16 divides evenly by 8\. On the 15th frame, `hide` is
    equal to `7` because 15 divided by 8 leaves a remainder of 7\. On the 17th frame,
    `hide` is equal to `1`. The result is a stream of numbers that counts from 0 up
    to 7, then restarts at 0.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当前帧计数除以`8`的余数赋值给`hide`变量。每个`if`语句将绘制一个单独的圆，前提是该圆没有被标记为隐藏。例如，在第16帧时，`hide`等于`0`，因为16能够被8整除。在第15帧时，`hide`等于`7`，因为15除以8的余数是7。在第17帧时，`hide`等于`1`。结果是一个从0到7的数字流，然后从0重新开始。
- en: Run the sketch. Focus on the gap as it moves around the circle. At the current
    frame rate of 2.5 fps, the circle just ahead of a gap appears to jump into the
    void left by the vacant circle. But adjust the frame rate to 25 fps, and a phantom
    background-colored dot appears to obscure the circles beneath it as it races around
    the ring.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 运行草图。注意间隙如何在圆圈周围移动。在当前的帧率2.5 fps下，间隙前方的圆圈似乎跳入了空缺圆圈留下的空白处。但当帧率调整为25 fps时，一个类似幽灵的背景色点似乎会在它绕环圈快速移动时遮住下面的圆圈。
- en: Global Variables
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 全局变量
- en: A *global variable* is one that you can access anywhere within your program.
    Up until this point in the book, almost every variable you have defined has been
    a global variable. You’ll need to understand more about global variables to manage
    data across multiple frames.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*全局变量*是指你可以在程序中的任何地方访问的变量。到目前为止，书中你定义的几乎每个变量都是全局变量。你需要更多地了解全局变量，以便在多个帧之间管理数据。'
- en: Global variables are declared outside any function definitions (indented blocks
    beginning with `def`), usually somewhere near the top of your code. For instance,
    any variables that you declare outside `setup()` and `draw()` are automatically
    global. Conversely, any variables declared inside the indented lines of those
    two functions are accessible within that function alone.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 全局变量是在任何函数定义（以`def`开头的缩进代码块）外声明的，通常位于代码的顶部。例如，你在`setup()`和`draw()`外声明的任何变量都会自动成为全局变量。相反，任何在这两个函数的缩进行内声明的变量只在该函数内可访问。
- en: 'As an example of this behavior in action, create a new sketch and save it as
    *global_variables*. Add the following code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这种行为的示例，创建一个新的草图并将其保存为*global_variables*。添加以下代码：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `y` variable 1 is declared within the `setup()` function. As such, `y` is
    accessible only within the indented lines of the `setup()` block. The `y` variable’s
    scope, therefore, is considered to be *local* to `setup()`. *Scope*, in programming,
    deals with the regions where a variable (or other entity) may be accessed. In
    this instance, running the sketch produces an error ([Figure 6-10](#figure6-10)),
    because you have attempted to access and print variable `y` from within the `draw()`
    function 2.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`y`变量1是在`setup()`函数内声明的。因此，`y`仅在`setup()`代码块的缩进行内可访问。`y`变量的作用域因此被认为是*局部*的，限定在`setup()`中。在编程中，*作用域*是指可以访问变量（或其他实体）的区域。在这种情况下，运行草图会产生一个错误（[图6-10](#figure6-10)），因为你尝试从`draw()`函数中访问并打印变量`y`
    2。'
- en: '![f06010](image_fi/500969c06/f06010.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![f06010](image_fi/500969c06/f06010.png)'
- en: 'Figure 6-10: The `draw()` function cannot access the `y` variable declared
    in `setup()`.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-10：`draw()`函数无法访问在`setup()`中声明的`y`变量。
- en: 'Alternatively, you can move the `y = 1` line outside the `setup()` function,
    which places it in the global scope; this permits either function to read it.
    Move this line to the top of your code and insert a `pass` statement in place
    of the location you moved it from:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，你也可以将`y = 1`这一行移动到`setup()`函数外部，这样它就处于全局作用域；这允许任意一个函数读取它。将这一行移动到代码顶部，并在你移出的位置插入一个`pass`语句：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `draw()` function has no problems accessing `y` now that it’s declared outside
    `setup()`. The `pass` statement is a *null operation*—that is, nothing happens
    when it executes. You need to include a `pass` line because Python does not allow
    empty function definitions. This makes `pass` a useful placeholder for any code
    you have yet to write. Upon running the sketch, the console should print endless
    lines of `1`s.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`draw()`函数现在可以访问`y`，因为它已经在`setup()`外部声明。`pass`语句是一个*空操作*——也就是说，当它执行时什么都不会发生。你需要包含一个`pass`语句，因为Python不允许空的函数定义。这使得`pass`成为任何尚未编写代码的有用占位符。运行草图时，控制台应该会打印出无尽的`1`。'
- en: 'You can override the global `y` variable on a local level with another variable
    of the same name—in this case, another variable named `y`. Make the following
    adjustments to your code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在局部范围内使用另一个同名变量来覆盖全局的`y`变量——在这种情况下，另一个名为`y`的变量。对你的代码进行以下调整：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `setup()` function runs first—just once—and its `print` line 2 displays
    a `0`. This is because within the `setup()` function, you define the `y` as a
    `0` 1. The outer (global) `y` is still equal to 1, and it’s said to be *shadowed*
    by the `setup()`’s inner (local) `y` variable. The `draw()` code executes after
    the `setup()` code, and with every new frame, prints 3 a `1` to the console. Run
    the sketch, quickly stop it, and then scroll up through the console output. The
    first line displayed is a `0`; from there down, it’s all `1`s ([Figure 6-11](#figure6-11)).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`setup()`函数先运行—仅运行一次—并且它的`print`第2行显示`0`。这是因为在`setup()`函数中，你将`y`定义为`0`。外部（全局）`y`仍然等于1，并且它被认为是被`setup()`内部（局部）`y`变量所*遮蔽*。`draw()`代码在`setup()`代码之后执行，并且在每个新帧中，都会向控制台打印`1`。运行草图，迅速停止它，然后向上滚动控制台输出。第一行显示的是`0`；从那以后，都是`1`（见[图
    6-11](#figure6-11)）。'
- en: '![f06011](image_fi/500969c06/f06011.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![f06011](image_fi/500969c06/f06011.png)'
- en: 'Figure 6-11: The global `y` variable is shadowed by the `y = 0`.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-11：全局`y`变量被`y = 0`遮蔽。
- en: 'Next, remove the `y = 0` line and add code that attempts to increment the global
    `y` variable by `1` with each frame:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，移除`y = 0`行，并添加代码，尝试在每帧中将全局`y`变量增加`1`：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: While you can read (or shadow) any global variable, writing or reassigning values
    requires additional code. As a result, this code should cause Processing to display
    an error ([Figure 6-12](#figure6-12)).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以读取（或遮蔽）任何全局变量，但写入或重新赋值需要额外的代码。因此，这段代码应该会导致Processing显示错误（见[图 6-12](#figure6-12)）。
- en: '![f06012](image_fi/500969c06/f06012.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![f06012](image_fi/500969c06/f06012.png)'
- en: 'Figure 6-12: The `draw()` function cannot reassign a value to `y`.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-12：`draw()`函数无法重新赋值给`y`。
- en: 'This is where the `global` statement is useful. Edit your code, inserting a
    `global y` line at the top of the `draw()` block:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`global`语句有用的地方。编辑你的代码，在`draw()`块的顶部插入`global y`行：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The global `y` variable is now bound to the local scope of `draw()`, and you
    may modify it as you wish. Run the sketch. The global `y` variable should now
    increment by 1 with each new frame ([Figure 6-13](#figure6-13)).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 全局`y`变量现在与`draw()`的局部作用域绑定，你可以根据需要修改它。运行草图。全局`y`变量现在应该在每个新帧中递增1（见[图 6-13](#figure6-13)）。
- en: '![f06013](image_fi/500969c06/f06013.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![f06013](image_fi/500969c06/f06013.png)'
- en: 'Figure 6-13: The global `y` variable is incremented by 1 with each new frame.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-13：全局`y`变量在每个新帧中递增1。
- en: 'Global variables allow you to keep track of and update values between frames
    easily, which is especially useful for animating objects. Add a moving circle,
    the y-coordinate of which is controlled by the `y` variable:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 全局变量允许你轻松地跟踪和更新帧之间的值，这对于动画对象尤其有用。添加一个移动的圆圈，其 y 坐标由`y`变量控制：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: I’ve placed the size, fill, and stroke properties in the `setup()` section of
    the code. Given that the stroke and fill are unchanged throughout the animation,
    there’s no need to apply those properties repeatedly in `draw()`. The circle’s
    y-coordinate, represented by variable `y`, moves the circle down as the frames
    advance. In [Figure 6-14](#figure6-14), a motion trail has been added to convey
    the direction of motion.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我将大小、填充和描边属性放在了代码的`setup()`部分。由于描边和填充在整个动画过程中保持不变，因此无需在`draw()`中重复应用这些属性。圆圈的
    y 坐标，由变量`y`表示，随着帧的推进而将圆圈向下移动。在[图 6-14](#figure6-14)中，已经添加了运动轨迹以传达运动方向。
- en: '![f06014](image_fi/500969c06/f06014.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![f06014](image_fi/500969c06/f06014.png)'
- en: 'Figure 6-14: The circle moves down from the top of the display window.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-14：圆圈从显示窗口的顶部向下移动。
- en: When the circle reaches the bottom of the display window, it continues out of
    sight beyond the lower edge.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当圆圈到达显示窗口的底部时，它会继续向下超出视野，越过底边。
- en: Saving Frames
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保存帧
- en: 'Processing provides the `saveFrame()` function to save frames as image files.
    Whenever your sketch calls a `saveFrame()`, it saves a *Tagged Image File Format,*
    or TIFF, image in the sketch folder. You’ll want to place this call at the end
    of your `draw()` function to ensure that you capture every shape rendered on the
    current frame. For instance, say you add the following code to a `draw()` function:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Processing 提供了`saveFrame()`函数，用于将帧保存为图像文件。每当你的草图调用`saveFrame()`时，它会将一个*标记图像文件格式*（TIFF）图像保存在草图文件夹中。你会希望在`draw()`函数的末尾放置这个调用，以确保捕获当前帧中渲染的每个形状。例如，假设你将以下代码添加到`draw()`函数中：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As the animation encounters every 100th frame, a new image file appears in your
    sketch folder. This image file is named *screen-* followed by a four-digit frame
    count; where necessary, this frame count is padded with leading zeros, as shown
    in [Figure 6-15](#figure6-15). Because `saveFrame()` precedes the `square()` line,
    the square appears in every frame of the animation, but never in the saved image
    files.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 每当动画遇到第100帧时，新的图像文件会出现在你的草图文件夹中。这个图像文件的命名规则是*screen-*后面跟着四位数的帧数；在需要时，帧数会用前导零填充，如[图
    6-15](#figure6-15)所示。因为`saveFrame()`在`square()`行之前执行，所以方块出现在动画的每一帧中，但永远不会出现在保存的图像文件中。
- en: '![f06015](image_fi/500969c06/f06015.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![f06015](image_fi/500969c06/f06015.png)'
- en: 'Figure 6-15: The `saveFrame``()` function generates an image file named using
    the frame count.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-15：`saveFrame()`函数生成一个以帧数命名的图像文件。
- en: 'If you want to save the file in an image format other than TIFF, such as JPG,
    PNG, or TARGA, include a filename argument with the relevant extension:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想将文件保存为除TIFF外的其他图像格式，如JPG、PNG或TARGA，可以在文件名参数中包含相关的扩展名：
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In this case, you’d use the same filename for every image saved, which is okay
    for capturing a single frame, but will lead to overwriting when you call the same
    `saveFrame()` function multiple times. However, you can include a series of hash
    marks to make the frame count appear in the filename. This code generates a uniquely
    named PNG file with every save:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你会使用相同的文件名保存每个图像，这对于捕捉单个帧是可以的，但当你多次调用相同的`saveFrame()`函数时，会导致文件被覆盖。然而，你可以在文件名中加入一系列哈希符号，使得帧数出现在文件名中。以下代码会在每次保存时生成一个独一无二的PNG文件：
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Processing replaces the hash marks with the frame count and, if necessary, pads
    the count with leading zeros.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Processing 会将哈希符号替换为帧数，并在必要时用前导零填充帧数。
- en: 'Challenge #5: DVD Screensaver'
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '挑战 #5：DVD 屏幕保护程序'
- en: In this task, you’ll combine `setup()`, `draw()`, global variables, and `if`
    statements to animate an object that bounces off the edges of the display window.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，你将结合`setup()`、`draw()`、全局变量和`if`语句来为一个物体制作动画，使其在显示窗口的边缘反弹。
- en: DVD players commonly feature a bouncing DVD logo as a screensaver ([Figure 6-16](#figure6-16)),
    which appears after a given period of inactivity. You may have seen a variation
    of this on other devices, albeit with a different graphic. Intriguingly, people
    often find themselves staring at the pointless animation in the hope of witnessing
    the logo land perfectly in the corner of the screen.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: DVD 播放器通常会有一个反弹的 DVD 标志作为屏幕保护程序（[图 6-16](#figure6-16)），它会在一定时间的非活动后出现。你可能在其他设备上见过这种变化，尽管它们的图形不同。有趣的是，人们经常会盯着这个无意义的动画，希望看到标志完美地停在屏幕的角落。
- en: '![f06016](image_fi/500969c06/f06016.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![f06016](image_fi/500969c06/f06016.png)'
- en: 'Figure 6-16: The logo bounces off edges of the screen.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-16：标志在屏幕的边缘反弹。
- en: 'Create a new sketch and save it as *dvd_screensaver*. Add the following code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的草图，并将其保存为*dvd_screensaver*。添加以下代码：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The code is similar to that of the previous example using the circle ([Figure
    6-14](#figure6-14)). In this instance, you include a `yspeed` variable. To use
    a single `global` statement for multiple variables, comma-separate them 1. With
    each new frame, the program adds `yspeed` to the `y` variable 2, which serves
    as the y-coordinate for the DVD text 3. Upon running the sketch, the logo should
    move directly down ([Figure 6-17](#figure6-17)), soon passing beyond the bottom
    edge of the display window.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与之前使用圆形的例子类似（[图 6-14](#figure6-14)）。在这个实例中，你需要加入一个`yspeed`变量。要为多个变量使用单一的`global`语句，可以用逗号分隔它们。1.
    每当新的一帧出现时，程序会将`yspeed`加到`y`变量上 2，这个`y`变量作为DVD文字的y坐标 3。运行草图时，标志应该会直接向下移动（[图 6-17](#figure6-17)），很快会超出显示窗口的底边。
- en: '![f06017](image_fi/500969c06/f06017.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![f06017](image_fi/500969c06/f06017.png)'
- en: 'Figure 6-17: The DVD text moves downward.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-17：DVD 文字向下移动。
- en: 'To make the logo rebound off the bottom edge of the display window, add the
    following `if` statement:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让标志从显示窗口的底边反弹，添加以下`if`语句：
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: When the `y` variable exceeds the `height` of the display window, the `yspeed`
    is multiplied by `-1`, sending the logo in the opposite direction. Run the sketch;
    the logo should rebound as it hits the bottom edge.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当`y`变量超出显示窗口的`height`时，`yspeed`会乘以`-1`，使得标志朝相反的方向移动。运行草图时，标志应该会在触碰到底部边缘时反弹。
- en: 'To move the logo diagonally, add some `x` values:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要让标志沿对角线移动，添加一些`x`值：
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, you’ve replicated everything you did with the `y` and `yspeed` variables
    for the `text()` function’s `x` argument. The logo should now move vertically
    and horizontally. Run the sketch ([Figure 6-18](#figure6-18)).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你已将之前使用 `y` 和 `yspeed` 变量所做的一切复制到了 `text()` 函数的 `x` 参数中。现在，标志应该可以在垂直和水平方向上移动了。运行草图（[图
    6-18](#figure6-18)）。
- en: '![f06018](image_fi/500969c06/f06018.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![f06018](image_fi/500969c06/f06018.png)'
- en: 'Figure 6-18: The diagonally moving DVD text rebounds near the lower-right corner.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-18：斜着移动的 DVD 文本在右下角附近反弹。
- en: When the logo rebounds off the bottom edge, the `yspeed` is inverted, but not
    the `xspeed`. This is the behavior you seek, but then the logo passes through
    the right edge. Instead, the logo must rebound off every edge it encounters. Your
    challenge is to complete the task. If you need help, you can access the solution
    at [https://github.com/tabreturn/processing.py-book/tree/master/chapter-06-motion_and_transformation/dvd_screensaver/](https://github.com/tabreturn/processing.py-book/tree/master/chapter-06-motion_and_transformation/dvd_screensaver/).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当标志从底边反弹时，`yspeed` 被反转，但`xspeed` 不变。这是你期望的行为，但随后标志穿越了右边缘。相反，标志必须从它遇到的每个边缘反弹。你的挑战是完成这个任务。如果你需要帮助，可以访问解决方案：[https://github.com/tabreturn/processing.py-book/tree/master/chapter-06-motion_and_transformation/dvd_screensaver/](https://github.com/tabreturn/processing.py-book/tree/master/chapter-06-motion_and_transformation/dvd_screensaver/)。
- en: Transformations
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变换
- en: Processing’s *transformation functions* provide convenient ways to manipulate
    elements by using translate, rotate, scale, and shear operations ([Figure 6-19](#figure6-19)).
    You may apply transformations to individual shapes, groups of elements, or the
    entire drawing space.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Processing 的*变换函数*通过使用平移、旋转、缩放和剪切操作提供了方便的方式来操控元素（[图 6-19](#figure6-19)）。你可以将变换应用于单个形状、元素组或整个绘图空间。
- en: '![f06019](image_fi/500969c06/f06019.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![f06019](image_fi/500969c06/f06019.png)'
- en: 'Figure 6-19: From left to right: translation, rotation, scaling, and shear
    transformations'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-19：从左到右：平移、旋转、缩放和剪切变换
- en: Suppose you want to rotate a star shape (as shown in [Figure 6-20](#figure6-20))
    in a clockwise direction. This star is composed of vertices using a series of
    `vertex()` functions; an x-y coordinate pair defines the position of each vertex.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要将一个星形（如[图 6-20](#figure6-20)所示）顺时针旋转。这个星形由一系列 `vertex()` 函数定义的顶点组成；每个顶点的位置由一对
    x-y 坐标表示。
- en: '![f06020](image_fi/500969c06/f06020.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![f06020](image_fi/500969c06/f06020.png)'
- en: 'Figure 6-20: Rotating a star shape'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-20：旋转一个星形
- en: Calculating the new positions of each vertex requires a *matrix*. You can think
    of a matrix as a table of numbers. For different transformations, you can add,
    subtract, or multiply each x-y coordinate pair with a *transformation matrix*.
    In the case of the star rotation, the matrix operation would look something like
    [Figure 6-21](#figure6-21). The *x* and *y* values in the square brackets labeled
    *vertex* represent the coordinate pair for a given vertex; this is multiplied
    by the *transformation matrix* to calculate a new rotated vertex position. The
    equation in the *result* brackets reveals the workings of the matrix math.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 计算每个顶点的新位置需要一个*矩阵*。你可以把矩阵看作是一个数字表格。对于不同的变换，你可以通过加、减或乘以每对 x-y 坐标和*变换矩阵*来进行操作。在星形旋转的情况下，矩阵操作大致如下所示：[图
    6-21](#figure6-21)。方括号中标记为*顶点*的*x*和*y*值表示给定顶点的坐标对；这与*变换矩阵*相乘，用以计算新的旋转后的顶点位置。*结果*方括号中的方程揭示了矩阵运算的过程。
- en: '![f06021](image_fi/500969c06/f06021.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![f06021](image_fi/500969c06/f06021.png)'
- en: 'Figure 6-21: A transformation matrix for rotation'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-21：旋转的变换矩阵
- en: If matrix math looks a little confusing, don’t worry; Processing quietly handles
    all of it for you.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果矩阵运算看起来有些困惑，不用担心；Processing 会悄悄为你处理这一切。
- en: In the next section, you’ll learn about the `translate()`, `rotate()`, `scale()`,
    `shearX()`, and `shearY()` functions. You’ll also see how to use the `pushMatrix()`
    and `popMatrix()` functions for applying transformations to selected groups of
    elements.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，你将学习 `translate()`、`rotate()`、`scale()`、`shearX()` 和 `shearY()` 函数。你还将看到如何使用
    `pushMatrix()` 和 `popMatrix()` 函数来将变换应用于选定的元素组。
- en: Processing Transformation Functions
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Processing 变换函数
- en: 'Create a new sketch and save it as *transformation_functions*. Within the sketch’s
    folder, create a *data* subfolder and then follow these steps:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的草图，并将其保存为*transformation_functions*。在草图的文件夹内，创建一个*data*子文件夹，然后按照以下步骤操作：
- en: Open your web browser and go to [https://github.com/tabreturn/processing.py-book/](https://github.com/tabreturn/processing.py-book/).
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的网页浏览器并访问[https://github.com/tabreturn/processing.py-book/](https://github.com/tabreturn/processing.py-book/)。
- en: Navigate to *chapter-06-motion_and_transformation*.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到*chapter-06-motion_and_transformation*。
- en: Download the *grid.png* and *grid-overlay.png* files.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载*grid.png*和*grid-overlay.png*文件。
- en: Place both files in your *data* subfolder.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将两个文件放入你的*data*子文件夹中。
- en: 'Add the following setup code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下设置代码：
- en: '[PRE18]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `grid` variable and `image()` lines load and display the *grid.png* graphic.
    The *grid-overlay.png* file is loaded into the variable `grido`, but it’s not
    rendered in the display window yet; you’ll display it later in this task.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`grid`变量和`image()`语句加载并显示*grid.png*图形。*grid-overlay.png*文件被加载到`grido`变量中，但还没有在显示窗口中渲染；你将在后续任务中显示它。'
- en: translate()
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: translate()
- en: 'The `translate()` function accepts two arguments: an x-offset and y-offset.
    Ordinarily, an x-y coordinate of (0, 0) marks the upper left corner of the display
    window. This point is called the *origin*. Using `translate()`, you can reposition
    the coordinate system, which shifts the origin and influences everything you draw
    after that.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`translate()`函数接受两个参数：x偏移量和y偏移量。通常，坐标(0, 0)表示显示窗口的左上角。这个点被称为*原点*。使用`translate()`，你可以重新定位坐标系，这会移动原点，并影响你之后绘制的所有内容。'
- en: Add a `translate()` function to your *transformation_functions* code, and display
    the grid-overlay graphic by using a new `image()` line.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在*transformation_functions*代码中添加`translate()`函数，并通过新的`image()`语句显示grid-overlay图形。
- en: '[PRE19]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `translate()` function moves the entire coordinate system 150 pixels across
    and 100 pixels down. The `image()` function draws the grid-overlay graphic—a pale
    blue version of the first grid image—at (0, 0). The *grid-overlay.png* graphic
    has a transparent background, so you should see the *grid.png* file showing through
    it. Run the sketch to confirm that the output matches [Figure 6-22](#figure6-22).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`translate()`函数将整个坐标系水平移动150像素，垂直移动100像素。`image()`函数在(0, 0)位置绘制grid-overlay图形——这是一种浅蓝色版本的第一个网格图像。*grid-overlay.png*图形具有透明背景，因此你应该能够看到*grid.png*文件透过它显示。运行草图以确认输出与[图6-22](#figure6-22)相符。'
- en: '![f06022](image_fi/500969c06/f06022.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![f06022](image_fi/500969c06/f06022.png)'
- en: 'Figure 6-22: The grid image with the translated grid-overlay displayed above
    it'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-22：显示在其上方的经过变换的grid-overlay图像的网格图
- en: The x-y coordinate (0, 0) no longer aligns with the upper left corner of the
    display window. The grid-overlay graphic serves as a visual representation of
    your new, shifted coordinate system.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: x-y坐标(0, 0)不再与显示窗口的左上角对齐。grid-overlay图形作为你新的、移动后的坐标系的可视化表示。
- en: 'Add a red and a yellow square:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个红色和一个黄色方块：
- en: '[PRE20]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The red and yellow squares share a y-argument of `0`, but the yellow square
    has an x-coordinate of `100`. Run the sketch. Processing positions both squares
    relative to your new origin. The yellow square should appear to the right of the
    red ([Figure 6-23](#figure6-23)).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 红色和黄色方块共享`y`参数为`0`，但黄色方块的x坐标为`100`。运行草图。Processing根据新的原点相对定位两个方块。黄色方块应该出现在红色方块的右侧（见[图6-23](#figure6-23)）。
- en: 'Transformations are cumulative, meaning that each subsequent transformation
    uses the current coordinate system as a reference, so you could have placed the
    yellow square 100 pixels to the right by using an additional `translate(100, 0)`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 变换是累积的，这意味着每个后续的变换都会使用当前的坐标系作为参考，因此你可以通过使用额外的`translate(100, 0)`将黄色方块向右移动100像素：
- en: '[PRE21]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The new `translate()` line has an `x` argument of `100`, and the `x` argument
    for the `square()` is now `0`. The visual result should be the same as [Figure
    6-23](#figure6-23).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`translate()`语句的`x`参数为`100`，而`square()`的`x`参数现在为`0`。视觉效果应与[图6-23](#figure6-23)相同。
- en: '![f06023](image_fi/500969c06/f06023.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![f06023](image_fi/500969c06/f06023.png)'
- en: 'Figure 6-23: Horizontally adjacent red and yellow squares'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-23：水平相邻的红色和黄色方块
- en: In Chapter 5, you learned how to use a loop to arrange Truchet tiles. A row
    and column variable kept track of where to place the tiles. Alternatively, you
    could have used `translate()`, moving the coordinate system with each iteration
    of the loop.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在第5章中，你学习了如何使用循环来排列Truchet图块。一个行和列变量追踪图块的位置。或者，你也可以使用`translate()`，每次循环迭代时移动坐标系。
- en: rotate()
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: rotate()
- en: The `rotate()` function rotates the coordinate system around its origin (0,
    0). It accepts a single argument specified in radians. Positive values rotate
    clockwise, and negative values rotate counterclockwise. As with all transformation
    functions, the effect is cumulative. Moreover, you can mix `rotate()` and other
    transformation functions as you please.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`rotate()` 函数围绕原点 (0, 0) 旋转坐标系统。它接受一个以弧度表示的单一参数。正值顺时针旋转，负值逆时针旋转。与所有变换函数一样，效果是累积的。此外，您可以自由地将
    `rotate()` 与其他变换函数混合使用。'
- en: 'Add a new `rotate()` line beneath your first `translate()` function to rotate
    the grid-overlay graphic and red and yellow squares:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个 `translate()` 函数下方添加一行新的 `rotate()` 语句，以旋转网格覆盖图形和红色与黄色方块：
- en: '[PRE22]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `rotate()` function uses an argument of `QUARTER_PI` radians, equivalent
    to 45 degrees. Note that `QUARTER_PI` is a predefined Processing variable, equivalent
    to writing `PI/4`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`rotate()` 函数使用 `QUARTER_PI` 弧度作为参数，相当于 45 度。请注意，`QUARTER_PI` 是一个预定义的 Processing
    变量，相当于写作 `PI/4`。'
- en: Run the sketch. The two squares should appear to be rotated as a group, along
    with the grid-overlay graphic ([Figure 6-24](#figure6-24)).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 运行草图。两个方块应当看起来作为一个整体进行旋转，同时显示网格覆盖图形（[图 6-24](#figure6-24)）。
- en: '![f06024](image_fi/500969c06/f06024.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![f06024](image_fi/500969c06/f06024.png)'
- en: 'Figure 6-24: Rotating the grid-overlay graphic and two squares'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-24：旋转网格覆盖图形和两个方块
- en: The coordinate system is rotated around the current origin, which serves as
    the pivot point. Recall that this origin has been offset by 150 pixels for `x`
    and 100 pixels for `y` by the `translate()` function.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 坐标系统围绕当前原点旋转，原点作为枢轴点。回想一下，这个原点通过 `translate()` 函数已经偏移了 150 像素的 `x` 和 100 像素的
    `y`。
- en: The order of functions matters. For instance, switching the `translate()` and
    `rotate()` lines produces different visual results. [Figure 6-25](#figure6-25)
    provides a comparison. The ghosted squares depict the result of the transformation
    that occurred first. The right image is produced by performing the `rotate()`
    first, when the origin is aligned with the upper left corner of the display window.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的顺序非常重要。例如，交换 `translate()` 和 `rotate()` 语句会产生不同的视觉效果。[图 6-25](#figure6-25)
    提供了对比。幽灵方块显示了先执行的变换结果。右边的图像是先执行 `rotate()` 时产生的结果，此时原点与显示窗口的左上角对齐。
- en: '![f06025](image_fi/500969c06/f06025.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![f06025](image_fi/500969c06/f06025.png)'
- en: 'Figure 6-25: The order of the `translate()` and `rotate()` functions matters;
    the image on the left shows `translate()` first, and the image on the right shows
    `rotate()` first.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-25：`translate()` 和 `rotate()` 函数的顺序很重要；左边的图像显示了先执行 `translate()`，右边的图像显示了先执行
    `rotate()`。
- en: To rotate a square around its center, as opposed to its upper left corner, align
    the center of the square with the origin by offsetting the `x` and `y` arguments
    for `square()`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要绕方块的中心而不是其左上角旋转，将方块的中心与原点对齐，方法是调整 `square()` 函数的 `x` 和 `y` 参数。
- en: scale()
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: scale()
- en: The `scale()` function resizes the coordinate system. One argument will scale
    proportionately; two arguments control the x-scale and y-scale. A `scale(1)` or
    `scale(1, 1)` will have no effect, as those are the default scale values.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`scale()` 函数调整坐标系统的大小。一个参数会按比例缩放；两个参数分别控制 x 和 y 轴的缩放。`scale(1)` 或 `scale(1,
    1)` 不会产生任何效果，因为这些是默认的缩放值。'
- en: 'To decrease the scale, use a floating-point value between 0 and 1\. Reduce
    the size of your existing elements:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 要减小缩放比例，请使用介于 0 和 1 之间的浮动值。缩小现有元素的大小：
- en: '[PRE23]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The scale value of `0.5` scales the elements to half their original size. Just
    as with `rotate()`, the scaling is relative to the origin of the current coordinate
    system. In other words, (0, 0) stays in place, and everything shrinks toward this
    point ([Figure 6-26](#figure6-26)).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`scale(0.5)` 会将元素的大小缩小到原来的一半。与 `rotate()` 一样，缩放是相对于当前坐标系的原点而言的。换句话说，(0, 0)
    保持不变，所有内容朝这个点收缩（[图 6-26](#figure6-26)）。'
- en: '![f06026](image_fi/500969c06/f06026.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![f06026](image_fi/500969c06/f06026.png)'
- en: 'Figure 6-26: Halving the size by using `scale(0.5)`'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-26：使用 `scale(0.5)` 将大小减半
- en: Any value above 1 scales upward. For instance, to double the size of everything,
    use `scale(2)`. To reflect/flip on a given axis, use a negative value. For example,
    `scale(-1, 1)` flips everything horizontally, producing a mirror image of your
    elements.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 任何大于 1 的值都会放大。例如，要将所有内容的大小加倍，请使用 `scale(2)`。要在某个轴上进行反射/翻转，请使用负值。例如，`scale(-1,
    1)` 会将所有内容水平翻转，生成元素的镜像图像。
- en: shearX() and shearY()
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: shearX() 和 shearY()
- en: '*Shearing* a shape skews it along the horizontal or vertical axis. The result
    is a distorted shape with the same area. A typical shear example is transforming
    a rectangle into a parallelogram with slanted sides.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '*剪切*形状会使其沿水平或垂直轴倾斜。结果是一个形变的形状，面积不变。一个典型的剪切例子是将矩形转换为具有倾斜边的平行四边形。'
- en: The `shearX()` and `shearY()` functions apply a horizontal and vertical shear,
    respectively. Each function accepts a single argument specified in radians.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`shearX()`和`shearY()`函数分别应用水平和垂直剪切。每个函数接受一个以弧度为单位的单一参数。'
- en: 'To apply a vertical shear to your grid-overlay graphic and two squares, comment
    out the `rotate()` line and apply a 45-degree vertical shear by using a `shearY()`
    function:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 要对你的网格覆盖图形和两个方块应用垂直剪切，可以注释掉`rotate()`行，并使用`shearY()`函数应用45度垂直剪切：
- en: '[PRE24]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `rotate()` function is commented to make the direction of the shear more
    visually apparent. The `shearY()` argument is a positive number, so the shear
    is applied in a clockwise direction. [Figure 6-27](#figure6-27) contrasts the
    result of these code changes (left image) and a `shearX()` operation (right).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`rotate()`函数被注释掉，以使剪切的方向更加直观。`shearY()`的参数是一个正数，因此剪切会按顺时针方向应用。[图6-27](#figure6-27)对比了这些代码更改的结果（左图）与`shearX()`操作（右图）。'
- en: You now know how to combine transformation functions; however, you’ll often
    want to contain the transformation effects to a limited selection of elements.
    Next, let’s look at how to use multiple coordinate matrices within a single sketch.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何组合变换函数；然而，你通常会希望将变换效果限制在某些元素的范围内。接下来，让我们看看如何在单个草图中使用多个坐标矩阵。
- en: '![f06027](image_fi/500969c06/f06027.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![f06027](image_fi/500969c06/f06027.png)'
- en: 'Figure 6-27: `shearY(QUARTER_PI)` (left) and `shearX(QUARTER_PI)` (right)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '图6-27: `shearY(QUARTER_PI)`（左）和`shearX(QUARTER_PI)`（右）'
- en: pushMatrix() and popMatrix()
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: pushMatrix()和popMatrix()
- en: The `pushMatrix()` and `popMatrix()` functions allow you to isolate the effects
    of any transformation functions. In this way, you can perform different transformations
    on selected elements, which is especially useful for groups of elements.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`pushMatrix()`和`popMatrix()`函数允许你隔离任何变换函数的效果。通过这种方式，你可以对选定的元素执行不同的变换，这对于元素组特别有用。'
- en: Any elements you add to your sketch are positioned relative to the coordinate
    system’s origin. Recall that each new transformation function affects the position
    or orientation of the origin and that each new transformation is influenced by
    any that precede it.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 你添加到草图中的任何元素都会相对于坐标系的原点定位。请记住，每个新的变换函数都会影响原点的位置或方向，并且每个新的变换都会受到前一个变换的影响。
- en: 'If you want to apply `translate()` and `scale()` to the yellow square, but
    not `shearY()`, isolate the red and yellow squares, placing each within `pushMatrix()`
    and `popMatrix()`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想将`translate()`和`scale()`应用于黄色方块，但不想应用`shearY()`，可以将红色和黄色方块隔离开来，将每个方块放置在`pushMatrix()`和`popMatrix()`内：
- en: '[PRE25]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `pushMatrix()` functions create new matrices for `shearY()` 2 and `translate()`
    3, which both extend upon the `translate(150, 100)` above 1. The `popMatrix()`
    function restores the coordinate system before the previous `pushMatrix()` line.
    I’ve added another grid-overlay graphic to help visualize what is happening with
    the two coordinate systems.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`pushMatrix()`函数为`shearY()` 2和`translate()` 3创建了新的矩阵，这两个函数都扩展了上面`translate(150,
    100)` 1。`popMatrix()`函数恢复了之前`pushMatrix()`行之前的坐标系。我添加了另一个网格覆盖图形，以帮助可视化两个坐标系之间的差异。'
- en: As an alternative, you could undo the shear by adding `shearY(-QUARTER_PI)`
    after the red square, but pushing and popping matrices is the more elegant solution.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 作为替代方法，你可以在红色方块后添加`shearY(-QUARTER_PI)`来撤销剪切，但推送和弹出矩阵是更优雅的解决方案。
- en: Run the sketch. As shown in [Figure 6-29](#figure6-29), the yellow square should
    appear translated and scaled, but not sheared.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 运行草图。如[图6-29](#figure6-29)所示，黄色方块应该被平移和缩放，但不被剪切。
- en: '![f06029](image_fi/500969c06/f06029.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![f06029](image_fi/500969c06/f06029.png)'
- en: 'Figure 6-29: The yellow square is translated and scaled, but not sheared.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '图6-29: 黄色方块已被平移和缩放，但未进行剪切。'
- en: Now imagine that you want to move drawings made of multiple shapes across the
    display window. [Figure 6-30](#figure6-30) depicts a fish tank simulation; each
    fish is composed of many shapes. Each eye (a circle) has its own x-y coordinate,
    and so does every vertex that defines a curve or straight line.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设你想将由多个形状组成的图形移动到显示窗口中。[图6-30](#figure6-30)展示了一个鱼缸模拟，每条鱼由多个形状组成。每只眼睛（一个圆形）都有自己的x-y坐标，每个定义曲线或直线的顶点也是如此。
- en: '![f06030](image_fi/500969c06/f06030.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![f06030](image_fi/500969c06/f06030.png)'
- en: 'Figure 6-30: Translating groups of shapes by using `pushMatrix``(``)` and `popMatrix``()`'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-30：使用 `pushMatrix()` 和 `popMatrix()` 进行形状组的平移
- en: To track and update all of these x-y coordinates, you must store them in global
    variables to increment with each frame. The more efficient approach is to define
    each fish within a pair of `pushMatrix()` and `popMatrix()` functions. In this
    way, you can control the position of one fish by using one global x-y coordinate
    pair and a `translate()` function.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 要追踪和更新所有这些 x-y 坐标，你必须将它们存储在全局变量中，以便在每一帧中递增。更高效的做法是将每条鱼定义在一对 `pushMatrix()` 和
    `popMatrix()` 函数中。这样，你可以通过使用一对全局 x-y 坐标和 `translate()` 函数来控制一条鱼的位置。
- en: Experiment with the `pushMatrix()` and `popMatrix()` functions containing different
    groups of shapes, each employing a different sequence of transformation functions.
    You can add animation if you like. Reuse the `image(grido, 0, 0)` line within
    each of your `pushMatrix()...` `popMatrix()` stacks to help visualize what’s happening.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `pushMatrix()` 和 `popMatrix()` 函数，包含不同形状的组，每个组使用不同的变换函数序列。你可以添加动画效果。如果需要，重新使用
    `image(grido, 0, 0)` 行，在每个 `pushMatrix()...` `popMatrix()` 栈中帮助你可视化正在发生的变化。
- en: 'Challenge #6: Analog Clock'
  id: totrans-203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '挑战 #6：模拟时钟'
- en: In this challenge, you’ll use all the techniques you’ve learned in this chapter
    to create an analog clock that displays the current time. The clock will update
    every second, so you’ll need to use `draw()`. To rotate the second, minute, and
    hour hands, you’ll use transformation functions.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个挑战中，你将使用本章学到的所有技巧来创建一个显示当前时间的模拟时钟。时钟将每秒更新一次，因此你需要使用 `draw()`。为了旋转秒针、分针和时针，你将使用变换函数。
- en: 'Create a new sketch and save it as *analog_clock*. Add the following code:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的草图，并将其保存为 *analog_clock*。添加以下代码：
- en: '[PRE26]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The frame rate is set to `1`, enough to update the second hand’s position each
    second.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 帧率设置为 `1`，足以每秒更新一次秒针的位置。
- en: 'To retrieve the relevant time values, use the Processing `hour()`, `minute()`,
    and `second()` functions. Each function communicates with your computer clock
    to return an integer value; these functions require no arguments. Add code to
    the `draw` block that displays the current time in the console:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取相关的时间值，请使用 Processing 的 `hour()`、`minute()` 和 `second()` 函数。每个函数与计算机时钟通信并返回一个整数值；这些函数不需要任何参数。在
    `draw` 块中添加代码以在控制台显示当前时间：
- en: '[PRE27]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Run the sketch. With each new frame, your console displays the current hours
    (0 to 23), minutes (0 to 59), and seconds (0 to 59), separated by colons. The
    time should match that of your system clock, usually displayed in the corner of
    your screen.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 运行草图。在每一帧中，控制台会显示当前的小时（0 到 23）、分钟（0 到 59）和秒数（0 到 59），并用冒号分隔。时间应与系统时钟一致，通常显示在屏幕的角落。
- en: Creating a digital-style clock (that is, no hands, just numbers) in Processing
    is a simple matter of combining time and `text()` functions. For an analog clock,
    however, you need to convert the hours, minutes, and seconds into angles of rotation.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个数字式时钟（即没有指针，只有数字）的方式非常简单，只需结合时间和 `text()` 函数即可。然而，对于模拟时钟，你需要将小时、分钟和秒数转换为旋转角度。
- en: 'Begin your clock by drawing the face and hour hand:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 从绘制表盘和时针开始：
- en: '[PRE28]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `translate()` function 1 positions the origin in the center of the display
    window. This will make rotating the clock hands simpler, because the `rotate()`
    function rotates around the origin of the coordinate system. The `circle()` function,
    with its x-y arguments both set at zero 2, is centered in the display window ([Figure
    6-31](#figure6-31)). The hour hand is the thickest (and shortest), with a stroke
    weight of `10` 3 and length of `100` pixels 4.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`translate()` 函数 1 将原点定位在显示窗口的中心。这样可以简化时钟指针的旋转，因为 `rotate()` 函数是围绕坐标系统的原点旋转的。`circle()`
    函数将 x-y 参数都设置为零 2，因此它位于显示窗口的中心（[图 6-31](#figure6-31)）。时针是最粗（也是最短）的，笔画粗细为 `10`
    3，长度为 `100` 像素 4。'
- en: '![f06031](image_fi/500969c06/f06031.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![f06031](image_fi/500969c06/f06031.png)'
- en: 'Figure 6-31: A clock face with an hour hand'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-31：带时针的时钟表盘
- en: 'The hour hand currently rests along 0 radians (pointing east). Recall that
    when drawing using the `arc()` function, the angle opens from this point, clockwise
    (southward). However, your clock will be offset by three hours should the hand
    begin from a three o’clock position. Calibrate this using a `rotate()` function:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 目前时针指向 0 弧度（指向东方）。回想一下，在使用`arc()`函数绘制时，角度是从该点顺时针打开的（向南）。然而，如果时针从三点钟位置开始，你的时钟会偏移三个小时。你可以使用`rotate()`函数来校准：
- en: '[PRE29]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `HALF_PI` is equivalent to `PI / 2`; by prepending this with a `–` sign,
    you rotate counterclockwise. Run the sketch. The hour hand should now point to
    twelve o’clock (directly upward).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`HALF_PI` 等于 `PI / 2`；通过在前面加上 `–` 符号，你可以实现逆时针旋转。运行草图，时针现在应该指向十二点（直接向上）。'
- en: The next step is to calculate how many radians the hand advances with each hour.
    Consider that a complete rotation is 2π radians; therefore, one hour equals `PI
    * 2 / 12`. So, six o’clock is `PI * 2 / 12 * 6`. Rather than writing `PI * 2`,
    though, you can use `TAU`. For example, six o’clock is equal to `TAU / 12 * 6`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是计算时针每小时前进多少弧度。考虑到一圈是 2π 弧度，因此一个小时等于 `PI * 2 / 12`。因此，六点钟是 `PI * 2 / 12 *
    6`。不过，你可以使用 `TAU` 代替 `PI * 2`。例如，六点钟等于 `TAU / 12 * 6`。
- en: 'Rotate your hour hand to the current hour:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 将时针旋转到当前时间：
- en: '[PRE30]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: At twelve o’clock, the hour hand points directly upward. This is because `TAU
    / 12 * 12` is equal to `TAU`, or one complete rotation. For every other hour,
    the hand should point to the correct position ([Figure 6-32](#figure6-32)). Of
    course, the angle of the hand will depend on what time of day it is.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在十二点钟，时针指向正上方。这是因为 `TAU / 12 * 12` 等于 `TAU`，即完成一圈。对于其他每个小时，时针应该指向正确的位置（[图 6-32](#figure6-32)）。当然，时针的角度将取决于现在是一天中的哪个时间。
- en: Now add the minute and second hands. The final result should look something
    like [Figure 6-33](#figure6-33).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在添加分钟和秒针。最终的效果应该类似于[图 6-33](#figure6-33)。
- en: The second hand should advance each second. Compare the time in the console
    to the visual output to ensure that your code is working correctly. If you need
    help, you can access the solution at [https://github.com/tabreturn/processing.py-book/tree/master/chapter-06-motion_and_transformation/analog_clock/](https://github.com/tabreturn/processing.py-book/tree/master/chapter-06-motion_and_transformation/analog_clock/).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 秒针应该每秒钟前进一次。比较控制台中的时间和视觉输出，确保代码正确运行。如果你需要帮助，可以访问解决方案：[https://github.com/tabreturn/processing.py-book/tree/master/chapter-06-motion_and_transformation/analog_clock/](https://github.com/tabreturn/processing.py-book/tree/master/chapter-06-motion_and_transformation/analog_clock/)。
- en: '![f06032](image_fi/500969c06/f06032.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![f06032](image_fi/500969c06/f06032.png)'
- en: 'Figure 6-32: The hour hand pointing to two o’clock'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-32：时针指向两点钟
- en: '![f06033](image_fi/500969c06/f06033.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![f06033](image_fi/500969c06/f06033.png)'
- en: 'Figure 6-33: The completed clock'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-33：完成的时钟
- en: Summary
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how to structure a Processing sketch for animation.
    To manage variables between frames, you learned how to use global variables. You
    can increment global variables every frame to control shape coordinates for smooth
    animation. You also now know how to save frames as images. You might save an animation
    as a sequence of images so that you can combine them into a movie by using video
    editing software.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何为动画结构化一个 Processing 草图。为了在不同的帧之间管理变量，你学会了如何使用全局变量。你可以在每帧增量更新全局变量，以控制形状坐标，从而实现流畅的动画效果。你还学会了如何将帧保存为图像。你可能会将动画保存为一系列图像，然后通过视频编辑软件将它们合成成电影。
- en: You also saw how transformation functions manipulate the coordinate system,
    allowing you to translate, rotate, scale, and shear your elements. And you learned
    to modify the coordinate system to apply transformations to a select group of
    elements. It’s far easier to move a group of shapes by using a single translate
    operation than to manage a large number of coordinate variables. Moreover, applying
    rotate, scale, and shear operations to a single shape, let alone group, would
    otherwise involve complex matrix calculations.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 你还看到了如何通过变换函数操作坐标系，允许你平移、旋转、缩放和剪切你的元素。你学习了如何修改坐标系，以便对特定组的元素应用变换。通过一次平移操作移动一组形状，比管理大量坐标变量要容易得多。此外，对单一形状（更别说是一个组）应用旋转、缩放和剪切操作，否则将涉及复杂的矩阵计算。
- en: In the next chapter, you’ll learn about Python lists and how to read in data
    from external files. Lists will unlock powerful ways to manage and manipulate
    values as collections of elements, rather than individually. To help visualize
    list values, you’ll also explore data visualization techniques.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，你将学习关于 Python 列表的内容以及如何从外部文件读取数据。列表将为你提供强大的方法来管理和操作值，将它们视为元素集合，而非单独的个体。为了帮助可视化列表值，你还将探索数据可视化技巧。
