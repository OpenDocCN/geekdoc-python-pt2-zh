- en: '**8**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**8**'
- en: '**FUNCTIONAL PROGRAMMING**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数式编程**'
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: 'Many Python developers are unaware of the extent to which you can use functional
    programming in Python, which is a shame: with few exceptions, functional programming
    allows you to write more concise and efficient code. Moreover, Python’s support
    for functional programming is extensive.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 Python 开发者并未意识到在 Python 中可以使用函数式编程的程度，这是很遗憾的：除了少数例外，函数式编程可以让你写出更加简洁和高效的代码。而且，Python
    对函数式编程的支持非常广泛。
- en: This chapter will cover some of the functional programming aspects of Python,
    including creating and using generators. You’ll learn about the most useful functional
    packages and functions available and how to use them in combination to get the
    most efficient code.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍 Python 中的一些函数式编程方面，包括创建和使用生成器。你将了解一些最有用的函数式包和函数，并学习如何将它们结合使用以获得最高效的代码。
- en: '**NOTE**'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you want to get serious about functional programming, here’s my advice:
    take a break from Python and learn a hugely functional programming language, such
    as Lisp. I know it might sound strange to talk about Lisp in a Python book, but
    playing with Lisp for several years taught me how to “think functional.” You may
    not develop the thought processes necessary to make full use of functional programming
    if all your experience comes from imperative and object-oriented programming.
    Lisp isn’t purely functional itself, but it has more focus on functional programming
    than you’ll find in Python.*'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你想认真学习函数式编程，以下是我的建议：暂时离开 Python，学习一门功能强大的函数式编程语言，比如 Lisp。我知道在一本 Python 书中谈
    Lisp 可能听起来有些奇怪，但我在玩 Lisp 几年后学会了如何“函数式思考”。如果你所有的编程经验都来自命令式编程和面向对象编程，你可能不会发展出充分利用函数式编程所需的思维方式。Lisp
    本身并不是纯函数式的，但它对函数式编程的关注比你在 Python 中看到的要多。*'
- en: '**Creating Pure Functions**'
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**创建纯函数**'
- en: 'When you write code using a functional style, your functions are designed to
    have no side effects: instead, they take an input and produce an output without
    keeping state or modifying anything not reflected in the return value. Functions
    that follow this ideal are referred to as *purely functional*.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用函数式风格编写代码时，你的函数设计上不会有副作用：相反，它们接受输入并生成输出，而不会保持状态或修改任何返回值以外的东西。遵循这一理想的函数被称为*纯函数*。
- en: 'Let’s start with an example of a regular, non-pure function that removes the
    last item in a list:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个常规的非纯函数示例开始，该函数用于移除列表中的最后一个元素：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following is a pure version of the same function:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是同一函数的纯粹版本：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We define a `butlast()` function to work like `butlast` in Lisp, in that it
    returns the list without the last element *without* modifying the original list.
    Instead, it returns a copy of the list that has the modifications in place, allowing
    us to keep the original.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个 `butlast()` 函数，它的功能类似于 Lisp 中的 `butlast`，返回没有最后一个元素的列表，而*不*修改原始列表。相反，它返回一个已进行修改的列表副本，从而允许我们保留原始列表。
- en: 'The practical advantages of functional programming include the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程的实际优势包括以下几点：
- en: '**Modularity** Writing with a functional style forces a certain degree of separation
    in solving your individual problems and makes sections of code easier to reuse
    in other contexts. Since the function does not depend on any external variable
    or state, calling it from a different piece of code is straightforward.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**模块化** 采用函数式编程风格强制在解决各个问题时进行一定程度的分离，使得代码的各个部分更容易在其他上下文中重用。由于函数不依赖于任何外部变量或状态，从不同的代码块中调用它非常直接。'
- en: '**Brevity** Functional programming is often less verbose than other paradigms.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**简洁性** 函数式编程通常比其他编程范式更加简洁。'
- en: '**Concurrency** Purely functional functions are thread-safe and can run concurrently.
    Some functional languages do this automatically, which can be a big help if you
    ever need to scale your application, though this is not quite the case yet in
    Python.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**并发性** 纯函数是线程安全的，可以并发执行。一些函数式语言会自动实现这一点，这在你需要扩展应用程序时非常有帮助，尽管在 Python 中这还不完全是现状。'
- en: '**Testability** Testing a functional program is incredibly easy: all you need
    is a set of inputs and an expected set of outputs. They are *idempotent*, meaning
    that calling the same function over and over with the same arguments will always
    return the same result.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**可测试性** 测试一个函数式程序是非常简单的：你只需要一组输入和一组预期的输出。这些输出是*幂等的*，意味着使用相同的参数多次调用同一个函数将始终返回相同的结果。'
- en: '**Generators**'
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**生成器**'
- en: A *generator* is an object that behaves like an iterator, in that it generates
    and returns a value on each call of its `next()` method until a `StopIteration`
    is raised. Generators, first introduced in PEP 255, offer an easy way to create
    objects that implement the *iterator protocol*. While writing generators in a
    functional style is not strictly necessary, doing so makes them easier to write
    and debug and is a common practice.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*生成器*是一个行为类似于迭代器的对象，它在每次调用`next()`方法时生成并返回一个值，直到引发`StopIteration`为止。生成器首次在PEP
    255中引入，提供了一种简单的方式来创建实现*迭代器协议*的对象。虽然以函数式风格编写生成器不是严格必要的，但这样做可以使它们更易于编写和调试，这也是一种常见的做法。'
- en: 'To create a generator, just write a regular Python function that contains a
    `yield` statement. Python will detect the use of `yield` and tag the function
    as a generator. When execution reaches the `yield` statement, the function returns
    a value as with a `return` statement, but with one notable difference: the interpreter
    will save a stack reference, and this will be used to resume the function’s execution
    when the `next()` function is called again.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建生成器，只需编写一个常规的Python函数，并包含一个`yield`语句。Python会检测到`yield`的使用，并将该函数标记为生成器。当执行到`yield`语句时，函数返回一个值，就像`return`语句一样，但有一个显著的区别：解释器会保存一个堆栈引用，这将用于在再次调用`next()`时恢复函数的执行。
- en: When functions are executed, the chaining of their execution produces a *stack*—function
    calls are said to be stacked on each other. When a function returns, it’s removed
    from the stack, and the value it returns is passed to the calling function. In
    the case of a generator, the function does not really return but *yields* instead.
    Python therefore saves the state of the function as a stack reference, resuming
    the execution of the generator at the point it saved when the next iteration of
    the generator is needed.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数执行时，它们的执行链会产生一个*堆栈*——函数调用被认为是堆叠在一起的。当一个函数返回时，它会从堆栈中移除，并将返回值传递给调用函数。对于生成器来说，函数并不真正返回，而是*生成*。因此，Python会保存函数的状态作为堆栈引用，当需要生成器的下一次迭代时，它会恢复生成器的执行，恢复到保存的点。
- en: '***Creating a Generator***'
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***创建生成器***'
- en: As mentioned, you create a generator by writing a normal function and including
    `yield` in the function’s body. [Listing 8-1](ch08.xhtml#ch8list1) creates a generator
    called `mygenerator()` that includes three yields, meaning it will iterate with
    the next three calls to `next()`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，您可以通过编写一个常规函数并在函数体内包含`yield`来创建生成器。[示例 8-1](ch08.xhtml#ch8list1)创建了一个名为`mygenerator()`的生成器，其中包含三个`yield`，意味着它将在接下来的三次`next()`调用时进行迭代。
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 8-1: Creating a generator with three iterations*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 8-1：创建一个具有三次迭代的生成器*'
- en: When it runs out of `yield` statements, `StopIteration` is raised at the next
    call to `next()`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当它耗尽`yield`语句时，下一次调用`next()`时会引发`StopIteration`。
- en: In Python, generators keep a reference to the stack when a function yields something,
    and they resume this stack when a call to `next()` is executed again.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，当函数产生某个值时，生成器会保留堆栈的引用，当再次调用`next()`时，它们会恢复这个堆栈。
- en: The naive approach when iterating over any data without using generators is
    to build the entire list first, which often consumes memory wastefully.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在不使用生成器时，迭代任何数据的朴素方法是首先构建整个列表，这通常会浪费内存。
- en: 'Say we want to find the first number between 1 and 10,000,000 that’s equal
    to 50,000\. Sounds easy, doesn’t it? Let’s make this a challenge. We’ll run Python
    with a memory constraint of 128MB and try the naive approach of first building
    the entire list:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想找到1和10,000,000之间第一个等于50,000的数字。听起来很简单，对吧？让我们给自己一个挑战。我们将在128MB内存限制下运行Python，并尝试首先构建整个列表的朴素方法：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This naive method first tries to build the list, but if we run the program
    so far:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这种朴素方法首先尝试构建列表，但如果我们运行程序到这个阶段：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Uh-oh. Turns out we can’t build a list of 10 million items with only 128MB of
    memory!
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀，结果我们不能仅凭128MB的内存构建一个包含1000万个项目的列表！
- en: '**WARNING**'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**'
- en: '*In Python 3, range() returns a generator when iterated. To get a generator
    in Python 2, you have to use xrange() instead. This function doesn’t exist in
    Python 3 anymore, since it’s redundant.*'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*在Python 3中，range()在迭代时返回一个生成器。要在Python 2中获取生成器，必须使用xrange()。这个函数在Python 3中已不再存在，因为它是多余的。*'
- en: 'Let’s try using a generator instead, with the same 128MB restriction:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们改用生成器试试看，同样的128MB限制：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This time, our program executes without issue. When it is iterated over, the
    `range()` class returns a generator that dynamically generates our list of integers.
    Better still, since we are only interested in the 50,000th number, instead of
    building the full list, the generator only had to generate 50,000 numbers before
    it stopped.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们的程序没有出现问题。当它被迭代时，`range()`类返回一个生成器，该生成器动态地生成我们的整数列表。更好的是，由于我们只对第50,000个数字感兴趣，因此生成器只需要生成50,000个数字就会停止，而不是构建完整的列表。
- en: By generating values on the fly, generators allow you to handle large data sets
    with minimal consumption of memory and processing cycles. Whenever you need to
    work with a huge number of values, generators can help you handle them efficiently.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 通过动态生成值，生成器允许你以最小的内存和处理周期消耗处理大型数据集。每当你需要处理大量的值时，生成器可以帮助你高效地处理它们。
- en: '***Returning and Passing Values with yield***'
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***通过yield返回和传递值***'
- en: 'A `yield` statement also has a less commonly used feature: it can return a
    value in the same way as a function call. This allows us to pass a value to a
    generator by calling its `send()` method. As an example of using `send()`, we’ll
    write a function called `shorten()` that takes a list of strings and returns a
    list consisting of those same strings, only truncated ([Listing 8-2](ch08.xhtml#ch8list2)).'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`yield`语句还有一个不太常用的功能：它可以像函数调用一样返回一个值。这使得我们可以通过调用生成器的`send()`方法向生成器传递一个值。作为使用`send()`的例子，我们将编写一个名为`shorten()`的函数，它接受一个字符串列表，并返回一个由这些相同字符串构成的列表，只是每个字符串都被截断了（[清单8-2](ch08.xhtml#ch8list2)）。'
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 8-2: Returning and using a value with send()*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单8-2：使用send()返回和使用值*'
- en: 'In this example, we’ve written a function called `shorten()` that takes a list
    of strings and returns a list consisting of those same strings, only truncated.
    The length of each truncated string is equal to the number of vowels in the previous
    string: *loremipsum* has four vowels, so the second value returned by the generator
    will be the first four letters of *dolorsit*; *dolo* has only two vowels, so *ametfoobar*
    will be truncated to its first two letters *am*. The generator then stops and
    raises `StopIteration`. Our generator thus returns:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们写了一个名为`shorten()`的函数，它接受一个字符串列表，并返回一个由这些相同字符串构成的列表，只是每个字符串都被截断了。每个截断后的字符串长度等于前一个字符串中的元音字母数量：*loremipsum*有四个元音，因此生成器返回的第二个值将是*dolorsit*的前四个字母；*dolo*只有两个元音，因此*ametfoobar*将被截断为前两个字母*am*。然后生成器停止并引发`StopIteration`。因此，我们的生成器返回：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Using `yield` and `send()` in this fashion allows Python generators to function
    like *coroutines* seen in Lua and other languages.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式使用`yield`和`send()`允许Python生成器像Lua和其他语言中的*协程*一样工作。
- en: 'PEP 289 introduced generator expressions, making it possible to build one-line
    generators using a syntax similar to list comprehension:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: PEP 289引入了生成器表达式，使得可以使用类似列表推导的语法构建单行生成器：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this example, `gen` is a generator, just as if we had used the `yield` statement.
    The `yield` in this case is implicit.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`gen`是一个生成器，就像我们使用`yield`语句一样。此时的`yield`是隐式的。
- en: '***Inspecting Generators***'
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***检查生成器***'
- en: To determine whether a function is considered a generator, use `inspect.isgeneratorfunction()`.
    In [Listing 8-3](ch08.xhtml#ch8list3), we create a simple generator and inspect
    it.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要判断一个函数是否被认为是生成器，可以使用`inspect.isgeneratorfunction()`。在[清单8-3](ch08.xhtml#ch8list3)中，我们创建了一个简单的生成器并进行了检查。
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 8-3: Checking whether a function is a generator*'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单8-3：检查函数是否为生成器*'
- en: Import the `inspect` package to use `isgeneratorfunction()` and then just pass
    it the name of the function to inspect. Reading the source code of `inspect.isgeneratorfunction()`
    gives us some insight into how Python marks functions as being generators (see
    [Listing 8-4](ch08.xhtml#ch8list4)).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 导入`inspect`包来使用`isgeneratorfunction()`，然后只需将函数的名称传递给它进行检查。阅读`inspect.isgeneratorfunction()`的源代码可以帮助我们了解Python是如何标记函数为生成器的（见[清单8-4](ch08.xhtml#ch8list4)）。
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 8-4: Source code of inspect.isgeneratorfunction()*'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单8-4：inspect.isgeneratorfunction()的源代码*'
- en: The `isgeneratorfunction()` function checks that the object is a function or
    a method and that its code has the `CO_GENERATOR` flag set. This example shows
    how easy it is to understand how Python works under the hood.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`isgeneratorfunction()`函数检查对象是否为函数或方法，并且其代码是否设置了`CO_GENERATOR`标志。这个例子展示了理解Python底层工作原理是多么简单。'
- en: 'The `inspect` package provides the `inspect.getgeneratorstate()` function,
    which gives the current state of the generator. We’ll use it on `mygenerator()`
    here at different points of execution:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`inspect` 包提供了 `inspect.getgeneratorstate()` 函数，可以返回生成器的当前状态。我们将在 `mygenerator()`
    中的不同执行点上使用它：'
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This allows us to determine whether the generator is waiting to be run for the
    first time (`GEN_CREATED`) ➊, waiting to be resumed by a call to `next()` (`GEN_SUSPENDED`)
    ➋, or finished running (`GEN_CLOSED`) ➌. This might come in handy to debug your
    generators.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够判断生成器是处于首次运行的等待状态（`GEN_CREATED`） ➊，等待通过调用`next()`恢复执行的状态（`GEN_SUSPENDED`）
    ➋，还是已经运行完毕的状态（`GEN_CLOSED`） ➌。这个功能在调试生成器时可能会很有用。
- en: '**List Comprehensions**'
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**列表推导式**'
- en: List comprehension, or *listcomp* for short, allows you to define a list’s contents
    inline with its declaration. To make a list into a listcomp, you must wrap it
    in square brackets as usual, but also include an expression that will generate
    the items in the list and a `for` loop to loop through them.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导式，简称 *listcomp*，允许你在声明列表时直接定义其内容。要将列表转变为列表推导式，必须像平常一样将其放在方括号中，但还要包括一个表达式来生成列表中的项，并加上一个
    `for` 循环来遍历这些项。
- en: 'The following example creates a list without using list comprehension:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下例子没有使用列表推导式创建列表：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And this next example uses list comprehension to make the same list with a
    single line:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 下面这个例子使用列表推导式在一行代码中创建相同的列表：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Using a list comprehension presents two advantages: code written using listcomps
    is usually shorter and therefore compiles down to fewer operations for Python
    to perform. Rather than creating a list and calling `append` over and over, Python
    can just create the list of items and move them into a new list in a single operation.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用列表推导式有两个优点：使用列表推导式编写的代码通常更简短，因此会减少 Python 执行的操作次数。与其反复创建列表并调用`append`，Python
    可以直接创建包含所有元素的列表，并在一次操作中将它们移动到新列表中。
- en: 'You can use multiple `for` statements together and use `if` statements to filter
    out items. Here we create a list of words and use list comprehension to capitalize
    each item, split up items with multiple words into single words, and delete the
    extraneous *or* :'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将多个 `for` 语句结合使用，并使用 `if` 语句来过滤掉某些元素。这里我们创建了一个单词列表，使用列表推导式将每个单词首字母大写，将包含多个单词的项拆分成单个单词，并删除多余的
    *or*：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This code has two `for` loops: the first iterates over the text lines, while
    the second iterates over words in each of those lines. The final `if` statement
    filters out words that start with *or* to exclude them from the final list.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码有两个 `for` 循环：第一个循环遍历文本行，第二个循环遍历每行中的单词。最后一个 `if` 语句过滤掉以 *or* 开头的单词，将它们从最终的列表中排除。
- en: 'Using list comprehension rather than `for` loops is a neat way to define lists
    quickly. Since we’re still talking about functional programming, it’s worth noting
    that lists built through list comprehension shouldn’t rely on changing the program’s
    state: you are not expected to modify any variable while building the list. This
    usually makes the lists more concise and easier to read than lists made without
    listcomp.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用列表推导式而非 `for` 循环是一种快速定义列表的简洁方法。由于我们仍在讨论函数式编程，值得注意的是，使用列表推导式创建的列表不应该依赖于改变程序的状态：在构建列表时，不应修改任何变量。这通常使得列表比没有使用列表推导式的列表更简洁、更易读。
- en: 'Note that there’s also syntax for building dictionaries or sets in the same
    fashion, like so:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，也有类似的语法可以构建字典或集合，像这样：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '**Functional Functions Functioning**'
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**功能性函数的运作**'
- en: You might repeatedly encounter the same set of problems when manipulating data
    using functional programming. To help you deal with this situation efficiently,
    Python includes a number of functions for functional programming. This section
    will give you a quick overview of some of these built-in functions that allow
    you to build fully functional programs. Once you have an idea of what’s available,
    I encourage you to research further and try out functions where they might apply
    in your own code.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用函数式编程处理数据时，你可能会反复遇到相同的一组问题。为了帮助你高效应对这种情况，Python 包含了一些函数来支持函数式编程。本节将快速概述一些内置函数，它们使你能够构建完全函数式的程序。一旦你了解了可用的函数，我鼓励你进一步研究，并尝试将这些函数应用到你自己的代码中。
- en: '***Applying Functions to Items with map()***'
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 map() 将函数应用于元素***'
- en: The `map()` function takes the form `map(function`, iterable) and applies `function`
    to each item in `iterable` to return a list in Python 2 or an iterable `map` object
    in Python 3, as shown in [Listing 8-5](ch08.xhtml#ch8list5).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`map()` 函数的形式为 `map(function, iterable)`，并将 `function` 应用到 `iterable` 中的每一项，返回
    Python 2 中的一个列表，或 Python 3 中的一个可迭代的 `map` 对象，如 [列表 8-5](ch08.xhtml#ch8list5) 所示。'
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 8-5: Using map() in Python 3*'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-5：在 Python 3 中使用 map()*'
- en: 'You could write an equivalent of `map()` using list comprehension, like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用列表推导式编写一个等效的 `map()`，如下所示：
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '***Filtering Lists with filter()***'
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 filter() 过滤列表***'
- en: 'The `filter()` function takes the form `filter(function or None`, iterable)
    and filters the items in `iterable` based on the result returned by `function`.
    This will return a list in Python 2 or an iterable `filter` object in Python 3:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter()` 函数的形式为 `filter(function or None, iterable)`，它根据 `function` 返回的结果过滤
    `iterable` 中的项。在 Python 2 中，这将返回一个列表，在 Python 3 中则返回一个可迭代的 `filter` 对象：'
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You could also write an equivalent of `filter()` using list comprehension,
    like so:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用列表推导式编写一个等效的 `filter()`，如下所示：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '***Getting Indexes with enumerate()***'
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 enumerate() 获取索引***'
- en: 'The `enumerate()` function takes the form `enumerate(iterable`[, start]) and
    returns an iterable object that provides a sequence of tuples, each consisting
    of an integer index (starting with `start`, if provided) and the corresponding
    item in `iterable`. This function is useful when you need to write code that refers
    to array indexes. For example, instead of writing this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`enumerate()` 函数的形式为 `enumerate(iterable [,start])`，并返回一个可迭代的对象，该对象提供一系列元组，每个元组包含一个整数索引（如果提供了
    `start`，则从 `start` 开始）和 `iterable` 中对应的项。当你需要编写引用数组索引的代码时，这个函数非常有用。例如，代替编写如下代码：'
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'you could accomplish the same thing more efficiently with `enumerate()`, like
    so:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以更高效地使用 `enumerate()` 完成同样的事情，如下所示：
- en: '[PRE21]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '***Sorting a List with sorted()***'
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 sorted() 排序列表***'
- en: 'The `sorted()` function takes the form `sorted(iterable`, key=None, reverse=False)
    and returns a sorted version of `iterable`. The `key` argument allows you to provide
    a function that returns the value to sort on, as shown here:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`sorted()` 函数的形式为 `sorted(iterable, key=None, reverse=False)`，并返回 `iterable`
    的排序版本。`key` 参数允许你提供一个返回排序值的函数，如下所示：'
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '***Finding Items That Satisfy Conditions with any() and all()***'
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 any() 和 all() 查找满足条件的项***'
- en: 'The `any(iterable`) and `all(iterable`) functions return a Boolean depending
    on the values returned by `iterable`. These simple functions are equivalent to
    the following full Python code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`any(iterable)` 和 `all(iterable)` 函数根据 `iterable` 返回的值返回布尔值。这些简单的函数等价于以下完整的
    Python 代码：'
- en: '[PRE23]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'These functions are useful for checking whether any or all of the values in
    an iterable satisfy a given condition. For example, the following checks a list
    for two conditions:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数对于检查可迭代对象中的任何值或所有值是否满足给定条件非常有用。例如，以下代码检查一个列表是否满足两个条件：
- en: '[PRE24]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The difference here is that `any()` returns `True` when at least one element
    meets the condition, while `all()` returns `True` only if every element meets
    the condition. The `all()` function will also return `True` for an empty iterable,
    since none of the elements is `False`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的区别是，`any()` 在至少一个元素满足条件时返回 `True`，而 `all()` 只有在每个元素都满足条件时才返回 `True`。`all()`
    函数对于空的可迭代对象也会返回 `True`，因为没有元素为 `False`。
- en: '***Combining Lists with zip()***'
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 zip() 合并列表***'
- en: 'The `zip()` function takes the form `zip(iter1` [,iter2 [...]]). It takes multiple
    sequences and combines them into tuples. This is useful when you need to combine
    a list of keys and a list of values into a dict. As with the other functions described
    here, `zip()` returns a list in Python 2 and an iterable in Python 3\. Here we
    map a list of keys to a list of values to create a dictionary:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`zip()` 函数的形式为 `zip(iter1 [,iter2 [...]])`。它接受多个序列并将它们合并成元组。当你需要将一组键和一组值合并成字典时，这非常有用。与此处描述的其他函数一样，`zip()`
    在 Python 2 中返回一个列表，在 Python 3 中返回一个可迭代的对象。这里我们将一组键映射到一组值以创建字典：'
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '**FUNCTIONAL FUNCTIONS IN PYTHON 2 AND 3**'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python 2 和 3 中的函数式编程函数**'
- en: 'You might have noticed by now how the return types differ between Python 2
    and Python 3\. Most of Python’s purely functional built-in functions return a
    list rather than an iterable in Python 2, making them less memory efficient than
    their Python 3.*x* equivalents. If you’re planning to write code using these functions,
    keep in mind that you’ll get the most benefit out of them in Python 3\. If you’re
    stuck with Python 2, don’t despair: the `itertools` module from the Standard Library
    provides an iterator-based version of many of these functions (`itertools.izip()`,
    `itertools.imap()`, `itertools.ifilter()`, and so on).'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到Python 2和Python 3之间的返回类型差异。Python的大多数纯函数式内置函数在Python 2中返回一个列表，而不是可迭代对象，这使得它们在内存使用上不如Python
    3的*x*版本高效。如果你打算使用这些函数编写代码，请记住在Python 3中你将获得最大收益。如果你仍然使用Python 2，不用担心：标准库中的`itertools`模块提供了这些函数的基于迭代器的版本（如`itertools.izip()`、`itertools.imap()`、`itertools.ifilter()`等）。
- en: '***A Common Problem Solved***'
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***一个常见问题的解决方案***'
- en: 'There’s one important tool still to cover. Often when working with lists we
    want to find the first item that satisfies a specific condition. We’ll look at
    the many ways to accomplish this and then see the most efficient way: the `first`
    package.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个重要的工具需要介绍。在处理列表时，我们经常想找到第一个满足特定条件的项。我们将看看多种实现方法，并最终找到最有效的方法：`first`包。
- en: '**Finding the Item with Simple Code**'
  id: totrans-109
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用简单代码找到项**'
- en: 'We might be able to find the first item to satisfy a condition with a function
    like this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们或许能够通过这样的函数找到第一个满足条件的项：
- en: '[PRE26]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We could rewrite the `first_positive_number()` function in functional style
    like this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这样以函数式风格重写`first_positive_number()`函数：
- en: '[PRE27]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'By using a functional approach where the predicate is passed as argument, the
    function becomes easily reusable. We could even write it more concisely, like
    so:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用函数式方法并将谓词作为参数传递，函数变得非常可复用。我们甚至可以像这样更简洁地编写它：
- en: '[PRE28]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note that this may raise an `IndexError` if no items satisfy the condition,
    causing `list(filter())` to return an empty list.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果没有项满足条件，这可能会引发`IndexError`，导致`list(filter())`返回一个空列表。
- en: 'For simple cases, you can rely on `next()` to prevent `IndexError` from occurring,
    like so:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 对于简单的情况，你可以依赖`next()`来防止发生`IndexError`，像这样：
- en: '[PRE29]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[Listing 8-6](ch08.xhtml#ch8list6) will raise `StopIteration` if a condition
    can never be satisfied. This too can be solved by adding a second argument of
    `next()`, like so.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 8-6](ch08.xhtml#ch8list6)会在条件永远无法满足时抛出`StopIteration`。这也可以通过为`next()`添加第二个参数来解决，像这样：'
- en: '[PRE30]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*Listing 8-6: Returning a default value when the condition is not met*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 8-6：在条件不满足时返回默认值*'
- en: This will return a default value rather than an error when a condition cannot
    be met. Lucky for us, Python provides a package to handle all of this for us.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当条件无法满足时，这将返回一个默认值，而不是抛出错误。幸运的是，Python提供了一个包来处理这一切。
- en: '**Finding the Item Using first()**'
  id: totrans-123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用first()找到项**'
- en: Rather than writing out the function from [Listing 8-6](ch08.xhtml#ch8list6)
    in all of your programs, you can include the small Python package `first`. [Listing
    8-7](ch08.xhtml#ch8list7) shows how this package lets you find the first element
    of an iterable matching a condition.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 与其在所有程序中都编写[示例 8-6](ch08.xhtml#ch8list6)中的函数，不如引入一个小型Python包`first`。[示例 8-7](ch08.xhtml#ch8list7)展示了该包如何帮助你找到匹配条件的可迭代对象的第一个元素。
- en: '[PRE31]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '*Listing 8-7: Finding the first item in a list that satisfies a condition*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 8-7：找到列表中第一个满足条件的项*'
- en: You see that the `first()` function returns the first valid, non-empty item
    in a list.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，`first()`函数返回列表中第一个有效的、非空的项。
- en: '**Using lambda() with functools**'
  id: totrans-128
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用lambda()与functools**'
- en: You’ll notice that we’ve used `lambda()` in a good portion of the examples so
    far in this chapter. The `lambda()` function was added to Python to facilitate
    functional programming functions such as `map()` and `filter()`, which otherwise
    would have required writing an entirely new function every time you wanted to
    check a different condition. [Listing 8-8](ch08.xhtml#ch8list8) is equivalent
    to [Listing 8-7](ch08.xhtml#ch8list7) but is written without using `lambda()`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，在本章的许多例子中，我们已经使用了`lambda()`。`lambda()`函数是为方便函数式编程而添加到Python中的，用于`map()`和`filter()`等函数，否则每次想要检查不同的条件时，你都需要编写一个全新的函数。[示例
    8-8](ch08.xhtml#ch8list8)与[示例 8-7](ch08.xhtml#ch8list7)等效，但没有使用`lambda()`。
- en: '[PRE32]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '*Listing 8-8: Finding the first item to meet the condition, without using lambda()*'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 8-8：找到满足条件的第一个项，不使用lambda()*'
- en: 'This code works identically to that in [Listing 8-7](ch08.xhtml#ch8list7),
    returning the first non-empty value in a list to meet the condition, but it’s
    a good deal more cumbersome: if we wanted to get the first number in the sequence
    that’s longer than, say, 42 items, we’d need to define an appropriate function
    via `def` rather than defining it inline with our call to `first()`.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的工作原理与[示例 8-7](ch08.xhtml#ch8list7)中的代码相同，返回列表中满足条件的第一个非空值，但它要更加繁琐：如果我们想要得到序列中第一个超过42个项目的数字，我们就需要通过`def`来定义一个适当的函数，而不是直接在调用`first()`时内联定义它。
- en: 'But despite its usefulness in helping us avoid situations like this, `lambda`
    still has its problems. The `first` module contains a `key` argument that can
    be used to provide a function that receives each item as an argument and returns
    a Boolean indicating whether it satisfies the condition. However, we can’t pass
    a `key` function, as it would require more than a single line of code: a `lambda`
    statement cannot be written on more than one line. That is a significant limitation
    of `lambda`.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`lambda`有助于我们避免类似的情况，但它仍然存在问题。`first`模块包含一个`key`参数，可以用于提供一个函数，该函数接收每个项作为参数并返回一个布尔值，表示是否满足条件。然而，我们不能传递`key`函数，因为它需要超过一行的代码：`lambda`语句不能跨越多行。这是`lambda`的一个重大限制。
- en: Instead, we would have to go back to the cumbersome pattern of writing new function
    definitions for each `key` we need. Or would we?
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们必须回到繁琐的方式，为每个我们需要的`key`编写新的函数定义。或者我们就不需要这样做吗？
- en: 'The `functools` package comes to the rescue with its `partial()` method, which
    provides us with a more flexible alternative to `lambda`. The `functools.partial()`
    method allows us to create a wrapper function with a twist: rather than changing
    the behavior of a function, it instead changes the *arguments* it receives, like
    so:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`functools`包通过其`partial()`方法为我们提供了帮助，它为我们提供了一个比`lambda`更灵活的替代方案。`functools.partial()`方法允许我们创建一个带有“变形”的包装函数：它不是改变函数的行为，而是改变它接收的*参数*，就像这样：'
- en: '[PRE33]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here we create a new `greater_than()` function that works just like the old
    `greater_than_zero()` from [Listing 8-8](ch08.xhtml#ch8list8) by default, but
    this version allows us to specify the value we want to compare our numbers to,
    whereas before it was hardcoded. Here, we pass `functools.partial()` to our function
    and the value we want for `min` ➊, and we get back a new function that has `min`
    set to 42, just as we want ➋. In other words, we can write a function and use
    `functools.partial()` to customize the behavior of our new functions to suit our
    needs in any given situation.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个新的`greater_than()`函数，它的默认行为与[示例 8-8](ch08.xhtml#ch8list8)中的旧版`greater_than_zero()`函数一样，但这个版本允许我们指定要与其比较的值，而之前的版本是硬编码的。在这里，我们将`functools.partial()`传递给我们的函数，并指定我们想要的`min`值➊，然后我们得到一个新的函数，这个函数将`min`设置为42，正如我们想要的那样➋。换句话说，我们可以编写一个函数，并使用`functools.partial()`来定制我们新函数的行为，以适应任何特定情况下的需求。
- en: 'Even this version can be pared down. All we’re doing in this example is comparing
    two numbers, and as it turns out, the `operator` module has built-in functions
    for exactly that:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是这个版本也可以简化。我们在这个例子中所做的只是比较两个数字，事实证明，`operator`模块正好为此提供了内置函数：
- en: '[PRE34]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This is a good example of `functools.partial()` working with positional arguments.
    In this case, the function `operator.le(a, b)`, which takes two numbers and returns
    a Boolean that tells us whether the first number is less than or equal to the
    second, is passed to `functools.partial()`. The 0 we pass to `functools.partial()`
    gets assigned to `a`, and the argument passed to the function returned by `functools.partial()`
    gets assigned to `b`. So this works identically to [Listing 8-8](ch08.xhtml#ch8list8)
    but without using `lambda` or defining any additional functions.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的例子，展示了`functools.partial()`如何与位置参数一起使用。在这个例子中，函数`operator.le(a, b)`接受两个数字并返回一个布尔值，告诉我们第一个数字是否小于或等于第二个数字。我们将其传递给`functools.partial()`，传递给`functools.partial()`的0被分配给`a`，而传递给`functools.partial()`返回的函数的参数则被分配给`b`。因此，这个例子与[示例
    8-8](ch08.xhtml#ch8list8)中的代码完全相同，但不使用`lambda`或定义任何额外的函数。
- en: '**NOTE**'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The functools.partial() method is typically useful in place of lambda and
    should be considered a superior alternative. The lambda function is something
    of an anomaly in the Python language, and dropping it altogether was considered
    for Python 3 due to the function’s limited body size of a single line.*'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*`functools.partial()`方法通常用于替代lambda表达式，并且应被视为一种更优秀的替代方案。lambda函数在Python语言中算是一种例外，并且由于该函数的体积限制（只能写单行代码），Python
    3中曾考虑过完全去除它。*'
- en: '***Useful itertools Functions***'
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***有用的 itertools 函数***'
- en: Finally, we’ll look at some useful functions in the `itertools` module in the
    Python Standard Library that you should be aware of. Too many programmers end
    up writing their own versions of these functions simply because they aren’t aware
    that Python provides them out of the box. They are all designed to help you manipulate
    `iterator` (that’s why the module is called *iter-tools*) and therefore are all
    purely functional. Here I’ll list a few of them and give a brief overview of what
    they do, and I encourage you to look into them further if they seem of use.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将看看 Python 标准库中 `itertools` 模块中的一些有用函数，你应该了解它们。很多程序员最终会编写这些函数的自定义版本，仅仅因为他们不知道
    Python 提供了这些现成的函数。它们都旨在帮助你操作 `iterator`（这就是该模块名为 *iter-tools* 的原因），因此它们都是纯粹的函数式函数。我将在这里列出其中的一些，并简要介绍它们的功能，鼓励你在有需要时进一步研究它们。
- en: '`accumulate(iterable`[, func]) returns a series of accumulated sums of items
    from iterables.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`accumulate(iterable`[, func]) 返回来自可迭代对象的项目累积和序列。'
- en: '`chain(*iterables`) iterates over multiple iterables, one after another, without
    building an intermediate list of all items.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chain(*iterables`) 依次遍历多个可迭代对象，而无需构建一个包含所有项目的中间列表。'
- en: '`combinations(iterable`, r) generates all combinations of length r from the
    given `iterable`.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`combinations(iterable`, r) 生成从给定 `iterable` 中长度为 r 的所有组合。'
- en: '`compress(data`, selectors) applies a Boolean mask from selectors to data and
    returns only the values from `data` where the corresponding element of selectors
    is `True`.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compress(data`, selectors) 将 selectors 中的布尔掩码应用于 data，只返回 data 中对应 selectors
    元素为 `True` 的值。'
- en: '`count(start`, step) generates an endless sequence of values, starting with
    start and incrementing step at a time with each call.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`count(start`, step) 生成一个无限的数值序列，从 start 开始，每次调用时递增 step。'
- en: '`cycle(iterable`) loops repeatedly over the values in iterable.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cycle(iterable`) 循环遍历 iterable 中的值。'
- en: '`repeat(elem`[, n]) repeats an element n times.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`repeat(elem`[, n]) 重复元素 elem，重复 n 次。'
- en: '`dropwhile(predicate`, iterable) filters elements of an iterable starting from
    the beginning until predicate is `False`.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dropwhile(predicate`, iterable) 从开始筛选可迭代对象的元素，直到谓词为 `False`。'
- en: '`groupby(iterable`, keyfunc) creates an iterator that groups items by the result
    returned by the `keyfunc()` function.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`groupby(iterable`, keyfunc) 创建一个迭代器，根据 `keyfunc()` 函数返回的结果对项目进行分组。'
- en: '`permutations(iterable`[, r]) returns successive r-length permutations of the
    items in iterable.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`permutations(iterable`[, r]) 返回 iterable 中项目的连续 r 长度排列。'
- en: '`product(*iterables`) returns an iterable of the Cartesian product of iterables
    without using a nested `for` loop.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`product(*iterables`) 返回一个可迭代对象，包含多个可迭代对象的笛卡尔积，而不需要使用嵌套的 `for` 循环。'
- en: '`takewhile(predicate`, iterable) returns elements of an iterable starting from
    the beginning until predicate is `False`.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`takewhile(predicate`, iterable) 从开始返回可迭代对象的元素，直到谓词为 `False`。'
- en: 'These functions are particularly useful in conjunction with the `operator`
    module. When used together, `itertools` and `operator` can handle most situations
    that programmers typically rely on `lambda` for. Here’s an example of using `operator.itemgetter()`
    instead of writing `lambda x: x[''foo'']`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '这些函数在与 `operator` 模块结合使用时特别有用。将 `itertools` 和 `operator` 一起使用，可以处理大多数程序员通常依赖
    `lambda` 的情况。以下是一个示例，展示了如何使用 `operator.itemgetter()` 来代替编写 `lambda x: x[''foo'']`：'
- en: '[PRE35]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In this case, we could have also written `lambda x: x[''foo'']`, but using
    `operator` lets us avoid having to use `lambda` at all.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '在这种情况下，我们也可以写作 `lambda x: x[''foo'']`，但是使用 `operator` 可以避免完全使用 `lambda`。'
- en: '**Summary**'
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: While Python is often advertised as being object oriented, it can be used in
    a very functional manner. A lot of its built-in concepts, such as generators and
    list comprehension, are functionally oriented and don’t conflict with an object-oriented
    approach. They also limit the reliance on a program’s global state, for your own
    good.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Python 通常被宣传为面向对象的语言，但它也可以以非常函数化的方式使用。它的许多内建概念，如生成器和列表推导式，都是函数式的，并且与面向对象的方法不冲突。它们还减少了对程序全局状态的依赖，这对你来说是有益的。
- en: Using functional programming as a paradigm in Python can help you make your
    program more reusable and easier to test and debug, supporting the Don’t Repeat
    Yourself (DRY) mantra. In this spirit, the standard Python modules `itertools`
    and `operator` are good tools to improve the readability of your functional code.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 使用函数式编程范式在 Python 中可以帮助你让程序更具可重用性，更容易测试和调试，支持“不要重复自己”（DRY）原则。在这个精神下，标准 Python
    模块 `itertools` 和 `operator` 是改善函数式代码可读性的好工具。
