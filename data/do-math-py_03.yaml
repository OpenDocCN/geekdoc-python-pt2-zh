- en: '**3**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**3**'
- en: '**Describing Data with Statistics**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**用统计学描述数据**'
- en: '![image](images/common-01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/common-01.jpg)'
- en: In this chapter, we’ll use Python to explore statistics so we can study, describe,
    and better understand sets of data. After looking at some basic statistical measures—the
    mean, median, mode, and range—we’ll move on to some more advanced measures, such
    as variance and standard deviation. Then, we’ll see how to calculate the correlation
    coefficient, which allows you to quantify the relationship between two sets of
    data. We’ll end the chapter by learning about scatter plots. Along the way, we’ll
    learn more about the Python language and standard library modules. Let’s get started
    with one of the most commonly used statistical measures—the mean.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用 Python 来探索统计学，以便研究、描述和更好地理解数据集。在介绍一些基本的统计量——均值、中位数、众数和极差之后，我们将进入一些更高级的统计量，如方差和标准差。然后，我们将学习如何计算相关系数，这使得你可以量化两组数据之间的关系。最后，我们将学习如何绘制散点图。在这个过程中，我们还将更多地了解
    Python 语言和标准库模块。让我们从最常用的统计量——均值开始吧。
- en: '**NOTE**'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In statistics, some statistical measures are calculated slightly differently
    depending on whether you have data for an entire population or just a sample.
    To keep things simple, we’ll stick with the calculation methods for a population
    in this chapter.*'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*在统计学中，一些统计量的计算方法会根据你是拥有整个总体的数据还是仅有样本数据而有所不同。为了简化起见，本章我们将使用总体的计算方法。*'
- en: '**Finding the Mean**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**计算均值**'
- en: The *mean* is a common and intuitive way to summarize a set of numbers. It’s
    what we might simply call the “average” in everyday use, although as we’ll see,
    there are other kinds of averages as well. Let’s take a sample set of numbers
    and calculate the mean.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*均值* 是一种常见且直观的方式，用来总结一组数字。它通常被我们称为“平均数”，尽管正如我们所见，还有其他类型的平均数。让我们取一个样本数据集并计算均值。'
- en: 'Say there’s a school charity that’s been taking donations over a period of
    time spanning the last 12 days (we’ll refer to this as period A). In that time,
    the following 12 numbers represent the total dollar amount of donations received
    for each day: 100, 60, 70, 900, 100, 200, 500, 500, 503, 600, 1000, and 1200\.
    We can calculate the mean by summing these totals and then dividing the sum by
    the number of days. In this case, the sum of the numbers is 5733\. If we divide
    this number by 12 (the number of days), we get 477.75, which is the *mean* donation
    per day. This number gives us a general idea of how much money was donated on
    any given day.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一个学校慈善机构，它在过去的12天里（我们称之为周期A）接受了捐款。在这段时间里，以下12个数字表示每天收到的捐款总额：100、60、70、900、100、200、500、500、503、600、1000
    和 1200。我们可以通过将这些总额相加，然后将总和除以天数来计算均值。在这个例子中，数字的总和是5733。如果我们将这个数字除以12（天数），我们得到477.75，这就是每一天的*均值*捐款。这个数字给了我们一个大致的了解，即每一天捐赠的金额。
- en: 'In a moment, we’ll write a program that calculates and prints the mean for
    a collection of numbers. As we just saw, to calculate the mean, we’ll need to
    take the sum of the list of numbers and divide it by the number of items in the
    list. Let’s look at two Python functions that make both of these operations very
    easy: `sum()` and `len()`.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后，我们将编写一个程序来计算并打印一组数字的均值。正如我们刚才看到的，计算均值时，我们需要先求出数字列表的总和，然后再将总和除以列表中的项数。我们来看看两个非常简单的
    Python 函数：`sum()` 和 `len()`，它们使这两个操作变得非常简单。
- en: 'When you use the `sum()` function on a list of numbers, it adds up all the
    numbers in the list and returns the result:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当你对一组数字使用`sum()`函数时，它会将列表中的所有数字加起来并返回结果：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can use the `len()` function to give us the length of a list:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`len()`函数来获取列表的长度：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When we use the `len()` function on the list, it returns `3` because there are
    three items in `shortlist`. Now we’re ready to write a program that will calculate
    the mean of the list of donations.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们对列表使用`len()`函数时，它返回`3`，因为`shortlist`中有三个项。现在我们可以编写一个程序来计算捐款列表的均值了。
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: First, we define a function, `calculate_mean()`, that accepts the argument `numbers`,
    which is a list of numbers. At ➊, we use the `sum()` function to add up the numbers
    in the list and create a label, `s`, to refer to the total. Similarly, at ➋, we
    use the `len()` function to get the length of the list and create a label, `N`,
    to refer to it. Then, as you can see at ➌, we calculate the mean by simply dividing
    the sum (`s`) by the number of members (`N`). At ➍, we create a list, `donations`,
    with the values of the donations listed earlier. We then call the `calculate_mean()`
    function, passing this list as an argument at ➎. Finally, we print the mean that
    was calculated at ➏.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义一个函数`calculate_mean()`，它接受参数`numbers`，这是一个数字列表。在➊处，我们使用`sum()`函数将列表中的数字相加，并创建一个标签`s`来表示总和。同样，在➋处，我们使用`len()`函数获取列表的长度，并创建一个标签`N`来表示它。然后，正如你在➌处看到的，我们通过将总和（`s`）除以元素个数（`N`）来计算均值。在➍处，我们创建一个列表`donations`，其中包含之前列出的捐赠值。然后，我们调用`calculate_mean()`函数，在➎处将此列表作为参数传递给它。最后，在➏处我们打印出计算出的均值。
- en: 'When you run the program, you should see the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行程序时，你应该看到如下内容：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `calculate_mean()` function will calculate the sum and length of *any* list,
    so we can reuse it to calculate the mean for other sets of numbers, too.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`calculate_mean()`函数将计算*任何*列表的总和和长度，因此我们也可以重复使用它来计算其他数字集合的均值。'
- en: We calculated that the mean donation per day was 477.75\. It’s worth noting
    that the donations during the first few days were much lower than the mean donation
    we calculated and that the donations during the last couple of days were much
    higher. The mean gives us one way to summarize the data, but it doesn’t give us
    a full picture. There are other statistical measurements, however, that can tell
    us more about the data when compared with the mean.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们计算得出每日均捐赠额为477.75。值得注意的是，前几天的捐赠额远低于我们计算的均值，而最后几天的捐赠额则远高于均值。均值为我们提供了一种总结数据的方式，但它并没有提供完整的图景。然而，其他统计量可以在与均值比较时，给我们更多有关数据的信息。
- en: '**Finding the Median**'
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**查找中位数**'
- en: 'The *median* of a collection of numbers is another kind of average. To find
    the median, we sort the numbers in ascending order. If the length of the list
    of numbers is odd, the number in the middle of the list is the median. If the
    length of the list of numbers is even, we get the median by taking the mean of
    the two middle numbers. Let’s find the median of the previous list of donations:
    100, 60, 70, 900, 100, 200, 500, 500, 503, 600, 1000, and 1200.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 数字集合的*中位数*是另一种平均值。为了找到中位数，我们将数字按升序排列。如果数字列表的长度是奇数，则列表中间的数字就是中位数。如果数字列表的长度是偶数，我们通过取中间两个数字的均值来得到中位数。让我们找出之前捐赠列表的中位数：100,
    60, 70, 900, 100, 200, 500, 500, 503, 600, 1000 和 1200。
- en: After sorting from smallest to largest, the list of numbers becomes 60, 70,
    100, 100, 200, 500, 500, 503, 600, 900, 1000, and 1200\. We have an even number
    of items in the list (12), so to get the median, we need to take the mean of the
    two middle numbers. In this case, the middle numbers are the sixth and the seventh
    numbers—500 and 500—and the mean of these two numbers is (500 + 500)/2, which
    comes out to 500\. That means the median is 500.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 按照从小到大的顺序排序后，数字列表变为60, 70, 100, 100, 200, 500, 500, 503, 600, 900, 1000 和 1200。我们有一个偶数个数的项目（12个），因此为了得到中位数，我们需要取中间两个数字的均值。在这个例子中，中间两个数字是第六个和第七个数字——500和500——这两个数字的均值是(500
    + 500)/2，结果是500。这意味着中位数是500。
- en: 'Now assume—just for this example—that we have another donation total for the
    13th day so that the list now looks like this: 100, 60, 70, 900, 100, 200, 500,
    500, 503, 600, 1000, 1200, and 800.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设——仅仅是为了这个示例——我们在第13天有了另一个捐赠总额，因此列表现在看起来像这样：100, 60, 70, 900, 100, 200, 500,
    500, 503, 600, 1000, 1200 和 800。
- en: Once again, we have to sort the list, which becomes 60, 70, 100, 100, 200, 500,
    500, 503, 600, 800, 900, 1000, and 1200\. There are 13 numbers in this list (an
    odd number), so the median for this list is simply the middle number. In this
    case, that’s the seventh number, which is 500.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们需要对列表进行排序，排序后的列表为60, 70, 100, 100, 200, 500, 500, 503, 600, 800, 900, 1000
    和 1200。这个列表中有13个数字（奇数个），因此这个列表的中位数就是中间的数字。在这个例子中，它是第七个数字，即500。
- en: Before we write a program to find the median of a list of numbers, let’s think
    about how we could automatically calculate the middle elements of a list in either
    case. If the length of a list (*N*) is odd, the middle number is the one in position
    (*N* + 1)/2\. If *N* is even, the two middle elements are *N*/2 and (*N*/2) +
    1\. For our first example in this section, *N* = 12, so the two middle elements
    were the 12/2 (sixth) and 12/2 + 1 (seventh) elements. In the second example,
    *N* = 13, so the seventh element, (*N* + 1)/2, was the middle element.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写程序以查找数字列表的中位数之前，让我们思考如何自动计算列表中的中间元素。如果列表的长度（*N*）是奇数，则中间数字位于位置（*N* + 1）/2。如果*N*是偶数，则两个中间元素位于*N*/2和(*N*/2)
    + 1的位置。在本节的第一个示例中，*N* = 12，所以两个中间元素是12/2（第六个）和12/2 + 1（第七个）元素。在第二个示例中，*N* = 13，所以第七个元素（(*N*
    + 1)/2）是中间元素。
- en: 'In order to write a function that calculates the median, we’ll also need to
    sort a list in ascending order. Luckily, the `sort()` method does just that:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写一个计算中位数的函数，我们还需要将列表按升序排序。幸运的是，`sort()`方法正好可以实现这一点：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now we can write our next program, which finds the median of a list of numbers:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以编写下一个程序，它可以查找数字列表的中位数：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The overall structure of the program is similar to that of the earlier program
    that calculates the mean. The `calculate_median()` function accepts a list of
    numbers and returns the median. At ➊, we calculate the length of the list and
    create a label, `N`, to refer to it. Next, at ➋, we sort the list using the `sort()`
    method.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的整体结构类似于前面计算均值的程序。`calculate_median()`函数接受一个数字列表并返回中位数。在➊处，我们计算列表的长度并创建一个标签`N`来引用它。接下来，在➋处，我们使用`sort()`方法对列表进行排序。
- en: 'Then, we check to see whether `N` is even. If so, we find the middle elements,
    `m1` and `m2`, which are the numbers at positions `N/2` and `(N/2) + 1` in the
    sorted list. The next two statements (➌ and ➍) adjust `m1` and `m2` in two ways.
    First, we use the `int()` function to convert `m1` and `m2` into integer form.
    This is because results of the division operator are always returned as floating
    point numbers, even when the result is equivalent to an integer. For example:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们检查`N`是否为偶数。如果是，我们找到中间的两个元素，`m1`和`m2`，它们分别是排序后列表中位置为`N/2`和`(N/2) + 1`的数字。接下来的两个语句（➌和➍）以两种方式调整`m1`和`m2`。首先，我们使用`int()`函数将`m1`和`m2`转换为整数。这是因为除法运算符的结果总是以浮动点数返回，即使结果相当于整数。例如：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We cannot use a floating point number as an index in a list, so we use `int()`
    to convert that result to an integer. We also subtract 1 from both `m1` and `m2`
    because positions in a list begin with 0 in Python. This means that to get the
    sixth and seventh numbers from the list, we have to ask for the numbers at index
    5 and index 6\. At ➎, we calculate the median by taking the mean of the two numbers
    in the middle positions.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能使用浮动点数作为列表的索引，所以我们使用`int()`将该结果转换为整数。我们还从`m1`和`m2`中各减去1，因为Python中的列表位置是从0开始的。这意味着要从列表中获取第六和第七个数字，我们必须请求索引为5和6的数字。在➎处，我们通过计算中间两个位置的数字的平均值来得到中位数。
- en: 'Starting at ➏, the program finds the median if there’s an odd number of items
    in the list, once again using `int()` and subtracting 1 to find the proper index.
    Finally, the program calculates the median for the list of donations and returns
    it. When you execute the program, it calculates that the median is 500:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 从➏开始，程序在列表中有奇数项时找到中位数，再次使用`int()`并减去1来找到正确的索引。最后，程序计算捐赠列表的中位数并返回结果。当你执行程序时，它计算出中位数是500：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see, the mean (477.75) and the median (500) are pretty close in this
    particular list, but the median is a little higher.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，均值（477.75）和中位数（500）在这个特定的列表中相当接近，但中位数稍微高一些。
- en: '**Finding the Mode and Creating a Frequency Table**'
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**查找众数并创建频率表**'
- en: 'Instead of finding the mean value or the median value of a set of numbers,
    what if you wanted to find the number that occurs most frequently? This number
    is called the *mode*. For example, consider the test scores of a math test (out
    of 10 points) in a class of 20 students: 7, 8, 9, 2, 10, 9, 9, 9, 9, 4, 5, 6,
    1, 5, 6, 7, 8, 6, 1, and 10\. The mode of this list would tell you which score
    was the most common in the class. From the list, you can see that the score of
    9 occurs most frequently, so 9 is the mode for this list of numbers. There’s no
    symbolic formula for calculating the mode—you simply count how many times each
    unique number occurs and find the one that occurs the most.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 与其找出一组数字的平均值或中位数值，不如问问哪个数字最常出现？这个数字叫做*众数*。例如，考虑一场数学考试的分数（满分10分），20个学生的成绩分别为：7、8、9、2、10、9、9、9、9、4、5、6、1、5、6、7、8、6、1和10。这个列表的众数告诉我们哪个分数在班级中最常见。从列表中可以看到，分数9出现的次数最多，所以9是这个数字列表的众数。计算众数没有符号公式——你只需要统计每个独特数字出现的次数，并找出出现最多的那个。
- en: To write a program to calculate the mode, we’ll need to have Python count how
    many times each number occurs within a list and print the one that occurs most
    frequently. The `Counter` class from the `collections` module, which is part of
    the standard library, makes this really simple for us.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写一个程序来计算众数，我们需要让Python计算每个数字在列表中出现的次数，并打印出出现次数最多的那个数字。`collections`模块中的`Counter`类，作为标准库的一部分，使这一操作变得非常简单。
- en: '***Finding the Most Common Elements***'
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***查找最常见的元素***'
- en: 'Finding the most common number in a data set can be thought of as a subproblem
    of finding an arbitrary number of most common numbers. For instance, instead of
    the most common score, what if you wanted to know the five most common scores?
    The `most_common()` method of the `Counter` class allows us to answer such questions
    easily. Let’s see an example:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据集中找出最常见的数字，可以看作是找出若干个最常见数字的子问题。例如，除了找出最常见的分数之外，如果你想知道最常见的五个分数呢？`Counter`类的`most_common()`方法让我们轻松回答这些问题。让我们看一个例子：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, we start off with a list of five numbers and import `Counter` from the
    collections module. Then, we create a `Counter` object, using `c` to refer to
    the object. We then call the `most_common()` method, which returns a list ordered
    by the most common elements.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们从五个数字的列表开始，并从`collections`模块导入`Counter`。然后，我们创建一个`Counter`对象，用`c`来引用这个对象。接着，我们调用`most_common()`方法，它返回一个按照最常见元素排序的列表。
- en: Each member of the list is a tuple. The first element of the first tuple is
    the number that occurs most frequently, and the second element is the number of
    times it occurs. The second, third, and fourth tuples contain the other numbers
    along with the count of the number of times they appear. This result tells us
    that 4 occurs the most (twice), while the others appear only once. Note that numbers
    that occur an equal number of times are returned by the `most_common()` method
    in an arbitrary order.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的每个成员都是一个元组。第一个元组的第一个元素是出现频率最高的数字，第二个元素是它出现的次数。第二、第三和第四个元组包含其他数字及其出现次数。这个结果告诉我们，4是出现次数最多的（出现两次），而其他数字仅出现一次。请注意，`most_common()`方法返回的数字顺序是随机的，若多个数字出现相同次数。
- en: 'When you call the `most_common()` method, you can also provide an argument
    telling it the number of most common elements you want it to return. For example,
    if we just wanted to find the most common element, we would call it with the argument
    `1`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用`most_common()`方法时，你还可以提供一个参数，告诉它你希望返回最常见元素的数量。例如，如果我们只想找到最常见的元素，可以使用参数`1`来调用：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If you call the method again with `2` as an argument, you’ll see this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再次调用该方法，并将`2`作为参数，你将看到以下结果：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now the result returned by the `most_common` method is a list with two tuples.
    The first is the most common element, followed by the second most common. Of course,
    in this case, there are several elements tied for most common, so the fact that
    the function returns 1 here (and not 2 or 3) is arbitrary, as noted earlier.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`most_common`方法返回的结果是一个包含两个元组的列表，第一个是最常见的元素，第二个是次常见的元素。当然，在这种情况下，有几个元素的出现次数并列为最多，因此，函数返回1（而不是2或3）是随机的，正如之前所提到的。
- en: 'The `most_common()` method returns both the numbers and the number of times
    they occur. What if we want only the numbers and we don’t care about the number
    of times they occur? Here’s how we can retrieve that information:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`most_common()`方法返回的既有数字，也有它们出现的次数。如果我们只想要数字，而不关心它们出现的次数，应该如何获取这个信息呢？你可以这样来获取：'
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: At ➊, we use the label `mode` to refer to the result returned by the `most_common()`
    method. We retrieve the first (and the only) element of this list with `mode[0]`
    ➋, which gives us a tuple. Because we just want the first element of the tuple,
    we can retrieve that using `mode[0][0]` ➌. This returns 4— the most common element,
    or the mode.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊，我们使用标签`mode`来表示`most_common()`方法返回的结果。我们通过`mode[0]` ➋获取该列表的第一个（也是唯一的）元素，这会返回一个元组。因为我们只需要元组的第一个元素，所以可以通过`mode[0][0]`
    ➌来获取。这会返回4——最常见的元素，即众数。
- en: Now that we know how the `most_common()` method works, we’ll apply it to solve
    the next two problems.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了`most_common()`方法的工作原理，我们将应用它来解决接下来的两个问题。
- en: '***Finding the Mode***'
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***寻找众数***'
- en: 'We’re ready to write a program that finds the mode for a list of numbers:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好编写一个程序来找出数字列表的众数：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `calculate_mode()` function finds and returns the mode of the numbers passed
    to it as a parameter. To calculate the mode, we first import the class `Counter`
    from the `collections` module and use it to create a `Counter` object at ➊. Then,
    at ➋, we use the `most_common()` method, which, as we saw earlier, gives us a
    list that contains a tuple with the most common number and the number of times
    it occurs. We assign that list the label `mode`. Finally, we use `mode[0][0]`
    ➌ to access the number we want: the most frequent number from the list, which
    is the mode.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`calculate_mode()`函数找到并返回作为参数传入的数字的众数。为了计算众数，我们首先从`collections`模块导入`Counter`类，并在
    ➊ 使用它来创建一个`Counter`对象。然后，在 ➋ 我们使用`most_common()`方法，正如之前所看到的，它会返回一个包含最常见数字及其出现次数的元组的列表。我们将该列表命名为`mode`。最后，我们使用`mode[0][0]`
    ➌来访问我们想要的数字：列表中最频繁的数字，即众数。'
- en: 'The rest of the program applies the `calculate_mode` function to the list of
    test scores we saw earlier. When you run the program, you should see the following
    output:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的其余部分应用了`calculate_mode`函数来处理我们之前看到的测试分数列表。当你运行程序时，应该会看到以下输出：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'What if you have a set of data where two or more numbers occur the same maximum
    number of times? For example, in the list of numbers 5, 5, 5, 4, 4, 4, 9, 1, and
    3, both 4 and 5 are present three times. In such cases, the list of numbers is
    said to have multiple modes, and our program should find and print all the modes.
    The modified program follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一组数据，其中两个或更多的数字出现的次数相同且为最大次数怎么办？例如，在数字列表 5、5、5、4、4、4、9、1 和 3 中，4和5都出现了三次。在这种情况下，数字列表被认为有多个众数，我们的程序应当找到并打印所有的众数。修改后的程序如下：
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: At ➊, instead of finding only the most common element, we retrieve all the numbers
    and the number of times each appears. Next, at ➋, we find the value of the maximum
    count—that is, the maximum number of times any number occurs. Then, for each of
    the numbers, we check whether the number of times it appears is equal to the maximum
    count ➌. Each number that fulfills this condition is a mode, and we add it to
    the list `modes` and return the list.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊，我们不仅仅找出最常见的元素，而是获取所有的数字以及每个数字出现的次数。接下来，在 ➋，我们找到最大计数的值——即任何数字出现的最大次数。然后，对于每个数字，我们检查它出现的次数是否等于最大计数
    ➌。每个满足此条件的数字都是众数，我们将它们添加到`modes`列表中并返回该列表。
- en: At ➍, we iterate over the list returned from the `calculate_mode()` function
    and print each of the numbers.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➍，我们遍历`calculate_mode()`函数返回的列表，并打印每个数字。
- en: 'When you execute the preceding program, you should see the following output:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当你执行前面的程序时，应该会看到以下输出：
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: What if you wanted to find the number of times every number occurs instead of
    just the mode? A *frequency table*, as the name indicates, is a table that shows
    how many times each number occurs within a collection of numbers.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想找出每个数字出现的次数，而不仅仅是众数怎么办？*频率表*，顾名思义，是一张表格，显示了每个数字在数字集合中出现的次数。
- en: '***Creating a Frequency Table***'
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***创建频率表***'
- en: 'Let’s consider the list of test scores again: 7, 8, 9, 2, 10, 9, 9, 9, 9, 4,
    5, 6, 1, 5, 6, 7, 8, 6, 1, and 10\. The frequency table for this list is shown
    in [Table 3-1](ch03.html#ch3tab1). For each number, we list the number of times
    it occurs in the second column.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再考虑一下测试分数列表：7、8、9、2、10、9、9、9、9、4、5、6、1、5、6、7、8、6、1和10。该列表的频率表如下所示：[表 3-1](ch03.html#ch3tab1)。对于每个数字，我们在第二列列出它出现的次数。
- en: '**Table 3-1:** Frequency Table'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 3-1：** 频率表'
- en: '| **Score** | **Frequency** |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| **分数** | **频率** |'
- en: '| --- | --- |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 1 | 2 |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 2 |'
- en: '| 2 | 1 |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 1 |'
- en: '| 4 | 1 |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 1 |'
- en: '| 5 | 2 |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 2 |'
- en: '| 6 | 3 |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 3 |'
- en: '| 7 | 2 |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 2 |'
- en: '| 8 | 2 |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 2 |'
- en: '| 9 | 5 |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 9 | 5 |'
- en: '| 10 | 2 |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 2 |'
- en: Note that the sum of the individual frequencies in the second column adds up
    to the total number of scores (in this case, 20).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，第二列中各个频率的总和等于所有分数的总数（在本例中为20）。
- en: We’ll use the `most_common()` method once again to print the frequency table
    for a given set of numbers. Recall that when we don’t supply an argument to the
    `most_common()` method, it returns a list of tuples with all the numbers and the
    number of times they appear. We can simply print each number and its frequency
    from this list to display a frequency table.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次使用`most_common()`方法打印给定数字集合的频率表。回顾一下，当我们不向`most_common()`方法提供参数时，它会返回一个包含所有数字及其出现次数的元组列表。我们可以直接打印每个数字及其频率，从而显示频率表。
- en: 'Here’s the program:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这是程序：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The function `frequency_table()` prints the frequency table of the list of
    numbers passed to it. At ➊, we first create a `Counter` object and create the
    label `table` to refer to it. Next, using a `for` loop ➋, we go through each of
    the tuples, printing the first member (the number itself) and the second member
    (the frequency of the corresponding number). We use `\t` to print a tab between
    each value to space the table. When you run the program, you’ll see the following
    output:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`frequency_table()`打印传递给它的数字列表的频率表。在➊处，我们首先创建一个`Counter`对象，并为其创建标签`table`。接下来，在使用`for`循环➋遍历每个元组时，打印第一个元素（数字本身）和第二个元素（该数字的频率）。我们使用`\t`来在每个值之间打印制表符，以便表格对齐。当你运行程序时，你将看到以下输出：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, you can see that the numbers are listed in decreasing order of frequency
    because the `most_common()` function returns the numbers in this order. If, instead,
    you want your program to print the frequency table sorted by value from lowest
    to highest, as shown in [Table 3-1](ch03.html#ch3tab1), you’ll have to re-sort
    the list of tuples.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到数字按频率从高到低的顺序列出，因为`most_common()`函数会以这种顺序返回数字。如果你希望程序打印一个按值从低到高排序的频率表，如[表3-1](ch03.html#ch3tab1)所示，你需要重新排序元组列表。
- en: 'The `sort()` method is all we need to modify our earlier frequency table program:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort()`方法是我们修改早期频率表程序所需的全部：'
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here, we store the list returned by the `most_common()` method in `numbers_freq`
    at ➊, and then we sort it by calling the `sort()` method ➋. Finally, we use the
    `for` loop to go over the sorted tuples and print each number and its frequency
    ➌. Now when you run the program, you’ll see the following table, which is identical
    to [Table 3-1](ch03.html#ch3tab1):'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在➊处将`most_common()`方法返回的列表存储在`numbers_freq`中，然后通过调用`sort()`方法在➋处对其进行排序。最后，我们使用`for`循环遍历排序后的元组，打印每个数字及其频率➌。现在，当你运行程序时，你会看到以下表格，它与[表3-1](ch03.html#ch3tab1)完全相同：
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this section, we’ve covered mean, median, and mode, which are three common
    measures for describing a list of numbers. Each of these can be useful, but they
    can also hide other aspects of the data when considered in isolation. Next, we’ll
    look at other, more advanced statistical measures that can help us draw more conclusions
    about a collection of numbers.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已经讨论了均值、中位数和众数，它们是描述一组数字的三种常见度量方法。每个度量方法都有其用处，但在单独考虑时也可能掩盖数据的其他方面。接下来，我们将探讨其他更高级的统计度量方法，它们可以帮助我们对一组数字做出更多的结论。
- en: '**Measuring the Dispersion**'
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**衡量离散程度**'
- en: 'The next statistical calculations we’ll look at measure the *dispersion*, which
    tells us how far away the numbers in a set of data are from the mean of the data
    set. We’ll learn to calculate three different measurements of dispersion: range,
    variance, and standard deviation.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们要看的统计计算是衡量*离散程度*，它告诉我们一组数据中数字与数据集均值的偏差程度。我们将学习计算三种不同的离散程度度量：极差、方差和标准差。
- en: '***Finding the Range of a Set of Numbers***'
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***计算一组数字的极差***'
- en: 'Once again, consider the list of donations during period A: 100, 60, 70, 900,
    100, 200, 500, 500, 503, 600, 1000, and 1200\. We found that the mean donation
    per day is 477.75\. But just looking at the mean, we have no idea whether all
    the donations fell into a narrow range—say between 400 and 500—or whether they
    varied much more than that—say between 60 and 1200, as in this case. For a list
    of numbers, the *range* is the difference between the highest number and the lowest
    number. You could have two groups of numbers with the exact same mean but with
    vastly different ranges, so knowing the range fills in more information about
    a set of numbers beyond what we can learn from just looking at the mean, median,
    and mode.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 再次考虑期间 A 的捐款列表：100、60、70、900、100、200、500、500、503、600、1000 和 1200。我们发现每日捐款的均值为
    477.75。但仅仅看均值，我们无法知道所有捐款是否都落在一个狭窄的范围内——例如在 400 和 500 之间，还是它们的差异比这大得多——比如在 60 和
    1200 之间，就像这个例子一样。对于一组数字，*范围*是最高值和最低值之间的差异。你可以有两个均值完全相同的数字组，但它们的范围却差异巨大，所以了解范围能为我们提供关于一组数字的更多信息，超越了仅仅通过均值、中位数和众数所能获得的信息。
- en: 'The next program finds the range of the preceding list of donations:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个程序查找前面提到的捐款列表的范围：
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The function `find_range()` accepts a list as a parameter and finds the range.
    First, it calculates the lowest and the highest numbers using the `min()` and
    the `max()` functions at ➊ and ➋. As the function names indicate, they find the
    minimum and the maximum values in a list of numbers.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`find_range()`函数接受一个列表作为参数并找到范围。首先，它在 ➊ 和 ➋ 使用`min()`和`max()`函数来计算最低值和最高值。正如函数名所示，它们分别用于找到列表中数字的最小值和最大值。'
- en: 'We then calculate the range by taking the difference between the highest and
    the lowest numbers, using the label `r` to refer to this difference. At ➌, we
    return all three numbers—the lowest number, the highest number, and the range.
    This is the first time in the book that we’re returning multiple values from a
    function—instead of just returning one value, this function returns three. At
    ➍, we use three labels to *receive* the three values being returned from the `find_range()`
    function. Finally, we print the values. When you run the program, you should see
    the following output:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过计算最高值和最低值之间的差异来计算范围，用标签`r`表示这个差异。在 ➌ 处，我们返回三个数字——最低值、最高值和范围。这是书中第一次从函数返回多个值——不是只返回一个值，而是返回三个值。在
    ➍ 处，我们使用三个标签来*接收*从`find_range()`函数返回的三个值。最后，我们打印这些值。当你运行程序时，应该会看到以下输出：
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This tells us that the days’ total donations were fairly spread out, with a
    range of 1140, because we had daily totals as small as 60 and as large as 1200.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们，捐款的总额相对分散，范围为 1140，因为我们的日捐款总额从 60 到 1200 不等。
- en: '***Finding the Variance and Standard Deviation***'
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***方差和标准差的计算***'
- en: 'The range tells us the difference between the two extremes in a set of numbers,
    but what if we want to know more about how all of the individual numbers vary
    from the mean? Were they all similar, clustered near the mean, or were they all
    different, closer to the extremes? There are two related measures of dispersion
    that tell us more about a list of numbers along these lines: the *variance* and
    the *standard deviation*. To calculate either of these, we first need to find
    the difference of each of the numbers from the mean. The variance is the average
    of the squares of those differences. A high variance means that values are far
    from the mean; a low variance means that the values are clustered close to the
    mean. We calculate the variance using the formula'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 范围告诉我们一组数字中两个极端值之间的差异，但如果我们想了解所有单独的数字与平均值的差异呢？它们是都相似，接近均值，还是差异很大，接近极端值？有两个相关的离散度度量可以告诉我们更多关于数字列表的变化情况：*方差*和*标准差*。要计算这两者中的任何一个，我们首先需要找到每个数字与平均值的差异。方差是这些差异的平方的平均值。高方差意味着值远离均值；低方差意味着值聚集在均值附近。我们使用以下公式来计算方差：
- en: '![image](images/e0073-01.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/e0073-01.jpg)'
- en: In the formula, *x[i]* stands for individual numbers (in this case, daily total
    donations), *x*[mean] stands for the mean of these numbers (the mean daily donation),
    and *n* is the number of values in the list (the number of days on which donations
    were received). For each value in the list, we take the difference between that
    number and the mean and square it. Then, we add all those squared differences
    together and, finally, divide the whole sum by *n* to find the variance.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个公式中，*x[i]* 代表单个数字（在这里是每日总捐款），*x*[mean] 代表这些数字的均值（即每日捐款的均值），*n* 是列表中数值的数量（即接收捐款的天数）。对于列表中的每个值，我们计算该数值与均值之间的差异并进行平方。然后，我们将所有这些平方差异相加，最后除以
    *n* 来得到方差。
- en: If we want to calculate the standard deviation as well, all we have to do is
    take the square root of the variance. Values that are within one standard deviation
    of the mean can be thought of as fairly typical, whereas values that are three
    or more standard deviations away from the mean can be considered much more atypical—we
    call such values *outliers*.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们还想计算标准差，只需对方差取平方根即可。值与均值相差一个标准差以内的可以被认为是比较典型的，而与均值相差三倍或更多标准差的值则可以认为是非常不典型的——我们称这样的值为
    *离群值*。
- en: Why do we have these two measures of dispersion—variance and standard deviation?
    In short, the two measures are useful in different situations. Going back to the
    formula we used to calculate the variance, you can see that the variance is expressed
    in square units because it’s the average of the squared difference from the mean.
    For some mathematical formulas, it’s nicer to work with those square units instead
    of taking the square root to find the standard deviation. On the other hand, the
    standard deviation is expressed in the same units as the population data. For
    example, if you calculate the variance for our list of donations (as we will in
    a moment), the result is expressed in dollars squared, which doesn’t make a lot
    of sense. Meanwhile, the standard deviation is simply expressed in dollars, the
    same unit as each of the donations.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们有这两种离散度的度量——方差和标准差？简而言之，这两种度量在不同情况下有不同的用途。回到我们用来计算方差的公式，你可以看到，方差以平方单位表示，因为它是平均偏差的平方。对于某些数学公式，使用这些平方单位更方便，而不是通过求平方根来计算标准差。另一方面，标准差与数据的单位相同。例如，如果你计算我们的捐款列表的方差（稍后我们将这样做），结果会以“美元平方”表示，这没有太大意义。与此同时，标准差则简单地以“美元”表示，这是每笔捐款的单位。
- en: 'The following program finds the variance and standard deviation for a list
    of numbers:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序用于计算一个数字列表的方差和标准差：
- en: '[PRE22]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The function `calculate_variance()` calculates the variance of the list of numbers
    passed to it. First, it calls the `find_differences()` function at ➊ to calculate
    the difference of each of the numbers from the mean. The `find_differences()`
    function returns the difference of each donation from the mean value as a list.
    In this function, we use the `calculate_mean()` function we wrote earlier to find
    the mean donation. Then, starting at ➋, the squares of these differences are calculated
    and saved in a list labeled `squared_diff`. Next, we use the `sum()` function
    to find the sum of the squared differences and, finally, calculate the variance
    at ➌. At ➍, we calculate the standard deviation by taking the square root of the
    variance.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `calculate_variance()` 计算传递给它的数字列表的方差。首先，它调用 `find_differences()` 函数在 ➊ 处计算每个数字与均值的差异。`find_differences()`
    函数返回每笔捐款与均值的差异，并将结果作为一个列表返回。在这个函数中，我们使用之前编写的 `calculate_mean()` 函数来计算均值捐款。然后，从
    ➋ 开始，计算这些差异的平方并将其保存在标记为 `squared_diff` 的列表中。接下来，我们使用 `sum()` 函数来计算这些平方差异的总和，最后在
    ➌ 处计算方差。在 ➍ 处，我们通过对方差取平方根来计算标准差。
- en: 'When you run the preceding program, you should see the following output:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行前面的程序时，你应该会看到以下输出：
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The variance and the standard deviation are both very large, meaning that the
    individual daily total donations vary greatly from the mean. Now, let’s compare
    the variance and the standard deviation for a different set of donations that
    have the same mean: 382, 389, 377, 397, 396, 368, 369, 392, 398, 367, 393, and
    396\. In this case, the variance and the standard deviation turn out to be 135.38888888888889
    and 11.63567311713804, respectively. Lower values for variance and standard deviation
    tell us that the individual numbers are closer to the mean. [Figure 3-1](ch03.html#ch3fig1)
    illustrates this point visually.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 方差和标准差都非常大，这意味着单个每日捐款总额与平均值差异很大。现在，让我们比较另一组捐款的方差和标准差，这组捐款的平均值相同：382、389、377、397、396、368、369、392、398、367、393
    和 396。在这种情况下，方差和标准差分别为 135.38888888888889 和 11.63567311713804。较低的方差和标准差值表明个别数据点更接近平均值。[图
    3-1](ch03.html#ch3fig1) 形象地展示了这一点。
- en: '![image](images/f03-01.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f03-01.jpg)'
- en: '*Figure 3-1: Variation of the donations around the average donation*'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-1：捐款围绕平均捐款的变化*'
- en: The mean donations for both lists of donations are similar, so the two lines
    overlap, appearing as a single line in the figure. However, the donations from
    the first list vary widely from the mean, whereas the donations from the second
    list are very close to the mean, which confirms what we inferred from the lower
    variance value.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 两组捐款的平均值相似，因此图中的两条线重叠，呈现为一条线。然而，第一组的捐款与平均值差异较大，而第二组的捐款则非常接近平均值，这验证了我们从较低方差值中推断出的结论。
- en: '**Calculating the Correlation Between Two Data Sets**'
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**计算两个数据集之间的相关性**'
- en: 'In this section, we’ll learn how to calculate a statistical measure that tells
    us the nature and strength of the relationship between two sets of numbers: the
    *Pearson correlation coefficient*, which I’ll call simply the *correlation coefficient*.
    Note that this coefficient measures the strength of the *linear* relationship.
    We’d have to use other measures (which we won’t be discussing here) to find out
    the coefficient when two sets have a nonlinear relationship. The coefficient can
    be either positive or negative, and its magnitude can range between –1 and 1 (inclusive).'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何计算一个统计量，该统计量告诉我们两个数字集合之间关系的性质和强度：*皮尔逊相关系数*，我将简称为 *相关系数*。请注意，该系数衡量的是*线性*关系的强度。如果两个集合存在非线性关系，我们需要使用其他度量（这里不讨论）来找到系数。该系数可以是正值或负值，且其绝对值范围在
    -1 到 1 之间（包括 -1 和 1）。
- en: A correlation coefficient of 0 indicates that there’s no linear correlation
    between the two quantities. (Note that this doesn’t mean the two quantities are
    independent of each other. There could still be a nonlinear relationship between
    them, for example). A coefficient of 1 or close to 1 indicates that there’s a
    strong positive linear correlation; a coefficient of exactly 1 is referred to
    as perfect positive correlation. Similarly, a correlation coefficient of –1 or
    close to –1 indicates a strong negative correlation, where 1 indicates a perfect
    negative correlation.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 相关系数为 0 表示这两个量之间没有线性相关性。（注意，这并不意味着这两个量是相互独立的，它们之间仍然可能存在非线性关系，例如）。相关系数为 1 或接近
    1 表示存在强的正线性相关性；相关系数恰好为 1 被称为完美正相关。同样，相关系数为 –1 或接近 –1 表示存在强的负相关性，其中 –1 表示完美负相关。
- en: '**CORRELATION AND CAUSATION**'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**相关性与因果性**'
- en: In statistics, you’ll often come across the statement “correlation doesn’t imply
    causation.” This is a reminder that even if two sets of observations are strongly
    correlated with each other, that doesn’t mean one variable *causes* the other.
    When two variables are strongly correlated, sometimes there’s a third factor that
    influences both variables and explains the correlation. A classic example is the
    correlation between ice cream sales and crime rates—if you track both of these
    variables in a typical city, you’re likely to find a correlation, but this doesn’t
    mean that ice cream sales cause crime (or vice versa). Ice cream sales and crime
    are correlated because they both go up as the weather gets hotter during the summer.
    Of course, this doesn’t mean that hot weather directly causes crime to go up either;
    there are more complicated causes behind that correlation as well.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在统计学中，你常常会遇到“相关性不代表因果性”这一说法。这是提醒我们，即使两个观察集合之间存在很强的相关性，也不意味着一个变量*导致*另一个变量。当两个变量之间的相关性很强时，有时是第三方因素同时影响这两个变量，从而解释了这种相关性。一个经典的例子是冰淇淋销量与犯罪率之间的相关性——如果你在一个典型的城市追踪这两个变量，你很可能会发现它们之间有相关性，但这并不意味着冰淇淋销量导致了犯罪（或反之亦然）。冰淇淋销量和犯罪的相关性是因为它们在夏天天气变热时都会增加。当然，这并不意味着炎热的天气直接导致了犯罪的增加；这种相关性背后也有更复杂的原因。
- en: '***Calculating the Correlation Coefficient***'
  id: totrans-124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***计算相关系数***'
- en: The correlation coefficient is calculated using the formula
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 相关系数通过以下公式计算：
- en: '![image](images/e0076-01.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/e0076-01.jpg)'
- en: 'In the above formula, *n* is the total number of values present in each set
    of numbers (the sets have to be of equal length). The two sets of numbers are
    denoted by *x* and *y* (it doesn’t matter which one you denote as which). The
    other terms are described as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述公式中，*n*是每个数字集合中存在的总值个数（这两个集合的长度必须相等）。这两个数字集合分别用*x*和*y*表示（哪个表示哪个不重要）。其他项的描述如下：
- en: '| Σ*xy* | Sum of the products of the individual elements of the two sets of
    numbers, *x* and *y* |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| Σ*xy* | 两个数字集合*x*和*y*中各个元素乘积的和 |'
- en: '| Σ*x* | Sum of the numbers in set *x* |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| Σ*x* | 集合*x*中数字之和 |'
- en: '| Σ*y* | Sum of the numbers in set *y* |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| Σ*y* | 集合*y*中数字之和 |'
- en: '| (Σ*x*)² | Square of the sum of the numbers in set *x* |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| (Σ*x*)² | 集合*x*中数字之和的平方 |'
- en: '| (Σ*y*)² | Square of the sum of the numbers in set *y* |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| (Σ*y*)² | 集合*y*中数字之和的平方 |'
- en: '| Σ*x*² | Sum of the squares of the numbers in set *x* |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| Σ*x*² | 集合*x*中数字的平方和 |'
- en: '| Σ*y*² | Sum of the squares of the numbers in set *y* |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| Σ*y*² | 集合*y*中数字的平方和 |'
- en: Once we’ve calculated these terms, you can combine them according to the preceding
    formula to find the correlation coefficient. For small lists, it’s possible to
    do this by hand without too much effort, but it certainly gets complicated as
    the size of each set of numbers increases.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们计算了这些项，就可以根据前述公式将它们结合起来，找到相关系数。对于较小的列表，这可以通过手动计算完成而不费太多力气，但随着每个数字集合大小的增加，这个过程会变得复杂。
- en: 'In a moment, we’ll write a program that calculates the correlation coefficient
    for us. In this program, we’ll use the `zip()` function, which will help us calculate
    the sum of products from the two sets of numbers. Here’s an example of how the
    `zip()` function works:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一会儿，我们将编写一个程序来计算相关系数。在这个程序中，我们将使用`zip()`函数，它帮助我们计算两个数字集合的乘积和。以下是`zip()`函数如何工作的示例：
- en: '[PRE24]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `zip()` function returns pairs of the corresponding elements in `x` and
    `y`, which you can then use in a loop to perform other operations (like printing,
    as shown in the preceding code). If the two lists are unequal in length, the function
    terminates when all the elements of the smaller list have been read.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`zip()`函数返回`x`和`y`中对应元素的配对，然后可以在循环中使用这些配对进行其他操作（如在前面的代码中显示的打印）。如果两个列表长度不相等，函数会在较小列表的所有元素被读取完后终止。'
- en: 'Now we’re ready to write a program that will calculate the correlation coefficient
    for us:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备写一个程序，计算相关系数：
- en: '[PRE25]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `find_corr_x_y()` function accepts two arguments, `x` and `y`, which are
    the two sets of numbers we want to calculate the correlation for. At the beginning
    of this function, we find the length of the lists and create a label, `n`, to
    refer to it. Next, at ➊, we have a `for` loop that uses the `zip()` function to
    calculate the product of the corresponding values from each list (multiplying
    together the first item of each list, then the second item of each list, and so
    on). We use the `append()` method to add these products to the list labeled `prod`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`find_corr_x_y()` 函数接受两个参数，`x` 和 `y`，这两个是我们要计算相关性的两个数字集。在此函数的开始部分，我们先找出列表的长度，并创建一个标签
    `n` 来表示它。接下来，在 ➊ 处，我们使用 `for` 循环，通过 `zip()` 函数计算每个列表中对应值的乘积（先将每个列表的第一个元素相乘，然后是第二个元素，依此类推）。我们使用
    `append()` 方法将这些乘积添加到标签为 `prod` 的列表中。'
- en: At ➋, we calculate the sum of the products stored in `prod` using the `sum()`
    function. In the statements at ➌ and ➍, we calculate the sum of the numbers in
    `x` and `y`, respectively (once again, using the `sum()` function). Then, we calculate
    the squares of the sum of the elements in `x` and `y`, creating the labels `squared_sum_x`
    and `squared_sum_y` to refer to them, respectively.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➋ 处，我们使用 `sum()` 函数计算存储在 `prod` 中的乘积之和。在 ➌ 和 ➍ 处的语句中，我们分别计算了 `x` 和 `y` 中数字的总和（同样使用
    `sum()` 函数）。然后，我们计算了 `x` 和 `y` 中元素总和的平方，并分别创建标签 `squared_sum_x` 和 `squared_sum_y`
    来表示这两个值。
- en: In the loop starting at ➎, we calculate the square of each of the elements in
    `x` and find the sum of these squares. Then, we do the same for the elements in
    `y`. We now have all the terms we need to calculate the correlation, and we do
    this in the statements at ➏, ➐, and ➑. Finally, we return the correlation. Correlation
    is an oft-cited measure in statistical studies—in popular media and scientific
    articles alike. Sometimes we know ahead of time that there’s a correlation, and
    we just want to find the strength of that correlation. We’ll see an example of
    this in “[Reading Data from a CSV File](ch03.html#ch03lev2sec09)” on [page 86](ch03.html#page_86),
    when we calculate the correlation between data read from a file. Other times,
    we might only suspect that there might be a correlation, and we must investigate
    the data to verify whether there actually is one (as in the following example).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在从 ➎ 开始的循环中，我们计算了 `x` 中每个元素的平方，并找出这些平方的和。然后，我们对 `y` 中的元素做相同的操作。现在我们已经获得了计算相关性所需的所有项，并在
    ➏、➐ 和 ➑ 处的语句中进行了相关性计算。最后，我们返回相关性。相关性是统计研究中经常引用的一个指标——在流行媒体和科学文章中都很常见。有时我们事先知道存在相关性，只是想找出这种相关性的强度。我们将在
    “[从 CSV 文件读取数据](ch03.html#ch03lev2sec09)” 一节中，在 [第 86 页](ch03.html#page_86) 看到这个例子，届时我们将计算从文件中读取数据的相关性。其他时候，我们可能只是怀疑存在相关性，需要通过数据调查来验证是否真的存在相关性（如下例所示）。
- en: '***High School Grades and Performance on College Admission Tests***'
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***高中成绩与大学入学考试成绩***'
- en: In this section, we’ll consider a fictional group of 10 students in high school
    and investigate whether there’s a relationship between their grades in school
    and how they fared on their college admission tests. [Table 3-2](ch03.html#ch3tab2)
    lists the data we’re going to assume for our study and base our experiments on.
    The “High school grades” column lists the percentile scores of the students’ grades
    in high school, and the “College admission test scores” column shows their percentile
    scores on the college admission test.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将考虑一个虚构的 10 人高中生小组，并研究他们的高中成绩和大学入学考试成绩之间是否存在关系。[表 3-2](ch03.html#ch3tab2)
    列出了我们假设的研究数据，并基于这些数据进行实验。表中的“高中成绩”列列出了学生的高中成绩百分位数，而“大学入学考试成绩”列列出了他们的大学入学考试百分位数。
- en: '**Table 3-2:** High School Grades and College Admission Test Performance'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 3-2：** 高中成绩与大学入学考试成绩'
- en: '| **High school grades** | **College admission test scores** |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| **高中成绩** | **大学入学考试成绩** |'
- en: '| --- | --- |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 90 | 85 |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| 90 | 85 |'
- en: '| 92 | 87 |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| 92 | 87 |'
- en: '| 95 | 86 |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| 95 | 86 |'
- en: '| 96 | 97 |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| 96 | 97 |'
- en: '| 87 | 96 |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| 87 | 96 |'
- en: '| 87 | 88 |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| 87 | 88 |'
- en: '| 90 | 89 |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| 90 | 89 |'
- en: '| 95 | 98 |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| 95 | 98 |'
- en: '| 98 | 98 |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| 98 | 98 |'
- en: '| 96 | 87 |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| 96 | 87 |'
- en: To analyze this data, let’s look at a *scatter plot*. [Figure 3-2](ch03.html#ch3fig2)
    shows the scatter plot of the preceding data set, with the *x*-axis representing
    high school grades and the *y*-axis representing the corresponding college admission
    test performance.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了分析这些数据，让我们看一个 *散点图*。 [图 3-2](ch03.html#ch3fig2) 展示了前述数据集的散点图，其中 *x* 轴表示高中成绩，*y*
    轴表示对应的大学入学考试成绩。
- en: '![image](images/f03-02.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f03-02.jpg)'
- en: '*Figure 3-2: Scatter plot of high school grades and college admission test
    scores*'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3-2：高中成绩与大学入学考试成绩的散点图*'
- en: The plot of the data indicates that the students with the highest grades in
    high school didn’t necessarily perform better on the college admission tests and
    vice versa. Some students with poor high school grades did very well on the college
    entrance exam, while others had excellent grades but did relatively poorly on
    the college exam. If we calculate the correlation coefficient of the two data
    sets (using our program from earlier), we see that it’s approximately 0.32\. This
    means that there’s some correlation, but not a very strong one. If the correlation
    were closer to 1, we’d see this reflected in the scatter plot as well—the points
    would conform more closely to a straight, diagonal line.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 数据图表显示，成绩最好的高中生并不一定在大学入学考试中表现更好，反之亦然。有些高中成绩差的学生在大学入学考试中表现非常好，而一些高中成绩优秀的学生则在大学考试中相对较差。如果我们计算这两个数据集的相关系数（使用我们之前的程序），我们会发现它大约是0.32。这意味着有一定的相关性，但并不很强。如果相关性接近1，我们会在散点图中看到这种趋势——数据点会更贴近一条直线。
- en: Let’s assume that the high school grades shown in [Table 3-2](ch03.html#ch3tab2)
    are an average of individual grades in math, science, English, and social science.
    Let’s also imagine that the college exam places a high emphasis on math—much more
    so than on other subjects. Instead of looking at students’ overall high school
    grades, let’s look at just their grades in math to see whether that’s a better
    predictor of how they did on their college exam. [Table 3-3](ch03.html#ch3tab3)
    now shows only the math scores (as percentiles) and the college admission tests.
    The corresponding scatter plot is shown in [Figure 3-3](ch03.html#ch3fig3).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 假设[表3-2](ch03.html#ch3tab2)中显示的高中成绩是数学、科学、英语和社会科学各科目成绩的平均值。我们还假设大学考试特别重视数学——比其他学科要重得多。与其看学生的总体高中成绩，不如只看他们的数学成绩，以判断数学成绩是否更能预测他们在大学考试中的表现。[表3-3](ch03.html#ch3tab3)现在只显示数学成绩（按百分位数）和大学入学考试成绩。相应的散点图显示在[图3-3](ch03.html#ch3fig3)中。
- en: '**Table 3-3:** High School Math Grades and College Admission Test Performance'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**表3-3：** 高中数学成绩与大学入学考试表现'
- en: '| **High school math grades** | **College admission test scores** |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| **高中数学成绩** | **大学入学考试成绩** |'
- en: '| --- | --- |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 83 | 85 |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| 83 | 85 |'
- en: '| 85 | 87 |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| 85 | 87 |'
- en: '| 84 | 86 |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| 84 | 86 |'
- en: '| 96 | 97 |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| 96 | 97 |'
- en: '| 94 | 96 |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| 94 | 96 |'
- en: '| 86 | 88 |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| 86 | 88 |'
- en: '| 87 | 89 |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| 87 | 89 |'
- en: '| 97 | 98 |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| 97 | 98 |'
- en: '| 97 | 98 |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| 97 | 98 |'
- en: '| 85 | 87 |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| 85 | 87 |'
- en: Now, the scatter plot ([Figure 3-3](ch03.html#ch3fig3)) shows the data points
    lying almost perfectly along a straight line. This is an indication of a high
    correlation between the high school math scores and performance on the college
    admission test. The correlation coefficient, in this case, turns out to be approximately
    1\. With the help of the scatter plot and correlation coefficient, we can conclude
    that there is indeed a strong relationship in this data set between grades in
    high school math and performance on college admission tests.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，散点图（[图3-3](ch03.html#ch3fig3)）显示数据点几乎完全沿一条直线分布。这表明高中数学成绩与大学入学考试成绩之间有很高的相关性。此时，相关系数大约为1。通过散点图和相关系数的帮助，我们可以得出结论：在这个数据集中，高中数学成绩与大学入学考试成绩之间确实存在很强的关系。
- en: '![image](images/f03-03.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f03-03.jpg)'
- en: '*Figure 3-3: Scatter plot of high school math grades and college admission
    test scores*'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3-3：高中数学成绩与大学入学考试成绩的散点图*'
- en: '**Scatter Plots**'
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**散点图**'
- en: In the previous section, we saw an example of how a scatter plot can give us
    a first indication of the existence of any correlation between two sets of numbers.
    In this section, we’ll see the importance of analyzing scatter plots by looking
    at a set of four data sets. For these data sets, conventional statistical measures
    all turn out to be the same, but the scatter plots of each data set reveal important
    differences.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到散点图如何为我们提供两个数据集之间是否存在相关性的初步指示。在这一节中，我们将通过查看一组四个数据集来了解分析散点图的重要性。对于这些数据集，传统的统计指标结果都是相同的，但每个数据集的散点图揭示了重要的差异。
- en: 'First, let’s go over how to create a scatter plot in Python:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们了解如何在Python中创建散点图：
- en: '[PRE26]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `scatter()` function is used to create a scatter plot between two lists
    of numbers, `x` and `y` ➊. The only difference between this plot and the plots
    we created in [Chapter 2](ch02.html#ch02) is that here we use the `scatter()`
    function instead of the `plot()` function. Once again, we have to call `show()`
    to display the plot.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`scatter()`函数用于创建两个数值列表`x`和`y`之间的散点图➊。这张图与我们在[第二章](ch02.html#ch02)中创建的图表唯一的不同之处是，在这里我们使用了`scatter()`函数，而不是`plot()`函数。我们仍然需要调用`show()`来显示图表。'
- en: 'To learn more about scatter plots, let’s look at an important statistical study:
    “Graphs in Statistical Analysis” by the statistician Francis Anscombe.[¹](footnote.html#fn01)
    The study considers four different data sets—referred to as *Anscombe’s quartet*—with
    identical statistical properties: mean, variance, and correlation coefficient.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 为了深入了解散点图，我们来看一个重要的统计学研究：“统计分析中的图表”，作者是统计学家弗朗西斯·安斯科姆。[¹](footnote.html#fn01)
    该研究考虑了四个不同的数据集—统称为*安斯科姆四重奏*—它们具有相同的统计属性：均值、方差和相关系数。
- en: The data sets are as shown in [Table 3-4](ch03.html#ch3tab4) (reproduced from
    the original study).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 数据集如[表3-4](ch03.html#ch3tab4)所示（摘自原始研究）。
- en: '**Table 3-4:** Anscombe’s Quartet—Four Different Data Sets with Almost Identical
    Statistical Measures'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**表3-4：** 安斯科姆四重奏—四个几乎相同统计度量的不同数据集'
- en: '| **A** | **B** | **C** | **D** |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| **A** | **B** | **C** | **D** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| **X1** | **Y1** | **X2** | **Y2** | **X3** | **Y3** | **X4** | **Y4** |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| **X1** | **Y1** | **X2** | **Y2** | **X3** | **Y3** | **X4** | **Y4** |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- |'
- en: '| 10.0 | 8.04 | 10.0 | 9.14 | 10.0 | 7.46 | 8.0 | 6.58 |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| 10.0 | 8.04 | 10.0 | 9.14 | 10.0 | 7.46 | 8.0 | 6.58 |'
- en: '| 8.0 | 6.95 | 8.0 | 8.14 | 8.0 | 6.77 | 8.0 | 5.76 |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| 8.0 | 6.95 | 8.0 | 8.14 | 8.0 | 6.77 | 8.0 | 5.76 |'
- en: '| 13.0 | 7.58 | 13.0 | 8.74 | 13.0 | 12.74 | 8.0 | 7.71 |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| 13.0 | 7.58 | 13.0 | 8.74 | 13.0 | 12.74 | 8.0 | 7.71 |'
- en: '| 9.0 | 8.81 | 9.0 | 8.77 | 9.0 | 7.11 | 8.0 | 8.84 |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| 9.0 | 8.81 | 9.0 | 8.77 | 9.0 | 7.11 | 8.0 | 8.84 |'
- en: '| 11.0 | 8.33 | 11.0 | 9.26 | 11.0 | 7.81 | 8.0 | 8.47 |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| 11.0 | 8.33 | 11.0 | 9.26 | 11.0 | 7.81 | 8.0 | 8.47 |'
- en: '| 14.0 | 9.96 | 14.0 | 8.10 | 14.0 | 8.84 | 8.0 | 7.04 |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| 14.0 | 9.96 | 14.0 | 8.10 | 14.0 | 8.84 | 8.0 | 7.04 |'
- en: '| 6.0 | 7.24 | 6.0 | 6.13 | 6.0 | 6.08 | 8.0 | 5.25 |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| 6.0 | 7.24 | 6.0 | 6.13 | 6.0 | 6.08 | 8.0 | 5.25 |'
- en: '| 4.0 | 4.26 | 4.0 | 3.10 | 4.0 | 5.39 | 19.0 | 12.50 |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| 4.0 | 4.26 | 4.0 | 3.10 | 4.0 | 5.39 | 19.0 | 12.50 |'
- en: '| 12.0 | 10.84 | 12.0 | 9.13 | 12.0 | 8.15 | 8.0 | 5.56 |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| 12.0 | 10.84 | 12.0 | 9.13 | 12.0 | 8.15 | 8.0 | 5.56 |'
- en: '| 7.0 | 4.82 | 7.0 | 7.26 | 7.0 | 6.42 | 8.0 | 7.91 |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| 7.0 | 4.82 | 7.0 | 7.26 | 7.0 | 6.42 | 8.0 | 7.91 |'
- en: '| 5.0 | 5.68 | 5.0 | 4.74 | 5.0 | 5.73 | 8.0 | 6.89 |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| 5.0 | 5.68 | 5.0 | 4.74 | 5.0 | 5.73 | 8.0 | 6.89 |'
- en: We’ll refer to the pairs (X1, Y1), (X2, Y2), (X3, Y3), and (X4, Y4) as data
    sets A, B, C, and D, respectively. [Table 3-5](ch03.html#ch3tab5) presents the
    statistical measures of the data sets rounded off to two decimal digits.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将一对对数据（X1, Y1）、（X2, Y2）、（X3, Y3）和（X4, Y4）分别称为数据集A、B、C和D。[表3-5](ch03.html#ch3tab5)展示了这些数据集的统计度量，并四舍五入保留两位小数。
- en: '**Table 3-5:** Anscombe’s Quartet—Statistical Measures'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '**表3-5：** 安斯科姆四重奏—统计度量'
- en: '| **Data set** | **X** | **Y** |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| **数据集** | **X** | **Y** |'
- en: '| --- | --- | --- |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| **Mean** | **Std. dev.** | **Mean** | **Std. dev.** | **Correlation** |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| **均值** | **标准差** | **均值** | **标准差** | **相关系数** |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| A | 9.00 | 3.32 | 7.50 | 2.03 | 0.82 |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| A | 9.00 | 3.32 | 7.50 | 2.03 | 0.82 |'
- en: '| B | 9.00 | 3.32 | 7.50 | 2.03 | 0.82 |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| B | 9.00 | 3.32 | 7.50 | 2.03 | 0.82 |'
- en: '| C | 9.00 | 3.32 | 7.50 | 2.03 | 0.82 |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| C | 9.00 | 3.32 | 7.50 | 2.03 | 0.82 |'
- en: '| D | 9.00 | 3.32 | 7.50 | 2.03 | 0.82 |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| D | 9.00 | 3.32 | 7.50 | 2.03 | 0.82 |'
- en: The scatter plots for each data set are shown in [Figure 3-4](ch03.html#ch3fig4).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 每个数据集的散点图展示在[图3-4](ch03.html#ch3fig4)中。
- en: '![image](images/f03-04.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f03-04.jpg)'
- en: '*Figure 3-4: Scatter plots of Anscombe’s quartet*'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3-4：安斯科姆四重奏的散点图*'
- en: If we look at just the traditional statistical measures (see [Table 3-5](ch03.html#ch3tab5))—
    like the mean, standard deviation, and correlation coefficient—these data sets
    seem nearly identical. But the scatter plots show that these data sets are actually
    quite different from each other. Thus, scatter plots can be an important tool
    and should be used alongside other statistical measures before drawing any conclusions
    about a data set.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只看传统的统计度量（见[表3-5](ch03.html#ch3tab5)），比如均值、标准差和相关系数，这些数据集似乎几乎相同。但是散点图显示，这些数据集实际上彼此之间有很大的不同。因此，散点图可以成为一个重要的工具，应该与其他统计度量一起使用，才能在得出关于数据集的结论之前进行全面的分析。
- en: '**Reading Data from Files**'
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**从文件中读取数据**'
- en: In all our programs in this chapter, the lists of numbers we used in our calculations
    were all explicitly written, or *hardcoded*, into the programs themselves. If
    you wanted to find the measures for a different data set, you’d have to enter
    the entire new data set in the program itself. You also know how to make programs
    that allow the user to enter the data as input, but with large data sets, it isn’t
    very convenient to make the user enter long lists of numbers each time he or she
    uses the program.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的所有程序中，我们用于计算的数字列表都是明确写入程序中的，或者说是*硬编码*的。如果你想为一个不同的数据集计算度量值，你必须在程序中输入整个新数据集。你也知道如何制作允许用户输入数据的程序，但对于大型数据集来说，每次让用户输入长长的数字列表并不是很方便。
- en: A better alternative is to read the user data from a file. Let’s see a simple
    example of how we can read numbers from a file and perform mathematical operations
    on them. First, I’ll show how to read data from a simple text file with each line
    of the file containing a new data element. Then, I’ll show you how to read from
    a file where the data is stored in the well-known CSV format, which will open
    up a lot of possibilities as there are loads of useful data sets you can download
    from the Internet in CSV format. (If you aren’t familiar with file handling in
    Python, see [Appendix B](app02.html#app02) for a brief introduction.)
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的替代方案是从文件中读取用户数据。让我们看一个简单的例子，看看如何从文件中读取数字并对它们进行数学运算。首先，我将展示如何从一个简单的文本文件中读取数据，文件中的每一行包含一个新的数据元素。然后，我会向你展示如何从一个文件中读取数据，这些数据是以著名的
    CSV 格式存储的，这为我们打开了许多可能性，因为你可以从互联网上下载许多有用的数据集，它们都是以 CSV 格式存储的。（如果你不熟悉 Python 中的文件操作，可以参考[附录
    B](app02.html#app02)进行简短的介绍。）
- en: '***Reading Data from a Text File***'
  id: totrans-220
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***从文本文件中读取数据***'
- en: 'Let’s take a file, *mydata.txt*, with the list of donations (one per line)
    during period A that we considered at the beginning of this chapter:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个文件，*mydata.txt*，其中包含了在 A 期内的捐款列表（每行一个捐款），这是我们在本章开始时考虑过的内容：
- en: '[PRE27]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The following program will read this file and print the sum of the numbers
    stored in the file:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序将读取这个文件并打印出文件中存储的数字的总和：
- en: '[PRE28]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `sum_data()` function opens the file specified by the argument `filename`
    at ➊ and reads it line by line (`f` is referred to as the *file object*, and you
    can think of it as pointing to an opened file). At ➋, we convert each number to
    a floating point number using the `float()` function and then keep adding until
    we’ve read all the numbers. The final number, labeled `s`, holds the sum of the
    numbers, which is printed at the end of the function.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`sum_data()` 函数在 ➊ 打开由参数 `filename` 指定的文件，并逐行读取它（`f` 被称为*文件对象*，你可以把它看作是指向一个打开的文件）。在
    ➋，我们使用 `float()` 函数将每个数字转换为浮动点数字，然后继续累加，直到读取完所有数字。最终的数字 `s` 保存了这些数字的总和，最后在函数末尾打印出来。'
- en: 'Before you run the program, you must first create a file called *mydata.txt*
    with the appropriate data and save it in the same directory as your program. You
    can create this file from IDLE itself by clicking **File**▸**New Window**, typing
    the numbers (one per line) in the new window, and then saving the file as *mydata.txt*
    in the same directory as your program. Now, if you run the program, you’ll see
    the following output:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行程序之前，你必须首先创建一个名为 *mydata.txt* 的文件，并在其中放入适当的数据，然后将其保存到与程序相同的目录下。你可以通过在 IDLE
    中点击 **文件**▸**新建窗口**，在新窗口中输入数字（每行一个），然后将文件保存为 *mydata.txt*，并确保它与程序保存在同一目录下。现在，如果你运行程序，你会看到如下输出：
- en: '[PRE29]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'All our programs in this chapter have assumed that the input data is available
    in lists. To use our earlier programs on the data from a file, we need to first
    create a list from that data. Once we have a list, we can use the functions we
    wrote earlier to calculate the corresponding statistic. The following program
    calculates the mean of the numbers stored in the file *mydata.txt*:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有程序都假设输入数据是以列表的形式存在的。为了在文件数据上使用我们之前的程序，我们首先需要从文件中创建一个列表。一旦我们拥有了这个列表，我们就可以使用之前编写的函数来计算相应的统计数据。以下程序计算存储在文件
    *mydata.txt* 中数字的平均值：
- en: '[PRE30]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Before we can call the `calculate_mean()` function, we need to read the numbers
    stored in the file and convert them into a list. To do this, use the `read_data()`
    function, which reads the file line by line. Instead of summing the numbers, this
    function converts them into floating point numbers and adds them to the list `numbers`
    ➊. The list is returned, and we refer to it by the label `data` ➋. We then invoke
    the `calculate_mean()` function, which returns the mean of the data. Finally,
    we print it.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们调用 `calculate_mean()` 函数之前，需要先读取文件中存储的数字并将其转换为列表。为此，使用 `read_data()` 函数，该函数逐行读取文件。与其求和，函数将数字转换为浮动点数并添加到
    `numbers` 列表中 ➊。然后返回该列表，并用标签 `data` 来表示 ➋。接着，我们调用 `calculate_mean()` 函数，它返回数据的平均值。最后，我们打印出结果。
- en: 'When you run the program, you should see the following output:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行程序时，应该会看到以下输出：
- en: '[PRE31]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Of course, you’ll see a different value for the mean if the numbers in your
    file are different from those in this example.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果文件中的数字与此示例中的不同，平均值也会有所不同。
- en: See [Appendix B](app02.html#app02) for hints on how you can ask the user to
    input the filename and then modify your program accordingly. This will allow your
    program’s user to specify any data file.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 请参见 [附录 B](app02.html#app02)，了解如何提示用户输入文件名，并相应修改你的程序。这样可以让程序的用户指定任何数据文件。
- en: '***Reading Data from a CSV File***'
  id: totrans-235
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***从 CSV 文件读取数据***'
- en: A comma-separated value (CSV) file consists of rows and columns with the columns
    separated from each other by commas. You can view a CSV file using a text editor
    on your operating system or specialized software, such as Microsoft Excel, OpenOffice
    Calc, or LibreOffice Calc.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 逗号分隔值（CSV）文件由行和列组成，列之间通过逗号分隔。你可以使用操作系统上的文本编辑器或专用软件（如 Microsoft Excel、OpenOffice
    Calc 或 LibreOffice Calc）查看 CSV 文件。
- en: 'Here’s a sample CSV file containing a few numbers and their squares:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例 CSV 文件，包含一些数字及其平方：
- en: '[PRE32]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The first line is referred to as the *header*. In this case, it tells us that
    the entries in the first column of this file are numbers and those in the second
    column are the corresponding squares. The next three lines, or rows, contain a
    number and its square separated by a comma. It’s possible to read the data from
    this file using an approach similar to what I showed for the *.txt* file. However,
    Python’s standard library has a dedicated module (`csv`) for reading (and writing)
    CSV files, which makes things a little easier.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行被称为 *表头*。在本例中，它告诉我们文件中第一列的条目是数字，第二列是相应的平方。接下来的三行（或行）包含一个数字及其平方，数字和平方之间用逗号分隔。你可以使用类似我展示过的
    *.txt* 文件读取方法来读取该文件的数据。然而，Python 的标准库中有一个专门用于读取（和写入）CSV 文件的模块（`csv`），这使得操作稍微简单了一些。
- en: 'Save the numbers and their squares into a file, *numbers.csv*, in the same
    directory as your programs. The following program shows how to read this file
    and then create a scatter plot displaying the numbers against their squares:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 将数字及其平方保存到与程序位于同一目录下的文件 *numbers.csv* 中。以下程序展示了如何读取此文件并创建一个散点图，展示数字与其平方之间的关系：
- en: '[PRE33]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `read_csv()` function reads the CSV file using the `reader()` function defined
    in the `csv` module (which is imported at the beginning of the program). This
    function is called with the file object `f` passed to it as an argument ➊. This
    function then returns a *pointer* to the first line of the CSV file. We know that
    the first line of the file is the header, which we want to skip, so we move the
    pointer to the next line using the `next()` function. We then read every line
    of the file with each line referred to by the label `row` ➋, with `row[0]` referring
    to the first column of the data and `row[1]` referring to the second. For this
    specific file, we know that both these numbers are integers, so we use the `int()`
    function to convert these from strings to integers and to store them in two lists.
    The lists are then returned—one containing the numbers and the other containing
    the squares.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`read_csv()` 函数使用在 `csv` 模块中定义的 `reader()` 函数读取 CSV 文件（该模块在程序开头导入）。此函数通过将文件对象
    `f` 作为参数传入来调用 ➊。然后，该函数返回指向 CSV 文件第一行的 *指针*。我们知道文件的第一行是表头，通常我们希望跳过它，因此我们使用 `next()`
    函数将指针移动到下一行。接着，我们读取文件的每一行，每行用标签 `row` 来表示 ➋，其中 `row[0]` 表示数据的第一列，`row[1]` 表示第二列。对于这个特定文件，我们知道这两列的数据都是整数，因此我们使用
    `int()` 函数将这些字符串转换为整数，并将它们存储到两个列表中。然后，这两个列表会被返回——一个包含数字，另一个包含它们的平方。'
- en: We then call the `scatter_plot()` function with these two lists to create the
    scatter plot. The `find_corr_x_y()` function we wrote earlier can also easily
    be used to find the correlation coefficient between the two sets of numbers.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们调用`scatter_plot()`函数，并传入这两个列表来创建散点图。我们之前编写的`find_corr_x_y()`函数也可以轻松用于计算这两个数值集之间的相关系数。
- en: Now let’s try dealing with a more complex CSV file. Open *[https://www.google.com/trends/correlate/](https://www.google.com/trends/correlate/)*
    in your browser, enter any search query you wish to (for example, *summer*), and
    click the **Search correlations** button. You’ll see that a number of results
    are returned under the heading “Correlated with summer,” and the first result
    is the one with the highest correlation (the number on the immediate left of each
    result). Click the **Scatter plot** option above the graph to see a scatter plot
    with the *x*-axis labeled *summer* and the *y*-axis labeled with the top result.
    Ignore the exact numbers plotted on both axes as we’re interested only in the
    correlation and the scatter plot.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试处理一个更复杂的CSV文件。在浏览器中打开*[https://www.google.com/trends/correlate/](https://www.google.com/trends/correlate/)*，输入你想要的任何搜索查询（例如，*summer*），然后点击**搜索相关性**按钮。你会看到在“与夏季相关”这一标题下返回了多个结果，第一个结果是相关性最高的（每个结果左侧的数字）。点击图表上方的**散点图**选项，查看带有*x*-轴标签为*summer*，*y*-轴标签为最高相关结果的散点图。忽略两轴上的具体数字，因为我们这里只关注相关性和散点图。
- en: A little above the scatterplot, click **Export data as CSV** and a file download
    will start. Save this file in the same directory as your programs.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在散点图上方，点击**导出数据为CSV**，下载文件将开始。将此文件保存在与你的程序相同的目录下。
- en: This CSV file is slightly different from the one we saw earlier. At the beginning
    of the file, you’ll see a number of blank lines and lines with a `'#'` symbol
    until finally you’ll see the header and the data. These lines aren’t useful to
    us—go ahead and delete them by hand using whatever software you opened the file
    with so that the first line of the file is the header. Also delete any blank lines
    at the end of the file. Now save the file. This step— where we cleaned up the
    file to make it easier to process with Python—is usually called *preprocessing*
    the data.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这个CSV文件与我们之前看到的略有不同。在文件的开头，你会看到一些空行和带有`'#'`符号的行，直到最后你才会看到表头和数据。这些行对我们没有用处——请使用你打开文件时所用的软件手动删除它们，确保文件的第一行是表头。同时，删除文件末尾的空行。现在保存文件。这个步骤——我们清理文件以便用Python处理——通常被称为*数据预处理*。
- en: The header has several columns. The first contains the date of the data in each
    row (each row has data corresponding to the week that started on the date in this
    column). The second column is the search query you entered, the third column shows
    the search query with the *highest* correlation with your search query, and the
    other columns include a number of other search queries arranged in decreasing
    order of correlation with your entered search query. The numbers in these columns
    are the *z*-scores of the corresponding search queries. The *z-score* indicates
    the difference between the number of times a term was searched for during a specific
    week and the overall mean number of searches per week for that term. A positive
    *z*-score indicates that the number of searches was higher than the mean for that
    week, and a negative *z*-score indicates it was lower.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 表头包含多个列。第一列包含每一行数据的日期（每一行的数据对应于以此列日期开始的那一周）。第二列是你输入的搜索查询，第三列显示与你的搜索查询有*最高*相关性的搜索查询，其他列包含许多其他搜索查询，按与输入查询的相关性降序排列。这些列中的数字是相应搜索查询的*z*-分数。*z*-分数表示某个术语在特定一周的搜索次数与该术语每周平均搜索次数之间的差异。正*z*-分数表示该周的搜索次数高于该术语的周平均搜索次数，负*z*-分数则表示低于平均值。
- en: 'For now, let’s just work with the second and the third columns. You could use
    the following `read_csv()` function to read these columns:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们只处理第二列和第三列。你可以使用以下`read_csv()`函数来读取这两列：
- en: '[PRE34]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This is pretty much like the earlier version of the `read_csv` function; the
    main change here is how we append the values to each list starting at ➊: we’re
    now reading the second and the third members of each row, and we’re storing them
    as floating point numbers.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这与之前版本的`read_csv`函数差不多；这里的主要变化是在➊处我们如何将值附加到每个列表：我们现在读取每一行的第二和第三个成员，并将它们作为浮动点数存储。
- en: 'The following program uses this function to calculate the correlation between
    the values for the search query you provided and the values for the query with
    the highest correlation with it. It also creates a scatter plot of these values:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序使用这个函数来计算你提供的搜索查询的值与与其相关性最高的查询的值之间的相关性。它还创建了这些值的散点图：
- en: '[PRE35]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Assuming that the CSV file was saved as *correlate-summer.csv*, we call the
    `read_csv()` function to read the data in the second and third columns ➊. Then,
    we call the `find_corr_x_y()` function we wrote earlier with the two lists `summer`
    and `highest_correlated`. It returns the correlation coefficient, which we then
    print. Now, we call the `scatter_plot()` function we wrote earlier with these
    two lists again. Before you can run this program, you’ll need to include the definitions
    of the `read_csv()`, `find_corr_x_y()`, and `scatter_plot()` functions.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 假设CSV文件保存为*correlate-summer.csv*，我们调用`read_csv()`函数来读取第二列和第三列的数据➊。然后，我们调用之前编写的`find_corr_x_y()`函数，传入两个列表`summer`和`highest_correlated`。它返回相关系数，我们将其打印出来。接下来，我们再次调用之前编写的`scatter_plot()`函数，传入这两个列表。在运行这个程序之前，你需要包含`read_csv()`、`find_corr_x_y()`和`scatter_plot()`函数的定义。
- en: On running, you’ll see that it prints the correlation coefficient and also creates
    a scatter plot. Both of these should be very similar to the data shown on the
    Google correlate website.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时，你会看到它打印出相关系数并且创建散点图。两者应该与Google相关性网站上显示的数据非常相似。
- en: '**What You Learned**'
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned to calculate statistical measures to describe a
    set of numbers and the relationships between sets of numbers. You also used graphs
    to aid your understanding of these measures. You learned a number of new programming
    tools and concepts while writing programs to calculate these measures.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何计算描述一组数字及其之间关系的统计量。你还使用图表来帮助理解这些统计量。在编写程序计算这些统计量时，你学会了许多新的编程工具和概念。
- en: '**Programming Challenges**'
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**编程挑战**'
- en: Next, apply what you’ve learned to complete the following programming challenges.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将你所学的应用于以下编程挑战。
- en: '***#1: Better Correlation Coefficient–Finding Program***'
  id: totrans-259
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***#1: 更好的相关系数寻找程序***'
- en: The `find_corr_x_y()` function we wrote earlier to find the correlation co efficient
    between two sets of numbers assumes that the two sets of numbers are the same
    length. Improve the function so that it first checks the length of the lists.
    If they’re equal, only then should the function proceed with the remaining calculations;
    otherwise, it should print an error message that the correlation can’t be found.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前编写的`find_corr_x_y()`函数用于查找两组数字之间的相关系数，它假设这两组数字的长度相同。改进该函数，使其首先检查列表的长度。如果它们相等，函数才继续进行剩余的计算；否则，函数应打印出无法找到相关性的信息。
- en: '***#2: Statistics Calculator***'
  id: totrans-261
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***#2: 统计计算器***'
- en: Implement a statistics calculator that takes a list of numbers in the file *mydata.txt*
    and then calculates and prints their mean, median, mode, variance, and standard
    deviation using the functions we wrote earlier in this chapter.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 实现一个统计计算器，读取文件*mydata.txt*中的数字列表，然后使用我们在本章中编写的函数来计算并打印它们的均值、中位数、众数、方差和标准差。
- en: '***#3: Experiment with Other CSV Data***'
  id: totrans-263
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***#3: 试验其他CSV数据***'
- en: 'You can experiment with numerous interesting data sources freely available
    on the Internet. The website *[http://www.quandl.com/](http://www.quandl.com/)*
    is one such source. For this challenge, download the following data as a CVS file
    from *[http://www.quandl.com/WORLDBANK/USA_SP_POP_TOTL/](http://www.quandl.com/WORLDBANK/USA_SP_POP_TOTL/)*:
    the total population of the United States at the end of each year for the years
    1960 to 2012\. Then, calculate the mean, median, variance, and standard deviation
    of the *difference* in population over the years and create a graph showing these
    differences.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以自由地尝试互联网上提供的许多有趣的数据源。网站* [http://www.quandl.com/](http://www.quandl.com/)*
    就是一个这样的数据源。对于这个挑战，下载以下数据作为CSV文件，来源于 *[http://www.quandl.com/WORLDBANK/USA_SP_POP_TOTL/](http://www.quandl.com/WORLDBANK/USA_SP_POP_TOTL/)*：1960年至2012年间美国每年年末的总人口。然后，计算这些年人口*差异*的均值、中位数、方差和标准差，并创建一张展示这些差异的图表。
- en: '***#4: Finding the Percentile***'
  id: totrans-265
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***#4: 查找百分位数***'
- en: The percentile is a commonly used statistic that conveys the value below which
    a given percentage of observations falls. For example, if a student obtained a
    95 percentile score on an exam, this means that 95 percent of the students scored
    less than or equal to the student’s score. For another example, in the list of
    numbers 5, 1, 9, 3, 14, 9, and 7, the 50th percentile is 7 and the 25th percentile
    is 3.5, a number that is not present in the list.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 百分位数是常用的统计量，用于表示给定百分比的观测值低于某个特定值。例如，如果一名学生在考试中获得了95百分位的分数，意味着95%的学生得分低于或等于该学生的分数。再举个例子，在数字列表5,
    1, 9, 3, 14, 9, 7中，第50百分位数是7，第25百分位数是3.5，这是一个列表中不存在的数字。
- en: There are a number of ways to find the observation corresponding to a given
    percentile, but here’s one approach.[²](footnote.html#fn02)
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以找到与给定百分位数对应的观测值，以下是一种方法。[²](footnote.html#fn02)
- en: 'Let’s say we want to calculate the observation at percentile *p*:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想计算百分位数*p*对应的观测值：
- en: 1\. In ascending order, sort the given list of numbers, which we might call
    `data`.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 按升序排序给定的数字列表，我们可以将其称为`data`。
- en: 2\. Calculate
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 计算
- en: '![image](images/e0090-01.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/e0090-01.jpg)'
- en: where *n* is the number of items in `data`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *n* 是`data`中的项数。
- en: 3\. If *i* is an integer, `data[i]` is the number corresponding to percentile
    *p*.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 如果*i*是整数，则`data[i]`是百分位数*p*对应的数字。
- en: 4\. If *i* is *not* an integer, set *k* equal to the integral part of *i* and
    *f* equal to the fractional part of *i*. The number `(1-f)*data[k] + f*data[k+1]`
    is the number at percentile *p*.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 4\. 如果*i*不是整数，将*k*设为*i*的整数部分，*f*设为*i*的分数部分。数字`(1-f)*data[k] + f*data[k+1]`就是百分位数*p*对应的数字。
- en: Using this approach, write a program that will take a set of numbers in a file
    and display the number that corresponds to a specific percentile supplied as an
    input to the program.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，编写一个程序，从文件中读取一组数字并显示与程序输入的特定百分位数对应的数字。
- en: '***#5: Creating a Grouped Frequency Table***'
  id: totrans-276
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***#5: 创建分组频率表***'
- en: 'For this challenge, your task is to write a program that creates a grouped
    frequency table from a set of numbers. A grouped frequency table displays the
    frequency of data classified into different *classes*. For example, let’s consider
    the scores we discussed in “[Creating a Frequency Table](ch03.html#ch03lev2sec03)”
    on [page 69](ch03.html#page_69): 7, 8, 9, 2, 10, 9, 9, 9, 9, 4, 5, 6, 1, 5, 6,
    7, 8, 6, 1, and 10\. A grouped frequency table would display this data as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个挑战，你的任务是编写一个程序，从一组数字中创建一个分组频率表。分组频率表显示了不同*类*中的数据频率。例如，考虑我们在“[创建频率表](ch03.html#ch03lev2sec03)”中讨论过的分数，出现在[第69页](ch03.html#page_69)：7,
    8, 9, 2, 10, 9, 9, 9, 9, 4, 5, 6, 1, 5, 6, 7, 8, 6, 1, 10。一个分组频率表将以如下方式显示这些数据：
- en: '| **Grade** | **Frequency** |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| **成绩** | **频率** |'
- en: '| --- | --- |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 1–6 | 6 |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| 1–6 | 6 |'
- en: '| 6–11 | 14 |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| 6–11 | 14 |'
- en: 'The table classifies the grades into two classes: 1–6 (which includes 1 but
    not 6) and 6–11 (which includes 6 but not 11). It displays against them the number
    of grades that belong to each category. Determining the number of classes and
    the range of numbers in each class are two key steps involved in creating this
    table. In this example, I’ve demonstrated two classes with the range of numbers
    in each class equally divided between the two.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 该表将成绩分为两类：1–6（包括1但不包括6）和6–11（包括6但不包括11）。它显示了每个类别中属于的成绩数量。确定类的数量和每个类中数字的范围是创建该表的两个关键步骤。在这个例子中，我展示了两个类，并且每个类的数字范围在两个类之间均等分配。
- en: 'Here’s one simple approach to creating classes, which assumes the number of
    classes can be arbitrarily chosen:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一种简单的方法来创建类，它假设类的数量可以任意选择：
- en: '[PRE36]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `create_classes()` function accepts two arguments: a list of numbers, `numbers`,
    and `n`, the number of classes to create. It’ll return a list of tuples with each
    tuple representing a class. For example, if it’s called with numbers 7, 8, 9,
    2, 10, 9, 9, 9, 9, 4, 5, 6, 1, 5, 6, 7, 8, 6, 1, 10, and `n` = 4, it returns the
    following list: [(1, 3.25), (3.25, 5.5), (5.5, 7.75), (7.75, 11)]. Once you have
    the list, the next step is to go over each of the numbers and find out which of
    the returned classes it belongs to.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`create_classes()`函数接受两个参数：一个数字列表`numbers`和`n`，即要创建的类的数量。它将返回一个包含元组的列表，每个元组表示一个类。例如，如果调用时传入数字7,
    8, 9, 2, 10, 9, 9, 9, 9, 4, 5, 6, 1, 5, 6, 7, 8, 6, 1, 10，并且`n` = 4，它将返回如下列表：[(1,
    3.25), (3.25, 5.5), (5.5, 7.75), (7.75, 11)]。获得这个列表后，下一步是遍历每个数字，找出它属于哪个返回的类。'
- en: Your challenge is to write a program to read a list of numbers from a file and
    then to print the grouped frequency table, making use of the `create_classes()`
    function.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 你的挑战是编写一个程序，从文件中读取一组数字，然后利用`create_classes()`函数打印分组频率表。
