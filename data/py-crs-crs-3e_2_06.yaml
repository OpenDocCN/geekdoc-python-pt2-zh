- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: Scoring
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 计分
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: In this chapter, we’ll finish building *Alien Invasion*. We’ll add a Play button
    to start the game on demand and to restart the game once it ends. We’ll also change
    the game so it speeds up when the player moves up a level, and we’ll implement
    a scoring system. By the end of the chapter, you’ll know enough to start writing
    games that increase in difficulty as a player progresses and that feature complete
    scoring systems.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将完成构建*外星人入侵*游戏。我们将添加一个播放按钮，让玩家可以随时开始游戏并在游戏结束后重新开始。我们还将修改游戏，使得玩家升到新的一关时，游戏速度会加快，并且实现一个计分系统。到本章结束时，你将掌握足够的知识来编写随着玩家进展而难度递增，并且包含完整计分系统的游戏。
- en: Adding the Play Button
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加播放按钮
- en: In this section, we’ll add a Play button that appears before a game begins and
    reappears when the game ends so the player can play again.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将添加一个播放按钮，它会在游戏开始前显示，并在游戏结束后重新显示，以便玩家可以再次玩游戏。
- en: 'Right now, the game begins as soon as you run *alien_invasion.py*. Let’s start
    the game in an inactive state and then prompt the player to click a Play button
    to begin. To do this, modify the `__init__()` method of `AlienInvasion`:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，游戏在运行*alien_invasion.py*时会立即开始。让我们先让游戏处于非活动状态，然后提示玩家点击播放按钮开始游戏。为此，修改`AlienInvasion`的`__init__()`方法：
- en: '**alien_invasion.py**'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**alien_invasion.py**'
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now the game should start in an inactive state, with no way for the player to
    start it until we make a Play button.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，游戏应该在非活动状态下启动，玩家在我们创建播放按钮之前无法启动游戏。
- en: Creating a Button Class
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建按钮类
- en: 'Because Pygame doesn’t have a built-in method for making buttons, we’ll write
    a `Button` class to create a filled rectangle with a label. You can use this code
    to make any button in a game. Here’s the first part of the `Button` class; save
    it as *button.py*:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Pygame没有内置的按钮制作方法，我们将编写一个`Button`类来创建一个带标签的填充矩形。你可以使用这段代码来制作任何游戏中的按钮。以下是`Button`类的第一部分；将其保存为*button.py*：
- en: '**button.py**'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**button.py**'
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: First, we import the `pygame.font` module, which lets Pygame render text to
    the screen. The `__init__()` method takes the parameters `self`, the `ai_game`
    object, and `msg`, which contains the button’s text ❶. We set the button dimensions
    ❷, set `button_color` to color the button’s `rect` object dark green, and set
    `text_color` to render the text in white.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入`pygame.font`模块，它允许Pygame将文本渲染到屏幕上。`__init__()`方法接受`self`、`ai_game`对象和`msg`（包含按钮文本）作为参数
    ❶。我们设置按钮的尺寸 ❷，将`button_color`设置为深绿色来着色按钮的`rect`对象，并将`text_color`设置为白色以渲染文本。
- en: Next, we prepare a `font` attribute for rendering text ❸. The `None` argument
    tells Pygame to use the default font, and `48` specifies the size of the text.
    To center the button on the screen, we create a `rect` for the button ❹ and set
    its `center` attribute to match that of the screen.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为渲染文本准备一个`font`属性 ❸。`None`参数告诉Pygame使用默认字体，而`48`指定了文本的大小。为了将按钮居中显示在屏幕上，我们为按钮创建一个`rect`
    ❹，并将其`center`属性设置为与屏幕中心对齐。
- en: Pygame works with text by rendering the string you want to display as an image.
    Finally, we call `_prep_msg()` to handle this rendering ❺.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Pygame通过将你想要显示的字符串渲染为图像来处理文本。最后，我们调用`_prep_msg()`来处理此渲染 ❺。
- en: 'Here’s the code for `_prep_msg()`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`_prep_msg()`的代码：
- en: '**button.py**'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**button.py**'
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `_prep_msg()` method needs a `self` parameter and the text to be rendered
    as an image (`msg`). The call to `font.render()` turns the text stored in `msg`
    into an image, which we then store in `self.msg_image` ❶. The `font.render()`
    method also takes a Boolean value to turn antialiasing on or off (*antialiasing*
    makes the edges of the text smoother). The remaining arguments are the specified
    font color and background color. We set antialiasing to `True` and set the text
    background to the same color as the button. (If you don’t include a background
    color, Pygame will try to render the font with a transparent background.)
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`_prep_msg()`方法需要一个`self`参数和要作为图像渲染的文本（`msg`）。对`font.render()`的调用将`msg`中存储的文本转化为图像，然后我们将其存储在`self.msg_image`中
    ❶。`font.render()`方法还接受一个布尔值来开启或关闭抗锯齿效果（*抗锯齿*使文本的边缘更加平滑）。其余的参数是指定的字体颜色和背景颜色。我们将抗锯齿设置为`True`，并将文本背景设置为与按钮相同的颜色。（如果不包括背景颜色，Pygame会尝试用透明背景渲染字体。）'
- en: We center the text image on the button by creating a `rect` from the image and
    setting its `center` attribute to match that of the button ❷.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过创建一个来自图像的`rect`，并将其`center`属性设置为与按钮的中心对齐，从而将文本图像居中于按钮 ❷。
- en: 'Finally, we create a `draw_button()` method that we can call to display the
    button onscreen:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建了一个`draw_button()`方法，我们可以调用它在屏幕上显示按钮：
- en: '**button.py**'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**button.py**'
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We call `screen.fill()` to draw the rectangular portion of the button. Then
    we call `screen.blit()` to draw the text image to the screen, passing it an image
    and the `rect` object associated with the image. This completes the `Button` class.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用`screen.fill()`绘制按钮的矩形部分。然后，我们调用`screen.blit()`将文本图像绘制到屏幕上，传递给它一个图像和与该图像相关的`rect`对象。这完成了`Button`类的创建。
- en: Drawing the Button to the Screen
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将按钮绘制到屏幕上
- en: 'We’ll use the `Button` class to create a Play button in `AlienInvasion`. First,
    we’ll update the `import` statements:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`AlienInvasion`中使用`Button`类创建Play按钮。首先，我们将更新`import`语句：
- en: '**alien_invasion.py**'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**alien_invasion.py**'
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Because we need only one Play button, we’ll create the button in the `__init__()`
    method of `AlienInvasion`. We can place this code at the very end of `__init__()`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们只需要一个Play按钮，所以我们将在`AlienInvasion`的`__init__()`方法中创建该按钮。我们可以将这段代码放在`__init__()`的末尾：
- en: '**alien_invasion.py**'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**alien_invasion.py**'
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This code creates an instance of `Button` with the label `Play`, but it doesn’t
    draw the button to the screen. To do this, we’ll call the button’s `draw_button()`
    method in `_update_screen()`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码创建了一个`Button`实例，标签为`Play`，但它没有将按钮绘制到屏幕上。为此，我们将在`_update_screen()`中调用按钮的`draw_button()`方法：
- en: '**alien_invasion.py**'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**alien_invasion.py**'
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: To make the Play button visible above all other elements on the screen, we draw
    it after all the other elements have been drawn but before flipping to a new screen.
    We include it in an `if` block, so the button only appears when the game is inactive.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让“Play”按钮在屏幕上的其他所有元素之上可见，我们在绘制完所有其他元素后，但在切换到新屏幕之前绘制它。我们将其包含在`if`语句块中，因此按钮只会在游戏处于非活动状态时显示。
- en: Now when you run *Alien Invasion*, you should see a Play button in the center
    of the screen, as shown in [Figure 14-1](#figure14-1).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你运行*Alien Invasion*时，你应该会看到一个Play按钮出现在屏幕中央，如[图 14-1](#figure14-1)所示。
- en: '![](image_fi/502703c14/f14001.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502703c14/f14001.png)'
- en: 'Figure 14-1: A Play button appears when the game is inactive.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14-1：当游戏处于非活动状态时，出现一个Play按钮。
- en: Starting the Game
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启动游戏
- en: 'To start a new game when the player clicks Play, add the following `elif` block
    to the end of `_check_events()` to monitor mouse events over the button:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在玩家点击Play时开始新游戏，我们需要在`_check_events()`的末尾添加以下`elif`语句块，以监控按钮上的鼠标事件：
- en: '**alien_invasion.py**'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**alien_invasion.py**'
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Pygame detects a `MOUSEBUTTONDOWN` event when the player clicks anywhere on
    the screen ❶, but we want to restrict our game to respond to mouse clicks only
    on the Play button. To accomplish this, we use `pygame.mouse.get_pos()`, which
    returns a tuple containing the mouse cursor’s *x*- and *y*-coordinates when the
    mouse button is clicked ❷. We send these values to the new method `_check_play_button()`
    ❸.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Pygame会在玩家点击屏幕上的任意位置时检测到`MOUSEBUTTONDOWN`事件❶，但我们希望游戏只响应鼠标点击Play按钮的事件。为此，我们使用`pygame.mouse.get_pos()`，它返回一个包含鼠标光标的*x*和*y*坐标的元组，当鼠标按钮被点击时会返回这些值❷。我们将这些值传递给新的方法`_check_play_button()`❸。
- en: 'Here’s `_check_play_button()`, which I chose to place after `_check_events()`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`_check_play_button()`，我选择将它放在`_check_events()`之后：
- en: '**alien_invasion.py**'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**alien_invasion.py**'
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We use the `rect` method `collidepoint()` to check whether the point of the
    mouse click overlaps the region defined by the Play button’s `rect` ❶. If so,
    we set `game_active` to `True`, and the game begins!
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`rect`方法`collidepoint()`来检查鼠标点击的位置是否与Play按钮的`rect`定义的区域重叠❶。如果重叠，我们将`game_active`设置为`True`，游戏开始！
- en: At this point, you should be able to start and play a full game. When the game
    ends, the value of `game_active` should become `False` and the Play button should
    reappear.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你应该能够启动并进行完整的游戏。当游戏结束时，`game_active`的值应变为`False`，并且Play按钮应重新出现。
- en: Resetting the Game
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重置游戏
- en: The Play button code we just wrote works the first time the player clicks Play.
    But it doesn’t work after the first game ends, because the conditions that caused
    the game to end haven’t been reset.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚编写的Play按钮代码在玩家第一次点击Play时有效。但在第一次游戏结束后它不再有效，因为导致游戏结束的条件尚未被重置。
- en: 'To reset the game each time the player clicks Play, we need to reset the game
    statistics, clear out the old aliens and bullets, build a new fleet, and center
    the ship, as shown here:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在每次玩家点击Play时重置游戏，我们需要重置游戏统计信息，清除旧的外星人和子弹，重新建立新的舰队，并重新定位飞船，代码如下所示：
- en: '**alien_invasion.py**'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**alien_invasion.py**'
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We reset the game statistics ❶, which gives the player three new ships. Then
    we set `game_active` to `True` so the game will begin as soon as the code in this
    function finishes running. We empty the `aliens` and `bullets` groups ❷, and then
    we create a new fleet and center the ship ❸.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重置了游戏统计信息❶，这会给玩家三个新船只。然后我们将`game_active`设置为`True`，这样当这个函数中的代码运行完毕后，游戏就会开始。我们清空了`aliens`和`bullets`两个组❷，然后创建一个新的外星舰队并将飞船居中❸。
- en: Now the game will reset properly each time you click Play, allowing you to play
    it as many times as you want!
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每次点击Play时，游戏都会正确重置，允许你玩任意次数！
- en: Deactivating the Play Button
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 禁用Play按钮
- en: One issue with our Play button is that the button region on the screen will
    continue to respond to clicks even when the Play button isn’t visible. If you
    click the Play button area by accident after a game begins, the game will restart!
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Play按钮存在一个问题，即即使Play按钮不可见，屏幕上的按钮区域仍然会响应点击。如果在游戏开始后不小心点击了Play按钮区域，游戏会重新开始！
- en: 'To fix this, set the game to start only when `game_active` is `False`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，设置游戏只在`game_active`为`False`时开始：
- en: '**alien_invasion.py**'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**alien_invasion.py**'
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The flag `button_clicked` stores a `True` or `False` value ❶, and the game will
    restart only if Play is clicked *and* the game is not currently active ❷. To test
    this behavior, start a new game and repeatedly click where the Play button should
    be. If everything works as expected, clicking the Play button area should have
    no effect on the gameplay.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 标志`button_clicked`存储`True`或`False`值❶，只有在点击Play且游戏当前不活跃的情况下，游戏才会重新开始❷。要测试这个行为，启动一个新游戏并反复点击Play按钮应该所在的位置。如果一切按预期工作，点击Play按钮区域应该不会对游戏玩法产生任何影响。
- en: Hiding the Mouse Cursor
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 隐藏鼠标光标
- en: 'We want the mouse cursor to be visible when the game is inactive, but once
    play begins, it just gets in the way. To fix this, we’ll make it invisible when
    the game becomes active. We can do this at the end of the `if` block in `_check_play_button()`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在游戏未激活时光标可见，但一旦游戏开始，光标就会妨碍操作。为了解决这个问题，我们将在游戏变为活跃状态时将光标设为不可见。我们可以在`_check_play_button()`函数的`if`块结束时实现这一点：
- en: '**alien_invasion.py**'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**alien_invasion.py**'
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Passing `False` to `set_visible()` tells Pygame to hide the cursor when the
    mouse is over the game window.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 将`False`传递给`set_visible()`会告诉Pygame在鼠标悬停在游戏窗口时隐藏光标。
- en: 'We’ll make the cursor reappear once the game ends so the player can click Play
    again to begin a new game. Here’s the code to do that:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏结束后，我们会让光标重新出现，这样玩家就可以点击Play重新开始新游戏。以下是实现这一点的代码：
- en: '**alien_invasion.py**'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**alien_invasion.py**'
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We make the cursor visible again as soon as the game becomes inactive, which
    happens in `_ship_hit()`. Attention to details like this makes your game more
    professional looking and allows the player to focus on playing, rather than figuring
    out the user interface.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当游戏变为未激活时，我们会再次让光标可见，这发生在`_ship_hit()`中。注意这些细节会让你的游戏看起来更专业，也能让玩家专注于游戏，而不是去琢磨界面。
- en: Leveling Up
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 升级关卡
- en: In our current game, once a player shoots down the entire alien fleet, the player
    reaches a new level, but the game difficulty doesn’t change. Let’s liven things
    up a bit and make the game more challenging by increasing the game’s speed each
    time a player clears the screen.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们当前的游戏中，一旦玩家击败整个外星舰队，玩家就会进入新一关，但游戏的难度并不会改变。让我们稍微增加一点挑战性，增加游戏速度，使每当玩家清除屏幕时，游戏难度增加。
- en: Modifying the Speed Settings
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改速度设置
- en: 'We’ll first reorganize the `Settings` class to group the game settings into
    static and dynamic ones. We’ll also make sure any settings that change during
    the game reset when we start a new game. Here’s the `__init__()` method for *settings.py*:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先重新组织`Settings`类，将游戏设置分为静态和动态设置。我们还会确保任何在游戏中变化的设置会在重新开始新游戏时重置。以下是*settings.py*中的`__init__()`方法：
- en: '**settings.py**'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**settings.py**'
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We continue to initialize settings that stay constant in the `__init__()` method.
    We add a `speedup_scale` setting ❶ to control how quickly the game speeds up:
    a value of 2 will double the game speed every time the player reaches a new level;
    a value of 1 will keep the speed constant. A value like `1.1` should increase
    the speed enough to make the game challenging but not impossible. Finally, we
    call the `initialize_dynamic_settings()` method to initialize the values for attributes
    that need to change throughout the game ❷.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续在`__init__()`方法中初始化那些保持不变的设置。我们添加了一个`speedup_scale`设置 ❶ 来控制游戏加速的速度：值为2时，每次玩家达到新关卡，游戏速度会翻倍；值为1时，速度保持不变。像`1.1`这样的值应该足够增加游戏难度，但又不至于让游戏变得不可能完成。最后，我们调用`initialize_dynamic_settings()`方法来初始化那些在游戏过程中需要变化的属性
    ❷。
- en: 'Here’s the code for `initialize_dynamic_settings()`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`initialize_dynamic_settings()`的代码：
- en: '**settings.py**'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**settings.py**'
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This method sets the initial values for the ship, bullet, and alien speeds.
    We’ll increase these speeds as the player progresses in the game and reset them
    each time the player starts a new game. We include `fleet_direction` in this method
    so the aliens always move right at the beginning of a new game. We don’t need
    to increase the value of `fleet_drop_speed`, because when the aliens move faster
    across the screen, they’ll also come down the screen faster.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法设置了飞船、子弹和外星人速度的初始值。随着玩家在游戏中的进展，我们将提高这些速度，并在每次玩家开始新游戏时重置它们。我们在这个方法中包含了`fleet_direction`，确保外星人在新游戏开始时总是向右移动。我们不需要增加`fleet_drop_speed`的值，因为当外星人横向移动速度加快时，它们也会更快地向下移动。
- en: 'To increase the speeds of the ship, bullets, and aliens each time the player
    reaches a new level, we’ll write a new method called `increase_speed()`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在玩家达到新关卡时提高飞船、子弹和外星人的速度，我们将编写一个新方法叫做`increase_speed()`：
- en: '**settings.py**'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**settings.py**'
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: To increase the speed of these game elements, we multiply each speed setting
    by the value of `speedup_scale`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了增加这些游戏元素的速度，我们将每个速度设置乘以`speedup_scale`的值。
- en: 'We increase the game’s tempo by calling `increase_speed()` in `_check_bullet_alien_collisions()`
    when the last alien in a fleet has been shot down:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当舰队中的最后一个外星人被击败时，我们在`_check_bullet_alien_collisions()`中调用`increase_speed()`来加速游戏：
- en: '**alien_invasion.py**'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**alien_invasion.py**'
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Changing the values of the speed settings `ship_speed`, `alien_speed`, and `bullet_speed`
    is enough to speed up the entire game!
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 只需改变飞船速度`ship_speed`、外星人速度`alien_speed`和子弹速度`bullet_speed`的值，就足以加速整个游戏！
- en: Resetting the Speed
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重置速度
- en: 'Now we need to return any changed settings to their initial values each time
    the player starts a new game; otherwise, each new game would start with the increased
    speed settings of the previous game:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要每次玩家开始新游戏时将任何改变的设置恢复到初始值；否则，每个新游戏将从前一个游戏的加速设置开始：
- en: '**alien_invasion.py**'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**alien_invasion.py**'
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Playing *Alien Invasion* should be more fun and challenging now. Each time you
    clear the screen, the game should speed up and become slightly more difficult.
    If the game becomes too difficult too quickly, decrease the value of `settings.speedup_scale`.
    Or if the game isn’t challenging enough, increase the value slightly. Find a sweet
    spot by ramping up the difficulty in a reasonable amount of time. The first couple
    of screens should be easy, the next few should be challenging but doable, and
    subsequent screens should be almost impossibly difficult.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，玩*Alien Invasion*应该更有趣和更具挑战性了。每次你清除屏幕时，游戏应该加速并变得稍微更难。如果游戏变得太难，可以降低`settings.speedup_scale`的值。如果游戏不够有挑战性，可以稍微提高这个值。通过在合理的时间内逐步增加难度，找到一个平衡点。前几个屏幕应该很容易，接下来的几个应该有挑战性但可以完成，而之后的屏幕应该几乎不可完成。
- en: Scoring
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 得分
- en: Let’s implement a scoring system to track the game’s score in real time and
    display the high score, level, and number of ships remaining.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来实现一个得分系统，实时追踪游戏分数，并显示最高分、关卡和剩余飞船数量。
- en: 'The score is a game statistic, so we’ll add a `score` attribute to `GameStats`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 得分是游戏的统计数据，因此我们将向`GameStats`添加一个`score`属性：
- en: '**game_stats.py**'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**game_stats.py**'
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: To reset the score each time a new game starts, we initialize `score` in `reset_stats()`
    rather than `__init__()`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了每次开始新游戏时重置得分，我们将在`reset_stats()`中初始化`score`，而不是在`__init__()`中。
- en: Displaying the Score
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 显示得分
- en: 'To display the score on the screen, we first create a new class, `Scoreboard`.
    For now, this class will just display the current score. Eventually, we’ll use
    it to report the high score, level, and number of ships remaining as well. Here’s
    the first part of the class; save it as *scoreboard.py*:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在屏幕上显示分数，我们首先创建一个新的类`Scoreboard`。现在，这个类只会显示当前的分数。最终，我们将用它来报告最高分、等级和剩余的飞船数量。以下是该类的第一部分；将其保存为*scoreboard.py*：
- en: '**scoreboard.py**'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**scoreboard.py**'
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Because `Scoreboard` writes text to the screen, we begin by importing the `pygame.font`
    module. Next, we give `__init__()` the `ai_game` parameter so it can access the
    `settings`, `screen`, and `stats` objects, which it will need to report the values
    we’re tracking ❶. Then we set a text color ❷ and instantiate a font object ❸.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`Scoreboard`会在屏幕上写入文本，我们首先导入`pygame.font`模块。接下来，我们为`__init__()`方法提供`ai_game`参数，这样它就可以访问`settings`、`screen`和`stats`对象，这些是用来报告我们正在跟踪的数值❶。然后，我们设置文本颜色❷，并实例化一个字体对象❸。
- en: 'To turn the text to be displayed into an image, we call `prep_score()` ❹, which
    we define here:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将显示的文本转化为图像，我们调用`prep_score()`❹，我们在这里定义它：
- en: '**scoreboard.py**'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**scoreboard.py**'
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In `prep_score()`, we turn the numerical value `stats.score` into a string ❶
    and then pass this string to `render()`, which creates the image ❷. To display
    the score clearly onscreen, we pass the screen’s background color and the text
    color to `render()`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在`prep_score()`中，我们将数值`stats.score`转换为字符串❶，然后将这个字符串传递给`render()`，它会创建图像❷。为了在屏幕上清晰地显示分数，我们将屏幕的背景颜色和文字颜色传递给`render()`。
- en: We’ll position the score in the upper-right corner of the screen and have it
    expand to the left as the score increases and the width of the number grows. To
    make sure the score always lines up with the right side of the screen, we create
    a `rect` called `score_rect` ❸ and set its right edge 20 pixels from the right
    edge of the screen ❹. We then place the top edge 20 pixels down from the top of
    the screen ❺.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把分数放置在屏幕的右上角，并随着分数增加和数字宽度的增加，分数向左扩展。为了确保分数总是与屏幕的右侧对齐，我们创建一个名为`score_rect`的`rect`❸，并将它的右边缘设置为离屏幕右边缘20个像素❹。然后我们将其上边缘设置为距离屏幕顶部20个像素❺。
- en: 'Then we create a `show_score()` method to display the rendered score image:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们创建一个`show_score()`方法来显示渲染后的分数图像：
- en: '**scoreboard.py**'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**scoreboard.py**'
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This method draws the score image onscreen at the location `score_rect` specifies.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法将分数图像绘制到屏幕上，位置由`score_rect`指定。
- en: Making a Scoreboard
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建记分板
- en: 'To display the score, we’ll create a `Scoreboard` instance in `AlienInvasion`.
    First, let’s update the `import` statements:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示分数，我们将在`AlienInvasion`中创建一个`Scoreboard`实例。首先，让我们更新`import`语句：
- en: '**alien_invasion.py**'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**alien_invasion.py**'
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, we make an instance of `Scoreboard` in `__init__()`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在`__init__()`中创建一个`Scoreboard`实例：
- en: '**alien_invasion.py**'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**alien_invasion.py**'
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then we draw the scoreboard onscreen in `_update_screen()`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们在`_update_screen()`中绘制记分板：
- en: '**alien_invasion.py**'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**alien_invasion.py**'
- en: '[PRE24]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We call `show_score()` just before we draw the Play button.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在绘制“Play”按钮之前调用`show_score()`。
- en: When you run *Alien Invasion* now, a 0 should appear at the top right of the
    screen. (At this point, we just want to make sure the score appears in the right
    place before developing the scoring system further.) [Figure 14-2](#figure14-2)
    shows the score as it appears before the game starts.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当你现在运行*外星人入侵*时，屏幕右上角应该会出现一个0。（此时，我们只是想确保分数出现在正确的位置，之后再继续开发得分系统。）[图 14-2](#figure14-2)显示了游戏开始前分数的样子。
- en: Next, we’ll assign point values to each alien!
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将为每个外星人分配分值！
- en: '![](image_fi/502703c14/f14002.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502703c14/f14002.png)'
- en: 'Figure 14-2: The score appears at the top-right corner of the screen.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14-2：分数出现在屏幕的右上角。
- en: Updating the Score as Aliens Are Shot Down
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 当外星人被击落时更新分数
- en: 'To write a live score onscreen, we update the value of `stats.score` whenever
    an alien is hit, and then call `prep_score()` to update the score image. But first,
    let’s determine how many points a player gets each time they shoot down an alien:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在屏幕上实时显示分数，我们每当外星人被击中时更新`stats.score`的值，然后调用`prep_score()`来更新分数图像。但首先，让我们确定每次击落外星人时玩家能获得多少分：
- en: '**settings.py**'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**settings.py**'
- en: '[PRE25]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We’ll increase each alien’s point value as the game progresses. To make sure
    this point value is reset each time a new game starts, we set the value in `initialize_dynamic_settings()`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 随着游戏的进行，我们将增加每个外星人的分数值。为了确保每次新游戏开始时分数值都会重置，我们在`initialize_dynamic_settings()`中设置该值。
- en: 'Let’s update the score in `_check_bullet_alien_collisions()` each time an alien
    is shot down:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 每次击落外星人时，让我们在`_check_bullet_alien_collisions()`中更新分数：
- en: '**alien_invasion.py**'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**alien_invasion.py**'
- en: '[PRE26]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: When a bullet hits an alien, Pygame returns a `collisions` dictionary. We check
    whether the dictionary exists, and if it does, the alien’s value is added to the
    score. We then call `prep_score()` to create a new image for the updated score.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当子弹击中外星人时，Pygame会返回一个`collisions`字典。我们检查这个字典是否存在，如果存在，就将外星人的分值添加到总分中。然后我们调用`prep_score()`来更新记分板的分数。
- en: Now when you play *Alien Invasion*, you should be able to rack up points!
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你玩*Alien Invasion*时，你应该能够快速累积分数！
- en: Resetting the Score
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重置分数
- en: Right now, we’re only prepping a new score *after* an alien has been hit, which
    works for most of the game. But when we start a new game, we’ll still see our
    score from the old game until the first alien is hit.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只是在外星人被击中后*才*准备新的分数，这对大多数游戏场景有效。但在开始新游戏时，我们仍然会看到上一个游戏的分数，直到第一个外星人被击中。
- en: 'We can fix this by prepping the score when starting a new game:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在开始新游戏时准备分数来解决这个问题：
- en: '**alien_invasion.py**'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**alien_invasion.py**'
- en: '[PRE27]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We call `prep_score()` after resetting the game stats when starting a new game.
    This preps the scoreboard with a score of 0.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在重置游戏统计数据后调用`prep_score()`来开始新游戏。这个方法将用0分初始化记分板。
- en: Making Sure to Score All Hits
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 确保为每次击中都得分
- en: As currently written, our code could miss scoring for some aliens. For example,
    if two bullets collide with aliens during the same pass through the loop or if
    we make an extra-wide bullet to hit multiple aliens, the player will only receive
    points for hitting one of the aliens. To fix this, let’s refine the way that bullet-alien
    collisions are detected.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 按照当前代码写法，我们可能会漏掉一些外星人的得分。例如，如果两颗子弹在同一轮循环中同时击中外星人，或者如果我们制作了一个超宽子弹来击中多个外星人，玩家只会为击中的一个外星人得分。为了修复这个问题，让我们改进子弹与外星人碰撞的检测方式。
- en: 'In `_check_bullet_alien_collisions()`, any bullet that collides with an alien
    becomes a key in the `collisions` dictionary. The value associated with each bullet
    is a list of aliens it has collided with. We loop through the values in the `collisions`
    dictionary to make sure we award points for each alien hit:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在`_check_bullet_alien_collisions()`中，任何与外星人碰撞的子弹都会成为`collisions`字典中的一个键。每颗子弹相关的值是它所击中的外星人列表。我们遍历`collisions`字典中的值，确保为每个被击中的外星人得分：
- en: '**alien_invasion.py**'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**alien_invasion.py**'
- en: '[PRE28]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If the `collisions` dictionary has been defined, we loop through all values
    in the dictionary. Remember that each value is a list of aliens hit by a single
    bullet. We multiply the value of each alien by the number of aliens in each list
    and add this amount to the current score. To test this, change the width of a
    bullet to 300 pixels and verify that you receive points for each alien you hit
    with your extra-wide bullets; then return the bullet width to its normal value.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`collisions`字典已定义，我们将遍历字典中的所有值。记住，每个值是一个被单颗子弹击中的外星人列表。我们将每个外星人的分值乘以每个列表中的外星人数量，并将这个值加到当前分数中。为了测试这个，先将子弹宽度改为300像素，验证你是否能为每个用超宽子弹击中的外星人得分；然后再把子弹宽度恢复到正常值。
- en: Increasing Point Values
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 增加分值
- en: 'Because the game gets more difficult each time a player reaches a new level,
    aliens in later levels should be worth more points. To implement this functionality,
    we’ll add code to increase the point value when the game’s speed increases:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 因为每次玩家达到新关卡时，游戏变得更加困难，所以后面的关卡中的外星人应该值更多的分。为了实现这个功能，我们将在游戏速度增加时添加代码来提高分值：
- en: '**settings.py**'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**settings.py**'
- en: '[PRE29]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We define a rate at which points increase, which we call `score_scale` ❶. A
    small increase in speed (`1.1`) makes the game more challenging quickly. But to
    see a more notable difference in scoring, we need to change the alien point value
    by a larger amount (`1.5`). Now when we increase the game’s speed, we also increase
    the point value of each hit ❷. We use the `int()` function to increase the point
    value by whole integers.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个分数增长的比率，称为`score_scale` ❶。小幅度的速度增加（`1.1`）能迅速增加游戏的挑战性。但为了看到得分差异更明显，我们需要通过更大的数值（`1.5`）来改变外星人的分值。现在，当我们提高游戏的速度时，每击中一个外星人的分值也会随之增加
    ❷。我们使用`int()`函数将分值增加为整数。
- en: 'To see the value of each alien, add a `print()` call to the `increase_speed()`
    method in `Settings`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看每个外星人的分值，可以在`Settings`中的`increase_speed()`方法中添加`print()`调用：
- en: '**settings.py**'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**settings.py**'
- en: '[PRE30]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The new point value should appear in the terminal every time you reach a new
    level.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 每次达到新关卡时，新的分值应该出现在终端中。
- en: Rounding the Score
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 四舍五入分数
- en: 'Most arcade-style shooting games report scores as multiples of 10, so let’s
    follow that lead with our scores. Also, let’s format the score to include comma
    separators in large numbers. We’ll make this change in `Scoreboard`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数街机风格的射击游戏都会以10的倍数报告分数，因此我们也会按此方式报告我们的分数。此外，我们会格式化分数，以便在大数值中包含逗号分隔符。我们将在`Scoreboard`中进行此更改：
- en: '**scoreboard.py**'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**scoreboard.py**'
- en: '[PRE31]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `round()` function normally rounds a float to a set number of decimal places
    given as the second argument. However, when you pass a negative number as the
    second argument, `round()` will round the value to the nearest 10, 100, 1,000,
    and so on. This code tells Python to round the value of `stats.score` to the nearest
    10 and assign it to `rounded_score`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`round()`函数通常会根据作为第二个参数传递的小数位数来四舍五入浮点数。然而，当你传递负数作为第二个参数时，`round()`会将数值四舍五入到最接近的10、100、1,000等。此代码告诉Python将`stats.score`的值四舍五入到最接近的10，并将其赋值给`rounded_score`。'
- en: We then use a format specifier in the f-string for the score. A *format specifier*
    is a special sequence of characters that modifies the way a variable’s value is
    presented. In this case the sequence `:,` tells Python to insert commas at appropriate
    places in the numerical value that’s provided. This results in strings like `1,000,000`
    instead of `1000000`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们在f-string中使用格式说明符来表示分数。*格式说明符*是一种特殊的字符序列，用于修改变量值的呈现方式。在这种情况下，序列`:,`告诉Python在数值的适当位置插入逗号。这会将`1000000`格式化为`1,000,000`。
- en: Now when you run the game, you should see a neatly formatted, rounded score
    even when you rack up lots of points, as shown in [Figure 14-3](#figure14-3).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你运行游戏时，你应该能看到一个格式整齐、四舍五入的分数，即使你获得了大量分数，正如在[图 14-3](#figure14-3)中所示。
- en: '![](image_fi/502703c14/f14003.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502703c14/f14003.png)'
- en: 'Figure 14-3: A rounded score with comma separators'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14-3：带有逗号分隔符的四舍五入分数
- en: High Scores
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最高分
- en: 'Every player wants to beat a game’s high score, so let’s track and report high
    scores to give players something to work toward. We’ll store high scores in `GameStats`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 每个玩家都希望打破游戏的最高分，因此我们将跟踪并报告最高分，以便给玩家设定一个目标。我们将在`GameStats`中存储最高分：
- en: '**game_stats.py**'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**game_stats.py**'
- en: '[PRE32]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Because the high score should never be reset, we initialize `high_score` in
    `__init__()` rather than in `reset_stats()`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 因为最高分永远不应重置，所以我们在`__init__()`方法中初始化`high_score`，而不是在`reset_stats()`方法中。
- en: 'Next, we’ll modify `Scoreboard` to display the high score. Let’s start with
    the `__init__()` method:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将修改`Scoreboard`来显示最高分。让我们从`__init__()`方法开始：
- en: '**scoreboard.py**'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**scoreboard.py**'
- en: '[PRE33]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The high score will be displayed separately from the score, so we need a new
    method, `prep_high_score()`, to prepare the high-score image ❶.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 最高分将与分数分开显示，因此我们需要一个新的方法`prep_high_score()`来准备最高分图像❶。
- en: 'Here’s the `prep_high_score()` method:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`prep_high_score()`方法：
- en: '**scoreboard.py**'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**scoreboard.py**'
- en: '[PRE34]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We round the high score to the nearest 10 and format it with commas ❶. We then
    generate an image from the high score ❷, center the high score `rect` horizontally
    ❸, and set its `top` attribute to match the top of the score image ❹.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将最高分四舍五入到最接近的10，并用逗号格式化❶。然后我们从最高分生成一张图像❷，将最高分的`rect`水平居中❸，并将其`top`属性设置为与分数图像的顶部对齐❹。
- en: 'The `show_score()` method now draws the current score at the top right and
    the high score at the top center of the screen:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`show_score()`方法现在会在屏幕的右上角绘制当前分数，并在屏幕的顶部中央绘制最高分：'
- en: '**scoreboard.py**'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**scoreboard.py**'
- en: '[PRE35]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To check for high scores, we’ll write a new method, `check_high_score()`, in
    `Scoreboard`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查最高分，我们将在`Scoreboard`中编写一个新的方法`check_high_score()`：
- en: '**scoreboard.py**'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**scoreboard.py**'
- en: '[PRE36]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The method `check_high_score()` checks the current score against the high score.
    If the current score is greater, we update the value of `high_score` and call
    `prep_high_score()` to update the high score’s image.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 方法`check_high_score()`将当前分数与最高分进行比较。如果当前分数更高，我们会更新`high_score`的值，并调用`prep_high_score()`来更新最高分的图像。
- en: 'We need to call `check_high_score()` each time an alien is hit after updating
    the score in `_check_bullet_alien_collisions()`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 每次击中外星人后更新分数时，我们需要调用`check_high_score()`：
- en: '**alien_invasion.py**'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '**alien_invasion.py**'
- en: '[PRE37]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We call `check_high_score()` when the `collisions` dictionary is present, and
    we do so after updating the score for all the aliens that have been hit.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当`collisions`字典存在时，我们会调用`check_high_score()`，并在更新所有已击中外星人的分数后执行此操作。
- en: The first time you play *Alien Invasion*, your score will be the high score,
    so it will be displayed as the current score and the high score. But when you
    start a second game, your high score should appear in the middle and your current
    score should appear at the right, as shown in [Figure 14-4](#figure14-4).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次玩*Alien Invasion*时，你的分数将是高分，因此它会显示为当前分数和高分。但是当你开始第二局游戏时，你的高分应该显示在中间，当前分数则显示在右侧，如[图14-4](#figure14-4)所示。
- en: '![](image_fi/502703c14/f14004.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502703c14/f14004.png)'
- en: 'Figure 14-4: The high score is shown at the top center of the screen.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图14-4：高分显示在屏幕的顶部中间。
- en: Displaying the Level
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 显示关卡
- en: 'To display the player’s level in the game, we first need an attribute in `GameStats`
    representing the current level. To reset the level at the start of each new game,
    initialize it in `reset_stats()`:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在游戏中显示玩家的关卡，我们首先需要在`GameStats`中添加一个属性来表示当前的关卡。为了在每场新游戏开始时重置关卡，我们在`reset_stats()`中初始化它：
- en: '**game_stats.py**'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**game_stats.py**'
- en: '[PRE38]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'To have `Scoreboard` display the current level, we call a new method, `prep_level()`,
    from `__init__()`:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让`Scoreboard`显示当前的关卡，我们从`__init__()`中调用一个新方法`prep_level()`：
- en: '**scoreboard.py**'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**scoreboard.py**'
- en: '[PRE39]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Here’s `prep_level()`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`prep_level()`：
- en: '**scoreboard.py**'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**scoreboard.py**'
- en: '[PRE40]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `prep_level()` method creates an image from the value stored in `stats.level`
    ❶ and sets the image’s `right` attribute to match the score’s `right` attribute
    ❷. It then sets the `top` attribute 10 pixels beneath the bottom of the score
    image to leave space between the score and the level ❸.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`prep_level()`方法根据`stats.level`中存储的值创建一张图像 ❶，并将图像的`right`属性设置为与分数的`right`属性相匹配
    ❷。然后，它将`top`属性设置为比分数图像底部低10个像素，以便分数和关卡之间留出空间 ❸。'
- en: 'We also need to update `show_score()`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要更新`show_score()`：
- en: '**scoreboard.py**'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**scoreboard.py**'
- en: '[PRE41]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This new line draws the level image to the screen.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这行新代码将关卡图像绘制到屏幕上。
- en: 'We’ll increment `stats.level` and update the level image in `_check_bullet_alien_collisions()`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`_check_bullet_alien_collisions()`中递增`stats.level`并更新关卡图像：
- en: '**alien_invasion.py**'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**alien_invasion.py**'
- en: '[PRE42]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: If a fleet is destroyed, we increment the value of `stats.level` and call `prep_level()`
    to make sure the new level displays correctly.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一队飞船被摧毁，我们会增加`stats.level`的值，并调用`prep_level()`来确保新关卡正确显示。
- en: 'To ensure the level image updates properly at the start of a new game, we also
    call `prep_level()` when the player clicks the Play button:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保在新游戏开始时关卡图像正确更新，我们还需要在玩家点击“开始”按钮时调用`prep_level()`：
- en: '**alien_invasion.py**'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**alien_invasion.py**'
- en: '[PRE43]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We call `prep_level()` right after calling `prep_score()`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在调用`prep_score()`之后立即调用`prep_level()`。
- en: Now you’ll see how many levels you’ve completed, as shown in [Figure 14-5](#figure14-5).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你将看到你完成了多少个关卡，如[图14-5](#figure14-5)所示。
- en: '![](image_fi/502703c14/f14005.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502703c14/f14005.png)'
- en: 'Figure 14-5: The current level appears just below the current score.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图14-5：当前关卡显示在当前得分下方。
- en: Displaying the Number of Ships
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 显示飞船数量
- en: Finally, let’s display the number of ships the player has left, but this time,
    let’s use a graphic. To do so, we’ll draw ships in the upper-left corner of the
    screen to represent how many ships are left, just as many classic arcade games
    do.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们显示玩家剩余的飞船数量，不过这次我们使用图形。为此，我们将在屏幕的左上角绘制飞船来表示剩余的飞船数量，就像许多经典街机游戏一样。
- en: 'First, we need to make `Ship` inherit from `Sprite` so we can create a group
    of ships:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要让`Ship`继承自`Sprite`，这样我们就可以创建一组飞船：
- en: '**ship.py**'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '**ship.py**'
- en: '[PRE44]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Here we import `Sprite`, make sure `Ship` inherits from `Sprite` ❶, and call
    `super()` at the beginning of `__init__()` ❷.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们导入`Sprite`，确保`Ship`继承自`Sprite` ❶，并在`__init__()`的开始调用`super()` ❷。
- en: 'Next, we need to modify `Scoreboard` to create a group of ships we can display.
    Here are the `import` statements for `Scoreboard`:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要修改`Scoreboard`以创建一组可以显示的飞船。这里是`Scoreboard`的`import`语句：
- en: '**scoreboard.py**'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '**scoreboard.py**'
- en: '[PRE45]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Because we’re making a group of ships, we import the `Group` and `Ship` classes.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们要创建一组飞船，所以我们导入了`Group`和`Ship`类。
- en: 'Here’s `__init__()`:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`__init__()`：
- en: '**scoreboard.py**'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '**scoreboard.py**'
- en: '[PRE46]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We assign the game instance to an attribute, because we’ll need it to create
    some ships. We call `prep_ships()` after the call to `prep_level()`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将游戏实例分配给一个属性，因为我们需要它来创建一些飞船。我们在调用`prep_level()`后调用`prep_ships()`。
- en: 'Here’s `prep_ships()`:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`prep_ships()`：
- en: '**scoreboard.py**'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '**scoreboard.py**'
- en: '[PRE47]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The `prep_ships()` method creates an empty group, `self.ships`, to hold the
    ship instances ❶. To fill this group, a loop runs once for every ship the player
    has left ❷. Inside the loop, we create a new ship and set each ship’s *x*-coordinate
    value so the ships appear next to each other with a 10-pixel margin on the left
    side of the group of ships ❸. We set the *y*-coordinate value 10 pixels down from
    the top of the screen so the ships appear in the upper-left corner of the screen
    ❹. Then we add each new ship to the group `ships` ❺.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`prep_ships()`方法创建了一个空的组，`self.ships`，用来存放飞船实例 ❶。为了填充这个组，循环会为玩家剩余的每艘飞船运行一次
    ❷。在循环内部，我们创建一艘新的飞船，并设置每艘飞船的* x *坐标值，使得飞船彼此相邻，且组内的左侧有10像素的间距 ❸。我们设置* y *坐标值为屏幕顶部下方10像素，使得飞船显示在屏幕的左上角
    ❹。然后我们将每艘新的飞船添加到`ships`组中 ❺。'
- en: 'Now we need to draw the ships to the screen:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要将飞船绘制到屏幕上：
- en: '**scoreboard.py**'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '**scoreboard.py**'
- en: '[PRE48]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: To display the ships on the screen, we call `draw()` on the group, and Pygame
    draws each ship.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在屏幕上显示飞船，我们在组上调用`draw()`，然后Pygame会绘制每一艘飞船。
- en: 'To show the player how many ships they have to start with, we call `prep_ships()`
    when a new game starts. We do this in `_check_play_button()` in `AlienInvasion`:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示玩家初始拥有多少艘飞船，我们在新游戏开始时调用`prep_ships()`。我们在`AlienInvasion`的`_check_play_button()`中执行此操作：
- en: '**alien_invasion.py**'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '**alien_invasion.py**'
- en: '[PRE49]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We also call `prep_ships()` when a ship is hit, to update the display of ship
    images when the player loses a ship:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 当飞船被击中时，我们也会调用`prep_ships()`，以更新飞船图像的显示，当玩家失去一艘飞船时：
- en: '**alien_invasion.py**'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '**alien_invasion.py**'
- en: '[PRE50]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We call `prep_ships()` after decreasing the value of `ships_left`, so the correct
    number of remaining ships displays each time a ship is destroyed.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在减少`ships_left`的值后调用`prep_ships()`，以便每次飞船被摧毁时正确显示剩余飞船的数量。
- en: '[Figure 14-6](#figure14-6) shows the complete scoring system, with the remaining
    ships displayed at the top left of the screen.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 14-6](#figure14-6)展示了完整的得分系统，剩余的飞船显示在屏幕的左上角。'
- en: '![](image_fi/502703c14/f14006.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502703c14/f14006.png)'
- en: 'Figure 14-6: The complete scoring system for *Alien Invasion*'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14-6：*Alien Invasion*的完整得分系统
- en: Summary
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 小结
- en: In this chapter, you learned how to implement a Play button to start a new game.
    You also learned how to detect mouse events and hide the cursor in active games.
    You can use what you’ve learned to create other buttons, like a Help button to
    display instructions on how to play your games. You also learned how to modify
    the speed of a game as it progresses, implement a progressive scoring system,
    and display information in textual and nontextual ways.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何实现一个“开始游戏”按钮来启动新游戏。你还学会了如何检测鼠标事件并在活动游戏中隐藏光标。你可以运用所学，创建其他按钮，例如帮助按钮来显示如何玩游戏的说明。你还学会了如何在游戏进程中调整游戏速度，实施渐进式得分系统，并以文本和非文本方式显示信息。
