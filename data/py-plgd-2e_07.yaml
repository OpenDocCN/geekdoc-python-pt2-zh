- en: '[5](nsp-venkitachalam503045-0008.xhtml#rch05)'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[5](nsp-venkitachalam503045-0008.xhtml#rch05)'
- en: Flocking Boids
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 鸟群模拟
- en: '![](images/nsp-venkitachalam503045-circle-image.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-circle-image.jpg)'
- en: Look closely at a flock of birds or a school of fish, and you’ll notice that
    although the group is composed of individual creatures, the group as a whole seems
    to have a life of its own. The birds in a flock align with each other as they
    move and flow over and around obstacles. They break formation when disturbed or
    startled, but then they regroup, as if controlled by some larger force.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细观察一群鸟或一群鱼，你会注意到，尽管这个群体由个体构成，但整个群体似乎有着自己独特的生命力。鸟群中的鸟在移动时相互对齐，穿越和绕过障碍物。当受到惊扰时，它们会打破队形，但很快会重新聚集，仿佛被某种更大的力量所控制。
- en: In 1986, Craig Reynolds created a realistic-looking simulation of the flocking
    behavior of birds called the *Boids model*. One remarkable thing about the Boids
    model (named after the stereotypical New Yorker’s pronunciation of the word *birds*)
    is that only three simple rules govern the interaction between individuals in
    the flock, yet the model produces remarkably realistic flocking behavior. The
    Boids model is widely studied and has even been used to animate computer-generated
    swarms like the marching penguins in the movie *Batman Returns* (1992).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 1986年，Craig Reynolds 创建了一个模拟鸟群行为的现实感十足的模拟系统，称为 *Boids 模型*。Boids 模型（以典型的纽约口音发音的
    *birds* 来命名）一个显著的特点是，尽管只有三个简单的规则来控制鸟群成员之间的相互作用，但该模型却能产生极为真实的群体行为。Boids 模型被广泛研究，甚至曾被用于动画生成计算机生成的鸟群，比如电影《蝙蝠侠归来》（1992）中的行进企鹅。
- en: In this project, you’ll use Reynolds’s three rules to create a Boids simulation
    of the flocking behavior of *N* birds and plot their positions and directions
    of movement over time. You’ll also provide a method to add a bird to the flock,
    as well as a scatter effect that you can use to study the impact of a local disturbance
    on the flock. Boids is called an *N*-body simulation because it models a dynamic
    system of *N* particles that exert forces on each other.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本项目中，你将使用 Reynolds 的三条规则，创建一个模拟 *N* 只鸟的 Boids 群体行为的模拟，并绘制它们随时间变化的位置和移动方向。你还将提供一个方法来将鸟加入群体，以及一个散点效果，用于研究局部干扰对鸟群的影响。Boids
    被称为 *N* 体模拟，因为它模拟了一个动态系统，其中 *N* 个粒子相互施加力。
- en: '[How It Works](nsp-venkitachalam503045-0008.xhtml#rah0701)'
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[它是如何工作的](nsp-venkitachalam503045-0008.xhtml#rah0701)'
- en: 'The three core rules of the Boids simulation are as follows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Boids 模拟的三条核心规则如下：
- en: Separation Keep a minimum distance between the boids.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 分离 让 boids 之间保持最小距离。
- en: Alignment Point each boid in the average direction of movement of its local
    flockmates.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对齐 让每只小鸟朝着本地群体的平均移动方向前进。
- en: Cohesion Move each boid toward the center of mass of its local flockmates.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 团结 让每只小鸟朝向其本地群体中心移动。
- en: 'Boids simulations can add other rules too, such as ones to avoid obstacles
    or scatter the flock when it’s disturbed, as you’ll learn in the following sections.
    To create the Boids animation, you’ll do the following for every time step in
    the simulation:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Boids 模拟还可以添加其他规则，例如避免障碍物或在群体受到干扰时分散鸟群，正如你将在接下来的章节中学习的那样。为了创建 Boids 动画，你需要在每一个时间步长中执行以下操作：
- en: '1\. For all boids in the flock:'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1\. 对所有 boids 执行以下操作：
- en: a. Apply the three core rules.
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: a. 应用三个核心规则。
- en: b. Apply any additional rules.
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: b. 应用任何附加规则。
- en: c. Apply all boundary conditions.
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: c. 应用所有边界条件。
- en: 2\. Update the positions and velocities of the boids.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2\. 更新群体中每个小鸟的位置和速度。
- en: 3\. Plot the new positions and velocities.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3\. 绘制新的位置和速度。
- en: As you’ll see, these simple steps create a flock with evolving, complex behavior.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你将看到的，这些简单的步骤创建了一个具有不断变化、复杂行为的鸟群。
- en: '[Requirements](nsp-venkitachalam503045-0008.xhtml#rah0702)'
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[需求](nsp-venkitachalam503045-0008.xhtml#rah0702)'
- en: 'These are the Python modules you’ll be using in this simulation:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是你将在本模拟中使用的 Python 模块：
- en: • `numpy` arrays to store the positions and velocities of the boids
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • `numpy` 数组用于存储 boids 的位置和速度
- en: • The `matplotlib` library to animate the boids
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • `matplotlib` 库用于动画化 boids
- en: • `argparse` to process command line options
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • `argparse` 用于处理命令行选项
- en: • The `scipy.spatial.distance` module, which has some really neat methods for
    calculating distances between points
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • `scipy.spatial.distance` 模块，它提供了一些非常实用的方法来计算点之间的距离。
- en: I chose to use `matplotlib` for boids as a matter of simplicity and convenience.
    To draw a huge number of boids as quickly as possible, you might use something
    like the OpenGL library. We’ll explore graphics in more detail in [Part III](nsp-venkitachalam503045-0018.xhtml#pt03)
    of this book.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择使用 `matplotlib` 来绘制 boids，因为它简单且方便。为了尽可能快速地绘制大量 boids，你可能会使用类似 OpenGL 库的东西。我们将在本书的
    [第三部分](nsp-venkitachalam503045-0018.xhtml#pt03)中更详细地探讨图形学。
- en: '[The Code](nsp-venkitachalam503045-0008.xhtml#rah0703)'
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[代码](nsp-venkitachalam503045-0008.xhtml#rah0703)'
- en: You’ll encapsulate the behavior of a group of boids in a class called `Boids`.
    First you’ll set the initial positions and velocities of the boids. Next, you’ll
    set up the boundary conditions for the simulation, look at how the boids are drawn,
    and implement the Boids simulation rules discussed earlier. Finally, you’ll add
    some interesting events to the simulation by allowing the user to add boids and
    scatter the flock. To see the full project code, skip ahead to [“The Complete
    Code”](nsp-venkitachalam503045-0017.xhtml#ah0707) on [page 96](nsp-venkitachalam503045-0017.xhtml#p96).
    You can also download it from the book’s GitHub repository at [https://github.com/mkvenkit/pp2e/blob/main/boids/boids.py](https://github.com/mkvenkit/pp2e/blob/main/boids/boids.py).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你将通过创建一个名为`Boids`的类来封装一群 boids 的行为。首先，你将设置 boids 的初始位置和速度。接下来，设置仿真的边界条件，查看 boids
    如何被绘制，并实现之前讨论过的 Boids 仿真规则。最后，你将通过允许用户添加 boids 并打散群体，向仿真中添加一些有趣的事件。要查看完整的项目代码，请跳到
    [“完整代码”](nsp-venkitachalam503045-0017.xhtml#ah0707) 位于 [第96页](nsp-venkitachalam503045-0017.xhtml#p96)。你还可以从本书的
    GitHub 仓库下载代码：[https://github.com/mkvenkit/pp2e/blob/main/boids/boids.py](https://github.com/mkvenkit/pp2e/blob/main/boids/boids.py)。
- en: '[Initializing the Simulation](nsp-venkitachalam503045-0008.xhtml#rbh0701)'
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[初始化仿真](nsp-venkitachalam503045-0008.xhtml#rbh0701)'
- en: The Boids simulation needs to compute the position and velocities of the boids
    at each step by pulling information from `numpy` arrays. At the beginning of the
    simulation, you use the `Boids` class’s `__init__()` method to create those arrays
    and initialize all boids in approximately the center of the screen, with their
    velocities set in random directions.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Boids 仿真需要通过从 `numpy` 数组中提取信息，计算每个步骤中 boids 的位置和速度。在仿真开始时，你使用 `Boids` 类的 `__init__()`
    方法来创建这些数组，并将所有 boids 初始化到大致位于屏幕中心的位置，其速度设定为随机方向。
- en: import argparse
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: import argparse
- en: import math
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: import math
- en: import numpy as np
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: import numpy as np
- en: import matplotlib.pyplot as plt
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: import matplotlib.pyplot as plt
- en: import matplotlib.animation as animation
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: import matplotlib.animation as animation
- en: from scipy.spatial.distance import squareform, pdist
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: from scipy.spatial.distance import squareform, pdist
- en: from numpy.linalg import norm
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: from numpy.linalg import norm
- en: ❶ width, height = 640, 480
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ width, height = 640, 480
- en: 'class Boids:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Boids:'
- en: '"""class that represents Boids simulation"""'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '"""表示 Boids 仿真的类"""'
- en: 'def __init__(self, N):'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, N):'
- en: '"""initialize the Boids simulation"""'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '"""初始化 Boids 仿真"""'
- en: '# init position & velocities'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '# 初始化位置与速度'
- en: ❷ self.pos = [width/2.0, height/2.0] +
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ self.pos = [width/2.0, height/2.0] +
- en: 10*np.random.rand(2*N).reshape(N, 2)
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 10*np.random.rand(2*N).reshape(N, 2)
- en: '# normalized random velocities'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '# 归一化随机速度'
- en: ❸ angles = 2*math.pi*np.random.rand(N)
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ angles = 2*math.pi*np.random.rand(N)
- en: ❹ self.vel = np.array(list(zip(np.cos(angles), np.sin(angles))))
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ self.vel = np.array(list(zip(np.cos(angles), np.sin(angles))))
- en: self.N = N
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: self.N = N
- en: 'First you import the modules required for the program and set the width and
    height of the simulation window on the screen ❶. Then you begin declaring the
    `Boids` class. Within the class’s `__init__()` method, you create a `numpy` array
    called `pos` to store the x- and y-coordinates of all the boids ❷. For the initial
    value of each pair of coordinates, you start with the center of the window, `[width/2.0,
    height/2.0]`, and add a random displacement of up to 10 units. The code `np.random.rand(2*N)`
    creates a one-dimensional array of 2*N* random numbers in the range [0, 1], which
    you multiply by 10 to scale to a range of [0, 10]. The `reshape()` call converts
    the one-dimensional array into a two-dimensional array of shape (*N*, 2), perfect
    for storing *N* pairs of x- and y-coordinates. Notice, too, the `numpy` broadcasting
    rules in action here: the 1×2 array `[width/2.0, height/2.0]` representing the
    center of the window is added to each element in the *N*×2 array to randomly offset
    each boid’s position from the center.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你导入程序所需的模块，并设置模拟窗口的宽度和高度 ❶。然后，你开始声明 `Boids` 类。在类的 `__init__()` 方法中，你创建了一个名为
    `pos` 的 `numpy` 数组，用于存储所有鸟群的 x 和 y 坐标 ❷。对于每一对坐标的初始值，你从窗口的中心 `[width/2.0, height/2.0]`
    开始，并加上最多 10 个单位的随机偏移。代码 `np.random.rand(2*N)` 创建一个 2*N 个随机数的一维数组，范围为 [0, 1]，然后乘以
    10 将范围调整为 [0, 10]。`reshape()` 调用将这个一维数组转换成形状为 (*N*, 2) 的二维数组，非常适合存储 *N* 对 x 和
    y 坐标。这里还需要注意 `numpy` 的广播规则：表示窗口中心的 1×2 数组 `[width/2.0, height/2.0]` 被加到每个 *N*×2
    数组的元素上，从而随机偏移每个鸟群的位置。
- en: 'Next, you create an array of random unit velocity vectors (these are vectors
    of magnitude 1.0, pointing in random directions) for each boid using the following
    method: given an angle *t*, the pair of numbers (cos(*t*), sin(*t*)) lie on a
    circle of radius 1.0, centered at the origin (0, 0). If you draw a line from the
    origin to a point on this circle, it becomes a unit vector that depends on the
    angle *t*. So if you choose *t* at random, you end up with a random velocity vector.
    [Figure 5-1](nsp-venkitachalam503045-0017.xhtml#fig5-1) illustrates this scheme.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你为每个鸟群创建一个随机单位速度向量的数组（这些是大小为 1.0、指向随机方向的向量），使用以下方法：给定一个角度 *t*，一对数字 (cos(*t*),
    sin(*t*)) 位于半径为 1.0 的圆上，圆心在原点 (0, 0)。如果你从原点画一条线到圆上的一个点，那么它就成为一个单位向量，依赖于角度 *t*。因此，如果你随机选择
    *t*，你就得到了一个随机的速度向量。[图 5-1](nsp-venkitachalam503045-0017.xhtml#fig5-1)说明了这个方案。
- en: '![](images/nsp-venkitachalam503045-f05001.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f05001.jpg)'
- en: 'Figure 5-1: Generating random unit velocity vectors'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-1：生成随机单位速度向量
- en: Returning to the code, you put this method into action by first generating an
    array of *N* random angles in the range [0, 2π] ❸. Then you create an array of
    random unit velocity vectors by calculating the cosine and sine of those angles
    ❹. You group the coordinates of each vector using Python’s built-in `zip()` method.
    The following is a simple example of `zip()`. This joins two lists into a list
    of tuples. The `list()` is needed because just calling `zip` will create only
    an iterator—you need all the elements in the list.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 回到代码，你通过首先生成一个包含 *N* 个随机角度的数组来启动此方法，角度范围为[0, 2π] ❸。然后，通过计算这些角度的余弦和正弦，你创建一个随机单位速度向量的数组
    ❹。你使用 Python 内置的 `zip()` 方法将每个向量的坐标组合在一起。以下是 `zip()` 的一个简单示例。它将两个列表合并成一个包含元组的列表。因为直接调用
    `zip` 只会创建一个迭代器，所以你需要使用 `list()` 来获取所有元素。
- en: '>>> list(`zip([0, 1, 2], [3, 4, 5]))`'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> list(`zip([0, 1, 2], [3, 4, 5]))`'
- en: '[(0, 3), (1, 4), (2, 5)]'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[(0, 3), (1, 4), (2, 5)]'
- en: In summary, you’ve generated two arrays that will be useful throughout the simulation,
    `pos` and `vel`. The first contains random positions clustered within a 10-pixel
    radius around the center of the screen, and the second contains unit velocities
    pointing in random directions. This means that at the start of the simulation,
    the boids will all hover around the center of the screen, pointed in random directions.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，你已经生成了两个数组，这将在整个模拟过程中发挥作用，分别是 `pos` 和 `vel`。第一个数组包含围绕屏幕中心 10 像素半径范围内的随机位置，第二个数组包含指向随机方向的单位速度向量。这意味着在模拟开始时，所有的鸟群都会围绕屏幕中心悬停，并且朝向随机的方向。
- en: 'The `__init__()` method continues by declaring some constant values that will
    help govern the simulation:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__()` 方法继续声明一些常量值，这些值将有助于控制模拟过程：'
- en: '# min dist of approach'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '# 最小接近距离'
- en: ❶ self.minDist = 25.0
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ self.minDist = 25.0
- en: '# max magnitude of velocities calculated by "rules"'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '# 由“规则”计算出的最大速度大小'
- en: ❷ self.maxRuleVel = 0.03
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ self.maxRuleVel = 0.03
- en: '# max magnitude of final velocity'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '# 最终速度的最大大小'
- en: ❸ self.maxVel = 2.0
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ self.maxVel = 2.0
- en: Here you define the minimum distance of approach between two boids ❶. You’ll
    use this value later to apply the separation rule. Then you define `maxRuleVel`,
    which limits how much a boid’s velocity can be changed each time one of the simulation
    rules is applied ❷. You also define `maxVel`, which sets an overall limit on the
    boids’ velocities ❸.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你定义了两个Boid之间的最小接近距离 ❶。稍后你将使用这个值来应用分离规则。然后你定义了`maxRuleVel`，它限制每次应用模拟规则时Boid速度的变化幅度
    ❷。你还定义了`maxVel`，它设置了Boid速度的总限制 ❸。
- en: '[Setting Boundary Conditions](nsp-venkitachalam503045-0008.xhtml#rbh0702)'
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[设置边界条件](nsp-venkitachalam503045-0008.xhtml#rbh0702)'
- en: Birds fly in a boundless sky, but the boids must play in limited space. To create
    that space, you’ll set boundary conditions, as you did with the toroidal boundary
    condition in the Game of Life simulation in [Chapter 3](nsp-venkitachalam503045-0015.xhtml#ch03).
    In this case, you’ll apply a *tiled boundary condition* (actually the continuous
    space version of the boundary condition you used in [Chapter 3](nsp-venkitachalam503045-0015.xhtml#ch03)).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 鸟儿飞翔在无边的天空，但Boid必须在有限的空间中游戏。为了创造这个空间，你需要设置边界条件，就像你在[第3章](nsp-venkitachalam503045-0015.xhtml#ch03)中的生命游戏模拟中使用环形边界条件一样。在这种情况下，你将应用*瓷砖式边界条件*（实际上是你在[第3章](nsp-venkitachalam503045-0015.xhtml#ch03)中使用的边界条件的连续空间版本）。
- en: 'Think of the Boids simulation as taking place in a tiled space: when a boid
    moves out of a tile, it moves in from the opposite direction to an identical tile.
    The main difference between the toroidal and tiled boundary conditions is that
    this Boids simulation won’t take place on a discrete grid; instead, the birds
    move over a continuous region. [Figure 5-2](nsp-venkitachalam503045-0017.xhtml#fig5-2)
    shows what those tiled boundary conditions look like.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 把Boid模拟想象成在瓷砖空间中进行：当一个Boid从一个瓷砖移出时，它会从对面方向进入一个相同的瓷砖。环形和瓷砖式边界条件的主要区别在于，这个Boid模拟不会发生在离散的网格上；相反，鸟儿在一个连续的区域上移动。[图
    5-2](nsp-venkitachalam503045-0017.xhtml#fig5-2)展示了这些瓷砖式边界条件的样子。
- en: '![](images/nsp-venkitachalam503045-f05002.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f05002.jpg)'
- en: 'Figure 5-2: Tiled boundary conditions'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '图 5-2: 瓷砖式边界条件'
- en: Look at the tile in the middle. The birds flying out to the right are entering
    the tile on the right, but the boundary conditions ensure that they actually come
    right back into the center tile through the tile at the left. You can see the
    same thing happening at the top and bottom tiles.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 看看中间的瓷砖。飞出右边的鸟进入了右边的瓷砖，但边界条件确保它们实际上从左边的瓷砖返回到中心瓷砖。你也可以在顶部和底部的瓷砖看到同样的情况。
- en: 'You implement the tiled boundary conditions for the Boids simulation as a method
    on the `Boids` class:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你在`Boids`类中实现了瓷砖式边界条件的方法，用于Boids模拟：
- en: 'def applyBC(self):'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 'def applyBC(self):'
- en: '"""apply boundary conditions"""'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '"""应用边界条件"""'
- en: deltaR = 2.0
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: deltaR = 2.0
- en: 'for coord in self.pos:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 'for coord in self.pos:'
- en: '❶ if coord[0] > width + deltaR:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '❶ if coord[0] > width + deltaR:'
- en: coord[0] = - deltaR
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: coord[0] = - deltaR
- en: 'if coord[0] < - deltaR:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 'if coord[0] < - deltaR:'
- en: coord[0] = width + deltaR
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: coord[0] = width + deltaR
- en: 'if coord[1] > height + deltaR:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 'if coord[1] > height + deltaR:'
- en: coord[1] = - deltaR
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: coord[1] = - deltaR
- en: 'if coord[1] < - deltaR:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 'if coord[1] < - deltaR:'
- en: coord[1] = height + deltaR
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: coord[1] = height + deltaR
- en: This method applies the tiled boundary conditions to each set of boid coordinates
    in the `pos` array. For example, if an x-coordinate is greater than the width
    of the window ❶, you set it back to the left edge of the window. The `deltaR`
    in this line provides a slight buffer, which allows the boid to move slightly
    outside the window before it starts coming back in from the opposite direction,
    thus producing a better visual effect. You perform a similar check at the left,
    top, and bottom edges of the window.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法将瓷砖式边界条件应用于`pos`数组中每组Boid坐标。例如，如果x坐标大于窗口的宽度 ❶，你将其设置回窗口的左边缘。该行中的`deltaR`提供了一个小的缓冲区，使得Boid可以在开始从相反方向返回之前稍微移出窗口，从而产生更好的视觉效果。你在窗口的左边、顶部和底部边缘也执行类似的检查。
- en: '[Drawing a Boid](nsp-venkitachalam503045-0008.xhtml#rbh0703)'
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[绘制Boid](nsp-venkitachalam503045-0008.xhtml#rbh0703)'
- en: To build the animation, you need to know each boid’s position and velocity and
    have a way to indicate both the position and direction of motion at each time
    step.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建动画，你需要知道每个Boid的位置和速度，并且在每个时间步长上都能够指示出位置和运动方向。
- en: Plotting the Boid’s Body and Head
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 绘制Boid的身体和头部
- en: To animate the boids, you use `matplotlib` and a little trick to plot both the
    position and velocity. Draw each boid as two circles, as shown in [Figure 5-3](nsp-venkitachalam503045-0017.xhtml#fig5-3).
    The larger circle represents the body, and the smaller one represents the head.
    Point *P* marks the center of the body. For our purposes, you can consider *P*
    to be the position of the boid, and you’ll set it using coordinates from the `pos`
    array discussed earlier. Point *H* is the center of the head. You calculate the
    position of *H* according to the formula *H* = *P* + *k* × *V*, where *V* is the
    velocity of the boid and *k* is a constant representing the distance from the
    center of the body to the center of the head. This way, the boid’s head will be
    aligned with its direction of motion at any given time, which visually communicates
    the boid’s direction of movement more clearly than just drawing the body alone.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使飞鸟动画生动起来，你使用 `matplotlib` 和一个小技巧来绘制飞鸟的位置和速度。将每个飞鸟绘制为两个圆圈，如[图 5-3](nsp-venkitachalam503045-0017.xhtml#fig5-3)所示。较大的圆圈代表身体，较小的圆圈代表头部。点
    *P* 标记身体的中心。对于我们的目的，你可以认为 *P* 是飞鸟的位置，并且你将使用之前讨论的 `pos` 数组中的坐标来设置它。点 *H* 是头部的中心。你根据公式
    *H* = *P* + *k* × *V* 计算 *H* 的位置，其中 *V* 是飞鸟的速度，*k* 是表示从身体中心到头部中心的距离的常数。这样，飞鸟的头部将在任何时刻与它的运动方向对齐，这比单纯绘制身体能更清楚地传达飞鸟的运动方向。
- en: '![](images/nsp-venkitachalam503045-f05003.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f05003.jpg)'
- en: 'Figure 5-3: Representing a boid'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-3：表示一个飞鸟
- en: 'In the following snippet from the program’s `main()` function, you draw the
    boid’s body and head as circular markers using `matplotlib`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下来自程序 `main()` 函数的代码片段中，你使用 `matplotlib` 将飞鸟的身体和头部绘制为圆形标记：
- en: fig = plt.figure()
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: fig = plt.figure()
- en: ax = plt.axes(xlim=(0, width), ylim=(0, height))
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ax = plt.axes(xlim=(0, width), ylim=(0, height))
- en: ❶ pts, = ax.plot([], [], markersize=10, c='k', marker='o', ls='None')
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ pts, = ax.plot([], [], markersize=10, c='k', marker='o', ls='None')
- en: ❷ head, = ax.plot([], [], markersize=4, c='r', marker='o', ls='None')
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ head, = ax.plot([], [], markersize=4, c='r', marker='o', ls='None')
- en: ❸ anim = animation.FuncAnimation(fig, tick, fargs=(pts[0], head, boids),
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ anim = animation.FuncAnimation(fig, tick, fargs=(pts[0], head, boids),
- en: interval=50)
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: interval=50)
- en: You set the size and shape of the markers for the boid’s body (`pts`) ❶ and
    head (`head`) ❷. The `'k'` and `'r'` strings specify the colors black and red,
    respectively, and `'o'` produces a circular marker. The `ax.plot()` method returns
    a list of `matplotlib.lines.Line2D` objects. The `,` syntax in these lines picks
    up the first and only element in this list.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你设置了飞鸟身体（`pts`）❶ 和头部（`head`）❷ 的标记大小和形状。`'k'` 和 `'r'` 字符串分别指定黑色和红色，`'o'` 生成圆形标记。`ax.plot()`
    方法返回一个 `matplotlib.lines.Line2D` 对象的列表。这些行中的 `,` 语法获取该列表中的第一个也是唯一一个元素。
- en: You next initialize a `matplotlib animation.FuncAnimation()` object ❸, which
    sets up a callback function `tick()` to be called for every frame of the animation
    (we’ll look at this function later in the chapter). The `fargs` parameter lets
    you specify the arguments of the callback function, and you also set the time
    interval (50 milliseconds in this case) at which this function will be called.
    Now that you know how to draw the body and the head, let’s see how to update their
    positions.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你初始化一个 `matplotlib animation.FuncAnimation()` 对象❸，它设置了一个回调函数 `tick()`，每帧动画都会调用该函数（我们稍后会详细讲解这个函数）。`fargs`
    参数让你指定回调函数的参数，你还可以设置该函数调用的时间间隔（此例为 50 毫秒）。现在你已经知道了如何绘制身体和头部，接下来我们来看如何更新它们的位置。
- en: Updating the Boid’s Position
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更新飞鸟的位置
- en: 'Once the animation starts, you need to update both the boid’s position and
    the location of the head, which tells you the direction in which the boid is moving.
    You do so with this code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 动画开始后，你需要更新飞鸟的身体位置和头部位置，头部位置告诉你飞鸟的运动方向。你可以使用以下代码实现：
- en: vec = self.pos + 10*self.vel/self.maxVel
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: vec = self.pos + 10*self.vel/self.maxVel
- en: head.set_data(vec.reshape(2*self.N)[::2], vec.reshape(2*self.N)[1::2])
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: head.set_data(vec.reshape(2*self.N)[::2], vec.reshape(2*self.N)[1::2])
- en: First you calculate the position of the head by applying the *H* = *P* + *k* × *V*
    formula discussed earlier. You use a *k* value of 10 units in the direction of
    the velocity (`vel`). You then update (`reshape`) the `matplotlib` axis (`set_data`)
    with the new values of the head position. The `[::2]` picks out the even-numbered
    elements (x-axis values) from the velocity list, and the `[1::2]` picks out the
    odd-numbered elements (y-axis values).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你通过应用前面讨论的*H* = *P* + *k* × *V* 公式来计算头部的位置。你使用一个* k *值为 10 个单位，方向与速度（`vel`）相同。然后，你用新的头部位置更新（`reshape`）`matplotlib`
    坐标轴（`set_data`）。`[::2]` 选取速度列表中的偶数索引元素（x轴值），而 `[1::2]` 选取奇数索引元素（y轴值）。
- en: '[Applying the Rules of the Boids](nsp-venkitachalam503045-0008.xhtml#rbh0704)'
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[应用 Boids 规则](nsp-venkitachalam503045-0008.xhtml#rbh0704)'
- en: 'In this section, we’ll look at how to implement the three rules of the Boids
    simulation—separation, alignment, and cohesion—to recalculate the boids’ velocities
    at each time step. We’ll start by focusing just on the separation rule. The goal
    is to generate a new velocity vector for each boid that pushes it away from its
    nearby flockmates, defined as all the boids within a certain radius *R*. Given
    two boids *i* and *j* with positions *P*[i] and *P*[j], *P*[i] − *P*[j] produces
    a new velocity vector for boid *i* that points away from boid *j*. We’ll call
    this a *displacement vector*. To calculate a new velocity vector *V*[i] for boid
    *i* that on average pushes it away from *all* its nearby flockmates, simply sum
    all the displacement vectors between boid *i* and each boid within radius *R*.
    In other words, *V*[i] = (*P*[i] − *P*[1]) + (*P*[i] − *P*[2]) + . . . (*P*[i]
    − *P*[N]), provided the distance between boids *i* and *j* is less than *R*. You
    can write this more formally as:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将讨论如何实现 Boids 仿真中的三条规则——分离、对齐和聚集——以在每个时间步重新计算 Boid 的速度。我们将首先专注于分离规则。目标是为每个
    Boid 生成一个新的速度向量，将它从附近的同伴推开，这些同伴定义为所有处于某个半径 *R* 内的 Boid。给定两个 Boid *i* 和 *j*，它们的位置分别是
    *P*[i] 和 *P*[j]，*P*[i] − *P*[j] 将为 Boid *i* 生成一个新的速度向量，使其远离 Boid *j*。我们称之为 *位移向量*。为了计算
    Boid *i* 的新速度向量 *V*[i]，它将平均地将其推离所有附近的同伴，只需将 Boid *i* 和半径 *R* 内的每个 Boid 之间的位移向量相加即可。换句话说，*V*[i]
    = (*P*[i] − *P*[1]) + (*P*[i] − *P*[2]) + . . . (*P*[i] − *P*[N])，前提是 Boid *i*
    和 Boid *j* 之间的距离小于 *R*。你可以更正式地写作：
- en: '![](images/nsp-venkitachalam503045-m05001.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-m05001.jpg)'
- en: Notice that implementing this rule—and, indeed, implementing the other Boids
    rules as well—involves calculating the distance between each boid and every other
    boid to determine which boids are local flockmates. The traditional way to do
    this in Python would be to use a pair of nested loops to iterate through the boids.
    As you’ll see, however, `numpy` arrays provide more efficient methods that bypass
    the need for loops. We’ll implement both approaches and compare the results and
    then apply what we’ve learned to the actual simulation code.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，实现这个规则——实际上，其他 Boids 规则的实现也是——涉及计算每个 Boid 与其他所有 Boid 之间的距离，以确定哪些 Boid 是局部的同伴。用传统的
    Python 方法，通常会使用一对嵌套循环来遍历 Boids。然而，正如你将看到的，`numpy` 数组提供了更高效的方法，可以避免使用循环。我们将实现这两种方法并比较结果，然后将我们学到的应用到实际的仿真代码中。
- en: Using Nested Loops
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用嵌套循环
- en: 'First, let’s define a function `test1()` that implements the separation rule
    in a straightforward way, using loops:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们定义一个函数`test1()`，它通过使用循环直接实现分离规则：
- en: 'def test1(pos, radius):'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 'def test1(pos, radius):'
- en: '# fill output with zeros'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '# 填充输出为零'
- en: vel = np.zeros(2*N).reshape(N, 2)
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: vel = np.zeros(2*N).reshape(N, 2)
- en: '# for each pos'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '# 针对每个位置'
- en: '❶ for (i1, p1) in enumerate(pos):'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '❶ for (i1, p1) in enumerate(pos):'
- en: '# velocity contribution'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '# 速度贡献'
- en: val = np.array([0.0, 0.0])
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: val = np.array([0.0, 0.0])
- en: '# for each other pos'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '# 针对其他位置'
- en: '❷ for (i2, p2) in enumerate(pos):'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '❷ for (i2, p2) in enumerate(pos):'
- en: 'if i1 != i2:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 'if i1 != i2:'
- en: '# calculate distance from p1'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '# 计算 p1 之间的距离'
- en: dist = math.sqrt((p2[0]-p1[0])*(p2[0]-p1[0]) +
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: dist = math.sqrt((p2[0]-p1[0])*(p2[0]-p1[0]) +
- en: (p2[1]-p1[1])*(p2[1]-p1[1]))
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: (p2[1]-p1[1])*(p2[1]-p1[1]))
- en: '# apply threshold'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '# 应用阈值'
- en: '❸ if dist < radius:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '❸ if dist < radius:'
- en: ❹ val += (p2 - p1)
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ val += (p2 - p1)
- en: '# set velocity'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置速度'
- en: vel[i1] = val
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: vel[i1] = val
- en: '# return computed velocity'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '# 返回计算的速度'
- en: return vel
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: return vel
- en: This code uses a nested pair of loops. The outer loop ❶ goes through each boid
    in the `pos` array. The inner loop ❷ computes the distance between the current
    boid and each other boid in the array. If the distance is less than the threshold
    defined as the function’s `radius` parameter ❸, you calculate the displacement
    vector as discussed earlier and add the result to `val` ❹. At the end of each
    cycle of the inner loop, `val` holds a new velocity that will push the current
    boid away from its neighbors. You store that velocity back in the `vel` array.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使用了一对嵌套的循环。外循环❶遍历`pos`数组中的每个boid。内循环❷计算当前boid与数组中每个其他boid之间的距离。如果距离小于作为函数`radius`参数定义的阈值❸，你就像之前讨论的那样计算位移向量，并将结果添加到`val`
    ❹。在每次内循环结束时，`val`保存了一个新的速度，它将推动当前boid远离邻居。你将这个速度存储回`vel`数组中。
- en: Using numpy Methods
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用numpy方法
- en: 'Now let’s define a function `test2()` that does the same thing “the `numpy`
    way,” avoiding loops and using highly optimized `numpy` methods. You’ll also use
    methods from the `scipy.spatial.distance` module to efficiently calculate the
    distance between points:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们定义一个函数`test2()`，它以“`numpy`方式”做同样的事情，避免使用循环，并利用高度优化的`numpy`方法。你还将使用`scipy.spatial.distance`模块中的方法来高效地计算点之间的距离：
- en: 'def test2(pos, radius):'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 'def test2(pos, radius):'
- en: '# get distance matrix'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '# 获取距离矩阵'
- en: ❶ distMatrix = squareform(pdist(pos))
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ distMatrix = squareform(pdist(pos))
- en: '# apply threshold'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '# 应用阈值'
- en: ❷ D = distMatrix < radius
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ D = distMatrix < radius
- en: '# compute velocity'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '# 计算速度'
- en: ❸ vel = pos*D.sum(axis=1).reshape(N, 1) - D.dot(pos)
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ vel = pos*D.sum(axis=1).reshape(N, 1) - D.dot(pos)
- en: return vel
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: return vel
- en: 'You use the `squareform()` and `pdist()` methods (defined in the `scipy` library)
    to calculate the distances between every possible pair of points in the `pos`
    array ❶. For an array of *N* points, `squareform()` gives you an *N*×*N* matrix,
    where any given entry *M*[ij] is the distance between points *P*[i] and *P*[j].
    Let’s consider a quick example of how that looks. In this code, you call the methods
    on an array of three points:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用了`squareform()`和`pdist()`方法（在`scipy`库中定义）来计算`pos`数组中每一对点之间的距离❶。对于一个*N*个点的数组，`squareform()`会给你一个*N*×*N*的矩阵，其中任意给定的条目*M*[ij]表示点*P*[i]和*P*[j]之间的距离。让我们通过一个快速示例来看看这种情况。在这段代码中，你对一个包含三个点的数组调用这些方法：
- en: '>>> `import numpy as np`'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> `import numpy as np`'
- en: '>>> `from scipy.spatial.distance import squareform, pdist`'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> `from scipy.spatial.distance import squareform, pdist`'
- en: '>>> `x = np.array([[0.0, 0.0], [1.0, 1.0], [2.0, 2.0]])`'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> `x = np.array([[0.0, 0.0], [1.0, 1.0], [2.0, 2.0]])`'
- en: '>>> `squareform(pdist(x))`'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> `squareform(pdist(x))`'
- en: array([[0.        , 1.41421356, 2.82842712],
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: array([[0.        , 1.41421356, 2.82842712],
- en: '[1.41421356, 0.        , 1.41421356],'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '[1.41421356, 0.        , 1.41421356],'
- en: '[2.82842712, 1.41421356, 0.        ]])'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '[2.82842712, 1.41421356, 0.        ]])'
- en: Since you provide an array of three points, the result is a 3×3 matrix of distance
    calculations. The values in the first row, for example, tell you the distance
    between the first point (`[0.0, 0.0]`) and each point in the array. The zeros
    running diagonally down the array correspond to the distance between each point
    and itself.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你提供了一个包含三个点的数组，结果是一个3×3的距离计算矩阵。例如，第一行中的值告诉你第一个点（`[0.0, 0.0]`）与数组中每个点之间的距离。数组中的对角线上的零值对应于每个点与自身的距离。
- en: 'Returning to the `test2()` function, you next filter the matrix based on whether
    the distance is less than the specified `radius` ❷. Using the same example array
    of three points, you have the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`test2()`函数，你接下来根据距离是否小于指定的`radius` ❷来过滤矩阵。使用相同的三个点的示例数组，你将得到以下结果：
- en: '>>> `squareform(``pdist(x)) < 1.4`'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> `squareform(``pdist(x)) < 1.4`'
- en: array([[ True, False, False],
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: array([[ True, False, False],
- en: '[False,  True, False],'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '[False,  True, False],'
- en: '[False, False,  True]])'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[False, False,  True]])'
- en: The `<` comparison creates a Boolean matrix of `True/False` values corresponding
    to the original distance matrix—`True` if a distance is less than the given threshold
    (in this example, 1.4).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`<` 比较生成了一个布尔矩阵，`True/False`值对应于原始的距离矩阵——如果距离小于给定的阈值（在这个示例中是1.4），则为`True`。'
- en: 'Back in `test2()`, you use a modified version of the equation for *V*[i] discussed
    earlier, broadcast over the entire `pos` array ❸. That equation can be rewritten
    as:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`test2()`，你使用了之前讨论的*V*[i]方程的修改版本，并广播到整个`pos`数组❸。这个方程可以重写为：
- en: '![](images/nsp-venkitachalam503045-m05002.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-m05002.jpg)'
- en: 'Here, the second summation term on the right includes only the points *P* that
    satisfy the distance criteria. The number of elements in the summation term is
    *m*. This equation can again be written as:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，右侧的第二个求和项只包括满足距离标准的*P*点。求和项中的元素数量是*m*。这个方程可以再次写作：
- en: '![](images/nsp-venkitachalam503045-m05003.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-m05003.jpg)'
- en: where *D*[ij] is row *i* of the Boolean matrix you generated ❷, *m* is the number
    of `True` values in that row, and *P*[j] is all the points *P* that fall within
    the specified radius of the current boid.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *D*[ij] 是你生成的布尔矩阵的第 *i* 行 ❷，*m* 是该行中 `True` 值的数量，而 *P*[j] 是所有位于当前鸟群指定半径内的
    *P* 点。
- en: The `D.sum` method ❸ adds up the `True` values in the Boolean matrix in a column-wise
    fashion, giving you *m* from the equation. The reshape is required because the
    result of the sum is a one-dimensional array of *N* values (shape (*N*, )), and
    you want it to be of shape (*N*, 1) so it’s compatible for multiplication with
    the position array. The `D.dot(pos)` part of the line ❸ is taking the dot product
    (multiplication) of the Boolean matrix and the array of boid positions, which
    corresponds to the *D*[ij]*P*[j] part of the equation.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`D.sum` 方法 ❸ 按列加总布尔矩阵中的 `True` 值，得到方程中的 *m*。 reshape 操作是必需的，因为求和的结果是一个包含 *N*
    个值的单维数组（形状为 (*N*, )），而你希望它具有形状 (*N*, 1)，以便与位置数组相乘。`D.dot(pos)` 这一行 ❸ 是将布尔矩阵与鸟群位置数组进行点积（乘法），这对应于方程中的
    *D*[ij]*P*[j] 部分。'
- en: Comparing Approaches
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 比较方法
- en: 'Comparing the two approaches, `test2()` is much more compact than `test1()`,
    but its real advantage is speed. Let’s use the Python `timeit` module to evaluate
    the performance of the two functions. First, enter the code for the functions
    `test1()` and `test2()` in a file named *test.py*, as shown here:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 比较这两种方法，`test2()` 比 `test1()` 更简洁，但它的真正优势在于速度。让我们使用 Python 的 `timeit` 模块来评估这两个函数的性能。首先，将
    `test1()` 和 `test2()` 函数的代码输入到一个名为 *test.py* 的文件中，如下所示：
- en: import math
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: import math
- en: import numpy as np
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: import numpy as np
- en: from scipy.spatial.distance import squareform, pdist, cdist
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: from scipy.spatial.distance import squareform, pdist, cdist
- en: N = 100
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: N = 100
- en: width, height = 640, 480
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: width, height = 640, 480
- en: pos = np.array(list(zip(width*np.random.rand(N), height*np.random.rand(N))))
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: pos = np.array(list(zip(width*np.random.rand(N), height*np.random.rand(N))))
- en: 'def test1(pos, radius):'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 'def test1(pos, radius):'
- en: --`snip`--
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: --`snip`--
- en: 'def test2(post, radius):'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 'def test2(post, radius):'
- en: --`snip`--
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: --`snip`--
- en: 'Now use the `timeit` module in a Python interpreter session to compare the
    performance of the two functions:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 Python 解释器会话中使用 `timeit` 模块比较这两个函数的性能：
- en: '>>> `from` `timeit import timeit`'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> `from` `timeit import timeit`'
- en: '>>> `timeit(''test1(pos, 100)'', ''from test import test1, N, pos, width, height'',
    number=100)`'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> `timeit(''test1(pos, 100)'', ''from test import test1, N, pos, width, height'',
    number=100)`'
- en: '7.880876064300537'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '7.880876064300537'
- en: '>>> `timeit(''test2(pos, 100)'', ''from test import test2, N, pos, width, height'',
    number=100)`'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> `timeit(''test2(pos, 100)'', ''from test import test2, N, pos, width, height'',
    number=100)`'
- en: '0.036969900131225586'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '0.036969900131225586'
- en: On my computer, the `numpy` code without loops runs about 200 times faster than
    the code that uses explicit loops! But why? Aren’t they both doing more or less
    the same thing?
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的计算机上，使用不带循环的 `numpy` 代码运行速度比使用显式循环的代码快大约 200 倍！但是，为什么呢？难道它们不做差不多相同的事情吗？
- en: As an interpreted language, Python is inherently slower than compiled languages
    like C. The `numpy` library brings the convenience of Python and performance nearly
    equal to that of C by providing highly optimized methods that operate on arrays
    of data. In general, you’ll find that `numpy` works best when you reorganize your
    algorithm as steps that operate on entire arrays at once, without looping through
    individual elements to perform computations.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种解释性语言，Python 本质上比像 C 这样的编译语言要慢。`numpy` 库通过提供高度优化的对数据数组进行操作的方法，将 Python 的便利性与几乎等同于
    C 的性能结合在一起。通常，你会发现 `numpy` 最适合将算法重构为一次操作整个数组的步骤，而不是逐个元素循环进行计算。
- en: Writing the Final Method
  id: totrans-183
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编写最终方法
- en: Now that you’ve compared the two approaches, you’re ready to use what you’ve
    learned to write a final version of the method that applies all three rules of
    the simulation and returns updated velocities for all the boids. The `applyRules()`
    method, part of the `Boids` class, uses the optimized `numpy` techniques discussed
    earlier.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经比较了这两种方法，你可以利用所学知识编写最终版本的方法，该方法应用模拟的所有三条规则，并返回所有鸟群的更新速度。`applyRules()`
    方法是 `Boids` 类的一部分，使用了之前讨论的优化 `numpy` 技术。
- en: 'def applyRules(self):'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 'def applyRules(self):'
- en: '# get pairwise distances'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '# 获取成对的距离'
- en: ❶ self.distMatrix = squareform(pdist(self.pos))
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ self.distMatrix = squareform(pdist(self.pos))
- en: '# apply rule #1: separation'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '# 应用规则 #1：分离'
- en: D = self.distMatrix < self.minDist
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: D = self.distMatrix < self.minDist
- en: ❷ vel = self.pos*D.sum(axis=1).reshape(self.N, 1) - D.dot(self.pos)
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ vel = self.pos*D.sum(axis=1).reshape(self.N, 1) - D.dot(self.pos)
- en: ❸ self.limit(vel, self.maxRuleVel)
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ self.limit(vel, self.maxRuleVel)
- en: '# distance threshold for alignment (different from separation)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '# 对齐的距离阈值（与分离不同）'
- en: ❹ D = self.distMatrix < 50.0
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ D = self.distMatrix < 50.0
- en: '# apply rule #2: alignment'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '# 应用规则 #2：对齐'
- en: ❺ vel2 = D.dot(self.vel)
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ vel2 = D.dot(self.vel)
- en: self.limit(vel2, self.maxRuleVel)
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: self.limit(vel2, self.maxRuleVel)
- en: ❻ vel += vel2
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ vel += vel2
- en: '# apply rule #3: cohesion'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '# 应用规则 #3：凝聚'
- en: ❼ vel3 = D.dot(self.pos) - self.pos
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ vel3 = D.dot(self.pos) - self.pos
- en: self.limit(vel3, self.maxRuleVel)
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: self.limit(vel3, self.maxRuleVel)
- en: ❽ vel += vel3
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ vel += vel3
- en: return vel
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: return vel
- en: You compute the pairwise distance matrix between the boids using the `squareform()`
    and `pdist()` methods from the `scipy` library, as discussed earlier ❶. When you
    apply the separation rule using `numpy` methods ❷, each boid is pushed away from
    neighboring boids within a distance of `minDist` (25 pixels). The calculated velocities
    are clamped, or restricted, to a certain maximum value using the `Boids` class’s
    `limit()` method ❸, which we’ll look at later. Without this restriction, the velocities
    would increase with each time step, and the simulation would go haywire.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用`scipy`库中的`squareform()`和`pdist()`方法计算鸟群之间的成对距离矩阵，如前所述❶。当你使用`numpy`方法❷应用分离规则时，每个鸟群都会被推离距离`minDist`（25像素）内的邻居。计算出的速度会被限制，或者说被约束在某个最大值内，使用的是`Boids`类中的`limit()`方法❸，我们稍后会讨论。如果没有这个限制，速度将在每个时间步长后增加，模拟就会失控。
- en: You next generate a new Boolean matrix using a distance threshold of 50 pixels
    rather than 25 ❹. You’ll use this broader definition of neighboring flockmates
    to apply the alignment and cohesion rules. The alignment rule is implemented so
    that each boid is influenced by and aligns itself with the average velocity of
    its neighbors. You get that average simply by taking the dot product of `D` (the
    Boolean matrix) and the velocity array ❺. Once again, you restrict the calculated
    velocities to a maximum so they don’t increase indefinitely. (Using the compact
    `numpy` syntax makes all these computations simple and fast.)
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你使用50像素的距离阈值生成一个新的布尔矩阵，而不是25像素❹。你将使用这个更广泛的邻近群体定义来应用对齐和凝聚规则。对齐规则的实现方式是每个鸟群（boid）都会受到其邻居的平均速度的影响，并与之对齐。你通过取`D`（布尔矩阵）和速度数组的点积❺来获得这个平均值。再一次，你限制计算出的速度，以防它们无限增长。（使用简洁的`numpy`语法使得所有这些计算变得简单且快速。）
- en: Finally, you apply the cohesion rule by adding the positions of all the neighboring
    boids and then subtracting the position of the current boid ❼. This produces a
    velocity vector for each boid that points to the *centroid* or geometric center
    of its neighbors. Again, you limit the velocities to keep them from getting out
    of control.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你通过将所有邻近鸟群的位置加在一起，然后减去当前鸟群的位置❼来应用凝聚规则。这会产生一个指向邻居的*质心*或几何中心的速度向量。再次强调，你限制了速度，以避免它们失控。
- en: Each of the three rules produces its own velocity vector for each boid. At ❻
    and ❽, you add these vectors together, producing an overall velocity vector for
    each boid that reflects the influence of all three simulation rules. You store
    the final velocity vectors in the `vel` array.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 三条规则中的每一条都会为每个鸟群生成一个自己的速度向量。在❻和❽处，你将这些向量加在一起，生成一个反映所有三条模拟规则影响的总体速度向量。你将最终的速度向量存储在`vel`数组中。
- en: Limiting the Velocities
  id: totrans-207
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 限制速度
- en: 'In the previous section, you saw how the `limit()` method was called after
    applying each rule to keep the boids’ velocities from getting out of control.
    Here’s that method:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一部分，你已经看到如何在应用每条规则后调用`limit()`方法，以防止鸟群的速度失控。下面是该方法：
- en: 'def limit(self, X, maxVal):'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 'def limit(self, X, maxVal):'
- en: '"""limit the magnitude of 2D vectors in array X to maxValue"""'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '"""限制数组X中2D向量的大小到最大值"""'
- en: '❶ for vec in X:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '❶ for vec in X:'
- en: self.limitVec(vec, maxVal)
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: self.limitVec(vec, maxVal)
- en: 'This method is designed to take in an array of velocity vectors, extract each
    individual vector ❶, and pass it along to the `limitVec()` method, which looks
    like this:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法设计用来接收一个速度向量数组，提取每个单独的向量❶，并将其传递给`limitVec()`方法，方法如下所示：
- en: 'def limitVec(self, vec, maxVal):'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 'def limitVec(self, vec, maxVal):'
- en: '"""limit the magnitude of the 2D vector"""'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '"""限制2D向量的大小"""'
- en: ❶ mag = norm(vec)
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ mag = norm(vec)
- en: 'if mag > maxVal:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 'if mag > maxVal:'
- en: ❷ vec[0], vec[1] = vec[0]*maxVal/mag, vec[1]*maxVal/mag
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ vec[0], vec[1] = vec[0]*maxVal/mag, vec[1]*maxVal/mag
- en: You use the `norm()` function from the `numpy` library to calculate the magnitude
    of the vector ❶. If it exceeds the maximum, you scale the x and y portions of
    the vector in proportion to the vector’s magnitude ❷. The maximum value was defined
    as `self.maxRuleVel = 0.03` as part of the initialization of the `Boids` class.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用来自`numpy`库的`norm()`函数来计算向量❶的大小。如果它超过了最大值，你会按向量的大小按比例缩放向量的 x 和 y 部分❷。最大值被定义为`self.maxRuleVel
    = 0.03`，这是`Boids`类初始化的一部分。
- en: '[Influencing the Simulation](nsp-venkitachalam503045-0008.xhtml#rbh0705)'
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[影响仿真](nsp-venkitachalam503045-0008.xhtml#rbh0705)'
- en: The core rules in the Boids simulation will cause the boids to automatically
    exhibit flocking behavior. But let’s make things more interesting by allowing
    the user to influence the simulation as it runs. Specifically, you’ll create the
    ability to add boids to the flock or make the flock scatter with the click of
    your mouse.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Boids 仿真中的核心规则将使 boid 自动展现出群体行为。但为了让事情更有趣，我们允许用户在仿真进行时影响它。具体来说，你将创建一种能力，可以通过鼠标点击向群体添加
    boid 或使群体散开。
- en: 'The first step to inject events into the simulation while it’s running is to
    add an *event handler* to the `matplotlib` canvas. This is a piece of code that
    calls a function every time a certain event, such as a mouse click, happens. Here’s
    how to do it:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 向正在运行的仿真注入事件的第一步是将一个*事件处理器*添加到`matplotlib`画布。它是一段代码，每次发生某个特定事件（如鼠标点击）时都会调用一个函数。以下是如何实现：
- en: cid = fig.canvas.mpl_connect('button_press_event', boids.buttonPress)
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: cid = fig.canvas.mpl_connect('button_press_event', boids.buttonPress)
- en: You use the `mpl_connect()` method to add a button press event handler to the
    `matplotlib` canvas. This handler will call the `buttonPress()` method of the
    `Boids` class every time a mouse button is pressed in the simulation window. Next,
    you need to define the `buttonPress()` method.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用`mpl_connect()`方法将一个按钮按下事件处理器添加到`matplotlib`画布上。每次在仿真窗口中按下鼠标按钮时，这个处理器都会调用`Boids`类的`buttonPress()`方法。接下来，你需要定义`buttonPress()`方法。
- en: Adding a Boid
  id: totrans-225
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加一个 Boid
- en: The first part of the `buttonPress()` method adds a boid to the simulation at the
    location of your cursor and assigns that boid a random velocity, when the *left*
    mouse button is pressed.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`buttonPress()`方法的第一部分是在左键按下时，在你的光标位置向仿真中添加一个 boid，并为该 boid 分配一个随机速度。'
- en: 'def buttonPress(self, event):'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 'def buttonPress(self, event):'
- en: '"""event handler for matplotlib button presses"""'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '"""matplotlib 按钮按下事件的事件处理器"""'
- en: left-click to add a boid
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 左键点击以添加一个 boid
- en: '❶ if event.button is 1:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如果 event.button 是 1：
- en: ❷ self.pos = np.concatenate((self.pos,
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ self.pos = np.concatenate((self.pos,
- en: np.array([[event.xdata, event.ydata]])),
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: np.array([[event.xdata, event.ydata]])),
- en: axis=0)
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: axis=0)
- en: '# generate a random velocity'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '# 生成一个随机速度'
- en: angles = 2*math.pi*np.random.rand(1)
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: angles = 2*math.pi*np.random.rand(1)
- en: v = np.array(list(zip(np.sin(angles), np.cos(angles))))
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: v = np.array(list(zip(np.sin(angles), np.cos(angles))))
- en: ❸ self.vel = np.concatenate((self.vel, v), axis=0)
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ self.vel = np.concatenate((self.vel, v), axis=0)
- en: ❹ self.N += 1
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ self.N += 1
- en: First you ensure that the mouse event is a left-click ❶. Then you append the
    mouse location given by (`event.xdata, event.ydata`) to the array of boid positions
    ❷. You also generate a random velocity vector, add it to the array of boid velocities
    ❸, and increment the count of boids by 1 ❹.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你确保鼠标事件是左键点击❶。然后，你将由（`event.xdata, event.ydata`）给出的鼠标位置添加到 boid 位置数组中❷。你还会生成一个随机速度向量，将其添加到
    boid 速度数组中❸，并将 boid 的数量加 1❹。
- en: Scattering the Boids
  id: totrans-240
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 散布 Boid
- en: 'The three simulation rules keep the boids in a flock as they move around. But
    what happens when the flock is disturbed? To simulate this situation, you can
    introduce a “scatter” effect: when you right-click in the simulation window, the
    flock will scatter from the location of the click. You can think of this as how
    the flock might respond to the sudden appearance of a predator or a loud noise
    that spooks the birds. You implement this effect as a continuation of the `buttonPress()`
    method:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 三个仿真规则保持 boid 们在同一个群体中随着它们的移动。但当群体受到干扰时会发生什么？为了模拟这种情况，你可以引入一个“散布”效果：当你在仿真窗口中右键点击时，群体会从点击位置散开。你可以把这想象成群体对捕食者突然出现或一声大响让鸟儿受惊的反应。你可以将此效果作为`buttonPress()`方法的延续来实现：
- en: '# right-click to scatter boids'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '# 右键点击以散布 boid'
- en: '❶ elif event.button is 3:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '❶ elif event.button is 3:'
- en: '# add scattering velocity'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '# 添加散布速度'
- en: self.vel += 0.1*(self.pos - np.array([[event.xdata, event.ydata]]))
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: self.vel += 0.1*(self.pos - np.array([[event.xdata, event.ydata]]))
- en: Here you check whether the mouse button press is a right-click event ❶. If so,
    you change the velocity for every boid by adding a vector that points away from
    the point where the disturbance arose (that is, where the mouse was clicked).
    You calculate this vector much like you calculated the displacement vectors for
    the separation rule. If *P*[i] is the position of a boid and *P*[m] is the point
    where the mouse was clicked, *P*[i] − *P*[m] is a vector that points away from
    the mouse click. You multiply this vector by `0.1` to keep the magnitude of the
    disturbance small. Initially, the boids will fly away from that point, but as
    you’ll see, the three rules prevail, and the boids will coalesce again as a flock.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这里你检查鼠标按键是否是右键点击事件 ❶。如果是，你通过添加一个指向扰动源（即鼠标点击的位置）的向量来改变每只鸟的速度。你计算这个向量的方法就像计算分离规则的位移向量一样。如果
    *P*[i] 是鸟群的位置，*P*[m] 是鼠标点击的点，*P*[i] − *P*[m] 就是指向鼠标点击位置的向量。你将这个向量乘以 `0.1` 来保持扰动的幅度较小。最初，鸟群会从那个点飞开，但正如你将看到的，三个规则最终会占主导，鸟群将再次聚集成群。
- en: '[Incrementing the Simulation](nsp-venkitachalam503045-0008.xhtml#rbh0706)'
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[递增仿真](nsp-venkitachalam503045-0008.xhtml#rbh0706)'
- en: At each time step in the simulation, you need to apply the rules to calculate
    the boids’ new velocities, update the boids’ positions based on those velocities,
    enforce the boundary conditions, and redraw everything in the display window.
    You can coordinate all this activity from the `tick()` function, which will be
    called at each frame of the `matplotlib` animation.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在仿真中的每个时间步骤，你需要应用规则来计算鸟群的新速度，基于这些速度更新鸟群的位置，执行边界条件，并在显示窗口中重新绘制所有内容。你可以通过 `tick()`
    函数来协调这一切活动，该函数将在每一帧的 `matplotlib` 动画中被调用。
- en: 'def tick(frameNum, pts, head, boids):'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 'def tick(frameNum, pts, head, boids):'
- en: '"""update function for animation"""'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '"""更新动画的函数"""'
- en: boids.tick(frameNum, pts, head)
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: boids.tick(frameNum, pts, head)
- en: return pts, head
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: return pts, head
- en: 'The stand-alone `tick()` function simply calls the `tick()` method of the `Boids`
    class. The latter is defined as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 独立的 `tick()` 函数仅仅调用了 `Boids` 类的 `tick()` 方法。后者定义如下：
- en: 'def tick(self, frameNum, pts, head):'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: def tick(self, frameNum, pts, head)
- en: '"""update the simulation by one time step"""'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '"""通过一个时间步骤更新仿真"""'
- en: '# apply rules'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '# 应用规则'
- en: ❶ self.vel += self.applyRules()
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ self.vel += self.applyRules()
- en: ❷ self.limit(self.vel, self.maxVel)
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ self.limit(self.vel, self.maxVel)
- en: ❸ self.pos += self.vel
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ self.pos += self.vel
- en: ❹ self.applyBC()
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ self.applyBC()
- en: '# update data'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '# 更新数据'
- en: ❺ pts.set_data(self.pos.reshape(2*self.N)[::2],
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ pts.set_data(self.pos.reshape(2*self.N)[::2],
- en: self.pos.reshape(2*self.N)[1::2])
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: self.pos.reshape(2*self.N)[1::2])
- en: ❻ vec = self.pos + 10*self.vel/self.maxVel
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ vec = self.pos + 10*self.vel/self.maxVel
- en: ❼ head.set_data(vec.reshape(2*self.N)[::2],
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ head.set_data(vec.reshape(2*self.N)[::2],
- en: vec.reshape(2*self.N)[1::2])
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: vec.reshape(2*self.N)[1::2])
- en: This method is where everything comes together. You apply the boid rules using
    the `applyRules()` method that we already looked at ❶. Then you limit the computed
    velocities of the boids using the `self.maxVel` threshold ❷. (Even though you
    limited the velocity vector generated by each individual rule, the overall velocity
    determined by adding all three rules together may still be too large.) You next
    compute the updated positions of the boids by adding the new velocity vectors
    to the old array of positions ❸. For example, if a boid was at position [0, 0]
    and has a velocity vector of [1, 1], its new position after one time step would
    be [1, 1]. You apply the boundary conditions for the simulation by calling `applyBC()`
    ❹.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法将一切结合在一起。你使用我们之前看过的 `applyRules()` 方法来应用鸟群规则 ❶。然后，你使用 `self.maxVel` 阈值限制计算得到的鸟群速度
    ❷。（即使你已经限制了每个单独规则生成的速度向量，通过将所有三个规则合成后的总体速度仍然可能太大。）接下来，你通过将新的速度向量加到旧的位置数组中来计算鸟群的更新位置
    ❸。例如，如果一只鸟的位置是 [0, 0]，速度向量是 [1, 1]，它经过一个时间步骤后的新位置将是 [1, 1]。你通过调用 `applyBC()` 来应用仿真的边界条件
    ❹。
- en: The call to `pts.set_data()` ❺ updates the `matplotlib` axis with the boids’
    new positions. The `[::2]` picks out the even-numbered elements (x-axis values)
    from the `pos` array, and the `[1::2]` picks out the odd-numbered elements (y-axis
    values). This will redraw the larger circles representing the boids’ bodies. Next,
    you need to draw the smaller circles representing the boids’ heads. You calculate
    the position of each boid’s head so it will point in the boid’s direction of motion
    by applying the *H* = *P* + *k* × *V* formula discussed earlier ❻. Recall that
    *P* is the center of a boid’s body, *k* is a constant representing the distance
    from the center of the body to the center of the head (you use a value of 10 units),
    and *V* is the boid’s velocity. Once you have the new head positions, you draw
    them via the same technique you used to draw the bodies ❼.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 对`pts.set_data()` ❺的调用会更新`matplotlib`轴，显示 boids 的新位置。`[::2]`选取`pos`数组中偶数编号的元素（x
    轴值），而`[1::2]`选取奇数编号的元素（y 轴值）。这将重新绘制表示 boids 身体的大圆圈。接下来，你需要绘制表示 boids 头部的小圆圈。你通过应用前面讨论过的
    *H* = *P* + *k* × *V* 公式来计算每个 boid 头部的位置，使其指向 boid 运动的方向 ❻。回想一下，*P* 是 boid 身体的中心，*k*
    是常数，表示从身体中心到头部中心的距离（你使用的值是 10 个单位），*V* 是 boid 的速度。得到了新的头部位置后，你通过与绘制身体相同的方法来绘制它们
    ❼。
- en: '[Parsing Arguments and Instantiating the Boids](nsp-venkitachalam503045-0008.xhtml#rbh0707)'
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[解析参数并实例化 Boids 类](nsp-venkitachalam503045-0008.xhtml#rbh0707)'
- en: 'The program’s `main()` function begins by handling command line arguments and
    instantiating the `Boids` class:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的`main()`函数首先处理命令行参数并实例化`Boids`类：
- en: 'def main():'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 'def main():'
- en: '# use sys.argv if needed'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '# 如有需要，使用 sys.argv'
- en: print('starting boids...')
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: print('正在启动 boids...')
- en: parser = argparse.ArgumentParser(description="Implementing Craig
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: parser = argparse.ArgumentParser(description="实现 Craig
- en: Reynolds's Boids...")
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: Reynolds 的 Boids..."
- en: '# add arguments'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '# 添加参数'
- en: ❶ parser.add_argument('--num-boids', dest='N', required=False)
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ parser.add_argument('--num-boids', dest='N', required=False)
- en: args = parser.parse_args()
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: args = parser.parse_args()
- en: '# set the initial number of boids'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置初始的 boids 数量'
- en: ❷ N = 100
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ N = 100
- en: 'if args.N:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 'if args.N:'
- en: N = int(args.N)
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: N = int(args.N)
- en: '# create boids'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '# 创建 boids'
- en: ❸ boids = Boids(N)
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ boids = Boids(N)
- en: You use the familiar `argparse` module to create a command line option for setting
    the initial number of boids in the simulation ❶. If no argument is provided at
    the command line, the simulation defaults to 100 boids ❷. You set the simulation
    in motion by creating an object of the `Boids` class ❸.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用熟悉的`argparse`模块来创建命令行选项，以设置模拟中 boids 的初始数量 ❶。如果命令行没有提供参数，模拟将默认为 100 个 boids
    ❷。你通过创建一个`Boids`类的对象来启动模拟 ❸。
- en: The `main()` function continues with the code to create and animate a `matplotlib`
    plot. We’ve already discussed this code in [“Plotting the Boid’s Body and Head”](nsp-venkitachalam503045-0017.xhtml#ch0701)
    on [page 84](nsp-venkitachalam503045-0017.xhtml#p84).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()`函数继续编写创建和动画化`matplotlib`图表的代码。我们已经在[“绘制 Boid 的身体和头部”](nsp-venkitachalam503045-0017.xhtml#ch0701)一节中讨论过这段代码，详见[第
    84 页](nsp-venkitachalam503045-0017.xhtml#p84)。'
- en: '[Running the Boids Simulation](nsp-venkitachalam503045-0008.xhtml#rah0704)'
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[运行 Boids 模拟](nsp-venkitachalam503045-0008.xhtml#rah0704)'
- en: 'Let’s see what happens when you run the simulation. Enter the following:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当你运行模拟时会发生什么。请输入以下内容：
- en: $ `python boids.py`
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: $ `python boids.py`
- en: The Boids simulation should start with all the boids clustered around the center
    of the window. Let the simulation run for a while, and the boids should start
    to flock as they form a pattern similar to the one shown in [Figure 5-4](nsp-venkitachalam503045-0017.xhtml#fig5-4).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: Boids 模拟应当从所有 boids 聚集在窗口中心开始。让模拟运行一段时间，boids 应该开始成群，并形成类似于[图 5-4](nsp-venkitachalam503045-0017.xhtml#fig5-4)所示的模式。
- en: '![](images/nsp-venkitachalam503045-f05004.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f05004.jpg)'
- en: 'Figure 5-4: A sample run of the Boids simulation'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-4：Boids 模拟的示例运行
- en: Left-click the simulation window. A new boid should appear at that location,
    and its velocity should change as it encounters the flock. Now right-click. The
    flock should initially scatter from your cursor but then recoalesce.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 左键单击模拟窗口。一个新的 boid 应该出现在那个位置，并且当它与鸟群相遇时，它的速度应该发生变化。现在右键单击。鸟群应该最初会从你的光标位置散开，然后再重新聚集。
- en: '[Summary](nsp-venkitachalam503045-0008.xhtml#rah0705)'
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[总结](nsp-venkitachalam503045-0008.xhtml#rah0705)'
- en: In this project, you simulated the flocking of birds (or boids) using the three
    rules proposed by Craig Reynolds. You looked at how operating on an entire `numpy`
    array at once is much faster than performing the same operations inside an explicit
    loop. You used the `scipy.spatial` module to perform fast and convenient distance
    calculations, and you implemented a `matplotlib` trick that uses two markers to
    represent both the position and the direction of points. Finally, you added interactivity
    to the simulation in the form of an event handler to respond to button presses
    within the `matplotlib` plot.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '在这个项目中，你使用 Craig Reynolds 提出的三个规则模拟了鸟群（或鸟群算法）的聚集行为。你观察到一次性操作整个 `numpy` 数组比在显式循环内执行相同的操作要快得多。你使用了
    `scipy.spatial` 模块来进行快速且便捷的距离计算，并实现了一个 `matplotlib` 技巧，使用两个标记来表示点的位置和方向。最后，你为仿真添加了交互性，作为事件处理程序响应
    `matplotlib` 图表中的按钮按下事件。  '
- en: '[Experiments!](nsp-venkitachalam503045-0008.xhtml#rah0706)'
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[实验！](nsp-venkitachalam503045-0008.xhtml#rah0706)  '
- en: 'Here are some ways you might further explore flocking behavior:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '下面是你可以进一步探索群体行为的一些方法：  '
- en: '1\. Implement obstacle avoidance for your flock of boids by writing a new method
    called `avoidObstacle()` and applying it right after you apply the three rules,
    as follows:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '1\. 通过编写一个名为`avoidObstacle()`的新方法，并在应用三个规则后立即应用它，来实现你群体中鸟群的避障功能，具体如下：  '
- en: self.vel += self.applyRules()
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'self.vel += self.applyRules()  '
- en: self.vel += self.avoidObstacle()
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: self.vel += self.avoidObstacle()
- en: The `avoidObstacle()` method should use a predefined tuple (*x*, *y*, *R*) to
    add an additional velocity term to a boid, pushing it away from the obstacle location
    (*x*, *y*), but only when the boid is within radius *R* of the obstacle. Think
    of this as the distance at which a boid sees the obstacle and steers away from
    it. You can specify the (*x*, *y*, *R*) tuple using a command line option.
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`avoidObstacle()` 方法应该使用预定义的元组 (*x*, *y*, *R*) 来为鸟群加上一个额外的速度项，将其从障碍物位置 (*x*,
    *y*) 推开，但只有在鸟群在障碍物半径 *R* 内时才生效。可以将其视为鸟群感知到障碍物并避开它的距离。你可以使用命令行选项来指定 (*x*, *y*,
    *R*) 元组。  '
- en: 2\. What happens when the boids fly through a strong gust of wind? Simulate
    this by adding a global velocity component to all the boids at random time steps
    in the simulation. The boids should temporarily be affected by the wind but return
    to the flock once the wind stops.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '2\. 当鸟群飞过强风时会发生什么？通过在仿真中的随机时间步骤为所有鸟群添加一个全局速度分量来模拟这一现象。鸟群应该暂时受到风的影响，但风停止后会返回到群体中。  '
- en: '[The Complete Code](nsp-venkitachalam503045-0008.xhtml#rah0707)'
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[完整代码](nsp-venkitachalam503045-0008.xhtml#rah0707)  '
- en: 'Here’s the complete code for the Boids simulation:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '这是Boids仿真的完整代码：  '
- en: '"""'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '"""  '
- en: boids.py
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 'boids.py  '
- en: An implementation of Craig Reynolds's Boids simulation.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 'Craig Reynolds 的 Boids 仿真实现。  '
- en: 'Author: Mahesh Venkitachalam'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '作者: Mahesh Venkitachalam  '
- en: '"""'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '"""  '
- en: import argparse
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 'import argparse  '
- en: import math
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 'import math  '
- en: import numpy as np
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 'import numpy as np  '
- en: import matplotlib.pyplot as plt
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 'import matplotlib.pyplot as plt  '
- en: import matplotlib.animation as animation
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 'import matplotlib.animation as animation  '
- en: from scipy.spatial.distance import squareform, pdist
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 'from scipy.spatial.distance import squareform, pdist  '
- en: from numpy.linalg import norm
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 'from numpy.linalg import norm  '
- en: width, height = 640, 480
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 'width, height = 640, 480  '
- en: 'class Boids:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Boids:  '
- en: '"""class that represents Boids simulation"""'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '"""表示Boids仿真的类"""  '
- en: 'def __init__(self, N):'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, N):  '
- en: '"""initialize the Boids simulation"""'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '"""初始化Boids仿真"""  '
- en: '# init position & velocities'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '# 初始化位置和速度  '
- en: self.pos = [width/2.0, height/2.0] +
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 'self.pos = [width/2.0, height/2.0] +  '
- en: 10*np.random.rand(2*N).reshape(N, 2)
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '10*np.random.rand(2*N).reshape(N, 2)  '
- en: '# normalized random velocities'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '# 标准化的随机速度  '
- en: angles = 2*math.pi*np.random.rand(N)
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 'angles = 2*math.pi*np.random.rand(N)  '
- en: self.vel = np.array(list(zip(np.cos(angles), np.sin(angles))))
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 'self.vel = np.array(list(zip(np.cos(angles), np.sin(angles))))  '
- en: self.N = N
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 'self.N = N  '
- en: '# min dist of approach'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '# 最小接近距离  '
- en: self.minDist = 25.0
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 'self.minDist = 25.0  '
- en: '# max magnitude of velocities calculated by "rules"'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '# 由“规则”计算的速度的最大大小  '
- en: self.maxRuleVel = 0.03
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 'self.maxRuleVel = 0.03  '
- en: '# max magnitude of final velocity'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '# 最终速度的最大大小  '
- en: self.maxVel = 2.0
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 'self.maxVel = 2.0  '
- en: 'def tick(self, frameNum, pts, head):'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 'def tick(self, frameNum, pts, head):  '
- en: '"""update the simulation by one time step"""'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '"""通过一个时间步长更新仿真"""  '
- en: '# apply rules'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '# 应用规则  '
- en: self.vel += self.applyRules()
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 'self.vel += self.applyRules()  '
- en: self.limit(self.vel, self.maxVel)
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 'self.limit(self.vel, self.maxVel)  '
- en: self.pos += self.vel
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 'self.pos += self.vel  '
- en: self.applyBC()
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 'self.applyBC()  '
- en: '# update data'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '# 更新数据  '
- en: pts.set_data(self.pos.reshape(2*self.N)[::2],
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 'pts.set_data(self.pos.reshape(2*self.N)[::2],  '
- en: self.pos.reshape(2*self.N)[1::2])
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 'self.pos.reshape(2*self.N)[1::2])  '
- en: vec = self.pos + 10*self.vel/self.maxVel
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 'vec = self.pos + 10*self.vel/self.maxVel  '
- en: head.set_data(vec.reshape(2*self.N)[::2],
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 'head.set_data(vec.reshape(2*self.N)[::2],  '
- en: vec.reshape(2*self.N)[1::2])
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: vec.reshape(2*self.N)[1::2])
- en: 'def limitVec(self, vec, maxVal):'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 'def limitVec(self, vec, maxVal):'
- en: '"""limit magnitude of 2D vector"""'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '"""限制 2D 向量的大小"""'
- en: mag = norm(vec)
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: mag = norm(vec)
- en: 'if mag > maxVal:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 'if mag > maxVal:'
- en: vec[0], vec[1] = vec[0]*maxVal/mag, vec[1]*maxVal/mag
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: vec[0], vec[1] = vec[0]*maxVal/mag, vec[1]*maxVal/mag
- en: 'def limit(self, X, maxVal):'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 'def limit(self, X, maxVal):'
- en: '"""limit magnitude of 2D vectors in array X to maxValue"""'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '"""限制数组 X 中 2D 向量的大小为 maxValue"""'
- en: 'for vec in X:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 'for vec in X:'
- en: self.limitVec(vec, maxVal)
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: self.limitVec(vec, maxVal)
- en: 'def applyBC(self):'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 'def applyBC(self):'
- en: '"""apply boundary conditions"""'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '"""应用边界条件"""'
- en: deltaR = 2.0
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: deltaR = 2.0
- en: 'for coord in self.pos:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 'for coord in self.pos:'
- en: 'if coord[0] > width + deltaR:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 'if coord[0] > width + deltaR:'
- en: coord[0] = - deltaR
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: coord[0] = - deltaR
- en: 'if coord[0] < - deltaR:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 'if coord[0] < - deltaR:'
- en: coord[0] = width + deltaR
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: coord[0] = width + deltaR
- en: 'if coord[1] > height + deltaR:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 'if coord[1] > height + deltaR:'
- en: coord[1] = - deltaR
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: coord[1] = - deltaR
- en: 'if coord[1] < - deltaR:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 'if coord[1] < - deltaR:'
- en: coord[1] = height + deltaR
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: coord[1] = height + deltaR
- en: 'def applyRules(self):'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 'def applyRules(self):'
- en: '# get pairwise distances'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '# 获取成对的距离'
- en: self.distMatrix = squareform(pdist(self.pos))
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: self.distMatrix = squareform(pdist(self.pos))
- en: '# apply rule #1 - separation'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '# 应用规则 #1 - 分离'
- en: D = self.distMatrix < self.minDist
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: D = self.distMatrix < self.minDist
- en: vel = self.pos*D.sum(axis=1).reshape(self.N, 1) - D.dot(self.pos)
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: vel = self.pos*D.sum(axis=1).reshape(self.N, 1) - D.dot(self.pos)
- en: self.limit(vel, self.maxRuleVel)
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: self.limit(vel, self.maxRuleVel)
- en: '# different distance threshold'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '# 不同的距离阈值'
- en: D = self.distMatrix < 50.0
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: D = self.distMatrix < 50.0
- en: '# apply rule #2 - alignment'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '# 应用规则 #2 - 对齐'
- en: vel2 = D.dot(self.vel)
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: vel2 = D.dot(self.vel)
- en: self.limit(vel2, self.maxRuleVel)
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: self.limit(vel2, self.maxRuleVel)
- en: vel += vel2;
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: vel += vel2;
- en: '# apply rule #1 - cohesion'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '# 应用规则 #1 - 凝聚力'
- en: vel3 = D.dot(self.pos) - self.pos
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: vel3 = D.dot(self.pos) - self.pos
- en: self.limit(vel3, self.maxRuleVel)
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: self.limit(vel3, self.maxRuleVel)
- en: vel += vel3
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: vel += vel3
- en: return vel
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: return vel
- en: 'def buttonPress(self, event):'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 'def buttonPress(self, event):'
- en: '"""event handler for matplotlib button presses"""'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '"""matplotlib 按钮点击事件处理程序"""'
- en: '# left-click - add a boid'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '# 左键点击 - 添加一个个体'
- en: 'if event.button == 1:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 'if event.button == 1:'
- en: self.pos = np.concatenate((self.pos,
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: self.pos = np.concatenate((self.pos,
- en: np.array([[event.xdata, event.ydata]])),
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: np.array([[event.xdata, event.ydata]])),
- en: axis=0)
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: axis=0)
- en: '# random velocity'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '# 随机速度'
- en: angles = 2*math.pi*np.random.rand(1)
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: angles = 2*math.pi*np.random.rand(1)
- en: v = np.array(list(zip(np.sin(angles), np.cos(angles))))
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: v = np.array(list(zip(np.sin(angles), np.cos(angles))))
- en: self.vel = np.concatenate((self.vel, v), axis=0)
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: self.vel = np.concatenate((self.vel, v), axis=0)
- en: self.N += 1
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: self.N += 1
- en: '# right-click - scatter'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '# 右键点击 - 散布'
- en: 'elif event.button == 3:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif event.button == 3:'
- en: '# add scattering velocity'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '# 添加散布速度'
- en: self.vel += 0.1*(self.pos - np.array([[event.xdata, event.ydata]]))
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: self.vel += 0.1*(self.pos - np.array([[event.xdata, event.ydata]]))
- en: 'def tick(frameNum, pts, head, boids):'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 'def tick(frameNum, pts, head, boids):'
- en: '"""update function for animation"""'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '"""动画更新函数"""'
- en: boids.tick(frameNum, pts, head)
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: boids.tick(frameNum, pts, head)
- en: return pts, head
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: return pts, head
- en: main() function
  id: totrans-407
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: main() 函数
- en: 'def main():'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 'def main():'
- en: '# use sys.argv if needed'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '# 如果需要，使用 sys.argv'
- en: print('starting boids...')
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: print('启动群体...')
- en: parser = argparse.ArgumentParser(description=
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: parser = argparse.ArgumentParser(description=
- en: '"Implementing Craig Reynolds''s Boids...")'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '"实现 Craig Reynolds 的群体模型..."'
- en: '# add arguments'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '# 添加参数'
- en: parser.add_argument('--num-boids', dest='N', required=False)
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: parser.add_argument('--num-boids', dest='N', required=False)
- en: args = parser.parse_args()
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: args = parser.parse_args()
- en: '# number of boids'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '# 群体数量'
- en: N = 100
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: N = 100
- en: 'if args.N:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 'if args.N:'
- en: N = int(args.N)
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: N = int(args.N)
- en: '# create boids'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '# 创建群体'
- en: boids = Boids(N)
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: boids = Boids(N)
- en: '# setup plot'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置图表'
- en: fig = plt.figure()
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: fig = plt.figure()
- en: ax = plt.axes(xlim=(0, width), ylim=(0, height))
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: ax = plt.axes(xlim=(0, width), ylim=(0, height))
- en: pts = ax.plot([], [], markersize=10,
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: pts = ax.plot([], [], markersize=10,
- en: c='k', marker='o', ls='None')
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: c='k', marker='o', ls='None')
- en: head, = ax.plot([], [], markersize=4,
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: head, = ax.plot([], [], markersize=4,
- en: c='r', marker='o', ls='None')
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: c='r', marker='o', ls='None')
- en: anim = animation.FuncAnimation(fig, tick, fargs=(pts[0], head, boids),
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: anim = animation.FuncAnimation(fig, tick, fargs=(pts[0], head, boids),
- en: interval=50)
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: interval=50)
- en: '# add a "button press" event handler'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '# 添加“按钮按下”事件处理程序'
- en: cid = fig.canvas.mpl_connect('button_press_event', boids.buttonPress)
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: cid = fig.canvas.mpl_connect('button_press_event', boids.buttonPress)
- en: plt.show()
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: plt.show()
- en: call main
  id: totrans-434
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: call main
- en: 'if __name__ == ''__main__'':'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: main()
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: main()
