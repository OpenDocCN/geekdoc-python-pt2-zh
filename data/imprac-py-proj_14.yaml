- en: '**14'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**14'
- en: MAPPING MARS WITH THE MARS ORBITER**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 用*火星轨道探测器*绘制火星地图**
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: The *Mars Orbiter* space probe has been successfully injected into Martian orbit,
    but all is not well. The orbit is highly elliptical, and the project’s mapping
    objectives require a low-altitude circular orbit. Fortunately, there’s just enough
    propellant on board to correct things, assuming the eggheads at Mission Control
    have the patience and skill to pull it off!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*火星轨道探测器*已经成功进入火星轨道，但情况并不理想。轨道非常椭圆，而该项目的地图绘制目标要求低高度的圆形轨道。幸运的是，探测器上有足够的推进剂来进行轨道修正，前提是任务控制中心的专家们有耐心和技能来完成这项工作！'
- en: In this chapter, you’ll design and build a game based on this scenario. You’ll
    use pygame again (for an overview of pygame, see “[A Slice of pygame](ch13.xhtml#lev296)”
    on [page 267](ch13.xhtml#page_267)), and you’ll do your part to advance STEM (science,
    technology, engineering, and mathematics) education by making the game real enough
    to teach players the fundamentals of orbital mechanics.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你将基于这个情景设计和构建一个游戏。你将再次使用pygame（关于pygame的概述，请参阅[《pygame概述》](ch13.xhtml#lev296)，见[第267页](ch13.xhtml#page_267)），并通过使游戏足够逼真来推动STEM（科学、技术、工程和数学）教育，教会玩家轨道力学的基础。
- en: '**NOTE**'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Although they share the same name, the* Mars Orbiter *space probe in the game
    bears no direct relationship to the* Mars Orbiter Mission *launched by the* Indian
    Space Research Organization (ISRO) *in 2014\. The game probe is patterned after
    the* Mars Global Surveyor*, launched by NASA in 1996.*'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*尽管它们共享相同的名称，游戏中的*火星轨道探测器*与2014年由*印度空间研究组织（ISRO）*发射的*火星轨道任务*没有直接关系。游戏中的探测器是仿照1996年由NASA发射的*火星全球勘测者*设计的。*'
- en: '**Astrodynamics for Gamers**'
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**游戏中的天体动力学**'
- en: Because you’ll want your game to be as realistic as possible, a quick review
    of some of the basic science underlying spaceflight is in order. This will be
    short, sweet, and tailored to game development and play.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你希望你的游戏尽可能逼真，所以有必要快速回顾一下航天飞行的基本科学。这将简短、精炼，并且与游戏开发和游戏玩法密切相关。
- en: '***The Law of Universal Gravity***'
  id: totrans-9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***万有引力定律***'
- en: 'The theory of gravity states that massive objects—like stars and planets—warp
    both space and time around them, similar to how a heavy bowling ball placed on
    a mattress causes a depression that is sudden and sharp near the ball but quickly
    levels off. This behavior is captured mathematically by Isaac Newton’s law of
    universal gravitation:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 万有引力理论认为，像恒星和行星这样的大质量物体会扭曲它们周围的时空，类似于将一个沉重的保龄球放在床垫上，床垫会在球附近产生一个突然而深的凹陷，但凹陷会迅速平坦化。这种行为由艾萨克·牛顿的万有引力定律数学化描述：
- en: '![image](../images/f0286-01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0286-01.jpg)'
- en: where *F* is the force of gravity, *m*[1] is the mass of object 1, *m*[2] is
    the mass of object 2, *d* is the distance between objects, and *G* is the gravitational
    constant (6.674 × 10^(–11) *N* · *m*² · kg^(–2)).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*F*是引力，*m*[1]是物体1的质量，*m*[2]是物体2的质量，*d*是物体之间的距离，*G*是引力常数（6.674 × 10^(–11) *N*
    · *m*² · kg^(–2)）。
- en: Two objects pull on each other according to the product of their masses divided
    by the square of the distance between them. So, gravity is much stronger when
    objects are close together, like the deep bowing of the mattress just beneath
    the bowling ball. To illustrate, a 220-pound (100 kg) man would weigh over half
    a pound less on top of Mt. Everest than he would at sea level, where he would
    be 8,848 m closer to the center of Earth. (This assumes the mass of the planet
    is 5.98 × 10^(24) kg and sea level is 6.37 × 10⁶ m from the center.)
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 两个物体会根据它们的质量乘积与它们之间距离的平方之比相互作用。因此，当物体靠得很近时，引力会更强，就像保龄球下方床垫的深凹。举个例子，一个220磅（100公斤）的人在珠穆朗玛峰上的体重比在海平面时轻半磅多，因为他距离地球中心近了8,848米。（假设地球的质量为5.98
    × 10^(24)公斤，海平面距离地球中心为6.37 × 10⁶米。）
- en: Today, we generally think of gravity as a *field*—like the mattress in the bowling
    ball analogy—rather than as Newton’s point of attraction. This field is still
    defined with Newton’s law and results in *acceleration*, usually expressed in
    m/sec².
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，我们通常将引力视为一个*场*—就像保龄球床垫类比中的床垫—而不是牛顿的吸引点。这个场仍然用牛顿定律定义，并导致*加速度*，通常以米/秒²表示。
- en: 'According to Newton’s second law of motion, force is equal to mass × acceleration.
    You can calculate the force exerted by object 1 (*m*[1]) on object 2 (*m*[2])
    by rewriting the gravitational equation as:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 根据牛顿的第二运动定律，力等于质量×加速度。你可以通过将引力方程改写为以下形式，来计算物体1（*m*[1]）对物体2（*m*[2]）施加的力：
- en: '![image](../images/f0286-02.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0286-02.jpg)'
- en: where *a* = acceleration, *G* is the gravitational constant, *m*[1] is the mass
    of one of the objects, and *d* is the distance between objects. The direction
    of force is from object 2 toward the center of mass of object 1 (*m*[1]).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *a* = 加速度，*G* 是引力常数，*m*[1] 是其中一个物体的质量，*d* 是物体之间的距离。力的方向是从物体 2 指向物体 1 的质心（*m*[1]）。
- en: The pull of very small objects on large ones is generally ignored. For example,
    the force exerted by a 1,000 kg satellite on Mars is about 1.6 × 10^(–21) times
    smaller than the force exerted by Mars on the satellite! Thus, you can safely
    ignore the satellite’s mass in your simulation.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 小物体对大物体的引力通常被忽略。例如，一个质量为 1000 千克的卫星对火星施加的引力约为火星对卫星施加引力的 1.6 × 10^(–21) 倍！因此，在你的模拟中，你可以安全地忽略卫星的质量。
- en: '**NOTE**'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*As a simplification in this project, distance is calculated from the center
    points of objects. In real life, an orbiting satellite would experience subtle
    changes in gravitational acceleration due to changes in a planet’s shape, topography,
    crustal density, and so on. According to the* Encyclopedia Britannica*, these
    changes cause gravitational acceleration at Earth’s surface to vary by about 0.5
    percent.*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*作为本项目的简化，距离是从物体的质心计算的。在现实中，绕行卫星会由于行星的形状、地形、地壳密度等变化而经历微妙的引力加速度变化。根据* 《大英百科全书》*，这些变化导致地球表面的引力加速度变化约为
    0.5%。*'
- en: '***Kepler’s Laws of Planetary Motion***'
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***开普勒行星运动定律***'
- en: In 1609, astronomer Johann Kepler discovered that planetary orbits are ellipses,
    allowing him to explain and predict the motion of the planets. He also found that
    a line segment drawn between the sun and an orbiting planet sweeps out equal areas
    in equal time intervals. This idea, known as Kepler’s second law of planetary
    motion, is demonstrated in [Figure 14-1](ch14.xhtml#ch14fig1), where a planet
    is shown at different points in its orbit.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 1609 年，天文学家约翰·开普勒发现行星的轨道是椭圆形的，这使他能够解释和预测行星的运动。他还发现，太阳与绕行行星之间画出的线段在相等的时间间隔内扫过相等的面积。这一观点被称为开普勒行星运动第二定律，示意图在
    [图 14-1](ch14.xhtml#ch14fig1) 中展示，其中展示了行星在其轨道上的不同位置。
- en: '![image](../images/f0287-01.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0287-01.jpg)'
- en: '*Figure 14-1: Kepler’s second law of planetary motion: orbital speed increases
    as planets near the sun.*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-1：开普勒行星运动第二定律：行星靠近太阳时轨道速度增加。*'
- en: This law applies to all celestial bodies, and it means that an orbiting object
    speeds up as it gets close to the body it is orbiting and slows down as it travels
    farther away.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这一定律适用于所有天体，这意味着当绕行一个天体时，物体会在接近该天体时加速，而在远离时减速。
- en: '***Orbital Mechanics***'
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***轨道力学***'
- en: Orbiting is basically free-falling forever. You’re falling into the core of
    a planet’s gravity well—located at its literal core—but your tangential velocity
    is fast enough that you keep missing the planet (see [Figure 14-2](ch14.xhtml#ch14fig2)).
    As long as you balance your momentum with the force of gravity, the orbit will
    never end.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 绕行基本上是永远自由下落。你正在掉入一个行星的引力井——位于它的核心——但是你的切向速度足够快，以至于你不断错过行星（参见 [图 14-2](ch14.xhtml#ch14fig2)）。只要你平衡好你的动量和引力，轨道将永远不会结束。
- en: '![image](../images/f0288-01.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0288-01.jpg)'
- en: '*Figure 14-2: Orbit is achieved when a spacecraft’s velocity keeps it “free-falling”
    around a celestial body.*'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-2：当航天器的速度使其“自由下落”绕行天体时，便达成了轨道。*'
- en: Some counterintuitive things can happen when you orbit a planet in the vacuum
    of space. With no friction or wind resistance, spacecraft can behave in unexpected
    ways.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在太空的真空中绕行一个行星时，有些反直觉的现象可能发生。由于没有摩擦或风阻，航天器可能会表现出意想不到的方式。
- en: '**Flying Backward**'
  id: totrans-31
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**向后飞行**'
- en: If you’ve ever watched an episode of *Star Trek*, you’ve probably noticed how
    the orbiting *Enterprise* seems to steer its way around planets, like a car going
    around a track. This is certainly possible to do—and definitely looks cool—but
    it requires the expenditure of precious fuel. If there’s no need to continuously
    point a specific part of a spacecraft at a planet, then the nose of the spacecraft
    will always point in the same direction throughout its orbit. As a result, there
    will be times in each orbit when it appears to fly backward (see [Figure 14-3](ch14.xhtml#ch14fig3)).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾看过《星际迷航》的一集，可能注意到环绕行星的*企业号*似乎像汽车绕过赛道一样，巧妙地绕过行星。这种做法确实是可能的——而且看起来也非常酷——但这需要消耗宝贵的燃料。如果没有必要让航天器的某一特定部分持续对准行星，那么航天器的鼻部就会始终指向同一方向，直到完成整个轨道。因此，在每次轨道运动中，航天器会有一些时刻看起来像是飞向相反方向（参见[图14-3](ch14.xhtml#ch14fig3)）。
- en: '![image](../images/f0288-02.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0288-02.jpg)'
- en: '*Figure 14-3: Spacecraft retain the same attitude in orbit unless forced to
    do otherwise.*'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-3：航天器在轨道中保持相同的姿态，除非被强制改变。*'
- en: You can blame this on Newton and his law of inertia, which states that an object
    at rest stays at rest and an object in motion stays in motion with the same speed
    and in the same direction unless acted upon by an unbalanced force.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这归咎于牛顿及其惯性定律，该定律表明，静止的物体会保持静止，运动的物体会以相同的速度和方向保持运动，除非受到不平衡的外力作用。
- en: '**Raising and Lowering Orbits**'
  id: totrans-36
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**提升和降低轨道**'
- en: Brakes don’t work in space, there’s no friction, and inertia takes itself very
    seriously. To lower a spacecraft’s orbit, you have to fire thrusters to reduce
    its velocity so that it falls farther into a planet’s gravity well. To accomplish
    this, you have to *retrograde* your spacecraft so that its nose faces away from
    the present velocity vector—a fancy way of saying you have to fly tail-first.
    This assumes, of course, that the main thrusters are at the back of the spacecraft.
    Conversely, if you want to raise the orbit, you have to *prograde* the spacecraft,
    so that its nose will be pointed in the direction you are traveling. These two
    concepts are shown in [Figure 14-4](ch14.xhtml#ch14fig4).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在太空中刹车是行不通的，因为没有摩擦力，惯性可是很强大的。要降低航天器的轨道，你必须使用推进器减速，让航天器进一步掉入行星的引力坑。为了做到这一点，你必须让航天器*逆行*，使其鼻部朝向与当前速度向量相反的方向——简而言之，你得让航天器尾部朝前飞行。当然，这假设主推进器位于航天器的尾部。相反，如果你想提升轨道，你就必须*顺行*航天器，使其鼻部朝向你旅行的方向。这两个概念在[图14-4](ch14.xhtml#ch14fig4)中展示。
- en: '![image](../images/f0289-01.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0289-01.jpg)'
- en: '*Figure 14-4: Prograde and retrograde are defined by the orientation of a spacecraft’s
    nose with respect to the direction it is traveling around the body it is orbiting.*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-4：顺行与逆行是通过航天器的鼻部相对于其绕行天体的运动方向来定义的。*'
- en: '**Taking the Inside Track**'
  id: totrans-40
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**采取内侧轨道**'
- en: If you’re chasing another spacecraft in orbit, do you speed up or slow down
    to catch it? According to Kepler’s second law, you slow down. This will lower
    your orbit, resulting in a faster orbital velocity. Just as in horse racing, you
    want to take the inside track.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在追赶一艘在轨道上的航天器，你是加速还是减速来追上它？根据开普勒的第二定律，你应该减速。这会降低你的轨道，导致更快的轨道速度。就像赛马一样，你想要采取内侧轨道。
- en: On the left side of [Figure 14-5](ch14.xhtml#ch14fig5), two space shuttles are
    side by side in essentially the same orbit, traveling at the same velocity.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图14-5](ch14.xhtml#ch14fig5)的左侧，两架航天飞机并排处于几乎相同的轨道上，且以相同的速度飞行。
- en: '![image](../images/f0289-02.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0289-02.jpg)'
- en: '*Figure 14-5: The orbital paradox: slow down to speed up!*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-5：轨道悖论：减速以加速！*'
- en: The shuttle closest to the planet rotates 180 degrees and does a retrograde
    thrust to slow its immediate velocity. The outer shuttle performs a prograde thrust
    that increases its immediate velocity. They simultaneously stop thrusting, and
    the inner shuttle drops to a lower orbit while the outer shuttle transfers to
    a higher orbit. After an hour or so, the inner shuttle is traveling much faster,
    due to its closer proximity to the planet, and is well on its way to catch and
    lap the outer shuttle.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 靠近行星的航天飞机旋转180度，进行逆行推力以减缓其瞬时速度。外侧的航天飞机则进行顺行推力，以增加其瞬时速度。它们同时停止推力，内侧的航天飞机下降到更低的轨道，而外侧的航天飞机转入更高的轨道。大约一个小时后，由于内侧航天飞机距离行星更近，其速度大大加快，并成功赶超并超过外侧航天飞机。
- en: '**Circularizing an Elliptical Orbit**'
  id: totrans-46
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**圆形化椭圆轨道**'
- en: You can make highly elliptical orbits circular by applying engine impulses at
    either the *apoapsis* or *periapsis*, depending on the situation. The apoapsis
    (called the *apogee* if the object is orbiting Earth) is the highest point in
    an elliptical orbit—the point where the object is the farthest away from the body
    it is orbiting ([Figure 14-6](ch14.xhtml#ch14fig6)). The periapsis (*perigee*
    if the object’s orbiting Earth) is the point lowest in an orbit.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在*远地点*或*近地点*施加发动机脉冲，将高度椭圆轨道转为圆形轨道，这取决于具体情况。远地点（如果物体绕地球运行，则称为*远地点*）是椭圆轨道中最高的点——即物体距离其轨道中心最远的点（见[图14-6](ch14.xhtml#ch14fig6)）。近地点（如果物体绕地球运行，则称为*近地点*）是轨道中最低的点。
- en: '![image](../images/f0290-01.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0290-01.jpg)'
- en: '*Figure 14-6: Location of the apoapsis and periapsis in an elliptical orbit*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-6：椭圆轨道中远地点和近地点的位置*'
- en: To raise the periapsis, the spacecraft performs a prograde thrust at the apoapsis
    (see the left-hand side of [Figure 14-7](ch14.xhtml#ch14fig7)). To lower the orbit
    while circularizing, the spacecraft must perform a retrograde thrust at the periapsis
    (see the right-hand side of [Figure 14-7](ch14.xhtml#ch14fig7)).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要升高近地点，宇航器在远地点执行顺行推力（参见[图14-7](ch14.xhtml#ch14fig7)左侧）。为了在环形化的同时降低轨道，宇航器必须在近地点执行逆行推力（参见[图14-7](ch14.xhtml#ch14fig7)右侧）。
- en: A somewhat counterintuitive part of this maneuver is that the initial orbit—that’s
    the orbit that would have been—and the final, or actual, orbit will coincide at
    the point the engine impulse was applied.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作中一个有些反直觉的部分是，初始轨道——即原本会存在的轨道——与最终轨道（实际轨道）会在发动机脉冲施加的点相交。
- en: '![image](../images/f0290-02.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0290-02.jpg)'
- en: '*Figure 14-7: Circularizing and raising an orbit at apoapsis (left) and circularizing
    and lowering an orbit at periapsis (right)*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-7：在远地点升高并环形化轨道（左）与在近地点降低并环形化轨道（右）*'
- en: '**Raising and Lowering Orbits with the Hohmann Transfer**'
  id: totrans-54
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用霍曼转移轨道升高和降低轨道**'
- en: A *Hohmann transfer orbit* uses an elliptical orbit to switch between two circular
    orbits in the same plane (see [Figure 14-8](ch14.xhtml#ch14fig8)). The orbit can
    be either raised or lowered. The maneuver is relatively slow, but it consumes
    the least possible amount of fuel.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*霍曼转移轨道*使用椭圆轨道在同一平面内切换两个圆形轨道（见[图14-8](ch14.xhtml#ch14fig8)）。轨道可以升高或降低。该操作相对较慢，但消耗的燃料最少。'
- en: To change to an orbit with both a different periapsis *and* apoapsis, a spacecraft
    requires two engine impulses. One impulse moves the spacecraft onto the transfer
    orbit, and another moves it onto the final, destination orbit. When raising an
    orbit, the spacecraft applies the change in velocity in the direction of motion,
    and when lowering an orbit, it applies the change of velocity opposite to the
    direction of motion. The velocity changes have to occur at opposite sides of the
    orbit, as shown in [Figure 14-8](ch14.xhtml#ch14fig8). Without the second thrust,
    the orbits will still intersect at the point of the first thrust, as shown on
    the right side of [Figure 14-7](ch14.xhtml#ch14fig7).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要改变一个轨道，使其具有不同的近地点*和*远地点，宇航器需要两次发动机脉冲。一脉冲将宇航器推入转移轨道，另一脉冲则将其推入最终的目的轨道。当升高轨道时，宇航器将在运动方向上施加速度变化；而当降低轨道时，速度变化则是施加在与运动方向相反的方向上。速度变化必须发生在轨道的对侧，如[图14-8](ch14.xhtml#ch14fig8)所示。如果没有第二次推力，轨道仍会在第一次推力点相交，如[图14-7](ch14.xhtml#ch14fig7)右侧所示。
- en: '![image](../images/f0291-01.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0291-01.jpg)'
- en: '*Figure 14-8: Transferring to a lower circular orbit with the Hohmann transfer
    technique*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-8：使用霍曼转移技术转移至较低的圆形轨道*'
- en: '**Raising and Lowering Orbits with the One-Tangent Burn**'
  id: totrans-59
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用单切线燃烧升高和降低轨道**'
- en: The *One-Tangent Burn* technique transfers a spacecraft between orbits faster
    but less efficiently than a Hohmann transfer. A *burn* is just another term for
    thrust or impulse. As with the Hohmann transfer, orbits can be either raised or
    lowered.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*单切线燃烧*技术比霍曼转移轨道更快速，但效率较低，用于在轨道之间快速转换。*燃烧*只是推力或脉冲的另一种术语。与霍曼转移轨道相同，轨道可以升高或降低。'
- en: The maneuver requires two engine impulses, the first tangential to the orbit
    and the second nontangential (see [Figure 14-9](ch14.xhtml#ch14fig9)). If the
    initial orbit is circular, as in the figure, then all points along it represent
    both the apoapsis and the periapsis, and the spacecraft can apply its first burn
    at any time.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 该机动需要两次引擎脉冲，第一次是切向轨道，第二次是非切向的（参见[图 14-9](ch14.xhtml#ch14fig9)）。如果初始轨道是圆形的，如图所示，那么轨道上的所有点既代表远地点也代表近地点，航天器可以在任何时候进行第一次燃烧。
- en: '![image](../images/f0291-02.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0291-02.jpg)'
- en: '*Figure 14-9: Transferring to a higher circular orbit with the One-Tangent
    Burn*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-9：通过单一切向燃烧转移至更高的圆形轨道*'
- en: Just as with the Hohmann transfer, a prograde burn raises the orbit, and a retrograde
    burn lowers it. If the orbit is elliptical, the first burn would be a prograde
    burn at the apoapsis to raise the orbit, or a retrograde burn at periapsis to
    lower it.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 就像霍曼转移一样，顺行燃烧会提高轨道，而反向燃烧则会降低轨道。如果轨道是椭圆形的，第一次燃烧将在远地点进行顺行燃烧以提高轨道，或在近地点进行反向燃烧以降低轨道。
- en: '**Executing a Spiral Orbit with the Spiral Transfer**'
  id: totrans-65
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**通过螺旋转移执行螺旋轨道**'
- en: A *spiral transfer* uses a continuous, low-thrust burn to change the size of
    an orbit. In gameplay, you can simulate this using retrograde or prograde burns
    that are short and regularly spaced, like those shown in [Figure 14-10](ch14.xhtml#ch14fig10).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*螺旋转移*利用持续的低推力燃烧来改变轨道的大小。在游戏中，你可以通过反向或顺行燃烧来模拟这一过程，这些燃烧是短暂的并且间隔均匀，如[图 14-10](ch14.xhtml#ch14fig10)所示。'
- en: '![image](../images/f0292-01.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0292-01.jpg)'
- en: '*Figure 14-10: Executing a spiral orbit using short retrograde burns at regular
    intervals*'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-10：通过定期间隔的短暂反向燃烧执行螺旋轨道*'
- en: To lower an orbit, all the burns must be retrograde; to raise an orbit, the
    spacecraft uses prograde burns.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要降低轨道，所有的燃烧必须是反向燃烧；要提高轨道，航天器则使用顺行燃烧。
- en: '**Executing Synchronous Orbits**'
  id: totrans-70
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**执行同步轨道**'
- en: In a *synchronous orbit*, a spacecraft takes the same amount of time to make
    one revolution around a planet as it takes the planet to make one rotation around
    its axis. If a synchronous orbit is parallel to the equator, with no orbital inclination,
    it is a *stationary* orbit; to an observer on the orbited body, the satellite
    appears motionless in a fixed position in the sky. Communications satellites commonly
    use *geostationary* orbits, which have an altitude of 22,236 miles around Earth.
    A similar orbit would be called *aerostationary* around Mars and *selenostationary*
    around the moon.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在*同步轨道*中，航天器绕行一个行星的公转周期与该行星自转周期相同。如果同步轨道与赤道平行，且没有轨道倾斜角，它就是*静止轨道*；对绕行天体上的观察者来说，卫星在天空中看起来是静止的，位置固定。通信卫星常使用*静止轨道*，其高度为地球周围22,236英里。类似的轨道在火星上被称为*aerostationary*轨道，在月球上被称为*selenostationary*轨道。
- en: '**Project #22: The Mars Orbiter Game**'
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**项目 #22：火星轨道器游戏**'
- en: In real life, a series of equations is used to precisely execute orbital maneuvers.
    In gameplay, you’ll use your intuition, patience, and reflexes! You’ll also need
    to fly by instruments to a certain extent, using mainly the spacecraft’s altitude
    readout and a measure of the orbit’s circularity.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实中，一系列方程被用来精确执行轨道机动。在游戏中，你将依靠直觉、耐心和反应！你还需要在一定程度上依靠仪表飞行，主要使用航天器的高度读数和轨道圆形度的测量。
- en: '**THE OBJECTIVE**'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标**'
- en: Use pygame to build an arcade game that teaches the fundamentals of orbital
    mechanics. The game’s goal is to nudge a satellite into a circular mapping orbit
    without running out of fuel or burning up in the atmosphere.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用pygame构建一款教授轨道力学基础的街机游戏。游戏的目标是将卫星推入一个圆形的映射轨道，而不耗尽燃料或在大气层中燃烧殆尽。
- en: '**The Strategy**'
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**策略**'
- en: Start the design phase with a game sketch, as you did in [Chapter 13](ch13.xhtml#ch13).
    This sketch should capture all of the salient points of the game, like how it
    will look, how it will sound, how things will move, and how the game will communicate
    with the player ([Figure 14-11](ch14.xhtml#ch14fig11)).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 从游戏草图设计阶段开始，就像在[第 13 章](ch13.xhtml#ch13)中做的那样。这个草图应当捕捉游戏的所有关键点，如游戏的外观、声音、物体的运动方式以及游戏如何与玩家进行互动（参见[图
    14-11](ch14.xhtml#ch14fig11)）。
- en: '![image](../images/f0293-01.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0293-01.jpg)'
- en: '*Figure 14-11: Sketch of the main gameplay of the Mars Orbiter game*'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-11：火星轨道器游戏的主要玩法草图*'
- en: 'The sketch in [Figure 14-11](ch14.xhtml#ch14fig11) describes the main gameplay.
    You’ll need a separate sketch to describe the win-lose conditions. For the main
    gameplay, the key points are:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 14-11](ch14.xhtml#ch14fig11)中的示意图描述了主要的游戏玩法。你需要一个单独的示意图来描述胜负条件。对于主要的游戏玩法，关键点是：'
- en: '**The viewpoint is Mission Control.** The game screen should resemble a monitor
    at Mission Control from which the player can operate the errant space probe.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视角是任务控制中心。** 游戏画面应该像任务控制中心的显示器，玩家可以通过它操作出轨的太空探测器。'
- en: '**Mars is at front and center.** Everybody loves the Red Planet, so it will
    occupy the center of the jet-black screen.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**火星位于屏幕的正中央。** 大家都喜欢红色星球，所以它将占据漆黑屏幕的中央位置。'
- en: '**Mars is animated.** The Martian globe will slowly rotate around its axis
    and cast a shadow. The satellite will dim appreciably when it passes through this
    shadow.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**火星是动态的。** 火星的地球仪会缓慢围绕其轴旋转并投下阴影。卫星在经过阴影时会明显变暗。'
- en: '**The satellite’s initial orbit is chosen at random.** The satellite will appear
    at startup with a randomized—but constrained—orientation and velocity. On rare
    occasions, this may result in an instant game loss. That’s still better than real
    missions, which fail 47 percent of the time!'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**卫星的初始轨道是随机选择的。** 卫星在启动时会以随机但受限制的方位和速度出现。偶尔，这可能会导致即时的游戏失败。但这比实际任务要好，因为实际任务有47%的失败率！'
- en: '**There’s no need to prograde or retrograde the satellite.** Constantly rotating
    the space probe before firing its thrusters greatly diminishes gameplay. Assume
    that attitudinal thrusters are arrayed around the fuselage and use the arrow keys
    to choose which thrusters to fire.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不需要调整卫星的轨道方向。** 在发射推进器之前不断旋转太空探测器会极大地减少游戏的趣味性。假设姿态推进器围绕机身排列，玩家可以使用箭头键选择要发射的推进器。'
- en: '**Firing thrusters causes an audible hiss.** Despite the fact that there’s
    no sound in space, give the player the satisfaction of hearing a nice hiss whenever
    they fire the thrusters.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发射推进器会产生可听的嘶嘶声。** 尽管太空中没有声音，但每当玩家发射推进器时，会给玩家带来听到嘶嘶声的满足感。'
- en: '**The satellite dish always points toward Mars.** The satellite will slowly
    and automatically rotate so that its remote-sensing dish is always aimed at Mars.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**卫星的天线始终指向火星。** 卫星会缓慢自动旋转，使其遥感天线始终指向火星。'
- en: '**The satellite’s orbital path is visible.** A thin white line will trail out
    from behind the satellite and persist until the player clears it by pressing the
    space bar.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**卫星的轨道路径是可见的。** 一条细白线将从卫星后方延伸出来，并在玩家按下空格键清除之前持续显示。'
- en: '**The data readouts are placed at the top of the screen.** You will display
    information useful for gameplay in boxes at the top of the window. Key data are
    the space probe’s velocity, altitude, fuel, and orbital eccentricity (a measure
    of the orbit’s circularity).'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据读数位于屏幕顶部。** 你将把对游戏玩法有用的信息显示在屏幕顶部的框中。关键信息包括太空探测器的速度、海拔、高度和轨道偏心率（即轨道的圆形度度量）。'
- en: '**A short introduction is shown at startup.** Text introducing the game will
    appear at the center of the screen when the game starts and stay up for about
    15 seconds. The text will not disrupt gameplay, so the player can start manipulating
    the satellite immediately.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**启动时会显示简短的介绍。** 游戏开始时，屏幕中央会显示介绍文本，持续约15秒。该文本不会干扰游戏玩法，玩家可以立即开始操控卫星。'
- en: '**Win conditions and key controls are shown in permanent legends.** Critical
    information, like mission objectives and control keys, will be displayed permanently
    in the lower-left and -right corners of the screen.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**胜利条件和关键控制显示在永久的图例中。** 关键信息，如任务目标和控制键，将永久显示在屏幕的左下角和右下角。'
- en: The game sketch in [Figure 14-12](ch14.xhtml#ch14fig12) describes what happens
    in success and failure cases. The player needs a reward when they win and an interesting
    outcome when they lose.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 14-12](ch14.xhtml#ch14fig12)中的游戏示意图描述了成功和失败的情况。玩家在获胜时需要奖励，而在失败时则需要一个有趣的结果。'
- en: '![image](../images/f0295-01.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0295-01.jpg)'
- en: '*Figure 14-12: Game sketch of winning versus losing outcomes in the Mars Orbiter
    game*'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-12：火星探测器游戏中胜利与失败结果的游戏示意图*'
- en: 'For winning and losing outcomes, the key points are:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 胜利和失败的结果中，关键点是：
- en: '**Change the satellite image for crash and burn.** If the satellite’s altitude
    drops below 68 miles, it burns up in the atmosphere. The moving satellite image
    will be replaced with a glowing red version that sticks to the side of Mars; this
    is similar to something you might see on a real Mission Control display.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**为坠毁和烧毁更换卫星图像。** 如果卫星的高度下降到 68 英里以下，它将在大气中燃烧。运动中的卫星图像将被一个发红的版本所替代，固定在火星的旁边，这类似于你在真实的任务控制显示器上可能看到的情形。'
- en: '**The satellite is lost in space if it runs out of fuel.** Although unrealistic,
    have the satellite fly off the screen and into the depths of space if it runs
    out of fuel. This really rubs the player’s nose in it!'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**如果卫星燃料耗尽，它将在太空中失联。** 尽管这不太现实，但如果卫星燃料耗尽，就让它飞出屏幕，进入深空。这样真的能让玩家意识到失败的后果！'
- en: '**Win conditions unlock a prize.** If the satellite achieves a circular orbit
    within the target altitude range, new text will urge the player to press the M
    key.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**胜利条件解锁奖励。** 如果卫星在目标高度范围内成功进入圆形轨道，新的文本将提示玩家按下 M 键。'
- en: '**Pressing M changes the Mars image.** When the M key is unlocked, pressing
    it causes the Mars image to change to a rainbow image where cool colors represent
    areas of high soil moisture and warm colors represent drier areas.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按下 M 键可以更改火星图像。** 当 M 键解锁后，按下它会使火星图像变成彩虹图像，其中冷色代表土壤湿度较高的区域，暖色则代表干燥的区域。'
- en: For gameplay, the size of the satellite and its orbital speed won’t be realistic,
    but the overall behavior will be correct. You should be able to correctly execute
    all of the orbital maneuvers described in “[Astrodynamics for Gamers](ch14.xhtml#lev315)”
    on [page 286](ch14.xhtml#page_286).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对于游戏玩法，卫星的大小和轨道速度不会非常现实，但整体行为是正确的。你应该能够正确执行在《[游戏者的天体力学](ch14.xhtml#lev315)》书中[第286页](ch14.xhtml#page_286)所描述的所有轨道操作。
- en: '**Game Assets**'
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**游戏资源**'
- en: The assets you’ll need for the Mars Orbiter game are two satellite images, two
    planet images, and a sound file. You can prepare these together at the start of
    the process or build them when you need them. The latter approach lets you take
    episodic breaks from coding, which some people prefer.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你将需要为火星轨道器游戏准备两张卫星图像、两张行星图像和一个音频文件。你可以在过程开始时一次性准备这些资源，或者在需要时再去构建。后者的方式可以让你在编码过程中间歇休息，这也是一些人喜欢的方式。
- en: Finding good, copyright-free graphics and sound files can be a challenge. You
    can find suitable assets online—either for free or for a fee—but it’s best to
    make your own whenever possible. This lets you avoid any legal issues down the
    road.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找好的、免版权的图像和音频文件可能是个挑战。你可以在线找到合适的资源——要么是免费的，要么是收费的——但最好在可能的情况下自己制作。这样可以避免将来出现任何法律问题。
- en: The sprites (2D icons or images) I used for this project are shown in [Figure
    14-13](ch14.xhtml#ch14fig13). You need a satellite, a red “burned” version of
    the satellite, a view of Mars with a polar cap centered, and the same view with
    a colorful overlay that will represent mapped soil-moisture gradations. I found
    the satellite sprite at the free icon site AHA-SOFT (*[http://www.aha-soft.com/](http://www.aha-soft.com/)*)
    and then copied and recolored it to make the crashed version. Both of the Mars
    sprites are NASA images modified for the game.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我为这个项目使用的精灵（2D 图标或图像）如[图 14-13](ch14.xhtml#ch14fig13)所示。你需要一张卫星图像、一张“燃烧”后的卫星图像、一张中心为极地冠的火星图像，以及同一视角下带有彩色覆盖层的火星图像，这个覆盖层将表示映射的土壤湿度渐变。我是在免费的图标网站
    AHA-SOFT 上找到卫星图像的（* [http://www.aha-soft.com/](http://www.aha-soft.com/) *），然后复制并重新着色，制作了坠毁后的版本。两张火星图像都是
    NASA 的图像，并经过修改以适应游戏。
- en: '![image](../images/f0296-01.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0296-01.jpg)'
- en: '*Figure 14-13: The satellite, crashed satellite, Mars, and Mars overlay images
    used as game sprites*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-13：作为游戏精灵使用的卫星、坠毁的卫星、火星和火星覆盖图像*'
- en: I made a sound file for when the satellite is firing its thrusters using the
    white noise generator in the open source program Audacity. You can download a
    free copy of Audacity at *[https://www.audacityteam.org/](https://www.audacityteam.org/)*.
    I saved the file in *Ogg Vorbis* format, an open source standard audio compression
    format that is free and works well with Python and pygame. You can use other formats,
    like MP3 and WAV, with pygame, but some have documented problems or have proprietary
    components that can raise legal issues if you try to commercialize your game.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我为卫星发射推进器时制作了一个声音文件，使用开源程序Audacity中的白噪声生成器。你可以在*[https://www.audacityteam.org/](https://www.audacityteam.org/)*下载Audacity的免费版本。我将文件保存为*Ogg
    Vorbis*格式，这是一种开源标准的音频压缩格式，免费且与Python和pygame兼容。你也可以使用其他格式，如MP3和WAV，在pygame中也可以，但某些格式可能存在已知问题，或者包含专有组件，如果你尝试商业化游戏，可能会引发法律问题。
- en: You can download these files from this book’s website at *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*
    as *satellite.png*, *satellite_crash_40x33.png*, *mars.png*, *mars_water.png*,
    and *thrust_audio.ogg*. Download them, preserving the filenames, into the same
    folder as the code.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从本书网站下载这些文件，文件名分别为*satellite.png*、*satellite_crash_40x33.png*、*mars.png*、*mars_water.png*
    和 *thrust_audio.ogg*。下载时，请保留文件名，并将这些文件保存在与代码相同的文件夹中。
- en: '**The Code**'
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**代码**'
- en: '[Figure 14-14](ch14.xhtml#ch14fig14) is an example of the final game screen
    you’ll be building. You can refer back to this figure to get an idea of what the
    code is doing.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '[图14-14](ch14.xhtml#ch14fig14)是你将要构建的最终游戏画面的示例。你可以参考这个图像，了解代码的作用。'
- en: '![image](../images/f0297-01.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0297-01.jpg)'
- en: '*Figure 14-14: Example startup game screen for the final version of* mars_orbiter.py'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-14：mars_orbiter.py最终版本的示例启动游戏画面*'
- en: You can download the complete program (*mars_orbiter.py*) at *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在*[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*下载完整程序(*mars_orbiter.py*)。
- en: '***Importing and Building a Color Table***'
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***导入并构建颜色表***'
- en: '[Listing 14-1](ch14.xhtml#ch14list1) imports the required modules and builds
    a color table.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表14-1](ch14.xhtml#ch14list1)导入了所需的模块并构建了颜色表。'
- en: '*mars_orbiter.py,* part 1'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*mars_orbiter.py,* 第1部分'
- en: ➊ import os
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ import os
- en: import math
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: import math
- en: import random
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: import random
- en: import pygame as pg
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: import pygame as pg
- en: ➋ WHITE = (255, 255, 255)
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ WHITE = (255, 255, 255)
- en: BLACK = (0, 0, 0)
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: BLACK = (0, 0, 0)
- en: RED = (255, 0, 0)
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: RED = (255, 0, 0)
- en: GREEN = (0, 255, 0)
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: GREEN = (0, 255, 0)
- en: LT_BLUE = (173, 216, 230)
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: LT_BLUE = (173, 216, 230)
- en: '*Listing 14-1: Imports modules and builds a color table*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表14-1：导入模块并构建颜色表*'
- en: First, import the operating system, designated by os ➊. The game will launch
    in full-screen mode, but the player will have the option of escaping out of full
    screen. This module will let you control the location of the game window after
    the player presses ESC.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，导入操作系统模块，指定为os ➊。游戏将以全屏模式启动，但玩家将有退出全屏的选项。这个模块将允许你在玩家按下ESC后控制游戏窗口的位置。
- en: You’ll use the math module for gravity and trigonometric calculations and random
    to start the satellite off with a random position and velocity. Import pygame
    as you did in [Chapter 13](ch13.xhtml#ch13), using pg, rather than pygame, to
    reduce typing.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用math模块进行重力和三角计算，并使用random来让卫星以随机位置和速度开始。像在[第13章](ch13.xhtml#ch13)中一样，导入pygame，使用pg而不是pygame以减少输入。
- en: Finish by building an RGB color table ➋ as you did in [Chapter 13](ch13.xhtml#ch13).
    This lets you type in color names, rather than RGB-value tuples, when you need
    to assign one of these colors.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，像在[第13章](ch13.xhtml#ch13)中一样构建RGB颜色表 ➋。这样，当你需要分配其中一种颜色时，可以直接输入颜色名称，而不是RGB值元组。
- en: '***Defining the Satellite Class Initialization Method***'
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***定义卫星类的初始化方法***'
- en: '[Listing 14-2](ch14.xhtml#ch14list2) defines the Satellite class and its initialization
    method, which you’ll use to instantiate a satellite object in the game. Since
    this method definition is long, it’s split over two listings.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表14-2](ch14.xhtml#ch14list2)定义了Satellite类及其初始化方法，你将在游戏中使用该方法实例化卫星对象。由于这个方法定义较长，因此分成了两个列表展示。'
- en: '*mars_orbiter.py,* part 2'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*mars_orbiter.py,* 第2部分'
- en: '➊ class Satellite(pg.sprite.Sprite):'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ class Satellite(pg.sprite.Sprite):'
- en: '"""Satellite object that rotates to face planet & crashes & burns."""'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '"""卫星物体旋转以面向行星并发生碰撞与爆炸。"""'
- en: '➋ def __init__(self, background):'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '➋ def __init__(self, background):'
- en: ➌ super().__init__()
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ super().__init__()
- en: ➍ self.background = background
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ self.background = background
- en: ➎ self.image_sat = pg.image.load("satellite.png").convert()
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ self.image_sat = pg.image.load("satellite.png").convert()
- en: self.image_crash = pg.image.load("satellite_crash_40x33.png").convert()
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: self.image_crash = pg.image.load("satellite_crash_40x33.png").convert()
- en: ➏ self.image = self.image_sat
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ➏ self.image = self.image_sat
- en: ➐ self.rect = self.image.get_rect()
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ➐ self.rect = self.image.get_rect()
- en: ➑ self.image.set_colorkey(BLACK)  # sets transparent color
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '➑ self.image.set_colorkey(BLACK)  # 设置透明色'
- en: '*Listing 14-2: Defines the first part of the* Satellite *class initialization
    method*'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表14-2：定义卫星* 类初始化方法的第一部分*'
- en: Define a class for a Satellite object ➊; if you need a refresher on object-oriented
    programming, read [Chapter 11](ch11.xhtml#ch11). Pass it the pygame Sprite class,
    as objects instantiated from the Satellite class will be sprites. As described
    in [Chapter 13](ch13.xhtml#ch13), Sprite is a built-in class that serves as a
    template for making sprites. Your new class will inherit features that your sprites
    will need from this base class. These include important attributes like rect and
    image, which you’ll deal with shortly.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个卫星对象类 ➊；如果你需要回顾面向对象编程的概念，可以阅读[第11章](ch11.xhtml#ch11)。将pygame的Sprite类传给它，因为从卫星类实例化的对象将是精灵。如[第13章](ch13.xhtml#ch13)中所述，Sprite是一个内建类，作为创建精灵的模板。你的新类将从这个基类继承精灵所需要的特性。这些特性包括像rect和image这样的关键属性，稍后你会处理它们。
- en: Next, define the __init__() method for the Satellite object ➋ and pass it self,
    which—by convention—is a special name within a class definition that refers to
    the current object. You also need to pass the method a background object. The
    satellite’s path will be drawn on this object.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，定义卫星对象的__init__()方法 ➋，并将self传递给它，self——根据惯例——是类定义中一个特殊的名称，表示当前对象。你还需要传递给方法一个背景对象。卫星的路径将在该对象上绘制。
- en: Inside the __init_() method, immediately invoke the initialization method for
    the built-in Sprite class using super ➌. This will initialize the sprite and establish
    the rect and image attributes it needs. With super, you don’t need to refer to
    the base class (Sprite) explicitly. For more on super, see [Listing 11-5](ch11.xhtml#ch11list5)
    on [page 229](ch11.xhtml#page_229) or visit the docs at *[https://docs.python.org/3/library/functions.html?highlight=super#super](https://docs.python.org/3/library/functions.html?highlight=super#super)*.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在__init_()方法内部，立即使用super调用内建Sprite类的初始化方法 ➌。这将初始化精灵并建立它所需要的rect和image属性。使用super时，你无需明确提到基类（Sprite）。更多关于super的内容，请参见[列表11-5](ch11.xhtml#ch11list5)中的[第229页](ch11.xhtml#page_229)，或者访问文档中的*
    [https://docs.python.org/3/library/functions.html?highlight=super#super](https://docs.python.org/3/library/functions.html?highlight=super#super)*。
- en: Next, assign the background to self as an object attribute ➍. Then use pygame’s
    image.load() method to load your two satellite images—one operational and one
    crashed—and in the same step, run the convert() method on them ➎. This converts
    the object into a graphic format that pygame can use efficiently once the game
    loop starts. Without this step, the game may slow noticeably as the png format
    is converted, on the fly, 30 or more times per second.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将背景分配给self作为对象属性 ➍。然后，使用pygame的image.load()方法加载你的两张卫星图像——一张是正常的，一张是摔毁的——并在同一步骤中，调用convert()方法对它们进行处理
    ➎。这会将对象转换为pygame可以高效使用的图形格式，一旦游戏循环开始。这一步骤是必要的，否则游戏可能会明显变慢，因为png格式会在每秒30次以上的频率下被实时转换。
- en: You’ll use only one of the satellite images at a time, depending on whether
    or not the player burned up in the atmosphere, so use a generic self.image attribute
    to hold the loaded and converted image ➏. The unburned satellite image will be
    the default image; it will be replaced with the red crashed image if the satellite
    object gets too close to Mars.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你一次只会使用其中一张卫星图像，取决于玩家是否在大气层中被烧毁，因此使用一个通用的self.image属性来保存加载并转换后的图像 ➏。未烧毁的卫星图像将是默认图像；如果卫星对象接近火星，它将被红色摔毁图像替代。
- en: Now, get the rectangle information for the image ➐. Remember that pygame places
    the sprites on rectangular surface objects, and it needs to know the dimensions
    and location of these rectangles as the game runs.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，获取图像的矩形信息 ➐。记住，pygame将精灵放置在矩形表面对象上，并且它需要知道这些矩形的尺寸和位置，以便在游戏运行时使用。
- en: 'Finally, make the black parts of the satellite image invisible ➑. The satellite
    icon is on a field of black (see [Figure 14-13](ch14.xhtml#ch14fig13)), and you
    want the crashed-and-burned image to plot partially over Mars, so use the BLACK
    constant with the image object’s colorkey() method in order to make the icon’s
    background transparent. Otherwise, you’ll see a black box with a red satellite
    overlapping the Red Planet. Note that if you want to type in the RGB equivalent
    for black, you need to enter it as a tuple: (0, 0, 0).'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使卫星图像的黑色部分不可见 ➑。卫星图标位于黑色背景上（参见[图14-13](ch14.xhtml#ch14fig13)），你希望碰撞并燃烧后的图像部分显示在火星上，所以使用BLACK常量配合图像对象的colorkey()方法来使图标的背景透明。否则，你会看到一个带有红色卫星的黑色框，重叠在红色星球上。请注意，如果你想输入黑色的RGB等效值，需要将其输入为一个元组：(0,
    0, 0)。
- en: '***Setting the Satellite’s Initial Position, Speed, Fuel, and Sound***'
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***设置卫星的初始位置、速度、燃料和声音***'
- en: '[Listing 14-3](ch14.xhtml#ch14list3) completes the definition of the Satellite
    class initialization method. The satellite object’s initial position and velocity
    are chosen at random from a limited range of choices; the orientation of the remote-sensing
    dish is initialized, the fuel tank topped off, and sound effects added.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单14-3](ch14.xhtml#ch14list3)完成了卫星类初始化方法的定义。卫星对象的初始位置和速度是从一个有限的范围中随机选择的；遥感天线的方向被初始化，燃料箱已填满，并且添加了声音效果。'
- en: '*mars_orbiter.py,* part 3'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*mars_orbiter.py,* 第3部分'
- en: ➊ self.x = random.randrange(315, 425)
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ self.x = random.randrange(315, 425)
- en: self.y = random.randrange(70, 180)
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: self.y = random.randrange(70, 180)
- en: ➋ self.dx = random.choice([-3, 3])
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ self.dx = random.choice([-3, 3])
- en: ➌ self.dy = 0
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ self.dy = 0
- en: ➍ self.heading = 0  # initializes dish orientation
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '➍ self.heading = 0  # 初始化遥感天线的方向'
- en: ➎ self.fuel = 100
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ self.fuel = 100
- en: self.mass = 1
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: self.mass = 1
- en: self.distance = 0  # initializes distance between satellite & planet
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 'self.distance = 0  # 初始化卫星与行星之间的距离'
- en: ➏ self.thrust = pg.mixer.Sound('thrust_audio.ogg')
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: ➏ self.thrust = pg.mixer.Sound('thrust_audio.ogg')
- en: ➐ self.thrust.set_volume(0.07)  # valid values are 0-1
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '➐ self.thrust.set_volume(0.07)  # 有效值为0-1'
- en: '*Listing 14-3: Completes the* Satellite *class initialization method by initializing
    parameters*'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单14-3：通过初始化参数* 卫星 *类的初始化方法完成*'
- en: When the game starts, the satellite will appear at a random point near the top
    of the screen. You’ll choose the exact location from a range of x- and y-values
    ➊.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当游戏开始时，卫星将出现在屏幕顶部附近的一个随机位置。你将从一系列的x和y值中选择确切的位置 ➊。
- en: You’ll also choose the satellite’s velocity at random, but it will be slow enough
    that the satellite can’t escape from orbit. Randomly set the velocity to either
    –3 or 3\. Negative values result in a counterclockwise orbit, and vice versa.
    Use the delta-x (dx) attribute only ➋ and let gravity take care of dy. As discussed
    in [Chapter 13](ch13.xhtml#ch13), pygame moves sprites around the screen using
    incremental changes in the x-location (called delta-x or *dx*) and incremental
    changes in the y-location (called delta-y or *dy*). These vector components are
    calculated and added to the sprite’s current position (self.x, self.y) with each
    game loop.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你还将随机选择卫星的速度，但速度会慢到足以让卫星无法逃脱轨道。将速度随机设置为-3或3。负值表示逆时针轨道，反之则顺时针。只使用delta-x（dx）属性
    ➋，并让gravity处理dy。如[第13章](ch13.xhtml#ch13)中讨论的，pygame通过x位置的增量变化（称为delta-x或*dx*）和y位置的增量变化（称为delta-y或*dy*）来移动精灵。这些向量分量会在每个游戏循环中计算并添加到精灵的当前位置信息（self.x,
    self.y）。
- en: Next, set the dy attribute to 0 ➌. Later, the gravity() method will establish
    an initial dy value when it accelerates the newly instantiated satellite downscreen
    toward the planet.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将dy属性设置为0 ➌。稍后，gravity()方法将在加速新实例化的卫星向下朝着行星移动时设置初始的dy值。
- en: Assign an attribute for the satellite’s heading ➍. The remote-sensing dish,
    which will read soil moisture on the planet’s surface, should always point toward
    Mars, and if you remember from [Figure 14-3](ch14.xhtml#ch14fig3), this won’t
    occur unless you overcome inertia. You’ll use a method to actually rotate the
    satellite, so for now, just initialize the heading attribute with 0.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为卫星的方向分配一个属性 ➍。遥感天线应始终指向火星，如果你还记得[图14-3](ch14.xhtml#ch14fig3)，除非克服惯性，否则天线不会指向火星。你将使用一个方法来旋转卫星，所以现在只需将heading属性初始化为0。
- en: Now, top off the fuel tank with 100 units of fuel ➎. If you want to relate this
    to real life, it would probably represent 100 kilograms of hydrazine, similar
    to what was used in the *Magellan* probe that mapped Venus.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，给燃料箱加满 100 单位的燃料 ➎。要是想与现实生活挂钩，这可能代表 100 公斤的肼，类似于用于*麦哲伦*探测器上绘制金星的燃料。
- en: Next, set the object’s mass to 1. This basically means you’ll just use the mass
    of Mars in the gravity equation, because you multiply the masses of two objects
    together. As stated earlier, the pull of the satellite on Mars is inconsequential,
    so you don’t need to calculate it. The satellite’s mass attribute is included
    for completeness and as a placeholder in case you want to experiment with different
    values later.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将物体的质量设置为 1。这基本上意味着你将只在引力方程中使用火星的质量，因为你将两个物体的质量相乘。如前所述，卫星对火星的引力可以忽略不计，所以你无需计算它。卫星的质量属性是为了完整性，并作为占位符，以防你以后想要尝试不同的值。
- en: The following distance attribute stores the distance between the satellite and
    the body it is orbiting. The actual value will be calculated by a method you’ll
    define later.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 以下距离属性存储卫星与其环绕的天体之间的距离。实际值将在稍后定义的方法中计算。
- en: It’s time to add sound effects. You’ll initialize pygame’s sound mixer in the
    main() function, but for now, name a thrust attribute for the thrusting sound
    effect ➏. Pass the mixer’s Sound class the short clip of white noise in Ogg Vorbis
    format (*.ogg*). Finally, set the playback volume, using values between 0 and
    1 ➐. You may need to calibrate this to your PC. Ideally, you want a value that
    every player will be able to at least *hear* and then fine-tune with their own
    computer’s volume control.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 该是添加音效的时候了。你将在 main() 函数中初始化 pygame 的音频混音器，但现在，先为推进音效命名一个 thrust 属性 ➏。将混音器的
    Sound 类传入 Ogg Vorbis 格式 (*.ogg*) 的短小白噪音片段。最后，设置播放音量，使用 0 到 1 之间的值 ➐。你可能需要根据自己的
    PC 进行调整。理想情况下，你希望值能让每个玩家至少能*听见*，然后再通过他们自己计算机的音量控制进行微调。
- en: '***Firing Thrusters and Checking for Player Input***'
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***发射推进器并检查玩家输入***'
- en: '[Listing 14-4](ch14.xhtml#ch14list4) defines the thruster() and check_keys()
    methods of the Satellite class. The first determines the actions taken if one
    of the satellite’s thrusters is fired. The second checks whether a player has
    interacted with the thrusters by pressing an arrow key.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 14-4](ch14.xhtml#ch14list4) 定义了 Satellite 类的 thruster() 和 check_keys()
    方法。第一个确定当卫星的推进器之一被激活时的操作。第二个检查玩家是否通过按箭头键与推进器互动。'
- en: '*mars_orbiter.py,* part 4'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '*mars_orbiter.py*，第4部分'
- en: '➊ def thruster(self, dx, dy):'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ def thruster(self, dx, dy):'
- en: '"""Execute actions associated with firing thrusters."""'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '"""执行与发射推进器相关的操作。"""'
- en: ➋ self.dx += dx
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ self.dx += dx
- en: self.dy += dy
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: self.dy += dy
- en: ➌ self.fuel -= 2
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ self.fuel -= 2
- en: ➍ self.thrust.play()
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ self.thrust.play()
- en: '➎ def check_keys(self):'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '➎ def check_keys(self):'
- en: '"""Check if user presses arrow keys & call thruster() method."""'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '"""检查用户是否按下箭头键并调用 thruster() 方法。"""'
- en: ➏ keys = pg.key.get_pressed()
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ➏ keys = pg.key.get_pressed()
- en: '# fire thrusters'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '# 火箭推进器'
- en: '➐ if keys[pg.K_RIGHT]:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '➐ if keys[pg.K_RIGHT]:'
- en: ➑ self.thruster(dx=0.05, dy=0)
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ➑ self.thruster(dx=0.05, dy=0)
- en: 'elif keys[pg.K_LEFT]:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif keys[pg.K_LEFT]:'
- en: self.thruster(dx=-0.05, dy=0)
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: self.thruster(dx=-0.05, dy=0)
- en: 'elif keys[pg.K_UP]:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif keys[pg.K_UP]:'
- en: self.thruster(dx=0, dy=-0.05)
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: self.thruster(dx=0, dy=-0.05)
- en: 'elif keys[pg.K_DOWN]:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif keys[pg.K_DOWN]:'
- en: self.thruster(dx=0, dy=0.05)
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: self.thruster(dx=0, dy=0.05)
- en: '*Listing 14-4: Defines the* thruster() *and* check_keys() *methods for the*
    Satellite *class*'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 14-4：为* Satellite *类定义了* thruster() *和* check_keys() *方法*'
- en: The thruster() method takes self, dx, and dy as arguments ➊. The last two arguments,
    which can be positive or negative, are immediately added to the satellite’s self.dx
    and self.dy velocity components ➋. Next, the fuel level is decreased by two units
    ➌. Altering this value is one way to make the game either harder or easier. Finish
    by calling the play() method on the thrust audio attribute to make the hissing
    sound ➍. Note that, instead of *returning* values, OOP methods *update* existing
    object attributes.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: thruster() 方法接受 self、dx 和 dy 作为参数 ➊。最后两个参数可以是正值或负值，它们会立即加到卫星的 self.dx 和 self.dy
    速度分量上 ➋。接下来，燃料水平减少两个单位 ➌。修改这个值是让游戏变得更难或更简单的一种方式。最后，通过调用 thrust 音频属性的 play() 方法来播放嘶嘶声
    ➍。注意，OOP 方法不是*返回*值，而是*更新*现有的对象属性。
- en: The check_keys() method takes self as an argument ➎. First you use the pygame
    key module to determine whether the player has pressed a key ➏. The get_pressed()
    method returns a tuple of Boolean values—1 for True and 0 for False—that represent
    the current state of each key on the keyboard. True means a key has been pressed.
    You can index this tuple by using the key constants. You can find a list of all
    the keyboard constants at *[https://www.pygame.org/docs/ref/key.html](https://www.pygame.org/docs/ref/key.html)*.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: check_keys()方法以self作为参数 ➎。首先，使用pygame的键盘模块来确定玩家是否按下了某个键 ➏。get_pressed()方法返回一个布尔值的元组—1表示True，0表示False—表示每个键在键盘上的当前状态。True意味着该键已被按下。你可以使用键常量来索引此元组。你可以在*[https://www.pygame.org/docs/ref/key.html](https://www.pygame.org/docs/ref/key.html)*中找到所有键盘常量的列表。
- en: For example, the right arrow key is K_RIGHT. If this key has been pressed ➐,
    call the thruster() method and pass it dx and dy values ➑. In pygame, x-values
    increase toward the right of the screen, and y-values increase toward the bottom
    of the screen. So, if the user presses the left arrow key, subtract from dx; likewise,
    if the up arrow is pressed, decrement the dy value. The right arrow will increase
    dx, and the down arrow will increase dy. Readouts at the top of the screen will
    help the player relate the satellite’s movements to the underlying dx and dy values
    (see [Figure 14-14](ch14.xhtml#ch14fig14)).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，右箭头键是K_RIGHT。如果这个键已经被按下 ➐，调用thruster()方法并传递dx和dy值 ➑。在pygame中，x值向屏幕右侧增加，y值向屏幕底部增加。因此，如果用户按下左箭头键，dx值会减少；同样，如果按下上箭头键，dy值会减小。右箭头键会增加dx，向下箭头键会增加dy。屏幕顶部的读数将帮助玩家将卫星的移动与底层的dx和dy值对应起来（参见[图14-14](ch14.xhtml#ch14fig14)）。
- en: '***Locating the Satellite***'
  id: totrans-198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***定位卫星***'
- en: Still in the Satellite class, [Listing 14-5](ch14.xhtml#ch14list5) defines the
    locate() method. This method calculates the distance of the satellite from the
    planet and determines the heading for pointing the dish at the planet. You’ll
    use the distance attribute later when calculating the force of gravity and the
    *eccentricity* of the orbit. Eccentricity is a measurement of the deviation of
    an orbit from a perfect circle.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然在Satellite类中，[清单14-5](ch14.xhtml#ch14list5)定义了locate()方法。该方法计算卫星与行星之间的距离，并确定指向行星的天线方位角。稍后在计算重力和*偏心率*时，你会使用distance属性。偏心率是衡量轨道偏离完美圆形的程度。
- en: '*mars_orbiter.py,* part 5'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '*mars_orbiter.py,* 第5部分'
- en: '➊ def locate(self, planet):'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ def locate(self, planet):'
- en: '"""Calculate distance & heading to planet."""'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '"""计算到行星的距离和方位角。"""'
- en: ➋ px, py = planet.x, planet.y
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ px, py = planet.x, planet.y
- en: ➌ dist_x = self.x - px
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ dist_x = self.x - px
- en: dist_y = self.y - py
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: dist_y = self.y - py
- en: '# get direction to planet to point dish'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '# 获取指向行星的方向以指向天线'
- en: ➍ planet_dir_radians = math.atan2(dist_x, dist_y)
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ planet_dir_radians = math.atan2(dist_x, dist_y)
- en: ➎ self.heading = planet_dir_radians * 180 / math.pi
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ self.heading = planet_dir_radians * 180 / math.pi
- en: ➏ self.heading -= 90  # sprite is traveling tail-first
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '➏ self.heading -= 90  # 精灵正尾部朝前行驶'
- en: ➐ self.distance = math.hypot(dist_x, dist_y)
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: ➐ self.distance = math.hypot(dist_x, dist_y)
- en: '*Listing 14-5: Defines the* locate() *method for the* Satellite *class*'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单14-5：为* Satellite *类定义了locate()方法*'
- en: To locate the satellite, you need to pass the locate() method the satellite
    (self) and planet objects ➊. First, determine the distance between the objects
    in x-y space. Get the planet’s x- and y-attributes ➋; then subtract them from
    the satellite’s x- and y-attributes ➌.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 要定位卫星，你需要将卫星（self）和行星对象传递给locate()方法 ➊。首先，确定两个对象在x-y空间中的距离。获取行星的x和y属性 ➋；然后从卫星的x和y属性中减去它们
    ➌。
- en: Now, use these new distance variables to calculate the angle between the satellite’s
    heading and the planet so you can rotate the satellite dish toward the planet.
    The math module uses radians, so assign a local variable called planet_dir_radians
    to hold the direction in radians and pass dist_x and dist_y to the math.atan2()
    function to calculate the arc tangent ➍. Since pygame uses degrees (sigh), convert
    the angle from radians to degrees using the standard formula; alternatively, you
    could use math to do this, but sometimes it’s good to see the man behind the curtain
    ➎. This should be a sharable attribute of the satellite object, so name it self.heading.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用这些新的距离变量来计算卫星的航向与行星之间的角度，以便将卫星天线指向行星。数学模块使用弧度，所以创建一个名为planet_dir_radians的局部变量来保存该方向，并将dist_x和dist_y传递给math.atan2()函数来计算反正切
    ➍。由于pygame使用的是角度（唉），你需要使用标准公式将弧度转换为角度；或者，你也可以使用数学模块来实现这一点，但有时看到“幕后的人”也是很有意思的 ➎。这个值应该是卫星对象的一个可共享属性，所以命名为self.heading。
- en: In pygame, the front of a sprite is to the east by default, which means the
    satellite sprite is orbiting tail-first (see the satellite icon in [Figure 14-13](ch14.xhtml#ch14fig13)).
    To get the dish to point toward Mars, you need to subtract 90 degrees from the
    heading, because negative angles result in *clockwise* rotation in pygame ➏. This
    maneuver will use none of the player’s fuel allotment.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在pygame中，精灵的前方默认朝东，这意味着卫星精灵是尾部先行轨道（参见[图14-13](ch14.xhtml#ch14fig13)中的卫星图标）。为了让天线指向火星，你需要从航向角度中减去90度，因为在pygame中，负角度会导致*顺时针*旋转
    ➏。此操作不会消耗玩家的燃料配额。
- en: Finally, get the Euclidian distance between the satellite and Mars by using
    the math module to calculate the hypotenuse from the x- and y-components ➐. You
    should make this an attribute of the satellite object since you will use it later
    in other functions.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用数学模块计算卫星与火星之间的欧几里得距离，通过x和y分量计算斜边 ➐。你应该将其作为卫星对象的一个属性，因为你稍后将在其他函数中使用它。
- en: '**NOTE**'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In real life, there are multiple ways to keep the dish of a satellite pointed
    toward a planet without expending large amounts of fuel. Techniques include slowly
    tumbling or spinning the satellite, making the dish end heavier than the opposite
    end, using magnetic torque, or using internal flywheels—also known as reaction
    wheels or momentum wheels. Flywheels use electric motors that can be powered by
    solar panels, eliminating the need for heavy and toxic liquid propellant.*'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '*在现实生活中，有多种方法可以让卫星的天线指向行星而不消耗大量燃料。这些技术包括缓慢翻转或旋转卫星、让天线端比另一端重、使用磁力矩，或使用内部飞轮——也称为反应轮或动量轮。飞轮使用电动机，可以由太阳能电池板提供电力，从而避免了使用沉重和有毒的液体推进剂。*'
- en: '***Rotating the Satellite and Drawing Its Orbit***'
  id: totrans-218
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***旋转卫星并绘制其轨道***'
- en: '[Listing 14-6](ch14.xhtml#ch14list6) continues the Satellite class by defining
    methods for rotating the satellite dish toward the planet and drawing a path behind
    it. Later, in the main() function, you’ll add code that lets the player erase
    and restart the path by pressing the space bar.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单14-6](ch14.xhtml#ch14list6)通过定义使卫星天线指向行星和绘制卫星后方轨迹的方法，继续扩展了Satellite类。稍后，在main()函数中，你将添加代码，允许玩家通过按空格键擦除并重新开始轨迹。'
- en: '*mars_orbiter.py,* part 6'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '*mars_orbiter.py,* 第6部分'
- en: '➊ def rotate(self):'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ def rotate(self):'
- en: '"""Rotate satellite using degrees so dish faces planet."""'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '"""通过角度旋转卫星，使天线朝向行星。"""'
- en: ➋ self.image = pg.transform.rotate(self.image_sat, self.heading)
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ self.image = pg.transform.rotate(self.image_sat, self.heading)
- en: ➌ self.rect = self.image.get_rect()
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ self.rect = self.image.get_rect()
- en: '➍ def path(self):'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '➍ def path(self):'
- en: '"""Update satellite’s position & draw line to trace orbital path."""'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '"""更新卫星的位置并绘制一条线以追踪轨道路径。"""'
- en: ➎ last_center = (self.x, self.y)
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ last_center = (self.x, self.y)
- en: ➏ self.x += self.dx
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: ➏ self.x += self.dx
- en: self.y += self.dy
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: self.y += self.dy
- en: ➐ pg.draw.line(self.background, WHITE, last_center, (self.x, self.y))
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: ➐ pg.draw.line(self.background, WHITE, last_center, (self.x, self.y))
- en: '*Listing 14-6: Defines the* rotate() *and* path() *methods of the* Satellite
    *class*'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单14-6：定义了* rotate() *和* path() *方法的* Satellite *类*'
- en: The rotate() method will use the heading attribute, which you calculate in the
    locate() method, to turn the satellite dish toward Mars. Pass self to rotate()
    ➊, which means rotate() will automatically take the name of the satellite object
    as an argument when it is called later.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: rotate()方法将使用你在locate()方法中计算的heading属性，来将卫星天线转向火星。将self传递给rotate() ➊，这意味着rotate()在被调用时会自动将卫星对象的名称作为参数。
- en: Now, rotate the satellite image using pygame’s transform.rotate() method ➋.
    Pass it the original image followed by the heading attribute; assign these to
    the self.image attribute so you don’t degrade the original master image. You’ll
    need to transform the image with each game loop, and transforming an image rapidly
    degrades it. So always keep a master image and work off a new copy every time
    you do a transformation.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用 pygame 的 transform.rotate() 方法旋转卫星图像 ➋。传入原始图像和方向属性；将这些赋值给 self.image 属性，以便不破坏原始的主图像。你需要在每次游戏循环中转换图像，而快速转换图像会使其质量下降。因此，始终保留一张主图像，并在每次进行转换时操作一份新的副本。
- en: End the function by getting the transformed image’s rect object ➌.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 通过获取转换后的图像的矩形对象 ➌ 来结束函数。
- en: Next, define a method called path() and pass it self ➍. This will draw a line
    marking the satellite’s path, and since you need two points to draw a line, assign
    a variable to record the satellite’s center location as a tuple prior to moving
    it ➎. Then increment the x- and y-locations with the dx and dy attributes ➏. Finish
    by using pygame’s draw.line() method to define the line ➐. This method needs a
    drawing object, so pass it the background attribute, followed by the line color
    and the previous and current x-y location tuples.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，定义一个名为 path() 的方法并传入 self ➍。此方法将绘制一条标记卫星路径的线，由于绘制线段需要两个点，因此在移动卫星之前，要先为卫星的中心位置分配一个变量并记录为元组
    ➎。然后，使用 dx 和 dy 属性递增 x 和 y 坐标 ➏。最后，使用 pygame 的 draw.line() 方法定义这条线 ➐。该方法需要一个绘图对象，因此传入背景属性，接着是线的颜色以及先前和当前的
    x-y 坐标元组。
- en: '***Updating the Satellite Object***'
  id: totrans-236
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***更新卫星对象***'
- en: '[Listing 14-7](ch14.xhtml#ch14list7) updates the satellite object and completes
    the class definition. Sprite objects almost always have an update() method that
    is called once per frame as the game runs. Anything that happens to the sprite,
    such as movement, color changes, user interactions, and so on, is included in
    this method. To keep them from becoming too cluttered, update() methods mostly
    call other methods.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 14-7](ch14.xhtml#ch14list7) 更新了卫星对象并完成了类的定义。Sprite 对象几乎总是有一个 `update()`
    方法，该方法在游戏运行时每帧调用一次。任何发生在精灵上的事情，例如移动、颜色变化、用户交互等，都包含在这个方法中。为了避免方法过于混乱，`update()`
    方法通常会调用其他方法。'
- en: '*mars_orbiter.py,* part 7'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '*mars_orbiter.py,* 第 7 部分'
- en: '➊ def update(self):'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ def update(self):'
- en: '"""Update satellite object during game."""'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '"""在游戏中更新卫星对象。"""'
- en: ➋ self.check_keys()
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ self.check_keys()
- en: ➌ self.rotate()
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ self.rotate()
- en: ➍ self.path()
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ self.path()
- en: ➎ self.rect.center = (self.x, self.y)
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ self.rect.center = (self.x, self.y)
- en: '# change image to fiery red if in atmosphere'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '# 如果在大气层内，则将图像更改为火红色'
- en: '➏ if self.dx == 0 and self.dy == 0:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: ➏ 如果 self.dx == 0 且 self.dy == 0：
- en: self.image = self.image_crash
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: self.image = self.image_crash
- en: self.image.set_colorkey(BLACK)
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: self.image.set_colorkey(BLACK)
- en: '*Listing 14-7: Defines the* update() *method for the* Satellite *class*'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 14-7：为* Satellite *类定义了* update() *方法*'
- en: Start by defining the update() method and passing it the object, or self ➊.
    Next, call the methods that you defined earlier. The first of these checks for
    player interactions made through the keyboard ➋. The second rotates the satellite
    object so that the dish keeps pointing toward the planet ➌. The final method updates
    the satellite’s x-y location and draws a path behind it so you can visualize the
    orbit ➍.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，定义 `update()` 方法并传入对象，或者是 self ➊。接下来，调用之前定义的方法。第一个方法检查玩家通过键盘进行的交互 ➋。第二个方法旋转卫星对象，使得天线始终指向行星
    ➌。最后一个方法更新卫星的 x-y 坐标，并绘制一条路径在其后面，以便你可以可视化轨道 ➍。
- en: The program needs to keep track of the satellite sprite’s location as it orbits
    Mars, so assign a rect.center attribute and set it to the satellite’s current
    x-y location ➎.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 程序需要跟踪卫星精灵的位置，随着其围绕火星轨道运行，因此要分配一个 rect.center 属性并将其设置为卫星的当前 x-y 坐标 ➎。
- en: The final bit of code changes the satellite image in the event the player crashes
    and burns in the atmosphere ➏. The top of the Martian atmosphere is about 68 miles
    above its *surface*. For reasons I’ll explain later, assume that an altitude value
    of 68—which is measured in pixels from the *center* of the planet—equates to the
    top of the atmosphere. If the satellite dips below this altitude during gameplay,
    the main() function will set its velocity—represented by dx and dy—to 0. Check
    that these values are both 0, and if so, change the image to image_crash and set
    its background to transparent (as you did previously for the main satellite image).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '最后这段代码会改变卫星图片，假设玩家在大气层中发生了撞击 ➏。火星大气层的顶部距离*表面*大约68英里。出于我稍后会解释的原因，假设68的高度值——这是从*行星中心*测量的像素值——等同于大气层的顶部。如果卫星在游戏过程中下降到这个高度以下，main()函数会将它的速度——由dx和dy表示——设置为0。检查这两个值是否都为0，如果是，就将图片更改为image_crash，并将其背景设置为透明（就像你之前对主要卫星图片所做的那样）。  '
- en: '***Defining the Planet Class Initialization Method***'
  id: totrans-253
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***定义Planet类的初始化方法***  '
- en: '[Listing 14-8](ch14.xhtml#ch14list8) defines the Planet class, which you’ll
    use to instantiate a planet object.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单14-8](ch14.xhtml#ch14list8)定义了Planet类，你将用它来实例化一个行星对象。  '
- en: '*mars_orbiter.py,* part 8'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '*mars_orbiter.py，* 第8部分  '
- en: '➊ class Planet(pg.sprite.Sprite):'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ class Planet(pg.sprite.Sprite):  '
- en: '"""Planet object that rotates & projects gravity field."""'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '"""旋转并投射重力场的行星对象。"""  '
- en: '➋ def __init__(self):'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '➋ def __init__(self):  '
- en: super().__init__()
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 'super().__init__()  '
- en: ➌ self.image_mars = pg.image.load("mars.png").convert()
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '➌ self.image_mars = pg.image.load("mars.png").convert()  '
- en: self.image_water = pg.image.load("mars_water.png").convert()
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 'self.image_water = pg.image.load("mars_water.png").convert()  '
- en: ➍ self.image_copy = pg.transform.scale(self.image_mars, (100, 100))
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '➍ self.image_copy = pg.transform.scale(self.image_mars, (100, 100))  '
- en: ➎ self.image_copy.set_colorkey(BLACK)
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '➎ self.image_copy.set_colorkey(BLACK)  '
- en: ➏ self.rect = self.image_copy.get_rect()
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '➏ self.rect = self.image_copy.get_rect()  '
- en: self.image = self.image_copy
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 'self.image = self.image_copy  '
- en: ➐ self.mass = 2000
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '➐ self.mass = 2000  '
- en: ➑ self.x = 400
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '➑ self.x = 400  '
- en: self.y = 320
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: self.y = 320
- en: self.rect.center = (self.x, self.y)
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 'self.rect.center = (self.x, self.y)  '
- en: ➒ self.angle = math.degrees(0)
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '➒ self.angle = math.degrees(0)  '
- en: self.rotate_by = math.degrees(0.01)
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 'self.rotate_by = math.degrees(0.01)  '
- en: '*Listing 14-8: Begins definition of the* Planet *class*'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单14-8：开始定义* Planet *类*  '
- en: You are probably very familiar with the initial steps to creating the Planet
    class by now. First, you name the class with a capital letter, then pass it the
    Sprite class so it will conveniently inherit features from this built-in pygame
    class ➊. Next, you define an __init__(), or initialization, method for your planet
    object ➋. Then you call the super() initialization method, as you did for the
    Satellite class.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '你现在可能已经非常熟悉创建Planet类的初始步骤了。首先，你用大写字母命名类，然后传递给Sprite类，这样它就能方便地从这个内建的pygame类继承特性
    ➊。接着，你为行星对象定义一个__init__()，或者初始化方法 ➋。然后你调用super()初始化方法，就像在Satellite类中做的那样。  '
- en: Load the images as attributes and convert them to pygame’s graphic format at
    the same time ➌. You need both the normal Mars image and the one for mapped soil
    moisture. You were able to use the satellite sprite at its native size, but the
    Mars image is too large. Scale the image to 100 pixels × 100 pixels ➍ and assign
    the scaled image to a new attribute so repeated transformations won’t degrade
    the master image.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '加载图片作为属性并同时转换为pygame的图形格式 ➌。你需要使用普通的火星图片和映射土壤湿度的图片。你能够使用卫星精灵的原始大小，但火星图片太大。将图片缩放到100像素
    × 100像素 ➍，并将缩放后的图片赋给一个新的属性，这样重复的变换就不会损坏原始图片。  '
- en: Now, set the transformed image’s transparent color to black, as you did earlier
    with the satellite image ➎. Sprites in pygame are all “mounted” on rectangular
    surfaces, and if you don’t make black invisible, the corners of the planet surface
    may overlap and cover the white-colored orbital path drawn by the satellite (see
    [Figure 14-15](ch14.xhtml#ch14fig15)).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，将变换后的图片的透明色设置为黑色，和之前设置卫星图片时一样 ➎。pygame中的精灵都“挂载”在矩形表面上，如果不让黑色透明，行星表面的角落可能会重叠并遮盖卫星绘制的白色轨道路径（见[图14-15](ch14.xhtml#ch14fig15)）。  '
- en: '![image](../images/f0305-01.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0305-01.jpg)  '
- en: '*Figure 14-15: Corners of Mars* rect *covering orbital path*'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-15：火星* rect *角落遮盖轨道路径*  '
- en: As always, get the sprite’s rect object ➏. There’s another transformation to
    come, so copy the image attribute again and assign it the logical name of self.image.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '和往常一样，获取精灵的rect对象 ➏。接下来有一个变换需要进行，所以再次复制图片属性，并将其赋予一个逻辑名称self.image。  '
- en: To apply the force of gravity, the planet needs mass, so name a mass attribute
    and assign it a value of 2000 ➐. Earlier, you assigned the satellite a mass of
    1; this means that Mars is only 2,000 times as massive as a satellite! That’s
    okay, because you aren’t working in real-world units, and the time and distance
    scales differ from reality. If you scale distances so that the satellite is only
    a few hundred pixels from Mars, you have to scale gravity as well. Despite this,
    the satellite will still behave realistically with respect to gravity.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应用重力，行星需要质量，因此命名一个mass属性，并将其值设为2000 ➐。之前，你为卫星分配了1的质量；这意味着火星的质量只是卫星的2000倍！没关系，因为你并不是在使用真实世界的单位，时间和距离的尺度与现实不同。如果你缩放距离，使卫星距离火星只有几百像素，你还需要缩放重力。尽管如此，卫星仍会在重力作用下表现得非常真实。
- en: The planet’s mass value was determined through experimentation. To scale the
    force of gravity, you can either change this mass value or use the gravitational
    constant (G) variable later.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 行星的质量值是通过实验确定的。为了缩放重力，你可以稍后改变这个质量值，或者使用重力常数（G）变量。
- en: Set the planet object’s x and y attributes to the center point of the screen—you’ll
    use a screen size of 800 × 645 in the main() function—and assign these values
    to the rect object’s center ➑.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 将行星对象的x和y属性设置为屏幕的中心点——你将在main()函数中使用800 × 645的屏幕尺寸——并将这些值分配给rect对象的中心 ➑。
- en: Finally, assign the attributes you’ll need to slowly rotate Mars about its axis
    ➒. You’ll use the same transform.rotate() method you used to turn the satellite,
    so you need to create an angle attribute. Then, use a rotate_by attribute to assign
    the increment—in degrees—by which this rotation angle changes with each game loop.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，分配你需要的属性，以便慢慢旋转火星绕其轴心 ➒。你将使用与旋转卫星相同的transform.rotate()方法，因此你需要创建一个角度属性。然后，使用rotate_by属性分配增量——以度为单位——表示每次游戏循环中该旋转角度的变化。
- en: '***Rotating the Planet***'
  id: totrans-283
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***旋转行星***'
- en: '[Listing 14-9](ch14.xhtml#ch14list9) continues the Planet class by defining
    its rotate() method. This method rotates the planet around its axis, making small
    changes with each game loop.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单14-9](ch14.xhtml#ch14list9)通过定义其rotate()方法继续Planet类。此方法使行星绕其轴心旋转，在每个游戏循环中进行小幅变化。'
- en: '*mars_orbiter.py,* part 9'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '*mars_orbiter.py,* 第9部分'
- en: '➊ def rotate(self):'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ def rotate(self):'
- en: '"""Rotate the planet image with each game loop."""'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '"""在每次游戏循环中旋转行星图像。"""'
- en: ➋ last_center = self.rect.center
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ last_center = self.rect.center
- en: ➌ self.image = pg.transform.rotate(self.image_copy, self.angle)
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ self.image = pg.transform.rotate(self.image_copy, self.angle)
- en: self.rect = self.image.get_rect()
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: self.rect = self.image.get_rect()
- en: ➍ self.rect.center = last_center
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ self.rect.center = last_center
- en: ➎ self.angle += self.rotate_by
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ self.angle += self.rotate_by
- en: '*Listing 14-9: Defines a method to rotate the planet around its axis*'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单14-9：定义一个方法来旋转行星绕其轴心*'
- en: The rotate() method also takes the object as an argument ➊. As the square Mars
    image is rotating, the bounding rectangle object (rect) remains stationary and
    must expand to accommodate the new configuration (see [Figure 14-16](ch14.xhtml#ch14fig16)).
    This change in size can affect the center point of the rect, so assign a last_center
    variable and set it to the planet’s current center point ➋. If you don’t do this,
    Mars will wobble around its axis as the game runs.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: rotate()方法也接受对象作为参数 ➊。随着方形火星图像的旋转，边界矩形对象（rect）保持不动，并且必须扩展以适应新的配置（见[图14-16](ch14.xhtml#ch14fig16)）。尺寸的变化可能会影响rect的中心点，因此需要分配一个last_center变量，并将其设置为行星的当前中心点
    ➋。如果不这样做，火星将在游戏运行时围绕其轴心晃动。
- en: '![image](../images/f0306-01.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0306-01.jpg)'
- en: '*Figure 14-16: The bounding rectangle changes size to accommodate rotating
    images.*'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-16：边界矩形的尺寸变化，以适应旋转的图像。*'
- en: Next, rotate the copied image using pygame’s transform.rotate() method and assign
    it to the self.image attribute ➌; you need to pass the method the copied image
    and the angle attribute. Immediately after rotating, reset the image’s rect attribute
    and move its center location back to last_center in order to mitigate any shifting
    of rect that occurred during rotation ➍.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用pygame的transform.rotate()方法旋转复制的图像，并将其分配给self.image属性 ➌；你需要将复制的图像和角度属性传递给该方法。旋转后，立即重置图像的rect属性，并将其中心位置恢复为last_center，以减少旋转过程中可能发生的rect偏移
    ➍。
- en: When the planet object is instantiated, the angle attribute will start at 0
    degrees, then increase by 0.1—assigned in the rotate_by attribute—with each frame
    ➎.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 当行星对象实例化时，角度属性将从0度开始，然后每帧增加0.1——通过rotate_by属性分配 ➎。
- en: '***Defining the gravity() and update() Methods***'
  id: totrans-299
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***定义gravity()和update()方法***'
- en: '[Listing 14-10](ch14.xhtml#ch14list10) completes the Planet class by defining
    the gravity() and update() methods. In [Chapter 13](ch13.xhtml#ch13), you treated
    gravity as a constant applied in the y-direction. The method applied here is slightly
    more sophisticated, because it takes into account the distance between two objects.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表14-10](ch14.xhtml#ch14list10)通过定义gravity()和update()方法完成了Planet类。在[第13章](ch13.xhtml#ch13)中，你将重力视为应用于y方向的常数。这里使用的方法稍微复杂一些，因为它考虑了两个物体之间的距离。'
- en: '*mars_orbiter.py,* part 10'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '*mars_orbiter.py，*第10部分'
- en: '➊ def gravity(self, satellite):'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ def gravity(self, satellite):'
- en: '"""Calculate impact of gravity on satellite."""'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '"""计算重力对卫星的影响。"""'
- en: ➋ G = 1.0  # gravitational constant for game
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '➋ G = 1.0  # 游戏中的引力常数'
- en: ➌ dist_x = self.x - satellite.x
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ dist_x = self.x - satellite.x
- en: dist_y = self.y - satellite.y
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: dist_y = self.y - satellite.y
- en: distance = math.hypot(dist_x, dist_y)
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: distance = math.hypot(dist_x, dist_y)
- en: '# normalize to a unit vector'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '# 归一化为单位向量'
- en: ➍ dist_x /= distance
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ dist_x /= distance
- en: dist_y /= distance
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: dist_y /= distance
- en: '# apply gravity (dx & dy represent pixels/frame)'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '# 应用重力（dx和dy表示像素/帧）'
- en: ➎ force = G * (satellite.mass * self.mass) / (math.pow(distance, 2))
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ force = G * (satellite.mass * self.mass) / (math.pow(distance, 2))
- en: ➏ satellite.dx += (dist_x * force)
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: ➏ satellite.dx += (dist_x * force)
- en: satellite.dy += (dist_y * force)
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: satellite.dy += (dist_y * force)
- en: '➐ def update(self):'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '➐ def update(self):'
- en: '"""Call the rotate method."""'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '"""调用rotate方法。"""'
- en: self.rotate()
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: self.rotate()
- en: '*Listing 14-10: Defines the* gravity() *and* update() *methods of the* Planet
    *class*'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表14-10：定义了* gravity() *和* update() *方法的* Planet *类*'
- en: Define the gravity() method and pass it self and the satellite object ➊. You’re
    still in the Planet class, so self here represents Mars.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 定义gravity()方法，并传入self和satellite对象 ➊。你仍然在Planet类中，因此这里的self代表火星。
- en: Start by naming a local variable G; an uppercase G is the *universal gravitational
    constant*, also known as the *constant of proportionality* ➋. In real life, this
    is a very small, empirically derived number, which is basically a conversion number
    to get all the units to work out correctly. You’re not using real-world units
    in the game, so set this to 1; this way, it won’t have an impact on the gravity
    equation. During game development, you can tweak this constant up or down to fine-tune
    the force of gravity and its effect on orbiting objects.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 开始时，命名一个局部变量G；大写的G是*万有引力常数*，也被称为*比例常数* ➋。在现实生活中，这是一个非常小的、经验导出的数字，基本上是一个转换系数，用于使所有单位都能正确运算。由于你在游戏中没有使用现实世界的单位，因此将其设置为1；这样，它就不会对重力公式产生影响。在游戏开发过程中，你可以微调这个常数，调整重力的强度及其对轨道物体的影响。
- en: You need to know how far apart the two objects are, so get their distance in
    the x-direction and the y-direction ➌. Then, use the math module’s hypot() method
    to get the Euclidian distance. This will represent the *r* in the gravity equation.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要知道这两个物体之间的距离，因此首先计算它们在x方向和y方向的距离 ➌。然后，使用math模块的hypot()方法计算欧几里得距离。这个值将表示重力公式中的*r*。
- en: Since you’re going to directly address the *magnitude* of the distance between
    the satellite and Mars in the gravity equation, all you need from the distance
    vector is *direction*. So, divide dist_x and dist_y by distance to “normalize”
    the vector to a unit vector with a magnitude of 1 ➍. You are basically dividing
    the length of each side of a right triangle by its hypotenuse. This preserves
    the vector’s direction, represented by the relative differences in dist_x and
    dist_y, but sets its magnitude to 1. Note that if you don’t perform this normalization
    step, the results will be unrealistic but interesting (see [Figure 14-17](ch14.xhtml#ch14fig17)).
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你将直接在重力公式中处理卫星与火星之间的*距离大小*，所以从距离向量中你只需要*方向*。因此，将dist_x和dist_y除以距离，以“归一化”该向量为一个大小为1的单位向量
    ➍。你基本上是在将直角三角形的每个边长除以斜边长度。这会保留向量的方向，通过dist_x和dist_y的相对差异表示，但将其大小设为1。请注意，如果你不执行此归一化步骤，结果将不现实但非常有趣（请参见[图14-17](ch14.xhtml#ch14fig17)）。
- en: '![image](../images/f0308-01.jpg)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0308-01.jpg)'
- en: '*Figure 14-17: “Spirograph” orbit resulting from use of an unnormalized distance
    vector*'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-17：“Spirograph”轨道，源于使用未归一化的距离向量*'
- en: Calculate the force of gravity using Newton’s equation, which I described in
    “[The Law of Universal Gravity](ch14.xhtml#lev316)” on [page 286](ch14.xhtml#page_286)
    ➎. Finish by multiplying the normalized distances by force—to calculate by how
    much acceleration changes velocity in each step—and add these amounts to the satellite
    object’s dx and dy attributes ➏.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 使用牛顿方程计算重力，我在“[万有引力定律](ch14.xhtml#lev316)”中描述了它，见[第286页](ch14.xhtml#page_286)
    ➎。最后，通过将标准化后的距离乘以力——来计算加速度在每一步中如何改变速度——并将这些量加到卫星对象的dx和dy属性上 ➏。
- en: Note that you don’t assign most of these variables as attributes of self. These
    just represent intermediate steps within a method that don’t need to be shared
    with other methods, and you can treat them as you would local variables in procedural
    programming.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你不会将这些变量作为self的属性进行赋值。这些只是方法中的中间步骤，不需要与其他方法共享，你可以像在过程式编程中处理局部变量一样处理它们。
- en: Finally, define a method that will be called every game loop to update the planet
    object ➐. Use it to call the rotate() method.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，定义一个方法，它将在每次游戏循环时调用，以更新行星对象 ➐。使用它来调用rotate()方法。
- en: '***Calculating Eccentricity***'
  id: totrans-328
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***计算离心率***'
- en: You’re through defining classes. Now it’s time to define some functions that
    will help with running the game. [Listing 14-11](ch14.xhtml#ch14list11) defines
    a function to calculate the eccentricity of the satellite’s orbit. The player
    will need to achieve a circular orbit within a certain altitude range, and this
    function will provide the measurement of circularity.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经完成了类的定义。现在是时候定义一些帮助运行游戏的函数了。[清单 14-11](ch14.xhtml#ch14list11)定义了一个函数来计算卫星轨道的离心率。玩家需要在一定的高度范围内实现一个圆形轨道，而这个函数将提供圆形度的测量值。
- en: '*mars_orbiter.py,* part 11'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '*mars_orbiter.py,* 第11部分'
- en: '➊ def calc_eccentricity(dist_list):'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ def calc_eccentricity(dist_list):'
- en: '"""Calculate & return eccentricity from list of radii."""'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '"""计算并返回由半径列表得出的离心率。"""'
- en: ➋ apoapsis = max(dist_list)
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ apoapsis = max(dist_list)
- en: periapsis = min(dist_list)
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: periapsis = min(dist_list)
- en: ➌ eccentricity = (apoapsis - periapsis) / (apoapsis + periapsis)
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ eccentricity = (apoapsis - periapsis) / (apoapsis + periapsis)
- en: return eccentricity
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: return eccentricity
- en: '*[Listing 14-11](ch14.xhtml#ch14list11): Defines a function to measure orbital
    eccentricity*'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '*[清单 14-11](ch14.xhtml#ch14list11)：定义了一个函数来测量轨道的离心率*'
- en: Define the calc_eccentricity() function and pass it a list of distances ➊. In
    the main() function, you’ll append the sat.distance attribute—which records the
    satellite’s altitude—to this list during every game loop. To calculate eccentricity,
    you need to know both the apoapsis and periapsis of the orbit. Get these by finding
    the maximum and minimum values in this list ➋. Then, calculate eccentricity ➌.
    Later, in the main() function, you’ll display this number to eight decimal places,
    just to look cool and precise in the readout.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 定义calc_eccentricity()函数，并传入一个距离列表 ➊。在main()函数中，你将每次游戏循环时都将卫星的距离属性（记录卫星的高度）添加到这个列表中。为了计算离心率，你需要知道轨道的远地点和近地点。通过查找这个列表中的最大值和最小值来获取这些数据
    ➋。然后，计算离心率 ➌。最后，在main()函数中，你将以八位小数的形式显示这个数值，让它看起来更酷、更精确。
- en: Note that circular orbits will have the same value for both apoapsis and periapsis,
    and so the calculation will yield 0 for a perfect circle. End the function by
    returning the eccentricity variable.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，圆形轨道的远地点和近地点的数值相同，因此计算结果对于完美的圆形轨道将为0。函数最后返回离心率变量。
- en: '***Defining Functions to Make Labels***'
  id: totrans-340
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***定义函数以创建标签***'
- en: The game will need a fair amount of text for instructions and telemetry readouts.
    Displaying this text one string at a time can result in a lot of code redundancy,
    so [Listing 14-12](ch14.xhtml#ch14list12) will define two functions—one to post
    instructions and another for the streams of velocity, altitude, fuel, and eccentricity
    data you’ll need to share with the player.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏需要大量的文本用于指令和遥测数据输出。逐行显示这些文本可能会导致代码冗余，[清单 14-12](ch14.xhtml#ch14list12)将定义两个函数——一个用于显示指令，另一个用于显示你需要与玩家共享的速度、高度、燃料和离心率等数据流。
- en: '*mars_orbiter.py,* part 12'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '*mars_orbiter.py,* 第12部分'
- en: '➊ def instruct_label(screen, text, color, x, y):'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ def instruct_label(screen, text, color, x, y):'
- en: '"""Take screen, list of strings, color, & origin & render text to screen."""'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '"""接收屏幕、字符串列表、颜色和原点并将文本渲染到屏幕上。"""'
- en: ➋ instruct_font = pg.font.SysFont(None, 25)
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ instruct_font = pg.font.SysFont(None, 25)
- en: ➌ line_spacing = 22
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ line_spacing = 22
- en: '➍ for index, line in enumerate(text):'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '➍ for index, line in enumerate(text):'
- en: label = instruct_font.render(line, True, color, BLACK)
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: label = instruct_font.render(line, True, color, BLACK)
- en: screen.blit(label, (x, y + index * line_spacing))
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: screen.blit(label, (x, y + index * line_spacing))
- en: '➎ def box_label(screen, text, dimensions):'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '➎ def box_label(screen, text, dimensions):'
- en: '"""Make fixed-size label from screen, text & left, top, width, height."""'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '"""从屏幕、文本以及左上角、宽度、高度生成固定大小的标签。"""'
- en: readout_font = pg.font.SysFont(None, 27)
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: readout_font = pg.font.SysFont(None, 27)
- en: ➏ base = pg.Rect(dimensions)
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: ➏ base = pg.Rect(dimensions)
- en: ➐ pg.draw.rect(screen, WHITE, base, 0)
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: ➐ pg.draw.rect(screen, WHITE, base, 0)
- en: ➑ label = readout_font.render(text, True, BLACK)
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: ➑ label = readout_font.render(text, True, BLACK)
- en: ➒ label_rect = label.get_rect(center=base.center)
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: ➒ label_rect = label.get_rect(center=base.center)
- en: ➓ screen.blit(label, label_rect)
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: ➓ screen.blit(label, label_rect)
- en: '*Listing 14-12: Defines functions to make instruction and readout labels*'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 14-12：定义用于生成指令和读取标签的函数*'
- en: Define a function called instruct_label() for displaying instructions on the
    game screen ➊. Pass it the screen, a list containing the text, a text color, and
    the coordinates for the upper-left corner of the pygame surface object that will
    hold the text.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个名为 instruct_label() 的函数，用于在游戏屏幕 ➊ 上显示指令。传入屏幕、包含文本的列表、文本颜色以及将要显示文本的 pygame
    表面对象的左上角坐标。
- en: Next, tell pygame which font to use ➋. The arguments for the font.SysFont()
    method are the typeface and size. Using None for the typeface invokes pygame’s
    built-in default font, which should work on multiple platforms. Note that the
    method accepts both None and 'None'.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，告诉 pygame 使用哪种字体 ➋。font.SysFont() 方法的参数包括字体类型和大小。使用 None 作为字体类型会调用 pygame
    的内建默认字体，适用于多个平台。请注意，该方法同时接受 None 和 'None'。
- en: The introduction and instruction text will take up multiple lines (see the example
    in [Figure 14-14](ch14.xhtml#ch14fig14)). You’ll need to specify the line spacing,
    in pixels, between the text strings, so assign a variable for this and set it
    to 22 ➌.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 介绍和指令文本将占据多行（见 [图 14-14](ch14.xhtml#ch14fig14) 示例）。你需要指定文本行之间的行距，以像素为单位，因此为此设置一个变量并将其值设置为
    22 ➌。
- en: Now, start looping through the list of text strings ➍. Use enumerate() to get
    an index, which you’ll use with the line_spacing variable to post the strings
    in the correct locations. The text will need to be placed on a surface. Name this
    surface label, pass the font.render() method the line of text you want to display,
    set antialiasing to True for smoother text, color the text, and set the background
    color to black. Finish by blitting the surface to the screen. Pass the method
    the label variable and the upper-left-corner coordinates, with y defined as y
    + index * line_spacing.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，开始遍历文本字符串列表 ➍。使用 enumerate() 获取索引，并结合行距变量，将文本显示在正确的位置。文本需要被放置到一个表面上。命名该表面为
    label，将文本行传递给 font.render() 方法，设置抗锯齿为 True 以获得更平滑的文本效果，给文本上色，并将背景色设为黑色。最后，将该表面绘制到屏幕上。传递方法
    label 变量和左上角坐标，并将 y 设置为 y + index * line_spacing。
- en: Next, define a function called box_label() for the data readout labels that
    will appear as gauges at the top of the screen (see [Figure 14-18](ch14.xhtml#ch14fig18))
    ➎. Parameters for this function are the screen, some text, and a tuple containing
    the dimensions of the rectangular surface that will form the gauge.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，定义一个名为 box_label() 的函数，用于屏幕顶部作为仪表显示的数据读取标签（见 [图 14-18](ch14.xhtml#ch14fig18)）
    ➎。此函数的参数为屏幕、文本以及一个包含将形成仪表的矩形表面尺寸的元组。
- en: '![image](../images/f0310-01.jpg)'
  id: totrans-364
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0310-01.jpg)'
- en: '*Figure 14-18: Readout labels at the top of the game window (header label above
    and data label below)*'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-18：游戏窗口顶部的数据读取标签（上方为标题标签，下方为数据标签）*'
- en: The surfaces made by the instruct_label() function will automatically change
    size to accommodate the amount of text being displayed. This works fine for static
    displays, but the readout data will change constantly, causing your gauges to
    expand and shrink as they adjust to fit the text inside them. To mitigate this,
    you’ll use a stand-alone rect object of a specified size to form a base for your
    text object.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: instruct_label() 函数生成的表面会根据显示的文本数量自动调整大小。这对于静态显示效果没问题，但读取数据会不断变化，导致仪表随着文本的增加或减少而扩展或收缩。为了避免这种情况，你将使用一个独立的指定大小的矩形对象作为文本对象的基础。
- en: Start the function by setting the font, as you did in ➋. Assign a variable called
    base to a pygame rect object; use the dimensions argument for the size ➏. This
    argument lets you precisely place the position of the box by specifying the left
    and top coordinates of the rectangle, followed by its width and height. The resulting
    rectangle should be wide enough to handle the longest possible readout the game
    will produce for the data type being displayed.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 通过设置字体开始函数，就像在 ➋ 中一样。给一个变量 base 分配一个 pygame 矩形对象；使用 dimensions 参数来设置大小 ➏。这个参数让你通过指定矩形的左上角坐标，然后是宽度和高度，精确放置矩形的位置。生成的矩形应该足够宽，以处理游戏为当前数据类型显示的最长期限。
- en: Now, draw the base using the draw_rect() method ➐. The arguments are the drawing
    surface, a fill color, the name of the rect, and a width of 0, which fills the
    rectangle rather than drawing a border. You’ll post your text object on top of
    this white rectangle.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用 draw_rect() 方法绘制矩形 ➐。参数包括绘制表面、填充颜色、矩形名称以及宽度为 0，这会填充矩形而不是绘制边框。你将把文本对象放在这个白色矩形上方。
- en: Repeat the code that renders the text ➑, then get the rect for the label ➒.
    Note that in the get_rect() method there’s a parameter that sets the center equal
    to the center of base. This lets you place the text label on top of the white
    base rectangle. Finally, blit to the screen, specifying the source and destination
    rects ➓.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 重复渲染文本的代码 ➑，然后获取标签的矩形 ➒。请注意，在 get_rect() 方法中有一个参数可以将中心设置为 base 的中心。这可以让你将文本标签放置在白色矩形的上方。最后，使用
    blit 将其绘制到屏幕上，指定源矩形和目标矩形 ➓。
- en: '***Mapping Soil Moisture***'
  id: totrans-370
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***绘制土壤湿度图***'
- en: '[Listing 14-13](ch14.xhtml#ch14list13) defines functions that allow the player
    to “map” Mars if the game’s winning conditions have been met. When the player
    presses the M key, these functions will be called by the main() function, and
    the planet’s image will be replaced with a colorful overlay we’ll pretend represents
    soil moisture content. When the player releases the key, the normal view of Mars
    will return. The key checks will also be performed in the main() function.'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 14-13](ch14.xhtml#ch14list13) 定义了让玩家在游戏的胜利条件满足时“绘制”火星土壤湿度图的功能。当玩家按下 M 键时，这些函数将被
    main() 函数调用，行星的图像将被一个彩色的覆盖层替代，我们假装它表示土壤湿度含量。当玩家释放按键时，火星的正常视图将恢复。按键检查也将在 main()
    函数中执行。'
- en: '*mars_orbiter.py,* part 13'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '*mars_orbiter.py,* 第13部分'
- en: '➊ def mapping_on(planet):'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ def mapping_on(planet):'
- en: '"""Show soil moisture image of planet."""'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '"""显示行星的土壤湿度图像。"""'
- en: ➋ last_center = planet.rect.center
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ last_center = planet.rect.center
- en: ➌ planet.image_copy = pg.transform.scale(planet.image_water, (100, 100))
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ planet.image_copy = pg.transform.scale(planet.image_water, (100, 100))
- en: ➍ planet.image_copy.set_colorkey(BLACK)
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ planet.image_copy.set_colorkey(BLACK)
- en: planet.rect = planet.image_copy.get_rect()
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: planet.rect = planet.image_copy.get_rect()
- en: planet.rect.center = last_center
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: planet.rect.center = last_center
- en: '➎ def mapping_off(planet):'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '➎ def mapping_off(planet):'
- en: '"""Restore normal planet image."""'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '"""恢复正常的行星图像。"""'
- en: ➏ planet.image_copy = pg.transform.scale(planet.image_mars, (100, 100))
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: ➏ planet.image_copy = pg.transform.scale(planet.image_mars, (100, 100))
- en: planet.image_copy.set_colorkey(BLACK)
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: planet.image_copy.set_colorkey(BLACK)
- en: '*Listing 14-13: Defines functions to let the player make a soil moisture map
    of Mars*'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 14-13：定义了让玩家绘制火星土壤湿度图的函数*'
- en: Start by defining a function that takes as an argument the planet object ➊.
    Start by assigning a last_center variable as you did in [Listing 14-9](ch14.xhtml#ch14list9);
    this will be used to keep the planet from wobbling on its axis ➋.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 首先定义一个函数，它以行星对象作为参数 ➊。像在 [列表 14-9](ch14.xhtml#ch14list9) 中一样，先分配一个 last_center
    变量；这个变量将用于防止行星在其轴上晃动 ➋。
- en: Next, scale the water image of Mars to the same size as the normal image and
    assign this to the planet’s image_copy attribute, because transformations degrade
    an image if used repeatedly ➌. Set the image’s background to transparent ➍, get
    its rect, and set the center of the rect equal to the last_center variable; that
    way Mars will stay put at the center of the screen.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将火星的水分图像缩放到与正常图像相同的大小，并将其分配给行星的 image_copy 属性，因为反复使用转换会使图像质量下降 ➌。将图像的背景设置为透明
    ➍，获取其矩形，并将矩形的中心设置为 last_center 变量；这样，火星就会保持在屏幕的中心位置。
- en: Now, define another function for when the player stops actively mapping Mars
    ➎. It also takes the planet object as an argument. All you need to do is reset
    the planet image to the original version ➏. Because you’re still using the image_copy
    attribute, you don’t need to get the rect again, but you do need to set the transparent
    color.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，定义另一个函数，当玩家停止主动绘制火星时使用 ➎。它也接受行星对象作为参数。你需要做的就是将行星图像重置为原始版本 ➏。因为你仍然在使用 image_copy
    属性，所以不需要重新获取矩形，但你确实需要设置透明色。
- en: '***Casting a Shadow***'
  id: totrans-388
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***投射阴影***'
- en: '[Listing 14-14](ch14.xhtml#ch14list14) defines a function that gives Mars a
    “dark side” and casts a shadow behind the planet. The shadow will be a black,
    semitransparent rectangle with its right edge coincident with the center of the
    planet sprite (see [Figure 14-19](ch14.xhtml#ch14fig19)). This assumes the sun
    is to the right of the screen and that it is either the vernal or autumnal equinox
    on Mars.'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 14-14](ch14.xhtml#ch14list14) 定义了一个函数，赋予火星一个“暗面”并在行星后面投下阴影。阴影将是一个黑色、半透明的矩形，其右边缘与行星精灵的中心重合（参见
    [Figure 14-19](ch14.xhtml#ch14fig19)）。这假设太阳位于屏幕的右侧，并且火星正处于春分或秋分时。'
- en: '![image](../images/f0312-01.jpg)'
  id: totrans-390
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0312-01.jpg)'
- en: '*Figure 14-19: Shadow rectangle in semitransparent white (left) and final semitransparent
    black (right)*'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '*Figure 14-19: 半透明白色的阴影矩形（左）和最终的半透明黑色阴影矩形（右）*'
- en: '*mars_orbiter.py,* part 14'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '*mars_orbiter.py,* 第14部分'
- en: '➊ def cast_shadow(screen):'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ def cast_shadow(screen):'
- en: '"""Add optional terminator & shadow behind planet to screen."""'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '"""向屏幕添加可选的终止符和行星后面的阴影。"""'
- en: ➋ shadow = pg.Surface((400, 100), flags=pg.SRCALPHA)  # tuple is w,h
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '➋ shadow = pg.Surface((400, 100), flags=pg.SRCALPHA)  # 元组是宽度，高度'
- en: ➌ shadow.fill((0, 0, 0, 210))  # last number sets transparency
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '➌ shadow.fill((0, 0, 0, 210))  # 最后一个数字设置透明度'
- en: screen.blit(shadow, (0, 270))  # tuple is top left coordinates
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 'screen.blit(shadow, (0, 270))  # 元组是左上角坐标'
- en: '*Listing 14-14: Defines a function to give Mars a dark side and let it cast
    a shadow*'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 14-14: 定义一个函数为火星赋予暗面并让它投下阴影*'
- en: The cast_shadow() function takes the screen object as an argument ➊. Assign
    a 400 pixel × 100 pixel pygame surface to an object named shadow ➋. Use pygame’s
    SRCALPHA flag—for “source alpha”—to indicate you will use per pixel alpha (transparency).
    Fill the object with black and set alpha—represented by the last number—to 210
    ➌. Alpha is part of the RGBA color system and has valid values of 0 through 255,
    so this is very dark but not completely opaque. Finally, blit the surface to the
    screen, along with the coordinates for its top-left corner. To turn off the shadow,
    just comment out the function call in main() or set the alpha value to 0.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: cast_shadow() 函数将屏幕对象作为参数 ➊。为名为 shadow 的对象分配一个 400 像素 × 100 像素的 pygame 表面 ➋。使用
    pygame 的 SRCALPHA 标志——表示“源透明度”——表明你将使用每个像素的透明度。将该对象填充为黑色并设置 alpha（由最后一个数字表示）为
    210 ➌。Alpha 是 RGBA 颜色系统的一部分，其有效值范围为 0 到 255，因此这是非常暗的，但不是完全不透明。最后，将表面绘制到屏幕上，并指定其左上角的坐标。要关闭阴影，只需在
    main() 中注释掉函数调用或将 alpha 值设置为 0。
- en: '***Defining the main() Function***'
  id: totrans-400
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***定义 main() 函数***'
- en: '[Listing 14-15](ch14.xhtml#ch14list15) begins the definition of the main()
    function that runs the game. The pygame package and the sound mixer are initialized,
    the game screen is set up, and instructions for the player are stored as lists.'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 14-15](ch14.xhtml#ch14list15) 开始定义运行游戏的 main() 函数。初始化了pygame包和声音混音器，设置了游戏屏幕，并将玩家指令存储为列表。'
- en: '*mars_orbiter.py,* part 15'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '*mars_orbiter.py,* 第15部分'
- en: 'def main():'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 'def main():'
- en: '"""Set up labels & instructions, create objects & run the game loop."""'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '"""设置标签和指令，创建对象并运行游戏循环。"""'
- en: ➊ pg.init()  # initialize pygame
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ pg.init()  # 初始化pygame'
- en: '# set up display:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置显示：'
- en: ➋ os.environ['SDL_VIDEO_WINDOW_POS'] = '700, 100'  # set game window origin
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '➋ os.environ[''SDL_VIDEO_WINDOW_POS''] = ''700, 100''  # 设置游戏窗口位置'
- en: ➌ screen = pg.display.set_mode((800, 645), pg.FULLSCREEN)
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ screen = pg.display.set_mode((800, 645), pg.FULLSCREEN)
- en: ➍ pg.display.set_caption("Mars Orbiter")
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ pg.display.set_caption("火星轨道探测器")
- en: ➎ background = pg.Surface(screen.get_size())
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ background = pg.Surface(screen.get_size())
- en: ➏ pg.mixer.init()  # for sound effects
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '➏ pg.mixer.init()  # 用于音效'
- en: ➐ intro_text = [
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: ➐ intro_text = [
- en: ''' The Mars Orbiter experienced an error during Orbit insertion.'','
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '''火星轨道探测器在轨道插入时遇到错误。'''
- en: ''' Use thrusters to correct to a circular mapping orbit without'','
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '''使用推力器修正为圆形绘制轨道，避免'''
- en: ''' running out of propellant or burning up in the atmosphere.'''
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '''燃料耗尽或在大气中烧毁。'''
- en: ']'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: ']'
- en: instruct_text1 = [
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: instruct_text1 = [
- en: '''Orbital altitude must be within 69-120 miles'','
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '''轨道高度必须在69-120英里之间'''
- en: '''Orbital Eccentricity must be < 0.05'','
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '''轨道偏心率必须小于 0.05'''
- en: '''Avoid top of atmosphere at 68 miles'''
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '''避免接近大气层顶部，68英里处'''
- en: ']'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: ']'
- en: instruct_text2 = [
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: instruct_text2 = [
- en: '''Left Arrow = Decrease Dx'','
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '''左箭头 = 减少 Dx'','
- en: '''Right Arrow = Increase Dx'','
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '''右箭头 = 增加 Dx'','
- en: '''Up Arrow = Decrease Dy'','
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '''上箭头 = 减少 Dy'','
- en: '''Down Arrow = Increase Dy'','
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '''下箭头 = 增加 Dy'','
- en: '''Space Bar = Clear Path'','
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '''空格键 = 清除路径'','
- en: '''Escape = Exit Full Screen'''
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '''Esc = 退出全屏'''
- en: ']'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: ']'
- en: '*Listing 14-15: Starts the* main() *function by initializing* pygame *and the
    sound mixer and by setting up the game screen and instructions*'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 14-15: 启动* main() *函数，通过初始化* pygame *和声音混合器，并设置游戏屏幕和说明*'
- en: Start the main() function by initializing pygame ➊. Then, use the os module’s
    environ() method to assign the coordinates of the upper-left corner of the game
    window ➋. This step is not strictly necessary, but I wanted to demonstrate that
    you have control over where windows appear on the desktop.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 启动 main() 函数，首先初始化 pygame ➊。然后，使用 os 模块的 environ() 方法分配游戏窗口左上角的坐标 ➋。这一步虽然不是严格必要的，但我想展示你如何控制窗口在桌面上的位置。
- en: Next, assign a variable to hold the screen object and set the display mode to
    full screen ➌. Use the tuple (800, 645) to specify the screen size to use if the
    player escapes from full-screen mode.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，分配一个变量来保存屏幕对象，并将显示模式设置为全屏 ➌。如果玩家退出全屏模式，使用元组 (800, 645) 来指定屏幕的大小。
- en: Now use pygame’s display.set_caption() method to name the game window “Mars
    Orbiter” ➍. Then, use pygame’s Surface class to create a background object for
    the game that’s the same size as the screen ➎.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用 pygame 的 display.set_caption() 方法将游戏窗口命名为 “火星轨道器” ➍。然后，使用 pygame 的 Surface
    类创建一个与屏幕大小相同的游戏背景对象 ➎。
- en: Initialize pygame’s sound mixer so you can play the thruster sound effect ➏.
    You defined this sound earlier in the satellite’s initialization method.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化 pygame 的声音混合器，以便播放推进器的音效 ➏。你在卫星的初始化方法中早已定义了这个声音。
- en: The game will start with a short introduction that will vanish after 15 seconds.
    Permanent legends describing keyboard controls and win conditions occupy the bottom
    corners of the screen. Enter the text for these as lists ➐. Later, you will pass
    these lists to the instruct_label() function you wrote in [Listing 14-12](ch14.xhtml#ch14list12).
    Each item in the list, delineated by a comma, will appear as a separate line in
    the game window (see [Figure 14-19](ch14.xhtml#ch14fig19)).
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏将从一个简短的介绍开始，15秒后会消失。描述键盘控制和胜利条件的永久性说明占据了屏幕的底部角落。将这些内容以列表形式输入 ➐。稍后，你将把这些列表传递给你在
    [Listing 14-12](ch14.xhtml#ch14list12) 中编写的 instruct_label() 函数。列表中的每个项目，按逗号分隔，将在游戏窗口中作为单独的行显示（参见
    [Figure 14-19](ch14.xhtml#ch14fig19)）。
- en: '***Instantiating Objects, Setting Up Orbit Verification, Mapping, and Timekeeping***'
  id: totrans-436
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***实例化对象、设置轨道验证、映射和时间管理***'
- en: '[Listing 14-16](ch14.xhtml#ch14list16), still in the main() function, instantiates
    the planet and satellite objects, assigns some useful variables for determining
    orbital eccentricity, prepares the game clock within the function, and assigns
    a variable to track the state of the mapping functionality.'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 14-16](ch14.xhtml#ch14list16)，仍然在 main() 函数中，实例化行星和卫星对象，分配一些有用的变量来确定轨道偏心率，准备函数内的游戏时钟，并分配一个变量来跟踪映射功能的状态。'
- en: '*mars_orbiter.py,* part 16'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '*mars_orbiter.py,* 第16部分'
- en: '# instantiate planet and satellite objects'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '# 实例化行星和卫星对象'
- en: ➊ planet = Planet()
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ planet = Planet()
- en: ➋ planet_sprite = pg.sprite.Group(planet)
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ planet_sprite = pg.sprite.Group(planet)
- en: ➌ sat = Satellite(background)
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ sat = Satellite(background)
- en: ➍ sat_sprite = pg.sprite.Group(sat)
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ sat_sprite = pg.sprite.Group(sat)
- en: '# for circular orbit verification'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '# 用于圆形轨道验证'
- en: ➎ dist_list = []
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ dist_list = []
- en: ➏ eccentricity = 1
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: ➏ eccentricity = 1
- en: ➐ eccentricity_calc_interval = 5  # optimized for 120 mile altitude
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '➐ eccentricity_calc_interval = 5  # 针对120英里高度优化'
- en: '# time keeping'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '# 时间管理'
- en: ➑ clock = pg.time.Clock()
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: ➑ clock = pg.time.Clock()
- en: fps = 30
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: fps = 30
- en: tick_count = 0
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: tick_count = 0
- en: '# for soil moisture mapping functionality'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '# 用于土壤湿度映射功能'
- en: ➒ mapping_enabled = False
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: ➒ mapping_enabled = False
- en: '*Listing 14-16: Instantiates objects and assigns useful variables in* main()'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 14-16: 在* main() *函数中实例化对象并分配有用的变量*'
- en: Continue the main() function by creating a planet object from the Planet class
    ➊, then place it in a sprite group ➋. Remember from [Chapter 13](ch13.xhtml#ch13)
    that pygame manages sprites using containers called *groups*.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 继续 main() 函数，首先创建一个来自 Planet 类的行星对象 ➊，然后将其放入一个精灵组 ➋。记得在 [第13章](ch13.xhtml#ch13)
    中提到，pygame 使用叫做 *组* 的容器来管理精灵。
- en: Next, instantiate a satellite object, passing the Satellite class’s initialization
    method the background object ➌. The satellite needs the background for drawing
    its path.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，实例化一个卫星对象，将背景对象传递给卫星类的初始化方法 ➌。卫星需要背景来绘制它的轨迹。
- en: After creating the satellite, put it in its own sprite group ➍. You should generally
    keep radically different sprite types in their own containers. This makes it easy
    to manage things like display order and collision handling.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 创建卫星后，将它放入自己的精灵组中➍。通常，应该将不同类型的精灵保持在各自的容器中，这样可以方便地管理显示顺序和碰撞处理等。
- en: Now, assign some variables to help with calculating eccentricity. Start an empty
    list to hold the distance values calculated in each game loop ➎, then assign an
    eccentricity variable a placeholder value of 1 ➏, indicating a noncircular starting
    orbit.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，分配一些变量来帮助计算偏心率。首先创建一个空列表，用于保存每次游戏循环中计算的距离值➎，然后给偏心率变量赋一个占位值1➏，表示一个非圆形的起始轨道。
- en: You’ll want to update the eccentricity variable regularly to evaluate any changes
    the player makes to the orbit. Remember, you need the orbit’s apoapsis and periapsis
    to calculate eccentricity, and for large, elliptical orbits, it may take a while
    to actually sample these. The good news is that you only need to consider “winning”
    orbits between 69 and 120 miles. So, you can optimize the sampling rate for orbits
    below 120 miles, which generally take the satellite sprite less than 6 seconds
    to complete. Use 5 seconds and assign this value to an eccentricity_calc_interval
    variable ➐. This means that, for orbits with altitudes above 120 miles, the calculated
    eccentricity may not be technically correct, but it will be good enough considering
    the orbit doesn’t satisfy the winning conditions at that altitude.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 你将需要定期更新偏心率变量，以评估玩家对轨道所做的任何更改。记住，你需要轨道的远地点和近地点来计算偏心率，对于大而椭圆的轨道，可能需要一段时间才能实际采样这些值。好消息是，你只需要考虑“获胜”轨道的高度在69到120英里之间。因此，你可以为低于120英里的轨道优化采样率，这些轨道通常只需要不到6秒钟的时间来完成。使用5秒钟，并将这个值赋给eccentricity_calc_interval变量➐。这意味着，对于高度超过120英里的轨道，计算出的偏心率可能不完全准确，但考虑到该轨道在该高度下不满足获胜条件，这个偏心率足够用了。
- en: Address timekeeping next. Use a clock variable to hold pygame’s game clock,
    which will control the speed of the game in frames per second ➑. Each frame will
    represent one tick of the clock. Assign a variable named fps a value of 30, which
    means the game will update 30 times per second. Next, assign a tick_count variable
    that you’ll use to determine when to clear the introduction text and when to call
    the calc_eccentricity() function.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来处理时间记录。使用一个时钟变量来保存pygame的游戏时钟，这将控制游戏的帧率（每秒帧数）➑。每一帧代表时钟的一次滴答。给一个变量fps赋值为30，意味着游戏将每秒更新30次。接着，定义一个tick_count变量，用于确定何时清除介绍文本以及何时调用calc_eccentricity()函数。
- en: Finish the section by naming a variable to enable the mapping functionality
    and set it to False ➒. If the player achieves the winning conditions, you’ll change
    this to True.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 通过命名一个变量来启用映射功能，并将其设置为False ➒。如果玩家达成获胜条件，你将把它改为True。
- en: '***Starting the Game Loop and Playing Sounds***'
  id: totrans-462
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***开始游戏循环并播放声音***'
- en: '[Listing 14-17](ch14.xhtml#ch14list17), still in the main() function, starts
    the game clock and while loop, also referred to as the *game loop*. It also receives
    events, such as a player firing thrusters using the arrow keys. If the player
    fires the thrusters, the Ogg Vorbis audio file plays, and the player hears a satisfying
    hiss.'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 14-17](ch14.xhtml#ch14list17)，仍在main()函数中，启动了游戏时钟和while循环，也称为*游戏循环*。它还接收事件，例如玩家使用箭头键发射推进器。如果玩家发射推进器，Ogg
    Vorbis音频文件将播放，玩家将听到令人满意的嘶嘶声。'
- en: '*mars_orbiter.py,* part 17'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '*mars_orbiter.py,* 第17部分'
- en: ➊ running = True
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ running = True
- en: 'while running:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 'while running:'
- en: ➋ clock.tick(fps)
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ clock.tick(fps)
- en: tick_count += 1
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: tick_count += 1
- en: ➌ dist_list.append(sat.distance)
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ dist_list.append(sat.distance)
- en: '# get keyboard input'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: '# 获取键盘输入'
- en: '➍ for event in pg.event.get():'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '➍ for event in pg.event.get():'
- en: ➎ if event.type == pg.QUIT:  # close window
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '➎ if event.type == pg.QUIT:  # 关闭窗口'
- en: running = False
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: running = False
- en: '➏ elif event.type == pg.KEYDOWN and event.key == pg.K_ESCAPE:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '➏ elif event.type == pg.KEYDOWN and event.key == pg.K_ESCAPE:'
- en: screen = pg.display.set_mode((800, 645))  # exit full screen
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 'screen = pg.display.set_mode((800, 645))  # 退出全屏'
- en: '➐ elif event.type == pg.KEYDOWN and event.key == pg.K_SPACE:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '➐ elif event.type == pg.KEYDOWN and event.key == pg.K_SPACE:'
- en: background.fill(BLACK)  # clear path
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 'background.fill(BLACK)  # 清除路径'
- en: '➑ elif event.type == pg.KEYUP:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '➑ elif event.type == pg.KEYUP:'
- en: ➒ sat.thrust.stop()  # stop sound
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '➒ sat.thrust.stop()  # 停止声音'
- en: mapping_off(planet)  # turn off moisture map view
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 'mapping_off(planet)  # 关闭湿度地图视图'
- en: '➓ elif mapping_enabled:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '➓ elif mapping_enabled:'
- en: 'if event.type == pg.KEYDOWN and event.key == pg.K_m:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 'if event.type == pg.KEYDOWN and event.key == pg.K_m:'
- en: mapping_on(planet)
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: mapping_on(planet)
- en: '*Listing 14-17: Starts the game loop, gets events, and plays sounds in* main()'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 14-17：在主函数中开始游戏循环，获取事件，并播放声音*'
- en: First assign a running variable for use with the while loop that runs the game
    ➊, then start the loop. Set the game speed using the clock’s tick() method and
    pass it the fps variable you named in the previous listing ➋. If the game feels
    slow to you, set the speed to 40 fps. For each loop—or frame—increment the clock-based
    counter by 1.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 首先为运行游戏的 while 循环分配一个运行变量 ➊，然后开始循环。使用时钟的 `tick()` 方法设置游戏速度，并传入你在前面列出的 `fps`
    变量。如果游戏感觉慢，可以将速度设置为 40 fps。对于每次循环——或每一帧——将基于时钟的计数器增加 1。
- en: Next, append the satellite object’s sat.distance value to dist_list ➌. This
    is the distance between the satellite and the planet, calculated each game loop
    by the satellite’s locate() method.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将卫星对象的 `sat.distance` 值附加到 `dist_list` ➌。这是卫星和行星之间的距离，通过卫星的 `locate()` 方法在每个游戏循环中计算得出。
- en: Now, gather player input made through the keyboard ➍. As described in the previous
    chapter, pygame records every user interaction—called an *event*—in an event buffer.
    The event.get() method creates a list of these events that you can evaluate, in
    this case, with if statements. Start by checking if the player closed the window
    to quit the game ➎. If this is True, set running to False to end the game loop.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，收集玩家通过键盘输入的内容 ➍。如前一章节所述，pygame 会记录每个用户交互——称为 *事件*——并将其存储在事件缓冲区中。`event.get()`
    方法创建一个事件列表，你可以通过 if 语句进行评估。在这里，首先检查玩家是否关闭了窗口退出游戏 ➎。如果是，则将 `running` 设置为 False
    来结束游戏循环。
- en: If the player presses ESC, they are exiting full-screen mode, so reset the screen
    size to 800 × 645 pixels using the display.set_mode() method that you called at
    the start of main() ➏. If the player presses the space bar, fill the background
    with black, which will erase the white orbital path of the satellite ➐.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家按下 ESC 键，表示退出全屏模式，因此使用 `display.set_mode()` 方法将屏幕大小重置为 800 × 645 像素，这个方法在主函数开始时已经调用过
    ➏。如果玩家按下空格键，则将背景填充为黑色，这将擦除卫星的白色轨道路径 ➐。
- en: When the player presses an arrow key, the satellite object plays the hissing
    sound, but nothing in its check_keys() method tells it to stop. So, pass pygame
    any KEYUP events ➑; when pygame reads that the player has released the arrow key,
    call the stop() method on thrust to stop the sound from playing ➒.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家按下箭头键时，卫星对象会播放嘶嘶声，但在其 `check_keys()` 方法中没有任何内容告诉它停止播放声音。因此，传递任何 KEYUP 事件给
    pygame ➑；当 pygame 检测到玩家释放了箭头键时，调用 `thrust` 的 `stop()` 方法以停止声音播放 ➒。
- en: To map Mars, the player will have to hold down the M key, so use the same KEYUP
    event to call the mapping_off() function. This will reset the planet image to
    its normal, nonmapped state.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 为了绘制火星，玩家需要按住 M 键，因此使用相同的 KEYUP 事件来调用 `mapping_off()` 函数。这将把行星图像重置为正常的、未映射的状态。
- en: Finally, check whether the mapping_enabled variable is True, meaning the player
    has achieved the winning conditions and is ready to map Mars ➓. If they press
    the M key, call the mapping_on() function to show the soil moisture overlay in
    place of the normal view of the planet.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，检查 `mapping_enabled` 变量是否为 True，这意味着玩家已达成胜利条件，准备绘制火星 ➓。如果他们按下 M 键，调用 `mapping_on()`
    函数来显示土壤湿度覆盖图，替代行星的正常视图。
- en: '***Applying Gravity, Calculating Eccentricity, and Handling Failure***'
  id: totrans-492
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***应用重力、计算偏心率和处理失败***'
- en: '[Listing 14-18](ch14.xhtml#ch14list18) continues the while loop of the main()
    function by exerting a gravity force on the satellite and then calculating the
    eccentricity of its orbit. The eccentricity value will determine whether the orbit
    is circular or not, one of the game’s winning conditions. The listing also blits
    the background and responds to the fail conditions of running out of fuel or burning
    up in the atmosphere.'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 14-18](ch14.xhtml#ch14list18) 继续执行 `main()` 函数中的 while 循环，对卫星施加重力并计算其轨道的偏心率。偏心率值将决定轨道是否为圆形，这是游戏的胜利条件之一。此列表还会绘制背景，并响应因燃料耗尽或在大气中烧毁而导致的失败条件。'
- en: '*mars_orbiter.py,* part 18'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: '*mars_orbiter.py,* 第 18 部分'
- en: '# get heading & distance to planet & apply gravity'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: '# 获取航向与行星的距离并施加重力'
- en: ➊ sat.locate(planet)
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ sat.locate(planet)
- en: planet.gravity(sat)
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: planet.gravity(sat)
- en: '# calculate orbital eccentricity'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '# 计算轨道偏心率'
- en: '➋ if tick_count % (eccentricity_calc_interval * fps) == 0:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ 如果 `tick_count % (eccentricity_calc_interval * fps) == 0`：
- en: eccentricity = calc_eccentricity(dist_list)
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: eccentricity = calc_eccentricity(dist_list)
- en: ➌ dist_list = []
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ dist_list = []
- en: '# re-blit background for drawing command - prevents clearing path'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: '# 重新绘制背景以防止路径被清除'
- en: ➍ screen.blit(background, (0, 0))
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ screen.blit(background, (0, 0))
- en: '# Fuel/Altitude fail conditions'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: '# 燃料/高度失败条件'
- en: '➎ if sat.fuel <= 0:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: '➎ if sat.fuel <= 0:'
- en: ➏ instruct_label(screen, ['Fuel Depleted!'], RED, 340, 195)
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: ➏ instruct_label(screen, ['燃料耗尽！'], RED, 340, 195)
- en: sat.fuel = 0
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: sat.fuel = 0
- en: sat.dx = 2
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: sat.dx = 2
- en: '➐ elif sat.distance <= 68:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: '➐ elif sat.distance <= 68:'
- en: instruct_label(screen, ['Atmospheric Entry!'], RED, 320, 195)
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: instruct_label(screen, ['大气层进入！'], RED, 320, 195)
- en: sat.dx = 0
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: sat.dx = 0
- en: sat.dy = 0
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: sat.dy = 0
- en: '*Listing 14-18: Applies gravity, calculates eccentricity, and addresses fail
    conditions*'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: '*代码清单14-18：应用重力，计算偏心率，并处理失败条件*'
- en: Call the satellite’s locate() method and pass it the planet object as an argument
    ➊. This method computes the heading and distance to Mars, which you use to point
    the dish, calculate orbital eccentricity, and apply gravity. Then, to apply the
    force of gravity, call the planet’s gravity() method and pass it the satellite
    object.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 调用卫星的locate()方法并将行星对象作为参数传递➊。该方法计算指向火星的航向和距离，你可以利用这些数据来调整天线的方向、计算轨道偏心率并应用重力。然后，为了施加重力，调用行星的gravity()方法并传递卫星对象。
- en: If the modulus of the tick_count and the eccentricity_calc_interval * fps is
    0 ➋, call the function that calculates eccentricity and pass it the dist_list
    variable. Then, reset the dist_list variable to 0 to restart the distance sampling
    ➌.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 如果tick_count的模与偏心率计算间隔 * fps的乘积为0 ➋，调用计算偏心率的函数，并传递dist_list变量。然后，重置dist_list变量为0，重新开始距离采样➌。
- en: Next, call the screen’s blit() method and pass it the background and coordinates
    for the upper-left corner ➍. The placement of this statement matters. For example,
    if you move it after the code that updates the sprites, you won’t see the satellite
    or Mars on the game screen.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，调用屏幕的blit()方法，并传递背景和左上角的坐标 ➍。这个语句的位置很重要。例如，如果你将它放在更新精灵的代码之后，你将看不到卫星或火星出现在游戏屏幕上。
- en: Now, handle the case where the player runs out of fuel before achieving a circular
    orbit. First, get the current fuel level from the satellite object’s fuel attribute
    ➎. If the level is at or below 0, use the instruct_label() function to announce
    that the fuel is spent ➏, then set the satellite’s dx attribute to 2. This will
    cause the satellite sprite to quickly fly off the screen and into the depths of
    space, with the altitude readout getting larger and larger. Though unrealistic,
    this ensures the player knows they have failed!
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，处理玩家在没有达到圆形轨道之前燃料耗尽的情况。首先，从卫星对象的fuel属性获取当前燃料水平➎。若燃料水平为0或更低，使用instruct_label()函数宣布燃料已耗尽➏，然后将卫星的dx属性设置为2。这将导致卫星精灵迅速飞出屏幕，进入深空，且高度读数会变得越来越大。尽管不现实，但这确保玩家知道他们失败了！
- en: The last failure case is when the player burns up in the atmosphere. If the
    satellite’s distance attribute is less than or equal to 68 ➐, make a label near
    the center of the screen that lets the player know they have entered the atmosphere
    and then set the satellite’s velocity attributes equal to 0. This will cause gravity
    to lock the sprite against the planet ([Figure 14-20](ch14.xhtml#ch14fig20)).
    Also, when dx and dy are 0, the satellite’s update() method ([Listing 14-7](ch14.xhtml#ch14list7))
    will switch the satellite’s image to the red “crashed” version.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种失败情况是当玩家在大气层中燃烧时。如果卫星的距离属性小于或等于68 ➐，在屏幕中央附近制作一个标签，让玩家知道他们已进入大气层，然后将卫星的速度属性设置为0。这将导致重力将精灵锁定在行星上（[图14-20](ch14.xhtml#ch14fig20)）。此外，当dx和dy为0时，卫星的update()方法（[代码清单14-7](ch14.xhtml#ch14list7)）会将卫星的图像切换为红色的“坠毁”版本。
- en: '![image](../images/f0317-01.jpg)'
  id: totrans-519
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0317-01.jpg)'
- en: '*Figure 14-20: Satellite in crash configuration*'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-20：卫星坠毁配置*'
- en: The altitude parameter is a bit of a cheat, as altitude equates to the distance
    attribute, which is measured from the *centers* of the planet and satellite sprites,
    rather than from the *surface* of the planet to the satellite. It all comes down
    to scale. Planetary atmospheres are very thin veneers—at the scale of the game,
    the Martian atmosphere would be less than 2 pixels thick! As the game is designed,
    when the tip of the satellite dish scrapes the planet, the satellite will burn
    up, but since the size of the satellite sprite is unrealistically large, the sprite’s
    68-mile center point must be pushed farther out.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 高度参数有点像是作弊，因为高度等同于距离属性，该属性是从行星和卫星精灵的*中心*测量的，而不是从行星表面到卫星的距离。这完全取决于比例。行星大气层非常薄——在游戏的尺度下，火星大气层的厚度不到2个像素！由于游戏的设计，当卫星天线的尖端刮到行星时，卫星将会燃烧，但由于卫星精灵的大小不现实地过大，卫星的68英里中心点必须被推得更远。
- en: '***Rewarding Success and Updating and Drawing Sprites***'
  id: totrans-522
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***奖励成功并更新和绘制精灵***'
- en: '[Listing 14-19](ch14.xhtml#ch14list19), still in the while loop of the main()
    function, rewards the winning player by enabling functionality that lets them
    map the moisture content in the Martian soil. In real life, this might be accomplished
    with radar or microwave resonators, which can remotely measure moisture in bare
    soil down to a depth of a few inches. The listing also updates the planet and
    satellite sprites and draws them to the screen.'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 14-19](ch14.xhtml#ch14list19)，仍然在 main() 函数的 while 循环中，通过启用让玩家映射火星土壤湿度的功能来奖励获胜的玩家。在现实中，这可能通过雷达或微波共振器来完成，这些设备可以远程测量裸土中的水分，深度可达几英寸。此列表还更新了行星和卫星精灵，并将其绘制到屏幕上。'
- en: '*mars_orbiter.py,* part 19'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: '*mars_orbiter.py,* 第 19 部分'
- en: '# enable mapping functionality'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: '# 启用映射功能'
- en: '➊ if eccentricity < 0.05 and sat.distance >= 69 and sat.distance <= 120:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ 如果偏心率 < 0.05 且卫星距离 >= 69 且卫星距离 <= 120:'
- en: ➋ map_instruct = ['Press & hold M to map soil moisture']
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ map_instruct = ['按住 M 键映射土壤湿度']
- en: instruct_label(screen, map_instruct, LT_BLUE, 250, 175)
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: instruct_label(screen, map_instruct, LT_BLUE, 250, 175)
- en: ➌ mapping_enabled = True
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ mapping_enabled = True
- en: 'else:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: mapping_enabled = False
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: mapping_enabled = False
- en: ➍ planet_sprite.update()
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ planet_sprite.update()
- en: ➎ planet_sprite.draw(screen)
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ planet_sprite.draw(screen)
- en: sat_sprite.update()
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: sat_sprite.update()
- en: sat_sprite.draw(screen)
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: sat_sprite.draw(screen)
- en: '*Listing 14-19: Enables mapping functionality and updates sprites in the game
    loop*'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 14-19: 启用映射功能并在游戏循环中更新精灵*'
- en: If the orbit is circular and meets the altitude requirements ➊, display a message
    instructing the player to press the M key to map soil moisture ➋. Put the text
    in brackets, as the instruct_label() function expects a list. Make the text color
    light blue and place it near the center of the screen.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 如果轨道是圆形的并且满足高度要求 ➊，显示一条信息，指示玩家按 M 键映射土壤湿度 ➋。将文本放入方括号中，因为 instruct_label() 函数期望一个列表。将文本颜色设置为浅蓝色，并将其放置在屏幕中心附近。
- en: Next, set the mapping_enabled variable to True ➌; otherwise, if the orbit strays
    outside of the target parameters, set it to False.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将 mapping_enabled 变量设置为 True ➌；否则，如果轨道偏离目标参数，将其设置为 False。
- en: Finish by calling the planet sprite’s update() method, through the sprite group
    ➍, then actually draw it to the screen ➎. The argument for the draw() method is
    the screen, the object on which to draw the sprites. Repeat these steps for the
    satellite sprite.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过精灵组 ➍ 调用行星精灵的 update() 方法，然后实际将其绘制到屏幕上 ➎。draw() 方法的参数是屏幕，即绘制精灵的对象。对卫星精灵重复这些步骤。
- en: '***Displaying Instructions and Telemetry and Casting a Shadow***'
  id: totrans-540
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***显示指令和遥测并投射阴影***'
- en: '[Listing 14-20](ch14.xhtml#ch14list20) completes the while loop and the main()
    function by displaying instructions, data readouts, and the planet’s shadow. The
    game introduction text will be shown only for a short time at startup.'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 14-20](ch14.xhtml#ch14list20) 完成了 while 循环和 main() 函数，通过显示指令、数据读出和行星的阴影。游戏介绍文本仅在启动时短暂显示。'
- en: '*mars_orbiter.py,* part 20'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: '*mars_orbiter.py,* 第 20 部分'
- en: '# display intro text for 15 seconds'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: '# 显示介绍文本 15 秒'
- en: ➊ if pg.time.get_ticks() <= 15000:  # time in milliseconds
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ 如果 pg.time.get_ticks() <= 15000:  # 时间（毫秒）'
- en: instruct_label(screen, intro_text, GREEN, 145, 100)
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: instruct_label(screen, intro_text, GREEN, 145, 100)
- en: '# display telemetry and instructions'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: '# 显示遥测和说明'
- en: ➋ box_label(screen, 'Dx', (70, 20, 75, 20))
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ box_label(screen, 'Dx', (70, 20, 75, 20))
- en: box_label(screen, 'Dy', (150, 20, 80, 20))
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: box_label(screen, 'Dy', (150, 20, 80, 20))
- en: box_label(screen, 'Altitude', (240, 20, 160, 20))
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: box_label(screen, '高度', (240, 20, 160, 20))
- en: box_label(screen, 'Fuel', (410, 20, 160, 20))
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: box_label(screen, '燃料', (410, 20, 160, 20))
- en: box_label(screen, 'Eccentricity', (580, 20, 150, 20))
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: box_label(screen, '偏心率', (580, 20, 150, 20))
- en: ➌ box_label(screen, '{:.1f}'.format(sat.dx), (70, 50, 75, 20))
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ box_label(screen, '{:.1f}'.format(sat.dx), (70, 50, 75, 20))
- en: box_label(screen, '{:.1f}'.format(sat.dy), (150, 50, 80, 20))
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: box_label(screen, '{:.1f}'.format(sat.dy), (150, 50, 80, 20))
- en: box_label(screen, '{:.1f}'.format(sat.distance), (240, 50, 160, 20))
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: box_label(screen, '{:.1f}'.format(sat.distance), (240, 50, 160, 20))
- en: box_label(screen, '{}'.format(sat.fuel), (410, 50, 160, 20))
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: box_label(screen, '{}'.format(sat.fuel), (410, 50, 160, 20))
- en: box_label(screen, '{:.8f}'.format(eccentricity), (580, 50, 150, 20))
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: box_label(screen, '{:.8f}'.format(eccentricity), (580, 50, 150, 20))
- en: ➍ instruct_label(screen, instruct_text1, WHITE, 10, 575)
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ instruct_label(screen, instruct_text1, WHITE, 10, 575)
- en: instruct_label(screen, instruct_text2, WHITE, 570, 510)
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: instruct_label(screen, instruct_text2, WHITE, 570, 510)
- en: '# add terminator & border'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: '# 添加终结线和边框'
- en: ➎ cast_shadow(screen)
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ cast_shadow(screen)
- en: ➏ pg.draw.rect(screen, WHITE, (1, 1, 798, 643), 1)
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: ➏ pg.draw.rect(screen, WHITE, (1, 1, 798, 643), 1)
- en: ➐ pg.display.flip()
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: ➐ pg.display.flip()
- en: '➑ if __name__ == "__main__":'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: '➑ if __name__ == "__main__":'
- en: main()
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: main()
- en: '*Listing 14-20: Displays text and planet’s shadow and calls the* main() *function*'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 14-20: 显示文本和行星阴影并调用* main() *函数*'
- en: The text summarizing the game should hover near the middle of the screen just
    long enough to be read, then vanish. Control this using an if statement and the
    pygame tick.get_ticks() method, which returns the number of milliseconds that
    have elapsed since the game started. If fewer than 15 seconds have passed, use
    the instruct_label() function to display the list of text strings from [Listing
    14-15](ch14.xhtml#ch14list15) in green.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 概述游戏的文字应该停留在屏幕中间的位置，足够长时间让玩家阅读后消失。可以使用 if 语句和 pygame 的 tick.get_ticks() 方法来控制，后者返回游戏开始以来已过的毫秒数。如果过去的时间少于
    15 秒，使用 instruct_label() 函数以绿色显示来自 [Listing 14-15](ch14.xhtml#ch14list15) 的文字列表。
- en: Next, make the gauges for the data readouts, starting with the header boxes.
    Use the box_label() function and call it for each of the five readout gauges ➋.
    Repeat this for the data readouts ➌. Note that you can use the string format method
    when you pass the function the text.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为数据读数创建仪表，从标题框开始。使用 box_label() 函数，并为每个读数仪表 ➋ 调用它。对数据读数 ➌ 重复此操作。注意，当你传递文本给函数时，可以使用字符串格式化方法。
- en: Use the instruct_label() function to place the instructions made in [Listing
    14-15](ch14.xhtml#ch14list15) in the bottom corners of the screen ➍. Feel free
    to change the text color if you want to distinguish between those that describe
    the winning conditions and those that define the key functions.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 instruct_label() 函数将 [Listing 14-15](ch14.xhtml#ch14list15) 中的指令放置在屏幕的底角
    ➍。如果你想区分描述获胜条件和定义关键功能的文本，可以随意更改文本颜色。
- en: Now, call the function that displays the planet’s shadow ➎ and then, as a finishing
    touch, add a border using pygame’s draw.rect() method ➏. Pass it the screen object,
    the border color, the corner coordinates, and a line width.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，调用显示行星阴影的函数 ➎，然后作为最后的修饰，使用 pygame 的 draw.rect() 方法添加边框 ➏。传递给它屏幕对象、边框颜色、角坐标和线宽。
- en: Finish the main() function and its game loop by flipping the display ➐. As described
    in the preceding chapter, the flip() method blits everything from the screen object
    to the visual display.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 完成 main() 函数及其游戏循环，方法是翻转显示器 ➐。正如前一章所述，flip() 方法将所有内容从屏幕对象绘制到可视显示器上。
- en: Finally, call main() in the global space, using the standard syntax for running
    it stand-alone or as a module ➑.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在全局空间中调用 main()，使用标准语法以独立运行或作为模块 ➑。
- en: '**Summary**'
  id: totrans-572
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter, you used pygame to build a 2D, arcade-style game with image
    sprites, sound effects, and keyboard game controls. You also created a fun, heuristic
    method for learning orbital mechanics. All of the techniques shown in “[Astrodynamics
    for Gamers](ch14.xhtml#lev315)” on [page 286](ch14.xhtml#page_286) should work
    in the game. In the following section, “Challenge Projects,” you can continue
    to improve both the game and the player experience.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你使用 pygame 构建了一个 2D 街机风格的游戏，包含图像精灵、音效和键盘控制。你还创建了一个有趣的启发式方法来学习轨道力学。所有在 “[为游戏者介绍天体动力学](ch14.xhtml#lev315)”
    第286页 [链接](ch14.xhtml#page_286) 中展示的技术都应该可以在游戏中使用。在接下来的部分“挑战项目”中，你可以继续改进游戏和玩家体验。
- en: '**Challenge Projects**'
  id: totrans-574
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**挑战项目**'
- en: Make the Mars Orbiter game your own by improving it and adding new challenges
    based on the following suggestions. As always, no solutions are provided to challenge
    projects.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 通过改进火星轨道探测器游戏并根据以下建议添加新的挑战，使其成为你自己的游戏。和往常一样，挑战项目没有提供解决方案。
- en: '***Game Title Screen***'
  id: totrans-576
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***游戏标题画面***'
- en: Copy and edit the *mars_orbiter.py* program so that a title screen appears for
    a short time before the main game screen. Have the title screen display a NASA-type
    mission patch, like the one for the *Mars Global Surveyor* ([Figure 14-21](ch14.xhtml#ch14fig21)),
    but make it unique to the Mars Orbiter in the game. You can see some other NASA
    patches, in color, at *[https://space.jpl.nasa.gov/art/patches.html](https://space.jpl.nasa.gov/art/patches.html)*.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 复制并编辑 *mars_orbiter.py* 程序，使得标题画面在主游戏画面之前短暂出现。让标题画面显示类似于 *火星全球探测器* 的 NASA 类型任务徽章
    ([图14-21](ch14.xhtml#ch14fig21))，但要确保它在游戏中独特地适用于火星轨道探测器。你可以在 *[https://space.jpl.nasa.gov/art/patches.html](https://space.jpl.nasa.gov/art/patches.html)*
    上查看一些其他的 NASA 徽章（彩色版本）。
- en: '![image](../images/f0320-01.jpg)'
  id: totrans-578
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0320-01.jpg)'
- en: '*Figure 14-21:* Mars Global Surveyor *mission patch*'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-21:* 火星全球探测器 *任务徽章*'
- en: '***Smart Gauges***'
  id: totrans-580
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***智能仪表***'
- en: 'Copy and edit the *mars_orbiter.py* program so that the altitude and eccentricity
    readouts use either a red background or red text color when their values are outside
    of the target ranges. But be careful: a circular eccentricity value should stay
    red until the altitude value is in range!'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 复制并编辑*mars_orbiter.py*程序，使得当高度和偏心率超出目标范围时，读数使用红色背景或红色文本颜色。但要小心：圆形轨道的偏心率值应保持红色，直到高度值进入范围！
- en: '***Radio Blackout***'
  id: totrans-582
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***无线电黑障***'
- en: Copy and edit the *mars_orbiter.py* program so that keyboard controls are locked
    when the satellite is within the shadow rectangle.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 复制并编辑*mars_orbiter.py*程序，使得当卫星处于阴影矩形区域内时，键盘控制被锁定。
- en: '***Scoring***'
  id: totrans-584
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***评分***'
- en: Copy and edit the *mars_orbiter.py* program so that it scores the player and
    keeps the best results in a displayable high-scores list. Highest scores go to
    those achieving the lowest allowable orbit while using the least amount of fuel
    in the least amount of time. For example, the fuel component of the score could
    be the amount of remaining fuel; for the orbit component, the maximum allowable
    altitude (120) minus the altitude of the circular orbit; and for the time component,
    the inverse of the time taken to achieve the circular orbit multiplied by 1,000\.
    Add the three components together for the final score.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 复制并编辑*mars_orbiter.py*程序，使其能够为玩家评分，并将最佳成绩显示在一个可显示的高分列表中。最高分奖励给那些以最少的燃料和时间达到最低允许轨道的人。例如，得分的燃料部分可以是剩余的燃料量；轨道部分为最大允许高度（120）减去圆形轨道的高度；时间部分为达到圆形轨道所用时间的倒数乘以1,000。将这三个部分相加得到最终得分。
- en: '***Strategy Guide***'
  id: totrans-586
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***策略指南***'
- en: Copy and edit the *mars_orbiter.py* program so it includes a pop-up strategy
    guide, or help file, by incorporating some of the figures in “[Astrodynamics for
    Gamers](ch14.xhtml#lev315)” on [page 286](ch14.xhtml#page_286). For example, add
    a line to the instructions telling the player to press and hold the H key for
    help. This could bring up and cycle through the images of different orbital maneuvers,
    such as the Hohmann transfer or the One-Tangent Burn. Be sure to include comments
    on the strengths and weaknesses of each technique and pause the game while the
    guide is open.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 复制并编辑*mars_orbiter.py*程序，添加一个弹出式策略指南或帮助文件，通过在[《游戏者的天体动力学》](ch14.xhtml#lev315)一书中的某些图像（在[286页](ch14.xhtml#page_286)）来实现。例如，添加一行指令，告诉玩家按住H键以获取帮助。这样可以弹出并循环展示不同的轨道机动图像，例如霍曼转移轨道或单切点燃烧。确保包含关于每种技巧的优缺点的评论，并在指南打开时暂停游戏。
- en: '***Aerobraking***'
  id: totrans-588
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***大气刹车***'
- en: Aerobraking is a fuel-saving technique that uses atmospheric friction to slow
    down a spacecraft ([Figure 14-22](ch14.xhtml#ch14fig22)). Copy and edit the *mars_orbiter.py*
    program to include aerobraking. In the main() function, set the lowest winning
    altitude to 70 miles and the lowest safe altitude to 60 miles. If the satellite’s
    altitude is between 60 and 70 miles, reduce its velocity by a small amount.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 大气刹车是一种节省燃料的技术，利用大气摩擦减慢航天器的速度（[图 14-22](ch14.xhtml#ch14fig22)）。复制并编辑*mars_orbiter.py*程序以包括大气刹车。在main()函数中，将最低获胜高度设置为70英里，最低安全高度设置为60英里。如果卫星的高度在60到70英里之间，则减小其速度。
- en: '![image](../images/f0321-01.jpg)'
  id: totrans-590
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0321-01.jpg)'
- en: '*Figure 14-22: Circularizing an orbit using the atmosphere in place of a retrograde
    burn*'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-22：使用大气而不是逆行燃烧来圆化轨道。*'
- en: '[Figure 14-23](ch14.xhtml#ch14fig23) is an example of using aerobraking in
    the game to circularize an elliptical orbit. The top of the atmosphere was set
    at 80 miles. Aerobraking serves the same purpose as a retrograde burn at periapsis,
    but you have to be cautious and patient and raise the orbit out of the atmosphere
    before it becomes circular.'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 14-23](ch14.xhtml#ch14fig23)展示了游戏中如何利用大气刹车来圆化椭圆轨道。大气层的顶部设定为80英里。大气刹车与逆行燃烧在近日点时的作用相同，但你必须小心耐心，确保在轨道变圆之前将轨道升出大气层。'
- en: '![image](../images/f0322-01.jpg)'
  id: totrans-593
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0322-01.jpg)'
- en: '*Figure 14-23: Circularizing an orbit using aerobraking. Note the low fuel
    consumption.*'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-23：使用大气刹车将轨道圆化。请注意低燃料消耗。*'
- en: NASA used a similar technique to move the *Mars Global Surveyor* from its elliptical
    capture orbit to its final mapping orbit. This process took many months to accomplish,
    because they needed to protect the spacecraft from overheating in the atmosphere.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: NASA 使用类似的技术将*火星全球勘测者*从其椭圆形捕获轨道移动到最终的制图轨道。这个过程花费了数月的时间，因为他们需要保护航天器避免在大气层中过热。
- en: '***Intruder Alert!***'
  id: totrans-596
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***入侵警告！***'
- en: Copy and edit the *mars_orbiter.py* program so that a new planet object is instantiated
    and flies across the screen, disrupting the satellite’s orbit with its gravity.
    Make a new sprite to represent a comet or asteroid and launch it at random intervals
    (but not *too* often!). Don’t apply Mars’s gravity() method to the object so that
    it doesn’t enter Martian orbit, but apply the new object’s gravity() method to
    the satellite. Play with the new object’s mass so that it noticeably perturbs
    the satellite’s orbit from 100 or so pixels away. Allow the object to pass Mars
    or the satellite without colliding.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 复制并编辑 *mars_orbiter.py* 程序，使得新的行星对象被实例化并穿越屏幕，利用其引力扰动卫星的轨道。创建一个新的精灵来表示彗星或小行星，并以随机间隔发射（但不要*过于*频繁！）。不要对该对象应用火星的
    gravity() 方法，以避免它进入火星轨道，而是应用新对象的 gravity() 方法到卫星上。调整新对象的质量，使其能在大约 100 像素的距离内明显扰动卫星的轨道。允许该对象穿越火星或卫星而不发生碰撞。
- en: '***Over the Top***'
  id: totrans-598
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***从上至下***'
- en: The Mars Orbiter currently uses an *equatorial* orbit. This is for easy coding,
    since you only need to rotate a single Mars image. But true mapping orbits use
    polar orbits—oriented perpendicular to equatorial orbits—and pass over the planet’s
    poles ([Figure 14-24](ch14.xhtml#ch14fig24)). As the planet rotates beneath the
    orbit, the satellite can map its entire surface. With equatorial orbits, high
    latitudes are essentially unmappable due to curvature of the planet’s surface
    (see the dashed line in [Figure 14-24](ch14.xhtml#ch14fig24)).
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 火星探测器目前使用的是*赤道*轨道。这是为了便于编码，因为你只需要旋转一张火星图像。但真实的映射轨道使用的是极轨道——与赤道轨道垂直——并且会经过行星的两极（见[图
    14-24](ch14.xhtml#ch14fig24)）。随着行星在轨道下方自转，卫星可以映射其整个表面。使用赤道轨道时，由于行星表面的曲率，高纬度地区实际上是无法映射的（参见[图
    14-24](ch14.xhtml#ch14fig24)中的虚线）。
- en: '![image](../images/f0323-01.jpg)'
  id: totrans-600
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0323-01.jpg)'
- en: '*Figure 14-24: Polar versus equatorial orbits; notional north and south mapping
    limits for an equatorial orbit are represented by the dashed line.*'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-24：极轨与赤道轨道的对比；赤道轨道的假想北南映射极限由虚线表示。*'
- en: Copy and edit the *mars_orbiter.py* program so that the satellite follows a
    polar orbit. All this involves is changing the Mars image. But you can’t use a
    single top-down image anymore; the view will need to be perpendicular to the planet’s
    axis of rotation. For a video example, see *[https://youtu.be/IP2SDbhFbXk](https://youtu.be/IP2SDbhFbXk)*;
    for an animated gif of Mars, see *[http://gph.is/2caBKKS](http://gph.is/2caBKKS)*.
    You can’t use animated gifs directly in pygame, but you can split out and use
    the individual frames. Tools for splitting out frames can be found online, and
    in the next chapter, you’ll use one of these products to extract images from a
    video.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 复制并编辑 *mars_orbiter.py* 程序，使得卫星遵循极轨道。这只涉及更换火星图像。但你不能再使用单一的俯视图像；视角需要垂直于行星的自转轴。有关视频示例，请参见
    *[https://youtu.be/IP2SDbhFbXk](https://youtu.be/IP2SDbhFbXk)*；有关火星动画 gif，请参见
    *[http://gph.is/2caBKKS](http://gph.is/2caBKKS)*。你不能直接在 pygame 中使用动画 gif，但可以将单独的帧提取出来并使用。提取帧的工具可以在网上找到，在下一章中，你将使用其中一种工具从视频中提取图像。
