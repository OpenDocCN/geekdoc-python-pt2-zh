- en: '**15'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**15'
- en: IMPROVING YOUR ASTROPHOTOGRAPHY WITH PLANET STACKING**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**通过行星叠加提高天体摄影质量**'
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: If you’ve ever looked through a telescope at Jupiter, Mars, or Saturn, you were
    probably a little disappointed. The planets appeared small and featureless. You
    wanted to zoom in and crank up the magnification, but it didn’t work. Anything
    bigger than about 200x magnification tends to be blurry.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾通过望远镜观察木星、火星或土星，可能会感到有些失望。行星看起来小而无特色。你想放大并增加倍率，但没有效果。任何超过大约 200 倍的放大镜头往往会变得模糊。
- en: The problem is air turbulence, or what astronomers call *seeing*. Even on a
    clear night, the air is constantly in motion, with thermal updrafts and downdrafts
    that can easily blur the pinpoints of light that represent celestial objects.
    But with the commercialization of the *charge-coupled device (CCD)* in the 1980s,
    astronomers found a way to overcome the turbulence. Digital photography permits
    a technique known as *image stacking*, in which many photos—some good, some bad—are
    averaged together, or stacked, into a single image. With enough photos, the persistent,
    unchanging features (like a planet’s surface) dominate transient features (like
    a stray cloud). This allows astrophotographers to increase magnification limits,
    as well as compensate for less-than-optimal seeing conditions.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 问题出在空气湍流，或天文学家所称的*视像*。即使在一个晴朗的夜晚，空气也在不断流动，伴随着热气上升和下降气流，这些气流很容易使代表天体的光点模糊不清。但是，随着
    1980 年代*电荷耦合器件（CCD）*的商业化，天文学家找到了一种克服湍流的方法。数字摄影允许一种名为*图像叠加*的技术，通过这种技术，许多照片——有些好，有些差——被一起平均或叠加成一张单独的图像。通过足够多的照片，持久且不变的特征（如行星的表面）会占据短暂变化的特征（如偶尔的云层）。这使得天体摄影师能够提高放大极限，并弥补不理想的视像条件。
- en: In this chapter, you’ll use a third-party Python module called pillow to stack
    hundreds of images of Jupiter. The result will be a single image with a higher
    signal-to-noise ratio than any of the individual frames. You’ll also work with
    files in different folders than your Python code and manipulate both the files
    and folders using the Python operating system (os) and shell utilities (shutil)
    modules.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将使用一个名为 pillow 的第三方 Python 模块来叠加数百张木星的照片。结果将是一个信噪比比任何单独的帧都要高的图像。你还将处理与
    Python 代码不同文件夹中的文件，并使用 Python 的操作系统（os）和 Shell 工具（shutil）模块来操作这些文件和文件夹。
- en: '**Project #23: Stacking Jupiter**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**项目 #23：叠加木星**'
- en: Large, bright, and colorful, the gas giant Jupiter is a favorite target of astrophotographers.
    Even amateur telescopes can resolve its orange striping, caused by linear cloud
    bands, and the Great Red Spot, an oval-shaped storm so large it could swallow
    the Earth (see [Figure 15-1](ch15.xhtml#ch15fig1)).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 巨大、明亮且色彩斑斓的气体巨星木星是天体摄影师的热门拍摄对象。即使是业余望远镜也能分辨出木星的橙色条纹，这些条纹由线状云带形成，以及大红斑——一个椭圆形的风暴，巨大到足以吞噬地球（见[图
    15-1](ch15.xhtml#ch15fig1)）。
- en: '![image](../images/f0326-01.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0326-01.jpg)'
- en: '*Figure 15-1: Jupiter as photographed by the Cassini spacecraft*'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-1：卡西尼号拍摄的木星*'
- en: Jupiter is a great subject for studying image stacking. Its linear cloud bands
    and Great Red Spot provide the eye with calibration points for judging improvements
    in edge definition and clarity, and its relatively large size makes it easy to
    detect noise.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 木星是研究图像叠加的绝佳对象。它的线状云带和大红斑为眼睛提供了校准点，用来判断边缘定义和清晰度的改善，而且它相对较大的尺寸使得噪声更容易被检测到。
- en: Noise manifests itself as “graininess.” Each color band has its own artifacts,
    resulting in colored speckles across an image. The main sources of noise are the
    camera (electronic readout noise and thermal signal) and photon noise from the
    light itself, as a variable number of photons strike the sensor over time. Noise
    artifacts are fortunately random in nature and can be largely canceled out by
    stacking images.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 噪声表现为“颗粒感”。每个颜色带都有其自己的伪影，导致图像中出现彩色斑点。噪声的主要来源是相机（电子读取噪声和热信号）以及来自光本身的光子噪声，因为随时间推移，传感器接收到的光子数量是可变的。幸运的是，噪声伪影本质上是随机的，可以通过叠加图像在很大程度上被消除。
- en: '**THE OBJECTIVE**'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标**'
- en: Write programs that crop, scale, stack, and enhance images to create a clearer
    photograph of Jupiter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 编写程序裁剪、缩放、叠加和增强图像，以创建更清晰的木星照片。
- en: '**The pillow Module**'
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**pillow 模块**'
- en: To work with images, you’ll need a free third-party Python module called pillow.
    It’s the successor project to the Python Imaging Library (PIL), which was discontinued
    in 2011\. The pillow module “forked” the PIL repository and upgraded the code
    for Python 3.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理图像，你需要一个免费的第三方 Python 模块，叫做 Pillow。它是 Python 图像库（PIL）的继任项目，而 PIL 在 2011 年已经停用。Pillow
    模块是从 PIL 仓库“分叉”出来的，并且将代码升级到了 Python 3。
- en: You can use pillow on Windows, macOS, and Linux, and it supports many image
    formats including PNG, JPEG, GIF, BMP, and TIFF. It offers standard image-manipulation
    procedures, such as altering individual pixels, masking, handling transparency,
    filtering and enhancing, and adding text. But the real strength of pillow is its
    ability to edit many images with ease.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Windows、macOS 和 Linux 上使用 Pillow，它支持多种图像格式，包括 PNG、JPEG、GIF、BMP 和 TIFF。它提供了标准的图像处理程序，例如更改单个像素、遮罩、处理透明度、过滤和增强，以及添加文本。但
    Pillow 的真正优势在于它能轻松编辑大量图像。
- en: Installing pillow is easy with the pip tool (for more about pip, see “[Manipulating
    Word Documents with python-docx](ch06.xhtml#lev136)” on [page 110](ch06.xhtml#page_110)).
    From the command line, enter pip install pillow.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 pip 工具安装 Pillow 非常简单（有关 pip 的更多信息，请参见“[使用 python-docx 操作 Word 文档](ch06.xhtml#lev136)”第
    [110 页](ch06.xhtml#page_110)）。在命令行中输入 pip install pillow 即可。
- en: Most major Linux distributions include pillow in packages that previously contained
    PIL, so you may already have pillow on your system. Regardless of your platform,
    if PIL is already installed, you’ll need to uninstall it before installing pillow.
    For more installation instructions, see *[http://pillow.readthedocs.io/en/latest/installation.html](http://pillow.readthedocs.io/en/latest/installation.html)*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数主要的 Linux 发行版已经将 Pillow 包含在以前包含 PIL 的包中，因此你可能已经在系统上安装了 Pillow。无论你使用的是哪个平台，如果
    PIL 已经安装，你需要先卸载它，再安装 Pillow。有关更多安装说明，请参见 *[http://pillow.readthedocs.io/en/latest/installation.html](http://pillow.readthedocs.io/en/latest/installation.html)*。
- en: '**Working with Files and Folders**'
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**操作文件和文件夹**'
- en: In all the previous projects in this book, you’ve kept supporting files and
    modules in the same folder as your Python code. This was handy for simple projects,
    but not very realistic for broad use, and it’s certainly not good when you’re
    dealing with the hundreds of image files you’ll generate in this project. Fortunately,
    Python ships with several modules that can help with this, like os and shutil.
    But first, I’ll briefly discuss directory paths.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的所有前面项目中，你将支持文件和模块保存在与 Python 代码相同的文件夹中。这对于简单项目来说很方便，但对于广泛使用来说并不现实，尤其是在处理本项目中将生成的数百个图像文件时，这肯定不适合。幸运的是，Python
    提供了几个可以帮助处理这一问题的模块，如 os 和 shutil。但首先，我会简要讨论目录路径。
- en: '***Directory Paths***'
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***目录路径***'
- en: The directory path is the address to a file or folder. It starts with a root
    directory, which is designated with a letter (such as *C:\*) in Windows, and a
    forward slash (*/*) in Unix-based systems. Additional drives in Windows are assigned
    a different letter than *C*, those in macOS are placed under */volume*, and those
    in Unix under */mnt* (for “mount”).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 目录路径是文件或文件夹的地址。它从根目录开始，在 Windows 中用一个字母表示（例如 *C:\*），而在基于 Unix 的系统中用正斜杠 (*/*)
    表示。Windows 中的其他驱动器会分配不同于 *C* 的字母，macOS 中的驱动器位于 */volume* 下，Unix 中的驱动器位于 */mnt*
    下（表示“挂载”）。
- en: '**NOTE**'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*I use the Windows operating system for the examples in this chapter, but you
    can achieve the same result on macOS and other systems. And as is commonly done,
    I use the terms* directory *and* folder *interchangeably here.*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*我在本章中的示例使用的是 Windows 操作系统，但你也可以在 macOS 和其他系统上实现相同的效果。并且，像通常那样，我在这里交替使用了*目录*
    和 *文件夹* 这两个术语。*'
- en: Pathnames appear differently depending on the operating system. Windows separates
    folders with a backslash (*\*), while macOS and Unix systems use a forward slash
    (*/*). Also, in Unix, folder and file names are case sensitive.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 路径名在不同操作系统上表现不同。Windows 使用反斜杠 (*\*) 来分隔文件夹，而 macOS 和 Unix 系统使用正斜杠 (*/*)。另外，在
    Unix 中，文件夹和文件名是区分大小写的。
- en: If you’re writing your program in Windows and type in pathnames with backslashes,
    other platforms won’t recognize the paths. Fortunately, the os.path.join() method
    will automatically ensure your pathname is suitable for whatever operating system
    Python is running on. Let’s take a look at this, and other examples, in [Listing
    15-1](ch15.xhtml#ch15list1).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 Windows 中编写程序并输入带有反斜杠的路径名，其他平台将无法识别这些路径。幸运的是，os.path.join() 方法将自动确保你的路径名适合
    Python 正在运行的操作系统。让我们在 [Listing 15-1](ch15.xhtml#ch15list1) 中看一下这个示例，和其他一些例子。
- en: ➊ >>> import os
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ >>> import os
- en: ➋ >>> os.getcwd()
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ >>> os.getcwd()
- en: '''C:\\Python35\\Lib\\idlelib'''
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '''C:\\Python35\\Lib\\idlelib'''
- en: ➌ >>> os.chdir('C:\\Python35\\Python 3 Stuff')
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ >>> os.chdir('C:\\Python35\\Python 3 Stuff')
- en: '>>> os.getcwd()'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> os.getcwd()'
- en: '''C:\\Python35\\Python 3 Stuff'''
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '''C:\\Python35\\Python 3 Stuff'''
- en: ➍ >>> os.chdir(r'C:\Python35\Python 3 Stuff\Planet Stacking')
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ >>> os.chdir(r'C:\Python35\Python 3 Stuff\Planet Stacking')
- en: '>>> os.getcwd()'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> os.getcwd()'
- en: ➎ 'C:\\Python35\\Python 3 Stuff\\Planet Stacking'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ 'C:\\Python35\\Python 3 Stuff\\Planet Stacking'
- en: ➏ >>> os.path.join('Planet Stacking', 'stack_8', '8file262.jpg')
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: ➏ >>> os.path.join('Planet Stacking', 'stack_8', '8file262.jpg')
- en: '''Planet Stacking\\stack_8\\8file262.jpg'''
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '''Planet Stacking\\stack_8\\8file262.jpg'''
- en: ➐ >>> os.path.normpath('C:/Python35/Python 3 Stuff')
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: ➐ >>> os.path.normpath('C:/Python35/Python 3 Stuff')
- en: '''C:\\Python35\\Python 3 Stuff'''
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '''C:\\Python35\\Python 3 Stuff'''
- en: ➑ >>> os.chdir('C:/Python35')
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ➑ >>> os.chdir('C:/Python35')
- en: '>>> os.getcwd()'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> os.getcwd()'
- en: '''C:\\Python35'''
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '''C:\\Python35'''
- en: '*Listing 15-1: Working with Windows pathnames using the* os *module*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 15-1：使用* os *模块处理 Windows 路径名*'
- en: After importing the os module for access to operating system–dependent functionality
    ➊, get the *current working directory*, or *cwd* ➋. The cwd is assigned to a process
    when it starts up; that is, when you run a script from your shell, the cwd of
    the shell and the script will be the same. For a Python program, the cwd is the
    folder that contains the program. When you get the cwd, you’re shown the full
    path. Note that you must use extra backslashes in order to escape the backslash
    characters used as file separators.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入 os 模块以访问操作系统相关的功能 ➊ 后，获取*当前工作目录*，或 *cwd* ➋。cwd 在进程启动时会被分配；也就是说，当你从 shell
    运行脚本时，shell 和脚本的 cwd 会相同。对于 Python 程序，cwd 就是包含程序的文件夹。当你获取 cwd 时，会显示完整路径。注意，你必须使用额外的反斜杠来转义作为文件分隔符的反斜杠字符。
- en: Next, you change the cwd using the os.chdir() method ➌, passing it the full
    path in quotes, using double backslashes. Then you get the cwd again to see the
    new path.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用 os.chdir() 方法 ➌，传入带引号的完整路径，并使用双反斜杠来更改当前工作目录（cwd）。然后再次获取 cwd，以查看新的路径。
- en: If you don’t want to type the double backslash, you can enter an r before the
    pathname argument string to convert it to a *raw string* ➍. Raw strings use different
    rules for backslash escape sequences, but even a raw string can’t end in a single
    backslash. The path will still be displayed with double backslashes ➎.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想输入双反斜杠，可以在路径名参数字符串前加上 r，将其转换为*原始字符串* ➍。原始字符串使用不同的反斜杠转义规则，但即便是原始字符串，也不能以单个反斜杠结尾。路径仍然会显示为双反斜杠
    ➎。
- en: If you want your program to be compatible with all operating systems, use the
    os.path.join() method and pass it the folder names and filenames without a separator
    character ➏. The os.path methods are aware of the system you’re using and return
    the proper separators. This allows for platform-independent manipulation of filenames
    and folder names.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望你的程序兼容所有操作系统，可以使用 os.path.join() 方法，并将文件夹名和文件名传递给它，且不使用分隔符字符 ➏。os.path
    方法会根据你使用的系统返回正确的分隔符，这使得文件名和文件夹名可以在不同平台之间独立操作。
- en: The os.path.normpath() method corrects separators for the system you are using
    ➐. In the Windows example shown, incorrect Unix-type separators are replaced with
    backslashes. Native Windows also supports use of the forward slash and will automatically
    make the conversion ➑.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: os.path.normpath() 方法会根据你使用的系统纠正分隔符 ➐。以 Windows 示例为例，不正确的 Unix 类型分隔符会被替换为反斜杠。原生
    Windows 系统也支持使用正斜杠，并会自动进行转换 ➑。
- en: The full directory path—from the root down—is called the *absolute path*. You
    can use shortcuts, called *relative paths*, to make working with directories easier.
    Relative paths are interpreted from the perspective of the current working directory.
    Whereas absolute paths start with a forward slash or drive label, relative paths
    do not. In the following code snippet, you can change directories without entering
    an absolute path—Python is aware of the new location because it is *within* the
    cwd. Behind the scenes, the relative path is joined to the path leading to the
    cwd to make a complete absolute path.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的目录路径，从根目录开始，称为*绝对路径*。你可以使用称为*相对路径*的快捷方式，使得目录操作更加简便。相对路径是从当前工作目录的角度进行解析的。而绝对路径从正斜杠或驱动器标签开始，相对路径则不是。以下代码片段中，你可以在不输入绝对路径的情况下更改目录——Python
    会意识到新的位置，因为它*位于* cwd 之内。幕后，Python 会将相对路径与通向 cwd 的路径连接起来，形成一个完整的绝对路径。
- en: '>>> os.getcwd()'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> os.getcwd()'
- en: '''C:\\Python35\\Python 3 Stuff'''
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '''C:\\Python35\\Python 3 Stuff'''
- en: '>>> os.chdir(''Planet Stacking'')'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> os.chdir(''Planet Stacking'')'
- en: '>>> os.getcwd()'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> os.getcwd()'
- en: '''C:\\Python35\\Python 3 Stuff\\Planet Stacking'''
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '''C:\\Python35\\Python 3 Stuff\\Planet Stacking'''
- en: 'You can identify folders and save more typing with dot (.) and dot-dot (..).
    For example, in Windows, .\ refers to the cwd, and ..\ refers to the parent directory
    that holds the cwd. You can also use a dot to get the absolute path to your cwd:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过点（.）和点点（..）来识别文件夹并减少输入。例如，在Windows中，.\ 指代当前工作目录（cwd），而..\ 指代包含当前工作目录的父目录。你还可以使用点来获取当前工作目录的绝对路径：
- en: '>>> os.path.abspath(''.'')'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> os.path.abspath(''.'')'
- en: '''C:\\Python35\\Python 3 Stuff\\Planet Stacking\\for_book'''
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '''C:\\Python35\\Python 3 Stuff\\Planet Stacking\\for_book'''
- en: Dot folders can be used in Windows, macOS, and Linux. For more on the os module,
    see *[https://docs.python.org/3/library/os.html](https://docs.python.org/3/library/os.html)*.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 点文件夹可以在 Windows、macOS 和 Linux 中使用。有关 os 模块的更多信息，请参阅 *[https://docs.python.org/3/library/os.html](https://docs.python.org/3/library/os.html)*。
- en: '***The Shell Utilities Module***'
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Shell 工具模块***'
- en: The shell utilities module, shutil, provides high-level functions for working
    with files and folders, such as copying, moving, renaming, and deleting. Since
    it’s part of the Python standard library, you can load shutil simply by typing
    import shutil. You’ll see example uses for the module in this chapter’s code sections.
    Meanwhile, you can find the module’s documentation at *[https://docs.python.org/3.7/library/shutil.html](https://docs.python.org/3.7/library/shutil.html)*.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: shell 工具模块 shutil 提供了用于处理文件和文件夹的高级功能，如复制、移动、重命名和删除。由于它是 Python 标准库的一部分，你只需输入
    `import shutil` 就可以加载该模块。在本章的代码部分，你将看到该模块的示例用法。同时，你可以在 *[https://docs.python.org/3.7/library/shutil.html](https://docs.python.org/3.7/library/shutil.html)*
    查阅该模块的文档。
- en: '**The Video**'
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**视频**'
- en: Brooks Clark recorded the color video of Jupiter used in this project on a windy
    night in Houston, Texas. It consists of a 101 MB *.mov* file with a runtime of
    about 16 seconds.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Brooks Clark 在德克萨斯州休斯敦的一个有风的夜晚录制了本项目中使用的木星彩色视频。视频文件为 101 MB 的 *.mov* 文件，时长约
    16 秒。
- en: The length of the video is intentionally short. Jupiter’s rotation period is
    about 10 hours, which means still photos may blur with exposure times of only
    a minute, and features you want to reinforce through stacking video frames can
    change positions, greatly complicating the process.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 视频的长度故意设置得很短。木星的自转周期大约为 10 小时，这意味着在曝光时间仅为一分钟的情况下，静态照片可能会模糊，而你希望通过堆叠视频帧来增强的特征可能会发生位置变化，极大地增加了处理的复杂性。
- en: To convert the video frames to individual images, I used Free Studio, a freeware
    set of multimedia programs developed by DVDVideoSoft. The Free Video to JPG Converter
    tool permits the capture of images at constant time or frame intervals. I set
    the interval to sample frames across the full length of the video, to improve
    the odds of capturing some images when the air was still and the seeing good.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将视频帧转换为单独的图像，我使用了 Free Studio，这是一个由 DVDVideoSoft 开发的多媒体免费软件集。Free Video to
    JPG Converter 工具可以按固定时间或帧间隔捕捉图像。我将间隔设置为覆盖整个视频的帧，以提高在空气平静、能见度良好的时候捕捉到一些图像的概率。
- en: A few hundred images should be enough for stacking to show demonstrable improvement.
    In this case, I captured 256 frames.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 几百张图像应该足以通过堆叠显示出可见的改善。在这个例子中，我捕捉了 256 帧。
- en: You can find the folder of images, named *video_frames*, online with the book’s
    resources at *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*.
    Download this folder and retain the name.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在书籍的在线资源中找到名为 *video_frames* 的图像文件夹，网址为 *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*。下载此文件夹并保持文件夹名称不变。
- en: An example frame from the video, in grayscale, is shown in [Figure 15-2](ch15.xhtml#ch15fig2).
    Jupiter’s cloud bands are faint and fuzzy, the Great Red Spot isn’t apparent,
    and the image suffers from low contrast, a common side effect of magnification.
    Noise artifacts also give Jupiter a grainy appearance.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 来自视频的示例帧（灰度图）显示在[图 15-2](ch15.xhtml#ch15fig2)中。木星的云带模糊且淡薄，大红斑不明显，图像对比度低，这是放大常见的副作用。噪声伪影也使木星看起来颗粒感较强。
- en: '![image](../images/f0330-01.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0330-01.jpg)'
- en: '*Figure 15-2: Example frame from the video of Jupiter*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-2：来自木星视频的示例帧*'
- en: In addition to those issues, the wind shook the camera, and imprecise tracking
    caused the planet to drift laterally to the left-hand side of the frame. You can
    see an example of *lateral drift* in [Figure 15-3](ch15.xhtml#ch15fig3), in which
    I have overlaid five randomly chosen frames with the black background set to transparent.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些问题外，风还摇动了相机，不精确的跟踪导致行星向画面左侧漂移。你可以在[图 15-3](ch15.xhtml#ch15fig3)中看到 *横向漂移*
    的示例，其中我将五个随机选定的帧叠加，并将黑色背景设为透明。
- en: '![image](../images/f0330-02.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0330-02.jpg)'
- en: '*Figure 15-3: An example of shake and drift in the Jupiter video based on five
    randomly chosen frames*'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*图15-3：基于五个随机选择的帧，在木星视频中出现的抖动和漂移示例*'
- en: Movement isn’t necessarily a bad thing, because shifting the image around can
    smooth defects associated with the CCD sensor surface, dust on the lens or sensor,
    and so on. But the key assumption in image stacking is that the images perfectly
    align so that persistent features, like Jupiter’s cloud bands, reinforce each
    other as you average the images. For the signal-to-noise ratio to be high, the
    images must be registered.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 运动不一定是坏事，因为移动图像可以平滑与CCD传感器表面、镜头或传感器上的灰尘等相关的缺陷。但图像堆叠的关键假设是，图像能够完美对齐，以便持久特征，如木星的云带，在平均图像时互相增强。为了使信噪比高，图像必须经过配准。
- en: '*Image registration* is the process of transforming data to the same coordinate
    system so that it can be compared and integrated. Registration is arguably the
    hardest part of image stacking. Astronomers typically use commercial software—such
    as RegiStax, RegiStar, Deep Sky Stacker, or CCDStack—to help them align and stack
    their astrophotos. You’ll get your hands dirty, however, and do this yourself
    using Python.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*图像配准*是将数据转换为相同坐标系的过程，以便进行比较和整合。配准可以说是图像堆叠中最困难的部分。天文学家通常使用商业软件——如RegiStax、RegiStar、Deep
    Sky Stacker或CCDStack——帮助他们对齐并堆叠他们的天文照片。然而，你将亲自动手，使用Python自己完成这项工作。'
- en: '**The Strategy**'
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**策略**'
- en: 'The steps required to stack the images are as follows (the first one has already
    been completed):'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 堆叠图像所需的步骤如下（第一个步骤已完成）：
- en: Extract images from video recording.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从视频录制中提取图像。
- en: Crop images around Jupiter.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 裁剪木星周围的图像。
- en: Scale cropped images to the same size.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将裁剪后的图像缩放到相同大小。
- en: Stack images into a single image.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将图像堆叠成一张单一的图像。
- en: Enhance and filter the final image.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 增强并过滤最终图像。
- en: '**The Code**'
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**代码**'
- en: You can incorporate all the steps into one program, but I chose to distribute
    them across three programs. This is because you generally want to stop and check
    results along the way, plus you may want to run later processes, such as enhancement,
    without having to completely rerun the whole workflow. The first program will
    crop and scale the images, the second will stack them, and the third will enhance
    them.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将所有步骤整合到一个程序中，但我选择将它们分布到三个程序中。这是因为你通常希望在过程中停下来检查结果，此外你可能希望运行后续处理，例如增强，而不必完全重新运行整个工作流。第一个程序将裁剪和缩放图像，第二个程序将堆叠它们，第三个程序将增强它们。
- en: '***The Cropping and Scaling Code***'
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***裁剪和缩放代码***'
- en: First, you need to register the images. For large, bright objects like the moon
    and Jupiter, one approach in astrophotography is to crop each image so that its
    four borders are tangent with the surface of the body. This removes most of the
    sky and mitigates any shake and drift issues. Scaling the cropped images will
    ensure they are all the same size and will smooth them slightly to reduce noise.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要对图像进行配准。对于像月球和木星这样的巨大亮度物体，在天文摄影中，一种方法是裁剪每张图像，使其四个边缘与天体的表面相切。这可以去除大部分天空区域，减少抖动和漂移问题。对裁剪后的图像进行缩放，确保它们的大小一致，并略微平滑图像以减少噪声。
- en: You can download *crop_n_scale_images.py* from *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*.
    Keep it in the directory that holds the folder of captured video frames.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从*[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*下载*crop_n_scale_images.py*。将其保存在包含捕获视频帧的文件夹的目录中。
- en: '**Importing Modules and Defining the main() Function**'
  id: totrans-87
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**导入模块并定义main()函数**'
- en: '[Listing 15-2](ch15.xhtml#ch15list2) performs imports and defines the main()
    function that runs the *crop_n_scale_images.py* program.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 15-2](ch15.xhtml#ch15list2)执行导入操作并定义了运行*crop_n_scale_images.py*程序的main()函数。'
- en: '*crop_n_scale_images.py,* part 1'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*crop_n_scale_images.py,* 第1部分'
- en: ➊ import os
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ import os
- en: import sys
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: import sys
- en: ➋ import shutil
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ import shutil
- en: ➌ from PIL import Image, ImageOps
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ from PIL import Image, ImageOps
- en: 'def main():'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 'def main():'
- en: '"""Get starting folder, copy folder, run crop function, & clean folder."""'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '"""获取起始文件夹，复制文件夹，运行裁剪函数，清理文件夹。"""'
- en: '# get name of folder in cwd with original video images'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '# 获取当前工作目录中包含原始视频图像的文件夹名称'
- en: ➍ frames_folder = 'video_frames'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ frames_folder = 'video_frames'
- en: '# prepare files & folders'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '# 准备文件和文件夹'
- en: ➎ del_folders('cropped')
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ del_folders('cropped')
- en: ➏ shutil.copytree(frames_folder, 'cropped')
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ➏ shutil.copytree(frames_folder, 'cropped')
- en: '# run cropping function'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '# 运行裁剪函数'
- en: print("start cropping and scaling...")
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: print("开始裁剪和缩放...")
- en: ➐ os.chdir('cropped')
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ➐ os.chdir('cropped')
- en: crop_images()
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: crop_images()
- en: ➑ clean_folder(prefix_to_save='cropped')  # delete uncropped originals
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '➑ clean_folder(prefix_to_save=''cropped'')  # 删除未裁剪的原始文件'
- en: print("Done! \n")
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: print("Done! \n")
- en: '*Listing 15-2: Imports modules and defines the* main() *function*'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 15-2：导入模块并定义* main() *函数*'
- en: Start by importing both the operating system (os) and system (sys) ➊. The os
    import already includes an import of sys, but this feature may go away in the
    future, so it’s best to manually import sys yourself. The shutil module contains
    the shell utilities described earlier ➋. From the imaging library, you’ll use
    Image to load, crop, convert, and filter images; you’ll also use ImageOps to scale
    images ➌. Note you must use PIL, not pillow, in the import statement.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 首先导入操作系统（os）和系统（sys）模块 ➊。os 模块的导入已经包括了 sys 模块的导入，但这个功能未来可能会消失，因此最好手动导入 sys 模块。shutil
    模块包含了之前提到的 shell 工具 ➋。从图像处理库中，你将使用 Image 来加载、裁剪、转换和过滤图像；你还将使用 ImageOps 来缩放图像 ➌。请注意，在导入语句中必须使用
    PIL，而不是 pillow。
- en: Start the main() function by assigning the name of the starting folder to the
    frames_folder variable ➍. This folder contains all the original images captured
    from the video.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将起始文件夹的名称赋值给 frames_folder 变量 ➍ 来启动 main() 函数。这个文件夹包含了从视频中捕获的所有原始图像。
- en: You’ll store the cropped images in a new folder named *cropped*, but the shell
    utilities won’t create this folder if it already exists, so call the del_folders()
    function that you’ll write in a moment ➎. As written, this function won’t throw
    an error if the folder doesn’t exist, so it can be run safely at any time.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你将把裁剪后的图像存储在一个名为 *cropped* 的新文件夹中，但如果该文件夹已存在，shell 工具将无法创建它，因此需要调用稍后会编写的 del_folders()
    函数 ➎。按当前的实现，如果文件夹不存在，该函数不会抛出错误，因此可以在任何时候安全地运行。
- en: You should always work off a copy of original images, so use the shutil.copytree()
    method to copy the folder containing the originals to a new folder named *cropped*
    ➏. Now, switch to this folder ➐ and call the crop_images() function, which will
    crop and scale the images. Follow this with the clean_folder() function, which
    removes the original video frames that were copied into the *cropped* folder and
    are still hanging around ➑. Note that you use the parameter name when you pass
    the argument to the clean_folder() function, since this makes the purpose of the
    function more obvious.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该始终在原始图像的副本上工作，因此可以使用 shutil.copytree() 方法将包含原始图像的文件夹复制到一个名为 *cropped* 的新文件夹中
    ➏。接着，切换到该文件夹 ➐ 并调用 crop_images() 函数，它将裁剪并缩放图像。随后调用 clean_folder() 函数，清理 *cropped*
    文件夹中仍然存在的原始视频帧 ➑。请注意，当传递参数给 clean_folder() 函数时，使用参数名称，因为这样可以让函数的目的更加明确。
- en: Print Done! to let the user know when the program is finished.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 打印 Done!，以便通知用户程序已完成。
- en: '**Deleting and Cleaning Folders**'
  id: totrans-113
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**删除和清理文件夹**'
- en: '[Listing 15-3](ch15.xhtml#ch15list3) defines helper functions to delete files
    and folders in *crop_n_scale_images.py*. The shutil module will refuse to make
    a new folder if one with the same name already exists in the target directory.
    If you want to run the program more than once, you first have to remove or rename
    existing folders. The program will also rename images once they have been cropped,
    and you’ll want to delete the original images before you start stacking them.
    Since there will be hundreds of image files, these functions will automate an
    otherwise laborious task.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 15-3](ch15.xhtml#ch15list3) 定义了帮助函数，用于删除 *crop_n_scale_images.py* 中的文件和文件夹。如果目标目录中已经存在同名的文件夹，shutil
    模块将拒绝创建新文件夹。如果你希望多次运行程序，首先必须删除或重命名已有的文件夹。程序还会在裁剪图像后对其进行重命名，在开始堆叠它们之前，你需要删除原始图像。由于图像文件会有数百个，这些函数可以自动化本来繁琐的任务。'
- en: '*crop_n_scale_images.py,* part 2'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*crop_n_scale_images.py，* 第 2 部分'
- en: '➊ def del_folders(name):'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ def del_folders(name):'
- en: '"""If a folder with a named prefix exists in directory, delete it."""'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '"""如果目录中存在以指定前缀命名的文件夹，删除该文件夹。"""'
- en: ➋ contents = os.listdir()
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ contents = os.listdir()
- en: '➌ for item in contents:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '➌ for item in contents:'
- en: '➍ if os.path.isdir(item) and item.startswith(name):'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '➍ if os.path.isdir(item) and item.startswith(name):'
- en: ➎ shutil.rmtree(item)
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ shutil.rmtree(item)
- en: '➏ def clean_folder(prefix_to_save):'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '➏ def clean_folder(prefix_to_save):'
- en: '"""Delete all files in folder except those with a named prefix."""'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '"""删除文件夹中的所有文件，除了那些带有指定前缀的文件。"""'
- en: ➐ files = os.listdir()
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ➐ files = os.listdir()
- en: 'for file in files:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 'for file in files:'
- en: '➑ if not file.startswith(prefix_to_save):'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '➑ if not file.startswith(prefix_to_save):'
- en: ➒ os.remove(file)
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ➒ os.remove(file)
- en: '*Listing 15-3: Defines functions to delete folders and files*'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 15-3：定义了删除文件夹和文件的函数*'
- en: Define a function called del_folders() for deleting folders ➊. The only argument
    will be the name of a folder you want to remove.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个名为 del_folders() 的函数，用于删除文件夹 ➊。唯一的参数将是你想删除的文件夹的名称。
- en: Next, list the contents of the folder ➋, then start looping through the contents
    ➌. If the function encounters an item that starts with the folder name and is
    also a directory ➍, use shutil.rmtree() to delete the folder ➎. As you’ll see
    in a moment, a different method is used to delete a folder than to delete a file.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，列出文件夹的内容 ➋，然后开始遍历内容 ➌。若函数遇到以文件夹名称开头且本身是目录的项目 ➍，则使用 shutil.rmtree() 删除该文件夹
    ➎。正如你稍后会看到的，删除文件夹与删除文件使用的是不同的方法。
- en: '**NOTE**'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Always be careful when using the* rmtree() *method, as it* permanently *deletes
    folders and their contents. You can wipe much of your system, lose important documents
    unrelated to Python projects, and break your computer!*'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用* rmtree() *方法时要小心，因为它* 永久 *删除文件夹及其内容。你可能会擦除系统中的大部分内容，丢失与 Python 项目无关的重要文档，甚至可能破坏你的电脑！*'
- en: Now, define a helper function to “clean” a folder and pass it the name of files
    *that you don’t want to delete* ➏. This is a little counterintuitive at first,
    but since you only want to keep the last batch of images you’ve processed, you
    don’t have to worry about explicitly listing any other files in the folder. If
    the files don’t start with the prefix you provide, such as *cropped*, then they
    are automatically removed.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，定义一个辅助函数来“清理”一个文件夹，并传入你*不想删除*的文件名 ➏。一开始这可能有点反直觉，但由于你只想保留最后一批处理过的图像，因此不需要明确列出文件夹中的任何其他文件。如果文件名没有以你提供的前缀（如
    *cropped*）开头，那么它们会被自动删除。
- en: The process is similar to the last function. List the contents of the folder
    ➐ and start looping through the list. If the file doesn’t start with the prefix
    you provided ➑, use os.remove() to delete it ➒.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程与上一个函数类似。列出文件夹的内容 ➐，然后开始循环遍历列表。如果文件名没有以你提供的前缀 ➑ 开头，使用 os.remove() 删除该文件
    ➒。
- en: '**Cropping, Scaling, and Saving Images**'
  id: totrans-135
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**裁剪、缩放和保存图像**'
- en: '[Listing 15-4](ch15.xhtml#ch15list4) registers the frames captured from the
    video by fitting a box around Jupiter and cropping the image to the box ([Figure
    15-4](ch15.xhtml#ch15fig4)). This technique works well with bright images on a
    field of black (see “[Further Reading](ch15.xhtml#lev376)” on [page 343](ch15.xhtml#page_343)
    for another example).'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 15-4](ch15.xhtml#ch15list4) 通过围绕木星拟合一个框并裁剪图像到该框来注册从视频中捕获的帧（[图 15-4](ch15.xhtml#ch15fig4)）。这种技术对于黑色背景上的亮图像非常有效（有关另一个示例，请参见[进一步阅读](ch15.xhtml#lev376)，第
    [343 页](ch15.xhtml#page_343)）。'
- en: '![image](../images/f0334-01.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0334-01.jpg)'
- en: '*Figure 15-4: Cropping the original video frame to Jupiter to align the images*'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-4：裁剪原始视频帧到木星，以对齐图像*'
- en: By cropping the images tightly around Jupiter, you resolve all of the drift
    and shake issues.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将图像紧密裁剪到木星周围，你解决了所有的漂移和抖动问题。
- en: Each cropped image is also scaled to a larger and consistent size and smoothed
    slightly to reduce noise. The cropped and scaled images will be kept in their
    own folder, which the main() function creates, later.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 每个裁剪后的图像还会被缩放到一个更大且一致的尺寸，并稍微平滑以减少噪点。裁剪并缩放后的图像将保存在它们自己的文件夹中，主函数 `main()` 会在稍后创建该文件夹。
- en: '*crop_n_scale_images.py,* part 3'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*crop_n_scale_images.py,* 第 3 部分'
- en: '➊ def crop_images():'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ def crop_images():'
- en: '"""Crop and scale images of a planet to box around planet."""'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '"""裁剪并缩放行星图像，使其围绕行星的框进行裁剪。"""'
- en: ➋ files = os.listdir()
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ files = os.listdir()
- en: '➌ for file_num, file in enumerate(files, start=1):'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '➌ for file_num, file in enumerate(files, start=1):'
- en: '➍ with Image.open(file) as img:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '➍ with Image.open(file) as img:'
- en: ➎ gray = img.convert('L')
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ gray = img.convert('L')
- en: '➏ bw = gray.point(lambda x: 0 if x < 90 else 255)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '➏ bw = gray.point(lambda x: 0 if x < 90 else 255)'
- en: ➐ box = bw.getbbox()
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ➐ box = bw.getbbox()
- en: padded_box = (box[0]-20, box[1]-20, box[2]+20, box[3]+20)
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: padded_box = (box[0]-20, box[1]-20, box[2]+20, box[3]+20)
- en: ➑ cropped = img.crop(padded_box)
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ➑ cropped = img.crop(padded_box)
- en: scaled = ImageOps.fit(cropped, (860, 860),
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: scaled = ImageOps.fit(cropped, (860, 860),
- en: Image.LANCZOS, 0, (0.5, 0.5))
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Image.LANCZOS, 0, (0.5, 0.5))
- en: file_name = 'cropped_{}.jpg'.format(file_num)
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: file_name = 'cropped_{}.jpg'.format(file_num)
- en: ➒ scaled.save(file_name, "JPEG")
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ➒ scaled.save(file_name, "JPEG")
- en: 'if __name__ == ''__main__'':'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: main()
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: main()
- en: '*Listing 15-4: Crops initial video frames to a box around Jupiter and rescales*'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 15-4：裁剪初始视频帧到木星周围的框并重新缩放*'
- en: The crop_images() function takes no argument ➊ but will ultimately work on a
    copy—named *cropped*—of the folder containing the original video frames. You made
    this copy in the main() function prior to calling this function.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: crop_images() 函数不接受任何参数 ➊，但最终会作用于包含原始视频帧的文件夹的副本——名为 *cropped*。你是在调用此函数之前，在 main()
    函数中创建了这个副本。
- en: Start the function by making a list of the contents of the current (*cropped*)
    folder ➋. The program will number each image sequentially, so use enumerate()
    with the for loop and set the start option to 1 ➌. If you haven’t used enumerate()
    before, it’s a handy built-in function that acts as an automatic counter; the
    count will be assigned to the file_num variable.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 通过列出当前（*裁剪过的*）文件夹内容 ➋ 来启动该函数。程序会依次为每张图像编号，因此请在 for 循环中使用 enumerate()，并将 start
    选项设置为 1 ➌。如果你之前没有使用过 enumerate()，它是一个非常实用的内置函数，可以充当自动计数器；计数值将被赋给 file_num 变量。
- en: Next, name a variable, img, to hold the image and use the open() method to open
    the file ➍.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，给一个变量命名为 img，用于保存图像，并使用 open() 方法打开该文件 ➍。
- en: To fit the borders of a bounding box to Jupiter, you need all the non-Jupiter
    parts of an image to be black (0, 0, 0). Unfortunately, there are stray, noise-related,
    nonblack pixels beyond Jupiter, and the edge of the planet is diffuse and gradational.
    These issues result in nonuniform box shapes, as shown in [Figure 15-5](ch15.xhtml#ch15fig5).
    Fortunately, you can easily resolve these by converting the image to black and
    white. You can then use this converted image to determine the proper box dimensions
    for each color photo.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让边界框适应木星的边缘，你需要确保图像中所有非木星部分都为黑色（0, 0, 0）。不幸的是，木星之外存在一些噪声导致的非黑色像素，并且行星的边缘是模糊渐变的。这些问题会导致不规则的边界框形状，如
    [图 15-5](ch15.xhtml#ch15fig5) 所示。幸运的是，你可以通过将图像转换为黑白图像轻松解决这些问题。然后，你可以使用转换后的图像来确定每张彩色照片的正确边框尺寸。
- en: '![image](../images/f0335-01.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0335-01.jpg)'
- en: '*Figure 15-5: Irregularly sized cropped images due to problems defining the
    bounding box dimensions*'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-5：由于无法正确定义边界框尺寸，裁剪后的图像大小不规则*'
- en: To eliminate the noise effects that compromise the bounding-box technique, convert
    the loaded image to the “L” mode—consisting of 8-bit black and white pixels—and
    name the variable gray, for grayscale ➎. With this mode there is only one channel
    (versus the three channels for RGB color images), so you only need to decide on
    a single value when thresholding—that is, setting a limit above or below which
    an action occurs.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了消除影响边界框技术的噪声效应，将加载的图像转换为“L”模式——该模式由 8 位黑白像素组成——并将变量命名为 gray，表示灰度 ➎。使用此模式时，图像只有一个通道（与
    RGB 彩色图像的三个通道不同），因此在进行阈值处理时，你只需要决定一个单一的值——即设置一个上限或下限，超出该范围就会触发某种操作。
- en: Assign a new variable, called bw, to hold a true black-and-white image ➏. Use
    the point() method, used to change pixel values, and a lambda function to set
    any value below 90 to black (0) and all other values to white (255). The threshold
    value was determined through trial and error. The point() method now returns a
    clean image for fitting the bounding box ([Figure 15-6](ch15.xhtml#ch15fig6)).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保存一张真实的黑白图像，给一个新变量命名为 bw ➏。使用 point() 方法（该方法用于更改像素值）和一个 lambda 函数，将小于 90 的像素值设置为黑色（0），将其他像素值设置为白色（255）。该阈值是通过反复试验得出的。现在，point()
    方法返回了一张干净的图像，用于拟合边界框（见 [图 15-6](ch15.xhtml#ch15fig6)）。
- en: '![image](../images/f0336-01.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0336-01.jpg)'
- en: '*Figure 15-6: Screen capture of one of the original video frames converted
    to pure black and white*'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-6：将原始视频帧之一转换为纯黑白的屏幕截图*'
- en: Now, call the Image module’s getbox() method on bw ➐. This method prunes off
    black borders by fitting a bounding box to the nonzero regions of an image. It
    returns a tuple with the left, upper, right, and lower pixel coordinates of the
    box.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，调用 Image 模块的 getbox() 方法在 bw 上 ➐。此方法通过为图像的非零区域拟合一个边界框来修剪掉黑色边框。它返回一个元组，其中包含框的左、上、右、下像素坐标。
- en: If you use box to crop the video frames, you get an image with borders tangent
    to Jupiter’s surface (see the middle image in [Figure 15-7](ch15.xhtml#ch15fig7)).
    This is what you want, but it’s not visually pleasing. So, add some black padding
    by assigning a new box variable, named padded_box, with its edges extended 20
    pixels in all four directions (see the rightmost image in [Figure 15-7](ch15.xhtml#ch15fig7)).
    Because the padding is consistent and applied to all images, it doesn’t compromise
    the results of cropping.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用框架来裁剪视频帧，你会得到一张边缘与木星表面相切的图像（见[图 15-7](ch15.xhtml#ch15fig7)中的中间图像）。这是你想要的效果，但视觉上并不太美观。因此，通过定义一个新的框架变量，命名为
    padded_box，并将其边缘在四个方向上扩展 20 像素，添加一些黑色填充（见[图 15-7](ch15.xhtml#ch15fig7)中的最右图像）。由于填充一致且应用于所有图像，它不会影响裁剪的结果。
- en: '![image](../images/f0336-02.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0336-02.jpg)'
- en: '*Figure 15-7: Initial crop tangent to Jupiter’s surface (*box*) and final crop
    with padding (*padded_box*)*'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-7：最初裁剪与木星表面相切（*box*）和最终带有填充的裁剪（*padded_box*）*'
- en: Continue by cropping each image with the crop() method ➑. This method takes
    padded_box as an argument.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 继续使用 crop() 方法裁剪每一张图像 ➑。此方法以 padded_box 作为参数。
- en: To scale the image, use the ImageOps.fit() method. This takes the image, a size
    as a pixel width-and-height tuple, a resampling method, a border (0 = no border),
    and even cropping from the center, designated by the tuple (0.5, 0.5). The pillow
    module has several algorithm choices for resizing an image, but I chose the popular
    *Lanczos* filter. Enlarging an image tends to reduce its sharpness, but Lanczos
    can produce *ringing artifacts* along strong edges; this helps increase *perceived*
    sharpness. This unintended edge enhancement can help the eye focus on features
    of interest, which are faint and blurry in the original video frames.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 要缩放图像，使用 ImageOps.fit() 方法。此方法接收图像、尺寸（像素宽度和高度元组）、重采样方法、边框（0 = 无边框），甚至是从中心裁剪，由元组（0.5，0.5）指定。Pillow
    模块提供了几种图像缩放算法供选择，但我选择了流行的 *Lanczos* 滤镜。放大图像往往会降低其清晰度，但 Lanczos 可以在强边缘产生 *振铃伪影*；这有助于提高
    *感知* 锐利度。这种意外的边缘增强有助于眼睛集中注意力于那些在原始视频帧中模糊且微弱的感兴趣特征上。
- en: After scaling, assign a file_name variable. Each of the 256 cropped images will
    start with *cropped_* and end with the number of the image, which you pass to
    the replacement field of the format() method. End the function by saving the file
    ➒.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 缩放后，定义一个 file_name 变量。每张裁剪后的图像将以 *cropped_* 开头，并以图像的编号结尾，你将该编号传递给 format() 方法的替换字段。最后，保存文件
    ➒。
- en: Back in the global scope, add the code that lets the program run as a module
    or in stand-alone mode.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在全局作用域中，添加使程序可以作为模块或独立模式运行的代码。
- en: '**NOTE**'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*I save the files using JPEG format because it is universally readable, handles
    gradations in color well, and takes up very little memory. JPEG uses “lossy” compression,
    however, which causes a tiny bit of image deterioration each time a file is saved;
    you can adjust the degree of compression at the expense of storage size. In most
    cases, when working with astrophotographs, you’ll want to use one of the many
    lossless formats available, such as TIFF.*'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '*我使用 JPEG 格式保存文件，因为它是通用的、能够很好地处理颜色渐变且占用的内存很少。然而，JPEG 使用的是“有损”压缩，每次保存文件时都会有轻微的图像退化；你可以调整压缩的程度，以换取存储空间的大小。在大多数情况下，当处理天文照片时，你会希望使用诸如
    TIFF 等多种无损格式之一。*'
- en: At this point in the workflow, you’ve cropped the original video frames down
    to a box around Jupiter; then you scaled the cropped images to a larger, consistent
    size ([Figure 15-8](ch15.xhtml#ch15fig8)).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在工作流的这一点上，你已经将原始视频帧裁剪成围绕木星的框架；然后你将裁剪后的图像缩放到更大且一致的尺寸（见[图 15-8](ch15.xhtml#ch15fig8)）。
- en: '![image](../images/f0337-01.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0337-01.jpg)'
- en: '*Figure 15-8: Relative sizes of images after cropping and scaling*'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-8：裁剪和缩放后图像的相对大小*'
- en: In the next section, you write the code that stacks the cropped and scaled images.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将编写堆叠裁剪和缩放图像的代码。
- en: '***The Stacking Code***'
  id: totrans-183
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***堆叠代码***'
- en: The *stack_images.py* code takes the images produced by the last program and
    averages them so that a single stacked image is produced. You can download it
    from the book’s resources at *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*.
    Keep it in the same folder as the *crop_n_scale_images.py* program.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '*stack_images.py* 代码会将上一个程序生成的图像进行平均处理，从而生成一张堆叠图像。你可以从本书的资源页面下载它，网址是 *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*。将它与
    *crop_n_scale_images.py* 程序保存在同一文件夹中。'
- en: '[Listing 15-5](ch15.xhtml#ch15list5) imports modules, loads images, creates
    lists of color channels (red, blue, green), averages the channels, recombines
    the channels, and creates and saves the final stacked image. It’s simple enough
    that we won’t bother with a main() function.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单15-5](ch15.xhtml#ch15list5)导入模块，加载图像，创建颜色通道（红色、蓝色、绿色）列表，平均各个通道，重新组合这些通道，创建并保存最终堆叠的图像。它足够简单，以至于我们不需要使用main()函数。  '
- en: '*stack_images.py*'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '*stack_images.py*  '
- en: ➊ import os
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ import os  '
- en: from PIL import Image
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 'from PIL import Image  '
- en: print("\nstart stacking images...")
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 'print("\n开始堆叠图像...")  '
- en: '# list images in directory'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '# 列出目录中的图像  '
- en: ➋ os.chdir('cropped')
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '➋ os.chdir(''cropped'')  '
- en: images = os.listdir()
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 'images = os.listdir()  '
- en: '# loop through images and extract RGB channels as separate lists'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '# 遍历图像并提取RGB通道作为单独的列表  '
- en: ➌ red_data = []
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '➌ red_data = []  '
- en: green_data = []
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 'green_data = []  '
- en: blue_data = []
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 'blue_data = []  '
- en: '➍ for image in images:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '➍ for image in images:  '
- en: 'with Image.open(image) as img:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 'with Image.open(image) as img:  '
- en: if image == images[0]:  # get size of 1st cropped image
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 'if image == images[0]:  # 获取第一个裁剪图像的大小  '
- en: img_size = img.size  # width-height tuple to use later
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 'img_size = img.size  # 宽度-高度元组，后续使用  '
- en: ➎ red_data.append(list(img.getdata(0)))
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '➎ red_data.append(list(img.getdata(0)))  '
- en: green_data.append(list(img.getdata(1)))
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 'green_data.append(list(img.getdata(1)))  '
- en: blue_data.append(list(img.getdata(2)))
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 'blue_data.append(list(img.getdata(2)))  '
- en: ➏ ave_red = [round(sum(x) / len(red_data)) for x in zip(*red_data)]
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '➏ ave_red = [round(sum(x) / len(red_data)) for x in zip(*red_data)]  '
- en: ave_blue = [round(sum(x) / len(blue_data)) for x in zip(*blue_data)]
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 'ave_blue = [round(sum(x) / len(blue_data)) for x in zip(*blue_data)]  '
- en: ave_green = [round(sum(x) / len(green_data)) for x in zip(*green_data)]
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 'ave_green = [round(sum(x) / len(green_data)) for x in zip(*green_data)]  '
- en: ➐ merged_data = [(x) for x in zip(ave_red, ave_green, ave_blue)]
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '➐ merged_data = [(x) for x in zip(ave_red, ave_green, ave_blue)]  '
- en: ➑ stacked = Image.new('RGB', (img_size))
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '➑ stacked = Image.new(''RGB'', (img_size))  '
- en: ➒ stacked.putdata(merged_data)
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '➒ stacked.putdata(merged_data)  '
- en: stacked.show()
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 'stacked.show()  '
- en: ➓ os.chdir('..')
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '➓ os.chdir(''..'')  '
- en: stacked.save('jupiter_stacked.tif', 'TIFF')
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: stacked.save('jupiter_stacked.tif', 'TIFF')
- en: '*Listing 15-5: Splits out and averages color channels, then recombines into
    a single image*'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单15-5：拆分并平均颜色通道，然后重新组合成单个图像*  '
- en: Start by repeating some of the imports you used in the previous program ➊. Next,
    change the current directory to the *cropped* folder, which contains the cropped
    and scaled images of Jupiter ➋, and immediately make a list of the images in the
    folder using os.listdir().
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '从重复你在前一个程序中使用的某些导入开始 ➊。接下来，将当前目录更改为*cropped*文件夹，该文件夹包含了木星的裁剪和缩放图像 ➋，并立即使用os.listdir()列出该文件夹中的图像。  '
- en: With pillow, you can manipulate individual pixels or groups of pixels, and you
    can do this for individual color channels, such as red, blue, and green. To demonstrate
    this, you’ll work on individual color channels to stack the images.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '使用Pillow库，你可以操作单个像素或像素组，并且可以针对单独的颜色通道进行操作，例如红色、蓝色和绿色。为了演示这一点，你将对单独的颜色通道进行操作，来堆叠图像。  '
- en: Create three empty lists to hold the RGB pixel data ➌, then start looping through
    the images list ➍. First, open the image. Then, get the width and height of the
    first image, in pixels, as a tuple. Remember, in the previous program, you scaled
    all the small cropped images to a larger size. You’ll need these dimensions later
    for creating the new stacked image, and size automatically retrieves this info
    for you.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '创建三个空列表来存储RGB像素数据 ➌，然后开始循环遍历图像列表 ➍。首先，打开图像。然后，获取第一张图像的宽度和高度，以像素为单位，作为一个元组。请记住，在前一个程序中，你将所有小的裁剪图像缩放为较大的尺寸。你稍后需要这些尺寸来创建新的堆叠图像，size会自动为你检索这些信息。  '
- en: 'Now use the getdata() method to get the pixel data for the selected image ➎.
    Pass the method the index of the color channel you want: 0 for red, 1 for green,
    and 2 for blue. Append the results to a data list, as appropriate. The data from
    each image will form a separate list in the data lists.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '现在使用getdata()方法获取所选图像的像素数据 ➎。将颜色通道的索引传递给该方法：0表示红色，1表示绿色，2表示蓝色。根据需要将结果添加到数据列表中。每个图像的数据将形成数据列表中的一个单独列表。  '
- en: To average the values in each list, use list comprehension to sum the pixels
    in all the images and divide by the total number of images ➏. Note that you use
    zip with the splat (*) operator. Your red_data list, for example, is a list of
    lists, with each nested list representing one of the 256 image files. Using zip
    with * unpacks the contents of the lists so that the first pixel in image1 is
    summed with the first pixel in image2, and so on.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 要平均每个列表中的值，使用列表推导式对所有图像中的像素求和，并除以图像的总数 ➏。请注意，你使用了带有展开（*）运算符的zip。例如，你的red_data列表是一个包含列表的列表，每个嵌套列表代表256个图像文件中的一个。使用zip和*会展开这些列表的内容，使得图像1中的第一个像素与图像2中的第一个像素相加，依此类推。
- en: To merge the averaged color channels, use list comprehension with zip ➐. Next,
    create a new image, named stacked, using Image.new() ➑. Pass the method a color
    mode ('RGB') and the img_size tuple containing the desired width and height of
    the image in pixels, which was obtained earlier from one of the cropped images.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 要合并平均后的颜色通道，使用带有zip的列表推导式 ➐。接下来，使用Image.new() ➑创建一张新的图像，命名为stacked。将方法传递一个颜色模式（'RGB'）和img_size元组，其中包含之前从裁剪图像中获取的图像宽度和高度。
- en: Populate the new stacked image using the putdata() method and pass it the merged_data
    list ➒. This method copies data from a sequence object into an image, starting
    at the upper-left corner (0, 0). Display the final image using the show() method.
    Finish by changing the folder to the parent directory and saving the image as
    a TIFF file named *jupiter_stacked.tif* ➓.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 使用putdata()方法填充新的堆叠图像，并将合并后的数据列表传递给它 ➒。该方法将序列对象中的数据复制到图像中，从左上角（0, 0）开始。使用show()方法显示最终图像。最后，切换到父目录并将图像保存为名为*jupiter_stacked.tif*的TIFF文件
    ➓。
- en: If you compare one of the original video frames to the final stacked image (*jupiter_stacked.tif*),
    as in [Figure 15-9](ch15.xhtml#ch15fig9), you’ll see a clear improvement in edge
    definition and the signal-to-noise ratio. This is best appreciated in color, so
    if you haven’t run the program, take the time to download *Figure 15-9.pdf* from
    the website. When the image is viewed in color, the benefits of the stacking include
    smoother, “creamier” white bands, better-defined red bands, and a more obvious
    Great Red Spot. There is still room for improvement, however, so next you’ll write
    a program to enhance the final stacked image.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将其中一帧原始视频帧与最终的堆叠图像（*jupiter_stacked.tif*）进行比较，如[图 15-9](ch15.xhtml#ch15fig9)所示，你会看到边缘定义和信噪比有了明显改善。这在彩色图像中最为显著，因此如果你还没有运行程序，可以花点时间从网站上下载*Figure
    15-9.pdf*。当图像以彩色显示时，堆叠的优势包括更平滑、更“奶油”状的白色带、更清晰的红色带以及更明显的伟大红斑。然而，仍然有改进的空间，因此接下来你将编写程序来增强最终的堆叠图像。
- en: '![image](../images/f0339-01.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0339-01.jpg)'
- en: '*Figure 15-9: An original video frame compared to final stacked image (*jupiter_stacked.tif*)*'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-9：一帧原始视频与最终堆叠图像（*jupiter_stacked.tif*）的对比*'
- en: '**NOTE**'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If the Great Red Spot looks pinkish to you in the stacked image, that’s because
    it is! It fades from time to time, and many published pictures of Jupiter have
    exaggerated colors due to processing, so this subtle coloration gets lost. This
    is probably for the best, as “Great Pink Spot” just doesn’t have the same ring
    to it.*'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果在堆叠图像中，大红斑看起来有点粉红色，那是因为它真的就是粉红色！它时不时会褪色，很多已发布的木星照片由于处理过程的原因颜色被夸大，所以这种微妙的颜色变化就被忽略了。这可能是最好的，因为“伟大的粉红色斑点”听起来总是差了点意思。*'
- en: '***The Enhancing Code***'
  id: totrans-226
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***增强代码***'
- en: You’ve successfully stacked all the video frames, but Jupiter is still crooked,
    and its features are faint. You can further improve the stacked image using filters,
    enhancers, and transforms found in pillow. As you enhance images, you get further
    and further from the “ground truth” raw data. For this reason, I chose to isolate
    the enhancement process in a separate program.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经成功堆叠了所有视频帧，但木星仍然歪斜，且其特征模糊。你可以通过使用pillow中的滤镜、增强器和变换来进一步改善堆叠图像。随着图像增强的进行，你会越来越远离“真实数据”。因此，我选择将增强过程隔离在一个独立的程序中。
- en: In general, the first steps after stacking are to enhance details, using high-pass
    filters or an unsharp mask algorithm, and then to fine-tune brightness, contrast,
    and color. The code will use pillow’s image enhancement capability to apply these
    steps—though in a different order. You can download the code as *enhance_image.py*
    from *[https://nostarch.com/impracticalpython/](https://nostarch.com/impracticalpython/)*.
    Keep it in the same folder as the previous Python programs.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，堆叠后的第一步是增强细节，使用高通滤波器或非锐化掩模算法，然后再微调亮度、对比度和颜色。代码将利用pillow的图像增强功能应用这些步骤，虽然顺序有所不同。你可以从*
    [https://nostarch.com/impracticalpython/](https://nostarch.com/impracticalpython/)*
    下载代码作为 *enhance_image.py*，并将其与之前的Python程序保存在同一文件夹内。
- en: '**NOTE**'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The processing of astronomical images can be quite involved, and whole books
    have been written on the subject. Some of the standard steps have been omitted
    in this workflow. For instance, the original video was not calibrated, and distortion
    effects due to turbulence were not corrected. Advanced software, such as RegiStax
    or AviStack, can prevent blurring by warping individual images so that distorted
    features, like the edges of cloud bands, overlap properly in all images.*'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '*天文图像的处理可以相当复杂，关于这一主题已经有整本书籍进行了详细讨论。这个工作流省略了一些标准步骤。例如，原始视频没有进行校准，因湍流造成的失真效应也未被修正。像RegiStax或AviStack这样的高级软件可以通过扭曲单独图像来防止模糊，使得失真特征（如云带的边缘）在所有图像中重叠正确。*'
- en: '[Listing 15-6](ch15.xhtml#ch15list6) imports pillow classes and opens, enhances,
    and saves the stacked image generated by the previous code. Because there are
    many possible options for enhancing images, I chose to modularize this program
    despite its small size.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 15-6](ch15.xhtml#ch15list6) 导入pillow类，并打开、增强并保存由前面代码生成的堆叠图像。因为增强图像有很多可能的选项，尽管程序较小，我还是选择将其模块化。'
- en: '*enhance_image.py*'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '*enhance_image.py*'
- en: ➊ from PIL import Image, ImageFilter, ImageEnhance
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ from PIL import Image, ImageFilter, ImageEnhance
- en: '➋ def main():'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '➋ def main():'
- en: '"""Get an image and enhance, show, and save it."""'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '"""获取图像并进行增强、显示和保存。"""'
- en: ➌ in_file = 'jupiter_stacked.tif'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ in_file = 'jupiter_stacked.tif'
- en: img = Image.open(in_file)
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: img = Image.open(in_file)
- en: ➍ img_enh = enhance_image(img)
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ img_enh = enhance_image(img)
- en: img_enh.show()
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: img_enh.show()
- en: img_enh.save('enhanced.tif', 'TIFF')
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: img_enh.save('enhanced.tif', 'TIFF')
- en: '➎ def enhance_image(image):'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '➎ def enhance_image(image):'
- en: '"""Improve an image using pillow filters & transforms."""'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '"""使用pillow滤镜和变换改善图像。"""'
- en: ➏ enhancer = ImageEnhance.Brightness(image)
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: ➏ enhancer = ImageEnhance.Brightness(image)
- en: ➐ img_enh = enhancer.enhance(0.75)  # 0.75 looks good
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '➐ img_enh = enhancer.enhance(0.75)  # 0.75 看起来很好'
- en: ➑ enhancer = ImageEnhance.Contrast(img_enh)
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: ➑ enhancer = ImageEnhance.Contrast(img_enh)
- en: img_enh = enhancer.enhance(1.6)
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: img_enh = enhancer.enhance(1.6)
- en: enhancer = ImageEnhance.Color(img_enh)
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: enhancer = ImageEnhance.Color(img_enh)
- en: img_enh = enhancer.enhance(1.7)
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: img_enh = enhancer.enhance(1.7)
- en: ➒ img_enh = img_enh.rotate(angle=133, expand=True)
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: ➒ img_enh = img_enh.rotate(angle=133, expand=True)
- en: ➓ img_enh = img_enh.filter(ImageFilter.SHARPEN)
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: ➓ img_enh = img_enh.filter(ImageFilter.SHARPEN)
- en: return img_enh
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: return img_enh
- en: 'if __name__ == ''__main__'':'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: main()
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: main()
- en: '*Listing 15-6: Opens an image, enhances it, and saves it using a new name*'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 15-6：打开图像，增强图像，并使用新名称保存它*'
- en: The import is familiar except for the last two ➊. These new modules, ImageFilter
    and ImageEnhance, contain predefined filters and classes that can be used to alter
    images with blurring, sharpening, brightening, smoothing, and more (see *[https://pillow.readthedocs.io/en/5.1.x/](https://pillow.readthedocs.io/en/5.1.x/)*
    for a full listing of what’s in each module).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 导入部分与之前相似，除了最后两个➊。这些新模块，ImageFilter和ImageEnhance，包含了可以用来改变图像的预定义滤镜和类，例如模糊、锐化、亮度调整、平滑处理等（参见*
    [https://pillow.readthedocs.io/en/5.1.x/](https://pillow.readthedocs.io/en/5.1.x/)*，查看每个模块的完整列表）。
- en: Start by defining the main() function ➋. Assign the stacked image to a variable
    named in_file, then pass it to Image.open() to open the file ➌. Next, call an
    enhance_image() function and pass it the image variable ➍. Show the enhanced image
    and then save it as a TIFF file, which results in no deterioration in image quality.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 首先定义main()函数➋。将堆叠图像赋值给一个名为in_file的变量，然后通过Image.open()打开文件 ➌。接下来，调用enhance_image()函数并将图像变量传递进去
    ➍。显示增强后的图像，然后将其保存为TIFF文件，这样图像质量不会受损。
- en: Now, define an enhancement function, enhance_image(), that takes an image as
    an argument ➎. To paraphrase the pillow documentation, all enhancement classes
    implement a common interface containing a single method, enhance(factor), that
    returns an enhanced image. The factor parameter is a floating-point value controlling
    the enhancement. A value of 1.0 returns a copy of the original; lower values diminish
    color, brightness, contrast, and so on; and higher values increase these qualities.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，定义一个增强函数enhance_image()，它接受一张图像作为参数➎。用通俗的语言来说，所有增强类都实现了一个公共接口，其中包含一个名为enhance(factor)的单一方法，该方法返回一张增强后的图像。factor参数是一个控制增强效果的浮动值。值为1.0时返回原图副本；较低的值会减弱颜色、亮度、对比度等；较高的值则会增强这些特性。
- en: 'To change the brightness of an image, you first create an instance of the ImageEnhance
    module’s Brightness class, passing it the original image ➏. Mimic the pillow docs
    and name this object enhancer. To make the final, enhanced image, you call the
    object’s enhance() method and pass it the factor argument ➐. In this case, you
    decrease brightness by 0.25\. The # 0.75 comment at the end of the line is a useful
    way to experiment with different factors. Use this comment to store values you
    like; that way, you can remember and restore them if other test values don’t yield
    pleasing results.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 要改变图像的亮度，首先创建ImageEnhance模块的Brightness类的实例，传入原始图像➏。模仿Pillow文档，将此对象命名为enhancer。要生成最终增强后的图像，调用该对象的enhance()方法并传入factor参数➐。在此情况下，通过0.25降低亮度。行尾的#
    0.75注释是实验不同因子的有用方式。使用此注释存储你喜欢的值；这样，如果其他测试值没有带来满意的结果，你可以记住并恢复它们。
- en: 'Continue enhancing the image, moving to contrast ➑. If you don’t want to adjust
    the contrast manually, you can take a chance and use pillow’s automatic contrast
    method. First, import ImageOps from PIL. Then, replace the two lines starting
    with step ➑ with the single line: img_enh = ImageOps.autocontrast(img_enh).'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 继续增强图像，调整对比度➑。如果不想手动调整对比度，你可以尝试使用Pillow的自动对比度方法。首先，从PIL导入ImageOps。然后，用以下单行代码替换以步骤➑开头的两行：img_enh
    = ImageOps.autocontrast(img_enh)。
- en: Next, punch up the color. This will help to make the Great Red Spot more visible.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，提高色彩饱和度。这将有助于让大红斑更加清晰可见。
- en: No one wants to look at a tilted Jupiter, so transform the image by rotating
    it to a more “conventional” view, where the cloud bands are horizontal and the
    Great Red Spot is to the lower right. Call the Image module’s rotate() method
    on the image and pass it an angle, measured counterclockwise in degrees, and have
    it automatically expand the output image to make it large enough to hold the entire
    rotated image ➒.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 没有人想看一个倾斜的木星，因此通过旋转图像，将其转换为更“常规”的视角，使云带呈水平，且大红斑位于右下角。调用图像模块的rotate()方法并传入一个角度（按逆时针方向测量，单位为度），并让它自动扩展输出图像，使其足够大以容纳整个旋转后的图像➒。
- en: Now, sharpen the image. Even on high-quality images, sharpening may be needed
    to ameliorate the interpolation effects of converting data, resizing and rotating
    images, and so on. Although some astrophotography resources recommend placing
    it first, in most image-processing workflows, it comes last. This is because it
    is dependent on the final size of the image (viewing distance), as well as the
    media being used. Sharpening can also increase noise artifacts and is a “lossy”
    operation that can remove data—things you don’t want to happen prior to other
    edits.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，锐化图像。即使是在高质量的图像中，锐化也可能是必要的，以改善转换数据、调整大小和旋转图像等过程中的插值效应。尽管一些天文摄影资源建议将锐化放在最前面，但在大多数图像处理工作流中，它通常是在最后进行的。这是因为锐化依赖于图像的最终大小（观看距离）以及所使用的媒介。锐化还可能增加噪点伪影，是一种“有损”操作，可能会去除数据——这些你不希望在其他编辑之前发生的事情。
- en: Sharpening is a little different from the previous enhancements, as you use
    the ImageFilter class. No intermediate step is needed; you can build the new image
    with a single line by calling the filter() method on the image object and passing
    it the predefined SHARPEN filter ➓. The pillow module has other filters that help
    define edges, such as UnsharpMask and EDGE_ENHANCE, but for this image, the results
    are indiscernible from SHARPEN.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 锐化与之前的增强略有不同，因为你需要使用ImageFilter类。无需中间步骤；你只需通过调用图像对象的filter()方法，并传入预定义的SHARPEN滤镜➓，即可生成新图像。Pillow模块还有其他可以帮助定义边缘的滤镜，如UnsharpMask和EDGE_ENHANCE，但对于这张图像而言，结果与SHARPEN滤镜几乎无差。
- en: Finish by returning the image and applying the code to run the program as a
    module or in stand-alone mode.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过返回图像并应用代码以将程序作为模块或独立模式运行。
- en: The final enhanced image is compared to a random video frame and the final stacked
    image in [Figure 15-10](ch15.xhtml#ch15fig10). All the images have been rotated
    for ease of comparison.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 最终增强图像与[图 15-10](ch15.xhtml#ch15fig10)中的随机视频画面和最终堆叠图像进行了对比。所有图像都已旋转，方便比较。
- en: '![image](../images/f0342-01.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0342-01.jpg)'
- en: '*Figure 15-10: A random video frame, the results of stacking 256 frames, and
    the final enhanced image*'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-10：一帧随机视频画面，堆叠 256 帧后的结果，以及最终增强的图像*'
- en: You can see the improvement best when you view it in color. If you want to see
    a color version prior to running the program, view or download *Figure 15-10.pdf*
    from the website.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过查看或下载网站上的*Figure 15-10.pdf*文件，来查看程序运行前的彩色版本，从而看到最佳的改进效果。
- en: '**NOTE**'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you’re familiar with* pillow*, you may be aware that you can use the* Image.blend()
    *method to stack images with only a few lines of code. To my eye, however, the
    resulting image is noticeably noisier than that obtained by breaking out and averaging
    the individual color channels, as you did with the* stack_images.py *program.*'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你熟悉* pillow*，你可能知道你可以使用* Image.blend() *方法通过仅几行代码堆叠图像。然而，在我看来，结果图像的噪点明显多于通过分离并平均每个颜色通道得到的图像，正如你在*
    stack_images.py *程序中所做的那样。*'
- en: '**Summary**'
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: The final image in [Figure 15-10](ch15.xhtml#ch15fig10) will never win any awards
    or be featured in *Sky & Telescope* magazine, but the point was to take on a challenge.
    And the result is a marked improvement over a single image captured from the video.
    The colors are brighter, the cloud bands sharper, and the Great Red Spot better
    defined. You can also make out the turbulent zone downwind of the Great Red Spot
    (refer to [Figure 15-1](ch15.xhtml#ch15fig1)).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 15-10](ch15.xhtml#ch15fig10)中的最终图像不会赢得任何奖项，也不会出现在*天空与望远镜*杂志上，但重点是接受挑战。结果比从视频中捕获的单一图像有了显著改进。颜色更鲜艳，云带更清晰，大红斑也更加明显。你还可以看到大红斑下风区的湍流带（参考[图
    15-1](ch15.xhtml#ch15fig1)）。'
- en: Despite starting with rough input, you were able to register the images, remove
    noise through stacking, and enhance the final image using filters and transforms.
    And all these steps were accomplished with the freely available pillow fork of
    the Python Imaging Library. You also gained experience with the Python shutil
    and os modules, which you used to manipulate files and folders.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管从粗糙的输入开始，你依然能够注册图像，通过堆叠去除噪声，并使用滤镜和变换增强最终图像。而这些步骤都可以通过免费的Python图像库（pillow fork）实现。你还通过使用Python的shutil和os模块，学习了如何操作文件和文件夹。
- en: For more advanced image processing, you can use OpenSource Computer Vision (OpenCV),
    which you implement by installing and importing the cv2 and NumPy modules. Other
    options involve matplotlib, SciPy, and NumPy. As always with Python, there’s more
    than one way to skin a cat!
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更高级的图像处理，你可以使用开源计算机视觉库（OpenCV），通过安装并导入cv2和NumPy模块来实现。其他选择包括matplotlib、SciPy和NumPy。像往常一样，Python有多种方法可以解决同一个问题！
- en: '**Further Reading**'
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**进一步阅读**'
- en: '*Automate the Boring Stuff with Python: Practical Programming for Total Beginners*
    (No Starch Press, 2015) by Al Sweigart includes several useful chapters on working
    with files, folders, and pillow.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '*Automate the Boring Stuff with Python: Practical Programming for Total Beginners*（Al
    Sweigart著，No Starch Press，2015年）包括几章有关处理文件、文件夹和pillow的实用内容。'
- en: Online resources for using Python with astronomy include Python for Astronomers
    (*[https://prappleizer.github.io/](https://prappleizer.github.io/)*) and Practical
    Python for Astronomers (*[https://python4astronomers.github.io/](https://python4astronomers.github.io/)*).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在线资源中有关于使用Python进行天文学应用的资料，包括《Python for Astronomers》(*[https://prappleizer.github.io/](https://prappleizer.github.io/)*)
    和《Practical Python for Astronomers》(*[https://python4astronomers.github.io/](https://python4astronomers.github.io/)*).
- en: If you want to learn more about the OpenCV-Python library, you can find tutorials
    at *[https://docs.opencv.org/3.4.2/d0/de3/tutorial_py_intro.html](https://docs.opencv.org/3.4.2/d0/de3/tutorial_py_intro.html)*.
    Note that knowledge of NumPy is a prerequisite for the tutorials and for writing
    optimized OpenCV code. Alternatively, SimpleCV lets you get started with computer
    vision and image manipulation with a smaller learning curve than OpenCV but only
    works with Python 2.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于OpenCV-Python库的内容，可以在*[https://docs.opencv.org/3.4.2/d0/de3/tutorial_py_intro.html](https://docs.opencv.org/3.4.2/d0/de3/tutorial_py_intro.html)*找到相关教程。请注意，学习这些教程并编写优化的OpenCV代码需要具备NumPy的知识。另一个选择是SimpleCV，它让你能够以较低的学习曲线开始计算机视觉和图像处理，但仅支持Python
    2。
- en: '*Astrophotography* (Rocky Nook, 2014) by Thierry Legault is an indispensable
    resource for anyone interested in serious astrophotography. A comprehensive and
    readable reference, it covers all aspects of the subject, from equipment selection
    through image processing.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '*天文摄影*（Rocky Nook, 2014）由Thierry Legault编写，是任何有意从事严肃天文摄影的人不可或缺的资源。这本全面而易读的参考书涵盖了该领域的各个方面，从设备选择到图像处理。'
- en: “Aligning Sun Images Using Python” (LabJG, 2013), a blog by James Gilbert, contains
    code for cropping the sun using the bounding-box technique. It also includes a
    clever method for realigning rotated images of the sun using sunspots as registration
    points. You can find it at *[https://labjg.wordpress.com/2013/04/01/aligning-sun-images-using-python/](https://labjg.wordpress.com/2013/04/01/aligning-sun-images-using-python/)*.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: “使用Python对太阳图像进行对齐”（LabJG, 2013）是James Gilbert的博客，包含了使用边界框技术裁剪太阳图像的代码。它还包括了一种巧妙的方法，用太阳黑子作为注册点，重新对齐旋转过的太阳图像。你可以在*[https://labjg.wordpress.com/2013/04/01/aligning-sun-images-using-python/](https://labjg.wordpress.com/2013/04/01/aligning-sun-images-using-python/)*找到它。
- en: A Google research team figured out how to use stacking to remove watermarks
    from images on stock photography websites and how the websites could better protect
    their property. You can read about it at *[https://research.googleblog.com/2017/08/making-visible-watermarks-more-effective.html](https://research.googleblog.com/2017/08/making-visible-watermarks-more-effective.html)*.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 一支Google研究团队找到了如何利用堆叠技术去除库存摄影网站上图像中的水印，同时也研究了这些网站如何能更好地保护他们的财产。你可以在*[https://research.googleblog.com/2017/08/making-visible-watermarks-more-effective.html](https://research.googleblog.com/2017/08/making-visible-watermarks-more-effective.html)*阅读相关内容。
- en: '**Challenge Project: Vanishing Act**'
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**挑战项目：消失的魔法**'
- en: Image-stacking techniques can do more than just remove noise—they can remove
    anything that moves at a photo site, including people. Adobe Photoshop, for example,
    has a stack script that makes nonstationary objects magically vanish. It relies
    on a statistical average known as the *median*, which is simply the “middle” value
    in a list of numbers arranged from smallest to largest. The process requires multiple
    photos—preferably taken with a tripod-mounted camera—so that the objects you want
    to remove change positions from one image to the next, while the background remains
    constant. You typically need 10 to 30 pictures taken about 20 seconds apart, or
    similarly spaced frames extracted from a video.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 图像堆叠技术不仅能去除噪点——它们还能去除照片中任何运动的物体，包括人。举例来说，Adobe Photoshop就有一款堆叠脚本，能够让非静止的物体神奇地消失。它依赖于一种称为*中位数*的统计平均数，简单来说，就是按从小到大的顺序排列的数字列表中的“中间”值。这个过程需要多张照片——最好是使用三脚架固定的相机拍摄——这样你想要移除的物体在不同的图像中位置发生变化，而背景保持不变。通常你需要拍摄10到30张照片，间隔大约20秒，或者从视频中提取相似间隔的帧。
- en: With the mean, you sum numbers and divide by the total. With the median, you
    sort numbers and choose the middle value. In [Figure 15-11](ch15.xhtml#ch15fig11),
    a row of five images is shown with the same pixel location outlined in each. In
    the fourth image, a blackbird has flown by and ruined the splendid white background.
    If you stack with the mean, the bird’s presence lingers. But do a median stack
    on the images—that is, sort the red, green, and blue channels and take the middle
    values—and you get the background value for each channel (255). No trace of the
    bird remains.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 对于均值，你将数字相加并除以总数。对于中位数，你需要对数字进行排序并选择中间的值。在[图 15-11](ch15.xhtml#ch15fig11)中，展示了一排五张图片，每张图的相同像素位置都有标出。在第四张图片中，一只乌鸦飞过并破坏了原本完美的白色背景。如果使用均值堆叠，鸟的存在将依然保留。但如果对这些图像进行中位数堆叠——即对红色、绿色和蓝色通道进行排序并取中间值——你将得到每个通道的背景值（255）。此时鸟的踪迹完全消失。
- en: '![image](../images/f0344-01.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0344-01.jpg)'
- en: '*Figure 15-11: Five white images with the same pixel highlighted and its RGB
    values displayed. Median-stacking removes the black pixel.*'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-11：五张白色图像，显示相同的像素并展示其RGB值。中值堆叠去除了黑色像素。*'
- en: When you average using the median, spurious values get pushed to the ends of
    the list. This makes it easy to remove outliers, such as satellites or airplanes
    in astrophotos, so long as the number of images containing the outlier is less
    than half the number of images.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 使用中值平均时，虚假的值会被推到列表的两端。这使得去除异常值变得容易，例如天文照片中的卫星或飞机，只要包含异常值的图像数量少于图像总数的一半。
- en: Armed with this knowledge, write an image-stacking program that will remove
    unwanted tourists from your vacation happy snaps. For testing, you can download
    the *moon_cropped* folder from the website, which contains five synthetic images
    of the moon, each “ruined” by a passing plane (see [Figure 15-12](ch15.xhtml#ch15fig12)).
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 拿到这些知识后，编写一个图像堆叠程序，去除你度假照片中的不需要的游客。在测试时，你可以从网站下载*moon_cropped*文件夹，里面包含了五张合成的月球图像，每张图像都被一架经过的飞机“破坏”了（见[图
    15-12](ch15.xhtml#ch15fig12)）。
- en: '![image](../images/f0345-01.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0345-01.jpg)'
- en: '*Figure 15-12: Synthetic moon photos for testing the median averaging approach*'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-12：用于测试中值平均方法的合成月球照片*'
- en: Your final stacked image should contain no evidence of the plane ([Figure 15-13](ch15.xhtml#ch15fig13)).
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 你最终的堆叠图像应该不包含飞机的痕迹（见[图 15-13](ch15.xhtml#ch15fig13)）。
- en: '![image](../images/f0345-02.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0345-02.jpg)'
- en: '*Figure 15-13: Result of stacking the images in the* moon_cropped *folder using
    median averaging*'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-13：使用中值平均堆叠*moon_cropped*文件夹中的图像结果*'
- en: As this is a challenge project, no solution is provided.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个挑战项目，因此没有提供解决方案。
