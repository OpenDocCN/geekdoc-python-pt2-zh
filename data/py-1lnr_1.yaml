- en: '**1'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**1'
- en: PYTHON REFRESHER**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: PYTHON 复习**
- en: '![Image](Images/comm-1.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/comm-1.jpg)'
- en: The purpose of this chapter is to refresh your knowledge of basic Python data
    structures, keywords, control flow operations, and other fundamentals. I wrote
    this book for intermediate Python programmers who want to reach the next level
    of programming expertise. To get to the expert level, you need a thorough study
    of the basics.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目的是刷新你对基本 Python 数据结构、关键字、控制流操作及其他基础知识的记忆。我写这本书是为了帮助中级 Python 程序员提升到更高的编程水平。要达到专家级别，你需要彻底学习基础知识。
- en: Understanding the basics allows you to take a step back and see the bigger picture—an
    important skill whether you want to become tech lead at Google, a computer science
    professor, or just a great programmer. For instance, computer science professors
    will often have an incredibly profound knowledge of the basics in their field
    that allows them to argue from first principles and identify research gaps, rather
    than being blinded by the latest state-of-the-art technology. This chapter presents
    the most important Python basics, which serve as a foundation for the more advanced
    topics in this book.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 理解基础知识让你能够退一步看整体——这是无论你想成为谷歌的技术负责人、计算机科学教授，还是成为一名优秀的程序员，都会用到的重要技能。例如，计算机科学教授通常对自己领域的基础知识有非常深刻的理解，这让他们能够从第一原理出发进行论证，并发现研究的空白，而不是被最新的最先进技术所迷惑。本章介绍了最重要的
    Python 基础知识，它们为本书后续更高级的主题奠定了基础。
- en: '**Basic Data Structures**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**基本数据结构**'
- en: A thorough understanding of data structures is one of the most fundamental skills
    you can acquire as a programmer. It will help you no matter whether you create
    machine learning projects, work on large code bases, set up and manage websites,
    or write algorithms.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 对数据结构的透彻理解是你作为程序员可以获得的最基本技能之一。无论你是创建机器学习项目、处理大型代码库、搭建和管理网站，还是编写算法，它都能为你提供帮助。
- en: '***Numerical Data Types and Structures***'
  id: totrans-7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***数值数据类型和结构***'
- en: The two most important numerical data types are the integer and float. An *integer*
    is a positive or negative number without a floating point (for example, 3). A
    *float* is a positive or negative number with floating-point precision (for example,
    3.14159265359). Python offers a wide variety of built-in numerical operations,
    as well as functionality to convert between those numerical data types. Study
    the examples in [Listing 1-1](#list1-1) carefully to master these highly important
    numerical operations.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 两种最重要的数值数据类型是整数和浮点数。*整数*是没有小数点的正数或负数（例如，3）。*浮点数*是带有浮动小数精度的正数或负数（例如，3.14159265359）。Python
    提供了多种内置的数值运算功能，并且可以在这些数值数据类型之间进行转换。请仔细研究[列表 1-1](#list1-1)中的示例，以掌握这些非常重要的数值运算。
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 1-1: The numerical data types*'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 1-1：数值数据类型*'
- en: Most of the operators are self-explanatory. Note that the `//` operator performs
    integer division. The result is an integer value that is rounded down (for example,
    `3 // 2 == 1`).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数运算符是显而易见的。请注意，`//`运算符执行整数除法，结果是一个向下取整的整数值（例如，`3 // 2 == 1`）。
- en: '***Booleans***'
  id: totrans-12
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***布尔值***'
- en: A variable of type *Boolean* can take only two values—either `False` or `True`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 类型为*布尔型*的变量只能取两个值——`False`或`True`。
- en: 'In Python, Boolean and integer data types are closely related: the Boolean
    data type internally uses integer values (by default, the Boolean value `False`
    is represented by integer `0`, and the Boolean value `True` is represented by
    integer `1`). [Listing 1-2](#list1-2) gives an example of these two Boolean keywords.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，布尔类型和整数类型密切相关：布尔类型在内部使用整数值（默认情况下，布尔值`False`由整数`0`表示，布尔值`True`由整数`1`表示）。[列表
    1-2](#list1-2)给出了这两个布尔关键字的示例。
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 1-2: The Boolean values `False` and `True`*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 1-2：布尔值`False`和`True`*'
- en: After evaluating the given expressions, variable `x` refers to the Boolean value
    `False`, and variable `y` refers to the Boolean value `True`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在评估给定的表达式后，变量`x`表示布尔值`False`，变量`y`表示布尔值`True`。
- en: You can use Booleans with three important keywords to create more-complicated
    expressions in Python.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Python 中使用布尔值与三个重要的关键字组合，创建更复杂的表达式。
- en: '**Keywords: and, or, not**'
  id: totrans-19
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**关键字：and，or，not**'
- en: 'Boolean expressions represent basic logical operators. Using them in combination
    with only the following three keywords, you can craft a wide variety of potentially
    complicated expressions:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔表达式表示基本的逻辑运算符。通过将它们与以下三个关键字结合使用，你可以构造多种可能复杂的表达式：
- en: '**`and`** The expression `x and y` evaluates to `True` if value `x` is `True`
    *and* value `y` is `True`. If either of those is `False`, the overall expression
    becomes `False` too.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**`and`** 表达式 `x and y` 会在 `x` 为 `True` *且* `y` 为 `True` 时评估为 `True`。如果其中任何一个为
    `False`，整个表达式也会变成 `False`。'
- en: '**`or`** The expression `x or y` evaluates to `True` if value `x` is `True`
    *or* value `y` is `True` (or both values are `True`). If even just one of those
    is `True`, the overall expression becomes `True` too.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**`or`** 表达式 `x or y` 会在 `x` 为 `True` *或者* `y` 为 `True`（或者两者都为 `True`）时评估为
    `True`。如果其中任何一个为 `True`，整个表达式也会变成 `True`。'
- en: '**`not`** The expression `not x` evaluates to `True` if value `x` is `False`.
    Otherwise, the expression evaluates to `False`.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**`not`** 表达式 `not x` 如果 `x` 为 `False` 时评估为 `True`，否则评估为 `False`。'
- en: Consider the following Python code in [Listing 1-3](#list1-3).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑 [清单 1-3](#list1-3) 中的 Python 代码。
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 1-3: The keywords `and`, `or`, and `not`*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 1-3: 关键字 `and`、`or` 和 `not`*'
- en: By using these three keywords, you can express all the logical expressions you’ll
    ever need.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用这三个关键词，你可以表达所有你需要的逻辑表达式。
- en: '**Boolean Operator Precedence**'
  id: totrans-28
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**布尔运算符优先级**'
- en: 'The order that Boolean operators are applied is an important aspect of understanding
    Boolean logic. For example, consider the natural language statement `"it rains
    and it''s cold or windy"`. We can interpret this in two ways:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔运算符的应用顺序是理解布尔逻辑的一个重要方面。例如，考虑自然语言中的语句 `"下雨且天气寒冷或刮风"`。我们可以用两种方式来解释这个表达式：
- en: '**`"(it rains and it''s cold) or windy"`** In this case, the statement would
    be `True` if it is windy—even if it doesn’t rain.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**`"(下雨且天气寒冷)或刮风"`** 在这种情况下，如果是刮风的话，语句会被评估为`True`——即使没有下雨。'
- en: '**`and "it rains and (it''s cold or windy)"`** In this case, however, the statement
    would be `False` if it doesn’t rain—no matter whether it’s cold or windy.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**`并且 "下雨且(天气寒冷或刮风)"`** 然而，在这种情况下，如果没有下雨，无论天气是否寒冷或刮风，语句会被评估为`False`。'
- en: The order of Boolean operators matters. The correct interpretation of this statement
    would be the first one because the `and` operator takes precedence before the
    `or` operator. Let’s consider the code snippet in [Listing 1-4](#list1-4).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔运算符的顺序很重要。这个语句的正确解释应该是第一个，因为 `and` 运算符优先级高于 `or` 运算符。让我们看一下 [清单 1-4](#list1-4)
    中的代码片段。
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 1-4: The Boolean data type*'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 1-4: 布尔数据类型*'
- en: 'This code shows two important points. First, Boolean operators are ordered
    by priority—the operator `not` has the highest priority, followed by the operator
    `and`, followed by the operator `or`. Second, the following values are automatically
    evaluated to `False`: the keyword `None`, the integer value `0`, the float value
    `0.0`, empty strings, or empty container types.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码展示了两个重要的观点。首先，布尔运算符按优先级排序——`not` 运算符具有最高优先级，其次是 `and` 运算符，然后是 `or` 运算符。其次，以下值会自动评估为
    `False`：关键字 `None`、整数值 `0`、浮点值 `0.0`、空字符串或空容器类型。
- en: '***Strings***'
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***字符串***'
- en: 'Python *strings* are sequences of characters. Strings are immutable and so
    cannot be changed after creation. While other ways to create strings exist, these
    are the five most commonly used:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Python *字符串* 是字符的序列。字符串是不可变的，因此在创建后不能修改。虽然还有其他方式来创建字符串，但以下是五种最常用的方法：
- en: '**Single quotes** `''Yes''`'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**单引号** `''Yes''`'
- en: '**Double quotes** `"Yes"`'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**双引号** `"Yes"`'
- en: '**Triple quotes for multiline strings** `''''''Yes''''''` or `"""Yes"""`'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**三引号用于多行字符串** `''''''Yes''''''` 或 `"""Yes"""`'
- en: '**The string method** `str(5) == ''5''` is `True`'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**字符串方法** `str(5) == ''5''` 结果为 `True`'
- en: '**Concatenation** `''Py'' + ''thon''` becomes `''Python''`'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**连接** `''Py'' + ''thon''` 变成 `''Python''`'
- en: Often, you’ll explicitly want to use *whitespace characters* in strings. The
    most frequently used whitespace characters are the newline character `\n`, the
    space character `\s`, and the tab character `\t`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 经常，你会显式地在字符串中使用 *空白字符*。最常用的空白字符包括换行符 `\n`、空格符 `\s` 和制表符 `\t`。
- en: '[Listing 1-5](#list1-5) shows the most important string methods.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 1-5](#list1-5) 展示了最重要的字符串方法。'
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 1-5: The string data type*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 1-5: 字符串数据类型*'
- en: 'This non-exclusive list of string methods shows that the string data type is
    powerful, and you can solve many common string problems with built-in Python functionality.
    If in doubt about how to achieve a certain result regarding string problems, consult
    the online reference listing all built-in string methods: [*https://docs.python.org/3/library/string.html#module-string*](https://docs.python.org/3/library/string.html#module-string).'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这个非详尽的字符串方法列表展示了字符串数据类型的强大，你可以通过 Python 内建功能解决许多常见的字符串问题。如果对如何处理字符串问题有疑问，可以查阅在线参考文档，列出了所有内建的字符串方法：[*https://docs.python.org/3/library/string.html#module-string*](https://docs.python.org/3/library/string.html#module-string)。
- en: 'Booleans, integers, floats, and strings are the most important basic data types
    in Python. But often, you’ll need to *structure* data items rather than just create
    them. In those cases, container types are the answer. But before we dive into
    container data structures, let’s quickly learn about an important special data
    type: `None`.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值、整数、浮点数和字符串是 Python 中最重要的基本数据类型。但通常，你需要*构建*数据项，而不仅仅是创建它们。在这些情况下，容器类型是答案。但是在我们深入容器数据结构之前，先快速了解一个重要的特殊数据类型：`None`。
- en: '***The Keyword None***'
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***关键字 None***'
- en: The keyword `None` is a Python constant and it means *the absence of a value*.
    Other programming languages such as Java use the value `null` instead. However,
    the term `null` often confuses beginners, who assume it’s equal to the integer
    value `0`. Instead, Python uses the keyword `None`, as shown as [Listing 1-6](#list1-6),
    to indicate that it’s different from any numerical value for zero, an empty list,
    or an empty string. An interesting fact is that the value `None` is the only value
    in the `NoneType` data type.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字 `None` 是 Python 常量，表示*没有值*。其他编程语言，如 Java，使用 `null` 值来代替。然而，`null` 这个术语常常让初学者感到困惑，他们误以为它等同于整数值
    `0`。实际上，Python 使用关键字 `None`，如[列表 1-6](#list1-6)所示，用来表明它与任何数字值、空列表或空字符串不同。一个有趣的事实是，`None`
    是 `NoneType` 数据类型中唯一的值。
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 1-6: Using the keyword `None`*'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 1-6：使用关键字 `None`*'
- en: This code shows several examples of the `None` data value (and what it is not).
    If you don’t define a return value for a function, the default return value is
    `None`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码展示了几个 `None` 数据值的示例（以及它不代表的东西）。如果你没有为一个函数定义返回值，默认返回值就是 `None`。
- en: '**Container Data Structures**'
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**容器数据结构**'
- en: Python ships with *container data types* that can handle complex operations
    efficiently while being easy to use.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Python 提供了*容器数据类型*，这些数据类型能够高效地处理复杂操作，同时易于使用。
- en: '***Lists***'
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***列表***'
- en: 'The *list* is a container data type that stores a sequence of elements. Unlike
    strings, lists are *mutable*—you can modify them at runtime. I can best describe
    the list data type with a series of examples:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表*是一种容器数据类型，用于存储一系列元素。与字符串不同，列表是*可变*的——你可以在运行时修改它们。我可以通过一系列示例来最好地描述列表数据类型：'
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This code snippet shows how to create a list by using square brackets and how
    to populate it with three integer elements. You can also see that lists can have
    repeated elements. The `len()` function returns the number of elements in a list.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码展示了如何使用方括号创建一个列表，并如何用三个整数元素填充它。你还可以看到列表可以包含重复元素。`len()` 函数返回列表中的元素数量。
- en: '**Keyword: is**'
  id: totrans-60
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**关键字：is**'
- en: The keyword `is` simply checks whether both variables refer to the same object
    in memory. This can confuse Python newcomers. [Listing 1-7](#list1-7) checks whether
    two integers and two lists refer to the same object in memory.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字 `is` 简单地检查两个变量是否引用了内存中的同一个对象。这可能会让 Python 新手感到困惑。[列表 1-7](#list1-7) 检查两个整数和两个列表是否引用了内存中的同一个对象。
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 1-7: Using the keyword `is`*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 1-7：使用关键字 `is`*'
- en: If you create two lists—even if they contain the same elements—they still refer
    to two different list objects in memory. Modifying one list object does not affect
    the other list object. We say that lists are *mutable* because you can modify
    them after creation. Therefore, if you check whether one list refers to the same
    object in memory, the result is `False`. However, integer values are *immutable*,
    so there is no risk of one variable changing the object that will then accidentally
    change all other variables. The reason is that you cannot change the integer object
    `3`—trying it will only create a new integer object and leave the old one unmodified.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你创建了两个列表——即使它们包含相同的元素——它们仍然引用内存中两个不同的列表对象。修改其中一个列表对象不会影响另一个列表对象。我们说列表是 *可变的*，因为你可以在创建后修改它们。因此，如果你检查两个列表是否引用内存中的同一个对象，结果会是
    `False`。然而，整数值是 *不可变的*，因此不存在一个变量改变对象后会意外地更改所有其他变量的风险。原因在于，你不能改变整数对象 `3`——尝试这么做只会创建一个新的整数对象，而不会修改旧的对象。
- en: '**Adding Elements**'
  id: totrans-65
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**添加元素**'
- en: 'Python provides three common ways to add elements to an existing list: *append*,
    *insert*, or *list concatenation*.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Python 提供了三种常见方式来向现有列表添加元素：*append*、*insert* 或 *list concatenation*。
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: All three operations generate the same list `[1, 2, 2, 4]`. But the *append*
    operation is the fastest because it neither has to traverse the list to insert
    an element at the correct position (as with *insert*), nor create a new list out
    of two sublists (as with *list concatenation*). Roughly speaking, you use the
    insert operation only if you want to add an element at a specific position in
    the list that is not the last position. And you use the list concatenation operation
    to concatenate two lists of arbitrary length. Note that a fourth method, `extend()`,
    allows you to append multiple elements to the given list in an efficient manner.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这三种操作都会生成相同的列表 `[1, 2, 2, 4]`。但是，*append* 操作是最快的，因为它不需要遍历列表来将元素插入到正确的位置（如
    *insert* 操作），也不需要从两个子列表创建一个新的列表（如 *list concatenation* 操作）。大致来说，只有当你希望将元素添加到列表中的某个特定位置（而不是最后一个位置）时，才会使用
    *insert* 操作。而你会使用 *list concatenation* 操作来连接两个任意长度的列表。请注意，第四种方法 `extend()`，可以高效地将多个元素添加到给定的列表中。
- en: '**Removing Elements**'
  id: totrans-69
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**移除元素**'
- en: 'You can easily remove an element *`x`* from a list by using the `list` method
    `remove(`*`x`*`)`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用 `list` 方法 `remove(`*`x`*`)` 来轻松地从列表中移除元素 *`x`*：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The method operates on the list object itself, rather than creating a new list
    with the changes made. In the previous code example, we create a list object named
    `l` and modify this exact object in memory by removing an element. This saves
    memory overhead by reducing redundant copies of the same list data.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法作用于列表对象本身，而不是创建一个新列表来保存变更。在之前的代码示例中，我们创建了一个名为 `l` 的列表对象，并通过删除元素修改了该对象在内存中的内容。这通过减少冗余的列表数据副本来节省内存开销。
- en: '**Reversing Lists**'
  id: totrans-73
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**反转列表**'
- en: 'You can reverse the order of list elements by using the method `list.reverse()`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用方法 `list.reverse()` 来反转列表元素的顺序：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Reversing the list also modifies the original list object and does not merely
    create a new list object.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 反转列表也会修改原始的列表对象，而不仅仅是创建一个新的列表对象。
- en: '**Sorting Lists**'
  id: totrans-77
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**排序列表**'
- en: 'You can sort list elements by using the method `list.sort()`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用方法 `list.sort()` 来对列表元素进行排序：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Again, sorting the list modifies the original list object. The resulting list
    is sorted in an ascending manner. Lists containing string objects would be sorted
    in an ascending lexicographical manner (from `'a'` to `'z'`). In general, the
    sorting function assumes that two objects can be compared. Roughly speaking, if
    you can calculate `a > b` for objects `a` and `b` of any data type, Python can
    also sort the list `[a, b]`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，排序列表会修改原始的列表对象。结果列表是按升序排序的。包含字符串对象的列表将按升序字典顺序排序（从 `'a'` 到 `'z'`）。通常，排序函数假设两个对象可以进行比较。大致来说，如果你能够计算出
    `a > b`，对于任何数据类型的对象 `a` 和 `b`，Python 也可以对列表 `[a, b]` 进行排序。
- en: '**Indexing List Elements**'
  id: totrans-81
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**索引列表元素**'
- en: 'You can find out the index of a specified list element *`x`* by using the method
    `list.index(`*`x`*`)`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用方法 `list.index(`*`x`*`)` 来查找指定列表元素 *`x`* 的索引：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The method `index(`*`x`*`)` finds the first occurrence of the element *`x`*
    in the list and returns its index. Like other major programming languages, Python
    assigns index 0 to the first sequence and index *i*–1 to the *i*-th sequence.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 `index(`*`x`*`)` 查找列表中元素 *`x`* 的第一次出现并返回其索引。像其他主要编程语言一样，Python 将索引 0 分配给第一个序列，索引
    *i*–1 分配给第 *i* 个序列。
- en: '***Stacks***'
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***栈***'
- en: 'The *stack* data structure works intuitively as a first-in, first-out (FIFO)
    structure. Think of it as a stack of paperwork: you place every new paper on the
    top of a pile of old papers, and when you work through the stack, you keep removing
    the topmost document. The stack is still a fundamental data structure in computer
    science, used in operating system management, algorithms, syntax parsing, and
    backtracking.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*栈* 数据结构直观地作为一种先进先出（FIFO）的结构工作。可以把它想象成一堆文件：每次新增一张纸时，你会把它放在旧文件堆的最上面，而在处理堆中的文件时，你会一直取出最上面的一张。栈依然是计算机科学中的一种基本数据结构，广泛用于操作系统管理、算法、语法解析和回溯。'
- en: 'Python lists can be used intuitively as stacks with the list operations `append()`
    to add to the stack and `pop()` to remove the most recently added item:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Python 列表可以直观地用作栈，通过列表操作 `append()` 向栈中添加元素，通过 `pop()` 删除最近添加的元素：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Because of the efficiency of the list implementation, there is usually no need
    to import external stack libraries.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 由于列表实现的效率，通常不需要导入外部的栈库。
- en: '***Sets***'
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***集合***'
- en: The *set* data structure is a basic collection data type in Python and many
    other programming languages. Popular languages for distributed computing (for
    example, MapReduce or Apache Spark) even focus almost exclusively on set operations
    as programming primitives. So what is a set exactly? A set is an unordered collection
    of unique elements. Let’s break this definition into its main pieces.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*集合* 数据结构是 Python 以及许多其他编程语言中的一种基础集合数据类型。对于分布式计算的流行语言（例如 MapReduce 或 Apache
    Spark）来说，它们几乎专注于集合操作作为编程原语。那么，集合到底是什么呢？集合是一个无序的唯一元素集合。我们将这个定义分解为它的几个主要部分。'
- en: '**Collection**'
  id: totrans-92
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**集合**'
- en: A set is a collection of elements like a list or a tuple. The collection consists
    of either primitive elements (integers, floats, strings), or complex elements
    (objects, tuples). However, all data types in a set must be *hashable*, meaning
    that they have an associated hash value. A hash value of an object never changes
    and is used to compare the object to other objects. Let’s look at an example in
    [Listing 1-8](#list1-8), which creates a set from three strings after checking
    their hash values. You try to create a set of lists, but fail because lists are
    not hashable.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是一个包含元素的集合，类似于列表或元组。集合中的元素可以是原始元素（整数、浮动数、字符串），也可以是复杂元素（对象、元组）。然而，集合中的所有数据类型必须是
    *可哈希的*，这意味着它们有一个与之相关联的哈希值。对象的哈希值永远不会改变，它用于将该对象与其他对象进行比较。我们来看一下 [清单 1-8](#list1-8)
    中的一个例子，它通过检查字符串的哈希值来创建一个由三个字符串组成的集合。你尝试创建一个由列表组成的集合，但由于列表不可哈希，操作失败。
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 1-8: The set data type allows for only hashable elements.*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 1-8：集合数据类型只允许可哈希元素。*'
- en: You can create a set of strings because strings are *hashable*. But you cannot
    create a set of lists, because lists are *unhashable*. The reason is that the
    hash value depends on the content of the item, and lists are *mutable*; if you
    change the list data type, the hash value must change too. Because mutable data
    types are not hashable, you cannot use them in sets.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建一个字符串集合，因为字符串是 *可哈希的*。但是你不能创建一个由列表组成的集合，因为列表是 *不可哈希的*。原因在于哈希值依赖于项的内容，而列表是
    *可变的*；如果你更改列表数据类型，那么哈希值也必须发生变化。由于可变数据类型不可哈希，所以你不能在集合中使用它们。
- en: '**Unordered**'
  id: totrans-97
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**无序**'
- en: 'Unlike lists, elements in a set have no fixed order. Regardless of the order
    in which you put stuff into the set, you can never be sure in which order the
    set stores these elements. Here is an example:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 与列表不同，集合中的元素没有固定的顺序。无论你以什么顺序将元素放入集合，你永远无法确定集合存储这些元素的顺序。以下是一个例子：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: I put in the hero first, but my interpreter prints the enemy first (the Python
    interpreter is on the dark side, obviously). Note that your interpreter may print
    yet another order of the set elements.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我先放入英雄，但我的解释器却先打印敌人（显然，Python 解释器站在黑暗面）。请注意，你的解释器可能会以另一种顺序打印集合中的元素。
- en: '**Unique**'
  id: totrans-101
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**唯一**'
- en: 'All elements in the set must be unique. Formally, each of two values `x, y`
    in the set with `x!=y` have different hash values `hash(x)!=hash(y)`. Because
    every two elements `x` and `y` in the set are different, you cannot create an
    army of Harry Potter clones to fight Lord V.:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 集合中的所有元素必须是唯一的。严格来说，集合中任意两个值 `x, y`，满足 `x!=y` 时，它们的哈希值也应该不同，即 `hash(x)!=hash(y)`。因为集合中的每两个元素
    `x` 和 `y` 都是不同的，所以你不能创造一支哈利·波特的克隆军队去对抗伏地魔。
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: No matter how often you put the same value into the same set, the set stores
    only one instance of this value. The reason is that those heroes have the same
    hash value, and a set contains at most one element per hash value. An extension
    of the normal set data structure is the *multiset data structure*, which can store
    multiple instances of the same value. However, it is seldom used in practice.
    In contrast, you will use sets in almost any nontrivial code project—for example,
    to intersect a set of customers with a set of persons who visited a store, which
    will return a new set of customers who also visited the store.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你多少次将相同的值放入同一个集合，集合只会存储该值的一个实例。原因在于这些值的哈希值相同，集合每个哈希值最多只能包含一个元素。普通集合数据结构的扩展是*多重集合数据结构*，它可以存储相同值的多个实例。然而，它在实际应用中很少被使用。相比之下，几乎在任何非平凡的代码项目中，你都会使用集合——例如，将一组顾客与一组访问过商店的人员进行交集运算，这将返回一个新的包含同时访问过商店的顾客的集合。
- en: '***Dictionaries***'
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***字典***'
- en: 'The *dictionary* is a useful data structure for storing `(`*`key, value`*`)`
    pairs:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典*是一个用于存储`(`*键, 值*`)`对的有用数据结构：'
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can read and write elements by specifying the key within brackets:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在方括号内指定键来读取和写入元素：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Use the `keys()` and `values()` functions to access all keys and values of
    the dictionary:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`keys()`和`values()`函数访问字典的所有键和值：
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Access the `(`*`key, value`*`)` pairs of a dictionary with the `items()` method:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`items()`方法访问字典的`(`*键, 值*`)`对：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This way, it’s easy to iterate over all keys and all values in a dictionary
    without accessing them individually.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你就可以轻松地遍历字典中的所有键和值，而无需单独访问它们。
- en: '***Membership***'
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***成员资格***'
- en: Use the keyword `in` to check whether the set, list, or dictionary contains
    an element (see [Listing 1-9](#list1-9)).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用关键字`in`来检查集合、列表或字典中是否包含某个元素（参见[列表1-9](#list1-9)）。
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 1-9: Using the keyword `in`*'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表1-9：使用关键字`in`*'
- en: You use the keyword `in` to test membership of the integer value `42` ➊ in a
    list of integer values or to test membership of a string value `"21"` in a set
    of strings ➋. We say *x* is a *member* of *y* if element *x* appears in the collection
    *y*.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用关键字`in`来测试整数值`42` ➊ 是否存在于整数值列表中，或者测试字符串值`"21"`是否存在于字符串集合中 ➋。我们说*x*是*y*的*成员*，如果元素*x*出现在集合*y*中。
- en: 'Checking set membership is faster than checking list membership: to check whether
    element *x* appears in list *y*, you need to traverse the whole list until you
    find *x* or have checked all elements. However, sets are implemented much like
    dictionaries: to check whether element *x* appears in set *y*, Python internally
    performs one operation *`y`*`[hash(`*`x`*`)]` and checks whether the return value
    is not `None`.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 检查集合成员比检查列表成员要快：要检查元素*x*是否出现在列表*y*中，你需要遍历整个列表，直到找到*x*或者检查完所有元素。然而，集合的实现方式类似于字典：要检查元素*x*是否出现在集合*y*中，Python会在内部执行一次操作`y`[`hash(x)`]，并检查返回值是否不为`None`。
- en: '***List and Set Comprehension***'
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***列表和集合推导式***'
- en: '*List comprehension* is a popular Python feature that helps you quickly create
    and modify lists. The simple formula is `[` *`expression`* `+` *`context`* `]`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表推导式*是Python中的一个流行特性，帮助你快速创建和修改列表。其简单公式是`[` *`表达式`* `+` *`上下文`* `]`：'
- en: '**Expression** Tells Python what to do with each element in the list.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**表达式** 告诉Python如何处理列表中的每个元素。'
- en: '**Context** Tells Python which list elements to select. The context consists
    of an arbitrary number of `for` and `if` statements.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**上下文** 告诉Python应该选择列表中的哪些元素。上下文由任意数量的`for`和`if`语句组成。'
- en: 'For example, in the list comprehension statement `[x for x in range(3)]`, the
    first part `x` is the (identity) expression, and the second part `for x in` `range(3)`
    is the context. The statement creates the list `[0, 1, 2]`. The `range()` function
    returns a range of subsequent integer values 0, 1, and 2—when used with one argument
    as in the example. Another code example for list comprehension is the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在列表推导式语句`[x for x in range(3)]`中，第一部分`x`是（标识）表达式，第二部分`for x in range(3)`是上下文。该语句创建了列表`[0,
    1, 2]`。`range()`函数返回0、1和2这三个连续的整数值——当使用一个参数时，如示例中所示。另一个列表推导式的代码示例如下：
- en: '[PRE22]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Set comprehension is like list comprehension, but creates a set rather than
    a list.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 集合推导式类似于列表推导式，但创建的是一个集合而不是列表。
- en: '**Control Flow**'
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**控制流**'
- en: '*Control flow* functionality allows you to make decisions in your code. Algorithms
    are often compared to cooking recipes that consist of a sequential list of commands:
    fill the pot with water, add salt, add rice, drain the water, and serve the rice.
    As it is, without a *conditional execution*, the sequence of commands would take
    only a few seconds to execute, and the rice would not be ready for sure. For example,
    you would fill in water, salt, and rice and immediately get rid of the water without
    waiting for the water to be hot and the rice to be soft.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*控制流*功能让你可以在代码中做出决策。算法常常被比作烹饪食谱，它们由一系列顺序的命令组成：把水倒进锅里，加入盐，加入米，倒掉水，最后把米盛出来。如果没有*条件执行*，这些命令的执行将仅需几秒钟，米饭也肯定不会做好。例如，你可能会先加入水、盐和米，然后立即把水倒掉，而不等水变热、米变软。'
- en: 'You need to respond in a different way to different circumstances: you need
    to put the rice in the pot only *if* the water is hot, and you need to remove
    the water from the pot only *if* the rice is soft. It’s almost impossible to write
    programs in a way that anticipates what happens deterministically in the real
    world. Instead, you need to write programs that respond differently if different
    conditions are met.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要根据不同的情况做出不同的反应：只有*当*水已经热了，你才需要把米放进锅里；只有*当*米已经煮软了，你才需要把水从锅里倒掉。几乎不可能用一种方式编写程序，预见现实世界中发生的所有确定性事件。相反，你需要编写能够在满足不同条件时作出不同响应的程序。
- en: '***if, else, and elif***'
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***if、else和elif***'
- en: The keywords `if`, `else`, and `elif` (see [Listing 1-10](#list1-10)) enable
    you to perform conditional execution of different code branches.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字`if`、`else`和`elif`（见[列表 1-10](#list1-10)）使你能够对不同的代码分支进行条件执行。
- en: '[PRE23]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 1-10: Using the keywords `if`, `else`, and `elif`*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 1-10：使用关键字`if`、`else`和`elif`*'
- en: This first takes the user input, converts it into an integer, and stores it
    in the variable `x` ➊. It then tests whether the variable value is larger than
    ➋, equal to ➌, or smaller than ➍ the value `3`. In other words, the code responds
    to real-world input that is *unpredictable* in a differentiated manner.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码首先获取用户输入，将其转换为整数，并存储在变量`x`中➊。然后测试变量的值是否大于➋、等于➌，或者小于➍值`3`。换句话说，代码以差异化的方式响应现实世界中的*不可预测*输入。
- en: '***Loops***'
  id: totrans-136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***循环***'
- en: 'To allow for repeated execution of code snippets, Python uses two types of
    loops: `for` loops and `while` loops. Using these, you can easily write a program
    consisting only of two lines of code that execute forever. This repetition would
    be difficult otherwise (an alternative is *recursion*.)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许代码片段的重复执行，Python使用两种类型的循环：`for`循环和`while`循环。通过使用这些循环，你可以轻松地编写一个仅由两行代码组成的程序，且能永远执行下去。否则，这种重复执行会变得很困难（另一个方法是*递归*）。
- en: In [Listing 1-11](#list1-11), you can see both loop variants in action.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表 1-11](#list1-11)中，你可以看到这两种循环变体的实际应用。
- en: '[PRE24]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Listing 1-11: Using the keywords `for` and `while`*'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 1-11：使用关键字`for`和`while`*'
- en: Both loop variants print the integers `0`, `1`, and `2` to the shell, but accomplish
    the task in two ways.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 两种循环变体都会将整数`0`、`1`和`2`打印到终端，但以两种不同的方式完成任务。
- en: The `for` loop declares a loop variable `i` that iteratively takes on all values
    in the list `[0, 1, 2]`. It keeps running until it runs out of values.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环声明了一个循环变量`i`，它会依次取列表`[0, 1, 2]`中的所有值。循环会一直执行，直到值用尽。'
- en: The `while` loop executes the loop body as long as a particular condition is
    met—in our case, while `j < 3`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环会在满足特定条件时执行循环体——在我们的例子中，当`j < 3`时。'
- en: 'There are two fundamental ways of terminating a loop: you can define a loop
    condition that eventually evaluates to `False`, or use the keyword `break` at
    the exact position in the loop body. [Listing 1-12](#list1-12) shows an example
    of the latter.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 终止循环有两种基本方式：你可以定义一个最终评估为`False`的循环条件，或者在循环体的特定位置使用关键字`break`。[列表 1-12](#list1-12)展示了后一种方式的示例。
- en: '[PRE25]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 1-12: Using the keyword `break`*'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 1-12：使用关键字`break`*'
- en: 'You create a `while` loop with a loop condition that will always evaluate to
    `True`. So, at first sight, it seems to run forever. An infinite `while` loop
    is common practice when, for example, developing web servers that forever repeat
    the following procedure: wait for a new web request and serve the request. However,
    in some cases, you’ll still want to terminate the loop prematurely. In the web
    server example, you would stop serving files for security reasons when your server
    detects that it is under attack. In these cases, you can use the keyword `break`
    to stop the loop and execute the code that follows immediately. In [Listing 1-12](#list1-12),
    the code executes `print("hello world")` after the loop ends prematurely.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你创建了一个`while`循环，其循环条件总是评估为`True`。所以乍一看，它似乎会一直运行下去。无限`while`循环是常见做法，例如在开发web服务器时，服务器会重复执行以下过程：等待新的网页请求并提供服务。然而，在某些情况下，你仍然希望提前终止循环。在web服务器的例子中，当服务器检测到正在受到攻击时，你会停止提供文件以确保安全。在这些情况下，你可以使用关键字`break`来停止循环并立即执行后续代码。在[Listing
    1-12](#list1-12)中，循环提前结束后，代码执行`print("hello world")`。
- en: It is also possible to force the Python interpreter to skip certain areas in
    the loop without ending it prematurely. For example, you may want to skip malicious
    web requests instead of halting the server completely. You can achieve this by
    using the `continue` statement, which finishes the current loop iteration and
    brings the execution flow back to the loop condition (see [Listing 1-13](#list1-13)).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以强制Python解释器跳过循环中的某些区域，而不提前结束循环。例如，你可能希望跳过恶意的网页请求，而不是完全停止服务器。你可以通过使用`continue`语句来实现这一点，它会结束当前的循环迭代并将执行流返回到循环条件（参见[Listing
    1-13](#list1-13)）。
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Listing 1-13: Using the keyword `continue`*'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 1-13: 使用关键字`continue`*'
- en: This code executes forever without executing the `print` statement once. The
    reason is that the `continue` statement finishes the current loop iteration and
    takes it back to the start, so execution never reaches the `print` statement.
    Code that never executes is known as *dead code*. For this reason, the `continue`
    statement (as well as the `break` statement) is commonly used under a certain
    condition by using a conditional if-else environment.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码会一直执行，但从未执行过`print`语句。原因是`continue`语句结束当前的循环迭代并将其带回到开始，所以执行从未到达`print`语句。永远不会执行的代码被称为*死代码*。因此，`continue`语句（以及`break`语句）通常在某些条件下，通过使用条件if-else语句来使用。
- en: '**Functions**'
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**函数**'
- en: '*Functions* help you to reuse code snippets at your leisure: write them once
    but use them often. You define a function with the keyword `def`, a function name,
    and a set of arguments to customize the execution of the function body. Calling
    the function with two sets of arguments can drastically change the result of the
    function. For example, you can define the function `square(`*`x`*`)` that returns
    the square number of input argument *`x`*. Calling `square(10)` results in *10
    × 10 = 100* while calling `square(100)` results in *100 × 100 = 10,000*.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数*帮助你在需要时重用代码片段：只需编写一次，但可以多次使用它们。你可以使用关键字`def`定义一个函数，接着是函数名称和一组参数来定制函数体的执行。用两组参数调用函数可以极大地改变函数的结果。例如，你可以定义函数`square(`*`x`*`)`，它返回输入参数*`x`*的平方值。调用`square(10)`的结果是*10
    × 10 = 100*，而调用`square(100)`的结果是*100 × 100 = 10,000*。'
- en: The keyword `return` terminates the function and passes the flow of execution
    to the caller of the function. You can also provide an optional value after the
    `return` keyword to specify the function result (see [Listing 1-14](#list1-14)).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字`return`终止函数并将执行流传递给调用该函数的地方。你还可以在`return`关键字后提供一个可选值，以指定函数的返回结果（参见[Listing
    1-14](#list1-14)）。
- en: '[PRE27]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 1-14: Using the keyword `return`*'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 1-14: 使用关键字`return`*'
- en: You create a function `appreciate()` that calculates how much a given investment
    appreciates at a given percentage of return. In the code, you calculate how much
    an investment of $10,000 appreciates in one year when assuming an interest rate
    of 5 percent. The result is $10,500\. You use the keyword `return` to specify
    that the result of the function should be the sum of the original investment and
    the nominal interest of this investment. The return value of the function `appreciate()`
    is of type float.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你创建了一个函数`appreciate()`，它计算给定投资在指定回报率下的增值情况。在代码中，你计算了当假设利率为5%时，$10,000的投资在一年内增值了多少。结果是$10,500。你使用了关键字`return`来指定函数的返回值应该是原始投资和该投资的名义利息之和。函数`appreciate()`的返回值类型为float。
- en: '**Lambdas**'
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Lambda表达式**'
- en: 'You use the keyword `lambda` to define lambda functions in Python. *Lambda
    functions* are anonymous functions that are not defined in the namespace. Roughly
    speaking, they are functions without names, intended for single use. The syntax
    is as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用关键字 `lambda` 来定义 Python 中的 lambda 函数。*Lambda 函数* 是匿名函数，它们没有在命名空间中定义。简单来说，lambda
    函数就是没有名称的函数，通常用于单次使用。其语法如下：
- en: '[PRE28]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: A lambda function can have one or multiple arguments, separated by commas. After
    the colon (`:`), you define the return expression that may (or may not) use the
    defined argument. The return expression can be any expression or even another
    function.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 lambda 函数可以有一个或多个参数，用逗号分隔。在冒号（`:`）之后，你定义了返回表达式，该表达式可以（也可以不）使用已定义的参数。返回表达式可以是任何表达式，甚至是另一个函数。
- en: 'Lambda functions play a major role in Python. You’ll see them a lot in practical
    code projects: for example, to make code shorter and more concise, or to create
    arguments of various Python functions (such as `map()` or `reduce()`). Consider
    the code in [Listing 1-15](#list1-15).'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 函数在 Python 中扮演着重要角色。在实际的代码项目中，你会经常看到它们：例如，用来简化代码或创建各种 Python 函数的参数（如
    `map()` 或 `reduce()`）。请看 [示例 1-15](#list1-15) 中的代码。
- en: '[PRE29]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*Listing 1-15: Using the keyword `lambda`*'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 1-15：使用关键字 `lambda`*'
- en: First, you create a lambda function that takes a value `x` and returns the result
    of the expression `x + 3`. The result is a function object that can be called
    like any other function. Because of its semantics, you denote this function as
    an *incrementor function*. When calling this incrementor function with the argument
    `x=3`—the suffix `(3)` within the print statement in [Listing 1-15](#list1-15)—the
    result is the integer value `6`. This book uses lambda functions heavily, so make
    sure you understand them properly (though you will also have opportunities to
    improve your intuitive understanding of lambda functions).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你创建了一个 lambda 函数，它接受一个值 `x` 并返回表达式 `x + 3` 的结果。返回的结果是一个函数对象，可以像其他函数一样被调用。由于其语义的原因，你将这个函数称为
    *增量函数*。当用参数 `x=3` 调用这个增量函数时——即 [示例 1-15](#list1-15) 中 print 语句后的后缀 `(3)`——结果是整数值
    `6`。本书大量使用 lambda 函数，因此请确保你正确理解它们（尽管你也将有机会进一步提升对 lambda 函数的直观理解）。
- en: '**Summary**'
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: 'This chapter gave you a concise Python crash course to refresh your basic Python
    education. You studied the most important Python data structures and how to use
    them in code examples. You learned how to control the program execution flow by
    using if-elif-else statements, as well as `while` and `for` loops. You revisited
    the basic data types in Python—Boolean, integer, float, and string—and saw which
    built-in operations and functions are commonly used. Most code snippets in practice
    and nontrivial algorithms are built around more-powerful container types such
    as lists, stacks, sets, and dictionaries. By studying the given examples, you
    learned how to add, remove, insert, and reorder elements. You also learned about
    membership operators and list comprehension: an efficient and powerful built-in
    method to create lists programmatically in Python. Finally, you learned about
    functions and how to define them (including the anonymous lambda function). Now,
    you are ready for the first 10 basic Python one-liners.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 本章为你提供了一个简洁的 Python 快速入门课程，以刷新你对基础 Python 知识的掌握。你学习了最重要的 Python 数据结构，以及如何在代码示例中使用它们。你学会了如何通过使用
    if-elif-else 语句以及 `while` 和 `for` 循环来控制程序的执行流程。你复习了 Python 中的基本数据类型——布尔型、整数、浮点型和字符串，并了解了哪些内建操作和函数是常用的。大多数实际代码片段和复杂算法都围绕着更强大的容器类型构建，如列表、栈、集合和字典。通过学习给定的示例，你学会了如何添加、删除、插入和重新排序元素。你还了解了成员操作符和列表推导式：这是一个高效且强大的内建方法，用于在
    Python 中以编程方式创建列表。最后，你学会了函数的定义方法（包括匿名的 lambda 函数）。现在，你已经准备好学习 Python 中的前 10 个基础单行代码。
