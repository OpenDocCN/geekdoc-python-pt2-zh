- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Creating Visualizations
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 创建可视化图表
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: Data can be viewed more clearly in a visual form than it can be as raw numbers.
    For example, you might want to create a line chart graphing the changes in a stock
    price over time. Or you could track the interest in the articles on your website
    using a histogram showing daily views of each. Visualizations such as these help
    you immediately recognize trends in your data.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 与原始数据相比，数据的可视化形式能更清晰地展示信息。例如，你可能想要创建一张折线图，展示股票价格随时间变化的趋势。或者，你也可以使用直方图跟踪网站文章的兴趣，显示每篇文章的日浏览量。像这样的可视化图表能帮助你立即识别数据中的趋势。
- en: This chapter provides an overview of the most common types of data visualizations
    and covers how to create them using Matplotlib, a popular Python plotting library.
    You’ll also learn how to integrate Matplotlib with pandas and how to create maps
    with Matplotlib and the Cartopy library.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章概述了最常见的数据可视化类型，并介绍了如何使用流行的 Python 绘图库 Matplotlib 创建这些可视化图表。你还将学习如何将 Matplotlib
    与 pandas 集成，以及如何使用 Matplotlib 和 Cartopy 库创建地图。
- en: Common Visualizations
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见的可视化图表
- en: Several chart types are available for visualizing data, including line graphs,
    bar graphs, pie charts, and histograms. In this section, we’ll discuss these common
    visualizations and explore typical use cases for each.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 可用于数据可视化的图表类型有多种，包括折线图、条形图、饼图和直方图。在本节中，我们将讨论这些常见的可视化图表，并探索每种图表的典型使用案例。
- en: Line Graphs
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 折线图
- en: '*Line graphs*, also known as *line charts*, are useful when you need to illustrate
    trends in data over a period of time. In a line graph, you place the timestamp
    column of a dataset along the x-axis and one or more numeric columns on the y-axis.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*折线图*，也称为 *折线图表*，用于展示一段时间内数据的趋势。在折线图中，你将数据集的时间戳列放置在 x 轴上，将一个或多个数值列放置在 y 轴上。'
- en: Consider a website where users can view different articles. You can create a
    chart for an article in which the x-axis plots a series of days and the y-axis
    displays how many times the article has been viewed each day. This is shown in
    [Figure 8-1](#figure8-1).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 以一个用户可以查看不同文章的网站为例，你可以为某篇文章创建一张图表，其中 x 轴表示一系列日期，y 轴表示每天该文章的浏览量。这一点在[图 8-1](#figure8-1)中得到了展示。
- en: '![A line graph with dates labeled along the x-axis and article views shown
    on the y-axis.](image_fi/502208c08/f08001.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![一张折线图，x 轴上标记了日期，y 轴上显示了文章的浏览量。](image_fi/502208c08/f08001.png)'
- en: 'Figure 8-1: A line graph showing article views over time'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-1：一张展示文章浏览量随时间变化的折线图
- en: You can overlay data from multiple parameters in one line chart to illustrate
    the correlation between them, plotting each parameter’s data with a line of a
    different color. For example, [Figure 8-2](#figure8-2) shows the website’s daily
    number of unique users on top of the number of article views.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在同一张折线图中叠加多个参数的数据，以展示它们之间的相关性，用不同颜色的线条绘制每个参数的数据。例如，[图 8-2](#figure8-2)展示了网站的日独立访客数与文章浏览量的叠加。
- en: '![The same line graph from Figure 8-1 with a second line added to show unique
    visitors each day. The two lines follow roughly the same shape.](image_fi/502208c08/f08002.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图 8-1 中相同的折线图，添加了第二条线，显示每天的独立访客数。两条线大致呈现相同的形状。](image_fi/502208c08/f08002.png)'
- en: 'Figure 8-2: A line graph showing the relationship between various parameters'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-2：一张折线图，展示了各参数之间的关系
- en: The left-hand y-axis in this line graph shows article views, while the right-hand
    y-axis shows unique visitors. Overlaying the data for both parameters, it’s visually
    clear that there’s a general correlation between the numbers of article views
    and unique visitors.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这张折线图的左侧 y 轴显示了文章浏览量，右侧 y 轴显示了独立访客数。将两者的数据叠加后，可以直观地看到文章浏览量与独立访客数之间的普遍关联。
- en: Bar Graphs
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 条形图
- en: '*Bar graphs*, also referred to as *bar charts* or *column charts*, show categorical
    data using rectangular bars with heights proportional to the values they represent,
    allowing for comparisons between categories. For example, consider the following
    figures, which represent a company’s annual sales aggregated on a regional basis:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*条形图*，也叫 *条形图表* 或 *柱形图表*，使用矩形条来显示类别数据，条形的高度与所代表的值成比例，从而可以对不同类别进行比较。例如，以下图示展示了一家公司按地区汇总的年度销售数据：'
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[Figure 8-3](#figure8-3) illustrates what this sales data looks like when plotted
    on a bar graph.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8-3](#figure8-3)展示了将这些销售数据绘制为条形图后的效果。'
- en: '![A bar graph with vertical bars for three regions. The heights of the bars
    indicate the sales totals for each region.](image_fi/502208c08/f08003.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![一个显示三个区域的垂直条形图。条形的高度表示每个区域的销售总额。](image_fi/502208c08/f08003.png)'
- en: 'Figure 8-3: A bar graph showing comparative categorical data'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-3：一个显示比较分类数据的条形图
- en: In this chart, the y-axis displays comparative sales figures for the regions
    shown on the x-axis.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在此图中，y轴显示了与x轴上显示的区域相比较的销售数据。
- en: Pie Charts
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 饼图
- en: '*Pie charts* illustrate the proportion of each category in the full dataset,
    expressed as a percentage. [Figure 8-4](#figure8-4) illustrates the sales figures
    from the previous example when plotted on a pie chart.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*饼图*展示了每个类别在整个数据集中的比例，通常以百分比表示。[图 8-4](#figure8-4)展示了之前示例中的销售数据在饼图中的表现。'
- en: '![A pie chart with three slices sized to show the sales totals for each of
    three regions.](image_fi/502208c08/f08004.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![一个饼图，三个切片的大小表示三个区域的销售总额。](image_fi/502208c08/f08004.png)'
- en: 'Figure 8-4: Pie charts represent the percentage of each category as a slice
    of a circle.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-4：饼图表示每个类别作为圆的一部分的百分比。
- en: Here, the size of each slice provides a visual representation of the proportion
    that each category contributes to the whole. You can easily see how the sales
    for each region compare to each other. This works well when each slice represents
    a substantial portion of the pie, but as you might guess, a pie chart isn’t the
    best choice when you have to represent very small portions. For example, a slice
    representing 0.01 percent of the whole may not even be visible in the chart.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，每个切片的大小提供了每个类别在整体中所占比例的可视化表示。你可以轻松地看出每个区域的销售额相互比较。对于每个切片表示整体中相对较大部分的情况，饼图非常有效，但如你所猜测的那样，当你需要表示非常小的部分时，饼图就不是最佳选择。例如，表示整个数据集
    0.01% 的切片可能在图表中根本不可见。
- en: Histograms
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 直方图
- en: '*Histograms* show frequency distributions, or how many times a particular value
    or range of values appears in a dataset. Each value, or outcome, is represented
    by a vertical bar whose height corresponds to that value’s frequency. For example,
    the histogram in [Figure 8-5](#figure8-5) immediately makes apparent the frequency
    of different salary groups in a sales department.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*直方图*显示频率分布，即某个特定值或值的范围在数据集中出现的次数。每个值或结果由一个垂直条表示，条形的高度与该值的频率对应。例如，[图 8-5](#figure8-5)中的直方图立即展示了销售部门中不同薪资群体的频率。'
- en: In this histogram, salaries are grouped into $50 ranges, with each vertical
    bar representing the number of people who have salaries within a certain range.
    The visualization lets you quickly see how many employees earn between $1,200
    and $1,250, for example, as compared to other ranges, like $1,250 to $1,300.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个直方图中，薪资被分成$50的区间，每个垂直条表示收入在某一范围内的人数。通过这种可视化，你可以迅速看到比如$1,200到$1,250之间的员工数量，与其他区间如$1,250到$1,300进行比较。
- en: '![A histogram whose x-axis is divided into $50 increments from $1,100 to $1,850\.
    Vertical bars show how many people have a salary within each increment. Some increments
    are blank.](image_fi/502208c08/f08005.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![一个直方图，x轴按$50的增量划分，从$1,100到$1,850。垂直条显示有多少人收入在每个增量区间内。有些增量区间没有数据。](image_fi/502208c08/f08005.png)'
- en: 'Figure 8-5: A histogram showing a salary distribution'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-5：一个显示薪资分布的直方图
- en: Plotting with Matplotlib
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Matplotlib 绘图
- en: Now that you’ve seen the most common types of charts, we’ll consider how to
    create them using Matplotlib, one of the most popular Python libraries for data
    visualization. You’ll learn how to make line graphs, pie charts, bar graphs, and
    histograms.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了最常见的图表类型，我们将讨论如何使用 Matplotlib 来创建它们。Matplotlib 是一个流行的 Python 数据可视化库，你将学习如何制作折线图、饼图、条形图和直方图。
- en: Each Matplotlib visualization, or *figure*, is built from a hierarchy of nested
    objects. You can work with those objects directly to create highly customizable
    visualizations, or you can manipulate the objects indirectly through the functions
    provided in the `matplotlib.pyplot` module. The latter approach is simpler and
    is often sufficient for creating basic charts and graphs.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 Matplotlib 可视化图形或*图表*是由一系列嵌套的对象组成的。你可以直接操作这些对象来创建高度可定制的可视化，或者通过 `matplotlib.pyplot`
    模块中提供的函数间接操作这些对象。后一种方法更简单，通常足以创建基本的图表和图形。
- en: Installing Matplotlib
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装 Matplotlib
- en: 'Check if Matplotlib is already installed by trying to import it in a Python
    interpreter session:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 Python 解释器会话中尝试导入 Matplotlib，检查它是否已经安装：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you get a `ModuleNotFoundError`, install Matplotlib with `pip` as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到`ModuleNotFoundError`错误，使用以下命令通过`pip`安装Matplotlib：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Using matplotlib.pyplot
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用matplotlib.pyplot
- en: 'The `matplotlib.pyplot` module, typically referred to in code as `plt`, provides
    a collection of functions for building good-looking figures. The module lets you
    easily define various aspects of a figure, such as its title, its axis labels,
    and so on. For example, here’s how to construct a line graph plotting Tesla’s
    closing stock price over five consecutive days:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`matplotlib.pyplot`模块，通常在代码中称为`plt`，提供了一系列函数，用于创建美观的图表。该模块使你能够轻松定义图表的各种属性，如标题、轴标签等。例如，下面是如何构建一个展示特斯拉五个连续交易日收盘股价的折线图：'
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'First, you define your dataset as two lists: `days`, which contains the dates
    that will be plotted along the x-axis, and `prices`, which contains the prices
    that will be plotted along the y-axis. Then you create a *plot*, the part of the
    figure that actually shows the data, with the `plt.plot()` function, passing it
    the data for the x- and y-axes. In the next three lines of code, you customize
    the figure: you add a title with `plt.title()` and labels for the x- and y-axes
    with `plt.xlabel()` and `plt.ylabel()`. Finally, you display the figure with `plt.show()`.
    [Figure 8-6](#figure8-6) shows the result.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你将数据集定义为两个列表：`days`，包含将在x轴上绘制的日期，以及`prices`，包含将在y轴上绘制的价格。然后，你使用`plt.plot()`函数创建一个*图表*，即实际显示数据的部分，并传入x轴和y轴的数据。在接下来的三行代码中，你对图表进行定制：使用`plt.title()`添加标题，使用`plt.xlabel()`和`plt.ylabel()`为x轴和y轴添加标签。最后，使用`plt.show()`显示图表。[图8-6](#figure8-6)展示了结果。
- en: '![A line graph plotting the increase in Tesla stock prices over five days.](image_fi/502208c08/f08006.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![一张展示特斯拉股价在五天内上涨的折线图。](image_fi/502208c08/f08006.png)'
- en: 'Figure 8-6: A simple line graph generated with the `matplotlib.pyplot` module'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-6：使用`matplotlib.pyplot`模块生成的简单折线图
- en: By default, `plt.plot()` yields a visualization rendered as a series of lines
    connecting the data points, which are plotted on the x- and y-axes. Matplotlib
    has automatically chosen a range of 720 to 880 for the y-axis, demarcated in intervals
    of 20, making it easy to see each day’s stock price.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`plt.plot()` 会生成一个可视化图像，将数据点连接成一系列线条，这些数据点会被绘制在x轴和y轴上。Matplotlib自动为y轴选择了一个720到880的范围，间隔为20，便于查看每日的股价。
- en: 'Building a basic pie chart is just as simple as making a line graph. For example,
    the following code generates the pie chart shown earlier in [Figure 8-4](#figure8-4):'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个基本的饼图和制作折线图一样简单。例如，以下代码生成了如前所示的[图8-4](#figure8-4)中的饼图：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The script follows the same basic pattern you used to make the line graph:
    you define the data to be plotted, create a plot, customize some of its features,
    and display it. This time, the data consists of a list of regions, which will
    serve as labels for each slice of the pie chart, and a list of the sales totals
    for each region, which will define the size of each slice. To make the plot a
    pie chart rather than a line graph, you call the `plt.pie()` function, passing
    in `sales` as the data to be plotted and `regions` as the labels for the data.
    You also use the `autopct` parameter to display percent values in the pie slices,
    using Python string formatting to show the values to the nearest tenth of a percent.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本遵循了你用来生成折线图的基本模式：首先定义要绘制的数据，创建图表，定制一些图表的特征，然后显示它。这一次，数据包含了一个地区列表，这将作为每个饼图切片的标签，和一个包含各地区销售总额的列表，这将决定每个切片的大小。为了将图表变为饼图而非折线图，你调用`plt.pie()`函数，将`sales`作为要绘制的数据，`regions`作为数据的标签。你还使用`autopct`参数在饼图的切片上显示百分比值，并使用Python字符串格式化来显示百分比值到小数点后一位。
- en: 'Here you visualize the same input data as a bar graph, like the one in [Figure
    8-3](#figure8-3):'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你将相同的输入数据可视化为柱状图，类似于[图8-3](#figure8-3)中的那张图：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You pass the `regions` list to the `plt.bar()` function as the x-axis labels
    for the bars. The second argument you pass to `plt.bar()` is the list with the
    sales figures corresponding to the items in `regions`. Both here and in the pie
    chart example, you’re able to use separate lists for labels and sales figures
    because the order of elements in a Python list is persistent.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你将`regions`列表传递给`plt.bar()`函数，作为柱状图的x轴标签。你传递给`plt.bar()`的第二个参数是与`regions`中每个项对应的销售数据列表。无论在这里还是在饼图的例子中，你都能使用单独的列表来表示标签和销售数据，因为Python列表中的元素顺序是持久的。
- en: Working with Figure and Axes Objects
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Figure和Axes对象
- en: 'At heart, a Matplotlib visualization is built from two main types of objects:
    a `Figure` object and one or more `Axes` objects. In the previous examples, `matplotlib.pyplot`
    served as an interface for working indirectly with these objects, allowing you
    to customize some elements of a visualization. However, you can exert more control
    over your visualizations by working directly with the `Figure` and `Axes` objects
    themselves.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，一个 Matplotlib 可视化是由两种主要类型的对象构成的：`Figure` 对象和一个或多个 `Axes` 对象。在前面的例子中，`matplotlib.pyplot`
    作为一个接口间接操作这些对象，允许你自定义可视化的一些元素。然而，你可以通过直接操作 `Figure` 和 `Axes` 对象本身，来对可视化进行更精细的控制。
- en: The `Figure` object is the top-level, outermost container for a Matplotlib visualization.
    It can include one or more plots. You work with a `Figure` object when you need
    to do something with the overall visualization, such as resize it or save it to
    a file. Meanwhile, each `Axes` object represents one plot in the figure. You use
    an `Axes` object to customize a plot and define its layout. For example, you can
    set the coordinate system of the plot and mark positions on an axis.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`Figure` 对象是 Matplotlib 可视化的最上层、最外层容器。它可以包含一个或多个子图。当你需要对整体可视化进行操作时，比如调整其大小或保存到文件中，你会使用
    `Figure` 对象。与此同时，每个 `Axes` 对象代表图形中的一个子图。你使用 `Axes` 对象来自定义子图并定义其布局。例如，你可以设置子图的坐标系统，并在坐标轴上标记位置。'
- en: You access the `Figure` and `Axes` objects through the `matplotlib.pyplot.subplots()`
    function. When invoked without arguments, this function returns a `Figure` instance
    and a single `Axes` instance associated with the `Figure`. By adding arguments
    to the `subplots()` function, you can create a `Figure` instance and multiple
    associated `Axes` instances. In other words, you’ll create a figure with multiple
    plots. For example, a call of `subplots(2,2)` creates a figure with four plots,
    arranged in two rows of two. Each plot is represented by one `Axes` object.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过 `matplotlib.pyplot.subplots()` 函数访问 `Figure` 和 `Axes` 对象。当该函数没有参数时，它返回一个
    `Figure` 实例和一个与该 `Figure` 关联的单一 `Axes` 实例。通过向 `subplots()` 函数添加参数，你可以创建一个 `Figure`
    实例和多个关联的 `Axes` 实例。换句话说，你将创建一个包含多个绘图的图形。例如，调用 `subplots(2,2)` 创建一个四个子图的图形，排列为两行两列。每个子图由一个
    `Axes` 对象表示。
- en: Creating a Histogram with subplots()
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 `subplots()` 创建直方图
- en: 'In the following script, you use `subplots()` to create a `Figure` object and
    a single `Axes` object. You then manipulate the objects to produce the histogram
    shown earlier in [Figure 8-5](#figure8-5), displaying the salary distribution
    of a collection of employees. In addition to working with the `Figure` and `Axes`
    objects, you also work with a Matplotlib module called `matplotlib.ticker` to
    format the ticks along the x-axis of the plot as well as with NumPy to define
    a sequence of bins for the histogram in $50 increments:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的脚本中，你使用 `subplots()` 创建一个 `Figure` 对象和一个 `Axes` 对象。然后你操作这些对象来生成先前在 [图 8-5](#figure8-5)
    中显示的直方图，展示一组员工的薪资分布。除了操作 `Figure` 和 `Axes` 对象外，你还会使用一个名为 `matplotlib.ticker` 的
    Matplotlib 模块来格式化子图中 x 轴的刻度，并使用 NumPy 来定义一个以 50 为增量的直方图分箱序列：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You start by defining a `salaries` list with the salary data you want to visualize
    ❶. You then invoke the `subplots()` function without parameters ❷, thus instructing
    it to create a figure containing a single plot. The function returns a tuple containing
    two objects, `fig` and `ax`, representing the figure and the plot, respectively.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先定义一个 `salaries` 列表，包含你想要可视化的薪资数据❶。然后你调用 `subplots()` 函数，且不传递任何参数❷，从而指示该函数创建一个包含单个子图的图形。该函数返回一个元组，包含两个对象，分别是表示图形的
    `fig` 和表示子图的 `ax`。
- en: Now that you have these `Figure` and `Axes` instances, you can begin to customize
    them. To start, you invoke the `set_size_inches()` method of the `Figure` object
    to resize the overall figure ❸. Then you invoke the `hist()` method of the `Axes`
    object to plot a histogram ❹. You pass the method the `salaries` list as the input
    data for the histogram, as well as a NumPy array defining the x-axis points for
    the histogram bins. You generate the array with NumPy’s `arange()` function, which
    produces an array of evenly spaced values within a given interval (in this case,
    increments of `50` between `1100` and `1900`). You use the `hist()` method’s `edgecolor`
    parameter to draw black line boundaries for the bins and the `linewidth` parameter
    to define the width of those boundaries.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经拥有了这些 `Figure` 和 `Axes` 实例，你可以开始自定义它们了。首先，你调用 `Figure` 对象的 `set_size_inches()`
    方法来调整整个图形的大小 ❸。然后，你调用 `Axes` 对象的 `hist()` 方法来绘制直方图 ❹。你将 `salaries` 列表作为直方图的输入数据传递给该方法，并使用
    NumPy 数组定义直方图箱子的 x 轴点。你通过 NumPy 的 `arange()` 函数生成这个数组，它会在给定区间内生成一个均匀分布的数值数组（在这种情况下是
    `1100` 到 `1900` 之间每 `50` 为递增值）。你使用 `hist()` 方法的 `edgecolor` 参数来绘制箱子的黑色边界线，并使用
    `linewidth` 参数定义这些边界的宽度。
- en: Next, you use the `FormatStrFormatter()` function from the `matplotlib.ticker`
    module to create a formatter that will prepend a dollar sign to each x-axis label
    ❺. You apply the formatter to the x-axis labels using the `set_major_formatter()`
    method of the `ax.xaxis` object ❻. Finally, you set the general aspects of the
    plot, such as its title and main axis labels, via the `matplotlib.pyplot` interface
    ❼ and display the plot.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你使用 `matplotlib.ticker` 模块中的 `FormatStrFormatter()` 函数创建一个格式化器，用于在每个 x 轴标签前加上美元符号
    ❺。你通过 `ax.xaxis` 对象的 `set_major_formatter()` 方法将格式化器应用到 x 轴标签 ❻。最后，你通过 `matplotlib.pyplot`
    接口 ❼ 设置图表的总体属性，如标题和主坐标轴标签，并显示图表。
- en: Showing Frequency Distributions on a Pie Chart
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在饼图上显示频率分布
- en: While histograms are well suited for visualizing frequency distributions, you
    can also use a pie chart to convey frequency distributions as percentages. As
    an example, this section shows how to transform the salary distribution histogram
    you just created into a pie chart displaying how the salaries are distributed
    as parts of a whole.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然直方图非常适合用于可视化频率分布，但你也可以使用饼图来传达频率分布的百分比。例如，本节展示了如何将你刚刚创建的薪资分布直方图转化为一个饼图，显示薪资如何作为整体的一部分进行分布。
- en: 'Before you can create such a pie chart, you need to extract and organize some
    key information from the histogram. In particular, you need to learn the number
    of salaries in each $50 range. You can use NumPy’s `histogram()` function for
    this; it computes a histogram without displaying it:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在你创建这样的饼图之前，你需要从直方图中提取并组织一些关键信息。特别是，你需要了解每个 $50 区间内的薪资数量。你可以使用 NumPy 的 `histogram()`
    函数来实现这一点；它会计算一个直方图，但不显示它：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here, you call the `histogram()` function, passing it the same `salaries` list
    you created earlier and again using NumPy’s `arange()` function to generate evenly
    spaced bins. Calling `histogram()` returns two NumPy arrays: `count` and `labels`.
    The `count` array represents the number of employees with salaries in each interval
    and looks as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你调用了 `histogram()` 函数，将之前创建的相同的 `salaries` 列表传递给它，并再次使用 NumPy 的 `arange()`
    函数生成均匀分布的箱子。调用 `histogram()` 会返回两个 NumPy 数组：`count` 和 `labels`。`count` 数组表示每个区间内具有相应薪资的员工数量，具体如下：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Meanwhile, the `labels` array contains the edges of the bin intervals:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，`labels` 数组包含了箱间隔的边缘：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next you need to combine neighboring elements of the `labels` array, turning
    them into the labels for the slices of the pie chart. For example, neighboring
    elements `1100` and `1150` should become a single label formatted as `''$1100-1150''`.
    Use the following list comprehension:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要将 `labels` 数组中的相邻元素组合起来，将它们变成饼图切片的标签。例如，相邻的元素 `1100` 和 `1150` 应该合并为一个标签，格式为
    `'$1100-1150'`。可以使用以下列表推导式：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As a result, the `labels` list will look as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`labels` 列表将如下所示：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Each element in `labels` corresponds to the element in the `count` array with
    the same index. Looking back at the `count` array, however, you may notice a problem:
    the count for some intervals is `0`, and you wouldn’t want to include these empty
    intervals to the pie chart. To exclude them, you need to generate a list of the
    indices corresponding to nonempty intervals in the `count` array:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`labels` 中的每个元素对应 `count` 数组中相同索引位置的元素。然而，回顾 `count` 数组，你可能会注意到一个问题：某些区间的计数为
    `0`，你不希望将这些空区间包含到饼图中。为了排除这些空区间，你需要生成一个列表，列出 `count` 数组中非空区间对应的索引：'
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now you can use `non_zero_pos` to filter `count` and `labels`, excluding those
    elements that represent empty intervals:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以使用 `non_zero_pos` 来过滤 `count` 和 `labels`，排除那些代表空区间的元素：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now all that remains is to create and display the pie chart using the `matplotlib.pyplot`
    interface and `plt.pie()`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下的就是使用 `matplotlib.pyplot` 接口和 `plt.pie()` 创建并显示饼图：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[Figure 8-7](#figure8-7) shows the result.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8-7](#figure8-7) 显示了结果。'
- en: The pie chart visualizes the same data as the histogram in [Figure 8-5](#figure8-5),
    but it shows each bin as a percentage of the whole instead of indicating exactly
    how many employees have salaries that fall within that bin.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 该饼图展示了与 [图 8-5](#figure8-5) 中直方图相同的数据，但它显示的是每个区间占总体的百分比，而不是精确地表示有多少员工的薪资落在该区间内。
- en: '![A pie chart with slices showing the percentage of people with salaries in
    each $50 increment between $1,200 and $1,750\. A few slices are quite thin.](image_fi/502208c08/f08007.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![一个饼图，展示了在 $1,200 到 $1,750 之间每增加 $50 的薪资区间内的人群百分比。有几块区域相当薄。](image_fi/502208c08/f08007.png)'
- en: 'Figure 8-7: A pie chart visualizing a frequency distribution'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-7：一个可视化频率分布的饼图
- en: Using Other Libraries with Matplotlib
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用其他库与 Matplotlib 配合
- en: Matplotlib can easily interface with other Python libraries to plot data from
    different sources or create other kinds of visualizations. For example, you can
    use Matplotlib in conjunction with pandas to plot the data from a DataFrame, or
    you can create maps by combining Matplotlib with Cartopy, a library that specializes
    in handling geospatial data.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib 可以轻松地与其他 Python 库进行接口对接，从不同来源绘制数据或创建其他类型的可视化。例如，你可以将 Matplotlib 与
    pandas 配合使用，绘制来自 DataFrame 的数据，或者通过将 Matplotlib 与 Cartopy（一个专门处理地理空间数据的库）结合使用来创建地图。
- en: Plotting pandas Data
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绘制 pandas 数据图
- en: 'The pandas library is closely integrated with Matplotlib. In fact, every pandas
    Series or DataFrame has a `plot()` method, which is actually a wrapper around
    the `matplotlib.pyplot.plot()` method. It allows you to directly convert a pandas
    data structure into a Matplotlib plot. To demonstrate, you’ll create a bar chart
    from a DataFrame with population data for US cities. You’ll use raw data from
    the *us-cities-top-1k.csv* file available at [https://github.com/plotly/datasets](https://github.com/plotly/datasets).
    The bar chart will show the number of megacities (those with a population of 1,000,000
    or greater) in each US state. Here’s how to do it:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: pandas 库与 Matplotlib 紧密集成。实际上，每个 pandas 的 Series 或 DataFrame 都有一个 `plot()` 方法，它实际上是
    `matplotlib.pyplot.plot()` 方法的一个封装。它允许你直接将 pandas 数据结构转换为 Matplotlib 图表。为了演示，你将使用美国城市的人口数据创建一个条形图。你将使用来自
    *us-cities-top-1k.csv* 文件的原始数据，文件可以在 [https://github.com/plotly/datasets](https://github.com/plotly/datasets)
    获取。这个条形图将展示每个美国州的百万级大城市（人口达到或超过 1,000,000）的数量。操作步骤如下：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You first load the dataset into a DataFrame using the pandas `read_csv()` method
    ❶. The dataset contains the population, latitude, and longitude of the 1,000 largest
    US cities. To filter the dataset to just megacities, you use the DataFrame’s `ge()`
    method, short for *greater than or equal to*, asking only for rows whose `Population`
    field is greater than or equal to `1000000` ❷. Then you group the data by the
    `State` column and apply the `count()` aggregate function to find the total number
    of megacities per state ❸. During the `groupby` operation, you set `as_index`
    to `False` to avoid converting the `State` column into the index of the resulting
    DataFrame. This is because you’ll need to refer to the `State` column later in
    the script. You rename the `City` column to `cities_count` to reflect that it
    now holds aggregate information and include only the `State` and `cities_count`
    columns in the resulting `top_cities_count` DataFrame.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你通过 pandas 的 `read_csv()` 方法将数据集加载到 DataFrame 中 ❶。该数据集包含了美国1,000个最大城市的人口、纬度和经度。为了将数据集筛选为仅包含特大城市，你使用
    DataFrame 的 `ge()` 方法，`ge()` 是 *greater than or equal to*（大于或等于）的缩写，要求仅返回 `Population`
    字段大于或等于 `1000000` 的行 ❷。然后，你按 `State` 列对数据进行分组，并应用 `count()` 聚合函数，计算每个州的特大城市数量
    ❸。在 `groupby` 操作中，你将 `as_index` 设置为 `False`，以避免将 `State` 列转换为结果 DataFrame 的索引。这是因为稍后你还需要在脚本中引用
    `State` 列。你将 `City` 列重命名为 `cities_count`，以反映它现在包含了汇总信息，并且只保留 `State` 和 `cities_count`
    列，生成新的 `top_cities_count` DataFrame。
- en: Next, you draw a bar chart with the DataFrame’s `plot.bar()` method ❹. Remember,
    `plot()` is actually a wrapper for Matplotlib’s `pyplot.plot()` method. In this
    call, you specify the DataFrame column names that will be used as the x- and y-axes
    of the plot, and you rotate the x-axis tick labels to 0 degrees. Having created
    the figure, you’re then able to customize it with the `matplotlib.pyplot` interface,
    as you’ve done in earlier examples. You set the axis labels and the figure title
    ❺, and you use `plt.yticks()` to set number labels for the y-axis to reflect the
    top cities count ❻. Finally, you display the figure with `plt.show()`. [Figure
    8-8](#figure8-8) shows the result.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你使用 DataFrame 的 `plot.bar()` 方法绘制一个条形图 ❹。记住，`plot()` 实际上是 Matplotlib 的 `pyplot.plot()`
    方法的一个封装。在这次调用中，你指定了将用作图表 x 轴和 y 轴的 DataFrame 列名，并将 x 轴的刻度标签旋转为 0 度。创建图形后，你可以像前面的示例中那样，使用
    `matplotlib.pyplot` 接口来定制图形。你设置了坐标轴标签和图形标题 ❺，并使用 `plt.yticks()` 设置 y 轴的数字标签，以反映特大城市的数量
    ❻。最后，你通过 `plt.show()` 显示图形。[图 8-8](#figure8-8) 显示了结果。
- en: '![A bar chart with vertical bars showing the number of megacities in the states
    of Arizona, California, Illinois, New York, Pennsylvania, and Texas.](image_fi/502208c08/f08008.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![一个条形图，显示了亚利桑那州、加利福尼亚州、伊利诺伊州、纽约州、宾夕法尼亚州和德克萨斯州的特大城市数量。](image_fi/502208c08/f08008.png)'
- en: 'Figure 8-8: A bar chart generated from a pandas DataFrame'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-8：从 pandas DataFrame 生成的条形图
- en: As you can see, the figure has the same general appearance as the others you’ve
    created in this chapter, particularly the bar chart in [Figure 8-3](#figure8-3).
    This is not surprising, since it was generated by the same Matplotlib library,
    which pandas uses behind the scenes.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，图形的外观与本章中你创建的其他图形非常相似，尤其是 [图 8-3](#figure8-3) 中的条形图。这并不令人惊讶，因为它是由同一个 Matplotlib
    库生成的，而 pandas 在幕后也使用了这个库。
- en: Plotting Geospatial Data with Cartopy
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Cartopy 绘制地理空间数据
- en: Cartopy is a Python library for creating geospatial visualizations, or maps.
    It includes the `matplotlib.pyplot` programmatic interface, which makes drawing
    maps easy. Essentially, drawing a map with Cartopy becomes a matter of creating
    a Matplotlib figure with longitude coordinates plotted along the x-axis and latitude
    coordinates plotted along the y-axis. Cartopy handles the complexity of translating
    Earth’s spherical shape into the 2D plane of the plot. To demonstrate, you’ll
    use the *us-cities-top-1k.csv* dataset introduced in the previous section to draw
    outline maps of Southern California showing the locations of various cities. But
    first you need to set up Cartopy.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Cartopy 是一个用于创建地理空间可视化（或地图）的 Python 库。它包含了 `matplotlib.pyplot` 的编程接口，使得绘制地图变得简单。基本上，使用
    Cartopy 绘制地图就是创建一个 Matplotlib 图形，其中经度坐标沿 x 轴绘制，纬度坐标沿 y 轴绘制。Cartopy 处理将地球的球形转化为绘图二维平面的复杂性。为了演示，你将使用前一节介绍的
    *us-cities-top-1k.csv* 数据集，绘制显示南加州各城市位置的轮廓图。但首先，你需要设置 Cartopy。
- en: Using Cartopy in Google Colab
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在 Google Colab 中使用 Cartopy
- en: Installing Cartopy can be tricky, and the process varies depending on your system.
    Therefore, this section shows how to use Cartopy through the Google Colab web
    IDE, which allows you to write and execute Python code through your browser.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Cartopy 可能会有些棘手，且过程因系统而异。因此，本节将展示如何通过 Google Colab Web IDE 使用 Cartopy，该 IDE
    允许您通过浏览器编写和执行 Python 代码。
- en: To load Colab, go to [https://colab.research.google.com](https://colab.research.google.com).
    Then click **New** **N****otebook** to start a new Colab notebook, where you can
    create, populate, and run an arbitrary number of code cells. In each code cell,
    you can group one or more lines of Python code together and execute them with
    a click of the run button in the top-left corner of the cell. Colab remembers
    the execution state built by any previously executed cells, similar to a Python
    interpreter session. You create new code cells with the +Code button in the upper-left
    corner of the Colab window.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要加载 Colab，请访问 [https://colab.research.google.com](https://colab.research.google.com)。然后点击**新建**
    **笔记本**以启动一个新的 Colab 笔记本，您可以在其中创建、填充并运行任意数量的代码单元。在每个代码单元中，您可以将一行或多行 Python 代码组合在一起，并通过点击单元格左上角的运行按钮执行它们。Colab
    会记住任何先前执行的单元所建立的执行状态，类似于 Python 解释器会话。您可以通过点击 Colab 窗口左上角的 +Code 按钮来创建新的代码单元。
- en: 'In the first code cell, enter and run the following command to install Cartopy
    within your Colab notebook:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个代码单元中，输入并运行以下命令，以在 Colab 笔记本中安装 Cartopy：
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Once Cartopy installs, you can proceed to the examples in the next section,
    running each separate listing as its own code cell.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了 Cartopy，您可以继续查看下一节的示例，将每个独立的代码列表示为单独的代码单元执行。
- en: Creating Maps
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建地图
- en: 'In this section, you’ll use Cartopy to create two maps of Southern California.
    First you’ll draw a map showing all the Southern California cities included in
    the *us-cities-top-1k.csv* dataset. You start by importing all the required modules:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，您将使用 Cartopy 创建两张南加州的地图。首先，您将绘制一张显示 *us-cities-top-1k.csv* 数据集中所有南加州城市的地图。您从导入所有所需模块开始：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You’ll need pandas, the `matplotlib.pyplot` interface, and a few different
    Cartopy modules: `cartopy.crs` to generate maps and `LongitudeFormatter` and `LatitudeFormatter`
    to format the tick labels properly. The `%matplotlib inline` command is required
    to include Matplotlib figures in a Google Colab notebook, next to the code.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 您将需要 pandas、`matplotlib.pyplot` 接口，以及一些不同的 Cartopy 模块：`cartopy.crs` 用于生成地图，`LongitudeFormatter`
    和 `LatitudeFormatter` 用于正确格式化刻度标签。`%matplotlib inline` 命令是必需的，以便将 Matplotlib 图形嵌入到
    Google Colab 笔记本中，显示在代码旁边。
- en: 'Next, you load the required data and draw the map:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，您加载所需的数据并绘制地图：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You load the *us-cities-top-1k.csv* dataset into a DataFrame ❶, as you did in
    the previous section. Remember, it contains geospatial data in the form of latitude
    and longitude coordinates, as well as population data. You then filter the data
    to include only California cities using the DataFrame’s `eq()` method ❷, short
    for *equal to*.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 您将 *us-cities-top-1k.csv* 数据集加载到 DataFrame 中 ❶，就像在上一节中做的那样。请记住，它包含以经纬度坐标形式表示的地理空间数据，以及人口数据。接着，您使用
    DataFrame 的 `eq()` 方法 ❷（即 *等于* 的简写）来筛选数据，仅保留加利福尼亚州的城市。
- en: Since drawing a map requires more customization than the `matplotlib.pyplot`
    interface will allow, you need to work directly with the visualization’s underlying
    Matplotlib objects. You therefore call the `plt.subplots()` function to obtain
    a `Figure` object and a single `Axes` object, setting the figure size in the process
    ❸. You then call `plt.axes()` to overwrite the `Axes` object, turning it into
    a Cartopy map ❹. You do this by telling Matplotlib to use Cartopy’s Mercator projection
    when plotting coordinates on the flat surface of the figure. The Mercator projection
    is a standard mapmaking technique that converts Earth from a sphere to a cylinder,
    then unrolls that cylinder into a rectangle.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 由于绘制地图需要比 `matplotlib.pyplot` 接口更多的定制化，因此您需要直接操作可视化的底层 Matplotlib 对象。因此，您调用
    `plt.subplots()` 函数来获取一个 `Figure` 对象和一个单独的 `Axes` 对象，同时设置图形大小 ❸。接着，您调用 `plt.axes()`
    来覆盖 `Axes` 对象，将其转变为一个 Cartopy 地图 ❹。您通过告诉 Matplotlib 在绘制坐标时使用 Cartopy 的墨卡托投影法，来实现这一点。墨卡托投影是一种标准的制图技术，它将地球从球体转换为圆柱形，然后将圆柱展开成一个矩形。
- en: Next you call `ax.coastlines()` to show the outlines of landmasses on the map
    ❺. The coastal outlines are added to the current `Axes` object from the Natural
    Earth *coastline* shapefile collection. By specifying `10m`, you draw the coastlines
    at a scale of 1 to 10 million; that is, 1 centimeter on the map is equivalent
    to 100 kilometers in real life.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您调用`ax.coastlines()`来显示地图上的陆地轮廓 ❺。海岸线是从Natural Earth的*海岸线*形状文件集合中添加到当前的`Axes`对象中的。通过指定`10m`，您以1比1000万的比例绘制海岸线；也就是说，地图上的1厘米相当于现实中的100公里。
- en: To define what the ticks along the y- and x-axes will be, you use the `set_yticks()`
    and `set_xticks()` methods, passing a list of latitudes and longitudes, respectively
    ❻. Specifically, you pass `32` through `36` as the y ticks and `-121` to `-115`
    as the x ticks (that is, 32°N to 36°N and 121°W to 115°W), since these latitudes
    and longitudes cover the area of Southern California. In both cases, you add `crs=ccrs.PlateCarree()`
    to specify how the latitude and longitude information should be projected onto
    a flat plane. Like the Mercator projection, Plate Carrée treats Earth as a cylinder
    that’s been flattened into a rectangle.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义y轴和x轴上的刻度，您使用`set_yticks()`和`set_xticks()`方法，分别传递纬度和经度的列表 ❻。具体来说，您将`32`到`36`作为y刻度，将`-121`到`-115`作为x刻度（即32°N到36°N和121°W到115°W），因为这些纬度和经度覆盖了南加州的区域。在这两种情况下，您都添加了`crs=ccrs.PlateCarree()`来指定如何将纬度和经度信息投影到平面上。像墨卡托投影一样，Plate
    Carrée将地球视为一个圆柱体，并将其展平为矩形。
- en: Next, you create formatters using Cartopy’s `LongitudeFormatter()` and `LatitudeFormatter()`
    objects and apply them to the x- and y-axes ❼. Using these formatters ensures
    the longitude and latitude values will be shown with degree signs and a *W* or
    *N* for *west* or *north*, respectively. You also set the extent for the plot,
    specifying appropriate longitudes and latitudes to limit the map to showing only
    Southern California ❽. Then you extract two pandas Series objects from your DataFrame,
    `X` and `Y`, for the longitude and latitude values, respectively. Finally, you
    draw the map with Matplotlib’s `scatter()` method ❾, passing the data to plot
    on the x- and y-axes along with instructions to display the cities as red dots.
    [Figure 8-9](#figure8-9) shows the result.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您使用Cartopy的`LongitudeFormatter()`和`LatitudeFormatter()`对象创建格式化器，并将它们应用于x轴和y轴
    ❼。使用这些格式化器可以确保经度和纬度值显示带有度数符号，并且分别带有表示*西*或*北*的*W*或*N*。您还设置了绘图的范围，指定了适当的经纬度，以限制地图仅显示南加州
    ❽。然后，您从DataFrame中提取两个pandas Series对象，分别为表示经度和纬度值的`X`和`Y`。最后，您使用Matplotlib的`scatter()`方法绘制地图
    ❾，将数据传递到x轴和y轴上，并指示将城市作为红点显示。[图8-9](#figure8-9)显示了结果。
- en: '![A map of Southern California with dots indicating cities. Latitude and longitude
    coordinates are labeled along the left and bottom sides of the map.](image_fi/502208c08/f08009.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![一张显示南加州城市的地图，地图上标记了城市的位置，地图的左侧和底部标注了纬度和经度坐标。](image_fi/502208c08/f08009.png)'
- en: 'Figure 8-9: An outline map of Southern California with cities'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-9：标注了城市的南加州轮廓地图
- en: 'The map provides a clear illustration of areas with a high population density.
    But what if you want to see only the largest cities marked with their names? Here’s
    how you can do this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这张地图清晰地展示了人口密度较高的区域。但是，如果您只想看到标注了城市名称的最大城市，应该怎么做呢？以下是您可以这样做的方法：
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You filter the `calif_cities` DataFrame generated in the previous listing to
    only include those cities with populations of 400,000 or more ❶. Then you generate
    the plot by following the same process as before, with some extra steps for adding
    city labels. You store the city names in a pandas Series called `cities` ❷, then
    you iterate over the city names, assigning them as centered labels over the points
    on the map with Matplotlib’s `plt.text()` method ❸. You specify `transform=ccrs.Geodetic()`
    to make Matplotlib use Cartopy’s Geodetic coordinate system when adding the labels.
    This system treats Earth as a sphere and specifies coordinates as latitude and
    longitude values. [Figure 8-10](#figure8-10) shows the result.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 您过滤了在前一部分生成的`calif_cities` DataFrame，仅包括人口超过40万的城市 ❶。然后，您按照之前的相同步骤生成图表，并添加一些额外的步骤来添加城市标签。您将城市名称存储在一个名为`cities`的pandas
    Series中 ❷，然后遍历城市名称，使用Matplotlib的`plt.text()`方法将其作为中心标签添加到地图上的点上 ❸。您指定`transform=ccrs.Geodetic()`以使Matplotlib在添加标签时使用Cartopy的Geodetic坐标系统。该系统将地球视为一个球体，并将坐标指定为纬度和经度值。[图8-10](#figure8-10)显示了结果。
- en: '![A map showing the same area as the previous figure. Three dots with text
    labels show the cities of Los Angeles, Long Beach, and San Diego.](image_fi/502208c08/f08010.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![一张地图，显示与前一图相同的区域。三个带有文本标签的点标示了洛杉矶、长滩和圣地亚哥这三座城市。](image_fi/502208c08/f08010.png)'
- en: 'Figure 8-10: The largest cities in Southern California'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-10：加利福尼亚南部最大的城市
- en: The map now shows the locations and names of the three cities in Southern California
    with populations over 400,000.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这张地图展示了加利福尼亚南部三座人口超过40万的城市的位置和名称。
- en: Summary
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: As you’ve seen, data visualizations are a powerful tool for discovering trends
    and gaining insights from your data. For example, a line graph immediately reveals
    trends in a stock price, while a map can clearly illustrate areas of high population
    density. In this chapter, you learned how to create common visualizations like
    line graphs, bar graphs, pie charts, and histograms using the Matplotlib library.
    You saw how to build simple yet powerful visualizations with the `matplotlib.pyplot`
    interface and how to exert more control over the result by directly manipulating
    a visualization’s underlying `Figure` and `Axes` objects. You also learned how
    to use Matplotlib alongside pandas to visualize DataFrame data, and you practiced
    creating maps with Matplotlib and the Cartopy geospatial data processing library.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，数据可视化是发现趋势和从数据中获得洞察的强大工具。例如，折线图能立即揭示股价的趋势，而地图则能清晰地展示人口密度较高的区域。在本章中，你学习了如何使用Matplotlib库创建常见的可视化图表，如折线图、柱状图、饼图和直方图。你了解了如何通过`matplotlib.pyplot`接口构建简单但强大的可视化图表，并通过直接操作可视化的底层`Figure`和`Axes`对象，获得更高的控制能力。你还学习了如何将Matplotlib与pandas配合使用，来可视化DataFrame数据，并且练习了使用Matplotlib和Cartopy地理空间数据处理库创建地图。
