- en: '**12**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**12**'
- en: '**MANAGING RELATIONAL DATABASES**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**管理关系型数据库**'
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: Applications will almost always have to store data of some kind, and developers
    will often combine a relational database management system (RDBMS) with some type
    of object relational mapping tool (ORM). RDBMSs and ORMs can be tricky and are
    not a favorite topic for many developers, but sooner or later, they must be addressed.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序几乎总是需要存储某种类型的数据，开发者通常会将关系型数据库管理系统（RDBMS）与某种类型的对象关系映射工具（ORM）结合使用。RDBMS和ORM可能会比较棘手，许多开发者对此话题并不感兴趣，但迟早必须处理这些问题。
- en: '**RDBMSs, ORMs, and When to Use Them**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**RDBMS、ORM及何时使用它们**'
- en: An RDBMS is the database that stores an application’s relational data. Developers
    will use a language like SQL (Structured Query Language) to deal with the relational
    algebra, meaning that a language like this handles the data management and the
    relationships between the data. Used together, they allow you to both store data
    and query that data to get specific information as efficiently as possible. Having
    a good understanding of relational database structures, such as how to use proper
    normalization or the different types of serializability, might keep you from falling
    into many traps. Obviously, such subjects deserve an entire book and won’t be
    covered in their entirety in this chapter; instead, we’ll focus on using the database
    via its usual programming language, SQL.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: RDBMS是存储应用程序关系数据的数据库。开发者将使用类似SQL（结构化查询语言）这样的语言来处理关系代数，也就是说，这类语言负责数据管理及数据之间的关系。它们配合使用，可以让你既存储数据，又能高效查询这些数据以获取特定的信息。深入理解关系数据库结构，比如如何正确使用规范化或不同类型的可序列化，可能会帮助你避免许多陷阱。显然，这些主题值得一本书来详细探讨，本章不会涵盖所有内容，而是集中讲解如何通过其常用编程语言SQL来使用数据库。
- en: Developers may not want to invest in learning a whole new programming language
    to interact with the RDBMS. If so, they tend to avoid writing SQL queries entirely,
    relying instead on a library to do the work for them. ORM libraries are commonly
    found in programming language ecosystems, and Python is no exception.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者可能不想花时间学习一门全新的编程语言来与RDBMS交互。如果是这样，他们往往会完全避免编写SQL查询，而是依赖于某个库来为他们完成这项工作。ORM库通常可以在编程语言生态系统中找到，Python也不例外。
- en: 'The purpose of an ORM is to make database systems easier to access by abstracting
    the process of creating queries: it generates the SQL so you don’t have to. Unfortunately,
    this abstraction layer can prevent you from performing more specific or low-level
    tasks that the ORM is simply not capable of doing, such as writing complex queries.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: ORM的目的是通过抽象创建查询的过程，使数据库系统更加易于访问：它会生成SQL，因此你不需要手动编写。不幸的是，这一抽象层可能会妨碍你执行一些更具体或更底层的任务，这些任务ORM根本无法完成，比如编写复杂的查询。
- en: 'There is also a particular set of difficulties with using ORMs in object-oriented
    programs that are so common, they are known collectively as the *object-relational
    impedance mismatch.* This impedance mismatch occurs because relational databases
    and object-oriented programs have different representations of data that don’t
    map properly to one another: mapping SQL tables to Python classes won’t give you
    optimal results, no matter what you do.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ORM时，在面向对象程序中有一组特定的难题，它们普遍存在，以至于被统称为*对象关系阻抗不匹配*。这种阻抗不匹配的出现，是因为关系型数据库和面向对象程序在数据表示上有所不同，导致无法正确映射：无论你怎么做，将SQL表映射到Python类，都无法得到最佳结果。
- en: Understanding SQL and RDBMSs will allow you to write your own queries, without
    having to rely on the abstraction layer for everything.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 理解SQL和RDBMS将使你能够编写自己的查询，而无需完全依赖抽象层来处理所有事情。
- en: 'But that’s not to say you should avoid ORMs entirely. ORM libraries can help
    with rapid prototyping of your application model, and some libraries even provide
    useful tools such as schema upgrades and downgrades. It’s important to understand
    that using an ORM is not a substitute for gaining a real understanding of RDBMSs:
    many developers try to solve problems in the language of their choice rather than
    using their model API, and the solutions they come up with are inelegant at best.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 但这并不是说你应该完全避免使用ORM。ORM库在快速原型化应用模型时非常有用，有些库甚至提供了像模式升级和降级这样的有用工具。需要理解的是，使用ORM并不能代替真正理解RDBMS的过程：许多开发者试图用他们选择的语言解决问题，而不是使用其模型API，结果得出的解决方案充其量只是勉强应付。
- en: '**NOTE**'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*This chapter assumes you know basic SQL. Introducing SQL queries and discussing
    how tables work is beyond the scope of this book. If you’re new to SQL, I recommend
    learning the basics before continuing. Practical SQL by Anthony DeBarros (No Starch
    Press, 2018) is a good place to start.*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章假设你已经了解基本的SQL。介绍SQL查询和讨论表格如何工作的内容超出了本书的范围。如果你是SQL新手，建议在继续之前先学习基本知识。Anthony
    DeBarros的《Practical SQL》（No Starch Press, 2018）是一个不错的入门选择。*'
- en: 'Let’s look at an example that demonstrates why understanding RDBMSs can help
    you write better code. Say you have a SQL table for keeping track of messages.
    This table has a single column named id representing the ID of the message sender,
    which is the primary key, and a string containing the content of the message,
    like so:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个示例，演示为什么理解RDBMS（关系数据库管理系统）有助于你编写更好的代码。假设你有一个SQL表格用于跟踪消息。这个表格有一个名为id的单列，表示消息发送者的ID，这是主键，还有一个包含消息内容的字符串，如下所示：
- en: CREATE TABLE message (
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: CREATE TABLE message (
- en: id serial PRIMARY KEY,
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: id serial PRIMARY KEY,
- en: content text
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: content text
- en: );
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: We want to detect any duplicate messages received and exclude them from the
    database. To do this, a typical developer might write SQL using an ORM, as shown
    in [Listing 12-1](ch12.xhtml#ch12list1).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望检测到任何重复的消息并将其排除在数据库之外。为此，一个典型的开发者可能会使用ORM编写SQL，如[清单12-1](ch12.xhtml#ch12list1)所示。
- en: 'if query.select(Message).filter(Message.id == some_id):'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 'if query.select(Message).filter(Message.id == some_id):'
- en: '# We already have the message, it''s a duplicate, ignore and raise'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '# 我们已经有这条消息，它是重复的，忽略并抛出'
- en: raise DuplicateMessage(message)
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: raise DuplicateMessage(message)
- en: 'else:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: '# Insert the message'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '# 插入消息'
- en: query.insert(message)
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: query.insert(message)
- en: '*Listing 12-1: Detecting and excluding duplicate messages with an ORM*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单12-1：使用ORM检测并排除重复消息*'
- en: 'This code works for most cases, but it has some major drawbacks:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码适用于大多数情况，但它有一些主要缺点：
- en: 'The duplicate constraint is already expressed in the SQL schema, so there is
    a sort of code duplication: using PRIMARY KEY implicitly defines the uniqueness
    of the id field.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复约束已经在SQL模式中表达，因此存在某种代码重复：使用PRIMARY KEY隐式定义了id字段的唯一性。
- en: 'If the message is not yet in the database, this code executes two SQL queries:
    a SELECT statement and then an INSERT statement. Executing a SQL query might take
    a long time and require a round-trip to the SQL server, introducing extraneous
    delay.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果消息尚未存入数据库，这段代码会执行两个SQL查询：首先是一个SELECT语句，然后是一个INSERT语句。执行SQL查询可能需要较长时间，并且需要与SQL服务器来回交互，从而引入额外的延迟。
- en: The code doesn’t account for the possibility that someone else might insert
    a duplicate message after we call select_by_id() but before we call insert(),
    which would cause the program to raise an exception. This vulnerability is called
    a *race condition*.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这段代码没有考虑到可能会有其他人在我们调用select_by_id()后，但在我们调用insert()之前插入一条重复消息，这将导致程序抛出异常。这种漏洞被称为*竞态条件*。
- en: 'There’s a much better way to write this code, but it requires cooperation with
    the RDBMS server. Rather than checking for the message’s existence and then inserting
    it, we can insert it right away and use a try...except block to catch a duplicate
    conflict:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一种更好的方法来编写这段代码，但它需要与RDBMS服务器合作。我们可以直接插入消息，并使用try...except块来捕获重复冲突，而不是先检查消息是否存在再插入：
- en: 'try:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 'try:'
- en: '# Insert the message'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '# 插入消息'
- en: message_table.insert(message)
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: message_table.insert(message)
- en: 'except UniqueViolationError:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 'except UniqueViolationError:'
- en: '# Duplicate'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '# 重复'
- en: raise DuplicateMessage(message)
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: raise DuplicateMessage(message)
- en: In this case, inserting the message directly into the table works flawlessly
    if the message is not already present. If it is, the ORM raises an exception indicating
    the violation of the uniqueness constraint. This method achieves the same effect
    as [Listing 12-1](ch12.xhtml#ch12list1) but in a more efficient fashion and without
    any race condition. This is a very simple pattern, and it doesn’t conflict with
    any ORM in any way. The problem is that developers tend to treat SQL databases
    as dumb storage rather than as a tool they can use to get proper data integrity
    and consistency; consequently, they may duplicate the constraints written in SQL
    in their controller code rather than in their model.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果消息尚未存在，直接将其插入表格可以完美运行。如果已经存在，ORM会抛出一个异常，表示违反了唯一性约束。这种方法实现了与[清单12-1](ch12.xhtml#ch12list1)相同的效果，但更加高效，并且没有任何竞态条件。这是一个非常简单的模式，并且与任何ORM都不会发生冲突。问题在于，开发者倾向于把SQL数据库当作傻瓜存储，而不是当作他们可以用来实现数据完整性和一致性的工具；因此，他们可能会在控制器代码中重复编写SQL中已经存在的约束，而不是在模型中编写。
- en: Treating your SQL backend as a model API is good way to make efficient use of
    it. You can manipulate the data stored in your RDBMS with simple function calls
    programmed in its own procedural language.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 将 SQL 后端视为模型 API 是有效利用它的好方法。你可以通过在其自身的过程语言中编写简单的函数调用来操作存储在 RDBMS 中的数据。
- en: '**Database Backends**'
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**数据库后端**'
- en: ORM supports multiple database backends. No ORM library provides a complete
    abstraction of all RDBMS features, and simplifying the code to the most basic
    RDBMS available will make using any advanced RDBMS functions impossible without
    breaking the abstraction layer. Even simple things that aren’t standardized in
    SQL, such as handling timestamp operations, are a pain to deal with when using
    an ORM. This is even more true if your code is RDBMS agnostic. It is important
    to keep this in mind when you choose your application’s RDBMS.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ORM 支持多种数据库后端。没有任何 ORM 库能够完全抽象所有关系型数据库管理系统（RDBMS）的特性，将代码简化到最基本的 RDBMS 会使得无法使用任何高级
    RDBMS 功能，且不破坏抽象层。即使是 SQL 中没有标准化的简单操作，如处理时间戳操作，使用 ORM 时也会很麻烦。如果你的代码与特定的 RDBMS 无关，那么这一点尤为明显。选择应用程序的
    RDBMS 时，务必牢记这一点。
- en: Isolating ORM libraries (as described in “[External Libraries](ch02.xhtml#lev1sec10)”
    on [page 22](ch02.xhtml#page_22)) helps mitigate potential problems. This approach
    allows you to easily swap your ORM library for a different one should the need
    arise and to optimize your SQL usage by identifying places with inefficient query
    usage, which lets you bypass most of the ORM boilerplate.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 隔离 ORM 库（如在 “[外部库](ch02.xhtml#lev1sec10)” 中描述的 [第 22 页](ch02.xhtml#page_22)）有助于缓解潜在问题。这种方法使你可以轻松地在需要时将
    ORM 库替换为其他库，并通过识别查询效率低的地方来优化 SQL 使用，从而绕过大部分 ORM 样板代码。
- en: For example, you can use your ORM in a module of your application, such as myapp.storage,
    to easily build in such isolation. This module should export only functions and
    methods that allow you to manipulate the data at a high level of abstraction.
    The ORM should be used only from that module. At any point, you will be able to
    drop in any module providing the same API to replace myapp.storage.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以在应用程序的某个模块中使用 ORM，比如 myapp.storage，从而轻松实现这种隔离。这个模块应该只导出允许你在高级抽象层次上操作数据的函数和方法。ORM
    应该仅从该模块中使用。任何时候，你都能通过提供相同 API 的任何模块来替换 myapp.storage。
- en: The most commonly used ORM library in Python (and arguably the de facto standard)
    is sqlalchemy. This library supports a huge number of backends and provides abstraction
    for most common operations. Schema upgrades can be handled by third-party packages
    such as alembic (*[https://pypi.python.org/pypi/alembic/](https://pypi.python.org/pypi/alembic/)*).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中最常用的 ORM 库（也可以说是事实上的标准）是 sqlalchemy。这个库支持大量的后端，并为大多数常见操作提供抽象。架构升级可以通过
    alembic 等第三方包来处理（*[https://pypi.python.org/pypi/alembic/](https://pypi.python.org/pypi/alembic/)*）。
- en: Some frameworks, such as Django (*[https://www.djangoproject.com](https://www.djangoproject.com)*),
    provide their own ORM libraries. If you choose to use a framework, it’s smart
    to use the built-in library because it will often integrate better with the framework
    than an external one.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一些框架，如 Django (*[https://www.djangoproject.com](https://www.djangoproject.com)*),
    提供了自己的 ORM 库。如果你选择使用框架，最好使用内置的库，因为它通常会比外部库更好地与框架集成。
- en: '**WARNING**'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**'
- en: '*The Module View Controller (MVC) architecture that most frameworks rely on
    can be easily misused. These frameworks implement (or make it easy to implement)
    ORM in their models directly, but without abstracting enough of it: any code you
    have in your view and controllers that use the model will also be using ORM directly.
    You need to avoid this. You should write a data model that includes the ORM library
    rather than consists of it. Doing so provides better testability and isolation,
    and makes swapping out the ORM with another storage technology much easier.*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*大多数框架所依赖的模块视图控制器（MVC）架构很容易被误用。这些框架直接在其模型中实现（或使实现变得容易）ORM，但并没有充分抽象化：任何在视图和控制器中使用模型的代码，也将直接使用
    ORM。你需要避免这种情况。你应该编写一个包含 ORM 库的数据模型，而不是由它构成。这样做可以提供更好的可测试性和隔离性，并且使得将 ORM 替换为其他存储技术变得更加容易。*'
- en: '**Streaming Data with Flask and PostgreSQL**'
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用 Flask 和 PostgreSQL 进行数据流处理**'
- en: Here, I’ll show you how you can use one of *PostgreSQL*’s advanced features
    to build an HTTP event-streaming system to help master your data storage.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我将展示如何使用 *PostgreSQL* 的高级功能来构建一个 HTTP 事件流系统，帮助掌握你的数据存储。
- en: '***Writing the Data-Streaming Application***'
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***编写数据流应用程序***'
- en: The purpose of the micro-application in [Listing 12-2](ch12.xhtml#ch12list2)
    is to store messages in a SQL table and provide access to those messages via an
    HTTP REST API. Each message consists of a channel number, a source string, and
    a content string.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 12-2](ch12.xhtml#ch12list2) 中的微应用程序的目的是将消息存储在 SQL 表中，并通过 HTTP REST
    API 提供对这些消息的访问。每条消息包括一个频道号、一个来源字符串和一个内容字符串。'
- en: CREATE TABLE message (
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: CREATE TABLE message (
- en: id SERIAL PRIMARY KEY,
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: id SERIAL PRIMARY KEY,
- en: channel INTEGER NOT NULL,
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: channel INTEGER NOT NULL,
- en: source TEXT NOT NULL,
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: source TEXT NOT NULL,
- en: content TEXT NOT NULL
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: content TEXT NOT NULL
- en: );
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '*Listing 12-2: SQL table schema for storing messages*'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 12-2：用于存储消息的 SQL 表模式*'
- en: 'We also want to stream these messages to the client so that it can process
    them in real time. To do this, we’re going to use the LISTEN and NOTIFY features
    of PostgreSQL. These features allow us to listen for messages sent by a function
    we provide that PostgreSQL will execute:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望将这些消息流式传输到客户端，以便它可以实时处理它们。为此，我们将使用 PostgreSQL 的 LISTEN 和 NOTIFY 功能。这些功能允许我们监听由我们提供的函数发送的消息，而
    PostgreSQL 会执行这些函数：
- en: ➊ CREATE OR REPLACE FUNCTION notify_on_insert() RETURNS trigger AS $$
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ CREATE OR REPLACE FUNCTION notify_on_insert() RETURNS trigger AS $$
- en: ➋ BEGIN
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ BEGIN
- en: PERFORM pg_notify('channel_' || NEW.channel,
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: PERFORM pg_notify('channel_' || NEW.channel,
- en: CAST(row_to_json(NEW) AS TEXT));
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: CAST(row_to_json(NEW) AS TEXT));
- en: RETURN NULL;
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: RETURN NULL;
- en: END;
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: END;
- en: $$ LANGUAGE plpgsql;
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: $$ LANGUAGE plpgsql;
- en: This code creates a trigger function written in pl/pgsql, a language that only
    PostgreSQL understands. Note that we could also write this function in other languages,
    such as Python itself, as PostgreSQL embeds the Python interpreter in order to
    provide a pl/python language. The single simple operation we’ll be performing
    here does not necessitate leveraging Python, so sticking to pl/pgsql is a wise
    choice.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码创建了一个用 pl/pgsql 编写的触发器函数，这是一种只有 PostgreSQL 理解的语言。请注意，我们也可以用其他语言编写此函数，例如
    Python 本身，因为 PostgreSQL 内嵌了 Python 解释器来提供 pl/python 语言。我们在这里执行的单一简单操作并不需要使用 Python，因此坚持使用
    pl/pgsql 是一个明智的选择。
- en: The function notify_on_insert() ➊ performs a call to pg_notify() ➋, which is
    the function that actually sends the notification. The first argument is a string
    that represents a *channel*, while the second is a string carrying the actual
    *payload*. We define the channel dynamically based on the value of the channel
    column in the row. In this case, the payload will be the entire row in JSON format.
    Yes, PostgreSQL knows how to convert a row to JSON natively!
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 notify_on_insert() ➊ 调用了 pg_notify() ➋，这是实际发送通知的函数。第一个参数是表示 *频道* 的字符串，而第二个参数是携带实际
    *载荷* 的字符串。我们根据行中的频道列的值动态定义频道。在这种情况下，载荷将是整个行的 JSON 格式。是的，PostgreSQL 原生知道如何将一行转换为
    JSON！
- en: 'Next, we want to send a notification message on each INSERT performed in the
    message table, so we need to trigger this function on such events:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们希望在每次在消息表中执行 INSERT 操作时发送通知消息，因此我们需要在此类事件上触发此函数：
- en: CREATE TRIGGER notify_on_message_insert AFTER INSERT ON message
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: CREATE TRIGGER notify_on_message_insert AFTER INSERT ON message
- en: FOR EACH ROW EXECUTE PROCEDURE notify_on_insert();
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: FOR EACH ROW EXECUTE PROCEDURE notify_on_insert();
- en: The function is now plugged in and will be executed upon each successful INSERT
    performed in the message table.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数现在已插入，并将在每次在消息表中执行成功的 INSERT 操作时被执行。
- en: 'We can check that it works by using the LISTEN operation in psql:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在 psql 中使用 LISTEN 操作来检查它是否正常工作：
- en: $ psql
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: $ psql
- en: psql (9.3rc1)
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: psql (9.3rc1)
- en: 'SSL connection (cipher: DHE-RSA-AES256-SHA, bits: 256)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: SSL 连接（加密算法：DHE-RSA-AES256-SHA，位数：256）
- en: Type "help" for help.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 输入 "help" 获取帮助。
- en: mydatabase=> LISTEN channel_1;
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: mydatabase=> LISTEN channel_1;
- en: LISTEN
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: LISTEN
- en: mydatabase=> INSERT INTO message(channel, source, content)
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: mydatabase=> INSERT INTO message(channel, source, content)
- en: mydatabase-> VALUES(1, 'jd', 'hello world');
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: mydatabase-> VALUES(1, 'jd', 'hello world');
- en: INSERT 0 1
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: INSERT 0 1
- en: Asynchronous notification "channel_1" with payload
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 异步通知 "channel_1" 载荷
- en: '"{"id":1,"channel":1,"source":"jd","content":"hello world"}"'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '"{"id":1,"channel":1,"source":"jd","content":"hello world"}"'
- en: received from server process with PID 26393.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 从服务器进程（PID 26393）接收。
- en: As soon as the row is inserted, the notification is sent, and we’re able to
    receive it through the PostgreSQL client. Now all we have to do is build the Python
    application that streams this event, shown in [Listing 12-3](ch12.xhtml#ch12list3).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦行被插入，通知就会发送，我们可以通过 PostgreSQL 客户端接收到它。现在我们只需构建一个 Python 应用程序来流式传输这个事件，如 [Listing
    12-3](ch12.xhtml#ch12list3) 所示。
- en: import psycopg2
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: import psycopg2
- en: import psycopg2.extensions
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: import psycopg2.extensions
- en: import select
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: import select
- en: conn = psycopg2.connect(database='mydatabase', user='myuser',
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: conn = psycopg2.connect(database='mydatabase', user='myuser',
- en: password='idkfa', host='localhost')
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: password='idkfa', host='localhost')
- en: conn.set_isolation_level(
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: conn.set_isolation_level(
- en: psycopg2.extensions.ISOLATION_LEVEL_AUTOCOMMIT)
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: psycopg2.extensions.ISOLATION_LEVEL_AUTOCOMMIT)
- en: curs = conn.cursor()
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: curs = conn.cursor()
- en: curs.execute("LISTEN channel_1;")
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: curs.execute("LISTEN channel_1;")
- en: 'while True:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: select.select([conn], [], [])
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: select.select([conn], [], [])
- en: conn.poll()
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: conn.poll()
- en: 'while conn.notifies:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 'while conn.notifies:'
- en: notify = conn.notifies.pop()
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: notify = conn.notifies.pop()
- en: print("Got NOTIFY:", notify.pid, notify.channel,
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: print("收到 NOTIFY:", notify.pid, notify.channel,
- en: notify.payload)
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: notify.payload)
- en: '*Listing 12-3: Listening and receiving the stream of notifications*'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 12-3：监听并接收通知流*'
- en: '[Listing 12-3](ch12.xhtml#ch12list3) connects to PostgreSQL using the psycopg2
    library. The psycopg2 library is a Python module that implements the PostgreSQL
    network protocol and allows us to connect to a PostgreSQL server to send SQL requests
    and receive results. We could have used a library that provides an abstraction
    layer, such as sqlalchemy, but abstracted libraries don’t provide access to the
    LISTEN and NOTIFY functionality of PostgreSQL. It’s important to note that it
    is still possible to access the underlying database connection to execute the
    code when using a library like sqlalchemy, but there would be no point in doing
    that for this example, since we don’t need any of the other features the ORM library
    provides.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 12-3](ch12.xhtml#ch12list3) 使用 psycopg2 库连接到 PostgreSQL。psycopg2 库是一个 Python
    模块，实现在 PostgreSQL 网络协议，并允许我们连接到 PostgreSQL 服务器以发送 SQL 请求并接收结果。我们本可以使用提供抽象层的库，例如
    sqlalchemy，但抽象库不提供 PostgreSQL 的 LISTEN 和 NOTIFY 功能。需要注意的是，即使使用像 sqlalchemy 这样的库，仍然可以访问底层数据库连接来执行代码，但对于这个示例来说这样做没有意义，因为我们不需要
    ORM 库提供的其他功能。'
- en: 'The program listens on channel_1, and as soon as it receives a notification,
    prints it to the screen. If we run the program and insert a row in the message
    table, we get the following output:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 程序监听 channel_1，一旦接收到通知，就将其打印到屏幕上。如果我们运行程序并在消息表中插入一行数据，我们将看到以下输出：
- en: $ python listen.py
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: $ python listen.py
- en: 'Got NOTIFY: 28797 channel_1'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '收到 NOTIFY: 28797 channel_1'
- en: '{"id":10,"channel":1,"source":"jd","content":"hello world"}'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '{"id":10,"channel":1,"source":"jd","content":"hello world"}'
- en: As soon as we insert the row, PostgreSQL runs the trigger and sends a notification.
    Our program receives it and prints the notification payload; here, that’s the
    row serialized to JSON. We now have the basic ability to receive data as it is
    inserted into the database, without doing any extra requests or work.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们插入行数据，PostgreSQL 会触发触发器并发送通知。我们的程序接收它并打印通知负载；在这里，就是将行数据序列化为 JSON。现在我们具备了接收数据库中插入数据的基本能力，而无需执行额外的请求或操作。
- en: '***Building the Application***'
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***构建应用程序***'
- en: 'Next, we’ll use *Flask*, a simple HTTP micro-framework, to build our application.
    We’re going to build an HTTP server that streams the flux of insert using the
    *Server-Sent Events* message protocol defined by HTML5\. An alternative would
    be to use *Transfer-Encoding: chunked* defined by HTTP/1.1:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '接下来，我们将使用*Flask*，一个简单的 HTTP 微框架，来构建我们的应用程序。我们将构建一个 HTTP 服务器，利用 HTML5 定义的 *Server-Sent
    Events* 消息协议来流式传输插入的数据。另一种选择是使用 HTTP/1.1 定义的 *Transfer-Encoding: chunked*：'
- en: import flask
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: import flask
- en: import psycopg2
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: import psycopg2
- en: import psycopg2.extensions
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: import psycopg2.extensions
- en: import select
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: import select
- en: app = flask.Flask(__name__)
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: app = flask.Flask(__name__)
- en: 'def stream_messages(channel):'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 'def stream_messages(channel):'
- en: conn = psycopg2.connect(database='mydatabase', user='mydatabase',
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: conn = psycopg2.connect(database='mydatabase', user='mydatabase',
- en: password='mydatabase', host='localhost')
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: password='mydatabase', host='localhost')
- en: conn.set_isolation_level(
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: conn.set_isolation_level(
- en: psycopg2.extensions.ISOLATION_LEVEL_AUTOCOMMIT)
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: psycopg2.extensions.ISOLATION_LEVEL_AUTOCOMMIT)
- en: curs = conn.cursor()
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: curs = conn.cursor()
- en: curs.execute("LISTEN channel_%d;" % int(channel))
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: curs.execute("LISTEN channel_%d;" % int(channel))
- en: 'while True:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: select.select([conn], [], [])
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: select.select([conn], [], [])
- en: conn.poll()
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: conn.poll()
- en: 'while conn.notifies:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 'while conn.notifies:'
- en: notify = conn.notifies.pop()
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: notify = conn.notifies.pop()
- en: 'yield "data: " + notify.payload + "\n\n"'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 'yield "data: " + notify.payload + "\n\n"'
- en: '@app.route("/message/<channel>", methods=[''GET''])'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '@app.route("/message/<channel>", methods=[''GET''])'
- en: 'def get_messages(channel):'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 'def get_messages(channel):'
- en: return flask.Response(stream_messages(channel),
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: return flask.Response(stream_messages(channel),
- en: mimetype='text/event-stream')
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: mimetype='text/event-stream')
- en: 'if __name__ == "__main__":'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == "__main__":'
- en: app.run()
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: app.run()
- en: This application is simple enough that it supports streaming but not any other
    data retrieval operation. We use Flask to route the HTTP request GET /message/channel
    to our streaming code. As soon as the code is called, the application returns
    a response with the mimetype text/event-stream and sends back a generator function
    instead of a string. Flask will call this function and send results each time
    the generator yields something.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序足够简单，支持流式传输，但不支持其他任何数据检索操作。我们使用 Flask 来路由 HTTP 请求 GET /message/channel
    到我们的流式代码。一旦代码被调用，应用程序会返回一个 mimetype 为 text/event-stream 的响应，并返回一个生成器函数，而不是字符串。Flask
    会调用这个函数，并在每次生成器产生数据时发送结果。
- en: The generator, stream_messages(), reuses the code we wrote earlier to listen
    to PostgreSQL notifications. It receives the channel identifier as an argument,
    listens to that channel, and then yields the payload. Remember that we used PostgreSQL’s
    JSON encoding function in the trigger function, so we’re already receiving JSON
    data from PostgreSQL. There’s no need for us to transcode the data since it’s
    fine to send JSON data to the HTTP client.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器`stream_messages()`重用了我们之前写的代码，用于监听 PostgreSQL 通知。它将频道标识符作为参数，监听该频道，然后生成有效载荷。记住我们在触发函数中使用了
    PostgreSQL 的 JSON 编码功能，所以我们已经从 PostgreSQL 收到 JSON 数据。我们不需要对数据进行转码，因为将 JSON 数据发送到
    HTTP 客户端是没问题的。
- en: '**NOTE**'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*For the sake of simplicity, this example application has been written in a
    single file. If this were a real application, I would move the storage-handling
    implementation into its own Python module.*'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*为了简单起见，这个示例应用程序被写在一个文件中。如果这是一个真实的应用程序，我会将存储处理实现移到自己的 Python 模块中。*'
- en: 'We can now run the server:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以运行服务器了：
- en: $ python listen+http.py
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: $ python listen+http.py
- en: '* Running on http://127.0.0.1:5000/'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '* 正在运行于 http://127.0.0.1:5000/'
- en: 'On another terminal, we can connect and retrieve the events as they’re entered.
    Upon connection, no data is received, and the connection is kept open:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个终端，我们可以连接并检索正在输入的事件。连接时没有收到任何数据，连接保持打开状态：
- en: $ curl -v http://127.0.0.1:5000/message/1
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: $ curl -v http://127.0.0.1:5000/message/1
- en: '* About to connect() to 127.0.0.1 port 5000 (#0)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '* 即将连接()到 127.0.0.1 端口 5000 (#0)'
- en: '*   Trying 127.0.0.1...'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*   尝试连接 127.0.0.1...'
- en: '* Adding handle: conn: 0x1d46e90'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '* 正在添加句柄：conn: 0x1d46e90'
- en: '* Adding handle: send: 0'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '* 正在添加句柄：send: 0'
- en: '* Adding handle: recv: 0'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '* 正在添加句柄：recv: 0'
- en: '* Curl_addHandleToPipeline: length: 1'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '* Curl_addHandleToPipeline: 长度: 1'
- en: '* - Conn 0 (0x1d46e90) send_pipe: 1, recv_pipe: 0'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '* - Conn 0 (0x1d46e90) send_pipe: 1, recv_pipe: 0'
- en: '* Connected to 127.0.0.1 (127.0.0.1) port 5000 (#0)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '* 已连接到 127.0.0.1 (127.0.0.1) 端口 5000 (#0)'
- en: GET /message/1 HTTP/1.1
  id: totrans-152
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: GET /message/1 HTTP/1.1
- en: 'User-Agent: curl/7.32.0'
  id: totrans-153
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 用户代理：curl/7.32.0
- en: 'Host: 127.0.0.1:5000'
  id: totrans-154
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 主机：127.0.0.1:5000
- en: 'Accept: */*'
  id: totrans-155
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 接受：*/*
- en: '>'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: 'But as soon as we insert some rows in the message table, we’ll start seeing
    data coming in through the terminal running curl. In a third terminal, we insert
    a message in the database:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，一旦我们在消息表中插入一些行，我们就会开始在运行 curl 的终端看到数据进入。在第三个终端中，我们向数据库插入一条消息：
- en: mydatabase=> INSERT INTO message(channel, source, content)
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: mydatabase=> INSERT INTO message(channel, source, content)
- en: mydatabase-> VALUES(1, 'jd', 'hello world');
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: mydatabase-> VALUES(1, 'jd', 'hello world');
- en: INSERT 0 1
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: INSERT 0 1
- en: mydatabase=> INSERT INTO message(channel, source, content) mydatabase-> VALUES(1,
    'jd', 'it works');
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: mydatabase=> INSERT INTO message(channel, source, content) mydatabase-> VALUES(1,
    'jd', 'it works');
- en: INSERT 0 1
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: INSERT 0 1
- en: 'Here’s the data output:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是数据输出：
- en: 'data: {"id":71,"channel":1,"source":"jd","content":"hello world"}'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 数据：{"id":71,"channel":1,"source":"jd","content":"hello world"}
- en: 'data: {"id":72,"channel":1,"source":"jd","content":"it works"}'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 数据：{"id":72,"channel":1,"source":"jd","content":"it works"}
- en: This data is printed to the terminal running curl. This keeps curl connected
    to the HTTP server while it waits for the next flux of messages. We created a
    streaming service without doing any kind of polling here, building an entirely
    *push-based* system where information flows from one point to another seamlessly.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据会打印到运行 curl 的终端。这样，curl 会保持与 HTTP 服务器的连接，同时等待下一波消息流。在这里，我们创建了一个流式服务，而没有进行任何类型的轮询，建立了一个完全基于
    *推送* 的系统，信息在不同点之间无缝流动。
- en: A naive and arguably more portable implementation of this application would
    instead repeatedly loop over a SELECT statement to poll for new data inserted
    in the table. This would work with any other storage system that does not support
    a publish-subscribe pattern as this one does.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 一个天真且可以说更具可移植性的应用程序实现会反复循环执行 SELECT 语句，通过轮询表中插入的新数据。这对于任何不支持发布-订阅模式的存储系统（像这个例子一样）也能起作用。
- en: '**Dimitri Fontaine on Databases**'
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Dimitri Fontaine 关于数据库的讨论**'
- en: Dimitri is a skilled PostgreSQL Major Contributor who works at Citus Data and
    argues with other database gurus on the *pgsql-hackers* mailing list. We’ve shared
    a lot of open source adventures, and he’s been kind enough to answer some questions
    about what you should do when dealing with databases.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Dimitri是一个熟练的PostgreSQL主要贡献者，现工作于Citus Data，并在*pgsql-hackers*邮件列表中与其他数据库专家进行辩论。我们分享了许多开源项目，他也很友好地回答了一些关于处理数据库时应该做什么的问题。
- en: '**What advice would you give to developers using RDBMSs as their storage backends?**'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**你会给使用RDBMS作为存储后端的开发者什么建议？**'
- en: RDBMSs were invented in the ’70s to solve some common problems plaguing every
    application developer at that time, and the main services implemented by RDBMSs
    were not simply data storage.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 关系数据库管理系统（RDBMS）是在70年代发明的，旨在解决当时每个应用程序开发者所面临的一些常见问题，而RDBMS所实现的主要服务不仅仅是数据存储。
- en: 'The main services offered by an RDBMS are actually the following:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 关系数据库管理系统（RDBMS）提供的主要服务实际上是以下内容：
- en: '**Concurrency:** Access your data for read or write with as many concurrent
    threads of execution as you want—the RDBMS is there to handle that correctly for
    you. That’s the main feature you want out of an RDBMS.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并发：** 你可以通过任意多个并发执行线程来访问数据进行读取或写入——RDBMS会正确处理这些操作。这是你希望RDBMS提供的主要特性。'
- en: '**Concurrency semantics:** The details about the concurrency behavior when
    using an RDBMS are proposed with a high-level specification in terms of atomicity
    and isolation, which are maybe the most crucial parts of ACID (atomicity, consistency,
    isolation, durability). *Atomicity* is the property that between the time you
    BEGIN a transaction and the time you’re done with it (either COMMIT or ROLLBACK),
    no other concurrent activity on the system is allowed to know what you’re doing—whatever
    that is. When using a proper RDBMS, also include the Data Definition Language
    (DDL), for example, CREATE TABLE or ALTER TABLE. *Isolation* is all about what
    you’re allowed to notice of the concurrent activity of the system from within
    your own transaction. The SQL standard defines four levels of isolation, as described
    in the PostgreSQL documentation (*[http://www.postgresql.org/docs/9.2/static/transaction-iso.html](http://www.postgresql.org/docs/9.2/static/transaction-iso.html)*).'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并发语义：** 使用关系数据库管理系统时的并发行为细节是通过一个高级规范来提出的，通常涉及原子性和隔离性，这可能是ACID（原子性、一致性、隔离性、持久性）中最关键的部分。*原子性*是指在你开始一个事务（BEGIN）到你完成它（无论是提交COMMIT还是回滚ROLLBACK）之间，系统不允许其他并发活动知道你正在做什么——不管是什么。使用合适的RDBMS时，还应包括数据定义语言（DDL），例如CREATE
    TABLE或ALTER TABLE。*隔离性*则涉及在自己的事务中，你允许观察到的系统并发活动的程度。SQL标准定义了四个隔离级别，具体内容请参见PostgreSQL文档中的描述
    (*[http://www.postgresql.org/docs/9.2/static/transaction-iso.html](http://www.postgresql.org/docs/9.2/static/transaction-iso.html)*).'
- en: The RDBMS takes full responsibility for your data. So it allows the developer
    to describe their own rules for consistency, and then it will check that those
    rules are valid at crucial times such as at transaction commit or at statement
    boundaries, depending on the deferability of your constraints declarations.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 关系数据库管理系统（RDBMS）对你的数据负全责。因此，它允许开发者描述自己的一致性规则，然后会在关键时刻检查这些规则是否有效，比如在事务提交时或语句边界时，具体取决于约束声明的可推迟性。
- en: The first constraint you can place on your data is its expected input and output
    formatting, using the proper data type. An RDBMS will know how to work with much
    more than text, numbers, and dates and will properly handle dates that actually
    appear in a calendar in use today.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以对数据施加的第一个约束是其预期的输入和输出格式，使用适当的数据类型。关系数据库管理系统（RDBMS）将知道如何处理比文本、数字和日期更多的数据类型，并且能够正确处理今天实际使用中的日历日期。
- en: 'Data types are not just about input and output formats, though. They also implement
    behaviors and some level of polymorphism, as we all expect the basic equality
    tests to be data type specific: we don’t compare text and numbers, dates and IP
    addresses, arrays and ranges, and so on in the same way.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类型不仅仅与输入和输出格式有关。它们还实现了行为和某种程度的多态性，因为我们都期望基本的相等性测试是特定于数据类型的：我们不会将文本与数字、日期与IP地址、数组与范围等进行同样的比较。
- en: Protecting your data also means that the only choice for an RDBMS is to actively
    refuse data that doesn’t match your consistency rules, the first of which is the
    data type you’ve chosen. If you think it’s okay to have to deal with a date such
    as 0000-00-00 that never existed in the calendar, then you need to rethink.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 保护你的数据也意味着，关系数据库管理系统（RDBMS）唯一的选择是主动拒绝不符合一致性规则的数据，其中第一个规则就是你选择的数据类型。如果你认为处理一个如
    0000-00-00 这样的日期（在日历中从未存在过）是可以接受的，那么你需要重新考虑。
- en: The other part of the consistency guarantees is expressed in terms of constraints
    as in CHECK constraints, NOT NULL constraints, and constraint triggers, one of
    which is known as foreign key. All of that can be thought of as a user-level extension
    of the data type definition and behavior, the main difference being that you can
    choose to DEFER the enforcement of checking those constraints from the end of
    each statement to the end of the current transaction.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 一致性保证的另一部分通过约束的形式来表达，例如 CHECK 约束、NOT NULL 约束和约束触发器，其中之一就是外键。所有这些可以被看作是数据类型定义和行为的用户级扩展，主要区别在于，你可以选择将这些约束的检查推迟执行，从每个语句的结束推迟到当前事务的结束。
- en: 'The relational bits of an RDBMS are all about modeling your data and the guarantee
    that all tuples found in a relation share a common set of rules: structure and
    constraints. When enforcing that, we are enforcing the use of a proper explicit
    schema to handle our data.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: RDBMS 的关系部分专注于建模你的数据，并保证所有在关系中找到的元组共享一套共同的规则：结构和约束。在强制执行这些时，我们实际上是在强制使用适当的显式模式来处理我们的数据。
- en: Working on a proper schema for your data is known as *normalization*, and you
    can aim for a number of subtly different normal forms in your design. Sometimes
    though, you need more flexibility than what is given by the result of your normalization
    process. Common wisdom is to first normalize your data schema and only then modify
    it to regain some flexibility. Chances are you actually don’t need more flexibility.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 为你的数据设计合适的模式称为 *规范化*，在设计中，你可以目标多个微妙不同的规范形式。然而，有时你需要比规范化过程的结果所提供的更大的灵活性。常见的做法是首先规范化你的数据模式，然后再修改它以恢复一些灵活性。很有可能你其实并不需要更多的灵活性。
- en: 'When you do need more flexibility, you can use PostgreSQL to try out a number
    of denormalization options: composite types, records, arrays, H-Store, JSON, or
    XML to name a few.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要更多的灵活性时，可以使用 PostgreSQL 来尝试多种去规范化选项：复合类型、记录、数组、H-Store、JSON 或 XML 等。
- en: There’s a very important drawback to denormalization though, which is that the
    query language we’re going to talk about next is designed to handle rather normalized
    data. With PostgreSQL, of course, the query language has been extended to support
    as much denormalization as possible when using composite types, arrays or H-Store,
    and even JSON in recent releases.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，去规范化有一个非常重要的缺点，那就是我们接下来要讨论的查询语言是为处理规范化数据而设计的。当然，在 PostgreSQL 中，查询语言已经扩展，以支持尽可能多的去规范化，当使用复合类型、数组或
    H-Store，甚至在最近的版本中支持 JSON 时。
- en: The RDBMS knows a lot about your data and can help you implement a very fine-grain
    security model, should you need to do so. The access patterns are managed at the
    relation and column level, and PostgreSQL also implements SECURITY DEFINER stored
    procedures, allowing you to offer access to sensible data in a very controlled
    way, much the same as with using saved user ID (SUID) programs.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: RDBMS 了解你的数据，能够帮助你实现非常细粒度的安全模型，如果你需要的话。访问模式在关系和列级别进行管理，PostgreSQL 还实现了 SECURITY
    DEFINER 存储过程，允许你以非常受控的方式提供对敏感数据的访问，类似于使用保存的用户 ID（SUID）程序。
- en: The RDBMS offers to access your data using a SQL, which became the de facto
    standard in the ’80s and is now driven by a committee. In the case of PostgreSQL,
    lots of extensions are being added, with each and every major release allowing
    you to access a very rich DSL language. All the work of query planning and optimization
    is done for you by the RDBMS so that you can focus on a declarative query where
    you describe only the result you want from the data you have.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: RDBMS 提供通过 SQL 访问你的数据，SQL 在 80 年代成为事实标准，现在由一个委员会推动。在 PostgreSQL 的情况下，很多扩展被添加进来，每次主要发布都允许你访问一个非常丰富的领域特定语言（DSL）。所有查询规划和优化的工作都由
    RDBMS 为你完成，这样你就可以专注于声明式查询，描述你希望从现有数据中获得的结果。
- en: And that’s also why you need to pay close attention to the NoSQL offerings here,
    as most of those trendy products are in fact not removing just the SQL from the
    offering but a whole lot of other foundations that you’ve been trained to expect.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是为什么你需要密切关注这里的NoSQL产品，因为这些时髦的产品实际上并不仅仅是去除了SQL，而是去除了你所习惯的许多其他基础设施。
- en: '**What advice would you give to developers using RDBMSs as their storage backends?**'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**你会给使用关系型数据库管理系统（RDBMS）作为存储后端的开发者什么建议？**'
- en: My advice is to remember the differences between a *storage backend* and an
    RDBMS. Those are very different services, and if all you need is a storage backend,
    maybe consider using something other than an RDBMS.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我的建议是，记住*存储后端*和RDBMS之间的区别。这是两种非常不同的服务，如果你需要的仅仅是存储后端，也许考虑使用其他非RDBMS的服务。
- en: Most often, though, what you really need is a full-blown RDBMS. In that case,
    the best option you have is PostgreSQL. Go read its documentation (*[https://www.postgresql.org/docs/](https://www.postgresql.org/docs/)*);
    see the list of data types, operators, functions, features, and extensions it
    provides. Read some usage examples on blog posts.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，大多数时候，你真正需要的是一个功能齐全的RDBMS。在这种情况下，你最好的选择是PostgreSQL。去阅读它的文档 (*[https://www.postgresql.org/docs/](https://www.postgresql.org/docs/)*);
    查看它提供的数据类型、运算符、函数、特性和扩展列表。阅读一些博客上的使用示例。
- en: Then consider PostgreSQL a tool you can leverage in your development and include
    it in your application architecture. Parts of the services you need to implement
    are best offered at the RDBMS layer, and PostgreSQL excels at being that trustworthy
    part of your whole implementation.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将PostgreSQL视为你可以在开发中利用的工具，并将其纳入你的应用架构中。你需要实现的部分服务最好由RDBMS层提供，而PostgreSQL在作为整个实现中的可靠部分方面表现出色。
- en: '**What’s the best way to use or not use an ORM?**'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用或不使用ORM的最佳方式是什么？**'
- en: 'The ORM will best work for *CRUD* applications: create, read, update, and delete.
    The read part should be limited to a very simple SELECT statement targeting a
    single table, as retrieving more columns than necessary has a significant impact
    on query performances and resources used.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: ORM最适合用于*CRUD*应用：创建、读取、更新和删除。读取部分应仅限于一个非常简单的SELECT语句，目标是单个表，因为检索不必要的更多列会对查询性能和资源使用产生显著影响。
- en: Any column you retrieve from the RDBMS and that you end up not using is pure
    waste of precious resources, a first scalability killer. Even when your ORM is
    able to fetch only the data you’re asking for, you still then have to somehow
    manage the exact list of columns you want in each situation, without using a simple
    abstract method that will automatically compute the fields list for you.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 从RDBMS中检索的任何列，如果最终没有使用，都是对宝贵资源的纯粹浪费，是首要的可扩展性杀手。即使你的ORM能够仅提取你请求的数据，你仍然必须在每种情况下管理精确的列列表，而不能使用一个简单的抽象方法来自动为你计算字段列表。
- en: The create, update, and delete queries are simple INSERT, UPDATE, and DELETE
    statements. Many RDBMSs offer optimizations that are not leveraged by ORMs, such
    as returning data after an INSERT.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 创建、更新和删除查询是简单的INSERT、UPDATE和DELETE语句。许多RDBMS提供了ORM无法利用的优化，例如在INSERT之后返回数据。
- en: Furthermore, in the general case, a relation is either a table or the result
    of any query. It’s common practice when using an ORM to build relational mapping
    between defined tables and some model classes, or some other helper stubs.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在一般情况下，关系要么是一个表，要么是任何查询的结果。在使用ORM时，通常会在已定义的表和某些模型类之间建立关系映射，或者与其他辅助存根之间建立映射。
- en: If you consider the whole SQL semantics in their generalities, then the relational
    mapper should really be able to map any query against a class. You would then
    presumably have to build a new class for each query you want to run.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你考虑SQL语义的整体，那么关系映射器应该能够将任何查询映射到一个类。你可能需要为你想要执行的每个查询构建一个新的类。
- en: The idea when applied to our case is that you trust your ORM to do a better
    job than you at writing efficient SQL queries, even when you’re not giving it
    enough information to work out the exact set of data you are interested in.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这个思想应用到我们的案例中就是，你信任你的ORM比你自己更能高效地编写SQL查询，即使你没有给它足够的信息来计算出你感兴趣的确切数据集。
- en: It’s true that, at times, SQL can get quite complex, though you’re not going
    to get anywhere near simplicity by using an API-to-SQL generator that you can’t
    control.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 诚然，有时SQL会变得相当复杂，但通过使用一个你无法控制的API-to-SQL生成器，你绝不会接近简单。
- en: 'However, there are two cases where you can relax and use your ORM, provided
    that you’re willing to accept the following compromise: at a later point, you
    may need to edit your ORM usage out of your codebase.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有两种情况你可以放松并使用ORM，前提是你愿意接受以下妥协：稍后你可能需要将ORM的使用从代码库中移除。
- en: '**Time to market:** When you’re really in a hurry and want to gain market share
    as soon as possible, the only way to get there is to release a first version of
    your application and idea. If your team is more proficient at using an ORM than
    handcrafting SQL queries, then by all means just do that. You have to realize,
    though, that as soon as you’re successful with your application, one of the first
    scalability problems you will have to solve is going to be related to your ORM
    producing really bad queries. Also, your usage of the ORM will have painted you
    into a corner and resulted in bad code design decisions. But if you’re there,
    you’re successful enough to spend some refactoring money and remove any dependency
    on the ORM, right?'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**上市时间：** 当你急需推出产品并尽快获得市场份额时，唯一的办法就是发布应用程序和创意的第一个版本。如果你的团队在使用ORM方面比手写SQL查询更熟练，那就直接这么做吧。不过，你必须意识到，一旦你的应用成功了，首先要解决的扩展性问题之一就是ORM生成的查询非常糟糕。此外，你使用ORM的方式会让你陷入困境，并导致糟糕的代码设计决策。但如果你到了那个阶段，说明你已经足够成功，可以花一些重构的费用来去除对ORM的依赖，对吧？'
- en: '**CRUD application:** This is the real thing, where you are only editing a
    single tuple at a time and you don’t really care about performance, like for the
    basic admin application interface.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CRUD应用：** 这是真正的应用场景，你只会一次编辑一个元组，而不太关心性能问题，例如在基本的管理应用界面中。'
- en: '**What are the pros of using PostgreSQL over other databases when working with
    Python?**'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '**在使用Python时，选择PostgreSQL而非其他数据库的优点是什么？**'
- en: 'Here are my top reasons for choosing PostgreSQL as a developer:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我选择PostgreSQL作为开发者的主要理由：
- en: '**Community support:** The PostgreSQL community is vast and welcoming to new
    users, and folks will typically take the time to provide the best possible answer.
    The mailing lists are still the best way to communicate with the community.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**社区支持：** PostgreSQL社区庞大且热情欢迎新用户，大家通常会花时间提供最佳答案。邮件列表仍然是与社区沟通的最佳方式。'
- en: '**Data integrity and durability:** Any data you send to PostgreSQL is safe
    in its definition and your ability to fetch it again later.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据完整性和持久性：** 你发送到PostgreSQL的任何数据都是安全的，数据的定义和你之后再获取它的能力都能得到保证。'
- en: '**Data types, functions, operators, arrays, and ranges:** PostgreSQL has a
    very rich set of data types that come with a host of operators and functions.
    It’s even possible to denormalize using arrays or JSON data types and still be
    able to write advanced queries, including joins, against those.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据类型、函数、运算符、数组和范围：** PostgreSQL提供了丰富的数据类型，附带许多运算符和函数。即便使用数组或JSON数据类型进行非规范化，仍然能够编写高级查询，包括对它们进行JOIN操作。'
- en: '**The planner and optimizer:** It’s worth taking the time to understand how
    complex and powerful these are.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**查询规划器和优化器：** 值得花时间理解这些组件有多复杂和强大。'
- en: '**Transactional DDL:** It’s possible to ROLLBACK almost any command. Try it
    now: just open your psql shell against a database you have and type in BEGIN;
    DROP TABLE foo; ROLLBACK;, where you replace foo with the name of a table that
    exists in your local instance. Amazing, right?'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事务性DDL：** 你几乎可以回滚任何命令。现在试试看：打开你的psql终端，连接到一个数据库，然后输入BEGIN; DROP TABLE foo;
    ROLLBACK;，其中将foo替换为本地实例中存在的表名。不可思议吧？'
- en: '**PL/Python (and others such as C, SQL, Javascript, or Lua):** You can run
    your own Python code on the server, right where the data is, so you don’t have
    to fetch it over the network just to process it and then send it back in a query
    to do the next level of JOIN.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PL/Python（以及其他如C、SQL、Javascript或Lua）：** 你可以在服务器上运行自己的Python代码，直接在数据所在的位置处理它，这样就不需要通过网络获取数据来处理，然后再通过查询将结果发送回来执行下一层的JOIN操作。'
- en: '**Specific indexing (GiST, GIN, SP-GiST, partial and functional):** You can
    create Python functions to process your data from within PostgreSQL and then index
    the result of calling that function. When you issue a query with a WHERE clause
    calling that function, it’s called only once with the data from the query; then
    it’s matched directly with the contents of the index.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**特定索引（GiST、GIN、SP-GiST、部分和函数索引）：** 你可以创建Python函数来处理PostgreSQL中的数据，然后对调用该函数的结果进行索引。当你发出带有WHERE子句的查询时，该函数只会对查询中的数据调用一次；然后，它直接与索引的内容进行匹配。'
