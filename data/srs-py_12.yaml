- en: '**12**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**12**'
- en: '**MANAGING RELATIONAL DATABASES**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**管理关系型数据库**'
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: Applications will almost always have to store data of some kind, and developers
    will often combine a relational database management system (RDBMS) with some type
    of object relational mapping tool (ORM). RDBMSs and ORMs can be tricky and are
    not a favorite topic for many developers, but sooner or later, they must be addressed.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序几乎总是需要存储某种数据，开发者通常会将关系型数据库管理系统（RDBMS）与某种类型的对象关系映射工具（ORM）结合使用。RDBMS 和 ORM
    可能很复杂，并且对于许多开发者来说并不是他们最喜欢的话题，但迟早需要面对。
- en: '**RDBMSs, ORMs, and When to Use Them**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**关系型数据库管理系统（RDBMS）、ORM 以及何时使用它们**'
- en: An RDBMS is the database that stores an application’s relational data. Developers
    will use a language like SQL (Structured Query Language) to deal with the relational
    algebra, meaning that a language like this handles the data management and the
    relationships between the data. Used together, they allow you to both store data
    and query that data to get specific information as efficiently as possible. Having
    a good understanding of relational database structures, such as how to use proper
    normalization or the different types of serializability, might keep you from falling
    into many traps. Obviously, such subjects deserve an entire book and won’t be
    covered in their entirety in this chapter; instead, we’ll focus on using the database
    via its usual programming language, SQL.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: RDBMS 是存储应用程序关系数据的数据库。开发者将使用类似 SQL（结构化查询语言）这样的语言来处理关系代数，也就是说，像这样的语言处理数据管理和数据之间的关系。两者结合使用，可以让你既能存储数据，又能尽可能高效地查询数据以获取特定的信息。对关系型数据库结构有良好的理解，例如如何正确使用规范化或不同类型的可串行性，可能会帮助你避免掉入许多陷阱。显然，这些主题值得写一本完整的书籍，而不会在本章中完全涵盖；相反，我们将专注于通过其常用的编程语言
    SQL 来使用数据库。
- en: Developers may not want to invest in learning a whole new programming language
    to interact with the RDBMS. If so, they tend to avoid writing SQL queries entirely,
    relying instead on a library to do the work for them. ORM libraries are commonly
    found in programming language ecosystems, and Python is no exception.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者可能不愿意投入时间学习一门全新的编程语言来与 RDBMS 交互。如果是这样，他们通常会完全避免编写 SQL 查询，而是依赖于某个库来为他们完成这项工作。ORM
    库在编程语言生态系统中非常常见，Python 也不例外。
- en: 'The purpose of an ORM is to make database systems easier to access by abstracting
    the process of creating queries: it generates the SQL so you don’t have to. Unfortunately,
    this abstraction layer can prevent you from performing more specific or low-level
    tasks that the ORM is simply not capable of doing, such as writing complex queries.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: ORM 的目的是通过抽象化创建查询的过程，使数据库系统更容易访问：它生成 SQL，这样你就不需要手动写了。不幸的是，这种抽象层可能会妨碍你执行一些更具体或底层的任务，这些任务是
    ORM 根本无法做到的，比如编写复杂的查询。
- en: 'There is also a particular set of difficulties with using ORMs in object-oriented
    programs that are so common, they are known collectively as the *object-relational
    impedance mismatch.* This impedance mismatch occurs because relational databases
    and object-oriented programs have different representations of data that don’t
    map properly to one another: mapping SQL tables to Python classes won’t give you
    optimal results, no matter what you do.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象程序中使用 ORM 也有一组特定的难题，这些问题非常常见，通常被统称为 *对象关系阻抗不匹配*。这种阻抗不匹配发生在关系型数据库和面向对象程序对数据的表示不同，彼此之间无法正确映射：无论你怎么做，将
    SQL 表映射到 Python 类都无法得到最佳结果。
- en: Understanding SQL and RDBMSs will allow you to write your own queries, without
    having to rely on the abstraction layer for everything.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 SQL 和 RDBMS 将使你能够编写自己的查询，而无需依赖于抽象层来做所有事情。
- en: 'But that’s not to say you should avoid ORMs entirely. ORM libraries can help
    with rapid prototyping of your application model, and some libraries even provide
    useful tools such as schema upgrades and downgrades. It’s important to understand
    that using an ORM is not a substitute for gaining a real understanding of RDBMSs:
    many developers try to solve problems in the language of their choice rather than
    using their model API, and the solutions they come up with are inelegant at best.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 但这并不是说你应该完全避免使用 ORM。ORM 库可以帮助你快速原型化应用程序模型，一些库甚至提供有用的工具，比如架构升级和降级。重要的是要理解，使用
    ORM 并不能替代你对 RDBMS 的真正理解：许多开发者尝试用自己选择的语言来解决问题，而不是使用它们的模型 API，而他们提出的解决方案充其量也只是勉强凑合。
- en: '**NOTE**'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*This chapter assumes you know basic SQL. Introducing SQL queries and discussing
    how tables work is beyond the scope of this book. If you’re new to SQL, I recommend
    learning the basics before continuing. Practical SQL by Anthony DeBarros (No Starch
    Press, 2018) is a good place to start.*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章假设你了解基本的 SQL。引入 SQL 查询并讨论表的工作原理超出了本书的范围。如果你是 SQL 新手，建议在继续之前先学习基本内容。Anthony
    DeBarros 的《实用 SQL》（No Starch Press，2018）是一个很好的起点。*'
- en: 'Let’s look at an example that demonstrates why understanding RDBMSs can help
    you write better code. Say you have a SQL table for keeping track of messages.
    This table has a single column named `id` representing the ID of the message sender,
    which is the primary key, and a string containing the content of the message,
    like so:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子，演示为什么理解关系型数据库管理系统（RDBMS）可以帮助你编写更好的代码。假设你有一个用于跟踪消息的 SQL 表。这张表有一个名为`id`的列，表示消息发送者的
    ID，这是主键，还有一个包含消息内容的字符串，像这样：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We want to detect any duplicate messages received and exclude them from the
    database. To do this, a typical developer might write SQL using an ORM, as shown
    in [Listing 12-1](ch12.xhtml#ch12list1).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望检测任何重复的消息并将其从数据库中排除。为此，典型的开发者可能会使用 ORM 编写 SQL，如[列表 12-1](ch12.xhtml#ch12list1)所示。
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 12-1: Detecting and excluding duplicate messages with an ORM*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 12-1：使用 ORM 检测并排除重复消息*'
- en: 'This code works for most cases, but it has some major drawbacks:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码适用于大多数情况，但它有一些主要的缺点：
- en: 'The duplicate constraint is already expressed in the SQL schema, so there is
    a sort of code duplication: using `PRIMARY KEY` implicitly defines the uniqueness
    of the `id` field.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复约束已经在 SQL 模式中表达，因此这里存在一种代码重复：使用`PRIMARY KEY`隐式定义了`id`字段的唯一性。
- en: 'If the message is not yet in the database, this code executes two SQL queries:
    a `SELECT` statement and then an `INSERT` statement. Executing a SQL query might
    take a long time and require a round-trip to the SQL server, introducing extraneous
    delay.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果消息尚未在数据库中，这段代码会执行两条 SQL 查询：一条`SELECT`语句，然后是`INSERT`语句。执行 SQL 查询可能需要很长时间，并且可能需要与
    SQL 服务器进行来回通信，造成额外的延迟。
- en: The code doesn’t account for the possibility that someone else might insert
    a duplicate message after we call `select_by_id()` but before we call `insert()`,
    which would cause the program to raise an exception. This vulnerability is called
    a *race condition*.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这段代码没有考虑到在我们调用`select_by_id()`之后、调用`insert()`之前，其他人可能会插入重复的消息，这样会导致程序抛出异常。这个漏洞被称为*竞态条件*。
- en: 'There’s a much better way to write this code, but it requires cooperation with
    the RDBMS server. Rather than checking for the message’s existence and then inserting
    it, we can insert it right away and use a `try...except` block to catch a duplicate
    conflict:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种更好的方式来编写这段代码，但它需要与 RDBMS 服务器协作。我们可以直接插入消息，并使用`try...except`块来捕捉重复冲突，而不是先检查消息是否存在然后再插入：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this case, inserting the message directly into the table works flawlessly
    if the message is not already present. If it is, the ORM raises an exception indicating
    the violation of the uniqueness constraint. This method achieves the same effect
    as [Listing 12-1](ch12.xhtml#ch12list1) but in a more efficient fashion and without
    any race condition. This is a very simple pattern, and it doesn’t conflict with
    any ORM in any way. The problem is that developers tend to treat SQL databases
    as dumb storage rather than as a tool they can use to get proper data integrity
    and consistency; consequently, they may duplicate the constraints written in SQL
    in their controller code rather than in their model.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果消息尚不存在，直接将消息插入表中可以完美运行。如果已存在，ORM 会抛出一个异常，指示违反了唯一性约束。此方法与[列表 12-1](ch12.xhtml#ch12list1)达到相同的效果，但更加高效且没有任何竞态条件。这是一个非常简单的模式，并且它与任何
    ORM 都不会冲突。问题在于开发者倾向于将 SQL 数据库视为“愚蠢的存储”而不是一个可以用来获得数据完整性和一致性的工具；因此，他们可能会在控制器代码中而不是在模型中重复写
    SQL 中的约束。
- en: Treating your SQL backend as a model API is good way to make efficient use of
    it. You can manipulate the data stored in your RDBMS with simple function calls
    programmed in its own procedural language.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的 SQL 后端当作模型 API 来使用是高效利用它的好方法。你可以通过用其自身的过程式语言编写简单的函数调用来操作存储在 RDBMS 中的数据。
- en: '**Database Backends**'
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**数据库后端**'
- en: ORM supports multiple database backends. No ORM library provides a complete
    abstraction of all RDBMS features, and simplifying the code to the most basic
    RDBMS available will make using any advanced RDBMS functions impossible without
    breaking the abstraction layer. Even simple things that aren’t standardized in
    SQL, such as handling timestamp operations, are a pain to deal with when using
    an ORM. This is even more true if your code is RDBMS agnostic. It is important
    to keep this in mind when you choose your application’s RDBMS.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: ORM支持多个数据库后端。没有哪个ORM库能够完全抽象所有RDBMS的特性，而将代码简化到最基础的RDBMS功能将使得在不打破抽象层的情况下使用任何高级RDBMS功能变得不可能。即使是一些在SQL中没有标准化的简单操作，比如处理时间戳操作，在使用ORM时也会变得很麻烦。如果你的代码是RDBMS无关的，这一点尤其如此。在选择应用程序的RDBMS时，记住这一点非常重要。
- en: Isolating ORM libraries (as described in “[External Libraries](ch02.xhtml#lev1sec10)”
    on [page 22](ch02.xhtml#page_22)) helps mitigate potential problems. This approach
    allows you to easily swap your ORM library for a different one should the need
    arise and to optimize your SQL usage by identifying places with inefficient query
    usage, which lets you bypass most of the ORM boilerplate.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 隔离ORM库（如在《[外部库](ch02.xhtml#lev1sec10)》中描述的，[第22页](ch02.xhtml#page_22)）有助于减轻潜在问题。这个方法允许你在需要时轻松更换ORM库，并通过识别低效查询的地方来优化SQL使用，从而避免大部分ORM的样板代码。
- en: For example, you can use your ORM in a module of your application, such as `myapp.storage`,
    to easily build in such isolation. This module should export only functions and
    methods that allow you to manipulate the data at a high level of abstraction.
    The ORM should be used only from that module. At any point, you will be able to
    drop in any module providing the same API to replace `myapp.storage`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以在应用程序的一个模块中使用ORM，比如`myapp.storage`，轻松实现这种隔离。该模块应该只导出允许你在高抽象级别操作数据的函数和方法。ORM应仅在该模块中使用。任何时候，你都可以插入任何提供相同API的模块来替代`myapp.storage`。
- en: The most commonly used ORM library in Python (and arguably the de facto standard)
    is `sqlalchemy`. This library supports a huge number of backends and provides
    abstraction for most common operations. Schema upgrades can be handled by third-party
    packages such as `alembic` (*[https://pypi.python.org/pypi/alembic/](https://pypi.python.org/pypi/alembic/)*).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Python中最常用的ORM库（可以说是事实上的标准）是`sqlalchemy`。这个库支持大量的后端，并为大多数常见操作提供了抽象。模式升级可以通过第三方包来处理，例如`alembic`（*[https://pypi.python.org/pypi/alembic/](https://pypi.python.org/pypi/alembic/)*）。
- en: Some frameworks, such as Django (*[https://www.djangoproject.com](https://www.djangoproject.com)*),
    provide their own ORM libraries. If you choose to use a framework, it’s smart
    to use the built-in library because it will often integrate better with the framework
    than an external one.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一些框架，比如Django（*[https://www.djangoproject.com](https://www.djangoproject.com)*），提供了它们自己的ORM库。如果你选择使用框架，最好使用内建库，因为它通常与框架的集成效果要优于外部库。
- en: '**WARNING**'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**'
- en: '*The Module View Controller (MVC) architecture that most frameworks rely on
    can be easily misused. These frameworks implement (or make it easy to implement)
    ORM in their models directly, but without abstracting enough of it: any code you
    have in your view and controllers that use the model will also be using ORM directly.
    You need to avoid this. You should write a data model that includes the ORM library
    rather than consists of it. Doing so provides better testability and isolation,
    and makes swapping out the ORM with another storage technology much easier.*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*大多数框架依赖的模块视图控制器（MVC）架构很容易被滥用。这些框架直接在模型中实现（或方便实现）ORM，但没有足够地进行抽象：任何在视图和控制器中使用模型的代码，也将直接使用ORM。你需要避免这种情况。你应该编写一个包含ORM库的数据模型，而不是由它构成。这样做可以提供更好的可测试性和隔离性，并使得用另一种存储技术替换ORM变得更加容易。*'
- en: '**Streaming Data with Flask and PostgreSQL**'
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用Flask和PostgreSQL进行数据流处理**'
- en: Here, I’ll show you how you can use one of *PostgreSQL*’s advanced features
    to build an HTTP event-streaming system to help master your data storage.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我将向你展示如何利用*PostgreSQL*的高级特性构建一个HTTP事件流系统，帮助你掌握数据存储。
- en: '***Writing the Data-Streaming Application***'
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***编写数据流处理应用程序***'
- en: The purpose of the micro-application in [Listing 12-2](ch12.xhtml#ch12list2)
    is to store messages in a SQL table and provide access to those messages via an
    HTTP REST API. Each message consists of a channel number, a source string, and
    a content string.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 12-2](ch12.xhtml#ch12list2)中微型应用程序的目的是将消息存储在 SQL 表中，并通过 HTTP REST API 提供对这些消息的访问。每条消息由一个频道号、一个源字符串和一个内容字符串组成。'
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 12-2: SQL table schema for storing messages*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 12-2：用于存储消息的 SQL 表架构*'
- en: 'We also want to stream these messages to the client so that it can process
    them in real time. To do this, we’re going to use the `LISTEN` and `NOTIFY` features
    of PostgreSQL. These features allow us to listen for messages sent by a function
    we provide that PostgreSQL will execute:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望将这些消息流式传输到客户端，以便它可以实时处理它们。为此，我们将使用 PostgreSQL 的 `LISTEN` 和 `NOTIFY` 功能。这些功能允许我们监听
    PostgreSQL 执行的函数发送的消息：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This code creates a trigger function written in pl/pgsql, a language that only
    PostgreSQL understands. Note that we could also write this function in other languages,
    such as Python itself, as PostgreSQL embeds the Python interpreter in order to
    provide a pl/python language. The single simple operation we’ll be performing
    here does not necessitate leveraging Python, so sticking to pl/pgsql is a wise
    choice.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码创建了一个用 pl/pgsql 编写的触发器函数，这是 PostgreSQL 独有的一种语言。请注意，我们也可以使用其他语言编写此函数，例如 Python
    本身，因为 PostgreSQL 嵌入了 Python 解释器以提供 pl/python 语言。我们在这里执行的单一简单操作并不需要利用 Python，因此坚持使用
    pl/pgsql 是一个明智的选择。
- en: The function `notify_on_insert()` ➊ performs a call to `pg_notify()` ➋, which
    is the function that actually sends the notification. The first argument is a
    string that represents a *channel*, while the second is a string carrying the
    actual *payload*. We define the channel dynamically based on the value of the
    channel column in the row. In this case, the payload will be the entire row in
    JSON format. Yes, PostgreSQL knows how to convert a row to JSON natively!
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `notify_on_insert()` ➊ 调用了 `pg_notify()` ➋，该函数实际上发送了通知。第一个参数是表示 *频道* 的字符串，而第二个参数是承载实际
    *有效载荷* 的字符串。我们根据行中频道列的值动态定义频道。在这种情况下，有效载荷将是整行数据的 JSON 格式。是的，PostgreSQL 确实知道如何将一行数据转换为
    JSON！
- en: 'Next, we want to send a notification message on each `INSERT` performed in
    the message table, so we need to trigger this function on such events:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们希望在每次在消息表中执行 `INSERT` 时发送通知消息，因此我们需要在此类事件上触发该函数：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The function is now plugged in and will be executed upon each successful `INSERT`
    performed in the message table.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数现在已经连接并将在每次在消息表中执行成功的`INSERT`时被执行。
- en: 'We can check that it works by using the `LISTEN` operation in `psql`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在 `psql` 中使用 `LISTEN` 操作来检查它是否工作正常：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As soon as the row is inserted, the notification is sent, and we’re able to
    receive it through the PostgreSQL client. Now all we have to do is build the Python
    application that streams this event, shown in [Listing 12-3](ch12.xhtml#ch12list3).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦行被插入，通知便会被发送，并且我们能够通过 PostgreSQL 客户端接收到它。现在我们只需构建流式传输该事件的 Python 应用程序，如 [清单
    12-3](ch12.xhtml#ch12list3) 所示。
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 12-3: Listening and receiving the stream of notifications*'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 12-3：监听并接收通知流*'
- en: '[Listing 12-3](ch12.xhtml#ch12list3) connects to PostgreSQL using the `psycopg2`
    library. The `psycopg2` library is a Python module that implements the PostgreSQL
    network protocol and allows us to connect to a PostgreSQL server to send SQL requests
    and receive results. We could have used a library that provides an abstraction
    layer, such as `sqlalchemy`, but abstracted libraries don’t provide access to
    the `LISTEN` and `NOTIFY` functionality of PostgreSQL. It’s important to note
    that it is still possible to access the underlying database connection to execute
    the code when using a library like `sqlalchemy`, but there would be no point in
    doing that for this example, since we don’t need any of the other features the
    ORM library provides.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 12-3](ch12.xhtml#ch12list3)使用 `psycopg2` 库连接到 PostgreSQL。`psycopg2` 库是一个
    Python 模块，实现了 PostgreSQL 网络协议，并允许我们连接到 PostgreSQL 服务器发送 SQL 请求并接收结果。我们本可以使用提供抽象层的库，例如
    `sqlalchemy`，但是抽象库并没有提供访问 PostgreSQL 的 `LISTEN` 和 `NOTIFY` 功能。需要注意的是，使用像 `sqlalchemy`
    这样的库时，仍然可以访问底层数据库连接来执行代码，但对于这个示例来说这样做没有意义，因为我们不需要 ORM 库提供的其他功能。'
- en: 'The program listens on `channel_1`, and as soon as it receives a notification,
    prints it to the screen. If we run the program and insert a row in the `message`
    table, we get the following output:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 程序监听 `channel_1`，一旦收到通知，就会将其打印到屏幕上。如果我们运行程序并在 `message` 表中插入一行数据，我们会得到以下输出：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As soon as we insert the row, PostgreSQL runs the trigger and sends a notification.
    Our program receives it and prints the notification payload; here, that’s the
    row serialized to JSON. We now have the basic ability to receive data as it is
    inserted into the database, without doing any extra requests or work.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们插入行，PostgreSQL 会运行触发器并发送通知。我们的程序接收到通知并打印通知负载；在这里，通知负载就是被序列化为 JSON 的行。现在，我们具备了接收插入数据库的数据的基本能力，而无需做任何额外的请求或工作。
- en: '***Building the Application***'
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***构建应用程序***'
- en: 'Next, we’ll use *Flask*, a simple HTTP micro-framework, to build our application.
    We’re going to build an HTTP server that streams the flux of `insert` using the
    *Server-Sent Events* message protocol defined by HTML5\. An alternative would
    be to use *Transfer-Encoding: chunked* defined by HTTP/1.1:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '接下来，我们将使用 *Flask*，一个简单的 HTTP 微框架，来构建我们的应用程序。我们将构建一个 HTTP 服务器，使用 HTML5 定义的 *Server-Sent
    Events* 消息协议流式传输 `insert` 数据流。另一种选择是使用 HTTP/1.1 定义的 *Transfer-Encoding: chunked*：'
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This application is simple enough that it supports streaming but not any other
    data retrieval operation. We use Flask to route the HTTP request `GET /message/channel`
    to our streaming code. As soon as the code is called, the application returns
    a response with the mimetype `text/event-stream` and sends back a generator function
    instead of a string. Flask will call this function and send results each time
    the generator yields something.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序足够简单，支持流式传输，但不支持其他数据检索操作。我们使用 Flask 将 HTTP 请求 `GET /message/channel` 路由到我们的流式代码。一旦调用该代码，应用程序会返回一个具有
    `text/event-stream` MIME 类型的响应，并返回一个生成器函数，而不是一个字符串。Flask 会调用这个函数，并在每次生成器生成内容时发送结果。
- en: The generator, `stream_messages()`, reuses the code we wrote earlier to listen
    to PostgreSQL notifications. It receives the channel identifier as an argument,
    listens to that channel, and then yields the payload. Remember that we used PostgreSQL’s
    JSON encoding function in the trigger function, so we’re already receiving JSON
    data from PostgreSQL. There’s no need for us to transcode the data since it’s
    fine to send JSON data to the HTTP client.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器 `stream_messages()` 重用了我们之前写的代码来监听 PostgreSQL 通知。它接收频道标识符作为参数，监听该频道，然后返回负载。记住，我们在触发器函数中使用了
    PostgreSQL 的 JSON 编码函数，所以我们已经从 PostgreSQL 接收到了 JSON 数据。我们不需要重新编码数据，因为直接将 JSON
    数据发送给 HTTP 客户端是可以的。
- en: '**NOTE**'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*For the sake of simplicity, this example application has been written in a
    single file. If this were a real application, I would move the storage-handling
    implementation into its own Python module.*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*为了简化起见，这个示例应用程序是写在一个文件中的。如果这是一个真正的应用程序，我会将存储处理实现移动到它自己的 Python 模块中。*'
- en: 'We can now run the server:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以运行服务器：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'On another terminal, we can connect and retrieve the events as they’re entered.
    Upon connection, no data is received, and the connection is kept open:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个终端中，我们可以连接并检索已输入的事件。连接时，没有数据接收，并且连接保持打开状态：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'But as soon as we insert some rows in the `message` table, we’ll start seeing
    data coming in through the terminal running `curl`. In a third terminal, we insert
    a message in the database:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，一旦我们在 `message` 表中插入一些行，我们会开始通过运行 `curl` 的终端看到数据流入。在第三个终端中，我们在数据库中插入一条消息：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here’s the data output:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这是数据输出：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This data is printed to the terminal running `curl`. This keeps `curl` connected
    to the HTTP server while it waits for the next flux of messages. We created a
    streaming service without doing any kind of polling here, building an entirely
    *push-based* system where information flows from one point to another seamlessly.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据会打印到运行 `curl` 的终端中。这样就保持了 `curl` 与 HTTP 服务器的连接，同时等待下一个消息流的到来。我们创建了一个流式服务，而没有做任何轮询，建立了一个完全基于
    *推送* 的系统，信息在一个点到另一个点之间无缝流动。
- en: A naive and arguably more portable implementation of this application would
    instead repeatedly loop over a `SELECT` statement to poll for new data inserted
    in the table. This would work with any other storage system that does not support
    a publish-subscribe pattern as this one does.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一个天真且可能更具可移植性的实现会反复循环执行 `SELECT` 语句，以轮询表中插入的新数据。这种方式适用于任何不支持发布-订阅模式的存储系统，而不是像本例中所示的这种方式。
- en: '**Dimitri Fontaine on Databases**'
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Dimitri Fontaine 论数据库**'
- en: Dimitri is a skilled PostgreSQL Major Contributor who works at Citus Data and
    argues with other database gurus on the *pgsql-hackers* mailing list. We’ve shared
    a lot of open source adventures, and he’s been kind enough to answer some questions
    about what you should do when dealing with databases.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Dimitri是一个熟练的PostgreSQL主要贡献者，现任Citus Data的工程师，并在*pgsql-hackers*邮件列表上与其他数据库专家进行辩论。我们分享了许多开源冒险经历，他也很友善地回答了一些关于处理数据库时应该做什么的问题。
- en: '**What advice would you give to developers using RDBMSs as their storage backends?**'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**你会给使用RDBMS作为存储后端的开发者什么建议？**'
- en: RDBMSs were invented in the ’70s to solve some common problems plaguing every
    application developer at that time, and the main services implemented by RDBMSs
    were not simply data storage.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: RDBMS是在70年代发明的，用于解决当时困扰每个应用程序开发者的常见问题，RDBMS实现的主要服务不仅仅是数据存储。
- en: 'The main services offered by an RDBMS are actually the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: RDBMS提供的主要服务实际上如下：
- en: '**Concurrency:** Access your data for read or write with as many concurrent
    threads of execution as you want—the RDBMS is there to handle that correctly for
    you. That’s the main feature you want out of an RDBMS.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并发性：** 你可以使用任意数量的并发执行线程来访问数据进行读取或写入——RDBMS会正确处理这些操作。这正是你从RDBMS中希望获得的主要功能。'
- en: '**Concurrency semantics:** The details about the concurrency behavior when
    using an RDBMS are proposed with a high-level specification in terms of atomicity
    and isolation, which are maybe the most crucial parts of ACID (atomicity, consistency,
    isolation, durability). *Atomicity* is the property that between the time you
    `BEGIN` a transaction and the time you’re done with it (either `COMMIT` or `ROLLBACK`),
    no other concurrent activity on the system is allowed to know what you’re doing—whatever
    that is. When using a proper RDBMS, also include the Data Definition Language
    (DDL), for example, `CREATE TABLE` or `ALTER TABLE`. *Isolation* is all about
    what you’re allowed to notice of the concurrent activity of the system from within
    your own transaction. The SQL standard defines four levels of isolation, as described
    in the PostgreSQL documentation (*[http://www.postgresql.org/docs/9.2/static/transaction-iso.html](http://www.postgresql.org/docs/9.2/static/transaction-iso.html)*).'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并发语义：** 使用RDBMS时的并发行为细节，通过高层次的规范提出，涉及原子性和隔离性，可能是ACID（原子性、一致性、隔离性、持久性）中最关键的部分。*原子性*是指，在你`BEGIN`一个事务和事务完成时（无论是`COMMIT`还是`ROLLBACK`）之间，系统中其他任何并发活动都不能知道你在做什么——无论是什么。当使用一个合适的RDBMS时，还包括数据定义语言（DDL），例如`CREATE
    TABLE`或`ALTER TABLE`。*隔离性*则涉及你在自己事务内可以注意到的系统并发活动的内容。SQL标准定义了四种隔离级别，如PostgreSQL文档中所述（*
    [http://www.postgresql.org/docs/9.2/static/transaction-iso.html](http://www.postgresql.org/docs/9.2/static/transaction-iso.html)*）。'
- en: The RDBMS takes full responsibility for your data. So it allows the developer
    to describe their own rules for consistency, and then it will check that those
    rules are valid at crucial times such as at transaction commit or at statement
    boundaries, depending on the deferability of your constraints declarations.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: RDBMS对你的数据负全责。因此，它允许开发者描述自己的一致性规则，然后它会在关键时刻检查这些规则是否有效，比如在事务提交或语句边界时，具体取决于约束声明的延迟性。
- en: The first constraint you can place on your data is its expected input and output
    formatting, using the proper data type. An RDBMS will know how to work with much
    more than text, numbers, and dates and will properly handle dates that actually
    appear in a calendar in use today.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以对数据施加的第一个约束是其预期的输入和输出格式，使用正确的数据类型。关系数据库管理系统（RDBMS）能够处理比文本、数字和日期更多的内容，并且能够正确处理实际出现在今天日历中的日期。
- en: 'Data types are not just about input and output formats, though. They also implement
    behaviors and some level of polymorphism, as we all expect the basic equality
    tests to be data type specific: we don’t compare text and numbers, dates and IP
    addresses, arrays and ranges, and so on in the same way.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类型不仅仅涉及输入和输出格式，它们还实现了行为和某种程度的多态性，因为我们都期望基本的相等性测试是特定于数据类型的：我们不会以相同的方式比较文本和数字、日期和IP地址、数组和范围等。
- en: Protecting your data also means that the only choice for an RDBMS is to actively
    refuse data that doesn’t match your consistency rules, the first of which is the
    data type you’ve chosen. If you think it’s okay to have to deal with a date such
    as 0000-00-00 that never existed in the calendar, then you need to rethink.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 保护你的数据也意味着，RDBMS的唯一选择是主动拒绝不符合一致性规则的数据，其中第一个规则就是你选择的数据类型。如果你认为处理像 0000-00-00
    这样的日期是可以接受的，这个日期在日历中从未存在过，那么你需要重新考虑。
- en: The other part of the consistency guarantees is expressed in terms of constraints
    as in `CHECK` constraints, `NOT NULL` constraints, and constraint triggers, one
    of which is known as foreign key. All of that can be thought of as a user-level
    extension of the data type definition and behavior, the main difference being
    that you can choose to `DEFER` the enforcement of checking those constraints from
    the end of each statement to the end of the current transaction.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一致性保证的另一部分是通过约束来表达的，例如`CHECK`约束、`NOT NULL`约束和约束触发器，其中一个叫做外键。所有这些可以被看作是数据类型定义和行为的用户级扩展，主要区别在于你可以选择将约束检查的强制执行从每个语句的末尾推迟到当前事务的末尾，使用`DEFER`来实现这一点。
- en: 'The relational bits of an RDBMS are all about modeling your data and the guarantee
    that all tuples found in a relation share a common set of rules: structure and
    constraints. When enforcing that, we are enforcing the use of a proper explicit
    schema to handle our data.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 关系型数据库管理系统（RDBMS）的关系位主要是关于建模你的数据，并确保在关系中的所有元组共享一套共同的规则：结构和约束。当执行这些规则时，我们是在强制使用一个合适的显式模式来处理我们的数据。
- en: Working on a proper schema for your data is known as *normalization*, and you
    can aim for a number of subtly different normal forms in your design. Sometimes
    though, you need more flexibility than what is given by the result of your normalization
    process. Common wisdom is to first normalize your data schema and only then modify
    it to regain some flexibility. Chances are you actually don’t need more flexibility.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为你的数据制定一个合适的模式被称为*规范化*，你可以在设计中追求几个细微不同的规范形式。然而，有时你可能需要比规范化过程的结果提供更多的灵活性。常见的做法是首先规范化你的数据模式，然后再修改它以恢复一些灵活性。实际上，你很可能并不需要更多的灵活性。
- en: 'When you do need more flexibility, you can use PostgreSQL to try out a number
    of denormalization options: composite types, records, arrays, H-Store, JSON, or
    XML to name a few.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当你确实需要更多灵活性时，你可以使用PostgreSQL尝试多种反规范化选项：复合类型、记录、数组、H-Store、JSON或XML等。
- en: There’s a very important drawback to denormalization though, which is that the
    query language we’re going to talk about next is designed to handle rather normalized
    data. With PostgreSQL, of course, the query language has been extended to support
    as much denormalization as possible when using composite types, arrays or H-Store,
    and even JSON in recent releases.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，反规范化有一个非常重要的缺点，那就是我们接下来要讨论的查询语言是为处理相对规范化的数据而设计的。当然，使用PostgreSQL时，查询语言已被扩展，以支持尽可能多的反规范化，特别是在使用复合类型、数组、H-Store，甚至最近发布的JSON时。
- en: The RDBMS knows a lot about your data and can help you implement a very fine-grain
    security model, should you need to do so. The access patterns are managed at the
    relation and column level, and PostgreSQL also implements `SECURITY DEFINER` stored
    procedures, allowing you to offer access to sensible data in a very controlled
    way, much the same as with using saved user ID (SUID) programs.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: RDBMS了解你的数据，并且可以帮助你实现一个非常细粒度的安全模型，若你需要的话。访问模式在关系和列级别进行管理，PostgreSQL还实现了`SECURITY
    DEFINER`存储过程，允许你以一种非常受控的方式提供对敏感数据的访问，类似于使用保存的用户ID（SUID）程序的方式。
- en: The RDBMS offers to access your data using a SQL, which became the de facto
    standard in the ’80s and is now driven by a committee. In the case of PostgreSQL,
    lots of extensions are being added, with each and every major release allowing
    you to access a very rich DSL language. All the work of query planning and optimization
    is done for you by the RDBMS so that you can focus on a declarative query where
    you describe only the result you want from the data you have.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: RDBMS通过SQL提供数据访问，这在80年代成为事实上的标准，并且现在由一个委员会推动。在PostgreSQL的情况下，增加了许多扩展，每个主要版本都会让你访问一个非常丰富的DSL语言。所有查询规划和优化的工作都由RDBMS为你完成，这样你就可以专注于一个声明式查询，在这个查询中你只需要描述你想从数据中得到的结果。
- en: And that’s also why you need to pay close attention to the NoSQL offerings here,
    as most of those trendy products are in fact not removing just the SQL from the
    offering but a whole lot of other foundations that you’ve been trained to expect.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是为什么你需要特别关注这里的NoSQL产品，因为大多数这些流行的产品实际上并不是仅仅去除了SQL，而是移除了你习惯期望的许多其他基础设施。
- en: '**What advice would you give to developers using RDBMSs as their storage backends?**'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**你会给使用RDBMS作为存储后端的开发人员什么建议？**'
- en: My advice is to remember the differences between a *storage backend* and an
    RDBMS. Those are very different services, and if all you need is a storage backend,
    maybe consider using something other than an RDBMS.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我的建议是记住*存储后端*和RDBMS之间的区别。这两者是非常不同的服务，如果你所需要的仅仅是存储后端，或许可以考虑使用RDBMS以外的其他工具。
- en: Most often, though, what you really need is a full-blown RDBMS. In that case,
    the best option you have is PostgreSQL. Go read its documentation (*[https://www.postgresql.org/docs/](https://www.postgresql.org/docs/)*);
    see the list of data types, operators, functions, features, and extensions it
    provides. Read some usage examples on blog posts.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，最常见的需求是一个完整的关系数据库管理系统（RDBMS）。在这种情况下，最佳的选择是PostgreSQL。去阅读它的文档（* [https://www.postgresql.org/docs/](https://www.postgresql.org/docs/)*）；查看它提供的数据类型、运算符、函数、特性和扩展。阅读一些博客中的使用示例。
- en: Then consider PostgreSQL a tool you can leverage in your development and include
    it in your application architecture. Parts of the services you need to implement
    are best offered at the RDBMS layer, and PostgreSQL excels at being that trustworthy
    part of your whole implementation.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，可以将PostgreSQL视为你在开发中可以利用的工具，并将其纳入你的应用架构中。你需要实现的服务部分最好在RDBMS层面提供，而PostgreSQL在作为整个实现中值得信赖的一部分方面表现出色。
- en: '**What’s the best way to use or not use an ORM?**'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用或不使用ORM的最佳方式是什么？**'
- en: 'The ORM will best work for *CRUD* applications: create, read, update, and delete.
    The read part should be limited to a very simple `SELECT` statement targeting
    a single table, as retrieving more columns than necessary has a significant impact
    on query performances and resources used.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ORM最适合用于*CRUD*应用程序：创建、读取、更新和删除。读取部分应该限制在一个非常简单的`SELECT`语句上，目标是单一表，因为获取不必要的更多列会对查询性能和使用的资源产生重大影响。
- en: Any column you retrieve from the RDBMS and that you end up not using is pure
    waste of precious resources, a first scalability killer. Even when your ORM is
    able to fetch only the data you’re asking for, you still then have to somehow
    manage the exact list of columns you want in each situation, without using a simple
    abstract method that will automatically compute the fields list for you.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 从RDBMS中检索到的任何列，如果最终没有使用，都是对宝贵资源的浪费，这是一个初步的可扩展性杀手。即使你的ORM能够仅获取你请求的数据，你仍然需要以某种方式管理你在每种情况下需要的确切列列表，而不是使用一个简单的抽象方法，它会自动为你计算字段列表。
- en: The create, update, and delete queries are simple `INSERT`, `UPDATE`, and `DELETE`
    statements. Many RDBMSs offer optimizations that are not leveraged by ORMs, such
    as returning data after an `INSERT`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 创建、更新和删除查询是简单的`INSERT`、`UPDATE`和`DELETE`语句。许多RDBMS提供了ORM没有利用的优化，例如在`INSERT`之后返回数据。
- en: Furthermore, in the general case, a relation is either a table or the result
    of any query. It’s common practice when using an ORM to build relational mapping
    between defined tables and some model classes, or some other helper stubs.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在一般情况下，关系要么是一个表，要么是任何查询的结果。在使用ORM时，常见的做法是建立定义好的表与一些模型类或其他辅助代码之间的关系映射。
- en: If you consider the whole SQL semantics in their generalities, then the relational
    mapper should really be able to map any query against a class. You would then
    presumably have to build a new class for each query you want to run.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你考虑SQL语义的整体性，那么关系映射器实际上应该能够将任何查询映射到一个类。然后，你大概需要为每个你想运行的查询构建一个新的类。
- en: The idea when applied to our case is that you trust your ORM to do a better
    job than you at writing efficient SQL queries, even when you’re not giving it
    enough information to work out the exact set of data you are interested in.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中应用这个理念的方式是，你信任你的ORM比你自己写更高效的SQL查询，即使你没有提供足够的信息来确定你感兴趣的确切数据集。
- en: It’s true that, at times, SQL can get quite complex, though you’re not going
    to get anywhere near simplicity by using an API-to-SQL generator that you can’t
    control.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 的确，SQL有时可能会变得相当复杂，但通过使用一个你无法控制的API到SQL生成器，你是无法接近简单性的。
- en: 'However, there are two cases where you can relax and use your ORM, provided
    that you’re willing to accept the following compromise: at a later point, you
    may need to edit your ORM usage out of your codebase.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在两个情况下，你可以放松并使用 ORM，前提是你愿意接受以下妥协：稍后你可能需要从代码库中删除 ORM 的使用。
- en: '**Time to market:** When you’re really in a hurry and want to gain market share
    as soon as possible, the only way to get there is to release a first version of
    your application and idea. If your team is more proficient at using an ORM than
    handcrafting SQL queries, then by all means just do that. You have to realize,
    though, that as soon as you’re successful with your application, one of the first
    scalability problems you will have to solve is going to be related to your ORM
    producing really bad queries. Also, your usage of the ORM will have painted you
    into a corner and resulted in bad code design decisions. But if you’re there,
    you’re successful enough to spend some refactoring money and remove any dependency
    on the ORM, right?'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**市场上市时间：** 当你非常急需并希望尽快抢占市场份额时，唯一的方法就是发布应用程序和创意的第一个版本。如果你的团队更擅长使用 ORM 而非手动编写
    SQL 查询，那就尽管使用它。你必须意识到，一旦你的应用成功，最先需要解决的扩展性问题之一就是 ORM 生成的查询非常糟糕。同时，你使用 ORM 的方式可能已经将你限制在了一个死胡同，导致了糟糕的代码设计决策。但如果你已经走到这一步，说明你的应用已经足够成功，足以投入一些重构的资金来移除对
    ORM 的依赖，对吧？'
- en: '**CRUD application:** This is the real thing, where you are only editing a
    single tuple at a time and you don’t really care about performance, like for the
    basic admin application interface.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CRUD 应用：** 这是实际的操作，其中你一次只编辑一个元组，并且你并不关心性能，适用于基本的管理员应用界面。'
- en: '**What are the pros of using PostgreSQL over other databases when working with
    Python?**'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**在使用 Python 时，为什么选择 PostgreSQL 而不是其他数据库？**'
- en: 'Here are my top reasons for choosing PostgreSQL as a developer:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我选择 PostgreSQL 作为开发者的主要原因：
- en: '**Community support:** The PostgreSQL community is vast and welcoming to new
    users, and folks will typically take the time to provide the best possible answer.
    The mailing lists are still the best way to communicate with the community.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**社区支持：** PostgreSQL 的社区非常庞大且对新用户友好，大家通常会花时间提供最佳答案。邮件列表仍然是与社区沟通的最佳方式。'
- en: '**Data integrity and durability:** Any data you send to PostgreSQL is safe
    in its definition and your ability to fetch it again later.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据完整性和持久性：** 你发送到 PostgreSQL 的任何数据都能在其定义中安全存储，并且你能够在之后重新获取它。'
- en: '**Data types, functions, operators, arrays, and ranges:** PostgreSQL has a
    very rich set of data types that come with a host of operators and functions.
    It’s even possible to denormalize using arrays or JSON data types and still be
    able to write advanced queries, including joins, against those.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据类型、函数、操作符、数组和范围：** PostgreSQL 提供了一套非常丰富的数据类型，并且伴随有许多操作符和函数。即使是使用数组或 JSON
    数据类型进行反规范化，仍然可以编写高级查询，包括对这些数据进行连接。'
- en: '**The planner and optimizer:** It’s worth taking the time to understand how
    complex and powerful these are.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规划器和优化器：** 值得花时间了解这些组件的复杂性和强大功能。'
- en: '**Transactional DDL:** It’s possible to `ROLLBACK` almost any command. Try
    it now: just open your `psql` shell against a database you have and type in `BEGIN;
    DROP TABLE foo`; ROLLBACK;, where you replace foo with the name of a table that
    exists in your local instance. Amazing, right?'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事务性 DDL：** 几乎可以 `ROLLBACK` 任何命令。现在试试：只需打开 `psql` shell，连接到你拥有的数据库，然后输入 `BEGIN;
    DROP TABLE foo; ROLLBACK;`，其中将 foo 替换为本地实例中存在的一个表的名称。很神奇，对吧？'
- en: '**PL/Python (and others such as C, SQL, Javascript, or Lua):** You can run
    your own Python code on the server, right where the data is, so you don’t have
    to fetch it over the network just to process it and then send it back in a query
    to do the next level of `JOIN`.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PL/Python（以及其他语言，如 C、SQL、JavaScript 或 Lua）：** 你可以在服务器上运行自己的 Python 代码，数据就在那里，这样就不必通过网络提取数据进行处理，再发回查询进行下一步的
    `JOIN` 操作。'
- en: '**Specific indexing (GiST, GIN, SP-GiST, partial and functional):** You can
    create Python functions to process your data from within PostgreSQL and then index
    the result of calling that function. When you issue a query with a `WHERE` clause
    calling that function, it’s called only once with the data from the query; then
    it’s matched directly with the contents of the index.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**特定索引（GiST、GIN、SP-GiST、部分和函数索引）：** 你可以在 PostgreSQL 内部创建 Python 函数来处理数据，然后索引该函数调用的结果。当你发出带有
    `WHERE` 子句的查询并调用该函数时，函数仅会使用查询中的数据执行一次，然后直接与索引内容进行匹配。'
