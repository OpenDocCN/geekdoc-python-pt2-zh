- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Data Science in Other Languages
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 数据科学在其他语言中的应用
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: 'All of our business solutions so far have had one thing in common: they’ve
    used only Python. Python is standard in the world of data science, but it’s not
    the only language out there. The best data scientists are versatile and capable
    of writing code in multiple languages. This chapter contains a short introduction
    to both Structured Query Language (SQL) and R, two common languages that every
    good data scientist should know. This chapter isn’t a comprehensive overview of
    either language. It’s only a basic introduction that will enable you to recognize
    and write a few lines of SQL or R code.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的所有商业解决方案都有一个共同点：它们只使用了Python。Python是数据科学领域的标准语言，但它并不是唯一的语言。最优秀的数据科学家是多才多艺的，能够使用多种语言编写代码。本章简要介绍了结构化查询语言（SQL）和R语言，这两种常见语言是每个优秀数据科学家都应该掌握的。本章并不是对这两种语言的全面概述，而是一个基本介绍，帮助你识别和编写几行SQL或R代码。
- en: We’ll start the chapter by introducing a business scenario. Then we’ll go over
    some simple SQL code to set up a database and manipulate data within it. We’ll
    go on to discuss R and how to use it to perform simple operations and linear regressions.
    Instead of spending a lot of effort setting up environments for running SQL and
    R commands, you’ll learn how to run SQL and R commands from within a Python session.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将从介绍一个商业场景开始。接着，我们将介绍一些简单的SQL代码，来创建数据库并操作其中的数据。接下来，我们将讨论R语言以及如何使用它执行简单的操作和线性回归。你将学习如何在Python会话中运行SQL和R命令，而不是花费大量精力配置环境来运行SQL和R命令。
- en: Winning Soccer Games with SQL
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用SQL赢得足球比赛
- en: Imagine that you receive a job offer to be the manager of a European soccer
    team. This may seem like more of a sports scenario than a business scenario, but
    remember that sports is a business, one with billions of dollars of revenues worldwide
    every year. Teams hire managers to maximize their revenues and profits and make
    sure everything runs well.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你收到了一份作为欧洲足球队经理的工作邀请。这可能看起来更像是一个体育场景，而非商业场景，但请记住，体育也是一项商业，每年全球都有数十亿美元的收入。球队聘请经理是为了最大化他们的收入和利润，并确保一切运作顺利。
- en: 'One of the most important things every team needs to do from a business perspective
    is win games—teams that win often earn higher profits than teams that tend to
    lose. As a good data scientist, you know exactly what to do first to set yourself
    up for success in your new job: you start diving into and exploring data, and
    trying to learn what it takes to win soccer games.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 每个团队从商业角度来看需要做的一件最重要的事情就是赢得比赛——常常获胜的团队通常比那些常常输掉比赛的团队赚得更多。作为一名优秀的数据科学家，你知道如何为自己在新职位上的成功奠定基础：你开始深入数据，探索数据，试图了解赢得足球比赛所需的要素。
- en: Reading and Analyzing Data
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 阅读和分析数据
- en: 'You can download several files that contain data related to European soccer
    from the following URLs: [https://bradfordtuckfield.com/players.csv](https://bradfordtuckfield.com/players.csv),
    [https://bradfordtuckfield.com/games.csv](https://bradfordtuckfield.com/games.csv),
    and [https://bradfordtuckfield.com/shots.csv](https://bradfordtuckfield.com/shots.csv).
    The first file, *players.csv*, contains a list of professional soccer players,
    including their names and unique ID numbers. The next file, *games.csv*, contains
    detailed statistics related to thousands of individual soccer games, including
    which teams played, the number of goals scored, and much more. The third file,
    *shots.csv*, is the largest. It contains information about hundreds of thousands
    of individual shots taken during games, including who took the shot, which foot
    the player used, where the shot was taken, and the result of the shot (whether
    it was blocked, missed, or a goal).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从以下网址下载几个包含与欧洲足球相关的数据的文件：[https://bradfordtuckfield.com/players.csv](https://bradfordtuckfield.com/players.csv)，[https://bradfordtuckfield.com/games.csv](https://bradfordtuckfield.com/games.csv)，以及[https://bradfordtuckfield.com/shots.csv](https://bradfordtuckfield.com/shots.csv)。第一个文件，*players.csv*，包含了一份职业足球球员的名单，包括他们的名字和唯一的ID号。接下来的文件，*games.csv*，包含了与成千上万场足球比赛相关的详细统计数据，包括参赛的队伍、进球数以及更多信息。第三个文件，*shots.csv*，是最大的，包含了关于数十万次比赛射门的信息，包括谁进行了射门、球员使用哪只脚、射门发生的地点以及射门的结果（是否被封堵、是否偏出或是否进球）。
- en: If you can do rigorous analysis of this data, you can get a deep understanding
    of European soccer and have much of the most important knowledge you’ll need to
    succeed as a manager. (The original sources of this public domain data include
    [https://www.kaggle.com/technika148/football-database](https://www.kaggle.com/technika148/football-database),
    [https://understat.com](https://understat.com), and [https://www.football-data.co.uk](https://www.football-data.co.uk).)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能够对这些数据进行严格分析，你将能深入了解欧洲足球，并掌握作为经理成功所需的大部分重要知识。（这些公共领域数据的原始来源包括[https://www.kaggle.com/technika148/football-database](https://www.kaggle.com/technika148/football-database)、[https://understat.com](https://understat.com)
    和 [https://www.football-data.co.uk](https://www.football-data.co.uk)。）
- en: 'Let’s start by reading these files. We’ll use Python here, but don’t worry,
    we’ll be using SQL soon:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从读取这些文件开始。我们这里使用 Python，但别担心，我们很快会使用 SQL：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'So far, this should look familiar. It’s standard Python code for reading *.csv*
    files. After importing pandas, we read in datasets that have information about
    European soccer. You can see that we read all three datasets that we’ll be working
    with here: `players`, which contains data about individual players; `games`, which
    contains data about individual games; and `shots`, which contains data about shots
    that players took during games.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这应该看起来很熟悉。这是读取 *.csv* 文件的标准 Python 代码。在导入 pandas 后，我们读取包含关于欧洲足球信息的数据集。你可以看到，我们读取了将在此使用的所有三个数据集：`players`，包含有关个人球员的数据；`games`，包含关于单场比赛的数据；以及
    `shots`，包含球员在比赛中射门的数据。
- en: 'Let’s look at the first few rows of each of these datasets:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下这些数据集的前几行：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `players` table has only two columns, and when you run `print(players.head())`,
    you should see the top five rows of both of them:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`players` 表只有两列，当你运行`print(players.head())`时，你应该能够看到它们的前五行：'
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `shots` data is more detailed. When you run `print(shots.head())`, you
    should see its top five rows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`shots` 数据更为详细。当你运行`print(shots.head())`时，你应该能够看到它的前五行：'
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can see that by default, the pandas package has omitted some columns that
    don’t fit in the output console. You can see a list of all the columns in the
    dataset by running `print(shots.columns)`, which will show you the following list:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，默认情况下，pandas 包省略了一些在输出控制台中无法显示的列。你可以通过运行`print(shots.columns)`来查看数据集中所有列的列表，执行后将显示如下列表：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We have detailed data about each shot. We know the foot that was used to shoot
    (in the `shotType` column), the results of the shot (in the `shotResult` column),
    and the position at which it was taken (in the `positionX` and `positionY` columns).
    But one thing that’s not stated explicitly in this data is the name of the player
    who took the shot. All we have is the `shooterID`, a number. If we want to find
    out the name of the person who took the shot, we have to look it up: find the
    `shooterID` number in the `shots` data, then look at the `players` dataset to
    find the name of the player whose ID matches that `shooterID` number.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有关于每次射门的详细数据。我们知道使用哪只脚进行射门（在 `shotType` 列中），射门的结果（在 `shotResult` 列中），以及射门的位置（在
    `positionX` 和 `positionY` 列中）。但有一点数据中没有明确提到，那就是射门球员的姓名。我们所拥有的只是 `shooterID`，一个数字。如果我们想知道谁射门了，我们必须查找：首先在
    `shots` 数据中找到 `shooterID`，然后在 `players` 数据集中查找与该 `shooterID` 匹配的球员姓名。
- en: The first shot, for example, was taken by the player with `shooterID` 554\.
    If we want to know the name of that player, we need to look at the `players` dataset.
    If you scroll through the `players` data, or if you run `print(players.loc[7,'name'])`
    in Python, you can see that this player is Juan Mata.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，第一脚射门是由 `shooterID` 为 554 的球员完成的。如果我们想知道这名球员的名字，我们需要查找 `players` 数据集。如果你浏览
    `players` 数据，或者在 Python 中运行 `print(players.loc[7,'name'])`，你会看到这名球员是胡安·马塔（Juan
    Mata）。
- en: Getting Familiar with SQL
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 熟悉 SQL
- en: 'Let’s go over some SQL code that will enable you to do these kinds of lookups.
    We’ll start by looking at SQL code, and we’ll discuss how to run the code later.
    Individual SQL commands are usually called SQL *queries*. The following code is
    a SQL query that will show you the entire `players` dataset:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一些 SQL 代码，这些代码将帮助你进行此类查找。我们先从 SQL 代码开始，然后再讨论如何执行这些代码。单独的 SQL 命令通常被称为 SQL
    *查询*。以下代码是一个 SQL 查询，它将展示整个 `players` 数据集：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Often, short SQL queries are simple to interpret as long as you know English.
    In this snippet, `SELECT` tells us that we’re selecting data. The `FROM` `playertable`
    text at the end of the query means that we’ll be selecting data from the table
    called `playertable`. Between `SELECT` and `FROM playertable` is where we’re supposed
    to specify the columns we want to select from the `playertable` data. The asterisk
    (`*`) is a shortcut that means that we want to select all the columns of the `playertable`
    table. The semicolon (`;`) tells SQL that we’ve finished this particular query.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，短小的 SQL 查询只要你懂英语，就很容易理解。在这个代码片段中，`SELECT` 告诉我们我们正在选择数据。查询末尾的 `FROM` `playertable`
    表示我们将从名为 `playertable` 的表中选择数据。在 `SELECT` 和 `FROM playertable` 之间，我们需要指定要从 `playertable`
    表中选择的列。星号（`*`）是一个快捷方式，表示我们要选择 `playertable` 表中的所有列。分号（`;`）告诉 SQL 我们已经完成了这个特定的查询。
- en: 'So, this SQL query selects our entire `players` table. If you don’t want to
    select all the columns of the data, you can replace the `*` with the names of
    one or more columns. For example, both of the following are also valid SQL queries:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这个 SQL 查询选择了整个 `players` 表。如果你不想选择所有的列，你可以用一个或多个列名替换 `*`。例如，以下两个查询也是有效的 SQL
    查询：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The first query will select only the `playerID` column from the `playertable`.
    The second will select both the `playerID` and the `name` columns from the `playertable`
    table—the output we get from specifying that we want both columns by name is the
    same as the output we get from writing an asterisk.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个查询只会从 `playertable` 表中选择 `playerID` 列。第二个查询会从 `playertable` 表中选择 `playerID`
    和 `name` 两列——我们指定要选择这两列的输出结果和使用星号时的输出结果是一样的。
- en: You may have noticed that our SQL queries use all caps for their keywords. This
    is a common practice when writing SQL queries, though it’s not technically required
    in most environments. We’ll do it to follow convention.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到我们的 SQL 查询中，关键字都是大写的。这是编写 SQL 查询时的一种常见做法，虽然在大多数环境中它并不是强制要求的。我们这样做是为了遵循约定。
- en: Setting Up a SQL Database
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置 SQL 数据库
- en: 'If you paste the preceding SQL queries directly into a Python session, they
    won’t run correctly; they’re not Python code. If you’re running SQL frequently,
    you will probably want to set up an environment that’s designed for editing and
    running SQL queries. However, this is a Python book, and we don’t want to get
    you bogged down in the details of setting up a SQL environment. Instead, let’s
    go over a few steps that will allow you to run SQL queries directly in Python.
    You can start by running the following commands in Python:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将前面的 SQL 查询直接粘贴到 Python 会话中，它们将无法正确运行；它们不是 Python 代码。如果你经常运行 SQL 查询，你可能希望设置一个专门用于编辑和运行
    SQL 查询的环境。然而，这是一本 Python 书，我们不想让你陷入设置 SQL 环境的细节中。相反，让我们讲解几个步骤，帮助你直接在 Python 中运行
    SQL 查询。你可以通过在 Python 中运行以下命令来开始：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here, we import the SQLite3 package, which allows us to run SQL queries in
    Python. SQL is a language that’s designed to work with databases, so we need to
    use SQLite3 to connect to a database. On the second line, we tell SQLite3 to connect
    to a database called `soccer.db`. You probably don’t have a database on your computer
    called `soccer.db`, so there may be nothing for SQLite3 to connect to. That’s
    all right, because the SQLite3 module is very helpful: when we specify a database
    we want to connect to, it will connect to the database if it exists, and if we
    try to connect to a database that doesn’t exist, it will create the database for
    us and then connect to it.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们导入了 SQLite3 包，它允许我们在 Python 中运行 SQL 查询。SQL 是一种与数据库交互的语言，因此我们需要使用 SQLite3
    来连接数据库。在第二行，我们告诉 SQLite3 连接到一个名为 `soccer.db` 的数据库。你可能电脑上没有名为 `soccer.db` 的数据库，所以
    SQLite3 可能没有可以连接的数据库。这没关系，因为 SQLite3 模块非常有用：当我们指定一个要连接的数据库时，如果该数据库存在，它会连接到该数据库；如果数据库不存在，它会为我们创建一个新的数据库并连接到它。
- en: Now that we’re connected to our database, we need to define a *cursor* to access
    this database. You can think of this cursor as similar to the cursor you use on
    your computer; it helps you select and manipulate objects. If that’s not clear
    to you now, don’t worry. The way we use this cursor will become clearer later.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经连接到数据库，我们需要定义一个 *游标* 来访问这个数据库。你可以把这个游标看作类似于你在电脑上使用的鼠标光标，它帮助你选择和操作对象。如果你现在不理解这一点，也不要担心。稍后我们会更清楚地展示如何使用这个游标。
- en: 'Now that we have a database, we want to fill it up. Usually, a database contains
    a collection of tables, but our `soccer.db` database is currently empty. The three
    pandas dataframes we’ve worked with so far can all be saved to our database as
    tables. We can add the `players` dataframe to our database with one line:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个数据库，我们希望将其填充。通常，数据库包含多个表，但我们的`soccer.db`数据库目前是空的。到目前为止，我们处理的三个pandas数据框都可以作为表格保存到数据库中。我们可以通过一行代码将`players`数据框添加到数据库中：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, we use the `to_sql()` method to push our `players` dataframe to the database’s
    `playertable` table. We use the connection we created before, called `conn`, which
    ensures that the table gets pushed to our `soccer.db` database. Now the players
    data is stored in our database instead of being accessible only as a pandas dataframe
    in our Python session.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`to_sql()`方法将我们的`players`数据框推送到数据库的`playertable`表中。我们使用之前创建的连接`conn`，它确保该表被推送到我们的`soccer.db`数据库中。现在，玩家数据被存储在我们的数据库中，而不是仅仅作为pandas数据框在Python会话中访问。
- en: Running SQL Queries
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行SQL查询
- en: 'We’re finally ready to run our SQL query on our data. This is Python code that
    will run our SQL query:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于准备好在数据上运行SQL查询了。以下是运行SQL查询的Python代码：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can see that the cursor we created, `curr`, is finally useful. The cursor
    is the object we’ll use to execute SQL queries on our data. In this case, we execute
    a simple query that selects the entire table called `playertable`. It’s important
    to note that this has selected the data, but it hasn’t displayed it. If we want
    to actually see the data that we selected, we need to print it to our console:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我们创建的游标`curr`终于派上用场了。游标是我们用来在数据上执行SQL查询的对象。在这种情况下，我们执行了一个简单的查询，选择了名为`playertable`的整个表。需要注意的是，这只选择了数据，但并没有显示它。如果我们想要实际查看选择的数据，我们需要将其打印到控制台：
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The cursor has selected the data and pushed it to your Python session’s memory,
    but we need to use the `fetchall()` method to access this data. When you run `fetchall()`,
    it selects a list of rows. That’s why we print each row individually in a `for`
    loop. The `playertable` table has thousands of rows, and you may not want to print
    all of them to your screen at once. You can limit the number of rows returned
    by your query by adding a `LIMIT` clause:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 游标已选择数据并将其推送到Python会话的内存中，但我们需要使用`fetchall()`方法来访问这些数据。当你运行`fetchall()`时，它会选择一组行。这就是为什么我们在`for`循环中逐行打印每一行的原因。`playertable`表有成千上万的行，你可能不希望一次性将所有行打印到屏幕上。你可以通过添加`LIMIT`子句来限制查询返回的行数：
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here, we run the same code as before, adding only seven characters: `LIMIT
    5`. By adding `LIMIT 5` to the SQL query, we limit the rows that are returned
    to only the first five. Since we get only the top five rows in the table, printing
    them to the screen becomes easier. This shows us the same data as we see when
    we run `print(players.head())` when we’re using pandas in Python. But be careful:
    in this case, `LIMIT 5` will give us the top five rows, but in other database
    environments, it will give you a random five rows. You can depend on getting five
    rows from the `LIMIT 5` clause, but you can’t always be sure which five you’ll
    get.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们运行与之前相同的代码，只是添加了七个字符：`LIMIT 5`。通过将`LIMIT 5`添加到SQL查询中，我们将返回的行数限制为仅前五行。由于我们只获取表中的前五行，打印它们到屏幕上变得更容易。这显示了我们在使用pandas时运行`print(players.head())`时看到的数据。但要小心：在这种情况下，`LIMIT
    5`将返回前五行，但在其他数据库环境中，它可能会随机返回五行。你可以依赖于从`LIMIT 5`子句中获得五行，但不能总是确定会得到哪五行。
- en: 'We often want only particular subsets of our data. For example, what if we
    want to find the player with a particular ID:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常只想要数据的特定子集。例如，假设我们想要查找具有特定ID的玩家：
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here, we run much of the same code, but we add a `WHERE` clause. Instead of
    selecting the whole table, we select only rows for which a particular condition
    is true. The condition we’re interested in is `playerID=554`. The output shows
    us one row, and that row tells us that the player with `playerID` equal to 554
    is named Juan Mata. This tells us what we wanted to know, that Juan Mata is the
    person who took the first shot recorded in the data. You should be starting to
    notice a pattern here: when creating SQL queries, we start with a short query
    that selects a whole table, and then we add *clauses* to the query (like the `LIMIT`
    clause or `WHERE` clause we added here) to refine the results we get. SQL queries
    consist of many clauses, each of which has an effect on the data the query selects.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们运行了大部分相同的代码，但我们添加了一个`WHERE`子句。我们不再选择整个表格，而只选择那些满足特定条件的行。我们感兴趣的条件是`playerID=554`。输出显示我们一行数据，告诉我们`playerID`等于554的玩家叫Juan
    Mata。这告诉我们我们想知道的信息：Juan Mata是数据中记录的第一次射门的球员。你应该开始注意到一个模式：在创建SQL查询时，我们从一个选择整个表格的简短查询开始，然后添加*子句*（就像我们在这里添加的`LIMIT`子句或`WHERE`子句），以精炼我们得到的结果。SQL查询由多个子句组成，每个子句都会影响查询选择的数据。
- en: 'We can use `WHERE` clauses to select all sorts of conditions. For example,
    we can use a `WHERE` clause to select the ID of a player with a particular name:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`WHERE`子句来选择各种条件。例如，我们可以使用`WHERE`子句来选择具有特定名字的玩家的ID：
- en: '[PRE13]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can also use the `AND` operator to specify multiple conditions:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`AND`操作符来指定多个条件：
- en: '[PRE14]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In this case, we select the rows of the `playertable` that satisfy two conditions
    simultaneously: both `playerID>100` and `playerID <200`.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们选择了满足两个条件的`playertable`中的行：`playerID>100`和`playerID <200`。
- en: 'You may want to look up a name in a table, but feel uncertain about the spelling.
    In that case, you can use the `LIKE` operator:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想查找表格中的一个名字，但不确定拼写。在这种情况下，你可以使用`LIKE`操作符：
- en: '[PRE15]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this case, we’re using the percent character (`%`) as a *wildcard*, meaning
    that it stands for any collection of characters. You may notice that this is similar
    to the way we used the asterisk earlier in the query (`SELECT *`). We use `*`
    to mean all columns and `%` to mean any possible character. But though these uses
    are similar (both representing unknown values), they’re not interchangeable, and
    there are two important differences. First, the `*` can be used as part of a query
    itself, while the `%` can be used only as part of a string of characters. Second,
    the `*` is used to refer to columns, and the `%` is used to refer to other characters.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用百分号字符(`%`)作为*通配符*，意味着它代表任何字符集合。你可能会注意到，这与我们在查询中早些时候使用星号(`*`)的方式类似（`SELECT
    *`）。我们使用`*`表示所有列，而`%`表示任何可能的字符。尽管这两种用法相似（都表示未知值），但它们并不能互换使用，并且有两个重要的区别。首先，`*`可以作为查询本身的一部分使用，而`%`只能作为字符串的一部分使用。其次，`*`用于指代列，而`%`用于指代其他字符。
- en: 'When you look at the results of this code, you can see that we’ve found several
    players whose names start with *Juan M*:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当你查看这段代码的结果时，你会发现我们找到了几个名字以*Juan M*开头的玩家：
- en: '[PRE16]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If what we’ve done so far feels familiar, it should. The string we searched
    for, `Juan M%`, is a regular expression, just like the regular expressions we
    covered in Chapter 8. You can see that every programming language has its own
    rules and syntax, but huge overlaps occur across these languages. Most languages
    allow the use of regular expressions to search for text. Many languages allow
    you to create tables and select their top five rows. Often, when you learn a new
    programming language, you’re not learning totally new capabilities, but rather
    learning to do things you’ve already done in new ways.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果到目前为止我们做的事情看起来很熟悉，那是正常的。我们搜索的字符串`Juan M%`是一个正则表达式，就像我们在第8章中讨论的正则表达式一样。你可以看到，每种编程语言都有自己的规则和语法，但这些语言之间有很大的重叠。大多数语言都允许使用正则表达式来搜索文本。许多语言允许你创建表格并选择它们的前五行。通常，当你学习一门新的编程语言时，你并不是在学习完全新的功能，而是在学习以新的方式做你已经做过的事情。
- en: You can create and work with tables by using Python and pandas, as well as SQL.
    The advantage of using SQL is that in many cases, SQL can be faster, more reliable,
    and more secure than pandas. It also may have compatibility with some programs
    that do not allow you to use Python and pandas.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用Python和pandas以及SQL来创建和操作表格。使用SQL的优势在于，在许多情况下，SQL比pandas更快、更可靠、更安全。它还可能与一些不允许你使用Python和pandas的程序兼容。
- en: Combining Data by Joining Tables
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过连接表格来组合数据
- en: 'So far, we’ve worked with our players table. But we can also work with our
    other tables. Let’s read in our `games` table, push it to our soccer database,
    and then select its top five rows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用了我们的球员表。但我们也可以使用其他的表。让我们读取`games`表，将其推送到我们的足球数据库中，然后选择前五行：
- en: '[PRE17]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This snippet does everything we did previously with the `players` table: reads
    it, converts it to a SQL database table, and selects rows from it. We can do the
    same thing yet again, for our `shots` table:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码片段完成了我们之前在`players`表中做的所有操作：读取它，将其转换为SQL数据库表，并从中选择行。我们可以再次对`shots`表做相同的事情：
- en: '[PRE18]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, our database has three tables: one for players, one for shots, and one
    for games. This situation is a little new to us. Throughout most of this book,
    we’ve had data conveniently gathered into a single table in each of our chapters.
    However, the data you’re interested in could be spread across several tables.
    In this case, we already noticed that our `shots` table has detailed information
    about individual shots, but it doesn’t have the name of the player who took each
    shot. To find out the name of the player who took a shot, we have to find the
    `shooterID` in the `shots` table and then look up this ID number in the `players`
    table.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的数据库中有三张表：一张是球员表，一张是投篮表，另一张是比赛表。这对我们来说有点新颖。在本书的大部分内容中，我们的数据都集中在每个章节中的单一表格中。然而，你感兴趣的数据可能会分散在多个表中。在这种情况下，我们已经注意到我们的`shots`表包含了关于每次投篮的详细信息，但没有包含投篮球员的名字。为了找出投篮球员的名字，我们需要在`shots`表中查找`shooterID`，然后在`players`表中查找该ID号。
- en: We have to do matching and lookups across multiple tables. If we have to do
    this only once or twice, manually scrolling through tables is probably not a big
    deal. But if we have to get the names of players who took thousands of shots,
    using manual lookups over and over again will become extremely time-consuming.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在多张表之间进行匹配和查找。如果我们只需要做一两次，手动滚动查看表格可能不是大问题。但如果我们需要获取投篮了数千次的球员名字，反复使用手动查找将变得非常耗时。
- en: Instead, imagine if we could automatically combine the information in these
    two tables. This is a natural specialty of SQL. We can see what we need to do
    in [Figure 11-1](#figure11-1).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，假设我们能自动将这两张表中的信息结合起来。这是SQL的一个自然特性。我们可以在[图11-1](#figure11-1)中看到我们需要做的事情。
- en: '![](image_fi/502888c11/f11001.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502888c11/f11001.png)'
- en: 'Figure 11-1: Joining two tables together, so lookups become easier and faster'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-1：连接两张表，使得查找变得更加容易和快速
- en: 'You can see that if we join two tables together, we no longer have to look
    at multiple tables to find all the information we need. Each row contains not
    only the information from the `shots` table but also the shooter name from the
    `players` table. We’re going to accomplish the joining illustrated in [Figure
    11-1](#figure11-1) by using a SQL query:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，如果我们将两张表连接起来，就不再需要查看多个表来获取我们需要的所有信息。每一行不仅包含来自`shots`表的信息，还包含来自`players`表的投篮球员名字。我们将通过使用SQL查询来完成[图11-1](#figure11-1)所示的连接操作：
- en: '[PRE19]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Let’s look at this snippet, one piece at a time. We start with `SELECT *`, just
    like our previous SQL queries. Next, we have `FROM shotstable`, indicating that
    we’ll be selecting from the table called `shotstable`. However, that’s where the
    difference starts. We see `shotstable JOIN` `playertable`, indicating that we’re
    not going to select only from the `shotstable`, but instead want to join these
    two tables and select from the combined table.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行查看这个代码片段。我们从`SELECT *`开始，就像我们之前的SQL查询一样。接下来是`FROM shotstable`，表示我们将从名为`shotstable`的表中选择数据。然而，差异从这里开始。我们看到`shotstable
    JOIN playertable`，这意味着我们不仅仅从`shotstable`中选择数据，而是想将这两张表连接起来，并从合并后的表中选择数据。
- en: But how should they be joined? We need to specify the way to join these two
    tables. Specifically, we’re going to join these tables by looking up where the
    IDs match. Every place where the `shotstable` column called `shooterID` is the
    same as the `playertable` column called `playerID`, we know that our rows match,
    and we can join them together. Finally, we add `LIMIT 5`, indicating that we want
    to see only the top five rows so the quantity of output rows isn’t overwhelming.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这两张表应该如何连接呢？我们需要指定连接这两张表的方式。具体来说，我们将通过查找ID是否匹配来连接这些表。每当`shotstable`表中的`shooterID`与`playertable`表中的`playerID`匹配时，我们就知道我们的行是匹配的，并可以将它们连接起来。最后，我们添加`LIMIT
    5`，表示我们只想看到前五行，以避免输出的行数过多。
- en: 'We can run this SQL query in Python as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在Python中运行以下SQL查询：
- en: '[PRE20]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here, we run the SQL query explained previously on the tables in our database.
    Our SQL query joins our tables together in the way shown in [Figure 11-1](#figure11-1).
    In that figure, you can see that for every shooter ID, we found the player with
    a matching player ID and added that player’s name to the matching row of the joined
    table. Our query does the same thing: since we specify `WHERE shotstable.shooterID=playertable.playerID`,
    it will find all matches between `shooterID` values (from the `shotstable`) and
    `playerID` values (from the `playertable`). After finding those matches, it will
    combine information from rows that match, and the final result will be a joined
    table with more complete information.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们运行了前面解释的 SQL 查询，查询的是我们数据库中的表格。我们的 SQL 查询以 [图 11-1](#figure11-1) 中所示的方式将表格连接在一起。在该图中，你可以看到，对于每个投篮者
    ID，我们找到了与之匹配的球员 ID，并将该球员的名字添加到了连接表格的匹配行中。我们的查询也做了同样的事情：由于我们指定了 `WHERE shotstable.shooterID=playertable.playerID`，它会查找
    `shooterID`（来自 `shotstable`）和 `playerID`（来自 `playertable`）之间的所有匹配项。在找到这些匹配项后，它会将匹配行中的信息结合在一起，最终的结果将是一个包含更多完整信息的连接表格。
- en: 'After we run our query, we print out the rows that the query has returned.
    Overall, we’ve followed the same process we followed before: executing a query
    with the cursor, then fetching what we selected and printing it to the console.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行查询后，我们会打印出查询返回的行。总体而言，我们遵循了之前相同的流程：使用光标执行查询，然后获取所选的数据并将其打印到控制台。
- en: 'The output looks like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下所示：
- en: '[PRE21]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You can see that this output shows the data we want: shots, combined with information
    about the players who made the shots (their names are the last element of each
    row). Joining tables in this way can be valuable to enable advanced analyses like
    the ones we’ve done in previous chapters.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，输出结果展示了我们想要的数据：投篮数据，以及关于投篮球员的信息（球员的名字是每行的最后一个元素）。以这种方式连接表格可以为进行更复杂的分析提供有价值的数据支持，就像我们在前几章中所做的那样。
- en: Joining tables may seem simple, but the process has many subtleties that you
    should learn about if you want to become great at SQL. For example, what happens
    if you have a shot with an ID that doesn’t appear in the `players` table? Or,
    what if two players have the same ID—how will we know which player took a shot
    that had their ID assigned to it? By default, SQL performs joining with `INNER
    JOIN`. An inner join will return nothing if no player ID matches a particular
    shooter ID; it will give you only rows where it knows exactly which player took
    a shot. But SQL provides other types of joins, and each uses different logic and
    follows different rules.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 连接表格看起来可能很简单，但这个过程有很多细微之处，如果你想在 SQL 上做到精通，这些细节是你需要了解的。例如，如果你有一个 ID 不出现在 `players`
    表中的投篮记录会发生什么？或者，如果两个球员有相同的 ID——我们如何知道哪个球员投出了那个 ID 的投篮？默认情况下，SQL 使用 `INNER JOIN`
    来执行连接。如果没有球员 ID 与特定的投篮者 ID 匹配，内连接将不会返回任何结果；它只会返回那些能够精确知道是哪个球员投篮的行。但 SQL 还提供了其他类型的连接，每种连接使用不同的逻辑并遵循不同的规则。
- en: This is not a SQL book, so we won’t go into every detail of the language and
    every type of join. When you study SQL more deeply, you’ll learn that advanced
    SQL capabilities usually consist of more and more sophisticated ways to select
    data and join tables. For now, you can feel proud that you’re able to do basic
    SQL queries. You’re able to put data in a database, select data from tables, and
    even join tables together.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一本 SQL 书籍，因此我们不会深入讨论 SQL 语言的每个细节以及每种连接方式。当你深入学习 SQL 时，你会了解到，SQL 的高级功能通常包括越来越复杂的选择数据和连接表格的方式。目前，你可以为自己感到自豪，因为你已经能够执行基本的
    SQL 查询了。你能够将数据存入数据库，从表格中选择数据，甚至将多个表格连接起来。
- en: Winning Soccer Games with R
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 R 赢得足球比赛
- en: R is another language that can be useful for a data science career. Let’s go
    over how to run R commands that will help you with your soccer management career.
    Just as we did with SQL, we can run our R commands from within a Python session
    instead of worrying about setting up an R environment. In many ways, R is similar
    to Python, so after gaining Python skills for data science, you may find that
    picking up R skills is less challenging.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: R 是另一种对数据科学职业非常有用的语言。让我们来学习如何运行一些 R 命令，这些命令将帮助你在足球管理的职业生涯中取得成功。就像我们使用 SQL 一样，我们可以在
    Python 会话中运行 R 命令，而不必担心设置 R 环境。在许多方面，R 与 Python 非常相似，因此在掌握 Python 数据科学技能之后，你会发现掌握
    R 技能相对容易一些。
- en: Getting Familiar with R
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 熟悉 R 语言
- en: 'Let’s start by looking at some R code. Just as we did with SQL queries, we’ll
    start by looking at the R code before running it:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看一下一些 R 代码。就像我们对 SQL 查询的处理一样，我们也先看一下 R 代码，然后再执行它：
- en: '[PRE22]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The first line defines a variable called `my_variable`. If we were writing Python,
    the equivalent statement would be `my_variable=512`. In R, we use `<-` instead
    of `=`, because in R, `<-` is the *assignment operator*—the collection of characters
    used to define the values of variables. The `<-` characters are meant to resemble
    an arrow pointing from right to left, indicating that the number 512 is being
    pushed from the right to be assigned as the value of `my_variable`. After we assign
    the variable, we can add to it, or print it out, or do anything else we want with
    it. In our snippet, we print out the value of our variable plus 12 by writing
    `print(my_variable+12)`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行定义了一个名为 `my_variable` 的变量。如果我们在写 Python，等价的语句将是 `my_variable=512`。在 R 中，我们使用
    `<-` 而不是 `=`，因为在 R 中，`<-` 是 *赋值运算符*，它是用于定义变量值的字符集合。`<-` 字符的形状像一支箭头，指示数字 512 从右侧传递并被赋值给
    `my_variable`。在赋值之后，我们可以对变量进行加法运算、打印它，或做任何我们想做的操作。在我们的代码片段中，我们通过 `print(my_variable+12)`
    打印出变量的值加上 12 的结果。
- en: 'Just like when we were running SQL queries, you may wonder: How can we run
    this R code? If you’d like, you can download R and set up an R environment where
    this code can be run. But instead, we can run it from within the comfort of our
    Python session, after some straightforward preparation. Let’s start by importing
    a module we need:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们运行 SQL 查询时一样，你可能会想：我们如何运行这段 R 代码？如果你愿意，可以下载 R 并设置一个可以运行这段代码的 R 环境。但我们也可以通过一些简单的准备工作，在
    Python 会话中直接运行它。让我们从导入一个需要的模块开始：
- en: '[PRE23]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In this case, the rpy2 package will be helpful for running R commands within
    a Python session. Now that we’ve imported our package, running R code is a breeze:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，rpy2 包将帮助我们在 Python 会话中运行 R 命令。现在我们已经导入了这个包，运行 R 代码变得轻松简单：
- en: '[PRE24]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This is similar to what we did to run SQL code. We can use the `robjects.r()`
    function to run any R code within a Python session. You can see that the output
    shows 524, the result of the addition we did in the code.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们之前运行 SQL 代码的方法类似。我们可以使用 `robjects.r()` 函数在 Python 会话中运行任何 R 代码。你可以看到输出显示了
    524，这是我们在代码中做加法运算的结果。
- en: 'So far, we’ve run simple R code, but nothing related to your soccer management
    job. Let’s run R code related to our soccer data, as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经运行了一些简单的 R 代码，但都没有涉及到你在足球管理工作中需要的内容。接下来，让我们运行一些与我们的足球数据相关的 R 代码，如下所示：
- en: '[PRE25]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, the first line reads our *players.csv* file, using the `read.csv()` command.
    We store the data in the `players` variable by using the same assignment operator
    as before (`<-`). In the second line, we print the top few rows of the data.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，第一行使用 `read.csv()` 命令读取我们的 *players.csv* 文件。我们通过使用和之前相同的赋值运算符（`<-`）将数据存储在
    `players` 变量中。在第二行，我们打印出数据的前几行。
- en: By looking at this R code, you can see some differences between R and Python.
    In Python, we use `pd.read_csv()`, and in R, we use `read.csv()`. Both are functions
    for reading *.csv* files, but there are small differences in the way they’re written.
    Similarly, in Python, we need to use `players.head()` to get the top rows of the
    data. In R, we use `head(players)`. When we’re working with pandas datasets, the
    `head()` method gives us the top five rows. But in R, the `head()` function gives
    the top six rows. R and Python have many similarities, but they are not identical.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看这段 R 代码，你可以看到 R 和 Python 之间的一些差异。在 Python 中，我们使用 `pd.read_csv()`，而在 R 中，我们使用
    `read.csv()`。这两个函数都用于读取 *.csv* 文件，但在写法上有一些小的差别。类似地，在 Python 中，我们需要使用 `players.head()`
    来获取数据的前几行。而在 R 中，我们使用 `head(players)`。当我们使用 pandas 数据集时，`head()` 方法返回前五行数据。但在
    R 中，`head()` 函数返回前六行。R 和 Python 有许多相似之处，但它们并不完全相同。
- en: 'We can read our other tables in the same way:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以相同的方式读取其他表格：
- en: '[PRE26]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This time, we read and print the top few rows of the `shots` data. We can also
    print out the top few elements of particular columns of our data:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们读取并打印出 `shots` 数据的前几行。我们还可以打印出数据中特定列的前几个元素：
- en: '[PRE27]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In R, the dollar sign (`$`) is used to refer to columns by name. This snippet
    prints out the head (top six elements) of the `minute` and `positionX` columns
    in our `shots` data. The `minute` column has the following top six elements:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在 R 中，美元符号（`$`）用来通过名称引用列。此代码片段打印出 `shots` 数据中 `minute` 和 `positionX` 列的前六个元素。`minute`
    列的前六个元素如下：
- en: '[PRE28]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'These are the minutes at which the first six shots (in our data) were taken.
    The first six elements of `positionX` are these:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们数据中前六次拍摄的时间点。`positionX` 的前六个元素如下：
- en: '[PRE29]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: These are the x-positions at which these first six shots (in our data) were
    taken. Here, we use the term *x-position* to mean how far “down the field” each
    shot was taken. One team’s goal has an x-position of 0, and the other team’s goal
    has an x-position of 1, so the x-position tells us how close to the opposing team’s
    goal a particular shot was taken.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是数据中前六次投篮的x位置。在这里，我们使用术语*x位置*来表示每次投篮距离“球场底线”的远近。一个队的球门x位置为0，另一个队的球门x位置为1，因此x位置告诉我们某次投篮距离对方球门有多远。
- en: Applying Linear Regression in R
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在R中应用线性回归
- en: 'Whenever we look at data, we can try to learn from it. One thing we might want
    to learn is how shots from the beginning of the game are different from shots
    at the end of the game. How does the time during the game influence the position
    from which shots are being taken? Several hypotheses could be true:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们查看数据时，我们可以尝试从中学习。我们可能想了解的一件事是，比赛开始时的投篮与比赛结束时的投篮有何不同。在比赛过程中，时间如何影响投篮的位置？有几种假设可能成立：
- en: Offensive players could get more tired and desperate as a game progresses, so
    they start to take shots from farther away from the goal (a lower x-position).
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进攻球员可能会随着比赛的进行变得更加疲劳和焦虑，因此他们开始从距离球门更远的位置投篮（即较低的x位置）。
- en: Defensive players could get more tired and careless as a game progresses, so
    players are able to take shots from closer to the goal (a higher x-position).
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防守球员可能会随着比赛的进行变得更加疲劳和马虎，因此进攻球员能够从距离球门较近的位置投篮（即较高的x位置）。
- en: Maybe neither of the first two hypotheses is true, or another pattern exists
    in the relationship between the minutes of a game and the x-position of shots.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 也许前两个假设都不成立，或者比赛时间与投篮x位置之间存在其他模式。
- en: 'To decide which of these hypotheses is true, we can try linear regression in
    R:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了决定这些假设中的哪一个是真实的，我们可以尝试在R中进行线性回归：
- en: '[PRE30]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here, we use the `lm()` command to run a linear regression. This regression
    attempts to find the relationship between the `minute` variable and the `positionX`
    variable in our `shots` data. Just as we did in Chapter 2, we want to look at
    the coefficients that are part of the output of every linear regression. Remember
    that the coefficient can be interpreted as the slope of a line. If we find a positive
    coefficient from this regression, we interpret that to mean that people take shots
    that are closer to the goal later in the game. If we find a negative coefficient,
    we interpret that to mean that people take shots that are farther from the goal
    later in the game. When we look at the output of our linear regression code, we
    see that it looks like this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`lm()`命令进行线性回归。该回归旨在找出我们`shots`数据中`minute`变量和`positionX`变量之间的关系。正如我们在第二章中所做的那样，我们希望查看每个线性回归输出中的系数。请记住，系数可以解释为直线的斜率。如果我们从回归中找到一个正系数，我们可以解释为比赛进行时，球员投篮的距离球门越来越近。如果我们找到一个负系数，我们可以解释为比赛进行时，球员投篮的距离球门越来越远。当我们查看线性回归代码的输出时，它看起来是这样的：
- en: '[PRE31]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If you look in the `Estimate` column of this output, you can see that the estimated
    coefficient for the `minute` variable is `5.251e-05`. This is a positive coefficient,
    so as games progress through time, we expect to see shots that are (slightly)
    closer to the goal.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看此输出中的`Estimate`列，你会看到`minute`变量的估计系数是`5.251e-05`。这是一个正系数，所以随着比赛的进行，我们预计投篮会（稍微）更靠近球门。
- en: Using R to Plot Data
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用R绘制数据
- en: 'Now that we’ve performed our regression, we can draw a plot of our data, together
    with the regression results:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了回归分析，我们可以绘制数据图表，展示回归结果：
- en: '[PRE32]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the first line, we use the `png()` command. This tells R to open a file to
    draw a plot on. We also have to specify a filename where we’ll write the file.
    Next, we use the `plot()` command. We specify what we’ll put on the x-axis first,
    and then we specify the y-axis. The `abline()` command is used to draw a line
    for our regression output. Finally, we run `dev.off()`. This command turns off
    the graphics device, meaning it tells R that we’ve finished the plotting, and
    the file should be written to your computer’s memory. After you run this snippet,
    you should be able to see the file saved to your laptop; it should look like [Figure
    11-2](#figure11-2).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我们使用了`png()`命令。这告诉R打开一个文件用于绘制图表。我们还需要指定一个文件名，文件会被写入到这个位置。接下来，我们使用`plot()`命令，首先指定x轴的内容，然后指定y轴的内容。`abline()`命令用于绘制回归线。最后，我们运行`dev.off()`命令，这会关闭图形设备，意味着它告诉R绘制完成，文件应该写入到计算机的内存中。运行这个代码片段后，你应该能看到文件保存在你的笔记本上，应该像[图11-2](#figure11-2)一样。
- en: '![](image_fi/502888c11/f11002.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502888c11/f11002.png)'
- en: 'Figure 11-2: The x-position of shots at each minute of thousands of soccer
    games, with a regression line'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-2：成千上万场足球比赛中每分钟射门的x位置及回归线
- en: If you have trouble finding the output file on your laptop, you can change the
    filename argument in the preceding snippet. For example, you can write `png(filename='``/home/Yossarian/Documents``/plotoutput.png')`
    to save it to any specific location on your computer.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在笔记本上找不到输出文件，可以修改上述代码片段中的文件名参数。例如，你可以写`png(filename='/home/Yossarian/Documents/plotoutput.png')`，将文件保存在你计算机的任何特定位置。
- en: You can see a huge number of shots on this plot, and many are being plotted
    right on top of one another. The regression line is barely visible—you can see
    it poking out at the left and right of the plot close to where *y* is about 0.85\.
    It has a positive slope, but it’s only slightly positive; very little pattern
    can be discerned in the shot locations by minute of soccer games. This is something
    that you could have done with Python, using the code and ideas from Chapter 2,
    but now you’re able to do it in another language as well.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这张图中，你可以看到大量的射门数据，许多数据点都叠加在一起。回归线几乎看不见——你能看到它在图的左右两侧稍微突出，接近*y*大约是0.85的位置。它有一个正斜率，但只是略微正向；通过分析足球比赛的每分钟射门位置，很难辨认出任何明显的模式。这是你本来可以用Python做到的，使用第二章中的代码和思路，但现在你也能用另一种语言完成。
- en: This one plot and one regression won’t make you a perfect soccer manager yet,
    but it will give you information and context that will be helpful as you study
    what it takes to win soccer games and help your team succeed. Instead of relying
    on theories or hearsay, you have the skills of a data scientist, so you can determine
    what works well in soccer games by examining the data directly. After reading
    this chapter, you can examine data and learn from it not only with Python but
    also with SQL and R.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这一张图和一个回归模型还不足以让你成为一个完美的足球经理，但它会为你提供信息和背景，帮助你学习如何赢得足球比赛，并帮助你的球队取得成功。与其依赖理论或道听途说，你拥有数据科学家的技能，可以通过直接分析数据来确定在足球比赛中什么是有效的。读完本章后，你不仅能用Python，还能用SQL和R来分析数据并从中学习。
- en: 'We can do so much more with R; anything we’ve done with Python in this book
    can also be done with R. In addition to plots and linear regression, you could
    do supervised learning, k-means clustering, and much more. But already, you know
    how to do a lot: you can read data, calculate a regression, and draw a plot.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用R做更多的事情；本书中使用Python完成的任何任务也可以用R完成。除了绘图和线性回归，你还可以进行监督学习、K均值聚类等操作。事实上，你已经学会了很多：你可以读取数据、计算回归并绘制图表。
- en: Gaining Other Valuable Skills
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取其他宝贵技能
- en: 'After you finish this book and close it, you’ll have some strong data science
    skills. But you can always learn more. One thing you should consider is gaining
    proficiency in even more programming languages. In addition to Python, SQL, and
    R, there are many other programming languages that you might want to learn, at
    least at a beginner or intermediate level. Here are some other languages that
    you might consider learning:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成本书并合上它时，你将具备一些强大的数据科学技能。但你总是可以学习更多的内容。你应该考虑的一件事是提高你对更多编程语言的熟练度。除了Python、SQL和R之外，还有许多其他编程语言，至少在初级或中级水平上，你可能也想学习。以下是你可能考虑学习的其他编程语言：
- en: '**C++**'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**C++**'
- en: C++ is a high-performance language; code written in C++ is powerful and fast.
    It tends to be harder to work with than Python.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C++ 是一种高性能语言；用 C++ 编写的代码功能强大且执行速度快。它通常比 Python 更难以使用。
- en: '**Scala**'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**Scala**'
- en: Scala is used for working with big data—that is, datasets that have millions
    or billions of rows.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Scala 用于处理大数据——即那些包含数百万或数十亿行数据的 datasets。
- en: '**Julia**'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**Julia**'
- en: Julia has been growing in popularity in recent years, gaining a reputation for
    efficiency and the speed of mathematical calculations.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Julia 在近年来的流行度不断上升，因其高效性和数学计算速度而声名鹊起。
- en: '**JavaScript**'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript**'
- en: JavaScript is extremely common in web programming. It enables you to create
    dynamic, interactive websites.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JavaScript 在网页编程中极为常见。它使你能够创建动态的、互动性强的网站。
- en: '**MATLAB**'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**MATLAB**'
- en: Short for *matrix laboratory*, MATLAB was designed for precision in mathematical
    calculations, including matrix manipulation. It’s often used for scientific computing,
    but only by people or institutions that can afford its hefty price tag.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: MATLAB 是 *矩阵实验室* 的缩写，旨在进行精确的数学计算，包括矩阵操作。它通常用于科学计算，但只有那些能够负担其高昂价格的人或机构才能使用。
- en: '**SAS, Stata, SPSS**'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**SAS，Stata，SPSS**'
- en: These are proprietary statistics packages. Stata is in common use among professional
    economists. SPSS, owned by IBM, is commonly used by some social scientists. SAS
    is used by some businesses. Just like MATLAB, all of these languages also have
    hefty price tags that often persuade people to use free alternatives like Python,
    SQL, and R.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些是专有的统计软件包。Stata 在专业经济学家中广泛使用。SPSS 由 IBM 拥有，通常被一些社会科学家使用。SAS 被一些企业使用。和 MATLAB
    一样，所有这些语言也都有高昂的价格，通常会促使人们选择像 Python、SQL 和 R 这样的免费替代品。
- en: 'Besides these, many others exist. Some data scientists say that a data scientist
    should be a better programmer than any statistician, and a better statistician
    than any programmer. Speaking of statistics, you may want to study the following
    topics in advanced statistics further:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些，还有许多其他方法。一些数据科学家认为，数据科学家应该比任何统计学家都更擅长编程，而比任何程序员都更擅长统计学。说到统计学，你可能希望进一步研究以下高级统计学主题：
- en: '**Linear algebra**'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**线性代数**'
- en: Many statistical methods like linear regression are, at heart, linear algebra
    methods. When you read textbooks related to advanced data science or advanced
    machine learning, you will see notation from linear algebra, and linear algebra
    ideas like matrix inversion. If you can gain deep knowledge of linear algebra,
    you’ll be better able to master these advanced topics.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 许多统计方法，如线性回归，本质上是线性代数方法。当你阅读与高级数据科学或高级机器学习相关的教科书时，你会看到线性代数符号和线性代数概念，比如矩阵求逆。如果你能深入理解线性代数，你将更好地掌握这些高级主题。
- en: '**Bayesian statistics**'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**贝叶斯统计**'
- en: In recent decades, a set of statistical techniques known as *Bayesian statistics*
    have become popular. Bayesian techniques allow us to reason effectively about
    our levels of confidence about different ideas and how we update our beliefs in
    the face of new information. They also allow us to use our prior beliefs in our
    statistical inferences and reason carefully about the uncertainty we have about
    statistical models.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在过去几十年里，一种被称为*贝叶斯统计*的统计技术变得非常流行。贝叶斯技术使我们能够有效地推理关于不同观点的信心水平，以及如何在面对新信息时更新我们的信念。它们还允许我们在统计推断中使用先验信念，并对我们对统计模型的不确定性进行细致推理。
- en: '**Nonparametric statistics**'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**非参数统计**'
- en: Like Bayesian statistics, nonparametric methods allow us to reason about data
    in new ways. Nonparametric methods are powerful because they require us to make
    very few assumptions about data, so they’re robust and applicable to all kinds
    of data, even data that isn’t “well behaved.”
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与贝叶斯统计类似，非参数方法使我们能够以新的方式推理数据。非参数方法非常强大，因为它们要求我们对数据做极少的假设，因此它们具有鲁棒性，并适用于各种数据，即使是那些“不太规范”的数据。
- en: 'Data science is about more than statistical theory. It’s also about deploying
    technology. Here are some technical skills related to technology deployment you
    will want to gain:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 数据科学不仅仅是统计理论。它还与技术部署相关。以下是你需要掌握的一些与技术部署相关的技术技能：
- en: '**Data engineering**'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据工程**'
- en: In most of the chapters of this book, we provided you clean data for analysis.
    However, in many real-life scenarios, you’ll receive data that’s messy, incomplete,
    badly labeled, constantly changing, or otherwise in need of careful management.
    Data engineering is a set of skills for working with big, unruly datasets in a
    careful and effective way. You may find yourself working at a company that has
    data engineers on staff to clean and prepare data for you, but you’ll likely find
    yourself in many situations where you need to do these tasks yourself.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本书的大多数章节中，我们为你提供了干净的数据进行分析。然而，在许多现实生活中的场景中，你将会收到杂乱、不完整、标签错误、不断变化，或其他需要精心管理的数据。数据工程是一套与大规模、难以控制的数据集打交道的技巧，以谨慎和高效的方式进行工作。你可能会发现自己在一家公司工作，那里有数据工程师负责为你清理和准备数据，但你也很可能会遇到许多需要你自己完成这些任务的情况。
- en: '**DevOps**'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**DevOps**'
- en: After a data scientist performs some analysis, more steps are often required
    before the analysis is useful. For example, if you use linear regression to do
    forecasting, you may want to install the regression on a server and have it performed
    regularly. How and where will you install it? Do you need to update it regularly?
    How will you monitor it? How and when will you redeploy it? These kinds of questions
    are related to machine learning DevOps, also called *MLOps*, and if you can gain
    some DevOps and MLOps skills, you can have more success in your data science career.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在数据科学家进行一些分析后，通常还需要更多的步骤，才能使分析结果变得有用。例如，如果你使用线性回归进行预测，你可能希望将回归模型安装到服务器上并定期执行。你将如何以及在哪里安装它？是否需要定期更新？你将如何监控它？如何以及何时重新部署它？这些问题与机器学习DevOps相关，也叫做*
    MLOps*，如果你能掌握一些DevOps和MLOps的技能，你在数据科学事业中将会更加成功。
- en: '**Advanced/fluent/efficient programming**'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**高级/流利/高效编程**'
- en: A beginner data scientist can write code that works. A talented data scientist,
    by contrast, can write code that’s efficient. It will run fast, and will be readable
    and concise.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个初级数据科学家能够编写可运行的代码。而一个有才华的数据科学家，相比之下，能够编写高效的代码。它将运行得更快，并且更加可读和简洁。
- en: Besides these skills, you will want to gain expertise in applied fields related
    to the work you do (or the work you want to do). If you’re interested in working
    as a data scientist in the world of finance, you should study mathematical finance
    and the types of quantitative models that top finance companies use. If you’re
    interested in working for a pharmaceutical or medical company, you should consider
    biostatistics or even just pure biology as fields to dive into. The more you know,
    the more effective you’ll be in your data science career.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些技能之外，你还需要在与你的工作（或你希望从事的工作）相关的应用领域获得专业知识。如果你有兴趣在金融领域担任数据科学家，你应该学习数学金融以及顶级金融公司使用的量化模型。如果你有兴趣在制药或医疗公司工作，你应该考虑生物统计学，甚至纯生物学作为研究领域。你知道的越多，你在数据科学事业中就会越有效。
- en: Summary
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discussed other languages besides Python that can be useful
    for data scientists. We started with SQL, a powerful language used to work with
    tables. We used SQL to select data from tables as well as to join tables together.
    We continued with a discussion of R, a language designed by statisticians that
    can be used for many powerful data analyses. Now you’ve completed the book, and
    you have excellent data science skills. Congratulations, good luck, and all the
    best!
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了除了Python之外，其他对数据科学家有用的编程语言。我们从SQL开始，SQL是一个强大的语言，用于处理表格数据。我们使用SQL从表格中选择数据并将表格连接在一起。接着，我们讨论了R语言，R是一种由统计学家设计的语言，适用于许多强大的数据分析。现在你已经完成了本书，并且掌握了出色的数据科学技能。恭喜你，祝你好运，万事如意！
