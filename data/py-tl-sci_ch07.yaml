- en: '**7'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**7'
- en: INTEGERS, FLOATS, AND STRINGS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**整数、浮点数和字符串**'
- en: '![image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common.jpg)'
- en: 'In this chapter, you’ll learn the difference between expressions and statements,
    discover how to assign values to variables, and become familiar with the most
    common types of data in Python: integers, floats, and strings. In the process,
    you’ll likely be surprised by how much programming you can accomplish using simple
    mathematical operations.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习表达式和语句的区别，了解如何给变量赋值，并熟悉 Python 中最常见的数据类型：整数、浮点数和字符串。在这个过程中，你可能会惊讶于使用简单的数学运算就能完成很多编程任务。
- en: While working through this and the following chapters, I recommend running the
    code examples rather than just reading them. Typing in the commands will help
    you to remember them and reduce any apprehension you might feel about coding.
    I’ll be using the console and text editor in Spyder for the examples in this primer.
    I suggest you do the same so that you can follow along. If you need a refresher
    on these tools, see [Chapter 3](ch03.xhtml) for the Jupyter Qt console and [Chapter
    4](ch04.xhtml) for the Spyder IDE.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成本章及后续章节的学习时，我建议你运行代码示例，而不仅仅是阅读它们。输入命令会帮助你记住它们，并减少你对编程的任何恐惧。我将使用 Spyder 中的控制台和文本编辑器来展示本教程中的示例。我建议你也这么做，这样你可以跟着一起操作。如果你需要复习这些工具，请参见[第
    3 章](ch03.xhtml)了解 Jupyter Qt 控制台，和[第 4 章](ch04.xhtml)了解 Spyder IDE。
- en: '**Mathematical Expressions**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**数学表达式**'
- en: In computer science, *expressions* are instructions that evaluate to a single
    value. The most familiar expressions are mathematical, such as 1 + 2, which evaluates
    to 3\. Using Python, you can incorporate equations into your programs (and even
    use an interactive console as a calculator). To do so, you’ll need to be familiar
    with the mathematical operators.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学中，*表达式*是计算得出单一值的指令。最常见的表达式是数学表达式，比如 1 + 2，它的计算结果为 3。使用 Python，你可以将方程式嵌入到你的程序中（甚至可以将交互式控制台当作计算器使用）。为此，你需要熟悉数学运算符。
- en: '***Mathematical Operators***'
  id: totrans-7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***数学运算符***'
- en: Symbols used to represent an action or process are called *operators*. These
    perform a function or manipulate values in some way. Common operators are the
    plus (`+`) and minus (`-`) signs, used for addition and subtraction, respectively.
    [Table 7-1](ch07.xhtml#ch07tab1) lists some of the available mathematical operators
    in Python. Most of these should be familiar to you, with a few exceptions that
    we’ll expand on next.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 用于表示某种操作或过程的符号叫做*运算符*。这些运算符执行某些功能或以某种方式操作值。常见的运算符有加号（`+`）和减号（`-`），分别用于加法和减法。[表
    7-1](ch07.xhtml#ch07tab1)列出了 Python 中一些可用的数学运算符。大多数运算符你应该都很熟悉，剩下的一些我们将在接下来的部分详细讲解。
- en: '**Table 7-1:** Mathematical Operators'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 7-1：** 数学运算符'
- en: '| **Operator** | **Description** | **Example** | **Result** |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| **运算符** | **描述** | **示例** | **结果** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| + | Addition | 5 + 3 | 8 |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| + | 加法 | 5 + 3 | 8 |'
- en: '| - | Subtraction | 5 - 3 | 2 |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| - | 减法 | 5 - 3 | 2 |'
- en: '| * | Multiplication | 5 * 3 | 15 |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| * | 乘法 | 5 * 3 | 15 |'
- en: '| / | Division | 5/3 | 1.6666666666666667 |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| / | 除法 | 5/3 | 1.6666666666666667 |'
- en: '| // | Division (floor or integer) | 5 // 3 | 1 |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| // | 除法（向下取整或整数除法） | 5 // 3 | 1 |'
- en: '| % | Modulus (remainder) | 5 % 3 | 2 |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| % | 取模（余数） | 5 % 3 | 2 |'
- en: '| ** | Power | 5**3 | 125 |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| ** | 幂运算 | 5**3 | 125 |'
- en: Whereas the division operator (`/`) represents true division, *floor* division
    (`//`) returns an integer with any fractional part ignored. Note that floor division
    will not round up. If the result is `1.99999`, you’ll still get `1` as the answer.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 除法运算符（`/`）表示真正的除法，而*向下取整*除法（`//`）返回一个整数，忽略任何小数部分。注意，向下取整除法不会向上取整。如果结果是`1.99999`，你仍然会得到`1`作为答案。
- en: 'If you want only the fraction, or *remainder*, of the division operation, use
    the *modulo* operator (`%`). The remainder may seem like a strange thing to separate
    out, but it can be useful. For example, you can use it to identify even and odd
    numbers. Enter the following code in a console:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想得到除法运算的分数或*余数*，可以使用*取模*运算符（`%`）。余数可能看起来像是一个奇怪的东西，但它其实非常有用。例如，你可以用它来识别偶数和奇数。在控制台输入以下代码：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**NOTE**'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The command for executing the code will depend on what tool you’re using.
    For the Jupyter Qt console, this will be pressing ENTER (or SHIFT-ENTER if you’re
    within indented code) on your keyboard.*'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*执行代码的命令将取决于你使用的工具。对于 Jupyter Qt 控制台，按下回车键（如果在缩进代码内，按 SHIFT+ENTER）。*'
- en: In the previous example, dividing `4` by `2` using the modulo operator returned
    `0`, meaning the operation resulted in no remainder and thus `4` is even. Other
    uses for modulo include instructing your program to do something every *n*th time
    and converting seconds to hours, minutes, and seconds.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，使用取余运算符将 `4` 除以 `2` 得到 `0`，这意味着操作结果没有余数，因此 `4` 是偶数。取余的其他用途包括让程序每隔 *n*
    次执行某些操作，或将秒转换为小时、分钟和秒。
- en: 'The power, or *exponent*, operator also has a non-intuitive feature. Not only
    can you raise numbers to a power, you can also calculate the root by using a decimal
    value after the `**` operator. For example, to take the square root of 9, enter
    the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 幂运算符，或*指数*运算符，也有一个不太直观的特性。你不仅可以将数字提高到某个指数，还可以通过在 `**` 运算符后使用小数值来计算根。例如，要计算 9
    的平方根，可以输入以下内容：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To take the cube root of 27, enter:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算 27 的立方根，请输入：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '***The Assignment Operator***'
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***赋值运算符***'
- en: Using Python as a hand calculator is a bit like calling in an air strike on
    an ant. For programs to be truly useful, you need to store the output of expressions
    in a reusable manner. That’s where assignment statements, assignment operators,
    and variables come in.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Python 作为手持计算器使用有点像对蚂蚁进行空袭。为了让程序真正有用，你需要以可重用的方式存储表达式的输出。这就是赋值语句、赋值运算符和变量的作用。
- en: Whereas expressions evaluate to a single value, *statements carry out* some
    action. The *assignment* statement, for example, creates a new *variable*. Variables
    are just *references* to data stored in memory. In an assignment statement, the
    equal sign (`=`) is an assignment *operator* that assigns a value or expression
    to a variable ([Figure 7-1](ch07.xhtml#ch07fig1)). A simple example is `my_name
    = 'Lee'`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式计算出单一值，而*语句执行*某些操作。例如，*赋值*语句会创建一个新的*变量*。变量只是指向存储在内存中的数据的*引用*。在赋值语句中，等号（`=`）是一个赋值*运算符*，它将一个值或表达式赋给一个变量（[图
    7-1](ch07.xhtml#ch07fig1)）。一个简单的例子是 `my_name = 'Lee'`。
- en: '![Image](../images/07fig01.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig01.jpg)'
- en: '*Figure 7-1: Rudiments of an assignment statement*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-1：赋值语句的基础*'
- en: In assignment statements, the item to the left of the equal sign is the variable’s
    name. This acts as a label for accessing information in memory. The item on the
    right is the variable’s value. These values don’t have to be numeric. Text data,
    lists of items, even images and music can be stored as variables.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在赋值语句中，等号左边的项是变量的名称。这充当访问内存中信息的标签。等号右边的项是变量的值。这些值不必是数字。文本数据、项目列表，甚至图像和音乐都可以作为变量存储。
- en: Now that you know about assignment statements, let’s use them to make our math
    expressions more persistent and purposeful by assigning the results to a variable.
    Because this is such a common programming task, Python helps you out by providing
    special *augmented* assignment operators, which we’ll talk about next.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你了解了赋值语句，让我们通过将结果赋给变量，来使数学表达式更加持久和有目的。因为这是一个非常常见的编程任务，Python 会通过提供特殊的*增强*赋值运算符来帮助你，接下来我们将讨论这些运算符。
- en: '***Augmented Assignment Operators***'
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***增强赋值运算符***'
- en: 'For convenience, you can combine mathematical operators to form *augmented
    assignment operators* that let you perform two operations at the same time. Here’s
    an example *without* an augmented operator:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便，你可以将数学运算符结合起来形成*增强赋值运算符*，这样你可以同时执行两个操作。以下是*没有*增强运算符的示例：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that you can add a variable to itself, and entering the variable name in
    the console will display its value. In the text editor, you’ll need to use `print(x)`
    to display the value to the screen.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你可以将一个变量加到它自身上，并且在控制台中输入变量名将显示其值。在文本编辑器中，你需要使用 `print(x)` 来将值显示到屏幕上。
- en: 'With an augmented assignment operator (`+=`), you can add 5 to `x` without
    having to repeat `x`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用增强赋值运算符（`+=`），你可以将 5 加到 `x` 上，而不必重复写 `x`：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To make an augmented assignment operator, just add the mathematical operator
    ([Table 7-1](ch07.xhtml#ch07tab1)) before the equal sign (`=`). For example, to
    multiply `x` by 2, you could enter the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建增强赋值运算符，只需在等号（`=`）前添加数学运算符（[表 7-1](ch07.xhtml#ch07tab1)）。例如，要将 `x` 乘以 2，可以输入以下内容：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice how, because you assign the result of each expression to the variable
    `x`, each expression can build on the one before.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于你将每个表达式的结果赋值给变量 `x`，每个表达式都可以在前一个的基础上构建。
- en: '***Precedence***'
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***优先级***'
- en: Mathematical expressions in Python use familiar rules of precedence ([Table
    7-2](ch07.xhtml#ch07tab2)). Expressions bounded by parentheses are always performed
    first, and operations within the same precedence level are evaluated left to right.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的数学表达式使用熟悉的优先级规则（[表7-2](ch07.xhtml#ch07tab2)）。被括号包围的表达式总是首先执行，同一优先级的操作从左到右计算。
- en: '**Table 7-2:** Mathematical Precedence'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**表7-2：** 数学运算优先级'
- en: '| **Level** | **Operator** | **Description** |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| **级别** | **运算符** | **描述** |'
- en: '| --- | --- | --- |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 1 (highest) | () | Parentheses |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 1（最高） | () | 括号 |'
- en: '| 2 | ** | Power |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 2 | ** | 幂运算 |'
- en: '| 3 | -n, +n | Negative and positive arguments |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 3 | -n, +n | 负数和正数参数 |'
- en: '| 4 | *, /, //, % | Multiplication, division, floor division, modulus |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 4 | *, /, //, % | 乘法、除法、整除、取余 |'
- en: '| 5 | +, - | Addition and subtraction |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 5 | +, - | 加法和减法 |'
- en: 'Here’s an example of precedence in action. Follow along in your head and see
    if you get the same answer as Python:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这是优先级作用的一个示例。你可以在心里跟着做，看看是否和Python的结果一致：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The precedence level influences how you use *whitespace* within an expression.
    For example, the expression that follows will execute, but you might find it less
    readable than the previous version:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 优先级影响你在表达式中如何使用*空格*。例如，下面的表达式虽然会执行，但你可能会觉得它比前一个版本更难读：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You can find guidelines for improving the readability of expressions in PEP8
    (*[https://pep8.org/](https://pep8.org/)*). Although there are some set rules—such
    as never use more than one space, always have the same amount of whitespace on
    both sides of a mathematical operator, and surround assignment (=) and augmented
    assignment operators (like +=) with a single space—you’re mostly free to use your
    own judgement. If you have poor eyesight, you might prefer to use more whitespace
    than is recommended.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在PEP8中找到提高表达式可读性的指南（* [https://pep8.org/](https://pep8.org/) *）。虽然有一些规定的规则——比如从不使用多个空格、始终确保数学运算符两边的空格数量相同、赋值（=）和增强赋值运算符（如+=）两侧留一个空格——但你大部分时间可以自由发挥。如果视力不好，你可能会倾向于使用比推荐更多的空格。
- en: '***The math Module***'
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***math模块***'
- en: The Python standard library includes a `math` module that provides access to
    underlying C library functions. *Functions* are like mini-programs that perform
    some task or tasks. They hide the details of these programs from you so that you
    can write cleaner code.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Python标准库包括一个`math`模块，它提供了对底层C库函数的访问。*函数*就像迷你程序，执行某些任务。它们将这些程序的细节隐藏起来，让你能够写出更简洁的代码。
- en: To use a function, enter the function name followed by parentheses. Values or
    variables you enter in the parentheses will be input to the function. We look
    at functions in more detail in [Chapter 11](ch11.xhtml), including how to write
    your own custom versions.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用一个函数，只需输入函数名后跟括号。你在括号中输入的值或变量将作为输入传递给函数。我们将在[第11章](ch11.xhtml)中更详细地讨论函数，包括如何编写你自己的自定义版本。
- en: Groups of related functions are often gathered into *modules*. The `math` module
    lets you efficiently perform common and useful mathematical calculations including
    working with factorials, quadratic equations, and trigonometric, exponential,
    and hyperbolic functions. It also includes constants including *π* and *e*. A
    subset of the available functions is listed in [Table 7-3](ch07.xhtml#ch07tab3).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 相关功能的组通常被集中到*模块*中。`math`模块让你高效地进行常见和有用的数学计算，包括处理阶乘、二次方程以及三角函数、指数函数和双曲函数。它还包括常数，如*π*和*e*。可用功能的一个子集列在[表7-3](ch07.xhtml#ch07tab3)中。
- en: To use the `math` module, you first must *import* it using an `import` statement.
    Think of this as checking a book out of a library. As there are literally thousands
    of available modules, you don’t want them all to load by default. This would be
    like emptying all the book shelves in a library onto your desk at once. Instead,
    you just take down books you need. Importing modules follows this principle with
    respect to your computer’s memory.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`math`模块，首先需要通过`import`语句将其*导入*。可以把这看作是从图书馆借书。因为有成千上万的可用模块，你不希望它们都默认加载。这就像把图书馆的所有书架上的书都一次性搬到你的桌子上一样。相反，你只拿取你需要的书籍。导入模块遵循这个原则，以便节省计算机的内存。
- en: '**Table 7-3:** A Subset of Python Math Module Functions'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**表7-3：** Python数学模块函数子集'
- en: '| **Function** | **Description** |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| **函数** | **描述** |'
- en: '| --- | --- |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `ceil(x)` | Returns the smallest integer greater than or equal to `x` |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `ceil(x)` | 返回大于或等于`x`的最小整数 |'
- en: '| `fabs(x)` | Returns the absolute value of `x` as a floating-point number
    |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `fabs(x)` | 返回 `x` 的绝对值，作为浮点数 |'
- en: '| `factorial(x)` | Returns the factorial of `x` |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `factorial(x)` | 返回 `x` 的阶乘值 |'
- en: '| `floor(x)` | Returns the largest integer less than or equal to `x` |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `floor(x)` | 返回小于或等于 `x` 的最大整数 |'
- en: '| `frexp(x)` | Returns the mantissa and exponent of `x` as the pair (`m`, `e`)
    |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `frexp(x)` | 返回 `x` 的尾数和指数，作为一对 (`m`, `e`) |'
- en: '| `isnan(x)` | Returns True if `x` is a NaN (Not a Number) |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `isnan(x)` | 如果 `x` 是 NaN（不是一个数字），则返回 True |'
- en: '| `exp(x)` | Returns `e**x` |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `exp(x)` | 返回 `e**x` |'
- en: '| `log(x[, b])` | Returns the logarithm of `x` to the base `b` (defaults to
    `e`) |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `log(x[, b])` | 返回 `x` 以 `b` 为底的对数（默认以 `e` 为底） |'
- en: '| `log2(x)` | Returns the base-2 logarithm of `x` |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `log2(x)` | 返回 `x` 的以 2 为底的对数 |'
- en: '| `log10(x)` | Returns the base-10 logarithm of `x` |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `log10(x)` | 返回 `x` 的以 10 为底的对数 |'
- en: '| `pow(x, y)` | Returns `x` raised to the power `y` |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `pow(x, y)` | 返回 `x` 的 `y` 次方 |'
- en: '| `sqrt(x)` | Returns the square root of `x` |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `sqrt(x)` | 返回 `x` 的平方根 |'
- en: '| `acos(x)` | Returns the arc cosine of `x` |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `acos(x)` | 返回 `x` 的反余弦值 |'
- en: '| `asin(x)` | Returns the arc sine of `x` |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `asin(x)` | 返回 `x` 的反正弦值 |'
- en: '| `atan(x)` | Returns the arc tangent of `x` |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `atan(x)` | 返回 `x` 的反正切值 |'
- en: '| `atan2(y, x)` | Returns the arc tangent of `y` / `x` |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `atan2(y, x)` | 返回 `y` / `x` 的反正切值 |'
- en: '| `cos(x)` | Returns the cosine of `x` |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `cos(x)` | 返回 `x` 的余弦值 |'
- en: '| `hypot(x, y)` | Returns the Euclidean norm, `sqrt(x**2 + y**2)` |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `hypot(x, y)` | 返回欧几里得范数，`sqrt(x**2 + y**2)` |'
- en: '| `sin(x)` | Returns the sine of `x` |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `sin(x)` | 返回 `x` 的正弦值 |'
- en: '| `tan(x)` | Returns the tangent of `x` |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `tan(x)` | 返回 `x` 的正切值 |'
- en: '| `degrees(x)` | Converts `x` from radians to degrees |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `degrees(x)` | 将 `x` 从弧度转换为度数 |'
- en: '| `radians(x)` | Converts `x` from degrees to radians |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `radians(x)` | 将 `x` 从度数转换为弧度 |'
- en: 'Let’s use the `math` module to calculate the cosine of 45 degrees:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 `math` 模块来计算 45 度的余弦值：
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Start by importing the `math` module, converting 45 to radians (all trigonometric
    calculations in Python use radians), and assigning the result to the variable,
    `x`. Note that you enter the name of the module followed by a dot (`.`), and the
    `radians()` function with the angle you want to convert in the parentheses. Using
    a dot in this manner is called *dot notation*. It tells Python to use the `math`
    module’s `radians()` function. You can think of it as an apostrophe indicating
    possession: “`math`’s `radians()` function.”'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，导入 `math` 模块，将 45 转换为弧度（Python 中所有三角函数使用弧度），并将结果赋给变量 `x`。注意，你输入模块名称后跟一个点（`.`），然后是
    `radians()` 函数，括号中是你想要转换的角度。以这种方式使用点号被称为 *点符号法*。它告诉 Python 使用 `math` 模块的 `radians()`
    函数。你可以把它理解为一个表示所有权的撇号：“`math` 的 `radians()` 函数。”
- en: 'Finally, call the `cos()` function on `x`. You can also assign this value to
    a variable as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，调用 `cos()` 函数并传入 `x`。你也可以将这个值赋给一个变量，如下所示：
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, let’s use `math` to access *π* and calculate the circumference of a circle
    with a diameter of 100 units:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们使用 `math` 来访问 *π* 并计算一个直径为 100 单位的圆的周长：
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `math` module handles basic math well, but for more advanced functionality,
    such as calculus, you’ll want to use external libraries like *SymPy*, which we
    examine in later chapters. In the meantime, to learn more about `math` and see
    a complete list of the available functions and constants, along with detailed
    documentation, visit *[https://docs.python.org/3/library/math.html](https://docs.python.org/3/library/math.html)*.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`math` 模块处理基本数学运算很好，但对于更高级的功能，例如微积分，你可能需要使用外部库，如 *SymPy*，我们将在后续章节中详细讲解。与此同时，想要了解更多关于
    `math` 的内容，查看完整的函数和常量列表，以及详细的文档，可以访问 *[https://docs.python.org/3/library/math.html](https://docs.python.org/3/library/math.html)*。'
- en: '**NOTE**'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Recalling information that you’ve recently learned helps you retain the knowledge.
    Take a few minutes to complete this short quiz. You can find answers and suggestions
    in the [appendix](app01.xhtml#app01).*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*回顾你最近学习的信息有助于保持记忆。花几分钟完成这个简短的测验。你可以在 [附录](app01.xhtml#app01) 中找到答案和建议。*'
- en: '**TEST YOUR KNOWLEDGE**'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试你的知识**'
- en: '1.  True or false: Statements are computational instructions that evaluate
    to a single value.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  对错：语句是计算指令，会计算出一个单一的值。
- en: '2.  The expression `12%4` evaluates to:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  表达式 `12%4` 的结果是：
- en: a.  3
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: a.  3
- en: b.  48
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: b.  48
- en: c.  0
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: c.  0
- en: d.  12.4
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: d.  12.4
- en: '3.  The mathematical operator with the highest precedence is:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  优先级最高的数学运算符是：
- en: a.  Power (**)
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: a.  乘方（**）
- en: b.  Floor division (//)
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: b.  整除 (//)
- en: c.  Parentheses (())
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: c.  括号 (())
- en: d.  Negative and positive arguments (-n, +n)
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: d.  负数与正数参数 (-n, +n)
- en: 4.  Write a line of code that first takes the square root of 42 and then raises
    the result to the 4th power.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 编写一行代码，首先计算 42 的平方根，然后将结果提升到 4 次方。
- en: '**Error Messages**'
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**错误信息**'
- en: As soon as you start coding, you’re going to make mistakes. One issue is that
    computers are much more literal than people. You and I can be very flexible when
    it comes to contextual meaning, grammar, and even spelling, but with computers,
    what you see is what you get ([Figure 7-2](ch07.xhtml#ch07fig2)).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你开始编写代码，你就会犯错误。一个问题是，计算机比人类更加字面化。你和我在处理上下文意义、语法甚至拼写时可以非常灵活，但在计算机中，看到的就是得到的（[图
    7-2](ch07.xhtml#ch07fig2)）。
- en: '![Image](../images/07fig02.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig02.jpg)'
- en: '*Figure 7-2: Computers take everything literally.*'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-2：计算机将一切都理解为字面意思。*'
- en: You can’t bend Python’s syntactic rules like you can the grammatical rules that
    govern human speech. When you try to perform an illegal operation in Python, such
    as divide a number by zero, it halts execution and displays an error message,
    a process called *raising an exception*.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能像处理人类语言的语法规则那样去弯曲 Python 的语法规则。当你在 Python 中尝试执行非法操作时，比如除以零，它会停止执行并显示一条错误信息，这个过程叫做*抛出异常*。
- en: 'Let’s look at an example that a human could handle but Python can’t:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个人类能处理但 Python 不能处理的例子：
- en: '[PRE11]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Python displayed an error message indicating a `TypeError` because you tried
    to divide an integer (`int`) by a string of text (`str`). Although you and I can
    easily guess the correct answer, Python won’t even try, because you mixed *data
    types* (more on these in a moment). To Python, this is as silly as dividing 25
    by “Steve.”
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Python 显示了一条错误信息，指出 `TypeError`，因为你试图将一个整数（`int`）除以一个字符串（`str`）。虽然你我可以很容易地猜出正确答案，但
    Python 甚至不会尝试，因为你混合了*数据类型*（稍后会讲到这些）。对于 Python 来说，这就像将 25 除以“Steve”一样荒谬。
- en: 'Now, let’s try to divide by zero:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试除以零：
- en: '[PRE12]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This raises the aptly named `ZeroDivisionError` and again provides a record,
    called a *traceback*, which describes where the interpreter encountered a problem
    in your code. In this case, the traceback includes the assignment statement that
    caused the exception and the type of error encountered. For some errors, it will
    also provide a pointer (`^`) to where the exception occurs in the line.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这会引发名为 `ZeroDivisionError` 的错误，并再次提供一个记录，称为*回溯*，描述了解释器在你的代码中遇到问题的位置。在这个案例中，回溯包含了导致异常的赋值语句和遇到的错误类型。对于某些错误，它还会提供一个指针（`^`），指向该行中发生异常的位置。
- en: '**NOTE**'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In many cases, it’s the line before the line referenced in the traceback that
    causes the problem. So always remember to look up!*'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*在许多情况下，实际上是回溯中引用的前一行导致了问题。所以请永远记得往上看！*'
- en: Knowing the type of error that the interpreter encountered will help you debug
    your code when you make mistakes. [Table 7-4](ch07.xhtml#ch07tab4) lists some
    of the common error types that you’ll encounter (you can find more at *[https://docs.python.org/3/library/exceptions.html](https://docs.python.org/3/library/exceptions.html)*).
    Don’t worry if you don’t understand them all now. They should make more sense
    by the end of this primer.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 了解解释器遇到的错误类型将帮助你在犯错时调试代码。[表 7-4](ch07.xhtml#ch07tab4)列出了你可能遇到的一些常见错误类型（你可以在
    *[https://docs.python.org/3/library/exceptions.html](https://docs.python.org/3/library/exceptions.html)*
    上找到更多）。如果你现在不理解它们，也不用担心。到本书的最后，它们应该会变得更加清晰。
- en: '**Table 7-4:** Some Common Python Error Types'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 7-4：** 常见 Python 错误类型'
- en: '| **Error type** | **Thrown when…** |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| **错误类型** | **抛出时…** |'
- en: '| --- | --- |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `SyntaxError` | a syntax error is encountered. |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `SyntaxError` | 遇到语法错误。 |'
- en: '| `IndexError` | trying to access an item at an invalid index. |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `IndexError` | 尝试访问一个无效索引的项。 |'
- en: '| `ModuleNotFoundError` | a module or package can’t be found. |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `ModuleNotFoundError` | 找不到模块或包。 |'
- en: '| `KeyError` | a dictionary key can’t be found. |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `KeyError` | 找不到字典键。 |'
- en: '| `ImportError` | a problem occurs when loading a module or package. |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `ImportError` | 加载模块或包时发生问题。 |'
- en: '| `StopIteration` | the `next()` function goes beyond the iterator items. |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `StopIteration` | `next()` 函数超出了迭代器的项目。 |'
- en: '| `TypeError` | an operation or function is applied to data of an inappropriate
    type. |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `TypeError` | 操作或函数应用于不适当类型的数据。 |'
- en: '| `ValueError` | a function’s argument is of an inappropriate type. |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `ValueError` | 函数的参数类型不合适。 |'
- en: '| `NameError` | an object (variable, function, and so on) can’t be found. |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `NameError` | 找不到对象（变量、函数等）。 |'
- en: '| `RecursionError` | the maximum recursion depth exceeded (long-running loop
    terminated). |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `RecursionError` | 超过了最大递归深度（长时间运行的循环被终止）。 |'
- en: '| `ZeroDivisionError` | the denominator in the division operation is zero.
    |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `ZeroDivisionError` | 除法操作中的分母为零。 |'
- en: '| `MemoryError` | an operation runs out of memory. |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `MemoryError` | 操作耗尽了内存。 |'
- en: '| `KeyboardInterrupt` | the user presses the interrupt key (such as CTRL-C)
    during execution. |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| `KeyboardInterrupt` | 用户在执行过程中按下中断键（例如 CTRL-C）。 |'
- en: 'Errors are no big deal. The last line in a traceback includes the error type
    and a brief explanation (such as `NameError: name` ''`load`'' `is not defined`).
    If you copy and paste this line into a search engine, you’ll find lots of friendly
    explanations that are easier to understand than the overly technical ones provided
    in the traceback report and the official documentation.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '错误没什么大不了的。回溯信息的最后一行包含错误类型和简短的解释（如 `NameError: name` ''`load`'' `is not defined`）。如果你将这一行复制并粘贴到搜索引擎中，你会找到很多更易理解的友好解释，比回溯报告和官方文档中过于技术化的解释更容易懂。'
- en: Later, we’ll look at ways to handle certain exceptions so that a program can
    keep running rather than crash when it encounters one. It’s also possible to write
    custom exceptions for a specific program in the event that the supplied exceptions
    are insufficient.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨处理某些异常的方法，以便在程序遇到异常时能够继续运行，而不是崩溃。如果提供的异常不足以处理特定情况，还可以为特定程序编写自定义异常。
- en: '**Data Types**'
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**数据类型**'
- en: Just as errors have types, every value in Python is automatically assigned to
    a specific data type. This lets Python distinguish between the letters of the
    alphabet, like “abc,” and numbers, like “123.”
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 就像错误有类型一样，Python 中的每个值都会自动分配到一个特定的数据类型。这使得 Python 能够区分字母（如“abc”）和数字（如“123”）。
- en: The same principles apply to humans. We wouldn’t try to multiply letters together
    (unless we were doing algebra). Nor would we name our children using numbers (unless
    we were Elon Musk). Without conscious thought, our brains recognize different
    types of data, and after we’ve categorized that data, we know how to use it.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的原则也适用于人类。我们不会尝试将字母相乘（除非我们在做代数）。我们也不会用数字给孩子起名字（除非我们是埃隆·马斯克）。在没有意识思考的情况下，我们的大脑能够识别不同类型的数据，并在对这些数据进行分类后，知道如何使用它们。
- en: In computer science, a *data type* is a classification that dictates what values
    objects can hold (in other words, what input is acceptable) and how they can be
    used (what operations can be performed using them, such as converting text to
    lowercase). Whereas many programming languages use *static typing* that requires
    you to explicitly declare the data type for any variable you create, Python uses
    *dynamic typing*, wherein variables can be any data type and even change types
    during execution. This makes Python a friendlier language, though this comes at
    a cost. Languages using static typing are better at catching bugs because they
    can check that data is being used correctly before the program runs.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学中，*数据类型*是一种分类，规定了对象可以存储哪些值（换句话说，哪些输入是可接受的），以及它们如何使用（可以进行哪些操作，例如将文本转换为小写）。许多编程语言使用*静态类型*，要求你明确声明每个创建的变量的数据类型，而
    Python 使用*动态类型*，变量可以是任何数据类型，甚至在执行过程中改变类型。这使得 Python 成为一种更友好的语言，尽管这也有代价。使用静态类型的语言更擅长捕捉错误，因为它们可以在程序运行之前检查数据是否被正确使用。
- en: '**NOTE**'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Python permits optional static typing using type hints. We won’t cover these
    here, but you can learn more at [https://www.python.org/dev/peps/pep-0484/](https://www.python.org/dev/peps/pep-0484/).*'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*Python 允许使用类型提示进行可选的静态类型检查。我们在这里不做详细介绍，但你可以在[https://www.python.org/dev/peps/pep-0484/](https://www.python.org/dev/peps/pep-0484/)了解更多。*'
- en: 'Let’s begin by looking at some of the built-in data types that you’ll use with
    Python ([Table 7-5](ch07.xhtml#ch07tab5)). Because numbers and text occur in pretty
    much every computer program, here we’ll focus on three data types: *strings*,
    *integers*, and *floating-point numbers (floats)*; we cover other data types in
    subsequent chapters. These three data types are highlighted in bold in [Table
    7-5](ch07.xhtml#ch07tab5).'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先来看一下 Python 中你将使用的一些内置数据类型（[表 7-5](ch07.xhtml#ch07tab5)）。由于数字和文本几乎出现在每个计算机程序中，我们在这里重点介绍三种数据类型：*字符串*、*整数*和*浮点数（浮动类型）*；其他数据类型将在后续章节中介绍。这三种数据类型在[表
    7-5](ch07.xhtml#ch07tab5)中以粗体突出显示。
- en: '**Table 7-5:** Some Common Data Types'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 7-5：** 一些常见的数据类型'
- en: '| **Category** | **Data type** | **Examples** |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| **类别** | **数据类型** | **示例** |'
- en: '| --- | --- | --- |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| **Numeric type** | **Integer** | -1**,** 0**,** 1**,** 4000 |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| **数值类型** | **整数** | -1**,** 0**,** 1**,** 4000 |'
- en: '| **Numeric type** | **Float** | -1.5**,** 0.0**,** 0.33**,** 4000.001 |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| **数值类型** | **浮动类型** | -1.5**,** 0.0**,** 0.33**,** 4000.001 |'
- en: '| Numeric type | Complex | `a = 4 + 3j` |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| 数值类型 | 复数 | `a = 4 + 3j` |'
- en: '| **Text type** | **String** | ''a''**,** "b"**,** "Hello, world" |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| **文本类型** | **字符串** | ''a''**,** "b"**,** "Hello, world" |'
- en: '| Sequence type | Tuple | `(2, 5, ''Pluto'', 4.56)` |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| 序列类型 | 元组 | `(2, 5, ''Pluto'', 4.56)` |'
- en: '| Sequence type | List | `[2, 5, ''Pluto'', 4.56]` |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| 序列类型 | 列表 | `[2, 5, ''Pluto'', 4.56]` |'
- en: '| Sequence type | Range | `range(0, 10, 1)` |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| 序列类型 | 范围 | `range(0, 10, 1)` |'
- en: '| Set type | Set | `{2, 5, ''Pluto'', 4.56}` |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| 集合类型 | 集合 | `{2, 5, ''Pluto'', 4.56}` |'
- en: '| Set type | Frozenset | `frozenset({2, 5, ''Pluto'', 4.56})` |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| 集合类型 | 冻集合 | `frozenset({2, 5, ''Pluto'', 4.56})` |'
- en: '| Mapping type | Dictionary | `{''key'': ''value''}` |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| 映射类型 | 字典 | `{''key'': ''value''}` |'
- en: '| Boolean type | Bool | `True`, `False` |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| 布尔类型 | 布尔值 | `True`, `False` |'
- en: Additional binary types, not listed in [Table 7-5](ch07.xhtml#ch07tab5), include
    *Bytes*, *Bytearray*, and *Memoryview*. For more on all these built-in types,
    visit *[https://docs.python.org/3/library/stdtypes.html](https://docs.python.org/3/library/stdtypes.html)*.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 除了[表7-5](ch07.xhtml#ch07tab5)中列出的二进制类型，还包括 *字节*、*字节数组* 和 *内存视图*。有关所有这些内建类型的更多信息，请访问
    *[https://docs.python.org/3/library/stdtypes.html](https://docs.python.org/3/library/stdtypes.html)*。
- en: '***Accessing the Data Type***'
  id: totrans-167
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***访问数据类型***'
- en: 'You can query for data type using the built-in `type()` function that ships
    with Python. Enter a value or variable in the parentheses, as in the following
    code:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用内建的 `type()` 函数来查询数据类型。将一个值或变量放入括号中，如以下代码所示：
- en: '[PRE13]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You can also use the `isinstance()` function to check whether a variable is
    an instance of a particular data type. For example, to check whether the integer
    `42` is an integer or a string, enter `42` in the parentheses, along with the
    data type you’re checking for, as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 `isinstance()` 函数来检查一个变量是否是某种数据类型的实例。例如，检查整数 `42` 是否是整数或字符串，可以将 `42`
    放入括号中，并指定你要检查的数据类型，如下所示：
- en: '[PRE14]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Much like the human brain, Python can recognize data types based on context.
    Numbers without a decimal are considered integers. Numbers with a decimal point
    are floats, even if there are no values behind the decimal point (such as `5.`).
    Strings are identified by enclosing characters in quotation marks (such as “Hello”
    or ‘123’).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 就像人类大脑一样，Python 可以根据上下文识别数据类型。没有小数点的数字被视为整数。带有小数点的数字是浮动数，即使小数点后面没有数值（比如 `5.`）。字符串通过将字符括在引号中来识别（如“Hello”或‘123’）。
- en: '***Integers***'
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***整数***'
- en: The *integer* type represents whole numbers, such as 0, 42, and 5,280\. The
    length of an integer is limited only by your system’s maximum available memory.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '*整数* 类型表示整数，如 0、42 和 5,280。整数的长度仅受系统最大可用内存的限制。'
- en: 'Python recognizes integers by the absence of a decimal point:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Python 通过小数点的缺失来识别整数：
- en: '[PRE15]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When working with large numbers, you can use an underscore (`_`) to separate
    thousands, such as `15_000_000` for `15000000`. Python doesn’t need this separator
    to understand these values, but you’ll have an easier time reading them. It reduces
    key-in errors and saves you from having to count lots of zeros:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理大数字时，你可以使用下划线 (`_`) 来分隔千位数，例如 `15_000_000` 代表 `15000000`。Python 不需要这个分隔符来理解这些数值，但它能让你更容易阅读。它减少了输入错误，避免了你数一堆零的麻烦：
- en: '[PRE16]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Later in this chapter, we’ll look at how to make the output more readable, as
    well.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 本章后续内容我们还会探讨如何使输出更易于阅读。
- en: '***Floats***'
  id: totrans-180
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***浮动数***'
- en: '*Floats*, or *floating-point numbers*, have decimal points. They include 0.0,
    0.42, and 3.14159\. With floats, you get 15 to 17 digits of precision. Small rounding
    errors, caused by the universal CPU need to store digits in the binary number
    system, mean that floats aren’t always perfectly accurate. For example, notice
    that the following addition results in an extra 0.00000000000000004:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '*浮动数* 或 *浮点数* 包含小数点。它们包括 0.0、0.42 和 3.14159。浮动数具有 15 到 17 位的精度。由于 CPU 在二进制数字系统中存储数字的方式，可能会出现小的舍入误差，这意味着浮动数不总是完全准确的。例如，注意以下加法结果会出现额外的
    0.00000000000000004：'
- en: '[PRE17]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If you need more exact precision for scientific work, you can use the built-in
    `decimal` module (*[https://docs.python.org/3/library/decimal.html](https://docs.python.org/3/library/decimal.html)*).
    For more on floating-point accuracy, see *[https://docs.python.org/3/tutorial/floatingpoint.html](https://docs.python.org/3/tutorial/floatingpoint.html)*.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要更精确的精度来进行科学计算，可以使用内建的 `decimal` 模块 (*[https://docs.python.org/3/library/decimal.html](https://docs.python.org/3/library/decimal.html)*)。关于浮点数精度的更多信息，请参见
    *[https://docs.python.org/3/tutorial/floatingpoint.html](https://docs.python.org/3/tutorial/floatingpoint.html)*。
- en: '**Converting Floats and Integers**'
  id: totrans-184
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**转换浮动数和整数**'
- en: 'Operations using integers sometimes return integers and sometimes return floats.
    Try the following in the console:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 使用整数进行操作有时返回整数，有时返回浮点数。在控制台中尝试以下操作：
- en: '[PRE18]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Even though most operations between integers always yield an integer, division
    may not (42 / 5, for example). Because dividing an integer by an integer can result
    in a float, Python automatically converts the quotient into a floating-point value,
    even if the result is still an integer.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管大多数整数之间的操作总是返回整数，但除法可能不会（例如，42 / 5）。因为将整数除以整数可能会得到浮点数，所以 Python 会自动将商转换为浮点数，即使结果仍然是整数。
- en: The process of converting from one data type to another is known as *type casting*.
    This can occur *implicitly*, as in the previous example, or *explicitly*, in which
    you use predefined functions. Explicit type casting is commonly used on user input,
    to ensure that the input values are the proper type for subsequent operations.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 从一种数据类型转换到另一种数据类型的过程称为 *类型转换*。这可以是 *隐式的*，如前面的示例，或者是 *显式的*，你使用预定义的函数进行转换。显式类型转换通常用于用户输入，以确保输入值的类型适合后续操作。
- en: 'With Python, you can convert integers to floats in several ways. One is to
    combine them in the same mathematical operation. Notice that adding a float value
    to an integer turns that integer into a float:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，你可以通过几种方式将整数转换为浮点数。一个方法是将它们组合在同一个数学运算中。注意，将浮点数加到整数上会将该整数转换为浮点数：
- en: '[PRE19]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You can also use explicit type casting with the `float()` built-in function:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用显式类型转换与内置的 `float()` 函数：
- en: '[PRE20]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If `x` is an integer, the following would work as well:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `x` 是整数，下面的操作也会生效：
- en: '[PRE21]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To convert a float into an integer, use the `int()` built-in function:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要将浮点数转换为整数，使用内置的 `int()` 函数：
- en: '[PRE22]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note that `int()` simply drops the decimal part and keeps the whole number to
    the left of the decimal point. If you want to account for any fractional remainder,
    you’ll need to use rounding.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`int()` 仅仅是去掉小数部分，保留小数点左边的整数部分。如果你想处理任何小数余数，你需要使用四舍五入。
- en: '**Rounding**'
  id: totrans-198
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**四舍五入**'
- en: 'To *round* a floating-point number up or down to the nearest integer rather
    than just remove the decimal part, you’ll want to use the built-in `round()`function.
    In the following example, we use `round()` to convert the float 5.89 to the nearest
    integer, 6:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 要将浮点数四舍五入到最接近的整数，而不仅仅是去掉小数部分，你需要使用内置的 `round()` 函数。在以下示例中，我们使用 `round()` 将浮点数
    5.89 四舍五入到最接近的整数 6：
- en: '[PRE23]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `round()` function rounds to no decimal places by default and returns an
    integer. To specify the number of significant digits for rounding, include the
    number after the value to round. In the following example, we round the value
    of the `y` variable to one decimal place:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`round()` 函数默认四舍五入到没有小数位，并返回一个整数。要指定四舍五入的小数位数，可以在待四舍五入的值后面加上数字。在以下示例中，我们将 `y`
    变量的值四舍五入到一位小数：'
- en: '[PRE24]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Because you preserved a value after the decimal point, `y` is still a float.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你保留了小数点后的值，`y` 仍然是一个浮点数。
- en: 'When working in an interactive console, you can also round numbers directly,
    without the need for a variable:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在交互式控制台中工作时，你也可以直接对数字进行四舍五入，而无需使用变量：
- en: '[PRE25]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If a float value is halfway between integer values, the rounding function rounds
    odd numbers up, and even numbers down, as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果浮点值恰好在两个整数之间，四舍五入函数会将奇数向上舍入，偶数向下舍入，如下所示：
- en: '[PRE26]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As you can see from the previous examples, you should always be aware of data
    types when working with numbers. Integers can automatically convert to floats
    during the processing of your code, and vice versa. For example, doing any operation
    that *uses* a float (such as `5 *= 1.0`), or *results* in a float (such as `5
    /= 3`), will produce a float.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 从之前的示例中可以看出，在处理数字时，你应该时刻注意数据类型。整数在代码处理中可以自动转换为浮点数，反之亦然。例如，进行任何使用浮点数的操作（如 `5
    *= 1.0`），或是产生浮点数的操作（如 `5 /= 3`），都会得到浮点数。
- en: '**TEST YOUR KNOWLEDGE**'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试你的知识**'
- en: 5.  Write an expression that raises a `SyntaxError`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 5. 写一个表达式，抛出一个 `SyntaxError`。
- en: '6.  What error would you expect from the expression, `round(``''``Alice``''``)`:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 6. 你会期望表达式 `round(``'``Alice``'``)` 出现什么错误？
- en: a.  a `TypeError`
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: a. 一个 `TypeError`
- en: b.  a `ValueError`
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: b. 一个 `ValueError`
- en: c.  a `NameError`
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: c. 一个 `NameError`
- en: d.  a `SyntaxError`
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: d. 一个 `SyntaxError`
- en: 7.  Round *π* to five decimal places.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 7. 将 *π* 四舍五入到五位小数。
- en: '8.  Use Python to determine the data type of this object: `(1, 2, 3)`.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 8. 使用 Python 来确定这个对象的类型：`(1, 2, 3)`。
- en: '9.  True or false: The tiny inaccuracies that sometimes occur in floating-point
    numbers are a Python-specific issue.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 9. 真假：有时在浮点数中出现的微小不准确性是 Python 特有的问题。
- en: '***Strings***'
  id: totrans-219
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***字符串***'
- en: '*Strings*, also known as *string literals*, are what we think of as text values.
    You can recognize them by their quotation marks. The most famous string value
    in programming, “Hello, World!”, is generally the first thing you learn to print.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '*字符串*，也叫做*字符串文字*，是我们所说的文本值。你可以通过引号来识别它们。编程中最著名的字符串值“Hello, World!”通常是你学会打印的第一个内容。'
- en: 'Strings should be surrounded by quotes, which mark the beginning and end of
    the string. In the console, enter:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串应该用引号括起来，表示字符串的开始和结束。在控制台中，输入：
- en: '[PRE27]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Generally, you should encase strings in single quotes, but if you need to include
    a single quote within your string, say, as an apostrophe, you can use double quotes,
    as in line `In [55]`. In line `In [58]`, note how numbers are treated as strings
    if they’re surrounded by quotes. You won’t be able to use these numbers in mathematical
    expressions without converting them into a numeric type, like integers or floats.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你应该使用单引号括起来字符串，但如果你需要在字符串中包含一个单引号，比如作为省略号，你可以使用双引号，如`In [55]`行所示。在`In [58]`行中，注意如果数字被引号括起来，它们会被视为字符串。你不能直接将这些数字用于数学表达式，除非将其转换为数字类型，如整数或浮点数。
- en: Triple quotes (`"""`) let you stretch strings across multiple lines. Although
    computers don’t care how long a line of code is, humans do. For readability, PEP
    8 recommends a maximum line length of 79 characters. If you want to write a very
    long string, say, for in-code documentation, you can use triple quotes at the
    start and end of the string, as in line `In [59]`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 三引号（`"""`）让你能够跨多行书写字符串。虽然计算机不在乎代码行的长度，但人类在乎。为了可读性，PEP 8 推荐最大行长度为 79 个字符。如果你想写一个非常长的字符串，比如用于代码中的文档说明，你可以在字符串的开始和结束处使用三引号，如
    `In [59]` 行所示。
- en: 'To honor the line length guideline, you can use the line continuation character
    (`\`) to break lines between triple quotes. But note that, if you’re using strings
    with single or double quotes, you’ll need to place it *outside* the strings, as
    shown here:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 为了遵守行长规范，你可以使用行续字符（`\`）在三引号之间换行。但请注意，如果你使用的是单引号或双引号的字符串，你需要将其放置在*引号外部*，如下面所示：
- en: '[PRE28]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Triple quotes also allow you to add simple drawings to your program, such as
    a grid to show board positions in a tic-tac-toe game:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 三引号还允许你在程序中添加简单的图形，例如显示井字游戏中棋盘位置的网格：
- en: '[PRE29]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Finally, you can convert other data types to strings using the `str()` function.
    The following example converts an integer into a string:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以使用`str()`函数将其他数据类型转换为字符串。以下示例将整数转换为字符串：
- en: '[PRE30]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '**NOTE**'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Behind the scenes, strings are sequences of characters in Unicode, an international
    encoding standard in which each letter, digit, or symbol is assigned a unique
    numeric value. Unicode ensures that computers everywhere see an A as an A, and
    a ☺ as a happy face.*'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '*在幕后，字符串是 Unicode 字符序列，Unicode 是一种国际编码标准，其中每个字母、数字或符号都有一个唯一的数值。Unicode 确保世界各地的计算机都能看到
    A 作为 A，☺ 作为一个笑脸。*'
- en: '**Escape Sequences**'
  id: totrans-233
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**转义序列**'
- en: '*Escape sequences* are special characters that let you insert otherwise illegal
    text into a string. In the previous section, we were able to include a single
    quote apostrophe by first enclosing the string in triple quotes. With the backslash
    (`\`) escape character, used *within* the quotes, we could use single quotes exclusively:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '*转义序列* 是一种特殊字符，它让你将原本无法插入字符串中的文本插入进去。在前一节中，我们通过先用三引号括起字符串，成功地在其中包含了单引号的省略号。使用反斜杠（`\`）转义字符，放在*引号内*，我们可以仅使用单引号：'
- en: '[PRE31]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Note that the backslash doesn’t appear in the final string. To print a backslash
    character, you’ll need to escape it with another backslash:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，反斜杠在最终的字符串中不会出现。如果你想打印反斜杠字符，你需要用另一个反斜杠对其进行转义：
- en: '[PRE32]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[Table 7-6](ch07.xhtml#ch07tab6) lists some useful escape sequences and their
    result.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 7-6](ch07.xhtml#ch07tab6)列出了几个有用的转义序列及其结果。'
- en: '**Table 7-6:** Useful Python Escape Sequences'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 7-6：** 有用的 Python 转义序列'
- en: '| **Escape sequence** | **Result** |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| **转义序列** | **结果** |'
- en: '| --- | --- |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `\``''` | Single quote (`''`) |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| `\``''` | 单引号（`''`） |'
- en: '| `\``″` | Double quote (`"`) |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| `\``″` | 双引号（`"`） |'
- en: '| `\\` | Backslash (`\`) |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| `\\` | 反斜杠（`\`） |'
- en: '| `\a` | Ring ASCII bell (such as `print(``''``\a``''``)` in Windows 10) |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| `\a` | ASCII 响铃（例如在 Windows 10 中使用 `print(``''``\a``''``)`） |'
- en: '| `\n` | ASCII linefeed (newline) |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| `\n` | ASCII 换行符（换行） |'
- en: '| `\r` | ASCII carriage return |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| `\r` | ASCII 回车符 |'
- en: '| `\t` | ASCII tab |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| `\t` | ASCII 制表符 |'
- en: For the full list of escape sequences, visit the documentation at *[https://docs.python.org/3/reference/lexical_analysis.html](https://docs.python.org/3/reference/lexical_analysis.html)*.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看完整的转义序列列表，请访问文档：*[https://docs.python.org/3/reference/lexical_analysis.html](https://docs.python.org/3/reference/lexical_analysis.html)*。
- en: '**Raw Strings**'
  id: totrans-250
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**原始字符串**'
- en: '*Raw strings* don’t recognize escape sequences. These are helpful when you
    need to deal with lots of backslashes, such as in a Windows path name. In a normal
    string, you must escape backslashes with the `\\` escape sequence, which can become
    awkward:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '*原始字符串*不识别转义序列。当你需要处理大量反斜杠时，它们非常有用，比如Windows路径名。在普通字符串中，你必须用`\\`转义反斜杠，这可能会变得很麻烦：'
- en: '[PRE33]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'With a raw string, what you see is what you get. To use one, just add an `r`
    prefix to the string, before the first quotation mark:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 使用原始字符串，你看到的就是你得到的。要使用原始字符串，只需在字符串前加一个`r`前缀，在第一个引号之前：
- en: '[PRE34]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '**Operator Overloading**'
  id: totrans-255
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**运算符重载**'
- en: 'Python can apply context to certain operators depending on whether they’re
    used with numbers or strings. An operator doing different things on different
    data types is known as *operator overloading.* That sounds bad, but it’s not.
    To see an example, enter the following code:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: Python可以根据运算符与数字或字符串的配合使用，来应用上下文。一个在不同数据类型上执行不同操作的运算符被称为*运算符重载*。这听起来可能很糟糕，但其实并非如此。要查看示例，请输入以下代码：
- en: '[PRE35]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'When used with strings, the `+` addition operator becomes the *string concatenation*
    operator. Also note that spaces are legitimate characters, so I added a space
    before the single quote at the end of `Hello`. Alternatively, the space could
    have been added before `world`, or separated out entirely, as shown here:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 当与字符串一起使用时，`+`加法运算符变成了*字符串连接*运算符。还要注意，空格是合法字符，所以我在`Hello`的单引号前加了一个空格。或者，也可以将空格加在`world`前面，或者完全分开，如下所示：
- en: '[PRE36]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Likewise, the `*` multiplication operator becomes the *string replication*
    operator when a string is multiplied by an integer:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，当一个字符串与整数相乘时，`*`乘法运算符变成了*字符串复制*运算符：
- en: '[PRE37]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This can be useful for drawing in scripts, such as generating a dividing line
    within your code:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于脚本中的绘图很有用，例如生成代码中的分隔线：
- en: '[PRE38]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Of course, you can’t mix and match these easily among data types. You can’t
    add a number to a string, for instance, or multiply two words together.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你不能轻松地在不同的数据类型之间混合使用它们。例如，你不能将数字和字符串相加，或者将两个单词相乘。
- en: '**String Formatting**'
  id: totrans-265
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**字符串格式化**'
- en: 'In many cases, you’ll want to create a string that includes other strings.
    For example, you might want to reference a variable in the `print()` function.
    *Format strings*, also called *f-strings*, make this easy. You just need to prefix
    the string with an `f` and put the variable name in curly brackets, as follows:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，你可能想创建一个包含其他字符串的字符串。例如，你可能想在`print()`函数中引用一个变量。*格式化字符串*，也叫做*f-strings*，可以轻松实现这一点。你只需在字符串前加上`f`并将变量名放入花括号中，如下所示：
- en: '[PRE39]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '**NOTE**'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you’re working in the console, you can omit the print() function and apply
    the f-string directly (such as: f''{solute} dissolves in {solvent}'').*'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你在控制台工作，可以省略`print()`函数，直接应用f-string（例如：f''{solute} dissolves in {solvent}''）。*'
- en: 'Within an f-string, expressions in curly brackets are evaluated at runtime:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在f-string中，花括号中的表达式会在运行时进行求值：
- en: '[PRE40]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'You can also specify the text’s alignment with f-strings, letting you create
    tabular output. In the following example, 25 spaces are reserved and `<` justifies
    these spaces to the left, `^` centers the text, and `>` justifies to the right:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用f-strings来指定文本的对齐方式，从而创建表格输出。在下面的示例中，保留了25个空格，`<`将这些空格左对齐，`^`将文本居中对齐，`>`则将文本右对齐：
- en: '[PRE41]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You can use f-strings to format numeric values. To add commas to a long number,
    use this format:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用f-strings来格式化数字值。要为一个长数字添加逗号，请使用以下格式：
- en: '[PRE42]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'To use exponential notation, use the `e` qualifier:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用指数表示法，使用`e`修饰符：
- en: '[PRE43]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'To format numbers to a specific precision point, use the `f` qualifier. For
    example, to print Euler’s number, *e*, to three decimal places, enter:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 要将数字格式化为特定的精度点，使用`f`修饰符。例如，要将欧拉数*e*打印为三位小数，输入：
- en: '[PRE44]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'To convert a number to a percent, use the `%` qualifier. Include a number to
    specify the number of decimal places to preserve:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 要将一个数字转换为百分比，使用`%`修饰符。包含一个数字来指定保留的小数位数：
- en: '[PRE45]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: As you can see, f-strings make code very readable, so long as your variable
    names make sense.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，f-strings使代码非常易读，只要你的变量名有意义。
- en: '**TEST YOUR KNOWLEDGE**'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试你的知识**'
- en: 10.  If `x =` `'``30_000_000``'`, what data type is `x`?
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 10.  如果`x =` `'``30_000_000``'`，那么`x`的数据类型是什么？
- en: 11.  Which of the following is the result of running the code `f'{3.14159:.2f}'`
    in Jupyter Qt console?
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 11. 以下哪项是运行代码 `f'{3.14159:.2f}'` 在Jupyter Qt控制台中的结果？
- en: a.  `'3.14'`
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: a. `'3.14'`
- en: b.  `'314,159'`
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: b. `'314,159'`
- en: c.  `'3.141590e+00'`
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: c. `'3.141590e+00'`
- en: d.  `'314.15%'`
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: d. `'314.15%'`
- en: 12.  Draw an owl in the text editor and print it to the screen. Each line of
    code should not exceed 79 characters.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 12. 在文本编辑器中绘制一只猫头鹰并将其打印到屏幕上。每行代码不应超过79个字符。
- en: 13.  Write a program that converts 1,824 seconds into minutes and seconds and
    then print the results.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 13. 编写一个程序，将1,824秒转换为分钟和秒数，然后打印结果。
- en: '**String Slicing**'
  id: totrans-292
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**字符串切片**'
- en: Each character in a string has a unique index that locates it within the string.
    Think of this as the character’s address. Python starts counting with 0; thus,
    the index for the first character in a string is `0`, not `1`.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串中的每个字符都有一个独特的索引，用来定位它在字符串中的位置。可以把这个索引当作字符的地址。Python从0开始计数，因此，字符串中第一个字符的索引是`0`，而不是`1`。
- en: 'In the console, enter the following to retrieve the first and last characters
    in the string `''PYTHON''`:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制台中，输入以下内容以检索字符串 `'PYTHON'` 的第一个和最后一个字符：
- en: '[PRE46]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: To use an index, enter the variable name (such as `x`) with the index that you
    want in square brackets (`[]`). Note that, even though `PYTHON` has six characters,
    the last index is `5`, again because Python starts counting at `0`.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 使用索引时，输入变量名（如`x`）和你想要的索引，索引放在方括号（`[]`）中。请注意，尽管`PYTHON`有六个字符，最后一个索引是`5`，这也是因为Python从`0`开始计数。
- en: 'If you ask for an index beyond the end of the string, you will get the (very
    common) `index out of range` error:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你请求一个超出字符串末尾的索引，你将得到一个（非常常见的）`index out of range` 错误：
- en: '[PRE47]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: You can also *slice* strings (and many other data types) using indexes. Slicing
    lets you chop a string into smaller pieces. For example, you might take the first
    three characters, the last two, the one in the middle, and so on.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用索引来*切片*字符串（以及许多其他数据类型）。切片让你把一个字符串切割成更小的部分。例如，你可能会提取前三个字符，最后两个字符，中间的一个字符，等等。
- en: 'To slice a string, enter endpoints that encompass the characters in which you’re
    interested. For example, to get the first three characters in `PYTHON`, enter
    the following:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 要切片一个字符串，输入包含你感兴趣字符的端点。例如，要获取`PYTHON`中的前三个字符，输入以下内容：
- en: '[PRE48]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Note that you get the characters at indexes `0`, `1`, and `2`, but not at index
    `3`. When slicing, Python takes everything *up to* but *not including* the ending
    index.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你获取的是索引`0`、`1`和`2`上的字符，但不是索引`3`上的字符。切片时，Python会获取*到*（但不包括）结束索引的所有内容。
- en: 'Because the starting and ending indexes are used so often, Python provides
    a shorthand technique in which you leave off those indexes. Rerun the preceding
    code, omitting the `0`:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 由于起始和结束索引使用得很频繁，Python提供了一种简写技巧，你可以省略这些索引。重新运行上面的代码，省略`0`：
- en: '[PRE49]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'To return the whole string, you can use just the colon:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 要返回整个字符串，你只需要使用冒号：
- en: '[PRE50]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'You can also take larger strides through the string by specifying a step size.
    The default step size is `1`. If you want to start at the beginning and take every
    other character, add another colon followed by a step size of `2`:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过指定步长来更大步幅地切割字符串。默认的步长是`1`。如果你想从开始位置并每隔一个字符取一个字符，可以再加上一个冒号，后跟步长`2`：
- en: '[PRE51]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The extra colon is needed because we are using the syntax `x[start:end:step]`.
    When no values are provided, Python defaults to taking the starting and ending
    indexes, for convenience.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 需要额外的冒号是因为我们正在使用语法`x[start:end:step]`。当没有提供值时，Python默认采用起始和结束索引，方便使用。
- en: 'You can slice going forward or backward through a string. To slice in reverse,
    you use *negative* indexes. For example, if you just want the end part of a string,
    you can use negative indexes when slicing. To get the last character and the last
    three characters, respectively, enter:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择正向或反向切片字符串。要反向切片，使用*负*索引。例如，如果你只想获取字符串的末尾部分，可以在切片时使用负索引。要分别获取最后一个字符和最后三个字符，输入：
- en: '[PRE52]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Note that the “first” index in reverse is `-1`, not `0` as you might expect.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，反向的“第一个”索引是`-1`，而不是你可能预期的`0`。
- en: 'To print the string in reverse, step backward one character at a time using
    `-1`:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 要打印反向的字符串，可以使用`-1`逐个字符倒退：
- en: '[PRE53]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '**Membership Operators**'
  id: totrans-315
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**成员运算符**'
- en: 'The `in` and `not in` operators tell you whether a character or substring exists
    within a string. For example:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`in`和`not in`运算符告诉你一个字符或子字符串是否存在于字符串中。例如：'
- en: '[PRE54]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This functionality is useful with conditional statements, which we’ll cover
    in more detail later. For example, if you’d like to know whether `''``Waldo``''`
    is part of the string contained in the variable `x`, you could enter the following:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这种功能在条件语句中很有用，我们稍后会更详细地讲解。例如，如果你想知道`'Waldo'`是否是变量`x`中字符串的一部分，可以输入以下内容：
- en: '[PRE55]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '**String Methods**'
  id: totrans-320
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**字符串方法**'
- en: A nice thing about data types is that they come with methods (a type of function)
    that helps you manipulate them. Methods represent actions that data types can
    perform. For example, although the `in` operator tells you that a character or
    substring is *present*, it doesn’t tell you how many times it occurs. If you want
    to count number of occurrences, you can use the `count()` method.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类型的一个优点是，它们带有一些方法（一种函数），可以帮助你操作这些数据类型。方法表示数据类型可以执行的操作。例如，虽然`in`运算符告诉你某个字符或子字符串是否*存在*，但它并不会告诉你该字符或子字符串出现了多少次。如果你想计算出现的次数，可以使用`count()`方法。
- en: 'To count the number of times lowercase “i” occurs in the string “I am a scientist,”
    enter the string (or a variable representing the string), followed by a dot (`.`)
    and the `count()` method with the character or substring you’re searching for
    in the parentheses:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算小写字母“i”在字符串“I am a scientist”中出现的次数，可以输入该字符串（或表示该字符串的变量），后跟一个点（`.`）和`count()`方法，并在括号内提供你要查找的字符或子字符串：
- en: '[PRE56]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Python comes with a long list of string methods (see *[https://docs.python.org/3/library/stdtypes.html#string-methods/](https://docs.python.org/3/library/stdtypes.html#string-methods/)*).
    Some of the more-used methods are listed in [Table 7-7](ch07.xhtml#ch07tab7).
    You should replace text in bold with your specific string or substring. Text in
    italics is optional. For example, the *start* and *end* indexing options default
    to the starting and ending indexes of the string, respectively, if you choose
    to ignore them.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: Python 提供了一个包含许多字符串方法的列表（参见 *[https://docs.python.org/3/library/stdtypes.html#string-methods/](https://docs.python.org/3/library/stdtypes.html#string-methods/)*）。一些常用的方法列在[表7-7](ch07.xhtml#ch07tab7)中。你应将粗体文本替换为你特定的字符串或子字符串。斜体文本是可选的。例如，*start*和*end*的索引选项默认分别为字符串的起始和结束索引，如果选择忽略它们。
- en: '**Table 7-7:** Common String Methods'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '**表7-7：** 常用字符串方法'
- en: '| **Method** | **Description** |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** |'
- en: '| --- | --- |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| str`.capitalize()` | Capitalizes the first character with the rest lowercase
    |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '| str`.capitalize()` | 将第一个字符大写，其余字符小写 |'
- en: '| str`.count(`sub`,` start`,` end`)` | Counts occurrences of a character or
    substring |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '| str`.count(sub, start, end)` | 计算字符或子字符串出现的次数 |'
- en: '| str`.endswith(`suffix`,` start`,` end`)` | Returns True if string ends with
    the suffix |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '| str`.endswith(suffix, start, end)` | 如果字符串以指定后缀结束，则返回True |'
- en: '| str`.find(`sub, start`,` end`)` | Returns lowest index where substring is
    found within slice |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '| str`.find(sub, start, end)` | 返回子字符串在切片中的最低索引 |'
- en: '| str`.isalnum()` | Returns True if all string characters are alphanumeric
    |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '| str`.isalnum()` | 如果字符串中的所有字符都是字母数字字符，则返回True |'
- en: '| str`.isalpha()` | Returns True if all string characters are alphabetic |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '| str`.isalpha()` | 如果字符串中的所有字符都是字母，则返回True |'
- en: '| str`.isdigit()` | Returns True if all string characters are digits |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '| str`.isdigit()` | 如果字符串中的所有字符都是数字，则返回True |'
- en: '| str`.islower()` | Returns True if all string characters are lowercase |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '| str`.islower()` | 如果字符串中的所有字符都是小写字母，则返回True |'
- en: '| str`.isupper()` | Returns True if all string characters are uppercase |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| str`.isupper()` | 如果字符串中的所有字符都是大写字母，则返回True |'
- en: '| str`.lower()` | Changes all cased characters to lowercase |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| str`.lower()` | 将所有字符转换为小写 |'
- en: '| str`.replace(`old, new, count`)` | Replace old substring with new substring
    |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| str`.replace(old, new, count)` | 用新子字符串替换旧子字符串 |'
- en: '| str`.split(sep=None,` maxsplit=-1`)` | Return list of words with “sep” character
    as the delimiter |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '| str`.split(sep=None, maxsplit=-1)` | 使用“sep”字符作为分隔符，返回单词列表 |'
- en: '| str`.startswith(`prefix`,` start`,` end`)` | Return True if string starts
    with the prefix |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '| str`.startswith(prefix, start, end)` | 如果字符串以指定前缀开始，则返回True |'
- en: '| str`.strip(`chars`)` | Removes leading and trailing characters; removes whitespace
    if no character is specified |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '| str`.strip(chars)` | 移除前后的字符；如果未指定字符，则移除空白字符 |'
- en: '| str`.title()` | Capitalizes the first character in each word |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '| str`.title()` | 将每个单词的第一个字符大写 |'
- en: '| str`.upper()` | Changes all cased characters to uppercase |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '| str`.upper()` | 将所有字符转换为大写 |'
- en: 'Because strings are *immutable* (unchangeable), these methods return *copies*
    of strings rather than alter the original object. Enter the following into the
    console:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 由于字符串是*不可变的*（无法更改的），这些方法返回的是字符串的*副本*，而不是修改原始对象。你可以在控制台中输入以下内容：
- en: '[PRE57]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: In this example, you assigned a lowercase string (`'``string``'`) to the `x`
    variable. You then called the `upper()` string method on `x` as you printed it.
    Python was able to see and use the uppercase string, but when you use the `x`
    variable later, it’s still in its original lowercase form.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，你将一个小写字符串（`'``string``'`）赋值给了变量`x`。然后，你对`x`调用了`upper()`字符串方法并打印出来。Python能够看到并使用大写字符串，但当你稍后使用`x`变量时，它仍然保持原来的小写形式。
- en: 'To make `x` always refer to an uppercase string, you need to reassign it to
    itself, as follows:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 要使`x`始终引用大写字符串，你需要将其重新赋值为自身，如下所示：
- en: '[PRE58]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'To see another example of string immutability, let’s try to change the `I`
    in `''STRING''` to `A` using its index:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示字符串不可变性，我们尝试通过索引将`'STRING'`中的`I`改为`A`：
- en: '[PRE59]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This raised a `TypeError`, as the string data type is immutable.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 这引发了一个`TypeError`，因为字符串数据类型是不可变的。
- en: 'To (sort of) get around immutability, use the `replace()` method, which requires
    the creation of a new variable:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 为了（某种程度上）绕过不可变性，使用`replace()`方法，这需要创建一个新变量：
- en: '[PRE60]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The `split()` method breaks up a string and returns a *list* data type (covered
    in [Chapter 9](ch09.xhtml)). For example:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '`split()`方法将一个字符串拆分并返回一个*列表*数据类型（在[第9章](ch09.xhtml)中介绍）。例如：'
- en: '[PRE61]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: If you look carefully at the results, you’ll notice that punctuation marks get
    lumped in with words.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细查看结果，你会发现标点符号被和单词一起归类。
- en: 'By default, `split()` uses a space as the *delimiter* character on which to
    split the string. You can also specify a delimiter such as a hyphen or, as in
    the following case, a comma with trailing whitespace:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`split()`将空格作为*分隔符*来拆分字符串。你还可以指定分隔符，例如连字符或如下例中的逗号以及后续的空格：
- en: '[PRE62]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Note that, compared to line `Out[113]`, the comma is no longer attached to `Tee-hee`,
    but the period is still attached to the `Brutus` item.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，与`Out[113]`行相比，逗号不再附加在`Tee-hee`上，但句点仍然附加在`Brutus`项上。
- en: 'To strip the punctuation marks, import the `string` module, which includes
    a `punctuation` string, and use the built-in `translate()` function to eliminate
    them:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 要去除标点符号，导入`string`模块，它包含一个`punctuation`字符串，并使用内置的`translate()`函数将其去除：
- en: '[PRE63]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The `maketrans()` method takes three arguments; the first two are empty strings
    (`''`), and the third is the list of punctuation marks to remove. This tells the
    function to replace all punctuation with `None`.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '`maketrans()`方法接受三个参数；前两个是空字符串（`''''`），第三个是要删除的标点符号列表。这告诉函数将所有标点符号替换为`None`。'
- en: 'Now, you can split the string on white space and get a list of words only:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以按空格分割字符串，并仅获得单词列表：
- en: '[PRE64]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Note that the remaining comma in line `Out[120]` is part of the list and is
    used to separate items in the list, like `Teehee` and `Brutus`. It doesn’t count
    as part of a string. Note also that the hyphen is missing from `Teehee`. This
    is because the `punctuation` string includes a hyphen.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`Out[120]`行中的逗号是列表的一部分，用于分隔列表中的项，如`Teehee`和`Brutus`。它不算作字符串的一部分。还要注意，`Teehee`中缺少了连字符。这是因为`punctuation`字符串中包含了连字符。
- en: There are a lot of ways to strip unwanted characters from strings with Python.
    For working with large bodies of text, you’ll want to use either *regular expressions*
    (*regex*) or a *natural language processing* library. These tools are specially
    designed for working with text, and we explore some of them in [Chapter 15](ch15.xhtml).
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中有很多方法可以去除字符串中的不需要的字符。如果处理大块文本，建议使用*正则表达式*（*regex*）或*自然语言处理*库。这些工具专为处理文本而设计，我们将在[第15章](ch15.xhtml)中探讨其中的一些。
- en: '**TEST YOUR KNOWLEDGE**'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试你的知识**'
- en: 14.  Which of the following is the result of running the code `'``latchstring``'``[2:8]`?
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 14. 运行代码`'``latchstring``'``[2:8]`的结果是哪个？
- en: a.  `'``atchstr``'`
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: a. `'``atchstr``'`
- en: b.  `'``tchstr``'`
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: b. `'``tchstr``'`
- en: c.  `'``gnirts``'`
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: c. `'``gnirts``'`
- en: d.  `'``atchst``'`
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: d. `'``atchst``'`
- en: '15.  To get a subset of a string value, you should use:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 15. 要获取字符串值的子集，应该使用：
- en: a.  negative indexes
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: a. 负索引
- en: b.  string iteration
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: b. 字符串迭代
- en: c.  augmented operators
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: c. 增强运算符
- en: d.  string slicing
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: d. 字符串切片
- en: '16.  Running the code `''``latchstring``''``[12]` results in:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 16. 运行代码`'``latchstring``'``[12]`的结果是：
- en: a.  a `SyntaxError`
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: a. 一个`SyntaxError`
- en: b.  a `StopIteration` error
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: b. 一个`StopIteration`错误
- en: c.  an `IndexError`
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: c. 一个`IndexError`
- en: d.  a `ValueError`
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: d. 一个`ValueError`
- en: 17.  Using the previous `caesar_said` example, use the `translate()` function
    to remove all the punctuation, *except for* the hyphen.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 17. 使用之前的`caesar_said`示例，使用`translate()`函数删除所有标点符号，*除了*连字符。
- en: 18.  Convert the string `'``impractical python projects``'` to “title” format.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 18. 将字符串 `'``impractical python projects``'` 转换为“标题”格式。
- en: '**Summary**'
  id: totrans-385
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter, you learned that *expressions* are instructions that evaluate
    to a single value, like a mathematical formula. *Statements* express some action
    to be carried out but don’t evaluate to a value. *Operators*, which are symbols
    used to represent an action or process, perform a function, or manipulate values
    in some way.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章，你学到了*表达式*是评估为单一值的指令，就像数学公式一样。*语句*表示需要执行的某个动作，但不评估为值。*运算符*是用于表示某种动作或过程的符号，执行函数或以某种方式操作值。
- en: 'You also learned that a *variable* is a *label* for data stored in memory.
    Variables have *names* and *values*. Every value in Python is automatically assigned
    a *data type*, and you learned about the three most basic types: *integers*, *floats*,
    and *strings*.'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 你还学到了*变量*是存储在内存中的数据的*标签*。变量有*名称*和*值*。在Python中，每个值都会自动分配一个*数据类型*，你了解了三种最基本的数据类型：*整数*、*浮点数*和*字符串*。
- en: In the next chapter, you’ll learn more about variables, which are objects that
    let you connect to and manipulate data.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，你将学习更多关于变量的内容，变量是让你连接和操作数据的对象。
