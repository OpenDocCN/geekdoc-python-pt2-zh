- en: '17'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '17'
- en: Working with APIs
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 API
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: In this chapter, you’ll learn how to write a self-contained program that generates
    a visualization based on data it retrieves. Your program will use an *application
    programming interface (**API)* to automatically request specific information from
    a website and then use that information to generate a visualization. Because programs
    written like this will always use current data to generate a visualization, even
    when that data might be rapidly changing, the visualization will always be up
    to date.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你将学习如何编写一个自包含的程序，基于它获取的数据生成可视化图表。你的程序将使用*应用程序编程接口（**API**）*来自动请求网站上的特定信息，然后使用这些信息生成可视化图表。因为这样的程序总是使用最新的数据来生成可视化图表，即使这些数据可能会快速变化，生成的图表也会始终保持最新。
- en: Using an API
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 API
- en: An API is a part of a website designed to interact with programs. Those programs
    use very specific URLs to request certain information. This kind of request is
    called an *API call*. The requested data will be returned in an easily processed
    format, such as JSON or CSV. Most apps that use external data sources, such as
    apps that integrate with social media sites, rely on API calls.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: API 是网站的一部分，用于与程序交互。这些程序使用非常特定的 URL 请求某些信息。这样的请求被称为*API 调用*。请求的数据将以易于处理的格式返回，如
    JSON 或 CSV。大多数使用外部数据源的应用程序，例如集成社交媒体网站的应用程序，都依赖于 API 调用。
- en: Git and GitHub
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Git 和 GitHub
- en: We’ll base our visualization on information from GitHub ([https://github.com](https://github.com)),
    a site that allows programmers to collaborate on coding projects. We’ll use GitHub’s
    API to request information about Python projects on the site, and then generate
    an interactive visualization of the relative popularity of these projects using
    Plotly.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将基于 GitHub ([https://github.com](https://github.com)) 上的信息创建可视化图表，这个网站允许程序员共同协作编码项目。我们将使用
    GitHub 的 API 请求网站上 Python 项目的信息，然后使用 Plotly 生成这些项目的相对受欢迎程度的交互式可视化图表。
- en: 'GitHub takes its name from Git, a distributed version control system. Git helps
    people manage their work on a project in a way that prevents changes made by one
    person from interfering with changes other people are making. When you implement
    a new feature in a project, Git tracks the changes you make to each file. When
    your new code works, you *commit* the changes you’ve made, and Git records the
    new state of your project. If you make a mistake and want to revert your changes,
    you can easily return to any previously working state. (To learn more about version
    control using Git, see Appendix D.) Projects on GitHub are stored in *repositories*,
    which contain everything associated with the project: its code, information on
    its collaborators, any issues or bug reports, and so on.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub 的名字来源于 Git，一种分布式版本控制系统。Git 帮助人们管理项目工作，防止一个人的更改与其他人的更改冲突。当你在一个项目中实现新功能时，Git
    会跟踪你对每个文件所做的更改。当你的新代码正常工作时，你*提交*所做的更改，Git 会记录项目的新状态。如果你犯了错误并想恢复更改，你可以轻松返回到任何之前正常工作的状态。（了解更多关于使用
    Git 的版本控制，参见附录 D。）GitHub 上的项目存储在*仓库*中，仓库包含与项目相关的所有内容：代码、协作者信息、任何问题或错误报告等。
- en: When users on GitHub like a project, they can “star” it to show their support
    and keep track of projects they might want to use. In this chapter, we’ll write
    a program to automatically download information about the most-starred Python
    projects on GitHub, and then we’ll create an informative visualization of these
    projects.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当 GitHub 用户喜欢一个项目时，他们可以通过“加星”来表示支持，并跟踪可能想要使用的项目。在这一章中，我们将编写一个程序，自动下载 GitHub
    上最受欢迎 Python 项目的信息，并创建这些项目的有用可视化图表。
- en: Requesting Data Using an API Call
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 API 调用请求数据
- en: 'GitHub’s API lets you request a wide range of information through API calls.
    To see what an API call looks like, enter the following into your browser’s address
    bar and press ENTER:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub 的 API 允许你通过 API 调用请求各种信息。要查看一个 API 调用的样式，输入以下内容到浏览器的地址栏并按下 ENTER：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This call returns the number of Python projects currently hosted on GitHub,
    as well as information about the most popular Python repositories. Let’s examine
    the call. The first part, `https://api.github.com/`, directs the request to the
    part of GitHub that responds to API calls. The next part, `search/repositories`,
    tells the API to conduct a search through all the repositories on GitHub.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这个调用返回当前托管在 GitHub 上的 Python 项目数量，以及最受欢迎的 Python 仓库的相关信息。让我们来检查一下这个调用。第一部分，`https://api.github.com/`，将请求定向到
    GitHub 处理 API 调用的部分。接下来的部分，`search/repositories`，指示 API 在 GitHub 上的所有仓库中进行搜索。
- en: The question mark after `repositories` signals that we’re about to pass an argument.
    The `q` stands for *query*, and the equal sign (`=`) lets us begin specifying
    a query (`q=`). By using `language:python`, we indicate that we want information
    only on repositories that have Python as the primary language. The final part,
    `+sort:stars`, sorts the projects by the number of stars they’ve been given.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`repositories` 后面的问号表示我们即将传递一个参数。`q` 代表 *查询*，等号（`=`）让我们开始指定查询（`q=`）。通过使用 `language:python`，我们表示只想获取主语言为
    Python 的仓库信息。最后部分，`+sort:stars`，按照项目的星标数量对项目进行排序。'
- en: 'The following snippet shows the first few lines of the response:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了响应的前几行：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can see from the response that this URL is not primarily intended to be
    entered by humans, because it’s in a format that’s meant to be processed by a
    program. GitHub found just under nine million Python projects as of this writing
    ❶. The value for `"incomplete_results"` is `true`, which tells us that GitHub
    didn’t fully process the query ❷. GitHub limits how long each query can run, in
    order to keep the API responsive for all users. In this case it found some of
    the most popular Python repositories, but it didn’t have time to find all of them;
    we’ll fix that in a moment. The `"items"` returned are displayed in the list that
    follows, which contains details about the most popular Python projects on GitHub
    ❸.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 从响应中可以看到，这个 URL 并非主要是供人类输入的，因为它的格式是为了让程序处理的。到目前为止，GitHub 找到了不到九百万个 Python 项目
    ❶。`"incomplete_results"` 的值为 `true`，这告诉我们 GitHub 没有完全处理查询 ❷。GitHub 限制了每个查询的运行时间，以保持
    API 对所有用户的响应能力。在这种情况下，它找到了最受欢迎的一些 Python 仓库，但没有足够的时间找到所有的；稍后我们会修复这个问题。返回的 `"items"`
    被显示在接下来的列表中，其中包含了 GitHub 上最受欢迎的 Python 项目的详细信息 ❸。
- en: Installing Requests
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装 Requests
- en: 'The *Requests* package allows a Python program to easily request information
    from a website and examine the response. Use pip to install Requests:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*Requests* 包允许 Python 程序轻松地从网站请求信息并查看响应。使用 pip 安装 Requests：'
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you use a command other than `python` to run programs or start a terminal
    session, such as `python3`, your command will look like this:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的命令不是 `python` 来运行程序或启动终端会话，比如 `python3`，你的命令将会像这样：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Processing an API Response
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理 API 响应
- en: 'Now we’ll write a program to automatically issue an API call and process the
    results:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将编写一个程序来自动发起 API 调用并处理结果：
- en: '**python_repos.py**'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**python_repos.py**'
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We first import the `requests` module. Then we assign the URL of the API call
    to the `url` variable ❶. This is a long URL, so we break it into two lines. The
    first line is the main part of the URL, and the second line is the query string.
    We’ve included one more condition to the original query string: `stars:>10000`,
    which tells GitHub to only look for Python repositories that have more than 10,000
    stars. This should allow GitHub to return a complete, consistent set of results.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入 `requests` 模块。然后，我们将 API 调用的 URL 分配给 `url` 变量 ❶。这是一个很长的 URL，所以我们将其拆分成两行。第一行是
    URL 的主体部分，第二行是查询字符串。我们在原查询字符串中添加了一个条件：`stars:>10000`，这表示 GitHub 只搜索那些星标超过 10,000
    的 Python 仓库。这应该能让 GitHub 返回一个完整、一致的结果集。
- en: GitHub is currently on the third version of its API, so we define headers for
    the API call that ask explicitly to use this version of the API, and return the
    results in the JSON format ❷. Then we use `requests` to make the call to the API
    ❸. We call `get()` and pass it the URL and the header that we defined, and we
    assign the response object to the variable `r`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub 当前使用的是第三版 API，因此我们定义了 API 调用的头部，明确要求使用这个版本的 API，并以 JSON 格式返回结果 ❷。然后，我们使用
    `requests` 来发起 API 调用 ❸。我们调用 `get()` 方法，并传入我们定义的 URL 和头部，将响应对象分配给变量 `r`。
- en: The response object has an attribute called `status_code`, which tells us whether
    the request was successful. (A status code of 200 indicates a successful response.)
    We print the value of `status_code` so we can make sure the call went through
    successfully ❹. We asked the API to return the information in JSON format, so
    we use the `json()` method to convert the information to a Python dictionary ❺.
    We assign the resulting dictionary to `response_dict`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 响应对象有一个名为`status_code`的属性，它告诉我们请求是否成功。（状态码200表示响应成功。）我们打印`status_code`的值，以确保请求成功完成
    ❹。我们请求API以JSON格式返回信息，因此我们使用`json()`方法将信息转换为Python字典 ❺。我们将结果字典赋值给`response_dict`。
- en: 'Finally, we print the keys from `response_dict` and see the following output:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们打印`response_dict`中的键并查看以下输出：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Because the status code is `200`, we know that the request was successful.
    The response dictionary contains only three keys: `''total_count''`, `''incomplete_results''`,
    and `''items''`. Let’s take a look inside the response dictionary.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因为状态码是`200`，我们知道请求成功。响应字典只包含三个键：`'total_count'`、`'incomplete_results'`和`'items'`。让我们来看一下响应字典的内容。
- en: Working with the Response Dictionary
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理响应字典
- en: 'With the information from the API call represented as a dictionary, we can
    work with the data stored there. Let’s generate some output that summarizes the
    information. This is a good way to make sure we received the information we expected,
    and to start examining the information we’re interested in:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将API调用返回的信息表示为字典，我们可以处理存储在其中的数据。让我们生成一些输出，来总结这些信息。这是确保我们收到了预期信息并开始检查我们感兴趣的信息的好方法：
- en: '**python_repos.py**'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**python_repos.py**'
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We start exploring the response dictionary by printing the value associated
    with `''total_count''`, which represents the total number of Python repositories
    returned by this API call ❶. We also use the value associated with `''incomplete_results''`,
    so we''ll know if GitHub was able to fully process the query. Rather than printing
    this value directly, we print its opposite: a value of `True` will indicate that
    we received a complete set of results.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过打印与`'total_count'`关联的值开始探索响应字典，这个值表示该API调用返回的Python仓库的总数 ❶。我们还使用与`'incomplete_results'`关联的值，这样我们就能知道GitHub是否完全处理了查询。我们不是直接打印这个值，而是打印它的相反值：`True`值表示我们收到了完整的结果集。
- en: The value associated with `'items'` is a list containing a number of dictionaries,
    each of which contains data about an individual Python repository. We assign this
    list of dictionaries to `repo_dicts` ❷. We then print the length of `repo_dicts`
    to see how many repositories we have information for.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`''items''`对应的值是一个列表，列表中包含多个字典，每个字典包含一个独立的Python仓库的数据。我们将这个字典列表赋值给`repo_dicts`
    ❷。然后我们打印`repo_dicts`的长度，以查看我们拥有多少个仓库信息。'
- en: To look closer at the information returned about each repository, we pull out
    the first item from `repo_dicts` and assign it to `repo_dict` ❸. We then print
    the number of keys in the dictionary to see how much information we have ❹. Finally,
    we print all the dictionary’s keys to see what kind of information is included
    ❺.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更仔细地查看每个仓库返回的信息，我们从`repo_dicts`中取出第一个项目并赋值给`repo_dict` ❸。然后我们打印字典中的键的数量，以查看我们拥有多少信息
    ❹。最后，我们打印所有字典的键，以查看包含了哪些类型的信息 ❺。
- en: 'The results give us a clearer picture of the actual data:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 结果让我们更清楚地了解了实际的数据：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: At the time of this writing, there are only `248` Python repositories with over
    10,000 stars ❶. We can see that GitHub was able to fully process the API call
    ❷. In this response, GitHub returned information about the first `30` repositories
    that match the conditions of our query. If we want more repositories, we can request
    additional pages of data.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在写这篇文章时，只有`248`个Python仓库拥有超过10,000颗星 ❶。我们可以看到GitHub成功地处理了API请求 ❷。在这个响应中，GitHub返回了符合我们查询条件的前`30`个仓库的信息。如果我们想要更多仓库信息，可以请求更多的数据页。
- en: 'GitHub’s API returns a lot of information about each repository: there are
    `78` keys in `repo_dict` ❸. When you look through these keys, you’ll get a sense
    of the kind of information you can extract about a project. (The only way to know
    what information is available through an API is to read the documentation or to
    examine the information through code, as we’re doing here.)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub的API返回了关于每个仓库的大量信息：`repo_dict`中有`78`个键 ❸。当你查看这些键时，你会大致了解你可以从一个项目中提取什么类型的信息。（通过API能获取哪些信息，唯一的方式就是阅读文档或者通过代码查看信息，就像我们现在所做的那样。）
- en: 'Let’s pull out the values for some of the keys in `repo_dict`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们提取一些`repo_dict`中的键的值：
- en: '**python_repos.py**'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**python_repos.py**'
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, we print the values for a number of keys from the first repository’s dictionary.
    We start with the name of the project ❶. An entire dictionary represents the project’s
    owner, so we use the key `owner` to access the dictionary representing the owner,
    and then use the key `login` to get the owner’s login name ❷. Next, we print how
    many stars the project has earned ❸ and the URL for the project’s GitHub repository.
    We then show when it was created ❹ and when it was last updated ❺. Finally, we
    print the repository’s description.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们打印第一个仓库字典中多个键的值。我们从项目名称开始❶。整个字典表示项目的所有者，所以我们使用键`owner`来访问表示所有者的字典，然后使用键`login`来获取所有者的登录名❷。接下来，我们打印项目获得的星标数❸和该项目
    GitHub 仓库的 URL。然后，我们展示它的创建时间❹和最后更新时间❺。最后，我们打印仓库的描述。
- en: 'The output should look something like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应类似于以下内容：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We can see that the most-starred Python project on GitHub as of this writing
    is *public-apis*. Its owner is an organization with the same name, and it has
    been starred by almost 200,000 GitHub users. We can see the URL for the project’s
    repository, its creation date of March 2016, and that it was updated recently.
    Additionally, the description tells us that *public-apis* contains a list of free
    APIs that programmers might be interested in.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，截至目前，GitHub 上星标最多的 Python 项目是*public-apis*。它的所有者是一个同名的组织，已获得近 20 万 GitHub
    用户的星标。我们可以看到项目仓库的 URL、创建日期是 2016 年 3 月，并且它最近有更新。此外，描述中告诉我们，*public-apis* 包含了一份程序员可能感兴趣的免费
    API 列表。
- en: Summarizing the Top Repositories
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 汇总顶级仓库
- en: 'When we make a visualization for this data, we’ll want to include more than
    one repository. Let’s write a loop to print selected information about each repository
    the API call returns so we can include them all in the visualization:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们为这些数据制作可视化时，我们希望包含多个仓库。让我们写一个循环来打印每个 API 调用返回的仓库的选定信息，这样我们就能将它们全部包含在可视化中：
- en: '**python_repos.py**'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**python_repos.py**'
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We first print an introductory message ❶. Then we loop through all the dictionaries
    in `repo_dicts` ❷. Inside the loop, we print the name of each project, its owner,
    how many stars it has, its URL on GitHub, and the project’s description:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先打印一条介绍性消息❶。然后我们遍历`repo_dicts`中的所有字典❷。在循环内部，我们打印每个项目的名称、所有者、星标数量、GitHub 上的
    URL 以及项目描述：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Some interesting projects appear in these results, and it might be worth looking
    at a few. But don’t spend too much time here, because we’re about to create a
    visualization that will make the results much easier to read.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一些有趣的项目出现在这些结果中，可能值得看一看。但不要在这里花太多时间，因为我们即将创建一个可视化，使得这些结果更易于阅读。
- en: Monitoring API Rate Limits
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 监控 API 请求限制
- en: 'Most APIs have *rate limits*, which means there’s a limit to how many requests
    you can make in a certain amount of time. To see if you’re approaching GitHub’s
    limits, enter [https://api.github.com/rate_limit](https://api.github.com/rate_limit%20)
    into a web browser. You should see a response that begins like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 API 都有*请求限制*，这意味着你在一定时间内可以发出的请求数量是有限制的。要查看是否接近 GitHub 的限制，请在浏览器中输入[https://api.github.com/rate_limit](https://api.github.com/rate_limit)。你应该会看到类似以下的响应：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The information we’re interested in is the rate limit for the search API ❶.
    We see that the limit is 10 requests per minute ❷ and that we have 9 requests
    remaining for the current minute ❸. The value associated with the key `"reset"`
    represents the time in *Unix* or *epoch time* (the number of seconds since midnight
    on January 1, 1970) when our quota will reset ❹. If you reach your quota, you’ll
    get a short response that lets you know you’ve reached the API limit. If you reach
    the limit, just wait until your quota resets.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们关心的信息是搜索 API 的请求限制❶。我们看到限制是每分钟 10 次请求❷，并且当前分钟剩余 9 次请求❸。与键`"reset"`相关的值表示我们的配额将在何时重置，时间是*Unix*
    或 *epoch 时间*（自 1970 年 1 月 1 日午夜以来的秒数）❹。如果达到配额限制，你会收到一条简短的响应，告知你已达到 API 限制。如果你达到了限制，只需等待配额重置。
- en: Visualizing Repositories Using Plotly
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Plotly 可视化仓库
- en: 'Let’s make a visualization using the data we’ve gathered to show the relative
    popularity of Python projects on GitHub. We’ll make an interactive bar chart:
    the height of each bar will represent the number of stars the project has acquired,
    and you’ll be able to click the bar’s label to go to that project’s home on GitHub.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用收集到的数据制作一个可视化图，展示GitHub上Python项目的相对受欢迎程度。我们将制作一个交互式条形图：每个条形的高度表示该项目获得的星标数量，你可以点击条形的标签进入该项目在GitHub上的主页。
- en: 'Save a copy of the program we’ve been working on as *python_repos_visual.py*,
    then modify it so it reads as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们正在编写的程序保存为*python_repos_visual.py*，然后修改它，使其如下所示：
- en: '**python_repos_visual.py**'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**python_repos_visual.py**'
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We import Plotly Express and then make the API call as we have been doing. We
    continue to print the status of the API call response so we’ll know if there is
    a problem ❶. When we process the overall results, we continue to print the message
    confirming that we got a complete set of results ❷. We remove the rest of the
    `print()` calls because we’re no longer in the exploratory phase; we know we have
    the data we want.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入Plotly Express，然后像之前一样进行API调用。我们继续打印API调用响应的状态，以便在出现问题时知道❶。当我们处理总体结果时，继续打印确认信息，确保我们获得了完整的结果集❷。我们删除了其他的`print()`调用，因为我们不再处于探索阶段；我们知道我们已经得到了所需的数据。
- en: We then create two empty lists ❸ to store the data we’ll include in the initial
    chart. We’ll need the name of each project to label the bars (`repo_names`) and
    the number of stars to determine the height of the bars (`stars`). In the loop,
    we append the name of each project and the number of stars it has to these lists.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建两个空列表❸来存储将要包含在初始图表中的数据。我们需要每个项目的名称来标记条形图（`repo_names`），以及每个项目的星标数量来确定条形图的高度（`stars`）。在循环中，我们将每个项目的名称和星标数量追加到这两个列表中。
- en: We make the initial visualization with just two lines of code ❹. This is consistent
    with Plotly Express’s philosophy that you should be able to see your visualization
    as quickly as possible before refining its appearance. Here we use the `px.bar()`
    function to create a bar chart. We pass the list `repo_names` as the `x` argument
    and `stars` as the `y` argument.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用两行代码❹制作初步的可视化。这与Plotly Express的理念一致：在美化图表之前，你应该尽快看到你的可视化效果。在这里，我们使用`px.bar()`函数来创建条形图。我们将`repo_names`列表作为`x`参数，`stars`作为`y`参数。
- en: '[Figure 17-1](#figure17-1) shows the resulting chart. We can see that the first
    few projects are significantly more popular than the rest, but all of them are
    important projects in the Python ecosystem.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '[图17-1](#figure17-1)展示了最终的图表。我们可以看到，前几个项目比其他项目受欢迎得多，但它们都是Python生态系统中非常重要的项目。'
- en: '![](image_fi/502703c17/f17001.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502703c17/f17001.png)'
- en: 'Figure 17-1: The most-starred Python projects on GitHub'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图17-1：GitHub上最受星标的Python项目
- en: Styling the Chart
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 样式调整图表
- en: Plotly supports a number of ways to style and customize the plots, once you
    know the information in the plot is correct. We’ll make some changes in the initial
    `px.bar()` call and then make some further adjustments to the `fig` object after
    it’s been created.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦确认图表中的信息正确，Plotly支持多种方式来调整和定制图表样式。我们将在最初的`px.bar()`调用中做一些修改，然后在图表创建后对`fig`对象进行进一步调整。
- en: 'We’ll start styling the chart by adding a title and labels for each axis:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过为每个坐标轴添加标题和标签来开始为图表进行样式调整：
- en: '**python_repos_visual.py**'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**python_repos_visual.py**'
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We first add a title and labels for each axis, as we did in Chapters 15 and
    16. We then use the `fig.update_layout()` method to modify specific elements of
    the chart ❶. Plotly uses a convention where aspects of a chart element are connected
    by underscores. As you become familiar with Plotly’s documentation, you’ll start
    to see consistent patterns in how different elements of a chart are named and
    modified. Here we set the title font size to `28` and the font size for each axis
    title to `20`. The result is shown in [Figure 17-2](#figure17-2).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先添加一个标题和每个坐标轴的标签，正如我们在第15章和第16章中所做的那样。然后，我们使用`fig.update_layout()`方法来修改图表的特定元素❶。Plotly使用一种约定，图表元素的各个方面通过下划线连接。当你熟悉Plotly的文档时，你会开始发现不同图表元素的命名和修改存在一致的模式。在这里，我们将标题的字体大小设置为`28`，每个坐标轴标题的字体大小设置为`20`。结果如[图17-2](#figure17-2)所示。
- en: '![](image_fi/502703c17/f17002.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502703c17/f17002.png)'
- en: 'Figure 17-2: A title has been added to the main chart, and to each axis as
    well.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图17-2：已经为主图表和每个坐标轴添加了标题。
- en: Adding Custom Tooltips
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加自定义工具提示
- en: In Plotly, you can hover the cursor over an individual bar to show the information
    the bar represents. This is commonly called a *tooltip*, and in this case, it
    currently shows the number of stars a project has. Let’s create a custom tooltip
    to show each project’s description as well as the project’s owner.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在Plotly中，你可以将光标悬停在单个柱状条上，以显示该柱状条所表示的信息。这通常被称为*工具提示*，在本例中，它目前显示项目的星标数。让我们创建一个自定义工具提示，显示每个项目的描述以及项目的所有者。
- en: 'We need to pull some additional data to generate the tooltips:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要提取一些额外的数据来生成工具提示：
- en: '**python_repos_visual.py**'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**python_repos_visual.py**'
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We first define a new empty list, `hover_texts`, to hold the text we want to
    display for each project ❶. In the loop where we process the data, we pull the
    owner and the description for each project ❷. Plotly allows you to use HTML code
    within text elements, so we generate a string for the label with a line break
    (`<br />`) between the project owner’s username and the description ❸. We then
    append this label to the list `hover_texts`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义一个新的空列表`hover_texts`，用于存储我们希望为每个项目显示的文本❶。在处理数据的循环中，我们提取每个项目的所有者和描述❷。Plotly允许在文本元素中使用HTML代码，因此我们生成一个包含换行符(`<br
    />`)的标签字符串，将项目所有者的用户名与描述分隔开❸。然后，我们将此标签附加到列表`hover_texts`中。
- en: In the `px.bar()` call, we add the `hover_name` argument and pass it `hover_texts`
    ❹. This is the same approach we used to customize the label for each dot in the
    map of global earthquake activity. As Plotly creates each bar, it will pull labels
    from this list and only display them when the viewer hovers over a bar. [Figure
    17-3](#figure17-3) shows one of these custom tooltips.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在`px.bar()`调用中，我们添加了`hover_name`参数，并将`hover_texts`传递给它❹。这与我们自定义全球地震活动图中每个点标签的做法相同。当Plotly创建每个柱状条时，它会从此列表中提取标签，并且只有当观众将光标悬停在柱状条上时才会显示这些标签。[图17-3](#figure17-3)展示了其中一个自定义工具提示。
- en: '![](image_fi/502703c17/f17003.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502703c17/f17003.png)'
- en: 'Figure 17-3: Hovering over a bar shows the project’s owner and description.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图17-3：悬停在柱状图上会显示项目的所有者和描述。
- en: Adding Clickable Links
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加可点击链接
- en: 'Because Plotly allows you to use HTML on text elements, we can easily add links
    to a chart. Let’s use the *x*-axis labels as a way to let the viewer visit any
    project’s home page on GitHub. We need to pull the URLs from the data and use
    them when generating the *x*-axis labels:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Plotly允许在文本元素中使用HTML，我们可以轻松地在图表中添加链接。我们可以使用*x*-轴标签作为方式，让观众访问任何项目在GitHub上的主页。我们需要从数据中提取URLs，并在生成*x*-轴标签时使用它们：
- en: '**python_repos_visual.py**'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**python_repos_visual.py**'
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We update the name of the list we’re creating from `repo_names` to `repo_links`
    to more accurately communicate the kind of information we’re putting together
    for the chart ❶. We then pull the URL for the project from `repo_dict` and assign
    it to the temporary variable `repo_url` ❷. Next, we generate a link to the project
    ❸. We use the HTML anchor tag, which has the form `<a href='URL'>link text</a>`,
    to generate the link. We then append this link to `repo_links`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建的列表名称从`repo_names`更新为`repo_links`，以更准确地传达我们为图表整理的信息类型❶。然后，我们从`repo_dict`中提取项目的URL，并将其赋值给临时变量`repo_url`❷。接下来，我们生成指向项目的链接❸。我们使用HTML锚标签，它的形式为`<a
    href='URL'>链接文本</a>`，来生成链接。然后，我们将这个链接附加到`repo_links`中。
- en: When we call `px.bar()`, we use `repo_links` for the *x*-values in the chart.
    The result looks the same as before, but now the viewer can click any of the project
    names at the bottom of the chart to visit that project’s home page on GitHub.
    Now we have an interactive, informative visualization of data retrieved through
    an API!
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用`px.bar()`时，我们使用`repo_links`作为图表中的*x*值。结果看起来和之前一样，但现在观众可以点击图表底部的任何项目名称，访问该项目在GitHub上的主页。现在我们有了一个互动的、富有信息的可视化，展示了通过API检索的数据！
- en: Customizing Marker Colors
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义标记颜色
- en: Once a chart has been created, almost any aspect of the chart can be customized
    through an update method. We’ve used the `update_layout()` method previously.
    Another method, `update_traces()`, can be used to customize the data that’s represented
    on a chart.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦图表创建完成，几乎图表的任何方面都可以通过更新方法进行自定义。我们之前使用过`update_layout()`方法。另一个方法`update_traces()`可以用来定制图表上呈现的数据。
- en: 'Let’s change the bars to a darker blue, with some transparency:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将柱状图的颜色改为更深的蓝色，并添加一些透明度：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In Plotly, a *trace* refers to a collection of data on a chart. The `update_traces()`
    method can take a number of different arguments; any argument that starts with
    `marker_` affects the markers on the chart. Here we set each marker’s color to
    `'SteelBlue'`; any named CSS color will work here. We also set the opacity of
    each marker to `0.6`. An opacity of 1.0 will be entirely opaque, and an opacity
    of 0 will be entirely invisible.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Plotly 中，*trace* 指的是图表上的一组数据。`update_traces()` 方法可以接受多种不同的参数；任何以 `marker_`
    开头的参数都会影响图表上的标记。这里，我们将每个标记的颜色设置为 `'SteelBlue'`；任何命名的 CSS 颜色都可以在这里使用。我们还将每个标记的透明度设置为
    `0.6`。透明度为 1.0 时，标记将完全不透明；透明度为 0 时，标记将完全透明。
- en: More About Plotly and the GitHub API
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更多关于 Plotly 和 GitHub API 的内容
- en: Plotly’s documentation is extensive and well organized; however, it can be hard
    to know where to start reading. A good place to start is with the article “Plotly
    Express in Python,” at [https://plotly.com/python/plotly-express](https://plotly.com/python/plotly-express).
    This is an overview of all the plots you can make with Plotly Express, and you
    can find links to longer articles about each individual chart type.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Plotly 的文档内容丰富且组织良好；然而，可能很难知道从哪里开始阅读。一个不错的起点是阅读文章《Python 中的 Plotly Express》，地址是：[https://plotly.com/python/plotly-express](https://plotly.com/python/plotly-express)。这篇文章概述了你可以使用
    Plotly Express 制作的所有图表，并且你可以找到关于每种单独图表类型的更长文章的链接。
- en: If you want to understand how to customize Plotly charts better, the article
    “Styling Plotly Express Figures in Python” will expand on what you’ve seen in
    Chapters 15–17. You can find this article at [https://plotly.com/python/styling-plotly-express](https://plotly.com/python/styling-plotly-express).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想更好地理解如何自定义 Plotly 图表，文章《Python 中的 Plotly Express 图表样式》将进一步扩展你在第 15 到 17
    章中看到的内容。你可以在这里找到这篇文章：[https://plotly.com/python/styling-plotly-express](https://plotly.com/python/styling-plotly-express)。
- en: For more about the GitHub API, refer to its documentation at [https://docs.github.com/en/rest](https://docs.github.com/en/rest).
    Here you’ll learn how to pull a wide variety of information from GitHub. To expand
    on what you saw in this project, look for the Search section of the reference
    in the sidebar. If you have a GitHub account, you can work with your own data
    as well as the publicly available data from other users’ repositories.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 GitHub API 的更多信息，请参考它的文档：[https://docs.github.com/en/rest](https://docs.github.com/en/rest)。在这里，你将了解如何从
    GitHub 拉取各种各样的信息。要扩展你在这个项目中看到的内容，可以在侧边栏中查找参考文献的搜索部分。如果你有 GitHub 账户，你也可以使用自己的数据以及其他用户的公开数据进行操作。
- en: The Hacker News API
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Hacker News API
- en: To explore how to use API calls on other sites, let’s take a quick look at Hacker
    News ([https://news.ycombinator.com](https://news.ycombinator.com)). On Hacker
    News, people share articles about programming and technology and engage in lively
    discussions about those articles. The Hacker News API provides access to data
    about all submissions and comments on the site, and you can use the API without
    having to register for a key.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了探索如何在其他网站上使用 API 调用，我们来快速看一下 Hacker News（[https://news.ycombinator.com](https://news.ycombinator.com)）。在
    Hacker News 上，人们分享关于编程和技术的文章，并就这些文章进行热烈讨论。Hacker News 的 API 提供了对网站上所有提交和评论的数据访问，你可以在无需注册
    API 密钥的情况下使用这个 API。
- en: 'The following call returns information about the current top article as of
    this writing:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下调用返回了截至目前的当前热门文章的信息：
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When you enter this URL in a browser, you’ll see that the text on the page
    is enclosed by braces, meaning it’s a dictionary. But the response is difficult
    to examine without some better formatting. Let’s run this URL through the `json.dumps()`
    method, like we did in the earthquake project in Chapter 16, so we can explore
    the kind of information that’s returned about an article:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在浏览器中输入这个 URL 时，你会看到页面上的文本被大括号括起来，这意味着它是一个字典。但是，如果没有更好的格式化，响应是很难查看的。让我们像第16章的地震项目中那样，通过`json.dumps()`方法运行这个
    URL，这样我们就能探索返回的关于文章的信息：
- en: '**hn_article.py**'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**hn_article.py**'
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Everything in this program should look familiar, because we’ve used it all in
    the previous two chapters. The main difference here is that we can print the formatted
    response string ❶ instead of writing it to a file, because the output is not particularly
    long.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序中的所有内容应该都很熟悉，因为我们在前两章中已经使用过它。这里的主要区别是，我们可以打印格式化后的响应字符串❶，而不是将其写入文件，因为输出并不特别长。
- en: 'The output is a dictionary of information about the article with the ID `31353677`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是关于 ID 为`31353677`的文章的字典信息：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The dictionary contains a number of keys we can work with. The key `"descendants"`
    tells us the number of comments the article has received ❶. The key `"kids"` provides
    the IDs of all comments made directly in response to this submission ❷. Each of
    these comments might have comments of their own as well, so the number of descendants
    a submission has is usually greater than its number of kids. We can see the title
    of the article being discussed ❸ and a URL for the article being discussed as
    well ❹.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这个字典包含了我们可以使用的多个键。键`"descendants"`告诉我们文章收到的评论数❶。键`"kids"`提供了所有直接响应该提交的评论ID❷。这些评论可能也会有自己的评论，因此一个提交的`descendants`通常会多于`kids`。我们可以看到正在讨论的文章的标题❸，以及该文章的URL❹。
- en: 'The following URL returns a simple list of all the IDs of the current top articles
    on Hacker News:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 以下URL返回了一个简单的列表，列出了当前Hacker News上最热门文章的所有ID：
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can use this call to find out which articles are on the home page right
    now, and then generate a series of API calls similar to the one we just examined.
    With this approach, we can print a summary of all the articles on the front page
    of Hacker News at the moment:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用此调用来查找当前首页上的文章，并生成一系列类似于我们刚才查看的API调用。通过这种方法，我们可以打印出当前Hacker News首页所有文章的摘要：
- en: '**hn_submissions.py**'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**hn_submissions.py**'
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: First, we make an API call and print the status of the response ❶. This API
    call returns a list containing the IDs of up to 500 of the most popular articles
    on Hacker News at the time the call is issued. We then convert the response object
    to a Python list ❷, which we assign to `submission_ids`. We’ll use these IDs to
    build a set of dictionaries, each of which contains information about one of the
    current submissions.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们进行一次API调用，并打印响应的状态❶。此API调用会返回一个列表，包含调用时Hacker News上最多500篇最受欢迎文章的ID。然后，我们将响应对象转换为一个Python列表❷，并将其赋值给`submission_ids`。我们将使用这些ID来构建一个包含当前提交信息的字典集合。
- en: We set up an empty list called `submission_dicts` to store these dictionaries
    ❸. We then loop through the IDs of the top 30 submissions. We make a new API call
    for each submission by generating a URL that includes the current value of `submission_id`
    ❹. We print the status of each request along with its ID, so we can see whether
    it’s successful.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置了一个空的列表，名为`submission_dicts`，用于存储这些字典❸。然后，我们循环遍历前30个提交的ID。我们为每个提交生成一个包含当前`submission_id`值的URL，进行新的API调用❹。我们打印每个请求的状态及其ID，以便查看请求是否成功。
- en: Next, we create a dictionary for the submission currently being processed ❺.
    We store the title of the submission, a link to the discussion page for that item,
    and the number of comments the article has received so far. Then we append each
    `submission_dict` to the list `submission_dicts` ❻.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为当前正在处理的提交创建一个字典❺。我们存储该提交的标题、讨论页面的链接以及该文章目前收到的评论数。然后，我们将每个`submission_dict`追加到`submission_dicts`列表中❻。
- en: Each submission on Hacker News is ranked according to an overall score based
    on a number of factors, including how many times it’s been voted on, how many
    comments it’s received, and how recent the submission is. We want to sort the
    list of dictionaries by the number of comments. To do this, we use a function
    called `itemgetter()` ❼, which comes from the `operator` module. We pass this
    function the key `'comments'`, and it pulls the value associated with that key
    from each dictionary in the list. The `sorted()` function then uses this value
    as its basis for sorting the list. We sort the list in reverse order, to place
    the most-commented stories first.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Hacker News上的每个提交都会根据多个因素进行排名，包括投票次数、收到的评论数和提交的时间等。我们希望根据评论数对字典列表进行排序。为此，我们使用了一个名为`itemgetter()`的函数❼，它来自`operator`模块。我们将这个函数的键`'comments'`传递给它，函数会从列表中的每个字典中提取该键的值。然后，`sorted()`函数使用这个值来排序列表。我们按降序排序，以将评论数最多的文章排在最前面。
- en: 'Once the list is sorted, we loop through the list ❽ and print out three pieces
    of information about each of the top submissions: the title, a link to the discussion
    page, and the number of comments the submission currently has:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦列表排序完成，我们遍历列表❽并打印出每个顶级提交的三条信息：标题、讨论页面的链接以及该提交目前的评论数：
- en: '[PRE23]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You would use a similar process to access and analyze information with any API.
    With this data, you could make a visualization showing which submissions have
    inspired the most active recent discussions. This is also the basis for apps that
    provide a customized reading experience for sites like Hacker News. To learn more
    about what kind of information you can access through the Hacker News API, visit
    the documentation page at [https://github.com/HackerNews/API](https://github.com/HackerNews/API).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用类似的过程通过任何 API 访问和分析信息。通过这些数据，你可以创建一个可视化，显示哪些提交激发了最活跃的近期讨论。这也是为像 Hacker
    News 这样的站点提供定制化阅读体验的基础。要了解更多关于如何通过 Hacker News API 访问的信息，请访问文档页面 [https://github.com/HackerNews/API](https://github.com/HackerNews/API)。
- en: Summary
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how to use APIs to write self-contained programs
    that automatically gather the data they need and use that data to create a visualization.
    You used the GitHub API to explore the most-starred Python projects on GitHub,
    and you also looked briefly at the Hacker News API. You learned how to use the
    Requests package to automatically issue an API call and how to process the results
    of that call. We also introduced some Plotly settings that further customize the
    appearance of the charts you generate.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何使用 API 编写自包含程序，自动收集所需的数据，并利用这些数据创建可视化。你使用了 GitHub API 探索了 GitHub
    上最受欢迎的 Python 项目，并且简要了解了 Hacker News API。你学会了如何使用 Requests 包自动发起 API 请求，并处理该请求的结果。我们还介绍了一些
    Plotly 设置，用于进一步自定义你生成的图表外观。
- en: In the next chapter, you’ll use Django to build a web application as your final
    project.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，你将使用 Django 构建一个 Web 应用程序作为最终项目。
