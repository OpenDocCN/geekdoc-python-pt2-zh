- en: Part I
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一部分
- en: Getting Started
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 入门
- en: '1'
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Setting Up Python, Anaconda, and Spyder
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 设置Python、Anaconda和Spyder
- en: '![](Images/chapterart.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: Even if you’ve never coded before, this chapter will guide you through installing
    the Python software you need to start running Python scripts for this book. We’ll
    be using Anaconda and Spyder, so we’ll discuss the advantages of choosing this
    Python distribution and development environment, respectively. I’ll guide you
    through the installation process based on your operating system, whether that’s
    Windows, Mac, or Linux. Then you’ll learn how to start coding in the Spyder editor.
    We’ll discuss basic Python rules and operations at the end.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你之前从未编写过代码，本章也会指导你安装运行本书Python脚本所需的软件。我们将使用Anaconda和Spyder，因此我们将分别讨论选择此Python发行版和开发环境的优点。我会根据你的操作系统（无论是Windows、Mac还是Linux）指导你完成安装过程。然后，你将学习如何在Spyder编辑器中开始编写代码。最后，我们将讨论基本的Python规则和操作。
- en: Before you begin, set up the folder */mpt/ch01/* for this chapter on your computer.
    All scripts in this chapter (and later chapters) are available at the book’s resources
    page, [https://www.nostarch.com/make-python-talk/](https://www.nostarch.com/make-python-talk/).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，在你的计算机上为本章创建文件夹*/mpt/ch01/*。本章（及后续章节）中的所有脚本都可以在本书的资源页面找到，[https://www.nostarch.com/make-python-talk/](https://www.nostarch.com/make-python-talk/)。
- en: Introducing Anaconda and Spyder
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍Anaconda和Spyder
- en: There are many ways to install Python and run scripts. In this book, we’ll use
    Anaconda and Spyder.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Python并运行脚本有很多方法。在本书中，我们将使用Anaconda和Spyder。
- en: '*Anaconda* is an open source Python distribution, package, and environment
    manager. It is user friendly and provides for the easy installation of many useful
    Python modules that otherwise can be quite a pain to compile and install yourself.
    We’ll start by downloading the Anaconda distribution of Python that comes bundled
    with Spyder.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*Anaconda*是一个开源的Python发行版、包和环境管理器。它用户友好，提供了许多实用的Python模块，安装这些模块本来可能非常麻烦。我们将从下载带有Spyder的Anaconda
    Python发行版开始。'
- en: '*Spyder* is a full-featured integrated development environment (IDE) for writing
    scripts. It comes with many useful features such as automatic code completion,
    automatic debugging, code suggestions, and warnings.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*Spyder*是一个功能完整的集成开发环境（IDE），用于编写脚本。它提供许多有用的功能，如自动代码补全、自动调试、代码建议和警告。'
- en: Installing Anaconda and Spyder
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Anaconda和Spyder
- en: Python is a cross-platform programming language, meaning you can run Python
    scripts whether you use Windows, Mac, or Linux. However, the installation of software
    and modules can be slightly different depending on your operating system. I’ll
    show you how to install various modules in your operating system. Once these are
    properly installed, Python code works the same in different operating systems.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Python是一个跨平台的编程语言，意味着你可以在Windows、Mac或Linux上运行Python脚本。然而，软件和模块的安装在不同操作系统上可能会有所不同。我将展示如何在你的操作系统中安装各种模块。一旦这些模块正确安装，Python代码在不同操作系统中运行是一样的。
- en: Install Anaconda and Spyder in Windows
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Windows上安装Anaconda和Spyder
- en: To install Anaconda in Windows, go to [https://www.anaconda.com/products/individual/](https://www.anaconda.com/products/individual/)
    and download the latest version of Python 3 for Windows.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Windows上安装Anaconda，请访问[https://www.anaconda.com/products/individual/](https://www.anaconda.com/products/individual/)并下载最新版本的Python
    3。
- en: I recommend using the graphical installer instead of the command line installer,
    especially for beginners, to avoid mistakes. Make sure you download the appropriate
    32- or 64-bit package for your machine. Run the installer and follow the instructions
    all the way through.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我推荐使用图形安装程序，而不是命令行安装程序，特别是对初学者来说，以避免错误。确保下载适合你机器的32位或64位版本。运行安装程序并按照提示完成安装。
- en: Find and open the Anaconda navigator, and you should see a screen like [Figure
    1-1](#figure1-1) (if you need to, search for *Anaconda navigator* in the search
    bar).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 找到并打开Anaconda导航器，你应该能看到像[图1-1](#figure1-1)那样的界面（如果需要，可以在搜索栏中搜索*Anaconda navigator*）。
- en: '![f01001](Images/f01001.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![f01001](Images/f01001.png)'
- en: 'Figure 1-1: The Anaconda navigator'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-1：Anaconda导航器
- en: Click the **Launch** button under the Spyder icon. If Spyder is not already
    installed, click **Install** to install the Spyder development environment. After
    it finishes, click **Launch**.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**启动**按钮，位于Spyder图标下方。如果Spyder尚未安装，点击**安装**以安装Spyder开发环境。安装完成后，点击**启动**。
- en: Install Anaconda and Spyder in macOS
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在macOS中安装Anaconda和Spyder
- en: To install Python via Anaconda for macOS, go to [https://www.anaconda.com/products/individual/](https://www.anaconda.com/products/individual/),
    scroll down, and download the latest version of Python 3 for Mac. Choose the graphical
    installer and follow the instructions through.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过 Anaconda 在 macOS 上安装 Python，请访问[https://www.anaconda.com/products/individual/](https://www.anaconda.com/products/individual/)，向下滚动并下载适用于
    Mac 的最新 Python 3 版本。选择图形安装程序并按照提示进行操作。
- en: Open the Anaconda navigator by searching for *Anaconda navigator* in Spotlight
    search. The screen for the Anaconda navigator in macOS should look similar to
    [Figure 1-1](#figure1-1), perhaps with slight differences.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 Spotlight 搜索中搜索*Anaconda navigator*来打开 Anaconda 导航器。macOS 中的 Anaconda 导航器界面应类似于[图
    1-1](#figure1-1)，可能会有一些小的差异。
- en: To launch Spyder, click **Launch** under the Spyder icon (if you see an **Install**
    button instead, click it to install Spyder first).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动 Spyder，请点击 Spyder 图标下的**启动**按钮（如果您看到的是**安装**按钮，请点击它先安装 Spyder）。
- en: Install Anaconda and Spyder in Linux
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Linux 上安装 Anaconda 和 Spyder
- en: The installation of Anaconda and Spyder in Linux involves more steps than for
    other operating systems. First, go to [https://www.anaconda.com/products/individual/](https://www.anaconda.com/products/individual/),
    scroll down, and find the latest Linux version. Choose the appropriate x86 or
    Power8 and Power9 package. Click and download the latest installer bash script.
    For example, the installer bash script during my installation was [https://repo.anaconda.com/archive/Anaconda3-2020.11-Linux-x86_64.sh](https://repo.anaconda.com/archive/Anaconda3-2020.11-Linux-x86_64.sh).
    This link will change over time, but we’ll use this version as our example.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 上安装 Anaconda 和 Spyder的步骤比其他操作系统更多。首先，访问[https://www.anaconda.com/products/individual/](https://www.anaconda.com/products/individual/)，向下滚动并找到最新的
    Linux 版本。选择适当的 x86 或 Power8 和 Power9 包。点击并下载最新的安装脚本。例如，在我的安装过程中，安装脚本的链接是[https://repo.anaconda.com/archive/Anaconda3-2020.11-Linux-x86_64.sh](https://repo.anaconda.com/archive/Anaconda3-2020.11-Linux-x86_64.sh)。此链接会随时间变化，但我们将以此版本作为示例。
- en: By default, the installer bash script is downloaded and saved to the *Downloads*
    folder on your computer. You should then install Anaconda as follows using the
    path for your bash script if it is different.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，安装脚本会下载并保存在您的计算机的*下载*文件夹中。如果您的 bash 脚本路径不同，您应按照以下方式安装 Anaconda。
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After pressing enter, you’ll be prompted to review and approve the license
    agreement. The last question in the installation process is this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 按下回车后，系统会提示您查看并同意许可协议。安装过程中的最后一个问题是：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You should type `yes` and press enter in order to use the `conda` command to
    open Anaconda in a terminal.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 您应输入 `yes` 并按回车，以便在终端中使用 `conda` 命令打开 Anaconda。
- en: 'Now you need to activate the installation by executing this command:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您需要通过执行以下命令来激活安装：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To open Anaconda navigator, enter the following command in a terminal:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要打开 Anaconda 导航器，请在终端中输入以下命令：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You should see the Anaconda navigator on your machine, similar to [Figure 1-1](#figure1-1).
    To launch Spyder, click the **Launch** button under the Spyder icon (if you see
    an **Install** button instead, click it to install Spyder first).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在您的计算机上看到 Anaconda 导航器，类似于[图 1-1](#figure1-1)。要启动 Spyder，请点击 Spyder 图标下的**启动**按钮（如果您看到的是**安装**按钮，请点击它先安装
    Spyder）。
- en: Using Spyder
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Spyder
- en: To get you up and running, we’ll build a really simple script in Spyder. Then
    I’ll run through a few basic concepts that’ll be useful to know before you start
    coding for real.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助您快速上手，我们将在 Spyder 中创建一个非常简单的脚本。接着我将介绍一些在开始编写代码之前非常有用的基本概念。
- en: Write Python in Spyder
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Spyder 中编写 Python 代码
- en: As mentioned earlier, Spyder is a full-featured IDE. Let’s start with a simple
    script. After you launch the Spyder development environment, you should see a
    layout like [Figure 1-2](#figure1-2).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Spyder 是一个功能齐全的集成开发环境（IDE）。让我们从一个简单的脚本开始。在启动 Spyder 开发环境后，您应该会看到类似于[图 1-2](#figure1-2)的布局。
- en: '![f01002](Images/f01002.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![f01002](Images/f01002.png)'
- en: 'Figure 1-2: Spyder development environment'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-2：Spyder 开发环境
- en: Spyder comes with several predefined layouts, and you can customize layouts
    according to your preferences. The default layout has three panels. Let’s examine
    that default.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Spyder 带有几个预定义的布局，您可以根据个人喜好自定义布局。默认布局包含三个面板。让我们来看看这个默认布局。
- en: At the left is the *Spyder editor*, in which you can write Python code. At the
    top right is the *variable explorer*, which shows the details of the data generated
    by your script. As scripts become quite complicated, the variable explorer becomes
    a valuable asset in double-checking the values stored in your variables.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧是*Spyder编辑器*，你可以在其中编写Python代码。右上方是*变量资源管理器*，它显示你的脚本生成的数据的详细信息。随着脚本变得复杂，变量资源管理器成为一个重要的工具，帮助你检查变量中存储的值。
- en: At the bottom right is the *interactive Python (IPython) console*, which shows
    the output of the script or executes snippets of Python code. The IPython console
    is also where you enter input for scripts that require user information. It also
    displays error messages if you make a mistake in your script.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 右下角是*交互式Python（IPython）控制台*，它显示脚本的输出或执行Python代码片段。IPython控制台也是你输入需要用户信息的脚本输入的地方。如果脚本中有错误，它也会显示错误信息。
- en: 'Now let’s start coding. Go to the Spyder editor window (again, the default
    location is on the left) and enter this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始编程。前往Spyder编辑器窗口（默认位置在左侧），并输入以下代码：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Click **File**▶**Save As** and save the file as *my_first_script.py* in your
    chapter folder.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**文件**▶**另存为**，并将文件保存为*my_first_script.py*，保存在你的章节文件夹中。
- en: 'There are three ways to run scripts, and all lead to the same outcome:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本有三种方式，所有方式都会导致相同的结果：
- en: Go to the **Run** menu and select **Run**.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到**运行**菜单并选择**运行**。
- en: Press F5 on your keyboard.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下键盘上的F5键。
- en: Press the green triangle icon ► in the icons bar.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下图标栏中的绿色三角形图标►。
- en: 'Run the script and you should see something like [Figure 1-3](#figure1-3).
    The output, shown in the IPython console, is a simple printed message: `This is
    my very first Python script!` Congratulations—you have written and successfully
    run your first Python script!'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本后，你应该会看到类似[图1-3](#figure1-3)的内容。在IPython控制台中显示的输出是一个简单的打印信息：`This is my
    very first Python script!` 恭喜你——你已经编写并成功运行了你的第一个Python脚本！
- en: '![f01003](Images/f01003.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![f01003](Images/f01003.png)'
- en: 'Figure 1-3: Running a script in the Spyder development environment'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-3：在Spyder开发环境中运行脚本
- en: Inspect Code in Spyder
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查Spyder中的代码
- en: 'Besides running an entire script, Spyder has the ability to run code line by
    line or block by block. Running a piece of a script at a time is useful for carefully
    following the execution of a script, to verify that it does exactly what you intended
    it to do. Go back to the *my_first_script.py* example and add another line:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 除了运行整个脚本，Spyder还可以逐行或逐块运行代码。逐步运行脚本对于仔细跟踪脚本的执行非常有用，可以验证脚本是否完全按照你的预期执行。返回到*my_first_script.py*示例，并添加另一行：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Place your cursor over this second line and press F9, and you should see the
    output shown in [Figure 1-4](#figure1-4).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 将光标放在第二行上并按F9键，你应该能看到如[图1-4](#figure1-4)所示的输出。
- en: '![f01004](Images/f01004.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![f01004](Images/f01004.png)'
- en: 'Figure 1-4: Running just one line of code in the Spyder editor'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-4：在Spyder编辑器中仅运行一行代码
- en: 'As you can see, only the highlighted line is executed. Here’s the output:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，只有高亮的那一行被执行。输出如下：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now press F5, and you’ll see that every line in the script is executed:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在按F5键，你会看到脚本中的每一行都被执行：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: To run a particular block of code, highlight those lines of code and press F9\.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 若要运行特定的代码块，选中这些行并按F9键\。
- en: Understanding Coding in Python
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解Python编程
- en: Before we get into the coding concepts of Python, you need to understand a few
    general things. This section introduces Python syntax and basic mathematical operations.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始介绍Python的编程概念之前，你需要了解一些基本的内容。本节将介绍Python的语法和基本的数学运算。
- en: Python Syntax
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python语法
- en: First, Python is case-sensitive. You should take great care when it comes to
    uppercase and lowercase letters. The variables *X* and *Y* are different from
    the variables *x* and *y*. The strings `"Hello"` and `"hello"` are also different
    from each other.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，Python是区分大小写的。在处理大写字母和小写字母时，你需要非常小心。变量*X*和*Y*与变量*x*和*y*是不同的。字符串`"Hello"`和`"hello"`也彼此不同。
- en: Second, indentations are significant in Python. Nonprinting characters like
    tabs must be consistently applied throughout a script. If you have experience
    with another programming language, like C or Java, you may notice the lack of
    brackets and semicolons in Python; this is by design. Blocks of code are defined
    by indentation. An unintended space in the code will likely betray your intentions,
    as we’ll see in Chapter 2 when we discuss indentations in conditional executions,
    loops, and functions.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，在 Python 中缩进非常重要。像制表符这样的不可打印字符必须在整个脚本中一致地应用。如果你有其他编程语言的经验，比如 C 或 Java，你可能会注意到
    Python 中缺少括号和分号；这是故意设计的。代码块通过缩进来定义。代码中的不必要空格很可能会暴露你的意图，正如我们在第二章讨论条件执行、循环和函数中的缩进时所看到的那样。
- en: Third, Python uses single quotation marks and double quotation marks (mostly)
    interchangeably. For example, placing a sequence of characters inside single quotes
    has the same effect as if we put them in double quotes (unless one of the characters
    is an escape character or a single quote).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，Python 使用单引号和双引号（大多数情况下）可以互换使用。例如，将字符序列放在单引号内与放在双引号内效果相同（除非其中某个字符是转义字符或单引号）。
- en: 'Fourth, Python lets you make notes, known as *comments*. One popular way to
    write a comment uses the hash mark (`#`). Everything in the same line after `#`
    will not be executed. It’s good practice to make notes in your scripts so others
    can more easily understand what the code is doing—and to remind yourself of the
    decisions you’ve made when you revisit the code after a few weeks or a few months.
    For example, in the very first line in *my_first_script.py*, we have this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 第四，Python 允许你做注释，这些注释被称为*注释*。一种常用的写注释的方法是使用井号（`#`）。井号后面的内容在同一行中不会被执行。最好在你的脚本中做些注释，这样别人可以更容易理解代码的作用——并且当你在几周或几个月后重新查看代码时，也能提醒自己当初做出的决定。例如，在
    *my_first_script.py* 的第一行，我们有以下内容：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Since this line starts with `#`, Python ignores it, understanding that it’s
    a comment and not code to execute.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这一行以 `#` 开头，Python 会忽略它，理解它是注释而不是需要执行的代码。
- en: 'When you have a comment that can’t fit on one line, you can place the comment
    in triple quotation marks (`"""`), and everything between the first set of quotes
    and the last set will not be executed by the Python script. For example, in lines
    2 to 6 in *my_first_script.py*, we have this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的注释不能写在一行时，你可以将注释放在三重引号（`"""`）中，第一组引号和最后一组引号之间的内容不会被 Python 脚本执行。例如，在 *my_first_script.py*
    的第 2 到第 6 行，我们有以下内容：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: All those lines are ignored by Python.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些行都会被 Python 忽略。
- en: Basic Operations in Python
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python 中的基本操作
- en: 'Python is capable of basic math operations. For example, to calculate 7 multiplied
    by 123, you enter the following in the Spyder editor:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Python 能够进行基本的数学运算。例如，要计算 7 乘以 123，你可以在 Spyder 编辑器中输入以下内容：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Place your cursor in this line, press F9, and you will get an output of 861.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 将光标放在这一行，按 F9，你会得到输出 861。
- en: '[Table 1-1](#table1-1) provides the other basic math operations in Python.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 1-1](#table1-1) 提供了 Python 中的其他基本数学运算。'
- en: 'Table 1-1: Basic Math Operators'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1-1：基本数学运算符
- en: '| **Operators** | **Action** |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| **运算符** | **操作** |'
- en: '| --- | --- |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `+` | Addition: `print(5+6)` will give you a result of `11`. |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `+` | 加法：`print(5+6)`会给你一个结果`11`。|'
- en: '| `-` | Subtraction: `print(9-4)` will give you a result of `5`. |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `-` | 减法：`print(9-4)`会给你一个结果`5`。|'
- en: '| `/` | Division: `print(9/3)` will give you a result of `3`. |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `/` | 除法：`print(9/3)`会给你一个结果`3`。|'
- en: '| `**` | Exponent: `print(5**3)` will give you a result of `125`. |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `**` | 指数：`print(5**3)`会给你一个结果`125`。|'
- en: '| `%` | Remainder: `print(13%5)` will give you a result of `3` because 13 =
    5 × 2 + 3. |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `%` | 余数：`print(13%5)`会给你一个结果`3`，因为 13 = 5 × 2 + 3。|'
- en: '| `//` | Integer quotient: `print(13//5)` will give you a result of `2` because
    13 = 5 × 2 + 3. |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `//` | 整数商：`print(13//5)`会给你一个结果`2`，因为 13 = 5 × 2 + 3。|'
- en: 'These operations have *precedence*, meaning they will execute in a particular
    order. That order of operations is as follows: operations within parentheses have
    highest priority, followed by exponents, then multiplication and division, which
    have the same priority and are executed from left to right. Addition and subtraction
    have the least priority and are treated equally, so whichever comes first is executed
    first.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这些运算有*优先级*，意味着它们会按照特定的顺序执行。运算顺序如下：括号内的运算具有最高优先级，其次是指数运算，再然后是乘法和除法，它们具有相同的优先级，按从左到右的顺序执行。加法和减法的优先级最低，且被平等对待，因此先出现的先执行。
- en: For more complicated mathematical operations, such as cosine in trigonometry
    or the natural logarithm, we need to import modules, which I’ll cover in Chapter
    2.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更复杂的数学运算，比如三角学中的余弦函数或自然对数，我们需要导入模块，这部分内容我将在第二章讲解。
- en: Summary
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how to install Python and Spyder via Anaconda.
    You also learned to run Python scripts by using Spyder.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何通过Anaconda安装Python和Spyder。你还学会了如何使用Spyder运行Python脚本。
- en: In Chapter 2, we’ll discuss the Python skills that you need for the rest of
    the book. You’ll learn the four main value types and how to convert one type to
    another. We’ll look at conditional execution and loops as well as how functions
    and modules work in Python, allowing you to accomplish more-complicated tasks.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二章中，我们将讨论你在本书其余部分需要掌握的Python技能。你将学习四种主要的值类型以及如何将一种类型转换为另一种类型。我们还将讨论条件执行和循环，以及函数和模块在Python中的工作原理，从而帮助你完成更复杂的任务。
- en: End-of-Chapter Exercises
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 章节末练习
- en: Add a line of code to *my_first_script.py* so that it prints out a third message
    that says `Here is a third message!`
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在*my_first_script.py*中添加一行代码，使其打印出一条第三条消息，内容为`Here is a third message!`
- en: What is the output from each of the following Python statements? First write
    down the answers and then run the commands in Spyder to verify.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下每个Python语句的输出是什么？首先写下答案，然后在Spyder中运行命令来验证。
- en: '[PRE11]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: What is the command line in the Spyder editor if you want to find the result
    of 55 multiplied by 234?
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想计算55乘以234，Spyder编辑器中的命令行应该输入什么？
- en: '2'
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Python Refresher
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Python基础回顾
- en: '![](Images/chapterart.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: This chapter is a refresher on basic Python. The purpose of this chapter is
    not to comprehensively review all the basic commands in Python. Instead, I’ll
    provide you with the Python skills that are most important to the rest of the
    book.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是对基本Python知识的回顾。本章的目的不是全面回顾Python中的所有基本命令，而是向你提供对本书其余部分最重要的Python技能。
- en: Specifically, you’ll learn the four Python variable types (strings, integers,
    floats, and Booleans) and how to convert one type to another. Functions are useful
    tools in programming languages, and you’ll learn to use built-in functions in
    Python and to import modules in the Python Standard Library.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，你将学习四种Python变量类型（字符串、整数、浮点数和布尔值），以及如何将一种类型转换为另一种类型。函数是编程语言中的有用工具，你将学习如何使用Python内置函数以及如何导入Python标准库中的模块。
- en: You’ll also learn how functions work and how to define your own functions. Many
    modules we use in this book are not in the Python Standard Library, and you’ll
    learn different ways of installing these modules on your computer.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你还将学习函数是如何工作的以及如何定义你自己的函数。本书中我们使用的许多模块不在Python标准库中，你将学习如何在你的计算机上安装这些模块。
- en: We’ll discuss how modules work and how to create your own self-made modules.
    You’ll then learn about a virtual environment, why it’s useful, and how to create
    and activate one.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论模块的工作原理以及如何创建你自己的自定义模块。然后你将学习虚拟环境，了解它为何有用，以及如何创建和激活它。
- en: Python uses strings, lists, dictionaries, and tuples as collections of elements
    to accomplish complicated tasks. In this chapter, you’ll learn these four types
    of collections, one by one. You’ll also see examples of their uses.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Python使用字符串、列表、字典和元组作为元素集合来完成复杂的任务。在这一章中，你将逐一学习这四种集合类型，并查看它们的使用示例。
- en: Before you begin, set up the folder */mpt/ch02*/ for this chapter. As in Chapter
    1, all scripts in this chapter are available at the book’s resources page, [https://www.nostarch.com/make-python-talk/](https://www.nostarch.com/make-python-talk/).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始之前，为本章设置文件夹*/mpt/ch02*。像第一章一样，本章的所有脚本可以在本书的资源页面找到，[https://www.nostarch.com/make-python-talk/](https://www.nostarch.com/make-python-talk/)。
- en: Variables and Values
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量和数值
- en: 'A *variable* is a reserved memory location to store values in Python (and in
    other programming languages). We can assign values to variables and use the variable
    name to recall the associated value. Python has four types of values: strings,
    floats, integers, and Booleans.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*变量*是一个保留的内存位置，用于在Python（以及其他编程语言）中存储值。我们可以将值赋给变量，并使用变量名来调用关联的值。Python有四种类型的值：字符串、浮点数、整数和布尔值。'
- en: Strings
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串
- en: 'A *string* is a sequence of characters inside quotation marks, often used to
    represent text. Here are some examples of strings:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*字符串*是由引号括起来的一系列字符，通常用于表示文本。以下是一些字符串的示例：'
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can find out the type that a variable contains by using the `type()` function.
    Enter the following in the Spyder editor:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`type()`函数来查找一个变量的类型。在Spyder编辑器中输入以下内容：
- en: '[PRE13]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'After execution, you’ll see the following output:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 执行后，你将看到以下输出：
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This means both variables have string values. You can add or multiply strings,
    but not in the traditional mathematical sense; instead, you can join strings or
    repeat them. For example, say you run the following two lines of code in the Spyder
    editor:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着两个变量都是字符串值。你可以对字符串进行加法或乘法运算，但不是传统的数学运算；而是可以连接字符串或重复字符串。例如，假设你在Spyder编辑器中运行以下两行代码：
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You will see the following output:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到以下输出：
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The plus sign joins two strings together, while multiplying a string by 3 means
    to repeat the characters in the string three times. Note that I’ve deliberately
    left an empty space at the end of the string `University of Kentucky`, so that
    when they join together, there is a space between the strings.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 加号将两个字符串连接在一起，而将一个字符串乘以3意味着将字符串中的字符重复三次。请注意，我故意在字符串`University of Kentucky`的末尾留了一个空格，这样它们连接在一起时，字符串之间会有一个空格。
- en: Floats
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 浮动类型
- en: '*Floating-point numbers*, also known as just *floats*, are a number type that’s
    equivalent to decimal numbers in mathematics. Here are two examples of floats:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*浮点数*，也称为*浮动类型*，是一种数字类型，相当于数学中的小数。以下是两个浮点数的示例：'
- en: '[PRE17]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can use the `round()` function to restrict a float to a certain number
    of digits after the decimal point. Floats can be positive, negative, or zero.
    Run the following code:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`round()`函数将浮动数限制为小数点后特定的位数。浮动数可以是正数、负数或零。运行以下代码：
- en: '[PRE18]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You will have the following output:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到以下输出：
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Floats are used to perform calculations.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 浮动类型用于执行计算。
- en: Integers
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 整数
- en: '*Integers* are another number type; they can’t have decimal places and so must
    be whole numbers. Integers are used mainly for indexing purposes in Python. Integers
    can be positive, negative, or zero. Here are some examples of integers:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*整数*是另一种数字类型；它们不能有小数部分，因此必须是整数。整数主要用于Python中的索引目的。整数可以是正数、负数或零。以下是一些整数的示例：'
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'It is important to know that floats always have decimals, while integers do
    not. You never need to tell Python what type you want to use; instead, it can
    tell by the information you give it. Python knows you’re using an integer if you
    enter a number without any quote marks and without decimal places. Even if you
    round a float number to zero digits after a decimal, you would still get a decimal
    point and a 0 trailing the number. Run the following code:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要知道，浮点数总是有小数部分，而整数没有。你无需告诉Python你想使用哪种类型；相反，Python可以通过你提供的信息自动判断。如果你输入一个没有引号且没有小数点的数字，Python知道你在使用整数。即使你将一个浮动数字四舍五入到小数点后零位，数字后面仍会跟着小数点和零。运行以下代码：
- en: '[PRE21]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You will have the following output:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到以下输出：
- en: '[PRE22]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The output shows that all three variables, `a`, `b`, and `c`, are integers.
    You will not get an output of `7` from `print(round(7.346,0))`, because using
    the decimal is Python’s way of telling an integer apart from a float.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示所有三个变量，`a`、`b`和`c`，都是整数。你不会从`print(round(7.346,0))`得到`7`，因为使用小数是Python区分整数和浮动类型的一种方式。
- en: Bools
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 布尔值
- en: '*Booleans*, or *bools*, are binary variables that can take only the value of
    `True` or `False`. Note that the first letter in `True` or `False` must always
    be uppercase. We use bools to find out truths about our code and make logical
    statements. As an example, run these two lines of code that compare two numbers:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*布尔值*，或称*布尔型*，是二进制变量，只能取`True`或`False`的值。请注意，`True`和`False`的首字母必须始终大写。我们使用布尔值来验证代码中的真值，并进行逻辑判断。例如，运行以下两行代码来比较两个数字：'
- en: '[PRE23]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You will get the following output:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到以下输出：
- en: '[PRE24]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The results show that the logic statement `4 > 5` is `False`, while the logic
    statement `10 >= 6` is `True`. The values `True` or `False` (without quotes) are
    not strings but are special values reserved by Python. Try the following commands:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示逻辑语句`4 > 5`的值为`False`，而逻辑语句`10 >= 6`的值为`True`。`True`或`False`（不带引号）不是字符串，而是Python保留的特殊值。试试以下命令：
- en: '[PRE25]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here’s the output:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As you can see, once you put `4 > 5` inside quotation marks, it becomes a string
    variable instead of a bool.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，一旦你将`4 > 5`放入引号中，它就变成了字符串变量，而不是布尔值。
- en: 'Bools can also be represented with `1` (or, in reality, anything that’s nonzero)
    for `True` and `0` for `False`. Run this code:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值也可以用`1`（或者实际上，任何非零值）表示`True`，用`0`表示`False`。运行此代码：
- en: '[PRE27]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'It outputs the following:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 它输出如下：
- en: '[PRE28]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `bool()` function converts any nonzero value to `True` and `0` to `False`.
    Run the following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`bool()` 函数将任何非零值转换为`True`，将`0`转换为`False`。运行以下代码：'
- en: '[PRE29]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'And you will get this:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到如下输出：
- en: '[PRE30]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Convert Variable Types
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 转换变量类型
- en: You can convert the type of a variable by using the functions `str()`, `int()`,
    `bool()`, and `float()`, but only if the type you’re trying to convert is compatible
    with the resulting type. For example, you can convert the string variable `"17"`
    to an integer or a float by using `int("17")` or `float("17")`, because 17 is
    a number that can be recognized as an integer or float. However, you cannot convert
    the string `"Kentucky"` to either an integer or a float.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用函数`str()`、`int()`、`bool()`和`float()`转换变量类型，但前提是你要转换的类型与目标类型兼容。例如，你可以使用`int("17")`或`float("17")`将字符串变量`"17"`转换为整数或浮点数，因为
    17 是一个可以被识别为整数或浮点数的数字。然而，你不能将字符串`"Kentucky"`转换为整数或浮点数。
- en: 'Consider the following lines of code:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑以下代码行：
- en: '[PRE31]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The output is the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE32]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Bool values `True` and `False` can be converted to integers `1` and `0`, respectively,
    because `1` and `0` are often used to represent `True` and `False`. While the
    float number `17.0` and string variable `"88"` can be converted to integers, the
    string variable `"3.45"` can’t be converted to an integer because it has values
    after the decimal point.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值`True`和`False`可以分别转换为整数`1`和`0`，因为`1`和`0`通常用来表示`True`和`False`。而浮点数`17.0`和字符串变量`"88"`可以转换为整数，但字符串变量`"3.45"`不能转换为整数，因为它有小数点后的数值。
- en: 'You can convert almost anything into a string variable; for example, the float
    number `17.0` can be converted to the string variable `"17.0"`. You can also convert
    any integer to a float: for example, the integer `–4` can be converted to the
    float `–4.0`.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎任何东西都可以转换成字符串变量；例如，浮点数`17.0`可以转换为字符串变量`"17.0"`。你也可以将任何整数转换为浮点数：例如，整数`–4`可以转换为浮点数`–4.0`。
- en: Rules for Variable Names
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变量名规则
- en: Certain rules exist for naming variables, and not everything can be used as
    a variable name. A variable name must start with a letter (either uppercase or
    lowercase) or an underscore (`_`). For example, you can’t use `8python` as a variable
    name because it starts with a number.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 命名变量时有一些规则，并不是所有内容都可以作为变量名。变量名必须以字母（无论大写或小写）或下划线（`_`）开头。例如，你不能使用`8python`作为变量名，因为它以数字开头。
- en: The only special character a variable name can have is the underscore, so special
    characters such as `@` or `&` are not allowed. See the Python naming conventions
    at [https://www.python.org/dev/peps/pep-0008/#id34/](https://www.python.org/dev/peps/pep-0008/#id34/)*.*
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 变量名唯一可以包含的特殊字符是下划线，因此像`@`或`&`这样的特殊字符是不允许的。请参阅 Python 命名规范：[https://www.python.org/dev/peps/pep-0008/#id34/](https://www.python.org/dev/peps/pep-0008/#id34/)*.*
- en: 'Variable names can’t be Python keywords or Python built-in functions. To get
    the list of all keywords, run these two lines of code in the Spyder editor:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 变量名不能是 Python 关键字或 Python 内建函数。要获取所有关键字的列表，可以在 Spyder 编辑器中运行以下两行代码：
- en: '[PRE33]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The output is a full list of Python keywords:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是 Python 关键字的完整列表：
- en: '[PRE34]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Variable names can, however, *contain* keywords. For example, `first_break`
    and `class1` are valid variable names, even though `break` and `class` are not.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，变量名*可以包含*关键字。例如，`first_break`和`class1`是有效的变量名，即使`break`和`class`不是。
- en: Variable names should not be Python built-in functions. [Figure 2-1](#figure2-1)
    lists those functions, which are found in the Python documentation at [https://docs.python.org/3/library/functions.html](https://docs.python.org/3/library/functions.html)*.*
    You would do well to familiarize yourself with the list and avoid using these
    terms as variable names.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 变量名不应当是 Python 内建函数。[图 2-1](#figure2-1) 列出了这些函数，相关内容可以在 Python 文档中的[https://docs.python.org/3/library/functions.html](https://docs.python.org/3/library/functions.html)*.*
    你应该熟悉这个列表，并避免将这些术语作为变量名。
- en: '![f02001](Images/f02001.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![f02001](Images/f02001.png)'
- en: 'Figure 2-1: List of Python built-in functions'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-1：Python 内建函数列表
- en: Loops and Conditional Execution
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 循环与条件执行
- en: Loops and conditional statements let you make decisions in your code, so that
    certain code will run if a particular thing happens.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 循环和条件语句让你在代码中做出决策，以便在特定条件发生时运行某些代码。
- en: Conditional Execution
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 条件执行
- en: 'The `if` statement allows your code to take particular actions based on whether
    a condition is met. Consider the following lines of code:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`if` 语句允许你的代码根据条件是否满足来执行特定的操作。请考虑以下代码行：'
- en: '[PRE35]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Here, `x > 0` is the condition. If the value of `x` is larger than 0, the condition
    is met, and the script prints the message `x is positive`. Conditionals in Python
    always need a colon (`:`) after the conditional statement. If the condition is
    not met, the script moves to the `else` branch and prints `x is nonpositive`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`x > 0`是条件。如果`x`的值大于0，则条件成立，脚本会打印出消息`x is positive`。Python中的条件语句总是在条件语句后面需要一个冒号（`:`）。如果条件不满足，脚本将跳到`else`分支并打印`x
    is nonpositive`。
- en: 'We can also have more than two conditions by using the `elif` keyword. Consider
    the following code:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过使用`elif`关键字来处理多个条件。考虑以下代码：
- en: '[PRE36]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Python uses the double equal sign (`==`) as a comparison operator, to distinguish
    it from value assignments when we use a single equal sign (`=`). This script has
    three possible outcomes, depending on which condition is met: `x is positive`,
    `x is zero`, or `x is negative`.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Python使用双等号（`==`）作为比较运算符，以区别于我们使用单等号（`=`）进行赋值操作。当满足某个条件时，脚本有三种可能的输出结果：`x is
    positive`，`x is zero`，或`x is negative`。
- en: 'If we require more than three conditions, the first condition must follow the
    `if` statement, the last condition must come after the `else` statement, and all
    conditions between should have the `elif` keyword:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要更多的条件，首个条件必须紧跟在`if`语句后，最后一个条件必须跟在`else`语句后，而所有中间的条件应使用`elif`关键字：
- en: '[PRE37]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The script prints out the letter grade based on the value of the score: A if
    the score is greater or equal to 90; if not, B if the score is above 80, and so
    on.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本根据分数的值打印字母成绩：如果分数大于或等于90，则为A；如果不是，则分数大于80时为B，依此类推。
- en: Loops
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 循环
- en: 'One great advantage of computers is their ability to repeat the same tasks
    many times at a fast rate. This is known as *looping*, or *iterating*, in programming.
    Python has two types of loop: the `while` and the `for` loop.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机的一个巨大优势是它们能够快速地重复执行相同的任务。这在编程中被称为*循环*或*迭代*。Python有两种循环类型：`while`循环和`for`循环。
- en: The while Loop
  id: totrans-192
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`while`循环'
- en: 'A `while` loop is used to execute a block of code as long as a certain condition
    is met. Here we use the `while` statement to create a loop that adds 1 to the
    variable `n` every time it loops until `n` reaches `3`. Then the loop exits, and
    the script prints `finished`. Save this as *whileloop.py*:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环用于在满足某个条件时执行一段代码块。在这里，我们使用`while`语句创建一个循环，每次循环都将`n`的值加1，直到`n`达到`3`。然后，循环退出，脚本打印`finished`。将此保存为*whileloop.py*：'
- en: '[PRE38]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We first assign `n` a value of `0`. Then, the script starts the `while` loop
    with the condition `n < 3`. As long as the condition is met, the loop keeps running.
    Notice the colon, which tells Python to expect the indented lines that follow
    as part of the loop. Those lines will execute every time the loop runs. The last
    line, which is not indented, runs only after the loop exits.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将`n`赋值为`0`。然后，脚本以条件`n < 3`开始`while`循环。只要条件满足，循环就会继续执行。注意冒号，它告诉Python接下来缩进的行是循环的一部分。这些行将在每次循环运行时执行。最后一行没有缩进，只有在循环结束后才会执行。
- en: 'In the first iteration, the value of `n` increases from `0` to `1`, and the
    updated value of `n` is printed out. In the second iteration, the value of `n`
    increases to `2`, and the updated value of `n` is printed out. In the third iteration,
    the value of `n` increases to `3`, and `3` is printed out. When the script goes
    to the fourth iteration, the condition `n < 3` is no longer met, and the loop
    stops. After that, the last line is executed. As a result, we see the following
    output from *whileloop.py*:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次迭代中，`n`的值从`0`增加到`1`，并打印出更新后的`n`值。在第二次迭代中，`n`的值增加到`2`，并打印出更新后的`n`值。在第三次迭代中，`n`的值增加到`3`，并打印出`3`。当脚本进入第四次迭代时，条件`n
    < 3`不再满足，循环停止。之后，执行最后一行。结果，我们看到来自*whileloop.py*的以下输出：
- en: '[PRE39]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `while` loop is most useful when we don’t know the number of iterations
    we need beforehand, even though it can also be used to perform the same tasks
    as a `for` loop. Later in this book, we often use the statement `while True` to
    create an infinite loop that puts the script in standby mode.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环在我们事先不知道需要多少次迭代时最为有用，尽管它也可以用于执行与`for`循环相同的任务。在本书的后面部分，我们经常使用语句`while
    True`来创建一个无限循环，将脚本置于待机模式。'
- en: The for Loop
  id: totrans-199
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`for`循环'
- en: 'The `for` loop is generally used when you want to execute a block of code a
    fixed number of times. The following script, *forloop.py*, is an example of a
    `for` loop that does the same as the `while` loop we just made, adding 1 to the
    variable `n` until `n` reaches `3`:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环通常用于你想要执行固定次数的代码块。以下脚本*forloop.py*是一个`for`循环的示例，它实现了与我们刚才做的`while`循环相同的功能，将变量`n`加1，直到`n`达到`3`：'
- en: '[PRE40]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We start by using `range()`, a built-in function in Python, to produce a range
    of values from 0 to 2 (Python always begins counting from 0). The line tells the
    script to loop through the three values, one value per loop, and execute the next
    two lines of code for each value, adding 1 to `n` per loop. When the range has
    been used up, the loop exits, and we print `finished`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用`range()`，这是Python中的一个内建函数，来生成从0到2的数值范围（Python的计数从0开始）。这一行指示脚本循环遍历这三个值，每次循环处理一个值，并为每个值执行接下来的两行代码，每次循环将`n`加1。当范围用尽时，循环退出，输出`finished`。
- en: The code in *forloop.py* produces the same output as *whileloop.py*.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '*forloop.py*中的代码输出与*whileloop.py*相同。'
- en: Loops in Loops
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 循环中的循环
- en: 'You can place a loop inside another loop. This is known as *nesting*. Nested
    loops are useful when, for each iteration in the outer loop, you need to repeat
    certain jobs for each iteration in the inner loop. The example script *loop_in_loop.py*
    loops through a list and a tuple, printing each member of the list with each member
    of the tuple, one pair per iteration:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将一个循环放在另一个循环内，这就是所谓的*嵌套*。嵌套循环在每次外层循环迭代时，需要对内层循环的每一次迭代重复某些操作时非常有用。示例脚本*loop_in_loop.py*遍历一个列表和一个元组，在每次迭代中打印列表中的每个成员与元组中的每个成员，每次迭代打印一对值：
- en: '[PRE41]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'First, we start the outer loop with `for`, and then the first indented line
    starts the inner loop. The script takes the first value in the outer loop, goes
    through all iterations in the inner loop, and prints a message at each iteration.
    It repeats the process again with the second value of the outer loop. We need
    to indent the content of the inner loop twice so the script knows which lines
    belong to which loops. The final output from *loop_in_loop.py* is shown here:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用`for`开始外层循环，然后第一行缩进代码开始内层循环。脚本获取外层循环中的第一个值，遍历内层循环的所有迭代，并在每次迭代时打印一条消息。然后它会用外层循环中的第二个值重复这个过程。我们需要将内层循环的内容缩进两次，这样脚本才能知道哪些代码行属于哪个循环。*loop_in_loop.py*的最终输出如下所示：
- en: '[PRE42]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Notice that we use the `f"{}"` string-formatting approach. The string `f"this
    is {``letter``}{``num``}"` tells Python to replace whatever is in the curly brackets
    with the actual value of the variable mentioned.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们使用了`f"{}"`字符串格式化的方法。字符串`f"this is {``letter``}{``num``}"`告诉Python将花括号中的内容替换为相应变量的实际值。
- en: You can nest loops pretty much indefinitely, and the script will iterate through
    all values in the innermost loop for each combination of values in the medium
    and outer loops. However, nesting too many loops can make your code difficult
    to read and isn’t generally recommended practice.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将循环嵌套得几乎无限深，脚本会在每次外层循环值的组合下，遍历内层循环的所有值。然而，过多的嵌套会使代码难以阅读，因此通常不推荐这种做法。
- en: Loop Commands
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 循环命令
- en: Loops have a few commands that are useful for controlling the way your loops
    behave—namely, `continue`, `break`, and `pass`. These commands allow you to make
    decisions within a loop by using the `if` statement.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 循环有几个命令，方便控制循环的行为——即`continue`、`break`和`pass`。这些命令通过使用`if`语句，让你在循环中做出决策。
- en: continue
  id: totrans-213
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: continue
- en: 'The `continue` command tells Python to stop executing the rest of the commands
    for the current iteration and to go to the next iteration. You use `continue`
    when you want to skip certain actions when certain conditions are met in a loop.
    For example, the script *forloop1.py* uses the `continue` command to skip printing
    the number 2 and go to the next iteration:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`continue`命令告诉Python停止执行当前迭代中的剩余命令，并进入下一次迭代。当你希望在满足某些条件时跳过某些操作时，可以使用`continue`。例如，脚本*forloop1.py*使用`continue`命令跳过打印数字2，并进入下一次迭代：'
- en: '[PRE43]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'When the value of `n` is `2`, line 1 will not be executed because the `continue`
    command tells the script to skip it and go to the next iteration. The output from
    this script is as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 当`n`的值为`2`时，第一行代码不会执行，因为`continue`命令告诉脚本跳过这一行，直接进入下一次迭代。该脚本的输出如下所示：
- en: '[PRE44]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: break
  id: totrans-218
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: break
- en: 'The `break` command tells Python to break the loop and skip all remaining iterations.
    You use `break` when you want to exit the loop. The example script *forloop2.py*
    uses the `break` command to exit the `for` loop when the number reaches value
    `2`:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`break`命令告诉 Python 打破循环并跳过所有剩余的迭代。当你希望退出循环时，使用`break`。示例脚本*forloop2.py*使用`break`命令，当数字达到值`2`时退出`for`循环：'
- en: '[PRE45]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'When the value of `n` is `2`, the whole loop stops and the script goes to line
    1 directly. The output is therefore as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 当`n`的值为`2`时，整个循环停止，脚本直接跳到第1行。因此，输出如下：
- en: '[PRE46]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Later in this book, we’ll frequently use the `break` command to tell the script
    to stop the infinite loop generated by the statement `while True`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的后面部分，我们将经常使用`break`命令来告诉脚本停止由`while True`语句生成的无限循环。
- en: pass
  id: totrans-224
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: pass
- en: 'The `pass` command tells Python to do nothing, and it is used when a command
    line is needed but no action needs to be taken. We often use it along with `try`
    and `except`, and we’ll revisit this command later in this book. The script *forloop3.py*
    uses a `pass` command to tell the script to take no action when the value of the
    number is `2`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`pass`命令告诉 Python 什么都不做，它在需要一行命令但不需要执行任何操作时使用。我们通常与`try`和`except`一起使用它，稍后我们将在本书中再次提到这个命令。脚本*forloop3.py*使用`pass`命令，当数字的值为`2`时，告诉脚本不执行任何操作：'
- en: '[PRE47]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'When the value of `n` is `2`, no action needs to be taken. Therefore, here’s
    the output from the preceding script:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 当`n`的值为`2`时，不需要采取任何操作。因此，下面是前一个脚本的输出：
- en: '[PRE48]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This is the same as the output from *forloop.py*.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这与*forloop.py*的输出相同。
- en: Strings
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串
- en: A *string* is a sequence of characters inside single or double quotation marks.
    The characters in the string can be letters, numbers, whitespace, or special characters.
    We’ll discuss how elements in a string are indexed, how to slice them, and how
    to join multiple strings together.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '*字符串*是由单引号或双引号括起来的字符序列。字符串中的字符可以是字母、数字、空格或特殊字符。我们将讨论如何对字符串中的元素进行索引、如何切片以及如何将多个字符串连接在一起。'
- en: String Indexing
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串索引
- en: The characters in strings are indexed from left to right, starting at 0\. This
    is because Python uses *zero-based indexing*, so the first element is always indexed
    as 0 instead of 1\.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串中的字符是从左到右按0开始索引的。这是因为 Python 使用*零基索引*，因此第一个元素的索引是 0，而不是 1\。
- en: 'You can access characters in a string by using the square bracket operator
    and the index of the character you want:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用方括号操作符和字符的索引来访问字符串中的字符：
- en: '[PRE49]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Since `e` is the second character in the string `"hello"`, the output is this:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`e`是字符串`"hello"`中的第二个字符，因此输出是：
- en: '[PRE50]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Python also uses *negative indexing*, which starts from the end of the string.
    The last character in the string can be indexed as `[-1]`, the second-to-last
    one as `[-2]`, and so on. This is useful when you have a long string and want
    to locate characters at the end of it.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: Python 还使用*负索引*，它是从字符串的末尾开始的。字符串中的最后一个字符可以通过`[-1]`索引，倒数第二个字符通过`[-2]`索引，依此类推。当你有一个很长的字符串并且希望定位字符串末尾的字符时，这非常有用。
- en: 'To find the third-to-last character of the string `msg`, you’d use this:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找字符串`msg`的倒数第三个字符，你可以使用以下代码：
- en: '[PRE51]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Here’s the output:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是输出：
- en: '[PRE52]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: String Slicing
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串切片
- en: '*Slicing* a string means taking out a subset of characters. We again use the
    square bracket operator:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '*切片*字符串意味着提取字符的一个子集。我们再次使用方括号操作符：'
- en: '[PRE53]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This will output the following:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出以下内容：
- en: '[PRE54]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The code `msg[``a``:``b``]` gives you the substring from position `a` to position
    `b` in the string `msg`, where the character in position `a` is included in the
    substring but the character in position *b* is not. Therefore, `msg[0:3]` produces
    a substring of the first three characters in the string `msg`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 代码`msg[``a``:``b``]`从字符串`msg`中的位置`a`到位置`b`提取子字符串，其中位置`a`的字符包含在子字符串中，但位置*b*的字符不包含。因此，`msg[0:3]`会生成字符串`msg`中前面三个字符的子字符串。
- en: String Methods
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串方法
- en: I’ll cover a few common string methods we’ll use throughout this book.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我将介绍一些我们在本书中将会使用的常见字符串方法。
- en: replace()
  id: totrans-251
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: replace()
- en: 'The `replace()` method replaces certain characters or substrings in the string
    with other characters. It takes two arguments: the character you want to replace
    and the character to replace it with. For example:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`replace()`方法用于将字符串中的某些字符或子字符串替换为其他字符。它接受两个参数：要替换的字符和用来替换它的字符。例如：'
- en: '[PRE55]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We use `replace()` to replace all whitespaces with the plus sign. The output
    from the preceding script is shown here:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`replace()`将所有空格替换为加号。前一个脚本的输出如下所示：
- en: '[PRE56]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This method will be useful later in the book, when we deal with the speech recognition
    feature. We’ll use `replace()` to change the voice text from the speech engine
    to a suitable format for the script.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 本方法将在本书稍后的章节中有用，当我们处理语音识别功能时。我们将使用 `replace()` 方法将语音引擎的语音文本转换为适合脚本的格式。
- en: lower()
  id: totrans-257
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: lower()
- en: The `lower()` method converts all uppercase letters in a string to lowercase.
    Since Python strings are case-sensitive, converting all letters to lowercase when
    matching strings means we won’t miss uppercase substrings that should match.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`lower()` 方法将字符串中的所有大写字母转换为小写字母。由于 Python 字符串区分大小写，因此在匹配字符串时将所有字母转换为小写，意味着我们不会错过应该匹配的大小写子字符串。'
- en: 'Say we want to capture the spoken phrase “department of education” via a speech
    recognition module. We can’t be sure whether the phrase will be captured as `Department
    of Education` or not. You can use `lower()` to convert the phrase to an all lowercase
    string to avoid mismatches, like so:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们希望通过语音识别模块捕捉到“department of education”这一语音短语。我们不能确定该短语是否会被捕捉为 `Department
    of Education`。你可以使用 `lower()` 将短语转换为全小写字符串，以避免不匹配，示例如下：
- en: '[PRE57]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The script tests whether the two strings `inp` and `inp1` are the same when
    we ignore case-sensitivity. Here’s the output:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本测试了当忽略大小写时，两个字符串 `inp` 和 `inp1` 是否相同。输出如下：
- en: '[PRE58]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: find()
  id: totrans-263
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: find()
- en: You can use `find()` to locate the position of a character in a string. The
    method returns the index of the character in the string.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `find()` 来查找字符在字符串中的位置。该方法返回字符在字符串中的索引。
- en: 'Enter the following lines of code into the Spyder editor and save it as *extract_last_name.py*;
    then run it:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码行输入 Spyder 编辑器并保存为 *extract_last_name.py*，然后运行：
- en: '[PRE59]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The string variable `email` has a pattern: it consists of the first name, the
    dot, and the last name, followed by `@uky.edu`. We use this pattern to locate
    the positions of the dot and the at sign, then retrieve the last name based on
    those two positions.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串变量 `email` 有一个模式：它由名字、点和姓氏组成，后面跟着 `@uky.edu`。我们使用这个模式来定位点和@符号的位置，然后根据这两个位置提取姓氏。
- en: First, we get the position of `.` and define it as a variable `pos1`. Then,
    we find the position of `@` and define it as `pos2`. Finally, we slice the string
    and take the characters between the two positions, returning the substring as
    the variable `last_name`.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们获取 `.` 的位置，并将其定义为变量 `pos1`。然后，我们找到 `@` 的位置，并将其定义为 `pos2`。最后，我们对字符串进行切片，取出两个位置之间的字符，并将子字符串作为变量
    `last_name` 返回。
- en: 'Running the script should produce this:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本后应该输出以下内容：
- en: '[PRE60]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The indexes of `.` and `@` in the email are `4` and `10`, respectively, and
    the last name is `Smith`.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`.` 和 `@` 在电子邮件中的索引分别是 `4` 和 `10`，而姓氏是 `Smith`。'
- en: You can also use the string method `find()` to locate a substring. The method
    returns the starting position of the substring in the original string. For example,
    if you run the following lines of code
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用字符串方法 `find()` 来定位子字符串。该方法返回子字符串在原始字符串中的起始位置。例如，如果你运行以下代码：
- en: '[PRE61]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'you’ll get the following output:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到以下输出：
- en: '[PRE62]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The output says that the substring `uky.edu` starts with the 12th character
    in the email.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示子字符串 `uky.edu` 从电子邮件中的第12个字符开始。
- en: split()
  id: totrans-277
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: split()
- en: 'The `split()` method splits a string into multiple strings, using the specified
    separator. Enter the following code in Spyder and run it:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`split()` 方法将字符串拆分成多个字符串，使用指定的分隔符。在 Spyder 中输入以下代码并运行：'
- en: '[PRE63]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The output is as follows:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE64]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The default *delimiter* (a fancy name for *separator*) is a whitespace (`' '`).
    You can also specify the delimiter when you use `split()`. Let’s revisit the example
    of extracting the last name from an email address, naming the new script *split_string.py*,
    as in [Listing 2-1](#listing2-1).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的 *delimiter*（分隔符的 fancy 名称）是空格（`' '`）。你也可以在使用 `split()` 时指定分隔符。让我们重新审视从电子邮件地址中提取姓氏的例子，并将新脚本命名为
    *split_string.py*，如 [列表 2-1](#listing2-1) 所示。
- en: '[PRE65]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Listing 2-1: Using a delimiter to split up an email address'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-1：使用分隔符拆分电子邮件地址
- en: 'We first split the email into two parts by using `@` as the delimiter and assign
    the name and domain to a tuple. (We’ll discuss the definition of a *tuple* later
    in this chapter.) As a result, the first element in the tuple, the variable `name`,
    is a substring: `John.Smith`. The script then splits `John.Smith` into the first
    name and the last name, using `.` as the delimiter, and saves them in the tuple
    `(``first``,` `last``)`. Finally, we print out the second element in the tuple
    as the last name.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过使用`@`作为分隔符，将电子邮件分为两部分，并将用户名和域名赋值给元组。（我们将在本章后面讨论*元组*的定义。）结果，元组中的第一个元素，即变量`name`，是子字符串：`John.Smith`。然后，脚本将`John.Smith`按照`.`分隔符分为名字和姓氏，并将它们保存在元组`(``first``,
    ``last``)`中。最后，我们打印出元组中的第二个元素作为姓氏。
- en: 'The output is shown here:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE66]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: join()
  id: totrans-288
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: join()
- en: 'The `join()` method joins several strings into one, as in this script, *join_string.py*:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`join()`方法将多个字符串连接成一个字符串，就像这个脚本中的*join_string.py*一样：'
- en: '[PRE67]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We define `&` as the variable `mylink`, to be used as our separator. The `strlist`
    is a list of the three words that we want to join together. We use `join()` to
    combine the three words into one single string. Note that you need to put `join()`
    after the separator. Finally, we print out the joined string:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`&`定义为变量`mylink`，作为分隔符。`strlist`是一个包含我们希望连接的三个单词的列表。我们使用`join()`将这三个单词组合成一个单一的字符串。请注意，`join()`需要放在分隔符之后。最后，我们打印出连接后的字符串：
- en: '[PRE68]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Lists
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列表
- en: A *list* is a collection of values separated by commas. The values in a list
    are called *elements*, or *items*, and they can be values, variables, or other
    lists.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表*是由逗号分隔的值的集合。列表中的值称为*元素*，或*项*，它们可以是值、变量或其他列表。'
- en: Create a List
  id: totrans-295
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个列表
- en: 'To create a new list, you simply put the elements in square brackets:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新列表，只需将元素放在方括号中：
- en: '[PRE69]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'We define the list `lst` with three elements: an integer number `1` and two
    strings. Note that `list()` is a built-in function in Python, so you cannot use
    `list` as a variable name or list name. I suggest that you use a descriptive name
    to help future readers understand the code.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个包含三个元素的列表`lst`：一个整数`1`和两个字符串。注意，`list()`是 Python 的内置函数，因此不能将`list`用作变量名或列表名。我建议你使用具有描述性的名称，以帮助未来的读者理解代码。
- en: 'You create an empty list by using a pair of square brackets with nothing in
    it:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用一对空的方括号创建一个空列表：
- en: '[PRE70]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Or you can use the `list()` function:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你也可以使用`list()`函数：
- en: '[PRE71]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Access Elements in a List
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问列表中的元素
- en: 'You can access the elements of a list by using the bracket operator:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用括号操作符访问列表中的元素：
- en: '[PRE72]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'This will produce the following:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成以下内容：
- en: '[PRE73]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Here, `lst[2]` refers to the third element in the list, because Python is like
    most computer programming languages, which start counting at zero.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`lst[2]`指的是列表中的第三个元素，因为 Python 与大多数计算机编程语言一样，从零开始计数。
- en: 'You can traverse the elements of a list by using a loop:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用循环遍历列表中的元素：
- en: '[PRE74]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'This give us the following:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们以下结果：
- en: '[PRE75]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: We use the built-in function `len()` to return the length of the list, which
    is `3` in this case. The built-in function `range()` returns values `0`, `1`,
    and `2` here.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用内置函数`len()`来返回列表的长度，在此例中是`3`。内置函数`range()`在此返回`0`、`1`和`2`。
- en: Use a List of Lists
  id: totrans-314
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用列表的列表
- en: 'A list can use lists as its elements. This is useful for mapping element positions
    to coordinates in a two-dimensional space. Here is one example:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 一个列表可以将其他列表作为元素。这对于将元素位置映射到二维空间中的坐标非常有用。以下是一个示例：
- en: '[PRE76]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Here’s the output:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出结果：
- en: '[PRE77]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The list `llst` itself contains five lists. To find the value of `llst[1][2]`,
    the code first looks at the second item in the outer list `llst`, which is the
    list `[2, 2, 6, 8]`. The third element of that list is `6;` hence `llst[1][2]
    = 6`.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 列表`llst`本身包含五个列表。为了查找`llst[1][2]`的值，代码首先查看外部列表`llst`中的第二项，即列表`[2, 2, 6, 8]`。该列表的第三个元素是`6`，因此`llst[1][2]
    = 6`。
- en: Now let’s draw a corresponding picture in a two-dimensional space, as in [Figure
    2-2](#figure2-2).
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在二维空间中绘制一个相应的图形，如[图 2-2](#figure2-2)所示。
- en: '![f02002](Images/f02002.png)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![f02002](Images/f02002.png)'
- en: 'Figure 2-2: Map a list of lists to a two-dimensional space'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-2：将列表的列表映射到二维空间
- en: We’ll use this in Part III to create boards for our interactive games.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第三部分中使用它来创建互动游戏的棋盘。
- en: Add or Multiply Lists
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加或乘法列表
- en: 'You can use the plus (`+`) and multiplication (`*`) operators on lists, but
    not in the mathematical sense. For example, run the following lines of code:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在列表上使用加号（`+`）和乘号（`*`）操作符，但不是在数学意义上。例如，运行以下代码：
- en: '[PRE78]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'You should see the following output:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '[PRE79]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The plus operator joins two lists into a larger list. The multiplication operator
    repeats the elements in the list. If you multiply a list by 3, the elements will
    appear three times.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 加号操作符将两个列表合并成一个更大的列表，乘号操作符将列表中的元素重复。如果你将一个列表乘以3，元素将出现三次。
- en: List Methods
  id: totrans-330
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列表方法
- en: I’ll introduce several useful list methods here that we’ll use in later chapters
    of this book.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在这里介绍几个有用的列表方法，我们将在本书的后续章节中使用它们。
- en: enumerate()
  id: totrans-332
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: enumerate()
- en: 'The `enumerate()` method prints out all elements in a list with their corresponding
    indexes. Assume we have the following list `names`:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '`enumerate()`方法会打印出列表中的所有元素及其对应的索引。假设我们有以下列表`names`：'
- en: '[PRE80]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The following lines of code
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码行
- en: '[PRE81]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'will generate this output:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 将生成如下输出：
- en: '[PRE82]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The first element at index `0` is Adam, the second at index `1` is Kate, and
    so on.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 索引为`0`的第一个元素是Adam，索引为`1`的第二个元素是Kate，依此类推。
- en: 'You can choose the start value to be 1 instead of 0 with `start=1`, like so:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择将起始值设置为1而不是0，使用`start=1`，如下所示：
- en: '[PRE83]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The output is as follows:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE84]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: append()
  id: totrans-344
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: append()
- en: 'You can append an element to the end of a list by using the `append()` method.
    Consider this script, *list_append.py*:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用`append()`方法将一个元素添加到列表的末尾。考虑这个脚本，*list_append.py*：
- en: '[PRE85]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'This code is appending the element `2` to the existing list `lst`, producing
    this:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码正在将元素`2`添加到现有的列表`lst`中，生成如下结果：
- en: '[PRE86]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The new `lst` now has four elements.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`lst`现在有四个元素。
- en: 'You can append only one element at a time, and it is added to the end of the
    list by default. Appending two elements will lead to an error message. Change
    line 1 in the script *list_append.py* to the following:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 你每次只能添加一个元素，它会被默认添加到列表的末尾。添加两个元素会导致错误信息。请将脚本*list_append.py*中的第1行更改为如下：
- en: '[PRE87]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'You’ll get the following error message:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 你将收到如下错误信息：
- en: '[PRE88]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'However, you can append multiple elements as a list. Add square brackets around
    the two numbers as follows:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，你可以将多个元素作为列表添加。将两个数字用方括号括起来，如下所示：
- en: '[PRE89]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'You’ll get the following output:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到以下输出：
- en: '[PRE90]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The new list has four elements.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 新的列表有四个元素。
- en: 'To add two or more elements to the existing list, you should use the plus operator.
    For example, to add 2 and 3 as two separate elements to the list, you can use
    the following line of code:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 要将两个或更多元素添加到现有列表中，你应该使用加号操作符。例如，要将2和3作为两个独立的元素添加到列表中，可以使用以下代码：
- en: '[PRE91]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The output will be as follows:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE92]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: remove()
  id: totrans-363
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: remove()
- en: 'You can remove an element from a list by using `remove()`:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用`remove()`方法从列表中删除一个元素：
- en: '[PRE93]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'We remove the element that was at index 1, resulting in this:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 我们移除了索引为1的元素，结果如下：
- en: '[PRE94]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: The new list no longer has element `a`. You can remove only one element at a
    time.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 新的列表中不再有元素`a`。每次只能移除一个元素。
- en: index()
  id: totrans-369
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: index()
- en: 'You can find the position of an element in a list by using the `index()` method:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用`index()`方法找到元素在列表中的位置：
- en: '[PRE95]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'From this we get the following:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 从中我们得到如下结果：
- en: '[PRE96]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: The result tells you that the element `a` has an index of `1` in the list.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 结果告诉你，元素`a`在列表中的索引为`1`。
- en: count()
  id: totrans-375
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: count()
- en: 'You can count how many times an element appears in a list by using `count()`:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用`count()`来计算一个元素在列表中出现的次数：
- en: '[PRE97]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'This produces the following:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成如下结果：
- en: '[PRE98]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: This tells us that the element `1` has appeared in the list twice, while the
    element `a` has appeared once.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们，元素`1`在列表中出现了两次，而元素`a`出现了一次。
- en: sort()
  id: totrans-381
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: sort()
- en: 'You can sort the elements in a list by using `sort()`. The elements must be
    the same type (or at least convertible to the same type). For example, if you
    have both integers and strings in a list, trying to sort the list will lead to
    the following error message:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用`sort()`方法对列表中的元素进行排序。元素必须是相同类型（或者至少可以转换为相同类型）。例如，如果你的列表中同时包含整数和字符串，尝试对其排序时会出现如下错误信息：
- en: '[PRE99]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Numbers are sorted from the smallest to the largest. Adding `reverse=True`
    inside the method as an option will reverse the ordering. Here’s an example:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 数字按从小到大的顺序排序。如果在方法中添加`reverse=True`作为选项，它将会反转排序顺序。以下是一个示例：
- en: '[PRE100]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'This will output the following:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出如下：
- en: '[PRE101]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Letters are sorted in alphabetic order, and they come after numbers. Consider
    this example:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 字母按字母顺序排序，并且排在数字之后。考虑以下示例：
- en: '[PRE102]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'The output is shown here:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示如下：
- en: '[PRE103]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Use Built-in Functions with Lists
  id: totrans-392
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用内建函数与列表
- en: 'We can use several Python built-in functions on lists directly, including `min()`,
    `max()`, `sum()`, and `len()`. These produce the minimum value, the maximum value,
    the total sum, and the length of the list, respectively, like so:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接对列表使用几个Python内置函数，包括`min()`、`max()`、`sum()`和`len()`。这些函数分别返回列表的最小值、最大值、总和和长度，如下所示：
- en: '[PRE104]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Here’s the output:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出结果：
- en: '[PRE105]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: list()
  id: totrans-397
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: list()
- en: 'You can use the `list()` function to convert a string to a list of characters:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`list()`函数将字符串转换为字符列表：
- en: '[PRE106]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'The output is as follows:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE107]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Interestingly enough, Python strings can be treated just like lists of characters.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，Python字符串可以像字符列表一样处理。
- en: Dictionaries
  id: totrans-403
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字典
- en: A *dictionary* is a collection of key-value pairs. We create a dictionary by
    placing the elements inside curly brackets, as shown in [Listing 2-2](#listing2-2).
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典*是一个包含键值对的集合。我们通过将元素放入花括号中来创建字典，如[列表2-2](#listing2-2)所示。'
- en: '[PRE108]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Listing 2-2: Creating a dictionary with two key-value pairs'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2-2：创建一个包含两个键值对的字典
- en: 'The dictionary `scores` has two key-value elements, separated by a comma: the
    first element is the key `blue` and the value `10`, denoted by their position
    and separated by a colon. The second element is `''white'':12`.'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 字典`scores`有两个键值对元素，用逗号分隔：第一个元素是键`blue`，值为`10`，通过位置和冒号分隔。第二个元素是`'white':12`。
- en: 'To create an empty dictionary, you use `dict()` or a pair of curly brackets
    with nothing within them:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个空字典，你可以使用`dict()`或一对空的花括号：
- en: '[PRE109]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'You can add a new element to the existing dictionary as follows:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以按如下方式向现有字典中添加一个新元素：
- en: '[PRE110]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: The line `Dict3['yellow'] = 6` assigns a value of `6` to the key `yellow`. The
    new `Dict3` contains the element `6`, which is accessible by the key `yellow`.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行`Dict3['yellow'] = 6`将值`6`分配给键`yellow`。新的`Dict3`包含了元素`6`，可以通过键`yellow`访问该元素。
- en: Access Values in a Dictionary
  id: totrans-413
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问字典中的值
- en: 'You access values in a dictionary by using the bracket operator. The key value
    in each pair acts as the index. For example, we can access the values in `scores`,
    built in [Listing 2-2](#listing2-2), as follows:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用方括号操作符来访问字典中的值。每个键值对中的键值充当索引。例如，我们可以按照如下方式访问[列表2-2](#listing2-2)中`score`字典的值：
- en: '[PRE111]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'This will give you the following results:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给你以下结果：
- en: '[PRE112]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'We can also use the `get()` method. The advantage of using `get()` is that
    it uses `None` as a default value when a user requests a key that isn’t in the
    dictionary, rather than returning an error. Consider the following script, *get_score.py*:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`get()`方法。使用`get()`的优点是，当用户请求一个不在字典中的键时，它会返回`None`作为默认值，而不是返回错误。请考虑以下脚本，*get_score.py*：
- en: '[PRE113]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'This produces the following:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下结果：
- en: '[PRE114]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Since the key `yellow` is not in `scores`, the method `get('yellow')` returns
    a value of `None`. Further, when you put the option `0` in the method, `get('yellow',
    0)` returns a value of `0`.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 由于键`yellow`不在`scores`中，方法`get('yellow')`返回值`None`。进一步地，当你在方法中添加选项`0`时，`get('yellow',
    0)`将返回值`0`。
- en: Use Dictionary Methods
  id: totrans-423
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用字典方法
- en: 'You can use the `keys()` method to produce a list of all keys in a dictionary:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`keys()`方法来生成字典中所有键的列表：
- en: '[PRE115]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'This gives us the following:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给我们以下结果：
- en: '[PRE116]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'We can use `values()` to produce a list of all values in a dictionary:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`values()`方法生成字典中所有值的列表：
- en: '[PRE117]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'The output is shown here:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE118]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: We can use `items()` to get the list of each key-value pair as a tuple (see
    “Tuples” on page 37).
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`items()`获取每个键值对的列表，作为元组（参见第37页的“元组”）。
- en: '[PRE119]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'This produces the following result:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下结果：
- en: '[PRE120]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: How to Use Dictionaries
  id: totrans-436
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何使用字典
- en: 'The values in a dictionary can be any type of variable, a list, or even another
    dictionary. Here we have a dictionary that uses lists as values:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 字典中的值可以是任何类型的变量、列表，甚至另一个字典。这里我们有一个使用列表作为值的字典：
- en: '[PRE121]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'The value for each key is a three-element list. The three values represent
    the scores each player got in the first half and second half of the game and the
    total score, respectively. To find out how many points the white team got in the
    second half, you can call this:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 每个键的值是一个包含三个元素的列表。这三个值分别表示每个玩家在比赛上半场、下半场和总分的得分。要查找白队在下半场的得分，可以调用以下内容：
- en: '[PRE122]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'The advantage of a dictionary is that its key can be any value, not necessarily
    an integer. This makes dictionaries useful in many situations. For example, *most_freq_word.py*
    uses a dictionary to count words:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 字典的优势在于它的键可以是任何值，不一定是整数。这使得字典在许多场景下都非常有用。例如，*most_freq_word.py*使用字典来统计单词：
- en: '[PRE123]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: We define `news` as a string variable with a short paragraph. We then create
    an empty dictionary `wdcnt`. Next, we split the string into a list of separate
    words. We then count the frequency of each word and store the information in the
    dictionary, with the word as the key and the word count as the value. Because
    we use `get()`, if a word is not already in the dictionary as a key, the second
    argument in `get()` assigns a value of `0` to the word.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`news`定义为一个包含简短段落的字符串变量。然后我们创建一个空字典`wdcnt`。接下来，我们将字符串拆分为一个单独单词的列表。然后我们统计每个单词的频率，并将信息存储在字典中，使用单词作为键，单词的计数作为值。因为我们使用`get()`方法，如果字典中没有该单词作为键，`get()`中的第二个参数会将该单词的值设为`0`。
- en: 'Finally, we print out the words that have the highest frequency. The result
    is as follows:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们打印出频率最高的单词。结果如下：
- en: '[PRE124]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: It turns out that the most frequent word in the news article is `and`, which
    is used three times.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，新闻文章中最常见的单词是`and`，它出现了三次。
- en: Switch Keys and Values
  id: totrans-447
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 交换键和值
- en: 'Sometimes you’ll want to switch the positions of keys and values. Now let’s
    take the term *dictionary* literally and suppose you have the following English-to-Spanish
    dictionary that uses the English word as the key and the Spanish translation as
    the value:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你可能需要交换键和值的位置。现在让我们字面上理解*字典*的含义，假设你有以下英语到西班牙语的字典，使用英语单词作为键，西班牙语翻译作为值：
- en: '[PRE125]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'You want to create a Spanish-to-English dictionary instead. You can accomplish
    this by using the following line of code:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 你想创建一个西班牙语到英语的字典。你可以通过使用以下代码行来实现：
- en: '[PRE126]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'The command `x,y in spanish.items()` retrieves all the key-value pairs in `spanish`.
    The command `y:x for x,y` switches the positions of the keys and values. You must
    put curly brackets around everything to the right of the equal sign so that the
    script treats it as a dictionary. To verify, enter this:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 命令`x,y in spanish.items()`检索`spanish`中的所有键值对。命令`y:x for x,y`交换了键和值的位置。你必须在等号右侧的所有内容周围加上花括号，以便脚本将其视为字典。为了验证，输入以下内容：
- en: '[PRE127]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'You will have the following output:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到以下输出：
- en: '[PRE128]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Combine Two Dictionaries
  id: totrans-456
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 合并两个字典
- en: 'To combine two dictionaries `x` and `y` into one large dictionary `z`, you
    assign `z = {**x, **y}`:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 要将两个字典`x`和`y`合并为一个大的字典`z`，你可以赋值`z = {**x, **y}`：
- en: '[PRE129]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'The result is a new dictionary called `spanishenglish` with six elements: three
    pairs from `spanish` and three pairs from `english`.'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个新的字典，称为`spanishenglish`，其中包含六个元素：三个来自`spanish`，三个来自`english`。
- en: Tuples
  id: totrans-460
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元组
- en: 'A *tuple* is a collection of values separated by commas, similar to a list—with
    the big difference that a tuple cannot be changed after it’s defined (that is,
    tuples are immutable). Elements of a tuple exist inside parentheses instead of
    square brackets to distinguish the tuple from a list. Here we make a tuple and
    attempt to modify it:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '*元组*是由逗号分隔的值的集合，类似于列表——但最大的区别在于元组在定义后不能被更改（也就是说，元组是不可变的）。元组的元素存在圆括号内，而不是方括号，以此来区分元组和列表。这里我们创建一个元组并尝试修改它：'
- en: '[PRE130]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'We get the following error message:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下错误信息：
- en: '[PRE131]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: Because tuples are immutable, we cannot use methods like `append()` or `remove()`
    on them. We cannot sort the elements in a tuple either.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 因为元组是不可变的，我们不能对其使用`append()`或`remove()`等方法。我们也无法对元组中的元素进行排序。
- en: 'The elements of a tuple are indexed by integers, and we can access them by
    using the bracket operator:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 元组的元素是通过整数索引的，我们可以使用方括号运算符来访问它们：
- en: '[PRE132]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Our output is shown here:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的输出如下所示：
- en: '[PRE133]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: We saw examples of assigning values to a tuple in *split_string.py* ([Listing
    2-1](#listing2-1)).
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*split_string.py*中看到过将值赋给元组的例子（[清单 2-1](#listing2-1)）。
- en: You can compare two tuples. This process begins with comparing their first elements.
    If the first elements are the same, we check whether the second elements match.
    If the second elements are also the same, we go to the third elements, and so
    on, until we find a difference.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以比较两个元组。这个过程从比较它们的第一个元素开始。如果第一个元素相同，我们接着检查第二个元素是否匹配。如果第二个元素也相同，我们再比较第三个元素，依此类推，直到发现不同之处。
- en: 'Run the following lines of code in your Spyder editor:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 Spyder 编辑器中运行以下代码：
- en: '[PRE134]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'And you’ll see this output:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到以下输出：
- en: '[PRE135]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: Functions
  id: totrans-476
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数
- en: A *function* is (ideally) a block of code designed to do a task. There are many
    functions that do many things, but it is commonly considered best practice to
    have a function that performs only one task (and does not make changes to other
    variables). Some functions have defined parameters (inputs). We can assign the
    function code to a variable name so we don’t have to repeat the same code every
    time we need that task done. Instead, we just call the function and enter the
    inputs.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数*（理想情况下）是一个为完成特定任务而设计的代码块。有许多执行各种任务的函数，但通常认为最佳实践是设计一个只执行一个任务的函数（并且不更改其他变量）。有些函数有定义的参数（输入）。我们可以将函数代码分配给一个变量名，这样每次需要完成任务时，就不必重复相同的代码。相反，我们只需调用该函数并输入参数。'
- en: Functions also improve readability, making the code more organized, less cluttered,
    and less error-prone.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 函数还可以提高代码的可读性，使代码更有组织性，减少混乱并减少出错的可能性。
- en: Use Built-in Python Functions
  id: totrans-479
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用内置Python函数
- en: Python comes with many built-in functions that you can readily use, including
    `print()` from Chapter 1. Here I’ll discuss a couple of built-in functions we’ll
    use frequently in this book.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: Python自带了许多可以直接使用的内置函数，包括第一章中的`print()`。在这里，我将讨论一些我们在本书中将频繁使用的内置函数。
- en: The range() Function
  id: totrans-481
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`range()` 函数'
- en: 'The `range()` function is used to produce a list of integers. We introduced
    `range()` when we discussed loops on page 21. We know that, for example, `range(5)`
    produces the values `[0, 1, 2, 3, 4]`. The default starting value generated by
    the function `range()` is `0`, because Python uses zero indexing, but you can
    also specify the starting value. For example, `range(3, 6)` produces the list
    of the following three values: `[3, 4, 5]`.'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '`range()` 函数用于生成一个整数列表。当我们在第21页讨论循环时，我们已经介绍过`range()`。我们知道，例如，`range(5)`会生成值`[0,
    1, 2, 3, 4]`。`range()`函数生成的默认起始值是`0`，因为Python使用零索引，但你也可以指定起始值。例如，`range(3, 6)`会生成以下三个值的列表：`[3,
    4, 5]`。'
- en: The default increment value is `1`, but you can also specify the increment as
    the optional third argument. For example, the code
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 默认增量值是`1`，但你也可以将增量值作为可选的第三个参数来指定。例如，代码
- en: '[PRE136]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'will give this output:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 将会输出以下内容：
- en: '[PRE137]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: The third argument in `range(-5, 6, 2)` tells the script to increase the value
    by 2 for each element.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '`range(-5, 6, 2)`中的第三个参数告诉脚本每个元素的值增加2。'
- en: If the increment value is a negative integer, the values in the list decrease.
    For example, `range(9, 0, -3)` produces the list `[9, 6, 3]`.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 如果增量值是负整数，列表中的值会减少。例如，`range(9, 0, -3)`会生成列表`[9, 6, 3]`。
- en: The input() Function
  id: totrans-489
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`input()` 函数'
- en: '*Text-to-speech* is the process of converting written text into human voice,
    so it’s important to know how Python takes written text inputs, using a built-in
    function called `input()`.'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '*语音合成*是将书面文本转换为人类语音的过程，因此了解Python如何使用一个名为`input()`的内置函数来接收书面文本输入是很重要的。'
- en: 'Run the following script in Spyder:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spyder中运行以下脚本：
- en: '[PRE138]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: You should see a screen similar to [Figure 2-3](#figure2-3).
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到一个类似于[图 2-3](#figure2-3)的屏幕。
- en: '![f02003](Images/f02003.png)'
  id: totrans-494
  prefs: []
  type: TYPE_IMG
  zh: '![f02003](Images/f02003.png)'
- en: 'Figure 2-3: A screenshot of what happens when Python is asking for input'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-3：Python请求输入时的截图
- en: 'As you can see in [Figure 2-3](#figure2-3), the script asks for your input
    in the lower-right IPython console. It waits for you to type some text and press
    enter before it continues to run. If you enter `blue`, the script will output
    the following:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在[图 2-3](#figure2-3)中看到的，脚本在右下角的IPython控制台中请求你的输入。它会等待你输入一些文本并按下回车键，然后才会继续运行。如果你输入`blue`，脚本将输出以下内容：
- en: '[PRE139]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'You can ask for multiple inputs, like so:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像这样请求多个输入：
- en: '[PRE140]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: The script asks for two inputs. The sequence `\n` is an escape character, inserting
    a new line below the question “What is your first name?”
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本请求两个输入。序列`\n`是一个转义字符，用于在问题“你的名字是什么？”下方插入新的一行。
- en: Define Your Own Functions
  id: totrans-501
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义你自己的函数
- en: In addition to using built-in functions, we can build our own. I’ll show you
    how to create a function, and this process will also show you how functions work.
    Functions can take one or more inputs, known as *arguments*, or no input at all.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用内置函数外，我们还可以构建自己的函数。我将向你展示如何创建一个函数，这个过程也将展示函数是如何工作的。函数可以接受一个或多个输入，称为*参数*，或者没有任何输入。
- en: A Function with No Argument
  id: totrans-503
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 没有参数的函数
- en: 'We’ll start by building a function that prints the message `Finished printing`.
    This function takes no input:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从构建一个打印`Finished printing`消息的函数开始。这个函数不接受任何输入：
- en: '[PRE141]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: We use `def` to signify a function definition, give a function name, and follow
    it with empty parentheses and a colon. The colon tells Python to expect the body
    of the function. All indented lines that follow are considered part of the function.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `def` 来表示函数定义，给函数命名，并紧跟空括号和冒号。冒号告诉 Python 要期待函数体。之后的所有缩进行都被视为函数的一部分。
- en: 'The script prints three numbers, after which we call the function. The output
    is as follows:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本打印出三个数字，接着我们调用该函数。输出结果如下：
- en: '[PRE142]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: As you can see, the command line in the function is executed only when the function
    is called, not when it is defined.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，函数中的命令只有在函数被调用时才会执行，而不是在函数定义时执行。
- en: A Function with One Argument
  id: totrans-510
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 一个带有一个参数的函数
- en: 'Now we’ll write a function that takes one input. We need to write a thank-you
    note to 50 people. The message is the same except for the recipient’s name. We’ll
    define a function to print the message, and we need to supply only the name for
    each message when we call it. We first define a function called `msgs()` as follows:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将编写一个接受一个输入的函数。我们需要给 50 个人写感谢信。除收件人的名字外，信息内容相同。我们将定义一个函数来打印信息，每次调用时只需要提供每个消息的名字。我们首先定义一个名为
    `msgs()` 的函数，具体如下：
- en: '[PRE143]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'The name of the function is `msgs`, with the variable `name` as its only input.
    If we call the function twice as follows:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的名称是 `msgs`，其唯一的输入是变量 `name`。如果我们按如下方式调用该函数两次：
- en: '[PRE144]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'the output will be this:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将是这样的：
- en: '[PRE145]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'To write the 50 thank-you notes, you can call the function 50 times: once with
    each name.'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 要写 50 张感谢信，你可以调用该函数 50 次：每次传入一个名字。
- en: A Function with Multiple Arguments
  id: totrans-518
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 一个带有多个参数的函数
- en: Functions can have two or more arguments as inputs. Consider the script *team_sales.py*
    in [Listing 2-3](#listing2-3), which defines a function that needs three inputs.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以有两个或更多的输入参数。请参考[列表 2-3](#listing2-3)中的脚本 *team_sales.py*，它定义了一个需要三个输入的函数。
- en: '[PRE146]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'Listing 2-3: Defining a function with three arguments'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-3：定义一个带有三个参数的函数
- en: We define a function to calculate the total sales from a team with three members.
    The function uses the sales from individual members, `sales1`, `sales2`, and `sales3`,
    as the three arguments. We calculate the total team sales, `sales`, by summing
    the three individual sales numbers. We then tell the script the output of the
    function by using the `return` command. As a result, when the function `team_sales()`
    is called, you get the sum of the three sales.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个函数来计算一个由三名成员组成的小组的总销售额。该函数使用单个成员的销售额 `sales1`、`sales2` 和 `sales3` 作为三个参数。我们通过将三项销售额相加来计算团队的总销售额
    `sales`。然后，我们通过使用 `return` 命令告诉脚本输出该函数的结果。因此，当调用函数 `team_sales()` 时，你将得到三项销售额的总和。
- en: If the individual sales are 100, 150, and 120, when we call the function `team_sales()`,
    we’ll get an output of 370.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 如果个人销售额分别为 100、150 和 120，当我们调用函数 `team_sales()` 时，输出将是 370。
- en: A Function That Takes an Unknown Number of Arguments
  id: totrans-524
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 一个接收不定数量参数的函数
- en: Sometimes the number of inputs is unknown. For example, you want to define a
    function to calculate the total sales made by a group of salespeople, but different
    groups have different numbers of salespeople. You can define a single function
    for this purpose that works regardless of the size of the group by using the argument
    `*args`, which allows you to pass multiple values of variable length to a function.
    [Listing 2-4](#listing2-4), *total_sales.py*, accomplishes the job.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 有时输入的数量是未知的。例如，你想定义一个函数来计算一组销售人员的总销售额，但不同的小组有不同数量的销售人员。你可以通过使用参数 `*args` 来定义一个适用于任何小组规模的函数，该参数允许你将不同长度的多个值传递给函数。[列表
    2-4](#listing2-4)中的 *total_sales.py* 就完成了这项工作。
- en: '[PRE147]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'Listing 2-4: First part of *total_sales.py*'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-4：*total_sales.py* 的第一部分
- en: We start `total_sales()`, which takes `*args` as the argument. We set the value
    of the variable `total` to `0` and then loop through each element in the argument
    `args`. For each element in the argument, we add it to the variable `total`. We
    output the total sales of the group. Test it out with [Listing 2-5](#listing2-5).
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始 `total_sales()`，它接收 `*args` 作为参数。我们将变量 `total` 的值设置为 `0`，然后遍历参数 `args`
    中的每个元素。对于参数中的每个元素，我们将其加到变量 `total` 中。最后我们输出该小组的总销售额。可以通过[列表 2-5](#listing2-5)来测试。
- en: '[PRE148]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'Listing 2-5: Second part of the script *t**otal_sales.py*'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-5：脚本 *total_sales.py* 的第二部分
- en: 'From this, we get the following:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 从中我们得到以下结果：
- en: '[PRE149]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: As you can see, the function takes the one argument, `*args`, but you can put
    as many elements in the function as you want.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，函数接收一个参数 `*args`，但你可以在函数中放入任意多个元素。
- en: Modules
  id: totrans-534
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块
- en: You are not limited to just the Python built-in functions. The Python Standard
    Library has many modules that provide other functions you can call from your own
    code.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅仅限于使用 Python 内建函数。Python 标准库有许多模块，提供了其他可以从你自己的代码中调用的函数。
- en: Import Modules
  id: totrans-536
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导入模块
- en: We’ll discuss three ways of using a function from a module and the pros and
    cons of each approach.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论使用模块中函数的三种方式以及每种方式的优缺点。
- en: Import the Module
  id: totrans-538
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 导入模块
- en: 'The first way is to import the entire module. For example, to find the value
    of the cosine of a 30-degree angle, you can first import the *math* module. Then
    you can use the `cos()` function from the module by calling both the module name
    and the function name: `math.cos()`.'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方式是导入整个模块。例如，要查找 30 度角的余弦值，你可以先导入 *math* 模块。然后，你可以通过调用模块名和函数名来使用模块中的 `cos()`
    函数：`math.cos()`。
- en: 'Enter the following code in Spyder:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Spyder 中输入以下代码：
- en: '[PRE150]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: You’ll have an output of `0.15425144988758405`.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到一个输出 `0.15425144988758405`。
- en: 'You have to import the module before you call `math.cos()`*.* If you don’t
    import *math* and just run this command:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须在调用 `math.cos()` 之前先导入模块。如果你没有导入 *math* 模块并直接运行这个命令：
- en: '[PRE151]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'Python will give you an error message:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: Python 会给出一个错误信息：
- en: '[PRE152]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'Also, you must always put the module name in front of the function name when
    you call the function. Enter the following two lines of code in Python:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当你调用函数时，必须始终将模块名放在函数名之前。在 Python 中输入以下两行代码：
- en: '[PRE153]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'You’ll get this error message:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 你将收到这个错误信息：
- en: '[PRE154]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: This is because Python doesn’t know where to find the `cos()` function, even
    though you have imported the *math* module.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 Python 不知道在哪里找到 `cos()` 函数，尽管你已经导入了 *math* 模块。
- en: Import the Functions
  id: totrans-552
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 导入函数
- en: 'If you want only one or two functions from a certain module, you can save time
    by importing just those one or two functions. This approach allows you to use
    the function name without having to append the module name. Enter the following
    two lines of code:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只需要某个模块中的一两个函数，可以通过只导入这一个或两个函数来节省时间。这样你就可以直接使用函数名，而不必附加模块名。输入以下两行代码：
- en: '[PRE155]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: You’ll get the correct output, `4.759421635875676`. We don’t need to use `math`
    because we told the script where to look for the two functions. This is particularly
    useful if you need to use the function dozens or hundreds of times in your script.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到正确的输出 `4.759421635875676`。我们不需要使用 `math`，因为我们已经告诉脚本在哪里查找这两个函数。如果你需要在脚本中使用这个函数几十次或上百次，这种方式特别有用。
- en: Use Asterisk Import
  id: totrans-556
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用星号导入
- en: 'If your script relies heavily on many functions in a module, you can potentially
    save time by importing all functions from the module by using asterisk import:
    `from module import *`. However, many in the Python community have cautioned against
    this approach because the `import *` statement can pollute your namespace, potentially
    interfering with functions you define (or functions from other modules). We won’t
    use this method in the book.'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的脚本依赖于模块中的许多函数，你可以通过使用星号导入 `from module import *` 来节省时间。然而，许多 Python 社区的成员警告不要使用这种方式，因为
    `import *` 语句可能会污染你的命名空间，可能会干扰你自己定义的函数（或来自其他模块的函数）。我们在本书中不会使用这种方法。
- en: Create Your Own Modules
  id: totrans-558
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建你自己的模块
- en: In [Listing 2-3](#listing2-3), we defined `team_sales()` in *team_sales.py*
    and then called the function. You might need to calculate the total sales in many
    scripts. You can do so without rewriting the code in each script by building the
    function into a module.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 2-3](#listing2-3) 中，我们在 *team_sales.py* 文件中定义了 `team_sales()` 函数，然后调用了该函数。你可能需要在多个脚本中计算总销售额。通过将该函数构建到模块中，你可以避免在每个脚本中重新编写代码。
- en: Let’s first create a script called *create_local_module.py,* as shown in [Listing
    2-6](#listing2-6).
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先创建一个名为 *create_local_module.py* 的脚本，如 [列表 2-6](#listing2-6) 所示。
- en: '[PRE156]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'Listing 2-6: Code for the local module'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-6：本地模块的代码
- en: This script defines `team_sales()` but does not call it. Next, create the new
    script *import_local_module.py* in [Listing 2-7](#listing2-7) and save it in the
    same folder as *create_local_module.py*.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本定义了 `team_sales()` 函数，但没有调用它。接下来，创建一个新的脚本 *import_local_module.py*，如 [列表
    2-7](#listing2-7) 所示，并将其保存在与 *create_local_module.py* 相同的文件夹中。
- en: '[PRE157]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'Listing 2-7: Code to import the local module'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-7：导入本地模块的代码
- en: When you import a module, Python first looks in the directory the importing
    script is stored in, so the module must be in the same folder. This kind of module
    is known as a *local module*.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 当你导入一个模块时，Python 首先会在导入脚本所在的目录中查找，所以模块必须位于相同的文件夹中。这种模块被称为 *本地模块*。
- en: 'If you run the script, you’ll get the following results:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行脚本，你将获得以下结果：
- en: '[PRE158]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: The `team_sales()` function correctly calculates the total sales for three teams.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: '`team_sales()` 函数正确计算了三个团队的总销售额。'
- en: Local modules work the same as modules in the Python Standard Library, but they
    need to be stored in the folder Python expects them to be in.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 本地模块与 Python 标准库中的模块一样工作，但它们需要存放在 Python 期望它们所在的文件夹中。
- en: 'For modules that you download, Python stores the file path of the downloaded
    module behind the scenes and follows that path when you import it. For example,
    the *tkinter* package is in the Python Standard Library we’ll use later in this
    book. When you install it, the files are placed under a specific path, which is
    something like the following on Windows:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你下载的模块，Python 会在后台存储已下载模块的文件路径，并在导入时遵循该路径。例如，*tkinter* 包就在我们稍后在本书中使用的 Python
    标准库中。当你安装它时，文件会被放置在一个特定的路径下，在 Windows 系统中通常是以下类似的路径：
- en: '[PRE159]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: It’s buried like this so you don’t accidentally alter or misplace it, which
    would mean you could no longer use it.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 它被这样隐藏起来，是为了防止你不小心更改或丢失它，否则你将无法继续使用它。
- en: Use Third-Party Modules
  id: totrans-574
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用第三方模块
- en: One of the main advantages of Python is that programmers can share modules with
    one another for free. Many of these modules are not in the Python Standard Library,
    including the module we’ll rely on for the text-to-speech and the speech recognition
    functionality. These external modules, known as *third-party modules*, can be
    installed separately. Before you do that, you need to check that the module isn’t
    already installed.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的主要优势之一是程序员可以相互免费分享模块。这些模块中有许多不在 Python 标准库中，包括我们将用于文本转语音和语音识别功能的模块。这些外部模块，被称为
    *第三方模块*，可以单独安装。在安装之前，你需要先检查该模块是否已安装。
- en: Check Installed Modules
  id: totrans-576
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 检查已安装模块
- en: All modules in the Python Standard Library are automatically installed on your
    machine when you install Python. Other modules may also be installed when you
    download various software or modules. For example, when you install *pandas* in
    Chapter 14, about 23 other supporting modules will be installed because *pandas*
    depends on them.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: Python 标准库中的所有模块都会在你安装 Python 时自动安装到你的计算机上。其他模块可能会在你下载各种软件或模块时一并安装。例如，当你在第十四章安装
    *pandas* 时，约有 23 个其他支持模块也将被安装，因为 *pandas* 依赖它们。
- en: 'You can check whether a module is installed on your computer already with the
    following in your Spyder editor:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下命令在 Spyder 编辑器中检查模块是否已经安装：
- en: '[PRE160]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: This will provide you with the list of all modules installed on your computer.
    However, it can take a long time for Python to list all the modules and for you
    to check them.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为你提供计算机上所有已安装模块的列表。不过，Python 列出所有模块并让你检查它们可能需要较长时间。
- en: 'Alternatively, you can check whether a module is installed by trying to import
    it:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，你也可以通过尝试导入模块来检查它是否已安装：
- en: '[PRE161]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: To check whether *pandas* is installed on your computer, run `import pandas`,
    and if you receive no error message, the module is already installed. If the output
    shows `ModuleNotFoundError`, you need to install it. Let’s see how.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查 *pandas* 是否已安装在你的计算机上，运行 `import pandas`，如果没有错误消息，说明模块已经安装。如果输出显示 `ModuleNotFoundError`，则需要安装它。让我们来看一下如何安装。
- en: Pip Install Modules
  id: totrans-584
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Pip 安装模块
- en: 'The *gTTS* module we’ll use in Chapter 4 is not included in Python Standard
    Library, so we’ll `pip` `install` it. Open the Anaconda prompt (in Windows) or
    a terminal (in Mac or Linux), and enter this:'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第四章使用的 *gTTS* 模块不包含在 Python 标准库中，因此我们需要通过 `pip install` 安装它。打开 Anaconda
    提示符（Windows）或终端（Mac 或 Linux），并输入以下命令：
- en: '[PRE162]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: Follow the onscreen instructions all the way through, and the *gTTS* module
    will be installed.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 按照屏幕上的指示完成操作，*gTTS* 模块将被安装。
- en: Conda Install Modules
  id: totrans-588
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Conda 安装模块
- en: If you can’t find the module you want through `pip` `install`, try `conda install`.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你通过 `pip install` 找不到你想要的模块，可以尝试 `conda install`。
- en: 'We’ll install the *yt* module by using the following in the Anaconda prompt
    (in Windows) or a terminal (in Mac or Linux):'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过在 Anaconda 提示符（Windows）或终端（Mac 或 Linux）中使用以下命令来安装 *yt* 模块：
- en: '[PRE163]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: Many people think `pip install` and `conda install` are the same, but they’re
    not. Pip is the Python packaging authority’s recommended tool for installing packages
    from the Python packaging index. You can install Python software only by using
    `pip install`. In contrast, Conda is a cross-platform package and environment
    manager that installs not only Python software but also packages in C or C++ libraries,
    R packages, or other software.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人认为 `pip install` 和 `conda install` 是一样的，但其实它们并不相同。Pip 是 Python 包管理机构推荐的工具，用于从
    Python 包索引安装包。你只能使用 `pip install` 安装 Python 软件。与此相对，Conda 是一个跨平台的包和环境管理器，它不仅安装
    Python 软件，还可以安装 C 或 C++ 库中的包、R 包或其他软件。
- en: As you build more and more projects in Python, you’ll install many modules.
    Some modules may interfere with other modules, and different projects may use
    different versions of the same module. To avoid problems of clashing modules,
    I recommend you build a virtual environment for each project. A *virtual environment*
    is a way to isolate projects from each other.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你在 Python 中构建越来越多的项目，你将会安装许多模块。有些模块可能会与其他模块发生冲突，而且不同的项目可能使用相同模块的不同版本。为了避免模块冲突问题，我建议你为每个项目创建一个虚拟环境。*虚拟环境*是一种将项目彼此隔离的方式。
- en: Create a Virtual Environment
  id: totrans-594
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建虚拟环境
- en: 'To create a virtual environment, open an Anaconda prompt (in Windows) or a
    terminal (in Mac or Linux). We’ll name the virtual environment for the projects
    in this book *chatting*. Enter the following command:'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建虚拟环境，请打开 Anaconda 提示符（在 Windows 中）或终端（在 Mac 或 Linux 中）。我们将为本书中的项目命名虚拟环境为
    *chatting*。输入以下命令：
- en: '[PRE164]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: After pressing enter, follow the instructions onscreen and press **y** when
    the prompt asks you `y/n`. Once you have created the virtual environment on your
    machine, you need to activate it.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 按下回车键后，按照屏幕上的指示操作，当提示你输入 `y/n` 时按 **y**。一旦你在机器上创建了虚拟环境，就需要激活它。
- en: Activate the Virtual Environment in Windows
  id: totrans-598
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Windows 中激活虚拟环境
- en: 'In the Anaconda prompt (in Windows) or a terminal (in Mac or Linux), type this:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Anaconda 提示符（在 Windows 中）或终端（在 Mac 或 Linux 中），输入以下命令：
- en: '[PRE165]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'In Windows, you’ll see the following on your Anaconda prompt:'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 中，你将在 Anaconda 提示符中看到以下内容：
- en: '[PRE166]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: You can see the `(chatting)` prompt, which indicates that the command line is
    now in the virtual environment *chatting* that you’ve just created.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到 `(chatting)` 提示符，表示命令行现在位于你刚刚创建的虚拟环境 *chatting* 中。
- en: 'On a Mac, you should see something similar to the following in the terminal
    (the username will be different):'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Mac 上，你应该在终端中看到类似以下内容（用户名会不同）：
- en: '[PRE167]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'In Linux, you should see something similar to this on your terminal (the username
    will be different):'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 中，你应该在终端中看到类似以下内容（用户名会不同）：
- en: '[PRE168]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: Set Up Spyder in the Virtual Environment in Windows
  id: totrans-608
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Windows 中设置虚拟环境中的 Spyder
- en: 'Now we need to install Spyder in the new virtual environment. First make sure
    you’ve activated the virtual environment. Then run this command:'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要在新的虚拟环境中安装 Spyder。首先确保你已激活虚拟环境。然后运行以下命令：
- en: '[PRE169]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'To then launch Spyder, execute the following command in the same terminal with
    the virtual environment activated:'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在同一个已激活虚拟环境的终端中执行以下命令以启动 Spyder：
- en: '[PRE170]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: Summary
  id: totrans-613
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned the four variable types and how to convert one
    type to another. You also learned how functions work in Python. You learned three
    ways to import a module into a script and the pros and cons of each approach.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了四种变量类型以及如何将一种类型转换为另一种类型。你还学习了 Python 中函数的工作原理。你学习了三种将模块导入脚本的方法，并了解了每种方法的优缺点。
- en: You also created your own functions. You created a local module and imported
    it to a script to make clean and concise code. Finally, you created and activated
    a virtual environment in order to separate packages in different projects.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 你还创建了自己的函数。你创建了一个本地模块并将其导入到脚本中，以使代码更加简洁清晰。最后，你创建并激活了虚拟环境，以便在不同的项目中分离包。
- en: In Chapter 3, you’ll learn how to install speech recognition–related modules
    to make Python understand the human voice.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 3 章中，你将学习如何安装与语音识别相关的模块，使 Python 能够理解人类的声音。
- en: End-of-Chapter Exercises
  id: totrans-617
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本章练习
- en: 'Assume:'
  id: totrans-618
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设：
- en: '[PRE171]'
  id: totrans-619
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE171]'
- en: What is the output from each of the following Python statements? First write
    down the answer and then run the command in Spyder to verify.
  id: totrans-620
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下每个 Python 语句的输出是什么？首先写下答案，然后在 Spyder 中运行该命令以验证。
- en: '[PRE172]'
  id: totrans-621
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'Assume:'
  id: totrans-622
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设：
- en: '[PRE173]'
  id: totrans-623
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE173]'
- en: What is the result from each of the following Python statements?
  id: totrans-624
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下每个 Python 语句的结果是什么？
- en: '[PRE174]'
  id: totrans-625
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'Here are some examples of integers:'
  id: totrans-626
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是一些整数的例子：
- en: '[PRE175]'
  id: totrans-627
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE175]'
- en: What is the result from each of the following Python statements?
  id: totrans-628
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下每条Python语句的结果是什么？
- en: '[PRE176]'
  id: totrans-629
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE176]'
- en: What is the output from each of the following Python statements?
  id: totrans-630
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下每条Python语句的输出是什么？
- en: '[PRE177]'
  id: totrans-631
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE177]'
- en: What is the output from each of the following Python statements?
  id: totrans-632
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下每条Python语句的输出是什么？
- en: '[PRE178]'
  id: totrans-633
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE178]'
- en: What is the output from each of the following Python statements?
  id: totrans-634
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下每条Python语句的输出是什么？
- en: '[PRE179]'
  id: totrans-635
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE179]'
- en: What is the output from each of the following Python statements?
  id: totrans-636
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下每条Python语句的输出是什么？
- en: '[PRE180]'
  id: totrans-637
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE180]'
- en: Are the following variable names valid, and why?
  id: totrans-638
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下变量名是否有效，为什么？
- en: '[PRE181]'
  id: totrans-639
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE181]'
- en: The loop command `break` is used in the following script. What should the output
    be? First write down the answer and then run the command in Spyder and verify.
  id: totrans-640
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下脚本中使用了循环命令`break`。输出应该是什么？首先写下答案，然后在Spyder中运行命令以验证。
- en: '[PRE182]'
  id: totrans-641
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE182]'
- en: The loop command `continue` is used in the following script. What should the
    output be? First write down the answer and then run the command in Spyder and
    verify.
  id: totrans-642
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下脚本中使用了循环命令`continue`。输出应该是什么？首先写下答案，然后在Spyder中运行命令以验证。
- en: '[PRE183]'
  id: totrans-643
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE183]'
- en: The loop command `pass` is used in the following script. What should the output
    be? First write down the answer and then run the command in Spyder and verify.
  id: totrans-644
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下脚本中使用了循环命令`pass`。输出应该是什么？首先写下答案，然后在Spyder中运行命令以验证。
- en: '[PRE184]'
  id: totrans-645
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE184]'
- en: What is the output from each of the following commands? First write down the
    answer and then run the command in Spyder to verify it.
  id: totrans-646
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下每条命令的输出是什么？首先写下答案，然后在Spyder中运行命令以验证。
- en: '[PRE185]'
  id: totrans-647
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-648
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-649
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE187]'
- en: What is the value of `team_sales(50, 100, 120)` according to the defined function
    in this chapter?
  id: totrans-650
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据本章中定义的函数，`team_sales(50, 100, 120)`的值是多少？
- en: Change the module import method in the script *import_local_module.py* from
    the `from` `module` `import` `function` method to the `import` `module` method.
    Name the new script *import_local_module1.py* and make sure it produces the same
    output.
  id: totrans-651
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将脚本*import_local_module.py*中的模块导入方法从`from` `module` `import` `function`方法改为`import`
    `module`方法。将新脚本命名为*import_local_module1.py*，并确保它产生相同的输出。
- en: Grades for the midterm project of eight groups in a class are in a list `midterm
    = [95, 78, 77, 86, 90, 88, 81, 66]`. Use Python built-in functions on the list
    to calculate the range and the average of the grades.
  id: totrans-652
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 班级中八个小组的期中项目成绩保存在列表`midterm = [95, 78, 77, 86, 90, 88, 81, 66]`中。使用Python内置函数计算成绩的范围和平均值。
- en: Assume `inp = "University of Kentucky"`, and determine `inp[5:10]`, `inp[-1]`,
    `inp[:10]`, and `inp[5:]`.
  id: totrans-653
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设`inp = "University of Kentucky"`，请确定`inp[5:10]`、`inp[-1]`、`inp[:10]`和`inp[5:]`的值。
- en: If `email = John.Smith@uky.edu`, what is `email.find("y")`?
  id: totrans-654
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`email = John.Smith@uky.edu`，`email.find("y")`的结果是什么？
- en: Assume `llst = [[1,2,3,5],[2,2,6,8],[2,3,5,9],[3,5,4,7],[1,3,5,0]]`. What are
    the values of `llst[2]`, `llst[2][2]`, and `llst[3][0]`?
  id: totrans-655
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设`llst = [[1,2,3,5],[2,2,6,8],[2,3,5,9],[3,5,4,7],[1,3,5,0]]`。`llst[2]`、`llst[2][2]`和`llst[3][0]`的值分别是多少？
- en: What is the output from each of the following Python statements?
  id: totrans-656
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下每条Python语句的输出是什么？
- en: '[PRE188]'
  id: totrans-657
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE188]'
- en: Assume `scores2 = {'blue':[5, 5, 10], 'white':[5, 7, 12]}`. What is `scores2['blue'][2]`?
  id: totrans-658
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设`scores2 = {'blue':[5, 5, 10], 'white':[5, 7, 12]}`。`scores2['blue'][2]`的值是多少？
- en: 'Here is an example of a tuple: `tpl = (1, 2, 3, 9, 0)`. What is `tpl[3:4]`?'
  id: totrans-659
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个元组的例子：`tpl = (1, 2, 3, 9, 0)`。`tpl[3:4]`的值是多少？
- en: 'You have a list `lst = [1, "a", "hello", 2]`. Create a dictionary with four
    key-value pairs: the key is the position of each element in `lst`, and the value
    is the element at that position.'
  id: totrans-660
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你有一个列表`lst = [1, "a", "hello", 2]`。创建一个字典，包含四个键值对：键是`lst`中每个元素的位置，值是该位置上的元素。
