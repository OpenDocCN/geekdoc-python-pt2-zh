- en: '[1](nsp-venkitachalam503045-0008.xhtml#rch01)'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[1](nsp-venkitachalam503045-0008.xhtml#rch01)'
- en: The Koch Snowflake
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 科赫雪花
- en: '![](images/nsp-venkitachalam503045-circle-image.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-circle-image.jpg)'
- en: We’ll start our Python adventures by figuring out how to draw an interesting
    shape called the *Koch snowflake*, invented by Swedish mathematician Helge von Koch
    in 1904\. The Koch snowflake is a *fractal*—a type of figure that repeats itself
    as you zoom in to it.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过弄清楚如何绘制一个有趣的形状——*科赫雪花*来开始我们的Python冒险。它是瑞典数学家赫尔格·冯·科赫（Helge von Koch）于1904年发明的。科赫雪花是一种*分形*——一种随着你不断放大它，它会重复自身的图形。
- en: Fractals derive their repeating nature from *recursion*, a technique where something
    is defined in terms of itself. In particular, you draw a fractal using a *recursive
    algorithm*, a repeating process where one repetition’s output becomes the input
    of the next repetition.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 分形的重复性质来自于*递归*，这是一种将某物定义为其自身的技巧。特别是，你通过*递归算法*绘制分形，这是一种重复的过程，其中一次重复的输出成为下次重复的输入。
- en: 'As you work through this chapter, you’ll learn:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章学习过程中，你将学到：
- en: • The basics of recursive algorithms and functions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 递归算法和函数的基础
- en: • How to create graphics using the `turtle` module
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 如何使用`turtle`模块创建图形
- en: • A recursive algorithm to draw the Koch snowflake
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 绘制科赫雪花的递归算法
- en: • Some linear algebra
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 一些线性代数
- en: '[How It Works](nsp-venkitachalam503045-0008.xhtml#rah0301)'
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[它是如何工作的](nsp-venkitachalam503045-0008.xhtml#rah0301)'
- en: '[Figure 1-1](nsp-venkitachalam503045-0012.xhtml#fig1-1) shows what the Koch
    snowflake looks like. Notice how the large branch in the middle is repeated on
    a smaller scale by branches on the left and right. Similarly, the large branch
    in the middle is itself made up of smaller branches that echo the larger shape.
    This is the repeating, self-similar nature of a fractal.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[图1-1](nsp-venkitachalam503045-0012.xhtml#fig1-1)显示了科赫雪花的样子。注意中间的大分支在左右两侧以较小的比例重复出现。类似地，中间的大分支本身由一些更小的分支构成，重复了更大的形状。这就是分形的重复自相似特性。'
- en: '![](images/nsp-venkitachalam503045-f01001.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f01001.jpg)'
- en: 'Figure 1-1: The Koch snowflake'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-1：科赫雪花
- en: If you know how to calculate the points that form the basic shape making up
    the snowflake, you can develop an algorithm to perform the same calculations recursively.
    This way, you’ll draw smaller and smaller versions of that shape, building up
    the fractal. In this section, we’ll look generally at how recursion works. Then
    we’ll consider how to apply recursion, along with some linear algebra and Python’s
    `turtle` module, to draw the Koch snowflake.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道如何计算构成雪花基本形状的点，你就可以开发一个算法，通过递归执行相同的计算。通过这种方式，你将绘制出该形状的越来越小的版本，从而构建出分形。在本节中，我们将大致了解递归是如何工作的。接着，我们将考虑如何结合递归、一些线性代数和Python的`turtle`模块来绘制科赫雪花。
- en: '[Using Recursion](nsp-venkitachalam503045-0008.xhtml#rbh0301)'
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[使用递归](nsp-venkitachalam503045-0008.xhtml#rbh0301)'
- en: 'To get a feel for how recursion works, let’s take a look at a simple recursive
    algorithm: computing the factorial of a number. The factorial of a number can
    be defined by a function, as shown here:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了感受递归是如何工作的，我们先来看一个简单的递归算法：计算一个数字的阶乘。一个数字的阶乘可以通过一个函数来定义，如下所示：
- en: '*f*(*N*) = 1 × 2 × 3 × . . . × (*N* − 1) × *N*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*f*(*N*) = 1 × 2 × 3 × . . . × (*N* − 1) × *N*'
- en: 'In other words, the factorial of *N* is just the product of the numbers 1 through
    *N*. You can rewrite this as:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，*N*的阶乘就是1到*N*之间所有数字的乘积。你可以将其重写为：
- en: '*f*(*N*) = *N* × (*N* − 1) × . . . × 3 × 2 × 1'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*f*(*N*) = *N* × (*N* − 1) × . . . × 3 × 2 × 1'
- en: 'which can again be rewritten as:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以再次被重写为：
- en: '*f*(*N*) = *N* × *f*(*N* − 1)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*f*(*N*) = *N* × *f*(*N* − 1)'
- en: Wait, what did you just do? You defined *f* in terms of itself! That’s recursion.
    Calling *f*(*N*) will end up calling *f*(*N* − 1), which will end up calling *f*(*N*
    − 2), and so on. But how do you know when to stop? Well, you have to define *f*(1)
    as 1, and that will be the deepest step of the recursion.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 等等，你刚刚做了什么？你把*f*定义为它自身！这就是递归。调用*f*(*N*)最终会调用*f*(*N* − 1)，而*f*(*N* − 1)又会调用*f*(*N*
    − 2)，依此类推。那么，怎么知道什么时候停止呢？你需要将*f*(1)定义为1，这就是递归的最深层次。
- en: 'Here’s how to implement the recursive factorial function in Python:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何在Python中实现递归阶乘函数的：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You handle the case where *N* is equal to 1 by simply returning `1` ❶, and you
    implement the recursive call by calling `factorial()` again ❷, this time passing
    in `N-1`. The function will keep calling itself until *N* equals 1\. The net effect
    is that when the function returns, it will have computed the product of all numbers
    1 through *N*.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当*N*等于1时，通过简单地返回`1` ❶来处理这种情况，并通过再次调用`factorial()`实现递归调用 ❷，这次传入`N-1`。该函数将一直调用自身，直到*N*等于1。其效果是，当函数返回时，它将计算出从1到*N*的所有数字的乘积。
- en: 'In general, when you’re trying to implement an algorithm using recursion, follow
    these steps:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在尝试使用递归实现算法时，按照以下步骤操作：
- en: 1\. Define a base case where the recursion ends. In our factorial example, you
    did this by defining *f*(1) as 1.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1\. 定义递归结束的基本情况。在我们的阶乘示例中，通过将*f*(1)定义为1来完成此操作。
- en: 2\. Define the recursive step. For this you need to think about how to express
    the algorithm as a recursive process. In some algorithms, there can be multiple
    recursive calls from a function—as you’ll see soon.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2\. 定义递归步骤。为此，你需要考虑如何将算法表达为递归过程。在某些算法中，函数可以从多个递归调用中调用，正如你将很快看到的那样。
- en: Recursion is a helpful tool for problems that can be naturally partitioned into
    smaller versions of themselves. The factorial algorithm is a perfect example of
    this partitioning, and as you’ll soon see, so is drawing the Koch snowflake. That
    said, recursion isn’t always the most efficient way to solve a problem. In some
    cases, it would make sense to re-implement the recursive algorithm in terms of
    loops. But the fact remains that recursive algorithms are often more compact and
    elegant compared to their loopy counterparts.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 递归是解决可以自然地分割成更小版本的问题的有用工具。阶乘算法就是这种分割的完美例子，正如你很快会看到的，绘制科赫雪花也是如此。尽管如此，递归并不总是解决问题的最有效方法。在某些情况下，重新用循环实现递归算法可能更合理。但事实是，递归算法通常比它们的循环对应物更紧凑和优雅。
- en: Computing the Snowflake
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计算雪花
- en: Now let’s look at how to construct the Koch snowflake. [Figure 1-2](nsp-venkitachalam503045-0012.xhtml#fig1-2)
    shows the basic pattern for drawing the snowflake. I’ll call this pattern a *flake*.
    The basis of the figure is the line segment ![](images/nsp-venkitachalam503045-m01001.jpg)
    of length *d*. The segment is split into three equal parts, ![](images/nsp-venkitachalam503045-m01002.jpg),
    ![](images/nsp-venkitachalam503045-m01003.jpg), and ![](images/nsp-venkitachalam503045-m01004.jpg),
    each of which has a length *r*. Instead of directly connecting points *P*[1] and
    *P*[3], these points are connected through *P*[2], which is chosen such that *P*[1],
    *P*[2], and *P*[3] form an equilateral triangle of side length *r* and height
    *h*. Point *C*, the midpoint of *P*[1] and *P*[3] (and by extension of *A* and
    *B*), falls directly beneath *P*[2], such that ![](images/nsp-venkitachalam503045-m01005.jpg)
    and ![](images/nsp-venkitachalam503045-m01006.jpg) are perpendicular.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何构造科赫雪花。[图1-2](nsp-venkitachalam503045-0012.xhtml#fig1-2)展示了绘制雪花的基本图案。我将这种图案称为*雪花*。图案的基础是长度为*d*的线段![](images/nsp-venkitachalam503045-m01001.jpg)。该段被分为三等分部分，![](images/nsp-venkitachalam503045-m01002.jpg)、![](images/nsp-venkitachalam503045-m01003.jpg)和![](images/nsp-venkitachalam503045-m01004.jpg)，每个部分的长度为*r*。不直接连接点*P*[1]和*P*[3]，而是通过*P*[2]连接这些点，选择*P*[2]使得*P*[1]、*P*[2]和*P*[3]形成边长为*r*、高度为*h*的等边三角形。点*C*，*P*[1]和*P*[3]（以及*A*和*B*）的中点，正好位于*P*[2]的正下方，因此![](images/nsp-venkitachalam503045-m01005.jpg)和![](images/nsp-venkitachalam503045-m01006.jpg)是垂直的。
- en: '![](images/nsp-venkitachalam503045-f01002.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f01002.jpg)'
- en: 'Figure 1-2: The basic pattern for drawing a Koch snowflake'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-2：绘制科赫雪花的基本图案
- en: 'Once you understand how to calculate the points shown in [Figure 1-2](nsp-venkitachalam503045-0012.xhtml#fig1-2),
    you’ll be able to recursively draw smaller and smaller flakes to reproduce the
    Koch snowflake. Essentially, your goal is this: given points *A* and *B*, you
    want to compute the points *P*[1], *P*[2], and *P*[3] and join them up as shown
    in the figure. To calculate those points, you’ll need to use some linear algebra,
    a mathematical discipline that lets you compute distances and figure out coordinates
    of points based on *vectors*, quantities that have both magnitude and direction.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你理解了如何计算[图1-2](nsp-venkitachalam503045-0012.xhtml#fig1-2)中显示的点，你就能递归地绘制越来越小的雪花，以重现科赫雪花。基本上，你的目标是这样的：给定点*A*和*B*，你想计算出点*P*[1]、*P*[2]和*P*[3]，并像图中显示的那样将它们连接起来。为了计算这些点，你需要使用一些线性代数，这是一门数学学科，让你可以计算距离，并根据*向量*确定点的坐标，向量是具有大小和方向的量。
- en: 'Here’s a simple formula from linear algebra that you’ll be using. Say you have
    a point *A* in 3D space and a unit vector ![](images/nsp-venkitachalam503045-m01007.jpg)
    (a *unit vector* is a vector with a length of 1 unit). Point *B* at a distance
    *d* along this unit vector is given by:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个你将使用的简单线性代数公式。假设你在 3D 空间中有一个点 *A* 和一个单位向量 ![](images/nsp-venkitachalam503045-m01007.jpg)（单位向量是长度为
    1 单位的向量）。沿着该单位向量，距离 *d* 的点 *B* 的坐标为：
- en: '*B* = *A* + *d* × ![](images/nsp-venkitachalam503045-m01007.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*B* = *A* + *d* × ![](images/nsp-venkitachalam503045-m01007.jpg)'
- en: 'You can easily verify this with an example. Take the case where *A* = (5, 0,
    0) and ![](images/nsp-venkitachalam503045-m01007.jpg) = (0, 1, 0). What are the
    coordinates for a point *B* that’s 10 units away from *A* along ![](images/nsp-venkitachalam503045-m01007.jpg)?
    Using the previous formula, you get:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过一个例子轻松验证这一点。假设 *A* = (5, 0, 0) 且 ![](images/nsp-venkitachalam503045-m01007.jpg)
    = (0, 1, 0)。那么，点 *B* 在沿着 ![](images/nsp-venkitachalam503045-m01007.jpg) 方向上与 *A*
    相距 10 个单位的坐标是多少呢？使用之前的公式，你得到：
- en: '*B* = (5, 0, 0) + 10 × (0, 1, 0) = (5, 10, 0)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*B* = (5, 0, 0) + 10 × (0, 1, 0) = (5, 10, 0)'
- en: In other words, to get from *A* to *B*, you move 10 units along the positive
    y-axis.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，从 *A* 到 *B*，你沿着正 y 轴移动了 10 个单位。
- en: 'Here’s another result you’ll use—let’s call it the *perpendicular vector trick*.
    Say you have a vector ![](images/nsp-venkitachalam503045-m01008.jpg) = (*a*, *b*).
    If you have another vector ![](images/nsp-venkitachalam503045-m01009.jpg) that’s
    perpendicular to ![](images/nsp-venkitachalam503045-m01008.jpg), it can be expressed
    as ![](images/nsp-venkitachalam503045-m01009.jpg) = (−*b*, *a*). You can verify
    that this trick works by taking the dot product of ![](images/nsp-venkitachalam503045-m01008.jpg)
    and ![](images/nsp-venkitachalam503045-m01009.jpg). To take the dot product of
    a pair of two-dimensional vectors, multiply the first components from each vector,
    then multiply the second components from each vector, and finally add the results
    together. In this case, the dot product of ![](images/nsp-venkitachalam503045-m01008.jpg)
    and ![](images/nsp-venkitachalam503045-m01009.jpg) is:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个你将使用的结果——我们称之为*垂直向量技巧*。假设你有一个向量 ![](images/nsp-venkitachalam503045-m01008.jpg)
    = (*a*, *b*)。如果你有另一个向量 ![](images/nsp-venkitachalam503045-m01009.jpg)，它与 ![](images/nsp-venkitachalam503045-m01008.jpg)
    垂直，那么它可以表示为 ![](images/nsp-venkitachalam503045-m01009.jpg) = (−*b*, *a*)。你可以通过对
    ![](images/nsp-venkitachalam503045-m01008.jpg) 和 ![](images/nsp-venkitachalam503045-m01009.jpg)
    进行点积来验证这个技巧的正确性。为了计算一对二维向量的点积，你需要将每个向量的第一个分量相乘，然后将每个向量的第二个分量相乘，最后将结果加在一起。在这种情况下，![](images/nsp-venkitachalam503045-m01008.jpg)
    和 ![](images/nsp-venkitachalam503045-m01009.jpg) 的点积为：
- en: '![](images/nsp-venkitachalam503045-m01010.jpg) = (*a* × −*b*) + (*b* × *a*)
    = −*ab* + *ab* = 0'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '![](images/nsp-venkitachalam503045-m01010.jpg) = (*a* × −*b*) + (*b* × *a*)
    = −*ab* + *ab* = 0'
- en: The dot product of two perpendicular vectors will always be zero, so ![](images/nsp-venkitachalam503045-m01009.jpg)
    is indeed perpendicular to ![](images/nsp-venkitachalam503045-m01008.jpg).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 两个垂直向量的点积总是零，因此 ![](images/nsp-venkitachalam503045-m01009.jpg) 确实与 ![](images/nsp-venkitachalam503045-m01008.jpg)
    垂直。
- en: 'With this in mind, let’s return to the flake in [Figure 1-2](nsp-venkitachalam503045-0012.xhtml#fig1-2).
    How can you calculate the position of *P*[2], given the coordinates for points
    *A* and *B*? You know that *P*[2] falls *h* distance away from point *C* along
    unit vector ![](images/nsp-venkitachalam503045-m01007.jpg). Your first linear
    algebra formula tells you:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个公式，让我们回到[图 1-2](nsp-venkitachalam503045-0012.xhtml#fig1-2)中的雪花。给定点 *A* 和
    *B* 的坐标，如何计算 *P*[2] 的位置？你知道 *P*[2] 离点 *C* 的距离是 *h*，并且沿着单位向量 ![](images/nsp-venkitachalam503045-m01007.jpg)
    方向。你的第一个线性代数公式告诉你：
- en: '*P*[2] = *C* + *h* × ![](images/nsp-venkitachalam503045-m01007.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*P*[2] = *C* + *h* × ![](images/nsp-venkitachalam503045-m01007.jpg)'
- en: 'Now let’s put those variables in terms that you know. First, *C* is the midpoint
    of line ![](images/nsp-venkitachalam503045-m01011.jpg), so *C* = (*A* + *B*) /
    2\. Next, *h* is the height of an equilateral triangle with side length *r*. The
    Pythagorean theorem tells you:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们把这些变量转换成你已知的形式。首先，*C* 是线段 ![](images/nsp-venkitachalam503045-m01011.jpg)
    的中点，因此 *C* = (*A* + *B*) / 2。接下来，*h* 是一个边长为 *r* 的等边三角形的高度。毕达哥拉斯定理告诉你：
- en: '![](images/nsp-venkitachalam503045-m01012.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-m01012.jpg)'
- en: 'In this case, *r* is simply a third of the distance from *A* to *B*. If *A*
    has coordinates (*x*[1], *y*[1]) and *B* has coordinates (*x*[2], *y*[2]), you
    can calculate the distance between them as:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，*r* 仅仅是从 *A* 到 *B* 的三分之一的距离。如果 *A* 的坐标是 (*x*[1], *y*[1])，*B* 的坐标是 (*x*[2],
    *y*[2])，你可以通过以下公式计算它们之间的距离：
- en: '![](images/nsp-venkitachalam503045-m01013.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-m01013.jpg)'
- en: Then simply divide *d* by 3 to get *r*.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然后只需将 *d* 除以 3 即可得到 *r*。
- en: 'Finally, you need a way to express ![](images/nsp-venkitachalam503045-m01007.jpg).
    You know that ![](images/nsp-venkitachalam503045-m01007.jpg) is perpendicular
    to vector ![](images/nsp-venkitachalam503045-m01014.jpg), and you can express
    ![](images/nsp-venkitachalam503045-m01014.jpg) by subtracting point *A*’s coordinates
    from point *B*’s:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你需要一种方法来表示 ![](images/nsp-venkitachalam503045-m01007.jpg)。你知道 ![](images/nsp-venkitachalam503045-m01007.jpg)
    垂直于向量 ![](images/nsp-venkitachalam503045-m01014.jpg)，你可以通过将点 *A* 的坐标减去点 *B* 的坐标来表示
    ![](images/nsp-venkitachalam503045-m01014.jpg)：
- en: '![](images/nsp-venkitachalam503045-m01014.jpg) = (*x*[2] − *x*[1], *y*[2] −
    *y*[1])'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-m01014.jpg) = (*x*[2] − *x*[1], *y*[2] −
    *y*[1])'
- en: 'The magnitude of ![](images/nsp-venkitachalam503045-m01014.jpg) is given by
    *d* = ![](images/nsp-venkitachalam503045-m01015.jpg). You can now use the perpendicular
    vector trick to express ![](images/nsp-venkitachalam503045-m01007.jpg) in terms
    of *A* and *B*:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '![](images/nsp-venkitachalam503045-m01014.jpg) 的大小由 *d* = ![](images/nsp-venkitachalam503045-m01015.jpg)
    给出。现在你可以使用垂直向量技巧，将 ![](images/nsp-venkitachalam503045-m01007.jpg) 用 *A* 和 *B*
    来表示：'
- en: '![](images/nsp-venkitachalam503045-m01016.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-m01016.jpg)'
- en: 'Next you need to compute *P*[1] and *P*[3]. For this you’re going to use another
    result from linear algebra. Let’s say you have a line ![](images/nsp-venkitachalam503045-m01011.jpg)
    and a point *C* on the line. Let *a* be the distance of *C* from *A* and *b* be
    the distance of *C* from *B*. The point *C* is given by:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来你需要计算 *P*[1] 和 *P*[3]。为此，你将使用线性代数中的另一个结果。假设你有一条线 ![](images/nsp-venkitachalam503045-m01011.jpg)
    和这条线上的一点 *C*。设 *a* 为 *C* 到 *A* 的距离，*b* 为 *C* 到 *B* 的距离。点 *C* 可以表示为：
- en: '![](images/nsp-venkitachalam503045-m01017.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-m01017.jpg)'
- en: 'To understand this formula, think about what happens if *C* is the midpoint
    of *A* and *B*, meaning *a* and *b* would be the same. In this case, you can intuit
    that *C* ought to equal (*A* + *B*) / 2\. Substitute all the *b*s for *a*s in
    the previous equation. You’ll get:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这个公式，想象一下如果 *C* 是 *A* 和 *B* 的中点，也就是说 *a* 和 *b* 会相等。在这种情况下，你可以直观地认为 *C* 应该等于
    (*A* + *B*) / 2。将先前方程中的所有 *b* 替换为 *a*，你将得到：
- en: '![](images/nsp-venkitachalam503045-m01018.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-m01018.jpg)'
- en: 'With this new formula in mind, you can now compute *P*[1] and *P*[3]. These
    points divide line ![](images/nsp-venkitachalam503045-m01011.jpg) into thirds,
    meaning the distance from *P*[1] to *B* is twice the distance from *P*[1] to *A*
    (*b* = 2*a*), and the distance from *P*[3] to *A* is twice the distance from *P*[3]
    to *B* (*a* = 2*b*). Feeding this into the formula, you can therefore calculate
    the points as:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有了这个新公式，你可以计算 *P*[1] 和 *P*[3]。这些点将线 ![](images/nsp-venkitachalam503045-m01011.jpg)
    分成三等分，这意味着从 *P*[1] 到 *B* 的距离是从 *P*[1] 到 *A* 的两倍（*b* = 2*a*），而从 *P*[3] 到 *A* 的距离是从
    *P*[3] 到 *B* 的两倍（*a* = 2*b*）。将这个代入公式，你就可以计算出这些点：
- en: '![](images/nsp-venkitachalam503045-m01019.jpg) and ![](images/nsp-venkitachalam503045-m01020.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-m01019.jpg) 和 ![](images/nsp-venkitachalam503045-m01020.jpg)'
- en: Now you have everything you need to draw the first level of the snowflake fractal.
    Once you decide on *A* and *B*, you know how to compute the points *P*[1], *P*[2],
    and *P*[3]. But what happens at the second level of the fractal? You take each
    individual line segment from the flake at the first level ([Figure 1-2](nsp-venkitachalam503045-0012.xhtml#fig1-2))
    and replace it with a smaller flake. The result is shown in [Figure 1-3](nsp-venkitachalam503045-0012.xhtml#fig1-3).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经具备了绘制雪花分形第一层所需的一切。决定了 *A* 和 *B* 后，你就知道如何计算点 *P*[1]、*P*[2] 和 *P*[3]。但是分形的第二层会发生什么呢？你将第一层雪花中的每一条线段（[图
    1-2](nsp-venkitachalam503045-0012.xhtml#fig1-2)）替换为一小段雪花。结果如 [图 1-3](nsp-venkitachalam503045-0012.xhtml#fig1-3)
    所示。
- en: '![](images/nsp-venkitachalam503045-f01003.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f01003.jpg)'
- en: 'Figure 1-3: The second step of Koch snowflake construction'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-3：Koch 雪花构造的第二步
- en: Notice how each of the four line segments from [Figure 1-2](nsp-venkitachalam503045-0012.xhtml#fig1-2),
    ![](images/nsp-venkitachalam503045-m01021.jpg), ![](images/nsp-venkitachalam503045-m01022.jpg),
    ![](images/nsp-venkitachalam503045-m01023.jpg), and ![](images/nsp-venkitachalam503045-m01024.jpg),
    has become the basis for a new flake. In the Koch snowflake program, you’ll be
    able to use the endpoints of each line segment, for example, *A* and *P*[1], as
    new values for *A* and *B* and recursively perform the same calculations used
    to arrive at the points in [Figure 1-2](nsp-venkitachalam503045-0012.xhtml#fig1-2).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，[图1-2](nsp-venkitachalam503045-0012.xhtml#fig1-2)中每个四个线段的变化， ![](images/nsp-venkitachalam503045-m01021.jpg),
    ![](images/nsp-venkitachalam503045-m01022.jpg), ![](images/nsp-venkitachalam503045-m01023.jpg),
    和 ![](images/nsp-venkitachalam503045-m01024.jpg)，都成为了新雪花的基础。在科赫雪花程序中，你将能够使用每个线段的端点，例如，*A*和*P*[1]，作为新的*A*和*B*的值，并递归执行相同的计算，得到[图1-2](nsp-venkitachalam503045-0012.xhtml#fig1-2)中的各个点。
- en: At each level of the fractal, you’ll subdivide the snowflake again, drawing
    smaller and smaller self-similar figures. This is the *recursive step* of the
    algorithm, which you’ll repeat until you reach a *base case*. This should happen
    when ![](images/nsp-venkitachalam503045-m01011.jpg) is smaller than a certain
    threshold—say, 10 pixels. When you hit that threshold, just draw the line segments
    and stop recursing.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在分形的每一层，你将再次细分雪花，绘制越来越小的自相似图形。这是算法的*递归步骤*，你将重复该步骤，直到达到*基本情况*。当 ![](images/nsp-venkitachalam503045-m01011.jpg)
    小于某个阈值时——比如10像素——就应停止递归，直接绘制线段。
- en: To make the final output a bit fancy, you can draw three linked flakes as the
    first level of the fractal. This will give you the hexagonal symmetry of an actual
    snowflake. [Figure 1-4](nsp-venkitachalam503045-0012.xhtml#fig1-4) shows what
    the starting drawing will look like.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让最终的输出更加花哨，你可以绘制三个相连的雪花，作为分形的第一层。这将呈现出实际雪花的六角对称性。[图1-4](nsp-venkitachalam503045-0012.xhtml#fig1-4)展示了开始绘制时的效果。
- en: '![](images/nsp-venkitachalam503045-f01004.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f01004.jpg)'
- en: 'Figure 1-4: Combining three snowflakes'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-4：结合三个雪花
- en: Now that you know how to calculate the coordinates for making the snowflake,
    let’s see how to use those coordinates in Python to actually draw an image.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道了如何计算雪花的坐标，我们来看看如何在Python中使用这些坐标实际绘制图像。
- en: Drawing with turtle Graphics
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用turtle图形绘制
- en: In this chapter, you’ll use Python’s `turtle` module to draw the snowflake;
    it’s a simple drawing program modeled after the idea of a turtle dragging its
    tail through the sand, creating patterns. The `turtle` module includes methods
    you can use to set the position and color of the pen (the turtle’s tail) and many
    other useful functions for drawing.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将使用Python的`turtle`模块来绘制雪花；这是一个简单的绘图程序，模仿了乌龟用尾巴在沙子里拖动，创造图案的概念。`turtle`模块包括一些方法，你可以使用这些方法来设置画笔的位置和颜色（即乌龟的尾巴），还有许多其他用于绘图的有用函数。
- en: 'As you’ll see, all you need is a handful of graphics functions to draw the
    Koch snowflake. In fact, from the standpoint of `turtle`, drawing the snowflake
    is almost as easy as drawing a triangle. To prove it, and to give you a feel for
    how `turtle` works, the following program uses `turtle` to draw said triangle.
    Enter the code, save it as *test_turtle.py*, and run it in Python:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，绘制科赫雪花所需的仅仅是少数几个图形函数。实际上，从`turtle`的角度来看，绘制雪花几乎和绘制三角形一样简单。为了证明这一点，并让你感受`turtle`的工作方式，以下程序使用`turtle`绘制了一个三角形。输入代码，保存为*test_turtle.py*，并在Python中运行：
- en: '[PRE1]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You start by importing the `turtle` module ❶. Next, you define the `draw_triangle()`
    method, whose parameters are three pairs of x-coordinates and y-coordinates (the
    three corners of a triangle), as well as `t`, a `turtle` object. The method starts
    by calling `up()` ❷. This tells Python to move the pen up; in other words, take
    the pen off the virtual paper so that it won’t draw as you move the turtle. You
    want to position the turtle before you start drawing. The `setpos()` call ❸ sets
    the position of the turtle to the first pair of x- and y-coordinates. Calling
    `down()` ❹ sets the pen down, and for each of the subsequent `setpos()` calls,
    a line is drawn as the turtle moves to the next set of coordinates. The net result
    is a triangle drawing.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 首先导入 `turtle` 模块 ❶。接下来，定义 `draw_triangle()` 方法，方法的参数是三对 x 坐标和 y 坐标（三个三角形的角），以及
    `t`，一个 `turtle` 对象。该方法首先调用 `up()` ❷。这告诉 Python 将画笔抬起；换句话说，把画笔从虚拟纸面上提起来，以便在移动海龟时不会画出任何东西。在开始绘制之前，你需要定位海龟的位置。`setpos()`
    调用 ❸ 将海龟的位置设置为第一对 x 和 y 坐标。调用 `down()` ❹ 将画笔放下，在接下来的每次 `setpos()` 调用时，海龟移动到下一个坐标点，画出一条线。最终结果是绘制出一个三角形。
- en: Next you declare a `main()` function to actually do the drawing. In it, you
    create the `turtle` object for drawing ❺ and hide the turtle ❻. Without this command,
    you’d see a small shape representing the turtle at the front of the line being
    drawn. You then call `draw_triangle()` to draw the triangle ❼, passing in the
    desired coordinates as arguments. The call to `mainloop()` ❽ keeps the `tkinter`
    window open after the triangle has been drawn. (`tkinter` is Python’s default
    GUI library.)
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你声明一个 `main()` 函数来实际进行绘制。在该函数中，你创建了一个用于绘制的 `turtle` 对象 ❺，并隐藏了海龟 ❻。如果没有这个命令，你将看到一个小形状，表示海龟出现在正在绘制的线条前端。然后你调用
    `draw_triangle()` 来绘制三角形 ❼，并传入所需的坐标作为参数。调用 `mainloop()` ❽ 可以在三角形绘制完成后保持 `tkinter`
    窗口打开。（`tkinter` 是 Python 的默认图形界面库。）
- en: '[Figure 1-5](nsp-venkitachalam503045-0012.xhtml#fig1-5) shows the output of
    this simple program.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 1-5](nsp-venkitachalam503045-0012.xhtml#fig1-5) 显示了这个简单程序的输出。'
- en: '![](images/nsp-venkitachalam503045-f01005.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f01005.jpg)'
- en: 'Figure 1-5: The output of a simple `turtle` program'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-5：一个简单的 `turtle` 程序的输出
- en: You now have everything you need for the project. Let’s draw some flakes!
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你拥有了完成项目所需的一切。让我们开始绘制雪花吧！
- en: '[Requirements](nsp-venkitachalam503045-0008.xhtml#rah0302)'
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[需求](nsp-venkitachalam503045-0008.xhtml#rah0302)'
- en: In this project, you’ll use the Python `turtle` module to draw the snowflake.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将使用 Python 的 `turtle` 模块来绘制雪花。
- en: '[The Code](nsp-venkitachalam503045-0008.xhtml#rah0303)'
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[代码](nsp-venkitachalam503045-0008.xhtml#rah0303)'
- en: To draw the Koch snowflake, define a recursive function, `drawKochSF()`. This
    function computes *P*[1], *P*[2], and *P*[3] in terms of *A* and *B* from [Figure
    1-2](nsp-venkitachalam503045-0012.xhtml#fig1-2) and then recursively calls itself
    to perform the same calculation for smaller and smaller line segments until it
    reaches the smallest base case. Then it draws the flakes using `turtle`. For the
    full project code, skip ahead to [“The Complete Code”](nsp-venkitachalam503045-0012.xhtml#ah0307)
    on [page 16](nsp-venkitachalam503045-0012.xhtml#p16). The code is also available
    in the book’s GitHub repository at [https://github.com/mkvenkit/pp2e/blob/main/koch/koch.py](https://github.com/mkvenkit/pp2e/blob/main/koch/koch.py).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要绘制 Koch 雪花，定义一个递归函数 `drawKochSF()`。该函数根据 [图 1-2](nsp-venkitachalam503045-0012.xhtml#fig1-2)
    中的 *A* 和 *B* 计算 *P*[1]、*P*[2] 和 *P*[3]，然后递归调用自身，进行相同的计算，逐渐处理更小的线段，直到达到最小的基准情况。然后使用
    `turtle` 绘制雪花。有关完整的项目代码，请跳转到 [“完整代码”](nsp-venkitachalam503045-0012.xhtml#ah0307)，位于
    [第 16 页](nsp-venkitachalam503045-0012.xhtml#p16)。代码也可以在本书的 GitHub 仓库中找到，链接为 [https://github.com/mkvenkit/pp2e/blob/main/koch/koch.py](https://github.com/mkvenkit/pp2e/blob/main/koch/koch.py)。
- en: Calculating the Points
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计算各个点
- en: Begin the `drawKochSF()` function by calculating the coordinates for all the
    points needed to draw the basic flake pattern shown in [Figure 1-2](nsp-venkitachalam503045-0012.xhtml#fig1-2).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `drawKochSF()` 函数中，首先计算出绘制基本雪花图案所需的所有点的坐标，如 [图 1-2](nsp-venkitachalam503045-0012.xhtml#fig1-2)
    所示。
- en: '[PRE2]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You define `drawKochSF()`, passing in the x- and y-coordinates for the endpoints
    of a line segment ![](images/nsp-venkitachalam503045-m01011.jpg), which forms
    the basis for one of the sides of the snowflake, as shown in [Figure 1-4](nsp-venkitachalam503045-0012.xhtml#fig1-4).
    You also pass in the `turtle` object `t`, which you use for the actual drawing.
    Then you compute all the parameters shown in [Figure 1-2](nsp-venkitachalam503045-0012.xhtml#fig1-2),
    as discussed in the [“Computing the Snowflake”](nsp-venkitachalam503045-0012.xhtml#bh0302)
    section, starting with `d`, the distance from *A* to *B*. Dividing `d` by 3 gives
    you `r`, the length of each of the four line segments that makes up a flake. You
    use `r` to find `h`, the height of the “cone” at the heart of the flake.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你定义了`drawKochSF()`，并传入了线段![](images/nsp-venkitachalam503045-m01011.jpg)的x和y坐标，这构成了雪花的一个边，如[图1-4](nsp-venkitachalam503045-0012.xhtml#fig1-4)所示。你还传入了`turtle`对象`t`，它用于实际绘制。然后，你计算出[图1-2](nsp-venkitachalam503045-0012.xhtml#fig1-2)中显示的所有参数，如[“计算雪花”](nsp-venkitachalam503045-0012.xhtml#bh0302)部分中所述，从`d`开始，`d`是点*A*到*B*的距离。将`d`除以3得到`r`，这是构成雪花的一条边的长度。你使用`r`来计算`h`，雪花锥体的高度。
- en: You calculate the rest of the parameters as tuples containing an x- and a y-coordinate.
    The `p3` and `p1` tuples describe the two points at the base of the cone portion
    of the flake. Point `c` is the midpoint of `p1` and `p3`, and `n` is the unit
    vector perpendicular to line ![](images/nsp-venkitachalam503045-m01011.jpg). Along
    with `h`, they help you calculate `p2`, the apex of the flake’s cone.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你将其余的参数计算为包含x和y坐标的元组。`p3`和`p1`元组描述了雪花锥形部分底部的两个点。点`c`是`p1`和`p3`的中点，`n`是垂直于线段![](images/nsp-venkitachalam503045-m01011.jpg)的单位向量。连同`h`一起，它们帮助你计算雪花锥体的顶点`p2`。
- en: Recursing
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 递归
- en: The next part of the `drawKochSF()` function uses recursion to break down the
    first-level flake into smaller and smaller versions of itself.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`drawKochSF()`函数的下一部分使用递归将一级雪花分解为更小的版本。'
- en: '[PRE3]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: First you check for the recursion-stopping criteria ❶. If `d`, the length of
    segment ![](images/nsp-venkitachalam503045-m01011.jpg), is greater than 10 pixels,
    you continue the recursion. You do this by calling the `drawKochSF()` function
    again—four times! With each call, you pass in a different set of arguments corresponding
    to the coordinates for one of the four line segments that make up a flake, which
    you calculated at the start of the function. At ❷, for example, you call `drawKochSF()`
    for the segment ![](images/nsp-venkitachalam503045-m01021.jpg). The other function
    calls are for segments ![](images/nsp-venkitachalam503045-m01022.jpg), ![](images/nsp-venkitachalam503045-m01023.jpg),
    and ![](images/nsp-venkitachalam503045-m01024.jpg). Within each of these recursive
    calls, you’ll perform a new set of calculations based on the new values for points
    *A* and *B*, and if `d` is still greater than 10 pixels, you’ll make another four
    recursive calls to `drawKochSF()`, and so on.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 首先检查递归停止的条件❶。如果`d`，即线段的长度 ![](images/nsp-venkitachalam503045-m01011.jpg)，大于10像素，则继续递归。你通过再次调用`drawKochSF()`函数来实现这一点——四次！每次调用时，你会传入一组不同的参数，对应于构成雪花的四条线段的坐标，这些坐标是在函数开始时计算出来的。例如，在❷处，你会调用`drawKochSF()`来处理线段
    ![](images/nsp-venkitachalam503045-m01021.jpg)。其他的函数调用则对应于线段 ![](images/nsp-venkitachalam503045-m01022.jpg)，![](images/nsp-venkitachalam503045-m01023.jpg)
    和 ![](images/nsp-venkitachalam503045-m01024.jpg)。在这些递归调用中，你将基于新计算的点*A*和*B*的值，执行一组新的计算，如果`d`仍然大于10像素，你将继续进行四次递归调用`drawKochSF()`，以此类推。
- en: Drawing a Flake
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绘制雪花
- en: Now let’s look at what happens if segment ![](images/nsp-venkitachalam503045-m01011.jpg)
    is less than 10 pixels. This is the base case for the recursive algorithm. Since
    you’re below the threshold, you aren’t going to recurse. Instead, you actually
    draw the four line segments that make up a single flake pattern and return from
    the function. You use the `up()`, `down()`, and `setpos()` methods from the `turtle`
    module, which you learned about in the “Drawing with `turtle` Graphics” section.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一下如果线段 ![](images/nsp-venkitachalam503045-m01011.jpg) 小于10像素时会发生什么。这是递归算法的基本情况。由于你已低于阈值，因此不再进行递归。相反，你将绘制构成单个雪花图案的四条线段，并从函数中返回。你使用了`up()`、`down()`和`setpos()`方法，这些方法来自`turtle`模块，你在“使用`turtle`图形绘制”部分已经学习过。
- en: '[PRE4]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: First you draw the cone formed by points `p1`, `p2`, and `p3` ❶. Then you draw
    lines ![](images/nsp-venkitachalam503045-m01021.jpg) ❷ and ![](images/nsp-venkitachalam503045-m01024.jpg)
    ❸. Since you already performed all the required calculations at the start of the
    function, drawing is simply a matter of passing the appropriate coordinates to
    the `setpos()` method.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你绘制由点 `p1`、`p2` 和 `p3` 形成的圆锥形 ❶。然后你绘制线条 ![](images/nsp-venkitachalam503045-m01021.jpg)
    ❷ 和 ![](images/nsp-venkitachalam503045-m01024.jpg) ❸。由于你在函数开始时已经完成了所有必要的计算，绘制仅仅是将适当的坐标传递给
    `setpos()` 方法的问题。
- en: '[Writing the main() Function](nsp-venkitachalam503045-0008.xhtml#rbh0307)'
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[编写 main() 函数](nsp-venkitachalam503045-0008.xhtml#rbh0307)'
- en: The `main()` function sets up a `turtle` object and calls `drawKochSF()`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()` 函数设置了一个 `turtle` 对象，并调用 `drawKochSF()`。'
- en: '[PRE5]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In [Figure 1-4](nsp-venkitachalam503045-0012.xhtml#fig1-4), you saw how you
    were going to draw three of the snowflakes to get a hexagonally symmetric image
    as the final output. You do this by making three calls to `drawKochSF()`. The
    coordinates used for points *A* and *B* are `(-100, 0), (100, 0)` for the first
    snowflake ❶, `(0, -173.2), (-100, 0)` for the second ❷, and `(100, 0), (0, -173.2)`
    for the third ❸. Notice that these are the same coordinates you used earlier to
    draw a triangle in your *test_turtle.py* program. Try to work out the coordinates
    for yourself. (Hint: ![](images/nsp-venkitachalam503045-m01025.jpg).)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [图1-4](nsp-venkitachalam503045-0012.xhtml#fig1-4) 中，你看到你将如何绘制三个雪花，以获得六边形对称的最终输出。你通过三次调用
    `drawKochSF()` 来实现这一点。用于点 *A* 和 *B* 的坐标为：第一个雪花 ❶ 的坐标是 `(-100, 0), (100, 0)`，第二个雪花
    ❷ 的坐标是 `(0, -173.2), (-100, 0)`，第三个雪花 ❸ 的坐标是 `(100, 0), (0, -173.2)`。注意，这些坐标和你之前在
    *test_turtle.py* 程序中绘制三角形时使用的坐标是一样的。试着自己算出这些坐标。（提示： ![](images/nsp-venkitachalam503045-m01025.jpg)）。
- en: The `drawKochSF()` calls are enclosed in a Python `try` block to catch any exceptions
    that happen during drawing. For example, if you close the window while the drawing
    is still in process, an exception is thrown. You catch it in the `except` block
    ❹, where you print a message and exit the program. If you allow the drawing to
    complete, you’ll get to `turtle.Screen().exitonclick()` ❺, which will wait until
    you close the window by clicking anywhere inside it.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`drawKochSF()` 的调用被封装在一个 Python `try` 块中，以捕获绘图过程中发生的任何异常。例如，如果你在绘制过程中关闭窗口，就会抛出异常。你在
    `except` 块 ❹ 中捕获它，打印一条消息并退出程序。如果你允许绘制完成，你将进入 `turtle.Screen().exitonclick()` ❺，该方法会等待你通过点击窗口中的任何地方来关闭窗口。'
- en: '[Running the Snowflake Code](nsp-venkitachalam503045-0008.xhtml#rah0304)'
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[运行雪花代码](nsp-venkitachalam503045-0008.xhtml#rah0304)'
- en: Run the code in a terminal as follows. [Figure 1-6](nsp-venkitachalam503045-0012.xhtml#fig1-6)
    shows the output.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中运行代码，如下所示。[图1-6](nsp-venkitachalam503045-0012.xhtml#fig1-6)展示了输出结果。
- en: '[PRE6]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![](images/nsp-venkitachalam503045-f01006.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f01006.jpg)'
- en: 'Figure 1-6: The Koch snowflake output'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-6：科赫雪花输出
- en: There’s your beautiful snowflake!
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你美丽的雪花！
- en: '[Summary](nsp-venkitachalam503045-0008.xhtml#rah0305)'
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[总结](nsp-venkitachalam503045-0008.xhtml#rah0305)'
- en: In this chapter, you learned the basics of recursive functions and algorithms.
    You also learned how to draw simple graphics with Python’s `turtle` module. You
    put these concepts together to create a nice drawing of an interesting fractal
    called the Koch snowflake.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学习了递归函数和算法的基础知识。你还学习了如何使用 Python 的 `turtle` 模块绘制简单的图形。你将这些概念结合在一起，创造了一个有趣的分形图形——科赫雪花。
- en: '[Experiments!](nsp-venkitachalam503045-0008.xhtml#rah0306)'
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[实验！](nsp-venkitachalam503045-0008.xhtml#rah0306)'
- en: Now that you have completed one fractal drawing, let’s look at another interesting
    one called the *Sierpi*ń*ski triangle*, named after the Polish mathematician Wacław
    Sierpiński. [Figure 1-7](nsp-venkitachalam503045-0012.xhtml#fig1-7) shows what
    it looks like.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经完成了一个分形图形，我们来看看另一个有趣的图形，叫做 *Sierpi*ń*ski 三角形*，它以波兰数学家瓦茨瓦夫·谢尔平斯基（Wacław
    Sierpiński）命名。[图1-7](nsp-venkitachalam503045-0012.xhtml#fig1-7)展示了它的样子。
- en: '![](images/nsp-venkitachalam503045-f01007.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f01007.jpg)'
- en: 'Figure 1-7: The Sierpiński triangle'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-7：Sierpiński 三角形
- en: Try drawing the Sierpiński triangle with `turtle` graphics. You can use a recursive
    algorithm like you did to draw the Koch snowflake. If you look at [Figure 1-7](nsp-venkitachalam503045-0012.xhtml#fig1-7),
    you’ll see that the large triangle is divided into three smaller triangles, with
    an upside-down triangular hole in the middle. Each of the three smaller triangles
    is itself divided into another three triangles plus a hole in the middle, and
    so on. That gives you a hint on how to split up your recursion.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用`turtle`图形绘制谢尔宾斯基三角形。你可以使用递归算法，就像你绘制科赫雪花时那样。如果你查看[图1-7](nsp-venkitachalam503045-0012.xhtml#fig1-7)，你会看到大三角形被分成三个较小的三角形，中间有一个倒三角形的空洞。这三个较小的三角形每个又被分成三个三角形，且中间都有一个空洞，依此类推。这为你如何拆分递归提供了一个提示。
- en: (The solution to this problem is in the GitHub repository for the book [https://github.com/mkvenkit/pp2e/blob/main/koch/koch.py](https://github.com/mkvenkit/pp2e/blob/main/koch/koch.py))
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: （此问题的解决方案在GitHub上的书籍仓库中，链接为[https://github.com/mkvenkit/pp2e/blob/main/koch/koch.py](https://github.com/mkvenkit/pp2e/blob/main/koch/koch.py)）
- en: '[The Complete Code](nsp-venkitachalam503045-0008.xhtml#rah0307)'
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[完整代码](nsp-venkitachalam503045-0008.xhtml#rah0307)'
- en: 'Here’s the complete code listing for this project:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这是该项目的完整代码列表：
- en: '[PRE7]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
