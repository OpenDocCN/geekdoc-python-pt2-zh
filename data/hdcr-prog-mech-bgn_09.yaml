- en: '7'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '7'
- en: AFFINE TRANSFORMATIONS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 仿射变换
- en: '![Image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common01.jpg)'
- en: If I had to choose my favorite topic from this book, it would be affine transformations.
    There’s something oddly beautiful about affine transformations, as you’ll see
    for yourself in [Chapter 12](ch12.xhtml#ch12) when we animate them.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我必须从本书中选择我最喜欢的主题，那就是仿射变换。仿射变换有某种奇异的美感，正如你在[第12章](ch12.xhtml#ch12)中看到我们为其制作动画时所见。
- en: Affine transformations are crucial to 2D graphic applications; they determine
    how to pan, zoom, and rotate what you see on the screen. If you’ve used AutoCAD,
    you’re pretty much used to zooming in to a portion of the drawing, which is done
    with an affine transformation. Whenever you scale and rotate your pics in Instagram,
    an affine transformation does the trick. Mastering this topic is essential for
    writing any piece of software involving graphics, even more so for those where
    the user is allowed to interact with them.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 仿射变换对于二维图形应用至关重要；它们决定了如何在屏幕上平移、缩放和旋转所看到的内容。如果你使用过AutoCAD，你应该已经习惯了对图纸的某一部分进行缩放，这就是通过仿射变换实现的。每当你在Instagram上缩放和旋转图片时，也是通过仿射变换来完成的。掌握这一主题对于编写任何涉及图形的软件都是必不可少的，尤其是那些允许用户与图形互动的软件。
- en: The math behind affine transformations is quite simple, yet the concept is stunningly
    powerful. By the end of this chapter, you’ll have a class representing these transformations
    with methods to apply them to geometric primitives. We’ll also learn how to combine
    transformations to compute compound transformations and take a look at some useful
    transformations, such as one that zooms a drawing around a concrete point.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 仿射变换背后的数学原理非常简单，但其概念却异常强大。在本章结束时，你将拥有一个表示这些变换的类，并具备应用这些变换到几何原始图形的能力。我们还将学习如何组合变换以计算复合变换，并了解一些有用的变换，例如围绕某个具体点缩放图形的变换。
- en: '**Affine Transformations**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**仿射变换**'
- en: Since affine transformations apply to affine spaces, let’s first try to understand
    what an affine space is. You can think of an *affine space* as being a vector
    space where the origin point can be moved around. The linear transformations used
    in vector spaces preserve the position of the space’s origin, whereas in an affine
    space, as we stop caring about a fixed origin, translations are allowed.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 由于仿射变换应用于仿射空间，首先我们需要理解什么是仿射空间。你可以把*仿射空间*看作是一个向量空间，其中原点可以移动。在向量空间中使用的线性变换保持空间原点的位置，而在仿射空间中，由于我们不再关心固定的原点，平移是允许的。
- en: An *affine transformation*, then, is a mapping between two affine spaces that
    preserves points, straight lines, and planes. Points after an affine transformation
    stay as points, straight lines continue to be straight, and planes remain plane.
    One interesting property of these transformations is that parallelism between
    lines is preserved. We’ll see this in action in [Chapter 12](ch12.xhtml#ch12)
    when we animate affine transformations. In that exercise, we’ll see how the sides
    of polygons that were originally parallel remain parallel during the whole simulation.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，*仿射变换*是指两个仿射空间之间的一种映射，它保持点、直线和平面的不变。仿射变换后的点依然是点，直线仍然是直线，平面依然是平面。这些变换的一个有趣特性是，直线之间的平行性被保持。我们将在[第12章](ch12.xhtml#ch12)中通过动画展示仿射变换时看到这一点。在那个练习中，我们将看到原本平行的多边形的边在整个模拟过程中保持平行。
- en: Affine transformations are similar to *linear transformations*. The only difference
    is that the latter preserves the origin; that is, the point (0, 0) doesn’t move.
    Affine transformations can alter the position of the origin. [Figure 7-1](ch07.xhtml#ch7fig1)
    depicts both a linear transformation and an affine transformation.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 仿射变换类似于*线性变换*。唯一的区别是，后者保持原点不变；也就是说，点（0，0）不会移动。仿射变换则可以改变原点的位置。[图7-1](ch07.xhtml#ch7fig1)展示了线性变换和仿射变换。
- en: '![Image](../images/07fig01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig01.jpg)'
- en: '*Figure 7-1: Linear versus affine transformation*'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-1：线性变换与仿射变换*'
- en: Each pair of axes *x,y* in [Figure 7-1](ch07.xhtml#ch7fig1) shows how the space
    was before the transformation; each *x*^′, *y*^′ pair shows what the space looks
    like after the transformation. In the case of the linear transformation, the origin
    of coordinates *O* is preserved; the affine transformation, in addition to scaling
    and rotating the axes, translated the origin *O* to *O*^′.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 每一对坐标轴*x, y*在[图7-1](ch07.xhtml#ch7fig1)中显示了变换前空间的状态；每一对*x*^′, *y*^′则展示了变换后空间的状态。在线性变换的情况下，坐标原点*O*得以保留；而在仿射变换中，除了对坐标轴进行缩放和旋转外，还将原点*O*平移到了*O*^′。
- en: Given a point *P*, we can define an affine transformation using the expression
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个点*P*，我们可以使用以下表达式定义仿射变换
- en: '![Image](../images/f00172-p1.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f00172-p1.jpg)'
- en: where *M* is a linear transformation, ![Image](../images/tvictorit.jpg) is a
    translation vector, and *P*^′ is the resulting point after applying the transformation.
    An affine transformation is thus a linear transformation *M* plus a translation
    ![Image](../images/tvictorit.jpg). This expression can be written with all its
    terms as shown in [Equation 7.1](ch07.xhtml#ch07eqa01).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，*M*是一个线性变换，![Image](../images/tvictorit.jpg)是一个平移向量，而*P*^′是应用变换后的结果点。因此，仿射变换是线性变换*M*加上平移![Image](../images/tvictorit.jpg)。这个表达式可以按照[方程7.1](ch07.xhtml#ch07eqa01)所示写出所有项。
- en: '![Image](../images/07eqa01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07eqa01.jpg)'
- en: The linear transformation matrix *M* has the items
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 线性变换矩阵*M*包含以下项目
- en: '*s*[*x*]    Scale in the x direction'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*s*[*x*]    在x方向上的缩放'
- en: '*s*[*y*]    Scale in the y direction'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*s*[*y*]    在y方向上的缩放'
- en: '*sh*[*x*]    Shear in the x direction'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*sh*[*x*]    在x方向上的剪切变换'
- en: '*sh*[*y*]    Shear in the y direction'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*sh*[*y*]    在y方向上的剪切变换'
- en: and the translation ![Image](../images/tvictorit.jpg) has the terms
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 平移![Image](../images/tvictorit.jpg)的项为
- en: '*t*[*x*]    Translation in the x direction'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*t*[*x*]    在x方向上的平移'
- en: '*t*[*y*]    Translation in the y direction'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*t*[*y*]    在y方向上的平移'
- en: '[Equation 7.2](ch07.xhtml#ch07eqa02) shows an equivalent form using what is
    known as the *augmented matrix*.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '[方程7.2](ch07.xhtml#ch07eqa02)展示了使用所谓的*增广矩阵*的等效形式。'
- en: '![Image](../images/07eqa02.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07eqa02.jpg)'
- en: This version reduces the transformation to one matrix multiplication by extending
    the size of the input and output vectors, appending a 1, which serves as an auxiliary
    value and can be discarded once the transformation has taken place. It’s usually
    preferred as it requires only one step compared to the extra addition involved
    in the former. You can observe how in both cases, [Equations 7.1](ch07.xhtml#ch07eqa01)
    and [7.2](ch07.xhtml#ch07eqa02), the resulting coordinates are as shown in [Equation
    7.3](ch07.xhtml#ch07eqa03).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这种版本通过扩展输入和输出向量的大小，并附加一个1来简化变换为一次矩阵乘法，这个1作为辅助值，在变换完成后可以丢弃。与前一种方法相比，这通常更受偏爱，因为它只需要一步，而不需要额外的加法。你可以观察到，在[方程7.1](ch07.xhtml#ch07eqa01)和[7.2](ch07.xhtml#ch07eqa02)中，结果坐标如[方程7.3](ch07.xhtml#ch07eqa03)所示。
- en: '![Image](../images/07eqa03.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07eqa03.jpg)'
- en: Each of the values in the matrix from [Equation 7.2](ch07.xhtml#ch07eqa02) contributes
    differently in the transformation process. [Figure 7-2](ch07.xhtml#ch7fig2) showcases
    the transformation that each of the components produces. A generic affine transformation
    is therefore a combination of those unitary transformations.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 来自[方程7.2](ch07.xhtml#ch07eqa02)矩阵中的每个值，在变换过程中都有不同的贡献。[图7-2](ch07.xhtml#ch7fig2)展示了每个组件产生的变换效果。因此，通用的仿射变换是这些单位变换的组合。
- en: '![Image](../images/07fig02.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig02.jpg)'
- en: '*Figure 7-2: Components of affine transformations*'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-2：仿射变换的组件*'
- en: There is a special affine transformation that maps each point to itself, the
    *identity transformation*.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种特殊的仿射变换，它将每个点映射到自身，即*恒等变换*。
- en: '![Image](../images/f0174-01.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0174-01.jpg)'
- en: 'As you can observe, this is an identity matrix: whatever point you multiply
    this matrix by will stay the same.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这是一个恒等矩阵：无论将这个矩阵乘以哪个点，结果都将保持不变。
- en: '***Examples of Affine Transformations***'
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***仿射变换的例子***'
- en: Let’s look at a few examples of affine transformations in action. For this section,
    leave your computer aside and take out your pen and paper. If you can work through
    the operations to transform spaces using affine transformations by hand, coding
    them will be straightforward.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看几个仿射变换的实际例子。在本节中，请放下你的电脑，拿出笔和纸。如果你能手工完成使用仿射变换转换空间的运算，那么编码实现这些变换就会变得很简单。
- en: '**Example 1: Scaling**'
  id: totrans-37
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**例子1：缩放**'
- en: Given a point (2, 3), what point results after applying a horizontal scale of
    2 and a vertical scale of 5?
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个点 (2, 3)，在应用水平缩放 2 和垂直缩放 5 后，结果会是什么点？
- en: 'In this case, the terms in the affine transformation matrix are all zero except
    for *s*[*x*] = 2 and *s*[*y*] = 5\. Plugging these values into [Equation 7.2](ch07.xhtml#ch07eqa02),
    we get the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，仿射变换矩阵中的项除了*s*[*x*] = 2 和 *s*[*y*] = 5 之外，其他都是零。将这些值代入[方程 7.2](ch07.xhtml#ch07eqa02)，我们得到如下结果：
- en: '![Image](../images/f0174-02.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0174-02.jpg)'
- en: The resulting point is therefore (4, 15). [Figure 7-3](ch07.xhtml#ch7fig3) depicts
    this transformation’s effect on the point.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，结果点为 (4, 15)。[图 7-3](ch07.xhtml#ch7fig3)展示了此变换对点的影响。
- en: '![Image](../images/07fig03.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig03.jpg)'
- en: '*Figure 7-3: Example of a scale transformation*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-3：缩放变换的示例*'
- en: '**Example 2: Scaling and Translating**'
  id: totrans-44
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**示例 2：缩放和平移**'
- en: Given a point (2, 3), what point results after applying a horizontal scale of
    2, vertical scale of 5, and translation of ⟨10, 15⟩?
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个点 (2, 3)，在应用水平缩放 2、垂直缩放 5 和平移 ⟨10, 15⟩ 后，结果会是什么点？
- en: 'This case has the same values for the scale as the previous one, plus a displacement
    vector. Let’s plug those values into our affine transformation equation:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这个案例与前一个案例具有相同的缩放值，外加一个位移向量。我们将这些值代入仿射变换方程：
- en: '![Image](../images/f0175-01.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0175-01.jpg)'
- en: 'This time, the resulting point is (14, 30). We’ll take a look at this later,
    but it’s interesting to note how we could achieve the same effect with two sequential
    affine transformations, the first one scaling the point and the second one translating
    it:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，结果点为 (14, 30)。稍后我们将进一步探讨这一点，但值得注意的是，我们可以通过两个连续的仿射变换来实现相同的效果，第一个变换是缩放点，第二个变换是平移它：
- en: '![Image](../images/f0175-02.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0175-02.jpg)'
- en: 'Note that transformations are applied from right to left. In the previous case,
    the scaling goes first and then the translation. If you were to switch the order
    of transformations, the result would be different, which we can check by multiplying
    both transformation matrices in both directions and comparing the results. This
    yields our original matrix:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，变换是从右到左应用的。在前面的案例中，首先是缩放，然后是平移。如果交换变换的顺序，结果会不同，我们可以通过分别在两个方向上相乘变换矩阵并比较结果来验证这一点。这将得到我们的原始矩阵：
- en: '![Image](../images/f0175-03.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0175-03.jpg)'
- en: 'But switching the order yields:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，交换顺序后得到的是：
- en: '![Image](../images/f0175-04.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0175-04.jpg)'
- en: '[Figure 7-4](ch07.xhtml#ch7fig4) depicts the effect of applying the scale first
    and then the translation.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-4](ch07.xhtml#ch7fig4)展示了先应用缩放然后应用平移的效果。'
- en: '![Image](../images/07fig04.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig04.jpg)'
- en: '*Figure 7-4: A scale plus a translation*'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-4：缩放加平移*'
- en: '**Example 3: Vertical Reflection**'
  id: totrans-57
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**示例 3：垂直反射**'
- en: 'Reflections can be achieved by using affine transformations with negative scale
    values. To reflect a point (2, 3) in the vertical direction, use *s*[*y*] = –1:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 反射可以通过使用具有负缩放值的仿射变换来实现。要将点 (2, 3) 在垂直方向上进行反射，可以使用 *s*[*y*] = –1：
- en: '![Image](../images/f0176-01.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0176-01.jpg)'
- en: 'This yields the vertical reflection of the original point: (2,–3). [Figure
    7-5](ch07.xhtml#ch7fig5) represents this vertical reflection.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这会得到原始点的垂直反射：(2,–3)。[图 7-5](ch07.xhtml#ch7fig5)表示了这个垂直反射。
- en: '![Image](../images/07fig05.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig05.jpg)'
- en: '*Figure 7-5: An example of a vertical reflection*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：垂直反射的示例*'
- en: '**Example 4: Horizontal Shear**'
  id: totrans-63
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**示例 4：水平剪切**'
- en: What is the result of applying a horizontal shear of *sh*[*x*] = 2 to a rectangle
    with its lower-left point located at the origin, a width of 10 units, and a height
    of 5 units?
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 将水平剪切 *sh*[*x*] = 2 应用于一个矩形，矩形的左下角位于原点，宽度为 10 单位，高度为 5 单位，结果会怎样？
- en: 'This time we’ll have to apply the same transformation to all four vertices
    of the rectangle: (0, 0), (10, 0), (10, 5), and (0, 5). The affine transformation
    matrix is then as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们需要将相同的变换应用到矩形的四个顶点：(0, 0)、(10, 0)、(10, 5) 和 (0, 5)。仿射变换矩阵如下：
- en: '![Image](../images/f0176-02.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0176-02.jpg)'
- en: 'Using [Equation 7.2](ch07.xhtml#ch07eqa02) with this matrix to transform the
    vertices yields the following: (0, 0), (10, 0), (20, 5), and (10, 5). Draw the
    resulting rectangle. It should look something like [Figure 7-6](ch07.xhtml#ch7fig6).'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[方程 7.2](ch07.xhtml#ch07eqa02)并用这个矩阵来变换顶点，得到以下结果：(0, 0)、(10, 0)、(20, 5) 和
    (10, 5)。绘制出结果矩形，应该像[图 7-6](ch07.xhtml#ch7fig6)那样。
- en: '![Image](../images/07fig06.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig06.jpg)'
- en: '*Figure 7-6: An example of a shear*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：剪切变换示例*'
- en: '**The Affine Transformation Class**'
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**仿射变换类**'
- en: Without further ado, let’s create a new class to represent affine transformations.
    We want to use a class so that the transformation scale, translation, and shear
    values are part of its inner state and don’t need to be passed to every transformation
    method we use. If we used functions to transform geometric primitives instead,
    we’d need to pass all these values to every function, but that would be a lot
    of parameters.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 不再赘述，让我们创建一个新的类来表示仿射变换。我们希望使用类来管理变换的缩放、平移和剪切值，这些值将作为类的内部状态，而无需在每次调用变换方法时都传递这些参数。如果我们使用函数来变换几何图形，那我们就需要将这些值作为参数传递给每个函数，但这将需要大量的参数。
- en: In the *geom2d* package, create a new file named *affine_transf.py* and enter
    the code in [Listing 7-1](ch07.xhtml#ch7lis1).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *geom2d* 包中，创建一个名为 *affine_transf.py* 的新文件，并输入 [列表 7-1](ch07.xhtml#ch7lis1)
    中的代码。
- en: '[PRE0]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 7-1: The AffineTransform class*'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-1：AffineTransform 类*'
- en: The affine transformation stores values for the scales *s*[*x*] and *s*[*y*],
    the translations *t*[*x*] and *t*[*y*], and the shears *sh*[*x*] and *sh*[*y*].
    All values are given a default value of zero, except for the scales, which are
    initialized to one, in case they are omitted in the initializer. This is for convenience,
    as we’ll create many transformations where the shear or translation values are
    zero.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 仿射变换存储了缩放值 *s*[*x*] 和 *s*[*y*]、平移值 *t*[*x*] 和 *t*[*y*]，以及剪切值 *sh*[*x*] 和 *sh*[*y*]。所有值的默认值为零，除非缩放值，它们初始化为一，以防在初始化器中省略。这是为了方便，因为我们会创建许多变换，其中剪切或平移值为零。
- en: With these values at hand we can already implement a method to apply the transformation
    to a point with the help of [Equation 7.3](ch07.xhtml#ch07eqa03). Enter the code
    in [Listing 7-2](ch07.xhtml#ch7lis2).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些值，我们已经可以实现一个方法，借助 [公式 7.3](ch07.xhtml#ch07eqa03) 将变换应用于一个点。在 *geom2d* 包中输入
    [列表 7-2](ch07.xhtml#ch7lis2) 中的代码。
- en: '[PRE1]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 7-2: Applying an affine transformation to a point*'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-2：将仿射变换应用于一个点*'
- en: To apply the affine transformation to a point, we create a new Point where the
    projections are calculated using [Equation 7.3](ch07.xhtml#ch07eqa03). Let’s test
    this method using several different transformations.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要将仿射变换应用于一个点，我们创建一个新的 Point，其中投影值是根据 [公式 7.3](ch07.xhtml#ch07eqa03) 计算的。让我们使用几种不同的变换来测试此方法。
- en: '***Testing the Transformation of Points***'
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***测试点的变换***'
- en: Create a new file in the *geom2d* package named *affine_transf_test.py* and
    enter the code in [Listing 7-3](ch07.xhtml#ch7lis3).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *geom2d* 包中创建一个名为 *affine_transf_test.py* 的新文件，并输入 [列表 7-3](ch07.xhtml#ch7lis3)
    中的代码。
- en: '[PRE2]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 7-3: Testing the affine transformation application*'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-3：测试仿射变换应用*'
- en: 'The test file contains the TestAffineTransform class, inheriting from unittest.TestCase
    as usual. Inside the class we define a point that is used in all tests as well
    as all three affine transformations, namely:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 测试文件包含 TestAffineTransform 类，继承自 unittest.TestCase，和往常一样。在类内部，我们定义一个在所有测试中使用的点，以及三个仿射变换，即：
- en: scale    A scaling transformation
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: scale    缩放变换
- en: trans    A translation transformation
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: trans    平移变换
- en: shear    A shear transformation
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: shear    剪切变换
- en: 'Then we have our first test ensure the scale is correctly applied to the point
    ➊. The second test applies the translation to the point and asserts that the result
    is as expected ➋. The third does the same with the shear transformation ➌. Run
    the tests. You can do so from the shell:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有第一个测试，确保缩放正确应用于点 ➊。第二个测试应用平移于点，并断言结果符合预期 ➋。第三个测试对剪切变换做同样的操作 ➌。运行测试。你可以从
    shell 执行：
- en: '[PRE3]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This should produce the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生如下结果：
- en: '[PRE4]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Great! Now that we’re confident we’re correctly applying affine transformations
    to points, let’s extend the logic to other more complex primitives.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在我们确信仿射变换正确应用于点，我们来将逻辑扩展到其他更复杂的图形。
- en: '***Transform Segments and Polygons***'
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***变换线段和多边形***'
- en: We can harness the implementation for transforming Points to transform any shape
    as long as it’s defined using points or vectors. The next logical step is implementing
    the transformation of segments, so after the apply_to _point method, enter the
    method in [Listing 7-4](ch07.xhtml#ch7lis4).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用实现的点变换方法来变换任何形状，只要它是通过点或向量定义的。下一步是实现线段的变换，因此在 apply_to _point 方法之后，输入
    [列表 7-4](ch07.xhtml#ch7lis4) 中的方法。
- en: '[PRE5]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 7-4: Applying affine transformations to segments*'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-4：将仿射变换应用于线段*'
- en: That was easy, wasn’t it? To transform a segment, we simply create a new segment
    with both end points transformed using the previous method. We can apply a similar
    logic to polygons (in [Listing 7-5](ch07.xhtml#ch7lis5)).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单，不是吗？要变换一个线段，我们只需使用前面的方法将两个端点都进行变换，创建一个新的线段。我们可以将类似的逻辑应用于多边形（见[列表 7-5](ch07.xhtml#ch7lis5)）。
- en: '[PRE6]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 7-5: Applying affine transformations to polygons*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-5：将仿射变换应用于多边形*'
- en: 'In this case, we return a new polygon where all vertices have been transformed.
    What about rectangles and circles? The idea is similar, with a caveat: after scaling,
    shearing, and rotating these primitives, the results may no longer be rectangles
    or circles. This is why, in the previous chapter, we provided Rect and Circle
    with a method to_polygon that creates a generic polygon representation for the
    primitive. The code is therefore quite simple. Enter the code from [Listing 7-6](ch07.xhtml#ch7lis6):'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们返回一个新的多边形，其中所有的顶点都已经被变换。那矩形和圆形呢？思路类似，但有一个警告：在缩放、错切和旋转这些原始图形后，结果可能不再是矩形或圆形。这就是为什么在前一章中，我们为矩形和圆形提供了一个
    `to_polygon` 方法，用于为这些原始图形创建一个通用的多边形表示。代码因此非常简单。请从[列表 7-6](ch07.xhtml#ch7lis6)输入代码：
- en: '[PRE7]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 7-6: Applying affine transformations to rectangles and circles*'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-6：将仿射变换应用于矩形和圆形*'
- en: The procedure consists of obtaining the polygon representation of the rectangle
    or circle and delegating the rest of the process to apply_to_polygon. In the case
    of circles, the number of divisions must be chosen, which is given a value of
    30 by default. Both methods return a Polygon instance, even if the affine transformation
    being applied is the identity, which wouldn’t transform the geometries at all.
    Once a rectangle or a circle goes through an affine transformation, it turns into
    a generic polygon, no matter what transformation.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程包括获取矩形或圆形的多边形表示，并将其余过程委托给 `apply_to_polygon`。对于圆形，需要选择分割数，默认值为 30。即使应用的仿射变换是恒等变换（不会改变几何形状），这两个方法也会返回一个
    `Polygon` 实例。一旦矩形或圆形经过仿射变换，它就会变成一个通用的多边形，无论是什么变换。
- en: We won’t do so here for space reasons, but feel free to add unit tests for these
    three new methods.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 由于空间原因，我们在这里不会这么做，但你可以随时为这三个新方法添加单元测试。
- en: '***Concatenating Transformations***'
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***连接变换***'
- en: One interesting property of affine transformations is that any complex transformation
    can be expressed as a sequence of simpler transformations. In fact, when you work
    with a 2D graphics application such as Sketch or Photoshop, every zoom or pan
    on the canvas is a combination, or concatenation, of a new affine transformation
    with the current one, which defines the projection of what you see on your screen
    at that particular moment.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 仿射变换的一个有趣性质是，任何复杂的变换都可以表示为一系列简单变换的组合。事实上，当你使用像 Sketch 或 Photoshop 这样的 2D 图形应用程序时，每一次画布的缩放或平移，都是当前变换与新的仿射变换的组合或连接，这决定了你在特定时刻在屏幕上看到的投影。
- en: 'Given two affine transformations [*T*[1]] and [*T*[2]] and input point *P*,
    the result of applying [*T*[1]] to the point is as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 给定两个仿射变换 [*T*[1]] 和 [*T*[2]] 以及输入点 *P*，将 [*T*[1]] 应用到该点的结果如下：
- en: '*P′* = [*T*[1]]*P*'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*P′* = [*T*[1]]*P*'
- en: 'Then, applying the second transformation [*T*[2]] to the previous result, we
    get this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将第二个变换 [*T*[2]] 应用到先前的结果，我们得到：
- en: '*P*^″ = [*T*[2]]*P*^′'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*P*^″ = [*T*[2]]*P*^′'
- en: If we substitute *P*^′ from the first expression into the second, we obtain
    the result of applying both transformations to input point *P* ([Equation 7.4](ch07.xhtml#ch07eqa04)),
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将第一个表达式中的 *P*^′ 代入第二个表达式，就得到应用这两次变换到输入点 *P* 的结果（[方程 7.4](ch07.xhtml#ch07eqa04)），
- en: '![Image](../images/07eqa04.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07eqa04.jpg)'
- en: where [*T*[*r*]] is the affine transformation equivalent to applying [*T*[1]]
    first and [*T*[2]] second. Notice how the order of the original transformations
    appears in reverse if you read from left to right?
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，[*T*[*r*]] 是等同于先应用[*T*[1]]再应用[*T*[2]]的仿射变换。注意，如果从左到右阅读，原始变换的顺序是如何反过来的？
- en: '[*T*[r]] = [*T*[2]][*T*[1]]'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[*T*[r]] = [*T*[2]][*T*[1]]'
- en: In the previous equation, reading from left to right [*T*[2]] appears first,
    but the effect of applying [*T*[*r*]] is equivalent to applying [*T*[1]] first
    and [*T*[2]] second. We need to be careful with the order, as matrix multiplication
    is noncommutative. If we swap the order of the operands, we obtain a different
    transformation, which was already proved in a previous exercise. The resulting
    transformation is then expressed mathematically as the product of matrices (see
    [Equation 7.5](ch07.xhtml#ch07eqa05)).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的公式中，从左到右[*T*[2]]首先出现，但应用[*T*[*r*]]的效果相当于先应用[*T*[1]]，再应用[*T*[2]]。我们需要小心顺序，因为矩阵乘法是不交换的。如果我们交换操作数的顺序，我们将得到一个不同的变换，这在之前的一个练习中已经证明过了。结果变换随后用矩阵的乘积表示（参见[方程
    7.5](ch07.xhtml#ch07eqa05)）。
- en: '![Image](../images/07eqa05.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07eqa05.jpg)'
- en: Let’s provide the AffineTransform class with a method to concatenate affine
    transformations using [Equation 7.5](ch07.xhtml#ch07eqa05). We’ll call the method
    then(), receiving parameters self and other. The first argument, self, is transformation
    [*T*[1]], and other is [*T*[2]]. Inside *affine_transf.py*, toward the end of
    the class, enter the code in [Listing 7-7](ch07.xhtml#ch7lis7).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为AffineTransform类提供一个方法，用[方程 7.5](ch07.xhtml#ch07eqa05)来串联仿射变换。我们将这个方法命名为then()，接受参数self和other。第一个参数self是变换[*T*[1]]，而other是[*T*[2]]。在*affine_transf.py*中，类的末尾输入[列表
    7-7](ch07.xhtml#ch7lis7)中的代码。
- en: '[PRE8]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 7-7: Method to concatenate transformations*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-7：串联变换的方法*'
- en: The name then is chosen so that it’s absolutely clear that self is applied before
    other (the method’s argument).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然后选择这个名称是为了确保完全清楚地表明self在other之前应用（即方法的参数）。
- en: Since this is such an important method, we’ll want it covered by unit tests;
    that means we need a way of knowing whether two given affine transformations are
    equal. Let’s implement the special __eq__ method in AffineTransform ([Listing
    7-8](ch07.xhtml#ch7lis8)).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个非常重要的方法，我们希望它能通过单元测试覆盖；这意味着我们需要一种方法来判断两个给定的仿射变换是否相等。让我们在AffineTransform中实现特殊的__eq__方法（参见[列表
    7-8](ch07.xhtml#ch7lis8)）。
- en: '[PRE9]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 7-8: Checking affine transformation equality*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-8：检查仿射变换相等性*'
- en: '**Testing the Concatenation of Transformations**'
  id: totrans-124
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**测试变换的串联**'
- en: Let’s now enter two new tests in *affine_transf_test.py*; both are listed in
    [Listing 7-9](ch07.xhtml#ch7lis9).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在*affine_transf_test.py*中输入两个新测试；它们都列在[列表 7-9](ch07.xhtml#ch7lis9)中。
- en: '[PRE10]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 7-9: Testing affine transformation concatenation*'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-9：测试仿射变换串联*'
- en: As you’ve probably realized, these two tests are repeating the operations we
    did by hand in one of the exercises at the beginning of the chapter. Run them
    to make sure you have the implementation of then right.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经意识到的，这两个测试重复了我们在本章开头的某个练习中手动进行的操作。运行它们，以确保你正确实现了这些操作。
- en: '[PRE11]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: There is a lot of adding and multiplying between self and other, so it’s easy
    to get the code wrong. If the tests aren’t passing, well, that means they’re doing
    their work by pointing out that something in the code is not right. Go back to
    your implementation and make sure you have everything right line by line.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 由于self和other之间有很多加法和乘法运算，很容易把代码写错。如果测试未通过，那就意味着它们通过指出代码中的问题来完成它们的工作。返回你的实现并逐行确保你一切都做对了。
- en: '***Inverting Affine Transformations***'
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***反转仿射变换***'
- en: To undo a transformation or apply the inverse of a known transformation [*T*],
    we want to be able to compute a transformation [*T*[*I*]] such that
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了撤销一个变换或应用已知变换[*T*]的逆，我们希望能够计算一个变换[*T*[*I*]]，使得
- en: '[*T*][*T*[I]] = [*T*[I]][*T*] = [*I*]'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '[*T*][*T*[I]] = [*T*[I]][*T*] = [*I*]'
- en: 'where [*I*] is the identity matrix of size 3:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 其中[*I*]是3x3的单位矩阵：
- en: '![Image](../images/f00184-p1.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f00184-p1.jpg)'
- en: 'An interesting property of these pairs of transformations [*T*] and [*T*[*I*]]
    is that they cancel each other out. For example, here is the result of applying
    the transformations one after the other (in whichever order) to a point *P*:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变换对[*T*]和[*T*[*I*]]的一个有趣属性是它们相互抵消。例如，以下是将这些变换按顺序（无论顺序如何）作用于一个点*P*的结果：
- en: '[*T*[I]]([*T*]*P*) = ([*T*[I]][*T*])*P* = [*I*]*P* = *P*'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '[*T*[I]]([*T*]*P*) = ([*T*[I]][*T*])*P* = [*I*]*P* = *P*'
- en: Another reason the inverse affine transformation is interesting is that it maps
    a point on the screen back to our “model space,” that is, the affine space where
    our model is defined. The direct transformation is used to compute how the geometry
    is projected onto the screen, that is, where each point of the model needs to
    be drawn—but what about the other way around? Knowing where a given point on the
    screen lies in the model requires the inverse transformation, the one that transforms
    the “screen space” into the model space. This is useful, for example, when trying
    to figure out whether the user’s mouse pointer on the screen maps to something
    in the model that could potentially be selected.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 逆仿射变换之所以有趣的另一个原因是，它将屏幕上的点映射回我们的“模型空间”，即定义我们模型的仿射空间。直接变换用于计算几何图形如何投影到屏幕上，也就是说，模型中的每个点应该绘制到哪里——但反过来呢？要知道屏幕上某个给定点在模型中的位置，需要逆变换，即将“屏幕空间”转换为模型空间的变换。这在某些情况下很有用，例如当试图弄清楚屏幕上用户的鼠标指针是否映射到模型中的某个可选项时。
- en: 'Take a look at [Figure 7-7](ch07.xhtml#ch7fig7). There’s our model space with
    just a triangle defined in it. To draw the model to the user’s screen, we have
    to apply an affine transformation that projects every point from model space to
    screen space. Now imagine the user has the mouse at point *P*^′ on the screen,
    and we want to know whether that point lies inside our triangle. Since the triangle
    is a geometry defined in the model space, we want to apply that point in the screen
    the inverse transformation: that which transforms screen space into model space.
    Recall that, to project our model geometry into the screen, we applied the direct
    affine transformation, so to map that geometry back into its original model space,
    the inverse of that transformation needs to be applied. With the point mapped
    to our model space (*P*), we can do the calculations to determine whether *P*
    is inside the triangle.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下[图 7-7](ch07.xhtml#ch7fig7)。这是我们的模型空间，其中只定义了一个三角形。为了将模型绘制到用户的屏幕上，我们必须应用一个仿射变换，将模型空间中的每个点投影到屏幕空间。现在，假设用户的鼠标位于屏幕上的*P*^′点，我们想知道该点是否位于我们的三角形内部。由于三角形是定义在模型空间中的几何图形，我们希望对屏幕上的该点应用逆变换：即将屏幕空间转换回模型空间的变换。回想一下，为了将我们的模型几何图形投影到屏幕上，我们应用了直接的仿射变换，因此要将几何图形映射回原始的模型空间，需要应用该变换的逆变换。通过将该点映射到我们的模型空间(*P*)，我们可以进行计算，以确定*P*是否在三角形内部。
- en: '![Image](../images/07fig07.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/07fig07.jpg)'
- en: '*Figure 7-7: Model and screen spaces*'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：模型和屏幕空间*'
- en: You can try to compute the inverse affine transformation matrix by yourself,
    which is a great exercise, but inverting matrices by hand is a tedious task, so
    [Equation 7.6](ch07.xhtml#ch07eqa06) shows the result.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以尝试自己计算逆仿射变换矩阵，这是一个很好的练习，但手动求逆矩阵是一个繁琐的任务，因此[方程 7.6](ch07.xhtml#ch07eqa06)展示了结果。
- en: '![Image](../images/07eqa06.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/07eqa06.jpg)'
- en: Using the transformation from [Equation 7.6](ch07.xhtml#ch07eqa06), computing
    the inverse requires only a few lines of code. In AffineTransform and after then,
    enter the code in [Listing 7-10](ch07.xhtml#ch7lis10).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[方程 7.6](ch07.xhtml#ch07eqa06)中的变换，计算逆变换只需要几行代码。在AffineTransform类中，之后输入[清单
    7-10](ch07.xhtml#ch7lis10)中的代码。
- en: '[PRE12]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 7-10: Inverse affine transformation*'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-10：逆仿射变换*'
- en: Let’s also add a test to make sure the inverse is properly computed. In *affine_transf_test.py*,
    add a new method to class TestAffineTransform with the test in [Listing 7-11](ch07.xhtml#ch7lis11).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再添加一个测试，确保逆变换能够正确计算。在*affine_transf_test.py*中，向TestAffineTransform类中添加一个新方法，测试内容参见[清单
    7-11](ch07.xhtml#ch7lis11)。
- en: '[PRE13]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 7-11: Testing the inverse affine transformation*'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-11：测试逆仿射变换*'
- en: In this test, we create a new affine transformation, transf, with all values
    set to nonzero values. Then we store the transformation result of concatenating
    transf and its inverse in actual, which, if you recall, should be the identity
    matrix if the inverse is properly constructed. Lastly, we compare the obtained
    result with the actual identity matrix. Run all tests in the file to make sure
    they succeed.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，我们创建了一个新的仿射变换transf，并将所有值设置为非零值。然后，我们将连接transf及其逆变换的结果存储在实际结果中，如果你记得的话，如果逆变换正确构造，结果应该是单位矩阵。最后，我们将得到的结果与实际的单位矩阵进行比较。运行文件中的所有测试，确保它们都能成功通过。
- en: '[PRE14]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let’s try an example. We’ll apply a translation to a point and then apply the
    inverse translation to the resulting point, which should yield the original point.
    In the Python shell, write the following:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试一个例子。我们将对一个点应用平移，然后对得到的点应用反向平移，最终应该得到原始点。在Python shell中，写下以下代码：
- en: '[PRE15]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We know if we apply the ⟨10, 20⟩ translation to point (5, 7), the resulting
    point should be (15, 27). Let’s test it.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，如果我们将⟨10, 20⟩的平移应用到点（5, 7），则得到的点应该是（15, 27）。让我们来验证一下。
- en: '[PRE16]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Using the str function, we get the string representation of translated, the
    point after applying the translation. Let’s now apply the inverse translation
    transformation to that point.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用str函数，我们可以获得平移后的点的字符串表示。现在，让我们对这个点应用反向平移变换。
- en: '[PRE17]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Applying the inverse transformation to the translated point yields the original
    point, as expected.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 对平移后的点应用反向变换，得到原始点，正如预期的那样。
- en: '***Scaling***'
  id: totrans-159
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***缩放***'
- en: 'Whenever you zoom in or out using a graphics application such as AutoCAD or
    Illustrator, a scaling affine transformation is applied to the geometric model
    so that it’s drawn on your screen with a different size than the real one. Architects
    draw blueprints for buildings hundreds of meters tall that need to fit inside
    a laptop screen a few inches wide. Inside the computer’s memory lives the geometric
    model with the real dimensions, but to draw it to the screen, a scale is applied:
    a scaling affine transformation.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你使用AutoCAD或Illustrator等图形应用程序进行缩放时，都会对几何模型应用一个缩放仿射变换，使得模型在屏幕上显示的大小与真实大小不同。建筑师绘制的建筑蓝图可能有几百米高，而这些蓝图需要适应几英寸宽的笔记本电脑屏幕。在计算机的内存中存储着具有真实尺寸的几何模型，但为了在屏幕上绘制它，需要应用一个缩放：一个缩放仿射变换。
- en: To get a visual intuition of what happens in this kind of affine transformation,
    let’s look at [Figure 7-8](ch07.xhtml#ch7fig8). Given a point *P*, let’s imagine
    a vector ![Image](../images/vvictorit.jpg) starting at the origin and with its
    tip on *P*. Applying scales *S*[*x*] and *S*[*y*] to point *P* transforms it into
    a point *P*^′ whose vector ![Image](../images/vivictorit.jpg) horizontal projection
    is *S*[*x*] ⋅ *v*[*x*] and vertical projection is *S*[*y*] ⋅ *v*[*y*]. As you
    see, a scale is a measure of how far or close points get to the origin with respect
    to their original distance to it. The origin, in fact, doesn’t move with pure
    scaling transformations. Scales with absolute value smaller than the unit pull
    points closer to the origin, whereas scales greater than one push points away
    from it.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得这种仿射变换的视觉直觉，让我们看一下[图 7-8](ch07.xhtml#ch7fig8)。给定一个点*P*，我们可以想象有一个从原点出发的向量![Image](../images/vvictorit.jpg)，其尖端在*P*上。对点*P*应用缩放*S*[*x*]和*S*[*y*]，将其转换为点*P*^′，其向量![Image](../images/vivictorit.jpg)的水平投影为*S*[*x*]
    ⋅ *v*[*x*]，垂直投影为*S*[*y*] ⋅ *v*[*y*]。正如你所看到的，缩放是衡量点相对于其原始距离与原点之间的远近。事实上，纯粹的缩放变换并不会移动原点。绝对值小于1的缩放会将点拉近原点，而大于1的缩放则会把点推远原点。
- en: '![Image](../images/07fig08.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig08.jpg)'
- en: '*Figure 7-8: A scale affine transformation*'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-8：一个尺度仿射变换*'
- en: This is useful, but often we want to apply a scale with respect to a point other
    than the origin. Imagine, for example, working with AutoCAD and wanting to zoom
    in to the drawing. If instead of zooming in around the center of your screen or
    mouse position it zoomed with respect to the origin (assuming it’s located in
    the lower-left corner of the app’s window), you’d feel like the drawing moved
    away, as depicted in the left diagram of [Figure 7-9](ch07.xhtml#ch7fig9).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这是有用的，但通常我们希望相对于原点以外的某个点应用缩放。例如，假设你正在使用AutoCAD并想放大图纸。如果缩放是相对于原点（假设它位于应用窗口的左下角）而不是围绕屏幕的中心或鼠标位置进行的，那么你会觉得图纸被移远了，如[图
    7-9](ch07.xhtml#ch7fig9)左图所示。
- en: '![Image](../images/07fig09.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig09.jpg)'
- en: '*Figure 7-9: Zooming in around the origin (left) and around the center of the
    screen (right)*'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-9：围绕原点缩放（左）与围绕屏幕中心缩放（右）*'
- en: You’re probably much more used to a zoom in function that scales the drawing
    around a point somewhere in the middle of your screen, or even the position of
    your mouse as it actually happens most of the time. Many graphic design programs
    work like this, and it makes things more convenient for the user, but the way
    we defined a pure scaling transformation, it can only happen with respect to the
    origin. So, how is this scaling around an arbitrary point achieved? Well, now
    that we know about constructing compound transformations, obtaining this transformation
    is actually a piece of cake.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能更习惯使用一个在屏幕中间某个点或甚至鼠标位置周围缩放绘图的功能，这种功能实际上在大多数情况下都会发生。许多图形设计程序都像这样工作，这样对用户来说更方便，但按照我们定义的纯缩放变换，它只能相对于原点发生。那么，如何在任意点周围进行缩放呢？好吧，现在我们知道了如何构造复合变换，实际上，获得这个变换就是轻而易举的事了。
- en: '**NOTE**'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*It took me quite some time to fully understand how to use affine transformations
    effectively and how to create compound transformations out of simpler ones. I
    had a really hard time trying to implement a proper “zoom in” option in my software
    InkStructure, and that’s why the original versions felt a bit buggy when trying
    to zoom in to the drawing and not have it randomly move around the screen. So
    when I say “a piece of cake,” I should probably qualify: it becomes easy only
    once you understand affine transformations.*'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*我花了相当长的时间才完全理解如何有效地使用仿射变换，以及如何从简单的变换中创建复合变换。我在尝试在我的软件 InkStructure 中实现一个正确的“放大”选项时遇到了很大的困难，这也是为什么原始版本在尝试放大绘图时感觉有些
    bug，当时图形会随机移动到屏幕的其他位置。所以，当我说“轻而易举”时，我应该加上一些说明：只有在理解了仿射变换之后，它才变得简单。*'
- en: 'Let’s quickly state the problem we want to solve: we want to find an affine
    transformation that applies scales *S*[*x*] and *S*[*y*] with respect to a center
    point *C*. Defining *O* as the origin of the coordinate system, we can build such
    a transformation by combining the following simpler transformations:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速说明我们想解决的问题：我们想找到一个仿射变换，它相对于中心点 *C* 应用缩放 *S*[*x*] 和 *S*[*y*]。定义 *O* 为坐标系的原点，我们可以通过组合以下更简单的变换来构建这样的变换：
- en: '[*T*[1]]: Translate so that *C* coincides with the origin *O* (![Image](../images/tvictorit.jpg)
    = ![Image](../images/coline.jpg) = ⟨–*C*[x], –*C*[y]⟩).'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[*T*[1]]: 移动 *C* 使其与原点 *O* 重合 (![Image](../images/tvictorit.jpg) = ![Image](../images/coline.jpg)
    = ⟨–*C*[x], –*C*[y]⟩)。'
- en: '[*T*[2]]: Scale with factors *S*[*x*] and *S*[*y*].'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[*T*[2]]: 使用缩放因子 *S*[*x*] 和 *S*[*y*] 进行缩放。'
- en: '[*T*[3]]: Translate *C* back to where it was (![Image](../images/tivictor.jpg)
    = ![Image](../images/ocline.jpg) = ⟨*C*[x], *C*[y]⟩).'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[*T*[3]]: 将 *C* 移动回原来的位置 (![Image](../images/tivictor.jpg) = ![Image](../images/ocline.jpg)
    = ⟨*C*[x], *C*[y]⟩)。'
- en: Since scales can be applied only with respect to the origin, we move the whole
    space so that our point *C* lies exactly on the origin, and then we apply the
    scale and translate things back to where they were initially. Beautiful, isn’t
    it? Thus, [*T*[*r*]] can be computed as shown in [Equation 7.7](ch07.xhtml#ch07eqa07).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 由于缩放只能相对于原点应用，我们将整个空间移动，使得我们的点 *C* 恰好位于原点，然后应用缩放并将其移动回原来的位置。漂亮吧？因此，[*T*[*r*]]
    可以通过[方程 7.7](ch07.xhtml#ch07eqa07)计算得出。
- en: '![Image](../images/07eqa07.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07eqa07.jpg)'
- en: Let’s create a factory function to generate these kinds of transformations.
    Start by creating a new file named *affine_transforms.py*; in it, enter the function
    in [Listing 7-12](ch07.xhtml#ch7lis12).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个工厂函数来生成这些类型的变换。首先，创建一个名为 *affine_transforms.py* 的新文件；在其中输入[列表 7-12](ch07.xhtml#ch7lis12)中的函数。
- en: '[PRE18]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 7-12: Creating a scale transformation*'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-12：创建一个缩放变换*'
- en: It is a good idea to add a few test cases checking the behavior of this function.
    For brevity, I’ll leave that as an exercise for you.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 最好添加一些测试用例，检查该函数的行为。为了简洁起见，我会把这个留给你作为练习。
- en: '***Rotating***'
  id: totrans-180
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***旋转***'
- en: Similar to scales, rotations always take place around the origin. Just like
    before, by using a clever sequence of transformations, we can produce a rotation
    around any point we want. You may have rotated a drawing in Sketch, Illustrator,
    or a similar application, in which case you’re used to choosing the *rotation
    pivot*, a point around which you then rotate using the square handles, something
    similar to [Figure 7-10](ch07.xhtml#ch7fig10).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于缩放，旋转总是围绕原点进行。就像之前一样，通过使用巧妙的变换序列，我们可以围绕任何我们想要的点进行旋转。你可能在 Sketch、Illustrator
    或类似应用程序中旋转过图形，在这种情况下，你已经习惯选择*旋转中心*，一个围绕它旋转的点，你可以使用方框控制柄，类似于[图 7-10](ch07.xhtml#ch7fig10)。
- en: '![Image](../images/07fig10.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig10.jpg)'
- en: '*Figure 7-10: Rotation around the center*'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-10：围绕中心的旋转*'
- en: The pivot point can be moved so the rotation happens around a different point.
    For example, moving it near the bottom-left corner of the bounding box, the rotation
    may look like [Figure 7-11](ch07.xhtml#ch7fig11).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转中心点可以移动，从而使旋转围绕不同的点进行。例如，将旋转中心移到边界框的左下角，旋转可能会像[图 7-11](ch07.xhtml#ch7fig11)那样。
- en: '![Image](../images/07fig11.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/07fig11.jpg)'
- en: '*Figure 7-11: Rotation around a corner*'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-11：围绕角落的旋转*'
- en: Let’s start by learning how to construct a rotation affine transformation around
    the origin; this will serve as the basis for constructing a more complex rotation
    around any point. [Equation 7.8](ch07.xhtml#ch07eqa08) shows how to rotate points
    *θ* radians around the origin.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从学习如何围绕原点构建旋转仿射变换开始；这将作为构建围绕任何点旋转的更复杂变换的基础。[方程 7.8](ch07.xhtml#ch07eqa08)展示了如何围绕原点旋转点
    *θ* 弧度。
- en: '![Image](../images/07eqa08.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/07eqa08.jpg)'
- en: 'With this in mind, let’s find an affine transformation that rotates points
    *θ* radians around a center point *C*. With *O* as the origin of the coordinate
    system, the transformation is the combination of the following:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 记住这一点后，让我们找到一个仿射变换，使得点围绕中心点 *C* 旋转 *θ* 弧度。以 *O* 作为坐标系的原点，变换是以下内容的组合：
- en: '[*T*[1]]: Translate *C* to the origin *O* so the rotation center is *C* (![Image](../images/tvictorit.jpg)
    = ![Image](../images/coline.jpg) = ⟨–*C*[x], –*C*[y]⟩).'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[*T*[1]]：将 *C* 平移到原点 *O*，使得旋转中心为 *C* (![图片](../images/tvictorit.jpg) = ![图片](../images/coline.jpg)
    = ⟨–*C*[x], –*C*[y]⟩)。'
- en: '[*T*[2]]: Rotate *θ* radians.'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[*T*[2]]：旋转 *θ* 弧度。'
- en: '[*T*[3]]: Translate *C* back to where it was (![Image](../images/tivictor.jpg)
    = ![Image](../images/ocline.jpg) = ⟨*C*[x], *C*[y]⟩).'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[*T*[3]]：将 *C* 平移回它原来的位置 (![图片](../images/tivictor.jpg) = ![图片](../images/ocline.jpg)
    = ⟨*C*[x], *C*[y]⟩)。'
- en: 'It’s the same algorithm as before, but this time we’ll use a rotation instead
    of a scale. [*T*[*r*]] is now computed as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这与之前的算法相同，但这次我们使用旋转而不是缩放。[*T*[*r*]]现在的计算方式如下：
- en: '![Image](../images/f0190-01.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0190-01.jpg)'
- en: This yields the affine transformation in [Equation 7.9](ch07.xhtml#ch07eqa09).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这得到了[方程 7.9](ch07.xhtml#ch07eqa09)中的仿射变换。
- en: '![Image](../images/07eqa09.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/07eqa09.jpg)'
- en: Let’s create a new factory function to generate rotations around a center point.
    In *affine_transforms.py*, with the help of [Equation 7.9](ch07.xhtml#ch07eqa09),
    implement the new function in [Listing 7-13](ch07.xhtml#ch7lis13).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的工厂函数，用于围绕中心点生成旋转。在*affine_transforms.py*中，在[方程 7.9](ch07.xhtml#ch07eqa09)的帮助下，实现新的函数，[清单
    7-13](ch07.xhtml#ch7lis13)中可以找到。
- en: '[PRE19]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 7-13: Creating a rotation transformation*'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-13：创建旋转变换*'
- en: Once again, you want to come up with at least one unit test to make sure our
    implementation is bug free.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，您需要至少编写一个单元测试，确保我们的实现没有漏洞。
- en: 'Let’s give it a try in the shell: let’s create two rotations of *π*/4 radians,
    one around the origin and another one around the point (10, 10). Then, we’ll apply
    both rotations to the point (15, 15) to see where it lands in both cases. Reload
    the Python shell and write the following:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 shell 中尝试一下：创建两个旋转，分别是*π*/4 弧度，一个围绕原点，另一个围绕点 (10, 10)。然后，我们将这两个旋转应用到点 (15,
    15)，看看它们在两种情况下的结果。重新加载 Python shell 并写入以下内容：
- en: '[PRE20]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let’s now try with the rotation around the origin:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试围绕原点进行旋转：
- en: '[PRE21]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The resulting point has an x-coordinate that is effectively zero (note the exponent
    e-15) and a y-coordinate of 21.2132..., which is the length of the vector going
    from the origin to the original point ![Image](../images/f00192.jpg).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 结果点的 x 坐标基本为零（注意指数 e-15），y 坐标为 21.2132...，这就是从原点到原始点的向量长度 ![图片](../images/f00192.jpg)。
- en: 'Let’s try the second rotation:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试第二次旋转：
- en: '[PRE22]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The resulting point is (10, 17.071...) this time. To help us make sense of the
    exercise we’ve just done, [Figure 7-12](ch07.xhtml#ch7fig12) illustrates the two
    rotation transformations.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这次结果点是 (10, 17.071...)。为了帮助我们理解刚刚做的练习，[图 7-12](ch07.xhtml#ch7fig12)展示了这两次旋转变换。
- en: '![Image](../images/07fig12.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/07fig12.jpg)'
- en: '*Figure 7-12: Example of a rotation around the origin (left) and around the
    point (10, 10) (right)*'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-12：围绕原点旋转（左）与围绕点 (10, 10) 旋转（右）的示例*'
- en: '**Interpolating Transformations**'
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**插值变换**'
- en: When you zoom in or out, most graphics programs don’t apply the scale all at
    once, but they typically produce a quick and smooth animation of the zooming process.
    This helps you, the user, better understand how the drawing is being transformed.
    To achieve this, graphics programs typically use a transformation interpolation.
    Later in the book we’ll animate affine transformations, that is, we’ll create
    a kind of movie where we can appreciate how a given geometry is transformed one
    step at a time. Each frame in the animation will depict the geometry after applying
    a fraction of the affine transformation, and this is where we’ll first use *interpolations*.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 当你进行放大或缩小时，大多数图形程序不会一次性应用缩放，而是通常通过一个快速平滑的动画来展示缩放过程。这可以帮助用户更好地理解图形是如何被转换的。为了实现这一点，图形程序通常使用变换插值。在本书的后续部分，我们将为仿射变换制作动画，也就是说，我们将创建一种电影，通过每一帧逐步展示给定几何图形如何变化。每一帧动画将展示在应用部分仿射变换后的几何图形，这也是我们第一次使用*插值*的地方。
- en: '***Motivating Interpolation***'
  id: totrans-213
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***激励插值***'
- en: Before we dive into the concept of interpolating transformations, take a look
    at [Figure 7-13](ch07.xhtml#ch7fig13).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入讨论插值变换的概念之前，先看一下[图7-13](ch07.xhtml#ch7fig13)。
- en: '![Image](../images/07fig13.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig13.jpg)'
- en: '*Figure 7-13: Animating an affine transformation*'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-13：动画中的仿射变换*'
- en: In the figure, there’s a triangle originally in the bottom left of the window
    that ends up in the top middle after passing through some middle positions drawn
    in a lighter gray. Each of the triangles represents the result we’d see at a given
    point in time, a concrete frame in the animation.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在图中，最初位于窗口左下角的三角形经过一些位置（以较浅的灰色绘制）后，最终到达窗口的顶部中间。每个三角形表示我们在某一时刻看到的结果，是动画中的一个具体帧。
- en: 'If we want our animation to have *n* frames, where *n* > 1, there needs to
    be *n* affine transformations [*T*[0]], [*T*[1]],..., [*T*[n–1]] such that each
    frame is the result of applying the corresponding transformation to the input
    geometry. It’s clear that the last transformation, [*T*[*n–*1]], needs to be the
    target affine transformation, as the final frame should depict the geometry after
    applying such a transformation. What should [*T*[0]] be then? Let’s give it some
    thought. What transformation applied to the input geometry results in the geometry
    itself? Well, there’s only one such transformation that we know doesn’t move things
    around, the identity transformation. So, our start and end transformations are
    as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望动画有*n*帧，其中*n* > 1，那么需要有*n*个仿射变换[*T*[0]]，[*T*[1]]，...，[*T*[n–1]]，使得每一帧都是将相应变换应用到输入几何体后的结果。显然，最后一个变换[*T*[n–1]]必须是目标仿射变换，因为最后一帧应展示应用该变换后的几何图形。那么[*T*[0]]应该是什么呢？让我们思考一下。什么变换应用到输入几何体后能得到原本的几何体呢？嗯，只有一个这样的变换，它不会移动任何东西，那就是恒等变换。所以，我们的起始变换和结束变换如下所示：
- en: '![Image](../images/f0193-01.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0193-01.jpg)'
- en: 'How do we go about computing [*T*[1]],...,[*T*[n–2]]? It’s easy: we can interpolate
    each of the start and end values to obtain as many intermediate values as we need.
    For example, a linear interpolation from 0 to 5 using five steps would yield [0,
    1, 2, 3, 4, 5]. Note that five steps produce six values, so to obtain *n* frames,
    we’ll use *n –* 1 steps.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何计算[*T*[1]]，...，[*T*[n–2]]呢？其实很简单：我们可以通过插值法将每个起始值和结束值进行插值，从而得到所需的中间值。例如，从0到5进行线性插值，使用五个步骤会得到[0,
    1, 2, 3, 4, 5]。注意，五个步骤产生六个值，所以要得到*n*帧，我们需要使用*n–1*步骤。
- en: To interpolate from a start value *v*[*s*] to an end value *v*[*e*], we can
    use any function that passes through them. A straight line (linear function) is
    the simplest one, and the resulting values are uniformly spaced. This is a linear
    interpolation. If we used such interpolation to produce the frames of an animation,
    the result would move at constant speed from the beginning to the end (the slope
    of the interpolating function is constant), which looks unnatural to the eye.
    Why is that? Well, it’s because we’re not used to seeing things in real life abruptly
    accelerating, moving at the same speed, and stopping all of a sudden. This may
    look fine for projectiles or bullets, but it’s strange for most real-life objects
    in motion. We can try a more natural-looking interpolating function such as an
    *ease-in-out*, plotted in the right-side graph of [Figure 7-14](ch07.xhtml#ch7fig14).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 要从起始值*v*[*s*]插值到结束值*v*[*e*]，我们可以使用任何一个通过这两个值的函数。直线（线性函数）是最简单的，得到的值是均匀间隔的。这就是线性插值。如果我们使用这种插值来生成动画的帧，结果将以恒定的速度从开始到结束移动（插值函数的斜率是恒定的），这在人眼中看起来不自然。为什么会这样呢？因为我们不习惯看到现实生活中的事物突然加速、以相同速度运动并突然停止。虽然这对于投射物或子弹可能没问题，但对于大多数现实生活中的运动物体来说就显得很奇怪。我们可以尝试一种看起来更自然的插值函数，比如在[图
    7-14](ch07.xhtml#ch7fig14)右侧图形中绘制的*ease-in-out*插值。
- en: '![Image](../images/07fig14.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig14.jpg)'
- en: '*Figure 7-14: Two interpolation functions*'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-14：两种插值函数*'
- en: In an ease-in-out function, values at the beginning and end vary slowly, which
    gives the sensation of things accelerating as they start to move and softly decelerating
    when reaching the end of their motion. This function defines motion in a much
    more natural way, and animations following this variation of the position with
    respect to time look nice to the human eye.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个ease-in-out函数中，开始和结束时的值变化较慢，这给人一种事物开始运动时加速，达到运动终点时缓慢减速的感觉。这个函数以更自然的方式定义了运动，跟随这种位置随时间变化的动画在人眼中看起来很美观。
- en: To obtain a value between *v*[*s*] and *v*[*e*], we use a parameter *t* such
    that 0 ≤ *t* ≤ 1 (see [Equation 7.10](ch07.xhtml#ch07eqa10)).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 要获得介于*v*[*s*]和*v*[*e*]之间的值，我们使用一个参数*t*，使得0 ≤ *t* ≤ 1（见[方程 7.10](ch07.xhtml#ch07eqa10)）。
- en: '![Image](../images/07eqa10.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07eqa10.jpg)'
- en: You can easily observe that [Equation 7.10](ch07.xhtml#ch07eqa10) yields a result
    of *v*[*s*] for *t* = 0 and *v*[*e*] for *t* = 1\. For any intermediate value
    of *t*, the value varies between those two values. If we want to obtain a sequence
    of values starting with *v*[*s*] all the way to *v*[*e*] that follow a linear
    distribution, we just need to use equally spaced values for *t*, like, for example,
    [0, 0.25, 0.5, 0.75, 1].
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以很容易地观察到，[方程 7.10](ch07.xhtml#ch07eqa10)在*t* = 0时给出*v*[*s*]的结果，在*t* = 1时给出*v*[*e*]的结果。对于任何介于这两个值之间的*t*值，结果都会在这两个值之间变化。如果我们想得到一个从*v*[*s*]到*v*[*e*]的值序列，并且该序列呈线性分布，我们只需为*t*使用均匀间隔的值，例如[0,
    0.25, 0.5, 0.75, 1]。
- en: To produce an ease-in-out distribution of interpolated values, we need a sequence
    of *t* values from 0 to 1 with uneven spacing, with small steps near the extreme
    values and greater steps around the middle. If we represent the values of *t*
    by circles in a horizontal line starting at *t* = 0 and ending at *t* = 1, we
    can get a sense of how uniform and ease-in-out values are distributed from [Figure
    7-15](ch07.xhtml#ch7fig15).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成ease-in-out分布的插值值，我们需要一个从0到1的不均匀间隔的*t*值序列，极值附近步长较小，中央附近步长较大。如果我们将*t*值表示为在水平线上从*t*
    = 0到*t* = 1的圆点，我们可以通过[图 7-15](ch07.xhtml#ch7fig15)来直观了解均匀和ease-in-out值是如何分布的。
- en: '![Image](../images/07fig15.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig15.jpg)'
- en: '*Figure 7-15: Interpolating t values*'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-15：插值t值*'
- en: To build the sequence of *t* values distributed according to the right-side
    plot in [Figure 7-14](ch07.xhtml#ch7fig14), we can plug a sequence of evenly spaced
    *t* values into [Equation 7.11](ch07.xhtml#ch07eqa11).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建一个按[图 7-14](ch07.xhtml#ch7fig14)右侧图形分布的*t*值序列，我们可以将一系列均匀间隔的*t*值代入[方程 7.11](ch07.xhtml#ch07eqa11)。
- en: '![Image](../images/07eqa11.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07eqa11.jpg)'
- en: This alters their spacing so that more of them lie near the extremes 0 and 1
    and fewer are located in the middle.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这改变了它们的间隔，使得更多的值位于极值0和1附近，较少的值位于中间。
- en: We have all the ingredients that we need; let’s get our hands dirty!
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好所需的所有要素，开始动手吧！
- en: '***Implementing Interpolation***'
  id: totrans-235
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***实现插值***'
- en: Create a new file named *interpolation.py* inside *geom2d* and enter the code
    in [Listing 7-14](ch07.xhtml#ch7lis14).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *geom2d* 中创建一个名为 *interpolation.py* 的新文件，并输入 [列表 7-14](ch07.xhtml#ch7lis14)
    中的代码。
- en: '[PRE23]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 7-14: Interpolated t values*'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-14：插值的 t 值*'
- en: 'Starting from the bottom, we have the function ease_in_out_t, which is simply
    the implementation of [Equation 7.11](ch07.xhtml#ch07eqa11). The first function
    builds a sequence of uniformly distributed *t* values using the given number of
    steps, thus producing as many values as steps plus one. We can test that in the
    shell. Reload it and try the following:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 从底部开始，我们有函数 ease_in_out_t，它仅仅是 [方程 7.11](ch07.xhtml#ch07eqa11) 的实现。第一个函数使用给定的步数构建一个均匀分布的
    *t* 值序列，从而生成与步数加一相同数量的值。我们可以在 shell 中测试这一点。重新加载并尝试以下操作：
- en: '[PRE24]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Function ease_in_out_t_sequence, on the other hand, creates sequences following
    an ease-in-out distribution. To do so, it applies [Equation 7.11](ch07.xhtml#ch07eqa11)
    to values of a uniform sequence. Let’s try it as well in the shell:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，函数 ease_in_out_t_sequence 创建遵循 ease-in-out 分布的序列。为此，它将 [方程 7.11](ch07.xhtml#ch07eqa11)
    应用到均匀序列的值上。我们也可以在 shell 中尝试一下：
- en: '[PRE25]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: See how values near 0 and 1 are closer together while values in the middle (near
    0.5) are farther apart? Great, so we’re just missing a function to interpolate
    between two values for a given *t*, just as [Equation 7.10](ch07.xhtml#ch07eqa10)
    defines. Add [Listing 7-15](ch07.xhtml#ch7lis15) in *interpolation.py*.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 看看接近 0 和 1 的值是否更接近，而中间的值（接近 0.5）则相隔更远？太好了，现在我们只缺一个函数，用于给定 *t* 值时在两个值之间进行插值，就像
    [方程 7.10](ch07.xhtml#ch07eqa10) 定义的那样。在 *interpolation.py* 中添加 [列表 7-15](ch07.xhtml#ch7lis15)。
- en: '[PRE26]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Listing 7-15: Interpolating between two values given t*'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-15：给定 t 值时的插值*'
- en: If you recall from [Chapter 5](ch05.xhtml#ch05), when we operate using a passed-in
    *t* parameter value, we want to check that it’s inside its expected range, for
    which the ensure_valid function is used. We’re now ready for the last step, and
    I hope you followed along, because here’s the actual interpolation of affine transformations
    we’ve been pursuing. Open your file *affine_transforms.py*, where we defined factory
    functions to create several special types of affine transformations, and enter
    the code in [Listing 7-16](ch07.xhtml#ch7lis16).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得 [第 5 章](ch05.xhtml#ch05)，当我们使用传入的 *t* 参数值进行操作时，我们需要检查它是否在预期的范围内，确保有效函数（ensure_valid）用于此。现在我们已准备好最后一步，希望你跟上了，因为这就是我们一直追求的仿射变换插值。打开你的文件
    *affine_transforms.py*，在其中我们定义了创建几种特殊类型仿射变换的工厂函数，然后输入 [列表 7-16](ch07.xhtml#ch7lis16)
    中的代码。
- en: '[PRE27]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 7-16: Sequence of interpolated affine transformations*'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-16：插值的仿射变换序列*'
- en: To help generate a sequence of interpolated affine transformations, we define
    a private function __interpolated, which, given two transformations and a value
    for *t*, returns the interpolation for that *t* ➌. Each value for the new transformation
    is the result of interpolating the values of both start and end transformations.
    Then we build a sequence of *t* values following the ease-in-out distribution
    ➊, each of which is mapped to the interpolated transformation using a list comprehension
    ➋.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助生成插值的仿射变换序列，我们定义了一个私有函数 __interpolated，它接受两个变换和一个 *t* 值作为输入，返回该 *t* 值的插值
    ➌。新变换的每个值都是对起始变换和结束变换的值进行插值的结果。然后，我们构建一个遵循 ease-in-out 分布的 *t* 值序列 ➊，每个 *t* 值都通过列表推导映射到相应的插值变换
    ➋。
- en: We’ll leave this for now until [Chapter 12](ch12.xhtml#ch12), where we’ll be
    using the sequences of interpolated affine transformations to produce animations.
    Don’t worry if the concepts explored in this last part of the chapter seem a little
    abstract. We’ll build the foundations of animating motion in the next part of
    the book, and until then it may be hard to make sense out of this interpolation
    thing.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们先将这个部分留到 [第 12 章](ch12.xhtml#ch12)，到时我们将使用插值的仿射变换序列来制作动画。如果这一章最后部分探讨的概念看起来有些抽象，不要担心。我们将在本书的下一部分构建动画运动的基础，到那时，这个插值的概念可能会变得更容易理解。
- en: '**Geom2D Final Touches**'
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Geom2D 最后润色**'
- en: Our *geom2d* package is tested and ready to be used throughout the rest of the
    book. We made it robust, but we can add a few small improvements before concluding
    this part of the book.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 *geom2d* 包已经经过测试，准备在本书剩余部分使用。我们使它变得稳健，但在本书这一部分结束之前，我们可以添加一些小的改进。
- en: '***Test Files***'
  id: totrans-253
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***测试文件***'
- en: 'The first thing we want to do is separate implementation and test files, which
    are all in the same folder at the moment. This is so that the *geom2d* package
    folder appears less cluttered and you can find implementation files easier. In
    the package, create a new folder named *tests*, and then select all test files,
    which we conveniently named ending in *_test.py*, and drag them to the folder.
    Your folder structure and files should look like the following:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要做的是将实现文件和测试文件分开，当前它们都在同一个文件夹中。这样做是为了让 *geom2d* 包文件夹看起来不那么杂乱，方便你更容易找到实现文件。在包内创建一个名为
    *tests* 的新文件夹，然后选择所有测试文件（我们便捷地将它们命名为以 *_test.py* 结尾），并将它们拖动到该文件夹中。你的文件夹结构和文件应如下所示：
- en: Mechanics
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: Mechanics
- en: '|- geom2d'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '|- geom2d'
- en: '|    |- tests'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- tests'
- en: '|    |    |- affine_transf_test.py'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |    |- affine_transf_test.py'
- en: '|    |    |- affine_transforms_test.py'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |    |- affine_transforms_test.py'
- en: '|    |    |- circle_test.py'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |    |- circle_test.py'
- en: '|    |    |- ...'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |    |- ...'
- en: '|    |    |- vector_test.py'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |    |- vector_test.py'
- en: '|    |- __init__.py'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- __init__.py'
- en: '|    |- affine_transf.py'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- affine_transf.py'
- en: '|    |- affine_transforms.py'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- affine_transforms.py'
- en: '|    |- circle.py'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- circle.py'
- en: '|    |- ...'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- ...'
- en: '|    |- vectors.py'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- vectors.py'
- en: '***Running All Tests***'
  id: totrans-269
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行所有测试***'
- en: Now that all our test files live in the same folder, what about running all
    test cases at once? It may happen that you changed part of the code and want to
    make sure you didn’t break anything, for which you decide to run every test in
    the package. The way we’ve been doing it would take you some time, as you’d have
    to open the test files one by one and click the green play button beside each
    of the class names. There’s a better way!
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，所有测试文件都在同一个文件夹中，那如何一次性运行所有测试用例呢？可能是你更改了部分代码，想确保没有破坏任何功能，于是你决定运行包中的每个测试。按照我们之前的方法，这需要花费一些时间，因为你需要逐个打开测试文件，并点击每个类名称旁边的绿色播放按钮。其实有更好的方法！
- en: 'Open the Terminal view inside PyCharm. If you can’t see it, from the menu select
    **View** ▸ **Tool Windows** ▸ **Terminal**. By default, the shell opens right
    in the root directory of the project, which is exactly what we want. In the shell,
    run the following command:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 PyCharm 内的终端视图。如果看不到，可以从菜单中选择 **View** ▸ **Tool Windows** ▸ **Terminal**。默认情况下，终端会在项目的根目录下打开，这正是我们所需要的。在终端中，运行以下命令：
- en: '[PRE28]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This command tells Python to discover and run all unit tests in *geom2d/tests/*
    inside files matching the pattern **_test.py*, that is, all files ending in *_test.py*.
    Running the command should result in something similar to the following:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令告诉 Python 查找并运行所有位于 *geom2d/tests/* 中的单元测试，文件名符合 **_test.py** 模式，即所有以 *_test.py*
    结尾的文件。运行该命令后，结果应类似于以下内容：
- en: '[PRE29]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You can save this command in a bash file at the project’s root level so you
    can execute it whenever you want without needing to memorize it.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将此命令保存在项目根目录下的 bash 文件中，这样你就可以随时执行它，而无需记住它。
- en: '***Package Imports***'
  id: totrans-276
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***包导入***'
- en: 'The last thing we want to do is include all modules in the package’s exports
    so that they can be loaded like so:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们要做的是将所有模块包含在包的导出中，这样它们就可以像这样被加载：
- en: '[PRE30]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Compare this to the following:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 将其与以下内容进行比较：
- en: '[PRE31]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The latter requires the user to type the path where each module lives in *geom2d*,
    but the former doesn’t: everything inside the package can be imported directly
    from the package itself. This style of exporting modules of a package is convenient
    for two reasons: (1) because it allows us to change the directory structure within
    the module without breaking the user’s imports and (2) because users don’t need
    to know where each module is located within the package and import everything
    from the package itself. As you can guess, this greatly reduces the cognitive
    load for using the package.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 后者要求用户输入每个模块在 *geom2d* 中的路径，而前者则不需要：包内的所有内容都可以直接从包本身导入。采用这种导出模块的方式有两个优点：（1）它允许我们在不破坏用户导入的情况下改变模块的目录结构，（2）用户不需要知道每个模块在包内的具体位置，所有内容都可以从包本身直接导入。如你所见，这大大减少了使用包时的认知负担。
- en: When PyCharm created the package *geom2d*, it included an empty file inside
    it named *__init__.py*. Can you spot it? Files with this name inside packages
    are loaded when the package itself is imported. We can use them to import what
    is defined inside the package.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 当 PyCharm 创建 *geom2d* 包时，它会在其中包含一个名为 *__init__.py* 的空文件。你能找到它吗？包中的文件名为此的文件会在包被导入时自动加载。我们可以利用它们来导入包内定义的内容。
- en: '**NOTE**'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If for whatever reason the file* __init__.py *doesn’t exist in your* geom2d
    *package, simply create it. Maybe you created the package as a normal directory
    inside PyCharm so the IDE didn’t add it for you.*'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果由于某种原因，文件* __init__.py *在你的* geom2d *包中不存在，直接创建它即可。也许你在 PyCharm 中将包创建为普通目录，因此
    IDE 没有为你自动添加它。*'
- en: So, open the file, which should be empty, and import all of the primitives we
    defined (see [Listing 7-17](ch07.xhtml#ch7lis17)).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，打开文件，它应该是空的，并导入我们定义的所有基本元素（见[列表 7-17](ch07.xhtml#ch7lis17)）。
- en: '[PRE32]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '*Listing 7-17: The geom2d package init file*'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-17：geom2d 包的初始化文件*'
- en: 'That’s all! To understand what we achieve with this change, you can try the
    following in the shell (Python’s shell, not the shell we just used to run commands):'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！要理解我们通过这个更改实现了什么，你可以在 Python 的 shell 中（不是我们刚才用来运行命令的 shell）尝试以下操作：
- en: '[PRE33]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This will prove convenient in future chapters, as we can import any module from
    *geom2d* directly from the package.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在后续章节中非常方便，因为我们可以直接从包中导入任何*geom2d*模块。
- en: '**Summary**'
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: 'In this chapter, we explored a core concept in computer graphics: affine transformations.
    They allow us to transform geometry by scaling, rotating, translating, and shearing
    it.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了计算机图形学中的一个核心概念：仿射变换。它们允许我们通过缩放、旋转、平移和剪切来变换几何图形。
- en: 'We started by taking a look at their mathematical definition and how they differ
    from linear transformations. The takeaway is that affine transformations can move
    the origin point, while linear transformations cannot. Affine transformations
    can be expressed as the combination of a linear transformation with a translation,
    but we saw a more convenient representation: the augmented matrix. Next, we implemented
    methods in the AffineTransform class to transform our geometric primitives: points,
    segments, and polygons.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先回顾了它们的数学定义，以及它们与线性变换的区别。结论是，仿射变换可以移动原点，而线性变换不能。仿射变换可以表示为线性变换与平移的组合，但我们看到了一个更方便的表示方法：增广矩阵。接下来，我们在
    AffineTransform 类中实现了方法，用于变换我们的几何原始元素：点、线段和多边形。
- en: 'We then learned how transformations can be concatenated to achieve complex
    transformations out of simpler ones. Thanks to that powerful idea, we were able
    to construct two essential affine transformations that happen in almost every
    graphics application we know: scaling and rotating around a point other than the
    origin.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们学习了如何将变换组合起来，以通过简单的变换实现复杂的变换。凭借这个强大的思想，我们能够构造出在几乎所有图形应用程序中都会用到的两个基本仿射变换：缩放和绕原点以外的点旋转。
- en: Lastly, we implemented a function to interpolate between two affine transformations,
    yielding a couple intermediate transformations that we’ll soon be using to produce
    animations.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们实现了一个函数，用于在两个仿射变换之间进行插值，从而生成一些中间变换，这些变换将很快用于制作动画。
