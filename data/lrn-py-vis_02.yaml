- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Drawing More Complicated Shapes
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制更复杂的形状
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: In Chapter 1, you learned about 2D primitives, including arcs, ellipses, lines,
    points, quads, rectangles, and triangles. However, some shapes, like hearts, stars,
    octagons, and Pikachu silhouettes, don’t fit into any such category and require
    more than shape functions to create.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1章中，你学习了2D基本图形，包括弧、椭圆、线条、点、四边形、矩形和三角形。然而，有些形状，比如心形、星形、八边形和皮卡丘轮廓，无法归入任何这种类别，需要使用更多的形状函数才能创建。
- en: In this chapter, you’ll learn how to draw more complicated shapes with points
    and curves, as well as vertex functions for laying points. Using these techniques,
    you’ll draw shapes that blend straight and curved lines, and you’ll create *negative*
    shapes by subtracting one shape from another.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何使用点和曲线绘制更复杂的形状，以及使用顶点函数来布局点。通过这些技术，你将绘制出融合直线和曲线的形状，并通过从一个形状中减去另一个形状来创建*负*形状。
- en: 'You’ll also learn how to work with two types of curves: *Catmull-Rom splines*
    and *Bézier curves*. Although both involve complicated math, Processing’s curve
    functions handle the underlying calculus, allowing you to create curves with just
    the coordinates of a few control points.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你还将学习如何使用两种类型的曲线：*Catmull-Rom样条曲线*和*Bézier曲线*。尽管这两者都涉及复杂的数学，但Processing的曲线函数处理了底层的微积分运算，使你只需控制点的坐标就能创建曲线。
- en: Displaying a Grid
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示网格
- en: 'The best way to understand how curves work in Processing is to draw a few and
    then manipulate them. It’s easier to plot points and curves by using a grid background
    for reference, so you’ll add one by using a ready-made graphic. Create a new sketch
    and save it as *curves*, and then follow these instructions to download the grid
    graphic:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 理解Processing中曲线如何工作的最佳方式是绘制几个曲线并对其进行操作。使用网格背景作为参考，可以更容易地绘制点和曲线，因此你将通过使用现成的图形来添加一个网格。创建一个新的草图并将其保存为*curves*，然后按照以下说明下载网格图形：
- en: Open your web browser and go to [https://github.com/tabreturn/processing.py-book/](https://github.com/tabreturn/processing.py-book/).
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的网页浏览器并访问[https://github.com/tabreturn/processing.py-book/](https://github.com/tabreturn/processing.py-book/)。
- en: Navigate to *chapter-02-drawing_more_complicated_shapes*.
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到*chapter-02-drawing_more_complicated_shapes*。
- en: Download the *grid.png* file.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载*grid.png*文件。
- en: Additional sketch assets (images, fonts, and other media) belong in a subfolder
    named *data*, so create a new *data* subfolder within your *curves* sketch folder
    and place the *grid.png* file within it ([Figure 2-1](#figure2-1)).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 其他草图资源（图像、字体和其他媒体）应放在名为*data*的子文件夹中，因此在你的*curves*草图文件夹内创建一个新的*data*子文件夹，并将*grid.png*文件放入其中（[图
    2-1](#figure2-1)）。
- en: '![f02001](image_fi/500969c02/f02001.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![f02001](image_fi/500969c02/f02001.png)'
- en: 'Figure 2-1: Place the grid graphic within your *data* subfolder.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-1：将网格图形放置在你的*data*子文件夹中。
- en: 'This grid graphic will lie beneath everything you draw ([Figure 2-2](#figure2-2)),
    assisting you in gauging x-y coordinates. Set up your sketch by using the following
    code:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这个网格图形将位于你绘制的所有内容下方（[图 2-2](#figure2-2)），帮助你衡量x-y坐标。使用以下代码设置你的草图：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `loadImage()` function loads the graphic file and assigns it to a variable
    named `grid` 1. The `image()` function 2 draws the image to the display window.
    The three arguments (`grid`, `0`, `0`) represent the loaded image file, x-coordinate,
    and y-coordinate, respectively.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`loadImage()`函数加载图形文件并将其分配给名为`grid`的变量1。`image()`函数2则将图像绘制到显示窗口。三个参数（`grid`，`0`，`0`）分别表示加载的图像文件、x坐标和y坐标。'
- en: The image is drawn at its original dimensions unless it’s resized using an additional
    fourth (width) and fifth (height) `image()` function argument.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图像将按其原始尺寸绘制，除非使用额外的第四（宽度）和第五（高度）`image()`函数参数来调整大小。
- en: '![f02002](image_fi/500969c02/f02002.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![f02002](image_fi/500969c02/f02002.png)'
- en: 'Figure 2-2: Displaying the grid image'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-2：显示网格图像
- en: Drawing Curves Using Catmull-Rom Splines
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Catmull-Rom样条曲线绘制曲线
- en: To draw a curved line in Processing, you can use the `curve()` function. This
    function accepts eight arguments, which represent four pairs of x-y coordinates;
    these are the starting control point, start of the curve, end of the curve, and
    ending control point.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Processing中绘制曲线，你可以使用`curve()`函数。此函数接受八个参数，它们表示四对x-y坐标；这些分别是起始控制点、曲线起点、曲线终点和终止控制点。
- en: 'Let’s begin with a standard line and then adapt it into a curve. This way,
    you can visualize how the `curve()` function operates by comparing it with the
    simpler and more familiar `line()` function. Add a diagonal line to your *curves*
    sketch ([Figure 2-3](#figure2-3)):'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一条标准直线开始，然后将其转变为曲线。这样，你可以通过与更简单且熟悉的`line()`函数进行比较，直观地了解`curve()`函数是如何工作的。在你的*curves*草图中添加一条对角线（见[图
    2-3](#figure2-3)）：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![f02003](image_fi/500969c02/f02003.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![f02003](image_fi/500969c02/f02003.png)'
- en: 'Figure 2-3: A straight line to adapt into a curve'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-3：将直线转变为曲线
- en: 'Processing draws a line between the specified pairs of x-y coordinates: (100,
    100) and (400, 400). Note that the line’s coordinates correspond to the grid beneath.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Processing 在指定的 x-y 坐标对之间绘制一条直线：(100, 100) 和 (400, 400)。注意，直线的坐标与下面的网格对应。
- en: Curving Lines with curve()
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 curve() 绘制曲线
- en: 'To use the `curve()` function to draw the same line, comment out the `line()`
    function in the *curves* sketch and replace it with a `curve()` function:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`curve()`函数绘制相同的直线，请在*curves*草图中注释掉`line()`函数，并将其替换为`curve()`函数：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When you run the sketch, the visual result should be exactly the same, as shown
    previously in [Figure 2-3](#figure2-3). The four middle values within the `curve()`
    function’s parentheses match those of the `line()` function, and they also indicate
    the starting and ending x-y coordinates of the curve.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行草图时，视觉效果应该与之前在[图 2-3](#figure2-3)中展示的完全相同。`curve()`函数括号中的四个中间值与`line()`函数相匹配，它们也表示曲线的起始和结束
    x-y 坐标。
- en: 'But the `curve()` function takes four additional outer arguments (in this example,
    `0,0` and `500,500`), which represent two pairs of *control-point* coordinates.
    The positions of these control points determine the direction and amount of curvature
    you apply to the line. Before exploring this in detail, add the following new
    lines to the end of your code to draw a yellow line of the same length, at the
    same position, but with some curvature:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，`curve()`函数需要额外的四个外部参数（在这个示例中是`0,0`和`500,500`），它们表示两对*控制点*坐标。这些控制点的位置决定了你对直线施加的曲率的方向和程度。在详细探讨之前，添加以下新行到代码的末尾，以绘制一条相同长度、相同位置，但带有曲率的黄色线条：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this instance, the four middle arguments remain the same, but the control-point
    coordinates have been changed to `0,250` and `500,250`. The result is a yellow
    curve with a slight S-bend ([Figure 2-4](#figure2-4)). By comparing the blue and
    yellow lines, you can visualize how changing the control points has manipulated
    the curve.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，四个中间参数保持不变，但控制点的坐标已改为`0,250`和`500,250`。结果是一条带有轻微 S 弯的黄色曲线（见[图 2-4](#figure2-4)）。通过比较蓝色和黄色线条，你可以直观地看到更改控制点如何影响曲线的形状。
- en: '![f02004](image_fi/500969c02/f02004.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![f02004](image_fi/500969c02/f02004.png)'
- en: 'Figure 2-4: The yellow curve’s control points, circled in orange, would otherwise
    be invisible.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-4：黄色曲线的控制点，橙色圈出的部分，否则将不可见。
- en: To understand how the control points influence the curve, imagine that each
    end of the yellow curve extends to its neighboring control point. The closer you
    bring the control point to the center of the display window, the harder you are
    “flexing” this curve. Conversely, with control points 1 and 2 positioned at the
    upper left and lower left corners of the display window, respectively, the four
    points lie in a row, and the curve does not have to flex, resulting in a straight
    line.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解控制点如何影响曲线，可以想象每个黄色曲线的端点延伸到相邻的控制点。你把控制点移近显示窗口的中心时，就相当于你在“弯曲”这条曲线。相反，如果将控制点
    1 和 2 分别放置在显示窗口的左上角和左下角，四个点将排成一行，曲线就不再弯曲，从而形成一条直线。
- en: 'To see how the control points work, add the following orange curves to serve
    as visual aids:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了观察控制点的作用，添加以下橙色曲线作为视觉辅助线：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The first `curve()` function 1 draws an orange curve from control point 1 to
    the starting point of the yellow curve; the second `curve()` function 2 draws
    another orange curve from the end point of the yellow curve to control point 2\.
    The result ([Figure 2-5](#figure2-5)) is a three-part curve (orange-yellow-orange)
    that shows how the control points determine the curvature of the yellow part.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`curve()`函数 1 从控制点 1 绘制一条橙色曲线，直到黄色曲线的起点；第二个`curve()`函数 2 从黄色曲线的终点绘制另一条橙色曲线，直到控制点
    2。结果（见[图 2-5](#figure2-5)）是一条三段式曲线（橙色-黄色-橙色），展示了控制点如何决定黄色部分的曲率。
- en: '![f02005](image_fi/500969c02/f02005.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![f02005](image_fi/500969c02/f02005.png)'
- en: 'Figure 2-5: Your Processing curve (left) and a traditional spline (right).
    (Illustration: Pearson Scott Foresman, licensed under public domain.)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-5：你的Processing曲线（左）与传统样条（右）。(插图：Pearson Scott Foresman，公有领域许可。)
- en: As you can see, the orange curves extend the yellow curve and illustrate what
    the yellow curve would look like as a physically complete spline. To the right
    in [Figure 2-5](#figure2-5), you can see the flexible strip for drawing such a
    curve without the aid of a computer. As mentioned earlier, it’s this strip from
    which the spline takes its name. The two nails correspond to the starting and
    ending points of the `curve()` function, and the L-pieces at each end represent
    the control points.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，橙色曲线延伸了黄色曲线，并说明了如果黄色曲线是一个完整的物理样条线，它会是什么样子。在[图 2-5](#figure2-5)的右侧，你可以看到没有计算机帮助下绘制此类曲线的柔性条带。如前所述，样条正是从这个条带得名。两个钉子对应`curve()`函数的起点和终点，而每端的L形件则代表控制点。
- en: Changing Curves with curveTightness()
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用curveTightness()更改曲线
- en: The `curveTightness()` function determines how rigidly the curve conforms to
    the points that control it, as if you were replacing the draftsman’s spline with
    a strip of less or more pliable material, or feeding a shorter or longer length
    of spline into the same area. The function accepts values ranging from –5.0 to
    5.0, with 0 being the default.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`curveTightness()`函数决定了曲线如何严格地符合控制它的点，就像你用一条更具或更少柔韧性的材料代替了草图绘制的样条，或者将一条更短或更长的样条输入到相同区域中。该函数接受从-5.0到5.0的值，默认值为0。'
- en: 'To experiment, add a `curveTightness()` line above the yellow stroke:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行实验，在黄色描边上方添加一行`curveTightness()`：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Enter different values to affect the curves below it. [Figure 2-6](#figure2-6)
    shows curves with different `curveTightness()` values.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 输入不同的值，以影响下方的曲线。[图 2-6](#figure2-6)展示了不同`curveTightness()`值下的曲线。
- en: '![f02006](image_fi/500969c02/f02006.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![f02006](image_fi/500969c02/f02006.png)'
- en: 'Figure 2-6: Clockwise from the top left: `curveTightness``(``-1)`, `curveTightness``(0)`,
    curveTightness`(1)`, and`curveTightness``(5)`'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-6：从左上角顺时针：`curveTightness`(`-1`)、`curveTightness`(`0`)、curveTightness`(1)`，以及`curveTightness`(`5`)
- en: The lower right curve in [Figure 2-6](#figure2-6), with its tightness argument
    set to `1`, fits so rigidly that the result is a straight yellow line. The more
    you adjust the tightness value away from `1`, the more the curve will deform.
    For curves that overshoot their starting and ending points, use values greater
    than 1\. For instance, at an upper tightness limit of `5` (bottom left), the spline
    loops as it passes through the starting and ending points. With a tightness argument
    of `-1` (top left), the lengthier spline is rerouted to better align with the
    points it passes through; hence, there is increased curvature but no looping.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-6](#figure2-6)中的右下曲线，紧度参数设置为`1`，因此曲线非常坚硬，结果是一条直的黄色线。你调整紧度值越远离`1`，曲线的变形程度就越大。对于超过起始点和结束点的曲线，可以使用大于1的值。例如，在紧度限制为`5`（左下）时，样条曲线会在通过起始和结束点时形成环路。而使用紧度参数`-1`（左上）时，较长的样条曲线会重新规划路线，以更好地与它所经过的点对齐，因此曲线更具弯曲性，但没有环路。'
- en: The `curve()` function is intuitive and useful for generating curved lines quickly.
    However, you’re most likely to encounter Bézier curves in 3D modeling, animation,
    computer-aided design (CAD), and vector illustration software, so let’s look at
    those next.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`curve()`函数直观且有用，用于快速生成曲线。但在3D建模、动画、计算机辅助设计（CAD）和矢量插图软件中，你最有可能遇到Bézier曲线，因此接下来我们将探讨这些曲线。'
- en: Drawing Bézier Curves
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制Bézier曲线
- en: '*Bézier curves* provide an intuitive and versatile means of modeling smooth
    curves using a series of anchor and control points. You may have encountered these
    curves in vector graphics drawing software, such as Adobe Illustrator or Inkscape.
    In this section, you’ll draw curves using the `bezier()` function. In graphics
    software, you have visual nodes to grab and manipulate; in Processing, you define
    the positions of your anchor and control points, using `bezier()` function arguments.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*Bézier曲线* 提供了一种直观且多功能的方式，通过一系列锚点和控制点来建模光滑的曲线。你可能在像Adobe Illustrator或Inkscape这样的矢量图形绘制软件中遇到过这些曲线。在本节中，你将使用`bezier()`函数绘制曲线。在图形软件中，你有可视化的节点可以抓取和操作；而在Processing中，你需要定义锚点和控制点的位置，使用`bezier()`函数的参数。'
- en: Using the bezier() Function
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`bezier()`函数
- en: 'The `bezier()` function takes eight arguments, expanded across multiple lines
    here for easier readability:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`bezier()`函数有八个参数，这里将其拆分为多行，便于阅读：'
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The first and last pair of arguments are the starting and ending points for
    your curve. When using Bézier curves, you typically refer to the points that your
    visible lines connect to as *anchor points*. The curvature of the line as it heads
    away from the first anchor point (`anchor_point_1_x, anchor_point_1_y`) is controlled
    by the position of its associated control point (`control_point_1_x, control_point_1_y`).
    The other control point (`control_point_2_x, control_point_2_y`) controls the
    curvature of the line as it heads toward the ending anchor point ([Figure 2-7](#figure2-7)).
    This is not spline-like behavior, though; instead, the control points behave more
    like magnets, causing the line to bulge toward them.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 第一对和最后一对参数是曲线的起点和终点。当使用贝塞尔曲线时，你通常将可见线连接的点称为*锚点*。从第一个锚点（`anchor_point_1_x, anchor_point_1_y`）开始，线条的曲率由其关联的控制点（`control_point_1_x,
    control_point_1_y`）的位置控制。另一个控制点（`control_point_2_x, control_point_2_y`）则控制线条朝向终点锚点的曲率（[图
    2-7](#figure2-7)）。不过，这种行为与样条曲线不同；相反，控制点更像是磁铁，导致线条向它们的方向膨胀。
- en: 'To draw a Bézier curve, create four variables to represent the x-y coordinate
    pairs of the two control points:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要绘制贝塞尔曲线，创建四个变量来表示两个控制点的 x-y 坐标对：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![f02007](image_fi/500969c02/f02007.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![f02007](image_fi/500969c02/f02007.png)'
- en: 'Figure 2-7: The anchor and control points manipulate the position and curvature
    of the Bézier curve.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-7：锚点和控制点控制贝塞尔曲线的位置和曲率。
- en: The first pair of `bezier()` coordinates positions anchor point 1 near the top
    right of the grid; the last pair of coordinates positions anchor point 2 near
    the bottom left. All of the control point variables (`cp1x,cp1y, cp2x,cp2y`) reference
    the center of the display window (250, 250). By placing the control points along
    the diagonal path formed between anchor points 1 and 2, you form a straight line.
    You’ll next shift these control points outward to observe how this curves the
    line.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 第一对 `bezier()` 坐标将锚点 1 放置在网格的右上方；最后一对坐标将锚点 2 放置在左下方。所有控制点变量（`cp1x, cp1y, cp2x,
    cp2y`）都引用显示窗口的中心（250, 250）。通过将控制点沿锚点 1 和锚点 2 之间的对角路径放置，你将形成一条直线。接下来，你将这些控制点向外移动，以观察这如何使线条发生弯曲。
- en: Run this sketch to render a pink line that represents a straightened Bézier
    curve ([Figure 2-8](#figure2-8)).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此草图以渲染一条粉色线，表示已拉直的贝塞尔曲线（[图 2-8](#figure2-8)）。
- en: '![f02008](image_fi/500969c02/f02008.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![f02008](image_fi/500969c02/f02008.png)'
- en: 'Figure 2-8: The pink line represents a straightened Bézier curve.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-8：粉色线条表示已拉直的贝塞尔曲线。
- en: The pink line should cross the yellow curve at the center of the display window
    (250, 250).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 粉色线条应穿过显示窗口的中心（250, 250）与黄色曲线交汇。
- en: Positioning Anchor and Control Points
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 锚点和控制点的定位
- en: 'To manipulate the pink line into a curve ([Figure 2-9](#figure2-9)), set the
    `cp1x` variable to `200`. In addition to this change, add two extra lines of code:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要将粉色线条调整为曲线（[图 2-9](#figure2-9)），将 `cp1x` 变量设置为 `200`。除了这个变化之外，还需添加两行额外的代码：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '![f02009](image_fi/500969c02/f02009.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![f02009](image_fi/500969c02/f02009.png)'
- en: 'Figure 2-9: Curving the pink line by adjusting a control point'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-9：通过调整控制点使粉色线条弯曲
- en: The additional code creates a red line connecting anchor point 1 (`400, 100`)
    and its control point (`cp1x,cp1y`). This red line is useful because you can now
    visualize where the control point sits and which anchor point it controls. Moreover,
    sharing variables between the `bezier()` and red `line()` functions means that
    each time you adjust the values that position the curve’s control point (`cp1x,cp1y`),
    the red line adapts accordingly. Setting the value of `cp1x` to `200` applies
    curvature to the pink line because—as the control point moves away from the pink
    line—the pink line bulges toward it.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 额外的代码创建了一条红线，连接锚点 1（`400, 100`）和其控制点（`cp1x, cp1y`）。这条红线很有用，因为现在你可以可视化控制点的位置以及它控制哪个锚点。此外，在
    `bezier()` 和红色 `line()` 函数之间共享变量意味着每次你调整定位曲线控制点（`cp1x, cp1y`）的值时，红线都会相应变化。将 `cp1x`
    的值设置为 `200` 会使粉色线条产生弯曲，因为——随着控制点远离粉色线条——粉色线条向其膨胀。
- en: The top half of the curve is affected most by the control point that connects
    to its top anchor point (control point 1); this will become more apparent when
    you manipulate the control point for the lower anchor point.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 曲线的上半部分受其顶部锚点连接的控制点（控制点 1）的影响最大；当你操作下方锚点的控制点时，这一点将更加明显。
- en: 'Now add another red line to connect (the lower) anchor point 2 and control
    point 2:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在添加另一条红线，将（下方的）锚点 2 和控制点 2 连接起来：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The new red line visually connects anchor point 2 (`100,400`) to its control
    point (`cp2x,cp2y`). Run the sketch to see the result ([Figure 2-10](#figure2-10)).
    Experiment with different control-point values to see how they affect the curve.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 新的红线将锚点2（`100,400`）与其控制点（`cp2x,cp2y`）视觉连接。运行草图查看结果（[图2-10](#figure2-10)）。尝试不同的控制点值，观察它们如何影响曲线。
- en: '![f02010](image_fi/500969c02/f02010.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![f02010](image_fi/500969c02/f02010.png)'
- en: 'Figure 2-10: Adjusting control point 2'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-10：调整控制点2
- en: Observe that the lower part of the pink curve is “magnetically” pulled toward
    control point 2\. Knowing where to place the anchor and control points for your
    desired curve takes some skill. Try downloading and practicing in Inkscape (or
    Illustrator if you have it installed). Alternatively, try playing The Bézier Game
    in your web browser at [https://bezier.method.ac](https://bezier.method.ac)*/*.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，粉色曲线的下半部分被“磁性”地拉向控制点2。了解如何放置锚点和控制点，以便获得所需的曲线是需要技巧的。尝试下载并在Inkscape（或如果你安装了Illustrator）中练习。或者，试着在你的浏览器中玩The
    Bézier Game，网址为[https://bezier.method.ac](https://bezier.method.ac)*/*。
- en: You can now draw curved lines by using Catmull-Rom splines and Bézier curves.
    The `curve()` and `bezier()` functions are useful for standalone curves, but to
    form shapes composed of multiple curve segments, you’ll need vertices.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用Catmull-Rom样条曲线和Bézier曲线绘制曲线。`curve()`和`bezier()`函数对于独立的曲线很有用，但如果要绘制由多个曲线段组成的形状，你需要使用顶点。
- en: Drawing Shapes Using Vertices
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用顶点绘制形状
- en: In Processing, a *vertex* is a point used to connect lines in order to form
    a shape. *Vertices* is the plural of vertex. You can think of vertices as the
    dots in a connect-the-dots drawing puzzle. For example, a triangle requires 3
    vertices; a pentagon requires 5; and a five-pointed star () requires 10\. When
    using straight lines and curves to connect vertices, the shape possibilities become
    limitless. A vertex is not limited to 2D space—for instance, Blender’s Suzanne
    (a monkey head) has around 500 vertices positioned in 3D space ([Figure 2-13](#figure2-13)).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在Processing中，*顶点*是用来连接线条以形成形状的点。*顶点*的复数形式是vertices。你可以将vertices视为连线画图谜题中的点。例如，一个三角形需要3个顶点；一个五边形需要5个；而一个五角星（）需要10个。当使用直线和曲线连接顶点时，形状的可能性变得无限。顶点不仅限于二维空间——例如，Blender中的Suzanne（一个猴头）有大约500个顶点，分布在三维空间中（[图2-13](#figure2-13)）。
- en: '![f02013](image_fi/500969c02/f02013.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![f02013](image_fi/500969c02/f02013.png)'
- en: 'Figure 2-13: Three of the 500 or so vertices circled in yellow'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-13：约500个顶点中的三个被圈出（黄色）
- en: You’ll draw a square-type shape by using a series of `vertex()` functions. Create
    a new sketch and save it as *vertices*. Within the new *vertices* folder, add
    a *data* folder containing a copy of the *grid.png* file from your preceding sketch
    ([Figure 2-14](#figure2-14)).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你将通过一系列的`vertex()`函数绘制一个方形。创建一个新的草图并将其保存为*vertices*。在新的*vertices*文件夹中，添加一个*data*文件夹，并包含前一个草图中的*grid.png*文件的副本（[图2-14](#figure2-14)）。
- en: '![f02014](image_fi/500969c02/f02014.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![f02014](image_fi/500969c02/f02014.png)'
- en: 'Figure 2-14: The *vertices* sketch folder structure'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-14：*vertices*草图文件夹结构
- en: 'Add code to set up the initial parameters:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 添加代码以设置初始参数：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Again, you load and display the grid image to help you gauge coordinates in
    the display window. Each shape that you draw will have no fill and a white stroke
    of 3 pixels.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你需要加载并显示网格图像，以帮助你在显示窗口中测量坐标。你绘制的每个形状将没有填充，且边框为3像素的白色。
- en: 'Now, instead of using a `rect()` or `square()` function, use vertices to draw
    a square:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，不再使用`rect()`或`square()`函数，而是使用顶点来绘制一个方形：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `beginShape()` and `endShape()` functions are essential for separating groups
    of vertices into individual shapes. Without those two functions, Processing would
    have to assume that all the vertices in your sketch belong to the same shape.
    That said, Processing ignores any rogue `vertex()` lines placed outside the `beginShape()`
    and `endShape()` pair. As depicted in [Figure 2-15](#figure2-15), the code draws
    a square with no left side.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`beginShape()`和`endShape()`函数对于将顶点分成不同形状至关重要。如果没有这两个函数，Processing将假设草图中的所有顶点都属于同一个形状。也就是说，Processing会忽略任何放置在`beginShape()`和`endShape()`对外的“非法”`vertex()`线。如[图2-15](#figure2-15)所示，代码绘制了一个没有左边的方形。'
- en: '![f02015](image_fi/500969c02/f02015.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![f02015](image_fi/500969c02/f02015.png)'
- en: 'Figure 2-15: An open square drawn using vertices'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-15：使用顶点绘制的开口方形
- en: The shape will not close automatically unless you include an `endShape(CLOSE)`
    argument or add a final vertex that connects with the start. However, an active
    `fill()` will fill in color regardless ([Figure 2-16](#figure2-16)).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 形状不会自动闭合，除非你包含一个`endShape(CLOSE)`参数，或者添加一个与起点连接的最终顶点。然而，活跃的`fill()`会填充颜色， 无论如何（[图
    2-16](#figure2-16)）。
- en: '![f02016](image_fi/500969c02/f02016.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![f02016](image_fi/500969c02/f02016.png)'
- en: 'Figure 2-16: Despite the open side, the shape is filled with color.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-16：尽管有一侧是开放的，形状仍然填充了颜色。
- en: You also can provide various parameters to the `beginShape()` function to determine
    how the enclosed vertices are connected, if at all ([Figure 2-17](#figure2-17)).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为`beginShape()`函数提供各种参数，以确定封闭顶点之间是否连接（如果有的话）（[图 2-17](#figure2-17)）。
- en: '![f02017](image_fi/500969c02/f02017.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![f02017](image_fi/500969c02/f02017.png)'
- en: 'Figure 2-17: The functions `beginShape(POINTS)` (left), and `beginShape(LINES)`
    (right)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-17：`beginShape(POINTS)`（左）和`beginShape(LINES)`（右）函数
- en: For a shape composed of only dots, use `beginShape(POINTS)`. For a line between
    every other vertex, use `beginShape(LINES)`. Consult the reference for more details
    on `beginShape()` arguments.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对于仅由点组成的形状，使用`beginShape(POINTS)`。对于每隔一个顶点之间的线条，使用`beginShape(LINES)`。有关`beginShape()`参数的更多细节，请参考文档。
- en: Bézier Vertices
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Bézier顶点
- en: The `bezierVertex()` function allows you to draw curved lines between vertices.
    A `curveVertex()` function is also available for Catmull-Rom-type curves, but
    this book focuses on the Bézier type, as it provides for greater control and more
    graceful curves.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`bezierVertex()`函数允许你在顶点之间绘制曲线。还可以使用`curveVertex()`函数来绘制Catmull-Rom类型的曲线，但本书侧重于Bézier类型，因为它提供了更大的控制力和更优美的曲线。'
- en: The `bezierVertex()` function takes six arguments. To understand how those arguments
    operate, you’ll work toward completing the remaining shapes shown in [Figure 2-18](#figure2-18).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`bezierVertex()`函数有六个参数。为了理解这些参数的作用，你将继续完成[图 2-18](#figure2-18)中显示的其他形状。'
- en: I have manually added the pale blue lines, the dotted tips of which provide
    a visual indication of the control points. Use these lines for reference purposes
    only; you don’t need to redraw them.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我手动添加了淡蓝色的线条，其虚线的尖端提供了控制点的视觉指示。仅将这些线条作为参考使用；你不需要重新绘制它们。
- en: '![f02018](image_fi/500969c02/f02018.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![f02018](image_fi/500969c02/f02018.png)'
- en: 'Figure 2-18: A Chinese coin (lower left), S-curve (middle), and heart (right)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-18：一枚中国硬币（左下），S曲线（中间），和心形（右）
- en: S-Curve
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: S曲线
- en: The *S-curve* is just a curved line that comprises two vertices, with each vertex
    attached to its own control point. You’ll draw it with a `bezierVertex()` function
    to keep this first example as simple as possible, but ordinarily, you would draw
    an S-curve by using `bezier()`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*S曲线*只是一个弯曲的线条，包含两个顶点，每个顶点都连接着自己的控制点。你将使用`bezierVertex()`函数来绘制它，以便将这个第一个示例保持尽可能简单，但通常，你会使用`bezier()`来绘制S曲线。'
- en: 'Within `beginShape()` and `endShape()`, combine the `bezierVertex()` and `vertex()`
    functions however necessary. Your first point, however, is always created with
    `vertex()`. Begin a new shape and plot the first (in this case, upper) vertex:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在`beginShape()`和`endShape()`之间，根据需要组合使用`bezierVertex()`和`vertex()`函数。然而，首先的顶点总是通过`vertex()`来创建。开始一个新的形状并绘制第一个（在这种情况下是上方）顶点：
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Run the sketch. There is no second vertex with which to form a line, so the
    isolated vertex should appear as a point at (400, 200).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 运行草图。由于没有第二个顶点来形成一条线，因此孤立的顶点应该显示为(400, 200)处的一个点。
- en: 'Now add the second vertex by using `bezierVertex()`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在通过使用`bezierVertex()`添加第二个顶点：
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The last pair of `bezierVertex()` arguments (`400, 600`) denotes the position
    of the second (lower) vertex. The second vertex is attached to a control point
    positioned by the second pair of arguments (`500, 500`). The first pair of arguments
    (`300, 300`) represents the control point for the `vertex()` function that immediately
    precedes `bezierVertex()`. With the positions of the vertices presented for you
    in the reference image ([Figure 2-18](#figure2-18)), creating this shape ([Figure
    2-19](#figure2-19)) is really just a matter of typing in the correct sequence
    of coordinates.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一对`bezierVertex()`参数（`400, 600`）表示第二个（下方）顶点的位置。第二个顶点连接到由第二对参数（`500, 500`）定位的控制点。第一对参数（`300,
    300`）代表紧跟在`bezierVertex()`之前的`vertex()`函数的控制点。参考图像中给出的顶点位置（[图 2-18](#figure2-18)），创建这个形状（[图
    2-19](#figure2-19)）实际上只是输入正确的坐标顺序而已。
- en: '![f02019](image_fi/500969c02/f02019.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![f02019](image_fi/500969c02/f02019.png)'
- en: 'Figure 2-19: The complete S-curve'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-19：完整的S曲线
- en: This is an open shape, so it would look odd if filled. Next, you’ll examine
    a closed shape, but feel free to experiment with different vertex and control-point
    values before moving along.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个开放形状，如果填充会显得不自然。接下来，你将研究一个闭合形状，但在继续之前，随时可以尝试不同的顶点和控制点值。
- en: Heart
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 心形
- en: 'You can think of the heart shape as two curved lines connected to two vertices.
    To begin, draw one half of the heart ([Figure 2-20](#figure2-20)):'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将心形想象成由两条弯曲的线连接到两个顶点。首先，绘制心形的一半（[图 2-20](#figure2-20)）：
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '![f02020](image_fi/500969c02/f02020.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![f02020](image_fi/500969c02/f02020.png)'
- en: 'Figure 2-20: Half a heart'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-20：半个心形
- en: 'All that is left for you to do is complete the right half of the heart. Add
    a second `bezierVertex()` line and see if you can fill in the missing arguments:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要做的就是完成心形的右半部分。添加第二行`bezierVertex()`，看看能否填补缺失的参数：
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Refer back to [Figure 2-18](#figure2-18) to see where the control points lie.
    Remember that you can access all of the solutions to the challenges at [https://github.com/tabreturn/processing.py-book/](https://github.com/tabreturn/processing.py-book/).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 回到[图 2-18](#figure2-18)查看控制点的位置。记住，你可以访问所有挑战的解决方案，网址为[https://github.com/tabreturn/processing.py-book/](https://github.com/tabreturn/processing.py-book/)。
- en: Chinese Coin
  id: totrans-128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 中国硬币
- en: Round metal coins with square holes in the center were first introduced in China
    many centuries ago, but replicating that shape makes for a good example to learn
    Processing. To create the purple coin shape in [Figure 2-18](#figure2-18), you’ll
    use the `beginContour()` and `endContour()` functions to subtract a square from
    a circle.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 带有中间方孔的圆形金属硬币最早是在几百年前的中国出现的，但复制这种形状是学习Processing的一个好例子。要创建[图 2-18](#figure2-18)中的紫色硬币形状，你将使用`beginContour()`和`endContour()`函数从圆形中减去一个正方形。
- en: First, you’ll create the outer shape by using the `beginShape()`, `endShape()`,
    and `vertex()` functions. You’ll then place the `beginContour()` and `endContour()`
    functions within the `beginShape()` and `endShape()` functions. Within this pair
    of contour functions, you’ll draw a second shape that’s also composed of `vertex()`
    and `bezierVertex()` functions; the contour functions subtract this shape from
    the outer shape.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你将使用`beginShape()`、`endShape()`和`vertex()`函数创建外形。然后，你将在`beginShape()`和`endShape()`函数中放置`beginContour()`和`endContour()`函数。在这对轮廓函数内，你将绘制一个第二个形状，它也由`vertex()`和`bezierVertex()`函数组成；轮廓函数会从外形中减去这个形状。
- en: The first challenge is creating the outer circle. The `beginContour()` and `endContour()`
    functions cannot subtract from predefined shape functions—like `rect()`, `ellipse()`,
    or `circle()`—so you need to construct the outer circle by using vertices. However,
    it is possible to draw circles by using Bézier curves, which you’ll do by creating
    a diamond and then using the control points to form it into something round.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个挑战是创建外圆。`beginContour()`和`endContour()`函数无法从预定义的形状函数（如`rect()`、`ellipse()`或`circle()`）中减去，因此你需要通过使用顶点来构造外圆。然而，使用贝塞尔曲线绘制圆形是可行的，你将通过创建一个菱形并使用控制点将其形成圆形。
- en: 'Begin by forming a diamond shape with `vertex()` functions (shown in [Figure
    2-21](#figure2-21)):'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 从用`vertex()`函数形成一个菱形开始（如[图 2-21](#figure2-21)所示）：
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '![f02021](image_fi/500969c02/f02021.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![f02021](image_fi/500969c02/f02021.png)'
- en: 'Figure 2-21: The diamond shape that you’ll form into a circle'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-21：你将形成圆形的菱形
- en: With the vertices in the correct positions, you can proceed to add curvature
    to the diamond. Of course, this will require `bezierVertex()` functions, for which
    you’ll reference the coordinates of the vertices currently in place. For an idea
    of where to position the additional control-point coordinates, see [Figure 2-22](#figure2-22).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶点定位正确后，你可以继续为菱形添加曲线。当然，这将需要`bezierVertex()`函数，你将参考当前定位的顶点坐标。要了解如何定位额外的控制点坐标，请参见[图
    2-22](#figure2-22)。
- en: '![f02022](image_fi/500969c02/f02022.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![f02022](image_fi/500969c02/f02022.png)'
- en: 'Figure 2-22: Positioning vertices and control points to form a circle'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-22：定位顶点和控制点以形成圆形
- en: '[Figure 2-22](#figure2-22) indicates how the control points should be positioned
    to form the most circular shape. Now replace each `vertex()` with a `bezierVertex()`
    function. Remember, though, that the first point must remain a `vertex()` to form
    your circle ([Figure 2-23](#figure2-23)):'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-22](#figure2-22)显示了控制点应该如何定位，以形成最圆的形状。现在将每个`vertex()`替换为`bezierVertex()`函数。记住，第一点必须保留为`vertex()`，以形成圆形（[图
    2-23](#figure2-23)）：'
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '![f02023](image_fi/500969c02/f02023.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![f02023](image_fi/500969c02/f02023.png)'
- en: 'Figure 2-23: A circle formed using `bezierVertex``(``)` functions'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-23：使用`bezierVertex``(``)`函数形成的圆形
- en: 'With the circle in place, you can go about removing a square from the middle.
    Once again, define this square by using vertices and not a predefined shape function,
    like `rect()` or `square()`. This is a relatively straightforward exercise, but
    be aware that you need to use *reverse winding* for the subtracted shape: you
    must lay the vertices of the square in a direction that’s opposite to the one
    you used to place the vertices of the exterior shape (the circle).'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在圆形到位后，你可以开始从中间移除正方形。同样，通过使用顶点而不是预定义的形状函数（如`rect()`或`square()`）来定义这个正方形。这是一个相对简单的练习，但请注意，你需要为被减去的形状使用*反向旋转*：你必须将正方形的顶点按与放置外部形状（圆形）顶点相反的方向排列。
- en: Read through the circle code again and notice that the vertices are plotted
    in a clockwise sequence; this means that the square’s vertices must be plotted
    counterclockwise—that is, opposite to the winding of the shape from which it will
    subtract. If you fail to get this direction correct, no subtraction will take
    place.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 再次阅读圆形的代码，并注意顶点是按顺时针顺序绘制的；这意味着正方形的顶点必须按逆时针顺序绘制——也就是说，与其将要减去的形状的旋转方向相反。如果你没有正确设置这个方向，将不会发生减去操作。
- en: 'Place the square’s vertices within a `beginContour()` and `endContour()` function.
    Of course, you can’t observe the effect (shown in [Figure 2-24](#figure2-24))
    unless you add a fill:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 将正方形的顶点放入`beginContour()`和`endContour()`函数中。当然，除非你添加填充，否则你无法看到效果（如[图 2-24](#figure2-24)所示）：
- en: '[PRE18]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '![f02024](image_fi/500969c02/f02024.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![f02024](image_fi/500969c02/f02024.png)'
- en: 'Figure 2-24: The completed coin'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-24：完成的硬币
- en: Without the fill 1, you would see only white outlines. The `beginContour()`
    function 2 starts recording the vertices that make up the negative shape. No `bezierVertex()`
    functions are necessary, because a square has no curves. The vertices follow a
    counterclockwise sequence, beginning at the upper left corner of the square (`180,
    580`), proceeding directly downward (to `180, 620`) and then farther around before
    the `endContour()` stops recording 3.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有填充 1，你只会看到白色的轮廓。`beginContour()`函数 2 开始记录组成负形状的顶点。不需要`bezierVertex()`函数，因为正方形没有曲线。顶点按逆时针顺序排列，从正方形的左上角（`180,
    580`）开始，直接向下（到`180, 620`），然后继续绕行，直到`endContour()`停止记录 3。
- en: Using Vector Graphics Software for Generating Shapes
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用矢量图形软件生成形状
- en: You can use vector graphics drawing software to draw shapes, and then reference
    the positions of the vertices and control points for writing Processing code.
    This is how I mapped out the blue guidelines for the Python logo shown in [Figure
    2-25](#figure2-25).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用矢量图形绘图软件来绘制形状，然后引用顶点和控制点的位置来编写 Processing 代码。这就是我如何绘制出[图 2-25](#figure2-25)中显示的
    Python 徽标的蓝色参考线。
- en: '![f02025](image_fi/500969c02/f02025.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![f02025](image_fi/500969c02/f02025.png)'
- en: 'Figure 2-25: Tracing a Python logo that includes the positions of the vertices
    and control points. (The Python Software Foundation logo trademark policy is available
    at [https://www.python.org/psf/trademarks/](https://www.python.org/psf/trademarks/).)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-25：追踪包含顶点和控制点位置的 Python 徽标。（Python 软件基金会的徽标商标政策可在[https://www.python.org/psf/trademarks/](https://www.python.org/psf/trademarks/)查看。）
- en: 'If you’re up for a challenge, clear out your *curves* sketch and try finishing
    the half of the Python logo I’ve begun in [Figure 2-25](#figure2-25). Here is
    some code to get the outline started:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢挑战，可以清除你的*曲线*草图，尝试完成我在[图 2-25](#figure2-25)中开始绘制的 Python 徽标的半部分。这里有一些代码可以帮助你开始绘制轮廓：
- en: '[PRE19]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You can also export vector graphics as SVG files for use in Processing with
    the `loadShape()` and `shape()` functions, as opposed to the `loadImage()` and
    `image()` functions. But be warned: SVG support is not always dependable, and
    you may spend some time fiddling with your SVG export settings to get them to
    display properly in Processing.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以将矢量图形导出为 SVG 文件，以便在 Processing 中使用`loadShape()`和`shape()`函数，而不是使用`loadImage()`和`image()`函数。但请注意：SVG
    支持并不总是可靠的，你可能需要花一些时间调整你的 SVG 导出设置，以确保它们在 Processing 中正确显示。
- en: Summary
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: You’ve now learned most of Processing’s essential drawing features. Using a
    grid graphic as a reference for your coordinates, you learned to plot curves that
    mimic physical splines. In addition, you learned to draw Bézier curves—smooth,
    graceful curves that you can control with anchor and control points. You also
    saw how to draw shapes by using a series of vertices. When you connect vertices
    with straight lines and curves, the shape possibilities are limitless. You’ll
    be using curves, vertices, and the skills you learned in Chapter 1 in many of
    the tasks to come.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经学习了Processing的大部分基本绘图功能。通过使用网格图形作为坐标参考，你学会了绘制模拟物理样条曲线的曲线。此外，你还学会了绘制贝塞尔曲线——这是一种平滑、优雅的曲线，你可以通过锚点和控制点来控制它们。你还了解了如何通过一系列顶点来绘制形状。当你用直线和曲线连接顶点时，形状的可能性是无限的。你将在接下来的许多任务中，运用曲线、顶点和第1章中学到的技能。
- en: In Chapter 3, you’ll move on to explore Processing’s text features. This includes
    drawing text to the display window, styling it, and loading fonts. You’ll also
    look at Python’s built-in features for manipulating string data. Later in this
    book, you’ll use text functions to label graphs and graphical interface elements,
    and to add speech bubbles to images.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3章中，你将开始探索Processing的文本功能。这包括将文本绘制到显示窗口、对其进行样式设置以及加载字体。你还将了解Python内置的字符串数据处理功能。在本书后续的章节中，你将使用文本功能为图表和图形界面元素添加标签，并为图像添加对话气泡。
