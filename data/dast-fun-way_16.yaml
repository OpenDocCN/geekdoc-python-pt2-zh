- en: Conclusion
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: Throughout this book, we examined a range of different data structures, how
    they impact the algorithms that use them, and whether they can aid us in our search
    for coffee. We showed how the organization of the data can lead to significant
    decreases in computational cost or changes to an algorithm’s behavior. We looked
    at the tradeoffs between different representations and why they matter. In doing
    so, we tried to provide an intuitive foundation for how to think about data structures.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们考察了多种不同的数据结构，了解它们如何影响使用它们的算法，以及它们是否能帮助我们找到咖啡。我们展示了数据的组织如何导致计算成本的显著减少或算法行为的变化。我们审视了不同表示方式之间的权衡以及它们为何重要。在此过程中，我们尝试为如何思考数据结构提供一个直观的基础。
- en: Understanding each data structure’s motivation, construction, uses, and tradeoffs
    is critical in order to use them in the development of efficient solutions. If
    you randomly choose a data structure that looks “good enough,” you can run into
    worst-case scenarios and terrible performance. Below we revisit some core themes
    from the preceding chapters in order to highlight some of the questions that every
    computer science practitioner should ask when selecting a data structure.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 理解每种数据结构的动机、构造方式、用途和权衡取舍是至关重要的，这样才能在开发高效解决方案时正确使用它们。如果你随便选择一个看起来“足够好”的数据结构，可能会遇到最坏的情况，导致性能差到无法忍受。接下来，我们将回顾前面章节中的一些核心主题，以强调每个计算机科学从业者在选择数据结构时应该问的一些问题。
- en: What Is the Impact of the Data’s Structure?
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据结构的影响是什么？
- en: Starting with binary search in Chapter 2, we saw how adding even a small amount
    of structure to the data can greatly impact the efficiency of algorithms. Structure
    within the data allows us to efficiently access values, aggregate computations,
    or prune out regions of the search space. As in the case of binary search, this
    structure can be as simple as putting the data in sorted order. This single change
    allows us to cut the worst-case runtime, changing its relationship to the number
    of values from linear to logarithmic. Similarly, organizing our coffee pantry
    can optimize our coffee making experience in different ways—most often in reducing
    the time needed to make our first cup.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 从第二章的二分查找开始，我们看到即使是对数据进行少量的结构化处理，也能大大提高算法的效率。数据中的结构使我们能够高效地访问值、聚合计算，或裁剪搜索空间的区域。就像二分查找的例子一样，这种结构可以简单到仅仅是将数据排序。这个简单的改变让我们能够将最坏情况下的运行时间缩短，并将其与值的数量的关系从线性转变为对数级别。类似地，整理我们的咖啡储藏室也能在不同的方面优化我们的咖啡制作体验——最常见的是减少制作第一杯咖啡所需的时间。
- en: 'Binary search trees, tries, quadtrees, and k-d trees showed us how to further
    facilitate pruning during a search. Tree-based data structures provide an explicit
    branching organization that allows us to prune out large regions of the search
    space with simple tests. We encode the bounds of the data into the structure of
    the trees and the nodes themselves. Further, the branching nature of the data
    allows us to clearly visualize the question we ask at each level: “Given bounds
    on the points lying below this node in a tree, could the point of interest be
    in this subtree?”'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉查找树、字典树、四叉树和k-d树向我们展示了如何在搜索过程中进一步促进剪枝。基于树的数据结构提供了一种显式的分支组织，使我们能够通过简单的测试裁剪掉搜索空间中的大区域。我们将数据的边界编码到树的结构和节点本身中。此外，数据的分支性质使我们能够清晰地可视化每一层次我们提出的问题：“考虑到这个节点下方的点的边界，感兴趣的点是否可能在这个子树中？”
- en: 'Even if we don’t actively optimize the data’s organization for the algorithm
    at hand, its arrangement can profoundly impact the behavior and efficiency of
    our algorithms, as stacks and queues demonstrate. Switching from a stack to a
    queue, for example, moves a search from depth-first to breadth-first. In the extreme
    case, the structure of the data requires the development of completely new algorithmic
    approaches: graphs’ connection-based structure drives a range of new algorithms
    to search, sort, and perform other computations.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们没有主动为当前算法优化数据的组织方式，它的排列也会深刻影响我们算法的行为和效率，正如栈和队列所展示的那样。例如，从栈切换到队列会将搜索从深度优先改为广度优先。在极端情况下，数据的结构要求开发全新的算法方法：图的连接结构驱动了一系列新的算法，用于搜索、排序和执行其他计算。
- en: Do We Need Dynamic Data Structures?
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们需要动态数据结构吗？
- en: Dynamic data structures dramatically increase the flexibility and adaptability
    of our approaches. Using these structures means we’re no longer constrained to
    preallocating blocks of memory that may turn out to be too small for the task
    at hand. Instead, we can link locations throughout the memory with pointers, allowing
    our data structures to grow and shrink as necessary. Most importantly, dynamic
    data structures allow us to continually grow our coffee log and store multiple
    coffee shop locations in our geographic grid cells.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 动态数据结构显著增强了我们方法的灵活性和适应性。使用这些结构意味着我们不再受限于预分配的内存块，这些内存块可能对当前任务来说太小。相反，我们可以通过指针将内存中的不同位置链接起来，使得我们的数据结构可以根据需要增长或缩小。最重要的是，动态数据结构让我们能够不断增加我们的咖啡记录，并在地理网格单元中存储多个咖啡店的位置。
- en: Dynamic data structures provide the foundation for some of the most exciting,
    interesting, and powerful algorithms in computer science. Almost every data structure
    described in this book takes advantage of pointers (or a related linkage) to organize
    the data across different blocks of memory. We used pointers to link the nodes
    in a binary search tree, create linked lists in both our grid cells and hash table
    bins, and represent the very structure of graphs.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 动态数据结构为计算机科学中一些最激动人心、有趣且强大的算法提供了基础。几乎本书中描述的每一个数据结构都利用了指针（或相关的链接）来组织内存中不同块的数据。我们使用指针将二叉搜索树中的节点连接起来，在网格单元和哈希表桶中创建链表，并表示图的结构。
- en: The tradeoff for this power and flexibility is additional complexity when accessing
    the data. In an array, we can look up any item given its index. However, this
    direct approach doesn’t work once pointers are involved. Our search for a particular
    piece of data must follow the chain of pointers through the memory, whether across
    the nodes of a linked list, down the nodes in a tree, or across the nodes in a
    graph. Depending on the arrangement of these pointers (linked list versus search
    tree), we may make the operations more or less efficient for the task at hand.
    We always need to understand how the algorithms will use the structure. It’s not
    enough just to buy a piece of fancy coffee-making equipment; we need to understand
    how to use it.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这种强大与灵活性的代价是，访问数据时会增加额外的复杂性。在数组中，我们可以根据索引查找任何项目。然而，一旦涉及指针，这种直接访问方式就不再适用。我们必须通过内存中的指针链条来查找特定的数据，无论是通过链表的节点、树的节点，还是图中的节点。根据这些指针的排列（链表与搜索树），我们可能会使操作对当前任务的效率更高或更低。我们始终需要理解算法如何使用数据结构。仅仅购买一台花哨的咖啡机是远远不够的；我们需要了解如何使用它。
- en: What Is the Amortized Cost?
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是摊销成本？
- en: When considering whether to use any data structure, it’s important to take into
    account both the cost of constructing the data structure and the savings it will
    enable. Sorting an array or constructing a binary search tree can be more expensive
    than scanning through the data to find a single value. It’s almost always the
    case that searching once through each data point is more efficient than constructing
    an auxiliary data structure. Yet the math changes as soon as we move beyond a
    single search.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑是否使用某个数据结构时，重要的是要同时考虑构建数据结构的成本和它带来的节省。对数组进行排序或构建二叉搜索树的成本可能比扫描数据以查找单个值更高。几乎总是情况下，通过扫描每个数据点一次进行搜索，比构建一个辅助数据结构更为高效。然而，当我们进行多次搜索时，数学上的计算就会发生变化。
- en: Sorted arrays, binary search trees, and other data structures are useful because
    they reduce the cost of *all* future searches. If we pay a one-time *N* log[2](*N*)
    cost to sort an array of integers, we can then perform as many log[2](*N*) binary
    searches as we want. We win because we amortize the cost of sorting the data over
    many future searches. In the same way, sorting cartons of milk in our refrigerator
    by expiration date can save us precious seconds during retrieval.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 排序数组、二叉搜索树以及其他数据结构之所以有用，是因为它们减少了*所有*未来搜索的成本。如果我们付出一次性的*N* log[2](*N*)成本来对一个整数数组进行排序，那么我们可以根据需要执行任意次数的log[2](*N*)二叉搜索。我们之所以能节省成本，是因为我们将排序数据的成本摊销到许多未来的搜索中。同样地，在冰箱里按过期日期对牛奶盒进行排序，可以在取用时节省宝贵的几秒钟。
- en: How Can We Adapt Data Structures to a Specific Problem?
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们如何将数据结构适应特定问题？
- en: Basic data structures provide not only a set of tools that are useful in their
    own right but also a foundation on which to build more adaptive and specialized
    approaches. With the trie, we examined how to extend the branching structure of
    the binary search tree to a higher branching factor that enables efficient search
    over strings. We saw how linked lists provide a second level of flexibility to
    handle collisions in a hash table or multiple items in a grid cell.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 基本数据结构不仅提供了一组本身有用的工具，还为构建更具适应性和专门化的方法奠定了基础。通过前缀树（trie），我们研究了如何将二叉搜索树的分支结构扩展到更高的分支因子，从而实现对字符串的高效搜索。我们还看到了链表如何提供第二层灵活性，以处理哈希表中的碰撞或网格单元中的多个项。
- en: Spatial data structures provide an excellent example of our ability to adapt,
    combine, and refine data structures. Combining the spatial partitioning of grids
    with a tree-based structure gives us the adaptive structure of a quadtree. However,
    both grids and quadtrees break down in higher dimensions. We saw how k-d trees
    adapt spatial data structures to split along a single dimension at each branch,
    not only helping the structure scale to higher dimensions but also improving its
    pruning power. As we consider new coffee-related problems, such as matching logos
    or optimizing the parameters of our brewing equipment, we should reexamine and
    potentially adapt the approaches in our toolbox to the specifics of the problem.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 空间数据结构很好地展示了我们适应、结合和优化数据结构的能力。将网格的空间划分与基于树的结构相结合，给我们带来了四叉树的适应性结构。然而，网格和四叉树在高维空间中都会出现问题。我们看到k-d树如何通过在每个分支沿着单一维度进行划分，帮助空间数据结构适应更高维度，不仅使得该结构能够扩展到更高维度，还提高了其剪枝能力。在考虑新的与咖啡相关的问题时，例如匹配标志或优化我们的冲泡设备的参数时，我们应该重新审视并可能根据问题的具体情况调整我们工具箱中的方法。
- en: What Are the Memory vs. Runtime Tradeoffs?
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存与运行时的权衡是什么？
- en: The tradeoff of memory and runtime is a classic consideration in computer science.
    We can often significantly decrease the cost of an algorithm by precomputing and
    storing additional data. Heaps allow us to efficiently find and extract the minimal
    (or maximal) element in a list, either within search algorithms or as an auxiliary
    data structure. The tradeoff is the cost of the heap itself. We use extra memory
    in a linear relationship to the size of the data we want to store. Similarly,
    by using extra memory to build a quadtree or k-d tree, we can drastically decrease
    the runtime of future nearest-neighbor searches.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 内存和运行时间的权衡是计算机科学中的经典问题。我们通常可以通过预计算并存储额外的数据显著减少算法的成本。堆允许我们在列表中高效地查找和提取最小（或最大）元素，无论是在搜索算法中还是作为辅助数据结构。其权衡是堆本身的开销。我们使用的额外内存与我们想要存储的数据大小成线性关系。类似地，通过使用额外的内存来构建四叉树或k-d树，我们可以大幅减少未来最近邻搜索的运行时间。
- en: Even within data structures, this tradeoff holds. We can decrease the collision
    rate in a hash table by increasing its size. Storing additional information in
    a linked list allows us to implement a skip list and realize better average performance
    for searches. Similarly, precomputing the bounds of spatial tree nodes and storing
    them in the node may allow us to more efficiently test whether we can prune a
    node.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在数据结构内部，这种权衡仍然存在。我们可以通过增加哈希表的大小来减少碰撞率。在链表中存储额外的信息使我们能够实现跳表，从而在搜索时获得更好的平均性能。类似地，预计算空间树节点的边界并将其存储在节点中，可能使我们能够更高效地测试是否可以剪枝该节点。
- en: It is critical to understand these tradeoffs and adapt them to a given project’s
    environment. Is the video game you are writing going to run on a personal computer,
    mobile device, or large server in a data center? Low memory environments might
    call for different approaches than high memory environments. The size of our coffee
    pantry will impact not only the total amount of coffee we can store but also whether
    adding brightly colored dividers is worth it. In a large pantry—such as a bedroom
    converted to a storage area, perhaps—the dividers might help us find coffee faster.
    In a small pantry, such as the kitchen cabinet, they might just cost us precious
    shelf space.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这些权衡并将其适应于特定项目的环境是至关重要的。你正在编写的视频游戏是要运行在个人电脑、移动设备，还是数据中心的大型服务器上？低内存环境可能需要与高内存环境不同的方法。我们的咖啡储藏室的大小不仅会影响我们能存储的咖啡总量，还会影响是否值得添加明亮的隔板。在一个大型储藏室中——例如可能将卧室改造成储物区——隔板可能帮助我们更快找到咖啡。而在一个小型储藏室中，比如厨房的橱柜，隔板可能只是占用了宝贵的货架空间。
- en: How Can We Tune Our Data Structure?
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何调整我们的数据结构？
- en: Some data structures have parameters that greatly impact the performance of
    operations. The performance of grids on a nearest-neighbor search is highly dependent
    on the number and granularity of the grid cells. Similarly, the size parameter
    *k* of B-trees allows us to adapt the size of each node to our local memory. These
    parameters almost always depend on the context in which we use the data structure.
    There is no one perfect setting.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一些数据结构有影响操作性能的参数。网格在最近邻搜索中的性能高度依赖于网格单元的数量和粒度。类似地，B 树的大小参数*k*使我们能够根据本地内存调整每个节点的大小。这些参数几乎总是依赖于我们使用数据结构的上下文。没有一个完美的设置。
- en: It is important to understand how a data structure’s parameters impact performance
    and how they depend on the specifics of the problem. In some cases, we can analytically
    determine what parameter to use. For example, we can choose the size parameter
    *k* for a B-tree using information about the size of memory blocks on the device
    where our code will run. We choose *k* so that a full B-tree node fits snuggly
    in the memory block, allowing us to retrieve the maximum amount of data with a
    single access.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 理解数据结构的参数如何影响性能以及它们如何依赖于问题的具体情况非常重要。在某些情况下，我们可以通过分析确定使用哪个参数。例如，我们可以根据运行代码的设备的内存块大小来选择
    B 树的大小参数*k*。我们选择*k*的方式是让一个完整的 B 树节点恰好适应内存块，从而使我们能够通过一次访问获取最大量的数据。
- en: Other times, we may need to empirically test different parameters on real data.
    One simple approach is to use the data with a range of parameter settings and
    see which one performs best.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们可能需要在真实数据上通过实证测试不同的参数。一种简单的方法是使用具有一系列参数设置的数据，并查看哪种设置的性能最佳。
- en: How Does Randomization Impact Expected Behavior?
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 随机化如何影响预期行为？
- en: When examining binary search trees and hash tables, we noted that both data
    structures’ worst-case performance could degrade to linear time. If we insert
    sorted items into a binary search tree or choose a bad hash function for the data,
    we effectively end up with linked lists. The performance of our data structures
    isn’t guaranteed to be optimal under all conditions but depends on the data itself.
    Sometimes the best we can do is improve expected (or average case) runtime.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查二叉搜索树和哈希表时，我们注意到这两种数据结构的最坏情况性能可能会退化为线性时间。如果我们将排序的项插入到二叉搜索树中，或者为数据选择了不良的哈希函数，我们实际上会得到链表。我们的数据结构的性能在所有条件下并不总是最优的，而是依赖于数据本身。有时我们能做的最好的事就是提高预期的（或平均情况）运行时。
- en: Understanding the possibility of extreme performance is critical to choosing
    and tuning the best data structure for your problem. When choosing the parameters
    of a hash table, we want to select a table size large enough to lower the probability
    of collisions while avoiding wasted memory. More critical is the choice of hash
    function, which, for hash tables, requires us to understand the distribution of
    keys. If the keys themselves have structure, such as consisting only of even numbers,
    we need to pick a hash function that is robust to that structure. Similarly, if
    we are organizing a conference for coffee lovers whose last name starts with *K*,
    the registration table shouldn’t partition attendees by the first letter of their
    last name.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 理解极端性能的可能性对于选择和调整最佳数据结构至关重要。在选择哈希表的参数时，我们希望选择一个足够大的表大小，以降低冲突的概率，同时避免浪费内存。更为关键的是哈希函数的选择，对于哈希表来说，这要求我们了解键的分布。如果键本身有结构，比如只包含偶数，我们需要选择一个对该结构有鲁棒性的哈希函数。类似地，如果我们正在为一个咖啡爱好者会议组织注册，而这些人的姓氏首字母都是*K*，那么注册表不应该根据他们姓氏的首字母来划分与会者。
- en: We can mitigate the impact of pathologically bad data somewhat by randomizing
    the data structure itself. If we are always adding data into a binary search tree
    in sorted order, we effectively end up with a linked list. Skip lists provide
    a technique for intentionally injecting randomness into the level of our list
    nodes to provide, on average, logarithmic running times. Randomization isn’t a
    cure-all, though. Skip lists may choose bad heights by chance. In the worst case,
    like linked lists, skip lists’ performance degrades to be linear in the size of
    the data. However, the odds that they do so are small, and we can expect them
    to perform well on average, even in the face of pathologically bad data.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过随机化数据结构本身来在一定程度上缓解病态坏数据的影响。如果我们总是按排序顺序将数据插入到二叉搜索树中，实际上最终会得到一个链表。跳表提供了一种技术，通过故意在我们的列表节点层级中注入随机性，平均来说，可以实现对数时间复杂度的运行时间。然而，随机化并不是万能的。跳表可能会因运气不佳而选择错误的高度。在最坏的情况下，像链表一样，跳表的性能会退化到与数据大小成线性关系。然而，它们发生这种情况的概率很小，我们可以预期它们在平均情况下会表现良好，即使面对病态坏数据。
- en: Why This Matters
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么这很重要
- en: There is no one perfect data structure in computer science. It would be fantastic
    if we could point to a single data structure and say, “Always use X,” but unfortunately,
    it’s not that simple. All data structures come with their own tradeoffs of complexity,
    performance, memory usage, and accuracy.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学中没有一种完美的数据结构。如果我们能指着某一个数据结构说：“总是使用X”，那该多好，但不幸的是，事情并没有那么简单。所有的数据结构都有其复杂性、性能、内存使用和准确性的权衡。
- en: Throughout this book, we examined a sampling of different data structures, their
    tradeoffs, and how they could impact algorithms. Our coverage was far from exhaustive;
    there’s a wide range of data structures further optimized for individual algorithms,
    problems, or domains. For example, red-black trees provide a self-balancing extension
    of binary search trees, while metric trees provide a different approach to spatial
    partitioning for higher-dimensional data. Both these approaches, and the hundreds
    of other impressive data structures out there, come with their own sets of tradeoffs
    and optimal use cases. We barely scratched the surface of the rich and complex
    world of data structures.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们考察了不同数据结构的样本，它们的权衡，以及它们如何影响算法。我们的讨论远非详尽无遗；还有很多数据结构专门为特定算法、问题或领域进行了优化。例如，红黑树提供了二叉搜索树的自平衡扩展，而度量树则为高维数据提供了不同的空间划分方法。这两种方法，以及其他成百上千种令人印象深刻的数据结构，都有自己的一套权衡和最佳使用场景。我们仅仅触及了数据结构这一丰富而复杂的世界的表面。
- en: This book aimed to encourage you to think carefully about how to store and organize
    your data. As much as specific programming languages or clever algorithms, data
    structures can have a material impact on the performance, accuracy, and complexity
    of your programs. It’s important for all computer science practitioners to understand
    not only the specifics of individual data structures but also how those data structures
    function in the broader context of the problem they are trying to solve.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 本书旨在鼓励你仔细思考如何存储和组织数据。像特定的编程语言或巧妙的算法一样，数据结构对程序的性能、准确性和复杂度有着实际的影响。所有计算机科学从业者不仅需要理解各个数据结构的具体内容，还要了解这些数据结构在解决问题的更广泛背景中的功能。
- en: Especially if coffee is involved.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是当涉及到咖啡时。
