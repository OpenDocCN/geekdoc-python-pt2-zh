- en: '1'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '1'
- en: SAVING SHIPWRECKED SAILORS WITH BAYES’ RULE
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用贝叶斯定理拯救海上遇难海员
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/common.jpg)'
- en: Sometime around 1740, an English Presbyterian minister named Thomas Bayes decided
    to mathematically prove the existence of God. His ingenious solution, now known
    as *Bayes’ rule*, would become one of the most successful statistical concepts
    of all time. But for 200 years it languished, largely ignored, because its tedious
    mathematics were impractical to do by hand. It took the invention of the modern
    computer for Bayes’ rule to reach its full potential. Now, thanks to our fast
    processors, it forms a key component of data science and machine learning.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 大约在1740年左右，一位名叫托马斯·贝叶斯的英国长老会牧师决定用数学证明上帝的存在。他的独特解决方案——现在被称为*贝叶斯定理*——成为了有史以来最成功的统计概念之一。但由于其繁琐的数学计算无法手动完成，这个定理在200年里几乎被忽视。直到现代计算机的发明，贝叶斯定理才发挥出它的全部潜力。如今，得益于我们快速的处理器，它已经成为数据科学和机器学习的重要组成部分。
- en: Because Bayes’ rule shows us the mathematically correct way to incorporate new
    data and recalculate probability estimates, it penetrates almost all human endeavors,
    from cracking codes to picking presidential winners to demonstrating that high
    cholesterol causes heart attacks. A list of applications of Bayes’ rule could
    easily fill this chapter. But since nothing is more important than saving lives,
    we’ll focus on the use of Bayes’ rule to help save sailors lost at sea.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 因为贝叶斯定理为我们提供了一个数学上正确的方式来纳入新数据并重新计算概率估计，它几乎渗透到了所有人类活动中，从破解密码到预测总统选举结果，再到证明高胆固醇会导致心脏病发作。贝叶斯定理的应用列表足以填满这一章。但因为没有什么比拯救生命更重要，我们将专注于如何利用贝叶斯定理帮助救援失事海员。
- en: In this chapter, you’ll create a simulation game for a Coast Guard search and
    rescue effort. Players will use Bayes’ rule to guide their decisions so they can
    locate the sailor as quickly as possible. In the process, you’ll start working
    with popular computer vision and data science tools like Open Source Computer
    Vision Library (OpenCV) and NumPy.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将创建一个模拟游戏，用于海岸警卫队的搜救行动。玩家将使用贝叶斯定理来指导决策，以便尽快定位失踪的海员。在此过程中，你将开始使用流行的计算机视觉和数据科学工具，如开源计算机视觉库（OpenCV）和NumPy。
- en: '**Bayes’ Rule**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**贝叶斯定理**'
- en: Bayes’ rule helps investigators determine the probability that something is
    true given new evidence. As the great French mathematician Laplace put it, “The
    probability of a cause—given an event—is proportional to the probability of the
    event—given its cause.” The basic formula is
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 贝叶斯定理帮助研究人员根据新证据确定某事是否成立的概率。正如伟大的法国数学家拉普拉斯所说：“一个原因的概率——给定一个事件——与这个事件的概率——给定它的原因——成正比。”基本公式是
- en: '![Image](../images/equ_page_2_01.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/equ_page_2_01.jpg)'
- en: where *A* is a hypothesis and *B* is data. *P*(*A*/*B*) means the probability
    of *A* given *B*. *P*(*B*/*A*) means the probability of *B* given *A*. For example,
    assume we know that a certain test for a certain cancer is not always accurate
    and can give false positives, indicating that you have cancer when you don’t.
    The Bayes expression would be
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，*A*是一个假设，*B*是数据。*P*(*A*/*B*)表示在给定*B*的情况下，*A*的概率。*P*(*B*/*A*)表示在给定*A*的情况下，*B*的概率。例如，假设我们知道某个癌症的检测并不总是准确，可能会出现假阳性，表示你得了癌症而实际上并没有。贝叶斯表达式为
- en: '![Image](../images/equ_page_2_02.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/equ_page_2_02.jpg)'
- en: The initial probabilities would be based on clinical studies. For example, 800
    out of 1,000 people who have cancer may receive a positive test result, and 100
    out of 1,000 may be misdiagnosed. Based on disease rates, the overall chance of
    a given person having cancer may only be 50 out of 10,000\. So, if the overall
    probability of having cancer is low and the overall probability of getting a positive
    test result is relatively high, the probability of having cancer given a positive
    test goes down. If studies have recorded the frequency of inaccurate test results,
    Bayes’ rule can correct for measurement errors!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 初始概率将基于临床研究。例如，1,000名患癌症的人中，800人可能会收到阳性检测结果，而100人可能会被误诊。根据疾病的发生率，一个人患癌症的总体概率可能仅为每10,000人中有50人。因此，如果患癌症的总体概率较低，而得到阳性检测结果的总体概率相对较高，那么在阳性检测结果下患癌症的概率就会降低。如果研究记录了不准确检测结果的频率，贝叶斯定理可以修正测量误差！
- en: Now that you’ve seen an example application, look at [Figure 1-1](ch01.xhtml#ch01fig1),
    which shows the names of the various terms in Bayes’ rule, along with how they
    relate to the cancer example.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了一个应用实例，请查看[图1-1](ch01.xhtml#ch01fig1)，它展示了贝叶斯定理中各个术语的名称，以及它们如何与癌症例子相关。
- en: '![Image](../images/fig01_01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig01_01.jpg)'
- en: 'Figure 1-1: Bayes’ rule with terms defined and related to the cancer test example'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-1：定义了术语并与癌症检测示例相关的贝叶斯定理
- en: 'To illustrate further, let’s consider a woman who has lost her reading glasses
    in her house. The last time she remembers wearing them, she was in her study.
    She goes there and looks around. She doesn’t see her glasses, but she does see
    a teacup and remembers that she went to the kitchen. At this point, she must make
    a choice: search the study more thoroughly or leave and check the kitchen. She
    decides to go to the kitchen. She has unknowingly made a Bayesian decision.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步说明，假设一位女士在家里丢失了她的阅读眼镜。她最后记得戴眼镜时是在书房。她去了书房并四处寻找。她没有找到眼镜，但看到了一个茶杯，并记得她去了厨房。此时，她必须做出选择：要么更加彻底地搜索书房，要么离开去厨房检查。她决定去厨房。她不知不觉中做出了一个贝叶斯决策。
- en: 'She went to the study first because she felt it offered the highest probability
    for success. In Bayesian terms, this initial probability of finding the glasses
    in the study is called the *prior*. After a cursory search, she changed her decision
    based on two new bits of information: she did not easily find the glasses, and
    she saw the teacup. This represents a *Bayesian update*, in which a new posterior
    estimate (*P*(*A*/*B*) in [Figure 1-1](ch01.xhtml#ch01fig1)) is calculated as
    more evidence becomes available.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 她首先去了书房，因为她觉得在书房找到眼镜的成功概率最高。从贝叶斯的角度来看，最初在书房找到眼镜的概率被称为*先验*。经过简略的搜索后，她根据两个新获得的信息改变了决定：她没有轻易找到眼镜，而且她看到了茶杯。这代表了一个*贝叶斯更新*，其中随着更多证据的出现，新的后验估计（在[图
    1-1](ch01.xhtml#ch01fig1)中为*P*(*A*/*B*)）被计算出来。
- en: Let’s imagine that the woman decided to use Bayes’ rule for her search. She
    would assign actual probabilities both to the likelihood of the glasses being
    in either the study or the kitchen and to the effectiveness of her searches in
    the two rooms. Rather than intuitive hunches, her decisions are now grounded in
    mathematics that can be continuously updated if future searches fail.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 假设这位女士决定在搜索过程中使用贝叶斯定理。她会为眼镜在书房或厨房中的可能性以及她在这两个房间中搜索的有效性分配实际的概率。与其凭直觉做决定，她的选择现在建立在数学基础上，如果未来的搜索失败，这些决策可以持续更新。
- en: '[Figure 1-2](ch01.xhtml#ch01fig2) illustrates the woman’s search for her glasses
    with these probabilities assigned.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 1-2](ch01.xhtml#ch01fig2)展示了这位女士在分配了这些概率后的眼镜搜索过程。'
- en: '![Image](../images/fig01_02.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig01_02.jpg)'
- en: 'Figure 1-2: Initial probabilities for the location of the glasses and search
    effectiveness (left) versus updated target probabilities for the glasses (right)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-2：眼镜位置的初始概率和搜索有效性（左）与更新后的眼镜目标概率（右）
- en: The left diagram represents the initial situation; the right diagram is updated
    with Bayes’ rule. Initially, let’s say there was an 85 percent chance of finding
    the glasses in the study and a 10 percent chance that the glasses are in the kitchen.
    Other possible rooms are given 1 percent because Bayes’ rule can’t update a target
    probability of zero (plus there’s always a small chance the woman left them in
    one of the other rooms).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧图表示最初的情况；右侧图是根据贝叶斯定理更新后的图。最初，假设在书房找到眼镜的概率是85%，在厨房找到眼镜的概率是10%。其他可能的房间被赋予1%的概率，因为贝叶斯定理无法更新为零的目标概率（而且总是有一个小概率她将眼镜落在其他房间）。
- en: Each number after a slash in the left diagram represents the *search effectiveness
    probability (SEP)*. The SEP is an estimate of how effectively you’ve searched
    an area. Because the woman has searched only in the study at this point, this
    value is zero for all other rooms. After the Bayesian update (the discovery of
    the teacup), she can recalculate the probabilities based on the search results,
    shown on the right. The kitchen is now the most likely place to look, but the
    probability for the other rooms increases as well.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 左图中每个斜杠后的数字代表*搜索有效性概率（SEP）*。SEP是对你搜索一个区域的有效性的估计。由于这位女士目前只在书房进行了搜索，因此其他房间的搜索有效性概率为零。在贝叶斯更新后（发现茶杯），她可以根据搜索结果重新计算概率，更新后的概率如右图所示。现在厨房是最可能的搜索地点，但其他房间的概率也有所增加。
- en: Human intuition tells us that if something isn’t where we think it is, the odds
    that it is someplace else go up. Bayes’ rule takes this into account, and thus
    the probability that the glasses are in other rooms increases. But this can happen
    only if there was a chance of them being in the other room in the first place.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 人类直觉告诉我们，如果某物不在我们认为它所在的地方，那么它出现在其他地方的概率就会增加。贝叶斯法则考虑到了这一点，因此眼镜出现在其他房间的概率也会增加。但只有在一开始就有它们可能出现在其他房间的情况时，这种情况才会发生。
- en: The formula used for calculating the probability that the glasses are in a given
    room, given the search effectiveness, is
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 用于计算眼镜在给定房间中概率的公式，考虑了搜索效果，公式为：
- en: '![Image](../images/equ_page_4_01.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/equ_page_4_01.jpg)'
- en: where *G* is the probability that the glasses are in a room, *E* is the search
    effectiveness, and *P*[prior] is the prior, or initial, probability estimate before
    receiving the new evidence.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *G* 是眼镜在某房间中的概率，*E* 是搜索效果，*P*[prior] 是接收到新证据前的先验概率估计。
- en: 'You can obtain the updated possibility that the glasses are in the study by
    inserting the target and search effectiveness probabilities into the equation
    as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将目标和搜索效果概率插入方程来获取眼镜在书房中的更新概率，具体如下：
- en: '![Image](../images/equ_page_5_01.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/equ_page_5_01.jpg)'
- en: As you can see, the simple math behind Bayes’ rule can quickly get tedious if
    you do it by hand. Fortunately for us, we live in the wonderous age of computers,
    so we can let Python handle the boring stuff!
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，贝叶斯法则背后的简单数学运算如果手工计算会变得很繁琐。幸运的是，我们生活在计算机的奇妙时代，所以我们可以让Python来处理这些无聊的计算工作！
- en: '**Project #1: Search and Rescue**'
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**项目 #1：搜索与救援**'
- en: In this project, you’ll write a Python program that uses Bayes’ rule to find
    a solitary fisherman who has gone missing off Cape Python. As the director of
    the Coast Guard’s search and rescue operations for the region, you’ve already
    interviewed his wife and determined his last known position, now more than six
    hours old. He radioed that he was abandoning ship, but no one knows if he is in
    a life raft or floating in the sea. The waters around the cape are warm, but if
    he’s immersed, he’ll experience hypothermia in 12 hours or so. If he’s wearing
    a personal flotation device and lucky, he might last three days.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将编写一个Python程序，使用贝叶斯法则来寻找在Python岬失踪的独自渔民。作为该地区海岸警卫队搜索与救援行动的负责人，你已经采访了他的妻子，并确定了他最后一次被见到的位置，距离现在已经超过六小时。他通过无线电报告说他要弃船，但没人知道他是坐上了救生艇还是漂浮在海中。岬角周围的水域温暖，但如果他被浸泡在水中，大约12小时后他会发生体温过低。如果他穿着个人漂浮装置并且幸运的话，他可能能撑三天。
- en: The ocean currents off Cape Python are complex ([Figure 1-3](ch01.xhtml#ch01fig3)),
    and the wind is currently blowing from the southwest. Visibility is good, but
    the waves are choppy, making a human head hard to spot.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Python岬的海洋洋流复杂多变（[图 1-3](ch01.xhtml#ch01fig3)），目前风从西南方向吹来。能见度良好，但波浪较为汹涌，使得人头较难被察觉。
- en: '![Image](../images/fig01_03.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig01_03.jpg)'
- en: 'Figure 1-3: Ocean currents off Cape Python'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-3：海洋洋流——Python岬
- en: In real life, your next course of action would be to plug all the information
    you have into the Coast Guard’s Search and Rescue Optimal Planning System (SAROPS).
    This software considers factors such as winds, tides, currents, whether a body
    is in the water or in a boat, and so on. It then generates rectangular search
    areas, calculates the initial probabilities for finding the sailor in each area,
    and plots the most efficient flight patterns.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实生活中，你的下一步行动是将你所掌握的所有信息输入海岸警卫队的搜索与救援最优规划系统（SAROPS）。该软件会考虑风、潮汐、洋流、物体是否漂浮在水面或在船上等因素。然后，它会生成矩形搜索区域，计算在每个区域内找到失踪水手的初步概率，并绘制出最有效的飞行路线。
- en: 'For this project, you’ll assume that SAROPS has identified three search areas.
    All you need to do is write the program that applies Bayes’ rule. You also have
    enough resources available to search two of the three areas in a day. You’ll have
    to decide how to allocate those resources. It’s a lot of pressure, but you have
    a powerful assistant to help you out: Bayes’ rule.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，你将假设SAROPS已经确定了三个搜索区域。你需要做的就是编写应用贝叶斯法则的程序。你也有足够的资源来在一天内搜索这三个区域中的两个。你必须决定如何分配这些资源。这很有压力，但你有一个强大的助手帮助你：贝叶斯法则。
- en: THE OBJECTIVE
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 目标
- en: Create a search and rescue game that uses Bayes’ rule to inform player choices
    on how to conduct a search.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个搜索与救援游戏，利用贝叶斯法则帮助玩家决定如何进行搜索。
- en: '***The Strategy***'
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***策略***'
- en: Searching for the sailor is like looking for the lost glasses in our previous
    example. You’ll start with initial target probabilities for the sailor’s location
    and update them for the search results. If you achieve an effective search of
    an area but find nothing, the probability that the sailor is in another area will
    increase.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找水手就像我们之前例子中寻找丢失的眼镜一样。你将从水手位置的初始目标概率开始，并根据搜索结果更新它们。如果你有效地搜索了一个区域，但什么也没找到，那么水手在另一个区域的概率将增加。
- en: 'But just as in real life, there are two ways things could go wrong: you thoroughly
    search an area but still miss the sailor, or your search goes poorly, wasting
    a day’s effort. To equate this to search effectiveness scores, in the first case,
    you might get an SEP of 0.85, but the sailor is in the remaining 15 percent of
    the area not searched. In the second case, your SEP is 0.2, and you’ve left 80
    percent of the area unsearched!'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 但就像在现实生活中一样，事情可能会有两种方式出错：你彻底搜索了一个区域，但仍然没有找到水手，或者你的搜索不顺利，浪费了一整天的努力。为了与搜索效果评分相匹配，在第一种情况下，你的SEP可能是0.85，但水手在剩下的15%未搜索的区域中。在第二种情况下，你的SEP是0.2，而你已经有80%的区域没有搜索！
- en: You can see the dilemma real commanders face. Do you go with your gut and ignore
    Bayes? Do you stick with the pure, cold logic of Bayes because you believe it’s
    the best answer? Or do you act expediently and protect your career and reputation
    by going with Bayes even when you doubt it?
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到真正的指挥官面临的困境。你是凭直觉行事并忽略贝叶斯方法吗？你是坚持贝叶斯的纯粹冷逻辑，因为你认为这是最好的答案吗？还是你为了权衡和保护自己的职业和声誉，即使怀疑贝叶斯方法，也选择采用它？
- en: To aid the player, you’ll use the OpenCV library to build an interface for working
    with the program. Although the interface can be something simple, like a menu
    built in the shell, you’ll also want a map of the cape and the search areas. You’ll
    use this map to display the sailor’s last known position and his position when
    found. The OpenCV library is an excellent choice for this game since it lets you
    display images and add drawings and text.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助玩家，你将使用OpenCV库来构建一个与程序交互的界面。虽然界面可以是简单的，例如在命令行中构建的菜单，但你还需要一张岬角和搜索区域的地图。你将使用这张地图来显示水手最后已知的位置和找到时的位置。OpenCV库是这个游戏的理想选择，因为它允许你显示图像，并添加绘图和文本。
- en: '***Installing the Python Libraries***'
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***安装Python库***'
- en: '*OpenCV* is the world’s most popular computer vision library. *Computer vision*
    is a field of deep learning that enables machines to see, identify, and process
    images like humans. OpenCV began as an Intel Research initiative in 1999 and is
    now maintained by the OpenCV Foundation, a nonprofit foundation which provides
    the software for free.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*OpenCV* 是世界上最流行的计算机视觉库。*计算机视觉* 是一个深度学习领域，使机器能够像人类一样看到、识别和处理图像。OpenCV最初是英特尔研究的一个项目，始于1999年，现在由OpenCV基金会维护，这是一个非营利性基金会，提供免费的软件。'
- en: OpenCV is written in C++, but there are bindings in other languages, such as
    Python and Java. Although aimed primarily at real-time computer vision applications,
    OpenCV also includes common image manipulation tools such as those found in the
    Python Imaging Library. As of this writing, the current version is OpenCV 4.1.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV是用C++编写的，但也有其他语言的绑定，例如Python和Java。尽管主要面向实时计算机视觉应用，OpenCV也包括常见的图像处理工具，例如Python图像库中的工具。截止本书编写时，当前版本为OpenCV
    4.1。
- en: OpenCV requires both the Numerical Python (NumPy) and SciPy packages to perform
    numerical and scientific computing in Python. OpenCV treats images as three-dimensional
    NumPy arrays ([Figure 1-4](ch01.xhtml#ch01fig4)). This allows for maximum interoperability
    with other Python scientific libraries.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV需要数值计算库（NumPy）和科学计算库（SciPy）来执行Python中的数值和科学计算。OpenCV将图像视为三维NumPy数组（[图1-4](ch01.xhtml#ch01fig4)）。这使得与其他Python科学库的互操作性达到最大化。
- en: '![Image](../images/fig01_04.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig01_04.jpg)'
- en: 'Figure 1-4: Visual representation of a three-channel color image array'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-4：三通道彩色图像数组的视觉表示
- en: OpenCV stores properties as rows, columns, and channels. For the image represented
    in [Figure 1-4](ch01.xhtml#ch01fig4), its “shape” would be a three-element tuple
    (4, 5, 3). Each stack of cells, like 0-20-40 or 19-39-59, represents a single
    pixel. The numbers shown are the intensity values for each color channel for that
    pixel.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV将图像的属性存储为行、列和通道。对于[图1-4](ch01.xhtml#ch01fig4)中表示的图像，其“形状”将是一个三元素元组(4,
    5, 3)。每一堆单元格，如0-20-40或19-39-59，代表一个单独的像素。显示的数字是该像素的每个颜色通道的强度值。
- en: As many projects in this book require scientific Python libraries like NumPy
    and matplotlib, this is a good time to install them.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本书中的许多项目需要像 NumPy 和 matplotlib 这样的科学计算 Python 库，因此现在是安装它们的好时机。
- en: There are numerous ways to install these packages. One way is to use SciPy,
    an open source Python library used for scientific and technical computing (see
    *[https://scipy.org/index.html](https://scipy.org/index.html)*).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 安装这些包的方法有很多。一种方法是使用 SciPy，它是一个用于科学和技术计算的开源 Python 库（详情见 *[https://scipy.org/index.html](https://scipy.org/index.html)*）。
- en: Alternatively, if you’re going to do a lot of data analysis and plotting on
    your own time, you may want to download and use a free Python distribution like
    Anaconda or Enthought Canopy, which work with Windows, Linux, and macOS. These
    distributions spare you the task of finding and installing the correct versions
    of all the required data science libraries, such as NumPy, SciPy, and so on. A
    listing of these types of distributions, along with links to their websites, can
    be found at *[https://scipy.org/install.html](https://scipy.org/install.html)*.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，如果你打算在自己的时间进行大量数据分析和绘图，你可能希望下载并使用一个免费的 Python 发行版，如 Anaconda 或 Enthought
    Canopy，它们都可以在 Windows、Linux 和 macOS 上使用。这些发行版省去了你寻找和安装所有所需数据科学库（如 NumPy、SciPy
    等）的麻烦。可以在 *[https://scipy.org/install.html](https://scipy.org/install.html)* 找到这些发行版的列表，并附有它们的网站链接。
- en: '**Installing NumPy and Other Scientific Packages with pip**'
  id: totrans-54
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用 pip 安装 NumPy 和其他科学包**'
- en: If you want to install the products directly, use the *Preferred Installer Program
    (pip)*, a package management system that makes it easy to install Python-based
    software (see *[https://docs.python.org/3/installing/](https://docs.python.org/3/installing/)*).
    For Windows and macOS, Python versions 3.4 and newer come with pip preinstalled.
    Linux users may have to install pip separately. To install or upgrade pip, see
    the instructions at *[https://pip.pypa.io/en/stable/installing/](https://pip.pypa.io/en/stable/installing/)*
    or search online for instructions on installing pip on your particular operating
    system.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想直接安装这些软件包，可以使用*首选安装程序（pip）*，这是一种软件包管理系统，可以轻松安装基于 Python 的软件（详情见 *[https://docs.python.org/3/installing/](https://docs.python.org/3/installing/)*）。对于
    Windows 和 macOS，Python 3.4 及更高版本已预安装 pip。Linux 用户可能需要单独安装 pip。要安装或升级 pip，查看 *[https://pip.pypa.io/en/stable/installing/](https://pip.pypa.io/en/stable/installing/)*
    上的说明，或在线搜索有关如何在你特定操作系统上安装 pip 的指南。
- en: 'I used pip to install the scientific packages using the instructions at *[https://scipy.org/install.html](https://scipy.org/install.html)*.
    Because matplotlib requires multiple dependen-cies, you’ll need to install these
    as well. For Windows, run the following Python 3–specific command using PowerShell,
    launched (using SHIFT-right-click) from within the folder containing the current
    Python installation:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用 pip 安装了科学计算包，参考了* [https://scipy.org/install.html](https://scipy.org/install.html)
    *上的说明。由于 matplotlib 需要多个依赖包，你也需要安装这些依赖包。对于 Windows 系统，可以在包含当前 Python 安装目录的文件夹内，使用
    PowerShell（通过 SHIFT-右键点击启动）运行以下 Python 3 特定命令：
- en: '[PRE0]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you have both Python 2 and 3 installed, use python3 in place of python.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你安装了 Python 2 和 3，请使用 python3 来代替 python。
- en: 'To verify that NumPy has been installed and is available for OpenCV, open a
    Python shell and enter the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证 NumPy 是否已经安装并且可以在 OpenCV 中使用，请打开 Python shell 并输入以下内容：
- en: '[PRE1]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you don’t see an error, you’re ready to install OpenCV.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有看到错误，你就可以准备安装 OpenCV 了。
- en: '**Installing OpenCV with pip**'
  id: totrans-62
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用 pip 安装 OpenCV**'
- en: 'You can find installation instructions for OpenCV at *[https://pypi.org/project/opencv-python/](https://pypi.org/project/opencv-python/)*.
    To install OpenCV for standard desktop environments (Windows, macOS, and almost
    any GNU/Linux distribution), enter the following in a PowerShell or terminal window:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 *[https://pypi.org/project/opencv-python/](https://pypi.org/project/opencv-python/)*
    找到 OpenCV 的安装说明。要为标准桌面环境（Windows、macOS 以及几乎所有 GNU/Linux 发行版）安装 OpenCV，请在 PowerShell
    或终端窗口中输入以下命令：
- en: '[PRE2]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: or
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you have multiple versions of Python installed (such as versions 2.7 and
    3.7), you will need to specify the Python version you want to use.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你安装了多个 Python 版本（如 2.7 和 3.7），你需要指定你想要使用的 Python 版本。
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you’re using Anaconda as a distribution medium, you can run this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 Anaconda 作为发行版媒介，你可以运行以下命令：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To check that everything loaded properly, enter the following in the shell:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查一切是否正确加载，请在 shell 中输入以下内容：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: No error means you’re good to go! If you get an error, read the troubleshooting
    list at *[https://pypi.org/project/opencv-python/](https://pypi.org/project/opencv-python/)*.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 没有错误意味着一切顺利！如果你遇到错误，可以阅读故障排除列表，访问 *[https://pypi.org/project/opencv-python/](https://pypi.org/project/opencv-python/)*。
- en: '***The Bayes Code***'
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***贝叶斯代码***'
- en: The *bayes.py* program you’ll write in this section simulates the search for
    a missing sailor over three contiguous search areas. It will display a map, print
    a menu of search choices for the user, randomly choose a location for the sailor,
    and either reveal the location if a search locates him or do a Bayesian update
    of the probabilities of finding the sailor for each search area. You can download
    the code, along with the map image (*cape_python.png*), from *[https://nostarch.com/real-world-python/](https://nostarch.com/real-world-python/)*.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在本节中编写的 *bayes.py* 程序模拟了在三个连续搜索区域中寻找失踪水手的过程。它将显示地图，打印用户可以选择的搜索菜单，随机选择一个水手的位置，如果找到水手，将显示该位置，或者执行贝叶斯更新，更新每个搜索区域找到水手的概率。你可以从
    *[https://nostarch.com/real-world-python/](https://nostarch.com/real-world-python/)*
    下载代码和地图图像（*cape_python.png*）。
- en: '**Importing Modules**'
  id: totrans-76
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**导入模块**'
- en: '[Listing 1-1](ch01.xhtml#ch01list1) starts the *bayes.py* program by importing
    the required modules and assigning some constants. We’ll look at what these modules
    do as we implement them in the code.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 1-1](ch01.xhtml#ch01list1)通过导入所需的模块并分配一些常量来启动 *bayes.py* 程序。我们将在实现代码时查看这些模块的功能。'
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 1-1: Importing modules and assigning constants used in the bayes.py
    program'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 1-1：导入模块并分配在 bayes.py 程序中使用的常量
- en: When importing modules into a program, the preferred order is the Python Standard
    Library modules, followed by third-party modules, followed by user-defined modules.
    The sys module includes commands for the operating system, such as exiting. The
    random module lets you generate pseudorandom numbers. The itertools module helps
    you with looping. Finally, numpy and cv2 import NumPy and OpenCV, respectively.
    You can also assign shorthand names (np, cv) to reduce keystrokes later.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当将模块导入到程序中时，推荐的顺序是首先导入 Python 标准库模块，其次是第三方模块，最后是用户定义的模块。sys 模块包含操作系统的命令，如退出。random
    模块允许你生成伪随机数。itertools 模块帮助你进行循环。最后，numpy 和 cv2 分别导入 NumPy 和 OpenCV。你还可以为这些模块分配简短的名称（np，cv），以减少后续的输入。
- en: Next, assign some constants. As per the PEP8 Python style guide (*[https://www.python.org/dev/peps/pep-0008/](https://www.python.org/dev/peps/pep-0008/)*),
    constant names should be all caps. This doesn’t make the variables truly immutable,
    but it does alert other developers that they shouldn’t change these variables.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，分配一些常量。根据 PEP8 Python 风格指南 (*[https://www.python.org/dev/peps/pep-0008/](https://www.python.org/dev/peps/pep-0008/)*)，常量名称应全部大写。这并不意味着这些变量是不可变的，但它确实提醒其他开发者不应更改这些变量。
- en: The map you’ll use for the fictional Cape Python area is an image file called
    *cape_python.png* ([Figure 1-5](ch01.xhtml#ch01fig5)). Assign this image file
    to a constant variable named MAP_FILE.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你将用于虚构的“海角 Python”区域的地图是一个名为*cape_python.png*的图像文件（[图 1-5](ch01.xhtml#ch01fig5)）。将此图像文件分配给一个名为
    MAP_FILE 的常量变量。
- en: '![Image](../images/fig01_05.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig01_05.jpg)'
- en: 'Figure 1-5: Grayscale base map of Cape Python (cape_python.png)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-5：海角 Python 的灰度基础地图（cape_python.png）
- en: You’ll draw the search areas on the image as rectangles. OpenCV will define
    each rectangle by the pixel number at the corner points, so assign a variable
    to hold these four points as a tuple. The required order is upper-left *x*, upper-left
    *y*, lower-right *x*, and lower-right *y*. Use SA in the variable name to represent
    “search area.”
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你将把搜索区域作为矩形绘制在图像上。OpenCV 将通过角点的像素数定义每个矩形，因此要为这四个点分配一个元组变量。所需的顺序是左上角 *x*，左上角
    *y*，右下角 *x*，右下角 *y*。在变量名中使用 SA 来表示“搜索区域”。
- en: '**Defining the Search Class**'
  id: totrans-86
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**定义搜索类**'
- en: A *class* is a data type in object-oriented programming (OOP). OOP is an alternative
    approach to functional/procedural programming. It’s especially useful for large,
    complex programs, as it produces code that’s easier to update, maintain, and reuse,
    while reducing code duplication. OOP is built around data structures known as
    *objects*, which consist of data, methods, and the interactions between them.
    As such, it works well with game programs, which typically use interacting objects,
    such as spaceships and asteroids.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*类*是面向对象编程（OOP）中的一种数据类型。OOP是功能/过程编程的另一种方法。它特别适用于大型复杂的程序，因为它产生的代码更易于更新、维护和重用，同时减少了代码重复。OOP围绕着被称为*对象*的数据结构构建，这些对象由数据、方法及其之间的交互组成。因此，它非常适合游戏程序，游戏程序通常使用交互的对象，如宇宙飞船和小行星。'
- en: A class is a template from which multiple objects can be created. For example,
    you could have a class that builds battleships in a World War II game. Each battleship
    would inherit certain consistent characteristics, such as tonnage, cruising speed,
    fuel level, damage level, weaponry, and so on. You could also give each battleship
    object unique characteristics, such as a different name. Once created, or *instantiated*,
    the individual characteristics of each battleship would begin to diverge depending
    on how much fuel the ships burn, how much damage they take, how much ammo they
    use, and so on.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 类是一个模板，可以用来创建多个对象。例如，你可以有一个类来构建二战游戏中的战列舰。每个战列舰将继承某些一致的特性，如吨位、巡航速度、燃料水平、损伤程度、武器等。你还可以给每个战列舰对象赋予独特的特性，比如不同的名字。一旦创建，或者说*实例化*，每个战列舰的个体特性将开始分化，具体取决于船只燃烧了多少燃料、受到多少伤害、使用了多少弹药等等。
- en: In *bayes.py*, you’ll use a class as a template to create a search and rescue
    mission that allows for three search areas. [Listing 1-2](ch01.xhtml#ch01list2)
    defines the Search class, which will act as a blueprint for your game.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在*bayes.py*中，你将使用一个类作为模板，创建一个搜索和救援任务，允许三个搜索区域。[列表1-2](ch01.xhtml#ch01list2)定义了Search类，它将作为你的游戏蓝图。
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 1-2: Defining the Search class and __init__() method'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1-2：定义Search类和`__init__()`方法
- en: Start by defining a class called Search. According to PEP8, the first letter
    of a class name should be capitalized.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 从定义一个名为Search的类开始。根据PEP8规范，类名的首字母应该大写。
- en: 'Next, define a method that sets up the initial attribute values for your object.
    In OOP, an *attribute* is a named value associated with an object. If your object
    is a person, an attribute might be their weight or eye color. *Methods* are attributes
    that also happen to be functions, which are passed a reference to their instance
    when they run. The __init__() method is a special built-in function that Python
    automatically invokes as soon as a new object is created. It binds the attributes
    of each newly created instance of a class. In this case, you pass it two arguments:
    self and the name you want to use for your object.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，定义一个方法，用于为你的对象设置初始属性值。在面向对象编程（OOP）中，*属性*是与对象相关联的命名值。如果你的对象是一个人，属性可能是他们的体重或眼睛颜色。*方法*是属性的一种，它们实际上是函数，在运行时会传入对实例的引用。`__init__()`方法是一个特殊的内建函数，Python会在创建新对象时自动调用它。它绑定每个新创建的类实例的属性。在这个例子中，你传递两个参数：self和你想为对象使用的名字。
- en: 'The self parameter is a reference to the instance of the class that is being
    created, or that a method was invoked on, technically referred to as a *context*
    instance. For example, if you create a battleship named the *Missouri*, then for
    that object, self becomes Missouri, and you can call a method for that object,
    like one for firing the big guns, with dot notation: Missouri.fire_big_guns().
    By giving objects unique names when they are instantiated, the scope of each object’s
    attributes is kept separate from all others. This way, damage taken by one battleship
    isn’t shared with the rest of the fleet.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: self参数是对正在创建的类实例，或被调用方法的实例的引用，技术上称为*上下文*实例。例如，如果你创建了一个名为*密苏里*的战列舰，那么对于该对象，self就成为了Missouri，你可以通过点表示法调用该对象的方法，例如执行一个大炮开火的方法：Missouri.fire_big_guns()。通过在实例化时为对象赋予独特的名字，每个对象的属性范围都与其他对象分开。这样，一个战列舰所受的伤害就不会与其他舰船共享。
- en: It’s good practice to list all the initial attribute values for an object under
    the __init__() method. This way, users can see all the key attributes of the object
    that will be used later in various methods, and your code will be more readable
    and updatable. In [Listing 1-2](ch01.xhtml#ch01list2), these are the self attributes,
    such as self.name.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在 __init__() 方法下列出对象的所有初始属性值是一种良好的实践。这样，用户可以查看对象的所有关键属性，这些属性将在后续的各个方法中使用，并且你的代码将更具可读性和可更新性。在[清单
    1-2](ch01.xhtml#ch01list2)中，这些是 self 属性，比如 self.name。
- en: Attributes assigned to self will also behave like global variables in procedural
    programming. Methods in the class will be able to access them directly, without
    the need for arguments. Because these attributes are “shielded” under the *class*
    umbrella, their use is not discouraged as with true global variables, which are
    assigned within the global scope and are modified within the local scope of individual
    functions.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 分配给 self 的属性也将像过程式编程中的全局变量一样行为。类中的方法可以直接访问这些属性，而无需传递参数。因为这些属性被“屏蔽”在*类*的范畴下，它们的使用不像真正的全局变量那样受到限制，后者是在全局作用域中赋值并在单个函数的局部作用域中修改。
- en: Assign the MAP_FILE variable to the self.img attribute using OpenCV’s imread()
    method ➊. The MAP_FILE image is grayscale, but you’ll want to add some color to
    it during the search. So, use ImreadFlag, as cv.IMREAD_COLOR, to load the image
    in color mode. This will set up three color channels (B, G, R) for you to exploit
    later.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 OpenCV 的 imread() 方法 ➊ 将 MAP_FILE 变量分配给 self.img 属性。MAP_FILE 图像是灰度图像，但在搜索过程中你可能需要为其添加一些颜色。因此，使用
    ImreadFlag，如 cv.IMREAD_COLOR，来以彩色模式加载图像。这将为你设置三个颜色通道（B、G、R），以便稍后使用。
- en: If the image file doesn’t exist (or the user entered the wrong filename), OpenCV
    will throw a confusing error (NoneType object is not subscriptable). To handle
    this, use a conditional to check whether self.img is None. If it is, print an
    error message and then use the sys module to exit the program. Passing it an exit
    code of 1 indicates that the program terminated with an error. Setting file=stderr
    will result in the use of the standard “error red” text color in the Python interpreter
    window, though not in other windows such as PowerShell.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果图像文件不存在（或用户输入了错误的文件名），OpenCV 将抛出一个令人困惑的错误（NoneType 对象不可下标）。为了解决这个问题，使用条件语句检查
    self.img 是否为 None。如果是，打印错误信息，然后使用 sys 模块退出程序。传递退出代码 1 表示程序以错误结束。设置 file=stderr
    会导致在 Python 解释器窗口中使用标准的“错误红色”文本颜色，但在其他窗口如 PowerShell 中不会出现此颜色。
- en: Next, assign two attributes for the sailor’s actual location when found. The
    first will hold the number of the search area ➋ and the second the precise (*x*,
    *y*) location. The assigned values will be placeholders for now. Later, you’ll
    define a method to randomly choose the final values. Note that you use a list
    for the location coordinates as you need a mutable container.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为找到的水手的实际位置分配两个属性。第一个将保存搜索区域的编号 ➋，第二个将保存精确的 (*x*, *y*) 坐标。分配的值现在将是占位符。稍后，你将定义一个方法来随机选择最终的值。请注意，使用列表作为位置坐标，因为你需要一个可变容器。
- en: The map image is loaded as an *array*. An array is a fixed-size collection of
    objects of the same type. Arrays are memory-efficient containers that provide
    fast numerical operations and effectively use the addressing logic of computers.
    One concept that makes NumPy particularly powerful is *vectorization*, which replaces
    explicit loops with more efficient array expressions. Basically, operations occur
    on entire arrays rather than their individual elements. With NumPy, internal looping
    is directed to efficient C and Fortran functions that are faster than standard
    Python techniques.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 地图图像被加载为*数组*。数组是一个固定大小的、包含相同类型对象的集合。数组是内存高效的容器，提供快速的数值操作，并有效利用计算机的地址逻辑。使得 NumPy
    特别强大的一个概念是*向量化*，它用更高效的数组表达式替代了显式的循环。基本上，操作是在整个数组上进行，而不是单独对其元素进行操作。使用 NumPy 时，内部循环会被导向高效的
    C 和 Fortran 函数，这些函数比标准的 Python 技术更快。
- en: So that you can work with local coordinates *within* a search area, you can
    create a subarray from the array ➌. Notice that this is done with indexing. You
    first provide the range from the upper-left *y* value to the lower-right *y* and
    then from the upper-left *x* to the lower-right *x*. This is a NumPy feature that
    takes some getting used to, especially since most of us are used to *x* coming
    before *y* in Cartesian coordinates.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于在搜索区域内使用局部坐标，您可以从数组 ➌ 中创建一个子数组。请注意，这是通过索引实现的。首先提供从左上角的*y*值到右下角的*y*，然后是从左上角的*x*到右下角的*x*。这是NumPy的一个特性，刚开始可能需要适应，尤其是大多数人习惯于在笛卡尔坐标中*x*排在*y*之前。
- en: Repeat the procedure for the next two search areas and then set the pre-search
    probabilities for finding the sailor in each of the search areas ➍. In real life,
    these would come from the SAROPS program. Of course, p1 represents area 1, p2
    is for area 2, and so on. Finish with placeholder attributes for the SEP.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对下两个搜索区域重复此过程，然后设置每个搜索区域中找到水手的前期搜索概率 ➍。在现实中，这些数据来自SAROPS程序。当然，p1代表区域1，p2代表区域2，以此类推。最后使用占位符属性表示SEP。
- en: '**Drawing the Map**'
  id: totrans-103
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**绘制地图**'
- en: Inside the Search class, you’ll use functionality within OpenCV to create a
    method that displays the base map. This map will include the search areas, a scale
    bar, and the sailor’s last known position ([Figure 1-6](ch01.xhtml#ch01fig6)).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在Search类中，您将使用OpenCV中的功能创建一个方法，显示基础地图。该地图将包括搜索区域、比例尺以及水手的最后已知位置（[图1-6](ch01.xhtml#ch01fig6)）。
- en: '![Image](../images/fig01_06.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig01_06.jpg)'
- en: 'Figure 1-6: Initial game screen (base map) for bayes.py'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-6：bayes.py的初始游戏屏幕（基础地图）
- en: '[Listing 1-3](ch01.xhtml#ch01list3) defines the draw_map() method that displays
    the initial map.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单1-3](ch01.xhtml#ch01list3)定义了draw_map()方法，用于显示初始地图。'
- en: '[PRE9]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 1-3: Defining a method for displaying the base map'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 清单1-3：定义一个显示基础地图的方法
- en: Define the draw_map() method with self and the sailor’s last known coordinates
    (last_known) as its two parameters. Then use OpenCV’s line() method to draw a
    scale bar. Pass it the base map image, a tuple of the left and right (*x*, *y*)
    coordinates, a line color tuple, and a line width as arguments.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用self和水手的最后已知坐标（last_known）作为两个参数，定义draw_map()方法。然后使用OpenCV的line()方法绘制比例尺。传递基础地图图像、左上角和右下角的(*x*,
    *y*)坐标元组、线条颜色元组以及线条宽度作为参数。
- en: Use the putText() method to annotate the scale bar. Pass it the attribute for
    the base map image and then the actual text, followed by a tuple of the coordinates
    of the bottom-left corner of the text. Then add the font name, font scale, and
    color tuple.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 使用putText()方法为比例尺添加注释。传递基础地图图像的属性，然后是实际文本，接着是文本左下角的坐标元组。然后添加字体名称、字体缩放和颜色元组。
- en: Now draw a rectangle for the first search area ➊. As usual, pass the base map
    image, then the variables representing the four corners of the box, and finally
    a color tuple and a line weight. Use putText() again to place the search area
    number just inside the upper-left corner. Repeat these steps for search areas
    2 and 3.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在为第一个搜索区域 ➊ 绘制一个矩形。像往常一样，传递基础地图图像、表示矩形四个角的变量，最后是颜色元组和线条宽度。再次使用putText()方法在左上角内放置搜索区域编号。对于搜索区域2和3，重复这些步骤。
- en: Use putText() to post a + at the sailor’s last known position ➋. Note that the
    symbol is red, but the color tuple reads (0, 0, 255), instead of (255, 0, 0).
    This is because OpenCV uses a Blue-Green-Red (BGR) color format, not the more
    common Red-Green-Blue (RGB) format.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 使用putText()方法在水手的最后已知位置 ➋ 处放置一个“+”。请注意，符号是红色的，但颜色元组为(0, 0, 255)，而不是(255, 0,
    0)。这是因为OpenCV使用蓝绿红（BGR）颜色格式，而不是更常见的红绿蓝（RGB）格式。
- en: Continue by placing text for a legend that describes the symbols for the last
    known position and actual position, which should display when a player’s search
    finds the sailor. Use blue for the actual position marker.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加描述水手最后已知位置和实际位置符号的图例文本，这些符号应当在玩家的搜索中找到水手时显示。实际位置标记使用蓝色。
- en: Complete the method by showing the base map, using OpenCV’s imshow() method
    ➌. Pass it a title for the window and the image.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 完成该方法，通过使用OpenCV的imshow()方法 ➌ 显示基础地图。传递给它窗口的标题和图像。
- en: To avoid the base map and interpreter windows interfering with each other as
    much as possible, force the base map to display in the upper-right corner of your
    monitor (you may need to adjust the coordinates for your machine). Use OpenCV’s
    moveWindow() method and pass it the name of the window, 'Search Area', and the
    coordinates for the top-left corner.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尽可能避免基础地图和解释器窗口相互干扰，强制让基础地图显示在显示器的右上角（你可能需要根据你的机器调整坐标）。使用OpenCV的moveWindow()方法，并传递窗口的名称‘Search
    Area’和左上角的坐标。
- en: Finish by using the waitKey() method, which introduces a delay of *n* milliseconds
    while rendering images to windows. Pass it 500, for 500 milliseconds. This should
    result in the game menu appearing a half-second after the base map.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最后使用waitKey()方法，它在渲染图像到窗口时引入* n *毫秒的延迟。传递500，表示500毫秒。这应该会导致游戏菜单在基础地图之后半秒出现。
- en: '**Choosing the Sailor’s Final Location**'
  id: totrans-118
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**选择水手的最终位置**'
- en: '[Listing 1-4](ch01.xhtml#ch01list4) defines a method to randomly choose the
    sailor’s actual location. For convenience, the coordinates are initially found
    within a search area subarray and then converted to global coordinates with respect
    to the full base map image. This methodology works because all the search areas
    are the same size and shape and can thus use the same internal coordinates.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 1-4](ch01.xhtml#ch01list4)定义了一个方法来随机选择水手的实际位置。为了方便起见，坐标最初在一个搜索区域的子数组内找到，然后转换为全局坐标，参照完整的基础地图图像。这个方法可行是因为所有搜索区域的大小和形状相同，因此可以使用相同的内部坐标。'
- en: '[PRE10]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 1-4: Defining a method to randomly choose the sailor’s actual location'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1-4：定义一个方法来随机选择水手的实际位置
- en: 'Define the sailor_final_location() method with two parameters: self and the
    number of search areas being used. For the first (*x*) coordinate in the self.sailor_actual
    list, use NumPy’s random.choice() method to choose a value from the area 1 subarray.
    Remember, the search areas are NumPy arrays copied out of the larger image array.
    Because the search areas/subarrays are all the same size, coordinates you choose
    from one will apply to all.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 定义sailor_final_location()方法，接受两个参数：self和正在使用的搜索区域数量。对于self.sailor_actual列表中的第一个(*x*)坐标，使用NumPy的random.choice()方法从区域1的子数组中选择一个值。记住，搜索区域是从更大的图像数组中复制出来的NumPy数组。因为搜索区域/子数组的大小相同，所以从一个区域中选择的坐标将适用于所有区域。
- en: 'You can get the coordinates of an array with shape, as shown here:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下方式获取数组的坐标：
- en: '[PRE11]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The shape attribute for a NumPy array must be a tuple with as many elements
    as dimensions in the array. And remember that, for an array in OpenCV, the order
    of elements in the tuple is rows, columns, and then channels.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy数组的shape属性必须是一个元组，其元素个数与数组的维度数相同。并且记住，在OpenCV中的数组，元组中元素的顺序是行、列，再到通道。
- en: Each of the existing search areas is a three-dimensional array 50×50 pixels
    in size. So, internal coordinates for both *x* and *y* will range from 0 to 49\.
    Selecting [0] with random.choice() means that rows are used, and the final argument,
    1, selects a single element. Selecting [1] chooses from columns.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现有的每个搜索区域都是一个大小为50×50像素的三维数组。因此，*x*和*y*的内部坐标范围为0到49。使用random.choice()选择[0]意味着使用的是行，最后一个参数1选择单个元素。选择[1]则是从列中选择。
- en: The coordinates generated by random.choice() will range from 0 to 49\. To use
    these with the full base map image, you first need to pick a search area ➊. Do
    this with the random module, which you imported at the start of the program. According
    to the SAROPS output, the sailor is most likely in area 2, followed by area 3\.
    Since these initial target probabilities are guesses that won’t correspond directly
    to reality, use a triangular distribution to choose the area containing the sailor.
    The arguments are the low and high endpoints. If a final mode argument is not
    provided, the mode defaults to the midpoint between the endpoints. This will align
    with the SAROPS results as area 2 will be picked the most often.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: random.choice()生成的坐标范围是0到49。为了将这些坐标与完整的基础地图图像结合使用，你首先需要选择一个搜索区域➊。使用在程序开始时导入的random模块来实现这一点。根据SAROPS输出，水手最有可能位于区域2，其次是区域3。由于这些初步的目标概率是基于猜测的，可能不会直接对应现实，因此使用三角分布来选择包含水手的区域。参数是低端和高端。如果没有提供最终的模式参数，默认的模式是低端和高端之间的中点。这将与SAROPS结果一致，因为区域2会被最常选择。
- en: Note that you use the local variable area within the method, rather than the
    self.area attribute, as there’s no need to share this variable with other methods.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您在方法中使用的是局部变量 area，而不是 `self.area` 属性，因为没有必要与其他方法共享此变量。
- en: To plot the sailor’s location on the base map, you need to add the appropriate
    search area corner-point coordinate. This converts the “local” search area coordinates
    to the “global” coordinates of the full base map image. You’ll also want to keep
    track of the search area, so update the self.area_actual attribute ➋.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要在基础地图上绘制水手的位置，您需要添加适当的搜索区域角点坐标。这将“本地”搜索区域坐标转换为“全局”基础地图图像的坐标。您还需要跟踪搜索区域，因此请更新`self.area_actual`属性
    ➋。
- en: Repeat these steps for search areas 2 and 3 and then return the (*x*, *y*) coordinates.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 对搜索区域 2 和 3 重复这些步骤，然后返回 (*x*, *y*) 坐标。
- en: '**NOTE**'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In real life, the sailor would drift along, and the odds of his moving into
    area 3 would increase with each search. I chose to use a static location, however,
    to make the logic behind Bayes’ rule as clear as possible. As a result, this scenario
    behaves more like a search for a sunken submarine.*'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*在现实生活中，水手会漂移，随着每次搜索，他进入区域 3 的几率会增加。然而，我选择使用静态位置，以便尽可能清楚地展示贝叶斯定理背后的逻辑。因此，这种场景更像是在搜索一艘沉没的潜艇。*'
- en: '**Calculating Search Effectiveness and Conducting the Search**'
  id: totrans-133
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**计算搜索有效性并执行搜索**'
- en: In real life, weather and mechanical problems can result in low search effectiveness
    scores. Thus, the strategy for each search will be to generate a list of all possible
    locations within a search area, shuffle the list, and then sample it based on
    the search effectiveness value. Because the SEP will never be 1.0, if you just
    sample from the start or end of the list—without shuffling—you’ll never be able
    to access coordinates tucked away in its “tail.”
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实生活中，天气和机械问题可能导致低搜索有效性评分。因此，每次搜索的策略将是生成搜索区域内所有可能位置的列表，打乱列表，然后根据搜索有效性值进行抽样。因为
    SEP 永远不会是 1.0，如果您只是从列表的开始或末尾进行抽样——不打乱列表——您将永远无法访问其“尾部”中隐藏的坐标。
- en: '[Listing 1-5](ch01.xhtml#ch01list5), still in the Search class, defines a method
    to randomly calculate the effectiveness of a given search and defines another
    method to conduct the search.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 1-5](ch01.xhtml#ch01list5)，仍然在Search类中，定义了一个方法来随机计算给定搜索的有效性，并定义了另一个方法来执行搜索。'
- en: '[PRE12]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 1-5: Defining methods to randomly choose search effectiveness and conduct
    search'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1-5：定义方法以随机选择搜索有效性并执行搜索
- en: Start by defining the search effectiveness method. The only parameter needed
    is self. For each of the search effectiveness attributes, such as E1, randomly
    choose a value between 0.2 and 0.9\. These are arbitrary values that mean you
    will always search at least 20 percent of the area but never more than 90 percent.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 首先定义搜索有效性方法。唯一需要的参数是 self。对于每个搜索有效性属性，如 E1，随机选择一个值，范围在 0.2 到 0.9 之间。这些是任意值，意味着您总是会至少搜索该区域的
    20%，但不会超过 90%。
- en: You could argue that the search effectiveness attributes for the three search
    areas are dependent. Fog, for example, might affect all three areas, yielding
    uniformly poor results. On the other hand, some of your helicopters may have infrared
    imaging equipment and would fare better. At any rate, making these independent,
    as you’ve done here, makes for a more dynamic simulation.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以认为三个搜索区域的搜索有效性属性是相关的。例如，雾霾可能会影响所有三个区域，导致结果普遍较差。另一方面，您的某些直升机可能配备红外成像设备，表现会更好。无论如何，像这里一样将它们设为独立，可以使模拟更加动态。
- en: Next, define a method for conducting a search ➊. Necessary parameters are the
    object itself, the area number (chosen by the user), the subarray for the chosen
    area, and the randomly chosen search effectiveness value.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，定义一个方法来执行搜索 ➊。必要的参数是对象本身、区域编号（由用户选择）、所选区域的子数组和随机选择的搜索有效性值。
- en: You’ll need to generate a list of all the coordinates within a given search
    area. Name a variable local_y_range and assign it a range based on the first index
    from the array shape tuple, which represents rows. Repeat for the x_range value.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要生成一个给定搜索区域内所有坐标的列表。命名一个变量 `local_y_range`，并根据数组形状元组中的第一个索引（表示行）为其分配一个范围。对
    `x_range` 值重复此操作。
- en: 'To generate the list of all coordinates in the search area, use the itertools
    module ➋. This module is a group of functions in the Python Standard Library that
    create iterators for efficient looping. The product() function returns tuples
    of all the permutations-with-repetition for a given sequence. In this case, you’re
    finding all the possible ways to combine *x* and *y* in the search area. To see
    it in action, type the following in the shell:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成搜索区域内所有坐标的列表，使用 itertools 模块 ➋。该模块是 Python 标准库中的一组函数，用于创建高效的迭代器以便进行循环。product()
    函数返回给定序列的所有带重复的排列组合。在此案例中，你是在寻找搜索区域内所有可能的 *x* 和 *y* 的组合。要查看其实际操作，在终端中输入以下内容：
- en: '[PRE13]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, the coords list contains every possible paired combination of
    the elements in the x_range and y_range lists.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，coords 列表包含了 x_range 和 y_range 列表中所有可能的配对组合。
- en: Next, shuffle the list of coordinates. This is so you won’t keep searching the
    same end of the list with each search event. In the next line, use index slicing
    to trim the list based on the search effectiveness probability. For example, a
    poor search effectiveness of 0.3 means that only one-third of the possible locations
    in an area are included in the list. As you’ll check the sailor’s actual location
    against this list, you’ll effectively leave two-thirds of the area “unsearched.”
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，打乱坐标列表。这是为了避免每次搜索时都从列表的同一端开始。下一行中，使用索引切片根据搜索有效性概率来修剪列表。例如，0.3 的低搜索有效性意味着列表中仅包含该区域三分之一的可能位置。由于你将根据这个列表检查水手的实际位置，因此实际上你会将该区域的三分之二“未搜索”。
- en: Assign a local variable, loc_actual, to hold the sailor’s actual location ➌.
    Then use a conditional to check that the sailor has been found. If the user chose
    the correct search area and the shuffled and trimmed coords list contains the
    sailor’s (*x*, *y*) location, return a string stating the sailor has been found,
    along with the coords list. Otherwise, return a string stating the sailor has
    not been found and the coords list.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 分配一个局部变量 loc_actual 来保存水手的实际位置 ➌。然后使用条件语句检查水手是否被找到。如果用户选择了正确的搜索区域，并且打乱和修剪后的
    coords 列表包含水手的 (*x*, *y*) 位置，则返回一条字符串，表示水手已找到，以及 coords 列表。否则，返回一条字符串，表示水手未找到，并附上
    coords 列表。
- en: '**Applying Bayes’ Rule and Drawing a Menu**'
  id: totrans-147
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**应用贝叶斯法则并绘制菜单**'
- en: '[Listing 1-6](ch01.xhtml#ch01list6), still in the Search class, defines a method
    and a function. The revise_target_probs() method uses Bayes’ rule to update the
    target probabilities. These represent the probability of the sailor being found
    per search area. The draw_menu() function, defined outside of the Search class,
    displays a menu that will serve as a graphical user interface (GUI) to run the
    game.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 1-6](ch01.xhtml#ch01list6)，仍然是在 Search 类中，定义了一个方法和一个函数。revise_target_probs()
    方法使用贝叶斯法则来更新目标概率，这些目标概率表示在每个搜索区域内找到水手的概率。draw_menu() 函数在 Search 类外部定义，显示一个菜单，该菜单将作为图形用户界面（GUI）来运行游戏。'
- en: '[PRE14]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 1-6: Defining ways to apply Bayes’ rule and draw a menu in the Python
    shell'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1-6：在 Python Shell 中定义应用贝叶斯法则和绘制菜单的方法
- en: Define the revise_target_probs() method to update the probability of the sailor
    being in each search area. Its only parameter is self.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 revise_target_probs() 方法来更新水手在每个搜索区域内的概率。它的唯一参数是 self。
- en: For convenience, break Bayes’ equation into two parts, starting with the denominator.
    You need to multiply the previous target probability by the current search effectiveness
    value (see [page 5](ch01.xhtml#page_5) to review how this works).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，将贝叶斯方程分成两部分，从分母开始。你需要将前一个目标概率与当前的搜索有效性值相乘（请参阅[第5页](ch01.xhtml#page_5)以复习这一过程）。
- en: With the denominator calculated, use it to complete Bayes’ equation. In OOP,
    you don’t need to return anything. You can simply update the attribute directly
    in the method, as if it were a declared global variable in procedural programming.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 计算出分母后，使用它来完成贝叶斯方程。在面向对象编程（OOP）中，你不需要返回任何东西。你可以直接在方法中更新属性，就像它是过程式编程中的一个全局变量一样。
- en: Next, in the global space, define the draw_menu() function to draw a menu. Its
    only parameter is the number of the search being conducted. Because this function
    has no “self-use,” you don’t have to include it in the class definition, though
    that is a valid option.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在全局作用域中定义 draw_menu() 函数来绘制菜单。它的唯一参数是正在进行的搜索编号。由于此函数没有“self”参数，因此不必将其包括在类定义中，尽管这也是一个有效的选项。
- en: Start by printing the search number. You’ll need this to keep track of whether
    you’ve found the sailor in the requisite number of searches, which we’ve currently
    set as 3.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 开始时打印搜索次数。你需要这个来跟踪是否已经在规定次数的搜索中找到水手，我们目前设置的搜索次数为 3 次。
- en: Use triple quotes with the print() function to display the menu. Note that the
    user will have the option to allocate both search parties to a given area or divide
    them between two areas.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用三引号和 print() 函数显示菜单。注意，用户将有选择将两个搜索小组分配到同一区域，或将它们分配到两个不同区域的选项。
- en: '**Defining the main() Function**'
  id: totrans-157
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**定义 main() 函数**'
- en: Now that you’re finished with the Search class, you’re ready to put all those
    attributes and methods to work! [Listing 1-7](ch01.xhtml#ch01list7) begins the
    definition of the main() function, used to run the program.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经完成了 Search 类的学习，准备好将所有这些属性和方法投入实际应用了！[清单 1-7](ch01.xhtml#ch01list7) 开始定义
    main() 函数，用于运行程序。
- en: '[PRE15]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 1-7: Defining the start of the main() function, used to run the program'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 1-7：定义 main() 函数的开始部分，用于运行程序
- en: The main() function requires no arguments. Start by creating a game application,
    named app, using the Search class. Name the object Cape_Python.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: main() 函数不需要任何参数。首先，使用 Search 类创建一个名为 app 的游戏应用。将该对象命名为 Cape_Python。
- en: Next, call the method that displays the map. Pass it the last known position
    of the sailor as a tuple of (*x*, *y*) coordinates. Note the use of the keyword
    argument, last_known=(160, 290), for clarity.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，调用显示地图的方法。传递给它水手的最后已知位置，作为一个 (*x*, *y*) 坐标的元组。注意使用关键字参数 last_known=(160,
    290)，以提高清晰度。
- en: Now, get the sailor’s *x* and *y* location by calling the method for that task
    and passing it the number of search areas. Then print the initial target probabilities,
    or priors, which were calculated by your Coast Guard underlings using Monte Carlo
    simulation, not Bayes’ rule. Finally, name a variable search_num and assign it
    1. This variable will keep track of how many searches you’ve conducted.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过调用相应的方法并传递搜索区域的数量，获取水手的 *x* 和 *y* 位置。然后打印初始目标概率，或者先验概率，这些是你的海岸警卫队下属通过蒙特卡洛模拟计算的，而不是通过贝叶斯规则得出的。最后，命名一个变量
    search_num，并将其值设置为 1。这个变量将跟踪你已经进行了多少次搜索。
- en: '**Evaluating the Menu Choices**'
  id: totrans-164
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**评估菜单选择**'
- en: '[Listing 1-8](ch01.xhtml#ch01list8) starts the while loop used to run the game
    in main(). Within this loop, the player evaluates and selects menu choices. Choices
    include searching a single area twice, splitting search efforts between two areas,
    restarting the game, and exiting the game. Note that the player can conduct as
    many searches as it takes to find the sailor; our three-day limit hasn’t been
    “hardwired” into the game.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 1-8](ch01.xhtml#ch01list8) 开始了 while 循环，用于在 main() 中运行游戏。在这个循环中，玩家评估并选择菜单选项。选项包括对单个区域进行两次搜索、将搜索工作分配到两个区域、重新开始游戏和退出游戏。请注意，玩家可以进行任意次数的搜索来找到水手；我们目前设置的三天限制并没有“硬编码”到游戏中。'
- en: '[PRE16]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 1-8: Using a loop to evaluate menu choices and run the game'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 1-8：使用循环来评估菜单选择并运行游戏
- en: Start a while loop that will run until the user chooses to exit. Immediately
    use dot notation to call the method that calculates the effectiveness of the search.
    Then call the function that displays the game menu and pass it the search number.
    Finish the preparatory stage by asking the user to make a choice, using the input()
    function.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 启动一个 while 循环，直到用户选择退出。立即使用点符号调用计算搜索效果的方法。然后调用显示游戏菜单的函数，并将搜索次数传递给它。最后，通过使用 input()
    函数要求用户做出选择，完成准备阶段。
- en: The player’s choice will be evaluated using a series of conditional statements.
    If they choose 0, exit the game. Exiting uses the sys module you imported at the
    beginning of the program.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家选择将通过一系列条件语句进行评估。如果选择 0，则退出游戏。退出操作使用了你在程序开头导入的 sys 模块。
- en: If the player chooses 1, 2, or 3, it means they want to commit both search teams
    to the area with the corresponding number. You’ll need to call the conduct_search()
    method twice to generate two sets of results and coordinates ➊. The tricky part
    here is determining the overall SEP, since each search has its own SEP. To do
    this, add the two coords lists together and convert the result to a set to remove
    any duplicates ➋. Get the length of the set and then divide it by the number of
    pixels in the 50×50 search area. Since you didn’t search the other areas, set
    their SEPs to 0.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家选择了 1、2 或 3，意味着他们希望将两个搜索队伍派往对应编号的区域。你需要调用 conduct_search() 方法两次，生成两组结果和坐标
    ➊。这里的难点是确定总体的 SEP，因为每次搜索都有自己的 SEP。为此，将两个 coords 列表合并，并将结果转换为集合以去除重复项 ➋。获取集合的长度，然后除以
    50×50 搜索区域中的像素数量。由于你没有搜索其他区域，将它们的 SEP 设置为 0。
- en: Repeat and tailor the previous code for search areas 2 and 3\. Use an elif statement
    since only one menu choice is valid per loop. This is more efficient than using
    additional if statements, as all elif statements below a true response will be
    skipped.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 重复并调整前面的代码以适应搜索区域 2 和 3。使用 elif 语句，因为每次循环只有一个有效的菜单选择。这比使用额外的 if 语句更高效，因为所有在响应为真之后的
    elif 语句都会被跳过。
- en: If the player chooses a 4, 5, or 6, it means they want to divide their teams
    between two areas. In this case, there’s no need to recalculate the SEP ➌.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家选择了 4、5 或 6，意味着他们希望将队伍分配到两个区域之间。在这种情况下，不需要重新计算 SEP ➌。
- en: If the player finds the sailor and wants to play again or just wants to restart,
    call the main() function ➍. This will reset the game and clear the map.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家找到了水手并且想要重新开始或仅仅想重新启动游戏，调用 main() 函数 ➍。这将重置游戏并清除地图。
- en: If the player makes a nonvalid choice, like “Bob”, let them know with a message
    and then use continue to skip back to the start of the loop and request the player’s
    choice again.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家做出了无效选择，例如“Bob”，通过消息提示他们并使用 continue 跳回循环的起始位置，重新请求玩家的选择。
- en: '**Finishing and Calling main()**'
  id: totrans-175
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**完成并调用 main()**'
- en: '[Listing 1-9](ch01.xhtml#ch01list9), still in the while loop, finishes the
    main() function and then calls it to run the program.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 1-9](ch01.xhtml#ch01list9)，仍在 while 循环中，完成了 main() 函数并调用它来运行程序。'
- en: '[PRE17]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 1-9: Completing and calling the main() function'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1-9：完成并调用 main() 函数
- en: Call the revise_target_probs() method to apply Bayes’ rule and recalculate the
    probability of the sailor being in each search area, given the search results.
    Next, display the search results and search effectiveness probabilities in the
    shell.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 revise_target_probs() 方法来应用贝叶斯定理，并根据搜索结果重新计算水手位于每个搜索区域的概率。接下来，在命令行中显示搜索结果和搜索有效性概率。
- en: If the results of both searches are negative, display the updated target probabilities,
    which the player will use to guide their next search ➊. Otherwise, display the
    sailor’s location on the map. Use OpenCV to draw a circle and pass the method
    the base map image, the sailor’s (*x*, *y*) tuple for the center point, a radius
    (in pixels), a color, and a thickness of –1\. A negative thickness value will
    fill the circle with the color.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两次搜索的结果都是负面，显示更新后的目标概率，玩家将用这些概率来指导下一次搜索 ➊。否则，显示水手在地图上的位置。使用 OpenCV 绘制圆圈，并将方法传入基础地图图像、水手的
    (*x*, *y*) 元组作为圆心、半径（像素）、颜色和 –1 的厚度。负厚度值将填充圆圈并给圆圈上色。
- en: Finish main() by showing the base map using code similar to [Listing 1-3](ch01.xhtml#ch01list3)
    ➋. Pass the waitKey() method 1500 to display the sailor’s actual location for
    1.5 seconds before the game calls main() and resets automatically. At the end
    of the loop, increment the search number variable by 1\. You want to do this *after*
    the loop so that an invalid choice isn’t counted as a search.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用类似于 [列表 1-3](ch01.xhtml#ch01list3) 的代码来展示基础地图，完成 main() ➋。将 waitKey() 方法传入
    1500，显示水手的实际位置 1.5 秒后，游戏会调用 main() 并自动重置。在循环结束时，将搜索次数变量加 1。你希望在循环后进行此操作，以便无效选择不被算作一次搜索。
- en: Back in the global space, apply the code that lets the program be imported as
    a module or run in stand-alone mode. The __name__ variable is a built-in variable
    used to evaluate whether a program is autonomous or imported into another program.
    If you run this program directly, __name__ is set to __main__, the condition of
    the if statement is met, and main() is called automatically. If the program is
    imported, the main() function won’t be run until it is intentionally called.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在全局空间中，应用可以让程序作为模块导入或独立运行的代码。__name__ 变量是一个内置变量，用于判断程序是自主运行还是被导入到另一个程序中。如果你直接运行这个程序，__name__
    会被设置为 __main__，if 语句的条件得到满足，main() 会被自动调用。如果程序被导入，则直到显式调用，main() 函数才会运行。
- en: '***Playing the Game***'
  id: totrans-183
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***游戏玩法***'
- en: To play the game, select **Run**▸**Run Module** in the text editor or just press
    F5\. [Figures 1-7](ch01.xhtml#ch01fig7) and [1-8](ch01.xhtml#ch01fig8) show the
    final game screens, with the results of a successful first search.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 要玩这个游戏，请在文本编辑器中选择**运行**▸**运行模块**，或者直接按 F5。 [图 1-7](ch01.xhtml#ch01fig7) 和 [1-8](ch01.xhtml#ch01fig8)
    显示了最终的游戏屏幕，其中展示了第一次搜索成功的结果。
- en: '![Image](../images/fig01_07.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/fig01_07.jpg)'
- en: 'Figure 1-7: Python interpreter window with a successful search result'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-7：带有成功搜索结果的 Python 解释器窗口
- en: '![Image](../images/fig01_08.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/fig01_08.jpg)'
- en: 'Figure 1-8: Base map image for a successful search result'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-8：成功搜索结果的基础地图图像
- en: In this example search, the player chose to commit both searches to area 2,
    which had an initial 50 percent probability of containing the sailor. The first
    search was unsuccessful, but the second one found the sailor. Note that the search
    effectiveness was only slightly better than 50 percent. This means there was only
    a one-in-four chance (0.5 × 0.521 = 0.260) of finding the sailor in the first
    search. Despite choosing wisely, the player still had to rely on a bit of luck
    in the end!
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例搜索中，玩家选择将两个搜索都提交到区域 2，该区域最初有 50% 的概率包含水手。第一次搜索没有成功，但第二次搜索找到了水手。请注意，搜索的效果仅比
    50% 略好。这意味着第一次搜索找到水手的概率仅为四分之一（0.5 × 0.521 = 0.260）。尽管做出了明智的选择，玩家最终仍然需要依赖一点运气！
- en: When you play the game, try to immerse yourself in the scenario. Your decisions
    determine whether a human being lives or dies, and you don’t have much time. If
    the sailor’s floating in the water, you’ve got only three guesses to get it right.
    Use them wisely!
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 玩这个游戏时，尽量沉浸在情境中。你的决定将决定一个人的生死，而且你没有太多时间。如果水手漂浮在水面上，你只有三次机会来猜对。请明智地使用它们！
- en: Based on the target probabilities at the start of the game, the sailor is most
    likely in area 2, followed by area 3\. So, a good initial strategy is to either
    search area 2 twice (menu option 2) or search areas 2 and 3 simultaneously (menu
    option 6). You’ll want to keep a close eye on the search effectiveness output.
    If an area gets a high effectiveness score, which means that it’s been thoroughly
    searched, you may want to focus your efforts elsewhere for the rest of the game.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 根据游戏开始时的目标概率，水手最有可能在区域 2，其次是区域 3。因此，一个好的初步策略是要么对区域 2 进行两次搜索（菜单选项 2），要么同时搜索区域
    2 和区域 3（菜单选项 6）。你需要密切关注搜索效果输出。如果某个区域的效果得分很高，意味着该区域已被彻底搜索过，那么你可能想在游戏的剩余部分将精力集中在其他地方。
- en: 'The following output represents one of the worst situations you can find yourself
    in as a decision maker:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出代表了作为决策者可能遇到的最糟糕的情况之一：
- en: '[PRE18]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: After search 2, with only one search left, the target probabilities are so similar
    they provide little guidance for where to search next. In this case, it’s best
    to divide your searches between two areas and hope for the best.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在搜索 2 之后，只剩下最后一次搜索，目标概率如此相似，以至于几乎无法提供有用的指导，帮助你决定接下来该搜索哪里。在这种情况下，最好的做法是将搜索分配到两个区域之间，并寄希望于好运。
- en: Play the game a few times by blindly searching the areas in order of initial
    probability, doubling up on area 2, then 3, then 1\. Then try obeying the Bayes
    results religiously, always doubling your searches in the area with the highest
    current target probability. Next, try dividing your searches between the areas
    with the two highest probabilities. After that, allow your own intuition to have
    a say, overruling Bayes when you feel it’s appropriate. As you can imagine, with
    more search areas and more search days, human intuition would quickly get overwhelmed.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 玩几次游戏，通过盲目地按初始概率的顺序搜索区域，先加倍搜索区域2，再是区域3，然后是区域1。接下来，严格遵循贝叶斯结果，总是加倍搜索当前目标概率最高的区域。然后，尝试将搜索分配给具有两个最高概率的区域。之后，让自己的直觉发挥作用，在感觉合适时超越贝叶斯法则。正如你能想象的那样，随着搜索区域和搜索天数的增加，人类的直觉很快会感到不堪重负。
- en: '**Summary**'
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter, you learned about Bayes’ rule, a simple statistical theorem
    with broad applications in our modern world. You wrote a program that used the
    rule to take new information—in the form of estimates of search effectiveness—and
    update the probability of finding a lost sailor in each area being searched.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了贝叶斯法则，这是一条简单的统计定理，在我们现代世界中有着广泛的应用。你编写了一个程序，利用贝叶斯法则将新的信息——即搜索效果的估计——应用于更新在每个被搜索区域中找到失踪水手的概率。
- en: You also loaded and used multiple scientific packages, like NumPy and OpenCV,
    that you’ll implement throughout the book. And you applied the useful itertools,
    sys, and random modules from the Python Standard Library.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你还加载并使用了多个科学包，如NumPy和OpenCV，它们将在本书中贯穿实现。同时，你还应用了Python标准库中的有用模块，如itertools、sys和random。
- en: '**Further Reading**'
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**进一步阅读**'
- en: '*The Theory That Would Not Die: How Bayes’ Rule Cracked the Enigma Code, Hunted
    Down Russian Submarines, and Emerged Triumphant from Two Centuries of Controversy*
    (Yale University Press, 2011), by Sharon Bertsch McGrayne, recounts the discovery
    and controversial history of Bayes’ rule. The appendix includes several example
    applications of Bayes’ rule, one of which inspired the missing-sailor scenario
    used in this chapter.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '*《不会消逝的理论：贝叶斯法则如何破解密码、追踪俄罗斯潜艇，并从两百年的争议中脱颖而出*（耶鲁大学出版社，2011年），由Sharon Bertsch
    McGrayne编著，回顾了贝叶斯法则的发现与争议历史。附录中包括了贝叶斯法则的几个应用实例，其中一个启发了本章使用的失踪水手场景。'
- en: A major source of documentation for NumPy is *[https://docs.scipy.org/doc/](https://docs.scipy.org/doc/)*.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy的主要文档来源是 *[https://docs.scipy.org/doc/](https://docs.scipy.org/doc/)*。
- en: '**Challenge Project: Smarter Searches**'
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**挑战项目：更智能的搜索**'
- en: Currently, the *bayes.py* program places all the coordinates within a search
    area into a list and randomly shuffles them. Subsequent searches in the same area
    may end up retracing previous tracks. This isn’t necessarily bad from a real-life
    perspective, as the sailor will be drifting around the whole time, but overall
    it would be best to cover as much of the area as possible without repetition.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的 *bayes.py* 程序将所有坐标放入搜索区域的列表中并进行随机打乱。之后对同一地区的再次搜索可能会重复之前的轨迹。从现实生活角度来看，这不一定是坏事，因为水手会一直漂移，但总体来说，最好尽可能覆盖整个区域而不重复。
- en: Copy and edit the program so that it keeps track of which coordinates have been
    searched within an area and excludes them from future searches (until main() is
    called again, either because the player finds the sailor or chooses menu option
    7 to restart). Test the two versions of the game to see whether your changes noticeably
    impact the results.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 复制并编辑程序，使其跟踪在一个区域内哪些坐标已被搜索过，并将这些坐标从未来的搜索中排除（直到再次调用main()，无论是因为玩家找到水手，还是选择菜单选项7来重启）。测试这两个版本的游戏，看看你的修改是否明显影响了结果。
- en: '**Challenge Project: Finding the Best Strategy with MCS**'
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**挑战项目：使用MCS找到最佳策略**'
- en: Monte Carlo simulation (MCS) uses repeated random sampling to predict different
    outcomes under a specified range of conditions. Create a version of *bayes.py*
    that automatically chooses menu items and keeps track of thousands of results,
    allowing you to determine the most successful search strategy. For example, have
    the program choose menu item 1, 2, or 3 based on the highest Bayesian target probability
    and then record the search number when the sailor is found. Repeat this procedure
    10,000 times and take the average of all the search numbers. Then loop again,
    choosing from menu item 4, 5, or 6 based on the highest combined target probability.
    Compare the final averages. Is it better to double up your searches in a single
    area or split them between two areas?
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 蒙特卡洛模拟（MCS）使用重复的随机抽样来预测在指定条件范围下的不同结果。创建一个*bayes.py*版本，自动选择菜单项并跟踪成千上万的结果，使你能够确定最成功的搜索策略。例如，让程序根据最高的贝叶斯目标概率选择菜单项1、2或3，然后记录发现水手时的搜索次数。重复此过程10,000次，并取所有搜索次数的平均值。然后再次循环，根据最高的组合目标概率选择菜单项4、5或6。比较最终的平均值。是集中搜索一个区域更好，还是分配到两个区域之间更好？
- en: '**Challenge Project: Calculating the Probability of Detection**'
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**挑战项目：计算检测概率**'
- en: In a real-life search and rescue operation, you would make an estimate of the
    *expected* search effectiveness probability for each area prior to making a search.
    This expected, or *planned*, probability would be informed primarily by weather
    reports. For example, fog might roll into one search area, while the other two
    enjoy clear skies.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际的搜索和救援行动中，你需要在进行搜索前，估计每个区域的*预期*搜索有效性概率。这个预期或*计划*概率主要由天气报告提供。例如，雾气可能会侵入一个搜索区域，而其他两个区域则是晴空万里。
- en: Multiplying target probability by the planned SEP yields the *probability of
    detection (PoD)* for an area. The PoD is the probability an object will be detected
    given all known error and noise sources.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 将目标概率乘以计划SEP可得出该区域的*检测概率（PoD）*。PoD是给定所有已知误差和噪声源下，目标被检测到的概率。
- en: Write a version of *bayes.py* that includes a randomly generated planned SEP
    for each search area. Multiply the target probability for each area (such as self.p1,
    self.p2, or self.p3) by these new variables to produce a PoD for the area. For
    example, if the Bayes target probability for area 3 is 0.90 but the planned SEP
    is only 0.1, then the probability of detection is 0.09.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个*bayes.py*版本，其中每个搜索区域都包含一个随机生成的计划SEP。将每个区域的目标概率（如self.p1、self.p2或self.p3）乘以这些新变量，以产生该区域的PoD。例如，如果区域3的贝叶斯目标概率是0.90，但计划SEP仅为0.1，则检测概率为0.09。
- en: In the shell display, show the player the target probabilities, the planned
    SEPs, and the PoD for each area, as shown next. Players can then use this information
    to guide their choice from the search menu.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端显示中，向玩家展示每个区域的目标概率、计划SEP和PoD，如下所示。玩家可以利用这些信息来指导他们从搜索菜单中做出选择。
- en: '[PRE19]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To combine PoD when searching the same area twice, use this formula:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在对同一区域进行两次搜索时，结合PoD，请使用以下公式：
- en: '![Image](../images/equ_page_26_01.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/equ_page_26_01.jpg)'
- en: Otherwise, just sum the probabilities.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，只需将概率加总即可。
- en: When calculating the actual SEP for an area, constrain it somewhat to the expected
    value. This considers the general accuracy of weather reports made only a day
    in advance. Replace the random.uniform() method with a distribution, such as triangular,
    built around the planned SEP value. For a list of available distribution types,
    see *[https://docs.python.org/3/library/random.html#real-valued-distributions](https://docs.python.org/3/library/random.html#real-valued-distributions)*.
    Of course, the actual SEP for an unsearched area will always be zero.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 计算一个区域的实际SEP时，应将其限制在预期值附近。这考虑了仅提前一天发布的天气报告的一般准确性。将random.uniform()方法替换为基于计划SEP值构建的分布，例如三角分布。有关可用分布类型的列表，请参见*[https://docs.python.org/3/library/random.html#real-valued-distributions](https://docs.python.org/3/library/random.html#real-valued-distributions)*。当然，未搜索区域的实际SEP始终为零。
- en: How does incorporating planned SEPs affect gameplay? Is it easier or harder
    to win? Is it harder to grasp how Bayes’ rule is being applied? If you oversaw
    a real search, how would you deal with an area with a high target probability
    but a low planned SEP due to rough seas? Would you search anyway, call off the
    search, or move the search to an area with a low target probability but better
    weather?
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 将计划好的SEP（搜索执行计划）纳入游戏玩法中会产生什么影响？获胜变得更容易还是更难？理解贝叶斯规则的应用变得更难了吗？如果你负责一次真实的搜救行动，遇到一个目标概率很高但由于海况恶劣导致计划的SEP较低的区域，你会怎么处理？你会继续搜索，取消搜索，还是将搜索移到一个目标概率较低但天气更好的区域？
