- en: '9'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '9'
- en: BUILDING OBJECTS WITH CLASSES
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类构建对象
- en: '*Old teachers never die, they just lose their class.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*老教师不会死，他们只是失去了他们的班级。*'
- en: —Anonymous*
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: —匿名*
- en: '![image](../images/fintro-01.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fintro-01.jpg)'
- en: Now that you’ve created cool graphics using functions and other code in Processing,
    you can supercharge your creativity using classes. A *class* is a structure that
    lets you create new types of objects. The object types (usually just called *objects*)
    can have *properties*, which are variables, and *methods*, which are functions.
    There are times you want to draw multiple objects using Python, but drawing lots
    of them would be way too much work. Classes make drawing several objects with
    the same properties easy, but they require a specific syntax you’ll need to learn.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经使用函数和其他代码在 Processing 中创建了酷炫的图形，你可以通过使用类来激发你的创造力。*类* 是一种结构，它让你可以创建新的对象类型。这些对象类型（通常简称为
    *对象*）可以拥有 *属性*，即变量，以及 *方法*，即函数。有时候你想用 Python 绘制多个对象，但绘制很多对象会非常繁琐。类使得绘制多个具有相同属性的对象变得简单，但它们需要特定的语法，你需要学习。
- en: The following example from the official Python website shows how to create a
    “Dog” object using a class. To code along, open a new file in IDLE, name it *dog.py*
    and enter the following code.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 来自官方 Python 网站的以下示例展示了如何使用类创建一个“狗”对象。为了跟着一起编写代码，请在 IDLE 中打开一个新文件，将其命名为 *dog.py*，并输入以下代码。
- en: '*dog.py*'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*dog.py*'
- en: 'class Dog:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Dog:'
- en: 'def __init__(self,name):'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self,name):'
- en: self.name = name
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: self.name = name
- en: This creates a new object called Dog using class Dog. It’s customary in Python
    and many other languages to capitalize the name of a class, but it’ll still work
    if you don’t. To instantiate, or create, the class, we have to use Python’s __init__
    method, which has two underscores before and two after init, meaning it’s a special
    method to create (or *construct*) an object. The __init__ line makes it possible
    to create instances of the class (in this case, dogs). In the __init__ method,
    we can create any properties of the class we want. Since it’s a dog, it can have
    a name, and because every dog has its own name, we use the self syntax. We don’t
    need to use it when we call the objects, only when we’re defining them.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了一个名为 Dog 的新对象，使用了 Dog 类。在 Python 以及许多其他语言中，类名通常以大写字母开头，但即使不这么做也能正常工作。要实例化或创建类，我们必须使用
    Python 的 __init__ 方法，它在 init 前后各有两个下划线，表示它是一个特殊方法，用于创建（或 *构造*）对象。__init__ 这一行使得我们能够创建该类的实例（在本例中是狗）。在
    __init__ 方法中，我们可以创建类的任何属性。由于这是狗，它可以有一个名字，而且因为每只狗都有自己的名字，我们使用 self 语法。我们在调用对象时不需要使用它，只在定义它们时需要使用。
- en: 'We can then create a dog with a name using the following line of code:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以通过以下代码行创建一只带名字的狗：
- en: d = Dog('Fido')
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: d = Dog('Fido')
- en: 'Now d is a Dog and its name is Fido. You can confirm this by running the file
    and entering the following in the shell:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，d 是一只狗，它的名字是 Fido。你可以通过运行文件并在 shell 中输入以下命令来确认这一点：
- en: '>>> d.name'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> d.name'
- en: '''Fido'''
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '''Fido'''
- en: 'Now when we call d.name, we get Fido because that is the name property we just
    gave to it. We can create another Dog and give it the name Bettisa, like so:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们调用 d.name 时，我们得到 Fido，因为这是我们刚刚赋予它的名字属性。我们还可以创建另一只狗，并给它取名 Bettisa，像这样：
- en: '>>> b = Dog(''Bettisa'')'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> b = Dog(''Bettisa'')'
- en: '>>> b.name'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> b.name'
- en: '''Bettisa'''
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '''Bettisa'''
- en: You can see one dog’s name can be different from another’s, but the program
    remembers them perfectly! This will be crucial when we give locations and other
    properties to the objects we create.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，一只狗的名字可以与另一只不同，但程序能完美记住它们！这在我们给对象分配位置和其他属性时将非常重要。
- en: Finally, we can give the dog something to do by putting a function in the class.
    But don’t call it a function! A function inside a class is called a *method*.
    Dogs bark, so we’ll add that method to the code in [Listing 9-1](ch09.xhtml#ch09list1).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以通过在类中放入一个函数来给这只狗安排一些事情。但不要称它为函数！类中的函数叫做 *方法*。狗会叫，所以我们会将这个方法添加到 [示例 9-1](ch09.xhtml#ch09list1)
    中的代码。
- en: '*dog.py*'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*dog.py*'
- en: 'class Dog:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Dog:'
- en: 'def __init__(self,name):'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self,name):'
- en: self.name = name
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: self.name = name
- en: 'def bark(self):'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 'def bark(self):'
- en: print("Woof!")
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: print("汪！")
- en: d = Dog('Fido')
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: d = Dog('Fido')
- en: '*Listing 9-1: Creating a dog that barks!*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 9-1：创建一只会叫的狗！*'
- en: 'When we call the bark() method of the d dog, it barks:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用 d 狗的 bark() 方法时，它会叫：
- en: '>>> d.bark()'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> d.bark()'
- en: Woof!
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 汪！
- en: It might not be clear why you’d need a Dog class from this simple example, but
    it’s good to know you can do literally anything you want with classes and be as
    creative as you want. In this chapter, we use classes to make lots of useful objects
    like bouncing balls and grazing sheep. Let’s start with the Bouncing Ball example
    to see how using classes lets us do something really cool while saving us a lot
    of work.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的例子可能不太能看出为什么需要一个 Dog 类，但了解你可以用类做任何事情，并且可以充分发挥创造力，还是很有帮助的。在本章中，我们使用类来制作许多有用的对象，比如弹跳球和吃草的羊。我们从弹跳球的例子开始，看看使用类是如何让我们做一些非常酷的事情，同时节省大量工作的。
- en: BOUNCING BALL PROGRAM
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 弹跳球程序
- en: Start a Processing sketch and save it as *BouncingBall.pyde*. We’ll draw a single
    circle on the screen, which we’ll make into a bouncing ball. [Listing 9-2](ch09.xhtml#ch09list2)
    shows the code for drawing one circle.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 启动一个 Processing 草图并将其保存为 *BouncingBall.pyde*。我们将在屏幕上绘制一个圆形，并将其变成一个弹跳球。[代码清单
    9-2](ch09.xhtml#ch09list2)展示了绘制一个圆形的代码。
- en: '*BouncingBall.pyde*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*BouncingBall.pyde*'
- en: 'def setup():'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 'def setup():'
- en: size(600,600)
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: size(600,600)
- en: 'def draw():'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 'def draw():'
- en: 'background(0) #black'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 'background(0) #黑色'
- en: ellipse(300,300,20,20)
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: ellipse(300,300,20,20)
- en: '*Listing 9-2: Drawing a circle*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*代码清单 9-2：绘制一个圆形*'
- en: First, we set the size of the window to be 600 pixels wide and 600 pixels tall.
    Then we set the background to black and drew a circle using the ellipse() function.
    The first two numbers in the function describe how far the center of the circle
    is from the top-left corner of the window, and the last two numbers describe the
    width and height of the ellipse. In this case, ellipse(300,300, 20,20) creates
    a circle that is 20 pixels wide and 20 pixels high, located in the center of the
    display window, as shown in [Figure 9-1](ch09.xhtml#ch09fig1).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将窗口的大小设置为 600 像素宽和 600 像素高。然后，我们将背景设置为黑色，并使用 ellipse() 函数绘制一个圆形。函数中的前两个数字描述圆心距窗口左上角的距离，最后两个数字描述椭圆的宽度和高度。在这个例子中，ellipse(300,300,
    20,20) 创建了一个 20 像素宽、20 像素高的圆形，位于显示窗口的中央，如图 [图 9-1](ch09.xhtml#ch09fig1)所示。
- en: '![image](../images/f177-01.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f177-01.jpg)'
- en: '*Figure 9-1: Drawing one circle for the Bouncing Ball sketch*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-1：为弹跳球草图绘制一个圆形*'
- en: Now that we have successfully created a circle located in the center of the
    display window, let’s try to make it move.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功地在显示窗口的中心创建了一个圆形，接下来我们尝试让它移动。
- en: '#### MAKING THE BALL MOVE'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 让球移动'
- en: We’ll make the ball move by changing its position. To do this, let’s first create
    a variable for the x-value and a variable for the y-value and set them to 300,
    which is the middle of the screen. Go back to [Listing 9-2](ch09.xhtml#ch09list2)
    and insert the following two lines at the beginning of the code, like in [Listing
    9-3](ch09.xhtml#ch09list3).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过改变球的位置来让它移动。为此，我们首先创建一个用于 x 值的变量和一个用于 y 值的变量，并将它们设置为 300，也就是屏幕的中间。返回到 [代码清单
    9-2](ch09.xhtml#ch09list2)，并在代码的开头插入以下两行，就像在 [代码清单 9-3](ch09.xhtml#ch09list3)
    中那样。
- en: '*BouncingBall.pyde*'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*BouncingBall.pyde*'
- en: xcor = 300
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: xcor = 300
- en: ycor = 300
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ycor = 300
- en: 'def setup():'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 'def setup():'
- en: size(600,600)
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: size(600,600)
- en: '*Listing 9-3: Setting variables for the x- and y-values*'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*代码清单 9-3：设置 x 和 y 值的变量*'
- en: Here, we use the xcor variable to represent the x-value and the ycor variable
    to represent the y-value. Then we set both variables to 300.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 xcor 变量表示 x 值，使用 ycor 变量表示 y 值。然后，我们将两个变量都设置为 300。
- en: Now let’s change the x-value and y-value by a certain number in order to change
    the location of the ellipse. Make sure to use the variables to draw the ellipse,
    as shown in [Listing 9-4](ch09.xhtml#ch09list4).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们通过改变 x 值和 y 值来改变椭圆的位置。确保使用这些变量来绘制椭圆，如 [代码清单 9-4](ch09.xhtml#ch09list4)
    所示。
- en: '*BouncingBall.pyde*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*BouncingBall.pyde*'
- en: xcor = 300
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: xcor = 300
- en: ycor = 300
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ycor = 300
- en: 'def setup():'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 'def setup():'
- en: size(600,600)
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: size(600,600)
- en: 'def draw():'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 'def draw():'
- en: ➊ global xcor, ycor
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ global xcor, ycor
- en: 'background(0) #black'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 'background(0) #黑色'
- en: xcor += 1
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: xcor += 1
- en: ycor += 1
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ycor += 1
- en: ellipse(xcor,ycor,20,20)
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ellipse(xcor,ycor,20,20)
- en: '*Listing 9-4: Incrementing xcor and ycor to change the location of the ellipse*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*代码清单 9-4：增加 xcor 和 ycor 来改变椭圆的位置*'
- en: 'The important thing to notice in this example is global xcor, ycor ➊, which
    tells Python to use the variables we’ve already created and not to create new
    ones just for the draw() function. If you don’t include this line, you’ll get
    an error message, something like “local variable ‘xcor’ referenced before assignment.”
    Once Processing knows what value to assign to xcor and ycor, we increment them
    both by 1 and draw the ellipse with its center at the location specified using
    the global variables: (xcor, ycor).'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例中需要注意的重点是全局变量 xcor 和 ycor ➊，它告诉 Python 使用我们已经创建的变量，而不是仅仅为 draw() 函数创建新的变量。如果你不包括这一行，你会得到一个错误消息，比如“局部变量
    ‘xcor’ 在赋值前被引用”。一旦 Processing 知道该给 xcor 和 ycor 赋什么值，我们就将它们都加 1，并使用全局变量 (xcor,
    ycor) 来绘制椭圆，椭圆的中心位置是由这些变量指定的。
- en: When you save and run [Listing 9-4](ch09.xhtml#ch09list4), you should see the
    ball move, like in [Figure 9-2](ch09.xhtml#ch09fig2).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当你保存并运行 [清单 9-4](ch09.xhtml#ch09list4) 时，你应该看到球体移动，就像在 [图 9-2](ch09.xhtml#ch09fig2)
    中一样。
- en: Now the ball moves down and to the right, because its x- and y-values are both
    increasing, but then it moves off the screen and we never see it again! The program
    keeps incrementing our variables obediently. It doesn’t know it’s drawing a ball
    or that we want the ball to bounce off the walls. Let’s explore how to keep the
    ball from disappearing.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，球体向下和向右移动，因为它的 x 和 y 值都在增加，但接着它就会离开屏幕，我们再也看不见它了！程序继续听从指令地增加我们的变量。它并不知道它正在绘制一个球体，也不知道我们希望球体能弹回墙壁。接下来让我们看看如何防止球体消失。
- en: '![image](../images/f179-01.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f179-01.jpg)'
- en: '*Figure 9-2: The ball moves!*'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-2：球体移动了！*'
- en: MAKING THE BALL BOUNCE OFF THE WALL
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 让球体弹回墙壁
- en: When we change the x-value and the y-value by adding 1, we’re changing the position
    of an object. In math, this change in position over time is called *velocity*.
    A positive change in x over time (positive x-velocity) will look like movement
    to the right (since x is getting bigger), whereas negative x-velocity will look
    like movement to the left. We can use this “positive-right, negative-left” concept
    to make the ball bounce off the wall. First, let’s create the x-velocity and y-velocity
    variables by adding the following lines to our existing code, as shown in [Listing
    9-5](ch09.xhtml#ch09list5).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们通过加 1 来改变 x 值和 y 值时，我们实际上是在改变物体的位置。在数学中，这种随时间变化的位置变化被称为 *速度*。在时间内 x 的正向变化（正
    x 速度）看起来像是向右移动（因为 x 在变大），而负 x 速度则看起来像是向左移动。我们可以利用这个“正右负左”的概念来让球体弹回墙壁。首先，我们通过向现有代码中添加以下几行来创建
    x 速度和 y 速度变量，如 [清单 9-5](ch09.xhtml#ch09list5) 所示。
- en: '*BouncingBall.pyde*'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*BouncingBall.pyde*'
- en: xcor = 300
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: xcor = 300
- en: ycor = 300
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ycor = 300
- en: xvel = 1
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: xvel = 1
- en: yvel = 2
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: yvel = 2
- en: 'def setup():'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 'def setup():'
- en: size(600,600)
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: size(600, 600)
- en: 'def draw():'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 'def draw():'
- en: global xcor,ycor,xvel,yvel
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: global xcor, ycor, xvel, yvel
- en: 'background(0) #black'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 'background(0) # 黑色背景'
- en: xcor += xvel
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: xcor += xvel
- en: ycor += yvel
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ycor += yvel
- en: '#if the ball reaches a wall, switch direction.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '# 如果球体触及墙壁，改变方向。'
- en: 'if xcor > width or xcor < 0:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 xcor > 宽度或 xcor < 0:'
- en: xvel = -xvel
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: xvel = -xvel
- en: 'if ycor > height or ycor < 0:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 ycor > 高度 或 ycor < 0:'
- en: yvel = -yvel
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: yvel = -yvel
- en: ellipse(xcor,ycor,20,20)
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ellipse(xcor, ycor, 20, 20)
- en: '*Listing 9-5: Adding code to make the ball bounce off the wall*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-5：添加代码让球体弹回墙壁*'
- en: First, we set xvel = 1 and yvel = 2 to specify how the ball will move. You can
    use other values and see how they change the movement. Then in the draw() function,
    we tell Python that xvel and yvel are global variables, and we change the x- and
    y-coordinates by incrementing using these variables. For example, when we set
    xcor += xvel, we’re updating the position by the velocity (the *change* in position).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将 xvel = 1 和 yvel = 2 来指定球体的移动方式。你可以尝试其他数值，看看它们如何改变球体的运动。然后，在 draw() 函数中，我们告诉
    Python xvel 和 yvel 是全局变量，并通过增加这些变量来改变 x 和 y 坐标。例如，当我们设置 xcor += xvel 时，我们就是通过速度（位置的
    *变化*）来更新位置。
- en: The two if statements tell the program that if the ball’s position goes outside
    the boundaries of the screen, it should change the ball’s velocity to its negative
    value. When we change the ball’s velocity to its negative value, we tell the program
    to move the ball in the opposite direction it was moving in, making it seem like
    the ball is bouncing off the wall.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个 if 语句告诉程序，如果球体的位置超出屏幕边界，它应该将球体的速度改为其负值。当我们将球体的速度改为负值时，我们就是在告诉程序让球体朝相反方向移动，这样就像是球体弹回了墙壁。
- en: We need to be precise in telling at what point the ball should move in the opposite
    direction in terms of its coordinates. For example, xcor > width represents cases
    where xcor is larger than the width of the display window, which is when the ball
    touches the right edge of the screen. And xcor < 0 represents instances where
    the xcor is less than 0 or when the ball touches the left edge of the screen.
    Similarly, ycor > height checks for instances where ycor is larger than the height
    of the window or when the ball reaches the bottom of the screen. Finally, ycor
    < 0 checks for instances where the ball reaches the upper edge of the screen.
    Since moving to the right is positive x-velocity (positive change in x), the opposite
    direction is negative x-velocity. If the velocity is already negative (it’s moving
    to the left), then the negative of a negative is a positive, which means the ball
    will move to the right, just like we want it to.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要精确地指出球应该在哪个坐标点反向移动。例如，xcor > width 表示 xcor 大于显示窗口的宽度，意味着球触碰到了屏幕的右边缘。而 xcor
    < 0 表示 xcor 小于 0，或者球触碰到了屏幕的左边缘。类似地，ycor > height 检查 ycor 是否大于窗口的高度，或者球到达了屏幕的底部。最后，ycor
    < 0 检查球是否到达了屏幕的上边缘。由于向右移动是正的 x 速度（x 的正变化），反方向是负的 x 速度。如果速度已经是负的（它正在向左移动），那么负数的负数是正数，这意味着球将向右移动，正如我们希望的那样。
- en: When you run [Listing 9-5](ch09.xhtml#ch09list5), you should see something like
    what’s shown in [Figure 9-3](ch09.xhtml#ch09fig3).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行[列出9-5](ch09.xhtml#ch09list5)时，你应该能看到类似[图9-3](ch09.xhtml#ch09fig3)中所展示的效果。
- en: '![image](../images/f180-01.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f180-01.jpg)'
- en: '*Figure 9-3: One bouncing ball!*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-3：一个弹跳的球！*'
- en: The ball looks like it’s bouncing off the walls and therefore stays in view.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 球看起来像是从墙壁上反弹，因此始终保持在视图内。
- en: '#### MAKING MULTIPLE BALLS WITHOUT CLASSES'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 在没有类的情况下创建多个球'
- en: Now suppose we want to make another bouncing ball, or many other bouncing balls.
    How would we do that? We could make a new variable for the second ball’s x-value,
    another variable for the second ball’s y-value, a third variable for its x-velocity,
    and a fourth for its y-velocity. Then we’d have to increment its position by its
    velocity, check if it needs to bounce off a wall, and finally draw it. However,
    we’d end up with double the amount of code! Adding a third ball would triple our
    code! Twenty balls would simply be out of the question. You *don’t* want to have
    to keep track of all these variables for position and velocity. [Listing 9-6](ch09.xhtml#ch09list6)
    show what this would look like.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们想要创建另一个弹跳球，或者许多其他的弹跳球。我们该怎么做呢？我们可以为第二个球的 x 值创建一个新变量，为第二个球的 y 值再创建一个变量，为其
    x 速度创建第三个变量，再为其 y 速度创建第四个变量。然后，我们必须根据速度增加其位置，检查是否需要从墙壁反弹，最后绘制它。然而，我们最终会得到双倍的代码量！添加第三个球将使我们的代码量增加三倍！二十个球简直无法想象。你*不*想要一直跟踪这些位置和速度的变量。[列出9-6](ch09.xhtml#ch09list6)展示了这种情况。
- en: '#ball1:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '#ball1:'
- en: ball1x = random(width)
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: ball1x = random(width)
- en: ball1y = random(height)
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: ball1y = random(height)
- en: ball1xvel = random(-2,2)
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ball1xvel = random(-2,2)
- en: ball1tvel = random(-2,2)
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ball1tvel = random(-2,2)
- en: '#ball2:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '#ball2:'
- en: ball2x = random(width)
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ball2x = random(width)
- en: ball2y = random(height)
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ball2y = random(height)
- en: ball2xvel = random(-2,2)
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ball2xvel = random(-2,2)
- en: ball2tvel = random(-2,2)
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ball2tvel = random(-2,2)
- en: '#ball3:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '#ball3:'
- en: ball3x = random(width)
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ball3x = random(width)
- en: ball3y = random(height)
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ball3y = random(height)
- en: ball3xvel = random(-2,2)
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ball3xvel = random(-2,2)
- en: ball3tvel = random(-2,2)
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ball3tvel = random(-2,2)
- en: '#update ball1:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '#更新球1：'
- en: ball1x += ball1xvel
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ball1x += ball1xvel
- en: ball1y += ball1yvel
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ball1y += ball1yvel
- en: ellipse(ball1x,ball1y,20,20)
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: ellipse(ball1x,ball1y,20,20)
- en: '#update ball2:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '#更新球2：'
- en: ball2x += ball2xvel
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ball2x += ball2xvel
- en: ball2y += ball2yvel
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: ball2y += ball2yvel
- en: ellipse(ball2x,ball2y,20,20)
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ellipse(ball2x,ball2y,20,20)
- en: '#update ball3:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '#更新球3：'
- en: ball3x += ball3xvel
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: ball3x += ball3xvel
- en: ball3y += ball3yvel
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ball3y += ball3yvel
- en: ellipse(ball3x,ball3y,20,20)
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ellipse(ball3x,ball3y,20,20)
- en: '*Listing 9-6: Creating multiple balls without classes. Way too much code!*'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*列出9-6：在没有类的情况下创建多个球。代码太多了！*'
- en: This is the code for creating only three balls. As you can see, it’s very long,
    and this doesn’t even include the bouncing part! Let’s see how we can use classes
    to make this task easier.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这是仅创建三个球的代码。正如你所看到的，它非常长，而且这还不包括反弹部分！让我们看看如何利用类来简化这项任务。
- en: '#### CREATING OBJECTS USING CLASSES'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 使用类创建对象'
- en: In programming, a class works like a recipe that details a way to create an
    object with its own specific properties. Using classes, we tell Python how to
    make a ball once. Then all we have to do is create a bunch of balls using a for
    loop and put them in a list. Lists are great for saving numerous things—strings,
    numbers, and objects!
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，类就像是一个食谱，详细说明了如何创建一个具有特定属性的对象。通过使用类，我们告诉 Python 如何创建一个球体一次。然后，我们只需使用 for
    循环创建多个球体，并将它们放入列表中。列表非常适合保存多个事物——字符串、数字和对象！
- en: 'Follow these three steps when using classes to create objects:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类创建对象时，请按照以下三个步骤操作：
- en: '*Write the class*. This is like a recipe for how to make balls, planets, rockets,
    and so on.'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*编写类*。这就像是制作球体、行星、火箭等的食谱。'
- en: '*Instantiate the object or objects*. You do this by calling the objects in
    the setup() function.'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*实例化对象*。通过在 setup() 函数中调用对象来执行此操作。'
- en: '*Update the object or objects*. Do this in the draw() function (the display
    loop).'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*更新对象*。在 draw() 函数（显示循环）中执行此操作。'
- en: Let’s use these steps to put the code we’ve already written into a class.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用这些步骤将我们已经编写的代码放入类中。
- en: Writing the Class
  id: totrans-141
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 编写类
- en: The first step in creating objects using classes is to write a class that tells
    the program how to make a ball. Let’s add the code in [Listing 9-7](ch09.xhtml#ch09list7)
    at the very beginning of our existing program.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类创建对象的第一步是编写一个类，告诉程序如何制作一个球体。让我们将 [列表 9-7](ch09.xhtml#ch09list7) 中的代码添加到我们现有程序的最前面。
- en: '*BouncingBall.pyde*'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*BouncingBall.pyde*'
- en: 'ballList=[] #empty list to put the balls in'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 'ballList=[]  # 用于存放球体的空列表'
- en: 'class Ball:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Ball:'
- en: 'def __init__(self,x,y):'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, x, y):'
- en: '''''''How to initialize a Ball'''''''
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '''''''如何初始化一个 Ball'''''''
- en: self.xcor = x
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: self.xcor = x
- en: self.ycor = y
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: self.ycor = y
- en: self.xvel = random(-2,2)
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: self.xvel = random(-2, 2)
- en: self.yvel = random(-2,2)
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: self.yvel = random(-2, 2)
- en: '*Listing 9-7: Defining a class called Ball*'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-7：定义一个名为 Ball 的类*'
- en: 'Note that because we’re putting the position and velocity variables into the
    Ball class as properties, you can delete the following lines from your existing
    code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于我们将位置和速度变量作为属性放入 Ball 类中，您可以从现有代码中删除以下几行：
- en: xcor = 300
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: xcor = 300
- en: ycor = 300
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ycor = 300
- en: xvel = 1
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: xvel = 1
- en: yvel = 2
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: yvel = 2
- en: In [Listing 9-7](ch09.xhtml#ch09list7), we create an empty list we’ll use to
    save the balls in; then we start defining the recipe. The name of a class object,
    which is Ball in this case, is always capitalized. The __init__ method is a requirement
    to create a class in Python that contains all the properties the object gets when
    it’s initialized. Otherwise, the class won’t work.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 9-7](ch09.xhtml#ch09list7) 中，我们创建了一个空列表，用于保存球体；然后我们开始定义食谱。类对象的名称（在这里是
    Ball）总是首字母大写。__init__ 方法是 Python 中创建类的必要条件，它包含对象在初始化时获得的所有属性。否则，类将无法工作。
- en: 'The self syntax simply means every object has its own methods and properties,
    which are functions and variables that can’t be used except by a Ball object.
    This means that each Ball has its own xcor, its own ycor, and so on. Because we
    might have to create a Ball at a specific location at some point, we made x and
    y parameters of the __init__ method. Adding these parameters allows us to tell
    Python the location of a Ball when we create it, like this:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: self 语法意味着每个对象都有自己的方法和属性，这些函数和变量只能由 Ball 对象使用。这意味着每个 Ball 都有自己的 xcor、ycor 等等。因为我们可能需要在某个特定位置创建一个
    Ball，所以我们将 x 和 y 作为 __init__ 方法的参数。添加这些参数使我们能够在创建 Ball 时告诉 Python 其位置，如下所示：
- en: Ball(100,200)
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Ball(100, 200)
- en: In this case, the ball will be located at the coordinate (100,200).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，球体将位于坐标 (100,200)。
- en: The last lines in [Listing 9-7](ch09.xhtml#ch09list7) tell Processing to assign
    a random number between –2 and 2 to be the x- and y-velocity of the new ball.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 9-7](ch09.xhtml#ch09list7)中的最后几行告诉 Processing 为新球体分配一个介于 -2 和 2 之间的随机数作为其
    x 和 y 速度。'
- en: Instantiating the Object
  id: totrans-163
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实例化对象
- en: Now that we’ve created a class called Ball, we need to tell Processing how to
    update the ball every time the draw() function loops. We’ll call that the update
    method and nest it inside the Ball class, just like we did with __init__. You
    can simply cut and paste all the ball code into the update() method and then add
    self. to each of the object’s properties, as shown in [Listing 9-8](ch09.xhtml#ch09list8).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个名为 Ball 的类，我们需要告诉 Processing 如何在每次 draw() 函数循环时更新球体。我们称之为更新方法，并将其嵌套在
    Ball 类内部，就像我们在 __init__ 中所做的那样。您只需将所有球体代码剪切并粘贴到 update() 方法中，然后在每个对象的属性前添加 self.，如
    [列表 9-8](ch09.xhtml#ch09list8) 所示。
- en: '*BouncingBall.pyde*'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*BouncingBall.pyde*'
- en: 'ballList=[] #empty list to put the balls in'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 'ballList=[] #空列表，用于存放小球'
- en: 'class Ball:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Ball:'
- en: 'def __init__(self,x,y):'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self,x,y):'
- en: '''''''How to initialize a Ball'''''''
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '''''''如何初始化一个小球'''''''
- en: self.xcor = x
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: self.xcor = x
- en: self.ycor = y
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: self.ycor = y
- en: self.xvel = random(-2,2)
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: self.xvel = random(-2,2)
- en: self.yvel = random(-2,2)
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: self.yvel = random(-2,2)
- en: 'def update(self):'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 'def update(self):'
- en: self.xcor += self.xvel
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: self.xcor += self.xvel
- en: self.ycor += self.yvel
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: self.ycor += self.yvel
- en: '#if the ball reaches a wall, switch direction'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '#如果小球碰到墙壁，则改变方向'
- en: 'if self.xcor > width or self.xcor < 0:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 'if self.xcor > width or self.xcor < 0:'
- en: self.xvel = -self.xvel
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: self.xvel = -self.xvel
- en: 'if self.ycor > height or self.ycor < 0:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 'if self.ycor > height or self.ycor < 0:'
- en: self.yvel = -self.yvel
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: self.yvel = -self.yvel
- en: ellipse(self.xcor,self.ycor,20,20)
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: ellipse(self.xcor,self.ycor,20,20)
- en: '*Listing 9-8: Creating the update() method*'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单9-8：创建update()方法*'
- en: Here, we placed all the code for moving and bouncing a ball into the update()
    method of the Ball class. The only new code is self in the velocity variables,
    making them velocity properties of the Ball object. Although it might seem like
    there are many instances of self, that’s how we tell Python that the x-coordinate,
    for example, belongs to that specific ball and not another. Very soon, Python
    is going to be updating a hundred balls, so we need self to keep track of each
    one’s location and velocity.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将所有用于移动和反弹小球的代码都放入了Ball类的update()方法中。唯一的新代码是速度变量中的self，使它们成为Ball对象的速度属性。虽然看起来有很多self的实例，但这就是我们告诉Python，x坐标例如属于特定的小球而不是其他小球的方式。很快，Python将更新上百个小球，因此我们需要self来跟踪每个小球的位置和速度。
- en: Now that the program knows how to create and update a ball, let’s update the
    setup() function to create three balls and put them into the ball list (ballList),
    as shown in [Listing 9-9](ch09.xhtml#ch09list9).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在程序已经知道如何创建和更新小球，让我们更新setup()函数，创建三个小球并将它们放入小球列表（ballList）中，如[清单9-9](ch09.xhtml#ch09list9)所示。
- en: 'def setup():'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 'def setup():'
- en: size(600,600)
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: size(600,600)
- en: 'for i in range(3):'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(3):'
- en: ballList.append(Ball(random(width),
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: ballList.append(Ball(random(width),
- en: random(height)))
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: random(height)))
- en: '*Listing 9-9: Creating three balls in the setup() function*'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单9-9：在setup()函数中创建三个小球*'
- en: We created ballList in [Listing 9-7](ch09.xhtml#ch09list7) already, and here
    we’re appending to the list a Ball at a random location. When the program creates
    (instantiates) a new ball, it will now choose a random number between 0 and the
    width of the screen to be the x-coordinate and another random number between 0
    and the height of the screen to be the y-coordinate. Then it’ll put that new ball
    into the list. Because we used the loop for i in range(3), the program will add
    three balls to the ball list.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[清单9-7](ch09.xhtml#ch09list7)中创建了ballList，这里我们向列表添加一个在随机位置的小球。当程序创建（实例化）一个新小球时，它将选择一个在0和屏幕宽度之间的随机数作为x坐标，并选择另一个在0和屏幕高度之间的随机数作为y坐标。然后，它会将这个新小球放入列表中。由于我们使用了循环for
    i in range(3)，程序将向小球列表中添加三个小球。
- en: Updating the Object
  id: totrans-193
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 更新对象
- en: 'Now let’s tell the program to go through ballList and update all the balls
    in the list (which means drawing them) every loop using the following draw() function:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们告诉程序每次循环时都遍历ballList，并更新列表中的所有小球（即绘制它们），使用如下的draw()函数：
- en: '*BouncingBall.pyde*'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '*BouncingBall.pyde*'
- en: 'def draw():'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 'def draw():'
- en: 'background(0) #black'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 'background(0) #黑色'
- en: 'for ball in ballList:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 'for ball in ballList:'
- en: ball.update()
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: ball.update()
- en: Note that we still want the background to be black, and then we loop over the
    ball list and for every ball in the list we run its update() method. All the previous
    code in draw() went into the Ball class!
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们仍然希望背景是黑色的，然后我们遍历小球列表，并对列表中的每个小球运行它的update()方法。所有之前在draw()中的代码都已移入Ball类中！
- en: '![image](../images/f184-01.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f184-01.jpg)'
- en: '*Figure 9-4: Creating as many bouncing balls as you want!*'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-4：创建任意数量的反弹小球！*'
- en: 'When you run this sketch, you should see three balls moving around the screen
    and bouncing off the walls! The great thing about using classes is that it’s super
    easy to change the number of balls. All you have to do is change the *number*
    in for i in range(*number*): in the setup() function to create even more bouncing
    balls. When you change this to 20, for example, you’ll see something like [Figure
    9-4](ch09.xhtml#ch09fig4).'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个示例时，你应该会看到三个小球在屏幕上移动并撞击墙壁反弹！使用类的一个好处是，改变小球数量非常简单。你只需要更改setup()函数中for i
    in range(*number*):中的*number*，就能创建更多反弹的小球。例如，当你将其改为20时，你将看到类似[图9-4](ch09.xhtml#ch09fig4)的效果。
- en: What’s cool about using classes is that you can give an object any properties
    or methods you want. For example, we don’t have to make our balls all the same
    color. Add the three lines of code shown in [Listing 9-10](ch09.xhtml#ch09list10)
    to your existing Ball class.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类的一个好处是，你可以为一个对象赋予任何你想要的属性或方法。例如，我们不需要让所有球体的颜色都相同。将[清单9-10](ch09.xhtml#ch09list10)中的三行代码添加到你现有的Ball类中。
- en: '*BouncingBall.pyde*'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '*BouncingBall.pyde*'
- en: 'class Ball:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Ball:'
- en: 'def __init__(self,x,y):'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self,x,y):'
- en: '''''''How to initialize a Ball'''''''
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '''''''如何初始化一个Ball对象'''''''
- en: self.xcor = x
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: self.xcor = x
- en: self.ycor = y
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: self.ycor = y
- en: self.xvel = random(-2,2)
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: self.xvel = random(-2,2)
- en: self.yvel = random(-2,2)
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: self.yvel = random(-2,2)
- en: self.col = color(random(255),
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: self.col = color(random(255),
- en: random(255),
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: random(255),
- en: random(255))
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: random(255))
- en: '*Listing 9-10: Updating the Ball class*'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单9-10：更新Ball类*'
- en: This code gives every ball its own color when it’s created. Processing’s color()
    function needs three numbers that represent red, green, and blue, respectively.
    RGB values go from 0 to 255\. Using random(255) lets the program choose the numbers
    randomly, resulting in a randomly chosen color. However, because the __init__
    method runs only one time, once the ball has a color, it keeps it.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码在每个球体创建时赋予其独特的颜色。Processing的color()函数需要三个数字，分别表示红色、绿色和蓝色。RGB值的范围是从0到255。使用random(255)允许程序随机选择这三个数值，从而得到一个随机的颜色。然而，由于__init__方法只会运行一次，一旦球体有了颜色，它就会保持这个颜色。
- en: 'Next, in the update() method, add the following line so the ellipse gets filled
    with its own randomly chosen color:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在update()方法中，添加以下代码行，使椭圆填充其自身随机选择的颜色：
- en: fill(self.col)
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: fill(self.col)
- en: ellipse(self.xcor,self.ycor,20,20)
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ellipse(self.xcor,self.ycor,20,20)
- en: Before a shape or line gets drawn, you can declare its color using fill for
    shapes or stroke for lines. Here, we tell Processing to use the ball’s own color
    (using self) to fill in the following shape.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在绘制形状或线条之前，可以使用fill来声明形状的颜色，使用stroke来声明线条的颜色。在这里，我们告诉Processing使用球体自身的颜色（使用self）来填充以下形状。
- en: Now when you run the program, each ball should have a random color, as shown
    in [Figure 9-5](ch09.xhtml#ch09fig5)!
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你运行程序时，每个球体都应该具有随机的颜色，如[图9-5](ch09.xhtml#ch09fig5)所示！
- en: '![image](../images/f185-01.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f185-01.jpg)'
- en: '*Figure 9-5: Giving balls their own colors*'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-5：给球体赋予各自的颜色*'
- en: 'EXERCISE 9-1: CREATING BALLS OF DIFFERENT SIZES'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 练习9-1：创建不同大小的球体
- en: Give each ball its own size, between 5 and 50 units.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 给每个球体设置一个自己的大小，范围在5到50个单位之间。
- en: GRAZING SHEEP PROGRAM
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 吃草的羊程序
- en: Now that you can create classes, let’s make something useful. We’ll code a Processing
    sketch of an ecosystem that simulates sheep walking around eating grass. In this
    sketch, the sheep have a certain level of energy that gets depleted as they walk
    around, and their energy gets replenished when they eat grass. If they get enough
    energy, they reproduce. If they don’t get enough energy, they die. We could potentially
    learn a lot about biology, ecology, and evolution by creating and tweaking this
    model.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以创建类了，接下来我们来做一些有用的东西。我们将编写一个Processing的生态系统草图，模拟羊在四处走动并吃草。在这个草图中，羊有一定的能量，随着它们走动，能量会逐渐消耗，当它们吃草时，能量会被补充。如果它们的能量足够，它们就会繁殖；如果能量不足，它们就会死亡。通过创建和调整这个模型，我们有可能学到很多关于生物学、生态学和进化的知识。
- en: In this program, the Sheep objects are kind of like the Ball objects you created
    earlier in this chapter; each has its own x- and y-position and size, and is represented
    by a circle.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，Sheep对象有点像你在本章早些时候创建的Ball对象；每个都有自己的x和y坐标，以及大小，并用圆形表示。
- en: WRITING THE CLASS FOR THE SHEEP
  id: totrans-230
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编写羊类
- en: Start a new Processing sketch and save it as *SheepAndGrass.pyde*. First, let’s
    create a class that makes a Sheep object with its own x- and y-position and its
    own size. Then we’ll create an update method that draws an ellipse representing
    the sheep’s size at the sheep’s location.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 开始一个新的Processing草图并保存为*SheepAndGrass.pyde*。首先，让我们创建一个类，使其能够生成一个具有自定义x和y坐标以及自定义大小的Sheep对象。接着，我们将创建一个update方法，在羊的位置绘制一个表示羊大小的椭圆。
- en: The class code is nearly identical to the Ball class, as you can see in [Listing
    9-11](ch09.xhtml#ch09list11).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 该类代码几乎与Ball类相同，正如你在[清单9-11](ch09.xhtml#ch09list11)中看到的那样。
- en: '*SheepAndGrass.pyde*'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '*SheepAndGrass.pyde*'
- en: 'class Sheep:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Sheep:'
- en: 'def __init__(self,x,y):'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self,x,y):'
- en: 'self.x = x #x-position'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 'self.x = x #x-position'
- en: 'self.y = y #y-position'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 'self.y = y #y-position'
- en: 'self.sz = 10 #size'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 'self.sz = 10 #大小'
- en: 'def update(self):'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 'def update(self):'
- en: ellipse(self.x,self.y,self.sz,self.sz)
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: ellipse(self.x,self.y,self.sz,self.sz)
- en: '*Listing 9-11: Creating a class for one sheep*'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单9-11：创建一个羊类*'
- en: Because we know we’ll be making a bunch of sheep, we start off creating a Sheep
    class. In the required __init__ method, we set the x- and y-coordinates of the
    sheep to the parameters we’ll declare when creating a sheep instance. I’ve set
    the size of the sheep (the diameter of the ellipse) to 10 pixels, but you can
    have bigger or smaller sheep if you like. The update() method simply draws an
    ellipse of the sheep’s size at the sheep’s location.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们知道以后会创建很多羊，所以我们开始创建一个Sheep类。在必需的__init__方法中，我们将羊的x和y坐标设置为我们在创建羊实例时声明的参数。我将羊的大小（椭圆的直径）设置为10像素，但如果你喜欢，也可以设置更大或更小的羊。update()方法仅仅是根据羊的位置绘制一个与羊大小相同的椭圆。
- en: Here’s the setup() and draw() code for a Processing sketch containing one Sheep,
    which I’ve named shawn. Add the code shown in [Listing 9-12](ch09.xhtml#ch09list12)
    right below the update() method you just wrote in [Listing 9-11](ch09.xhtml#ch09list11).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这是包含一个名为shawn的Sheep的Processing草图中的setup()和draw()代码。将[清单 9-12](ch09.xhtml#ch09list12)中显示的代码添加到你刚才在[清单
    9-11](ch09.xhtml#ch09list11)中写的update()方法下面。
- en: 'def setup():'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 'def setup():'
- en: global shawn
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: global shawn
- en: size(600,600)
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: size(600,600)
- en: '#create a Sheep object called shawn at (300,200)'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '#在(300,200)创建一个名为shawn的Sheep对象'
- en: shawn = Sheep(300,200)
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: shawn = Sheep(300,200)
- en: 'def draw():'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 'def draw():'
- en: background(255)
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: background(255)
- en: shawn.update()
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: shawn.update()
- en: '*Listing 9-12: Creating a Sheep object named shawn*'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-12：创建一个名为shawn的Sheep对象*'
- en: We first create shawn, an instance of a Sheep object, in the setup() function.
    Then we update it in the draw() function—but Python doesn’t know we mean the same
    shawn unless we tell it that shawn is a global variable.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在setup()函数中创建了shawn，一个Sheep对象的实例。然后我们在draw()函数中更新它——但是Python不知道我们指的是同一个shawn，除非我们告诉它shawn是一个全局变量。
- en: When you run this code, you should see something like what’s shown in [Figure
    9-6](ch09.xhtml#ch09fig6).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这段代码时，你应该会看到类似[图 9-6](ch09.xhtml#ch09fig6)所示的效果。
- en: '![image](../images/f187-01.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f187-01.jpg)'
- en: '*Figure 9-6: One sheep*'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-6：一只羊*'
- en: You get a white screen with a little circular sheep at the coordinate (300,200),
    which is 300 pixels to the right of the starting point and 200 pixels down.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到一个白色的屏幕，上面有一只小圆形的羊，位于坐标（300,200），即距离起始点300像素，向下200像素。
- en: PROGRAMMING SHEEP TO MOVE AROUND
  id: totrans-258
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编程让羊四处移动
- en: 'Now let’s teach a Sheep how to move around. We’ll start by programming the
    Sheep to move around randomly. (You can always program it to move differently
    in the future if you want to.) [Listing 9-13](ch09.xhtml#ch09list13) changes the
    x- and y-coordinates of a Sheep by a random number between –10 and 10\. Return
    to your existing code and add the following lines above the ellipse() function
    within the update() method:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们教一只羊如何四处移动。我们将首先编程让羊随机移动。（如果你愿意，未来你可以让它按照不同的方式移动。）[清单 9-13](ch09.xhtml#ch09list13)会把一只羊的x和y坐标更改为-10到10之间的随机数。回到你现有的代码中，并在update()方法中的ellipse()函数上方添加以下代码：
- en: '*SheepAndGrass.pyde*'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '*SheepAndGrass.pyde*'
- en: 'def update(self):'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 'def update(self):'
- en: '#make sheep walk randomly'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '#让羊随机行走'
- en: 'move = 10 #the maximum it can move in any direction'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 'move = 10  #它可以在任何方向上移动的最大距离'
- en: self.x += random(-move, move)
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: self.x += random(-move, move)
- en: self.y += random(-move, move)
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: self.y += random(-move, move)
- en: 'fill(255) #white'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 'fill(255)  #白色'
- en: ellipse(self.x,self.y,self.sz,self.sz)
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: ellipse(self.x,self.y,self.sz,self.sz)
- en: '*Listing 9-13: Making the sheep move randomly*'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-13：让羊随机移动*'
- en: This code creates a variable called move to specify the maximum value or distance
    the sheep will be able to move on the screen. Then we set move to 10 and use it
    to update the sheep’s x- and y-coordinates by a random number between -move (–10)
    and move (10). Finally, we use fill(255) to set the sheep’s color to white for
    now.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码创建了一个名为move的变量，用来指定羊在屏幕上能够移动的最大值或距离。然后我们将move设置为10，并使用它通过- move（-10）到move（10）之间的随机数来更新羊的x和y坐标。最后，我们使用fill(255)将羊的颜色暂时设置为白色。
- en: When you run this code, you should see the sheep wandering around randomly—and
    it might wander off the screen.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这段代码时，你应该会看到羊在屏幕上随机徘徊——它可能会走出屏幕。
- en: Let’s give the sheep some company. If we want to create and update more than
    one object, it’s a good idea to put them in a list. Then in the draw() function,
    we’ll go through the list and update each Sheep. Update your existing code to
    look like [Listing 9-14](ch09.xhtml#ch09list14).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们给羊找个伴。如果我们想创建并更新多个对象，最好将它们放入一个列表中。然后在draw()函数中，我们将遍历这个列表，并更新每一只羊。更新你的现有代码，使其看起来像[清单
    9-14](ch09.xhtml#ch09list14)。
- en: '*SheepAndGrass.pyde*'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '*SheepAndGrass.pyde*'
- en: 'class Sheep:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Sheep:'
- en: 'def __init__(self,x,y):'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self,x,y):'
- en: 'self.x = x #x-position'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 'self.x = x  #x-坐标'
- en: 'self.y = y #y-position'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 'self.y = y #y 坐标'
- en: 'self.sz = 10 #size'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 'self.sz = 10 #大小'
- en: 'def update(self):'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 'def update(self):'
- en: '#make sheep walk randomly'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '#让羊随机走动'
- en: 'move = 10 #the maximum it can move in any direction'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 'move = 10 #它可以在任何方向上移动的最大值'
- en: self.x += random(-move, move)
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: self.x += random(-move, move)
- en: self.y += random(-move, move)
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: self.y += random(-move, move)
- en: 'fill(255) #white'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 'fill(255) #白色'
- en: ellipse(self.x,self.y,self.sz,self.sz)
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: ellipse(self.x,self.y,self.sz,self.sz)
- en: 'sheepList = [] #list to store sheep'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 'sheepList = [] #存储羊的列表'
- en: 'def setup():'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 'def setup():'
- en: size(600,600)
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: size(600,600)
- en: 'for i in range(3):'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(3):'
- en: sheepList.append(Sheep(random(width),
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: sheepList.append(Sheep(random(width),
- en: random(height)))
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: random(height)))
- en: 'def draw():'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 'def draw():'
- en: background(255)
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: background(255)
- en: 'for sheep in sheepList:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 'for sheep in sheepList:'
- en: sheep.update()
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: sheep.update()
- en: '*Listing 9-14: Creating more sheep using a for loop*'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-14：使用 for 循环创建更多的羊*'
- en: 'This code is similar to the code we wrote to put the bouncing balls in a list.
    First, we create a list to store the sheep. Then we create a for loop and put
    a Sheep in the sheep list. Then in the draw() function, we write another for loop
    to go through the sheep list and update each one according to the update() method
    we already defined. When you run this code, you should get three Sheep walking
    around randomly. Change the number 3 in for i in range(3): to a larger number
    to add even more sheep.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '这段代码类似于我们之前写的将弹跳球放入列表的代码。首先，我们创建一个列表来存储羊。然后我们创建一个 for 循环，将一只羊放入羊列表。接着，在 draw()
    函数中，我们再写一个 for 循环，遍历羊列表并根据我们已定义的 update() 方法更新每只羊。当你运行这段代码时，你应该会看到三只羊在随机走动。将 for
    i in range(3): 中的数字 3 改为更大的数字，可以增加更多的羊。'
- en: CREATING THE ENERGY PROPERTY
  id: totrans-297
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建能量属性
- en: Walking takes up energy! Let’s give the sheep a certain level of energy when
    they’re created and take away their energy when they walk. Use the code in [Listing
    9-15](ch09.xhtml#ch09list15) to update your existing __init__ and update() methods
    in the *SheepAndGrass.pyde*.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 行走需要消耗能量！让我们在羊被创建时给它们一定的能量，在它们走动时消耗掉这些能量。使用[清单 9-15](ch09.xhtml#ch09list15)中的代码来更新你现有的__init__和update()方法，位于*SheepAndGrass.pyde*文件中。
- en: 'class Sheep:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Sheep:'
- en: 'def __init__(self,x,y):'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self,x,y):'
- en: 'self.x = x #x-position'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 'self.x = x #x 坐标'
- en: 'self.y = y #y-position'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 'self.y = y #y 坐标'
- en: 'self.sz = 10 #size'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 'self.sz = 10 #大小'
- en: 'self.energy = 20 #energy level'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 'self.energy = 20 #能量水平'
- en: 'def update(self):'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 'def update(self):'
- en: '#make sheep walk randomly'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '#让羊随机走动'
- en: move = 1
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: move = 1
- en: 'self.energy -= 1 #walking costs energy'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 'self.energy -= 1 #走动消耗能量'
- en: 'if sheep.energy <= 0:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 'if sheep.energy <= 0:'
- en: sheepList.remove(self)
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: sheepList.remove(self)
- en: self.x += random(-move, move)
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: self.x += random(-move, move)
- en: self.y += random(-move, move)
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: self.y += random(-move, move)
- en: 'fill(255) #white'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 'fill(255) #白色'
- en: ellipse(self.x,self.y,self.sz,self.sz)
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: ellipse(self.x,self.y,self.sz,self.sz)
- en: '*Listing 9-15: Updating __init__ and update() with the energy property*'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-15：使用能量属性更新 __init__ 和 update() 方法*'
- en: We do this by creating an energy property in the __init__ method and set it
    to 20, the energy level every sheep starts with. Then self.energy -= 1 in the
    update() method lowers the sheep’s energy level by 1 when it walks around.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在 __init__ 方法中创建一个能量属性并将其设置为 20（每只羊的初始能量值）来实现这一点。然后，在 update() 方法中通过 self.energy
    -= 1 每次走动时降低羊的能量值。
- en: Then we check whether the sheep is out of energy, and if it is, we remove it
    from the sheepList. Here, we use a conditional statement to check whether if sheep.energy
    <= 0 returns True. If so, we remove that sheep from the sheepList using the remove()
    function. Once that Sheep instance is gone from the list, it doesn’t exist anymore.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们检查羊是否耗尽了能量，如果是，就从 sheepList 中移除它。这里，我们使用一个条件语句来检查 sheep.energy <= 0 是否返回
    True。如果是，我们就用 remove() 函数将该羊从 sheepList 中移除。一旦该羊实例从列表中消失，它就不再存在。
- en: CREATING GRASS USING CLASSES
  id: totrans-318
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用类创建草
- en: When you run the program, you should see the Sheep move around for a second
    and then disappear—walking around is costing the sheep energy, and once that energy
    is gone, the sheep dies. What we need to do is to give the sheep grass to eat.
    We’ll call each patch of grass Grass and make a new class for it. Grass will have
    its own x- and y-value, size, and energy content. We’ll also make it change color
    when it’s eaten.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行程序时，你应该会看到羊走动了一会儿然后消失——走动消耗了羊的能量，一旦能量耗尽，羊就会死掉。我们需要做的是给羊提供草来吃。我们将每一块草称为 Grass，并为其创建一个新类。Grass
    会有自己的 x 和 y 值、大小和能量含量。我们还会在草被吃掉时改变它的颜色。
- en: In fact, we’ll be using a bunch of different colors in this sketch for our sheep
    and our grass, so let’s add the code in [Listing 9-16](ch09.xhtml#ch09list16)
    to the very beginning of the program so we can just refer to the colors by their
    names. Feel free to add other colors too.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们在这个草图中会使用许多不同的颜色来表示我们的羊和草，所以我们将在程序的最开始添加 [列表 9-16](ch09.xhtml#ch09list16)
    中的代码，这样我们就可以通过颜色名称来引用这些颜色。也可以随意添加其他颜色。
- en: WHITE = color(255)
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: WHITE = color(255)
- en: BROWN = color(102,51,0)
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: BROWN = color(102,51,0)
- en: RED = color(255,0,0)
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: RED = color(255,0,0)
- en: GREEN = color(0,102,0)
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: GREEN = color(0,102,0)
- en: YELLOW = color(255,255,0)
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: YELLOW = color(255,255,0)
- en: PURPLE = color(102,0,204)
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: PURPLE = color(102,0,204)
- en: '*Listing 9-16: Setting colors as constants*'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-16：将颜色设置为常量*'
- en: 'Using all-caps for the color names indicates that they’re constants and won’t
    change in value, but that’s just for the programmer. There’s nothing inherently
    magical about the constants, and you can change these values if you want. Setting
    constants lets you just type the names of the colors instead of having to write
    the RGB values every time. We’ll do this when we make the grass green. Update
    your existing code by adding the code in [Listing 9-17](ch09.xhtml#ch09list17)
    right after the Sheep class in *SheepAndGrass.pyde*:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 使用全大写字母表示颜色名称表示它们是常量，并且值不会改变，但这只是对程序员的约定。常量本身没有神奇之处，如果你愿意，可以更改这些值。设置常量让你只需要输入颜色名称，而不用每次都写
    RGB 值。我们将在将草变绿时使用这个方法。通过在 *SheepAndGrass.pyde* 中的 Sheep 类之后添加 [列表 9-17](ch09.xhtml#ch09list17)
    中的代码，来更新现有代码：
- en: 'class Grass:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Grass:'
- en: 'def __init__(self,x,y,sz):'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self,x,y,sz):'
- en: self.x = x
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: self.x = x
- en: self.y = y
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: self.y = y
- en: 'self.energy = 5 #energy from eating this patch'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 'self.energy = 5 #通过吃这个草块获得的能量'
- en: 'self.eaten = False #hasn''t been eaten yet'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 'self.eaten = False #尚未被吃掉'
- en: self.sz = sz
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: self.sz = sz
- en: 'def update(self):'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 'def update(self):'
- en: fill(GREEN)
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: fill(GREEN)
- en: rect(self.x,self.y,self.sz,self.sz)
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: rect(self.x,self.y,self.sz,self.sz)
- en: '*Listing 9-17: Writing the Grass class*'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-17：编写 Grass 类*'
- en: You’re probably starting to get used to the structure of the class notation.
    It conventionally starts with the __init__ method, where you create its properties.
    In this case, you tell the program that Grass will have an x- and y-location,
    an energy level, a Boolean (True/False) variable that keeps track of whether the
    grass has been eaten or not, and a size. To update a patch of grass, we just create
    a green rectangle at the Grass object’s location.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经开始习惯类表示法的结构了。它通常以 __init__ 方法开始，在那里你创建类的属性。在这种情况下，你告诉程序，Grass 将具有 x 和 y
    坐标、能量级别、一个布尔值（True/False）变量来追踪草是否被吃掉过，以及草的大小。要更新一个草块，我们只需要在 Grass 对象的位置创建一个绿色矩形。
- en: Now we have to initialize and update our grass, the same way we did for our
    sheep. Because there will be a lot of grass, let’s create a list for it. Before
    the setup() function, add the following code.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要像处理羊一样初始化和更新我们的草。因为草会很多，所以让我们为它创建一个列表。在 setup() 函数之前，添加以下代码。
- en: 'sheepList = [] #list to store sheep'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 'sheepList = [] #存储羊的列表'
- en: 'grassList = [] #list to store grass'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 'grassList = [] #存储草的列表'
- en: 'patchSize = 10 #size of each patch of grass'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 'patchSize = 10 #每个草块的大小'
- en: We might want to vary the size of the patch of grass in the future, so let’s
    create a variable called patchSize so we’ll only have to change it in one place.
    In the setup() function, after creating the sheep, create the grass by adding
    the new code in [Listing 9-18](ch09.xhtml#ch09list18).
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能想在未来改变草块的大小，所以让我们创建一个名为 patchSize 的变量，这样我们就只需要在一个地方修改它。在 setup() 函数中，在创建羊之后，通过添加
    [列表 9-18](ch09.xhtml#ch09list18) 中的新代码来创建草。
- en: 'def setup():'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 'def setup():'
- en: global patchSize
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: global patchSize
- en: size(600,600)
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: size(600,600)
- en: '#create the sheep'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '#创建羊'
- en: 'for i in range(3):'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(3):'
- en: sheepList.append(Sheep(random(width),
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: sheepList.append(Sheep(random(width),
- en: random(height)))
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: random(height)))
- en: '#create the grass:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '#创建草：'
- en: 'for x in range(0,width,patchSize):'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 'for x in range(0,width,patchSize):'
- en: 'for y in range(0,height,patchSize):'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 'for y in range(0,height,patchSize):'
- en: grassList.append(Grass(x,y,patchSize))
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: grassList.append(Grass(x,y,patchSize))
- en: '*Listing 9-18: Updating the Grass object using patchSize variable*'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-18：使用 patchSize 变量更新 Grass 对象*'
- en: In this example, global patchSize tells Python that we’re using the same patchSize
    variable everywhere. Then we write two for loops (one for x and the other for
    y) to append Grass to the grass list so we can create a square grid of grass.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，global patchSize 告诉 Python 我们在任何地方都使用相同的 patchSize 变量。然后，我们写了两个 for 循环（一个用于
    x，另一个用于 y）来将 Grass 添加到草列表中，这样我们就可以创建一个草的方形网格。
- en: Then we update everything in the draw() function, just like we did for the sheep.
    Whatever is drawn first will be drawn covered up by what’s drawn after, so we’ll
    update the grass first by changing the draw() function to the code in [Listing
    9-19](ch09.xhtml#ch09list19).
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们像更新羊一样，在draw()函数中更新所有内容。先绘制的内容会被后绘制的内容覆盖，因此我们首先通过将draw()函数改成[列表 9-19](ch09.xhtml#ch09list19)中的代码来更新草地。
- en: '*SheepAndGrass.pyde*'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '*SheepAndGrass.pyde*'
- en: 'def draw():'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 'def draw():'
- en: background(255)
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: background(255)
- en: '#update the grass first'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '#先更新草地'
- en: 'for grass in grassList:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 'for grass in grassList:'
- en: grass.update()
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: grass.update()
- en: '#then the sheep'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '#然后是羊'
- en: 'for sheep in sheepList:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 'for sheep in sheepList:'
- en: sheep.update()
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: sheep.update()
- en: '*Listing 9-19: Updating the grass before the sheep*'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-19：在羊之前更新草地*'
- en: When you run this code, you should see a grid of green squares, like in [Figure
    9-7](ch09.xhtml#ch09fig7).
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这段代码时，你应该能看到一组绿色方块，就像[图 9-7](ch09.xhtml#ch09fig7)中所示。
- en: '![image](../images/f192-01.jpg)'
  id: totrans-371
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f192-01.jpg)'
- en: '*Figure 9-7: Grass with grid lines*'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-7：带网格线的草地*'
- en: 'Let’s shut off the black outline so it’ll look like a smooth field of grass.
    Add noStroke() to the setup() function to remove the outline of the green squares:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们关闭黑色边框，这样草地看起来就像是平滑的草地。将noStroke()添加到setup()函数中，以去除绿色方块的边框：
- en: 'def setup():'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 'def setup():'
- en: global patchSize
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: global patchSize
- en: size(600,600)
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: size(600,600)
- en: noStroke()
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: noStroke()
- en: Now we have our grass!
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了草地！
- en: MAKING THE GRASS BROWN WHEN EATEN
  id: totrans-379
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 让草地在被吃掉时变成棕色
- en: 'How do we make it so that when a sheep is on a patch of grass, the sheep gets
    the grass’s energy and the patch of grass turns brown to show that the sheep has
    eaten it? Change the update() method for Grass by adding the following lines of
    code:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何使得当一只羊站在一片草地上时，羊能获得草的能量，并且草地变成棕色，显示羊已经吃过它呢？通过添加以下代码行来修改草地的update()方法：
- en: 'def update(self):'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 'def update(self):'
- en: 'if self.eaten:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 'if self.eaten:'
- en: fill(BROWN)
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: fill(BROWN)
- en: 'else:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: fill(GREEN)
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: fill(GREEN)
- en: rect(self.x,self.y,self.sz,self.sz)
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: rect(self.x,self.y,self.sz,self.sz)
- en: This code tells Processing that if the patch of grass is “eaten,” the rectangle
    should be filled with a brown color. Otherwise, the grass should be colored green.
    There’s more than one way for a sheep to “eat” grass. One way is to make each
    patch of grass check the entire sheepList for a sheep on its location, which could
    mean tens of thousands of patches are checking thousands of sheep. Those numbers
    could get big. However, because each patch of grass is in the grassList, an alternate
    way is that when a sheep changes its location, it could simply change the patch
    at that location to “eaten” (if it isn’t already) and get energy from eating it.
    That would mean a lot less checking.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码告诉Processing，如果草地“被吃了”，则矩形应该填充为棕色。否则，草地应该是绿色的。羊“吃”草的方式有多种。一种方式是让每一片草地检查整个sheepList，看是否有羊在它的位置，这意味着成千上万的草地要检查数千只羊。那些数字可能会变得非常大。然而，因为每片草地都在grassList中，另一种方法是当羊改变位置时，它可以简单地将该位置的草地标记为“已吃”（如果尚未标记），并从中获取能量。这样就会减少很多检查。
- en: The problem is that the x- and y-coordinates of the sheep don’t exactly match
    up to where the patches of grass are in the grassList. For example, our patchSize
    is 10, meaning that if a sheep is at (92,35), it’ll be on the 10th patch to the
    right and the 4th patch down (because the “first” patch is from x = 0 to x = 9).
    We’re dividing by the patchSize to get the “scaled” x- and y-values, 9 and 3.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是羊的x和y坐标与grassList中草地的位置不完全匹配。例如，我们的patchSize是10，这意味着如果羊在(92,35)的位置，它将位于右边第10个草地和下方第4个草地（因为“第一个”草地的范围是x
    = 0到x = 9）。我们通过patchSize来划分，得到“缩放后的”x和y值，分别是9和3。
- en: 'However, the grassList doesn’t have rows and columns. We do know that the x-value,
    9, means it’s the 10th row (don’t forget row 0), so we’ll just have to add in
    nine rows of 60 (the height divided by the patchSize) and then add the y-value
    to get the index of the patch of grass the sheep is on. Therefore, we need a variable
    to tell us how many patches of grass there are in a row, which we’ll call rows_of_grass.
    Add global rows_of_grass to the beginning of the setup() function and then add
    this line to setup() after declaring the size:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，grassList没有行和列。我们知道x值9意味着它是第10行（不要忘了第0行），所以我们只需添加九行60（即高度除以patchSize），然后加上y值来得到羊所在的草地索引。因此，我们需要一个变量来告诉我们每行有多少片草地，称之为rows_of_grass。将global
    rows_of_grass添加到setup()函数的开头，然后在声明大小之后，添加这一行：
- en: rows_of_grass = height/patchSize
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: rows_of_grass = height/patchSize
- en: This takes the width of the display window and divides it by the size of the
    patches of grass to tell us how many columns of grass there are. The code to add
    to the Sheep class is in [Listing 9-20](ch09.xhtml#ch09list20).
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将显示窗口的宽度除以草地块的大小，告诉我们有多少列草。添加到 Sheep 类中的代码在[清单 9-20](ch09.xhtml#ch09list20)中。
- en: '*SheepAndGrass.pyde*'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '*SheepAndGrass.pyde*'
- en: self.x += random(-move, move)
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: self.x += random(-move, move)
- en: self.y += random(-move, move)
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: self.y += random(-move, move)
- en: '#"wrap" the world Asteroids-style'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: “包裹”世界，就像小行星游戏一样
- en: '➊ if self.x > width:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ if self.x > width:'
- en: self.x %= width
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: self.x %= width
- en: 'if self.y > height:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 'if self.y > height:'
- en: self.y %= height
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: self.y %= height
- en: 'if self.x < 0:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 'if self.x < 0:'
- en: self.x += width
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: self.x += width
- en: 'if self.y < 0:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 'if self.y < 0:'
- en: self.y += height
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: self.y += height
- en: '#find the patch of grass you''re on in the grassList:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '#找到你所在的草地区域在 grassList 中的位置：'
- en: ➋ xscl = int(self.x / patchSize)
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ xscl = int(self.x / patchSize)
- en: yscl = int(self.y / patchSize)
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: yscl = int(self.y / patchSize)
- en: ➌ grass = grassList[xscl * rows_of_grass + yscl]
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ grass = grassList[xscl * rows_of_grass + yscl]
- en: 'if not grass.eaten:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 'if not grass.eaten:'
- en: self.energy += grass.energy
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: self.energy += grass.energy
- en: grass.eaten = True
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: grass.eaten = True
- en: '*Listing 9-20: Updating the sheep’s energy level and turning the grass brown*'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-20：更新羊的能量并让草变成棕色*'
- en: After updating the sheep’s location, we “wrap” the coordinates ➊ so if the sheep
    walks off the screen in one direction, it shows up on the other side of the screen,
    like in the video game *Asteroids*. We calculate which patch the sheep is on according
    to the patchSize ➋. Then we use code to go from x- and y-values to the index of
    that patch in the grassList ➌. We now know the exact index of the patch of grass
    the sheep is on. If this patch of grass is not already eaten, the sheep eats it!
    It gets the energy from the grass, and the grass’s eaten property is set to True.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新羊的位置后，我们“包裹”坐标 ➊，所以如果羊走出屏幕的一侧，它会出现在屏幕的另一侧，就像视频游戏 *小行星* 中一样。我们根据 patchSize
    ➋ 来计算羊所在的草地块。然后我们用代码将 x 和 y 的值转化为该草地块在 grassList 中的索引 ➌。现在我们知道羊所在草地块的确切索引。如果这块草地还没有被吃掉，羊就会吃掉它！它从草地中获取能量，并将草地的
    eaten 属性设置为 True。
- en: Run this code, and you’ll see the three sheep running around eating grass, which
    turns brown once it’s eaten. Slow the sheep down by changing the move variable
    to a lesser value, such as 5\. You can also scale down the patches by changing
    one number, the patchSize variable, to 5\. Try other values if you like.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这段代码，你会看到三只羊在四处奔跑，吃掉草地，草地一旦被吃掉就变成棕色。通过将 move 变量设置为较小的值（例如 5）可以让羊走得慢一点。你还可以通过修改一个数字——patchSize
    变量，将草地的大小缩小到 5。如果你愿意，可以尝试其他值。
- en: 'Now we can create more Sheep. Let’s change the number in the for i in range
    line to 20, like so:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以创建更多的羊。让我们将 for i in range 行中的数字改为 20，如下所示：
- en: '#create the sheep'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '#创建羊群'
- en: 'for i in range(20):'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(20):'
- en: sheepList.append(Sheep(random(width),
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: sheepList.append(Sheep(random(width),
- en: random(height)))
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: random(height)))
- en: When you run this code, you should see something like [Figure 9-8](ch09.xhtml#ch09fig8).
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这段代码时，你应该能看到类似[图9-8](ch09.xhtml#ch09fig8)的效果。
- en: '![image](../images/f194-01.jpg)'
  id: totrans-420
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f194-01.jpg)'
- en: '*Figure 9-8: A herd of sheep!*'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-8：一群羊！*'
- en: Now there are 20 sheep walking around, leaving patches of brown grass.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有 20 只羊在四处走动，留下了一片片棕色的草地。
- en: GIVING EACH SHEEP A RANDOM COLOR
  id: totrans-423
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 为每只羊赋予一个随机颜色
- en: 'Let’s have the sheep choose a color when they’re “born.” After the code defining
    the color constants, let’s put some colors into a color list, like this:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 让羊在“出生”时选择一个颜色。在定义颜色常量的代码之后，让我们将一些颜色放入一个颜色列表中，像这样：
- en: YELLOW = color(255,255,0)
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: YELLOW = color(255,255,0)
- en: PURPLE = color(102,0,204)
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: PURPLE = color(102,0,204)
- en: colorList = [WHITE,RED,YELLOW,PURPLE]
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: colorList = [WHITE,RED,YELLOW,PURPLE]
- en: Make the following changes to the Sheep class to use different colors. First,
    you need to give Sheep a color property. Because color is already a keyword in
    Processing, col is used in [Listing 9-21](ch09.xhtml#ch09list21).
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 对 Sheep 类进行以下更改，以使用不同的颜色。首先，你需要为 Sheep 添加一个颜色属性。由于 color 已经是 Processing 中的关键字，因此在[清单
    9-21](ch09.xhtml#ch09list21)中使用了 col。
- en: 'class Sheep:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Sheep:'
- en: 'def __init__(self,x,y,col):'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self,x,y,col):'
- en: 'self.x = x #x-position'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 'self.x = x #x位置'
- en: 'self.y = y #y-position'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 'self.y = y #y位置'
- en: 'self.sz = 10 #size'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 'self.sz = 10 #大小'
- en: self.energy = 20
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: self.energy = 20
- en: self.col = col
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: self.col = col
- en: '*Listing 9-21: Adding a color property to the Sheep class*'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-21：向 Sheep 类添加颜色属性*'
- en: 'Then in the update() method, replace the fill line with this:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在 update() 方法中，将 fill 行替换为以下代码：
- en: 'fill(self.col) #its own color'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 'fill(self.col) #它自己的颜色'
- en: ellipse(self.x,self.y,self.sz,self.sz)
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: ellipse(self.x,self.y,self.sz,self.sz)
- en: Before the ellipse is drawn, fill(self.col) tells Processing to fill the ellipse
    with the Sheep’s own randomly chosen color.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 在画椭圆之前，fill(self.col) 会告诉 Processing 使用羊自己的随机颜色填充椭圆。
- en: 'When all the Sheep are instantiated in the setup() function, you need to give
    them a random color. That means at the top of the program you have to import the
    choice() function from the random module, like this:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有羊在 setup() 函数中被实例化时，你需要给它们一个随机颜色。这意味着你必须在程序顶部导入 random 模块中的 choice() 函数，如下所示：
- en: from random import choice
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: from random import choice
- en: 'Python’s choice() function allows you to have one item chosen at random from
    a list and then returned. We should be able to tell the program to do this as
    follows:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的 choice() 函数允许你从列表中随机选择一个项目并返回。我们应该能让程序这样做：
- en: choice(colorList)
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: choice(colorList)
- en: 'Now the program will return a single value from the color list. Finally, when
    you’re creating the Sheep, add the random choice of color from the color list
    as one of the arguments you pass to the Sheep constructor, as shown here:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 现在程序将从颜色列表中返回一个单一的值。最后，在创建羊时，将从颜色列表中随机选择的颜色作为传递给 Sheep 构造函数的参数之一，如下所示：
- en: 'def setup():'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 'def setup():'
- en: size(600,600)
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: size(600,600)
- en: noStroke()
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: noStroke()
- en: '#create the sheep'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '#创建羊'
- en: 'for i in range(20):'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(20):'
- en: sheepList.append(Sheep(random(width),
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: sheepList.append(Sheep(random(width),
- en: random(height),
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: random(height),
- en: choice(colorList)))
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: choice(colorList)))
- en: Now when you run this code, you should see a bunch of randomly colored sheep
    walking around the screen, as shown in [Figure 9-9](ch09.xhtml#ch09fig9).
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当你运行这段代码时，你应该会看到一群随机颜色的羊在屏幕上走动，正如[图 9-9](ch09.xhtml#ch09fig9)所示。
- en: '![image](../images/f196-01.jpg)'
  id: totrans-455
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f196-01.jpg)'
- en: '*Figure 9-9: Multicolored sheep*'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-9：多彩的羊*'
- en: 'Each new sheep gets assigned one of the four colors we defined in colorList:
    white, red, yellow, or purple.'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 每只新羊都会从我们在 colorList 中定义的四种颜色中随机选一个：白色、红色、黄色或紫色。
- en: PROGRAMMING SHEEP TO REPRODUCE
  id: totrans-458
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编程让羊繁殖
- en: Unfortunately, in our current program the sheep eat the grass until they wander
    too far away from the grass, run out of energy, and die. To prevent this, let’s
    tell the sheep to use some of that energy to reproduce.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在我们当前的程序中，羊会吃掉草，直到它们走得太远，远离草地，耗尽能量并死亡。为防止这种情况发生，我们可以让羊用一部分能量进行繁殖。
- en: Let’s use the code in [Listing 9-22](ch09.xhtml#ch09list22) to tell the sheep
    to reproduce if their energy level reaches 50.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用[清单 9-22](ch09.xhtml#ch09list22)中的代码，当羊的能量达到 50 时，让它们繁殖。
- en: 'if self.energy <= 0:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 'if self.energy <= 0:'
- en: sheepList.remove(self)
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: sheepList.remove(self)
- en: 'if self.energy >= 50:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 'if self.energy >= 50:'
- en: 'self.energy -= 30 #giving birth takes energy'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 'self.energy -= 30 #生育需要能量'
- en: '#add another sheep to the list'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '#向列表中添加另一只羊'
- en: sheepList.append(Sheep(self.x,self.y,self.col))
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: sheepList.append(Sheep(self.x,self.y,self.col))
- en: '*Listing 9-22: Adding a conditional for sheep to reproduce*'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-22：为羊的繁殖添加条件*'
- en: 'The conditional if self.energy >= 50: checks whether that sheep’s energy is
    greater than or equal to 50\. If it is, we decrement the energy level by 30 for
    birthing and add another sheep to the sheep list. Notice that the new sheep is
    at the same location and is the same color as its parent. Run this code, and you
    should see the sheep reproduce, like in [Figure 9-10](ch09.xhtml#ch09fig10).'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '条件 if self.energy >= 50: 会检查羊的能量是否大于或等于 50。如果是，它将能量减少 30 用于生育，并向羊群列表中添加另一只羊。请注意，新的羊与父母的颜色相同，并且位于相同的位置。运行这段代码，你应该能看到羊繁殖，就像[图
    9-10](ch09.xhtml#ch09fig10)中所示的那样。'
- en: '![image](../images/f197-01.jpg)'
  id: totrans-469
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f197-01.jpg)'
- en: '*Figure 9-10: Sheep eating grass and reproducing*'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-10：羊吃草和繁殖*'
- en: Soon you should see what looks like tribes of similarly colored sheep.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 很快你会看到看起来像是部落的相似颜色的羊群。
- en: LETTING THE GRASS REGROW
  id: totrans-472
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 让草重新生长
- en: 'Unfortunately, the sheep soon eat up all the grass in their area and die (probably
    a lesson in there somewhere). We need to allow our grass to regrow. To do this,
    change the Grass’s update() method to this:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，羊很快就吃光了它们区域里的所有草并死去（这大概是某种教训）。我们需要让草重新生长。为此，将草的 update() 方法改成如下：
- en: 'def update(self):'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 'def update(self):'
- en: 'if self.eaten:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 'if self.eaten:'
- en: 'if random(100) < 5:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 'if random(100) < 5:'
- en: self.eaten = False
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: self.eaten = False
- en: 'else:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: fill(BROWN)
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: fill(BROWN)
- en: 'else:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: fill(GREEN)
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: fill(GREEN)
- en: rect(self.x,self.y,self.sz,self.sz)
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: rect(self.x,self.y,self.sz,self.sz)
- en: The Processing code random(100) generates a random number between 0 and 100\.
    If the number is less than 5, we regrow a patch of grass by setting its eaten
    property to False. We use the number 5 because this gives us a probability of
    5/100 that eaten grass will regrow during each frame. Otherwise, it stays brown.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: Processing 代码 random(100) 会生成一个介于 0 和 100 之间的随机数。如果这个数字小于 5，我们会通过将草的 eaten 属性设置为
    False 来重新种植一片草地。我们选择数字 5，因为这样可以使每一帧中被吃掉的草有 5/100 的几率重新生长。否则，它会保持棕色。
- en: Run the code, and you should see something like [Figure 9-11](ch09.xhtml#ch09fig11).
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码，你应该会看到类似[图 9-11](ch09.xhtml#ch09fig11)的内容。
- en: '![image](../images/f198-01.jpg)'
  id: totrans-485
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f198-01.jpg)'
- en: '*Figure 9-11: The grass regrows and the sheep populate the whole screen!*'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-11：草地重新生长，羊群占满了整个屏幕！*'
- en: 'Now you might get so many sheep that the program starts to slow down! This
    could be because the sheep have too much energy. If so, try reducing the amount
    of energy each patch of grass contains from 5 to 2:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能会发现羊群越来越多，程序开始变慢了！这可能是因为羊有太多的能量。如果是这样，尝试将每片草地的能量从 5 降到 2：
- en: 'class Grass:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Grass:'
- en: 'def __init__(self,x,y,sz):'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self,x,y,sz):'
- en: self.x = x
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: self.x = x
- en: self.y = y
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: self.y = y
- en: 'self.energy = 2 #energy from eating this patch'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 'self.energy = 2 #吃这片草得到的能量'
- en: 'self.eaten = False #hasn''t been eaten yet'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 'self.eaten = False #还没被吃掉'
- en: self.sz = sz
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: self.sz = sz
- en: That seems to be a good balance that lets the sheep population grow at a reasonable
    pace. Play around with the numbers all you want—it’s your world!
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎是一个良好的平衡，使得羊群能够以合理的速度增长。你可以随意调整数字——这是你的世界！
- en: PROVIDING AN EVOLUTIONARY ADVANTAGE
  id: totrans-496
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 提供进化优势
- en: 'Let’s give one of the sheep groups an advantage. You can choose any advantage
    you can think of (getting more energy from grass or producing more offspring at
    a time, for instance). For this example, we’re going to let the purple sheep walk
    a little further than the others. Will that make any difference? To find out,
    make the Sheep’s update() method match the following code:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们给某一组羊一个优势。你可以选择任何你能想到的优势（例如从草地获得更多的能量或一次性产生更多的后代）。在这个例子中，我们将让紫色羊走得比其他羊更远。这样会有变化吗？为了找出答案，将
    Sheep 的 update() 方法修改为以下代码：
- en: 'def update(self):'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 'def update(self):'
- en: '#make sheep walk randomly'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: '#让羊随机走动'
- en: 'move = 5 #the maximum it can move in any direction'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 'move = 5 #它在任何方向上最多能移动的距离'
- en: 'if self.col == PURPLE:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 'if self.col == PURPLE:'
- en: move = 7
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: move = 7
- en: self.energy -= 1
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: self.energy -= 1
- en: This conditional checks whether the Sheep’s color is purple. If so, it sets
    the Sheep’s move value to 7\. Otherwise, it leaves the value at 5\. This allows the
    purple sheep to travel further, and therefore more likely to find green patches,
    than the other sheep. Let’s run the code and check the outcome, which should look
    like [Figure 9-12](ch09.xhtml#ch09fig12).
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 这个条件判断检查羊的颜色是否为紫色。如果是，它将羊的移动值设置为 7。否则，它将值保持为 5。这样，紫色羊就能比其他羊走得更远，因此更有可能找到绿色草地。让我们运行代码并检查结果，应该类似于[图
    9-12](ch09.xhtml#ch09fig12)。
- en: '![image](../images/f199-01.jpg)'
  id: totrans-505
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f199-01.jpg)'
- en: '*Figure 9-12: Giving purple sheep an advantage*'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-12：给紫色羊一个优势*'
- en: After a little while it sure looks like that tiny advantage paid off for the
    purple sheep. They’re dominating the environment and pushing out all the other
    sheep just by competing for grass. This simulation could spark interesting discussions
    about ecology, invasive species, biodiversity, and evolution.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 一段时间后，紫色羊的小小优势似乎真的带来了回报。它们在环境中占据主导地位，并且通过与其他羊争夺草地，把其他羊挤了出去。这个模拟可能会激发关于生态学、外来物种、生物多样性和进化的有趣讨论。
- en: 'EXERCISE 9-2: SETTING SHEEP LIFESPAN'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 9-2：设置羊的寿命
- en: Create an “age” property and decrease it every time the sheep update so they
    live for only a limited amount of time.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个“age”属性，并在每次羊更新时减少它，让它们的生命只持续有限的时间。
- en: 'EXERCISE 9-3: CHANGING SHEEP SIZE'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 9-3：改变羊的大小
- en: Vary the size of the sheep according to their energy level.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 根据羊的能量水平改变羊的大小。
- en: SUMMARY
  id: totrans-512
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how to make objects using classes, which involved
    defining the class using properties and then instantiating (“creating”) and updating
    the object. This let you create multiple similar-but-independent objects with
    the same properties more efficiently. The more you use classes, the more creative
    you can get by making autonomous objects walk, fly, or bounce around without your
    having to code every step!
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章，你学会了如何使用类来创建对象，这包括通过属性定义类，然后实例化（“创建”）并更新对象。这让你能够更高效地创建多个相似但独立的具有相同属性的对象。你使用类越多，你就能越有创意，通过让自主对象走动、飞行或弹跳，而无需为每个步骤都写代码！
- en: Knowing how to use classes supercharges your coding abilities. Now you can create
    models of complicated situations easily, and once you tell the program what to
    do with one particle, or planet, or sheep, it’ll be able to make a dozen, a hundred,
    or even a million of them very easily!
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 学会使用类能极大提升你的编程能力。现在你可以轻松创建复杂情况的模型，一旦你告诉程序如何处理一个粒子、行星或羊，它就能非常轻松地生成十个、百个，甚至上百万个！
- en: You also got a taste of setting up models to explore physical, biological, chemical,
    or environmental situations with very few equations! A physicist once told me
    that’s often the most efficient method for solving problems involving many factors,
    or “agents.” You set up a computer model, let it run, and look at the results.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 你还体验了如何搭建模型，探索物理、生物、化学或环境等情况，几乎不需要用到任何方程！一位物理学家曾告诉我，这通常是解决涉及多因素或“代理”问题的最有效方法。你搭建一个计算机模型，让它运行，然后观察结果。
- en: In the next chapter, you’ll learn how to create fractals using an almost-magical
    phenomenon called recursion.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，你将学习如何使用一种几乎是魔法般的现象——递归，来创建分形。
