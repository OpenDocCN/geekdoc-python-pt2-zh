- en: '**2**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**2**'
- en: '**MODULES, LIBRARIES, AND FRAMEWORKS**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**模块、库和框架**'
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: Modules are an essential part of what makes Python extensible. Without them,
    Python would just be a language built around a monolithic interpreter; it wouldn’t
    flourish within a giant ecosystem that allows developers to build applications
    quickly and simply by combining extensions. In this chapter, I’ll introduce you
    to some of the features that make Python modules great, from the built-in modules
    you need to know to externally managed frameworks.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 模块是Python可扩展性的关键部分。没有它们，Python将只是一个围绕单一解释器构建的语言；它无法在一个庞大的生态系统中蓬勃发展，开发者也无法通过组合扩展快速简便地构建应用程序。在这一章中，我将向你介绍一些使Python模块出色的特性，从你需要了解的内置模块到外部管理的框架。
- en: '**The Import System**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**导入系统**'
- en: To use modules and libraries in your programs, you have to import them using
    the `import` keyword. As an example, [Listing 2-1](ch02.xhtml#ch2list1) imports
    the all-important Zen of Python guidelines.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 要在程序中使用模块和库，你必须使用`import`关键字导入它们。例如，[清单 2-1](ch02.xhtml#ch2list1)导入了Python之禅的核心指导原则。
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 2-1: The Zen of Python*'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-1: Python之禅*'
- en: The import system is quite complex, and I’m assuming you already know the basics,
    so here I’ll show you some of the internals of this system, including how the
    `sys` module works, how to change or add import paths, and how to use custom importers.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 导入系统相当复杂，我假设你已经掌握了基础知识，因此在这里我将向你展示这个系统的一些内部工作原理，包括`sys`模块的工作方式、如何更改或添加导入路径，以及如何使用自定义导入器。
- en: 'First, you need to know that the `import` keyword is actually a wrapper around
    a function named `__import__`. Here is a familiar way of importing a module:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要知道`import`关键字实际上是一个名为`__import__`的函数的封装器。以下是一个熟悉的导入模块方式：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This is precisely equivalent to this method:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这与以下方法完全等效：
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can also imitate the `as` keyword of `import`, as these two equivalent
    ways of importing show:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以模仿`import`的`as`关键字，就像这两种等效的导入方式所示：
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And here’s the second example:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第二个示例：
- en: '[PRE4]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'While `import` is a keyword in Python, internally it’s a simple function that’s
    accessible through the `__import__` name. The `__import__` function is extremely
    useful to know, as in some (corner) cases, you might want to import a module whose
    name is unknown beforehand, like so:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`import`是Python中的一个关键字，但在内部它实际上是一个可以通过`__import__`名称访问的简单函数。了解`__import__`函数非常有用，因为在某些（边缘）情况下，你可能希望导入一个事先无法知道名称的模块，例如这样：
- en: '[PRE5]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Don’t forget that modules, once imported, are essentially objects whose attributes
    (classes, functions, variables, and so on) are objects.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记，一旦导入，模块本质上是对象，它们的属性（类、函数、变量等）也是对象。
- en: '***The sys Module***'
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***sys模块***'
- en: The `sys` module provides access to variables and functions related to Python
    itself and the operating system it is running on. This module also contains a
    lot of information about Python’s import system.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`sys`模块提供了与Python本身以及它所运行的操作系统相关的变量和函数。这个模块还包含关于Python导入系统的许多信息。'
- en: 'First of all, you can retrieve the list of modules currently imported using
    the `sys.modules` variable. The `sys.modules` variable is a dictionary whose key
    is the module name you want to inspect and whose returned value is the module
    object. For example, once the `os` module is imported, we can retrieve it by entering:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以使用`sys.modules`变量检索当前导入的模块列表。`sys.modules`变量是一个字典，其键是你想要查看的模块名称，返回值是模块对象。例如，一旦导入了`os`模块，我们可以通过输入以下内容来检索它：
- en: '[PRE6]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `sys.modules` variable is a standard Python dictionary that contains all
    loaded modules. That means that calling `sys.modules.keys()`, for example, will
    return the complete list of the names of loaded modules.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`sys.modules`变量是一个标准的Python字典，包含所有已加载的模块。这意味着，例如调用`sys.modules.keys()`将返回已加载模块的名称的完整列表。'
- en: You can also retrieve the list of modules that are built in by using the `sys.builtin_module_names`
    variable. The built-in modules compiled to your interpreter can vary depending
    on what compilation options were passed to the Python build system.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用`sys.builtin_module_names`变量来检索内置模块的列表。根据传递给Python构建系统的编译选项，编译到解释器中的内置模块可能会有所不同。
- en: '***Import Paths***'
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***导入路径***'
- en: When importing modules, Python relies on a list of paths to know where to look
    for the module. This list is stored in the `sys.path` variable. To check which
    paths your interpreter will search for modules, just enter `sys.path`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入模块时，Python依赖一个路径列表来确定在哪里查找模块。这个列表存储在`sys.path`变量中。要查看你的解释器会搜索哪些路径，只需输入`sys.path`。
- en: 'You can change this list, adding or removing paths as necessary, or even modify
    the `PYTHONPATH` environment variable to add paths without writing Python code
    at all. Adding paths to the `sys.path` variable can be useful if you want to install
    Python modules to nonstandard locations, such as a test environment. In normal
    operations, however, it should not be necessary to change the path variable. The
    following approaches are almost equivalent—*almost* because the path will not
    be placed at the same level in the list; this difference may not matter, depending
    on your use case:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以修改这个列表，按需添加或删除路径，甚至通过修改`PYTHONPATH`环境变量来添加路径，而无需编写Python代码。如果你想将Python模块安装到非标准位置（例如测试环境），将路径添加到`sys.path`变量可能很有用。然而，在正常操作中，通常不需要更改路径变量。以下几种方法几乎等效——*几乎*因为路径在列表中的位置不同；这个差异在你的使用场景中可能不重要：
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This would be (almost) the same as:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎和下面的情况一样：
- en: '[PRE8]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: It’s important to note that the list will be iterated over to find the requested
    module, so the order of the paths in `sys.path` is important. It’s useful to put
    the path most likely to contain the modules you are importing early in the list
    to speed up search time. Doing so also ensures that if two modules with the same
    name are available, the first match will be picked.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，这个列表会被迭代以查找请求的模块，因此`sys.path`中的路径顺序很重要。将最有可能包含你正在导入模块的路径放在列表前面，有助于加速搜索时间。这样做还可以确保，如果有两个同名的模块可用，首先匹配到的模块会被选中。
- en: This last property is especially important because one common mistake is to
    shadow Python built-in modules with your own. Your current directory is searched
    before the Python Standard Library directory. That means that if you decide to
    name one of your scripts *random.py* and then try using `import random`, the file
    from your current directory will be imported rather than the Python module.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一项特性尤为重要，因为一个常见的错误是用你自己的模块覆盖Python的内置模块。当前目录会在Python标准库目录之前被搜索。这意味着，如果你决定将你的脚本命名为*random.py*，然后尝试使用`import
    random`，那么当前目录中的文件将被导入，而不是Python模块。
- en: '***Custom Importers***'
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***自定义导入器***'
- en: You can also extend the import mechanism using custom importers. This is the
    technique that the Lisp-Python dialect `Hy` uses to teach Python how to import
    files other than standard *.py* or *.pyc* files. (`Hy` is a Lisp implementation
    on top of Python, discussed later in the section “[A Quick Introduction to Hy](ch09.xhtml#lev1sec48)”
    on [page 145](ch09.xhtml#page_145).)
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用自定义导入器扩展导入机制。这就是Lisp-Python方言`Hy`使用的技术，它教Python如何导入除标准的*.py*或*.pyc*文件以外的文件。（`Hy`是基于Python的Lisp实现，稍后将在[第145页](ch09.xhtml#page_145)的“[快速了解Hy](ch09.xhtml#lev1sec48)”一节中讨论。）
- en: The *import hook mechanism*, as this technique is called, is defined by PEP
    302\. It allows you to extend the standard import mechanism, which in turn allows
    you to modify how Python imports modules and build your own system of import.
    For example, you could write an extension that imports modules from a database
    over the network or that does some sanity checking before importing any module.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*导入钩子机制*，即此技术，由PEP 302定义。它允许你扩展标准导入机制，从而可以修改Python导入模块的方式并构建你自己的导入系统。例如，你可以编写一个扩展，通过网络从数据库导入模块，或者在导入任何模块之前进行一些合理性检查。'
- en: 'Python offers two different but related ways to broaden the import system:
    the meta path finders for use with `sys.meta_path` and the path entry finders
    for use with `sys.path_hooks`.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了两种不同但相关的方式来扩展导入系统：用于`sys.meta_path`的元路径查找器和用于`sys.path_hooks`的路径条目查找器。
- en: '***Meta Path Finders***'
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***元路径查找器***'
- en: The *meta path finder* is an object that will allow you to load custom objects
    as well as standard *.py* files. A meta path finder object must expose a `find_module(fullname,
    path=None)` method that returns a loader object. The loader object must also have
    a `load_module(fullname)` method responsible for loading the module from a source
    file.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*元路径查找器*是一个允许你加载自定义对象以及标准的*.py*文件的对象。元路径查找器对象必须暴露一个`find_module(fullname, path=None)`方法，该方法返回一个加载器对象。加载器对象还必须具有一个`load_module(fullname)`方法，负责从源文件加载模块。'
- en: To illustrate, [Listing 2-2](ch02.xhtml#ch2list2) shows how `Hy` uses a custom
    meta path finder to enable Python to import source files ending with *.hy* instead
    of *.py*.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明，[列表 2-2](ch02.xhtml#ch2list2) 展示了 `Hy` 如何使用自定义的元路径查找器，使 Python 能够导入以 *.hy*
    结尾的源文件，而不是 *.py*。
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 2-2: A Hy module importer*'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-2：一个 Hy 模块导入器*'
- en: Once Python has determined that the path is valid and that it points to a module,
    a `MetaLoader` object is returned, as shown in [Listing 2-3](ch02.xhtml#ch2list3).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 Python 确定路径有效并且指向一个模块，就会返回一个 `MetaLoader` 对象，如 [列表 2-3](ch02.xhtml#ch2list3)
    所示。
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 2-3: A Hy module loader object*'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-3：一个 Hy 模块加载器对象*'
- en: At ➊, `import_file_to_module` reads a *.hy* source file, compiles it to Python
    code, and returns a Python module object.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，`import_file_to_module` 读取一个 *.hy* 源文件，将其编译为 Python 代码，并返回一个 Python 模块对象。
- en: 'This loader is pretty straightforward: once the *.hy* file is found, it’s passed
    to this loader, which compiles the file if necessary, registers it, sets some
    attributes, and then returns it to the Python interpreter.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这个加载器非常直接：一旦找到 *.hy* 文件，就将其传递给这个加载器，若有必要，它会编译文件、注册文件、设置一些属性，然后返回给 Python 解释器。
- en: The `uprefix` module is another good example of this feature in action. Python
    3.0 through 3.2 didn’t support the `u` prefix for denoting Unicode strings that
    was featured in Python 2; the `uprefix` module ensures compatibility between Python
    versions 2 and 3 by removing the `u` prefix from strings before compilation.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`uprefix` 模块是此功能应用的另一个很好的示例。Python 3.0 到 3.2 不支持 Python 2 中用于表示 Unicode 字符串的
    `u` 前缀；`uprefix` 模块通过在编译前移除字符串中的 `u` 前缀，确保 Python 2 和 3 版本之间的兼容性。'
- en: '**Useful Standard Libraries**'
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**有用的标准库**'
- en: Python comes with a huge standard library packed with tools and features for
    almost any purpose you can think of. Newcomers to Python who are used to having
    to write their own functions for basic tasks are often shocked to find that the
    language itself ships with so much functionality built in and ready for use.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Python 附带了一个庞大的标准库，里面包含了几乎任何你能想到的工具和功能。习惯于为基本任务编写自己函数的 Python 新手，通常会被语言本身已经内置并准备好使用的如此丰富的功能所震惊。
- en: Whenever you’re tempted to write your own function to handle a simple task,
    first stop and look through the standard library. In fact, skim through the whole
    thing at least once before you begin working with Python so that next time you
    need a function, you have an idea of whether it already exists in the standard
    library.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你有写自己函数来处理简单任务的冲动时，先停下来查阅一下标准库。事实上，在你开始使用 Python 之前，至少浏览一遍标准库，这样下次需要某个函数时，你就能知道它是否已经存在于标准库中。
- en: 'We’ll talk about some of these modules, such as `functools` and `itertools`,
    in later chapters, but here are a few of the standard modules that you’ll definitely
    find useful:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后续章节讨论这些模块中的一些，比如 `functools` 和 `itertools`，但这里有一些你肯定会发现有用的标准模块：
- en: '`atexit` allows you to register functions for your program to call when it
    exits.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`atexit` 允许你注册程序在退出时调用的函数。'
- en: '`argparse` provides functions for parsing command line arguments.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`argparse` 提供用于解析命令行参数的函数。'
- en: '`bisect` provides bisection algorithms for sorting lists (see [Chapter 10](ch10.xhtml#ch10)).'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bisect` 提供用于排序列表的二分法算法（参见 [第 10 章](ch10.xhtml#ch10)）。'
- en: '`calendar` provides a number of date-related functions.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`calendar` 提供多个与日期相关的函数。'
- en: '`codecs` provides functions for encoding and decoding data.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`codecs` 提供用于编码和解码数据的函数。'
- en: '`collections` provides a variety of useful data structures.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`collections` 提供多种有用的数据结构。'
- en: '`copy` provides functions for copying data.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`copy` 提供用于复制数据的函数。'
- en: '`csv` provides functions for reading and writing CSV files.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`csv` 提供用于读取和写入 CSV 文件的函数。'
- en: '`datetime` provides classes for handling dates and times.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`datetime` 提供处理日期和时间的类。'
- en: '`fnmatch` provides functions for matching Unix-style filename patterns.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fnmatch` 提供用于匹配 Unix 风格文件名模式的函数。'
- en: '`concurrent` provides asynchronous computation (native in Python 3, available
    for Python 2 via PyPI).'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`concurrent` 提供异步计算（Python 3 中为原生支持，Python 2 通过 PyPI 提供）。'
- en: '`glob` provides functions for matching Unix-style path patterns.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`glob` 提供用于匹配 Unix 风格路径模式的函数。'
- en: '`io` provides functions for handling I/O streams. In Python 3, it also contains
    StringIO (inside the module of the same name in Python 2), which allows you to
    treat strings as files.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`io` 提供用于处理 I/O 流的函数。在 Python 3 中，它还包含 StringIO（在 Python 2 中是同名模块），允许你将字符串当作文件来处理。'
- en: '`json` provides functions for reading and writing data in JSON format.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`json` 提供用于读取和写入 JSON 格式数据的函数。'
- en: '`logging` provides access to Python’s own built-in logging functionality.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`logging` 提供对 Python 内置日志功能的访问。'
- en: '`multiprocessing` allows you to run multiple subprocesses from your application,
    while providing an API that makes them look like threads.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`multiprocessing` 允许你从应用程序中运行多个子进程，同时提供一个 API，使它们看起来像线程。'
- en: '`operator` provides functions implementing the basic Python operators, which
    you can use instead of having to write your own lambda expressions (see [Chapter
    10](ch10.xhtml#ch10)).'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`operator` 提供实现基本 Python 运算符的函数，你可以使用这些函数，而无需编写自己的 lambda 表达式（参见 [第 10 章](ch10.xhtml#ch10)）。'
- en: '`os` provides access to basic OS functions.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`os` 提供对基本操作系统功能的访问。'
- en: '`random` provides functions for generating pseudorandom numbers.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`random` 提供生成伪随机数的函数。'
- en: '`re` provides regular expression functionality.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`re` 提供正则表达式功能。'
- en: '`sched` provides an event scheduler without using multithreading.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sched` 提供一个事件调度器，而无需使用多线程。'
- en: '`select` provides access to the `select()` and `poll()` functions for creating
    event loops.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`select` 提供对 `select()` 和 `poll()` 函数的访问，用于创建事件循环。'
- en: '`shutil` provides access to high-level file functions.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shutil` 提供对高级文件操作的访问。'
- en: '`signal` provides functions for handling POSIX signals.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`signal` 提供处理 POSIX 信号的函数。'
- en: '`tempfile` provides functions for creating temporary files and directories.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tempfile` 提供用于创建临时文件和目录的函数。'
- en: '`threading` provides access to high-level threading functionality.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`threading` 提供对高级线程功能的访问。'
- en: '`urllib` (and `urllib2` and `urlparse` in Python 2.*x*) provides functions
    for handling and parsing URLs.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`urllib`（以及 Python 2.*x* 中的 `urllib2` 和 `urlparse`）提供处理和解析 URL 的函数。'
- en: '`uuid` allows you to generate Universally Unique Identifiers (UUIDs).'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uuid` 允许你生成全局唯一标识符（UUID）。'
- en: Use this list as a quick reference for what these useful libraries modules do.
    If you can memorize even part of this list, all the better. The less time you
    have to spend looking up library modules, the more time you can spend writing
    the code you actually need.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个列表作为快速参考，了解这些有用库模块的功能。如果你能记住其中的一部分，那就更好了。你花在查找库模块上的时间越少，就可以花更多的时间编写你真正需要的代码。
- en: Most of the standard library is written in Python, so there’s nothing stopping
    you from looking at the source code of the modules and functions. When in doubt,
    crack open the code and see what it does for yourself. Even if the documentation
    has everything you need to know, there’s always a chance you could learn something
    useful.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数标准库是用 Python 编写的，因此没有任何阻止你查看模块和函数源代码的理由。如果有疑问，打开代码看看它自己是如何工作的。即使文档中包含了你需要知道的所有内容，依然有可能学到一些有用的东西。
- en: '**External Libraries**'
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**外部库**'
- en: Python’s “batteries included” philosophy is that, once you have Python installed,
    you should have everything you need to build whatever you want. This is to prevent
    the programming equivalent of unwrapping an awesome gift only to find out that
    whoever gave it to you forgot to buy batteries for it.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的“自带电池”理念是，一旦你安装了 Python，你应该拥有构建任何你想要的东西所需的一切。这是为了避免编程中的“拆开一个很棒的礼物，却发现赠送者忘记给它买电池”的情况。
- en: Unfortunately, there’s no way the people behind Python can predict *everything*
    you might want to make. And even if they could, most people wouldn’t want to deal
    with a multigigabyte download, especially if they just wanted to write a quick
    script for renaming files. So even with its extensive functionality, the Python
    Standard Library doesn’t cover everything. Luckily, members of the Python community
    have created external libraries.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，Python 的开发者无法预测你可能想要制作的*所有*内容。即使他们能做到，大多数人也不愿意处理一个几 GB 的下载文件，尤其是当他们只是想写一个快速的脚本来重命名文件时。因此，即使
    Python 标准库功能强大，它也不能覆盖所有内容。幸运的是，Python 社区的成员们创建了外部库。
- en: 'The Python Standard Library is safe, well-charted territory: its modules are
    heavily documented, and enough people use it on a regular basis that you can feel
    assured it won’t break messily when you give it a try—and in the unlikely event
    that it *does* break, you can be confident someone will fix it in short order.
    External libraries, on the other hand, are the parts of the map labeled “here
    there be dragons”: documentation may be sparse, functionality may be buggy, and
    updates may be sporadic or even nonexistent. Any serious project will likely need
    functionality that only external libraries can provide, but you need to be mindful
    of the risks involved in using them.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Python 标准库是安全的、已充分探测的领域：其模块有丰富的文档，且足够多的人定期使用它，你可以放心地尝试它，而不会发生混乱的错误——即使它*确实*出现问题，你也可以确信有人会在短时间内修复它。另一方面，外部库就像地图上标注的“这里有龙”的地方：文档可能稀缺，功能可能有缺陷，更新可能零散甚至不存在。任何严肃的项目都可能需要外部库才能提供的功能，但你需要意识到使用它们的风险。
- en: Here’s a tale of external library dangers from the trenches. OpenStack uses
    SQLAlchemy, a database toolkit for Python. If you’re familiar with SQL, you know
    that database schemas can change over time, so OpenStack also made use of `sqlalchemy-migrate`
    to handle schema migration needs. And it worked . . . until it didn’t. Bugs started
    piling up, and nothing was getting done about them. At this time, OpenStack was
    also interested in supporting Python 3, but there was no sign that `sqlalchemy-migrate`
    was moving toward Python 3 support. It was clear by that point that `sqlalchemy-migrate`
    was effectively dead for our needs and we needed to switch to something else—our
    needs had outlived the capabilities of the external library. At the time of this
    writing, OpenStack projects are migrating toward using Alembic instead, a new
    SQL database migrations tool with Python 3 support. This is happening not without
    some effort, but fortunately without much pain.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个来自战壕的外部库危险故事。OpenStack 使用 SQLAlchemy，这是一个 Python 的数据库工具包。如果你熟悉 SQL，你知道数据库模式可能会随时间变化，因此
    OpenStack 还使用了 `sqlalchemy-migrate` 来处理模式迁移需求。而且它曾经有效……直到它失效。漏洞开始堆积，但没有人去修复它们。那时，OpenStack
    也开始考虑支持 Python 3，但 `sqlalchemy-migrate` 并没有向 Python 3 兼容性发展。到那个时候，显然 `sqlalchemy-migrate`
    对我们来说已经没有用了，我们需要换成其他工具——我们的需求超出了这个外部库的能力范围。目前，OpenStack 项目正在向使用 Alembic 迁移，这是一个支持
    Python 3 的新 SQL 数据库迁移工具。虽然这不是没有努力，但幸运的是，过程并没有带来太多痛苦。
- en: '***The External Libraries Safety Checklist***'
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***外部库安全检查清单***'
- en: 'All of this builds up to one important question: how can you be sure you won’t
    fall into this external libraries trap? Unfortunately, you can’t: programmers
    are people, too, and there’s no way you can know for sure whether a library that’s
    zealously maintained today will still be in good shape in a few months. However,
    using such libraries may be worth the risk; it’s just important to carefully assess
    your situation. At OpenStack, we use the following checklist when choosing whether
    to use an external library, and I encourage you to do the same.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都引出一个重要问题：你如何确保自己不会陷入外部库的陷阱？不幸的是，你无法确定：程序员也是人，也没有办法确切知道今天仍然积极维护的库，几个月后是否还能保持良好状态。然而，使用这些库可能值得承担一定的风险；重要的是要仔细评估你的情况。在
    OpenStack 中，我们使用以下清单来决定是否使用外部库，我鼓励你也这样做。
- en: '**Python 3 compatibility** Even if you’re not targeting Python 3 right now,
    odds are good that you will somewhere down the line, so it’s a good idea to check
    that your chosen library is already Python 3–compatible and committed to staying
    that way.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python 3 兼容性** 即使你当前不针对 Python 3，未来你可能会需要它，所以最好检查你选择的库是否已经支持 Python 3，并承诺保持兼容性。'
- en: '**Active development** GitHub and Ohloh usually provide enough information
    to determine whether a given library is being actively developed by its maintainers.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**活跃开发** GitHub 和 Ohloh 通常提供足够的信息，帮助判断某个库是否正在被其维护者积极开发。'
- en: '**Active maintenance** Even if a library is considered finished (that is, feature
    complete), the maintainers should be ensuring it remains bug-free. Check the project’s
    tracking system to see how quickly the maintainers respond to bugs.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**积极维护** 即使一个库被认为已完成（即功能完整），其维护者也应该确保它保持无漏洞。检查项目的跟踪系统，看看维护者对漏洞的响应速度如何。'
- en: '**Packaged with OS distributions** If a library is packaged with major Linux
    distributions, that means other projects are depending on it—so if something goes
    wrong, you won’t be the only one complaining. It’s also a good idea to check this
    if you plan to release your software to the public: your code will be easier to
    distribute if its dependencies are already installed on the end user’s machine.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**与操作系统分发版捆绑** 如果一个库与主要的 Linux 发行版一起打包，这意味着其他项目也依赖于它——所以如果出现问题，你不会是唯一抱怨的人。如果你计划将软件发布给公众，检查这一点也是个好主意：如果它的依赖项已经安装在终端用户的机器上，你的代码将更容易分发。'
- en: '**API compatibility commitment** Nothing’s worse than having your software
    suddenly break because a library it depends on has changed its entire API. You
    might want to check whether your chosen library has had anything like this happen
    in the past.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**API 兼容性承诺** 没有什么比软件因其依赖的库更改了整个 API 而突然崩溃更糟糕的了。你可能想检查一下你选择的库是否曾经发生过类似的情况。'
- en: '**License** You need to make sure that the license is compatible with the software
    you’re planning to write and that it allows you to do whatever you intend to do
    with your code in terms of distribution, modification, and execution.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**许可证** 你需要确保许可证与你计划编写的软件兼容，并且它允许你按计划对代码进行分发、修改和执行。'
- en: Applying this checklist to dependencies is also a good idea, though that could
    turn out to be a huge undertaking. As a compromise, if you know your application
    is going to depend heavily on a particular library, you should apply this checklist
    to each of that library’s dependencies.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 将此检查清单应用于依赖项也是个不错的主意，尽管这可能是一个庞大的工作量。作为折衷，如果你知道你的应用程序将严重依赖某个特定的库，你应该将此检查清单应用于该库的每一个依赖项。
- en: '***Protecting Your Code with an API Wrapper***'
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***通过 API 封装保护你的代码***'
- en: 'No matter what libraries you end up using, you need to treat them as useful
    devices that could potentially do some serious damage. For safety, libraries should
    be treated like any physical tool: kept in your tool shed, away from your fragile
    valuables but available when you actually need them.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你最终使用哪些库，都需要把它们当作可能造成严重损害的有用工具来对待。为了安全起见，库应该像任何物理工具一样存放：放在工具棚里，远离易碎的贵重物品，但在需要时可以随时使用。
- en: No matter how useful an external library might be, be wary of letting it get
    its hooks into your actual source code. Otherwise, if something goes wrong and
    you need to switch libraries, you might have to rewrite huge swaths of your program.
    A better idea is to write your own API—a wrapper that encapsulates your external
    libraries and keeps them out of your source code. Your program never has to know
    what external libraries it’s using, only what functionality your API provides.
    Then, if you need to use a different library, all you have to change is your wrapper.
    As long as the new library provides the same functionality, you won’t have to
    touch the rest of your codebase at all. There might be exceptions, but probably
    not many; most libraries are designed to solve a tightly focused range of problems
    and can therefore be easily isolated.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 无论外部库多么有用，都要小心不要让它深入到你的源代码中。否则，如果出现问题需要切换库，你可能需要重写大量的程序代码。一个更好的主意是编写你自己的 API——一个封装外部库并将其隔离于源代码的包装器。你的程序永远不需要知道它使用了哪些外部库，只需知道你的
    API 提供了哪些功能。然后，如果你需要使用不同的库，只需更改你的包装器。只要新库提供相同的功能，你就不需要触动代码库的其余部分。可能会有例外，但大多数库都是为了处理一个紧密集中的问题范围而设计的，因此可以轻松地进行隔离。
- en: Later in [Chapter 5](ch05.xhtml#ch05), we’ll also look at how you can use entry
    points to build driver systems that will allow you to treat parts of your projects
    as modules you can switch out at will.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](ch05.xhtml#ch05)中，我们还会探讨如何利用入口点构建驱动系统，这样你就可以把项目的部分内容当作模块来随意切换。
- en: '**Package Installation: Getting More from pip**'
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**包安装：从 pip 获取更多功能**'
- en: The `pip` project offers a really simple way to handle package and external
    library installations. It is actively developed, well maintained, and included
    with Python starting at version 3.4\. It can install or uninstall packages from
    the *Python Packaging Index (PyPI)*, a tarball, or a `Wheel` archive (we’ll discuss
    these in [Chapter 5](ch05.xhtml#ch05)).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`pip` 项目提供了一种非常简单的方法来处理包和外部库的安装。它正在积极开发，得到了良好的维护，并从 Python 3.4 版本开始与 Python
    一起包含。它可以从 *Python 包索引 (PyPI)*、tar 包或 `Wheel` 归档文件安装或卸载包（我们将在[第5章](ch05.xhtml#ch05)中讨论这些）。'
- en: 'Its usage is simple:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 它的使用非常简单：
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: By looking it up on the PyPI distribution index, where anyone can upload a package
    for distribution and installation by others, `pip install` can install any package.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 PyPI 分发索引中查找，任何人都可以上传包以供其他人分发和安装，`pip install` 可以安装任何包。
- en: You can also provide a `--user` option that makes `pip` install the package
    in your home directory. This avoids polluting your operating system directories
    with packages installed system-wide.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以提供 `--user` 选项，使 `pip` 将包安装到你的主目录中。这可以避免将包安装到系统目录中，从而污染操作系统的目录。
- en: 'You can list the packages you already have installed using the `pip freeze`
    command, like so:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `pip freeze` 命令列出你已经安装的包，如下所示：
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Uninstalling packages is also supported by `pip`, using the `uninstall` command:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`pip` 也支持卸载包，可以使用 `uninstall` 命令：'
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'One very valuable feature of `pip` is its ability to install a package without
    copying the package’s file. The typical use case for this feature is when you’re
    actively working on a package and want to avoid the long and boring process of
    reinstalling it each time you need to test a change. This can be achieved by using
    the `-e <directory>` flag:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`pip` 的一个非常有价值的功能是能够安装一个包而不复制包的文件。这个功能的典型使用场景是当你在积极开发一个包并且想避免每次需要测试更改时都重新安装的漫长乏味过程。你可以通过使用
    `-e <directory>` 标志来实现：'
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here, `pip` does not copy the files from the local source directory but places
    a special file, called an `egg-link`, in your distribution path. For example:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`pip` 不会从本地源目录复制文件，而是将一个名为 `egg-link` 的特殊文件放入你的分发路径中。例如：
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `egg-link` file contains the path to add to `sys.path` to look for packages.
    The result can be easily checked by running the following command:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`egg-link` 文件包含要添加到 `sys.path` 中以查找包的路径。结果可以通过运行以下命令轻松检查：'
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Another useful `pip` tool is the `-e` option of `pip install`, helpful for
    deploying code from repositories of various version control systems: git, Mercurial,
    Subversion, and even Bazaar are supported. For example, you can install any library
    directly from a git repository by passing its address as a URL after the `-e`
    option:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的 `pip` 工具是 `pip install` 的 `-e` 选项，它有助于从各种版本控制系统的仓库中部署代码：支持 git、Mercurial、Subversion，甚至是
    Bazaar。例如，你可以通过将仓库地址作为 URL 传递给 `-e` 选项来直接从 git 仓库安装任何库：
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: For the installation to work correctly, you need to provide the package egg
    name by adding `#egg=` at the end of the URL. Then, `pip` just uses `git clone`
    to clone the repository inside a `src/<eggname>` and creates an `egg-link` file
    pointing to that same cloned directory.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确安装，你需要通过在 URL 末尾添加 `#egg=` 来提供包的 egg 名称。然后，`pip` 仅使用 `git clone` 将仓库克隆到
    `src/<eggname>` 目录下，并创建一个指向该克隆目录的 `egg-link` 文件。
- en: This mechanism is extremely handy when depending on unreleased versions of libraries
    or when working in a continuous testing system. However, since there is no versioning
    behind it, the `-e` option can also be very nasty. You cannot know in advance
    that the next commit in this remote repository is not going to break everything.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当依赖于未发布版本的库或在持续测试系统中工作时，这个机制非常有用。然而，由于没有版本控制，`-e` 选项也可能非常麻烦。你无法提前知道远程仓库中的下一个提交是否会破坏一切。
- en: Finally, all other installation tools are being deprecated in favor of `pip`,
    so you can confidently treat it as your one-stop shop for all your package management
    needs.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，所有其他安装工具都被弃用，推荐使用 `pip`，所以你可以放心地将它作为你所有包管理需求的一站式解决方案。
- en: '**Using and Choosing Frameworks**'
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用和选择框架**'
- en: 'Python has a variety of frameworks available for various kinds of Python applications:
    if you’re writing a web application, you could use Django, Pylons, TurboGears,
    Tornado, Zope, or Plone; if you’re looking for an event-driven framework, you
    could use Twisted or Circuits; and so on.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Python 为各种 Python 应用程序提供了多种框架：如果你正在编写一个 Web 应用程序，可以使用 Django、Pylons、TurboGears、Tornado、Zope
    或 Plone；如果你在寻找一个事件驱动框架，可以使用 Twisted 或 Circuits；等等。
- en: 'The main difference between frameworks and external libraries is that applications
    use frameworks by building on top of them: your code will extend the framework
    rather than vice versa. Unlike a library, which is basically an add-on you can
    bring in to give your code some extra oomph, a framework forms the *chassis* of
    your code: everything you do builds on that chassis in some way. This can be a
    double-edged sword. There are plenty of upsides to using frameworks, such as rapid
    prototyping and development, but there are also some noteworthy downsides, such
    as lock-in. You need to take these considerations into account when you decide
    whether to use a framework.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 框架和外部库之间的主要区别在于应用程序通过在框架上进行构建来使用框架：你的代码会扩展框架，而不是反过来。与库不同，库本质上是你可以引入的附加功能，来为你的代码增添一些额外的动力；框架则构成了你代码的
    *底盘*：你所做的一切都以某种方式建立在这个底盘之上。这既有利也有弊。使用框架有许多优点，例如快速原型开发和快速开发，但也有一些值得注意的缺点，比如锁定效应。在决定是否使用框架时，你需要考虑这些因素。
- en: The recommendations for what to check when choosing the right framework for
    your Python application are largely the same as those described in “[The External
    Libraries Safety Checklist](ch02.xhtml#lev2sec9)” on [page 23](ch02.xhtml#page_23)—which
    makes sense, as frameworks are distributed as bundles of Python libraries. Sometimes
    frameworks also include tools for creating, running, and deploying applications,
    but that doesn’t change the criteria you should apply. We’ve established that
    replacing an external library after you’ve already written code that makes use
    of it is a pain, but replacing a framework is a thousand times worse, usually
    requiring a complete rewrite of your program from the ground up.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择适合你的 Python 应用程序的框架时，要检查的推荐内容大体上与在《"[外部库安全检查清单](ch02.xhtml#lev2sec9)"》[第
    23 页](ch02.xhtml#page_23) 中描述的内容相同——这也说得通，因为框架通常作为 Python 库的捆绑包分发。有时框架还包括用于创建、运行和部署应用程序的工具，但这并不改变你应该应用的标准。我们已经确认，替换你已经编写了代码并依赖于的外部库是件麻烦事，但替换框架则更糟，通常需要从头开始完全重写程序。
- en: 'To give an example, the Twisted framework mentioned earlier still doesn’t have
    full Python 3 support: if you wrote a program using Twisted a few years back and
    wanted to update it to run on Python 3, you’d be out of luck. Either you’d have
    to rewrite your entire program to use a different framework, or you’d have to
    wait until someone finally gets around to upgrading Twisted with full Python 3
    support.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，前面提到的 Twisted 框架仍然没有完全支持 Python 3：如果你几年前写了一个使用 Twisted 的程序并希望将其更新以在 Python
    3 上运行，那么你可能会很失望。你要么需要重写整个程序以使用另一个框架，要么只能等到有人最终升级 Twisted，完全支持 Python 3。
- en: 'Some frameworks are lighter than others. For example, Django has its own built-in
    ORM functionality; Flask, on the other hand, has nothing of the sort. The *less*
    a framework tries to do for you, the fewer problems you’ll have with it in the
    future. However, each feature a framework lacks is another problem for you to
    solve, either by writing your own code or going through the hassle of handpicking
    another library to handle it. It’s your choice which scenario you’d rather deal
    with, but choose wisely: migrating away from a framework when things go sour can
    be a Herculean task, and even with all its other features, there’s nothing in
    Python that can help you with that.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一些框架比其他框架更轻量。例如，Django 有自己内置的 ORM 功能；而 Flask 则完全没有这种功能。框架为你做的事情越少，未来你遇到的问题就会越少。然而，每个框架缺失的功能都意味着你需要解决另一个问题，可能是通过编写自己的代码，或者麻烦地挑选另一个库来处理它。选择处理哪个场景完全取决于你，但请谨慎选择：当事情变得糟糕时，从框架迁移出去可能是一个艰巨的任务，且即使有其他所有功能，Python
    也没有什么能够帮助你应对这种情况的工具。
- en: '**Doug Hellmann, Python Core Developer, on Python Libraries**'
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Doug Hellmann，Python 核心开发者，谈 Python 库**'
- en: Doug Hellmann is a senior developer at DreamHost and a fellow contributor to
    the OpenStack project. He launched the website Python Module of the Week (*[http://www.pymotw.com/](http://www.pymotw.com/)*)
    and has written an excellent book called *The Python Standard Library by Example*.
    He is also a Python core developer. I’ve asked Doug a few questions about the
    Standard Library and designing libraries and applications around it.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Doug Hellmann 是 DreamHost 的高级开发人员，同时也是 OpenStack 项目的贡献者。他创办了名为 Python Module
    of the Week 的网站 (*[http://www.pymotw.com/](http://www.pymotw.com/)*)，并撰写了一本优秀的书籍《*Python
    标准库实例解析*》。他还是 Python 核心开发者。我向 Doug 提出了一些关于标准库以及围绕它设计库和应用程序的问题。
- en: '**When you start writing a Python application from scratch, what’s your first
    move?**'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**从零开始编写 Python 应用程序时，你的第一步是什么？**'
- en: The steps for writing an application from scratch are similar to hacking an
    existing application, in the abstract, but the details change.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 从零开始编写应用程序的步骤与修改现有应用程序在抽象层面上相似，但细节有所不同。
- en: 'When I change existing code, I start by figuring out how it works and where
    my changes would need to go. I may use some debugging techniques: adding logging
    or print statements, or using `pdb`, and running the app with test data to make
    sure I understand what it’s doing. I usually make the change and test it by hand,
    then add any automated tests before contributing a patch.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当我更改现有代码时，我首先弄清楚它是如何工作的，以及我的更改需要放在哪里。我可能会使用一些调试技术：添加日志或打印语句，或使用 `pdb`，并使用测试数据运行应用程序，以确保我理解它的运行方式。我通常会先手动做出更改并测试，然后再添加任何自动化测试，最后再提交补丁。
- en: I take the same exploratory approach when I create a new application—create
    some code and run it by hand, and then once I have the basic functionality working,
    I write tests to make sure I’ve covered all of the edge cases. Creating the tests
    may also lead to some refactoring to make the code easier to work with.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当我创建一个新应用程序时，我采取相同的探索性方法——先编写一些代码并手动运行，等基本功能实现后，我编写测试以确保覆盖所有边界情况。创建测试的过程也可能导致一些重构，使代码更易于使用。
- en: That was definitely the case with smiley [a tool for spying on your Python programs
    and recording their activities]. I started by experimenting with Python’s trace
    API, using some throwaway scripts, before building the real application. Originally,
    I planned to have one piece to instrument and collect data from another running
    application, and another to collect the data sent over the network and save it.
    While adding a couple of reporting features, I realized that the processing for
    replaying the collected data was almost identical to the processing for collecting
    it in the first place. I refactored a few classes and was able to create a base
    class for the data collection, database access, and report generator. Making those
    classes conform to the same API allowed me to easily create a version of the data
    collection app that wrote directly to the database instead of sending information
    over the network.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这在 smiley [一个用于监视 Python 程序并记录其活动的工具] 中的确如此。我从实验 Python 的 trace API 开始，使用一些临时脚本，然后才构建真正的应用程序。最初，我打算有一个部分用于插装并收集另一个正在运行的应用程序的数据，另一个部分则用于收集通过网络发送的数据并保存它。在添加了一些报告功能后，我意识到重播收集数据的处理几乎与收集数据时的处理完全相同。我重构了几个类，并能够创建一个基类来处理数据收集、数据库访问和报告生成。使这些类符合相同的
    API，使我能够轻松创建一个直接将数据写入数据库而不是通过网络发送信息的数据收集应用程序版本。
- en: While designing an app, I think about how the user interface works, but for
    libraries, I focus on how a developer will use the API. It can also be easier
    to write the tests for programs that will use the new library first, then the
    library code. I usually create a series of example programs in the form of tests
    and then build the library to work that way.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计应用程序时，我会考虑用户界面是如何工作的，但对于库，我更关注开发者将如何使用 API。有时，先为将要使用新库的程序编写测试，再编写库代码会更容易。我通常会创建一系列测试形式的示例程序，然后构建库来支持这些程序。
- en: I’ve also found that writing documentation for a library before writing any
    code helps me think through the features and workflows without committing to the
    implementation details, and it lets me record the choices I made in the design
    so the reader understands not just how to use the library but the expectations
    I had while creating it.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我还发现，在编写代码之前先为库编写文档有助于我思考功能和工作流，而不必立即决定实现细节，同时它也让我记录下我在设计中做出的选择，让读者理解不仅是如何使用库，还能理解我在创建库时的期望。
- en: '**What’s the process for getting a module into the Python Standard Library?**'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**将一个模块添加到 Python 标准库的过程是什么？**'
- en: The full process and guidelines for submitting a module into the standard library
    can be found in the Python Developer’s Guide at *[https://docs.python.org/devguide/stdlibchanges.html](https://docs.python.org/devguide/stdlibchanges.html)*.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 提交模块到标准库的完整过程和指南可以在 Python 开发者指南中找到，网址是 *[https://docs.python.org/devguide/stdlibchanges.html](https://docs.python.org/devguide/stdlibchanges.html)*。
- en: Before a module can be added, the submitter needs to prove that it’s stable
    and widely useful. The module should provide something that is either hard to
    implement correctly on your own or so useful that many developers have created
    their own variations. The API should be clear, and any module dependencies should
    be inside the Standard Library only.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个模块被添加之前，提交者需要证明它是稳定且广泛有用的。该模块应提供一些功能，这些功能要么是自己实现起来很难正确完成，要么是非常有用，很多开发者已经创建了自己的变体。API应该清晰，任何模块的依赖项应仅限于标准库内部。
- en: The first step would be to run the idea of introducing the module into the standard
    library by the community via the *python-ideas* list to informally gauge the level
    of interest. Assuming the response is positive, the next step is to create a Python
    Enhancement Proposal (PEP), which should include the motivation for adding the
    module and implementation details of how the transition will happen.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是通过*python-ideas*邮件列表在社区中提出引入该模块到标准库的想法，非正式地评估大家的兴趣。如果反响积极，下一步是创建一个Python增强提案（PEP），其中应包括添加该模块的动机和实现细节，说明如何进行过渡。
- en: Because package management and discovery tools have become so reliable, especially
    `pip` and the PyPI, it may be more practical to maintain a new library outside
    of the Python Standard Library. A separate release allows for more frequent updates
    with new features and bug fixes, which can be especially important for libraries
    addressing new technologies or APIs.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 由于包管理和发现工具已经变得非常可靠，尤其是`pip`和PyPI，因此将新的库维护在Python标准库之外可能更为实际。单独发布允许更频繁地更新新特性和修复bug，这对于处理新技术或API的库尤其重要。
- en: '**What are the top three modules from the Standard Library that you wish people
    knew more about?**'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**你希望人们更多了解的标准库中的前三个模块是什么？**'
- en: One really useful tool from the Standard Library is the `abc` module. I use
    the `abc` module to define the APIs for dynamically loaded extensions as abstract
    base classes, to help extension authors understand which methods of the API are
    required and which are optional. Abstract base classes are built into some other
    OOP [object-oriented programming] languages, but I’ve found a lot of Python programmers
    don’t know we have them as well.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 来自标准库的一个非常有用的工具是`abc`模块。我使用`abc`模块将动态加载的扩展的API定义为抽象基类，以帮助扩展作者理解哪些API方法是必需的，哪些是可选的。抽象基类内置于一些其他面向对象编程（OOP）语言中，但我发现很多Python程序员不知道我们也有它们。
- en: The binary search algorithm in the `bisect` module is a good example of a useful
    feature that’s often implemented incorrectly, which makes it a great fit for the
    Standard Library. I especially like the fact that it can search sparse lists where
    the search value may not be included in the data.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`bisect`模块中的二分查找算法是一个很好的例子，它是一个有用的特性，但经常被错误实现，因此非常适合放入标准库。我特别喜欢它可以搜索稀疏列表，其中搜索值可能不在数据中。'
- en: There are some useful data structures in the `collections` module that aren’t
    used as often as they could be. I like to use `namedtuple` for creating small,
    class-like data structures that need to hold data without any associated logic.
    It’s very easy to convert from a `namedtuple` to a regular class if logic does
    need to be added later, since `namedtuple` supports accessing attributes by name.
    Another interesting data structure from the module is `ChainMap`, which makes
    a good stackable namespace. `ChainMap` can be used to create contexts for rendering
    templates or managing configuration settings from different sources with clearly
    defined precedence.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在`collections`模块中有一些有用的数据结构，它们的使用频率并不像应有的那样高。我喜欢使用`namedtuple`来创建小型、类似类的数据结构，用于存储数据而不包含任何相关的逻辑。如果以后需要添加逻辑，将`namedtuple`转换为常规类非常简单，因为`namedtuple`支持通过名称访问属性。这个模块中的另一个有趣的数据结构是`ChainMap`，它非常适合做堆叠式命名空间。`ChainMap`可以用于创建渲染模板的上下文，或用于管理来自不同来源的配置设置，并明确规定优先级。
- en: '**A lot of projects, including OpenStack and external libraries, roll their
    own abstractions on top of the Standard Library, like for date/time handling,
    for example. In your opinion, should programmers stick to the Standard Library,
    roll their own functions, switch to some external library, or start sending patches
    to Python?**'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**很多项目，包括OpenStack和外部库，都在标准库之上构建了自己的抽象层，比如日期/时间处理等方面。你认为程序员应该坚持使用标准库，自己编写函数，切换到外部库，还是开始向Python提交补丁？**'
- en: All of the above! I prefer to avoid reinventing the wheel, so I advocate strongly
    for contributing fixes and enhancements upstream to projects that can be used
    as dependencies. On the other hand, sometimes it makes sense to create another
    abstraction and maintain that code separately, either within an application or
    as a new library.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 上述所有建议！我倾向于避免重复造轮子，因此我强烈主张将修复和增强贡献给上游项目，这些项目可以作为依赖项使用。另一方面，有时创建另一个抽象并将代码单独维护，无论是在应用程序中还是作为新库，都有其合理性。
- en: The `timeutils` module, used in your example, is a fairly thin wrapper around
    Python’s `datetime` module. Most of the functions are short and simple, but creating
    a module with the most common operations ensures they’re handled consistently
    throughout all projects. Because a lot of the functions are application specific,
    in the sense that they enforce decisions about things like timestamp format strings
    or what “now” means, they are not good candidates for patches to Python’s library
    or to be released as a general purpose library and adopted by other projects.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在你示例中使用的`timeutils`模块是对Python `datetime`模块的一个相对薄的封装。大多数函数简短且简单，但创建一个包含最常见操作的模块可以确保它们在所有项目中一致地处理。由于很多函数是应用特定的，意味着它们强制决定了像时间戳格式字符串或“现在”意味着什么这样的事项，因此它们并不适合作为补丁贡献到Python库，或者作为一个通用库发布并被其他项目采用。
- en: In contrast, I have been working to move the API services in OpenStack away
    from the WSGI [Web Server Gateway Interface] framework created in the early days
    of the project and onto a third-party web development framework. There are a lot
    of options for creating WSGI applications in Python, and while we may need to
    enhance one to make it completely suitable for OpenStack’s API servers, contributing
    those reusable changes upstream is preferable to maintaining a “private” framework.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，我一直在努力将OpenStack中的API服务从项目初期创建的WSGI [Web Server Gateway Interface]框架迁移到第三方Web开发框架。在Python中创建WSGI应用程序有很多选择，虽然我们可能需要增强其中一个框架，使其完全适用于OpenStack的API服务器，但将这些可重用的更改贡献到上游比维护一个“私有”框架更为可取。
- en: '**What would your advice be to developers hesitating between major Python versions?**'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**对于在主要Python版本之间犹豫不决的开发者，你有什么建议？**'
- en: The number of third-party libraries supporting Python 3 has reached critical
    mass. It’s easier than ever to build new libraries and applications for Python
    3, and thanks to the compatibility features added to 3.3, maintaining support
    for Python 2.7 is also easier. The major Linux distributions are working on shipping
    releases with Python 3 installed by default. Anyone starting a new project in
    Python should look seriously at Python 3, unless they have a dependency that hasn’t
    been ported. At this point, though, libraries that don’t run on Python 3 could
    almost be classified as “unmaintained.”
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 支持Python 3的第三方库数量已经达到了临界点。现在比以往任何时候都更容易为Python 3构建新的库和应用程序，而且得益于3.3中新增的兼容性功能，维护对Python
    2.7的支持也变得更容易。主要的Linux发行版正在致力于发布默认安装Python 3的版本。任何开始新项目的Python开发者都应该认真考虑Python
    3，除非他们有尚未迁移的依赖项。不过，到目前为止，不能运行在Python 3上的库几乎可以被归类为“未维护”的库。
- en: '**What are the best ways to branch code out from an application into a library
    in terms of design, planning ahead, migration, etc.?**'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**从设计、提前规划、迁移等方面来看，将代码从应用程序分支到库的最佳方法是什么？**'
- en: Applications are collections of “glue code” holding libraries together for a
    specific purpose. Designing your application with the features to achieve that
    purpose as a library first and then building the application ensures that code
    is properly organized into logical units, which in turn makes testing simpler.
    It also means the features of an application are accessible through the library
    and can be remixed to create other applications. If you don’t take this approach,
    you risk the features of the application being tightly bound to the user interface,
    which makes them harder to modify and reuse.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序是将库按特定目的组合在一起的“胶水代码”集合。先将应用程序设计为具有实现该目的的功能的库，然后再构建应用程序，确保代码被正确地组织成逻辑单元，从而简化测试。这也意味着应用程序的功能可以通过库访问，并且可以重新组合以创建其他应用程序。如果不采取这种方法，就有可能使应用程序的功能与用户界面紧密绑定，从而使它们更难以修改和重用。
- en: '**What advice would you give to people planning to design their own Python
    libraries?**'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**你会给计划设计自己Python库的人什么建议？**'
- en: I always recommend designing libraries and APIs from the top down, applying
    design criteria such as the Single Responsibility Principle (SRP) at each layer.
    Think about what the caller will want to do with the library and create an API
    that supports those features. Think about what values can be stored in an instance
    and used by the methods versus what needs to be passed to each method every time.
    Finally, think about the implementation and whether the underlying code should
    be organized differently than the code of the public API.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我总是建议从上到下设计库和 API，在每一层应用设计标准，例如单一职责原则（SRP）。考虑调用者希望如何使用库，并创建支持这些功能的 API。考虑实例中可以存储哪些值并由方法使用，以及每次方法调用时需要传递哪些参数。最后，考虑实现方式以及底层代码是否应该与公共
    API 的代码组织方式有所不同。
- en: SQLAlchemy is an excellent example of applying those guidelines. The declarative
    ORM [object relational mapping], data mapping, and expression generation layers
    are all separate. A developer can decide the right level of abstraction for entering
    the API and using the library based on their needs rather than constraints imposed
    by the library’s design.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 是一个应用这些准则的优秀示例。声明式 ORM [对象关系映射]、数据映射和表达式生成层都是分开的。开发者可以根据自己的需求而非库设计的限制，决定进入
    API 和使用库的合适抽象层次。
- en: '**What are the most common programming errors you encounter while reading Python
    developers’ code?**'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**你在阅读 Python 开发者代码时，遇到的最常见编程错误是什么？**'
- en: One area where Python’s idioms are significantly different from other languages
    is in looping and iteration. For example, one of the most common anti-patterns
    I see is the use of a `for` loop to filter a list by first appending items to
    a new list and then processing the result in a second loop (possibly after passing
    the list as an argument to a function). I almost always suggest converting filtering
    loops like these into generator expressions, which are more efficient and easier
    to understand. It’s also common to see lists being combined so their contents
    can be processed together in some way, rather than using `itertools.chain()`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的惯用法在循环和迭代方面与其他语言有显著不同。例如，我看到的最常见的反模式之一是使用 `for` 循环过滤列表，方法是首先将项附加到新列表中，然后在第二个循环中处理结果（可能是在将列表作为参数传递给函数之后）。我几乎总是建议将这种过滤循环转换为生成器表达式，这样既更高效又更容易理解。也常见将多个列表合并在一起，以便它们的内容可以以某种方式一起处理，而不是使用
    `itertools.chain()`。
- en: There are other, more subtle things I often suggest in code reviews, like using
    a `dict()` as a lookup table instead of a long `if:then:else` block, making sure
    functions always return the same type of object (for example, an empty list instead
    of `None`), reducing the number of arguments a function requires by combining
    related values into an object with either a tuple or a new class, and defining
    classes to use in public APIs instead of relying on dictionaries.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码审查中，我经常建议其他一些更微妙的改进，比如使用 `dict()` 作为查找表，而不是使用长的 `if:then:else` 语句块，确保函数总是返回相同类型的对象（例如，返回一个空列表而不是
    `None`），通过将相关值组合成元组或新类的对象来减少函数所需的参数数量，以及定义类以用于公共 API，而不是依赖字典。
- en: '**What’s your take on frameworks?**'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**你对框架的看法是什么？**'
- en: Frameworks are like any other kind of tool. They can help, but you need to take
    care when choosing one to make sure that it’s right for the job at hand.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 框架就像其他任何工具一样。它们能提供帮助，但在选择框架时，你需要小心，确保它适合当前的工作需求。
- en: Pulling out the common parts of your app into a framework helps you focus your
    development efforts on the unique aspects of an application. Frameworks also provide
    a lot of bootstrapping code, for doing things like running in development mode
    and writing a test suite, that helps you bring an application to a useful state
    more quickly. They also encourage consistency in the implementation of the application,
    which means you end up with code that is easier to understand and more reusable.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序的公共部分提取到框架中有助于你将开发精力集中在应用程序的独特方面。框架还提供了大量的引导代码，用于执行像在开发模式下运行和编写测试套件等任务，帮助你更快地将应用程序带入有用的状态。它们还鼓励应用程序实现的一致性，这意味着你最终得到的代码更容易理解和复用。
- en: There are some potential pitfalls too, though. The decision to use a particular
    framework usually implies something about the design of the application itself.
    Selecting the wrong framework can make an application harder to implement if those
    design constraints do not align naturally with the application’s requirements.
    You may end up fighting with the framework if you try to use patterns or idioms
    that differ from what it recommends.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，也存在一些潜在的陷阱。选择使用特定框架通常意味着对应用程序设计的某些假设。选择错误的框架可能会使应用程序的实现变得更加困难，特别是当这些设计约束与应用程序的需求不自然契合时。如果你尝试使用与框架推荐的模式或惯用法不同的方式，可能会发现自己不得不与框架“斗争”。
