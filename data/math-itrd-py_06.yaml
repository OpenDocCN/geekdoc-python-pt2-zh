- en: '4'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '4'
- en: TRANSFORMING AND STORING NUMBERS WITH ALGEBRA
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用代数变换和存储数字
- en: '*“Mathematics may be defined as the subject in which we never know what we
    are talking about, nor whether what we are saying is true.”'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*“数学可以定义为我们永远不知道自己在讲什么，也不知道我们所说的是否正确。”*'
- en: —Bertrand Russell*
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: — 伯特兰·罗素*
- en: '![image](../images/fintro-01.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fintro-01.jpg)'
- en: If you learned algebra in school, you’re probably familiar with the idea of
    replacing numbers with letters. For example, you can write 2*x* where *x* is a
    placeholder that can represent any number. So 2*x* represents the idea of multiplying
    two by some unknown number. In math
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在学校学过代数，你可能熟悉用字母代替数字的概念。例如，你可以写 2*x*，其中 *x* 是一个占位符，可以代表任何数字。所以 2*x* 代表将2乘以某个未知数字。在数学中
- en: class, variables become “mystery numbers” and you’re required to find what numbers
    the letters represent. [Figure 4-1](ch04.xhtml#ch04fig1) shows a student’s cheeky
    response to the problem “Find *x*.”
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在代数课上，变量成为了“神秘数字”，你需要找出字母代表的是什么数字。[图 4-1](ch04.xhtml#ch04fig1)展示了一位学生对“找 *x*”这一问题的调皮回应。
- en: '![image](../images/f053-01.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f053-01.jpg)'
- en: '*Figure 4-1: Locating the* x *variable instead of solving for its value*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-1：定位 *x* 变量，而不是解出它的值*'
- en: 'As you can see, this student has located the variable *x* in the diagram instead
    of *solving* for its value. Algebra class is all about solving equations like
    this: solve 2*x* + 5 = 13\. In this context, “to solve” means to figure out which
    number, when you replace *x* with that number, makes the equation true. You can
    solve algebra problems by balancing equations, which requires a lot of rules you
    have to memorize and follow.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这个学生在图中找到了变量 *x*，而不是*解出*它的值。代数课的核心就是解决这样的方程：解 2*x* + 5 = 13。在这个背景下，“解”意味着找出一个数字，当你用这个数字替换
    *x* 时，使方程成立。你可以通过平衡方程来解代数问题，这需要你记住并遵循很多规则。
- en: Using letters as placeholders in this way is just like using variables in Python.
    In fact, you already learned how to use variables to store and calculate numerical
    values in previous chapters. The important skill math students should learn is
    not solving for variables but rather *using* variables. In fact, solving equations
    by hand is only of limited value. In this chapter you use variables to write programs
    that find unknown values quickly and automatically without having to balance equations!
    You also learn to use a programming environment called Processing to graph functions
    to help you explore algebra visually.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 以字母作为占位符的方式就像在Python中使用变量。事实上，你已经在之前的章节中学会了如何使用变量来存储和计算数值。数学学生应学习的重要技能不是解变量，而是*使用*变量。事实上，手动解方程的价值是有限的。在这一章中，你将使用变量编写程序，快速而自动地找到未知数，而不必平衡方程！你还将学习使用一个叫做Processing的编程环境来绘制函数图像，帮助你直观地探索代数。
- en: SOLVING FIRST-DEGREE EQUATIONS
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解一阶方程
- en: One way to solve a simple equation like 2*x* + 5 = 13 with programming is by
    using *brute force* (that is, plugging in random numbers until we find the right
    one). For this particular equation we need to find a number, *x*, that when we
    multiply it by 2 and then add 5, returns 13\. I’ll make an educated guess that
    *x* is a value between −100 and 100, since we’re working with mostly double-digit
    numbers or lower.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一种通过编程解简单方程的方法是使用*暴力法*（即通过随机输入数字，直到找到正确的那个）。对于这个特定的方程，我们需要找到一个数字，*x*，当我们将它乘以2再加上5时，结果等于13。我会做一个合理的猜测，认为
    *x* 的值介于−100和100之间，因为我们处理的主要是两位数或更小的数字。
- en: This means that we can write a program that plugs all the integers between −100
    and 100 into the equation, checks the output, and prints the number that makes
    the equation true. Open a new file in IDLE, save it as *plug.py*, and enter the
    code in [Listing 4-1](ch04.xhtml#ch04list1) to see such a program in action.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以编写一个程序，将所有介于−100和100之间的整数代入方程，检查输出，并打印出使方程成立的数字。打开IDLE中新建一个文件，将其保存为
    *plug.py*，然后输入[Listing 4-1](ch04.xhtml#ch04list1)中的代码，看看这个程序是如何运行的。
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 4-1: Brute-force program that plugs in numbers to see which one satisfies
    the equation*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 4-1：暴力破解程序，通过插入数字查看哪个数字满足方程*'
- en: Here, we define the `plug()` function and initialize the `x` variable at `-100` ➊.
    On the next line we start a `while` loop that repeats until `x` equals 100, which
    is the upper limit of the range we set. We then multiply `x` by 2 and add 5 ➋.
    If the output equals 13, we tell the program to print the number, because that’s
    the solution. If the output does not equal 13, we tell the program to keep going
    through the code.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了 `plug()` 函数并将 `x` 变量初始化为 `-100` ➊。在下一行，我们开始一个 `while` 循环，直到 `x` 等于
    100，这是我们设置的范围上限。然后，我们将 `x` 乘以 2 并加上 5 ➋。如果输出等于 13，我们就告诉程序打印这个数字，因为那就是解。如果输出不等于
    13，我们就告诉程序继续执行代码。
- en: 'The loop then starts over, and the program tests the next number, which we
    get by incrementing `x` by 1 ➌. We continue the loop until we hit a match. Be
    sure to include the last line, which makes the program run the `plug()` function
    we just defined; if you don’t, your program won’t do anything! The output should
    be this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，循环重新开始，程序测试下一个数字，我们通过将 `x` 增加 1 ➌ 来获得。我们会继续循环，直到找到匹配的结果。一定要包括最后一行，这一行会使程序运行我们刚刚定义的
    `plug()` 函数；如果你不加这一行，程序就不会有任何操作！输出应该是这样的：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Using the guess-and-check method is a perfectly valid way to solve this problem.
    Plugging in all the digits by hand can be laborious, but using Python makes it
    a cinch! If you suspect the solution isn’t an integer, you might have to increment
    by smaller numbers by changing the line at ➌ to `x += .25` or some other decimal
    value.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 使用猜测和检查法是解决这个问题的一种完全有效的方法。手动插入所有数字可能很费力，但使用 Python 可以轻松搞定！如果你怀疑解不是整数，你可能需要通过更小的数字来增加，在
    ➌ 这一行改为 `x += .25` 或其他小数值。
- en: FINDING THE FORMULA FOR FIRST-DEGREE EQUATIONS
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 一阶方程的公式推导
- en: Another way to solve an equation like 2*x* + 5 = 13 is to find a general formula
    for this type of equation. We can then use this formula to write a program in
    Python. You might recall from math class that the equation 2*x* + 5 = 13 is an
    example of a *first-degree equation*, because the highest exponent a variable
    has in this equation is 1\. And you probably know that a number raised to the
    first power equals the number itself.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种解像 2*x* + 5 = 13 这样的方程的方法是找出这种类型方程的一般公式。然后，我们可以使用这个公式在 Python 中写一个程序。你可能记得数学课上讲过，方程
    2*x* + 5 = 13 是一个 *一阶方程* 的例子，因为在这个方程中，变量的最高指数是 1。你也应该知道，任何数的 1 次方等于它本身。
- en: 'In fact, all first-degree equations fit into this general formula: a*x* + b =
    c*x* + d, where a, b, c, and d represent different numbers. Here are some examples
    of other first-degree equations:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，所有一阶方程都符合这个一般公式：a*x* + b = c*x* + d，其中 a、b、c 和 d 代表不同的数字。这里是一些其他一阶方程的例子：
- en: '![image](../images/e055-01.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e055-01.jpg)'
- en: On each side of the equal sign, you can see an *x* term and a *constant*, which
    is a number with no *x* attached to it. The number that precedes the *x* variable
    is called a *coefficient*. For example, the coefficient of 3*x* is 3.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在等号的两边，你可以看到一个 *x* 项和一个 *常数*，常数是一个没有 *x* 的数字。前面那个 *x* 变量的数字叫做 *系数*。例如，3*x* 的系数是
    3。
- en: 'But sometimes there’s no *x* term at all on one side of the equation, which
    means that the coefficient of that *x* is zero. You can see this in the first
    example, 3*x* − 5 = 22, where 22 is the only term on the right side of the equal
    sign:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 但有时方程的一边根本没有 *x* 项，这意味着那个 *x* 的系数为零。你可以在第一个例子中看到这一点，3*x* − 5 = 22，其中 22 是等号右边唯一的项：
- en: '![image](../images/e055-02.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e055-02.jpg)'
- en: Using the general formula, you can see that a = 3, b = −5, and d = 22\. The
    only thing that seems to be missing is the value of c. But it’s not actually missing.
    In fact, the fact that there’s nothing there means c*x* = 0, which means that
    c must equal zero.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一般公式，你可以看到 a = 3，b = −5，d = 22。唯一缺少的似乎是 c 的值。但实际上它并不缺失。事实上，什么都没有意味着 c*x* =
    0，这也就意味着 c 必须等于零。
- en: Now let’s use a little algebra to solve the equation a*x* + b = c*x* + d for
    *x*. If we can find what *x* is in the formula, we can use it to solve virtually
    all equations of this form.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们用一点代数来解方程 a*x* + b = c*x* + d 中的 *x*。如果我们能找到 *x* 的值，就可以用它来解几乎所有这种形式的方程。
- en: 'To solve this equation, we first get all the *x*’s on one side of the equal
    sign by subtracting c*x* and b from both sides of the equation, like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解这个方程，我们首先通过从方程的两边同时减去 c*x* 和 b，将所有的 *x* 移到等号的一边，像这样：
- en: a*x* − c*x* = d − b
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: a*x* − c*x* = d − b
- en: 'Then we can factor out the *x* from a*x* and c*x*:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以从 a*x* 和 c*x* 中提取出 *x*：
- en: '*x*(a − c) = d − b'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*x*(a − c) = d − b'
- en: 'Finally, divide both sides by a − c to isolate *x*, which gives us the value
    of *x* in terms of a, b, c, and d:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，除以 a − c 来孤立 *x*，这给出了 *x* 作为 a、b、c 和 d 的函数值：
- en: '![image](../images/e056-01.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e056-01.jpg)'
- en: Now you can use this general equation to solve for any variable *x* when the
    equation is a first-degree equation and all coefficients (a, b, c, and d) are
    known. Let’s use this to write a Python program that can solve first-degree algebraic
    equations for us.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用这个一般方程来求解任何变量 *x*，当方程是一次方程并且所有系数（a、b、c 和 d）已知时。让我们用这个来编写一个 Python 程序，可以为我们解一次代数方程。
- en: WRITING THE EQUATION() FUNCTION
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编写 `equation()` 函数
- en: To write a program that will take the four coefficients of the general equation
    and print out the solution for *x*, open a new Python file in IDLE. Save it as
    *algebra.py*. We’ll write a function that takes the four numbers a, b, c, and
    d as parameters and plug them into the formula (see [Listing 4-2](ch04.xhtml#ch04list2)).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写一个程序，它将接受一般方程的四个系数并打印出 *x* 的解，请在 IDLE 中打开一个新的 Python 文件，并将其保存为 *algebra.py*。我们将编写一个函数，接受四个数字
    a、b、c 和 d 作为参数，并将它们代入公式中（参见[清单 4-2](ch04.xhtml#ch04list2)）。
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 4-2: Using programming to solve for `x`*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-2：使用编程求解 `x`*'
- en: 'Recall that the general formula of a first-degree equation is this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，一次方程的一般公式是这样的：
- en: '![image](../images/e056-02.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e056-02.jpg)'
- en: This means that for any equation with the form a*x* + b = c*x* + d, if we take
    the coefficients and plug them into this formula, we can calculate the *x* value.
    First, we set the `equation()` function to take the four coefficients as its parameters.
    Then we use the expression `(d - b)/(a − c)` to represent the general equation.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着对于任何形式为 a*x* + b = c*x* + d 的方程，如果我们将系数代入这个公式，就可以计算出 *x* 的值。首先，我们设置 `equation()`
    函数，使其接受四个系数作为参数。然后，我们使用表达式 `(d - b)/(a − c)` 来表示一般方程。
- en: 'Now let’s test our program with an equation you’ve already seen: 2*x* + 5 =
    13\. Open the Python shell, type the following code at the `>>>` prompt, and press
    ENTER:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们用你已经见过的方程来测试我们的程序：2*x* + 5 = 13。打开 Python shell，在 `>>>` 提示符下输入以下代码并按下 ENTER：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you input the coefficients of this equation into the function, you get 4
    as the solution. You can confirm that it’s correct by plugging in 4 in place of
    *x*. It works!
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将这个方程的系数输入到函数中，你将得到 4 作为解。你可以通过将 4 代入 *x* 来确认它是正确的。它有效！
- en: 'EXERCISE 4-1: SOLVING MORE EQUATIONS FOR X'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 4-1：求解更多方程中的 x
- en: Solve 12x + 18 = –34x + 67 using the program you wrote in [Listing 4-2](ch04.xhtml#ch04list2).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你在[清单 4-2](ch04.xhtml#ch04list2)中编写的程序求解 12x + 18 = –34x + 67。
- en: USING PRINT() INSTEAD OF RETURN
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 `print()` 而不是 `return`
- en: 'In [Listing 4-2](ch04.xhtml#ch04list2), we used `return` instead of `print()`
    to display our results. This is because `return` gives us our result as a number
    that we can assign to a variable and then use again. [Listing 4-3](ch04.xhtml#ch04list3)
    shows what would happen if we used `print()` instead of `return` to find *x*:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单 4-2](ch04.xhtml#ch04list2)中，我们使用 `return` 而不是 `print()` 来显示结果。这是因为 `return`
    会返回一个可以赋值给变量并再次使用的数字。[清单 4-3](ch04.xhtml#ch04list3)展示了如果我们使用 `print()` 而不是 `return`
    来查找 *x* 会发生什么：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 4-3: Using `print()` doesn’t let us save the output*'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-3：使用 `print()` 不允许我们保存输出*'
- en: 'When you run this, you get the same output:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个程序时，你会得到相同的输出：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: But when you try to call the `x` value using `print()`, the program doesn’t
    recognize your command because it hasn’t saved the result. As you can see, `return`
    can be more useful in programming because it lets you save the output of a function
    so you can apply it elsewhere. This is why we used `return` in [Listing 4-2](ch04.xhtml#ch04list2).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 但是当你尝试使用 `print()` 来调用 `x` 的值时，程序无法识别你的命令，因为它没有保存结果。如你所见，`return` 在编程中更有用，因为它允许你保存函数的输出，以便在其他地方使用。这就是为什么我们在[清单
    4-2](ch04.xhtml#ch04list2)中使用了 `return`。
- en: 'To see how you can work with the returned output, use the equation 12*x* +
    18 = −34*x* + 67 from Exercise 4-1 and assign the result to the `x` variable,
    as shown here:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看如何使用返回的输出，请使用练习 4-1 中的方程 12*x* + 18 = −34*x* + 67，并将结果赋值给 `x` 变量，如下所示：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: First, we pass the coefficients and constants of our equation to the `equation()`
    function so that it solves the equation for us and assigns the solution to the
    variable `x`. Then we can simply enter x to see its value. Now that the variable
    `x` stores the solution, we can plug it back into the equation to check that it’s
    the correct answer.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将方程的系数和常数传递给`equation()`函数，这样它就能为我们解方程并将解赋值给变量`x`。然后我们可以简单地输入x来查看它的值。现在变量`x`已经存储了解，我们可以将其代入方程中检查它是否是正确的答案。
- en: 'Enter the following to find out what 12*x* + 18, the left side of the equation,
    evaluates to:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 输入以下内容来查找方程左侧12*x* + 18的值：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We get `30.782608695652176`. Now enter the following to do the same for −34*x*
    + 67, the right side of the equation:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了`30.782608695652176`。现在输入以下内容，计算方程右侧的−34*x* + 67的值：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Except for a slight rounding discrepancy at the 15th decimal place, you can
    see that both sides of the equation evaluate to around 30.782608\. So we can be
    confident that 1.065217391304348 is indeed the correct solution for *x*! Good
    thing we returned the solution and saved the value instead of just printing it
    out once. After all, who wants to type in a number like 1.065217391304348 again
    and again?
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 除了第15位小数处的轻微舍入误差外，你可以看到方程的两边结果都接近30.782608。所以我们可以有信心，1.065217391304348确实是正确的*x*解！幸运的是，我们返回了这个解并保存了值，而不是仅仅打印一次。毕竟，谁想一遍又一遍地输入像1.065217391304348这样的数字呢？
- en: 'EXERCISE 4-2: FRACT IONS AS COEFFICIENTS'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 4-2：分数作为系数
- en: 'Use the `equation()` function to solve the last, most sinister-looking equation
    you saw on [page 55](ch04.xhtml#page_55):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`equation()`函数来解答你在[第55页](ch04.xhtml#page_55)看到的最后一个最复杂的方程：
- en: '![image](../images/e058-01.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e058-01.jpg)'
- en: SOLVING HIGHER-DEGREE EQUATIONS
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解高次方程
- en: 'Now that you know how to write programs that solve for unknown values in first-degree
    equations, let’s try something harder. For example, things get a little more complicated
    when an equation has a term raised to the second degree, like *x*² + 3*x* − 10 = 0\.
    These are called *quadratic equations*, and their general form looks like a*x*²
    + b*x* + c = 0, where a, b, and c can be any number: positive or negative, whole
    numbers, fractions, or decimals. The only exception is that a can’t be 0 because
    that would make this a first-degree equation. Unlike first-degree equations, which
    have one solution, quadratic equations have two possible solutions.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何编写程序求解一元一次方程中的未知值了，我们来尝试一些更难的题目。例如，当方程中有一个二次项时，事情会变得更加复杂，例如*x*² + 3*x*
    − 10 = 0。这些方程被称为*二次方程*，它们的一般形式是a*x*² + b*x* + c = 0，其中a、b、c可以是任何数字：正数或负数、整数、分数或小数。唯一的例外是a不能为0，因为那样会使其变成一元一次方程。与一元一次方程只有一个解不同，二次方程有两个可能的解。
- en: 'To solve an equation with a squared term, you can use the *quadratic formula*,
    which is what you get when you isolate *x* by balancing the equation a*x*² + b*x*
    + c = 0:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要解含有平方项的方程，你可以使用*二次方程公式*，这是当你通过平衡方程a*x*² + b*x* + c = 0将*x*孤立出来时得到的公式：
- en: '![image](../images/e058-02.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e058-02.jpg)'
- en: The quadratic formula is a very powerful tool for solving equations, because
    no matter what a, b, and c are in a*x*² + b*x* + c = 0, you can just plug them
    in to the formula and use basic arithmetic to find your solutions.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 二次方程公式是解决方程的一个非常强大的工具，因为无论a、b、c分别是多少，在方程a*x*² + b*x* + c = 0中，你只需将它们代入公式，并使用基本的算术运算就能找到解。
- en: We know that the coefficients of *x*² + 3*x* − 10 = 0 are 1, 3, and −10\. When
    we plug those in to the formula, we get
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道方程*x*² + 3*x* − 10 = 0的系数分别是1、3和−10。当我们将这些数代入公式时，我们得到
- en: '![image](../images/e059-01.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e059-01.jpg)'
- en: Isolate *x* and this simplifies to
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 将*x*孤立后，这个公式简化为
- en: '![image](../images/e059-02.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e059-02.jpg)'
- en: 'There are two solutions:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个解：
- en: '![image](../images/e059-03.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e059-03.jpg)'
- en: which is equal to 2, and
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 结果为2，
- en: '![image](../images/e059-04.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e059-04.jpg)'
- en: which is equal to −5.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 结果等于−5。
- en: 'We can see that replacing *x* in the quadratic formula with either of these
    solutions makes the equation true:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，将*x*代入二次方程公式中的任一解，都能使方程成立：
- en: (*2*)² + 3(*2*) − 10 = 4 + 6 − 10 = 0
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: (*2*)² + 3(*2*) − 10 = 4 + 6 − 10 = 0
- en: (*−5*)² + 3(*−5*) − 10 = 25 − 15 − 10 = 0
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: (*−5*)² + 3(*−5*) − 10 = 25 − 15 − 10 = 0
- en: Next, we’ll write a function that uses this formula to return two solutions
    for any quadratic equation.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将编写一个使用此公式的函数，返回任何二次方程的两个解。
- en: USING QUAD() TO SOLVE QUADRATIC EQUATIONS
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用QUAD()求解二次方程
- en: 'Let’s say we want to use Python to solve the following quadratic equation:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想用 Python 来求解以下二次方程：
- en: 2*x*² + 7*x* − 15 = 0
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 2*x*² + 7*x* − 15 = 0
- en: 'To do this, we’ll write a function called `quad()` that takes the three coefficients
    (a, b, and c) and returns two solutions. But before we do anything, we need to
    import the `sqrt` method from the math module. The `sqrt` method allows us to
    find the square root of a number in Python, just like a square root button on
    a calculator. It works great for positive numbers, but if you try finding the
    square root of a negative number, you’ll see an error like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们将编写一个名为 `quad()` 的函数，它接收三个系数（a、b 和 c）并返回两个解。但在我们做任何事情之前，我们需要从 math 模块导入
    `sqrt` 方法。`sqrt` 方法让我们能够在 Python 中计算一个数字的平方根，就像计算器上的平方根按钮一样。它对正数效果很好，但如果你尝试计算负数的平方根，程序会报错：
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Open a new Python file in IDLE and name it *polynomials.py*. Add the following
    line to the top of your file to import the `sqrt` function from the math module:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在 IDLE 中打开一个新的 Python 文件，并将其命名为 *polynomials.py*。在文件顶部添加以下代码，以从 math 模块导入 `sqrt`
    函数：
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Then enter the code in [Listing 4-4](ch04.xhtml#ch04list4) to create the `quad()`
    function.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然后输入[清单 4-4](ch04.xhtml#ch04list4)中的代码来创建 `quad()` 函数。
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 4-4: Using the quadratic formula to solve an equation*'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-4：使用二次公式求解方程*'
- en: The `quad()` function takes the numbers `a`, `b`, and `c` as parameters and
    plugs them in to the quadratic formula. We use `x1` to assign the result of (the
    first solution), and `x2` will store the value of (the second solution).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`quad()` 函数接收数字 `a`、`b` 和 `c` 作为参数，并将它们代入二次方程公式中。我们使用 `x1` 来存储第一个解的结果，`x2`
    将存储第二个解的值。'
- en: 'Now, let’s test this program to solve for *x* in 2*x*² + 7*x* − 15 = 0\. Plugging
    in the numbers 2, 7, and −15 for `a`, `b`, and `c` should return the following
    output:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们测试这个程序，求解方程 2*x*² + 7*x* − 15 = 0。将 2、7 和 −15 代入 `a`、`b` 和 `c` 后，应该返回以下输出：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As you can see, the two solutions for *x* are 1.5 and −5, which means both
    values should satisfy the equation 2*x*² + 7*x* − 15 = 0\. To test this, replace
    all the *x* variables in the original equation 2*x*² + 7*x* − 15 = 0 with 1.5,
    the first solution, and then with −5, the second solution, as shown here:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，*x* 的两个解是 1.5 和 −5，这意味着这两个值都应该满足方程 2*x*² + 7*x* − 15 = 0。为了验证这一点，我们将原方程
    2*x*² + 7*x* − 15 = 0 中的所有 *x* 变量分别替换为 1.5（第一个解）和 −5（第二个解），如下所示：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Success! This confirms that both values work in the original equation. You can
    use the `equation()` and `quad()` functions any time in the future. Now that you’ve
    learned to write functions to solve first-degree and second-degree equations,
    let’s discuss how to solve even higher-degree equations!
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 成功！这证明了两个值都能在原始方程中成立。你可以在未来随时使用 `equation()` 和 `quad()` 函数。既然你已经学会了编写函数来解决一阶和二阶方程，我们来讨论如何解决更高次的方程吧！
- en: USING PLUG() TO SOLVE A CUBIC EQUATION
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 `plug()` 求解三次方程
- en: In algebra class, students are often asked to solve a *cubic equation* like
    6*x*³ + 31*x*² + 3*x* − 10 = 0, which has a term raised to the third degree. We
    can tweak the `plug()` function we wrote in [Listing 4-1](ch04.xhtml#ch04list1)
    to solve this cubic equation using the brute-force method. Enter the code shown
    in [Listing 4-5](ch04.xhtml#ch04list5) into IDLE to see this in action.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在代数课上，学生经常需要解这样的 *三次方程*，例如 6*x*³ + 31*x*² + 3*x* − 10 = 0，它包含一个三次项。我们可以修改我们在[清单
    4-1](ch04.xhtml#ch04list1)中编写的 `plug()` 函数，使用暴力法来解这个三次方程。将[清单 4-5](ch04.xhtml#ch04list5)中的代码输入到
    IDLE 中，看看它如何工作。
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 4-5: Using `plug()` to solve a cubic equation*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-5：使用 `plug()` 求解三次方程*'
- en: First, we define `g(x)` to be a function that evaluates the expression `6*x**3
    + 31*x**2 + 3*x − 10`, the left side of our cubic equation. Then we tell the program
    to plug all numbers between −100 and 100 into the `g(x)` function we just defined.
    If the program finds a number that makes `g(x)` equal zero, then it has found
    the solution and prints it for the user.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义 `g(x)` 为一个函数，用于求解表达式 `6*x**3 + 31*x**2 + 3*x − 10`，这是我们三次方程的左边。然后我们让程序将
    −100 到 100 之间的所有数字代入刚才定义的 `g(x)` 函数。如果程序找到一个使得 `g(x)` 等于零的数字，那么它就找到了一个解并输出给用户。
- en: 'When you call `plug()`, you should see the following output:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用 `plug()` 时，应该会看到以下输出：
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This gives you −5 as the solution, but as you might suspect from working with
    quadratic equations previously, the *x*³ term means there could be as many as
    three solutions to this equation. As you can see, you can brute-force your way
    to a solution like this, but you won’t be able to determine whether other solutions
    exist or what they are. Fortunately, there’s a way to see all the possible inputs
    and corresponding outputs of a function; it’s called *graphing*.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这样可以得到-5作为解，但正如你可能从以前做二次方程时猜到的那样，*x*³项意味着这个方程可能有多达三个解。如你所见，你可以通过暴力求解的方式得到一个解，但你无法确定是否存在其他解或它们是什么。幸运的是，有一种方法可以看到函数的所有可能输入及其对应输出，那就是*图形化*。
- en: SOLVING EQUATIONS GRAPHICALLY
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 图形化求解方程
- en: In this section, we’ll use a nifty tool called Processing to graph higher-degree
    equations. This tool will help us find solutions to higher-degree equations in
    a fun and visual way! If you haven’t already installed Processing, follow the
    instructions in “Installing Processing” on [page xxiii](ch00.xhtml#page_xxiii).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将使用一个叫做Processing的酷工具来图形化更高次方程的解。这种工具将帮助我们以一种有趣且直观的方式找到高次方程的解！如果你还没有安装Processing，请按照[第xxiii页](ch00.xhtml#page_xxiii)的“安装Processing”部分进行操作。
- en: GETTING STARTED WITH PROCESSING
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 开始使用Processing
- en: Processing is a programming environment and a graphics library that makes it
    easy to visualize your code. You can see the cool, dynamic, interactive art you
    can make with Processing in the examples page at *[https://processing.org/examples/](https://processing.org/examples/)*.
    You can think of Processing as a sketchbook for your programming ideas. In fact,
    each Processing program you create is called a *sketch*. [Figure 4-2](ch04.xhtml#ch04fig2)
    shows what a short Processing sketch in Python mode looks like.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Processing是一个编程环境和图形库，能让你轻松地将代码可视化。你可以在*https://processing.org/examples/*这个示例页面看到你可以用Processing做出来的酷炫、动态、互动的艺术作品。你可以把Processing当作一个编程创意的草图本。事实上，你创建的每一个Processing程序都被称为*草图*。[图4-2](ch04.xhtml#ch04fig2)展示了一个在Python模式下的短Processing草图的样子。
- en: '![image](../images/f062-01.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f062-01.jpg)'
- en: '*Figure 4-2: Example of a Processing sketch*'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-2：Processing示例程序*'
- en: 'As you can see, there’s a programming environment where you enter code and
    a separate *display window* that shows the visualization of the code. This is
    a sketch of a simple program that creates a small circle. Every one of the Processing
    sketches we’ll create will contain two of Processing’s built-in functions: `setup()`
    and `draw()`. The code we put in the `setup()` function will be run once, when
    you click the play button, the arrow at the top left of the interface. Whatever
    we put in `draw()` will be repeated as an infinite loop until you click the stop
    button next to the play button.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这里有一个编程环境，你可以在其中输入代码，以及一个独立的*显示窗口*，显示代码的可视化效果。这是一个简单程序的草图，程序会创建一个小圆形。我们将创建的每一个Processing草图都将包含两个Processing内置函数：`setup()`和`draw()`。我们在`setup()`函数中放入的代码会运行一次，当你点击界面左上角的播放按钮时。我们放在`draw()`中的内容会作为一个无限循环重复执行，直到你点击播放按钮旁边的停止按钮。
- en: 'In [Figure 4-2](ch04.xhtml#ch04fig2) you can see in the `setup()` function
    we declared the size of the display screen to be 600 pixels by 600 pixels using
    the `size()` function. In the `draw()` function we told the program to draw a
    circle using the `ellipse()` function. Where? How big? We have to tell the `ellipse()`
    function four numbers: the x-coordinate of the ellipse, its y-coordinate, its
    width, and its height.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图4-2](ch04.xhtml#ch04fig2)中，你可以看到在`setup()`函数中，我们使用`size()`函数声明了显示屏的大小为600像素乘600像素。在`draw()`函数中，我们告诉程序使用`ellipse()`函数画一个圆。在哪里？多大？我们必须告诉`ellipse()`函数四个数字：椭圆的x坐标、y坐标、宽度和高度。
- en: Notice the circle shows up in the middle of the screen, which in math class
    is the *origin* (0,0). But in Processing and in many other graphics libraries,
    (0,0) is in the top left corner of the screen. So to put a circle in the middle,
    I had to divide the length of the window (600) and the width of the window (600)
    in half. So its location is (300,300), and not (0,0).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到圆形出现在屏幕中央，在数学课上，这是*原点*(0,0)。但在Processing以及许多其他图形库中，(0,0)位于屏幕的左上角。所以为了把圆放到中间，我必须将窗口的长度（600）和宽度（600）各自除以二。因此，它的位置是(300,300)，而不是(0,0)。
- en: Processing has a number of functions, like `ellipse()`, that make it easy to
    draw shapes. To see the full list, look at the reference pages at *[https://processing.org/reference/](https://processing.org/reference/)*
    to find functions for drawing ellipses, triangles, rectangles, arcs, and much
    more. We’ll explore drawing shapes with Processing in more detail in the next
    chapter.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Processing有许多函数，比如`ellipse()`，可以帮助我们轻松绘制图形。要查看完整的函数列表，可以访问*[https://processing.org/reference/](https://processing.org/reference/)*，其中有绘制椭圆、三角形、矩形、弧线等图形的函数。在下一章中，我们将更详细地探讨如何在Processing中绘制图形。
- en: '**NOTE**'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The code colors in Processing appear different from those used in IDLE. For
    example, you can see that def appears green in Processing in [Figure 4-2](ch04.xhtml#ch04fig2),
    whereas it is orange in IDLE*.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*在Processing中的代码颜色与IDLE中使用的颜色不同。例如，在[图4-2](ch04.xhtml#ch04fig2)中，可以看到`def`在Processing中显示为绿色，而在IDLE中则是橙色的*。'
- en: '#### CREATING YOUR OWN GRAPHING TOOL'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 创建你自己的图表工具'
- en: Now that you’ve downloaded Processing, let’s use it to create a graphing tool
    that allows us to see how many solutions an equation has. First, we create a grid
    of blue lines that looks like graphing paper. Then, we create the x- and y-axes
    using black lines.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经下载了Processing，我们可以用它来创建一个图表工具，帮助我们查看方程有多少个解。首先，我们创建一个蓝色线条组成的网格，看起来像图表纸。接着，我们用黑色线条创建x轴和y轴。
- en: Setting Graph Dimensions
  id: totrans-122
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 设置图表尺寸
- en: In order to make a grid for our graphing tool, we first need to set the dimensions
    of the display window. In Processing, you can use the `size()` function to indicate
    the width and height of the screen in pixels. The default screen size is 600 pixels
    by 600 pixels, but for our graphing tool we’ll create a graph that includes x-
    and y-values ranging from −10 to 10.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建我们的图表工具，首先需要设置显示窗口的尺寸。在Processing中，可以使用`size()`函数来指定屏幕的宽度和高度，单位是像素。默认的屏幕尺寸是600像素×600像素，但为了我们的图表工具，我们将创建一个包含从−10到10的x和y值的图表。
- en: Open a new file in Processing and save it as *grid.pyde*. Make sure you’re in
    Python mode. Enter the code in [Listing 4-6](ch04.xhtml#ch04list6) to declare
    the range of x- and y-values we’re interested in displaying for our graph.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在Processing中打开一个新文件，并将其保存为*grid.pyde*。确保处于Python模式。输入[清单4-6](ch04.xhtml#ch04list6)中的代码，声明我们希望显示的x值和y值范围，用于我们的图表。
- en: '[PRE16]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 4-6: Setting the range of x- and y-values for the graph*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单4-6：设置图表的x值和y值范围*'
- en: In [Listing 4-6](ch04.xhtml#ch04list6) we create two variables, `xmin` and `xmax`,
    for the minimum and maximum x-values in our grid, then we repeat the process for
    the y-values. Next we declare `rangex` for the x-range and `rangey` variable for
    the y-range. We calculate the value of `rangex` by subtracting `xmin` from `xmax`
    and do the same for the y-values.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单4-6](ch04.xhtml#ch04list6)中，我们创建了两个变量，`xmin`和`xmax`，分别代表网格中最小和最大x值，然后我们对y值做同样的处理。接下来，我们声明`rangex`表示x轴范围，`rangey`表示y轴范围。我们通过将`xmax`减去`xmin`来计算`rangex`的值，对y值做同样的操作。
- en: Because we don’t need a graph that’s 600 units by 600 units, we need to scale
    the coordinates down by multiplying the x- and y-coordinates by scale factors.
    When graphing we have to remember to multiply all our x-coordinates and y-coordinates
    by these scale factors; otherwise, they won’t show up correctly on the screen.
    To do this, update the existing code in the `setup()` function with the lines
    of code in [Listing 4-7](ch04.xhtml#ch04list7).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不需要一个600单位×600单位的图表，因此我们需要通过将x坐标和y坐标乘以缩放因子来缩放坐标。当绘制图表时，我们必须记得将所有x坐标和y坐标都乘以这些缩放因子，否则它们不会在屏幕上正确显示。为此，在`setup()`函数中更新现有代码，加入[清单4-7](ch04.xhtml#ch04list7)中的代码行。
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 4-7: Scaling coordinates using scale factors*'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单4-7：使用缩放因子缩放坐标*'
- en: First, we declare the global variables `xscl` and `yscl`, which we’ll use to
    scale our screen. `xscl` and `yscl` stand for the x-scale factor and y-scale factor,
    respectively. For example, the x-scale factor would be 1 if we want our x-range
    to be 600 pixels, or the full width of the screen. But if we want our screen to
    be between −300 and 300, the x-scale factor would be 2, which we get by dividing
    the `width` (600) by the `rangex` (300).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们声明全局变量`xscl`和`yscl`，它们将用于缩放我们的屏幕。`xscl`和`yscl`分别代表x轴缩放因子和y轴缩放因子。例如，如果我们希望x范围为600像素，即屏幕的完整宽度，那么x轴缩放因子就是1。但如果我们希望屏幕显示的范围在−300到300之间，那么x轴缩放因子就是2，这可以通过将`width`（600）除以`rangex`（300）得到。
- en: In our case, we can calculate the scale factor by dividing 600 by the x-range,
    which is 20 (−10 to 10). So the scale factor has to be 30\. From now on, we need
    to scale up all of our x- and y-coordinates by a factor of 30 so that they show
    on the screen. The good news is that the computer will do all the dividing and
    scaling for us. We just have to remember to use `xscl` and `yscl` when graphing!
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们可以通过将 600 除以 x 范围（即 20，从 −10 到 10）来计算缩放因子。所以缩放因子是 30。从现在开始，我们需要将所有的
    x 和 y 坐标都放大 30 倍，这样它们才能显示在屏幕上。好消息是，计算机会为我们完成所有的除法和缩放工作。我们只需要记得在绘制图表时使用 `xscl`
    和 `yscl`！
- en: Drawing a Grid
  id: totrans-133
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 绘制网格
- en: Now that we’ve set the proper dimensions for our graph, we can draw grid lines
    like the ones you see on graphing paper. Everything in the `setup()` function
    will be run once. Then we create an infinite loop with a function called `draw()`.
    `Setup()` and `draw()` are built-in Processing functions, and you can’t change
    their names if you want the sketch to run. Add the code in [Listing 4-8](ch04.xhtml#ch04list8)
    to create the `draw()` function.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了图表的适当尺寸，我们可以像在图表纸上看到的那样绘制网格线。`setup()` 函数中的所有代码会执行一次。然后我们用一个名为 `draw()`
    的函数创建一个无限循环。`Setup()` 和 `draw()` 是 Processing 中的内置函数，如果你想让草图运行，你不能改变它们的名称。请将代码添加到
    [Listing 4-8](ch04.xhtml#ch04list8) 中，以创建 `draw()` 函数。
- en: '[PRE18]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 4-8: Creating blue grid lines for the graph*'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 4-8: 为图表创建蓝色网格线*'
- en: First, we use `global xscl, yscl` to tell Python we’re not creating new variables
    but just using the global ones we already created. Then we set the background
    color to white using the value 255\. We use Processing’s `translate()` function
    to move shapes up and down, or left and right. The code `translate(width/2,height/2)`
    will move the origin (where x and y are both 0) from the top left to the center
    of the screen. Then we set the thickness of the lines with `strokeWeight`, where
    `1` is the thinnest. You can make them thicker if you want by using higher numbers.
    You can also change the color of the lines using `stroke`. Here, we’re using cyan
    (“sky blue”), whose RGB value is (0,255,255), which means no red values, maximum
    green, and maximum blue.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用 `global xscl, yscl` 来告诉 Python，我们并不是创建新变量，而是使用我们已经创建的全局变量。然后，我们通过使用值
    255 来将背景色设置为白色。我们使用 Processing 的 `translate()` 函数来上下或左右移动图形。代码 `translate(width/2,height/2)`
    会将原点（x 和 y 都为 0）从左上角移动到屏幕中心。然后，我们通过 `strokeWeight` 设置线条的粗细，其中 `1` 是最细的。如果你想让线条更粗，可以使用更高的数字。你还可以使用
    `stroke` 更改线条的颜色。在这里，我们使用青色（“天蓝色”），其 RGB 值是 (0,255,255)，意味着没有红色值，最大绿色和最大蓝色。
- en: After that, we use a `for` loop to avoid having to type 40 lines of code to
    draw 40 blue lines. We want the blue lines to go from `xmin` to `xmax`, including
    `xmax`, because that’s how wide our graph should be.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们使用 `for` 循环来避免输入 40 行代码绘制 40 条蓝色线条。我们希望蓝色线条从 `xmin` 到 `xmax`，包括 `xmax`，因为这就是我们的图表宽度。
- en: RGB VALUES
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: RGB 值
- en: An RGB value is a mixture of red, green, and blue, in that order. The values
    range from 0 to 255\. For example, (255,0,0) means “maximum red, no green, no
    blue.” Yellow is a mixture of red and green only, and cyan (“sky blue”) is a mixture
    of green and blue only.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: RGB 值是红、绿、蓝三种颜色的混合，顺序为红、绿、蓝。值的范围从 0 到 255。例如，(255,0,0) 表示“最大红色，没有绿色，没有蓝色”。黄色是红色和绿色的混合，青色（“天蓝色”）是绿色和蓝色的混合。
- en: '![image](../images/f065-01.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f065-01.jpg)'
- en: 'Other colors are a mixture of different levels of red, green, and blue:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 其他颜色是不同红、绿、蓝三种颜色的混合：
- en: '![image](../images/f065-02.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f065-02.jpg)'
- en: You can do a web search for “RGB Tables” to get RGB values for many more colors!
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过网页搜索“RGB 表”来获取更多颜色的 RGB 值！
- en: 'In Processing, you can draw a line by declaring four numbers: the x- and y-coordinates
    of the beginning and endpoints of the line. The vertical lines would look something
    like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Processing 中，你可以通过声明四个数字来绘制一条线：线段的起始点和结束点的 x 和 y 坐标。垂直线看起来像这样：
- en: '[PRE19]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: But because `range(x)` doesn’t include `x` (as you learned previously), our
    `for` loop needs to go from `xmin` to `xmax + 1` to include `xmax`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 但因为 `range(x)` 不包括 `x`（正如你之前学到的），所以我们的 `for` 循环需要从 `xmin` 到 `xmax + 1`，以包括 `xmax`。
- en: 'Similarly, the horizontal lines would go like this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，水平线会像这样：
- en: '[PRE20]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This time, you can see that the y-values are −10, −9, −8 and so on, whereas
    the x-values stay constant at −10 and 10, which are `xmin` and `xmax`. Let’s add
    another loop to go from `ymin` to `ymax`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，你可以看到 y 值是 −10, −9, −8 等等，而 x 值则保持不变，分别是 −10 和 10，这就是 `xmin` 和 `xmax`。让我们添加另一个循环，从
    `ymin` 到 `ymax`：
- en: '[PRE21]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If you graphed this right, you would now see a tiny splotch in the middle of
    the screen because the x- and y-coordinates go from −10 to 10, but the screen
    goes from 0 to 600 by default. This is because we haven’t multiplied all our x-
    and y-coordinates by their scale factor yet! To display the grid properly, update
    your code as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正确地绘制了图形，你现在会看到屏幕中间有一个小斑点，因为 x 和 y 坐标范围是从 −10 到 10，而屏幕默认范围是从 0 到 600。这是因为我们还没有将所有的
    x 和 y 坐标乘以它们的缩放因子！为了正确显示网格，更新你的代码如下：
- en: '[PRE22]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now you’re ready to create the x- and y-axes.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你准备好创建 x 轴和 y 轴了。
- en: Creating the X- and Y-Axes
  id: totrans-155
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 创建 X 轴和 Y 轴
- en: To add the two black lines for the x- and y-axes, we first set the stroke color
    to black by calling the `stroke()` function (with 0 being black and 255 being
    white). Then we draw a vertical line from (0,−10) to (0,10) and a horizontal line
    from (−10,0) to (10,0). Don’t forget to multiply the values by their respective
    scale factors, unless they’re 0, in which case multiplying them wouldn’t change
    them anyway.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了添加两条黑色的线条作为 x 轴和 y 轴，我们首先通过调用 `stroke()` 函数将描边颜色设置为黑色（0 为黑色，255 为白色）。然后，我们从
    (0,−10) 到 (0,10) 画一条垂直线，从 (−10,0) 到 (10,0) 画一条水平线。别忘了将这些值乘以它们各自的缩放因子，除非它们是 0，在这种情况下，乘上它们也不会改变它们。
- en: Listing 4-9 shows the complete code for creating the grid.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 4-9](ch04.xhtml#ch04list9) 显示了创建网格的完整代码。'
- en: '[PRE23]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 4-9: Creating the grid lines*'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-9：创建网格线*'
- en: When you click **Run**, you should get a nice grid, like in [Figure 4-3](ch04.xhtml#ch04fig3).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击 **运行** 时，你应该会看到一个漂亮的网格，就像在 [图 4-3](ch04.xhtml#ch04fig3) 中一样。
- en: '![image](../images/f067-01.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f067-01.jpg)'
- en: '*Figure 4-3: You’ve created a grid for graphing—and you only have to do it
    once!*'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-3：你已经创建了一个用于绘图的网格——而且你只需要做一次！*'
- en: 'This looks done, but if we try to put a point (a tiny ellipse, actually) at
    (3,6), we see a problem. Add the following code to the end of the `draw()` function:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来已经完成了，但是如果我们试图在 (3,6) 位置放一个点（实际上是一个小椭圆），我们会看到一个问题。将以下代码添加到 `draw()` 函数的末尾：
- en: '[PRE24]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: When you run this, you’ll see the output in [Figure 4-4](ch04.xhtml#ch04fig4).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个时，你会在[图 4-4](ch04.xhtml#ch04fig4)中看到输出结果。
- en: '![image](../images/f067-02.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f067-02.jpg)'
- en: '*Figure 4-4: Checking our graphing program. Almost there!*'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-4：检查我们的绘图程序。快完成了！*'
- en: 'As you can see, the point ends up on (3,−6) instead of at (3,6). Our graph
    is upside-down! To fix this, we can add a negative sign to the y-scale factor
    in the `setup()` function to flip it over:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，点最终出现在 (3,−6) 位置，而不是 (3,6) 位置。我们的图像颠倒了！要修正这个问题，我们可以在 `setup()` 函数中将 y 缩放因子加上一个负号，以翻转它：
- en: '[PRE25]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now, you should see the point at the correct location, like in [Figure 4-5](ch04.xhtml#ch04fig5).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该能看到该点在正确的位置，就像在[图 4-5](ch04.xhtml#ch04fig5)中所示。
- en: '![image](../images/f068-01.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f068-01.jpg)'
- en: '*Figure 4-5: The grapher is working properly!*'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-5：绘图程序正常工作！*'
- en: Now that we’ve written the graphing tool, let’s put it into a function so we
    can reuse it whenever we need to graph an equation.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经写好了绘图工具，让我们将其放入一个函数中，这样以后每次需要绘制方程时就可以重复使用它。
- en: Writing the grid() Function
  id: totrans-174
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 编写 `grid()` 函数
- en: To keep our code organized, we’ll separate all the code that makes the grid
    and place it in its own function, which we’ll call `grid()`. Then we’ll call the
    `grid()` function in the `draw()` function like in [Listing 4-10](ch04.xhtml#ch04list10).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持代码的组织性，我们将所有创建网格的代码分离出来，放到一个叫做 `grid()` 的独立函数中。然后，我们像在[清单 4-10](ch04.xhtml#ch04list10)中那样，在
    `draw()` 函数中调用 `grid()` 函数。
- en: '[PRE26]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Listing 4-10: Moving all the grid code into a separate function*'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-10：将所有网格代码移动到一个单独的函数中*'
- en: In programming we often organize our code into functions. Notice in [Listing
    4-10](ch04.xhtml#ch04list10) we can easily see what we’re executing in our `draw()`
    function. Now we’re ready to solve our cubic equation, 6*x*³ + 31*x*² + 3*x* −
    10 = 0.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，我们通常将代码组织成函数。注意在[清单 4-10](ch04.xhtml#ch04list10)中，我们可以轻松看到在`draw()`函数中执行的内容。现在我们准备好解方程了：6*x*³
    + 31*x*² + 3*x* − 10 = 0。
- en: GRAPHING AN EQUATION
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 绘制方程
- en: Plotting graphs is a fun and visual way to find solutions of polynomials that
    have more than one potential solution for *x*. But before we try to graph a complicated
    equation like 6*x*³ + 31*x*² + 3*x* − 10 = 0, let’s plot a simple parabola.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制图形是一种有趣且直观的方式，用于寻找具有多个潜在解的多项式的解。例如，6*x*³ + 31*x*² + 3*x* − 10 = 0 这样的复杂方程，但在我们尝试绘制这样的复杂方程之前，先来绘制一个简单的抛物线。
- en: Plotting Points
  id: totrans-181
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 绘制点
- en: 'Add this function after the `draw()` function from [Listing 4-10](ch04.xhtml#ch04list10):'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [清单 4-10](ch04.xhtml#ch04list10) 的 `draw()` 函数后面添加这个函数：
- en: '[PRE27]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This defines the function we’re calling `f(x)`. We’re telling Python what to
    do with the number *x* to produce the output of the function. In this case, we’re
    telling it to square the number *x* and return the output. Math classes have traditionally
    called functions `f(x), g(x), h(x)` and so on. Using a programming language, you
    can call functions whatever you like! We could have given this function a descriptive
    name like `parabola(x),` but since `f(x)` is commonly used, we’ll stick to that
    for now.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了我们所调用的函数`f(x)`。我们正在告诉Python如何处理数字 *x* 以生成函数的输出。在这个例子中，我们告诉它对数字 *x* 进行平方运算并返回结果。数学课程传统上将函数称为`f(x)，g(x)，h(x)`，等等。使用编程语言，你可以根据自己的喜好命名函数！我们本可以给这个函数一个描述性的名字，比如`parabola(x)`，但由于`f(x)`是常见的表示方法，我们暂时还是使用它。
- en: This is a simple parabola that we’ll graph before getting into more complicated
    functions. All the points on this curve are simply the values for `x` and its
    corresponding y-value. We could use a loop and draw small ellipses for points
    at all the whole-number values for `x`, but that would look like an unconnected
    group of points, as in [Figure 4-6](ch04.xhtml#ch04fig6).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的抛物线，我们将在深入研究更复杂的函数之前先绘制它。曲线上的所有点仅仅是`x`和它对应的y值。我们本可以使用循环并在所有整数值的`x`上绘制小椭圆，但那样看起来就像是一个不连接的点集，如[图4-6](ch04.xhtml#ch04fig6)所示。
- en: '![image](../images/f069-01.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f069-01.jpg)'
- en: '*Figure 4-6: A graph of disconnected dots*.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-6：一个由不连续点组成的图*'
- en: Using a different kind of loop, we could draw dots closer together, as in [Figure
    4-7](ch04.xhtml#ch04fig7).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不同类型的循环，我们可以将点画得更靠近，就像在[图4-7](ch04.xhtml#ch04fig7)中那样。
- en: '![image](../images/f070-01.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f070-01.jpg)'
- en: '*Figure 4-7: The dots are closer together, but it’s still not a convincing
    curve*.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-7：点更靠近了，但它仍然不像一条令人信服的曲线*。'
- en: The best way to make a connected curve is to draw lines from point to point.
    If the points are close enough together, they’ll look curved. First, we’ll create
    a `graphFunction()` function after `f(x)`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制连接曲线的最佳方法是从一个点绘制到下一个点。如果这些点足够接近，它们就会看起来像曲线。首先，我们将在`f(x)`后创建一个`graphFunction()`函数。
- en: Connecting the Points
  id: totrans-192
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 连接点
- en: 'In the `graphFunction()` function, start `x` at `xmin`, like this:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在`graphFunction()`函数中，从`xmin`开始设置`x`，像这样：
- en: '[PRE28]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To make the graph extend across the whole grid, we’ll keep increasing `x` until
    it’s equal to `xmax`. That means we’ll keep this loop going “while `x` is less
    than or equal to `xmax`,” as shown here:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使图形覆盖整个网格，我们将不断增加`x`，直到它等于`xmax`。这意味着我们将继续运行这个循环，“只要`x`小于或等于`xmax`”，如这里所示：
- en: '[PRE29]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: To draw the curve itself, we’ll draw lines from every point to every next point,
    going up a tenth of a unit at a time. Even if our function produces a curve, you
    probably won’t notice if we’re drawing a straight line between two points that
    are really close together. For example, the distance from (2, f(2)) to (2.1, f(2.1))
    is tiny, so overall the output will look curved.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 为了绘制曲线本身，我们将从每个点绘制一条线到下一个点，每次上升0.1个单位。即使我们的函数产生的是一条曲线，如果我们在两个非常接近的点之间绘制一条直线，你可能也不会注意到。例如，从(2,
    f(2))到(2.1, f(2.1))的距离非常小，因此整体输出看起来仍然是弯曲的。
- en: '[PRE30]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This code defines a function that draws a graph of `f(x)` by starting at `xmin`
    and going all the way up to `xmax`. While the x-value is less than or equal to
    `xmax`, we’ll draw a line from (x, f(x)) to ((x + 0.1), f(x + 0.1)). We can’t
    forget to increment `x` by 0.1 at the end of the loop.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码定义了一个函数，通过从`xmin`开始，一直到`xmax`，绘制`f(x)`的图像。只要x值小于或等于`xmax`，我们就会从(x, f(x))绘制一条线到((x
    + 0.1), f(x + 0.1))。我们不能忘记在循环结束时将`x`增加0.1。
- en: Listing 4-11 shows the whole code for *grid.pyde*.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4-11显示了*grid.pyde*的完整代码。
- en: '[PRE31]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '*Listing 4-11: Complete code for graphing the parabola*'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表4-11：绘制抛物线的完整代码*'
- en: This gets us the curve we’re looking for, as shown in [Figure 4-8](ch04.xhtml#ch04fig8).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这样我们就得到了我们想要的曲线，如[图4-8](ch04.xhtml#ch04fig8)所示。
- en: '![image](../images/f072-01.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f072-01.jpg)'
- en: '*Figure 4-8: A nice continuous graph of a parabola!*'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-8：一个漂亮的连续抛物线图！*'
- en: 'Now we can change our function to something more complicated, and the grapher
    will easily draw it:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将函数更改为更复杂的形式，绘图器将轻松地绘制出来：
- en: '[PRE32]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: With this simple change, you’ll see the output in [Figure 4-9](ch04.xhtml#ch04fig9),
    but the function will be in black. If you prefer a red curve, change the `stroke(0)`
    line in `graphFunction()` to `stroke``(255,0,0)`, and you’ll get a red function.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个简单的修改，你将看到[图4-9](ch04.xhtml#ch04fig9)中的输出，但是函数会显示为黑色。如果你更喜欢红色曲线，只需将`graphFunction()`中的`stroke(0)`行改为`stroke(255,0,0)`，你就能得到红色曲线。
- en: '![image](../images/f072-02.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f072-02.jpg)'
- en: '*Figure 4-9: Graphing a polynomial function*'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-9：绘制多项式函数图像*'
- en: 'It’s great to be able to simply change one line in the `f()` function and have
    the program automatically graph a different function! The solutions (called the
    *roots*) of the equation are where the graph crosses the x-axis. We can see three
    places: one where *x* = −5, another where *x* is between −1 and 0, and a third
    where *x* is between 0 and 1.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 只需要改变 `f()` 函数中的一行代码，程序就能自动绘制不同的函数图像，真是太棒了！方程的解（称为 *根*）是图形与 x 轴的交点。我们可以看到三个位置：一个是
    *x* = −5，另一个是 *x* 位于 −1 和 0 之间，第三个是 *x* 位于 0 和 1 之间。
- en: Using Guess and Check to Find the Roots
  id: totrans-212
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用猜测和检查法寻找根
- en: 'We already saw how effective our guess-and-check method was for guessing numbers
    in [Chapter 3](ch03.xhtml#ch03). Now we can use it to approximate the roots, or
    solutions, for the equation 6*x*³ + 31*x*² + 3*x* − 10 = 0\. Let’s start with
    the root between 0 and 1\. Is it 0.5 or something else? To test this, we can easily
    plug 0.5 into the equation. Create a new file in IDLE, name it *guess.py*, and
    enter the following code:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到在 [第 3 章](ch03.xhtml#ch03)中，猜测和检查方法在猜数字时是多么有效。现在我们可以用它来近似求解方程 6*x*³ +
    31*x*² + 3*x* − 10 = 0 的根或解。我们从 0 和 1 之间的根开始。是 0.5 还是其他值？为了验证这一点，我们可以轻松地将 0.5
    代入方程。创建一个新文件，在 IDLE 中命名为 *guess.py*，并输入以下代码：
- en: '[PRE33]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As you can see, when *x* equals 0.5, it makes the function equal 0, so another
    solution of our equation is *x* = 0.5.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，当 *x* 等于 0.5 时，函数值为 0，因此我们的方程的另一个解是 *x* = 0.5。
- en: 'Next, let’s try to find the root between −1 and 0\. We’ll try the average of
    −1 and 0 to start:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们尝试在 −1 和 0 之间找到根。我们首先尝试 −1 和 0 的平均值：
- en: '[PRE34]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'At *x* = −0.5, the function is negative, not zero. Looking at the graph, we
    can tell we guessed too high, so the root must be somewhere between −1 and −0.5\.
    We’ll average those endpoints and try again:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *x* = −0.5 时，函数值为负，不是零。从图形上看，我们可以判断猜测过高，因此根一定位于 −1 和 −0.5 之间。我们将这两个端点取平均值，再次尝试：
- en: '[PRE35]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We get a positive number, so we guessed too low. Therefore, the solution must
    be between −0.75 and −0.5:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到一个正值，所以猜测过低。因此，解应该位于 −0.75 和 −0.5 之间：
- en: '[PRE36]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Still too high. This is getting a bit tedious. Let’s see how we might use Python
    to do these steps for us.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然过高。这有点繁琐。我们来看看如何用 Python 来帮我们完成这些步骤。
- en: Writing the guess() Function
  id: totrans-223
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编写 guess() 函数
- en: Let’s create a function that will find the roots of an equation by averaging
    the lower and upper values and adjusting its next guesses accordingly. This will
    work for our current task, where the function is passing through the x-axis from
    positive to negative. For a function going up, from negative to positive, we’d
    have to change it around a little. [Listing 4-12](ch04.xhtml#ch04list12) shows
    the complete code for this function.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来创建一个函数，通过平均下限和上限的值并相应调整下一个猜测，来找到方程的根。这个方法适用于我们当前的任务，其中函数从正数经过 x 轴到负数。对于一个从负数到正数的上升函数，我们需要稍作调整。
    [列表 4-12](ch04.xhtml#ch04list12) 显示了这个函数的完整代码。
- en: '[PRE37]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '*Listing 4-12: The guess method for solving equations*'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 4-12：求解方程的猜测方法*'
- en: First, we declare the function for the equation we’re trying to solve using
    `f(x)`. Then we create the `average()` function to find the average of two numbers,
    which we’ll be using at every step. Finally, we write a `guess()` function that
    starts with a lower limit of −1 and an upper limit of 0, since that’s where our
    graph crossed the x-axis.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们声明我们尝试求解的方程的函数 `f(x)`。然后我们创建 `average()` 函数来找到两个数字的平均值，我们将在每一步中使用它。最后，我们编写一个
    `guess()` 函数，起始时将下限设为 −1，上限设为 0，因为这是我们的图形穿过 x 轴的地方。
- en: We then use `for i in range(20):` ➊ to create a loop that cuts the range by
    half 20 times. Our guess will be the average, or midpoint, of the upper and lower
    limits. We put that midpoint into `f(x)` and if the output equals 0, we know that’s
    our root. If the output is negative, we know we guessed too high. Then the midpoint
    will replace our upper limit and we’ll take another guess. Otherwise, if we guessed
    too low, the midpoint will become our lower limit and we’ll guess again.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用 `for i in range(20):` ➊ 来创建一个循环，将范围分割为 20 次。我们的猜测将是上下限的平均值或中点。我们将该中点代入
    `f(x)`，如果输出为 0，我们就知道它是我们的根。如果输出为负值，我们知道我们的猜测过高。然后，中点将替换我们的上限，我们将再次猜测。否则，如果我们的猜测过低，中点将成为下限，我们将继续猜测。
- en: If we haven’t returned the solution in 20 guesses, we return the latest midpoint
    and the function of that midpoint.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在 20 次猜测后仍未找到解，我们将返回最新的中点及其对应的函数值。
- en: 'When we run this, we should get two values as the output:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个时，应该会得到两个值作为输出：
- en: '[PRE38]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The first output is the x-value, which is very close to −2/3\. The second output
    is what `f(x)` evaluates to when we plug in −2/3 as the x-value. The `e-06` at
    the end is scientific notation, which means you take 9.64 and move the decimal
    place to the left six places. So `f(x)` evaluates to 0.00000964, which is very
    close to zero. To go through this guess-and-check program and get this solution,
    or rather an approximation accurate to within a millionth of the actual solution,
    to pop up in less than a second is still surprising and wonderful to me! Can you
    see the power in exploring math problems using free software like Python and Processing?
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个输出是x值，接近−2/3。第二个输出是当我们将−2/3作为x值代入时`f(x)`的结果。最后的`e-06`是科学记数法，意味着你把9.64的小数点向左移六位。因此，`f(x)`的结果是0.00000964，非常接近零。通过这个猜测并检查程序并得到这个解决方案，或者说精确到百万分之一的近似值，在不到一秒钟的时间内弹出，仍然让我感到惊讶和欣喜！你能感受到使用像Python和Processing这样的自由软件探索数学问题的力量吗？
- en: 'If we increase the number of iterations from 20 to 40, we get a number even
    closer to 0:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将迭代次数从20增加到40，我们将得到一个更接近0的数字：
- en: '[PRE39]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Let’s check `f(-0.6666666666669698)`, or `f(-2/3)`:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查`f(-0.6666666666669698)`，或者`f(-2/3)`：
- en: '[PRE40]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This checks out, so the three solutions to 6*x*³ + 31*x*² + 3*x* − 10 = 0 are
    *x* = −5, −2/3, and 1/2.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这没错，所以6*x³ + 31*x² + 3*x − 10 = 0的三个解是*x* = −5, −2/3 和 1/2。
- en: 'EXERCISE 4-3: FINDING MORE ROOTS'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 练习4-3：寻找更多的根
- en: Use the graphing tool you just created to find the roots of 2x² + 7x – 15 =
    0\. Remember, the roots are where the graph crosses the x-axis, or where the function
    equals 0\. Check your answers using your `quad()` function.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你刚刚创建的图形工具找到方程2x² + 7x – 15 = 0的根。记住，根是图形与x轴交点的位置，或者说是函数等于0的地方。使用你的`quad()`函数检查你的答案。
- en: SUMMARY
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: Math class used to be all about taking years to learn how to solve equations
    of higher and higher degree. In this chapter you learned that this isn’t so hard
    to do programmatically using our guess-and-check method. You also wrote programs
    that solve equations in other ways, like using the quadratic formula and graphing.
    In fact, you learned that all we have to do to solve an equation, no matter how
    complicated, is to graph it and approximate where it crosses the x-axis. By iterating
    and halving the range of values that work, we can get as accurate as we want.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 数学课以前总是需要花费多年时间来学习如何解高次方程。在这一章中，你学习到，使用我们的方法猜测并检查，程序化地解决这个问题并不是那么难。你还编写了其他方法来解决方程，比如使用二次公式和图形法。实际上，你已经学会了，要解决一个方程，不论它多复杂，我们所需要做的就是绘制它的图形，并估算它与x轴的交点位置。通过迭代并缩小有效值的范围，我们可以达到任意精度。
- en: In programming, we use algebra to create variables to represent values that
    will change, like the size or coordinates of an object. The user can then change
    the value of a variable in one place, and the program will automatically change
    the value of that variable everywhere in the program. The user can also change
    these variables using a loop or declare the value in a function call. In future
    chapters we’ll model real-life situations where we need to use variables to represent
    parameters and constraints on the model, like energy content and force of gravity.
    Using variables lets us change values easily, to vary different aspects of the
    model.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，我们使用代数创建变量来表示将会变化的值，比如物体的大小或坐标。用户可以在一个地方更改变量的值，然后程序会自动更新程序中所有地方的该变量的值。用户也可以通过循环改变这些变量的值，或者在函数调用中声明变量值。在未来的章节中，我们将模拟需要使用变量来表示模型参数和约束的现实情况，比如能量含量和重力。使用变量让我们能够轻松改变值，从而调整模型的不同方面。
- en: In the next chapter you’ll use Processing to create interactive graphics, like
    rotating triangles and colorful grids!
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将使用Processing创建交互式图形，比如旋转的三角形和五彩斑斓的网格！
