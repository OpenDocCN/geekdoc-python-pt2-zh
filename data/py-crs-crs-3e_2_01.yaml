- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Files and Exceptions
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 文件与异常
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: Now that you’ve mastered the basic skills you need to write organized programs
    that are easy to use, it’s time to think about making your programs even more
    relevant and usable. In this chapter, you’ll learn to work with files so your
    programs can quickly analyze lots of data.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经掌握了编写结构化、易用程序的基本技能，是时候考虑如何使你的程序更具相关性和实用性了。在本章中，你将学习如何处理文件，这样你的程序就能快速分析大量数据。
- en: You’ll learn to handle errors so your programs don’t crash when they encounter
    unexpected situations. You’ll learn about *exceptions*, which are special objects
    Python creates to manage errors that arise while a program is running. You’ll
    also learn about the `json` module, which allows you to save user data so it isn’t
    lost when your program stops running.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你将学会如何处理错误，以确保当程序遇到意外情况时不会崩溃。你将了解*异常*，它是 Python 创建的特殊对象，用来管理程序运行时发生的错误。你还将学习
    `json` 模块，它可以帮助你保存用户数据，以防程序停止运行时数据丢失。
- en: Learning to work with files and save data will make your programs easier for
    people to use. Users will be able to choose what data to enter and when to enter
    it. People will be able to run your program, do some work, and then close the
    program and pick up where they left off. Learning to handle exceptions will help
    you deal with situations in which files don’t exist and deal with other problems
    that can cause your programs to crash. This will make your programs more robust
    when they encounter bad data, whether it comes from innocent mistakes or from
    malicious attempts to break your programs. With the skills you’ll learn in this
    chapter, you’ll make your programs more applicable, usable, and stable.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 学会处理文件和保存数据将使你的程序更易于使用。用户将能够选择何时输入哪些数据。人们可以运行你的程序，完成一些工作，然后关闭程序，并从上次离开的地方继续。学习如何处理异常将帮助你处理文件不存在的情况，并应对其他可能导致程序崩溃的问题。这将使你的程序在遇到坏数据时更具稳健性，无论数据是来自无心的错误，还是恶意企图破坏程序。通过本章你将学到的技能，你将使你的程序更具适用性、可用性和稳定性。
- en: Reading from a File
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从文件中读取
- en: An incredible amount of data is available in text files. Text files can contain
    weather data, traffic data, socioeconomic data, literary works, and more. Reading
    from a file is particularly useful in data analysis applications, but it’s also
    applicable to any situation in which you want to analyze or modify information
    stored in a file. For example, you can write a program that reads in the contents
    of a text file and rewrites the file with formatting that allows a browser to
    display it.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 大量的数据可以通过文本文件获取。文本文件可以包含天气数据、交通数据、社会经济数据、文学作品等内容。从文件中读取数据在数据分析应用中尤为重要，但它同样适用于任何需要分析或修改存储在文件中的信息的情况。例如，你可以编写一个程序，读取文本文件的内容，并重新编写文件，添加格式以便浏览器能够显示。
- en: When you want to work with the information in a text file, the first step is
    to read the file into memory. You can then work through all of the file’s contents
    at once or work through the contents line by line.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想处理文本文件中的信息时，第一步是将文件读取到内存中。然后，你可以一次性处理整个文件的内容，或者逐行处理内容。
- en: Reading the Contents of a File
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 读取文件内容
- en: 'To begin, we need a file with a few lines of text in it. Let’s start with a
    file that contains *pi* to 30 decimal places, with 10 decimal places per line:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个包含几行文本的文件。让我们从一个包含 *pi* 到 30 位小数的文件开始，每行包含 10 位小数：
- en: '**pi_digits.txt**'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**pi_digits.txt**'
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To try the following examples yourself, you can enter these lines in an editor
    and save the file as *pi_digits.txt*, or you can download the file from the book’s
    resources through [https://ehmatthes.github.io/pcc_3e](https://ehmatthes.github.io/pcc_3e).
    Save the file in the same directory where you’ll store this chapter’s programs.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要亲自尝试以下示例，你可以在编辑器中输入这些行并将文件保存为 *pi_digits.txt*，或者你可以通过 [https://ehmatthes.github.io/pcc_3e](https://ehmatthes.github.io/pcc_3e)
    下载该文件。将文件保存在与你存储本章程序相同的目录中。
- en: 'Here’s a program that opens this file, reads it, and prints the contents of
    the file to the screen:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个程序，它打开文件，读取文件内容，并将文件内容打印到屏幕上：
- en: '**file_reader.py**'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**file_reader.py**'
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To work with the contents of a file, we need to tell Python the path to the
    file. A *path* is the exact location of a file or folder on a system. Python provides
    a module called `pathlib` that makes it easier to work with files and directories,
    no matter which operating system you or your program’s users are working with.
    A module that provides specific functionality like this is often called a *library*,
    hence the name `pathlib`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理文件内容，我们需要告诉 Python 文件的路径。*路径*是系统中一个文件或文件夹的确切位置。Python 提供了一个叫 `pathlib` 的模块，使得无论你或你的程序用户使用的是哪个操作系统，都能更轻松地处理文件和目录。像这样提供特定功能的模块通常被称为
    *库*，因此命名为 `pathlib`。
- en: We start by importing the `Path` class from `pathlib`. There’s a lot you can
    do with a `Path` object that points to a file. For example, you can check that
    the file exists before working with it, read the file’s contents, or write new
    data to the file. Here, we build a `Path` object representing the file *pi_digits.txt*,
    which we assign to the variable `path` ❶. Since this file is saved in the same
    directory as the *.py* file we’re writing, the filename is all that `Path` needs
    to access the file.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先从 `pathlib` 导入 `Path` 类。使用 `Path` 对象指向文件后，你可以做很多事情。例如，在操作文件之前，你可以检查文件是否存在，读取文件内容，或者向文件写入新数据。在这里，我们构建了一个表示文件
    *pi_digits.txt* 的 `Path` 对象，并将其赋值给变量 `path` ❶。因为这个文件保存在与我们编写的 *.py* 文件相同的目录中，所以
    `Path` 只需要文件名就能访问该文件。
- en: 'Once we have a `Path` object representing *pi_digits.txt*, we use the `read_text()`
    method to read the entire contents of the file ❷. The contents of the file are
    returned as a single string, which we assign to the variable `contents`. When
    we print the value of `contents`, we see the entire contents of the text file:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了一个表示 *pi_digits.txt* 的 `Path` 对象，我们就可以使用 `read_text()` 方法读取文件的全部内容 ❷。文件的内容会作为一个字符串返回，我们将其赋值给变量
    `contents`。当我们打印 `contents` 的值时，看到的就是文件的全部内容：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The only difference between this output and the original file is the extra blank
    line at the end of the output. The blank line appears because `read_text()` returns
    an empty string when it reaches the end of the file; this empty string shows up
    as a blank line.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这段输出与原始文件的唯一区别是输出末尾多了一行空白行。空白行出现是因为 `read_text()` 在到达文件末尾时返回了一个空字符串；这个空字符串显示为一行空白。
- en: 'We can remove the extra blank line by using `rstrip()` on the `contents` string:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过对 `contents` 字符串使用 `rstrip()` 来去除多余的空白行：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Recall from Chapter 2 that Python’s `rstrip()` method removes, or strips, any
    whitespace characters from the right side of a string. Now the output matches
    the contents of the original file exactly:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下第二章，Python 的 `rstrip()` 方法会移除字符串右侧的所有空白字符。现在输出的内容与原始文件完全一致：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can strip the trailing newline character when we read the contents of the
    file, by applying the `rstrip()` method immediately after calling `read_text()`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在调用 `read_text()` 后立即应用 `rstrip()` 方法来去掉读取文件内容时的末尾换行符：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This line tells Python to call the `read_text()` method on the file we’re working
    with. Then it applies the `rstrip()` method to the string that `read_text()` returns.
    The cleaned-up string is then assigned to the variable `contents`. This approach
    is called *method chaining*, and you’ll see it used often in programming.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行代码告诉 Python 调用我们正在处理的文件的 `read_text()` 方法。然后它将 `read_text()` 返回的字符串应用 `rstrip()`
    方法。清理后的字符串随后被赋值给变量 `contents`。这种方法称为 *方法链*，在编程中你会经常看到它。
- en: Relative and Absolute File Paths
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 相对路径和绝对路径
- en: When you pass a simple filename like *pi_digits.txt* to `Path`, Python looks
    in the directory where the file that’s currently being executed (that is, your
    *.py* program file) is stored.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个简单的文件名，比如 *pi_digits.txt*，传递给 `Path` 时，Python 会在当前执行的文件所在的目录中查找该文件（也就是你的
    *.py* 程序文件）。
- en: Sometimes, depending on how you organize your work, the file you want to open
    won’t be in the same directory as your program file. For example, you might store
    your program files in a folder called *python_work*; inside *python_work*, you
    might have another folder called *text_files* to distinguish your program files
    from the text files they’re manipulating. Even though *text_files* is in *python_work*,
    just passing `Path` the name of a file in *text_files* won’t work, because Python
    will only look in *python_work* and stop there; it won’t go on and look in *text_files.*
    To get Python to open files from a directory other than the one where your program
    file is stored, you need to provide the correct path.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，取决于你如何组织工作，你想要打开的文件可能不在与你的程序文件相同的目录中。例如，你可能将程序文件存储在名为*python_work*的文件夹中；在*python_work*文件夹内，你可能会有另一个名为*text_files*的文件夹，用以区分程序文件和它们所操作的文本文件。即使*text_files*在*python_work*中，直接传递文件名给`Path`也无法正常工作，因为
    Python 只会在*python_work*中查找，并且在那停止；它不会继续查找*text_files*中的文件。为了让 Python 从与你的程序文件存储位置不同的目录打开文件，你需要提供正确的路径。
- en: 'There are two main ways to specify paths in programming. A *relative file path*
    tells Python to look for a given location relative to the directory where the
    currently running program file is stored. Since *text_files* is inside *python_work*,
    we need to build a path that starts with the directory *text_files*, and ends
    with the filename. Here’s how to build this path:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 编程中指定路径有两种主要方法。*相对文件路径*告诉 Python 从当前正在运行的程序文件所在目录的位置查找给定位置。由于*text_files*位于*python_work*内，我们需要构建一个从*text_files*文件夹开始，并以文件名结束的路径。以下是如何构建这个路径的示例：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You can also tell Python exactly where the file is on your computer, regardless
    of where the program that’s being executed is stored. This is called an *absolute
    file path*. You can use an absolute path if a relative path doesn’t work. For
    instance, if you’ve put *text_files* in some folder other than *python_work*,
    then just passing `Path` the path `'text_files/``filename``.txt'` won’t work because
    Python will only look for that location inside *python_work*. You’ll need to write
    out an absolute path to clarify where you want Python to look.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以告诉 Python 文件在你电脑上的确切位置，无论正在执行的程序存储在哪里。这称为*绝对文件路径*。如果相对路径不起作用，你可以使用绝对路径。例如，如果你把*text_files*放在了与*python_work*不同的文件夹中，那么直接传递路径`Path`
    `'text_files/``filename``.txt'` 是行不通的，因为 Python 只会在*python_work*中查找该位置。你需要写出绝对路径来明确指定
    Python 应该查找的位置。
- en: 'Absolute paths are usually longer than relative paths, because they start at
    your system’s root folder:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 绝对路径通常比相对路径长，因为它们是从系统的根文件夹开始的：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Using absolute paths, you can read files from any location on your system. For
    now it’s easiest to store files in the same directory as your program files, or
    in a folder such as *text_files* within the directory that stores your program
    files.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用绝对路径，你可以从系统上的任何位置读取文件。现在，最简单的做法是将文件存储在与你的程序文件相同的目录中，或存储在一个名为*text_files*的文件夹内，该文件夹位于存储程序文件的目录中。
- en: Accessing a File’s Lines
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问文件的行
- en: When you’re working with a file, you’ll often want to examine each line of the
    file. You might be looking for certain information in the file, or you might want
    to modify the text in the file in some way. For example, you might want to read
    through a file of weather data and work with any line that includes the word *sunny*
    in the description of that day’s weather. In a news report, you might look for
    any line with the tag `<headline>` and rewrite that line with a specific kind
    of formatting.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当你处理文件时，你通常需要检查文件的每一行。你可能在文件中查找特定的信息，或者你可能想以某种方式修改文件中的文本。例如，你可能希望阅读一份天气数据文件，并处理包含*sunny*（晴天）字样的所有描述该日天气的行。在新闻报道中，你可能需要查找任何带有标签`<headline>`的行，并以特定格式重新写入该行。
- en: 'You can use the `splitlines()` method to turn a long string into a set of lines,
    and then use a `for` loop to examine each line from a file, one at a time:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`splitlines()`方法将一长串字符串转换为一组行，然后使用`for`循环逐行检查文件中的内容：
- en: '**file_reader.py**'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**file_reader.py**'
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We start out by reading the entire contents of the file, as we did earlier
    ❶. If you’re planning to work with the individual lines in a file, you don’t need
    to strip any whitespace when reading the file. The `splitlines()` method returns
    a list of all lines in the file, and we assign this list to the variable `lines`
    ❷. We then loop over these lines and print each one:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先读取文件的全部内容，就像之前那样 ❶。如果你打算处理文件中的单独行，在读取文件时不需要去除任何空白字符。`splitlines()`方法会返回文件中所有行的列表，我们将这个列表赋值给变量`lines`
    ❷。然后我们遍历这些行并打印每一行：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Since we haven’t modified any of the lines, the output matches the original
    text file exactly.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有修改任何行，输出与原始文本文件完全一致。
- en: Working with a File’s Contents
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理文件内容
- en: 'After you’ve read the contents of a file into memory, you can do whatever you
    want with that data, so let’s briefly explore the digits of *pi*. First, we’ll
    attempt to build a single string containing all the digits in the file with no
    whitespace in it:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在你将文件的内容读取到内存中后，你可以对这些数据做任何你想做的事情，所以让我们简要地探索一下*π*的数字。首先，我们将尝试构建一个不包含任何空白字符的字符串，包含文件中的所有数字：
- en: '**pi_string.py**'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**pi_string.py**'
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We start by reading the file and storing each line of digits in a list, just
    as we did in the previous example. We then create a variable, `pi_string`, to
    hold the digits of *pi*. We write a loop that adds each line of digits to `pi_string`
    ❶. We print this string, and also show how long the string is:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先读取文件并将每行数字存储在一个列表中，就像我们在前面的示例中所做的那样。然后我们创建一个变量`pi_string`，用来存储*π*的数字。我们写一个循环，将每一行数字添加到`pi_string`中
    ❶。然后我们打印这个字符串，并显示字符串的长度：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The variable `pi_string` contains the whitespace that was on the left side
    of the digits in each line, but we can get rid of that by using `lstrip()` on
    each line:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`pi_string`包含了每行数字左侧的空白字符，但我们可以通过对每一行使用`lstrip()`来去除这些空白字符：
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now we have a string containing *pi* to 30 decimal places. The string is 32
    characters long because it also includes the leading `3` and a decimal point:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个包含*π*到30位小数的字符串。这个字符串长度为32个字符，因为它还包括了前导的`3`和小数点：
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Large Files: One Million Digits'
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 大文件：一百万位
- en: 'So far, we’ve focused on analyzing a text file that contains only three lines,
    but the code in these examples would work just as well on much larger files. If
    we start with a text file that contains *pi* to 1,000,000 decimal places, instead
    of just 30, we can create a single string containing all these digits. We don’t
    need to change our program at all, except to pass it a different file. We’ll also
    print just the first 50 decimal places, so we don’t have to watch a million digits
    scroll by in the terminal:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们专注于分析一个只包含三行的文本文件，但这些示例中的代码同样适用于更大的文件。如果我们从一个包含*π*到1,000,000位的小数的文本文件开始，而不是仅仅30位，我们可以创建一个包含所有这些数字的字符串。我们不需要更改程序，只需传入一个不同的文件。我们还会只打印前50位小数，这样就不需要在终端上看一百万个数字滚动过去：
- en: '**pi_string.py**'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**pi_string.py**'
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The output shows that we do indeed have a string containing *pi* to 1,000,000
    decimal places:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示，我们确实得到了一个包含*π*到1,000,000位小数的字符串：
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Python has no inherent limit to how much data you can work with; you can work
    with as much data as your system’s memory can handle.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Python没有固有的限制来限制你可以处理的数据量；你可以处理尽可能多的数据，只要你的系统内存能承受。
- en: Is Your Birthday Contained in Pi?
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你的生日出现在*π*中吗？
- en: 'I’ve always been curious to know if my birthday appears anywhere in the digits
    of *pi*. Let’s use the program we just wrote to find out if someone’s birthday
    appears anywhere in the first million digits of *pi*. We can do this by expressing
    each birthday as a string of digits and seeing if that string appears anywhere
    in `pi_string`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我一直很好奇我的生日是否出现在*π*的数字中。让我们用刚刚写的程序来查找一下，看看某人的生日是否出现在*π*的前一百万位数字中。我们可以通过将每个生日表示为一个数字字符串，然后查看该字符串是否出现在`pi_string`中来实现：
- en: '**pi_birthday.py**'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**pi_birthday.py**'
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We first prompt for the user’s birthday, and then check if that string is in
    `pi_string`. Let’s try it:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先提示用户输入生日，然后检查该字符串是否在`pi_string`中。让我们试试：
- en: '[PRE17]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: My birthday does appear in the digits of *pi*! Once you’ve read from a file,
    you can analyze its contents in just about any way you can imagine.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我的生日确实出现在*π*的数字中！一旦你从文件中读取数据，就可以以任何你能想象的方式分析其内容。
- en: Writing to a File
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 写入文件
- en: One of the simplest ways to save data is to write it to a file. When you write
    text to a file, the output will still be available after you close the terminal
    containing your program’s output. You can examine output after a program finishes
    running, and you can share the output files with others as well. You can also
    write programs that read the text back into memory and work with it again later.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 保存数据的最简单方法之一就是将其写入文件。当你将文本写入文件时，输出在你关闭包含程序输出的终端后仍然可用。你可以在程序运行完毕后检查输出，也可以将输出文件分享给他人。你还可以编写读取文本并重新加载到内存中的程序，以便以后继续使用。
- en: Writing a Single Line
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 写入单行
- en: 'Once you have a path defined, you can write to a file using the `write_text()`
    method. To see how this works, let’s write a simple message and store it in a
    file instead of printing it to the screen:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了路径，你就可以使用 `write_text()` 方法向文件写入内容。为了演示这一过程，让我们写一个简单的消息并将其存储到文件中，而不是直接输出到屏幕：
- en: '**write_message.py**'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**write_message.py**'
- en: '[PRE18]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `write_text()` method takes a single argument: the string that you want
    to write to the file. This program has no terminal output, but if you open the
    file *programming.txt*, you’ll see one line:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`write_text()` 方法接受一个参数：你想写入文件的字符串。这个程序没有终端输出，但如果你打开 *programming.txt* 文件，你会看到一行内容：'
- en: '**programming.txt**'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**programming.txt**'
- en: '[PRE19]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This file behaves like any other file on your computer. You can open it, write
    new text in it, copy from it, paste to it, and so forth.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件的行为就像你电脑上的任何其他文件。你可以打开它，写入新文本，复制其中的内容，粘贴到其他地方，等等。
- en: Writing Multiple Lines
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 写入多行
- en: The `write_text()` method does a few things behind the scenes. If the file that
    `path` points to doesn’t exist, it creates that file. Also, after writing the
    string to the file, it makes sure the file is closed properly. Files that aren’t
    closed properly can lead to missing or corrupted data.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`write_text()` 方法在后台做了几件事。如果 `path` 指向的文件不存在，它会创建该文件。而且，在将字符串写入文件后，它会确保文件被正确关闭。没有正确关闭的文件可能会导致数据丢失或损坏。'
- en: 'To write more than one line to a file, you need to build a string containing
    the entire contents of the file, and then call `write_text()` with that string.
    Let’s write several lines to the *programming.txt* file:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要向文件写入多行，你需要构建一个包含文件所有内容的字符串，然后使用该字符串调用 `write_text()`。让我们写几行内容到 *programming.txt*
    文件中：
- en: '[PRE20]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We define a variable called `contents` that will hold the entire contents of
    the file. On the next line, we use the `+=` operator to add to this string. You
    can do this as many times as you need, to build strings of any length. In this
    case we include newline characters at the end of each line, to make sure each
    statement appears on its own line.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个名为 `contents` 的变量，用来保存文件的全部内容。在下一行，我们使用 `+=` 运算符将新的内容添加到这个字符串中。你可以根据需要多次执行此操作，构建任意长度的字符串。在这个例子中，我们在每一行的末尾添加了换行符，以确保每条语句都出现在单独的一行上。
- en: 'If you run this and then open *programming.txt*, you’ll see each of these lines
    in the text file:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这个程序并打开 *programming.txt* 文件，你会看到每一行内容都出现在文本文件中：
- en: '[PRE21]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You can also use spaces, tab characters, and blank lines to format your output,
    just as you’ve been doing with terminal-based output. There’s no limit to the
    length of your strings, and this is how many computer-generated documents are
    created.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用空格、制表符和空白行来格式化输出，就像你在终端输出中所做的那样。字符串的长度没有限制，这也是许多计算机生成文档的创建方式。
- en: Exceptions
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常
- en: Python uses special objects called *exceptions* to manage errors that arise
    during a program’s execution. Whenever an error occurs that makes Python unsure
    of what to do next, it creates an exception object. If you write code that handles
    the exception, the program will continue running. If you don’t handle the exception,
    the program will halt and show a *traceback*, which includes a report of the exception
    that was raised.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Python 使用名为 *exceptions*（异常）的特殊对象来处理程序执行过程中发生的错误。当发生一个错误时，导致 Python 不确定下一步该做什么，它会创建一个异常对象。如果你编写了处理异常的代码，程序将继续运行。如果你没有处理异常，程序会停止并显示
    *traceback*（追踪信息），其中包含已引发的异常报告。
- en: Exceptions are handled with `try`-`except` blocks. A *try*-*except* block asks
    Python to do something, but it also tells Python what to do if an exception is
    raised. When you use `try`-`except` blocks, your programs will continue running
    even if things start to go wrong. Instead of tracebacks, which can be confusing
    for users to read, users will see friendly error messages that you’ve written.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 异常通过`try`-`except`块进行处理。一个*try*-*except*块要求Python执行某些操作，但它也告诉Python如果发生异常时该怎么做。当你使用`try`-`except`块时，即使出现问题，程序也会继续运行。用户将看到你编写的友好错误信息，而不是可能让用户困惑的回溯信息。
- en: Handling the ZeroDivisionError Exception
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理`ZeroDivisionError`异常
- en: 'Let’s look at a simple error that causes Python to raise an exception. You
    probably know that it’s impossible to divide a number by zero, but let’s ask Python
    to do it anyway:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个简单的错误，导致Python引发异常。你可能知道，除以零是不可能的，但我们还是要求Python这么做：
- en: '**division_calculator.py**'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**division_calculator.py**'
- en: '[PRE22]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Python can’t do this, so we get a traceback:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Python无法执行此操作，因此我们会得到一个回溯信息：
- en: '[PRE23]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The error reported in the traceback, `ZeroDivisionError`, is an exception object
    ❶. Python creates this kind of object in response to a situation where it can’t
    do what we ask it to. When this happens, Python stops the program and tells us
    the kind of exception that was raised. We can use this information to modify our
    program. We’ll tell Python what to do when this kind of exception occurs; that
    way, if it happens again, we’ll be prepared.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 回溯中报告的错误，`ZeroDivisionError`，是一个异常对象 ❶。Python会在无法执行我们要求的操作时创建这种对象。当发生这种情况时，Python会停止程序并告诉我们引发的异常类型。我们可以使用这些信息来修改我们的程序。我们将告诉Python在这种异常发生时该做什么，这样如果它再次发生，我们就能做好准备。
- en: Using try-except Blocks
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`try`-`except`块
- en: When you think an error may occur, you can write a `try`-`except` block to handle
    the exception that might be raised. You tell Python to try running some code,
    and you tell it what to do if the code results in a particular kind of exception.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当你认为可能发生错误时，可以编写一个`try`-`except`块来处理可能引发的异常。你告诉Python尝试运行某些代码，并告诉它在代码引发特定类型的异常时应该怎么做。
- en: 'Here’s what a `try`-`except` block for handling the `ZeroDivisionError` exception
    looks like:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个用于处理`ZeroDivisionError`异常的`try`-`except`块的示例：
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We put `print(5/0)`, the line that caused the error, inside a `try` block. If
    the code in a `try` block works, Python skips over the `except` block. If the
    code in the `try` block causes an error, Python looks for an `except` block whose
    error matches the one that was raised, and runs the code in that block.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将导致错误的`print(5/0)`语句放在`try`块中。如果`try`块中的代码执行成功，Python会跳过`except`块。如果`try`块中的代码发生错误，Python会查找与引发的错误匹配的`except`块，并执行该块中的代码。
- en: 'In this example, the code in the `try` block produces a `ZeroDivisionError`,
    so Python looks for an `except` block telling it how to respond. Python then runs
    the code in that block, and the user sees a friendly error message instead of
    a traceback:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`try`块中的代码引发了一个`ZeroDivisionError`，因此Python会查找一个`except`块，告诉它如何响应。然后Python会执行该块中的代码，用户将看到一个友好的错误信息，而不是回溯信息：
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If more code followed the `try`-`except` block, the program would continue running
    because we told Python how to handle the error. Let’s look at an example where
    catching an error can allow a program to continue running.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`try`-`except`块后面还有更多的代码，程序将继续运行，因为我们告诉Python如何处理错误。让我们看一个示例，捕获错误可以让程序继续运行。
- en: Using Exceptions to Prevent Crashes
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用异常防止崩溃
- en: Handling errors correctly is especially important when the program has more
    work to do after the error occurs. This happens often in programs that prompt
    users for input. If the program responds to invalid input appropriately, it can
    prompt for more valid input instead of crashing.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 正确处理错误在程序发生错误后仍有更多工作要做时尤为重要。尤其是在提示用户输入的程序中，这种情况经常发生。如果程序能够适当响应无效输入，它可以提示用户输入更多有效的内容，而不是崩溃。
- en: 'Let’s create a simple calculator that does only division:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的仅进行除法的计算器：
- en: '**division_calculator.py**'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**division_calculator.py**'
- en: '[PRE26]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This program prompts the user to input a `first_number` ❶ and, if the user
    does not enter `q` to quit, a `second_number` ❷. We then divide these two numbers
    to get an `answer` ❸. This program does nothing to handle errors, so asking it
    to divide by zero causes it to crash:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序提示用户输入一个`first_number` ❶，如果用户没有输入`q`来退出，则输入一个`second_number` ❷。然后我们将这两个数字相除得到`answer`
    ❸。这个程序没有做任何错误处理，因此如果要求它进行除以零的操作，它会崩溃：
- en: '[PRE27]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: It’s bad that the program crashed, but it’s also not a good idea to let users
    see tracebacks. Nontechnical users will be confused by them, and in a malicious
    setting, attackers will learn more than you want them to. For example, they’ll
    know the name of your program file, and they’ll see a part of your code that isn’t
    working properly. A skilled attacker can sometimes use this information to determine
    which kind of attacks to use against your code.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 程序崩溃虽然不好，但让用户看到追踪信息也不是一个好主意。非技术用户会被这些信息弄得很困惑，而在恶意环境中，攻击者会通过这些信息学到你不希望他们知道的内容。例如，他们会知道你的程序文件名，还会看到某个无法正常工作的代码部分。一个有经验的攻击者有时可以利用这些信息来确定攻击代码的方式。
- en: The else Block
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`else` 块'
- en: 'We can make this program more error resistant by wrapping the line that might
    produce errors in a `try`-`except` block. The error occurs on the line that performs
    the division, so that’s where we’ll put the `try`-`except` block. This example
    also includes an `else` block. Any code that depends on the `try` block executing
    successfully goes in the `else` block:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将可能产生错误的行包装在`try`-`except`块中，使程序更具抗错能力。错误发生在执行除法的那一行，所以我们将在那里放置`try`-`except`块。这个例子还包括了一个`else`块。任何依赖于`try`块成功执行的代码都会放入`else`块中：
- en: '[PRE28]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We ask Python to try to complete the division operation in a `try` block ❶,
    which includes only the code that might cause an error. Any code that depends
    on the `try` block succeeding is added to the `else` block. In this case, if the
    division operation is successful, we use the `else` block to print the result
    ❸.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要求Python在`try`块中尝试完成除法操作❶，该块只包含可能引发错误的代码。任何依赖于`try`块成功的代码都放入`else`块。在这种情况下，如果除法操作成功，我们使用`else`块来打印结果❸。
- en: 'The `except` block tells Python how to respond when a `ZeroDivisionError` arises
    ❷. If the `try` block doesn’t succeed because of a division-by-zero error, we
    print a friendly message telling the user how to avoid this kind of error. The
    program continues to run, and the user never sees a traceback:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`except`块告诉Python在遇到`ZeroDivisionError`时如何响应❷。如果`try`块因为除零错误而未能成功执行，我们会打印一条友好的消息，告诉用户如何避免这种错误。程序会继续运行，用户也看不到追踪信息：'
- en: '[PRE29]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The only code that should go in a `try` block is code that might cause an exception
    to be raised. Sometimes you’ll have additional code that should run only if the
    `try` block was successful; this code goes in the `else` block. The `except` block
    tells Python what to do in case a certain exception arises when it tries to run
    the code in the `try` block.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 只有可能引发异常的代码应该放入`try`块中。有时你还会有一些额外的代码，只有在`try`块成功执行后才应该运行，这些代码会放在`else`块中。`except`块告诉Python在`try`块运行代码时遇到特定异常时应该怎么做。
- en: By anticipating likely sources of errors, you can write robust programs that
    continue to run even when they encounter invalid data and missing resources. Your
    code will be resistant to innocent user mistakes and malicious attacks.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 通过预测可能出现的错误来源，你可以编写出更加健壮的程序，即使遇到无效数据或缺失资源时也能继续运行。你的代码将能抵抗无心的用户错误和恶意攻击。
- en: Handling the FileNotFoundError Exception
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理FileNotFoundError异常
- en: One common issue when working with files is handling missing files. The file
    you’re looking for might be in a different location, the filename might be misspelled,
    or the file might not exist at all. You can handle all of these situations with
    a `try`-`except` block.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理文件时，一个常见的问题是如何处理丢失的文件。你要找的文件可能在不同的位置，文件名可能拼写错误，或者文件根本不存在。你可以通过`try`-`except`块来处理所有这些情况。
- en: 'Let’s try to read a file that doesn’t exist. The following program tries to
    read in the contents of *Alice in Wonderland*, but I haven’t saved the file *alice.txt*
    in the same directory as *alice.py*:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试读取一个不存在的文件。以下程序尝试读取*爱丽丝梦游仙境*的内容，但我没有将文件*alice.txt*保存在与*alice.py*相同的目录下：
- en: '**alice.py**'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**alice.py**'
- en: '[PRE30]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note that we’re using `read_text()` in a slightly different way here than what
    you saw earlier. The `encoding` argument is needed when your system’s default
    encoding doesn’t match the encoding of the file that’s being read. This is most
    likely to happen when reading from a file that wasn’t created on your system.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在这里使用`read_text()`的方式与之前所见的稍有不同。当你的系统默认编码与正在读取的文件编码不匹配时，需要使用`encoding`参数。这种情况最常见于读取来自非本地系统创建的文件时。
- en: 'Python can’t read from a missing file, so it raises an exception:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Python无法从丢失的文件中读取数据，因此会引发异常：
- en: '[PRE31]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This is a longer traceback than the ones we’ve seen previously, so let’s look
    at how you can make sense of more complex tracebacks. It’s often best to start
    at the very end of the traceback. On the last line, we can see that a `FileNotFoundError`
    exception was raised ❸. This is important because it tells us what kind of exception
    to use in the `except` block that we’ll write.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这是比我们之前见过的回溯信息更长的回溯，所以让我们来看看如何理解更复杂的回溯。通常最好从回溯的最后一行开始查看。在最后一行，我们可以看到引发了`FileNotFoundError`异常
    ❸。这很重要，因为它告诉我们在`except`块中使用哪种类型的异常。
- en: Looking back near the beginning of the traceback ❶, we can see that the error
    occurred at line 4 in the file *alice.py*. The next line shows the line of code
    that caused the error ❷. The rest of the traceback shows some code from the libraries
    that are involved in opening and reading from files. You don’t usually need to
    read through or understand all of these lines in a traceback.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 回溯信息的开头附近 ❶，我们可以看到错误发生在文件*alice.py*的第4行。下一行显示了导致错误的代码 ❷。其余的回溯信息展示了涉及打开和读取文件的库中的一些代码。通常，你不需要逐行阅读或理解回溯中的所有这些内容。
- en: 'To handle the error that’s being raised, the `try` block will begin with the
    line that was identified as problematic in the traceback. In our example, this
    is the line that contains `read_text()`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理引发的错误，`try`块将从回溯中标识为问题行的那一行开始。在我们的示例中，这一行包含了`read_text()`：
- en: '[PRE32]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In this example, the code in the `try` block produces a `FileNotFoundError`,
    so we write an `except` block that matches that error ❶. Python then runs the
    code in that block when the file can’t be found, and the result is a friendly
    error message instead of a traceback:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，`try`块中的代码会产生`FileNotFoundError`，因此我们编写一个匹配该错误的`except`块 ❶。当找不到文件时，Python会运行该块中的代码，结果是显示一个友好的错误信息，而不是回溯信息：
- en: '[PRE33]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The program has nothing more to do if the file doesn’t exist, so this is all
    the output we see. Let’s build on this example and see how exception handling
    can help when you’re working with more than one file.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件不存在，程序没有其他操作要做，因此我们只会看到这些输出。让我们基于这个例子继续，看看异常处理如何帮助你处理多个文件时的问题。
- en: Analyzing Text
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分析文本
- en: You can analyze text files containing entire books. Many classic works of literature
    are available as simple text files because they are in the public domain. The
    texts used in this section come from Project Gutenberg ([https://gutenberg.org](https://gutenberg.org)).
    Project Gutenberg maintains a collection of literary works that are available
    in the public domain, and it’s a great resource if you’re interested in working
    with literary texts in your programming projects.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以分析包含整本书的文本文件。许多经典文学作品作为简单的文本文件可供使用，因为它们属于公有领域。本节使用的文本来自古腾堡计划（[https://gutenberg.org](https://gutenberg.org)）。古腾堡计划维护着一系列公有领域的文学作品，如果你有兴趣在编程项目中使用文学文本，这是一个很好的资源。
- en: 'Let’s pull in the text of *Alice in Wonderland* and try to count the number
    of words in the text. To do this, we’ll use the string method `split()`, which
    by default splits a string wherever it finds any whitespace:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们导入*爱丽丝梦游仙境*的文本并尝试统计其中的单词数。为此，我们将使用字符串方法`split()`，它默认在任何空白字符处将字符串拆分：
- en: '[PRE34]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: I moved the file *alice.txt* to the correct directory, so the `try` block will
    work this time. We take the string `contents`, which now contains the entire text
    of *Alice in Wonderland* as one long string, and use `split()` to produce a list
    of all the words in the book ❶. Using `len()` on this list ❷ gives us a good approximation
    of the number of words in the original text. Lastly, we print a statement that
    reports how many words were found in the file. This code is placed in the `else`
    block because it only works if the code in the `try` block was executed successfully.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我将文件*alice.txt*移动到了正确的目录，因此这次`try`块会正常工作。我们获取包含*爱丽丝梦游仙境*全文的字符串`contents`，并使用`split()`方法将其转换为一本书中所有单词的列表
    ❶。使用`len()`函数计算该列表的长度 ❷，可以很好地估算出原始文本中的单词数。最后，我们打印一条报告，显示文件中找到的单词数。此代码放在`else`块中，因为只有在`try`块中的代码成功执行时，它才会执行。
- en: 'The output tells us how many words are in *alice.txt*:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 输出告诉我们*alice.txt*中有多少个单词：
- en: '[PRE35]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The count is a little high because extra information is provided by the publisher
    in the text file used here, but it’s a good approximation of the length of *Alice
    in Wonderland*.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 计数有点偏高，因为出版商在此处使用的文本文件中提供了额外的信息，但它大致上可以反映出*爱丽丝梦游仙境*的字数。
- en: Working with Multiple Files
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理多个文件
- en: 'Let’s add more books to analyze, but before we do, let’s move the bulk of this
    program to a function called `count_words()`. This will make it easier to run
    the analysis for multiple books:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加更多的书籍来分析，但在此之前，先将程序的大部分内容移动到一个名为`count_words()`的函数中。这将使我们能够更轻松地对多本书进行分析：
- en: '**word_count.py**'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**word_count.py**'
- en: '[PRE36]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Most of this code is unchanged. It’s only been indented, and moved into the
    body of `count_words()`. It’s a good habit to keep comments up to date when you’re
    modifying a program, so the comment has also been changed to a docstring and reworded
    slightly ❶.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码大部分没有变化。它只是被缩进并移到了`count_words()`的主体内。修改程序时保持注释更新是一个好习惯，因此注释也已经被更改为文档字符串，并稍微重新措辞了
    ❶。
- en: 'Now we can write a short loop to count the words in any text we want to analyze.
    We do this by storing the names of the files we want to analyze in a list, and
    then we call `count_words()` for each file in the list. We’ll try to count the
    words for *Alice in Wonderland*, *Siddhartha*, *Moby Dick*, and *Little Women*,
    which are all available in the public domain. I’ve intentionally left *siddhartha.txt*
    out of the directory containing *word_count.py*, so we can see how well our program
    handles a missing file:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以编写一个简短的循环，统计我们想要分析的任何文本中的单词。我们通过将要分析的文件名存储在一个列表中来实现，然后对列表中的每个文件调用`count_words()`。我们将尝试统计*Alice
    in Wonderland*（《爱丽丝梦游仙境》）、*Siddhartha*（《悉达多》）、*Moby Dick*（《白鲸》）和*Little Women*（《小妇人》）的字数，这些书籍都可以在公共领域找到。我故意将*siddhartha.txt*文件从包含*word_count.py*的目录中遗漏，以便我们可以看到程序如何处理缺失的文件：
- en: '[PRE37]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The names of the files are stored as simple strings. Each string is then converted
    to a `Path` object ❶, before the call to `count_words()`. The missing *siddhartha.txt*
    file has no effect on the rest of the program’s execution:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 文件名作为简单的字符串存储。每个字符串在调用`count_words()`之前都会被转换为一个`Path`对象 ❶。缺失的*siddhartha.txt*文件不会影响程序的其余部分执行：
- en: '[PRE38]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Using the `try`-`except` block in this example provides two significant advantages.
    We prevent our users from seeing a traceback, and we let the program continue
    analyzing the texts it’s able to find. If we don’t catch the `FileNotFoundError`
    that *siddhartha.txt* raises, the user would see a full traceback, and the program
    would stop running after trying to analyze *Siddhartha*. It would never analyze
    *Moby Dick* or *Little Women*.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中使用`try`-`except`块提供了两个显著的优势。我们防止用户看到回溯信息，并且让程序继续分析它能够找到的文本。如果我们没有捕获到*siddhartha.txt*引发的`FileNotFoundError`，用户将看到完整的回溯信息，程序会在尝试分析*Siddhartha*后停止运行。它将永远不会分析*Moby
    Dick*或*Little Women*。
- en: Failing Silently
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安静地失败
- en: 'In the previous example, we informed our users that one of the files was unavailable.
    But you don’t need to report every exception you catch. Sometimes, you’ll want
    the program to fail silently when an exception occurs and continue on as if nothing
    happened. To make a program fail silently, you write a `try` block as usual, but
    you explicitly tell Python to do nothing in the `except` block. Python has a `pass`
    statement that tells it to do nothing in a block:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的示例中，我们告知用户某个文件不可用。但并不是所有捕获到的异常都需要报告。有时你希望程序在发生异常时默默地失败，并继续执行，就好像什么都没发生一样。要让程序安静地失败，你照常编写`try`块，但在`except`块中明确告诉Python不做任何事。Python有一个`pass`语句，它会告诉Python在该块中什么也不做：
- en: '[PRE39]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The only difference between this listing and the previous one is the `pass`
    statement in the `except` block. Now when a `FileNotFoundError` is raised, the
    code in the `except` block runs, but nothing happens. No traceback is produced,
    and there’s no output in response to the error that was raised. Users see the
    word counts for each file that exists, but they don’t see any indication that
    a file wasn’t found:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这份列表和之前的唯一不同之处在于`except`块中的`pass`语句。现在，当抛出`FileNotFoundError`时，`except`块中的代码会运行，但什么也不会发生。不会生成回溯信息，用户也不会看到针对抛出的错误的任何输出。用户只能看到每个文件的字数，但不会看到文件未找到的任何提示：
- en: '[PRE40]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `pass` statement also acts as a placeholder. It’s a reminder that you’re
    choosing to do nothing at a specific point in your program’s execution and that
    you might want to do something there later. For example, in this program we might
    decide to write any missing filenames to a file called *missing_files.txt*. Our
    users wouldn’t see this file, but we’d be able to read the file and deal with
    any missing texts.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`pass`语句也充当占位符。它提醒你在程序执行的特定位置选择不做任何操作，并且可能稍后在该位置做些事情。例如，在这个程序中，我们可能决定将任何缺失的文件名写入名为*missing_files.txt*的文件。我们的用户看不到这个文件，但我们可以读取这个文件并处理任何缺失的文本。'
- en: Deciding Which Errors to Report
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 决定报告哪些错误
- en: How do you know when to report an error to your users and when to let your program
    fail silently? If users know which texts are supposed to be analyzed, they might
    appreciate a message informing them why some texts were not analyzed. If users
    expect to see some results but don’t know which books are supposed to be analyzed,
    they might not need to know that some texts were unavailable. Giving users information
    they aren’t looking for can decrease the usability of your program. Python’s error-handling
    structures give you fine-grained control over how much to share with users when
    things go wrong; it’s up to you to decide how much information to share.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何知道何时向用户报告错误，以及何时让程序悄无声息地失败？如果用户知道哪些文本应该被分析，他们可能会希望看到一条消息，告诉他们为什么某些文本未被分析。如果用户期望看到一些结果，但不知道哪些书籍应该被分析，他们可能不需要知道某些文本不可用。向用户提供他们不需要的信息可能会降低程序的可用性。Python的错误处理结构让你能精细地控制在出现问题时与用户共享多少信息；决定共享多少信息由你来决定。
- en: Well-written, properly tested code is not very prone to internal errors, such
    as syntax or logical errors. But every time your program depends on something
    external such as user input, the existence of a file, or the availability of a
    network connection, there is a possibility of an exception being raised. A little
    experience will help you know where to include exception-handling blocks in your
    program and how much to report to users about errors that arise.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 编写良好、经过充分测试的代码不容易出现内部错误，如语法或逻辑错误。但是每当你的程序依赖于外部因素，比如用户输入、文件的存在或网络连接的可用性时，都有可能引发异常。通过一些经验，你将能知道在程序中应该在哪里加入异常处理块，以及在出现错误时应该向用户报告多少信息。
- en: Storing Data
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储数据
- en: Many of your programs will ask users to input certain kinds of information.
    You might allow users to store preferences in a game or provide data for a visualization.
    Whatever the focus of your program is, you’ll store the information users provide
    in data structures such as lists and dictionaries. When users close a program,
    you’ll almost always want to save the information they entered. A simple way to
    do this involves storing your data using the `json` module.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你的许多程序都会要求用户输入某些类型的信息。你可能会允许用户在游戏中存储偏好设置，或为可视化提供数据。无论你的程序关注的是什么，你都会将用户提供的信息存储在列表和字典等数据结构中。当用户关闭程序时，你几乎总是希望保存他们输入的信息。一种简单的实现方法是使用`json`模块来存储数据。
- en: The `json` module allows you to convert simple Python data structures into JSON-formatted
    strings, and then load the data from that file the next time the program runs.
    You can also use `json` to share data between different Python programs. Even
    better, the JSON data format is not specific to Python, so you can share data
    you store in the JSON format with people who work in many other programming languages.
    It’s a useful and portable format, and it’s easy to learn.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`json`模块允许你将简单的Python数据结构转换为JSON格式的字符串，然后在程序下次运行时从该文件中加载数据。你还可以使用`json`在不同的Python程序之间共享数据。更好的是，JSON数据格式并不限于Python，因此你可以将存储在JSON格式中的数据与使用其他编程语言的人员共享。这是一个有用且便于移植的格式，而且容易学习。'
- en: Using json.dumps() and json.loads()
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用json.dumps()和json.loads()
- en: Let’s write a short program that stores a set of numbers and another program
    that reads these numbers back into memory. The first program will use `json.dumps()`
    to store the set of numbers, and the second program will use `json.loads()`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个简单的程序，存储一组数字，再编写另一个程序将这些数字读取回内存。第一个程序将使用`json.dumps()`来存储这组数字，第二个程序将使用`json.loads()`。
- en: 'The `json.dumps()` function takes one argument: a piece of data that should
    be converted to the JSON format. The function returns a string, which we can then
    write to a data file:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`json.dumps()`函数接受一个参数：一个应该转换为JSON格式的数据。该函数返回一个字符串，我们可以将其写入数据文件：'
- en: '**number_writer.py**'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**number_writer.py**'
- en: '[PRE41]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We first import the `json` module, and then create a list of numbers to work
    with. Then we choose a filename in which to store the list of numbers ❶. It’s
    customary to use the file extension *.json* to indicate that the data in the file
    is stored in the JSON format. Next, we use the `json.dumps()` ❷ function to generate
    a string containing the JSON representation of the data we’re working with. Once
    we have this string, we write it to the file using the same `write_text()` method
    we used earlier.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入`json`模块，然后创建一个数字列表来处理。接着我们选择一个文件名来存储数字列表❶。通常使用文件扩展名*.json*来表示文件中的数据采用JSON格式。然后，我们使用`json.dumps()`❷函数生成一个包含数据JSON表示形式的字符串。得到这个字符串后，我们使用之前使用的`write_text()`方法将其写入文件。
- en: 'This program has no output, but let’s open the file *numbers.json* and look
    at it. The data is stored in a format that looks just like Python:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序没有输出，但让我们打开文件*numbers.json*并查看它。数据以类似Python的格式存储：
- en: '[PRE42]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now we’ll write a separate program that uses `json.loads()` to read the list
    back into memory:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将编写一个单独的程序，使用`json.loads()`将列表读回内存：
- en: '**number_reader.py**'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**number_reader.py**'
- en: '[PRE43]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We make sure to read from the same file we wrote to ❶. Since the data file
    is just a text file with specific formatting, we can read it with the `read_text()`
    method ❷. We then pass the contents of the file to `json.loads()` ❸. This function
    takes in a JSON-formatted string and returns a Python object (in this case, a
    list), which we assign to `numbers`. Finally, we print the recovered list of numbers
    and see that it’s the same list created in *number_writer.py*:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确保从我们写入的同一个文件中读取❶。由于数据文件只是一个具有特定格式的文本文件，我们可以使用`read_text()`方法读取它❷。然后我们将文件内容传递给`json.loads()`❸。该函数接收一个JSON格式的字符串并返回一个Python对象（在此情况下是一个列表），我们将其赋值给`numbers`。最后，我们打印恢复的数字列表，看到它与*number_writer.py*中创建的列表相同：
- en: '[PRE44]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This is a simple way to share data between two programs.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在两个程序之间共享数据的一种简单方法。
- en: Saving and Reading User-Generated Data
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保存和读取用户生成的数据
- en: Saving data with `json` is useful when you’re working with user-generated data,
    because if you don’t store your user’s information somehow, you’ll lose it when
    the program stops running. Let’s look at an example where we prompt the user for
    their name the first time they run a program and then remember their name when
    they run the program again.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`json`保存数据在处理用户生成的数据时非常有用，因为如果你不以某种方式存储用户的信息，当程序停止运行时，你将丢失这些数据。让我们看一个例子，我们首次运行程序时提示用户输入名字，然后下次运行时记住他们的名字。
- en: 'Let’s start by storing the user’s name:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从存储用户的名字开始：
- en: '**remember_me.py**'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**remember_me.py**'
- en: '[PRE45]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We first prompt for a username to store ❶. Next, we write the data we just
    collected to a file called *username.json* ❷. Then we print a message informing
    the user that we’ve stored their information ❸:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先提示用户输入用户名以进行存储❶。接下来，我们将刚刚收集的数据写入一个名为*username.json*的文件❷。然后我们打印一条消息，告知用户我们已经存储了他们的信息❸：
- en: '[PRE46]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now let’s write a new program that greets a user whose name has already been
    stored:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们编写一个新程序，向已存储姓名的用户打招呼：
- en: '**greet_user.py**'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**greet_user.py**'
- en: '[PRE47]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We read the contents of the data file ❶ and then use `json.loads()` to assign
    the recovered data to the variable `username` ❷. Since we’ve recovered the username,
    we can welcome the user back with a personalized greeting:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们读取数据文件的内容❶，然后使用`json.loads()`将恢复的数据赋值给变量`username`❷。由于我们已经恢复了用户名，我们可以用个性化的问候语欢迎用户回来：
- en: '[PRE48]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We need to combine these two programs into one file. When someone runs *remember_me.py*,
    we want to retrieve their username from memory if possible; if not, we’ll prompt
    for a username and store it in *username.json* for next time. We could write a
    `try`-`except` block here to respond appropriately if *username.json* doesn’t
    exist, but instead we’ll use a handy method from the `pathlib` module:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将这两个程序合并为一个文件。当有人运行*remember_me.py*时，我们希望尽可能从内存中检索他们的用户名；如果没有找到，我们将提示输入用户名并将其存储在*username.json*中，以便下次使用。我们可以在这里写一个`try`-`except`块来处理*username.json*不存在的情况，但我们将使用`pathlib`模块中的一个方便方法：
- en: '**remember_me.py**'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '**remember_me.py**'
- en: '[PRE49]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: There are many helpful methods you can use with `Path` objects. The `exists()`
    method returns `True` if a file or folder exists and `False` if it doesn’t. Here
    we use `path.exists()` to find out if a username has already been stored ❶. If
    *username.json* exists, we load the username and print a personalized greeting
    to the user.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`Path`对象的许多有用方法。`exists()`方法会在文件或文件夹存在时返回`True`，如果不存在则返回`False`。这里我们使用`path.exists()`来检查用户名是否已经存储❶。如果*username.json*存在，我们加载用户名并打印个性化的问候语。
- en: If the file *username.json* doesn’t exist ❷, we prompt for a username and store
    the value that the user enters. We also print the familiar message that we’ll
    remember them when they come back.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件*username.json*不存在❷，我们会提示用户输入用户名并存储用户输入的值。我们还会打印一个熟悉的消息，告诉用户我们会记住他们，当他们回来时。
- en: 'Whichever block executes, the result is a username and an appropriate greeting.
    If this is the first time the program runs, this is the output:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 无论执行哪个代码块，结果都会是一个用户名和相应的问候语。如果这是程序第一次运行，输出将是：
- en: '[PRE50]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Otherwise:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 否则：
- en: '[PRE51]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This is the output you see if the program was already run at least once. Even
    though the data in this section is just a single string, the program would work
    just as well with any data that can be converted to a JSON-formatted string.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你在程序至少运行过一次后看到的输出。即使这一部分的数据只是一个字符串，程序也同样适用于任何可以转换为JSON格式字符串的数据。
- en: Refactoring
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重构
- en: Often, you’ll come to a point where your code will work, but you’ll recognize
    that you could improve the code by breaking it up into a series of functions that
    have specific jobs. This process is called *refactoring*. Refactoring makes your
    code cleaner, easier to understand, and easier to extend.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你会遇到一种情况，代码可以正常运行，但你会意识到可以通过将代码拆分成一系列具有特定功能的函数来改进代码。这个过程叫做*重构*。重构使你的代码更简洁、更易于理解，也更容易扩展。
- en: 'We can refactor *remember_me.py* by moving the bulk of its logic into one or
    more functions. The focus of *remember_me.py* is on greeting the user, so let’s
    move all of our existing code into a function called `greet_user()`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将大部分逻辑移动到一个或多个函数中来重构*remember_me.py*。*remember_me.py*的重点是问候用户，所以让我们把现有的所有代码移到一个叫做`greet_user()`的函数中：
- en: '**remember_me.py**'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**remember_me.py**'
- en: '[PRE52]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Because we’re using a function now, we rewrite the comments as a docstring that
    reflects how the program currently works ❶. This file is a little cleaner, but
    the function `greet_user()` is doing more than just greeting the user—it’s also
    retrieving a stored username if one exists and prompting for a new username if
    one doesn’t.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们现在使用了函数，所以我们将注释重写为反映程序当前工作方式的文档字符串❶。这个文件变得稍微更简洁了一些，但函数`greet_user()`做的不仅仅是问候用户——它还会检索已存储的用户名（如果存在），如果没有，则会提示输入新用户名。
- en: 'Let’s refactor `greet_user()` so it’s not doing so many different tasks. We’ll
    start by moving the code for retrieving a stored username to a separate function:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重构`greet_user()`，使它不再做这么多不同的任务。我们将首先把检索已存储用户名的代码移到一个单独的函数中：
- en: '[PRE53]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The new function `get_stored_username()` ❶ has a clear purpose, as stated in
    the docstring. This function retrieves a stored username and returns the username
    if it finds one. If the path that’s passed to `get_stored_username()` doesn’t
    exist, the function returns `None` ❷. This is good practice: a function should
    either return the value you’re expecting, or it should return `None`. This allows
    us to perform a simple test with the return value of the function. We print a
    welcome back message to the user if the attempt to retrieve a username is successful
    ❸, and if it isn’t, we prompt for a new username.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 新函数`get_stored_username()`❶有一个明确的目的，正如文档字符串所述。这个函数检索存储的用户名，并返回用户名（如果找到）。如果传递给`get_stored_username()`的路径不存在，函数返回`None`❷。这是一个好习惯：函数应该返回你期望的值，或者返回`None`。这使我们可以用函数的返回值进行简单的测试。如果成功检索到用户名，我们会向用户打印欢迎回来的消息❸；如果失败，我们会提示输入新用户名。
- en: 'We should factor one more block of code out of `greet_user()`. If the username
    doesn’t exist, we should move the code that prompts for a new username to a function
    dedicated to that purpose:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该再从`greet_user()`中提取出一个代码块。如果用户名不存在，我们应该把提示输入新用户名的代码移到一个专门的函数中：
- en: '[PRE54]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Each function in this final version of *remember_me.py* has a single, clear
    purpose. We call `greet_user()`, and that function prints an appropriate message:
    it either welcomes back an existing user or greets a new user. It does this by
    calling `get_stored_username()` ❶, which is responsible only for retrieving a
    stored username if one exists. Finally, if necessary, `greet_user()` calls `get_new_username()`❷,
    which is responsible only for getting a new username and storing it. This compartmentalization
    of work is an essential part of writing clear code that will be easy to maintain
    and extend.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在最终版本的*remember_me.py*中，每个函数都有一个单一且明确的目的。我们调用`greet_user()`，该函数会打印出合适的消息：它要么欢迎回来的老用户，要么向新用户问好。它通过调用`get_stored_username()`❶来完成这一任务，`get_stored_username()`只负责获取已存储的用户名（如果存在）。最后，如果有必要，`greet_user()`会调用`get_new_username()`❷，它仅负责获取新的用户名并将其存储。这样的工作分工是编写清晰代码的重要组成部分，能够使代码易于维护和扩展。
- en: Summary
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how to work with files. You learned to read the
    entire contents of a file, and then work through the contents one line at a time
    if you need to. You learned to write as much text as you want to a file. You also
    read about exceptions and how to handle the exceptions you’re likely to see in
    your programs. Finally, you learned how to store Python data structures so you
    can save information your users provide, preventing them from having to start
    over each time they run a program.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学会了如何处理文件。你学会了读取文件的全部内容，并且如果需要的话，可以逐行处理文件内容。你学会了向文件中写入任意文本。你还了解了异常处理以及如何处理程序中可能遇到的异常。最后，你学会了如何存储Python数据结构，以便保存用户提供的信息，避免用户每次运行程序时都要重新开始。
- en: In Chapter 11, you’ll learn efficient ways to test your code. This will help
    you trust that the code you develop is correct, and it will help you identify
    bugs that are introduced as you continue to build on the programs you’ve written.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在第11章，你将学习高效的代码测试方法。这将帮助你确保所编写的代码是正确的，并且帮助你识别在继续构建程序时可能引入的错误。
