- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: How Complexity Harms Your Productivity
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂性如何损害你的生产力
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: In this chapter, we’re going to have a comprehensive look at the important and
    highly underexplored topic of complexity. What exactly is *complexity*? Where
    does it occur? How does it damage your productivity? Complexity is the enemy of
    the lean and efficient organization and individual, so it’s worth taking a close
    look at all areas where we find complexity and what forms it takes. This chapter
    focuses on the problem—complexity—and the remaining chapters will explore effective
    methods to attack it by redirecting the released resources previously occupied
    by complexity.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将全面探讨一个重要且高度未被充分研究的话题——复杂性。究竟什么是*复杂性*？它在哪里发生？它如何损害你的生产力？复杂性是精益高效的组织和个人的敌人，因此值得仔细观察我们在哪些领域发现复杂性以及它表现出哪些形式。本章专注于问题——复杂性，接下来的章节将探讨通过重新分配之前被复杂性占用的资源来有效解决这一问题的方法。
- en: 'Let’s start with a quick overview of where complexity may be daunting to a
    new coder:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先快速概览一下新手程序员可能会觉得复杂的地方：
- en: Choosing a programming language
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择一种编程语言
- en: Choosing a coding project to work on—from thousands of open source projects
    and myriads of problems
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择一个编程项目来进行——从成千上万的开源项目和无数的问题中选择
- en: Deciding which libraries to use (scikit-learn versus NumPy versus TensorFlow)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 决定使用哪些库（scikit-learn 与 NumPy 与 TensorFlow）
- en: Deciding which emerging technologies to invest time in—Alexa apps, smartphone
    apps, browser-based web apps, integrated Facebook or WeChat apps, virtual reality
    apps
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 决定将时间投入哪些新兴技术——Alexa 应用、智能手机应用、基于浏览器的 web 应用、集成的 Facebook 或微信应用、虚拟现实应用
- en: Choosing a coding editor such as PyCharm, Integrated Development and Learning
    Environment (IDLE), and Atom
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择一个编码编辑器，如 PyCharm、集成开发与学习环境（IDLE）和 Atom
- en: Given the great confusion caused by these sources of complexity, it’s no surprise
    that *“How do I start?”* is one of the most common questions from programming
    beginners.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于这些复杂性来源所带来的巨大困惑，*“我该从哪里开始？”* 成为编程初学者最常见的问题之一，也就不足为奇了。
- en: The best way to start is *not* by choosing a programming book and reading about
    all the syntactical features of the programming language. Many ambitious students
    buy programming books as an incentive and then add the learning task to their
    to-do lists—if they’ve spent money on the book, they better read it or the investment
    will be lost. But as with so many other tasks on to-do lists, *reading a programming
    book* is seldomly completed.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的开始方式是*不要*通过选择一本编程书并阅读编程语言的所有语法特性来开始。许多有抱负的学生购买编程书籍作为激励，然后把学习任务加入他们的待办事项列表——如果他们已经花钱买了书，他们最好去读，否则投资就会丧失。但和许多待办事项列表中的任务一样，*阅读编程书籍*很少能完成。
- en: 'The best way to start is to choose a practical code project—a simple one if
    you’re a beginner—and push it to completion. Don’t read coding books or random
    tutorials on the web before completing a full project. Don’t scroll through endless
    feeds on StackOverflow. Just set up the project and start coding with the limited
    skills you have and your common sense. A student of mine wanted to create a financial
    dashboard application checking the historic returns of different asset allocations
    to answer questions such as “What was the maximum down year of a portfolio consisting
    of 50 percent stocks and 50 percent government bonds?” At first she didn’t know
    how to approach this project but soon found out about a framework called Python
    Dash that deals with building data-based web apps. She learned how to set up a
    server and studied just the HyperText Markup Language (HTML) and Cascading Style
    Sheets (CSS) she needed to move forward, and now her app is live and has already
    helped thousands of people find the right asset allocation. But, more importantly,
    she joined the team of developers that created Python Dash and is even writing
    a book about it with No Starch Press. She did all of this in one year—and you
    can, too. It’s okay if you don’t understand what you’re doing; you will gradually
    increase your understanding. Read articles only to make progress on the project
    in front of you. The process of finishing your first project introduces a number
    of highly relevant problems, including:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的开始方式是选择一个实用的编码项目——如果你是初学者，可以选择一个简单的项目——并推动它完成。在完成一个完整项目之前，不要去阅读编码书籍或互联网上的随机教程，也不要在
    StackOverflow 上翻阅无休止的帖子。只需设置好项目并利用你现有的有限技能和常识开始编码。我的一位学生想要创建一个财务仪表盘应用，用于查看不同资产配置的历史回报，以回答像“由
    50% 股票和 50% 政府债券组成的投资组合在某一年最大的亏损是多少？”这样的提问。起初，她不知道如何着手这个项目，但很快发现了一个名为 Python Dash
    的框架，这个框架专注于构建基于数据的 web 应用。她学习了如何设置服务器，并且只研究了她所需的超文本标记语言（HTML）和层叠样式表（CSS），最终她的应用已经上线，并且帮助了成千上万的人找到合适的资产配置。但更重要的是，她加入了创建
    Python Dash 的开发团队，甚至与 No Starch Press 一起写了一本关于它的书。她在一年内完成了这一切——你也可以做到。如果你不理解自己在做什么也没关系；你会逐渐增加自己的理解。只要通过阅读文章推动当前项目的进展即可。完成第一个项目的过程会引入一系列非常相关的问题，包括：
- en: Which code editor should you use?
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该使用哪个代码编辑器？
- en: How do you install your project’s programming language?
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何安装你项目的编程语言？
- en: How do you read input from a file?
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何从文件中读取输入？
- en: How do you store the input in your program for later use?
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在程序中存储输入以供后续使用？
- en: How do you manipulate the input to obtain the desired output?
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何处理输入以获得期望的输出？
- en: By answering these questions, you’ll gradually build a well-rounded skill set.
    Over time, you’ll be able to answer these questions better and more easily. You’ll
    be able to solve much bigger problems, and you’ll build up an internal database
    of programming patterns and conceptual insights. Even advanced coders learn and
    improve with this same process—only the coding projects have become much larger
    and more complicated.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通过回答这些问题，你将逐步建立起一个全面的技能组合。随着时间的推移，你将能够更好、更轻松地回答这些问题。你将能够解决更大、更复杂的问题，并积累起一个内部的编程模式和概念洞察数据库。即便是高级程序员，也通过相同的过程进行学习和提升——只不过编码项目变得更大、更复杂。
- en: With this project-based learning approach, you’ll likely find that you struggle
    with complexity in areas such as finding bugs in ever-growing codebases, understanding
    code components and how they interact, choosing the right feature to be implemented
    next, and understanding the mathematical and conceptual basics of the code.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 采用这种基于项目的学习方法，你很可能会发现自己在诸如寻找日益增长的代码库中的 bug、理解代码组件及其交互、选择下一个要实现的功能以及理解代码的数学和概念基础等方面与复杂性作斗争。
- en: 'Complexity is everywhere, at every stage of a project. The hidden cost of this
    complexity is often that brand-new coders throw in the towel and their projects
    never see the light of day. So, the question arises: How do I solve the problem
    of complexity?'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂性无处不在，贯穿项目的每个阶段。这种复杂性的隐藏成本通常是，刚入门的程序员会放弃，他们的项目最终无法实现。所以，问题就来了：我该如何解决复杂性问题？
- en: 'The answer is straightforward: *simplicity*. Seek simplicity and focus in every
    stage of the coding cycle. If you take only one thing away from this book, let
    it be this: take a radically minimalistic position in every area you encounter
    in programming. Throughout the book, we’ll discuss all of the following methods:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 答案很简单：*简单性*。在编码的每个阶段寻求简单性和专注。如果你从这本书中只记住一件事，那就是：在你遇到的编程领域中采取极简的立场。全书将讨论以下所有方法：
- en: Declutter your day, do fewer tasks, and focus your efforts on the tasks that
    matter. For example, instead of starting 10 new interesting code projects in parallel,
    carefully select one and focus all your efforts on finishing this one project.
    In Chapter 2, you’ll learn about the 80/20 principle in programming in greater
    detail.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清理你的日程，做更少的任务，把精力集中在重要的任务上。例如，与其平行启动10个有趣的新代码项目，不如仔细挑选一个并将所有精力集中在完成这个项目上。在第2章，你将更详细地了解编程中的80/20原则。
- en: Given one software project, strip away all unnecessary features and focus on
    the minimum viable product (see Chapter 3), ship it, and validate your hypotheses
    quickly and efficiently.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定一个软件项目，去除所有不必要的功能，专注于最小可行产品（见第3章），发布它，并快速高效地验证你的假设。
- en: Write simple and concise code wherever you can. In Chapter 4, you’ll learn many
    practical tips for how to accomplish this.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在可能的地方编写简单而简洁的代码。在第4章，你将学到如何实现这一目标的许多实用技巧。
- en: Reduce time and effort spent on premature optimization—optimizing code without
    need is one of the major reasons for unnecessary complexity (see Chapter 5).
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少在过早优化上花费的时间和精力——没有必要的代码优化是导致不必要复杂性的主要原因之一（见第5章）。
- en: Reduce switching time by blocking large chunks of time for programming to obtain
    a state of *flow*—a term from psychological research to describe a focused state
    of mind that increases your attention, focus, and productivity. Chapter 6 is all
    about reaching a state of flow.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将大量时间块集中用于编程，减少切换时间，以达到*心流*状态——这是心理学研究中的术语，用来描述一种集中的心理状态，它能够提高你的注意力、专注力和生产力。第6章将全面讲解如何达到心流状态。
- en: Apply the Unix philosophy of focusing code functions on one objective only (“Do
    One Thing Well”). See Chapter 7 for a detailed guide to the Unix philosophy with
    Python code examples.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运用Unix哲学，专注于代码功能的单一目标（“做好一件事”）。有关Unix哲学的详细指南，包含Python代码示例，请见第7章。
- en: Apply simplicity in design to create beautiful, clean, and focused user interfaces
    that are easy to use and intuitive (see Chapter 8).
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在设计中应用简化原则，创造美观、简洁、专注且易于使用的直观用户界面（见第8章）。
- en: Apply focusing techniques when planning your career, your next project, your
    day, or your area of expertise (see Chapter 9).
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在规划职业、下一个项目、一天的工作或你的专业领域时，应用聚焦技巧（见第9章）。
- en: Let’s dive deeper into the concept of complexity to develop an understanding
    of one of the great enemies of your coding productivity.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地探讨复杂性这一概念，理解它是你编码生产力的巨大敌人之一。
- en: What Is Complexity?
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是复杂性？
- en: In different fields, the term *complexity* comes with different meanings. Sometimes,
    it’s strictly defined, such as the *computational complexity* of a computer program
    that provides a means to analyze a given code function for varying inputs. Other
    times, it’s loosely defined as the amount or structure of interactions between
    system components. In this book, we’re going to use it more generically.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同的领域，*复杂性*这个术语有不同的含义。有时它被严格定义，比如计算机程序的*计算复杂度*，这为分析给定代码功能在不同输入下的表现提供了一种方法。其他时候，它是宽泛定义的，指的是系统组件之间的交互量或结构。在本书中，我们将更广泛地使用它。
- en: 'We’ll define *complexity* as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将*复杂性*定义如下：
- en: Complexity A whole, made up of parts, that is difficult to analyze, understand,
    or explain.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复杂性是由多个部分组成的整体，难以分析、理解或解释。
- en: 'Complexity describes a whole system or entity. Because complexity makes the
    system difficult to explain, complexity causes struggle and confusion. Because
    real-world systems are messy, you’ll find complexity everywhere: the stock market,
    social trends, emerging political viewpoints, and big computer programs with hundreds
    of thousands of lines of code—such as the Windows operating system.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂性描述的是一个整体或实体。由于复杂性使得系统难以解释，它会引起挣扎和困惑。因为现实世界的系统很混乱，你会发现复杂性无处不在：股市、社会趋势、新兴的政治观点、以及拥有数十万行代码的大型计算机程序——例如Windows操作系统。
- en: 'If you’re a coder, you are especially prone to overwhelming complexity, such
    as from these different sources that we’ll cover in this chapter:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一个程序员，你尤其容易受到复杂性困扰，来自这些我们将在本章讨论的不同来源：
- en: Complexity in a project life cycle
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目生命周期中的复杂性
- en: Complexity in software and algorithmic theory
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 软件和算法理论中的复杂性
- en: Complexity in learning
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 学习中的复杂性
- en: Complexity in processes
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 流程中的复杂性
- en: Complexity in social networks
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 社交网络中的复杂性
- en: Complexity in your daily life
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你日常生活中的复杂性
- en: Complexity in a Project Life Cycle
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目生命周期中的复杂性
- en: 'Let’s dive into the different stages of the project life cycle: planning, defining,
    designing, building, testing, and deployment (see [Figure 1-1](#figure1-1)).'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨项目生命周期的不同阶段：规划、定义、设计、构建、测试和部署（见[图 1-1](#figure1-1)）。
- en: '![Life cycle graphic showing a circle of arrows pointing from planning to defining
    to designing to building to testing to deployment and back to planning. ](image_fi/502185c01/f01001.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![生命周期图示，展示一个从规划到定义、设计、构建、测试、部署再回到规划的箭头循环。](image_fi/502185c01/f01001.png)'
- en: 'Figure 1-1: The six conceptual phases of a software project based on the official
    Institute of Electrical and Electronics Engineers (IEEE) standard for software
    engineering'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-1：基于电气与电子工程师协会（IEEE）软件工程标准的软件项目六个概念性阶段
- en: Even if you’re working on a very small software project, you’re likely going
    through all six phases of the software development life cycle. Note that you may
    not necessarily go through each phase only once—in modern software development,
    a more iterative approach is generally preferred where each phase is revisited
    multiple times. Next, we’ll look at how complexity has a significant impact on
    each phase.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你正在处理一个非常小的软件项目，你也很可能经历软件开发生命周期的所有六个阶段。请注意，你不一定只能经历每个阶段一次——在现代软件开发中，更倾向于采用迭代方法，每个阶段会被反复
    revisited。接下来，我们将探讨复杂性如何对每个阶段产生重要影响。
- en: Planning
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 规划
- en: The first stage of the software development life cycle is the planning phase,
    sometimes known in engineering literature as *requirement analysis*. The purpose
    of this phase is to determine how the product will look. A successful planning
    phase leads to a strictly defined set of required features to deliver to the end
    user.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发生命周期的第一阶段是规划阶段，有时在工程学文献中被称为*需求分析*。这个阶段的目的是确定产品的外观。成功的规划阶段将导致一个严格定义的、需要交付给最终用户的特性集合。
- en: 'Whether you’re a single person working on your hobby project or you’re responsible
    for managing and orchestrating collaboration among multiple software development
    teams, you must figure out the optimal set of features of the software. A number
    of factors must be taken into consideration: the costs of building a feature,
    the risk of not being able to successfully implement the feature, the expected
    value for the end user, marketing and sales implications, maintainability, scalability,
    legal restrictions, and many more.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是一个人独自工作于你的爱好项目，还是负责管理和协调多个软件开发团队的协作，你都必须弄清楚软件的最优特性集合。需要考虑许多因素：构建一个特性的成本、无法成功实施该特性的风险、最终用户的预期价值、市场营销和销售的影响、可维护性、可扩展性、法律限制等等。
- en: This phase is crucial because it can save you from wasting massive amounts of
    energy later. Planning mistakes can lead to millions of dollars’ worth of wasted
    resources. On the other hand, careful planning can set the business up for great
    success in the years to follow. The planning phase is a time to apply your newly
    acquired skill of 80/20 thinking (see Chapter 2).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这个阶段至关重要，因为它可以帮助你避免以后浪费大量精力。规划上的错误可能导致数百万美元的资源浪费。另一方面，谨慎的规划可以为接下来的几年中业务的巨大成功奠定基础。规划阶段是应用你新获得的80/20思维技巧的时候（见第二章）。
- en: 'The planning phase is also difficult to do right because of the complexity
    involved. Several considerations add to the complexity: assessing risk properly
    in advance, figuring out the strategic direction of a company or an organization,
    guessing the customers’ responses, weighing the positive impact of different feature
    candidates, and determining the legal implications of a given software feature.
    Taken together, the sheer complexity of solving this multidimensional problem
    is killing us.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 规划阶段也是一个难以做到完美的阶段，因为涉及的复杂性。许多因素增加了复杂性：提前正确评估风险，弄清楚公司或组织的战略方向，猜测客户的反应，权衡不同功能候选项的积极影响，并确定某个软件功能的法律影响。综合来看，解决这个多维度问题的复杂性令我们不堪重负。
- en: Defining
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义
- en: The defining phase consists of translating the results from the planning phase
    into properly specified software requirements. In other words, it formalizes the
    output of the previous phase to gain approval or feedback from clients and end
    users who will later use the product.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 定义阶段包括将规划阶段的结果转化为恰当规范的软件需求。换句话说，它将上一阶段的输出正式化，以便获得客户和最终用户的批准或反馈，他们将在后续使用该产品。
- en: 'If you’ve spent a lot of time planning and figuring out the project requirements
    but fail in communicating them well, it’ll cause significant problems and difficulties
    later. A wrongly specified requirement that helps the project may be just as bad
    as a correctly formulated requirement that doesn’t. Effective communication and
    precise specification are crucial to avoid ambiguities and misunderstandings.
    In all human communication, getting your message across is a highly complex endeavor
    due to the “curse of knowledge” and other psychological biases that outweigh the
    relevance of personal experiences. If you try to deliver ideas (or requirements
    for that matter) out of your head and into another one’s head, be careful: complexity
    is out to get you!'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你花费了大量时间来规划和弄清楚项目需求，但却未能有效地传达这些需求，后续将会带来严重的问题和困难。一项错误表述的需求，尽管有助于项目，可能和一项正确表述的需求但并无帮助的情况一样糟糕。有效的沟通和精确的规范对于避免歧义和误解至关重要。在所有的人类沟通中，由于“知识诅咒”和其他心理偏见的影响，信息传递是一个极为复杂的任务，这些偏见往往压倒了个人经验的相关性。如果你试图将想法（或需求）从自己脑海中传递到他人脑海中，要小心：复杂性在等着你！
- en: Designing
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计
- en: The goal of the designing phase is to draft the architecture of the system,
    decide on the modules and components that deliver the defined functionality, and
    design the user interface—while keeping the requirements developed in the previous
    two phases in mind. The gold standard of the designing phase is to create a crystal-clear
    picture of how the final software product will look and how it’s built. This holds
    for all methods of software engineering. Agile approaches would just iterate over
    those phases more quickly.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 设计阶段的目标是草拟系统的架构，决定提供已定义功能的模块和组件，并设计用户界面——同时牢记之前两个阶段中开发的需求。设计阶段的黄金标准是创建一个清晰明确的图像，展示最终软件产品的外观以及其构建方式。这适用于所有软件工程方法。敏捷方法只会更快速地迭代这些阶段。
- en: But the devil lies in the detail! A great system designer must know about the
    pros and cons of a huge variety of software tools they may use to build the system.
    For example, some libraries may be easy for the programmer to use but slow in
    execution speed. Building custom libraries is harder for the programmers but may
    result in much higher speed and, consequently, improved usability of the final
    software product. The designing phase must fix these variables so that the benefit-to-cost
    ratio is maximized.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，细节决定成败！一位优秀的系统设计师必须了解他们可能用来构建系统的各种软件工具的优缺点。例如，一些库可能对程序员来说容易使用，但执行速度较慢。构建自定义库对程序员来说更为复杂，但可能带来更高的速度，从而提高最终软件产品的可用性。设计阶段必须解决这些变量，以便最大化收益与成本的比率。
- en: Building
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建
- en: The building phase is where many coders want to spend all their time. This is
    where the transformation from the architectural draft to the software product
    happens. Your ideas transform into tangible results.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 构建阶段是许多程序员希望投入所有时间的地方。这是从架构草图到软件产品的转变发生的地方。你的想法转化为具体的结果。
- en: Through proper preparation in the previous phases, a lot of complexity has already
    been eliminated. Ideally, the builders should know which features to implement
    from all the possible features, how the features look, and which tools to use
    to implement them. Yet, the building phase is always full of new and emerging
    problems. Unexpected things like bugs in external libraries, performance issues,
    corrupted data, and human mistakes can slow progress. Building a software product
    is a highly complicated endeavor. A small spelling mistake can undermine viability
    of the whole software product.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 通过前期阶段的适当准备，许多复杂性已经被排除。理想情况下，构建者应该知道要实现哪些功能，功能的外观如何，以及要使用哪些工具来实现它们。然而，构建阶段总是充满了新出现的问题。外部库中的错误、性能问题、数据损坏以及人为错误等意外情况可能会减缓进度。构建软件产品是一项极其复杂的工作。一个小小的拼写错误就可能破坏整个软件产品的可行性。
- en: Testing
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试
- en: Congratulations! You’ve implemented all requested features, and the program
    seems to work. You’re not done yet, though. You still must test the behavior of
    your software product for different user inputs and usage patterns. This phase
    is often the most important of all—so much so that many practitioners now advocate
    the use of *test-driven development* where you don’t even start to implement (in
    the building phase) without having written all tests. While you can argue against
    that point of view, it’s generally a good idea to spend time testing your product
    by creating test cases and checking if the software delivers the correct result
    for these test cases.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你！你已经实现了所有要求的功能，并且程序似乎正常工作。然而，你还没有完成。你仍然需要测试软件产品在不同用户输入和使用模式下的行为。这个阶段通常是最重要的——以至于许多实践者现在提倡使用*测试驱动开发*，即在实施（构建阶段）之前，必须先编写所有的测试。虽然你可以反对这种观点，但通常来说，花时间通过创建测试用例并检查软件是否为这些测试用例提供正确的结果，是个不错的主意。
- en: 'For example, say you’re implementing a self-driving car. You must write *unit
    tests* to check that each little function (a *unit*) in your code generates the
    desired output for a given input. Unit tests will usually uncover some faulty
    functions that behave strangely under certain (extreme) inputs. For example, consider
    the following Python function stub that calculates the average red, green, and
    blue (RGB) color value of an image, perhaps used to differentiate whether you’re
    traveling through a city or a forest:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你正在实现一辆自动驾驶汽车。你必须编写*单元测试*，检查代码中每个小功能（即*单元*）是否为给定输入生成预期的输出。单元测试通常能发现一些在特定（极端）输入下表现异常的错误函数。例如，考虑以下Python函数代码，它计算图像的平均红色、绿色和蓝色（RGB）值，也许可以用来区分你是穿越城市还是森林：
- en: '[PRE0]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For example, the following list of pixels will yield the average red, green,
    and blue values of 96.0, 64.0, and 11.0, respectively:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下像素列表将分别得出96.0、64.0和11.0的平均红、绿、蓝值：
- en: '[PRE1]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here’s the output:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出结果：
- en: '[PRE2]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Although the function seems simple enough, many things can go wrong in practice.
    What if the pixel list of tuples is corrupted and some (RGB) tuples have only
    two instead of three elements? What if one value is of a non-integer type? What
    if the output must be a tuple of integers to avoid the floating-point error that
    is inherent to all floating-point computations?
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个函数看起来足够简单，但在实际操作中，许多事情可能会出错。如果像素元组列表被损坏，其中一些（RGB）元组只有两个元素而不是三个怎么办？如果其中一个值是非整数类型呢？如果输出必须是整数元组，以避免所有浮点计算固有的浮点错误怎么办？
- en: A unit test can test for all of those conditions to make sure that the function
    works in isolation.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试可以测试所有这些条件，以确保函数在孤立情况下正常工作。
- en: 'Here are two simple unit tests, one that checks whether the function works
    for a border case with zeros as inputs and another that checks whether the function
    returns a tuple of integers:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是两个简单的单元测试，一个检查函数是否在输入为零的边界情况下正常工作，另一个检查函数是否返回整数元组：
- en: '[PRE3]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The result shows that the type check fails and the function doesn’t return
    the correct type, which should be tuple-of-integer values:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示类型检查失败，函数没有返回正确的类型，应该是一个整数元组：
- en: '[PRE4]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In a more realistic setting, testers would write hundreds of those unit tests
    to check the function against all types of inputs—and whether it generates the
    expected outputs. Only if the unit tests reveal that the function works properly
    can we move on to test higher-level functions of the application.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在更现实的环境中，测试人员需要编写数百个单元测试来检查函数对所有类型输入的响应——并验证它是否生成了预期的输出。只有当单元测试表明函数运行正常时，我们才能继续测试应用程序的更高级功能。
- en: In fact, even if all your unit tests successfully pass, you haven’t yet completed
    the testing phase. You must test the correct interaction of the units as they’re
    building a greater whole. You must design real-world tests, driving the car for
    thousands or even tens of thousands of miles to uncover unexpected behavior patterns
    under strange and unpredictable situations. What if your car drives on a small
    road without road signs? What if the car in front of you abruptly stops? What
    if multiple cars wait for each other at a crossroad? What if the driver suddenly
    steers into approaching traffic?
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，即使所有单元测试都成功通过，您仍然没有完成测试阶段。您必须测试各个单元如何正确地相互作用，共同构建一个更大的整体。您必须设计现实世界的测试，像驾驶汽车一样测试数千甚至数万辆英里，以揭示在陌生和不可预测的情况下出现的意外行为模式。假设您的汽车行驶在没有路标的小路上怎么办？如果前方的车突然停下怎么办？如果多辆车在十字路口互相等待怎么办？如果驾驶员突然转向迎面而来的车流怎么办？
- en: There are so many tests to consider; the complexity is so high that many people
    throw in the towel here. What looked good in theory, even after your first implementation,
    often fails in practice after applying different levels of software testing such
    as unit tests or real-world usage tests.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 需要考虑的测试非常多；复杂性极高，以至于许多人在这里放弃了。理论上看起来不错的东西，即使是首次实现后，往往在实践中也会失败，特别是在应用了不同级别的软件测试（如单元测试或现实世界使用测试）后。
- en: Deployment
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部署
- en: The software has now passed the rigorous testing phase. It’s time to deploy
    it! Deployment can take many forms. Apps may be published to marketplaces, packages
    may be published to repositories, and major (or minor) releases may be made public.
    In a more iterative and agile approach to software development, you revisit the
    deployment phase multiple times using *continuous deployment*. Depending on your
    concrete project, this phase requires you to launch the product, create marketing
    campaigns, talk to early users of the product, fix new bugs that will surely come
    to light after being exposed to users, orchestrate the deployment of the software
    on different operating systems, support and troubleshoot different kinds of problems,
    or maintain the codebase to adapt and improve over time. This phase can become
    quite messy, given the complexity and interdependency of the various design choices
    you made and implemented in previous phases. The subsequent chapters will suggest
    tactics to help you overcome the mess.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 该软件现在已经通过了严格的测试阶段。是时候部署它了！部署可以有多种形式。应用程序可能会发布到市场，软件包可能会发布到仓库，重大（或次要）版本可能会公开发布。在一种更迭代和敏捷的软件开发方法中，您需要多次回顾部署阶段，采用*持续部署*的方式。根据具体项目的不同，这一阶段可能需要您推出产品、创建营销活动、与早期用户沟通、修复在用户使用后必然暴露的新问题、协调软件在不同操作系统上的部署、支持和排除各种问题，或维护代码库以便随着时间的推移适应和改进。由于您在前几个阶段做出的各种设计选择及其相互依赖性，这个阶段可能会变得非常混乱。后续章节将提供一些策略，帮助您克服这些混乱。
- en: Complexity in Software and Algorithmic Theory
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 软件和算法理论中的复杂性
- en: There can be as much complexity *within* a piece of software as there is in
    the process that surrounds software development. Many metrics in software engineering
    measure the complexity of software in a formal way.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一段软件内部的复杂性可能与软件开发过程中所涉及的复杂性一样多。许多软件工程的度量标准会以正式的方式衡量软件的复杂性。
- en: First, we’ll look at *algorithmic complexity*, which is concerned with the resource
    requirements of different algorithms. Using algorithmic complexity, you can compare
    different algorithms that solve the same problem. For example, say you’ve implemented
    a game application with a high-score rating system. You want the players with
    the highest scores to appear at the top of the list and the players with the lowest
    scores to appear at the bottom. In other words, you need to *sort* the list. Thousands
    of algorithms exist for sorting a list, and sorting a list is computationally
    more demanding for 1,000,000 players than it is for 100 players. Some algorithms
    scale better with increasing size of the list input; others scale worse. While
    your app serves a few hundred users, it doesn’t really matter which algorithm
    you choose, but as your user base grows, the runtime complexity of the list grows
    superlinearly. Soon, the end users will have to wait longer and longer for the
    list to be sorted. They’ll start complaining, and you’ll need better algorithms!
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们来看看*算法复杂度*，它涉及不同算法的资源需求。通过算法复杂度，你可以比较解决同一问题的不同算法。例如，假设你实现了一个带有高分评级系统的游戏应用程序。你希望得分最高的玩家排在列表的顶部，得分最低的玩家排在底部。换句话说，你需要对列表进行*排序*。有成千上万的算法可以用来排序列表，且排序列表在
    1,000,000 名玩家时比在 100 名玩家时更具计算需求。有些算法随着列表输入的增大而表现更好，而有些则表现更差。当你的应用服务几百个用户时，选择哪个算法并不重要，但随着用户数量的增长，列表的运行时间复杂度会超线性增长。不久，最终用户将不得不等待越来越长的时间才能看到列表排序完成。他们会开始抱怨，而你需要更好的算法！
- en: '[Figure 1-2](#figure1-2) exemplifies the algorithmic complexity of two schematic
    algorithms. The x-axis shows the size of the list to be sorted. The y-axis shows
    the runtime of the algorithm (in time units). Algorithm 1 is much slower than
    Algorithm 2\. In fact, the inefficiency of Algorithm 1 becomes more apparent the
    more list elements must be sorted. Using Algorithm 1, your game app would become
    slower the more users are playing.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 1-2](#figure1-2) 举例说明了两种示意性算法的算法复杂度。x 轴显示要排序的列表大小。y 轴显示算法的运行时间（单位为时间）。算法
    1 比算法 2 要慢得多。事实上，算法 1 的低效性在需要排序更多列表元素时变得更加明显。使用算法 1，你的游戏应用随着玩家人数的增加而变得越来越慢。'
- en: '![Graph showing list size on the x-axis and runtime on the y-axis. The line
    shows a steady upward trend. ](image_fi/502185c01/f01002.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图表显示列表大小在 x 轴，运行时间在 y 轴。线条呈现稳定的上升趋势。](image_fi/502185c01/f01002.png)'
- en: 'Figure 1-2: Algorithmic complexity of two different sorting algorithms'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-2：两种不同排序算法的算法复杂度
- en: 'Let’s see whether this holds for real Python sorting routines. [Figure 1-3](#figure1-3)
    compares three popular sorting algorithms: bubble sort, Quicksort, and Timsort.
    Bubble sort has the highest algorithmic complexity. Quicksort and Timsort have
    the same asymptotical algorithmic complexity. But the Timsort algorithm is still
    much faster—that’s why it’s used as Python’s default sorting routine. The runtime
    of the bubble sort algorithm explodes with a growing list size.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这是否适用于真实的 Python 排序算法。[图 1-3](#figure1-3) 比较了三种流行的排序算法：冒泡排序、快速排序和 Timsort。冒泡排序的算法复杂度最高。快速排序和
    Timsort 的渐进算法复杂度相同。但 Timsort 算法仍然要快得多——这就是为什么它被用作 Python 默认的排序算法。随着列表大小的增长，冒泡排序的运行时间爆炸性增加。
- en: 'In [Figure 1-4](#figure1-4), we repeat this experiment but only for Quicksort
    and Timsort. Again, there’s a drastic difference in algorithmic complexity: Timsort
    scales better and is faster for the growing list size. Now you see why Python’s
    built-in sorting algorithm hasn’t changed for such a long time!'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 1-4](#figure1-4)中，我们重复了这个实验，但只比较了快速排序和 Timsort。再次，我们看到算法复杂度的显著差异：Timsort
    更适应规模增长，并且在增加的列表大小下更快。现在你明白为什么 Python 的内建排序算法这么长时间没有改变了！
- en: '![Graph showing list size (number of elements) on the x-axis and runtime in
    seconds on the y-axis. Three lines represent bubble sort, quicksort, and Timsort.
    The lines for quicksort and Timsort are flat along the 0-second point on the y-axis.
    The line for Timsort is a steady, slightly curved incline between the x- and y-axes.](image_fi/502185c01/f01003.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图表显示列表大小（元素数量）在 x 轴，运行时间（秒）在 y 轴。三条线分别代表冒泡排序、快速排序和 Timsort。快速排序和 Timsort
    的线条在 y 轴的 0 秒点附近平稳。Timsort 的线条是一个稳定的、稍微弯曲的上升趋势。](image_fi/502185c01/f01003.png)'
- en: 'Figure 1-3: Algorithmic complexity of bubble sort, Quicksort, and Timsort'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-3：冒泡排序、快速排序和 Timsort 的算法复杂度
- en: '![Graph showing list size (number of elements) on the x-axis and runtime in
    seconds on the y-axis. two lines represent Quicksort and Timsort. The line for
    quicksort raises slightly from 0.0 seconds to about 0.05 seconds on the y-axis
    as it moves along the x-axis. The line for Timsort is a jagged but fairly even
    incline between the x- and y-axes.](image_fi/502185c01/f01004.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图表显示了列表大小（元素数量）在横轴上，运行时间（秒）在纵轴上。两条线分别代表快速排序和 TimSort。快速排序的曲线从 0.0 秒略微上升至约
    0.05 秒，随着横轴的移动。TimSort 的曲线在横纵轴之间呈锯齿状但相当平稳的上升。](image_fi/502185c01/f01004.png)'
- en: 'Figure 1-4: Algorithmic complexity of Quicksort and Timsort'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-4：快速排序和 TimSort 的算法复杂度
- en: '[Listing 1-1](#listing1-1) shows the code in Python in case you want to reproduce
    the experiment. I’d recommend you choose a smaller value for `n` because the code
    runs a long time on my machine before terminating.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 1-1](#listing1-1)显示了 Python 代码，如果你想重现实验，可以参考这个代码。我建议你选择一个较小的`n`值，因为代码在我的机器上运行较长时间才会终止。'
- en: '[PRE5]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 1-1: Measuring elapsed runtime for three popular sorting routines'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1-1：测量三种流行排序算法的运行时间
- en: Algorithmic complexity is a thoroughly researched field. In my opinion, the
    improved algorithms produced from this research are among the most valuable technological
    assets of humanity, allowing us to solve the same problems with fewer resources,
    over and over. We truly stand on the shoulders of giants.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 算法复杂度是一个经过深入研究的领域。在我看来，从这些研究中产生的改进算法是人类最有价值的技术资产之一，它们让我们能够用更少的资源不断地解决相同的问题。我们确实站在巨人的肩膀上。
- en: In addition to algorithmic complexity, we can measure the complexity of code
    with *cyclomatic complexity*. This metric, developed by Thomas McCabe in 1976,
    describes the number of *linearly independent paths* through your code, or the
    number of paths that have at least one edge that’s not in another path. For example,
    code with an `if` statement would result in two independent paths through your
    code, so it would have a higher cyclomatic complexity than flat code without any
    branching like that in an `if` statement. [Figure 1-5](#figure1-5) shows the cyclomatic
    complexity of two Python programs that process user input and respond accordingly.
    The first program contains only one conditional branch, which could be considered
    a fork in the road. Either branch could be taken, but not both. Thus, the cyclomatic
    complexity is two because there are two linearly independent paths. The second
    program contains two conditional branches leading to a total of three linearly
    independent paths and a cyclomatic complexity of three. Each additional `if` statement
    increases cyclomatic complexity.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 除了算法复杂度之外，我们还可以通过*圈复杂度*来衡量代码的复杂性。这个度量标准由托马斯·麦凯布（Thomas McCabe）于 1976 年提出，描述了代码中*线性独立路径*的数量，或者说是具有至少一条边不属于其他路径的路径数。例如，包含`if`语句的代码将导致通过代码的两条独立路径，因此它的圈复杂度要高于没有任何分支的平坦代码。
    [图 1-5](#figure1-5)展示了两个处理用户输入并作出响应的 Python 程序的圈复杂度。第一个程序只包含一个条件分支，可以看作是道路上的一个分叉。可以选择其中一个分支，但不能同时选择两个分支。因此，圈复杂度为
    2，因为有两条线性独立的路径。第二个程序包含两个条件分支，导致总共三条线性独立的路径，圈复杂度为 3。每增加一个`if`语句，圈复杂度就会增加。
- en: '![Left side of figure shows a diagram of cyclomatic complexity equaling 2\.
    A start node points to a second node containing code with a condition. Two arrows
    exit this node: path 1 points to an end node, and path 2 points to second node
    containing a print statement.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '![图左侧显示了圈复杂度为 2 的示意图。一个起始节点指向包含条件代码的第二个节点。两条箭头从该节点退出：路径 1 指向结束节点，路径 2 指向包含打印语句的第二个节点。](image_fi/502185c01/f01005.png)'
- en: Right side of figure shows a diagram of cyclomatic complexity equaling 3\. the
    start node points to node containing a condition. Two arrows exit this node, the
    first pointing to an end node, the second to a second conditional node. From this
    node, arrows point to two more print statement nodes. From each of these conditional
    nodes, an arrow points to the same end node.](image_fi/502185c01/f01005.png)
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图右侧显示了圈复杂度为 3 的示意图。起始节点指向包含条件的节点。两条箭头从该节点退出，第一条指向结束节点，第二条指向第二个条件节点。从该节点，箭头指向两个打印语句节点。从这些条件节点中的每个节点，箭头指向相同的结束节点。](image_fi/502185c01/f01005.png)
- en: 'Figure 1-5: Cyclomatic complexity of two Python programs'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-5：两个 Python 程序的圈复杂度
- en: The cyclomatic complexity is a solid proxy metric for the hard-to-measure *cognitive
    complexity*, that is, how difficult it is to understand a given codebase. However,
    cyclomatic complexity ignores the cognitive complexity that comes from, say, multiple
    nested `for` loops compared to a flat `for` loop. That’s why other measures such
    as `NPath` complexity improve upon cyclomatic complexity. To sum up, code complexity
    not only is an important subject of algorithmic theory but also is relevant for
    all practical matters when implementing code—and for writing easy-to-understand,
    readable, and robust code. Both algorithmic theory and programming complexity
    have been thoroughly researched for decades. A primary goal of these efforts is
    to *reduce computational and non-computational complexity* to mitigate its harmful
    effects on productivity and resource utilization of humans and machines alike.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 环状复杂度是一个很好的代理度量，用于衡量难以度量的*认知复杂性*，即理解给定代码库的难度。然而，环状复杂度忽略了诸如多个嵌套的`for`循环相比于平坦的`for`循环所带来的认知复杂性。这就是为什么其他度量如`NPath`复杂度能在环状复杂度的基础上进行改进。总的来说，代码复杂性不仅是算法理论中的一个重要主题，而且对于实现代码时的所有实际问题也具有相关性——并且对于编写易于理解、可读且稳健的代码至关重要。算法理论和编程复杂性已经被深入研究了几十年。这些努力的一个主要目标是*减少计算和非计算的复杂性*，以减轻其对人类和机器的生产力和资源利用的负面影响。
- en: Complexity in Learning
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习中的复杂性
- en: 'Facts don’t exist in a vacuum but are interrelated. Consider these two facts:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 事实不是孤立存在的，它们是相互关联的。考虑以下两个事实：
- en: Walt Disney was born in the year 1901.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 沃尔特·迪士尼出生于1901年。
- en: Louis Armstrong was born in the year 1901.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 路易斯·阿姆斯特朗出生于1901年。
- en: 'If you fed a program with these facts, it could answer questions like *“What’s
    the birth year of Walt Disney?”* as well as questions like *“Who was born in 1901?”*
    To answer the latter, the program must figure out the interdependency of different
    facts. It may model the information like this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你给程序输入这些事实，它能够回答诸如*“沃尔特·迪士尼的出生年份是什么？”*以及*“谁出生于1901年？”*之类的问题。为了回答后者，程序必须弄清楚不同事实之间的相互依赖关系。它可能会像这样建模信息：
- en: '[PRE6]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: To get all persons born in 1901, it could use the query `(*, born, 1901)` or
    any other way to relate the facts and group them together.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取所有出生于1901年的人，可以使用查询`(*, born, 1901)`，或者其他任何方式将事实关联并归类。
- en: In 2012, Google launched a new search feature showing info boxes on the search
    result page. These fact-based info boxes are populated using a data structure
    called the *knowledge graph*, which is a massive database of billions of interrelated
    facts to represent information in a network-like structure. Instead of storing
    objective and independent facts, this database maintains information about the
    interrelationship between different facts and other pieces of information. The
    Google search engine uses this knowledge graph to enrich its search results with
    higher-level knowledge and form answers autonomously.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 2012年，谷歌推出了一项新的搜索功能，在搜索结果页面上显示信息框。这些基于事实的信息框使用一种叫做*知识图谱*的数据结构来填充，知识图谱是一个庞大的包含数十亿个相互关联事实的数据库，用于以网络结构的方式表示信息。这个数据库不仅存储独立的客观事实，还维护不同事实及其他信息片段之间的相互关系。谷歌搜索引擎利用这个知识图谱，增强其搜索结果，自动生成答案。
- en: '[Figure 1-6](#figure1-6) shows an example. One node on the knowledge graph
    may be about the famous computer scientist Alan Turing. In the knowledge graph,
    the concept of `Alan Turing` is connected to different pieces of information such
    as his birth year (`1912`), his fields of study (`Computer science`, `Philosophy`,
    `Linguistics`), and his doctoral advisor (`Alonzo Church`). Each of those pieces
    of information is also connected to other facts (Alonzo Church’s field of study
    was `Computer science` as well), forming a massive network of interrelated facts.
    You can use this network to acquire new information and answer user queries programmatically.
    A query about the `"field of study of Turing''s doctoral advisor"` would result
    in the deducted answer `"Computer science"`. While this may sound trivial or obvious,
    the ability to generate new factoids like these has led to a breakthrough in information
    retrieval and search engine relevancy. You’d probably agree that it’s far more
    effective to learn by association than by remembering unrelated facts.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '[图1-6](#figure1-6)展示了一个示例。知识图谱中的一个节点可能是著名计算机科学家艾伦·图灵。在知识图谱中，`艾伦·图灵`这一概念与不同的信息片段相关联，例如他的出生年份（`1912`）、他的研究领域（`计算机科学`、`哲学`、`语言学`）以及他的博士导师（`阿隆佐·丘奇`）。这些信息片段还与其他事实相关联（阿隆佐·丘奇的研究领域也是`计算机科学`），从而形成一个巨大的互相关联的事实网络。你可以利用这个网络获取新信息并以编程方式回答用户查询。关于“`图灵博士导师的研究领域`”的查询将得出推导的答案“`计算机科学`”。虽然这听起来可能微不足道或显而易见，但生成这些新事实的能力促成了信息检索和搜索引擎相关性领域的突破。你可能会同意，通过联想学习远比记忆无关的事实更有效。'
- en: '![Knowledge graph representing connections between various topics. The seven
    topic nodes contain the following: 1912, linguistics, alan turing, computer science,
    alonzo church, philosophy, and human. Arrows point between them, connecting them
    via criteria such as “has field of study” and “has birth year.” ](image_fi/502185c01/f01006.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![知识图谱表示各个主题之间的联系。七个主题节点包括：1912、语言学、艾伦·图灵、计算机科学、阿隆佐·丘奇、哲学和人类。箭头指向它们，通过“具有研究领域”和“具有出生年份”等标准将它们连接起来。](image_fi/502185c01/f01006.png)'
- en: 'Figure 1-6: Knowledge graph representations'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-6：知识图谱表示
- en: 'Every field of study focuses only on a small part of the graph, each consisting
    of myriads of interrelated factoids. You can only really understand a field by
    taking into account related facts. To understand Alan Turing thoroughly, you must
    research his beliefs, his philosophies, and the characteristics of his doctorate
    advisor. To understand Church, you must investigate his relationship to Turing.
    Of course, there are too many related dependencies and facts in the graph to expect
    to understand everything. The complexity of these interrelations imposes the most
    fundamental boundaries around your ambitions to learn. Learning and complexity
    are two sides of the same coin: complexity is at the boundary of the knowledge
    you’ve already acquired. To learn more, you must first know how to control complexity.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 每个研究领域仅关注图谱中的一小部分，每部分包含无数相互关联的事实片段。你只能通过考虑相关事实来真正理解一个领域。要全面了解艾伦·图灵，你必须研究他的信仰、他的哲学观点以及他博士导师的特点。要了解丘奇，你必须调查他与图灵的关系。当然，图谱中有太多相关的依赖关系和事实，无法期望理解所有内容。这些相互关系的复杂性给你学习的雄心设立了最基本的边界。学习与复杂性是同一枚硬币的两面：复杂性位于你已获得知识的边界上。要学习更多，你必须首先学会如何控制复杂性。
- en: 'We’re getting kind of abstract here, so let’s have an example! Say you want
    to program a trading bot that buys and sells assets according to a set of sophisticated
    rules. You could learn lots of useful knowledge before starting your project:
    the basics of programming, distributed systems, databases, application programming
    interfaces (APIs), web services, machine learning, and data science and the related
    mathematics. You could learn about practical tools such as Python, NumPy, scikit-learn,
    ccxt, TensorFlow, and Flask. You could learn about trading strategies and stock
    market philosophies. Many people approach these problems with such a mindset and
    so never feel ready to start the project. The problem is that the more you learn,
    the less knowledgeable you feel. You’ll never attain sufficient mastery in all
    those fields to truly satisfy your desire to feel prepared. Overwhelmed by the
    complexity of the whole endeavor, you feel like quitting. Complexity is about
    to take its next victim: you.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有点抽象了，让我们来看一个例子！假设你想编程一个交易机器人，根据一套复杂的规则买卖资产。在开始项目之前，你可以学习许多有用的知识：编程基础、分布式系统、数据库、应用程序编程接口（API）、网络服务、机器学习、数据科学以及相关的数学知识。你可以学习一些实用工具，如
    Python、NumPy、scikit-learn、ccxt、TensorFlow 和 Flask。你可以学习交易策略和股市哲学。许多人以这样的心态来处理这些问题，所以永远觉得自己没有准备好开始项目。问题在于，学得越多，你觉得自己知道的越少。你永远无法在所有这些领域达到足够的精通，去真正满足自己准备充分的愿望。被整个任务的复杂性压得喘不过气来，你感到想放弃。复杂性即将成为下一个受害者：你。
- en: 'Fortunately, in the chapters of this book, you’ll learn skills to combat complexity:
    focus, simplification, scaling down, reduction, and minimalism. This book will
    teach you those skills.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，在本书的章节中，你将学到应对复杂性的技能：专注、简化、缩小、减少和极简主义。本书将教你这些技能。
- en: Complexity in Processes
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过程中的复杂性
- en: A *process* is a series of actions taken with the goal of realizing a defined
    result. The complexity of a process is calculated by its number of actions, participants,
    or branches. In general, the more actions (and participants), the more complicated
    a process becomes (see [Figure 1-7](#figure1-7)).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*过程*是为实现定义结果而采取的一系列行动。过程的复杂性由其行动、参与者或分支的数量来计算。通常，行动（和参与者）越多，过程就越复杂（参见[图 1-7](#figure1-7)）。'
- en: '![Top half of figure shows a simple process with the term “Code” pointing to
    “Test” pointing to “Launch.” Bottom half shows a slightly more complex process
    showing the term “Code” three times, all pointing to “feedback.” From “feedback”
    a rightward arrow labeled Yes points to Test and a downward arrow labeled No points
    back to Code. From Test a rightward arrow labeled Yes points to Launch and a downward
    arrow labeled No points back to the term Code.](image_fi/502185c01/f01007.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图的上半部分展示了一个简单的过程，"Code"指向"Test"，然后指向"Launch"。下半部分展示了一个稍微复杂的过程，"Code"出现三次，全部指向"feedback"。从"feedback"一个标为Yes的右箭头指向Test，一个标为No的向下箭头指向Code。从Test一个标为Yes的右箭头指向Launch，一个标为No的向下箭头指向Code。](image_fi/502185c01/f01007.png)'
- en: 'Figure 1-7: Two example processes: one-person development versus team development'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-7：两个示例过程：单人开发与团队开发
- en: 'Many software companies follow process models for different aspects of the
    business in an attempt to simplify processes. Here are some examples:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 许多软件公司会遵循不同方面的流程模型，试图简化过程。以下是一些示例：
- en: Software development may use agile development or scrum.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 软件开发可能会使用敏捷开发或Scrum。
- en: Customer relationship development may use customer relationship management (CRM)
    and sales scripts.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户关系发展可能会使用客户关系管理（CRM）和销售脚本。
- en: New product and business model creation may use the business model canvas.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新产品和商业模型的创建可能会使用商业模型画布。
- en: 'When organizations accumulate too many processes, complexity starts to clog
    the system. For example, before Uber entered the scene, the process of traveling
    from location A to B often involved many steps: finding telephone numbers of taxi
    organizations, comparing rates, preparing different payment options, and planning
    different modes of transportation. For many, Uber streamlined the process of traveling
    from A to B, integrating the whole planning process into an easy-to-use mobile
    application. The radical simplification performed by Uber made traveling more
    convenient for customers and reduced planning time and costs compared to the traditional
    taxi industry.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当组织积累了过多流程时，复杂性开始阻塞系统。例如，在优步出现之前，从A地点到B地点的过程通常涉及许多步骤：寻找出租车公司的电话号码、比较价格、准备不同的支付方式以及规划不同的交通方式。对于许多人来说，优步简化了从A到B的旅行过程，将整个规划过程整合到一个易于使用的移动应用程序中。优步的这种彻底简化让客户的出行更加便捷，并且相比传统的出租车行业，减少了规划时间和成本。
- en: In overly complex organizations, innovation finds fewer vehicles for change
    because it’s unable to break through the complexity. Resources are wasted as actions
    within processes become redundant. Trying to fix the suffering business, managers
    invest energy in establishing new processes and new actions, and the vicious cycle
    begins to destroy the business or organization.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在过于复杂的组织中，创新很难找到改变的途径，因为它无法突破复杂性。随着流程中的行动变得冗余，资源被浪费。为了修复这些困扰企业的痛苦，管理者将精力投入到建立新的流程和新行动中，恶性循环开始摧毁企业或组织。
- en: 'Complexity is the enemy of efficiency. The solution here is minimalism: to
    keep your processes efficient, you must radically weed out unnecessary steps and
    actions. It’s very unlikely that you’ll find your processes *oversimplified*.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂性是效率的敌人。这里的解决方案是极简主义：为了保持流程高效，必须彻底剔除不必要的步骤和行动。你很难发现你的流程会*过于简化*。
- en: Complexity in Your Daily Life, or Death by a Thousand Cuts
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你日常生活中的复杂性，或者说千刀万剐
- en: 'The purpose of this book is to increase the productivity of your programming
    efforts. Your progress can be interrupted by your own personal daily habits and
    routines. You must tackle the daily distractions and the constant competition
    for your valuable time. Computer science professor Cal Newport talks about this
    in his excellent book *Deep Work: Rules for Focused Success in a Distracted World*
    (Grand Central Publishing, 2016). He argues that there’s both an *increasing*
    demand for work that requires deep thinking—such as programming, researching,
    medicine, and writing—and a *decreasing* supply of time to do it due to the proliferation
    of communication devices and entertainment systems. If increasing demand meets
    decreasing supply, economic theory suggests that prices will rise. If you are
    capable of engaging in deep work, your economic value will increase. There has
    never been a better time for programmers who can engage in deep work.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书的目的是提高你编程工作的生产力。你的进步可能会被你个人的日常习惯和惯例所打断。你必须应对日常的干扰以及对你宝贵时间的持续竞争。计算机科学教授卡尔·纽波特在他那本出色的书《深度工作：在分心的世界中如何高效专注》（Grand
    Central Publishing，2016）中谈到过这一点。他认为，像编程、研究、医学和写作这样的工作——需要深度思考的工作——的需求正在*增加*，而由于通讯设备和娱乐系统的普及，可用于此类工作的时间在*减少*。如果需求增加而供给减少，经济学理论表明，价格会上涨。如果你能从事深度工作，那么你的经济价值就会增加。对于能够进行深度工作程序员来说，这绝对是一个前所未有的好时机。
- en: 'Now, the caveat: it has become almost impossible to engage in deep work if
    you don’t brutally enforce its prioritization. The external world is a nonstop
    distraction. Your colleagues pop into your office. Your smartphone demands your
    attention every 20 minutes. Your inbox pops up a new email dozens of times a day—each
    asking for a slice of your time.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，警告：如果你不严格执行优先级的管理，几乎不可能进行深度工作。外部世界是不断的干扰。你的同事会走进你的办公室。你的智能手机每20分钟就会吸引你的注意。你的收件箱每天都会弹出新的电子邮件——每封都在争夺你的一点时间。
- en: 'Deep work results in delayed gratification; it’s a satisfying feeling to have
    spent weeks of work on a computer program and find that it works. However, what
    you *desire* in most moments is instant gratification. Your subconscious often
    looks for ways to escape from the effort of deep work. Small rewards produce an
    easy boost of endorphins: checking your messages, engaging in meaningless chitchat,
    flicking through Netflix. The promise of delayed gratification becomes less and
    less attractive compared to the happy, colorful, and lively world of instant gratification.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 深度工作带来的是延迟的满足感；当你在一个计算机程序上花费数周时间，最终发现它有效时，那是一种令人满足的感觉。然而，在大多数时刻，你*渴望*的是即时的满足感。你的潜意识经常寻找逃避深度工作努力的方式。小小的奖励能轻松刺激内啡肽的分泌：查看消息、进行无意义的闲聊、翻看Netflix。与即时满足感的快乐、色彩斑斓、充满活力的世界相比，延迟满足感的承诺变得越来越不吸引人。
- en: 'Your efforts to stay focused and productive are prone to dying the death of
    a thousand cuts. Yes, you can turn off your smartphone once and use willpower
    to avoid checking your social media and switching on your favorite shows, but
    can you do it consistently day after day? Here, too, the answer lies in applying
    radical minimalism to the root of the problem: *uninstall* social media apps rather
    than trying to manage consumption, *reduce* the number of projects and tasks you’re
    involved in rather than trying to do more by working more, *go deep* into one
    programming language rather than spending lots of time switching between many.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你保持专注和高效的努力容易在无数小细节中消耗殆尽。是的，你可以关闭智能手机，依靠意志力避免查看社交媒体或打开你喜欢的节目，但你能每天都做到吗？答案也在于将极简主义应用于问题的根本：*卸载*社交媒体应用，而不是试图管理你的使用，*减少*你参与的项目和任务数量，而不是通过更多工作来试图做得更多，*深入*学习一门编程语言，而不是花费大量时间在多个语言间切换。
- en: Conclusion
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: By now, you should be thoroughly motivated by the need to overcome complexity.
    For further exploration of complexity and how we might overcome it, I do recommend
    reading *Deep Work* by Cal Newport.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你应该已经彻底被克服复杂性的需求所激励。为了进一步探讨复杂性以及我们如何克服它，我确实推荐阅读Cal Newport的《深度工作》。
- en: 'Complexity harms productivity and reduces focus. If you don’t take early control
    over complexity, it will quickly consume your most precious resource: time. At
    the end of your life, you won’t judge whether you’ve led a meaningful life based
    on how many emails you’ve replied to, hours of computer games you’ve played, or
    Sudoku puzzles you’ve solved. By learning how to handle complexity, by keeping
    it simple, you’ll be able to fight complexity and give yourself a powerful competitive
    advantage.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂性会损害生产力并降低专注力。如果你不及早控制复杂性，它将迅速吞噬你最宝贵的资源：时间。在你的一生结束时，你不会根据回复了多少电子邮件、玩了多少小时的电脑游戏或解了多少数独来评判你是否过上了有意义的生活。通过学习如何应对复杂性，保持简单，你将能够对抗复杂性，并为自己提供强大的竞争优势。
- en: 'In Chapter 2, you’ll learn about the power of the 80/20 principle: focus on
    the vital few and ignore the trivial many.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二章中，你将了解80/20原则的力量：专注于重要的少数，忽略琐碎的多数。
