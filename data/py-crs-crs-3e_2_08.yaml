- en: '16'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '16'
- en: Downloading Data
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 下载数据
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: In this chapter, you’ll download datasets from online sources and create working
    visualizations of that data. You can find an incredible variety of data online,
    much of which hasn’t been examined thoroughly. The ability to analyze this data
    allows you to discover patterns and connections that no one else has found.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将从在线来源下载数据集并创建该数据的可视化效果。你可以在线找到各种各样的数据，其中许多数据尚未得到彻底研究。能够分析这些数据将帮助你发现其他人尚未发现的模式和联系。
- en: 'We’ll access and visualize data stored in two common data formats: CSV and
    JSON. We’ll use Python’s `csv` module to process weather data stored in the CSV
    format and analyze high and low temperatures over time in two different locations.
    We’ll then use Matplotlib to generate a chart based on our downloaded data to
    display variations in temperature in two dissimilar environments: Sitka, Alaska,
    and Death Valley, California. Later in the chapter, we’ll use the `json` module
    to access earthquake data stored in the GeoJSON format and use Plotly to draw
    a world map showing the locations and magnitudes of recent earthquakes.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将访问并可视化存储在两种常见数据格式中的数据：CSV 和 JSON。我们将使用 Python 的 `csv` 模块处理存储在 CSV 格式中的天气数据，并分析两个不同地点的高低温度变化。然后，我们将使用
    Matplotlib 基于下载的数据生成图表，显示两个不同环境中温度的变化：阿拉斯加的锡特卡和加利福尼亚的死亡谷。之后，在本章的后续部分，我们将使用 `json`
    模块访问存储在 GeoJSON 格式中的地震数据，并使用 Plotly 绘制一张世界地图，显示最近地震的地点和震级。
- en: By the end of this chapter, you’ll be prepared to work with various types of
    datasets in different formats, and you’ll have a deeper understanding of how to
    build complex visualizations. Being able to access and visualize online data is
    essential to working with a wide variety of real-world datasets.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你将能够处理各种格式的数据集，并深入理解如何构建复杂的可视化。能够访问和可视化在线数据是处理各种现实世界数据集的基础。
- en: The CSV File Format
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CSV 文件格式
- en: 'One simple way to store data in a text file is to write the data as a series
    of values separated by commas, called *comma-separated values*. The resulting
    files are *CSV* files. For example, here’s a chunk of weather data in CSV format:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 一种简单的文本文件数据存储方式是将数据写成由逗号分隔的一系列值，这就是所谓的 *逗号分隔值*。生成的文件即为 *CSV* 文件。例如，这里有一段以 CSV
    格式存储的天气数据：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is an excerpt of weather data from January 1, 2021, in Sitka, Alaska. It
    includes the day’s high and low temperatures, as well as a number of other measurements
    from that day. CSV files can be tedious for humans to read, but programs can process
    and extract information from them quickly and accurately.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这是来自2021年1月1日，位于阿拉斯加锡特卡的天气数据摘录。它包括当天的最高温度和最低温度，以及当天的其他若干测量值。CSV 文件对人类来说可能阅读起来很繁琐，但程序可以快速、准确地处理并提取其中的信息。
- en: We’ll begin with a small set of CSV-formatted weather data recorded in Sitka;
    it is available in this book’s resources at [https://ehmatthes.github.io/pcc_3e](https://ehmatthes.github.io/pcc_3e).
    Make a folder called *weather_data* inside the folder where you’re saving this
    chapter’s programs. Copy the file *sitka_weather_07-2021_simple.csv* into this
    new folder. (After you download this book’s resources, you’ll have all the files
    you need for this project.)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一小部分以 CSV 格式记录的锡特卡天气数据开始；这些数据可以在本书的资源中找到，网址为 [https://ehmatthes.github.io/pcc_3e](https://ehmatthes.github.io/pcc_3e)。在你保存本章程序的文件夹中创建一个名为
    *weather_data* 的文件夹，并将文件 *sitka_weather_07-2021_simple.csv* 复制到这个新文件夹中。（下载本书资源后，你将获得该项目所需的所有文件。）
- en: Parsing the CSV File Headers
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解析 CSV 文件标题
- en: 'Python’s `csv` module in the standard library parses the lines in a CSV file
    and allows us to quickly extract the values we’re interested in. Let’s start by
    examining the first line of the file, which contains a series of headers for the
    data. These headers tell us what kind of information the data holds:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Python 标准库中的 `csv` 模块解析 CSV 文件中的行，允许我们快速提取感兴趣的值。让我们从检查文件的第一行开始，这一行包含数据的标题。标题告诉我们数据包含的是什么类型的信息：
- en: '**sitka_highs.py**'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**sitka_highs.py**'
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We first import `Path` and the `csv` module. We then build a `Path` object that
    looks in the *weather_data* folder, and points to the specific weather data file
    we want to work with ❶. We read the file and chain the `splitlines()` method to
    get a list of all lines in the file, which we assign to `lines`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入 `Path` 和 `csv` 模块。然后我们创建一个 `Path` 对象，它指向 *weather_data* 文件夹，并指向我们想要处理的具体天气数据文件
    ❶。我们读取文件，并链式调用 `splitlines()` 方法，以获取文件中所有行的列表，并将其赋值给 `lines`。
- en: Next, we build a `reader` object ❷. This is an object that can be used to parse
    each line in the file. To make a reader object, call the function `csv.reader()`
    and pass it the list of lines from the CSV file.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们构建一个`reader`对象 ❷。这个对象可以用来解析文件中的每一行。要创建一个`reader`对象，调用函数`csv.reader()`并将CSV文件的行列表传递给它。
- en: 'When given a `reader` object, the `next()` function returns the next line in
    the file, starting from the beginning of the file. Here we call `next()` only
    once, so we get the first line of the file, which contains the file headers ❸.
    We assign the data that’s returned to `header_row`. As you can see, `header_row`
    contains meaningful, weather-related headers that tell us what information each
    line of data holds:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当给定一个`reader`对象时，`next()`函数返回文件中的下一行，从文件的开头开始。在这里，我们只调用了一次`next()`，因此我们得到了文件的第一行，其中包含文件头
    ❸。我们将返回的数据赋值给`header_row`。如你所见，`header_row`包含了有意义的、与天气相关的标题，告诉我们每行数据所包含的信息：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `reader` object processes the first line of comma-separated values in the
    file and stores each value as an item in a list. The header `STATION` represents
    the code for the weather station that recorded this data. The position of this
    header tells us that the first value in each line will be the weather station
    code. The `NAME` header indicates that the second value in each line is the name
    of the weather station that made the recording. The rest of the headers specify
    what kinds of information were recorded in each reading. The data we’re most interested
    in for now are the date (`DATE`), the high temperature (`TMAX`), and the low temperature
    (`TMIN`). This is a simple dataset that contains only temperature-related data.
    When you download your own weather data, you can choose to include a number of
    other measurements relating to wind speed, wind direction, and precipitation data.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`reader`对象处理文件中的第一行逗号分隔值，并将每个值存储为列表中的一项。标题`STATION`代表记录此数据的气象站的代码。该标题的位置告诉我们，每行的第一个值将是气象站的代码。`NAME`标题表明每行的第二个值是进行记录的气象站的名称。其余标题指定每次读取中记录了哪些类型的信息。现在我们最关心的数据是日期（`DATE`）、最高温度（`TMAX`）和最低温度（`TMIN`）。这是一个简单的数据集，仅包含与温度相关的数据。当你下载自己的天气数据时，你可以选择包括与风速、风向和降水数据等相关的其他测量项。'
- en: Printing the Headers and Their Positions
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 打印标题及其位置
- en: 'To make it easier to understand the file header data, let’s print each header
    and its position in the list:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更容易理解文件头数据，让我们打印出每个标题及其在列表中的位置：
- en: '**sitka_highs.py**'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**sitka_highs.py**'
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `enumerate()` function returns both the index of each item and the value
    of each item as you loop through a list. (Note that we’ve removed the line `print(header_row)`
    in favor of this more detailed version.)
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`enumerate()`函数在遍历列表时返回每个项的索引和对应的值。（请注意，我们已删除了`print(header_row)`这一行，改用更详细的版本。）'
- en: 'Here’s the output showing the index of each header:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是显示每个标题索引的输出：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We can see that the dates and their high temperatures are stored in columns
    2 and 4\. To explore this data, we’ll process each row of data in *sitka_weather_07-2021_simple.csv*
    and extract the values with the indexes 2 and 4.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，日期及其对应的最高温度存储在第2列和第4列。为了探索这些数据，我们将处理*sitka_weather_07-2021_simple.csv*中的每一行数据，并提取索引为2和4的值。
- en: Extracting and Reading Data
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提取和读取数据
- en: 'Now that we know which columns of data we need, let’s read in some of that
    data. First, we’ll read in the high temperature for each day:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了需要哪些数据列，让我们读取其中的一些数据。首先，我们将读取每天的最高温度：
- en: '**sitka_highs.py**'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**sitka_highs.py**'
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We make an empty list called `highs` ❶ and then loop through the remaining rows
    in the file ❷. The `reader` object continues from where it left off in the CSV
    file and automatically returns each line following its current position. Because
    we’ve already read the header row, the loop will begin at the second line where
    the actual data begins. On each pass through the loop we pull the data from index
    4, corresponding to the header `TMAX`, and assign it to the variable `high` ❸.
    We use the `int()` function to convert the data, which is stored as a string,
    to a numerical format so we can use it. We then append this value to `highs`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个名为`highs`的空列表 ❶，然后遍历文件中的其余行 ❷。`reader`对象从它在CSV文件中的当前位置继续，并自动返回当前行后的每一行。因为我们已经读取了标题行，循环将从第二行开始，实际数据也从这一行开始。在每次循环中，我们提取索引为4的数据显示，该索引对应标题`TMAX`，并将其赋值给变量`high`
    ❸。我们使用`int()`函数将存储为字符串的数据转换为数值格式，以便后续使用。然后我们将该值追加到`highs`列表中。
- en: 'The following listing shows the data now stored in `highs`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是当前存储在`highs`中的数据：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We’ve extracted the high temperature for each date and stored each value in
    a list. Now let’s create a visualization of this data.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提取了每个日期的最高温度，并将每个值存储在列表中。现在，让我们创建一个关于这些数据的可视化图表。
- en: Plotting Data in a Temperature Chart
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在温度图表中绘制数据
- en: 'To visualize the temperature data we have, we’ll first create a simple plot
    of the daily highs using Matplotlib, as shown here:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可视化我们拥有的温度数据，我们首先使用Matplotlib绘制一个简单的每日最高温度图，如下所示：
- en: '**sitka_highs.py**'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**sitka_highs.py**'
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We pass the list of highs to `plot()` and pass `color=''red''` to plot the
    points in red ❶. (We’ll plot the highs in red and the lows in blue.) We then specify
    a few other formatting details, such as the title, font size, and labels ❷, just
    as we did in Chapter 15. Because we have yet to add the dates, we won’t label
    the *x*-axis, but `ax.set_xlabel()` does modify the font size to make the default
    labels more readable ❸. [Figure 16-1](#figure16-1) shows the resulting plot: a
    simple line graph of the high temperatures for July 2021 in Sitka, Alaska.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将最高温度列表传递给`plot()`，并传递`color='red'`来将点绘制为红色❶。（我们将用红色绘制最高温度，蓝色绘制最低温度。）然后，我们指定一些其他的格式细节，比如标题、字体大小和标签❷，就像我们在第15章中做的那样。由于我们还没有添加日期，所以我们不会标注*X*轴，但`ax.set_xlabel()`确实修改了字体大小，使默认标签更具可读性❸。[图16-1](#figure16-1)显示了生成的图表：一张展示2021年7月阿拉斯加锡特卡每日最高温度的简单折线图。
- en: '![](image_fi/502703c16/f16001.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502703c16/f16001.png)'
- en: 'Figure 16-1: A line graph showing daily high temperatures for July 2021 in
    Sitka, Alaska'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图16-1：显示2021年7月阿拉斯加锡特卡每日最高温度的折线图
- en: The datetime Module
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: datetime模块
- en: 'Let’s add dates to our graph to make it more useful. The first date from the
    weather data file is in the second row of the file:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们向图表中添加日期，使其更加实用。天气数据文件中的第一行日期位于文件的第二行：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The data will be read in as a string, so we need a way to convert the string
    `"2021-07-01"` to an object representing this date. We can construct an object
    representing July 1, 2021, using the `strptime()` method from the `datetime` module.
    Let’s see how `strptime()` works in a terminal session:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 数据将作为字符串读取，因此我们需要一种方法将字符串`"2021-07-01"`转换为表示该日期的对象。我们可以使用`datetime`模块中的`strptime()`方法来构造一个表示2021年7月1日的对象。让我们看一下`strptime()`在终端会话中的工作方式：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We first import the `datetime` class from the `datetime` module. Then we call
    the method `strptime()` with the string containing the date we want to process
    as its first argument. The second argument tells Python how the date is formatted.
    In this example, `'%Y-'` tells Python to look for a four-digit year before the
    first dash; `'%m-'` indicates a two-digit month before the second dash; and `'%d'`
    means the last part of the string is the day of the month, from 1 to 31.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先从`datetime`模块导入`datetime`类。然后，我们调用`strptime()`方法，并将包含我们要处理的日期的字符串作为第一个参数。第二个参数告诉Python日期的格式。在这个例子中，`'%Y-'`告诉Python在第一个破折号之前寻找四位数的年份；`'%m-'`表示第二个破折号之前是两位数的月份；`'%d'`表示字符串的最后部分是日期，范围从1到31。
- en: The `strptime()` method can take a variety of arguments to determine how to
    interpret the date. [Table 16-1](#table16-1) shows some of these arguments.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`strptime()`方法可以接受多种参数来决定如何解析日期。[表16-1](#table16-1)展示了这些参数的一部分。'
- en: 'Table 16-1: Date and Time Formatting Arguments from the `datetime` Module'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 表16-1：`datetime`模块中的日期和时间格式化参数
- en: '| **Argument** | **Meaning** |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| **参数** | **含义** |'
- en: '| --- | --- |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `%A` | Weekday name, such as Monday |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `%A` | 星期几的名称，例如星期一 |'
- en: '| `%B` | Month name, such as January |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `%B` | 月份名称，例如一月 |'
- en: '| `%m` | Month, as a number (01 to 12) |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `%m` | 月份，数字表示（01到12） |'
- en: '| `%d` | Day of the month, as a number (01 to 31) |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `%d` | 月份中的日期（01到31） |'
- en: '| `%Y` | Four-digit year, such as 2019 |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `%Y` | 四位数的年份，例如2019 |'
- en: '| `%y` | Two-digit year, such as 19 |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `%y` | 两位数的年份，例如19 |'
- en: '| `%H` | Hour, in 24-hour format (00 to 23) |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `%H` | 小时（24小时制，00到23） |'
- en: '| `%I` | Hour, in 12-hour format (01 to 12) |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `%I` | 小时（12小时制，01到12） |'
- en: '| `%p` | AM or PM |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `%p` | AM或PM |'
- en: '| `%M` | Minutes (00 to 59) |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `%M` | 分钟（00到59） |'
- en: '| `%S` | Seconds (00 to 61) |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `%S` | 秒（00到61） |'
- en: Plotting Dates
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绘制日期
- en: 'We can improve our plot by extracting dates for the daily high temperature
    readings, and using these dates on the *x*-axis:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过提取每日最高温度的日期，并将这些日期用于*X*轴，来改善我们的图表：
- en: '**sitka_highs.py**'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**sitka_highs.py**'
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We create two empty lists to store the dates and high temperatures from the
    file ❶. We then convert the data containing the date information (`row[2]`) to
    a `datetime` object ❷ and append it to `dates`. We pass the dates and the high
    temperature values to `plot()` ❸. The call to `fig.autofmt_xdate()` ❹ draws the
    date labels diagonally to prevent them from overlapping. [Figure 16-2](#figure16-2)
    shows the improved graph.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了两个空列表，用来存储文件中的日期和高温数据 ❶。然后，我们将包含日期信息的数据（`row[2]`）转换为 `datetime` 对象 ❷，并将其附加到
    `dates` 中。接着，我们将日期和高温数据传递给 `plot()` ❸。调用 `fig.autofmt_xdate()` ❹ 会将日期标签以对角线方式绘制，以避免它们重叠。[图
    16-2](#figure16-2) 显示了改进后的图表。
- en: '![](image_fi/502703c16/f16002.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502703c16/f16002.png)'
- en: 'Figure 16-2: The graph is more meaningful, now that it has dates on the *x*-axis.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16-2：图表更有意义，因为它在 *x* 轴上有了日期。
- en: Plotting a Longer Timeframe
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绘制更长时间跨度的数据
- en: With our graph set up, let’s include additional data to get a more complete
    picture of the weather in Sitka. Copy the file *sitka_weather_2021_simple.csv*,
    which contains a full year’s worth of weather data for Sitka, to the folder where
    you’re storing the data for this chapter’s programs.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图表设置好之后，让我们加入更多数据，以获得对 Sitka 天气的更全面了解。将包含 Sitka 一整年天气数据的文件 *sitka_weather_2021_simple.csv*
    复制到你存储本章程序数据的文件夹中。
- en: 'Now we can generate a graph for the entire year’s weather:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以生成全年天气的数据图表：
- en: '**sitka_highs.py**'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**sitka_highs.py**'
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We modify the filename to use the new data file *sitka_weather_2021_simple.csv*,
    and we update the title of our plot to reflect the change in its content. [Figure
    16-3](#figure16-3) shows the resulting plot.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们修改文件名以使用新的数据文件 *sitka_weather_2021_simple.csv*，并更新图表的标题以反映其内容的变化。[图 16-3](#figure16-3)
    显示了生成的图表。
- en: '![](image_fi/502703c16/f16003.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502703c16/f16003.png)'
- en: 'Figure 16-3: A year’s worth of data'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16-3：一年的数据
- en: Plotting a Second Data Series
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绘制第二组数据
- en: 'We can make our graph even more useful by including the low temperatures. We
    need to extract the low temperatures from the data file and then add them to our
    graph, as shown here:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过包括低温数据使我们的图表更有用。我们需要从数据文件中提取低温数据，然后将其添加到图表中，如下所示：
- en: '**sitka_highs_lows.py**'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**sitka_highs_lows.py**'
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We add the empty list `lows` to hold low temperatures ❶, and then we extract
    and store the low temperature for each date from the sixth position in each row
    (`row[5]`) ❷. We add a call to `plot()` for the low temperatures and color these
    values blue ❸. Finally, we update the title ❹. [Figure 16-4](#figure16-4) shows
    the resulting chart.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了空列表 `lows` 用来存放低温数据 ❶，然后从每行的第六个位置（`row[5]`）提取并存储每个日期的低温数据 ❷。我们为低温数据添加了
    `plot()` 调用，并将这些值设置为蓝色 ❸。最后，我们更新了标题 ❹。[图 16-4](#figure16-4) 显示了生成的图表。
- en: '![](image_fi/502703c16/f16004.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502703c16/f16004.png)'
- en: 'Figure 16-4: Two data series on the same plot'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16-4：同一图表上的两组数据
- en: Shading an Area in the Chart
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在图表中填充阴影区域
- en: 'Having added two data series, we can now examine the range of temperatures
    for each day. Let’s add a finishing touch to the graph by using shading to show
    the range between each day’s high and low temperatures. To do so, we’ll use the
    `fill_between()` method, which takes a series of *x*-values and two series of
    *y*-values and fills the space between the two series of *y*-values:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加了两组数据后，我们现在可以查看每天的温度范围。让我们通过使用阴影来显示每天的最高温度和最低温度之间的范围，为图表画上完美的句号。为此，我们将使用
    `fill_between()` 方法，它需要传入一系列 *x* 值和两组 *y* 值，并在两组 *y* 值之间填充区域：
- en: '**sitka_highs_lows.py**'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**sitka_highs_lows.py**'
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `alpha` argument controls a color’s transparency ❶. An `alpha` value of
    0 is completely transparent, and a value of 1 (the default) is completely opaque.
    By setting `alpha` to 0.5, we make the red and blue plot lines appear lighter.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`alpha` 参数控制颜色的透明度 ❶。`alpha` 值为 0 时完全透明，值为 1（默认）时完全不透明。通过将 `alpha` 设置为 0.5，我们让红色和蓝色的绘图线条看起来更轻。'
- en: We pass `fill_between()` the list `dates` for the *x*-values and then the two
    *y*-value series `highs` and `lows` ❷. The `facecolor` argument determines the
    color of the shaded region; we give it a low `alpha` value of 0.1 so the filled
    region connects the two data series without distracting from the information they
    represent. [Figure 16-5](#figure16-5) shows the plot with the shaded region between
    the highs and lows.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`fill_between()`应用于列表`dates`作为 *x* 值，然后是两组 *y* 值数据系列 `highs` 和 `lows` ❷。`facecolor`
    参数决定了阴影区域的颜色；我们将其`alpha`值设置为 0.1，这样填充区域就可以连接两组数据系列，而不会干扰它们所代表的信息。[图 16-5](#figure16-5)
    显示了带有阴影区域的图表，其中高温和低温之间有一个填充区域。
- en: '![](image_fi/502703c16/f16005.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502703c16/f16005.png)'
- en: 'Figure 16-5: The region between the two datasets is shaded.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16-5：两个数据集之间的区域已被阴影填充。
- en: The shading helps make the range between the two datasets immediately apparent.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 阴影有助于使两个数据集之间的范围立即显现。
- en: Error Checking
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 错误检查
- en: We should be able to run the *sitka_highs_lows.py* code using data for any location.
    But some weather stations collect different data than others, and some occasionally
    malfunction and fail to collect some of the data they’re supposed to. Missing
    data can result in exceptions that crash our programs, unless we handle them properly.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该能够使用任何位置的数据运行 *sitka_highs_lows.py* 代码。但有些气象站收集的数据与其他站点不同，有些站点偶尔出现故障，未能收集到应收集的数据。缺失的数据可能会导致异常，进而导致程序崩溃，除非我们适当处理这些异常。
- en: For example, let’s see what happens when we attempt to generate a temperature
    plot for Death Valley, California. Copy the file *death_valley_2021_simple.csv*
    to the folder where you’re storing the data for this chapter’s programs.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们看看当我们尝试为加利福尼亚州的死亡谷生成温度图表时会发生什么。将文件*death_valley_2021_simple.csv*复制到你存储本章程序数据的文件夹中。
- en: 'First, let’s run the code to see the headers that are included in this data
    file:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们运行代码以查看此数据文件中包含的标题：
- en: '**death_valley_highs_lows.py**'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**death_valley_highs_lows.py**'
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here’s the output:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The date is in the same position, at index 2\. But the high and low temperatures
    are at indexes 3 and 4, so we’ll need to change the indexes in our code to reflect
    these new positions. Instead of including an average temperature reading for the
    day, this station includes `TOBS`, a reading for a specific observation time.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 日期位于相同的位置，索引为 2。但最高和最低气温位于索引 3 和 4，因此我们需要更改代码中的索引以反映这些新位置。此站点不包括当天的平均温度，而是包括`TOBS`，即特定观察时间的读数。
- en: 'Change *sitka_highs_lows.py* to generate a graph for Death Valley using the
    indexes we just noted, and see what happens:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 更改 *sitka_highs_lows.py*，使用我们刚刚注意到的索引生成死亡谷的图表，并查看发生了什么：
- en: '**death_valley_highs_lows.py**'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**death_valley_highs_lows.py**'
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We update the program to read from the Death Valley data file, and we change
    the indexes to correspond to this file’s `TMAX` and `TMIN` positions.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更新程序以从死亡谷数据文件中读取数据，并将索引更改为对应于该文件中 `TMAX` 和 `TMIN` 的位置。
- en: 'When we run the program, we get an error:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行程序时，我们得到一个错误：
- en: '[PRE17]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The traceback tells us that Python can’t process the high temperature for one
    of the dates because it can’t turn an empty string (`''`) into an integer ❶. Rather
    than looking through the data to find out which reading is missing, we’ll just
    handle cases of missing data directly.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 错误跟踪信息告诉我们，Python 无法处理某个日期的最高温度，因为它无法将空字符串(`''`)转换为整数 ❶。我们不会逐一查找缺失的数据，而是直接处理缺失数据的情况。
- en: 'We’ll run error-checking code when the values are being read from the CSV file
    to handle exceptions that might arise. Here’s how to do this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在从 CSV 文件读取值时运行错误检查代码，以处理可能出现的异常。以下是如何做到这一点：
- en: '**death_valley_highs_lows.py**'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**death_valley_highs_lows.py**'
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Each time we examine a row, we try to extract the date and the high and low
    temperature ❶. If any data is missing, Python will raise a `ValueError` and we
    handle it by printing an error message that includes the date of the missing data
    ❷. After printing the error, the loop will continue processing the next row. If
    all data for a date is retrieved without error, the `else` block will run and
    the data will be appended to the appropriate lists ❸. Because we’re plotting information
    for a new location, we update the title to include the location on the plot, and
    we use a smaller font size to accommodate the longer title ❹.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们检查一行时，我们尝试提取日期以及最高和最低气温 ❶。如果缺少任何数据，Python 会抛出一个`ValueError`，我们通过打印包含缺失数据日期的错误信息来处理它
    ❷。在打印错误信息后，循环将继续处理下一行数据。如果没有出现错误并且所有日期的数据都成功获取，则`else`块将执行，数据会被追加到相应的列表中 ❸。由于我们要绘制新的位置的信息，因此我们更新标题以在图表中包含位置，并使用较小的字体大小以适应较长的标题
    ❹。
- en: 'When you run *death_valley_highs_lows.py* now, you’ll see that only one date
    had missing data:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当你现在运行*death_valley_highs_lows.py*时，你会看到只有一个日期缺少数据：
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Because the error is handled appropriately, our code is able to generate a plot,
    which skips over the missing data. [Figure 16-6](#figure16-6) shows the resulting
    plot.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于错误得到了适当处理，我们的代码能够生成图表，并跳过缺失的数据。[图 16-6](#figure16-6)显示了生成的图表。
- en: Comparing this graph to the Sitka graph, we can see that Death Valley is warmer
    overall than southeast Alaska, as we expect. Also, the range of temperatures each
    day is greater in the desert. The height of the shaded region makes this clear.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 比较这张图和西特卡图表，我们可以看到死亡谷总体上比东南阿拉斯加温暖，正如我们所预期的那样。此外，每天的温度范围在沙漠地区更大。阴影区域的高度清晰地表明了这一点。
- en: '![](image_fi/502703c16/f16006.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502703c16/f16006.png)'
- en: 'Figure 16-6: Daily high and low temperatures for Death Valley'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16-6：死亡谷的每日最高和最低温度
- en: Many datasets you work with will have missing, improperly formatted, or incorrect
    data. You can use the tools you learned in the first half of this book to handle
    these situations. Here we used a `try`-`except`-`else` block to handle missing
    data. Sometimes you’ll use `continue` to skip over some data, or use `remove()`
    or `del` to eliminate some data after it’s been extracted. Use any approach that
    works, as long as the result is a meaningful, accurate visualization.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你处理的许多数据集可能会有缺失、不正确格式化或不正确的数据。你可以使用本书前半部分介绍的工具来处理这些情况。在这里，我们使用了一个`try`-`except`-`else`块来处理缺失的数据。有时你会使用`continue`跳过一些数据，或者使用`remove()`或`del`在提取数据后删除一些数据。只要结果是有意义且准确的可视化，可以使用任何有效的方法。
- en: Downloading Your Own Data
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 下载你自己的数据
- en: 'To download your own weather data, follow these steps:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要下载你自己的天气数据，请按照以下步骤操作：
- en: Visit the NOAA Climate Data Online site at [https://www.ncdc.noaa.gov/cdo-web](https://www.ncdc.noaa.gov/cdo-web).
    In the Discover Data By section, click **Search Tool**. In the Select a Dataset
    box, choose **Daily Summaries**.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问 NOAA 气候数据在线网站 [https://www.ncdc.noaa.gov/cdo-web](https://www.ncdc.noaa.gov/cdo-web)。在“通过数据发现”部分，点击**搜索工具**。在“选择数据集”框中，选择**每日总结**。
- en: Select a date range, and in the Search For section, choose **ZIP Codes**. Enter
    the ZIP code you’re interested in and click **Search**.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择日期范围，在“搜索”部分，选择**邮政编码**。输入你感兴趣的邮政编码并点击**搜索**。
- en: On the next page, you’ll see a map and some information about the area you’re
    focusing on. Below the location name, click **View Full Details**, or click the
    map and then click **Full Details**.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一页，你将看到一个地图和关于你关注区域的一些信息。在位置名称下，点击**查看详细信息**，或者点击地图然后点击**查看详细信息**。
- en: Scroll down and click **Station List** to see the weather stations that are
    available in this area. Click one of the station names and then click **Add to
    Cart**. This data is free, even though the site uses a shopping cart icon. In
    the upper-right corner, click the cart.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向下滚动并点击**站点列表**，查看此区域可用的气象站。点击一个站点名称，然后点击**添加到购物车**。尽管该站点使用购物车图标，但这些数据是免费的。在右上角，点击购物车。
- en: In Select the Output Format, choose **Custom GHCN-Daily CSV**. Make sure the
    date range is correct and click **Continue**.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“选择输出格式”中，选择**自定义 GHCN-Daily CSV**。确保日期范围正确，然后点击**继续**。
- en: On the next page, you can select the kinds of data you want. You can download
    one kind of data (for example, focusing on air temperature) or you can download
    all the data available from this station. Make your choices and then click **Continue**.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一页，你可以选择你想要的数据类型。你可以下载一种数据（例如，专注于空气温度），或者下载该站点提供的所有数据。做出选择后，点击**继续**。
- en: On the last page, you’ll see a summary of your order. Enter your email address
    and click **Submit Order**. You’ll receive a confirmation that your order was
    received, and in a few minutes, you should receive another email with a link to
    download your data.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在最后一页，你会看到你订单的总结。输入你的电子邮件地址并点击**提交订单**。你会收到一封确认邮件，确认你的订单已被接收，并且几分钟后，你应该会收到另一封包含下载数据链接的邮件。
- en: The data you download should be structured just like the data we worked with
    in this section. It might have different headers than those you saw in this section,
    but if you follow the same steps we used here, you should be able to generate
    visualizations of the data you’re interested in.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你下载的数据应与我们在本节中处理的数据结构相同。它可能会有与本节中不同的表头，但如果你按照我们在这里使用的相同步骤操作，你应该能够生成你感兴趣的数据的可视化图表。
- en: 'Mapping Global Datasets: GeoJSON Format'
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 映射全球数据集：GeoJSON 格式
- en: In this section, you’ll download a dataset representing all the earthquakes
    that have occurred in the world during the previous month. Then you’ll make a
    map showing the location of these earthquakes and how significant each one was.
    Because the data is stored in the GeoJSON format, we’ll work with it using the
    `json` module. Using Plotly’s `scatter_geo()` plot, you’ll create visualizations
    that clearly show the global distribution of earthquakes.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将下载一个数据集，表示过去一个月内全球发生的所有地震。然后，你将制作一张地图，显示这些地震的位置以及每次地震的严重程度。由于数据以GeoJSON格式存储，我们将使用`json`模块来处理它。使用Plotly的`scatter_geo()`图表，你将创建清晰显示地震全球分布的可视化图。
- en: Downloading Earthquake Data
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 下载地震数据
- en: Make a folder called *eq_data* inside the folder where you’re saving this chapter’s
    programs. Copy the file *eq_1_day_m1.geojson* into this new folder. Earthquakes
    are categorized by their magnitude on the Richter scale. This file includes data
    for all earthquakes with a magnitude M1 or greater that took place in the last
    24 hours (at the time of this writing). This data comes from one of the United
    States Geological Survey’s earthquake data feeds, at [https://earthquake.usgs.gov/earthquakes/feed](https://earthquake.usgs.gov/earthquakes/feed).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在你保存本章程序的文件夹内，创建一个名为*eq_data*的文件夹。将文件*eq_1_day_m1.geojson*复制到这个新文件夹中。地震按其里氏震级进行分类。此文件包含过去24小时内（截至撰写时）所有震级M1或更大的地震数据。这些数据来自美国地质调查局的地震数据源，网址为[https://earthquake.usgs.gov/earthquakes/feed](https://earthquake.usgs.gov/earthquakes/feed)。
- en: Examining GeoJSON Data
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查GeoJSON数据
- en: 'When you open *eq_1_day_m1.geojson*, you’ll see that it’s very dense and hard
    to read:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打开*eq_1_day_m1.geojson*时，你会看到它非常密集且难以阅读：
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This file is formatted more for machines than humans. But we can see that the
    file contains some dictionaries, as well as information that we’re interested
    in, such as earthquake magnitudes and locations.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件的格式更适合机器处理而非人类阅读。但我们可以看到文件中包含了一些字典，以及我们感兴趣的信息，如地震的震级和位置。
- en: The `json` module provides a variety of tools for exploring and working with
    JSON data. Some of these tools will help us reformat the file so we can look at
    the raw data more easily before we work with it programmatically.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`json`模块提供了多种工具，用于探索和处理JSON数据。其中一些工具将帮助我们重新格式化文件，以便在编程处理之前更容易查看原始数据。'
- en: 'Let’s start by loading the data and displaying it in a format that’s easier
    to read. This is a long data file, so instead of printing it, we’ll rewrite the
    data to a new file. Then we can open that file and scroll back and forth through
    the data more easily:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从加载数据并以更易读的格式显示它开始。由于这是一个长数据文件，因此我们将数据重写到一个新文件中，而不是直接打印它。然后我们可以打开该文件，方便地浏览数据：
- en: '**eq_explore_data.py**'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**eq_explore_data.py**'
- en: '[PRE21]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We read the data file as a string, and use `json.loads()` to convert the string
    representation of the file to a Python object ❶. This is the same approach we
    used in Chapter 10. In this case, the entire dataset is converted to a single
    dictionary, which we assign to `all_eq_data`. We then define a new `path` where
    we can write this same data in a more readable format ❷. The `json.dumps()` function
    that you saw in Chapter 10 can take an optional `indent` argument ❸, which tells
    it how much to indent nested elements in the data structure.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将数据文件作为字符串读取，并使用`json.loads()`将文件的字符串表示转换为Python对象❶。这与我们在第10章中使用的方法相同。在这种情况下，整个数据集被转换为一个字典，我们将其赋值给`all_eq_data`。然后，我们定义一个新的`path`，在其中以更易读的格式写入相同的数据❷。你在第10章中看到的`json.dumps()`函数可以接受一个可选的`indent`参数❸，该参数告诉它在数据结构中嵌套元素的缩进量。
- en: 'When you look in your *eq_data* directory and open the file *readable_eq_data.json*,
    here’s the first part of what you’ll see:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当你查看你的*eq_data*目录并打开文件*readable_eq_data.json*时，你将看到以下是你所看到的第一部分内容：
- en: '**readable_eq_data.json**'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**readable_eq_data.json**'
- en: '[PRE22]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The first part of the file includes a section with the key `"metadata"`❶. This
    tells us when the data file was generated and where we can find the data online.
    It also gives us a human-readable title and the number of earthquakes included
    in this file. In this 24-hour period, `160` earthquakes were recorded.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的第一部分包括一个键为`"metadata"`的部分❶。这告诉我们数据文件生成的时间以及我们可以在哪里找到在线数据。它还为我们提供了一个人类可读的标题和文件中包含的地震数量。在这个24小时的时间段内，共记录了`160`次地震。
- en: This GeoJSON file has a structure that’s helpful for location-based data. The
    information is stored in a list associated with the key `"features"` ❷. Because
    this file contains earthquake data, the data is in list form where every item
    in the list corresponds to a single earthquake. This structure might look confusing,
    but it’s quite powerful. It allows geologists to store as much information as
    they need to in a dictionary about each earthquake, and then stuff all those dictionaries
    into one big list.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这个GeoJSON文件具有对基于位置的数据非常有用的结构。信息存储在与键`"features"`相关的列表中 ❷。由于该文件包含地震数据，因此数据以列表的形式存储，其中列表中的每一项对应一个地震。这个结构可能看起来有些混乱，但它非常强大。它允许地质学家将他们需要的所有信息存储在每个地震的字典中，然后将所有这些字典放入一个大的列表中。
- en: 'Let’s look at a dictionary representing a single earthquake:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下表示单个地震的字典：
- en: '**readable_eq_data.json**'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**readable_eq_data.json**'
- en: '[PRE23]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The key `"properties"` contains a lot of information about each earthquake ❶.
    We’re mainly interested in the magnitude of each earthquake, associated with the
    key `"mag"`. We’re also interested in the `"title"` of each event, which provides
    a nice summary of its magnitude and location ❷.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 键`"properties"`包含了每个地震的许多信息 ❶。我们主要关心的是每个地震的震级，与键`"mag"`相关。我们还对每个事件的`"title"`感兴趣，它提供了震级和位置的简洁总结
    ❷。
- en: The key `"geometry"` helps us understand where the earthquake occurred ❸. We’ll
    need this information to map each event. We can find the longitude ❹ and the latitude
    ❺ for each earthquake in a list associated with the key `"coordinates"`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 键`"geometry"`帮助我们理解地震发生的地点 ❸。我们需要这些信息来绘制每个事件的地图。我们可以在与键`"coordinates"`相关的列表中找到每个地震的经度
    ❹ 和纬度 ❺。
- en: 'This file contains way more nesting than we’d use in the code we write, so
    if it looks confusing, don’t worry: Python will handle most of the complexity.
    We’ll only be working with one or two nesting levels at a time. We’ll start by
    pulling out a dictionary for each earthquake that was recorded in the 24-hour
    time period.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件的嵌套层级比我们写的代码要多得多，所以如果看起来很混乱，别担心：Python会处理大部分复杂性。我们将一次只处理一个或两个嵌套层级。我们将从提取在24小时内记录的每个地震的字典开始。
- en: Making a List of All Earthquakes
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建包含所有地震的列表
- en: First, we’ll make a list that contains all the information about every earthquake
    that occurred.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个列表，其中包含发生的每个地震的所有信息。
- en: '**eq_explore_data.py**'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**eq_explore_data.py**'
- en: '[PRE24]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We take the data associated with the key `''features''` in the `all_eq_data`
    dictionary, and assign it to `all_eq_dicts`. We know this file contains records
    of 160 earthquakes, and the output verifies that we’ve captured all the earthquakes
    in the file:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们获取与键`'features'`相关的数据，并将其赋值给`all_eq_dicts`。我们知道该文件包含160个地震记录，输出结果验证了我们已捕获文件中的所有地震：
- en: '[PRE25]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Notice how short this code is. The neatly formatted file *readable_eq_data.json*
    has over 6,000 lines. But in just a few lines, we can read through all that data
    and store it in a Python list. Next, we’ll pull the magnitudes from each earthquake.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这段代码是多么简洁。格式整齐的文件*readable_eq_data.json*有超过6000行。但只需几行代码，我们就能读取所有数据并将其存储在Python列表中。接下来，我们将从每个地震中提取震级。
- en: Extracting Magnitudes
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提取震级
- en: 'We can loop through the list containing data about each earthquake, and extract
    any information we want. Let’s pull out the magnitude of each earthquake:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以遍历包含每个地震数据的列表，并提取我们需要的任何信息。让我们提取每个地震的震级：
- en: '**eq_explore_data.py**'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**eq_explore_data.py**'
- en: '[PRE26]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We make an empty list to store the magnitudes, and then loop through the list
    `all_eq_dicts` ❶. Inside this loop, each earthquake is represented by the dictionary
    `eq_dict`. Each earthquake’s magnitude is stored in the `'properties'` section
    of this dictionary, under the key `'mag'` ❷. We store each magnitude in the variable
    `mag` and then append it to the list `mags`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个空列表来存储震级，然后遍历列表`all_eq_dicts` ❶。在这个循环中，每个地震由字典`eq_dict`表示。每个地震的震级存储在该字典的`'properties'`部分，键为`'mag'`
    ❷。我们将每个震级存储在变量`mag`中，然后将其添加到列表`mags`中。
- en: 'We print the first `10` magnitudes, so we can see whether we’re getting the
    correct data:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打印前`10`个震级，这样我们可以看看是否获取了正确的数据：
- en: '[PRE27]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Next, we’ll pull the location data for each earthquake, and then we can make
    a map of the earthquakes.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将提取每个地震的位置信息，然后我们可以绘制地震地图。
- en: Extracting Location Data
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提取位置信息
- en: 'The location data for each earthquake is stored under the key `"geometry"`.
    Inside the geometry dictionary is a `"coordinates"` key, and the first two values
    in this list are the longitude and latitude. Here’s how we’ll pull this data:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 每个地震的位置数据存储在键`"geometry"`下。几何字典内部有一个`"coordinates"`键，列表中的前两个值分别是经度和纬度。以下是我们如何提取这些数据：
- en: '**eq_explore_data.py**'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**eq_explore_data.py**'
- en: '[PRE28]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We make empty lists for the longitudes and latitudes. The code `eq_dict['geometry']`
    accesses the dictionary representing the geometry element of the earthquake ❶.
    The second key, `'coordinates'`, pulls the list of values associated with `'coordinates'`.
    Finally, the `0` index asks for the first value in the list of coordinates, which
    corresponds to an earthquake’s longitude.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为经度和纬度创建了空列表。代码`eq_dict['geometry']`访问表示地震几何元素的字典❶。第二个键`'coordinates'`提取与`'coordinates'`相关联的值列表。最后，`0`索引请求获取坐标列表中的第一个值，这对应于地震的经度。
- en: 'When we print the first `5` longitudes and latitudes, the output shows that
    we’re pulling the correct data:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们打印前`5`个经度和纬度时，输出显示我们正在提取正确的数据：
- en: '[PRE29]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: With this data, we can move on to mapping each earthquake.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些数据，我们可以继续绘制每次地震的位置。
- en: Building a World Map
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建世界地图
- en: 'Using the information we’ve pulled so far, we can build a simple world map.
    Although it won’t look presentable yet, we want to make sure the information is
    displayed correctly before focusing on style and presentation issues. Here’s the
    initial map:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 利用我们目前提取的信息，我们可以构建一张简单的世界地图。虽然它现在看起来还不美观，但我们希望在关注样式和展示问题之前，确保信息正确显示。以下是初始地图：
- en: '**eq_world_map.py**'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**eq_world_map.py**'
- en: '[PRE30]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We import `plotly.express` with the alias `px`, just as we did in Chapter 15.
    The `scatter_geo()` function ❶ allows you to overlay a scatterplot of geographic
    data on a map. In the simplest use of this chart type, you only need to provide
    a list of latitudes and a list of longitudes. We pass the list `lats` to the `lat`
    argument, and `lons` to the `lon` argument.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入`plotly.express`并给它取别名`px`，就像在第15章中一样。`scatter_geo()`函数❶允许你在地图上叠加地理数据的散点图。在这种图表类型的最简单用法中，你只需要提供纬度列表和经度列表。我们将列表`lats`传递给`lat`参数，将`lons`传递给`lon`参数。
- en: When you run this file, you should see a map that looks like the one in [Figure
    16-7](#figure16-7). This again shows the power of the Plotly Express library;
    in just three lines of code, we have a map of global earthquake activity.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行此文件时，你应该会看到一张类似于[图16-7](#figure16-7)的地图。这再次展示了Plotly Express库的强大功能；仅用三行代码，我们就能得到一张全球地震活动的地图。
- en: '![](image_fi/502703c16/f16007.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502703c16/f16007.png)'
- en: 'Figure 16-7: A simple map showing where all the earthquakes in the last 24
    hours occurred'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图16-7：显示过去24小时所有地震发生地点的简单地图
- en: Now that we know the information in our dataset is being plotted correctly,
    we can make a few changes to make the map more meaningful and easier to read.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道数据集中的信息已经正确地绘制在地图上，我们可以做一些修改，让地图更有意义且更易于阅读。
- en: Representing Magnitudes
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 表示震级
- en: A map of earthquake activity should show the magnitude of each earthquake. We
    can also include more data, now that we know the data is being plotted correctly.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 地震活动的地图应该显示每次地震的震级。现在我们知道数据已经正确绘制，可以加入更多数据。
- en: '[PRE31]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We load the file *eq_data_30_day_m1.geojson*, to include a full 30 days’ worth
    of earthquake activity. We also use the size argument in the `px.scatter_geo()`
    call, which specifies how the points on the map will be sized. We pass the list
    `mags` to `size`, so earthquakes with a higher magnitude will show up as larger
    points on the map.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们加载文件*eq_data_30_day_m1.geojson*，以包含过去30天的地震活动数据。我们还在`px.scatter_geo()`调用中使用了`size`参数，它指定了地图上点的大小。我们将列表`mags`传递给`size`，这样震级较大的地震将在地图上显示为较大的点。
- en: The resulting map is shown in [Figure 16-8](#figure16-8). Earthquakes usually
    occur near tectonic plate boundaries, and the longer period of earthquake activity
    included in this map reveals the exact locations of these boundaries.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 结果地图如[图16-8](#figure16-8)所示。地震通常发生在构造板块边界附近，包含的更长时间段的地震活动揭示了这些边界的确切位置。
- en: '![](image_fi/502703c16/f16008.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502703c16/f16008.png)'
- en: 'Figure 16-8: The map now shows the magnitude of all earthquakes in the last
    30 days.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图16-8：地图现在显示了过去30天内所有地震的震级。
- en: This map is better, but it’s still difficult to pick out which points represent
    the most significant earthquakes. We can improve this further by using color to
    represent magnitudes as well.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这张地图更好一些，但仍然很难从中挑出哪些点代表最重要的地震。我们可以通过使用颜色来表示震级，进一步改善这一点。
- en: Customizing Marker Colors
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义标记颜色
- en: We can use Plotly’s color scales to customize each marker’s color, according
    to the severity of the corresponding earthquake. We’ll also use a different projection
    for the base map.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Plotly的颜色刻度来根据相应地震的严重程度自定义每个标记的颜色。我们还将为底图使用不同的投影。
- en: '**eq_world_map.py**'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**eq_world_map.py**'
- en: '[PRE32]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: All the significant changes here occur in the `px.scatter_geo()` function call.
    The `color` argument tells Plotly what values it should use to determine where
    each marker falls on the color scale ❶. We use the `mags` list to determine the
    color for each point, just as we did with the `size` argument.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这里所有显著的变化都发生在`px.scatter_geo()`函数调用中。`color`参数告诉Plotly应使用哪些值来确定每个标记在颜色刻度上的位置❶。我们使用`mags`列表来确定每个点的颜色，就像我们使用`size`参数时一样。
- en: The `color_continuous_scale` argument tells Plotly which color scale to use
    ❷. *Viridis* is a color scale that ranges from dark blue to bright yellow, and
    it works well for this dataset. By default, the color scale on the right of the
    map is labeled *color*; this is not representative of what the colors actually
    mean. The `labels` argument, shown in Chapter 15, takes a dictionary as a value
    ❸. We only need to set one custom label on this chart, making sure the color scale
    is labeled *Magnitude* instead of *color*.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`color_continuous_scale`参数告诉Plotly使用哪个颜色刻度❷。*Viridis*是一种颜色刻度，从深蓝到亮黄，适用于这个数据集。默认情况下，地图右侧的颜色刻度标记为*color*；这并不代表颜色实际的含义。`labels`参数，如第15章所示，接受一个字典作为值❸。我们只需要在这个图表上设置一个自定义标签，确保颜色刻度标记为*Magnitude*，而不是*color*。'
- en: We add one more argument, to modify the base map over which the earthquakes
    are plotted. The `projection` argument accepts a number of common map projections
    ❹. Here we use the `'natural earth'` projection, which rounds the ends of the
    map. Also, note the trailing comma after this last argument. When a function call
    has a long list of arguments spanning multiple lines like this, it’s common practice
    to add a trailing comma so you’re always ready to add another argument on the
    next line.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个额外的参数来修改地震绘制的底图。`projection`参数接受多种常见的地图投影❹。这里我们使用了`'natural earth'`投影，它将地图的两端做了圆形处理。另外，注意这个最后一个参数后面的逗号。当一个函数调用有一个跨多行的长参数列表时，通常的做法是在最后一个参数后加上逗号，这样你就可以随时在下一行添加新的参数。
- en: When you run the program now, you’ll see a much nicer-looking map. In [Figure
    16-9](#figure16-9), the color scale shows the severity of individual earthquakes;
    the most severe earthquakes stand out as light-yellow points, in contrast to many
    darker points. You can also tell which regions of the world have more significant
    earthquake activity.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行程序时，你会看到一张看起来更漂亮的地图。在[图16-9](#figure16-9)中，颜色刻度显示了每个地震的严重程度；最严重的地震以浅黄色的点突出显示，与许多较暗的点形成对比。你还可以看出哪些区域的地震活动更为显著。
- en: '![](image_fi/502703c16/f16009.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502703c16/f16009.png)'
- en: 'Figure 16-9: In 30 days’ worth of earthquakes, color and size are used to represent
    the magnitude of each earthquake.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图16-9：在30天内的地震数据中，颜色和大小用于表示每次地震的震级。
- en: Other Color Scales
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他颜色刻度
- en: 'You can choose from a number of other color scales. To see the available color
    scales, enter the following two lines in a Python terminal session:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从多种其他颜色刻度中选择。要查看可用的颜色刻度，可以在Python终端会话中输入以下两行：
- en: '[PRE33]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Feel free to try out these color scales in the earthquake map, or with any dataset
    where continuously varying colors can help show patterns in the data.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎尝试在地震地图中，或者在任何数据集上使用这些颜色刻度，尤其是在连续变化的颜色可以帮助显示数据模式的情况下。
- en: Adding Hover Text
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加悬浮文本
- en: To finish this map, we’ll add some informative text that appears when you hover
    over the marker representing an earthquake. In addition to showing the longitude
    and latitude, which appear by default, we’ll show the magnitude and provide a
    description of the approximate location as well.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这张地图，我们将添加一些信息文本，当你悬停在代表地震的标记上时会显示。除了显示经纬度（默认显示外），我们还将显示震级，并提供一个大致位置的描述。
- en: 'To make this change, we need to pull a little more data from the file:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行此更改，我们需要从文件中提取更多数据：
- en: '**eq_world_map.py**'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**eq_world_map.py**'
- en: '[PRE34]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We first make a list called `eq_titles` to store the title of each earthquake
    ❶. The `'title'` section of the data contains a descriptive name of the magnitude
    and location of each earthquake, in addition to its longitude and latitude. We
    pull this information and assign it to the variable `eq_title` ❷, and then append
    it to the list `eq_titles`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个名为`eq_titles`的列表，用于存储每次地震的标题❶。数据中的`'title'`部分包含了每次地震的震级和位置的描述性名称，以及它的经纬度。我们提取这些信息并将其赋值给变量`eq_title`❷，然后将其追加到`eq_titles`列表中。
- en: In the `px.scatter_geo()` call, we pass `eq_titles` to the `hover_name` argument
    ❸. Plotly will now add the information from the title of each earthquake to the
    hover text on each point. When you run this program, you should be able to hover
    over any marker, see a description of where that earthquake took place, and read
    its exact magnitude. An example of this information is shown in [Figure 16-10](#figure16-10).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在`px.scatter_geo()`调用中，我们将`eq_titles`传递给`hover_name`参数❸。Plotly现在会将每次地震的标题信息添加到每个数据点的鼠标悬停文本中。当你运行这个程序时，你应该能够将鼠标悬停在任何标记上，看到描述地震发生位置的文本，并查看其确切震级。这个信息的示例显示在[图16-10](#figure16-10)中。
- en: '![](image_fi/502703c16/f16010.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502703c16/f16010.png)'
- en: 'Figure 16-10: The hover text now includes a summary of each earthquake.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图16-10：现在，鼠标悬停时的文本会包含每次地震的总结信息。
- en: This is impressive! In less than 30 lines of code, we’ve created a visually
    appealing and meaningful map of global earthquake activity that also illustrates
    the geological structure of the planet. Plotly offers a wide range of ways you
    can customize the appearance and behavior of your visualizations. Using Plotly’s
    many options, you can make charts and maps that show exactly what you want them
    to.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常令人印象深刻！不到30行代码，我们就创建了一个既美观又有意义的全球地震活动地图，同时还展示了地球的地质结构。Plotly提供了多种方式来定制你可视化内容的外观和行为。利用Plotly的众多选项，你可以制作出准确显示你所需信息的图表和地图。
- en: Summary
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how to work with real-world datasets. You processed
    CSV and GeoJSON files, and extracted the data you want to focus on. Using historical
    weather data, you learned more about working with Matplotlib, including how to
    use the `datetime` module and how to plot multiple data series on one chart. You
    plotted geographical data on a world map in Plotly, and learned to customize the
    style of the map.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何处理实际数据集。你处理了CSV和GeoJSON文件，并提取了你想要关注的数据。通过使用历史天气数据，你更深入地了解了如何使用Matplotlib，包括如何使用`datetime`模块以及如何在一个图表上绘制多个数据系列。你在Plotly中将地理数据绘制到世界地图上，并学习了如何自定义地图的样式。
- en: As you gain experience working with CSV and JSON files, you’ll be able to process
    almost any data you want to analyze. You can download most online datasets in
    either or both of these formats. By working with these formats, you’ll be able
    to learn how to work with other data formats more easily as well.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你在处理CSV和JSON文件方面的经验积累，你将能够处理几乎任何你想分析的数据。你可以下载大多数在线数据集，并以这两种格式之一或两者兼有的方式获取。通过处理这些格式，你也将能够更轻松地学习如何处理其他数据格式。
- en: In the next chapter, you’ll write programs that automatically gather their own
    data from online sources, and then you’ll create visualizations of that data.
    These are fun skills to have if you want to program as a hobby and are critical
    skills if you’re interested in programming professionally.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将编写程序自动从在线来源收集数据，然后创建这些数据的可视化。如果你想把编程当作爱好，这些技能非常有趣；如果你有意从事编程职业，它们则是至关重要的技能。
