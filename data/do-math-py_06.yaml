- en: '**6**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**6**'
- en: '**Drawing Geometric Shapes and Fractals**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**绘制几何形状和分形**'
- en: '![image](images/common-01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/common-01.jpg)'
- en: In this chapter, we’ll start by learning about patches in matplotlib that allow
    us to draw geometric shapes, such as circles, triangles, and polygons. We’ll then
    learn about matplotlib’s animation support and write a program to animate a projectile’s
    trajectory. In the final section, we’ll learn how to draw *fractals*—complex geometric
    shapes created by the repeated applications of simple geometric transformations.
    Let’s get started!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章，我们将首先学习 matplotlib 中的 patches，它使我们能够绘制几何形状，例如圆形、三角形和多边形。然后我们将学习 matplotlib
    的动画支持，并编写一个程序来动画化投射物的轨迹。在最后一部分，我们将学习如何绘制 *分形*——通过反复应用简单的几何变换创造出的复杂几何形状。让我们开始吧！
- en: '**Drawing Geometric Shapes with Matplotlib’s Patches**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用 Matplotlib 的 Patches 绘制几何形状**'
- en: 'In matplotlib, *patches* allow us to draw geometric shapes, each of which we
    refer to as a *patch*. You can specify, for example, a circle’s radius and center
    in order to add the corresponding circle to your plot. This is quite different
    from how we’ve used matplotlib so far, which has been to supply the *x*- and *y*-coordinates
    of the points to plot. Before we can write a program to make use of the patches
    feature, however, we’ll need to understand a little bit more about how a matplotlib
    plot is created. Consider the following program, which plots the points (1, 1),
    (2, 2), and (3, 3) using matplotlib:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在 matplotlib 中，*patches* 使我们能够绘制几何形状，每个几何形状我们称之为一个 *patch*。例如，你可以指定一个圆的半径和中心，然后将相应的圆形添加到你的图表中。这与我们之前使用
    matplotlib 的方式有所不同，之前我们只是提供了要绘制点的 *x* 和 *y* 坐标。然而，在我们编写程序来利用 patches 特性之前，我们需要更深入地了解
    matplotlib 图表是如何创建的。考虑以下程序，它使用 matplotlib 绘制了点 (1, 1)、(2, 2) 和 (3, 3)：
- en: '>>> import matplotlib.pyplot as plt'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> import matplotlib.pyplot as plt'
- en: '>>> x = [1, 2, 3]'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x = [1, 2, 3]'
- en: '>>> y = [1, 2, 3]'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> y = [1, 2, 3]'
- en: '>>> plt.plot(x, y)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> plt.plot(x, y)'
- en: '[<matplotlib.lines.Line2D object at 0x7fe822d67a20>]'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[<matplotlib.lines.Line2D object at 0x7fe822d67a20>]'
- en: '>>> plt.show()'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> plt.show()'
- en: This program creates a matplotlib window that shows a line passing through the
    given points. Under the hood, when the plt.plot() function is called, a Figure
    object is created, within which the axes are created, and finally the data is
    plotted within the axes (see [Figure 6-1](ch06.html#ch6fig1)).[¹](footnote.html#fn03)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序创建了一个 matplotlib 窗口，显示了一条通过给定点的直线。在背后，当调用 plt.plot() 函数时，创建了一个 Figure 对象，在其中创建了坐标轴，最后数据在坐标轴中绘制（参见
    [图 6-1](ch06.html#ch6fig1)）。[¹](footnote.html#fn03)
- en: '![image](images/f06-01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f06-01.jpg)'
- en: '*Figure 6-1: Architecture of a matplotlib plot*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-1：Matplotlib 图表架构*'
- en: 'The following program re-creates this plot, but we’ll also explicitly create
    the Figure object and add axes to it, instead of just calling the plot() function
    and relying on it to create those:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序重新创建了这个图表，但我们将显式创建 Figure 对象并为其添加坐标轴，而不是仅仅调用 plot() 函数并依赖它来创建这些：
- en: '>>> import matplotlib.pyplot as plt'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> import matplotlib.pyplot as plt'
- en: '>>> x = [1, 2, 3]'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x = [1, 2, 3]'
- en: '>>> y = [1, 2, 3]'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> y = [1, 2, 3]'
- en: ➊ >>> fig = plt.figure()
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ >>> fig = plt.figure()
- en: ➋ >>> ax = plt.axes()
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ >>> ax = plt.axes()
- en: '>>> plt.plot(x, y)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> plt.plot(x, y)'
- en: '[<matplotlib.lines.Line2D object at 0x7f9bad1dcc18>]'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '[<matplotlib.lines.Line2D object at 0x7f9bad1dcc18>]'
- en: '>>> plt.show()'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> plt.show()'
- en: '>>>'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '>>>'
- en: Here, we create the Figure object using the figure() function at ➊, and then
    we create the axes using the axes() function at ➋. The axes() function also adds
    the axes to the Figure object. The last two lines are the same as in the earlier
    program. This time, when we call the plot() function, it sees that a Figure object
    with an Axes object already exists and directly proceeds to plot the data supplied
    to it.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 figure() 函数在 ➊ 创建了 Figure 对象，然后在 ➋ 使用 axes() 函数创建了坐标轴。axes() 函数也将坐标轴添加到
    Figure 对象中。最后两行与之前的程序相同。这次，当我们调用 plot() 函数时，它会看到已经存在一个带有坐标轴的 Figure 对象，并直接开始绘制提供的数据。
- en: Besides manually creating Figure and Axes objects, you can use two different
    functions in the pyplot module to get a reference to the current Figure and Axes
    objects. When you call the gcf() function, it returns a reference to the current
    Figure, and when you call the gca() function, it returns a reference to the current
    Axes. An interesting feature of these functions is that each will create the respective
    object if it doesn’t already exist. How these functions work will become clearer
    as we make use of them later in this chapter.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 除了手动创建Figure和Axes对象外，您还可以使用pyplot模块中的两个不同函数来获取当前Figure和Axes对象的引用。当您调用gcf()函数时，它会返回当前Figure的引用；当您调用gca()函数时，它会返回当前Axes的引用。一个有趣的特点是，如果这些对象还不存在，每个函数都会创建它们。随着我们在本章后续内容中的使用，您将会更清楚地理解这些函数的工作原理。
- en: '***Drawing a Circle***'
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***绘制圆形***'
- en: 'To draw a circle, you can add the Circle patch to the current Axes object,
    as demonstrated by the following example:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要绘制一个圆形，您可以将Circle补丁添加到当前的Axes对象中，以下例子演示了这一方法：
- en: ''''''''
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ''''''''
- en: Example of using matplotlib's Circle patch
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用matplotlib的Circle补丁示例
- en: ''''''''
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ''''''''
- en: import matplotlib.pyplot as plt
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: import matplotlib.pyplot as plt
- en: 'def create_circle():'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 'def create_circle():'
- en: ➊     circle = plt.Circle((0, 0), radius = 0.5)
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: ➊     circle = plt.Circle((0, 0), radius = 0.5)
- en: return circle
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: return circle
- en: 'def show_shape(patch):'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 'def show_shape(patch):'
- en: ➋     ax = plt.gca()
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ➋     ax = plt.gca()
- en: ax.add_patch(patch)
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: ax.add_patch(patch)
- en: plt.axis('scaled')
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: plt.axis('scaled')
- en: plt.show()
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: plt.show()
- en: 'if __name__ == ''__main__'':'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: ➌     c = create_circle()
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: ➌     c = create_circle()
- en: show_shape(c)
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: show_shape(c)
- en: 'In this program, we’ve separated the creation of the Circle patch object and
    the addition of the patch to the figure into two functions: create_circle() and
    show_shape(). In create_circle(), we make a circle with a center at (0, 0) and
    a radius of 0.5 by creating a Circle object with the coordinates of the center
    (0, 0) passed as a tuple and with the radius of 0.5 passed using the keyword argument
    of the same name at ➊. The function returns the created Circle object.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，我们将Circle补丁对象的创建与将补丁添加到图形中的操作分成了两个函数：create_circle()和show_shape()。在create_circle()函数中，我们通过创建一个Circle对象并传入中心坐标(0,
    0)作为元组，并使用相同名称的关键字参数radius传入半径0.5，来绘制一个圆形。该函数返回创建的Circle对象。
- en: The show_shape() function is written such that it will work with any matplotlib
    patch. It first gets a reference to the current Axes object using the gca() function
    at ➋. Then, it adds the patch passed to it using the add_patch() function and,
    finally, calls the show() function to display the figure. We call the axis() function
    here with the scaled parameter, which basically tells matplotlib to automatically
    adjust the axis limits. We’ll need to have this statement in all programs that
    use patches to automatically scale the axes. You can, of course, also specify
    fixed values for the limits, as we saw in [Chapter 2](ch02.html#ch02).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: show_shape()函数的编写方式是，它能够与任何matplotlib补丁一起工作。它首先通过在➋处使用gca()函数获取当前Axes对象的引用。然后，它使用add_patch()函数将传入的补丁添加到该对象，最后调用show()函数来显示图形。我们在这里调用了axis()函数，并使用了scaled参数，这基本上告诉matplotlib自动调整轴的限制。在所有使用补丁的程序中，我们都需要有这一语句来自动缩放坐标轴。当然，您也可以像在[第2章](ch02.html#ch02)中所见那样，指定固定的限制值。
- en: At ➌, we call the create_circle() function using the label c to refer to the
    returned Circle object. Then, we call the show_shape() function, passing c as
    an argument. When you run the program, you’ll see a matplotlib window showing
    the circle (see [Figure 6-2](ch06.html#ch6fig2)).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在➌处，我们调用create_circle()函数，并使用标签c来引用返回的Circle对象。然后，我们调用show_shape()函数，并将c作为参数传入。当您运行程序时，您将看到一个matplotlib窗口显示出圆形（见[图6-2](ch06.html#ch6fig2)）。
- en: '![image](images/f06-02.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f06-02.jpg)'
- en: '*Figure 6-2: A circle with a center of (0, 0) and radius of 0.5*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-2：一个中心在(0, 0)，半径为0.5的圆*'
- en: The circle doesn’t quite look like a circle here, as you can see. This is due
    to the automatic aspect ratio, which determines the ratio of the length of the
    *x*- and *y*-axes. If you insert the statement ax.set_aspect('equal') after ➋,
    you will see that the circle does indeed look like a circle. The set_aspect()
    function is used to set the aspect ratio of the graph; using the equal argument,
    we ask matplotlib to set the ratio of the length of the *x*- and *y*-axes to 1:1.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，圆形看起来并不像圆。这是由于自动的纵横比，它决定了*x*轴和*y*轴的长度比例。如果在➋之后插入语句ax.set_aspect('equal')，您会发现圆形确实变成了一个圆。set_aspect()函数用于设置图形的纵横比；使用equal参数，我们要求matplotlib将*x*轴和*y*轴的长度比例设置为1:1。
- en: Both the edge color and the face color (fill color) of the patch can be changed
    using the ec and fc keyword arguments. For example, passing fc='g' and ec='r'
    will create a circle with a green face color and red edge color.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 贴图的边缘颜色和面颜色（填充颜色）可以使用 ec 和 fc 关键字参数来更改。例如，传递 fc='g' 和 ec='r' 将创建一个面颜色为绿色、边缘颜色为红色的圆形。
- en: Matplotlib supports a number of other patches, such as Ellipse, Polygon, and
    Rectangle.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib 支持许多其他的图形对象，比如椭圆（Ellipse）、多边形（Polygon）和矩形（Rectangle）。
- en: '***Creating Animated Figures***'
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***创建动画图形***'
- en: Sometimes we may want to create figures with moving shapes. Matplotlib’s animation
    support will help us achieve this. At the end of this section, we’ll create an
    animated version of the projectile trajectory-drawing program.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们可能希望创建带有动态形状的图形。Matplotlib 的动画支持将帮助我们实现这一目标。在本节结束时，我们将创建一个动态版本的抛物线轨迹绘制程序。
- en: 'First, let’s see a simpler example. We’ll draw a matplotlib figure with a circle
    that starts off small and grows to a certain radius indefinitely (unless the matplotlib
    window is closed):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们来看一个更简单的例子。我们将绘制一个 matplotlib 图形，其中的圆形从小到大增长到一定半径（直到关闭 matplotlib 窗口为止）：
- en: ''''''''
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: ''''''''
- en: A growing circle
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一个正在增长的圆形
- en: ''''''''
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: ''''''''
- en: from matplotlib import pyplot as plt
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: from matplotlib import pyplot as plt
- en: from matplotlib import animation
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 从 matplotlib 导入 animation
- en: 'def create_circle():'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 'def create_circle():'
- en: circle = plt.Circle((0, 0), 0.05)
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: circle = plt.Circle((0, 0), 0.05)
- en: return circle
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: return circle
- en: 'def update_radius(i, circle):'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 'def update_radius(i, circle):'
- en: circle.radius = i*0.5
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: circle.radius = i*0.5
- en: return circle,
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: return circle,
- en: 'def create_animation():'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 'def create_animation():'
- en: ➊     fig = plt.gcf()
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ➊     fig = plt.gcf()
- en: ax = plt.axes(xlim=(-10, 10), ylim=(-10, 10))
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ax = plt.axes(xlim=(-10, 10), ylim=(-10, 10))
- en: ax.set_aspect('equal')
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ax.set_aspect('equal')
- en: circle = create_circle()
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: circle = create_circle()
- en: ➋     ax.add_patch(circle)
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ➋     ax.add_patch(circle)
- en: ➌     anim = animation.FuncAnimation(
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ➌     anim = animation.FuncAnimation(
- en: fig, update_radius, fargs = (circle,), frames=30, interval=50)
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: fig, update_radius, fargs = (circle,), frames=30, interval=50)
- en: plt.title('Simple Circle Animation')
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: plt.title('简单圆形动画')
- en: plt.show()
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: plt.show()
- en: 'if __name__ == ''__main__'':'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: create_animation()
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: create_animation()
- en: 'We start by importing the animation module from the matplotlib package. The
    create_animation() function carries out the core functionality here. It gets a
    reference to the current Figure object using the gcf() function at ➊ and then
    creates the axes with limits of –10 and 10 for both the *x*- and *y*-axes. After
    that, it creates a Circle object that represents a circle with a radius of 0.05
    and a center at (0, 0) and adds this circle to the current axes at ➋. Then, we
    create a FuncAnimation object ➌, which passes the following data about the animation
    we want to create:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先从 matplotlib 包中导入动画模块。create_animation() 函数执行核心功能。在 ➊ 处，它通过 gcf() 函数获取当前的
    Figure 对象引用，然后创建一个坐标轴，设置 x 轴和 y 轴的限制为 -10 到 10。接着，它创建一个 Circle 对象，表示一个半径为 0.05、中心点在
    (0, 0) 的圆形，并在 ➋ 处将其添加到当前的坐标轴中。然后，我们创建一个 FuncAnimation 对象 ➌，传递我们想要创建的动画的以下数据：
- en: fig This is the current Figure object.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: fig 这是当前的 Figure 对象。
- en: update_radius This function will be responsible for drawing *every* frame. It
    takes two arguments—a frame number that is automatically passed to it when called
    and the patch object that we want to update every frame. This function also must
    return the object.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: update_radius 这个函数将负责绘制*每一帧*。它接收两个参数——一个帧编号，系统在调用时会自动传递，另一个是我们希望每一帧更新的图形对象。这个函数还必须返回该对象。
- en: fargs This tuple consists of all the arguments to be passed to the update_radius()
    function other than the frame number. If there are no such arguments to pass,
    this keyword argument need not be specified.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: fargs 这个元组包含传递给 update_radius() 函数的所有参数，除了帧编号。如果没有需要传递的参数，可以不指定此关键字参数。
- en: frames This is the number of frames in the animation. Our function update_radius()
    is called this many times. Here, we’ve arbitrarily chosen 30 frames.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: frames 这是动画中的帧数。我们的 update_radius() 函数会被调用这么多次。在这里，我们随便选择了 30 帧。
- en: interval This is the time interval in milliseconds between two frames. If your
    animation seems too slow, decrease this value; if it seems too fast, increase
    this value.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: interval 这是两个帧之间的时间间隔，单位是毫秒。如果你的动画感觉太慢，可以减少这个值；如果感觉太快，可以增加这个值。
- en: We then set a title using the title() function and, finally, show the figure
    using the show() function.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用 title() 函数设置标题，最后使用 show() 函数显示图形。
- en: As mentioned earlier, the update_radius() function is responsible for updating
    the property of the circle that will change each frame. Here, we set the radius
    to i*0.5, where i is the frame number. As a result, you see a circle that grows
    every frame for 30 frames—thus, the radius of the largest circle is 15\. Because
    the axes’ limits are set at –10 and 10, this gives the effect of the circle exceeding
    the figure’s dimensions. When you run the program, you’ll see your first animated
    figure, as shown in [Figure 6-3](ch06.html#ch6fig3).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，update_radius()函数负责更新每一帧会变化的圆圈属性。在这里，我们将半径设置为i*0.5，其中i是帧数。因此，你会看到一个每帧增长的圆圈，持续30帧——因此，最大圆圈的半径为15。由于坐标轴的限制设置为-10到10，这会给圆圈超出图像尺寸的效果。当你运行程序时，你将看到你的第一个动画图形，如[图6-3](ch06.html#ch6fig3)所示。
- en: You’ll notice that the animation continues until you close the matplotlib window.
    This is the default behavior, which you can change by setting the keyword argument
    to repeat=False when you create the FuncAnimation object.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到动画会持续运行，直到你关闭matplotlib窗口。这是默认行为，你可以通过在创建FuncAnimation对象时将关键词参数设置为repeat=False来改变这一行为。
- en: '![image](images/f06-03.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f06-03.jpg)'
- en: '*Figure 6-3: Simple circle animation*'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-3：简单的圆圈动画*'
- en: '**FUNCANIMATION OBJECT AND PERSISTENCE**'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**FUNCANIMATION对象与持久性**'
- en: You probably noted in the animated circle program that we assigned the created
    FuncAnimation object to the label anim even though we don’t use it again elsewhere.
    This is because of an issue with matplotlib’s current behavior—it doesn’t store
    any reference to the FuncAnimation object, making it subject to garbage collection
    by Python. This means the animation will not be created. Creating a label referring
    to the object prevents this from happening.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，在动画圆圈程序中，尽管我们没有在其他地方再次使用它，我们仍然将创建的FuncAnimation对象分配给标签anim。这是由于matplotlib当前的行为问题——它并不会存储对FuncAnimation对象的任何引用，这使得该对象会被Python的垃圾回收机制回收。这意味着动画不会被创建。通过创建一个指向该对象的标签可以防止这种情况发生。
- en: For more on this issue, you may want to follow the discussions at *[https://github.com/matplotlib/matplotlib/issues/1656/](https://github.com/matplotlib/matplotlib/issues/1656/)*.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 有关此问题的更多信息，您可以关注讨论：[https://github.com/matplotlib/matplotlib/issues/1656/](https://github.com/matplotlib/matplotlib/issues/1656/)。
- en: '***Animating a Projectile’s Trajectory***'
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***动画化抛射物体的轨迹***'
- en: 'In [Chapter 2](ch02.html#ch02), we drew the trajectory for a ball in projectile
    motion. Here, we’ll build upon this drawing, making use of matplotlib’s animation
    support to animate the trajectory so that it will come closer to demonstrating
    how you’d see a ball travel in real life:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html#ch02)中，我们画出了一个抛射物体的轨迹图。在这里，我们将在此基础上进行扩展，利用matplotlib的动画功能来为轨迹加上动画效果，从而更接近地展示现实中你看到一个球体运动的样子：
- en: ''''''''
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ''''''''
- en: Animate the trajectory of an object in projectile motion
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 动画演示一个物体的抛射运动轨迹
- en: ''''''''
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ''''''''
- en: from matplotlib import pyplot as plt
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: from matplotlib import pyplot as plt
- en: from matplotlib import animation
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: from matplotlib import animation
- en: import math
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: import math
- en: g = 9.8
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: g = 9.8
- en: 'def get_intervals(u, theta):'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 'def get_intervals(u, theta):'
- en: t_flight = 2*u*math.sin(theta)/g
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: t_flight = 2*u*math.sin(theta)/g
- en: intervals = []
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: intervals = []
- en: start = 0
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: start = 0
- en: interval = 0.005
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: interval = 0.005
- en: 'while start < t_flight:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 'while start < t_flight:'
- en: intervals.append(start)
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: intervals.append(start)
- en: start = start + interval
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: start = start + interval
- en: return intervals
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: return intervals
- en: 'def update_position(i, circle, intervals, u, theta):'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 'def update_position(i, circle, intervals, u, theta):'
- en: t = intervals[i]
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: t = intervals[i]
- en: x = u*math.cos(theta)*t
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: x = u*math.cos(theta)*t
- en: y = u*math.sin(theta)*t - 0.5*g*t*t
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: y = u*math.sin(theta)*t - 0.5*g*t*t
- en: circle.center = x, y
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: circle.center = x, y
- en: return circle,
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: return circle,
- en: 'def create_animation(u, theta):'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 'def create_animation(u, theta):'
- en: intervals = get_intervals(u, theta)
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: intervals = get_intervals(u, theta)
- en: xmin = 0
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: xmin = 0
- en: xmax = u*math.cos(theta)*intervals[-1]
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: xmax = u*math.cos(theta)*intervals[-1]
- en: ymin = 0
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ymin = 0
- en: t_max = u*math.sin(theta)/g
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: t_max = u*math.sin(theta)/g
- en: ➊     ymax = u*math.sin(theta)*t_max - 0.5*g*t_max**2
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ➊     ymax = u*math.sin(theta)*t_max - 0.5*g*t_max**2
- en: fig = plt.gcf()
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: fig = plt.gcf()
- en: ➋     ax = plt.axes(xlim=(xmin, xmax), ylim=(ymin, ymax))
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ➋     ax = plt.axes(xlim=(xmin, xmax), ylim=(ymin, ymax))
- en: circle = plt.Circle((xmin, ymin), 1.0)
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: circle = plt.Circle((xmin, ymin), 1.0)
- en: ax.add_patch(circle)
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: ax.add_patch(circle)
- en: ➌     anim = animation.FuncAnimation(fig, update_position,
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ➌     anim = animation.FuncAnimation(fig, update_position,
- en: fargs=(circle, intervals, u, theta),
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: fargs=(circle, intervals, u, theta),
- en: frames=len(intervals), interval=1,
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: frames=len(intervals), interval=1,
- en: repeat=False)
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: repeat=False)
- en: plt.title('Projectile Motion')
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: plt.title('抛射运动')
- en: plt.xlabel('X')
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: plt.xlabel('X')
- en: plt.ylabel('Y')
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: plt.ylabel('Y')
- en: plt.show()
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: plt.show()
- en: 'if __name__ == ''__main__'':'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: 'try:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 'try:'
- en: u = float(input('Enter the initial velocity (m/s): '))
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: u = float(input('请输入初始速度（m/s）：'))
- en: theta = float(input('Enter the angle of projection (degrees): '))
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: theta = float(input('请输入投射角度（度）：'))
- en: 'except ValueError:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 'except ValueError:'
- en: print('You entered an invalid input')
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: print('你输入了无效的内容')
- en: 'else:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: theta = math.radians(theta)
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: theta = math.radians(theta)
- en: create_animation(u, theta)
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: create_animation(u, theta)
- en: 'The create_animation() function accepts two arguments: u and theta. These arguments
    correspond to the initial velocity and the angle of projection (*θ*), which were
    supplied as input to the program. The get_intervals() function is used to find
    the time intervals at which to calculate the *x*- and *y*-coordinates. This function
    is implemented by making use of the same logic we used in [Chapter 2](ch02.html#ch02),
    when we implemented a separate function, frange(), to help us.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: create_animation()函数接受两个参数：u和theta。这些参数对应于程序输入的初速度和投射角度（*θ*）。get_intervals()函数用于找出计算*x*和*y*坐标的时间间隔。这个函数的实现借用了我们在[第2章](ch02.html#ch02)中所使用的相同逻辑，当时我们实现了一个独立的函数frange()来帮助我们。
- en: To set up the axis limits for the animation, we’ll need to find the minimum
    and maximum values of *x* and *y*. The minimum value for each is 0, which is the
    initial value for each. The maximum value of the *x*-coordinate is the value of
    the coordinate at the end of the flight of the ball, which is the last time interval
    in the list intervals. The maximum value of the *y*-coordinate is when the ball
    is at its highest point—that is, at ➊, where we calculate that point using the
    formula
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置动画的坐标轴范围，我们需要找到*x*和*y*的最小值和最大值。每个坐标的最小值为0，这是它们的初始值。*x*坐标的最大值是小球飞行结束时的坐标值，也就是列表intervals中最后一个时间间隔时的值。*y*坐标的最大值是小球处于最高点时的坐标，也就是在➊处，我们使用公式计算该点。
- en: '![image](images/e0157-01.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/e0157-01.jpg)'
- en: Once we have the values, we create the axes at ➋, passing the appropriate axis
    limits. In the next two statements, we create a representation of the ball and
    add it to the figure’s Axes object by creating a circle of radius 1.0 at (xmin,
    ymin)—the minimum coordinates of the *x*- and *y*-axes, respectively.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦获得了这些值，我们在➋创建坐标轴，并传入适当的坐标轴范围。在接下来的两条语句中，我们创建了一个表示小球的图形，并通过在(xmin, ymin)—*x*轴和*y*轴的最小坐标位置创建半径为1.0的圆形，将其添加到图形的Axes对象中。
- en: 'We then create the FuncAnimation object ➌, supplying it with the current figure
    object and the following arguments:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们创建了FuncAnimation对象 ➌，并将当前图形对象以及以下参数传递给它：
- en: update_position This function will change the center of the circle in each frame.
    The idea here is that a new frame is created for every time interval, so we set
    the number of frames to the size of the time intervals (see the description of
    frames in this list). We calculate the *x*-and *y*-coordinates of the ball at
    the time instant at the ith time interval, and we set the center of the circle
    to these values.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: update_position 这个函数将在每一帧中改变圆的中心。这里的想法是，每个时间间隔都会创建一帧，因此我们将帧的数量设置为时间间隔的大小（请参阅此列表中的帧描述）。我们计算小球在第i个时间间隔时刻的*x*和*y*坐标，并将圆心设置为这些值。
- en: fargs The update_position() function needs to access the list of time intervals,
    intervals, initial velocity, and theta, which are specified using this keyword
    argument.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: fargs update_position()函数需要访问时间间隔列表intervals、初速度和theta，这些通过此关键字参数指定。
- en: frames Because we’ll draw one frame per time interval, we set the number of
    frames to the size of the intervals list.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: frames 由于我们每个时间间隔绘制一帧，因此我们将帧的数量设置为intervals列表的大小。
- en: repeat As we discussed in the first animation example, animation repeats indefinitely
    by default. We don’t want that to happen in this case, so we set this keyword
    to False.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: repeat 正如我们在第一个动画示例中所讨论的，动画默认会无限重复。在本例中我们不希望出现这种情况，因此将此关键字设置为False。
- en: When you run the program, it asks for the initial inputs and then creates the
    animation, as shown in [Figure 6-4](ch06.html#ch6fig4).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行程序时，它会要求输入初始数据，然后创建动画，如[图6-4](ch06.html#ch6fig4)所示。
- en: '![image](images/f06-04.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f06-04.jpg)'
- en: '*Figure 6-4: Animation of the trajectory of a projectile*'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-4：投射物轨迹的动画*'
- en: '**Drawing Fractals**'
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**绘制分形图**'
- en: Fractals are complex geometric patterns or shapes arising out of surprisingly
    simple mathematical formulas. Compared to geometric shapes, such as circles and
    rectangles, a fractal seems irregular and without any obvious pattern or description,
    but if you look closely, you see that patterns emerge and the entire shape is
    composed of numerous copies of itself. Because fractals involve the repetitive
    application of the same *geometric transformation* of points in a plane, computer
    programs are well-suited to create them. In this chapter, we’ll learn how to draw
    the Barnsley fern, the Sierpiński triangle, and the Mandelbrot set (the latter
    two in the challenges)— popular examples of fractals studied in the field. Fractals
    abound in nature, too—popular examples include coastlines, trees, and snowflakes.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 分形是由出人意料的简单数学公式生成的复杂几何图案或形状。与圆形和矩形等几何形状相比，分形看起来不规则，似乎没有任何明显的模式或描述，但如果仔细观察，你会发现图案在显现，整个形状是由无数个自身的复制组成的。由于分形涉及对平面中点进行相同*几何变换*的重复应用，计算机程序非常适合用来生成它们。在本章中，我们将学习如何绘制巴恩斯利蕨、谢尔宾斯基三角形和曼德尔布罗集合（后两者在挑战部分）——这些都是分形研究领域中的流行示例。自然界中也充满了分形——一些常见示例包括海岸线、树木和雪花。
- en: '***Transformations of Points in a Plane***'
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***平面中的点变换***'
- en: A basic idea in creating fractals is that of the transformation of a point.
    Given a point, *P*(*x*, *y*), in an *x*-*y* plane, an example of a transformation
    is *P* (*x*, *y*) → *Q* (*x* + 1, *y* + 1), which means that after applying the
    transformation, a new point, *Q*, which is one unit above and one unit to the
    right of *P*, is created. If you then consider *Q* as the starting point, you’ll
    get another point, *R*, that’s one unit above and one unit to the right of *Q*.
    Consider the starting point, *P*, to be (1, 1). [Figure 6-5](ch06.html#ch6fig5)
    shows what the points would look like.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 创建分形的基本思想之一是点的变换。给定一个点，*P*(*x*, *y*)，在 *x*-*y* 平面中，一个变换的例子是 *P* (*x*, *y*) →
    *Q* (*x* + 1, *y* + 1)，这意味着应用变换后，会生成一个新的点 *Q*，该点位于 *P* 的右上方一单位。如果你将 *Q* 作为起始点，就会得到另一个点
    *R*，该点位于 *Q* 的右上方一单位。假设起始点 *P* 为 (1, 1)。[图 6-5](ch06.html#ch6fig5) 展示了这些点的样子。
- en: '![image](images/f06-05.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f06-05.jpg)'
- en: '*Figure 6-5: The points* Q *and* R *have been obtained by applying a transformation
    to the point* P *for two iterations.*'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-5：点* Q *和* R *是通过对点* P *进行两次迭代变换得到的。*'
- en: 'This transformation is, thus, a rule describing how a point moves around in
    the *x*-*y* plane, starting from an initial position and moving to a different
    point at each iteration. We can think of a transformation as the point’s *trajectory*
    in the plane. Now, consider that instead of one transformation rule, there are
    two such rules and one of these transformations is picked at *random* at every
    step. Let’s consider these rules:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这种变换是一个规则，描述了一个点如何在 *x*-*y* 平面中移动，从初始位置开始，在每次迭代时移动到不同的点。我们可以将变换看作是点在平面中的*轨迹*。现在，考虑到不仅仅有一个变换规则，而是有两个变换规则，并且在每一步中会随机选择其中一个变换。让我们考虑这些规则：
- en: 'Rule 1: *P* 1 (*x*, *y*) → *P* 2 (*x* + 1, *y* – 1)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 规则 1：*P* 1 (*x*, *y*) → *P* 2 (*x* + 1, *y* – 1)
- en: 'Rule 2: *P* 1 (*x*, *y*) → *P* 2 (*x* + 1, *y* + 1)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 规则 2：*P* 1 (*x*, *y*) → *P* 2 (*x* + 1, *y* + 1)
- en: 'Consider *P*1(1, 1) to be the starting point. If we carry out four iterations,
    we could have the following sequence of points:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 *P*1(1, 1) 为起始点。如果我们进行四次迭代，得到的点序列如下：
- en: '*P* 1 (1, 1) → *P* 2 (2, 0) (Rule 1)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*P* 1 (1, 1) → *P* 2 (2, 0) （规则 1）'
- en: '*P* 2 (2, 0) → *P* 3 (3, 1) (Rule 2)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '*P* 2 (2, 0) → *P* 3 (3, 1) （规则 2）'
- en: '*P* 3 (3, 1) → *P* 4 (4, 2) (Rule 2)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '*P* 3 (3, 1) → *P* 4 (4, 2) （规则 2）'
- en: '*P* 4 (4, 2) → *P* 5 (5, 1) (Rule 1)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*P* 4 (4, 2) → *P* 5 (5, 1) （规则 1）'
- en: '... and so on.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: …等等。
- en: 'The transformation rule is picked at random, with each rule having an equal
    probability of being selected. No matter which one is picked, the points will
    advance toward the right because we increase the *x*-coordinate in both cases.
    As the points go to the right, they move either up or down, thus creating a zigzag
    path. The following program charts out the path of a point when subjected to one
    of these transformations for a specified number of iterations:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 变换规则是随机选择的，每个规则被选择的概率相等。无论选择哪一个，点都会向右移动，因为在两种情况下我们都增加了 *x* 坐标。随着点向右移动，它们要么向上移动，要么向下移动，从而形成一个之字形路径。以下程序绘制了一个点在经过指定次数的变换迭代后所经过的路径：
- en: ''''''''
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: ''''''''
- en: Example of selecting a transformation from two equally probable
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 从两个等概率的变换中选择一个的示例
- en: transformations
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 变换
- en: ''''''''
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: ''''''''
- en: import matplotlib.pyplot as plt
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: import matplotlib.pyplot as plt
- en: import random
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: import random
- en: 'def transformation_1(p):'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 'def transformation_1(p):'
- en: x = p[0]
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: x = p[0]
- en: y = p[1]
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: y = p[1]
- en: return x + 1, y - 1
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: return x + 1, y - 1
- en: 'def transformation_2(p):'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 'def transformation_2(p):'
- en: x = p[0]
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: x = p[0]
- en: y = p[1]
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: y = p[1]
- en: return x + 1, y + 1
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: return x + 1, y + 1
- en: 'def transform(p):'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 'def transform(p):'
- en: ➊     # List of transformation functions
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '➊     # 变换函数列表'
- en: transformations = [transformation_1, transformation_2]
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: transformations = [transformation_1, transformation_2]
- en: '# Pick a random transformation function and call it'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '# 随机选择一个变换函数并调用它'
- en: ➋     t = random.choice(transformations)
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: ➋     t = random.choice(transformations)
- en: ➌     x, y = t(p)
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: ➌     x, y = t(p)
- en: return x, y
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: return x, y
- en: 'def build_trajectory(p, n):'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 'def build_trajectory(p, n):'
- en: x = [p[0]]
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: x = [p[0]]
- en: y = [p[1]]
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: y = [p[1]]
- en: 'for i in range(n):'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(n):'
- en: p = transform(p)
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: p = transform(p)
- en: x.append(p[0])
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: x.append(p[0])
- en: y.append(p[1])
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: y.append(p[1])
- en: return x, y
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: return x, y
- en: 'if __name__ == ''__main__'':'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: '# Initial point'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '# 初始点'
- en: p = (1, 1)
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: p = (1, 1)
- en: n = int(input('Enter the number of iterations: '))
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 'n = int(input(''请输入迭代次数: ''))'
- en: ➍     x, y = build_trajectory(p, n)
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ➍     x, y = build_trajectory(p, n)
- en: '# Plot'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '# 绘图'
- en: ➎     plt.plot(x, y)
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ➎     plt.plot(x, y)
- en: plt.xlabel('X')
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: plt.xlabel('X')
- en: plt.ylabel('Y')
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: plt.ylabel('Y')
- en: plt.show()
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: plt.show()
- en: We define two functions, transformation_1() and transformation_2(), corresponding
    to the two preceding transformations. In the transform() function, we create a
    list with these two function names at ➊ and use the random.choice() function to
    pick one of the transformations from the list at ➋. Now that we’ve picked the
    transformation to apply, we call it with the point, *P*, and store the coordinates
    of the transformed point in the labels x, y ➌ and return them.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了两个函数，transformation_1()和transformation_2()，分别对应前面提到的两个变换。在transform()函数中，我们创建一个包含这两个函数名的列表
    ➊，然后使用random.choice()函数从列表中随机选择一个变换 ➋。现在我们已经选定了要应用的变换，调用它，并将变换后点的坐标存入x、y标签 ➌，并返回这些坐标。
- en: '**SELECTING A RANDOM ELEMENT FROM A LIST**'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**从列表中随机选择一个元素**'
- en: 'The random.choice() function we saw in our first fractal program can be used
    to select a random element from a list. Each element has an *equal* chance of
    being returned. Here’s an example:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第一个分形程序中看到的random.choice()函数可以用来从列表中随机选择一个元素。每个元素都有 *相等* 的机会被返回。以下是一个例子：
- en: '>>> import random'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> import random'
- en: '>>> l = [1, 2, 3]'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> l = [1, 2, 3]'
- en: '>>> random.choice(l)'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> random.choice(l)'
- en: '3'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: '>>> random.choice(l)'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> random.choice(l)'
- en: '1'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '>>> random.choice(l)'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> random.choice(l)'
- en: '1'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '>>> random.choice(l)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> random.choice(l)'
- en: '3'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: '>>> random.choice(l)'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> random.choice(l)'
- en: '3'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: '>>> random.choice(l)'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> random.choice(l)'
- en: '2'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: The function also works with tuples and strings. In the latter case, it returns
    a random character from the string.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数也适用于元组和字符串。在后者情况下，它会返回字符串中的一个随机字符。
- en: When you run the program, it asks you for the number of iterations, n—that is,
    the number of times the transformation would be applied. Then, it calls the build_trajectory()
    function with n and the initial point, *P*, which is set to (1, 1) ➍. The build_trajectory()
    function repeatedly calls the transform() function n times, using two lists, x
    and y, to store the *x*-coordinate and *y*-coordinate of all the transformed points.
    Finally, it returns the two lists, which are then plotted ➎.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行程序时，它会要求你输入迭代次数 n——也就是变换应用的次数。接着，它会调用build_trajectory()函数，传入n和初始点 *P*，默认设置为(1,
    1) ➍。build_trajectory()函数会重复调用transform()函数n次，使用两个列表x和y来存储所有变换点的 *x* 坐标和 *y* 坐标。最后，它会返回这两个列表，之后会进行绘制
    ➎。
- en: '[Figures 6-6](ch06.html#ch6fig6) and [6-7](ch06.html#ch6fig7) show the trajectory
    of the point for 100 and 10,000 iterations, respectively. The zigzag motion is
    quite apparent in both figures. This zigzag path is usually referred to as a *random
    walk on a line*.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-6](ch06.html#ch6fig6)和[图6-7](ch06.html#ch6fig7)分别展示了点的轨迹在100次和10,000次迭代后的变化。这种锯齿形的运动在两张图中都非常明显。这个锯齿路径通常被称为
    *随机漫步*。'
- en: '![image](images/f06-06.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f06-06.jpg)'
- en: '*Figure 6-6: The zigzag path traced by the point (1, 1) when subjected to one
    or the other of the two transformations randomly for 100 iterations*'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-6：点（1, 1）在经历两个变换之一随机作用100次后的锯齿路径*'
- en: '![image](images/f06-07.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f06-07.jpg)'
- en: '*Figure 6-7: The zigzag path traced by the point (1, 1) when subjected to one
    or the other of the two transformations randomly for 10,000 iterations.*'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-7：点（1, 1）在经历两个变换之一随机作用10,000次后的锯齿路径*'
- en: This example demonstrates a basic idea in creating fractals—starting from an
    initial point and applying a transformation to that point repeatedly. Next, we’ll
    see an example of applying the same ideas to draw the *Barnsley fern*.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了创建分形的基本思想——从一个初始点开始，反复应用一个变换到该点。接下来，我们将看到应用相同思想来绘制*巴恩斯利蕨*的例子。
- en: '***Drawing the Barnsley Fern***'
  id: totrans-236
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***绘制巴恩斯利蕨***'
- en: The British mathematician Michael Barnsley described how to create fern-like
    structures using repeated applications of a simple transformation on a point (see
    [Figure 6-8](ch06.html#ch6fig8)).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 英国数学家迈克尔·巴恩斯利描述了如何通过对一个点反复应用简单的变换来创建蕨类植物的结构（见[图 6-8](ch06.html#ch6fig8)）。
- en: '![image](images/f06-08.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f06-08.jpg)'
- en: '*Figure 6-8: Lady ferns[²](footnote.html#fn04)*'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-8：女士蕨[²](footnote.html#fn04)*'
- en: 'He proposed the following steps to create fern-like structures: start with
    the point (0, 0) and *randomly* select one of the following transformations with
    the assigned *probability*:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 他提出了以下步骤来创建类似蕨类植物的结构：从点 (0, 0) 开始，并*随机*选择以下变换之一，选择的*概率*如下：
- en: '**Transformation 1** (0.85 probability):'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '**变换 1**（0.85 概率）：'
- en: '*x*[*n*+1] = 0.85*x[n]* + 0.04*y[n]*'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '*x*[*n*+1] = 0.85*x[n]* + 0.04*y[n]*'
- en: '*y*[*n*+1] = –0.04*y[n]* + 0.85*y[n]* + 1.6'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '*y*[*n*+1] = –0.04*y[n]* + 0.85*y[n]* + 1.6'
- en: '**Transformation 2** (0.07 probability):'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '**变换 2**（0.07 概率）：'
- en: '*x*[*n*+1] = 0.2*x[n]* – 0.26*y[n]*'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '*x*[*n*+1] = 0.2*x[n]* – 0.26*y[n]*'
- en: '*y*[*n*+1] = 0.23*y[n]* + 0.22*y[n]* + 1.6'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '*y*[*n*+1] = 0.23*y[n]* + 0.22*y[n]* + 1.6'
- en: '**Transformation 3** (0.07 probability):'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '**变换 3**（0.07 概率）：'
- en: '*x*[*n*+1] = –0.15*x[n]* – 0.28*x[n]*'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '*x*[*n*+1] = –0.15*x[n]* – 0.28*x[n]*'
- en: '*y*[*n*+1] = 0.26*y[n]* + 0.24*y[n]* + 0.44'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '*y*[*n*+1] = 0.26*y[n]* + 0.24*y[n]* + 0.44'
- en: '**Transformation 4** (0.01 probability):'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '**变换 4**（0.01 概率）：'
- en: '*x*[*n*+1] = 0'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '*x*[*n*+1] = 0'
- en: '*y*[*n*+1] = 0.16*y[n]*'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '*y*[*n*+1] = 0.16*y[n]*'
- en: Each of these transformations is responsible for creating a part of the fern.
    The first transformation selected with the highest probability—and hence the maximum
    number of times—creates the stem and the bottom fronds of the fern. The second
    and third transformations create the bottom frond on the left and the right, respectively,
    and the fourth transformation creates the stem of the fern.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 每个变换负责创建蕨类植物的一部分。第一个变换由于具有最高的概率——因此最多的次数——创建了蕨类植物的茎部和底部叶片。第二个和第三个变换分别创建了左侧和右侧的底部叶片，而第四个变换则创建了蕨类植物的茎部。
- en: 'This is an example of nonuniform probabilistic selection, which we first learned
    about in [Chapter 5](ch05.html#ch05). The following program draws the Barnsley
    fern for the specified number of points:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这是非均匀概率选择的一个例子，我们在[第5章](ch05.html#ch05)首次了解了这个概念。以下程序绘制了指定数量点的巴恩斯利蕨：
- en: ''''''''
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: ''''''''
- en: Draw a Barnsley Fern
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制巴恩斯利蕨
- en: ''''''''
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: ''''''''
- en: import random
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: import random
- en: import matplotlib.pyplot as plt
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: import matplotlib.pyplot as plt
- en: 'def transformation_1(p):'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 'def transformation_1(p):'
- en: x = p[0]
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: x = p[0]
- en: y = p[1]
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: y = p[1]
- en: x1 = 0.85*x + 0.04*y
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: x1 = 0.85*x + 0.04*y
- en: y1 = -0.04*x + 0.85*y + 1.6
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: y1 = -0.04*x + 0.85*y + 1.6
- en: return x1, y1
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: return x1, y1
- en: 'def transformation_2(p):'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 'def transformation_2(p):'
- en: x = p[0]
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: x = p[0]
- en: y = p[1]
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: y = p[1]
- en: x1 = 0.2*x - 0.26*y
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: x1 = 0.2*x - 0.26*y
- en: y1 = 0.23*x + 0.22*y + 1.6
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: y1 = 0.23*x + 0.22*y + 1.6
- en: return x1, y1
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: return x1, y1
- en: 'def transformation_3(p):'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 'def transformation_3(p):'
- en: x = p[0]
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: x = p[0]
- en: y = p[1]
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: y = p[1]
- en: x1 = -0.15*x + 0.28*y
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: x1 = -0.15*x + 0.28*y
- en: y1 = 0.26*x + 0.24*y + 0.44
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: y1 = 0.26*x + 0.24*y + 0.44
- en: return x1, y1
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: return x1, y1
- en: 'def transformation_4(p):'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 'def transformation_4(p):'
- en: x = p[0]
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: x = p[0]
- en: y = p[1]
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: y = p[1]
- en: x1 = 0
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: x1 = 0
- en: y1 = 0.16*y
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: y1 = 0.16*y
- en: return x1, y1
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: return x1, y1
- en: 'def get_index(probability):'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 'def get_index(probability):'
- en: r = random.random()
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: r = random.random()
- en: c_probability = 0
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: c_probability = 0
- en: sum_probability = []
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: sum_probability = []
- en: 'for p in probability:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 'for p in probability:'
- en: c_probability += p
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: c_probability += p
- en: sum_probability.append(c_probability)
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: sum_probability.append(c_probability)
- en: 'for item, sp in enumerate(sum_probability):'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 'for item, sp in enumerate(sum_probability):'
- en: 'if r <= sp:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: if r <= sp
- en: return item
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: return item
- en: return len(probability)-1
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: return len(probability)-1
- en: 'def transform(p):'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 'def transform(p):'
- en: '# List of transformation functions'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '# 变换函数列表'
- en: transformations = [transformation_1, transformation_2,
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: transformations = [transformation_1, transformation_2,
- en: transformation_3, transformation_4]
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: transformation_3, transformation_4]
- en: ➊     probability = [0.85, 0.07, 0.07, 0.01]
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: ➊      probability = [0.85, 0.07, 0.07, 0.01]
- en: '# Pick a random transformation function and call it'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '# 随机选择一个变换函数并调用它'
- en: tindex = get_index(probability)
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: tindex = get_index(probability)
- en: ➋     t = transformations[tindex]
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: ➋      t = transformations[tindex]
- en: x, y = t(p)
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: x, y = t(p)
- en: return x, y
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: return x, y
- en: 'def draw_fern(n):'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 'def draw_fern(n):'
- en: '# We start with (0, 0)'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '# 我们从 (0, 0) 开始'
- en: x = [0]
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: x = [0]
- en: y = [0]
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: y = [0]
- en: x1, y1 = 0, 0
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: x1, y1 = 0, 0
- en: 'for i in range(n):'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(n):'
- en: x1, y1 = transform((x1, y1))
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: x1, y1 = transform((x1, y1))
- en: x.append(x1)
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: x.append(x1)
- en: y.append(y1)
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: y.append(y1)
- en: return x, y
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: return x, y
- en: 'if __name__ == ''__main__'':'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: n = int(input('Enter the number of points in the Fern: '))
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: n = int(input('请输入蕨类植物的点数：'))
- en: x, y = draw_fern(n)
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: x, y = draw_fern(n)
- en: '# Plot the points'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '# 绘制点'
- en: plt.plot(x, y, 'o')
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: plt.plot(x, y, 'o')
- en: plt.title('Fern with {0} points'.format(n))
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: plt.title('蕨类植物，点数为{0}'.format(n))
- en: plt.show()
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: plt.show()
- en: When you run this program, it asks for the number of points in the fern to be
    specified and then creates the fern. [Figures 6-9](ch06.html#ch6fig9) and [6-10](ch06.html#ch6fig10)
    show ferns with 1,000 and 10,000 points, respectively.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个程序时，它会要求你指定蕨类植物的点数，并随后创建出蕨类植物。 [图6-9](ch06.html#ch6fig9) 和 [6-10](ch06.html#ch6fig10)
    分别展示了包含1000个和10000个点的蕨类植物。
- en: '![image](images/f06-09.jpg)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f06-09.jpg)'
- en: '*Figure 6-9: A fern with 1,000 points*'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-9：含有1000个点的蕨类植物*'
- en: '![image](images/f06-10.jpg)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f06-10.jpg)'
- en: '*Figure 6-10: A fern with 10,000 points*'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-10：含有10000个点的蕨类植物*'
- en: The four transformation rules are defined in the transformation_1(), transformation_2(),
    transformation_3(), and transformation_4() functions. The probability of each
    being selected is declared in a list at ➊, and then one of them is selected ➋
    to be applied every time the transform() function is called by the draw_fern()
    function.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 四个变换规则分别在 transformation_1()、transformation_2()、transformation_3() 和 transformation_4()
    函数中定义。每个规则被选中的概率在➊处的列表中声明，然后每次调用 draw_fern() 函数时，transform() 函数都会应用其中的一个变换。
- en: The number of times the initial point (0, 0) is transformed is the same as the
    number of points in the fern specified as input to the program.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 初始点 (0, 0) 被变换的次数与作为程序输入的蕨类植物点数相同。
- en: '**What You Learned**'
  id: totrans-329
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started by learning how to draw basic geometric shapes
    and how to animate them. This process introduced you to a number of new matplotlib
    features. You then learned about geometric transformations and saw how repetitive
    simple transformations help you draw complex geometric shapes called *fractals*.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你首先学习了如何绘制基本的几何形状以及如何为它们添加动画。这个过程让你了解了许多新的 matplotlib 功能。接着，你学习了几何变换，并看到了如何通过重复简单的变换帮助你绘制复杂的几何形状——被称为*分形*。
- en: '**Programming Challenges**'
  id: totrans-331
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**编程挑战**'
- en: Here are a few programming challenges that should help you further apply what
    you’ve learned. You can find sample solutions at *[http://www.nostarch.com/doingmathwithpython/](http://www.nostarch.com/doingmathwithpython/)*.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些编程挑战，应该能帮助你进一步应用所学内容。你可以在 *[http://www.nostarch.com/doingmathwithpython/](http://www.nostarch.com/doingmathwithpython/)*
    找到示例解答。
- en: '***#1: Packing Circles into a Square***'
  id: totrans-333
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***#1: 将圆形装入正方形***'
- en: 'I mentioned earlier that matplotlib supports the creation of other geometric
    shapes. The Polygon patch is especially interesting, as it allows you to draw
    polygons with different numbers of sides. Here’s how we can draw a square (each
    side of length 4):'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到过，matplotlib 支持创建其他几何形状。多边形补丁尤其有趣，因为它允许你绘制具有不同边数的多边形。下面是我们如何绘制一个正方形（每边长度为4）：
- en: ''''''''
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: ''''''''
- en: Draw a square
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制一个正方形
- en: ''''''''
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: ''''''''
- en: from matplotlib import pyplot as plt
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: from matplotlib import pyplot as plt
- en: 'def draw_square():'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 'def draw_square():'
- en: ax = plt.axes(xlim = (0, 6), ylim = (0, 6))
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: ax = plt.axes(xlim = (0, 6), ylim = (0, 6))
- en: square = plt.Polygon([(1, 1), (5, 1), (5, 5), (1, 5)], closed = True)
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: square = plt.Polygon([(1, 1), (5, 1), (5, 5), (1, 5)], closed = True)
- en: ax.add_patch(square)
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: ax.add_patch(square)
- en: plt.show()
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: plt.show()
- en: 'if __name__ == ''__main__'':'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: draw_square()
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: draw_square()
- en: 'The Polygon object is created by passing the list of the vertices’ coordinates
    as the first argument. Because we’re drawing a square, we pass the coordinates
    of the four vertices: (1, 1), (5, 1), (5, 5), and (1, 5). Passing closed=True
    tells matplotlib that we want to draw a closed polygon, where the starting and
    the ending vertices are the same.'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 多边形对象是通过将顶点坐标列表作为第一个参数传入创建的。因为我们要绘制正方形，所以传入四个顶点的坐标：(1, 1)、(5, 1)、(5, 5)、(1,
    5)。将 closed=True 传入 matplotlib，表示我们希望绘制一个闭合的多边形，即起始点和终止点是相同的。
- en: In this challenge, you’ll attempt a very simplified version of the “circles
    packed into a square” problem. How many circles of radius 0.5 will fit in the
    square produced by this code? Draw and find out! [Figure 6-11](ch06.html#ch6fig11)
    shows how the final image will look.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个挑战中，你将尝试解决“将圆形装入正方形”的简化版本问题。半径为0.5的圆形可以在由此代码生成的正方形中放置多少个？画出来并找出答案！[图6-11](ch06.html#ch6fig11)展示了最终图像的样子。
- en: '![image](images/f06-11.jpg)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f06-11.jpg)'
- en: '*Figure 6-11: Circles packed into a square*'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-11：圆形装入正方形*'
- en: 'The trick here is to start from the lower-left corner of the square— that is,
    (1, 1)—and then continue adding circles until the entire square is filled. The
    following snippet shows how you can create the circles and add them to the figure:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的技巧是从正方形的左下角开始——也就是(1, 1)——然后不断添加圆圈，直到整个正方形被填满。下面的代码片段展示了如何创建圆圈并将它们添加到图形中：
- en: y = 1.5
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: y = 1.5
- en: 'while y < 5:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 'while y < 5:'
- en: x = 1.5
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: x = 1.5
- en: 'while x < 5:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 'while x < 5:'
- en: c = draw_circle(x, y)
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: c = draw_circle(x, y)
- en: ax.add_patch(c)
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: ax.add_patch(c)
- en: x += 1.0
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: x += 1.0
- en: y += 1.0
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: y += 1.0
- en: A point worth noting here is that this is *not* the most optimal or, for that
    matter, the only way to pack circles into a square, and finding different ways
    of solving this problem is popular among mathematics enthusiasts.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的是，这*不是*将圆形填充到正方形中的最优方法，或者说，它不是唯一的方式，寻找不同的解决方法在数学爱好者中很受欢迎。
- en: '***#2: Drawing the Sierpiński Triangle***'
  id: totrans-360
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***#2：绘制谢尔宾斯基三角形***'
- en: The Sierpiński triangle, named after the Polish mathematician Wacław Sierpiński,
    is a fractal that is an equilateral triangle composed of smaller equilateral triangles
    embedded inside it. [Figure 6-12](ch06.html#ch6fig12) shows a Sierpiński triangle
    composed of 10,000 points.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 谢尔宾斯基三角形以波兰数学家瓦茨瓦夫·谢尔宾斯基命名，是一个由更小的等边三角形嵌套在其中构成的分形。[图6-12](ch06.html#ch6fig12)展示了由10,000个点构成的谢尔宾斯基三角形。
- en: '![image](images/f06-12.jpg)'
  id: totrans-362
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f06-12.jpg)'
- en: '*Figure 6-12: Sierpiński triangle with 10,000 points*'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-12：包含10,000个点的谢尔宾斯基三角形*'
- en: 'The interesting thing here is that the same process that we used to draw a
    fern will also draw the Sierpiński triangle—only the transformation rules and
    their probability will change. Here’s how you can draw the Sierpiński triangle:
    start with the point (0, 0) and apply one of the following transformations:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，我们用来绘制蕨类植物的相同过程也可以绘制谢尔宾斯基三角形——只是转换规则和它们的概率会发生变化。你可以这样绘制谢尔宾斯基三角形：从点(0, 0)开始，并应用以下其中一个转换：
- en: '**Transformation 1:**'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '**转换1：**'
- en: '*x*[*n*+1] = 0.5*x[n]*'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '*x*[*n*+1] = 0.5*x[n]*'
- en: '*y*[*n*+1] = 0.5*y[n]*'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '*y*[*n*+1] = 0.5*y[n]*'
- en: '**Transformation 2**:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '**转换2**：'
- en: '*x*[*n*+1] = 0.5*x[n]* + 0.5'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '*x*[*n*+1] = 0.5*x[n]* + 0.5'
- en: '*y*[*n*+1] = 0.5*y[n]* + 0.5'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '*y*[*n*+1] = 0.5*y[n]* + 0.5'
- en: '**Transformation 3**:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '**转换3**：'
- en: '*x*[*n*+1] = 0.5*x[n]* + 1'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '*x*[*n*+1] = 0.5*x[n]* + 1'
- en: '*y*[*n*+1] = 0.5*y[n]*'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '*y*[*n*+1] = 0.5*y[n]*'
- en: Each of the transformations has an equal probability of being selected—1/3\.
    Your challenge here is to write a program that draws the Sierpiński triangle composed
    of a certain number of points specified as input.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 每个转换的选择概率相等——1/3。你的挑战是编写一个程序，绘制由输入指定的点数构成的谢尔宾斯基三角形。
- en: '***#3: Exploring Hénon’s Function***'
  id: totrans-375
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***#3：探索亨农函数***'
- en: 'In 1976, Michel Hénon introduced the Hénon function, which describes a transformation
    rule for a point *P*(*x*, *y*) as follows:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 1976年，Michel Hénon提出了亨农函数，它描述了一个点*P*(*x*, *y*)的转换规则，如下所示：
- en: '*P* (*x*, *y*) → *Q* (*y* + 1 – 1.4*x*², 0.3*x*)'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '*P* (*x*, *y*) → *Q* (*y* + 1 – 1.4*x*², 0.3*x*)'
- en: Irrespective of the initial point (provided it’s not very far from the origin),
    you’ll see that as you create more points, they start lying along curved lines,
    as shown in [Figure 6-13](ch06.html#ch6fig13).
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 无论初始点如何（只要它离原点不太远），你会看到随着更多点的创建，它们开始沿着弯曲的线排列，如[图6-13](ch06.html#ch6fig13)所示。
- en: '![image](images/f06-13.jpg)'
  id: totrans-379
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f06-13.jpg)'
- en: '*Figure 6-13: Hénon function with 10,000 points*'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-13：包含10,000个点的亨农函数*'
- en: Your challenge here is to write a program to create a graph showing 20,000 iterations
    of this transformation, starting with the point (1, 1).
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 你的挑战是编写一个程序，生成一个图形，显示从点(1, 1)开始的20,000次迭代的结果。
- en: Extra credit for writing another program to create an animated figure showing
    the points starting to lie along the curves! See *[https://www.youtube.com/watch?v=76ll818RlpQ](https://www.youtube.com/watch?v=76ll818RlpQ)*
    for an example.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 额外加分：编写另一个程序，创建一个动画图形，展示点开始沿着曲线排列！请参考* [https://www.youtube.com/watch?v=76ll818RlpQ](https://www.youtube.com/watch?v=76ll818RlpQ)*查看示例。
- en: 'This is an example of a dynamical system, and the curved lines that all the
    points seem attracted to are referred to as *attractors*. To learn more about
    this function, dynamical systems, and fractals in general, you may want to refer
    to *Fractals: A Very Short Introduction* by Kenneth Falconer (Oxford University
    Press, 2013).'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '这是一个动态系统的例子，所有点似乎被吸引的弯曲线被称为*吸引子*。要了解更多关于这个函数、动态系统以及分形的知识，你可以参考Kenneth Falconer的《Fractals:
    A Very Short Introduction》（牛津大学出版社，2013年）。'
- en: '***#4: Drawing the Mandelbrot Set***'
  id: totrans-384
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***#4：绘制曼德尔布罗特集合***'
- en: Your challenge here is to write a program to draw the *Mandelbrot set*—another
    example of the application of simple rules leading to a complicated-looking shape
    (see [Figure 6-14](ch06.html#ch6fig14)). Before I lay down the steps to do that,
    however, we’ll first learn about matplotlib’s imshow() function.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 你的挑战是编写一个程序来绘制*曼德博集合*——这是一个简单规则应用的另一个例子，最终呈现出一个看似复杂的形状（参见[图6-14](ch06.html#ch6fig14)）。不过，在我列出步骤之前，我们将首先了解matplotlib的imshow()函数。
- en: '![image](images/f06-14.jpg)'
  id: totrans-386
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f06-14.jpg)'
- en: '*Figure 6-14: Mandelbrot set in the plane between (–2.5, –1.0) and (1.0, 1.0)*'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-14：位于（–2.5, –1.0）和（1.0, 1.0）之间的曼德博集合平面*'
- en: '**The imshow() Function**'
  id: totrans-388
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**imshow()函数**'
- en: The imshow() function is usually used to display an external image, such as
    a JPEG or PNG image. You can see an example at *[http://matplotlib.org/users/image_tutorial.html](http://matplotlib.org/users/image_tutorial.html)*.
    Here, however, we’ll use the function to draw a new image of our own creation
    via matplotlib.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: imshow()函数通常用于显示外部图像，如JPEG或PNG图像。你可以在* [http://matplotlib.org/users/image_tutorial.html](http://matplotlib.org/users/image_tutorial.html)
    *看到一个例子。然而，在这里，我们将使用该函数绘制我们自己通过matplotlib创建的新图像。
- en: 'Consider the part of the Cartesian plane where *x* and *y* both range from
    0 to 5\. Now, consider six equidistant points along each axis: (0, 1, 2, 3, 4,
    5) along the *x*-axis and the same set of points along the *y*-axis. If we take
    the Cartesian product of these points, we get 36 equally spaced points in the
    *x*-*y* plane with the coordinates (0, 0), (0, 1) ... (0, 5), (1, 0), (1, 1) ...
    (1, 5) ... (5, 5). Let’s now say that we want to color each of these points with
    a shade of gray—that is, some of these points will be black, some will be white,
    and others will be colored with a shade in between, randomly chosen. [Figure 6-15](ch06.html#ch6fig15)
    illustrates the scenario.'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑笛卡尔平面中* x *和* y *都从0到5的部分。现在，考虑沿每个轴的六个等距点：* x *轴上的(0, 1, 2, 3, 4, 5)以及* y
    *轴上的相同点集。如果我们取这些点的笛卡尔积，我们将得到在* x *-* y *平面中均匀分布的36个点，坐标为(0, 0)，(0, 1)，... (0,
    5)，(1, 0)，(1, 1)，... (1, 5)，... (5, 5)。现在，假设我们要用灰色的不同色调为这些点着色——即，这些点中有些是黑色的，有些是白色的，其他的将随机选取一个介于两者之间的色调。[图6-15](ch06.html#ch6fig15)展示了这个场景。
- en: '![image](images/f06-15.jpg)'
  id: totrans-391
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f06-15.jpg)'
- en: '*Figure 6-15: Part of the* x-y *plane with* x *and* y *both ranging from 0
    to 5\. We’ve considered 36 points in the region equidistant from each other and
    colored each with a shade of gray.*'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-15：* x *-* y *平面的一个部分，* x *和* y *都从0到5。我们考虑了区域内36个等距的点，并且每个点都用灰色的色调着色。*'
- en: To create this figure, we have to make a list of six lists. Each of these six
    lists will in turn consist of six integers ranging from 0 to 10\. Each number
    will correspond to the color for each point, 0 standing for black and 10 standing
    for white. We’ll then pass this list to the imshow() function along with other
    necessary arguments.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建这个图形，我们需要创建一个包含六个列表的列表。每个列表将包含六个从0到10的整数。每个数字将对应每个点的颜色，0代表黑色，10代表白色。然后，我们将这个列表传递给imshow()函数以及其他必要的参数。
- en: '**Creating a List of Lists**'
  id: totrans-394
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**创建一个列表的列表**'
- en: 'A list can also contain lists as its members:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 一个列表也可以包含列表作为其成员：
- en: '>>> l1 = [1, 2, 3]'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> l1 = [1, 2, 3]'
- en: '>>> l2 = [4, 5, 6]'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> l2 = [4, 5, 6]'
- en: '>>> l = [l1, l2]'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> l = [l1, l2]'
- en: 'Here, we created a list, l, consisting of two lists, l1 and l2. The first element
    of the list, l[0], is thus the same as the l1 list and the second element of the
    list, l[1], is the same as the l2 list:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个列表l，包含两个列表l1和l2。列表的第一个元素l[0]与l1列表相同，第二个元素l[1]与l2列表相同：
- en: '>>> l[0]'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> l[0]'
- en: '[1, 2, 3]'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '[1, 2, 3]'
- en: '>>> l[1]'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> l[1]'
- en: '[4, 5, 6]'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '[4, 5, 6]'
- en: To refer to an individual element within one of the member lists, we have to
    specify two indices—l[0][1] refers to the second element of the first list, l[1][2]
    refers to the third element of the second list, and so on.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 为了引用成员列表中的单个元素，我们必须指定两个索引——l[0][1]表示第一个列表的第二个元素，l[1][2]表示第二个列表的第三个元素，依此类推。
- en: 'Now that we know how to work with a list of lists, we can write the program
    to create a figure similar to [Figure 6-15](ch06.html#ch6fig15):'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何处理列表的列表了，我们可以编写程序来创建一个类似于[图6-15](ch06.html#ch6fig15)的图形：
- en: import matplotlib.pyplot as plt
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 matplotlib.pyplot 作为 plt
- en: import matplotlib.cm as cm
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 matplotlib.cm 作为 cm
- en: import random
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 random
- en: '➊ def initialize_image(x_p, y_p):'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ def initialize_image(x_p, y_p):'
- en: image = []
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 图像 = []
- en: 'for i in range(y_p):'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(y_p):'
- en: x_colors = []
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: x_colors = []
- en: 'for j in range(x_p):'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 'for j in range(x_p):'
- en: x_colors.append(0)
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: x_colors.append(0)
- en: image.append(x_colors)
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: image.append(x_colors)
- en: return image
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 返回图像
- en: 'def color_points():'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 'def color_points():'
- en: x_p = 6
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: x_p = 6
- en: y_p = 6
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: y_p = 6
- en: image = initialize_image(x_p, y_p)
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: image = initialize_image(x_p, y_p)
- en: 'for i in range(y_p):'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(y_p):'
- en: 'for j in range(x_p):'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 'for j in range(x_p):'
- en: ➋             image[i][j] = random.randint(0, 10)
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: ➋             image[i][j] = random.randint(0, 10)
- en: ➌     plt.imshow(image, origin='lower', extent=(0, 5, 0, 5),
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: ➌     plt.imshow(image, origin='lower', extent=(0, 5, 0, 5),
- en: cmap=cm.Greys_r, interpolation='nearest')
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: cmap=cm.Greys_r, interpolation='nearest')
- en: plt.colorbar()
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: plt.colorbar()
- en: plt.show()
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: plt.show()
- en: 'if __name__ == ''__main__'':'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: color_points()
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: color_points()
- en: The initialize_image() function at ➊ creates a list of lists with each of the
    elements initialized to 0\. It accepts two arguments, x_p and y_p, which correspond
    to the number of points along the *x*-axis and *y*-axis, respectively. This effectively
    means that the initialized list image will consist of x_p lists with each list
    containing y_p zeros.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 的 initialize_image() 函数创建了一个列表的列表，列表中的每个元素都被初始化为 0。它接受两个参数，x_p 和 y_p，分别对应
    *x* 轴和 *y* 轴上的点数。这意味着初始化后的列表 image 将由 x_p 个列表组成，每个列表包含 y_p 个零。
- en: In the color_points() function, once you have the image list back from initialize_image(),
    assign a random integer between 0 and 10 to the element image[i][j] at ➋. When
    we assign this random integer to the element, we are assigning a color to the
    point in the Cartesian plane that’s *i* steps along the *y*-axis and *j* steps
    along the *x*-axis from the origin. It’s important to note that the imshow() function
    automatically deduces the color of a point from its position in the image list
    and doesn’t care about its specific *x*- and *y*-coordinates.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 在 color_points() 函数中，一旦从 initialize_image() 获取了图像列表，就将一个介于 0 到 10 之间的随机整数赋值给元素
    image[i][j] 在 ➋ 处。当我们将这个随机整数赋值给元素时，我们实际上是在为位于 *y* 轴上 i 步，*x* 轴上 j 步的直角坐标系中的点指定颜色。需要注意的是，imshow()
    函数会自动根据点在图像列表中的位置推断出颜色，而不关心它的具体 *x* 和 *y* 坐标。
- en: Then, call the imshow() function at ➌, passing image as the first argument.
    The keyword argument origin='lower' specifies that the number in image[0][0] corresponds
    to the color of the point (0, 0). The keyword argument extent=(0, 5, 0, 5) sets
    the lower-left and upper-right corners of the image to (0, 0) and (5, 5), respectively.
    The keyword argument cmap=cm.Greys_r specifies that we’re going to create a grayscale
    image.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，调用 ➌ 处的 imshow() 函数，将图像作为第一个参数传入。关键字参数 origin='lower' 指定 image[0][0] 中的数字对应于点
    (0, 0) 的颜色。关键字参数 extent=(0, 5, 0, 5) 设置图像的左下角和右上角分别为 (0, 0) 和 (5, 5)。关键字参数 cmap=cm.Greys_r
    指定我们将创建一个灰度图像。
- en: The last keyword argument, interpolation='nearest', specifies that matplotlib
    should color a point for which the color wasn’t specified with the same color
    as the one nearest to it. What does this mean? Note that we consider and specify
    the color for only 36 points in the region (0, 5) and (5, 5). Because there is
    an infinite number of points in this region, we tell matplotlib to set the color
    of an unspecified point to that of its nearest point. This is the reason you see
    color “boxes” around each point in the figure.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的关键字参数 interpolation='nearest' 指定了当 matplotlib 无法为某个点指定颜色时，会使用与其最近的点的颜色。那这是什么意思呢？请注意，我们只在区域
    (0, 5) 和 (5, 5) 中为 36 个点指定颜色。由于该区域中有无限多个点，我们告诉 matplotlib 将未指定颜色的点设置为其最近的点的颜色。这就是你在图形中看到每个点周围出现“颜色框”的原因。
- en: Call the colorbar() function to display a color bar in the figure showing which
    integer corresponds to which color. Finally, call show() to display the image.
    Note that due to the use of the random.randint() function, your image will be
    colored differently than the one in [Figure 6-15](ch06.html#ch6fig15).
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 colorbar() 函数在图形中显示一个颜色条，显示哪个整数对应哪个颜色。最后，调用 show() 显示图像。请注意，由于使用了 random.randint()
    函数，你的图像颜色将与 [图 6-15](ch06.html#ch6fig15) 中的图像不同。
- en: If you increase the number of points along each axis by setting x_p and y_p
    to, let’s say, 20 in color_points(), you’ll see a figure similar to the one shown
    in [Figure 6-16](ch06.html#ch6fig16). Note that the color boxes grow smaller in
    size. If you increase the number of points even more, you’ll see the size of the
    boxes shrink further, giving the illusion that each point has a different color.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你通过将 color_points() 中的 x_p 和 y_p 设置为，比如 20，来增加每个轴上的点数，你将看到一个类似于 [图 6-16](ch06.html#ch6fig16)
    的图形。请注意，颜色框的大小变得更小。如果你进一步增加点数，你将看到框的大小进一步缩小，给人一种每个点都有不同颜色的错觉。
- en: '![image](images/f06-16.jpg)'
  id: totrans-436
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f06-16.jpg)'
- en: '*Figure 6-16: Part of the* x-y *plane with* x *and* y *both ranging from 0
    to 5\. We’ve considered 400 points in the region equidistant from each other and
    colored each with a shade of gray.*'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-16：x-y 平面的一部分，其中* x *和* y *都从 0 到 5。我们在该区域内考虑了 400 个相互等距的点，并用灰色的不同色调为每个点上色。*'
- en: '**Drawing the Mandelbrot Set**'
  id: totrans-438
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**绘制曼德布罗特集合**'
- en: We’ll consider the area of the *x*-*y* plane between (–2.5, –1.0) and (1.0,
    1.0) and divide each axis into 400 equally spaced points. The Cartesian product
    of these points will give us 1,600 equally spaced points in this region. We’ll
    refer to these points as (*x*[1], *y*[1]), (*x*[1], *y*[2]) ... (*x*[400], *y*[400]).
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将考虑 x-y 平面中区域（–2.5，–1.0）和（1.0，1.0）之间的面积，并将每个轴划分为 400 个等距的点。这些点的笛卡尔积将给我们 1,600
    个等距的点。我们将这些点称为（*x*[1]，*y*[1]），（*x*[1]，*y*[2]）……（*x*[400]，*y*[400]）。
- en: 'Create a list, image, by calling the initialize_image() function we saw earlier
    with both x_p and y_p set to 400\. Then, follow these steps for *each* of the
    generated points (*x[i]*, *y[k]*):'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个列表，image，通过调用之前看到的 initialize_image() 函数，并将 x_p 和 y_p 都设置为 400。然后，按照以下步骤处理生成的每个点（*x[i]*，*y[k]*）：
- en: 1\. First, create two complex numbers, *z*[1] = 0 + 0*j* and *c* = *x[i]* +
    *y[k] j*. (Recall that we use *j* for ![image](images/e0176-01.jpg).)
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 首先，创建两个复数，*z*[1] = 0 + 0*j* 和 *c* = *x[i]* + *y[k] j*。（请记住，我们用 *j* 来表示 ![image](images/e0176-01.jpg)。）
- en: 2\. Create a label iteration and set it to 0—that is, iteration=0.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 创建一个标签迭代并将其设置为 0——即，iteration=0。
- en: 3\. Create a complex number, ![image](images/e0176-02.jpg).
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 创建一个复数，![image](images/e0176-02.jpg)。
- en: 4\. Increment the value stored in iteration by 1—that is, iteration = iteration
    + 1.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 4\. 将迭代值增加 1——即，iteration = iteration + 1。
- en: 5\. If abs(z1) < 2 and iteration < max_iteration, then go back to step 3; otherwise,
    go to step 6\. The larger the value of max_iteration, the more detailed the image,
    but the longer it’ll take to create the image. Set max_iteration to 1,000 here.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 5\. 如果 abs(z1) < 2 且 iteration < max_iteration，则返回第 3 步；否则，转到第 6 步。max_iteration
    的值越大，图像越详细，但创建图像的时间也会更长。在这里将 max_iteration 设置为 1,000。
- en: 6\. Set the color of the point (*x[i]*, *y[k]*) to the value in iteration—that
    is, image[k][i] = iteration.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 6\. 将点（*x[i]*，*y[k]*）的颜色设置为迭代值——即，image[k][i] = iteration。
- en: Once you have the complete image list, call the imshow() function with the extent
    keyword argument changed to indicate the region bounded by (–2.5, –1.0) and (1.0,
    1.0).
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你得到完整的图像列表，调用 imshow() 函数，并更改 extent 关键字参数，以指示由（–2.5，–1.0）和（1.0，1.0）所界定的区域。
- en: This algorithm is usually referred to as the *escape-time algorithm*. When the
    maximum number of iterations is reached before a point’s magnitude exceeds 2,
    that point belongs to the Mandelbrot set and is colored white. The points that
    exceed the magnitude within fewer iterations are said to “escape”; they don’t
    belong to the Mandelbrot set and are colored black. You can experiment by decreasing
    and increasing the number of points along each axis. Decreasing the number of
    points will lead to a grainy image, while increasing them will result in a more
    detailed image.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法通常称为 *逃逸时间算法*。当一个点的幅度在最大迭代次数达到之前未超过 2 时，该点属于曼德布罗特集合并显示为白色。那些在较少迭代次数内就超出幅度的点被称为“逃逸”；它们不属于曼德布罗特集合，且显示为黑色。你可以通过减少或增加每个轴上的点数来进行实验。减少点数会导致图像颗粒感增强，而增加点数则会得到更加详细的图像。
