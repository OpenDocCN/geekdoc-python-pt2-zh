- en: '[12](nsp-venkitachalam503045-0008.xhtml#rch12)'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[12](nsp-venkitachalam503045-0008.xhtml#rch12)'
- en: Karplus-Strong on a Raspberry Pi Pico
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Karplus-Strong 在 Raspberry Pi Pico 上的实现
- en: '![](images/nsp-venkitachalam503045-circle-image.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-circle-image.jpg)'
- en: 'In [Chapter 4](nsp-venkitachalam503045-0016.xhtml#ch04), you learned how to
    make plucked string sounds using the Karplus-Strong algorithm. You saved the generated
    sounds as WAV files and played notes from a pentatonic musical scale on your computer.
    In this chapter, you’ll learn how to shrink that project to fit on a tiny piece
    of hardware: the Raspberry Pi Pico.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 4 章](nsp-venkitachalam503045-0016.xhtml#ch04)中，你学习了如何使用 Karplus-Strong 算法生成拨弦声。你将生成的声音保存为
    WAV 文件，并在计算机上播放五声音阶的音符。在本章中，你将学习如何将该项目缩小到适应一个微小的硬件平台：Raspberry Pi Pico。
- en: The Pico (see [Figure 12-1](nsp-venkitachalam503045-0027.xhtml#fig12-1)) is
    built using an RP2040 microcontroller chip, which has just 264KB of random access
    memory (RAM). Compare that to the tens of gigabytes of RAM on the typical personal
    computer! The Pico also has 2MB of flash memory on a separate chip, in contrast
    to a normal computer’s hundreds of gigabytes of hard disk space. Despite these
    limitations, however, the Pico is still extremely capable. It can perform many
    useful services, while also being much cheaper and less power-hungry than a regular
    computer. Your watch, your air conditioning unit, your clothes dryer, your car,
    your phone—tiny microcontrollers like the RP2040 are everywhere!
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Pico（见[图 12-1](nsp-venkitachalam503045-0027.xhtml#fig12-1)）采用 RP2040 微控制器芯片构建，该芯片仅有
    264KB 的随机存取内存（RAM）。与典型个人计算机的数十GB内存相比，这个内存显得微不足道！Pico 还配备了 2MB 的闪存，这与普通计算机的几百GB硬盘空间形成对比。尽管有这些限制，Pico
    依然非常强大。它能够执行许多有用的服务，同时比普通计算机更便宜，功耗也更低。你的手表、空调、烘干机、汽车、手机——像 RP2040 这样的微型控制器无处不在！
- en: '![](images/nsp-venkitachalam503045-f12001.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f12001.jpg)'
- en: 'Figure 12-1: The Raspberry Pi Pico'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-1：Raspberry Pi Pico
- en: 'The goal for this project is to use the Raspberry Pi Pico to create a musical
    instrument with five buttons. Pressing each button will play a note from a pentatonic
    scale, generated with the Karplus-Strong algorithm. Some of the concepts you’ll
    learn from this project are:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目的目标是使用 Raspberry Pi Pico 创建一个带有五个按钮的音乐乐器。按下每个按钮将播放一个来自五声音阶的音符，这些音符由 Karplus-Strong
    算法生成。你将在本项目中学习到的一些概念包括：
- en: • Programming a microcontroller using MicroPython, an implementation of Python
    optimized to run on devices like the Pico
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用 MicroPython 编程微控制器，MicroPython 是专为像 Pico 这样的设备优化的 Python 实现
- en: • Building a simple audio circuit on a breadboard using the Pico
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 在面包板上使用 Pico 构建一个简单的音频电路
- en: • Using the I2S digital audio protocol and an I2S amplifier to send audio data
    to a speaker
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用 I2S 数字音频协议和 I2S 放大器将音频数据发送到扬声器
- en: • Implementing the Karplus-Strong algorithm from [Chapter 4](nsp-venkitachalam503045-0016.xhtml#ch04)
    on a resource-constrained microcontroller
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 在资源受限的微控制器上实现[第 4 章](nsp-venkitachalam503045-0016.xhtml#ch04)中的 Karplus-Strong
    算法
- en: '[How It Works](nsp-venkitachalam503045-0008.xhtml#rah1401)'
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[工作原理](nsp-venkitachalam503045-0008.xhtml#rah1401)'
- en: 'We discussed the Karplus-Strong algorithm in detail in [Chapter 4](nsp-venkitachalam503045-0016.xhtml#ch04),
    so we won’t revisit it here. Instead, we’ll focus on what makes this version of
    the project different. Your program from [Chapter 4](nsp-venkitachalam503045-0016.xhtml#ch04)
    was designed to run on a laptop or desktop computer. Thanks to the computer’s
    ample RAM and hard disk resources, it had no problems creating WAV files using
    the Karplus-Strong algorithm and playing audio through speakers with `pyaudio`.
    The challenge now is to fit the project code onto a resource-constrained Raspberry
    Pi Pico. This will require the following modifications:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第 4 章](nsp-venkitachalam503045-0016.xhtml#ch04)中详细讨论了 Karplus-Strong 算法，因此这里不再赘述。相反，我们将重点讲解本版本项目的不同之处。你在[第
    4 章](nsp-venkitachalam503045-0016.xhtml#ch04)中编写的程序是为笔记本电脑或台式机设计的。得益于计算机充足的内存和硬盘资源，它在使用
    Karplus-Strong 算法生成 WAV 文件并通过扬声器播放音频时没有问题。现在的挑战是将项目代码适配到资源受限的 Raspberry Pi Pico
    上。这将需要以下修改：
- en: • Using a smaller audio sampling rate to reduce memory requirements
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用较小的音频采样率以减少内存需求
- en: • Using a simple binary file to store raw generated samples rather than a WAV
    file
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用简单的二进制文件存储原始生成的样本，而不是 WAV 文件
- en: • Using the I2S protocol to send out the audio data to an external audio amplifier
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用 I2S 协议将音频数据发送到外部音频放大器
- en: • Using memory management techniques to avoid copying the same data repeatedly
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用内存管理技术，避免重复复制相同的数据
- en: We’ll discuss the specifics of these modifications as they arise.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这些修改出现时讨论具体细节。
- en: '[Input and Output](nsp-venkitachalam503045-0008.xhtml#rbh1401)'
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[输入与输出](nsp-venkitachalam503045-0008.xhtml#rbh1401)'
- en: To make the project interactive, you’ll want the Pico to generate sounds in
    response to user input. You’ll need to wire five push buttons to the Pico for
    this purpose, since the Pico doesn’t have a keyboard or mouse. (You’ll use a sixth
    push button to run the program.) We also need to figure out how to produce the
    sound output, since unlike a personal computer, the Pico board doesn’t have any
    built-in speakers. [Figure 12-2](nsp-venkitachalam503045-0027.xhtml#fig12-2) shows
    a block diagram of the project.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使项目具有交互性，你希望 Pico 能够根据用户输入生成声音。你需要将五个按钮连接到 Pico，因为 Pico 没有键盘或鼠标。（你将使用第六个按钮来运行程序。）我们还需要想办法生成声音输出，因为与个人计算机不同，Pico
    板没有内置扬声器。[图 12-2](nsp-venkitachalam503045-0027.xhtml#fig12-2) 显示了项目的框图。
- en: '![](images/nsp-venkitachalam503045-f12002.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f12002.jpg)'
- en: 'Figure 12-2: A block diagram of the project'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-2：项目的框图
- en: When you press a button, the MicroPython code running on the Pico will generate
    a plucked string sound using the Karplus-Strong algorithm. The digital sound samples
    produced by the algorithm will be sent to a separate MAX98357A amplifier board,
    which decodes the digital data into an analog audio signal. The MAX98357A also
    amplifies the analog signal, which allows you to connect its output to an external
    8-ohm speaker so you can hear the audio. [Figure 12-3](nsp-venkitachalam503045-0027.xhtml#fig12-3)
    shows the Adafruit MAX98357A board.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当你按下按钮时，运行在 Pico 上的 MicroPython 代码将使用 Karplus-Strong 算法生成一个拨弦声音。算法产生的数字声音样本将发送到一个独立的
    MAX98357A 放大器板，该板将数字数据解码为模拟音频信号。MAX98357A 还会放大模拟信号，这样你就可以将其输出连接到外部 8 欧姆扬声器，从而听到音频。[图
    12-3](nsp-venkitachalam503045-0027.xhtml#fig12-3) 显示了 Adafruit MAX98357A 板。
- en: '![](images/nsp-venkitachalam503045-f12003.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f12003.jpg)'
- en: 'Figure 12-3: An Adafruit MAX98357A I2S amplifier board'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-3：Adafruit MAX98357A I2S 放大器板
- en: The Pi Pico needs to send data to the amplifier board in a certain format for
    it to successfully be interpreted as an audio signal. Enter the I2S protocol.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Pi Pico 需要以特定格式将数据发送到放大器板，以便它能够成功地被解读为音频信号。这就是 I2S 协议的作用。
- en: '[The I2S Protocol](nsp-venkitachalam503045-0008.xhtml#rbh1402)'
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[I2S 协议](nsp-venkitachalam503045-0008.xhtml#rbh1402)'
- en: The *Inter-IC Sound (I2S) protocol* is a standard for sending digital audio
    data between devices. It’s a simple, convenient way to get quality audio output
    from a microcontroller. The protocol transmits audio using three digital signals,
    which are shown in [Figure 12-4](nsp-venkitachalam503045-0027.xhtml#fig12-4).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*Inter-IC 音频 (I2S) 协议* 是一种在设备之间发送数字音频数据的标准。它是从微控制器获取高质量音频输出的一种简单、便捷的方式。该协议通过三种数字信号传输音频，这些信号如[图
    12-4](nsp-venkitachalam503045-0027.xhtml#fig12-4)所示。'
- en: '![](images/nsp-venkitachalam503045-f12004.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f12004.jpg)'
- en: 'Figure 12-4: The I2S protocol'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-4：I2S 协议
- en: The first signal, SCK, is the *clock*, a signal that alternates between high
    and low at a fixed speed. This sets the rate of data transmission. Next, WS is
    the *word select* signal. It steadily alternates between high and low to indicate
    which audio channel, left or right, is being sent at any given moment. Finally,
    SD is the *serial data* signal, which carries the actual audio information, in
    the form of N-bit binary values representing the amplitude of the sound.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个信号，SCK，是*时钟*信号，一个在固定速度下高低交替的信号。这个信号设置了数据传输的速率。接下来，WS 是*字选择*信号。它稳定地在高低之间交替，表示此时正在传输的是哪个音频通道——左通道还是右通道。最后，SD
    是*串行数据*信号，承载实际的音频信息，以 N 位二进制值表示声音的幅度。
- en: To understand how this works, let’s consider an example. Say you want to send
    stereo audio at a sampling rate of 16,000 Hz and you want the amplitude of each
    sound sample to be a 16-bit value. The frequency of WS should be the same as the
    sampling rate, since that’s the rate at which you’re sending each amplitude value.
    This way, the WS signal will alternate between high and low 16,000 times per second;
    when it’s high, SD will send the amplitude value of one audio channel, and when
    it’s low, SD will send the amplitude value of the other audio channel. Since each
    amplitude value for each channel is made up of 16 bits, SD has to transmit at
    a rate that’s 16 × 2 = 32 times faster than the sampling rate. The clock controls
    the rate of transmission, so SCK’s frequency must be 16,000 Hz × 32 = 512,000 Hz.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这个过程，我们来看一个例子。假设你想以 16,000 Hz 的采样率发送立体声音频，并且你希望每个声音样本的振幅为 16 位值。WS 的频率应该与采样率相同，因为那是你发送每个振幅值的速率。这样，WS
    信号将每秒高低交替 16,000 次；当它为高电平时，SD 会发送一个音频通道的振幅值，而当它为低电平时，SD 会发送另一个音频通道的振幅值。由于每个通道的振幅值由
    16 位组成，SD 必须以比采样率快 16 × 2 = 32 倍的速率进行传输。时钟控制传输速率，因此 SCK 的频率必须是 16,000 Hz × 32
    = 512,000 Hz。
- en: For this project, the Pico will be the I2S transmitter, so it will generate
    the SCK, WS, and SD signals. MicroPython actually has a fully implemented `I2S`
    module for the Pico, so much of the work generating the signals will be done for
    you, behind the scenes. As you’ve already seen, the Pico will send the signals
    to a MAX98357A board, which is specifically designed to receive audio data through
    the I2S protocol. Then the board converts the I2S data into an analog audio signal
    that can be played through a speaker.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，Pico 将充当 I2S 发送器，因此它将生成 SCK、WS 和 SD 信号。MicroPython 实际上为 Pico 提供了一个完全实现的
    `I2S` 模块，因此生成信号的大部分工作将在后台为你完成。如你所见，Pico 将把信号发送到 MAX98357A 板，该板专门设计用于通过 I2S 协议接收音频数据。然后，板子将
    I2S 数据转换为模拟音频信号，能够通过扬声器播放。
- en: '[Requirements](nsp-venkitachalam503045-0008.xhtml#rah1402)'
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[需求](nsp-venkitachalam503045-0008.xhtml#rah1402)'
- en: 'You’ll program the project for the Raspberry Pi Pico using MicroPython. You’ll
    need the following hardware:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用 MicroPython 为 Raspberry Pi Pico 编写程序。你将需要以下硬件：
- en: • One Raspberry Pi Pico board based on the RP2040 chip
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 一块基于 RP2040 芯片的 Raspberry Pi Pico 板
- en: • One Adafruit MAX98357A I2S breakout board
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 一块 Adafruit MAX98357A I2S 扩展板
- en: • One 8-ohm speaker
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 一个 8 欧姆扬声器
- en: • Six push buttons
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 六个按钮
- en: • Five 10 kΩ resistors
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 五个 10 kΩ 电阻
- en: • One breadboard
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 一块面包板
- en: • An assortment of hookup wires
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 一组连接线
- en: • One Micro USB cable for uploading code to the Pico
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 一根 Micro USB 数据线，用于将代码上传到 Pico
- en: '[Hardware Setup](nsp-venkitachalam503045-0008.xhtml#rbh1403)'
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[硬件设置](nsp-venkitachalam503045-0008.xhtml#rbh1403)'
- en: You’ll assemble the hardware on a breadboard. [Figure 12-5](nsp-venkitachalam503045-0027.xhtml#fig12-5)
    shows the hookup.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在面包板上组装硬件。[图 12-5](nsp-venkitachalam503045-0027.xhtml#fig12-5) 显示了连接方式。
- en: '![](images/nsp-venkitachalam503045-f12005.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f12005.jpg)'
- en: 'Figure 12-5: The hardware hookup'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-5：硬件连接
- en: '[Figure 12-6](nsp-venkitachalam503045-0027.xhtml#fig12-6) shows a pin diagram
    of the Pico from the official datasheet, which is a handy reference for your hookup.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 12-6](nsp-venkitachalam503045-0027.xhtml#fig12-6) 显示了 Pico 的引脚图，来自官方数据手册，是你进行连接时的实用参考。'
- en: '![](images/nsp-venkitachalam503045-f12006.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f12006.jpg)'
- en: 'Figure 12-6: A pin diagram from the Raspberry Pi Pico datasheet'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-6：来自 Raspberry Pi Pico 数据手册的引脚图
- en: '[Table 12-1](nsp-venkitachalam503045-0027.xhtml#tab12-1) summarizes the electrical
    connections you need to implement on the breadboard. [Figure 12-5](nsp-venkitachalam503045-0027.xhtml#fig12-5)
    shows these connections.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 12-1](nsp-venkitachalam503045-0027.xhtml#tab12-1) 总结了你需要在面包板上实现的电气连接。[图
    12-5](nsp-venkitachalam503045-0027.xhtml#fig12-5) 显示了这些连接。'
- en: 'Table 12-1: Electrical Connections'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 表 12-1：电气连接
- en: '| Pico pin | Connection |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| Pico 引脚 | 连接 |'
- en: '| --- | --- |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| GP3 | Push button 1 (other pin to VDD via 10 kΩ resistor) |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| GP3 | 按钮 1（另一引脚通过 10 kΩ 电阻连接至 VDD） |'
- en: '| GP4 | Push button 2 (other pin to VDD via 10 kΩ resistor) |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| GP4 | 按钮 2（另一引脚通过 10 kΩ 电阻连接至 VDD） |'
- en: '| GP5 | Push button 3 (other pin to VDD via 10 kΩ resistor) |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| GP5 | 按钮 3（另一引脚通过 10 kΩ 电阻连接至 VDD） |'
- en: '| GP6 | Push button 4 (other pin to VDD via 10 kΩ resistor) |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| GP6 | 按钮 4（另一引脚通过 10 kΩ 电阻连接至 VDD） |'
- en: '| GP7 | Push button 5 (other pin to VDD via 10 kΩ resistor) |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| GP7 | 按钮 5（另一引脚通过 10 kΩ 电阻连接至 VDD） |'
- en: '| RUN | Push button 6 (other pin to GND) |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| RUN | 按钮 6（另一引脚连接至 GND） |'
- en: '| GP0 | MAX98357A BCLK |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| GP0 | MAX98357A BCLK |'
- en: '| GP1 | MAX98357A LRC |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| GP1 | MAX98357A LRC |'
- en: '| GP2 | MAX98357A DIN |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| GP2 | MAX98357A DIN |'
- en: '| GND | MAX98357A GND |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| GND | MAX98357A GND |'
- en: '| 3V3(OUT) | MAX98357A Vin |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 3V3(OUT) | MAX98357A Vin |'
- en: Once you’ve hooked up the hardware, your project should look like [Figure 12-7](nsp-venkitachalam503045-0027.xhtml#fig12-7).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你连接好硬件，你的项目应该看起来像[图12-7](nsp-venkitachalam503045-0027.xhtml#fig12-7)。
- en: '![](images/nsp-venkitachalam503045-f12007.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f12007.jpg)'
- en: 'Figure 12-7: The fully built hardware'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-7：完全搭建好的硬件
- en: Before you start using your Pico, however, you need to set up MicroPython.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在开始使用Pico之前，你需要设置MicroPython。
- en: '[MicroPython Setup](nsp-venkitachalam503045-0008.xhtml#rbh1404)'
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[MicroPython 设置](nsp-venkitachalam503045-0008.xhtml#rbh1404)'
- en: 'Setting up your Raspberry Pi Pico with MicroPython is quite straightforward.
    Follow these steps:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用MicroPython设置你的树莓派Pico非常简单。请按照以下步骤操作：
- en: 1\. Visit [https://micropython.org](https://micropython.org), go to the Download
    page, and find the Raspberry Pi Pico.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1\. 访问[https://micropython.org](https://micropython.org)，进入下载页面，并找到树莓派Pico。
- en: 2\. Download the UF2 binary file (version 1.18 or later) containing the MicroPython
    implementation for the Pico.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2\. 下载包含Pico版本的MicroPython实现的UF2二进制文件（版本1.18或更高）。
- en: 3\. Press the white BOOTSEL button on the Pico, and while holding this button
    down, use your Micro USB cable to connect the Pico to your computer. Then release
    the button.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3\. 按下Pico上的白色BOOTSEL按钮，同时按住这个按钮，用Micro USB数据线将Pico连接到计算机上。然后松开按钮。
- en: 4\. You should see a folder called *RPI-RP2* pop up on your computer. Drag and
    drop the UF2 file into this folder.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 4\. 你应该能看到一个名为*RPI-RP2*的文件夹出现在计算机上。将UF2文件拖放到该文件夹中。
- en: Once the copying is done and the Pico reboots, you’re all set to code the Pico
    using MicroPython!
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 文件复制完成并且Pico重启后，你就可以开始使用MicroPython编写Pico代码了！
- en: '[The Code](nsp-venkitachalam503045-0008.xhtml#rah1403)'
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[代码](nsp-venkitachalam503045-0008.xhtml#rah1403)'
- en: The code consists of some initial setup, followed by functions for generating
    and playing the five notes. Then everything comes together in the program’s `main()`
    function. To see the full program, skip ahead to [“The Complete Code”](nsp-venkitachalam503045-0027.xhtml#ah1407)
    on [page 275](nsp-venkitachalam503045-0027.xhtml#p275). The code is also available
    on GitHub at [https://github.com/mkvenkit/pp2e/blob/main/karplus_pico/karplus_pico.py](https://github.com/mkvenkit/pp2e/blob/main/karplus_pico/karplus_pico.py).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 代码包括一些初步的设置，接着是用于生成和播放五个音符的函数。然后，所有内容在程序的`main()`函数中组合起来。要查看完整的程序，可以跳到[《完整代码》](nsp-venkitachalam503045-0027.xhtml#ah1407)第275页。代码也可以在GitHub上找到，地址是[https://github.com/mkvenkit/pp2e/blob/main/karplus_pico/karplus_pico.py](https://github.com/mkvenkit/pp2e/blob/main/karplus_pico/karplus_pico.py)。
- en: '[Setting Up](nsp-venkitachalam503045-0008.xhtml#rbh1405)'
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[设置](nsp-venkitachalam503045-0008.xhtml#rbh1405)'
- en: 'The code begins with some basic setup. First, import the required MicroPython
    modules:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 代码从一些基本的设置开始。首先，导入所需的MicroPython模块：
- en: import time
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: import time
- en: import array
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: import array
- en: import random
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: import random
- en: import os
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: import os
- en: from machine import I2S
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: from machine import I2S
- en: from machine import Pin
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: from machine import Pin
- en: You import the `time` module for its “sleep” functionality to create timed pauses
    during the execution of the code. The `array` module will let you create arrays
    for sending the sound data via I2S. An array is a more efficient version of a
    Python list, since it requires all members to be of the same data type. You’ll
    use the `random` module to fill the initial buffer with random values (the first
    step in the Karplus-Strong algorithm), and you’ll use the `os` module to check
    if a note has already been saved in the filesystem. Finally, the `I2S` module
    will let you send sound data, and the `Pin` module lets you set up the pin outputs
    of the Pico.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你导入`time`模块来使用其“sleep”功能，以便在代码执行过程中创建定时暂停。`array`模块将允许你创建数组，通过I2S发送声音数据。数组是比Python列表更高效的版本，因为它要求所有成员必须是相同的数据类型。你将使用`random`模块用随机值填充初始缓冲区（Karplus-Strong算法的第一步），并且你将使用`os`模块检查某个音符是否已经保存在文件系统中。最后，`I2S`模块将允许你发送声音数据，而`Pin`模块让你设置Pico的引脚输出。
- en: 'You complete the setup by declaring some useful information:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 通过声明一些有用的信息来完成设置：
- en: notes of a minor pentatonic scale
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 小调五声音阶的音符
- en: piano C4-E(b)-F-G-B(b)-C5
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 钢琴音符 C4-E(b)-F-G-B(b)-C5
- en: '❶ pmNotes = {''C4'': 262, ''Eb'': 311, ''F'': 349, ''G'':391, ''Bb'':466}'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '❶ pmNotes = {''C4'': 262, ''Eb'': 311, ''F'': 349, ''G'':391, ''Bb'':466}'
- en: button to note mapping
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按钮到音符的映射
- en: '❷ btnNotes = {0: (''C4'', 262), 1: (''Eb'', 311), 2: (''F'', 349), 3: (''G'',
    391),'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '❷ btnNotes = {0: (''C4'', 262), 1: (''Eb'', 311), 2: (''F'', 349), 3: (''G'',
    391),'
- en: '4: (''Bb'', 466)}'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '4: (''Bb'', 466)}'
- en: sample rate
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 采样率
- en: ❸ SR = 16000
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ SR = 16000
- en: Here you define a dictionary `pmNotes` that maps the name of a note to its integer
    frequency value ❶. You’ll use the names of the notes to save files containing
    the sound data, and you’ll use the frequency values to generate the sounds using
    the Karplus-Strong algorithm. You also define a dictionary `btnNotes` that maps
    the ID of each push button (represented as the integers 0 through 4) to a tuple
    that has the corresponding note name and frequency value ❷. This dictionary controls
    which note is played when the user presses each button.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你定义了一个字典`pmNotes`，它将音符的名称映射到其整数频率值❶。你将使用音符的名称来保存包含声音数据的文件，并使用频率值通过Karplus-Strong算法生成声音。你还定义了一个字典`btnNotes`，它将每个按钮的ID（表示为整数0到4）映射到一个元组，该元组包含相应的音符名称和频率值❷。这个字典控制当用户按下每个按钮时播放哪个音符。
- en: Finally, you define the sampling rate as 16,000 Hz ❸. This is the number of
    sound amplitude values per second that you’ll be sending out via I2S. Notice that
    this is much lower than the sampling rate of 44,100 Hz used in [Chapter 4](nsp-venkitachalam503045-0016.xhtml#ch04).
    This is because of the limited memory on the Pico compared to a standard computer.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你将采样率定义为16,000 Hz❸。这是每秒发送的声音幅度值数，使用I2S发送。请注意，这比在[第4章](nsp-venkitachalam503045-0016.xhtml#ch04)中使用的44,100
    Hz采样率要低得多。这是因为Pico的内存有限，相较于标准计算机来说有所差异。
- en: '[Generating the Notes](nsp-venkitachalam503045-0008.xhtml#rbh1406)'
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[生成音符](nsp-venkitachalam503045-0008.xhtml#rbh1406)'
- en: 'You generate the five notes of the pentatonic scale with the help of two functions:
    `generate_note()` and `create_notes()`. The `generate_note()` function uses the
    Karplus-Strong algorithm to calculate the amplitude values for a single note,
    while `create_notes()` coordinates generating all five notes and saving their
    sample data to the Pico’s filesystem. Let’s consider the `generate_note()` function
    first. (You implemented a similar function in [Chapter 4](nsp-venkitachalam503045-0016.xhtml#ch04),
    so this might be a good time to review the original implementation.)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你借助两个函数`generate_note()`和`create_notes()`生成五个五声音阶的音符。`generate_note()`函数使用Karplus-Strong算法计算单个音符的幅度值，而`create_notes()`则协调生成所有五个音符并将它们的样本数据保存到Pico的文件系统中。我们先来看看`generate_note()`函数。（你在[第4章](nsp-venkitachalam503045-0016.xhtml#ch04)中实现了一个类似的函数，所以现在复习一下原始实现可能是个不错的选择。）
- en: generate note of given frequency
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成给定频率的音符
- en: 'def generate_note(freq):'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 'def generate_note(freq):'
- en: nSamples = SR
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: nSamples = SR
- en: N = int(SR/freq)
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: N = int(SR/freq)
- en: '# initialize ring buffer'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '# 初始化环形缓冲区'
- en: ❶ buf = [2*random.random() - 1 for i in range(N)]
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ buf = [2*random.random() - 1 for i in range(N)]
- en: '# init sample buffer'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '# 初始化样本缓冲区'
- en: ❷ samples = array.array('h', [0]*nSamples)
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ samples = array.array('h', [0]*nSamples)
- en: 'for i in range(nSamples):'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(nSamples):'
- en: ❸ samples[i] = int(buf[0] * (2 ** 15 - 1))
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ samples[i] = int(buf[0] * (2 ** 15 - 1))
- en: ❹ avg = 0.4975*(buf[0] + buf[1])
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ avg = 0.4975*(buf[0] + buf[1])
- en: buf.append(avg)
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: buf.append(avg)
- en: buf.pop(0)
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: buf.pop(0)
- en: ❺ return samples
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 返回样本
- en: The function starts by setting `nSamples`, the length of the samples buffer
    that will hold the final audio data, to `SR`, the sampling rate. Since `SR` is
    the number of samples per second, this implies that you’ll be creating a one-second
    audio clip. Then you compute `N`, the number of samples in the Karplus-Strong
    ring buffer, by dividing the sampling rate by the frequency of the note being
    generated.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数首先将`nSamples`设置为`SR`，即样本缓冲区的长度，它将保存最终的音频数据。由于`SR`是每秒的样本数，这意味着你将创建一个持续一秒钟的音频片段。然后，通过将采样率除以生成音符的频率，你计算出Karplus-Strong环形缓冲区中的样本数`N`。
- en: Next, you initialize your buffers. First you create the ring buffer with random
    initial values ❶. The `random.random()` method returns values in the range [0.0,
    1.0], so `2*random.random() - 1` scales the values to the range [−1.0, 1.0]. Remember,
    you need both positive and negative amplitudes for the algorithm. Notice that
    you’re implementing the ring buffer as a regular Python list, instead of as a
    `deque` object like you used in [Chapter 4](nsp-venkitachalam503045-0016.xhtml#ch04).
    MicroPython’s `deque` implementation has restrictions and doesn’t give you what
    you need for a ring buffer. Instead, you’ll just use the regular `append()` and
    `pop()` list methods to add and remove elements from the buffer. You also create
    the samples buffer as an `array` object of length `nSamples` filled with zeros
    ❷. The `'h'` argument specifies that each element in this array is a *signed short*,
    a 16-bit value that can be positive or negative. Since each sample will be represented
    by a 16-bit value, this is exactly what you need.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你初始化缓冲区。首先，你创建一个带有随机初始值的环形缓冲区 ❶。`random.random()`方法返回[0.0, 1.0]范围内的值，所以`2*random.random()
    - 1`将这些值缩放到范围[−1.0, 1.0]。记住，算法需要正负幅度值。请注意，你实现的是一个常规的Python列表作为环形缓冲区，而不是像在[第4章](nsp-venkitachalam503045-0016.xhtml#ch04)中那样使用`deque`对象。MicroPython的`deque`实现有一些限制，无法提供你所需的环形缓冲区功能。因此，你将使用常规的`append()`和`pop()`列表方法来添加和移除缓冲区中的元素。你还创建了一个`array`对象作为采样缓冲区，长度为`nSamples`，并用零填充
    ❷。`'h'`参数指定该数组中的每个元素是一个*有符号短整型*，即一个16位的值，可以是正数或负数。由于每个采样值将由16位值表示，因此这正是你所需要的。
- en: Next, you iterate over the items in the `samples` array and build up the audio
    clip using the Karplus-Strong algorithm. You take the first sample value in the
    ring buffer and scale it from range [−1.0, 1.0] to range [−32767, 32767] ❸. (The
    range of a 16-bit signed short is [−32767, 32768]. You scale the amplitude values
    to be as high as possible, which will give you the highest possible volume of
    sound output.) Then you calculate an attenuated average of the first two samples
    in the ring buffer ❹. (Here, `0.4975` is the same as `0.995*0.5` from the original
    implementation.) You use `append()` to add the new amplitude value to the end
    of the ring buffer, while using `pop()` to remove the first element, thus maintaining
    the buffer’s fixed size. At the end of the loop, the samples buffer is full, so
    you return it for further processing ❺.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你遍历`samples`数组中的元素，并使用Karplus-Strong算法构建音频片段。你从环形缓冲区获取第一个采样值，并将其从范围[−1.0,
    1.0]缩放到范围[−32767, 32767] ❸。（16位有符号短整型的范围是[−32767, 32768]。你将幅度值缩放到尽可能高，这样可以获得最大的音量输出。）然后你计算环形缓冲区中前两个采样值的衰减平均值
    ❹。（这里，`0.4975`等同于原始实现中的`0.995*0.5`。）你使用`append()`将新的幅度值添加到环形缓冲区的末尾，同时使用`pop()`移除第一个元素，从而保持缓冲区的固定大小。在循环结束时，采样缓冲区已满，所以你返回它进行进一步处理
    ❺。
- en: NOTE Using `append()` and `pop()` to update the ring buffer works, but it isn’t
    an efficient method of computation. We’ll look more at optimization in [“Experiments!”](nsp-venkitachalam503045-0027.xhtml#ah1406)
    on [page 273](nsp-venkitachalam503045-0027.xhtml#p273).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 使用`append()`和`pop()`更新环形缓冲区是可行的，但这并不是一种高效的计算方法。我们将在[“实验！”](nsp-venkitachalam503045-0027.xhtml#ah1406)中更深入地探讨优化问题，具体内容请见[第273页](nsp-venkitachalam503045-0027.xhtml#p273)。
- en: 'Now let’s consider the `create_notes()` function:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看`create_notes()`函数：
- en: 'def create_notes():'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 'def create_notes():'
- en: '"create pentatonic notes and save to files in flash"'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '"创建五声音符并保存到闪存中的文件"'
- en: ❶ files = os.listdir()
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ files = os.listdir()
- en: '❷ for (k, v) in pmNotes.items():'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '❷ for (k, v) in pmNotes.items():'
- en: '# set note filename'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置音符文件名'
- en: ❸ file_name = k + ".bin"
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ file_name = k + ".bin"
- en: '# check if file already exists'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '# 检查文件是否已存在'
- en: '❹ if file_name in files:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '❹ if file_name in files:'
- en: print("Found " + file_name + ". Skipping...")
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: print("找到 " + file_name + "。跳过...")
- en: continue
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 继续
- en: '# generate note'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '# 生成音符'
- en: print("Generating note " + k + "...")
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: print("正在生成音符 " + k + "...")
- en: ❺ samples = generate_note(v)
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ samples = generate_note(v)
- en: '# write to file'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '# 写入文件'
- en: print("Writing " + file_name + "...")
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: print("正在写入 " + file_name + "...")
- en: ❻ file_samples = open(file_name, "wb")
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ file_samples = open(file_name, "wb")
- en: ❼ file_samples.write(samples)
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ file_samples.write(samples)
- en: ❽ file_samples.close()
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ file_samples.close()
- en: You don’t want to have to run the Karplus-Strong algorithm every time the user
    presses a button to play a note, as that would be too slow. Instead, this function
    creates the notes the first time the code is run and stores them in the Pico’s
    filesystem as *.bin* files. Then, as soon as the user presses a button, you’ll
    be able to read the appropriate file and output the sound data via I2S.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你不希望每次用户按下按钮播放音符时都需要运行 Karplus-Strong 算法，因为那样太慢了。相反，这个函数会在代码第一次运行时创建音符，并将它们以
    *.bin* 文件的形式存储在 Pico 的文件系统中。之后，每当用户按下按钮时，你就能读取相应的文件并通过 I2S 输出声音数据。
- en: You begin by using the `os` module to list the files on the Pico ❶. (There’s
    no “hard disk” on the Pico. Rather, a flash chip on the Pico board is used to
    store data, and MicroPython provides a way to access this data like a normal filesystem.)
    Then you iterate through the items in the `pmNotes` dictionary, which maps note
    names to frequencies ❷. For each note, you generate a filename based on its name
    in the dictionary (for example, *C4.bin*) ❸. If a file with that name exists in
    the directory ❹, you’ve generated that note already, so you can skip to the next
    one. Otherwise, you generate the sound samples for that note using the `generate_note()`
    function ❺. Then you create a binary file with the appropriate name ❻ and write
    the samples to it ❼. Finally, you clean up by closing the file ❽.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先使用 `os` 模块列出 Pico 上的文件 ❶。（Pico 上没有“硬盘”，而是使用 Pico 板上的闪存芯片来存储数据，MicroPython
    提供了一种像访问常规文件系统那样访问这些数据的方法。）然后你遍历 `pmNotes` 字典中的条目，该字典将音符名称映射到频率 ❷。对于每个音符，你根据字典中的名称生成文件名（例如，*C4.bin*）
    ❸。如果该目录下存在该文件 ❹，说明该音符已经生成过了，你可以跳到下一个音符。否则，你通过 `generate_note()` 函数生成该音符的声音样本 ❺。接着，你创建一个适当的二进制文件
    ❻ 并将样本写入其中 ❼。最后，你通过关闭文件来清理 ❽。
- en: The first time you run the code, `create_notes()` will run the `generate_note()`
    function to create a file for each note using the Karplus-Strong algorithm. This
    will create the files *C4.bin*, *Eb.bin*, *F.bin*, *G.bin*, and *Bb.bin* on the
    Pico. On subsequent runs, the function will find these files still in place, so
    it won’t need to create them again.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次运行代码时，`create_notes()` 会运行 `generate_note()` 函数，利用 Karplus-Strong 算法为每个音符创建一个文件。这将会在
    Pico 上创建 *C4.bin*、*Eb.bin*、*F.bin*、*G.bin* 和 *Bb.bin* 文件。在后续的运行中，该函数会发现这些文件已经存在，因此不需要再创建它们。
- en: '[Playing a Note](nsp-venkitachalam503045-0008.xhtml#rbh1407)'
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[播放音符](nsp-venkitachalam503045-0008.xhtml#rbh1407)'
- en: 'The `play_note()` function plays one of the notes from the pentatonic scale
    by outputting the samples using the I2S protocol. Here’s the definition:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`play_note()` 函数通过使用 I2S 协议输出样本来播放五声音阶中的一个音符。下面是该函数的定义：'
- en: 'def play_note(note, audio_out):'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 'def play_note(note, audio_out):'
- en: '"read note from file and send via I2S"'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '"从文件读取音符并通过 I2S 发送"'
- en: ❶ fname = note[0] + ".bin"
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ fname = note[0] + ".bin"
- en: print("opening " + fname)
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: print("正在打开 " + fname)
- en: '# open file'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '# 打开文件'
- en: 'try:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 'try:'
- en: print("opening {}...".format(fname))
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: print("正在打开 {}...".format(fname))
- en: ❷ file_samples = open(fname, "rb")
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ file_samples = open(fname, "rb")
- en: 'except:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 'except:'
- en: 'print("Error opening file: {}!".format(fname))'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: print("打开文件时出错：{}！".format(fname))
- en: return
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: return
- en: '# allocate sample array'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '# 分配样本数组'
- en: ❸ samples = bytearray(1000)
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ samples = bytearray(1000)
- en: '# memoryview used to reduce heap allocation'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '# 使用 memoryview 来减少堆内存分配'
- en: ❹ samples_mv = memoryview(samples)
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ samples_mv = memoryview(samples)
- en: '# read samples and send to I2S'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '# 读取样本并发送到 I2S'
- en: 'try:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 'try:'
- en: '❺ while True:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '❺ while True:'
- en: ❻ num_read = file_samples.readinto(samples_mv)
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ num_read = file_samples.readinto(samples_mv)
- en: '# end of file?'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '# 文件结束？'
- en: '❼ if num_read == 0:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '❼ 如果 num_read == 0:'
- en: break
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: break
- en: 'else:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: '# send samples via I2S'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '# 通过 I2S 发送样本'
- en: ❽ num_written = audio_out.write(samples_mv[:num_read])
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ num_written = audio_out.write(samples_mv[:num_read])
- en: '❾ except (Exception) as e:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '❾ except (Exception) as e:'
- en: 'print("Exception: {}".format(e))'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: print("异常：{}".format(e))
- en: '# close file'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '# 关闭文件'
- en: ❿ file_samples.close()
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ❿ file_samples.close()
- en: 'The function has two arguments: `note`, a tuple in the form `(''C4'', 262)`
    conveying the note name and frequency, and `audio_out`, an instance of the `I2S`
    module used for sound output. You first create the appropriate *.bin* filename
    based on the name of the note to be played ❶. Then you open the file ❷. You expect
    the file to exist at this point, so if the open fails, you just return from the
    function.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数有两个参数：`note`，一个元组，形式为 `('C4', 262)`，表示音符名称和频率，以及 `audio_out`，它是 `I2S` 模块的实例，用于声音输出。你首先根据要播放的音符名称创建适当的
    *.bin* 文件名 ❶。然后你打开该文件 ❷。此时你期望文件已经存在，所以如果打开失败，你就直接从函数中返回。
- en: The rest of the function outputs the audio data via I2S, working in batches
    of 1,000 samples. To mediate the data transfer, you create a MicroPython `bytearray`
    of 1,000 samples ❸ and a `memoryview` of the samples ❹. This is a MicroPython
    optimization technique to prevent the whole array from being copied when a slice
    of the array is passed into other functions such as `file_samples.readinto()`
    and `audio_out.write()`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数的其余部分通过 I2S 输出音频数据，按每批 1,000 个样本处理。为了调节数据传输，你创建了一个包含 1,000 个样本的 MicroPython
    `bytearray` ❸ 和一个样本的 `memoryview` ❹。这是一个 MicroPython 的优化技巧，可以防止在将数组片段传递给其他函数（如
    `file_samples.readinto()` 和 `audio_out.write()`）时，整个数组被复制。
- en: NOTE A *slice* of an array represents a range of values within that array. For
    example, `a[100:200]` is a slice representing array values `a[100]` through `a[199]`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：数组的 *切片* 表示数组中的一段值。例如，`a[100:200]` 是一个切片，表示数组 `a[100]` 到 `a[199]` 的值。
- en: Next, you start a `while` loop to read samples from the file ❺. In the loop,
    you read a batch of samples from the file into the `memoryview` object using the
    `readinto()` method ❻, which returns the number of samples read (`num_read`).
    You output the samples from the `memoryview` object via I2S using the `audio_out.write()`
    method ❽. The `[:num_read]` slice notation ensures you write out the same number
    of samples you read in. You handle any exceptions at ❾. You’re done outputting
    data when you get to the point where zero samples are read into the `memoryview`
    object ❼, in which case you can break out of the `while` loop and close the *.bin*
    file ❿.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你启动一个 `while` 循环，从文件中读取样本 ❺。在循环中，你使用 `readinto()` 方法将文件中的一批样本读取到 `memoryview`
    对象中 ❻，该方法返回读取的样本数量（`num_read`）。你通过 I2S 使用 `audio_out.write()` 方法从 `memoryview`
    对象输出样本 ❽。`[:num_read]` 切片符号确保你写出的样本数与读取的样本数相同。你在 ❾ 处处理任何异常。当读取到 `memoryview` 对象中零个样本时
    ❼，就完成数据输出，这时可以跳出 `while` 循环并关闭 *.bin* 文件 ❿。
- en: '[Writing the main() Function](nsp-venkitachalam503045-0008.xhtml#rbh1408)'
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[编写 main() 函数](nsp-venkitachalam503045-0008.xhtml#rbh1408)'
- en: 'Now let’s look at the `main()` function, which brings all the code together:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下 `main()` 函数，它将所有代码组合在一起：
- en: 'def main():'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 'def main():'
- en: '# set up LED'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置 LED'
- en: ❶ led = Pin(25, Pin.OUT)
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ led = Pin(25, Pin.OUT)
- en: '# turn on LED'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '# 打开 LED'
- en: led.toggle()
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: led.toggle()
- en: '# create notes and save in flash'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '# 创建音符并保存在闪存中'
- en: ❷ create_notes()
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ create_notes()
- en: '# create I2S object'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '# 创建 I2S 对象'
- en: ❸ audio_out = I2S(
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ audio_out = I2S(
- en: 0,                  # I2S ID
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 0,                  # I2S ID
- en: sck=Pin(0),         # SCK Pin
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: sck=Pin(0),         # SCK 引脚
- en: ws=Pin(1),          # WS Pin
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: ws=Pin(1),          # WS 引脚
- en: sd=Pin(2),          # SD Pin
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: sd=Pin(2),          # SD 引脚
- en: mode=I2S.TX,        # I2S transmitter
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: mode=I2S.TX,        # I2S 发射器
- en: bits=16,            # 16 bits per sample
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: bits=16,            # 每个样本 16 位
- en: format=I2S.MONO,    # Mono - single channel
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: format=I2S.MONO,    # 单声道 - 单个通道
- en: rate=SR,            # sample rate
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: rate=SR,            # 采样率
- en: ibuf=2000,          # I2S buffer length
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: ibuf=2000,          # I2S 缓冲区长度
- en: )
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '# set up btns'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置按钮'
- en: ❹ btns = [Pin(3, Pin.IN, Pin.PULL_UP),
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ btns = [Pin(3, Pin.IN, Pin.PULL_UP),
- en: Pin(4, Pin.IN, Pin.PULL_UP),
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Pin(4, Pin.IN, Pin.PULL_UP),
- en: Pin(5, Pin.IN, Pin.PULL_UP),
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Pin(5, Pin.IN, Pin.PULL_UP),
- en: Pin(6, Pin.IN, Pin.PULL_UP),
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Pin(6, Pin.IN, Pin.PULL_UP),
- en: Pin(7, Pin.IN, Pin.PULL_UP)]
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Pin(7, Pin.IN, Pin.PULL_UP)]
- en: '# "ready" note'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '# “准备好”标志'
- en: ❺ play_note(('C4', 262), audio_out)
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ play_note(('C4', 262), audio_out)
- en: print("Piano ready!")
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: print("钢琴准备好了！")
- en: '# turn off LED'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '# 关闭 LED'
- en: ❻ led.toggle()
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ led.toggle()
- en: 'while True:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: 'for i in range(5):'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(5):'
- en: 'if btns[i].value() == 0:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 'if btns[i].value() == 0:'
- en: ❼ play_note(btnNotes[i], audio_out)
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ play_note(btnNotes[i], audio_out)
- en: break
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: break
- en: ❽ time.sleep(0.2)
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ time.sleep(0.2)
- en: The function starts by setting up the Pico’s onboard LED ❶. It’s toggled ON
    at the start to indicate the Pico is busy initializing. Next, you call the `create_notes()`
    function ❷. As we discussed, this function will create the *.bin* files for the
    notes only if they don’t already exist in the filesystem. To manage the audio
    output, you instantiate the `I2S` module as `audio_out` ❸. The module requires
    a number of input parameters. The first parameter is the I2S ID, which is `0`
    for the Raspberry Pi Pico. Next come the pin numbers corresponding to the clock
    (SCK), word select (WS), and data (SD) signals. We discussed these signals in
    [“I2S Protocol”](nsp-venkitachalam503045-0027.xhtml#bh1402) [on page 262](nsp-venkitachalam503045-0027.xhtml#p262).
    You then set the I2S mode to `TX`, indicating this is an I2S transmitter. Next,
    you set `bits` to `16`, indicating the number of bits per sample, and `format`
    to `MONO`, since there’s only one audio output channel. You set the sampling rate
    to `SR`, and lastly, you set the value for the internal I2S buffer `ibuf` to `2000`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的开始是设置 Pico 上的板载 LED ❶。它在开始时切换为 ON，以表示 Pico 正在忙于初始化。接下来，您调用 `create_notes()`
    函数 ❷。正如我们讨论的，这个函数仅在文件系统中不存在时，才会为音符创建 *.bin* 文件。为了管理音频输出，您实例化 `I2S` 模块为 `audio_out`
    ❸。该模块需要多个输入参数。第一个参数是 I2S ID，对于 Raspberry Pi Pico，ID 为 `0`。接下来是与时钟（SCK）、字选择（WS）和数据（SD）信号对应的引脚号。我们在[“I2S
    协议”](nsp-venkitachalam503045-0027.xhtml#bh1402) [第 262 页](nsp-venkitachalam503045-0027.xhtml#p262)中讨论过这些信号。然后，您将
    I2S 模式设置为 `TX`，表示这是一个 I2S 发送器。接下来，将 `bits` 设置为 `16`，表示每个样本的位数，并将 `format` 设置为
    `MONO`，因为只有一个音频输出通道。您将采样率设置为 `SR`，最后，设置内部 I2S 缓冲区 `ibuf` 的值为 `2000`。
- en: NOTE A smooth audio experience requires an uninterrupted stream of data output.
    MicroPython uses a special hardware module in the Pico called Direct Memory Access
    (DMA) for this. DMA can transfer data from the memory to the I2S output without
    involving the CPU directly. The CPU just needs to keep an internal buffer (`ibuf`
    in the code) filled with data and is free to do other things while the DMA is
    doing its job. The size of the internal buffer is typically set to at least twice
    the size of the audio output so the DMA doesn’t run out of data to transfer, which
    would result in distorted audio. In this case, you’ll be transferring 1,000 bytes
    to I2S at a time, so you set `ibuf` to twice that.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：流畅的音频体验需要连续不断的数据输出。MicroPython 使用 Pico 中的一个特殊硬件模块，称为直接内存访问（DMA）。DMA 可以在不直接涉及
    CPU 的情况下，将数据从内存传输到 I2S 输出。CPU 只需要保持内部缓冲区（代码中的`ibuf`）填充数据，同时 DMA 执行任务时，CPU 可以自由执行其他操作。内部缓冲区的大小通常设置为音频输出的两倍，确保
    DMA 不会因数据不足而导致音频失真。在这种情况下，您将每次传输 1,000 字节到 I2S，因此将 `ibuf` 设置为两倍大小。
- en: Next, you need to set up the buttons so that notes will play when the buttons
    are pressed. For this, you create a list of `Pin` objects called `btns` ❹. For
    each button in the list, you specify the pin number, the data direction of the
    pin (`Pin.IN`, or input, in this case), and whether the pin has a pull-up resistor.
    In this case, all the push button pins have a 10 kΩ resistor pull-up on them.
    This means that by default the pins’ voltages are “pulled up” to VDD, or 3.3 V,
    and when the buttons are pushed, the voltage drops to GND, or 0 V. You’ll use
    this fact to detect button presses.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您需要设置按钮，使得在按钮按下时会播放音符。为此，您创建一个名为 `btns` ❹ 的 `Pin` 对象列表。对于列表中的每个按钮，您需要指定引脚号、引脚的数据方向（在本例中为
    `Pin.IN`，即输入），以及该引脚是否有上拉电阻。在本例中，所有的按键引脚上都有一个 10 kΩ 的上拉电阻。这意味着默认情况下，引脚的电压会被“拉高”至
    VDD，即 3.3 V，而当按钮被按下时，电压会下降至 GND，即 0 V。您将利用这一点来检测按钮的按下。
- en: Once the setup is done, you play a C4 note using the `play_note()` function
    to indicate the Pico is ready to accept button presses ❺, and you also toggle
    the onboard LED to OFF ❻. Then you start a `while` loop to monitor for button
    presses. Within this loop, you use a `for` loop to check whether any of the five
    buttons have a value of `0`, indicating the button is pressed. If so, you look
    up the note corresponding to that button in the `btnNotes` dictionary and play
    it using `play_note()` ❼. Once the note is done playing, you break out of the
    `for` loop and wait for 0.2 seconds ❽ before continuing with the outer `while`
    loop.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 设置完成后，使用 `play_note()` 函数播放 C4 音符，以表明 Pico 已准备好接受按键输入 ❺，同时将板载 LED 切换为 OFF ❻。接着，启动一个
    `while` 循环来监控按键按下情况。在这个循环中，你使用 `for` 循环检查五个按钮中是否有任何一个的值为 `0`，表示按钮被按下。如果是，你会在 `btnNotes`
    字典中查找对应按钮的音符，并使用 `play_note()` 播放该音符 ❼。当音符播放完成后，跳出 `for` 循环，并等待 0.2 秒 ❽ 后继续执行外部的
    `while` 循环。
- en: '[Running the Pico Code](nsp-venkitachalam503045-0008.xhtml#rah1404)'
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[运行 Pico 代码](nsp-venkitachalam503045-0008.xhtml#rah1404)'
- en: 'Now you’re ready to test your project! To run the code on the Pico, it’s useful
    to install two pieces of software. The first is Thonny, an open source, easy-to-use
    Python integrated development environment (IDE), which you can download from [https://thonny.org](https://thonny.org).
    Thonny makes it easy to copy your project code to the Raspberry Pi Pico and manage
    files on the Pico. A typical development cycle is as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经准备好测试你的项目了！为了在 Pico 上运行代码，安装两个软件是很有用的。第一个是 Thonny，一个开源、易于使用的 Python 集成开发环境（IDE），你可以从
    [https://thonny.org](https://thonny.org) 下载。Thonny 让你轻松将项目代码复制到 Raspberry Pi Pico，并管理
    Pico 上的文件。一个典型的开发周期如下：
- en: 1\. Connect your Pico to your computer via USB.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1\. 通过 USB 将你的 Pico 连接到电脑。
- en: 2\. Open Thonny. Click the Python version number in the bottom-right of the
    window and change the interpreter to **MicroPython (Raspberry Pi Pico)**.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2\. 打开 Thonny。点击窗口右下角的 Python 版本号，将解释器更改为 **MicroPython (Raspberry Pi Pico)**。
- en: 3\. Copy your code to Thonny and click the red **Stop/Restart** button to stop
    the code from running on the Pico. This will show the Python interpreter at the
    bottom of the IDE.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3\. 将你的代码复制到 Thonny 中，点击红色的 **停止/重启** 按钮，停止代码在 Pico 上运行。这时，Python 解释器会显示在 IDE
    的底部。
- en: 4\. Edit your code in Thonny.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 4\. 在 Thonny 中编辑你的代码。
- en: 5\. When you’re ready to save the file, select **File‣Save As**, and you’ll
    be prompted to save it on the Raspberry Pi Pico. The next dialog will also list
    the files on the Pico. Save your code as *main.py*. You can also use this dialog
    to right-click and delete existing files on the Pico.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 5\. 当你准备保存文件时，选择 **文件‣另存为**，系统会提示你在 Raspberry Pi Pico 上保存文件。接下来的对话框也会列出 Pico
    上的文件。将你的代码保存为 *main.py*。你还可以使用这个对话框右键点击并删除 Pico 上现有的文件。
- en: 6\. After saving the file, press the extra push button you hooked up to the
    RUN pin on the Pico, and your code will start running.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 6\. 保存文件后，按下连接到 Pico 上 RUN 引脚的额外按键，代码将开始运行。
- en: 7\. Anytime you want to edit the code, click the **Stop/Restart** button in
    the IDE and Thonny will drop you to the Python interpreter on the Pico.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 7\. 每当你想编辑代码时，点击 IDE 中的 **停止/重启** 按钮，Thonny 会将你带到 Pico 上的 Python 解释器。
- en: The other useful piece of software for working with the Pico is CoolTerm, which
    you can download from [http://freeware.the-meiers.org](http://freeware.the-meiers.org).
    CoolTerm lets you monitor the Pico’s serial output. All print statements from
    your program will end up here. To use CoolTerm, ensure that you aren’t “stopped”
    in Thonny. The Pico code should be in the running state, since the Pico can’t
    connect to both Thonny and CoolTerm at the same time.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个在使用 Pico 时非常有用的软件是 CoolTerm，你可以从 [http://freeware.the-meiers.org](http://freeware.the-meiers.org)
    下载。CoolTerm 让你监控 Pico 的串口输出。程序中的所有打印语句都会显示在这里。使用 CoolTerm 时，确保 Thonny 不是处于“停止”状态。Pico
    代码应该是运行状态，因为 Pico 无法同时连接到 Thonny 和 CoolTerm。
- en: Once you have the code running, press the push buttons one by one and you’ll
    hear the notes of a nice pentatonic scale coming out of your speaker. [Figure
    12-8](nsp-venkitachalam503045-0027.xhtml#fig12-8) shows the serial output for
    a typical session.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦代码运行起来，按下一个个按键，你会听到从扬声器传出的美妙五声音阶。[图 12-8](nsp-venkitachalam503045-0027.xhtml#fig12-8)
    显示了典型会话的串口输出。
- en: '![](images/nsp-venkitachalam503045-f12008.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f12008.jpg)'
- en: 'Figure 12-8: A sample Raspberry Pi Pico output in CoolTerm'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-8：CoolTerm 中的 Raspberry Pi Pico 输出示例
- en: See what melodies you can compose and play using your digital instrument’s five
    push buttons!
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 看看你能用数字乐器的五个按钮编排并演奏出什么旋律！
- en: '[Summary](nsp-venkitachalam503045-0008.xhtml#rah1405)'
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[总结](nsp-venkitachalam503045-0008.xhtml#rah1405)'
- en: In this chapter, you adapted your Karplus-Strong algorithm implementation from
    [Chapter 4](nsp-venkitachalam503045-0016.xhtml#ch04) to run on a tiny microcontroller
    and built a digital musical instrument using a Raspberry Pi Pico. You learned
    how to run Python (in the form of MicroPython) on the Pico, as well as how to
    transmit audio data using the I2S protocol. You also learned about the limitations
    of adapting code from a personal computer to a resource-constrained device like
    the Pico.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将你的 Karplus-Strong 算法实现从[第 4 章](nsp-venkitachalam503045-0016.xhtml#ch04)中调整，使其能够在一个小型微控制器上运行，并利用
    Raspberry Pi Pico 构建了一个数字乐器。你学会了如何在 Pico 上运行 Python（以 MicroPython 形式），以及如何使用 I2S
    协议传输音频数据。你还了解了从个人计算机到资源受限设备（如 Pico）的代码迁移限制。
- en: '[Experiments!](nsp-venkitachalam503045-0008.xhtml#rah1406)'
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[实验!](nsp-venkitachalam503045-0008.xhtml#rah1406)'
- en: 1\. The MAX98357A I2S board lets you increase the volume (gain) of the output.
    Look at the datasheet of this board and try to boost the sound coming from the
    speaker.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1\. MAX98357A I2S 板可以让你增加输出的音量（增益）。查看该板的 datasheet 并尝试提高从扬声器发出的声音。
- en: '2\. The current implementation of `generate_note()` isn’t very fast. It didn’t
    matter that much for this project, because you generate the notes only once. Still,
    can you make the method faster? Here are a few strategies to try:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2\. 当前的 `generate_note()` 实现速度不快。对于这个项目来说这并不重要，因为你只生成一次音符。但你能让这个方法更快吗？这里有一些策略可以尝试：
- en: a. Instead of using `append()` and `pop()` operations on the `buf` list, turn
    the list into a circular buffer by keeping tracking of the current position in
    the list and incrementing it using the modulo operation `%N`.
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: a. 不要在 `buf` 列表上使用 `append()` 和 `pop()` 操作，而是通过跟踪当前列表位置并使用取模操作 `%N` 来将列表转换为循环缓冲区。
- en: b. Use integer operations instead of floating point. You’ll have to think about
    how the initial random values will be generated and scaled.
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: b. 使用整数运算代替浮点运算。你需要考虑如何生成和缩放初始的随机值。
- en: 'The Language Reference page in the MicroPython documentation ([https://docs.micropython.org](https://docs.micropython.org/))
    has an article on maximizing the speed of your code. The documentation also suggests
    how you can test your results. First, define a function to measure timing:'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: MicroPython 文档中的语言参考页面 ([https://docs.micropython.org](https://docs.micropython.org/))
    上有一篇关于最大化代码速度的文章。文档还建议了如何测试你的结果。首先，定义一个用于计时的函数：
- en: 'def timed_function(f, *args, **kwargs):'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'def timed_function(f, *args, **kwargs):'
- en: myname = str(f).split(' ')[1]
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: myname = str(f).split(' ')[1]
- en: 'def new_func(*args, **kwargs):'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'def new_func(*args, **kwargs):'
- en: t = time.monotonic()
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: t = time.monotonic()
- en: result = f(*args, **kwargs)
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: result = f(*args, **kwargs)
- en: delta = time.monotonic() - t
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: delta = time.monotonic() - t
- en: print('Function {} Time = {:f} s'.format(myname, delta))
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: print('函数 {} 时间 = {:f} 秒'.format(myname, delta))
- en: return result
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return result
- en: return new_func
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return new_func
- en: 'Then use `timed_function()` as a *decorator* for the function you want to time:'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后使用 `timed_function()` 作为你想要计时的函数的 *装饰器*：
- en: generate note of given frequency
  id: totrans-250
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成给定频率的音符
- en: '@timed_function'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '@timed_function'
- en: 'def generateNote(freq):'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'def generateNote(freq):'
- en: nSamples = SR
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: nSamples = SR
- en: N = int(SR/freq)
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: N = int(SR/freq)
- en: --`snip`--
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: --`snip`--
- en: 'When you call `generateNote()` in your main code, you’ll see something like
    this in the serial output:'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你在主代码中调用 `generateNote()` 时，你会在串行输出中看到类似下面的内容：
- en: Function generateNote Time = 1019.711ms
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 函数 generateNote 时间 = 1019.711ms
- en: 3\. When you press a hardware push button, it doesn’t just go from ON to OFF,
    or the reverse. The spring-loaded contacts inside the button bounce between ON
    and OFF multiple times in a fraction of a second, triggering multiple software
    events for one physical press of the button. Think about how this could affect
    your project, and then read up on *debouncing*, a class of techniques for mitigating
    the problem. What steps can you take to debounce your buttons?
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3\. 当你按下硬件按钮时，它不会只是从开到关，或反之。按钮内的弹簧接触点会在极短的时间内在开和关之间反复弹跳，这会触发多个软件事件，仅仅是一次物理按压。想一想这会如何影响你的项目，然后学习关于
    *去抖动* 的技巧，这是一类用于缓解此问题的技术。你可以采取哪些步骤来去抖动你的按钮？
- en: 4\. When you press a button, a new note isn’t played until the current note
    is done playing. How can you abruptly stop playing the current note when a new
    button is pressed and switch to playing the new note immediately?
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 4\. 当你按下按钮时，新的音符不会在当前音符播放完之前开始播放。如何在按下新按钮时立即停止当前音符并切换到播放新音符？
- en: '[The Complete Code](nsp-venkitachalam503045-0008.xhtml#rah1407)'
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[完整代码](nsp-venkitachalam503045-0008.xhtml#rah1407)'
- en: Here’s the full code listing for this project.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这是此项目的完整代码列表。
- en: '"""'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: karplus_pico.py
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: karplus_pico.py
- en: Uses the Karplus-Strong algorithm to generate musical notes in a
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Karplus-Strong 算法生成音乐音符
- en: pentatonic scale. Runs on a Raspberry Pi Pico. (MicroPython)
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 五声音阶。运行在树莓派Pico上。（MicroPython）
- en: 'Author: Mahesh Venkitachalam'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 作者：Mahesh Venkitachalam
- en: '"""'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: import time
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: import time
- en: import array
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: import array
- en: import random
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: import random
- en: import os
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: import os
- en: from machine import I2S
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: from machine import I2S
- en: from machine import Pin
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: from machine import Pin
- en: notes of a minor pentatonic scale
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 小调五声音阶的音符
- en: piano C4-E(b)-F-G-B(b)-C5
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 钢琴 C4-E(b)-F-G-B(b)-C5
- en: 'pmNotes = {''C4'': 262, ''Eb'': 311, ''F'': 349, ''G'':391, ''Bb'':466}'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 'pmNotes = {''C4'': 262, ''Eb'': 311, ''F'': 349, ''G'':391, ''Bb'':466}'
- en: button to note mapping
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按钮到音符的映射
- en: 'btnNotes = {0: (''C4'', 262), 1: (''Eb'', 311), 2: (''F'', 349), 3: (''G'',
    391),'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 'btnNotes = {0: (''C4'', 262), 1: (''Eb'', 311), 2: (''F'', 349), 3: (''G'',
    391),'
- en: '4: (''Bb'', 466)}'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '4: (''Bb'', 466)}'
- en: sample rate
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: sample rate
- en: SR = 16000
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: SR = 16000
- en: 'def timed_function(f, *args, **kwargs):'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 'def timed_function(f, *args, **kwargs):'
- en: myname = str(f).split(' ')[1]
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: myname = str(f).split(' ')[1]
- en: 'def new_func(*args, **kwargs):'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 'def new_func(*args, **kwargs):'
- en: t = time.ticks_us()
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: t = time.ticks_us()
- en: result = f(*args, **kwargs)
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: result = f(*args, **kwargs)
- en: delta = time.ticks_diff(time.ticks_us(), t)
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: delta = time.ticks_diff(time.ticks_us(), t)
- en: print('Function {} Time = {:6.3f}ms'.format(myname, delta/1000))
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: print('函数 {} 时间 = {:6.3f}ms'.format(myname, delta/1000))
- en: return result
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: return result
- en: return new_func
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: return new_func
- en: generate note of given frequency
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成给定频率的音符
- en: (Uncomment line below when you need to time the function.)
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: （当你需要计时函数时，取消注释下面的行。）
- en: '@timed_function'
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '@timed_function'
- en: 'def generate_note(freq):'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 'def generate_note(freq):'
- en: nSamples = SR
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: nSamples = SR
- en: N = int(SR/freq)
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: N = int(SR/freq)
- en: '# initialize ring buffer'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '# 初始化环形缓冲区'
- en: buf = [2*random.random() - 1 for i in range(N)]
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: buf = [2*random.random() - 1 for i in range(N)]
- en: '# init sample buffer'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '# 初始化样本缓冲区'
- en: samples = array.array('h', [0]*nSamples)
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: samples = array.array('h', [0]*nSamples)
- en: 'for i in range(nSamples):'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(nSamples):'
- en: samples[i] = int(buf[0] * (2 ** 15 - 1))
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: samples[i] = int(buf[0] * (2 ** 15 - 1))
- en: avg = 0.4975*(buf[0] + buf[1])
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: avg = 0.4975*(buf[0] + buf[1])
- en: buf.append(avg)
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: buf.append(avg)
- en: buf.pop(0)
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: buf.pop(0)
- en: return samples
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: return samples
- en: generate note of given frequency - improved method
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成给定频率音符 - 改进方法
- en: 'def generate_note2(freq):'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 'def generate_note2(freq):'
- en: nSamples = SR
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: nSamples = SR
- en: sampleRate = SR
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: sampleRate = SR
- en: N = int(sampleRate/freq)
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: N = int(sampleRate/freq)
- en: '# initialize ring buffer'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '# 初始化环形缓冲区'
- en: buf = [2*random.random() - 1 for i in range(N)]
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: buf = [2*random.random() - 1 for i in range(N)]
- en: '# init sample buffer'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '# 初始化样本缓冲区'
- en: samples = array.array('h', [0]*nSamples)
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: samples = array.array('h', [0]*nSamples)
- en: start = 0
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: start = 0
- en: 'for i in range(nSamples):'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(nSamples):'
- en: samples[i] = int(buf[start] * (2**15 - 1))
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: samples[i] = int(buf[start] * (2**15 - 1))
- en: avg = 0.4975*(buf[start] + buf[(start + 1) % N])
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: avg = 0.4975*(buf[start] + buf[(start + 1) % N])
- en: buf[(start + N) % N] = avg
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: buf[(start + N) % N] = avg
- en: start = (start + 1) % N
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: start = (start + 1) % N
- en: return samples
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: return samples
- en: 'def play_note(note, audio_out):'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 'def play_note(note, audio_out):'
- en: '"read note from file and send via I2S"'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '"从文件读取音符并通过 I2S 发送"'
- en: fname = note[0] + ".bin"
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: fname = note[0] + ".bin"
- en: '# open file'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '# 打开文件'
- en: 'try:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 'try:'
- en: print("opening {}...".format(fname))
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: print("正在打开 {}...".format(fname))
- en: file_samples = open(fname, "rb")
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: file_samples = open(fname, "rb")
- en: 'except:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 'except:'
- en: 'print("Error opening file: {}!".format(fname))'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: print("打开文件出错：{}!".format(fname))
- en: return
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: return
- en: '# allocate sample array'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '# 分配样本数组'
- en: samples = bytearray(1000)
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: samples = bytearray(1000)
- en: '# memoryview used to reduce heap allocation'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '# 使用 memoryview 来减少堆分配'
- en: samples_mv = memoryview(samples)
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: samples_mv = memoryview(samples)
- en: '# read samples and send to I2S'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '# 读取样本并发送到 I2S'
- en: 'try:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 'try:'
- en: 'while True:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: num_read = file_samples.readinto(samples_mv)
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: num_read = file_samples.readinto(samples_mv)
- en: '# end of file?'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '# 文件结束？'
- en: 'if num_read == 0:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 'if num_read == 0:'
- en: break
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: break
- en: 'else:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: '# send samples via I2S'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '# 通过 I2S 发送样本'
- en: num_written = audio_out.write(samples_mv[:num_read])
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: num_written = audio_out.write(samples_mv[:num_read])
- en: 'except (Exception) as e:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 'except (Exception) as e:'
- en: 'print("Exception: {}".format(e))'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: print("异常：{}".format(e))
- en: '# close file'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '# 关闭文件'
- en: file_samples.close()
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: file_samples.close()
- en: 'def create_notes():'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 'def create_notes():'
- en: '"create pentatonic notes and save to files in flash"'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '"创建五声音阶音符并将其保存到闪存文件中"'
- en: files = os.listdir()
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: files = os.listdir()
- en: 'for (k, v) in pmNotes.items():'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 'for (k, v) in pmNotes.items():'
- en: '# set note filename'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置音符文件名'
- en: file_name = k + ".bin"
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: file_name = k + ".bin"
- en: '# check if file already exists'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '# 检查文件是否已经存在'
- en: 'if file_name in files:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 'if file_name in files:'
- en: print("Found " + file_name + ". Skipping...")
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: print("找到 " + file_name + "。跳过...")
- en: continue
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: continue
- en: '# generate note'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '# 生成音符'
- en: print("Generating note " + k + "...")
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: print("生成音符 " + k + "...")
- en: samples = generate_note(v)
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: samples = generate_note(v)
- en: '# write to file'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '# 写入文件'
- en: print("Writing " + file_name + "...")
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: print("写入 " + file_name + "...")
- en: file_samples = open(file_name, "wb")
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: file_samples = open(file_name, "wb")
- en: file_samples.write(samples)
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: file_samples.write(samples)
- en: file_samples.close()
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: file_samples.close()
- en: 'def main():'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 'def main():'
- en: '# set up LED'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置 LED'
- en: led = Pin(25, Pin.OUT)
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: led = Pin(25, Pin.OUT)
- en: '# turn on LED'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '# 打开 LED'
- en: led.toggle()
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: led.toggle()
- en: '# create notes and save in flash'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '# 创建音符并保存在闪存中'
- en: create_notes()
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: create_notes()
- en: '# create I2S object'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '# 创建 I2S 对象'
- en: audio_out = I2S(
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: audio_out = I2S(
- en: 0,                  # I2S ID
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '0,                  # I2S ID'
- en: sck=Pin(0),         # SCK Pin
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 'sck=Pin(0),         # SCK 引脚'
- en: ws=Pin(1),          # WS Pin
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 'ws=Pin(1),          # WS 引脚'
- en: sd=Pin(2),          # SD Pin
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 'sd=Pin(2),          # SD 引脚'
- en: mode=I2S.TX,        # I2S transmitter
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 'mode=I2S.TX,        # I2S 发送器'
- en: bits=16,            # 16 bits per sample
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 'bits=16,            # 每个采样16位'
- en: format=I2S.MONO,    # Mono - single channel
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 'format=I2S.MONO,    # 单声道 - 单通道'
- en: rate=SR,            # sample rate
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 'rate=SR,            # 采样率'
- en: ibuf=2000,          # I2S buffer length
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 'ibuf=2000,          # I2S 缓冲区长度'
- en: )
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '# set up btns'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置按钮'
- en: btns = [Pin(3, Pin.IN, Pin.PULL_UP),
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: btns = [Pin(3, Pin.IN, Pin.PULL_UP),
- en: Pin(4, Pin.IN, Pin.PULL_UP),
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: Pin(4, Pin.IN, Pin.PULL_UP),
- en: Pin(5, Pin.IN, Pin.PULL_UP),
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: Pin(5, Pin.IN, Pin.PULL_UP),
- en: Pin(6, Pin.IN, Pin.PULL_UP),
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: Pin(6, Pin.IN, Pin.PULL_UP),
- en: Pin(7, Pin.IN, Pin.PULL_UP)]
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: Pin(7, Pin.IN, Pin.PULL_UP)]
- en: '# "ready" note'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '# "准备好" 音符'
- en: play_note(('C4', 262), audio_out)
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: play_note(('C4', 262), audio_out)
- en: print("Piano ready!")
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: print("钢琴准备好！")
- en: '# turn off LED'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '# 关闭 LED'
- en: led.toggle()
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: led.toggle()
- en: 'while True:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: 'for i in range(5):'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(5):'
- en: 'if btns[i].value() == 0:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 'if btns[i].value() == 0:'
- en: play_note(btnNotes[i], audio_out)
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: play_note(btnNotes[i], audio_out)
- en: break
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 休息
- en: time.sleep(0.2)
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: time.sleep(0.2)
- en: call main
  id: totrans-405
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: call main
- en: 'if __name__ == ''__main__'':'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: main()
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: main()
