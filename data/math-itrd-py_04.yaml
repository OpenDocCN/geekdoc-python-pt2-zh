- en: '3'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '3'
- en: GUESSING AND CHECKING WITH CONDITIONALS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用条件语句进行猜测和检查
- en: '*“Put your dough into the oven when it is hot: After making sure that it is
    in fact dough.” —Idries Shah*, Learning How to Learn'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*“当它热时，将面团放入烤箱：确保它确实是面团之后。” — 伊德里斯·沙阿，《学习如何学习》'
- en: '![image](../images/fintro-01.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fintro-01.jpg)'
- en: In almost every program you write for this book, you’re going to instruct the
    computer to make a decision. You can do this using an important programming tool
    called *conditionals*. In programming we can use conditional statements
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在你为本书编写的几乎每个程序中，你都会指示计算机做出决策。你可以使用一个非常重要的编程工具，称为*条件语句*，来做到这一点。在编程中，我们可以使用条件语句
- en: like “If this variable is more than 100, do this; otherwise, do that” to check
    whether certain conditions are met and then determine what to do based on the
    result. In fact, this is a very powerful method that we apply to big problems,
    and it’s even at the heart of machine learning. At its most basic level, the program
    is guessing and then modifying its guesses based on feedback.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 比如“如果这个变量大于100，就做这个；否则，做那个”，用来检查某些条件是否满足，然后根据结果决定接下来该做什么。事实上，这是一种非常强大的方法，我们在解决大问题时会用到，甚至它是机器学习的核心。在最基本的层面上，程序是在进行猜测，然后根据反馈修改其猜测。
- en: In this chapter you learn how to apply the guess-and-check method using Python
    to take user input and tell the program what to print depending on the input.
    You then use conditionals to compare different numerical values in different mathematical
    situations to make a turtle wander around the screen randomly. You also create
    a number-guessing game and use the same logic to find the square root of large
    numbers.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何使用猜测与检查方法，通过 Python 获取用户输入，并根据输入告诉程序打印什么内容。然后你将使用条件语句比较不同的数值，在不同的数学情境下使海龟在屏幕上随机漫游。你还将创建一个猜数字游戏，并使用相同的逻辑来找到大数的平方根。
- en: COMPARISON OPERATORS
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 比较运算符
- en: 'As you learned in [Chapter 2](ch02.xhtml#ch02), `True` and `False` (which we
    capitalize in Python) are called Boolean values. Python returns Booleans when
    comparing two values, allowing you to use the result to decide what to do next.
    For example, we can use comparison operators like greater than (`>`) or less than
    (`<`) to compare two values, like this:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在[第二章](ch02.xhtml#ch02)中学到的，`True` 和 `False`（在 Python 中我们将其大写）称为布尔值。Python
    在比较两个值时会返回布尔值，你可以使用这些结果来决定接下来要做什么。例如，我们可以使用比较运算符，如大于（`>`）或小于（`<`）来比较两个值，像这样：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, we ask Python whether 6 is greater than 5, and Python returns `True`.
    Then we ask whether 6 is greater than 7, and Python returns `False`.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们让 Python 判断6是否大于5，Python 返回`True`。接着我们问6是否大于7，Python 返回`False`。
- en: 'Recall that in Python we use one equal sign to assign a value to a variable.
    But checking for equality requires two equal signs (`==`), as shown here:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下，在 Python 中我们使用一个等号来给变量赋值。但检查相等性需要两个等号（`==`），如下所示：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As you can see, when we try to check using only one equal sign, we get a syntax
    error. We can also use comparison operators to compare variables:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，当我们尝试只使用一个等号进行检查时，会出现语法错误。我们还可以使用比较运算符来比较变量：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We set the variable `y` to contain 3, and then set the variable `x` to contain
    4\. Then we use those variables to ask whether `y` is greater than `x`, so Python
    returns `False`. Then we asked whether `y` is less than 10, which returns `True`.
    This is how Python makes comparisons.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将变量`y`设置为3，然后将变量`x`设置为4。接着，我们使用这些变量来判断`y`是否大于`x`，因此 Python 返回`False`。然后我们问`y`是否小于10，返回`True`。这就是
    Python 如何进行比较的方式。
- en: MAKING DECISIONS WITH IF AND ELSE STATEMENTS
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 IF 和 ELSE 语句进行决策
- en: 'You can have your program make decisions about what code to run using `if`
    and `else` statements. For example, if the condition you set turns out to be `True`,
    the program runs one set of code. If the condition turns out to be `False`, you
    can write the program to do something else or even do nothing at all. Here’s an
    example:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过 `if` 和 `else` 语句让程序决定运行哪些代码。例如，如果你设定的条件为 `True`，程序将运行一组代码。如果条件为 `False`，你可以让程序做其他事情，甚至什么也不做。以下是一个例子：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, we are saying, assign variable `y` the value 7\. If the value of `y` is
    more than 5, print “yes!”; otherwise, do nothing.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们说，将变量`y`的值设为7。如果`y`的值大于5，则打印“yes!”；否则，不做任何事情。
- en: You can also give your program alternative code to run using `else` and `elif`.
    Since we'll be writing some longer code, open a new Python file and save it as
    *conditionals.py*.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为你的程序提供备用代码，通过使用`else`和`elif`来运行。由于我们将编写一些较长的代码，打开一个新的 Python 文件并将其保存为*conditionals.py*。
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this example we’re saying, if the value of `y` is more than 7, print “yes!”;
    otherwise, print “no!”. Run this program, and it should print “no!” because 6
    is not larger than 7.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们说的是，如果`y`的值大于7，则打印“yes！”；否则，打印“no！”。运行这个程序，它应该打印“no！”，因为6并不大于7。
- en: 'You can add more alternatives using `elif`, which is short for “else if.” You
    can have as many `elif` statements as you want. Here’s a sample program with three
    `elif` statements:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`elif`添加更多的替代条件，`elif`是“else if”的缩写。你可以根据需要添加任意数量的`elif`语句。下面是一个包含三个`elif`语句的示例程序：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This program runs different code depending on which of the specified ranges
    the value of `age` falls into. Notice you can use `<=` for “less than or equal
    to” and you can use compound inequalities like `if 11 < age < 20:` for “if age
    is between 11 and 20.” For example, when `age = 50`, the output is the following
    string:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序会根据`age`值所在的特定范围执行不同的代码。注意，你可以使用`<=`表示“小于或等于”，并且可以使用复合不等式，如`if 11 < age
    < 20:`表示“如果年龄在11到20之间”。例如，当`age = 50`时，输出将是以下字符串：
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Being able to have your programs make decisions quickly and automatically according
    to the conditions you define is an important aspect of programming!
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 能够根据你定义的条件快速且自动地让程序做出决策，是编程中的一个重要方面！
- en: USING CONDITIONALS TO FIND FACTORS
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用条件语句查找因子
- en: Now let’s use what you’ve learned so far to factor a number! A *factor* is a
    number that divides evenly into another number; for example, 5 is a factor of
    10 because we can divide 10 evenly by 5\. In math class, we use factors to do
    everything from finding common denominators to determining whether a number is
    prime. But finding factors manually can be a tedious task involving a lot of trial
    and error, especially when you’re working with bigger numbers. Let’s see how to
    automate factoring using Python.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用到目前为止学到的知识来因数化一个数字！*因子*是能够整除另一个数字的数字；例如，5是10的因子，因为我们可以用5整除10。在数学课上，我们使用因子来做各种事情，从寻找最小公倍数到判断一个数字是否是质数。然而，手动寻找因子可能是一个繁琐的任务，特别是当处理较大的数字时，涉及大量的反复试探。让我们看看如何使用
    Python 来自动化因数分解。
- en: 'In Python you can use the modulo operator (`%`) to calculate the remainder
    when dividing two numbers. For example, if `a % b` equals zero, it means that
    `b` divides evenly into `a`. Here’s an example of the modulo in action:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，你可以使用取余运算符（`%`）来计算两个数字相除的余数。例如，如果`a % b`等于零，表示`b`能整除`a`。下面是一个取余操作的示例：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This shows that when you divide 20 by 3, you get a remainder of 2, which means
    that 3 is not a factor of 20\. Let’s try 5 instead:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明，当你将20除以3时，得到的余数是2，这意味着3不是20的因子。让我们试试5：
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now we get a remainder of zero, so we know that 5 is a factor of 20.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们得到了余数为零，所以我们知道5是20的因子。
- en: WRITING THE FACTORS.PY PROGRAM
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编写 FACTORS.PY 程序
- en: 'Let’s use the modulo operator to write a function that takes a number and returns
    a list of that number’s factors. Instead of just printing the factors, we’ll put
    them in a list so we can use the factors list in another function later. Before
    we start writing this program, it’s a good idea to lay out our plan. Here are
    the steps involved in the *factors.py* program:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用取余运算符来编写一个函数，接收一个数字并返回该数字的所有因子。我们不仅仅打印因子，而是将它们放入一个列表中，以便稍后可以在另一个函数中使用这个因子列表。在开始编写这个程序之前，先规划一下我们的步骤。以下是*factors.py*程序的步骤：
- en: Define the `factors` function, which takes a number as an argument.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`factors`函数，接收一个数字作为参数。
- en: Create an empty factors list to fill with factors.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个空的因子列表，准备填充因子。
- en: Loop over all the numbers from 1 to the given number.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 循环遍历从1到给定数字的所有数字。
- en: If any of these numbers divides evenly, add it to the factors list.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果这些数字中有任何一个能够整除，则将其添加到因子列表中。
- en: Return the list of factors at the end.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在最后返回因子列表。
- en: Listing 3-1 shows the `factors()` function. Enter this code into a new file
    in IDLE and save it as *factors.py*.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-1 显示了`factors()`函数。将这段代码输入到 IDLE 中的一个新文件，并将其保存为*factors.py*。
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 3-1: Writing the* factors.py *program*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*列出 3-1：编写* factors.py *程序*'
- en: 'We first create an empty list called `factorList`, which we’ll later fill with
    the factors as we find them. Then we start a loop, beginning with `1` (we can’t
    divide by zero) and ending with `num + 1`, so that the loop will include `num`.
    Inside the loop we instruct the program to make a decision: if `num` is divisible
    by the current value of `i` (if the remainder is 0), then the program appends
    `i` to the factors list. Finally, we return the list of factors.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个空列表 `factorList`，稍后在找到因数时将其填充。然后我们开始一个循环，从 `1` 开始（因为不能除以零），以 `num +
    1` 结束，这样循环就会包括 `num`。在循环内部，我们指示程序做出决策：如果 `num` 能被当前的 `i` 整除（余数为 0），则程序将 `i` 添加到因数列表中。最后，我们返回因数列表。
- en: Now run *factors.py* by pressing the F5 key or by clicking **Run** ▸ **Run Module**,
    as shown in [Figure 3-1](ch03.xhtml#ch03fig1).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在通过按下 F5 键或点击 **Run** ▸ **Run Module** 来运行 *factors.py*，如 [图 3-1](ch03.xhtml#ch03fig1)
    所示。
- en: '![image](../images/f041-01.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f041-01.jpg)'
- en: '*Figure 3-1: Running the* factors.py *module*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-1：运行* factors.py *模块*'
- en: 'After running this module, you can use the `factors` function in the normal
    IDLE terminal by passing it a number you want to find the factors for, like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此模块后，你可以在普通的 IDLE 终端中使用 `factors` 函数，通过传入一个你想找到因数的数字，例如这样：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You found all the factors of 120 using the `factors` function! This is much
    easier and faster than using trial and error.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经使用 `factors` 函数找到了 120 的所有因数！这比使用试错法要容易和快速得多。
- en: 'EXERCISE 3-1: FINDING THE FACTOR'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 3-1：寻找因数
- en: 'The `factors()` function could come in handy for finding the greatest common
    factor (GCF) of two numbers. Write a function that will return the GCF of two
    numbers, like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`factors()` 函数对于找到两个数字的最大公因数（GCF）很有用。编写一个函数来返回两个数字的 GCF，如下所示：'
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: THE WANDERING TURTLE
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 漫游的海龟
- en: Now that you know how to instruct a program to make decisions automatically,
    let’s explore how to let a program execute indefinitely! To start, we’ll make
    a turtle walk around the screen and use conditionals to make it turn around if
    it goes beyond a certain point.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何指示程序自动做出决策，让我们探索如何让程序无限期地执行！首先，我们将让海龟在屏幕上四处走动，并使用条件语句让它在超出某个点时转身。
- en: The turtle’s window is a classic x-y grid whose x- and y-axes go from –300 to
    300 by default. Let’s limit the turtle’s position to anywhere between –200 and
    200 for *x* and *y*, as shown in [Figure 3-2](ch03.xhtml#ch03fig2).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 海龟的窗口是一个经典的 x-y 坐标系，默认情况下 x 轴和 y 轴的范围是从 -300 到 300。让我们将海龟的位置限制在 *x* 和 *y* 的
    -200 到 200 之间，如 [图 3-2](ch03.xhtml#ch03fig2) 所示。
- en: '![image](../images/f042-01.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f042-01.jpg)'
- en: '*Figure 3-2: The rectangle of coordinates the turtle is limited to*'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-2：海龟受限的坐标矩形*'
- en: 'Open a new Python file in IDLE and save it as *wander.py*. First, let’s import
    the turtle module. To do so, add the following code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在 IDLE 中打开一个新的 Python 文件，并将其保存为 *wander.py*。首先，让我们导入 turtle 模块。为此，添加以下代码：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note that we also need to import the `randint` function from the random module
    to generate random integers.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们还需要从 random 模块导入 `randint` 函数来生成随机整数。
- en: Writing the wander.py Program
  id: totrans-63
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 编写 wander.py 程序
- en: Now let’s create a function called `wander` to make the turtle wander around
    the screen, as shown in [Listing 3-2](ch03.xhtml#ch03list2). To do this, we use
    Python’s infinite `while True` loop, which always evaluates to `True`. This will
    make the turtle wander around without stopping. To stop it, you can click the
    X on the turtle graphics window.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个名为 `wander` 的函数，让海龟在屏幕上漫游，如 [清单 3-2](ch03.xhtml#ch03list2) 所示。为此，我们使用
    Python 的无限 `while True` 循环，该循环始终评估为 `True`。这将使海龟不停地漫游。要停止它，你可以点击海龟图形窗口上的 X。
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 3-2: Writing the* wander.py *program*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-2：编写* wander.py *程序*'
- en: First, we set the turtle’s speed to 0, which is the fastest, and then define
    the `wander()` function. Inside the function we use the infinite loop, so everything
    inside `while True` will execute forever. Then the turtle goes forward three steps
    (or 3 pixels) and evaluates its position using a conditional. The functions for
    the x-coordinate and y-coordinate of a turtle are `xcor()` and `ycor()`, respectively.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将海龟的速度设置为 0，这是最快的速度，然后定义 `wander()` 函数。在函数内部，我们使用无限循环，所以 `while True` 内部的所有内容都会永远执行。然后海龟向前走三步（或
    3 个像素），并使用条件语句评估其位置。海龟的 x 坐标和 y 坐标分别是 `xcor()` 和 `ycor()` 函数。
- en: Using the `if` statement, we tell the program that if any one of the conditional
    statements is `True` (the turtle is outside the specified region), then make the
    turtle turn left a random number of degrees, between 90 and 180, to prevent it
    from straying. If the turtle is inside the rectangle, the conditional evaluates
    to False and no code is executed. Either way, the program returns to the top of
    the `while True` loop and does `fd(3)` again.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`if`语句，我们告诉程序，如果任何一个条件语句为`True`（海龟在指定区域外），那么让海龟随机转动90到180度之间的角度，防止它偏离方向。如果海龟在矩形内，条件判断为假，程序不执行任何操作。无论哪种情况，程序会返回到`while
    True`循环的顶部，并再次执行`fd(3)`。
- en: Running the wander.py Program
  id: totrans-69
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 运行wander.py程序
- en: When you run the *wander.py* program, you should see something like [Figure
    3-3](ch03.xhtml#ch03fig3).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行*wander.py*程序时，你应该会看到类似于[图3-3](ch03.xhtml#ch03fig3)的内容。
- en: '![image](../images/f043-01.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f043-01.jpg)'
- en: '*Figure 3-3: The output of* wander.py'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3-3：wander.py程序的输出*'
- en: As you can see, the turtle walks in a straight line until its x-coordinate gets
    to 200\. (The turtle always starts walking to the right in the positive x-direction.)
    Then it turns left a random number of degrees, between 90 and 180, and keeps walking
    straight again. Sometimes the turtle is able to walk outside of the boundary lines,
    because after the 90-degree turn it’s still pointed off the screen and you’ll
    see it turning around every loop, trying to get back into the rectangle. This
    causes the little blobs outside the rectangle you see in [Figure 3-3](ch03.xhtml#ch03fig3).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，海龟会沿着直线走，直到它的x坐标达到200。（海龟总是从右向左走，沿着正x方向。）然后它会随机转动90到180度之间的角度，继续直线前进。有时，海龟会走出边界，因为它在90度转弯后仍然指向屏幕外，你会看到它每次循环时都会转身，试图重新进入矩形区域。这就是[图3-3](ch03.xhtml#ch03fig3)中你看到的矩形外的小点。
- en: CREATING A NUMBER-GUESSING GAME
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个数字猜测游戏
- en: You successfully used conditionals to create a turtle that seemed to make decisions
    on its own! Let’s use conditionals to write an interactive number-guessing program
    that seems conscious. In this game I think of a number between 1 and 100, and
    you guess what the number is. How many guesses do you think you would need to
    guess my number correctly? To narrow down your options, after each incorrect guess,
    I tell you whether you should guess higher or lower. Fortunately, we can use the
    `average` function we wrote in [Chapter 2](ch02.xhtml) to make this task infinitely
    easier.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你成功地使用了条件语句创建了一个似乎能自己做决定的海龟！让我们继续使用条件语句来编写一个互动的数字猜测程序，让它看起来像是有意识的。在这个游戏中，我会想一个1到100之间的数字，你来猜这个数字是多少。你认为你需要多少次猜测才能正确猜出我的数字？为了缩小选择范围，在每次猜错之后，我会告诉你是猜高一点还是低一点。幸运的是，我们可以使用在[第二章](ch02.xhtml)中编写的`average`函数，让这个任务变得极其简单。
- en: When you make an incorrect guess, your next guess should depend on whether your
    guess was too low or too high. For example, if your guess was too low, your next
    guess should be the middle number between your last guess and the maximum value
    the number can be. If your guess was too high, your next guess should be the middle
    number between your last guess and the minimum value the number can be.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当你做出错误的猜测时，你的下一个猜测应该取决于你之前的猜测是过低还是过高。例如，如果你的猜测太低，那么下一个猜测应该是你上次猜测和最大可能值之间的中间数。如果你的猜测太高，那么下一个猜测应该是你上次猜测和最小可能值之间的中间数。
- en: This sounds like calculating the average of two numbers—good thing we have the
    `average` function! We’ll use it to write the *numberGame.py* program, which makes
    smart guesses by narrowing down half the possible numbers every time. You’ll be
    surprised how quickly you can hone in on the answer.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来像是在计算两个数字的平均值——幸运的是，我们有`average`函数！我们将利用它编写*numberGame.py*程序，该程序通过每次将可能的数字范围缩小一半来做出智能猜测。你会惊讶于自己能多快找出答案。
- en: Let’s take this one step at a time, starting with making a random number generator.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步一步来，首先从制作一个随机数生成器开始。
- en: MAKING A RANDOM NUMBER GENERATOR
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 制作一个随机数生成器
- en: First, we need the computer to choose a number at random between 1 and 100\.
    Create a new file in IDLE and save it as *numberGame.py*. Then enter the code
    in [Listing 3-3](ch03.xhtml#ch03list3).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要让计算机随机选择一个1到100之间的数字。在IDLE中创建一个新文件并保存为*numberGame.py*。然后输入[清单3-3](ch03.xhtml#ch03list3)中的代码。
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 3-3: Writing the `numberGame()` function*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单3-3：编写`numberGame()`函数*'
- en: Here, we import the `random` module and assign a random integer to a variable
    using the `randint()` function. Then we create a `number` variable that will hold
    a random number between 1 and 100, generated each time we call it.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们导入 `random` 模块，并使用 `randint()` 函数将一个随机整数分配给一个变量。然后我们创建一个 `number` 变量，它将存储一个
    1 到 100 之间的随机数字，每次调用时都会生成。
- en: TAKING USER INPUT
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 获取用户输入
- en: 'Now the program needs to ask the user for input so they can take a guess! Here’s
    an example you can enter into the interactive shell to see how the `input()` function
    works:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在程序需要让用户输入，以便他们可以进行猜测！以下是你可以在交互式 shell 中输入的示例，看看 `input()` 函数是如何工作的：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The program prints the text “What’s your name?” in the shell, asking the user
    to input their name. The user types something, presses ENTER, and the program
    saves the input.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 程序在 shell 中打印出“你叫什么名字？”提示用户输入他们的名字。用户输入一些内容，按下回车键，程序保存输入。
- en: 'We can check whether Python saves the user input to the `name` variable, like
    so:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以检查 Python 是否将用户输入保存到 `name` 变量中，像这样：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: When we ask the program to print `name`, it prints the user input that was saved
    in that variable (in this case, Peter).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们让程序打印 `name` 时，它会打印出保存在该变量中的用户输入（在这个例子中是 Peter）。
- en: 'We can create a function called `greet()` that we’ll use later in our program:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个名为 `greet()` 的函数，以便在程序的后续部分使用：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The output will be the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Try writing a short program that takes the user’s name as input, and if they
    enter “Peter,” it will print “That’s my name, too!” If the name is not “Peter,”
    it will just print “Hello” and the name.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试编写一个简单的程序，接受用户的名字作为输入，如果他们输入“Peter”，程序将打印“那也是我的名字！”如果名字不是“Peter”，它只会打印“Hello”和名字。
- en: CONVERTING USER INPUT TO INTEGERS
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将用户输入转换为整数
- en: Now you know how to work with text that the user inputs, but we’ll be taking
    in number inputs in our guessing game. In [Chapter 2](ch02.xhtml#ch02) you learned
    about basic data types, like integers and floats, that you can use to perform
    math operations. In Python, all input from users is always taken in as a *string*.
    This means that if we want numbers as inputs, we have to convert them to an integer
    data type so we can use them in operations.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何处理用户输入的文本，但我们将在猜数字游戏中接受数字输入。在[第2章](ch02.xhtml#ch02)中，你学习了基本数据类型，比如整数和浮点数，你可以使用它们进行数学运算。在
    Python 中，所有用户输入的内容始终被作为 *字符串* 处理。这意味着，如果我们需要数字输入，我们必须将它们转换为整数数据类型，这样才能在运算中使用。
- en: 'To convert a string to an integer, we pass the input to `int()`, like this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要将字符串转换为整数，我们将输入传递给 `int()`，像这样：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now whatever the user enters will be transformed into an integer that Python
    can operate on.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，无论用户输入什么，都会被转换为 Python 可以操作的整数。
- en: USING CONDITIONALS TO CHECK FOR A CORRECT GUESS
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用条件语句检查是否猜对
- en: Now the *numberGame.py* program needs a way to check whether the number the
    user guessed is correct. If it is, we’ll announce that the guess is right and
    the game is over. Otherwise, we tell the user whether they should guess higher
    or lower.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 *numberGame.py* 程序需要一种方法来检查用户猜测的数字是否正确。如果正确，我们会宣布猜对了并结束游戏。否则，我们告诉用户应该猜更高还是更低。
- en: We use the `if` statement to compare the input to the content of `number`, and
    we use `elif` and `else` to decide what to do in each circumstance. Revise the
    existing code in *numberGame.py* to look like the code in [Listing 3-4](ch03.xhtml#ch03list4).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `if` 语句将输入与 `number` 的内容进行比较，使用 `elif` 和 `else` 来决定在每种情况下应该做什么。修改现有代码 *numberGame.py*，使其看起来像
    [列出 3-4](ch03.xhtml#ch03list4) 中的代码。
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 3-4: Checking for a correct guess*'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*列出 3-4：检查是否猜对*'
- en: If the random number held in `number` is equal to the input stored in `guess`,
    we tell the user their guess was correct and print the random number. Otherwise,
    we tell the user whether they need to guess higher or lower. If the number they
    guessed is lower than the random number, we tell them to guess higher. If they
    guessed higher, we tell them to guess lower.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存储在 `number` 中的随机数字与存储在 `guess` 中的输入相等，我们会告诉用户他们的猜测是正确的，并打印随机数字。否则，我们告诉用户是否需要猜更高或更低。如果他们猜的数字低于随机数字，我们会告诉他们猜更高。如果他们猜得更高，我们会告诉他们猜更低。
- en: 'Here’s an example of the output so far:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是到目前为止的输出示例：
- en: '[PRE21]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Pretty good, but currently our program ends here and doesn’t let the user make
    any more guesses. We can use a loop to fix that.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 很不错，但目前我们的程序到此为止，并没有让用户进行更多猜测。我们可以使用循环来解决这个问题。
- en: USING A LOOP TO GUESS AGAIN!
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用循环再次猜测！
- en: To allow the user to guess again, we can make a loop so that the program keeps
    asking for more guesses until the user guesses correctly. We use the `while` loop
    to keep looping until `guess` is equal to `number`, and then the program will
    print a success message and break out of the loop. Replace the code in [Listing
    3-4](ch03.xhtml#ch03list4) with the code in [Listing 3-5](ch03.xhtml#ch03list5).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让用户再次猜测，我们可以创建一个循环，让程序不断请求更多的猜测，直到用户猜对为止。我们使用 `while` 循环来持续循环，直到 `guess` 等于
    `number`，然后程序会打印出成功信息并跳出循环。用 [Listing 3-4](ch03.xhtml#ch03list4) 中的代码替换为 [Listing
    3-5](ch03.xhtml#ch03list5) 中的代码。
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 3-5: Using a loop to allow the user to guess again*'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 3-5: 使用循环允许用户再次猜测*'
- en: In this example, `while guess` means “while the variable `guess` contains a
    value.” First, we check whether the random number it chose is equal to the guess.
    If it is, the program prints that the guess is correct and breaks out of the loop.
    If the number is greater than the guess, the program prompts the user to guess
    higher. Otherwise, it prints that the user needs to guess lower. Then it takes
    in the next guess and the loop starts over, allowing the user to guess as many
    times as needed to get the correct answer. Finally, after we’re done defining
    the function, we write `numberGame()` to call the function to itself so the program
    can run it.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`while guess` 表示“当变量 `guess` 包含一个值时”。首先，我们检查它选择的随机数是否等于猜测值。如果是，程序会打印出猜测正确并跳出循环。如果数字大于猜测值，程序会提示用户猜更大一些。否则，程序会打印出需要猜更小一些。然后，程序会接受下一个猜测并重新开始循环，允许用户根据需要多次猜测直到猜对为止。最后，当我们定义完函数后，写上
    `numberGame()` 来调用这个函数，这样程序就可以运行了。
- en: TIPS FOR GUESSING
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 猜测技巧
- en: Save the *numberGame.py* program and run it. Each time you make an incorrect
    guess, your next guess should be exactly halfway between your first guess and
    the closest end of the range. For example, if you start by guessing 50 and the
    program tells you to guess higher, your next guess would be halfway between 50
    and 100 at the top of the range, so you’d guess 75.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 保存 *numberGame.py* 程序并运行它。每次你猜错时，你的下一个猜测应该恰好位于你的第一个猜测与范围的最近端之间。例如，如果你从猜测 50
    开始，程序告诉你猜得更大一些，那么你的下一个猜测应该位于 50 和范围顶部 100 之间的中点，即猜 75。
- en: This is the most efficient way to arrive at the correct number, because for
    each guess you’re eliminating half the possible numbers, no matter whether the
    guess is too high or too low. Let’s see how many guesses it takes to guess a number
    between 1 and 100\. [Figure 3-4](ch03.xhtml#ch03fig4) shows an example.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这是到达正确数字的最有效方法，因为每次猜测时，你都在排除一半可能的数字，无论猜测是太高还是太低。让我们看看需要多少次猜测才能猜中 1 到 100 之间的一个数字。[图
    3-4](ch03.xhtml#ch03fig4)展示了一个例子。
- en: '![image](../images/f047-01.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f047-01.jpg)'
- en: '*Figure 3-4: The output of the number-guessing game*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*Figure 3-4: 数字猜测游戏的输出*'
- en: This time it took six guesses.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这次共猜了六次。
- en: 'Let’s see how many times you can multiply 100 by a half before you get to a
    number below 1:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在将 100 乘以二分之一后，能重复多少次，直到得到小于 1 的数字：
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: It takes seven times to get to a number less than 1, so it makes sense that
    on average it takes around six or seven tries to guess a number between 1 and
    100\. This is the result of eliminating half the numbers in our range with every
    guess. This might not seem like a useful strategy for anything but number-guessing
    games, but we can use this exact idea to find a very accurate value for the square
    root of a number, which we’ll do next.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要得到小于 1 的数字需要七次猜测，因此平均而言，猜一个 1 到 100 之间的数字大约需要六到七次尝试。这是因为每次猜测时，我们都在排除范围中一半的数字。这个策略可能看起来只适用于数字猜测游戏，但我们可以用这个相同的思路来找到一个数字的平方根的非常准确的值，接下来我们就要这样做。
- en: FINDING SQUARE ROOTS
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 寻找平方根
- en: You can use the number-guessing game strategy to approximate square roots. As
    you know, some square roots can be whole numbers (the square root of 100 is 10,
    for example). But many more are *irrational numbers*, which are never-ending,
    never-repeating decimals. They come up a lot in coordinate geometry when you have
    to find the roots of polynomials.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用数字猜测游戏的策略来近似计算平方根。正如你所知道的，有些平方根是整数（例如 100 的平方根是 10）。但更多的平方根是 *无理数*，它们是永无止境且不重复的小数。在坐标几何中，你经常需要找到多项式的根时，这种情况会经常出现。
- en: So how could we possibly use the number-guessing game strategy to find an accurate
    value for a square root? You can simply use the averaging idea to calculate the
    square root, correct to eight or nine decimal places. In fact, your calculator
    or computer uses an iterative method like the number-guessing strategy to come
    up with square roots that are correct to 10 decimal places!
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如何利用数字猜测游戏的策略来找到一个平方根的准确值呢？你可以简单地使用平均法来计算平方根，精确到八位或九位小数。事实上，你的计算器或电脑使用的正是类似数字猜测策略的迭代方法来求出精确到10位小数的平方根！
- en: APPLYING THE NUMBER-GUESSING GAME LOGIC
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 应用数字猜测游戏逻辑
- en: For example, let’s say you don’t know the square root of 60\. First, you narrow
    your options down to a range, like we did for the number-guessing game. You know
    that 7 squared is 49 and 8 squared is 64, so the square root of 60 must be between
    7 and 8\. Using the `average()` function, you can calculate the average of 7 and
    8 to get 7.5, which is your first guess.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你不知道60的平方根。首先，你将选项缩小到一个范围，就像我们在数字猜测游戏中做的那样。你知道7的平方是49，8的平方是64，所以60的平方根必须介于7和8之间。使用`average()`函数，你可以计算7和8的平均值，得到7.5，这就是你的第一次猜测。
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To check whether 7.5 is the correct guess, you can square 7.5 to see if it
    yields 60:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查7.5是否是正确的猜测，你可以将7.5平方，看看是否得到60：
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As you can see, 7.5 squared is 56.25\. In our number-guessing game, we’d be
    told to guess higher since 56.25 is lower than 60.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，7.5的平方是56.25。在我们的数字猜测游戏中，由于56.25小于60，我们会被告知猜更大一些。
- en: 'Because we have to guess higher, we know the square root of 60 has to be between
    7.5 and 8, so we average those and plug in the new guess, like so:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们必须猜得更高，我们知道60的平方根应该介于7.5和8之间，所以我们取这两个数的平均值，并将新猜测代入，如下所示：
- en: '[PRE26]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now we check the square of 7.75 to see if it’s 60:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们检查7.75的平方，看它是否为60：
- en: '[PRE27]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Too high! So the square root must be between 7.5 and 7.75.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 太大了！因此，平方根必须在7.5和7.75之间。
- en: WRITING THE SQUAREROOT() FUNCTION
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编写SQUAREROOT()函数
- en: We can automate this process using the code in [Listing 3-6](ch03.xhtml#ch03list6).
    Open a new Python file and name it *squareRoot.py*.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用[清单3-6](ch03.xhtml#ch03list6)中的代码来自动化这个过程。打开一个新的Python文件，并命名为*squareRoot.py*。
- en: '[PRE28]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*Listing 3-6: Writing the `squareRoot()` function*'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单3-6：编写`squareRoot()`函数*'
- en: 'Here, the `squareRoot()` function takes three parameters: `num` (the number
    we want the square root of), `low` (the lowest limit `num` can be), and `high`
    (the upper limit of `num`). If the number you guess squared is equal to `num`,
    we just print it and break out of the loop. This might happen for a whole number,
    but not for an irrational number. Remember, irrational numbers never end!'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`squareRoot()`函数有三个参数：`num`（我们想要求平方根的数字）、`low`（`num`的最小值）和`high`（`num`的最大值）。如果你猜测的数字的平方等于`num`，我们就打印出来并跳出循环。这种情况可能发生在整数上，但不适用于无理数。记住，无理数永远不会结束！
- en: Next, the program checks whether the number you guess squared is greater than
    `num`, in which case you should guess lower. We shorten our range to go from `low`
    to the guess by replacing `high` with the guess. The only other possibility is
    if the guess is too low, in which case we shorten our range to go from the guess
    to `high` by replacing `low` with the guess.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，程序检查你猜测的数字的平方是否大于`num`，如果是这种情况，你应该猜更小的数字。我们将范围缩小到从`low`到猜测的数字，并用猜测替换`high`。另一种可能是猜测太小，此时我们将范围缩小到从猜测到`high`，并用猜测替换`low`。
- en: The program keeps repeating that process as many times as we want (in this case,
    20 times) and then prints the approximate square root. Keep in mind that any decimal,
    no matter how long, can only approximate an irrational number. But we can still
    get a very good approximation!
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 程序会按照我们设定的次数（在这个例子中是20次）重复这一过程，然后打印出近似的平方根。记住，无论小数点后有多少位，它始终只能近似一个无理数。但我们仍然能得到非常好的近似值！
- en: 'In the final line we call the `squareRoot()` function, giving it the number
    we want the square root of, and the low and high numbers in the range we know
    the square root has to be in. Our output should look like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一行，我们调用`squareRoot()`函数，传入我们想要求平方根的数字，以及我们知道平方根必须位于的低值和高值范围。我们的输出应如下所示：
- en: '[PRE29]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can find out how close our approximation is by squaring it:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过对其进行平方来找出我们的近似值有多接近：
- en: '[PRE30]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: That’s pretty close to 60! Isn’t it surprising that we can calculate an irrational
    number so accurately just by guessing and averaging?
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 那么接近60了！难道不令人惊讶吗？我们仅凭猜测和平均计算就能如此准确地求出一个无理数的值？
- en: 'EXERCISE 3-2: FINDING THE SQUARE ROOT'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 练习3-2：求平方根
- en: 'Find the square root of these numbers:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 求这些数字的平方根：
- en: '200'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '200'
- en: '1000'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1000'
- en: '50000 (Hint: you know the square root has to be somewhere between 1 and 500,
    right?)'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 50000（提示：你知道平方根应该介于1和500之间，对吧？）
- en: SUMMARY
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned about some handy tools like arithmetic operators,
    lists, inputs, and Booleans, as well as a crucial programming concept called conditionals.
    The idea that we can get the computer to compare values and make choices for us
    automatically, instantly, and repeatedly is extremely powerful. Every programming
    language has a way to do this, and in Python we use `if`, `elif`, and `else` statements.
    As you’ll see throughout this book, you’ll build on these tools to tackle meatier
    tasks to explore math.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章，你了解了一些有用的工具，如算术运算符、列表、输入和布尔值，以及一个关键的编程概念——条件语句。通过条件语句，我们可以让计算机自动、瞬时、反复地比较数值并做出选择，这个想法非常强大。每种编程语言都有类似的方式来实现这一点，而在Python中，我们使用`if`、`elif`和`else`语句。正如你将在本书中看到的，你将以这些工具为基础，解决更具挑战性的任务，探索数学问题。
- en: In the next chapter, you’ll practice the tools you learned so far to solve algebra
    problems quickly and efficiently. You’ll use the number-guessing strategy to solve
    complicated algebraic equations that have more than one solution! And you’ll write
    a graphing program so you can better estimate the solutions to equations and make
    your math explorations more visual!
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，你将练习到目前为止学到的工具，以快速高效地解决代数问题。你将使用猜数字的策略来解决那些有多个解的复杂代数方程！你还将编写一个绘图程序，以便更好地估算方程的解，并使你的数学探索更加可视化！
