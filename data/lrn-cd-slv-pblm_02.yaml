- en: '2'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '2'
- en: MAKING DECISIONS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 做出决策
- en: '![image](Images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/common.jpg)'
- en: 'Most programs that we use on a daily basis behave differently depending on
    what happens during their execution. For example, when a word processor asks us
    whether we want to save our work, it makes a decision based on our response: saving
    our work if we answer “yes” and not saving our work if we answer “no.” In this
    chapter, we’ll learn about `if` statements, which let our programs make decisions.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数我们日常使用的程序会根据其执行过程中发生的事情表现得不同。例如，当文字处理软件问我们是否保存工作时，它会根据我们的回答做出决策：如果我们回答“是”，它就保存工作；如果回答“否”，它就不保存工作。在这一章中，我们将学习`if`语句，它让我们的程序能够做出决策。
- en: 'We’ll solve two problems: determining the result of a basketball game and determining
    whether a phone number belongs to a telemarketer.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将解决两个问题：确定篮球比赛的结果和确定一个电话号码是否属于推销员。
- en: 'Problem #3: Winning Team'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '问题 #3：获胜队伍'
- en: In this problem, we’ll need to output a message that depends on the outcome
    of a basketball game. To do that, we’ll learn all about `if` statements. We’ll
    also learn how we can store and manipulate true and false values in our programs.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个问题中，我们需要输出一个根据篮球比赛结果不同而变化的消息。为此，我们将学习所有关于`if`语句的内容。我们还将学习如何在程序中存储和操作真假值。
- en: This is DMOJ problem `ccc19j1`.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这是DMOJ问题`ccc19j1`。
- en: The Challenge
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战
- en: 'In basketball, three plays score points: a three-point shot, a two-point shot,
    and a one-point free throw.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在篮球比赛中，有三种方式得分：三分球、两分球和一分罚球。
- en: You just watched a basketball game between the Apples and Bananas and recorded
    the number of successful three-point, two-point, and one-point plays for each
    team. Indicate whether the game was won by the Apples, the game was won by the
    Bananas, or the game was a tie.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚观看了苹果队和香蕉队之间的篮球比赛，并记录了每支队伍成功的三分球、两分球和一分罚球数。请判断比赛是由苹果队获胜、香蕉队获胜还是平局。
- en: Input
  id: totrans-11
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输入
- en: There are six lines of input. The first three give the scoring for the Apples,
    and the latter three give the scoring for the Bananas.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 有六行输入。前三行给出苹果队的得分，后面三行给出香蕉队的得分。
- en: The first line gives the number of successful three-point shots for the Apples.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一行给出苹果队成功投中的三分球数。
- en: The second line gives the number of successful two-point shots for the Apples.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二行给出苹果队成功投中的两分球数。
- en: The third line gives the number of successful one-point free throws for the
    Apples.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三行给出苹果队成功投中的一分罚球数。
- en: The fourth line gives the number of successful three-point shots for the Bananas.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四行给出香蕉队成功投中的三分球数。
- en: The fifth line gives the number of successful two-point shots for the Bananas.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第五行给出香蕉队成功投中的两分球数。
- en: The sixth line gives the number of successful one-point free throws for the
    Bananas.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第六行给出香蕉队成功投中的一分罚球数。
- en: Each number is an integer between 0 and 100.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 每个数字是0到100之间的整数。
- en: Output
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输出
- en: The output is a single character.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是一个单一字符。
- en: If the Apples scored more points than the Bananas, output `A` (*A* for Apples).
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果苹果队得分高于香蕉队，输出`A`（*A*代表苹果队）。
- en: If the Bananas scored more points than the Apples, output `B` (*B* for Bananas).
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果香蕉队得分高于苹果队，输出`B`（*B*代表香蕉队）。
- en: If the Apples and Bananas scored the same number of points, output `T` (*T*
    for Tie).
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果苹果队和香蕉队得分相同，输出`T`（*T*代表平局）。
- en: Conditional Execution
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 条件执行
- en: We can make a lot of headway here by using what we learned in [Chapter 1](ch01.xhtml#ch01).
    We can use `input` and `int` to read each of the six integers from the input.
    We can use variables to hang on to those values. We can multiply the number of
    successful three-point shots by 3 and the number of successful two-point shots
    by 2\. We can use `print` to output an `A`, `B`, or `T`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用[第1章](ch01.xhtml#ch01)学到的知识在这里取得很大进展。我们可以使用`input`和`int`读取输入中的六个整数。我们可以使用变量保存这些值。我们可以将成功的三分球数乘以3，将成功的两分球数乘以2。我们可以使用`print`输出`A`、`B`或`T`。
- en: What we haven’t learned yet is how our programs can make a decision about the
    outcome of the game. I can demonstrate why we need this through two test cases.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有学习的是，如何让程序根据比赛结果做出决策。我可以通过两个测试用例演示我们为什么需要这个。
- en: 'First, consider this test case:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，考虑这个测试用例：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The Apples scored 5 * 3 + 1 * 2 + 3 = 20 points, and the Bananas scored 1 *
    3 + 1 * 2 + 1 = 6 points. The Apples won the game, so this is the correct output:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果队得分为5 * 3 + 1 * 2 + 3 = 20分，香蕉队得分为1 * 3 + 1 * 2 + 1 = 6分。苹果队赢得了比赛，所以这是正确的输出：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Second, consider this test case, where the Apples’ and Bananas’ scores have
    been swapped:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，考虑这个测试用例，其中苹果队和香蕉队的得分已被交换：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This time, the Bananas won the game, so this is the correct output:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，香蕉队赢得了比赛，因此这是正确的输出：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Our program must be able to compare the total points scored by the Apples and
    the total points scored by the Bananas and use the result of that comparison to
    choose whether to output `A`, `B`, or `T`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序必须能够比较苹果队和香蕉队的总得分，并利用这个比较结果来决定输出 `A`、`B` 或 `T`。
- en: We can use Python’s `if` statement to make these kinds of decisions. A *condition*
    is an expression that’s true or false, and an `if` statement uses conditions to
    determine what to do. `if` statements lead to *conditional execution*, so named
    because the execution of our program is influenced by conditions.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Python 的`if`语句来做这些决定。一个*条件*是一个真假表达式，`if`语句利用条件来决定做什么。`if`语句导致*条件执行*，这个名字的由来是程序的执行受到条件的影响。
- en: We’ll first learn about a new type that lets us represent true or false values,
    and how we can build expressions of this type. Then, we’ll use such expressions
    to write `if` statements.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先了解一种新类型，允许我们表示真假值，以及如何构建这种类型的表达式。然后，我们将使用这些表达式编写 `if` 语句。
- en: The Boolean Type
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 布尔类型
- en: 'Pass an expression to Python’s `type` function, and it’ll tell you the type
    of the expression’s value:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个表达式传递给 Python 的`type`函数，它会告诉你该表达式值的类型：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'One Python type we haven’t met yet is the Boolean (`bool`) type. Unlike integers,
    strings, and floats, which have billions of possible values, there are only two
    Boolean values: `True` and `False`. These are exactly the values we need to represent
    the result of a condition.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有遇到的 Python 类型是布尔（`bool`）类型。与整数、字符串和浮点数不同，它们有数十亿个可能的值，布尔类型只有两个值：`True` 和
    `False`。这正是我们用来表示条件结果的值。
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: What can we do with these values? With numbers, we had mathematical operators
    like `+` and `-` that let us combine values into more complex expressions. We’ll
    need a new set of operators that work with Boolean values.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能用这些值做什么呢？对于数字，我们有像 `+` 和 `-` 这样的数学运算符，允许我们将值组合成更复杂的表达式。我们需要一组新的运算符来处理布尔值。
- en: Relational Operators
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关系运算符
- en: Is `5` greater than `2`? Is `4` less than `1`? We can make such comparisons
    using Python’s *relational operators*. They produce `True` or `False` and are
    therefore used to write *Boolean expressions*.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`5` 是否大于 `2`？`4` 是否小于 `1`？我们可以使用 Python 的*关系运算符*来进行这些比较。它们返回 `True` 或 `False`，因此用于编写*布尔表达式*。'
- en: 'The `>` operator takes two operands and returns `True` if the first is greater
    than the second, and `False` otherwise:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`>`运算符接受两个操作数，如果第一个大于第二个则返回`True`，否则返回`False`：'
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Similarly, we have the `<` operator for less-than:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们有 `<` 运算符表示小于：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'There’s `>=` for greater-than-or-equal-to, and `<=` for less-than-or-equal-to:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`>=` 表示大于或等于，`<=` 表示小于或等于：'
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: To determine equality, we use the `==` operator. That’s two equal signs, not
    one. Remember that one equal sign (`=`) is used in an assignment statement; it
    has nothing to do with checking equality.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了判断相等，我们使用`==`运算符。那是两个等号，而不是一个。记住，一个等号（`=`）用于赋值语句；它与检查相等无关。
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'For inequality, we use the `!=` operator. It returns `True` if the operands
    are not equal and `False` if they are equal:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不等式，我们使用 `!=` 运算符。如果操作数不相等，它返回 `True`，如果相等，它返回 `False`：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Real programs wouldn’t evaluate expressions whose values we already know. We
    don’t need Python to tell us that `15` doesn’t equal `10`. More typically, we’d
    use variables in these kinds of expressions. For example, `number != 10` is an
    expression whose value depends on what `number` refers to.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 真实程序不会评估我们已经知道其值的表达式。我们不需要 Python 告诉我们 `15` 不等于 `10`。更常见的是，我们在这些表达式中使用变量。例如，`number
    != 10` 是一个表达式，它的值取决于 `number` 代表的内容。
- en: 'The relational operators also work on strings. When checking equality, case
    matters:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 关系运算符也适用于字符串。在检查相等性时，大小写是重要的：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'One string is less than another if it comes first in alphabetical order:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一个字符串比另一个字符串小，如果它在字母顺序中排在前面：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'But things can be surprising when lowercase and uppercase characters are both
    involved:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 但是当同时涉及大小写字母时，事情可能会变得出人意料：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Weird, right? It has to do with the way that characters are stored internally
    in a computer. Generally, uppercase characters come alphabetically before lowercase
    characters. And check this out:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 很奇怪吧？这与字符在计算机中存储的方式有关。通常，大写字母按字母顺序排在小写字母之前。看看这个：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If these were numbers, then the result would be `False`. But strings are compared
    character by character from left to right. Python compares the `'1'` and `'4'`,
    and because `'1'` is smaller, the `<` operator returns `True`. Be sure that your
    values have the types you think they have!
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些是数字，那么结果将是`False`。但是字符串是逐个字符地从左到右比较的。Python比较`'1'`和`'4'`，因为`'1'`较小，所以`<`运算符返回`True`。确保你的值具有你认为它们应该有的类型！
- en: 'One relational operator that works on strings but not numbers is `in`. It returns
    `True` if the first string occurs at least once in the second, and `False` otherwise:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一个对字符串有效但对数字无效的关系运算符是`in`。如果第一个字符串至少出现在第二个字符串中一次，它返回`True`，否则返回`False`：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '**CONCEPT CHECK**'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念检查**'
- en: What is the output of the following code?
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码的输出是什么？
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: A. `True`
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: A. `True`
- en: B. `False`
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: B. `False`
- en: C. `3`
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: C. `3`
- en: D. This code produces a syntax error
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: D. 这段代码会产生语法错误
- en: 'Answer: B. The expression `a != 3` evaluates to `False`; `b` is then made to
    refer to this `False` value.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：B. 表达式`a != 3`的值为`False`；然后`b`被赋值为这个`False`值。
- en: The if Statement
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`if`语句'
- en: We’ll now explore several variations of Python’s `if` statement.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来探讨Python的`if`语句的几种变体。
- en: if by Itself
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 单独使用`if`
- en: 'Suppose we have our final scores in two variables, `apple_total` and `banana_total`,
    and we want to output `A` if `apple_total` is greater than `banana_total`. Here’s
    how we can do that:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有两个变量`apple_total`和`banana_total`存储最终分数，我们希望如果`apple_total`大于`banana_total`时输出`A`。下面是实现方法：
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Python outputs `A`, as we’d expect.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Python输出`A`，正如我们所预期的那样。
- en: An `if` statement starts with the keyword `if`. A *keyword* is a word that has
    special meaning to Python and cannot be used as a variable name. The keyword `if`
    is followed by a Boolean expression, followed by a colon, followed by one or more
    indented statements. The indented statements are often referred to as the *block*
    of the `if` statement. The block executes if the Boolean expression is `True`
    and is skipped if the Boolean expression is `False`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句以关键字`if`开始。*关键字*是Python中特别有意义的单词，不能作为变量名使用。关键字`if`后跟布尔表达式，接着是冒号，然后是一个或多个缩进的语句。缩进的语句通常被称为`if`语句的*代码块*。当布尔表达式为`True`时，代码块执行；当布尔表达式为`False`时，代码块被跳过。'
- en: Notice that the prompt changes from `>>>` to `...`. That’s a reminder that we’re
    inside the block of the `if` statement and must indent the code. I’ve chosen to
    indent by four spaces, so to indent the code, press the spacebar four times. Some
    Python programmers press the TAB key to indent, but we’ll exclusively use spaces
    in this book.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到提示符从`>>>`变成了`...`。这是一个提醒，表示我们在`if`语句的代码块内部，必须缩进代码。我选择了使用四个空格进行缩进，因此按空格键四次来缩进代码。某些Python程序员会按TAB键来缩进，但在本书中我们将仅使用空格。
- en: Once you type `print('A')` and hit ENTER, you should see another `...` prompt.
    Since we don’t have anything else to put in this `if` statement, press ENTER again
    to dismiss this prompt and return to the `>>>` prompt. This extra press of ENTER
    is a quirk of the Python shell; such blank lines are not required when we write
    a Python program in a file.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你输入`print('A')`并按下ENTER键，你应该看到另一个`...`提示符。由于我们在这个`if`语句中没有其他内容需要写，再按一次ENTER键来取消此提示符并返回到`>>>`提示符。这个额外的ENTER按键是Python
    Shell的一个特点；当我们在文件中编写Python程序时，不需要这些空白行。
- en: 'Let’s see an example of putting two statements in the block of an `if` statement:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子，在`if`语句的代码块中放入两个语句：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Both `print` calls execute, producing two lines of output.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 两个`print`调用都执行，输出两行内容。
- en: 'Let’s try another `if` statement, this one with a Boolean expression that’s
    `False`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试另一个`if`语句，这次使用一个布尔表达式，其值为`False`：
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `print` function is *not* called this time: `apple_total > banana_total`
    is `False`, so the block of the `if` statement is skipped.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这次没有调用`print`函数：`apple_total > banana_total`为`False`，所以`if`语句的代码块被跳过。
- en: if with elif
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用`elif`的`if`语句
- en: 'Let’s use three successive `if` statements to print `A` if the Apples win,
    `B` if the Bananas win, and `T` if it’s a tie:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用三个连续的`if`语句来打印`A`（如果苹果获胜），`B`（如果香蕉获胜），以及`T`（如果是平局）：
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The blocks of the first two `if` statements are skipped, because their Boolean
    expressions are `False`. But the block of the third `if` statement executes, producing
    the `T`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个和第二个`if`语句的代码块被跳过，因为它们的布尔表达式是`False`。但是第三个`if`语句的代码块执行了，输出了`T`。
- en: When you put one `if` statement after another, they’re independent. Each Boolean
    expression is evaluated, regardless of whether the previous Boolean expressions
    were `True` or `False`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个`if`语句放在另一个后面时，它们是独立的。每个布尔表达式都会被评估，无论前面的布尔表达式是`True`还是`False`。
- en: 'For any given values of `apple_total` and `banana_total`, only one of our `if`
    statements can run. For example, if `apple_total > banana_total` is `True`, then
    the first `if` statement will run, but the other two will not. It’s possible to
    write the code to highlight that only one block of code is allowed to run. Here’s
    how we can do that:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何给定的`apple_total`和`banana_total`的值，只有一个`if`语句能够运行。例如，如果`apple_total > banana_total`为`True`，那么第一个`if`语句将会运行，而其他两个则不会。可以编写代码突出显示只有一个代码块被允许执行。以下是我们可以如何实现：
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This is now a single `if` statement, not three separate `if` statements. For
    this reason, don’t press ENTER at the `...` prompt; instead, type the `elif` line.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这现在是一个单独的`if`语句，而不是三个独立的`if`语句。因此，不要在`...`提示符下按回车键；而是直接输入`elif`行。
- en: To execute this `if` statement, Python begins by evaluating the first Boolean
    expression ❶. If it’s `True`, then `A` is output, and the rest of the `elif`s
    are skipped. If it’s `False`, Python continues, evaluating the second Boolean
    expression ❷. If it’s `True`, then `B` is output, and the remaining `elif` is
    skipped. If it’s `False`, Python continues, evaluating the third Boolean expression
    ❸. If it’s `True`, then `T` is output.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行这个`if`语句，Python 首先评估第一个布尔表达式 ❶。如果它为`True`，则输出`A`，并跳过其余的`elif`语句。如果它为`False`，Python
    会继续，评估第二个布尔表达式 ❷。如果它为`True`，则输出`B`，并跳过剩下的`elif`语句。如果它为`False`，Python 会继续，评估第三个布尔表达式
    ❸。如果它为`True`，则输出`T`。
- en: The keyword `elif` stands for “else-if.” Use this as a reminder that an `elif`
    expression is checked only if nothing “else” before it in the `if` statement was
    executed.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字`elif`代表“else-if”。可以用它来提醒自己，`elif`表达式只有在之前的`if`语句没有执行时才会被检查。
- en: This version of the code is equivalent to the previous code where we used three
    separate `if` statements. Had we wanted to allow the possibility of executing
    more than one block, we’d have to use three separate `if` statements, not a single
    `if` statement with `elif` blocks.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这版代码等同于我们之前使用了三个独立的`if`语句的版本。如果我们希望允许执行多个代码块，就必须使用三个独立的`if`语句，而不是一个带有`elif`块的单个`if`语句。
- en: if with else
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 带有`else`的`if`
- en: 'We can use the `else` keyword to run code if all the Boolean expressions in
    the `if` statement are `False`. Here’s an example:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`else`关键字来在`if`语句中的所有布尔表达式为`False`时执行代码。以下是一个示例：
- en: '[PRE22]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Python evaluates the Boolean expressions from top to bottom. If any of them
    is `True`, Python runs the associated block and skips the rest of the `if` statement.
    If all the Boolean expressions are `False`, Python executes the `else` block.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Python 会从上到下评估布尔表达式。如果其中任何一个为`True`，Python 会执行相关的代码块并跳过其余的`if`语句。如果所有布尔表达式都为`False`，Python
    会执行`else`块。
- en: Notice that there is no longer a test for `apple_total == banana_total`. The
    only way to get to the `else` part of the `if` statement is if `apple_total >
    banana_total` is `False` and `banana_total > apple_total` is `False`, that is,
    if the values are equal.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，代码中不再测试`apple_total == banana_total`。只有当`apple_total > banana_total`为`False`且`banana_total
    > apple_total`为`False`时，才能进入`else`部分，即当两个值相等时。
- en: Should you use separate `if` statements? An `if` statement with `elif`s? An
    `if` statement with an `else`? It often comes down to preference. Use a chain
    of `elif`s if you want at most one block of code to execute. An `else` can help
    make the code clearer and removes the need to write a catchall Boolean expression.
    What’s far more important than the precise styling of an `if` statement is writing
    correct logic!
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 是否应该使用独立的`if`语句？使用带有`elif`的`if`语句？还是使用带有`else`的`if`语句？这通常取决于个人偏好。如果你希望最多只有一个代码块执行，可以使用一系列的`elif`语句。`else`可以帮助使代码更清晰，并且去除了编写兜底布尔表达式的需求。比起`if`语句的具体写法，编写正确的逻辑才是最重要的！
- en: '**CONCEPT CHECK**'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念检查**'
- en: What is the value of `x` after the following code runs?
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码执行后，`x`的值是多少？
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: A. `-3`
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: A. `-3`
- en: B. `1`
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: B. `1`
- en: C. `2`
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: C. `2`
- en: D. `3`
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: D. `3`
- en: E. `5`
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: E. `5`
- en: 'Answer: D. Because `x > 2` is `True`, the block of the first `if` statement
    executes. The assignment `x = -3` makes `x` refer to `-3`. Now for the second
    `if` statement. Here, `x > 1` is `False`, so the `else` block runs, and `x = 3`
    makes `x` refer to `3`. I’d suggest changing `if x > 1` to `elif x > 1` and observing
    how the behavior of the program changes!'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：D。因为`x > 2`为`True`，所以第一个`if`语句的代码块会执行。赋值`x = -3`使得`x`指向`-3`。接下来是第二个`if`语句。这里，`x
    > 1`为`False`，因此执行`else`代码块，`x = 3`使得`x`指向`3`。我建议将`if x > 1`改为`elif x > 1`并观察程序行为如何变化！
- en: '**CONCEPT CHECK**'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念检查**'
- en: Do the following two snippets of code do exactly the same thing? Assume that
    `temperature` already refers to a number.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个代码片段执行的是否完全相同？假设`temperature`已经是一个数字。
- en: 'Snippet 1:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 代码片段 1：
- en: '[PRE24]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Snippet 2:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 代码片段 2：
- en: '[PRE25]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: A. Yes
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: A. 是的
- en: B. No
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: B. 不是
- en: 'Answer: B. Snippet 2 *always* prints `cold` as its final line of output, because
    `print(''cold'')` is not indented! It is not associated with any `if` statement.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：B。代码片段2*始终*将`cold`作为最终输出行打印，因为`print('cold')`没有缩进！它不与任何`if`语句相关联。
- en: Solving the Problem
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解题步骤
- en: It’s time to solve Winning Team. In this book, I’ll generally present the full
    code and then discuss it. But as our solution here is longer than those in [Chapter
    1](ch01.xhtml#ch01), I’ve decided in this case to present the code in three pieces
    before presenting it as a whole.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候解决“胜利团队”问题了。在本书中，我通常会先展示完整代码，然后进行讨论。但由于我们的解决方案比[第1章](ch01.xhtml#ch01)的要长，我决定先分三部分展示代码，再将其合并。
- en: 'First, we need to read the input. This requires six calls of `input`, because
    we have two teams and three pieces of information for each team. We also need
    to convert each piece of input to an integer. Here’s the code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要读取输入。这需要进行六次`input`调用，因为我们有两个队，每个队有三项信息。我们还需要将每项输入转换为整数。以下是代码：
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Second, we need to determine the number of points scored by the Apples and
    the Bananas. For each team, we add the points from three-point, two-point, and
    one-point plays. We can do that as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，我们需要确定“苹果队”和“香蕉队”各自的得分。对于每个队，我们将三分、两分和一分的得分相加。可以按以下方式进行：
- en: '[PRE27]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Third, we produce the output. If the Apples win, we output `A`; if the Bananas
    win, we output `B`; otherwise, we know that the game is a tie, so we output `T`.
    We use an `if` statement to do this, as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，我们生成输出。如果“苹果队”获胜，则输出`A`；如果“香蕉队”获胜，则输出`B`；否则，我们知道比赛是平局，因此输出`T`。我们使用`if`语句来实现这一点，如下所示：
- en: '[PRE28]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: That’s all the code we need. See [Listing 2-1](ch02.xhtml#ch02ex01) for the
    complete solution.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要的全部代码。请参见[代码清单 2-1](ch02.xhtml#ch02ex01)获取完整解决方案。
- en: '[PRE29]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*Listing 2-1: Solving Winning Team*'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*代码清单 2-1：解决胜利团队问题*'
- en: If you submit our code to the judge, you should see that all test cases pass.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将我们的代码提交给评测系统，您应该会看到所有测试用例都通过了。
- en: '**CONCEPT CHECK**'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念检查**'
- en: Does the following version of the code correctly solve the problem?
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 以下版本的代码是否正确解决了问题？
- en: '[PRE30]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: A. Yes
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: A. 是的
- en: B. No
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: B. 不是
- en: 'Answer: A. The operators and order of the code are different, but the code
    is still correct. If the Apples lose, we output `B` (because the Bananas win);
    if the Apples win, we output `A`; otherwise, we know that the game is a tie, so
    we output `T`.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：A。操作符和代码的顺序不同，但代码仍然是正确的。如果“苹果队”输掉了比赛，则输出`B`（因为“香蕉队”获胜）；如果“苹果队”获胜，则输出`A`；否则，我们知道比赛是平局，因此输出`T`。
- en: Before continuing, you might like to try solving exercise 1 from “Chapter Exercises”
    on [page 45](ch02.xhtml#ch02lev1sec13).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，您可能想尝试解决“章节练习”中的第1题，见[第45页](ch02.xhtml#ch02lev1sec13)。
- en: 'Problem #4: Telemarketers'
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '问题 #4：电话推销员'
- en: Sometimes we need to encode more complex Boolean expressions than those that
    we have seen so far. In this problem, we’ll learn about Boolean operators that
    help us do this.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们需要编码比我们目前看到的更复杂的布尔表达式。在这个问题中，我们将学习有助于此的布尔运算符。
- en: This is DMOJ problem `ccc18j1`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这是DMOJ问题`ccc18j1`。
- en: The Challenge
  id: totrans-149
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战
- en: 'In this problem, we’ll assume that phone numbers are four digits. A phone number
    belongs to a telemarketer if its four digits satisfy all three of the following
    properties:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个问题中，我们假设电话号码是四位数。如果一个电话号码的四个数字满足以下三项条件之一，那么它就属于电话推销员：
- en: The first digit is `8` or `9`.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个数字是`8`或`9`。
- en: The fourth digit is `8` or `9`.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四位数字是`8`或`9`。
- en: The second and third digits are the same.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二和第三位数字相同。
- en: For example, a phone number whose four digits are `8119` belongs to a telemarketer.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个电话号码`8119`属于电话推销员。
- en: Determine whether a phone number belongs to a telemarketer, and indicate whether
    we should answer the phone or ignore it.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 确定一个电话号码是否属于电话推销员，并指示我们是否应该接电话或忽略它。
- en: Input
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输入
- en: There are four lines of input. These lines give the first, second, third, and
    fourth digits of the phone number, respectively. Each digit is an integer between
    0 and 9.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 输入有四行。这些行分别给出了电话号码的第一位、第二位、第三位和第四位数字。每个数字都是介于0和9之间的整数。
- en: Output
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输出
- en: If the phone number belongs to a telemarketer, output `ignore`; otherwise, output
    `answer`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果电话号码属于电话推销员，输出`ignore`；否则，输出`answer`。
- en: Boolean Operators
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 布尔运算符
- en: What has to be true about a phone number that belongs to a telemarketer? Its
    first digit has to be `8` *or* `9`. *And*, its fourth digit has to be `8` *or*
    `9`. *And*, the second and third digits have to be the same. We can encode this
    “or” and “and” logic using Python’s *Boolean operators*.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 一个电话号码如果属于电话推销员，必须满足什么条件？它的第一位数字必须是`8` *或* `9`。*并且*，它的第四位数字也必须是`8` *或* `9`。*并且*，第二位和第三位数字必须相同。我们可以使用
    Python 的*布尔运算符*来编码这个“或”和“与”的逻辑。
- en: or Operator
  id: totrans-162
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: or 运算符
- en: 'The `or` operator takes two Boolean expressions as its operands. It returns
    `True` if at least one operand is `True`, and `False` otherwise:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`or`运算符接受两个布尔表达式作为操作数。如果至少有一个操作数为`True`，则返回`True`，否则返回`False`：'
- en: '[PRE31]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The only way to get `False` out of the `or` operator is if both of its operands
    are `False`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一能让`or`运算符返回`False`的情况是它的两个操作数都为`False`。
- en: 'We can use `or` to tell us whether a digit is an `8` or a `9`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`or`来判断一个数字是`8`还是`9`：
- en: '[PRE32]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Remember from “Integer and Floating-Point Numbers” in [Chapter 1](ch01.xhtml#ch01)
    that Python uses operator precedence to determine the order that operators are
    applied. The precedence of `or` is lower than the precedence of relational operators,
    which means that we don’t often need parentheses around operands. For example,
    in `digit == 8 or digit == 9`, the two operands to `or` are `digit == 8` and `digit
    == 9`. It’s the same as if we’d written it as `(digit == 8) or (digit == 9)`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在[第1章](ch01.xhtml#ch01)的“整数和浮点数”中，Python 使用运算符优先级来决定运算符应用的顺序。`or`的优先级低于关系运算符的优先级，这意味着我们通常不需要在操作数周围加上括号。例如，在`digit
    == 8 or digit == 9`中，`or`的两个操作数是`digit == 8`和`digit == 9`。这与我们写成`(digit == 8)
    or (digit == 9)`是一样的。
- en: 'In English, it makes sense if someone says “if the digit is 8 or 9.” But writing
    that won’t work in Python:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 用英语表达，“如果数字是8或9”是合理的。但这样写在 Python 中不起作用：
- en: '[PRE33]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Notice that I’ve (incorrectly!) written the second operand as `9` instead of
    `digit == 9`. Python responds by outputting `yes!`, which is certainly not what
    we’d want given that `digit` refers to `3`. The reason is that Python considers
    nonzero numbers to be `True`. Since `9` is considered `True`, this makes the whole
    `or` expression `True`. Carefully double-check your Boolean expressions to avoid
    these kinds of mistakes when translating from natural language to Python.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我（错误地！）将第二个操作数写成了`9`，而不是`digit == 9`。Python输出了`yes!`，这显然不是我们希望的结果，因为`digit`指的是`3`。原因是
    Python 将非零数字视为`True`。由于`9`被视为`True`，这使得整个`or`表达式为`True`。在将自然语言翻译成 Python 时，请仔细检查你的布尔表达式，以避免这类错误。
- en: and Operator
  id: totrans-172
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: and 运算符
- en: 'The `and` operator returns `True` if both of its operands are `True`, and returns
    `False` otherwise:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`and`运算符返回`True`，当它的两个操作数都为`True`时，否则返回`False`：'
- en: '[PRE34]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The only way to get `True` out of the `And` operator is if both of its operands
    are `True`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一能让`And`运算符返回`True`的情况是它的两个操作数都为`True`。
- en: 'The precedence of `and` is higher than `or`. Here’s an example of why this
    matters:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`and`的优先级高于`or`。以下是为什么这很重要的一个示例：'
- en: '[PRE35]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Python interprets that expression like this, with the `and` happening first:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Python 会这样解析该表达式，首先执行`and`：
- en: '[PRE36]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The result is `True` because the first operand of `or` is `True`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 结果为`True`，因为`or`的第一个操作数为`True`。
- en: 'We can force the `or` to happen first by including parentheses:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过括号强制让`or`先发生：
- en: '[PRE37]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The result is `False` because the second operand of `and` is `False`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 结果为`False`，因为`and`的第二个操作数为`False`。
- en: not Operator
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: not 运算符
- en: 'Another important Boolean operator is `not`. Unlike `or` and `and`, `not` takes
    only one operand (not two). If its operand is `True`, not returns `False`, and
    vice versa:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的布尔运算符是`not`。与`or`和`and`不同，`not`只接受一个操作数（而不是两个）。如果其操作数为`True`，则`not`返回`False`，反之亦然：
- en: '[PRE38]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The precedence of `not` is higher than `or` and `and`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`not`的优先级高于`or`和`and`。'
- en: '**CONCEPT CHECK**'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念检查**'
- en: Here’s an expression and versions of that expression with parentheses. Which
    of them evaluates to `True`?
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个表达式及其带括号的不同版本。哪个版本的值为 `True`？
- en: A. `not True and False`
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: A. `not True and False`
- en: B. `(not True) and False`
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: B. `(not True) and False`
- en: C. `not (True and False)`
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: C. `not (True and False)`
- en: D. None of the above
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: D. 以上都不是
- en: 'Answer: C. The expression `(True and False)` evaluates to `False`; the `not`
    therefore makes the full expression `True`.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：C。表达式 `(True and False)` 的值为 `False`；因此，`not` 会使整个表达式的值为 `True`。
- en: '**CONCEPT CHECK**'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念检查**'
- en: Consider the expression `not a or b`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑表达式 `not a or b`。
- en: Which of the following makes the expression `False`?
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 以下哪项使得表达式的值为 `False`？
- en: A. `a False`, `b False`
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: A. `a False`，`b False`
- en: B. `a False`, `b True`
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: B. `a False`，`b True`
- en: C. `a True`, `b False`
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: C. `a True`，`b False`
- en: D. `a True`, `b True`
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: D. `a True`，`b True`
- en: E. More than one of the above
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: E. 以上多个选项
- en: 'Answer: C. If `a` is `True`, then `not a` is `False`. Since `b` is `False`,
    too, both operands to `or` are `False`, so the whole expression evaluates to `False`.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：C。如果 `a` 为 `True`，则 `not a` 为 `False`。由于 `b` 也为 `False`，所以 `or` 运算符的两个操作数都是
    `False`，因此整个表达式的值为 `False`。
- en: Solving the Problem
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决问题
- en: With Boolean operators at the ready, we can tackle the Telemarketers problem.
    Our solution is in [Listing 2-2](ch02.xhtml#ch02ex02).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 使用布尔运算符，我们可以解决电话推销员问题。我们的解决方案在 [清单 2-2](ch02.xhtml#ch02ex02) 中。
- en: '[PRE39]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '*Listing 2-2: Solving Telemarketers*'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-2：解决电话推销员问题*'
- en: As in Winning Team, we start by reading the input and converting it to integers.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如同“获胜团队”章节一样，我们首先读取输入并将其转换为整数。
- en: The high-level structure of our `if` statement ❶ is three expressions connected
    by `and` operators; each of them must be `True` for the entire expression to be
    `True`. We require that the first number be `8` or `9`, that the fourth number
    be `8` or `9`, and that the second and third numbers be equal. If all three of
    these conditions hold, then we know that the phone number belongs to a telemarketer,
    and we output `ignore`. Otherwise, the phone number does not belong to a telemarketer,
    and we output `answer`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `if` 语句的高级结构 ❶ 由三个用 `and` 运算符连接的表达式组成；它们每一个都必须为 `True`，整个表达式才为 `True`。我们要求第一个数字是
    `8` 或 `9`，第四个数字是 `8` 或 `9`，第二个和第三个数字相等。如果这三个条件都满足，那么我们知道该电话号码属于电话推销员，我们输出 `ignore`。否则，电话号码不属于电话推销员，我们输出
    `answer`。
- en: I’ve split the Boolean expression over three lines. This requires wrapping the
    entire expression in an additional pair of parentheses, as I have done. (Without
    those parentheses, you’ll get a syntax error, because there’s no indication to
    Python that the expression is continuing on the next line.)
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我将布尔表达式拆分为三行。这要求将整个表达式用一对额外的括号括起来，正如我所做的那样。（如果没有这些括号，你会遇到语法错误，因为 Python 不知道该表达式将在下一行继续。）
- en: Python style guides suggest that a line be no longer than 79 characters. A line
    with the full Boolean expression would squeak in there at 76 characters. But I
    think the three-line version is clearer, highlighting each condition that must
    be `True` on its own line.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Python 风格指南建议一行代码长度不超过 79 个字符。带有完整布尔表达式的一行代码长度为 76 个字符，正好符合要求。但我认为三行版本更清晰，将每个条件单独列出。
- en: We have a good solution here. To explore a little further, let’s discuss some
    alternate approaches.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这里有一个很好的解决方案。为了进一步探索，让我们讨论一些其他的方法。
- en: Our code uses a Boolean expression to detect when a phone number belongs to
    a telemarketer. We could have also chosen to write code that detects when a phone
    number does *not* belong to a telemarketer. If the phone number doesn’t belong
    to a telemarketer, we should output `answer`; otherwise, we should output `ignore`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码使用布尔表达式来检测电话号码是否属于电话推销员。我们也可以选择编写代码来检测电话号码是否*不*属于电话推销员。如果电话号码不属于电话推销员，我们应该输出
    `answer`；否则，我们应该输出 `ignore`。
- en: If the first digit isn’t `8` and isn’t `9`, then the phone number doesn’t belong
    to a telemarketer. Or, if the fourth digit isn’t `8` and isn’t `9`, then the phone
    number doesn’t belong to a telemarketer. Or, if the second and third digits aren’t
    equal, then the phone number doesn’t belong to a telemarketer. If even one of
    these expressions is `True`, then the phone number doesn’t belong to a telemarketer.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第一个数字不是 `8` 且不是 `9`，则电话号码不属于电话推销员。或者，如果第四个数字不是 `8` 且不是 `9`，则电话号码不属于电话推销员。或者，如果第二和第三个数字不相等，则电话号码不属于电话推销员。如果这些表达式中有任何一个为
    `True`，则电话号码不属于电话推销员。
- en: See [Listing 2-3](ch02.xhtml#ch02ex03) for a version of the code that captures
    this logic.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 请参见 [清单 2-3](ch02.xhtml#ch02ex03) 了解捕获此逻辑的代码版本。
- en: '[PRE40]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '*Listing 2-3: Solving Telemarketers, alternate approach*'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-3：解决推销员问题，替代方法*'
- en: It’s not easy getting all of those `!=`, `or`, and `and` operators correct!
    Notice, for example, that we’ve had to change all `==` operators to `!=`, all
    `or` operators to `and`, and all `and` operators to `or`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 要正确使用所有这些`!=`、`or`和`and`运算符可不容易！例如，注意我们已经将所有的`==`运算符改为`!=`，所有的`or`运算符改为`and`，所有的`and`运算符改为`or`。
- en: An alternate approach is to use the `not` operator to negate the “is a telemarketer”
    expression in one shot. See [Listing 2-4](ch02.xhtml#ch02ex04) for that code.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用`not`运算符来一次性否定“是推销员”的表达式。可以查看[清单 2-4](ch02.xhtml#ch02ex04)中的代码。
- en: '[PRE41]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '*Listing 2-4: Solving Telemarketers, not operator*'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-4：解决推销员问题，使用非运算符*'
- en: Which of these solutions do you find most intuitive? There’s often more than
    one way to structure the logic of an `if` statement, and we should use the one
    that’s easiest to get right. To me, [Listing 2-2](ch02.xhtml#ch02ex02) is the
    most natural, but you may feel otherwise!
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为哪一种解决方案最直观？通常有不止一种方式来构建`if`语句的逻辑，我们应该选择最容易正确实现的方式。对我来说，[清单 2-2](ch02.xhtml#ch02ex02)是最自然的，但你可能有不同的看法！
- en: Choose your favorite version and submit it to the judge. You should see that
    all test cases pass.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 选择你最喜欢的版本并提交给评测系统。你应该看到所有的测试用例都通过了。
- en: Comments
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释
- en: 'We should always strive to make our programs as clear as possible. This helps
    to avoid introducing errors when programming and makes it easier to fix our code
    when errors do slip in. Meaningful variable names, spaces around operators, blank
    lines to segment the program into its logical pieces, simple `if` statement logic:
    all of these practices can improve the quality of the code we write. Another good
    habit is adding *comments* to our code.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该始终努力使我们的程序尽可能清晰。这有助于避免在编程时引入错误，并使在错误发生时更容易修复代码。具有意义的变量名、运算符周围的空格、分割程序逻辑部分的空行、简单的`if`语句逻辑：所有这些做法都能提高我们编写代码的质量。另一个好习惯是为我们的代码添加*注释*。
- en: 'A comment is introduced by the `#` character and continues until the end of
    the line. Python ignores comments, so they have no impact on what our program
    does. We add comments to remind ourselves, or others, about design decisions that
    we’ve made. Assume that the person reading the code knows Python, so avoid comments
    that simply restate what the code is doing. Here’s code with an unnecessary comment:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 注释是通过`#`字符引入的，并且会一直持续到行末。Python 会忽略注释，因此它们对程序的执行没有任何影响。我们添加注释是为了提醒自己或他人关于我们所做的设计决策。假设阅读代码的人懂
    Python，所以避免写那些只是简单重复代码功能的注释。下面是一个带有不必要注释的代码：
- en: '[PRE42]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: That comment adds nothing beyond what we already know about assignment statements.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这个注释除了我们已经知道的赋值语句之外，并没有提供任何额外的信息。
- en: See [Listing 2-5](ch02.xhtml#ch02ex05) for a version of [Listing 2-2](ch02.xhtml#ch02ex02)
    with comments.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 可以查看[清单 2-5](ch02.xhtml#ch02ex05)中的版本，那里是[清单 2-2](ch02.xhtml#ch02ex02)的注释版。
- en: '[PRE43]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '*Listing 2-5: Solving Telemarketers, comments added*'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-5：解决推销员问题，已添加注释*'
- en: 'I’ve added three comment lines: the one at the top ❶ reminds us of the problem
    code and name, and the two before the `if` statement ❷ remind us of the rules
    for detecting a telemarketer phone number.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我添加了三行注释：顶部的那一行❶提醒我们问题代码和名称，而`if`语句前的两行❷提醒我们如何识别推销员的电话号码。
- en: Don’t go overboard with comments. Whenever possible, write code that doesn’t
    require comments in the first place. But for tricky code or to document why you
    chose to do something in a particular way, a well-placed comment now can save
    time and frustration later.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 不要过度使用注释。尽可能编写不需要注释的代码。如果代码比较复杂，或者需要记录你为何以某种方式编写代码，那么现在添加一个适当的注释将能为以后节省时间和减少挫败感。
- en: Input and Output Redirection
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 输入和输出重定向
- en: When you submit Python code to the judge, it runs many test cases to determine
    whether your code is correct. Is someone there, dutifully waiting for new code
    and then frantically hammering test cases at it from the keyboard?
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将 Python 代码提交给评测系统时，它会运行许多测试用例来确定代码是否正确。难道有人在那里，忠实地等待新代码，并且疯狂地从键盘上敲下测试用例？
- en: No way! It’s all automated. There’s no one typing test cases at the keyboard.
    How does the judge test our code, then, if we satisfy a call to `input` by typing
    something from the keyboard?
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 不可能！这一切都是自动化的。没有人在键盘上输入测试用例。那么，如果我们通过键盘输入某些内容来满足`input`的调用，评测系统是如何测试我们的代码的呢？
- en: The truth is that `input` isn’t necessarily reading input from the keyboard.
    It’s reading from a source of input called *standard input*, which, by default,
    is the keyboard.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，`input`不一定是从键盘读取输入。它是从一个名为*标准输入*的输入源读取，默认情况下，标准输入就是键盘。
- en: It’s possible to change standard input so that it refers to a file rather than
    the keyboard. The technique is called *input redirection*, and it’s what the judge
    uses to provide input.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 可以更改标准输入，使其指向文件而不是键盘。这种技术称为*输入重定向*，它是评测系统用来提供输入的方式。
- en: We can also try input redirection ourselves. For programs whose input is small—just
    a line of text or a couple of integers—input redirection may not save us much.
    But for programs whose test cases can be tens or hundreds of lines long, input
    redirection makes it much easier to test our work. Rather than typing the same
    test case over and over, we can store it in a file and then run our program on
    it as many times as we want.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以自己尝试输入重定向。对于输入较小的程序——比如一行文本或几个整数——输入重定向可能不会节省太多时间。但对于那些测试用例可能有几十行甚至上百行的程序，输入重定向能大大简化测试工作。我们可以将测试用例保存在文件中，然后多次运行程序，而不需要一遍遍地手动输入。
- en: 'Let’s try input redirection on Telemarketers. Navigate to your *programming*
    folder and create a new file called *telemarketers_input.txt*. In that file, type
    the following:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试在电话营销程序上使用输入重定向。进入你的*programming*文件夹，创建一个名为*telemarketers_input.txt*的新文件。在该文件中输入以下内容：
- en: '[PRE44]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The problem specifies that we should provide one integer per line, so we’ve
    written them one per line here.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 该问题要求我们每行提供一个整数，所以我们在这里按行写下它们。
- en: Save the file. Now enter python telemarketers.py < telemarketers_input.txt to
    run your program using input redirection. Your program should output `ignore`,
    just as it would if you’d typed the test case from the keyboard.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件后，输入`python telemarketers.py < telemarketers_input.txt`来使用输入重定向运行程序。你的程序应该输出`ignore`，就像你从键盘输入测试用例时一样。
- en: The `<` symbol instructs your operating system to use a file rather than the
    keyboard to provide input. After the `<` symbol comes the name of the file that
    contains the input.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`<`符号指示操作系统使用文件而不是键盘提供输入。`<`符号后面是包含输入的文件名。'
- en: To try your program on different test cases, just modify the *telemarketers_input.txt*
    file and run your program again.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 要在不同的测试用例上尝试你的程序，只需修改*telemarketers_input.txt*文件并重新运行程序。
- en: We can also change where our output goes, though we won’t need to for this book.
    The `print` function outputs to *standard output*, which, by default, is the screen.
    We can change standard output so that it instead refers to a file. We do so using
    *output redirection*, which is written as a `>` symbol followed by a filename.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以改变输出的去向，尽管在本书中我们不需要这样做。`print`函数默认输出到*标准输出*，即屏幕。我们可以改变标准输出，使其指向文件。通过使用*输出重定向*，它是一个`>`符号后跟一个文件名。
- en: Enter python telemarketers.py > telemarketers_output.txt to run your program
    using output redirection. Provide four integers of input, and you should be back
    to your operating system prompt. But you shouldn’t see any output from your Telemarketers
    program! That’s because we’ve redirected the output to file `telemarketers_output.txt`.
    If you open `telemarketers_output.txt` in your text editor, you should see the
    output there.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 输入`python telemarketers.py > telemarketers_output.txt`来使用输出重定向运行程序。输入四个整数后，你应该回到操作系统的提示符。但你不应该看到来自电话营销程序的任何输出！这是因为我们将输出重定向到了文件`telemarketers_output.txt`。如果你在文本编辑器中打开`telemarketers_output.txt`，应该能在那里看到输出。
- en: Be careful with output redirection. If you use a filename that already exists,
    your old file will be overwritten! Always double-check that you’re using the filename
    you intended.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 小心输出重定向。如果你使用已经存在的文件名，旧的文件将被覆盖！请始终仔细检查你使用的文件名是否是你预期的。
- en: Summary
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned how to use `if` statements to direct what our programs
    do. The key ingredient of an `if` statement is a Boolean expression, which is
    an expression with a `True` or `False` value. To build up Boolean expressions,
    we use relational operators such as `==` and `>=`, and we use Boolean operators
    such as `and` and `or`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用`if`语句来控制程序的行为。`if`语句的关键部分是布尔表达式，它是一个值为`True`或`False`的表达式。为了构建布尔表达式，我们使用关系运算符，如`==`和`>=`，以及布尔运算符，如`and`和`or`。
- en: Deciding what to do based on what is `True` and `False` makes our programs more
    flexible, able to adapt to the situation at hand. But our programs are still limited
    to handling small amounts of input and output—whatever we can do with individual
    calls to `input` and `print`. In the next chapter, we’ll start learning about
    loops, which let us repeat code so that we can process as much input and output
    as we like.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 `True` 和 `False` 来决定做什么，使我们的程序更加灵活，能够根据实际情况做出调整。但我们的程序仍然局限于处理少量的输入和输出——无论是使用单独的
    `input` 和 `print` 调用能做到什么。下一章，我们将开始学习循环，它让我们能够重复代码，从而处理任意多的输入和输出。
- en: Want to work with 100 values? How about 1,000? And with just a small amount
    of Python code? It is a little early for me to be provoking you, I know, because
    you still have the following exercises to do. But when you’re ready, read on!
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 想要处理 100 个值吗？那 1,000 个怎么样？而且只需要一点点 Python 代码？我知道现在挑衅你有点早，因为你还需要完成以下练习。但当你准备好时，继续往下读吧！
- en: Chapter Exercises
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 章节练习
- en: Here are some exercises for you to try.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些练习供你尝试。
- en: DMOJ problem `ccc06j1`, Canadian Calorie Counting
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ 问题 `ccc06j1`，加拿大卡路里计算
- en: DMOJ problem `ccc15j1`, Special Day
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ 问题 `ccc15j1`，特别的日子
- en: DMOJ problem `ccc15j2`, Happy or Sad
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ 问题 `ccc15j2`，快乐还是悲伤
- en: DMOJ problem `dmopc16c1p0`, C.C. and Cheese-kun
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ 问题 `dmopc16c1p0`，C.C. 和 Cheese-kun
- en: DMOJ problem `ccc07j1`, Who is in the Middle
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ 问题 `ccc07j1`，谁在中间
- en: Notes
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: Winning Team is originally from the 2019 Canadian Computing Competition, Junior
    Level. Telemarketers is originally from the 2018 Canadian Computing Competition,
    Junior Level.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 《获胜团队》原本来自 2019 年加拿大计算机竞赛，初级水平。《电话推销员》原本来自 2018 年加拿大计算机竞赛，初级水平。
