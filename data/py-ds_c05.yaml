- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Working with Databases
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数据库
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: A *database* is an organized collection of data that can be easily accessed,
    managed, and updated. Even if there isn’t a database in the initial architecture
    of your project, data that flows through your application will likely touch one
    or more databases at some point.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*数据库*是一个有组织的数据集合，可以方便地访问、管理和更新。即使你的项目初期架构中没有数据库，流经你应用的数据在某个时刻也很可能会接触到一个或多个数据库。'
- en: Continuing the previous chapter’s discussion on importing data into your Python
    applications, this chapter covers working with database data. The examples here
    will show you how to access and manipulate data stored in databases of different
    types, including those that position SQL as the primary tool to work with data
    and those that don’t. You’ll explore how to use Python to interface with a variety
    of popular databases, including MySQL, Regis, and MongoDB.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章延续上一章关于将数据导入Python应用程序的讨论，讲解如何处理数据库中的数据。这里的示例将展示如何访问和操作存储在不同类型数据库中的数据，包括将SQL作为主要工具来处理数据的数据库以及不使用SQL的数据库。你将学习如何使用Python与多种流行数据库进行交互，包括MySQL、Regis和MongoDB。
- en: Databases offer many advantages. For one, with the help of a database, you can
    persist data between invocations of a script and efficiently share data between
    different applications. Moreover, database languages can help you systematically
    organize and answer questions about your data. Additionally, many database systems
    allow you to implement programming code within the database itself, which can
    improve the performance, modularity, and reusability of an application. For example,
    you might store a *trigger* in a database; this is a piece of code that’s invoked
    automatically each time a certain event happens, such as every time you insert
    a new row into a particular table.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '数据库提供了许多优势。首先，借助数据库，你可以在脚本的多次调用之间持久化数据，并高效地在不同应用程序之间共享数据。此外，数据库语言可以帮助你系统地组织数据并回答关于数据的问题。更重要的是，许多数据库系统允许你在数据库内部实现编程代码，这可以提高应用程序的性能、模块化和可重用性。例如，你可以在数据库中存储一个*触发器*；这是一段代码，每当发生某个特定事件时自动触发，比如每次向某个特定表格插入新行时。 '
- en: 'There are two categories of databases: relational databases and nonrelational
    (NoSQL) databases. Relational databases have a rigid structure implemented in
    the form of a schema for the data being stored. This approach helps ensure the
    integrity, consistency, and overall accuracy of the data. However, the major drawback
    of relational databases is that they don’t scale well as data volumes increase.
    In contrast, NoSQL databases don’t impose restrictions on the structure of the
    data being stored, thus allowing for more flexibility, adaptability, and scalability.
    This chapter will cover storing and retrieving data in both relational and nonrelational
    databases.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库分为两类：关系型数据库和非关系型（NoSQL）数据库。关系型数据库有一个固定的结构，以数据的架构形式实现。这种方法有助于确保数据的完整性、一致性和总体准确性。然而，关系型数据库的主要缺点是随着数据量的增加，它们的扩展性较差。相比之下，NoSQL数据库对数据结构没有限制，从而提供了更多的灵活性、适应性和可扩展性。本章将涵盖在关系型和非关系型数据库中存储和检索数据。
- en: Relational Databases
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关系型数据库
- en: '*Relational databases*, also known as *row-and-column databases*, are the most
    common type of database in use today. They provide a structured way of storing
    data. Just like a list of books on Amazon has a set structure for storing information,
    with fields for book titles, authors, descriptions, ratings, and so on, the data
    stored in a relational database must fit a predefined formal schema. Working with
    a relational database starts with designing that formal schema: you define a collection
    of tables, each made up of a set of fields or columns, and you specify what type
    of data each field will store. You also establish the relationships between the
    tables. Then you can store data to the database, retrieve data from the database,
    or update the data as needed.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*关系型数据库*，也叫做*行列式数据库*，是当今最常用的数据库类型。它们提供了一种结构化的方式来存储数据。就像亚马逊上的书籍列表有一套结构来存储信息，包括书名、作者、简介、评分等字段，存储在关系型数据库中的数据必须符合预定义的形式化架构。使用关系型数据库的工作从设计这个形式化架构开始：你定义一组表格，每个表格由一组字段或列组成，并且你指定每个字段将存储的数据类型。你还要建立表格之间的关系。然后，你就可以将数据存入数据库、从数据库中检索数据或根据需要更新数据。'
- en: Relational databases are designed to allow the efficient insertion, updating,
    and/or deleting of small to vast amounts of structured data. There are plenty
    of applications where this type of database can be put to great use. In particular,
    relational databases are well suited for *online transaction processing (OLTP)*
    applications, which process a high volume of transactions for a large number of
    users.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 关系型数据库旨在高效地插入、更新和/或删除少量到大量的结构化数据。在许多应用中，这种类型的数据库都能发挥重要作用。特别地，关系型数据库非常适合*在线事务处理（OLTP）*应用程序，这些应用程序处理大量用户的高交易量。
- en: Some common relational database systems are MySQL, MariaDB, and PostgreSQL.
    This section will focus on MySQL, arguably the world’s most popular open source
    database, to illustrate how to interact with a database. You’ll learn how to set
    up MySQL, create a new database, define its structure, and write Python scripts
    to store and retrieve data to and from the database.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一些常见的关系型数据库系统包括MySQL、MariaDB和PostgreSQL。本节将重点介绍MySQL，毫无疑问是全球最流行的开源数据库，来说明如何与数据库交互。你将学习如何设置MySQL、创建新数据库、定义其结构，并编写Python脚本来存储和检索数据。
- en: Understanding SQL Statements
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解SQL语句
- en: '*SQL*, or *Structured Query Language*, is the primary tool for interacting
    with a relational database. Although our focus here is on interfacing with databases
    using Python, the Python code must itself contain SQL statements to do this. A
    comprehensive look at SQL is beyond the scope of this book, but a brief introduction
    to this query language is nonetheless in order.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*SQL*，或称*结构化查询语言*，是与关系型数据库进行交互的主要工具。尽管我们这里的重点是使用Python与数据库进行交互，但Python代码本身必须包含SQL语句才能实现这一点。全面了解SQL超出了本书的范围，但简要介绍这一查询语言仍然是必要的。'
- en: 'SQL statements are text commands recognized and executed by a database engine
    like MySQL. For example, this SQL statement asks a database to retrieve all the
    rows from a table called `orders` whose `status` field is set to `Shipped`:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: SQL语句是数据库引擎（如MySQL）识别并执行的文本命令。例如，这条SQL语句要求数据库检索`orders`表中`status`字段设置为`Shipped`的所有行：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'SQL statements typically have three major components: an *operation* to be
    performed, a *target* for that operation, and a *condition* that narrows the scope
    of the operation. In the preceding example, `SELECT` is the SQL operation, meaning
    we’re accessing rows from the database. The `orders` table is the target for the
    operation, as defined by the `FROM` clause, and the condition is specified in
    the `WHERE` clause of the statement. All SQL statements must have an operation
    and a target, but the condition is optional. This statement, for instance, lacks
    a condition, so it retrieves all the rows from the `orders` table:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: SQL语句通常包含三个主要组成部分：一个*操作*，一个*目标*以及一个*条件*，后者用以限定操作的范围。在前面的例子中，`SELECT`是SQL操作，意味着我们正在从数据库中访问行。`orders`表是操作的目标，由`FROM`子句定义，条件则在语句的`WHERE`子句中指定。例如，这条语句缺少条件，因此它将检索`orders`表中的所有行：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You can also refine SQL statements to only affect certain columns of a table.
    Here’s how to retrieve only the `pono` and `date` columns of all the rows in the
    `orders` table:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以精炼SQL语句，使其仅影响表中的某些列。以下是如何仅检索`orders`表中所有行的`pono`和`date`列：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: By convention, language-reserved words in SQL, such as `SELECT` and `FROM`,
    are written in all caps. However, SQL is a case-insensitive language, so this
    capitalization isn’t strictly necessary. Each SQL statement should end with a
    semicolon.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 按约定，SQL中的保留字，如`SELECT`和`FROM`，通常采用全大写字母书写。然而，SQL是一个大小写不敏感的语言，因此这种大写并非严格必要。每个SQL语句应以分号结束。
- en: '`SELECT` operations like those just shown are examples of *Data Manipulation
    Language (DML)* *statements*, a category of SQL statements that you use to access
    and manipulate database data. Other DML operations include `INSERT`, `UPDATE`,
    and `DELETE`, which add, change, and remove records from a database, respectively.
    *Data Definition Language (DDL)* *statements* are another common category of SQL
    statements. You use these to actually define the database structure. Typical DDL
    operations include `CREATE` to make, `ALTER` to modify, and `DROP` to delete data
    containers, whether that be columns, tables, or whole databases.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 像刚才展示的`SELECT`操作就是*数据操作语言（DML）* *语句*的例子，DML语句是一类用于访问和操作数据库数据的SQL语句。其他DML操作包括`INSERT`、`UPDATE`和`DELETE`，分别用于向数据库中添加、修改和删除记录。*数据定义语言（DDL）*
    *语句*是另一类常见的SQL语句。你使用这些语句来实际定义数据库结构。典型的DDL操作包括`CREATE`来创建、`ALTER`来修改、`DROP`来删除数据容器，无论是列、表还是整个数据库。
- en: Getting Started with MySQL
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MySQL入门
- en: MySQL is available on a majority of modern operating systems, including Linux,
    Unix, Windows, and macOS. Both free and commercial editions are available. For
    the purposes of this chapter, you can use MySQL Community Edition ([https://www.mysql.com/products/community](https://www.mysql.com/products/community)),
    the freely downloadable version of MySQL, which is available under the GPL license.
    For detailed MySQL installation instructions for your operating system, refer
    to the reference manual for the latest version of MySQL, available at [https://dev.mysql.com/doc](https://dev.mysql.com/doc).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL可用于大多数现代操作系统，包括Linux、Unix、Windows和macOS。提供免费和商业版。对于本章内容，你可以使用MySQL社区版（[https://www.mysql.com/products/community](https://www.mysql.com/products/community)），这是MySQL的免费下载版，适用于GPL许可证。有关你操作系统的MySQL安装详细说明，请参考MySQL最新版本的参考手册，网址为[https://dev.mysql.com/doc](https://dev.mysql.com/doc)。
- en: 'To start the MySQL server after installation, you need to use the command that
    the installation guide specifies for your operating system. Then you can connect
    to the MySQL server from a system terminal using the *mysql* client program:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装后，要启动MySQL服务器，你需要使用安装指南中为你的操作系统指定的命令。然后，你可以从系统终端使用*mysql*客户端程序连接到MySQL服务器：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You’ll be asked to enter your password, which you set during the MySQL server
    installation process. After that, you’ll see the MySQL prompt:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 系统会要求你输入在MySQL服务器安装过程中设置的密码。之后，你将看到MySQL提示符：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you like, you can choose a new password for the root user with the following
    SQL command:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，可以使用以下SQL命令为root用户选择一个新密码：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now you can create the database that you’ll need for your application. Enter
    this command at the `mysql>` prompt:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以创建你的应用程序所需的数据库。在`mysql>`提示符下输入以下命令：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This creates a database called `sampledb`. Next, you must choose that database
    for use:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为`sampledb`的数据库。接下来，你必须选择该数据库进行使用：
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now any subsequent commands will apply to your `sampledb` database.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，任何后续命令都将作用于你的`sampledb`数据库。
- en: Defining the Database Structure
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义数据库结构
- en: 'A relational database gets its structure from the makeup of its constituent
    tables and from the connections between those tables. The fields that link different
    tables are called *keys*. There are two types: *primary keys* and *foreign keys*.
    A primary key uniquely identifies a record in a table. A foreign key is a field
    in another table that corresponds to the primary key in the first table. Typically,
    the primary key and its corresponding foreign key share the same name in both
    tables.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 关系型数据库的结构来自其组成表格的构成以及这些表格之间的连接。链接不同表格的字段称为*键*。有两种类型：*主键*和*外键*。主键唯一标识表格中的一条记录。外键是另一个表中的字段，指向第一个表中的主键。通常，主键和对应的外键在两个表中共享相同的名称。
- en: 'Now that you’ve created your `sampledb` database, you’re ready to create some
    tables and define their structure. For demonstration purposes, the tables will
    have the same structure as some of the pandas DataFrames you worked with in Chapter
    3. Here are three tabular data structures to be implemented in your database:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经创建了`sampledb`数据库，可以开始创建一些表格并定义它们的结构。为了演示目的，这些表格将具有与你在第3章中使用的一些pandas数据框相同的结构。以下是需要在数据库中实现的三个表格数据结构：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: To review what relations can be established between these structures, refer
    back to Figures 3-4 and 3-6 from Chapter 3. As can be seen in Figure 3-4, the
    rows in the `emps` and `salary` tables are related with a one-to-one relationship.
    The relation is established via the `empno` field. The `emps` and `orders` tables
    are also related via the `empno` field. This is a one-to-many relationship, as
    depicted in Figure 3-6.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看这些结构之间可以建立哪些关系，请回顾第3章中的图3-4和图3-6。如图3-4所示，`emps`表和`salary`表中的行之间具有一对一的关系。这个关系是通过`empno`字段建立的。`emps`表和`orders`表之间也通过`empno`字段建立了关系。这是一个一对多的关系，如图3-6所示。
- en: 'You can add these data structures to your relational database using SQL commands
    at the `mysql>` prompt. Start by creating the `emps` table:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`mysql>`提示符通过SQL命令将这些数据结构添加到关系型数据库中。首先，创建`emps`表：
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You create the table with the `CREATE TABLE` command, specifying each column
    along with the type and, optionally, the size of data you can store in it. For
    example, the `empno` column is for integers (type `INT`), and the `NOT NULL` constraint
    applied to it guarantees that you won’t be able to insert a row with an empty
    `empno` field. Meanwhile, the `empname` column can hold strings (type `VARCHAR`)
    up to 50 characters long, while `job` can hold strings up to 30 characters long.
    You also specify that `empno` is the primary key column in the table, meaning
    it’s not supposed to have duplicates across the table.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用`CREATE TABLE`命令创建表，指定每一列及其数据类型，并可选择性地指定可存储数据的大小。例如，`empno`列用于存储整数（类型为`INT`），而对其应用的`NOT
    NULL`约束确保你无法插入一个`empno`字段为空的行。与此同时，`empname`列可以存储最长为50个字符的字符串（类型为`VARCHAR`），而`job`列可以存储最多30个字符的字符串。你还指定`empno`是该表的主键列，意味着它在表中不应有重复值。
- en: 'On successful execution of this command, you’ll see the following message:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功执行该命令后，你将看到以下消息：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Similarly, here’s how to create the `salary` table:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，下面是如何创建`salary`表的示例：
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, you’ll add a foreign key constraint to the `empno` column of the `salary`
    table, referencing the `empno` column of the `emps` table:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将在`salary`表的`empno`列中添加外键约束，引用`emps`表中的`empno`列：
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This command creates the relationship between the `salary` and `empno` tables.
    It establishes that an employee number in the `salary` table must match an employee
    number in the `emps` table. This constraint guarantees that you won’t be able
    to insert a row into the `salary` table if the table doesn’t have a corresponding
    row in the `emps` table.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令创建了`salary`表和`empno`表之间的关系。它规定了`salary`表中的员工编号必须与`emps`表中的员工编号匹配。这个约束确保如果`emps`表中没有对应的行，你将无法向`salary`表插入新行。
- en: 'Since the `salary` table has no rows so far, the `ALTER TABLE` operation affects
    no rows, as can be seen from the resulting message:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`salary`表目前没有任何行，因此`ALTER TABLE`操作不会影响任何行，可以从返回的消息中看到这一点：
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, create the `orders` table:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，创建`orders`表：
- en: '[PRE14]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This time you add a foreign key constraint within the `CREATE TABLE` command,
    thus defining the foreign key immediately upon the creation of the table.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这次你在`CREATE TABLE`命令中添加了一个外键约束，从而在创建表时立即定义外键。
- en: Inserting Data into the Database
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向数据库插入数据
- en: 'Now you’re ready to insert rows into your newly created tables. While you could
    do this using the `mysql>` prompt, this type of operation is usually performed
    from an application. You’ll interact with the database from your Python code through
    the MySQL Connector/Python driver. You can install it via `pip`, as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经准备好向新创建的表中插入数据。虽然你可以使用`mysql>`提示符执行此操作，但通常这种操作是通过应用程序进行的。你将在Python代码中通过MySQL
    Connector/Python驱动与数据库进行交互。你可以通过`pip`安装它，如下所示：
- en: '[PRE15]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Run the following script to populate your database tables with data:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下脚本，将数据填充到数据库表中：
- en: '[PRE16]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this script, you import the MySQL Connector/Python driver as `mysql.connector`.
    Then you open a `try/except` block, which provides a template for any database-related
    operations you need to perform within your script. You write the code for the
    operation in the `try` block, and if an error occurs when the operation is carried
    out, the execution is transferred to the `except` block.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个脚本中，你将MySQL Connector/Python驱动导入为`mysql.connector`。然后你打开一个`try/except`块，它为你在脚本中执行任何与数据库相关的操作提供了一个模板。你将在`try`块中编写操作的代码，如果操作执行时发生错误，执行将转到`except`块。
- en: Within the `try` block, you start by establishing a connection to the database,
    specifying your username and password, the host IP address (in this case, your
    local host), and the database name ❶. Then you obtain a `cursor` object related
    to this connection ❷. The `cursor` object provides the means for statement execution
    as well as the interface for fetching the results.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在`try`块中，首先建立与数据库的连接，指定你的用户名和密码、主机IP地址（在这种情况下是本地主机）以及数据库名称❶。然后，获取与此连接相关的`cursor`对象❷。`cursor`对象提供了执行语句和获取结果的接口。
- en: You define rows for the `emps` table as a list of tuples ❸. Then, you define
    the SQL statement to be executed to insert these rows into the table ❹. In this
    `INSERT` statement, you specify the fields to be filled with data, along with
    `%s` placeholders that map these fields to the members of each tuple. In a loop,
    you execute the statement, inserting the rows one at a time with the `cursor.execute()`
    method ❺. Similarly, you then insert rows into the `salary` and `orders` tables.
    At the end of the `try` block, you make all the insertions into the database permanent
    with the connection’s `commit()` method ❻.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你将`emps`表的行定义为一个元组列表❸。然后，定义要执行的SQL语句，以便将这些行插入表中❹。在此`INSERT`语句中，你指定了要填充数据的字段，并使用`%s`占位符将这些字段与每个元组的成员相对应。在循环中，你执行该语句，使用`cursor.execute()`方法逐行插入数据❺。类似地，你也将数据插入`salary`和`orders`表中。在`try`块的末尾，你使用连接的`commit()`方法使所有插入的数据永久生效❻。
- en: If any database-related operation fails, the rest of the `try` clause is skipped
    and the `except` clause executes ❼, printing out an error code generated by the
    MySQL server along with the corresponding error message.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何与数据库相关的操作失败，`try`块中的其余部分将被跳过，`except`子句会执行❼，并打印出由MySQL服务器生成的错误代码以及相应的错误信息。
- en: The `finally` clause is executed in any case ❽. In this clause, you explicitly
    close the `cursor` and then close the connection.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`finally`子句无论如何都会执行❽。在此子句中，你显式地关闭`cursor`，然后关闭连接。'
- en: Querying Database Data
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询数据库数据
- en: 'Now that you’ve populated the tables with data, you can query that data for
    use in your Python code. Say you want to retrieve all the rows in the `emps` table
    where `empno` is greater than `9001`. To achieve this, use the script from the
    previous section as a model, changing only the `try` block as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经用数据填充了表格，可以查询这些数据以供Python代码使用。假设你想检索`emps`表中`empno`大于`9001`的所有行。为此，可以参考前一节的脚本，只需更改`try`块如下：
- en: '[PRE17]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Unlike the insertion operation, selecting rows doesn’t require you to perform
    multiple `cursor.execute()` operations in a loop, one for each row. Instead, you
    write a query specifying criteria for the rows you want to select, then get them
    all at once with a single `cursor.execute()` operation.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 与插入操作不同，选择行不需要在循环中对每一行执行多个`cursor.execute()`操作。相反，你编写一个查询，指定要选择的行的条件，然后通过一次`cursor.execute()`操作一次性获取所有行。
- en: In the `SELECT` statement that forms your query, you specify the asterisk symbol
    (`*`), which means you want to see all the fields in the retrieved rows ❶. In
    the `WHERE` clause, you specify the condition that a row must meet in order to
    be selected. Here, you indicate that rows must have an `empno` greater than the
    value of the variable bound to the `%s` placeholder ❷. The variable `empno` is
    bound to the placeholder during execution ❸. When you execute the query with `cursor.execute()`,
    you pass in the binding variable within a tuple as the second parameter ❹. The
    `execute()` method requires that binding variables be passed within a tuple or
    a dictionary even if you only need to pass in a single variable.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在构成查询的`SELECT`语句中，你指定了星号符号（`*`），这意味着你想查看检索到的行中的所有字段❶。在`WHERE`子句中，你指定了选择行必须满足的条件。在这里，你表明只有当`empno`大于绑定到`%s`占位符的变量的值时，行才会被选中❷。在执行过程中，变量`empno`会绑定到占位符❸。当你使用`cursor.execute()`执行查询时，你将绑定变量作为第二个参数传递，并以元组的形式传递❹。即使只需要传递一个变量，`execute()`方法也要求将绑定变量作为元组或字典传递。
- en: 'You access the retrieved rows via the `cursor` object, iterating over it in
    a loop. Each row is accessible as a tuple whose items represent the values of
    the row’s fields ❺. Here, you simply print the fields’ values, outputting the
    results row by row, as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过`cursor`对象访问检索到的行，并在循环中遍历它。每一行作为元组访问，元组的项表示该行字段的值❺。在这里，你只是打印字段的值，逐行输出结果，如下所示：
- en: '[PRE18]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You can also write `SELECT` statements that join rows from different tables
    together. Joining relational database tables mirrors the process of joining pandas
    DataFrames, as discussed in Chapter 3. You typically join tables through the foreign
    key relationship you define when you set up the database.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以编写`SELECT`语句，连接来自不同表的行。连接关系型数据库表类似于连接pandas DataFrame的过程，如第3章所讨论的那样。您通常通过在设置数据库时定义的外键关系来连接表。
- en: 'For example, suppose you want to join the `emps` and `salary` tables while
    keeping the condition that `empno` be greater than `9001`. You do this through
    their shared `empno` columns, since you defined `empno` in the `salary` table
    as a foreign key referencing `empno` in the `emps` table. You can implement this
    join with another modification to the `try` block of your script:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设您想要连接`emps`和`salary`表，并保持`empno`大于`9001`的条件。您可以通过它们共享的`empno`列来实现这一点，因为您在`salary`表中将`empno`定义为外键，引用了`emps`表中的`empno`。您可以通过修改脚本中的`try`块来实现此连接：
- en: '[PRE19]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This time, `query` contains a `SELECT` statement joining the `emps` and `salary`
    tables. In the `SELECT` list, you specify the columns from both tables that you
    want to include in the join ❶. In the `FROM` clause, you specify the two tables,
    connecting them with the `JOIN` keyword, along with the aliases `e` and `s`, which
    are needed to differentiate columns with the same name in both tables ❷. In the
    `ON` clause, you define the join condition, stating that the values in both tables’
    `empno` columns should match ❸. In the `WHERE` clause, as in the previous example,
    you use the `%s` placeholder to set the minimum `empno` value ❹.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，`query`包含一个`SELECT`语句，连接了`emps`和`salary`表。在`SELECT`列表中，您指定了要在连接中包含的两个表中的列
    ❶。在`FROM`子句中，您指定了这两个表，并通过`JOIN`关键字连接它们，以及别名`e`和`s`，这对于区分两个表中同名的列是必要的 ❷。在`ON`子句中，您定义了连接条件，表示两个表中的`empno`列的值应该匹配
    ❸。在`WHERE`子句中，与之前的例子一样，您使用`%s`占位符设置最小的`empno`值 ❹。
- en: 'The script outputs the following rows, with each employee’s salary joined to
    their record from the `emps` table:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本输出以下行，每个员工的薪资与其在`emps`表中的记录连接：
- en: '[PRE20]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Using Database Analytics Tools
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用数据库分析工具
- en: When persisting data in MySQL, you can take advantage of the database’s built-in
    analytics tools, such as analytical SQL, to significantly reduce the volume of
    data sent between your application and the database. *Analytical SQL* is an extra
    set of SQL commands designed for actually analyzing data stored in a database
    rather than simply storing, retrieving, and updating data. As an example, say
    you only want to import stock market data related to those companies whose prices
    didn’t drop more than 1 percent below the previous day’s price over a certain
    period. You can perform this preliminary analysis with analytical SQL, saving
    you from having to load an entire dataset of stock prices from the database into
    your Python script.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在MySQL中持久化数据时，您可以利用数据库内置的分析工具，如分析SQL，显著减少应用程序和数据库之间传输的数据量。*分析SQL*是一组额外的SQL命令，旨在实际分析存储在数据库中的数据，而不仅仅是存储、检索和更新数据。例如，假设您只想导入与那些股票价格在一定期间内未跌破前一天价格1%的公司相关的股市数据。您可以通过分析SQL进行初步分析，这样您就无需将整个股票价格数据集从数据库加载到Python脚本中。
- en: 'To see how this works, you’ll obtain stock data via the yfinance library introduced
    in Chapter 3 and store it to a database table. You’ll then query the table from
    a Python script, loading only the portion of the stock data that satisfies the
    specified condition. To start, you need to create a table in your `sampledb` database
    to store the stock data. The table should have three columns: `ticker`, `date`,
    and `price`. Enter the following command at the `mysql>` prompt:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解这个过程，您将通过第3章介绍的yfinance库获取股票数据并将其存储到数据库表中。然后，您将从Python脚本中查询该表，只加载满足指定条件的股票数据部分。首先，您需要在`sampledb`数据库中创建一个表来存储股票数据。该表应有三列：`ticker`、`date`和`price`。在`mysql>`提示符下输入以下命令：
- en: '[PRE21]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now use this script to obtain some stock data with yfinance:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用此脚本通过yfinance获取一些股票数据：
- en: '[PRE22]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: First, you define an empty list called `data` that will be populated with stock
    data ❶. As you saw earlier in the chapter, the `cursor.execute()` method expects
    data in the form of a list object when it executes an `INSERT` statement. Next,
    you define a list of tickers for which you want to obtain data ❷. Then, in a loop,
    you pass in each ticker from the `tickers` list to yfinance’s `Ticker()` function
    ❸. The function returns a `Ticker` object, whose `history()` method provides you
    with data related to the corresponding ticker. In this example you obtain stock
    data for each ticker for the last five business days (`period='5d'`).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，定义一个名为 `data` 的空列表，将填充股票数据❶。正如本章前面所见，`cursor.execute()` 方法在执行 `INSERT` 语句时期望数据以列表对象的形式传入。接下来，定义一个股票代码列表，你希望获取这些股票的数据❷。然后，在一个循环中，将
    `tickers` 列表中的每个股票代码传递给 yfinance 的 `Ticker()` 函数❸。该函数返回一个 `Ticker` 对象，其 `history()`
    方法提供与对应股票代码相关的数据。在此示例中，你获取了每个股票代码过去五个交易日的股票数据（`period='5d'`）。
- en: The `history()` method returns stock data as a pandas DataFrame with the `Date`
    column as the index. Ultimately, you want to convert that DataFrame into a list
    of tuples for insertion into the database. Since you need to include the `Date`
    column in your dataset, you remove it from the index with the DataFrame’s `reset_index()`
    method, thus turning `Date` into a regular column ❹. You then take only the `Date`
    and `Close` columns from the retrieved DataFrame, where `Close` contains stock
    prices at the end of the day, and convert them to a NumPy record array, an intermediate
    step in the process of converting the input data ❺. Next, you convert the data
    to a list of tuples ❻. After that, you still need to reformat each tuple so that
    it can be inserted into the `stocks` database table as a row. In particular, each
    `Date` field contains a lot of extraneous information (hours, minutes, seconds,
    and so on). By taking only the first 10 characters of field 0 in each tuple, you
    extract just the year, month, and day, which is all that you need for your analysis
    ❼. For example, `2022-01-06T00:00:00.000000000` would become simply `2022-01-06`.
    Finally, still within the loop, you append the tuples related to the ticker to
    the `data` list ❽.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`history()` 方法将股票数据返回为 pandas DataFrame，并以 `Date` 列作为索引。最终，你需要将该 DataFrame
    转换为元组列表，以便插入数据库。由于需要将 `Date` 列包含在数据集中，你可以通过 DataFrame 的 `reset_index()` 方法将其从索引中移除，从而将
    `Date` 转换为普通列❹。然后，从获取的 DataFrame 中仅提取 `Date` 和 `Close` 列，其中 `Close` 包含当天的股票收盘价，并将其转换为
    NumPy 记录数组，这是将输入数据转换的一个中间步骤❺。接下来，将数据转换为元组列表❻。之后，还需要重新格式化每个元组，以便将其作为一行插入到 `stocks`
    数据库表中。特别地，每个 `Date` 字段包含大量多余信息（小时、分钟、秒等）。通过提取每个元组中第一个字段的前 10 个字符，你仅保留年、月和日，这是你分析所需的全部信息❼。例如，`2022-01-06T00:00:00.000000000`
    将变为 `2022-01-06`。最后，仍在循环内，将与股票代码相关的元组追加到 `data` 列表中❽。'
- en: 'As a result, the content of the `data` list of tuples might look as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`data` 元组列表的内容可能如下所示：
- en: '[PRE23]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To insert this dataset into the `stocks` table as a set of rows, append the
    following code to the previous script and re-execute it:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 若要将此数据集作为一组行插入 `stocks` 表，请将以下代码附加到之前的脚本并重新执行：
- en: '[PRE24]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The code follows the same model you used earlier to insert data into the database.
    This time, however, you use the `cursor.executemany()` method, which allows you
    to efficiently execute the `INSERT` statement multiple times, for each tuple in
    the `data` list of tuples ❶.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码遵循你之前用于将数据插入数据库的相同模型。不过，这次你使用 `cursor.executemany()` 方法，它允许你高效地多次执行 `INSERT`
    语句，每次执行时使用 `data` 元组列表中的一个元组❶。
- en: 'Now that you have the data in the database, you can play with queries against
    it using analytical SQL, trying to answer questions. For example, to filter out
    stocks that have dropped more than 1 percent below the previous day’s price, as
    suggested at the beginning of this section, you’ll need a query that can analyze
    prices for the same ticker across multiple days. As a first step, the following
    query generates a dataset that includes both the current stock price and its price
    for the previous day within the same row. Try it out at the `mysql>` prompt:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经将数据存入数据库，可以使用分析 SQL 查询来进行操作，尝试回答问题。例如，为了筛选出股价比前一天低于 1% 的股票，如本节开始时所建议的，你需要一个能够分析同一股票在多天内股价的查询。作为第一步，以下查询生成一个数据集，其中包含当前股价和前一天的股价，并将它们放在同一行中。在
    `mysql>` 提示符下试试这个查询：
- en: '[PRE25]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `LAG()` function in the `SELECT` list is an analytical SQL function. It
    lets you access a previous row’s data from the current row. The `PARTITION BY`
    clause within the `OVER` clause divides the dataset into groups, one for each
    ticker. The `LAG()` function is applied separately within each group, ensuring
    data won’t bleed over from one ticker to the next. The result generated by the
    query will look something like this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`SELECT`列表中的`LAG()`函数是一个分析SQL函数。它让你从当前行访问上一行的数据。`OVER`子句中的`PARTITION BY`子句将数据集分成多个组，每个组对应一个ticker。`LAG()`函数在每个组内单独应用，确保数据不会从一个ticker传递到另一个ticker。查询生成的结果看起来大概是这样的：'
- en: '[PRE26]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The query generated a new column, `prev_price`, containing the previous day’s
    stock prices. As you can see, `LAG()` essentially gives you access to two rows’
    worth of data in the same row, meaning you can manipulate data from both rows
    within the same math expression as part of a query. For example, you can divide
    one price by the other to calculate the percent change from day to day. With this
    in mind, here’s a query to address the original requirement, selecting the rows
    of only those tickers whose prices didn’t drop more than 1 percent below the previous
    day’s price over the specified period:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 查询生成了一个新的列`prev_price`，包含前一天的股票价格。如你所见，`LAG()`基本上让你在同一行中访问两行数据，这意味着你可以在同一个数学表达式中操作这两行数据作为查询的一部分。例如，你可以将一个价格除以另一个价格来计算每日的百分比变化。考虑到这一点，下面是一个查询，满足最初的要求，仅选择那些价格在指定期间内没有跌幅超过1%的代码的行：
- en: '[PRE27]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The SQL statement is a join between two different queries issued against the
    same table: `stocks`. The first query of the join retrieves all the rows from
    the `stocks` table ❶, while the second query retrieves only the names of those
    tickers whose prices dropped 1 percent or more below their previous day’s price
    at least once over the period of analysis ❷. This second query of the join has
    a complex structure: it selects data from a subquery rather than from the `stocks`
    table directly. The subquery, which starts at ❸, retrieves those rows from the
    table whose values in the `price` field are at least 1 percent lower than in the
    previous row. You determine this by dividing `price` by `LAG(price)` ❹ and checking
    if the result is less than `0.99` ❺. Then, in the `SELECT` list of the main query,
    you apply the `DISTINCT()` function to the `ticker` field to eliminate duplicate
    ticker names from the result set ❷.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这个SQL语句是对同一表`stocks`发出的两个不同查询的连接。连接的第一个查询检索了`stocks`表的所有行❶，而第二个查询仅检索了那些价格至少下降了1%或更多的代码，这种下降发生在分析期的至少一天❷。这个连接的第二个查询结构较为复杂：它从子查询中选择数据，而不是直接从`stocks`表中选择。该子查询从❸开始，检索那些在`price`字段中的值比前一行低至少1%的行。你通过将`price`除以`LAG(price)`❹并检查结果是否小于`0.99`❺来确定这一点。然后，在主查询的`SELECT`列表中，你对`ticker`字段应用`DISTINCT()`函数，以去除结果集中重复的代码名❷。
- en: You join the queries on the `ticker` column ❻. In the `WHERE` clause, you instruct
    the join to retrieve only the rows where no correspondence is found between the
    `a.ticker` field (tickers whose price dropped more than 1 percent) and the `s.ticker`
    field (all the tickers) ❼. Since you have a left join, only the matching rows
    from the first query are retrieved. As a result, the join returns all the rows
    of the `stocks` table with a ticker not found among the tickers retrieved by the
    second query.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你在`ticker`列上连接了查询❻。在`WHERE`子句中，你指示连接只检索那些`a.ticker`字段（价格跌幅超过1%的代码）和`s.ticker`字段（所有代码）之间没有对应关系的行❼。由于使用了左连接，只有来自第一个查询的匹配行会被检索。结果是，连接返回了所有`tickers`不在第二个查询返回的代码中的`stocks`表行。
- en: 'Given the stock data shown previously, the result set generated by the query
    is as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面展示的股票数据，查询生成的结果集如下：
- en: '[PRE28]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'As you can see, not all the rows from the `stocks` table have been retrieved.
    In particular, you won’t find the rows related to the FB and TSLA tickers. The
    latter, for example, was excluded due to the following row found in the output
    generated by the previous query:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，并非所有来自`stocks`表的行都已被检索。特别是，你不会找到与FB和TSLA代码相关的行。例如，后者被排除是因为在之前查询生成的输出中发现了以下这一行：
- en: '[PRE29]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This row shows a 3.54 percent drop, which exceeds the 1 percent threshold.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 该行显示了3.54%的跌幅，超出了1%的阈值。
- en: 'In the following script, you issue the same query from within Python code and
    fetch the results into a pandas DataFrame:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下脚本中，你在 Python 代码中发出相同的查询，并将结果提取到一个 pandas DataFrame 中：
- en: '[PRE30]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The script looks mostly like the ones shown earlier in the chapter. The key
    difference is that you load the database data directly into a pandas DataFrame.
    For that, you use the pandas `read_sql()` method, which takes a SQL query as a
    string as the first parameter and a database connection object as the second ❶.
    Then, you set the `ticker` and `date` columns as the DataFrame index ❷.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本与本章前面展示的那些大体相似，主要区别是你直接将数据库数据加载到 pandas DataFrame 中。为此，你使用 pandas 的 `read_sql()`
    方法，该方法的第一个参数是 SQL 查询语句（作为字符串），第二个参数是数据库连接对象 ❶。然后，你将 `ticker` 和 `date` 列设置为 DataFrame
    的索引 ❷。
- en: 'Given the stock data shown previously, the resulting `df_stocks` DataFrame
    will look as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 给定之前展示的股票数据，生成的 `df_stocks` DataFrame 将如下所示：
- en: '[PRE31]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now that you have the data in a DataFrame, you can proceed with further analysis
    within Python. For example, you might want to calculate the average price of each
    ticker over a defined period. In the next chapter, you’ll see how you can solve
    such problems, applying an appropriate aggregate function at a group level in
    a DataFrame.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经将数据加载到 DataFrame 中，可以在 Python 中继续进行进一步分析。例如，你可能想计算每个股票符号在一定时间段内的平均价格。在下一章中，你将看到如何通过在
    DataFrame 中按组级别应用适当的聚合函数来解决这类问题。
- en: NoSQL Databases
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NoSQL 数据库
- en: '*NoSQL databases*, or *nonrelational databases*, don’t require a predetermined
    organizational schema for the data being stored, and they don’t support standard
    relational database operations like joins. Instead, they provide ways to store
    data with more structural flexibility, making it easier to handle massive volumes
    of data. For example, key-value stores, one type of NoSQL database, let you store
    and retrieve data as key-value pairs, such as time-event pairs. Document-oriented
    databases, another type of NoSQL database, are designed to work with flexibly
    structured data containers such as JSON documents. This allows you to store all
    the information related to a given object as a single entry in the database rather
    than splitting information across multiple tables, as is common in relational
    databases.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*NoSQL 数据库*，或称 *非关系型数据库*，不要求存储数据时有预先定义的组织架构，也不支持像连接（joins）这样的标准关系型数据库操作。相反，它们提供了更加灵活的结构化数据存储方式，使得处理大量数据变得更加容易。例如，一种类型的
    NoSQL 数据库是键值存储（key-value store），它允许你将数据存储为键值对，例如时间-事件对。另一种类型的 NoSQL 数据库是面向文档的数据库，它们被设计为处理灵活结构的数据容器，如
    JSON 文档。这使得你可以将与特定对象相关的所有信息作为数据库中的一个条目进行存储，而不是像关系型数据库中那样将信息拆分到多个表中。'
- en: Although NoSQL databases haven’t been around as long as their relational counterparts,
    they’ve quickly become popular because they allow developers to store data in
    simple, straightforward formats and don’t require advanced expertise to access
    and manipulate the data. Their flexibility makes them particularly well suited
    to real-time and big data applications such as Google Gmail or LinkedIn.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 NoSQL 数据库的出现时间不如关系型数据库那样久远，但由于它们允许开发人员以简单直观的格式存储数据，并且无需高级技术就能访问和操作数据，因此它们迅速获得了普及。它们的灵活性使其特别适用于实时和大数据应用，例如
    Google Gmail 或 LinkedIn。
- en: Key-Value Stores
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 键值存储
- en: 'A *key-value store* is a database that holds key-value pairs, similar to a
    Python dictionary. A good example of a key-value store is Redis, which stands
    for Remote Dictionary Service. Redis supports commands such as `GET`, `SET`, and
    `DEL` to access and manipulate key-value pairs, as illustrated in this simple
    example:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*键值存储* 是一种持有键值对的数据库，类似于 Python 字典。一个典型的键值存储示例是 Redis，它代表远程字典服务（Remote Dictionary
    Service）。Redis 支持诸如 `GET`、`SET` 和 `DEL` 等命令，用于访问和操作键值对，以下是一个简单的示例：'
- en: '[PRE32]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, you use the `SET` command to create the key `emp1` with the value `Maya
    Silver`, then you use `GET` to retrieve the value via its key.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你使用 `SET` 命令创建键 `emp1`，并为其赋值 `Maya Silver`，然后使用 `GET` 命令通过键获取值。
- en: Setting Up Redis
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置 Redis
- en: 'To explore Redis yourself, you’ll need to install it. You can find details
    on the Redis Quick Start page at [https://redis.io/topics/quickstart](https://redis.io/topics/quickstart).
    After installing the Redis server in your system, you’ll also need to install
    redis-py, the Python library that lets you interact with Redis from your Python
    code. You can do this with the `pip` command:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要自行探索Redis，你需要安装它。你可以在[https://redis.io/topics/quickstart](https://redis.io/topics/quickstart)上找到Redis快速入门页面的详细信息。安装完Redis服务器后，你还需要安装redis-py，这是一个让你能够通过Python代码与Redis交互的Python库。你可以使用`pip`命令来完成安装：
- en: '[PRE33]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You then import redis-py into your script with the command `import redis`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以通过命令`import redis`将redis-py导入到你的脚本中。
- en: Accessing Redis with Python
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用Python访问Redis
- en: 'The following is a simple example of accessing the Redis server from Python
    via the redis-py library:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个通过redis-py库从Python访问Redis服务器的简单示例：
- en: '[PRE34]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You use the `redis.Redis()` method to set a connection to the Redis server
    ❶. Since the method’s parameters are omitted, the default values will be taken,
    which assume the server is running on your local machine: `host=''localhost''`,
    `port=6379`, and `db=0`.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用`redis.Redis()`方法建立与Redis服务器的连接 ❶。由于方法的参数被省略，默认值将被采用，这假设服务器运行在你的本地机器上：`host='localhost'`，`port=6379`，以及`db=0`。
- en: After establishing a connection, you use the `mset()` method to set multiple
    key-value pairs ❷ (*m* is short for *multiple*). The server returns `True` when
    data has been stored successfully. You can then get the value of any of your stored
    keys with the `get()` method ❸.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在建立连接后，你使用`mset()`方法设置多个键值对 ❷（*m*代表*multiple*）。当数据成功存储时，服务器返回`True`。然后，你可以使用`get()`方法获取任何已存储键的值
    ❸。
- en: 'Like any other database, Redis allows you to persist the data being inserted,
    so you’ll be able to get a value by its key in another Python session or script.
    Redis also allows you to set an *expire flag* on a key when you set a key-value
    pair, specifying how long it should be retained. This can be especially useful
    in real-time applications where input data becomes irrelevant after a certain
    period of time. For example, if your application was for a taxi service, you might
    want to store data about the availability of each individual cab. Since this data
    would be subject to change often, you’d want it to expire after a short time.
    Here’s how this might work:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 像任何其他数据库一样，Redis允许你持久化插入的数据，这样你就可以在另一个Python会话或脚本中通过键来获取值。Redis还允许你在设置键值对时为键设置*过期标志*，指定它应该保留多长时间。这在实时应用程序中尤为有用，因为输入数据在一定时间后会变得无关紧要。例如，如果你的应用程序是一个出租车服务，你可能想要存储每辆出租车的可用性数据。由于这些数据会经常变化，你可能希望它们在短时间后过期。以下是这种情况的示例：
- en: '[PRE35]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: You use the `setex()` method to set a key-value pair that will be automatically
    removed from the database after a specified period of time. Here, you specify
    the expiration time as a `timedelta` object. Alternatively, you could specify
    it as a number in seconds.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用`setex()`方法设置一个键值对，该键值对将在指定的时间后自动从数据库中删除。在这里，你将过期时间指定为一个`timedelta`对象。或者，你可以将其指定为秒数。
- en: 'So far we’ve only looked at simple key-value pairs, but you can also store
    multiple pieces of information about the same object using Redis, as illustrated
    here:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只讨论了简单的键值对，但你还可以使用Redis存储与同一对象相关的多个信息，正如下例所示：
- en: '[PRE36]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: You start by defining a Python dictionary that can contain an arbitrary number
    of key-value pairs. Then, you send the entire dictionary to the database, storing
    it under the key `cab48` using `hmset()` (*h* is short for *hash*). You then use
    the `hgetall()` function to retrieve all the key-value pairs stored under the
    `cab48` key.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先定义一个Python字典，可以包含任意数量的键值对。然后，你将整个字典发送到数据库，并通过`hmset()`将其存储在`cab48`键下（*h*代表*hash*）。接着，你使用`hgetall()`函数来检索存储在`cab48`键下的所有键值对。
- en: Document-Oriented Databases
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文档导向数据库
- en: A *document-oriented database* stores each record as a separate document. Rather
    than having to conform to a predefined schema, like the fields of a relational
    database table, each document in a document-oriented database can have its own
    structure. This flexibility makes document-oriented databases the most popular
    category of NoSQL databases, and among document-oriented databases, MongoDB is
    arguably the leader. MongoDB is designed to manage collections of JSON-like documents.
    We’ll explore how to work with MongoDB in this section.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*文档导向数据库* 将每条记录存储为一个单独的文档。与关系型数据库表的字段必须遵循预定义的模式不同，文档导向数据库中的每个文档可以具有自己的结构。这种灵活性使得文档导向数据库成为最受欢迎的
    NoSQL 数据库类型，而在文档导向数据库中，MongoDB 无疑是领先者。MongoDB 旨在管理 JSON 类文档的集合。在本节中，我们将探讨如何使用
    MongoDB。'
- en: Setting Up MongoDB
  id: totrans-133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置 MongoDB
- en: There are several ways you can try out MongoDB. One is to install the MongoDB
    database on your system. For details, refer to the MongoDB documentation at [https://docs.mongodb.com/manual/installation](https://docs.mongodb.com/manual/installation).
    Another option that requires no installation overhead is to create a free hosted
    MongoDB database using MongoDB Atlas. You’ll need to register at [https://www.mongodb.com/cloud/atlas/register](https://www.mongodb.com/cloud/atlas/register).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以尝试使用 MongoDB 的几种方式。其中一种是将 MongoDB 数据库安装到你的系统上。详情请参考 MongoDB 文档：[https://docs.mongodb.com/manual/installation](https://docs.mongodb.com/manual/installation)。另一种无需安装的方式是使用
    MongoDB Atlas 创建一个免费的托管 MongoDB 数据库。你需要在 [https://www.mongodb.com/cloud/atlas/register](https://www.mongodb.com/cloud/atlas/register)
    注册账号。
- en: 'Before you can start interacting with a MongoDB database from Python, you’ll
    need to install PyMongo, the official Python driver for MongoDB. This can be done
    with the `pip` command:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始从 Python 与 MongoDB 数据库交互之前，你需要安装 PyMongo，这是 MongoDB 的官方 Python 驱动程序。你可以使用
    `pip` 命令来安装：
- en: '[PRE37]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Accessing MongoDB with Python
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 Python 访问 MongoDB
- en: 'The first step to working with MongoDB using Python is to establish a connection
    to the database server via a PyMongo `MongoClient` object, as shown here:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Python 操作 MongoDB 的第一步是通过 PyMongo 的 `MongoClient` 对象建立与数据库服务器的连接，如下所示：
- en: '[PRE38]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The connection string can be a MongoDB connection URI, such as *mongodb://localhost:27017*.
    This connection string assumes you have installed MongoDB on your local system.
    If you’re using MongoDB Atlas instead, you’ll need to use a connection string
    provided by Atlas. For further details, refer to the “Connect via Driver” page
    in the Atlas documentation at [https://docs.atlas.mongodb.com/driver-connection](https://docs.atlas.mongodb.com/driver-connection).
    You might also want to check out the “Connection String URI Format” page of the
    MongoDB documentation at [https://docs.mongodb.com/manual/reference/connection-string](https://docs.mongodb.com/manual/reference/connection-string).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 连接字符串可以是 MongoDB 连接 URI，例如 *mongodb://localhost:27017*。这个连接字符串假设你已在本地系统上安装了
    MongoDB。如果你使用的是 MongoDB Atlas，你需要使用 Atlas 提供的连接字符串。有关详细信息，请参考 Atlas 文档中的“通过驱动程序连接”页面：[https://docs.atlas.mongodb.com/driver-connection](https://docs.atlas.mongodb.com/driver-connection)。你还可以查看
    MongoDB 文档中的“连接字符串 URI 格式”页面：[https://docs.mongodb.com/manual/reference/connection-string](https://docs.mongodb.com/manual/reference/connection-string)。
- en: 'Instead of using a connection string, you might specify the host and port as
    separate parameters of the `MongoClient()` constructor:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用连接字符串外，你还可以将主机和端口作为 `MongoClient()` 构造函数的单独参数来指定：
- en: '[PRE39]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'A single MongoDB instance can support multiple databases, so once a connection
    to the server is established, you need to specify the database you want to work
    with. MongoDB doesn’t provide a separate command to create a database, so you
    use the same syntax for creating a new database and accessing an existing one.
    For example, to create a database named `sampledb` (or access it if it already
    exists), you can use the following dictionary-like syntax:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 MongoDB 实例可以支持多个数据库，因此一旦与服务器建立连接，你需要指定要操作的数据库。MongoDB 并未提供单独的命令来创建数据库，因此你使用相同的语法来创建新数据库或访问现有数据库。例如，要创建一个名为
    `sampledb` 的数据库（如果已存在，则访问它），你可以使用以下类似字典的语法：
- en: '[PRE40]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'or use the attribute-access syntax:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 或者使用属性访问语法：
- en: '[PRE41]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Unlike relational databases, MongoDB doesn’t store data in tables. Instead,
    documents are grouped into *collections*. Creating or accessing a collection is
    similar to creating or accessing a database:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 与关系型数据库不同，MongoDB 不将数据存储在表格中。相反，文档被分组到 *集合* 中。创建或访问集合类似于创建或访问数据库：
- en: '[PRE42]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This command will create the `emps` collection in the `sampledb` database,
    if it has not already been created. Then, you can use the `insert_one()` method
    to insert a document into the collection. In this example, you insert an `emp`
    document formatted as a dictionary:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将在 `sampledb` 数据库中创建 `emps` 集合，如果该集合尚未创建。然后，你可以使用 `insert_one()` 方法将文档插入该集合。在这个例子中，你将插入一个格式为字典的
    `emp` 文档：
- en: '[PRE43]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Upon insertion of the document, an `"_id"` field is automatically added to
    it. The value of this field is generated to be unique across the collection. You
    can access the ID via the `inserted_id` field of the object returned by `insert_one()`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在文档插入后，会自动为其添加一个 `"_id"` 字段。该字段的值在集合中是唯一的。你可以通过 `insert_one()` 返回的对象的 `inserted_id`
    字段访问该 ID：
- en: '[PRE44]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now that you have some data in the database, how can you query it? The most
    common type of query can be performed with `find_one()`, which returns a single
    document that matches the search criteria:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经在数据库中插入了一些数据，如何查询它呢？最常见的查询类型是使用 `find_one()`，它返回一个与搜索条件匹配的单一文档：
- en: '[PRE45]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: As you can see, `find_one()` doesn’t require you to use the document’s ID, which
    was automatically added on insert. Instead, you can query on specific elements,
    assuming that the resulting document matches them.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`find_one()` 不需要使用文档的 ID，该 ID 在插入时会自动添加。相反，你可以查询特定的元素，只要返回的文档与之匹配。
- en: 'The result will look similar to this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将类似于以下内容：
- en: '[PRE46]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Summary
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you saw examples of moving data to and from databases of different
    types, including relational and NoSQL databases. You worked with MySQL, one of
    the most popular relational databases. Then you looked at Redis, a NoSQL solution
    that allows you to efficiently store and retrieve key-value pairs. You also explored
    MongoDB, arguably the most popular NoSQL database today, which allows you to work
    with JSON-like documents in a Python-friendly manner.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你看到了将数据从不同类型的数据库（包括关系型数据库和 NoSQL 数据库）进行迁移的示例。你使用了 MySQL，这是最受欢迎的关系型数据库之一。接着，你了解了
    Redis，一种 NoSQL 解决方案，它允许你高效地存储和检索键值对。你还探讨了 MongoDB，可以说是今天最受欢迎的 NoSQL 数据库，它允许你以对
    Python 友好的方式处理类似 JSON 的文档。
