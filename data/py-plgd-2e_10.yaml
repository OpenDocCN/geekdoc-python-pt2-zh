- en: '[7](nsp-venkitachalam503045-0008.xhtml#rch07)'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[7](nsp-venkitachalam503045-0008.xhtml#rch07)'
- en: Photomosaics
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 照片马赛克
- en: '![](images/nsp-venkitachalam503045-circle-image.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-circle-image.jpg)'
- en: When I was in the sixth grade, I saw a picture like the one shown in [Figure
    7-1](nsp-venkitachalam503045-0020.xhtml#fig7-1) but couldn’t quite figure out
    what it was. After squinting at it for a while, I eventually figured it out. (Turn
    the book upside down, and view it from across the room. I won’t tell anyone.)
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当我上六年级时，我看到了一张类似于[图 7-1](nsp-venkitachalam503045-0020.xhtml#fig7-1)中的图片，但当时并没完全搞懂那是什么。盯着它看了一会儿后，我终于弄明白了。（把书倒过来，从房间对面看。这个秘密我不告诉别人。）
- en: The puzzle works because of how the human eye functions. The low-resolution,
    blocky image shown in the figure is hard to recognize up close, but when it is
    seen from a distance, you know what it represents because your eyes perceive less
    detail, which makes the edges smooth.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这个谜题的巧妙之处在于人眼的工作方式。图中的低分辨率、块状图像在近距离下很难识别，但当从远处看时，你就能知道它代表什么，因为眼睛看到的细节更少，这让边缘变得平滑。
- en: 'A *photomosaic* is an image that works according to a similar principle. You
    take a *target* image, split it into a grid of rectangles, and replace each rectangle
    with another, smaller image that matches that section of the target. When you
    look at a photomosaic from a distance, all you see is the target image, but if
    you come closer, the secret is revealed: the image actually consists of many tiny
    images!'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*照片马赛克* 是根据类似的原理制作的图像。你将一个 *目标* 图像拆分成一个矩形网格，然后用另一个匹配目标图像部分的较小图像替换每个矩形。当你从远处看照片马赛克时，你看到的只是目标图像，但如果你走近一点，真相就揭晓了：这幅图像实际上是由许多小图像组成的！'
- en: '![](images/nsp-venkitachalam503045-f07001.jpg)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f07001.jpg)'
- en: 'Figure 7-1: A puzzling image'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-1：一张让人困惑的图片
- en: In this project, you’ll create a photomosaic using Python. You’ll divide a target
    image into a grid and replace each block in the grid with a suitable image to
    create a photomosaic of the original. You’ll be able to specify the grid dimensions
    and choose whether input images can be reused in the mosaic.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将使用 Python 创建一个照片马赛克。你将把目标图像划分成一个网格，并用合适的图像替换网格中的每一个小块，从而创建出原图的照片马赛克。你可以指定网格的尺寸，并选择是否在马赛克中重复使用输入图像。
- en: 'As you work on the project, you’ll learn how to do the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将学习如何完成以下任务：
- en: • Create images using the Python Imaging Library (PIL).
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用 Python 图像库（PIL）创建图像。
- en: • Compute the average RGB value of an image.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 计算图像的平均 RGB 值。
- en: • Crop images.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 剪裁图像。
- en: • Replace part of an image by pasting in another image.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 通过粘贴另一张图像来替换图像的一部分。
- en: • Compare RGB values using a measurement of average distance in three dimensions.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用三维的平均距离度量来比较 RGB 值。
- en: • Use a data structure called a *k-d tree* to efficiently find the image that
    best matches a section of the target image.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用一种叫做 *k-d 树* 的数据结构来高效地找到与目标图像某部分最匹配的图像。
- en: '[How It Works](nsp-venkitachalam503045-0008.xhtml#rah0901)'
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[它是如何工作的](nsp-venkitachalam503045-0008.xhtml#rah0901)'
- en: 'To create a photomosaic, begin with a blocky, low-resolution version of the
    target image (because the number of tile images would be too great in a high-resolution
    image). The user inputs the dimensions *M*×*N* (where *M* is the number of rows
    and *N* is the number of columns) of the mosaic. Next, build the mosaic according
    to this methodology:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个照片马赛克，首先使用一个块状的低分辨率版本的目标图像（因为在高分辨率图像中，瓦片图像的数量会太大）。用户输入马赛克的尺寸 *M*×*N*（其中
    *M* 是行数，*N* 是列数）。接下来，根据以下方法构建马赛克：
- en: 1\. Read the input images, which will be drawn on to replace the tiles in the
    original image.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1\. 读取输入图像，这些图像将用于替换原图中的瓦片。
- en: 2\. Read the target image and split it into an *M*×*N* grid of tiles.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2\. 读取目标图像并将其拆分成 *M*×*N* 的瓦片网格。
- en: 3\. For each tile, find the best match from the input images.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3\. 对于每个瓦片，从输入图像中找到最佳匹配。
- en: 4\. Create the final mosaic by arranging the selected input images in an *M*×*N*
    grid.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 4\. 通过将选定的输入图像排列成 *M*×*N* 网格来创建最终的马赛克。
- en: '[Splitting the Target Image](nsp-venkitachalam503045-0008.xhtml#rbh0901)'
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[拆分目标图像](nsp-venkitachalam503045-0008.xhtml#rbh0901)'
- en: We’ll start by looking at how to split the target image into an *M*×*N* grid
    of tiles. Follow the scheme shown in [Figure 7-2](nsp-venkitachalam503045-0020.xhtml#fig7-2).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从如何将目标图像拆分成 *M*×*N* 的瓦片网格开始。请参照[图 7-2](nsp-venkitachalam503045-0020.xhtml#fig7-2)中的方案。
- en: '![](images/nsp-venkitachalam503045-f07002.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f07002.jpg)'
- en: 'Figure 7-2: Splitting the target image'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-2：拆分目标图像
- en: We split the original image into a grid of tiles with *N* columns arranged along
    the x-axis and *M* rows arranged along the y-axis. Each tile is represented by
    an index (*i*, *j*) and is *w* pixels wide and *h* pixels high. According to this
    scheme, the original image is *w* × *N* pixels wide and *h* × *M* pixels high.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将原始图像划分为一个由*N*列和*M*行组成的瓦片网格，列沿x轴排列，行沿y轴排列。每个瓦片由一个索引(*i*, *j*)表示，宽度为*w*像素，高度为*h*像素。根据这个方案，原始图像的宽度为*w*
    × *N*像素，高度为*h* × *M*像素。
- en: The right side of [Figure 7-2](nsp-venkitachalam503045-0020.xhtml#fig7-2) shows
    how to calculate the pixel coordinates for a single tile from this grid. The tile
    with index (*i*, *j*) has a top-left corner coordinate of (*i* × *w, i* × *j*)
    and a bottom-right corner coordinate of ((*i* + 1) × *w*, (*j* + 1) × *h*). These
    coordinates can be used with the PIL to crop and create tiles from the original
    image.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '[图7-2](nsp-venkitachalam503045-0020.xhtml#fig7-2)的右侧展示了如何计算从此网格中单个瓦片的像素坐标。索引为(*i*,
    *j*)的瓦片，其左上角坐标为(*i* × *w, i* × *j*)，右下角坐标为((*i* + 1) × *w*, (*j* + 1) × *h*)。这些坐标可以与PIL一起使用，从原始图像中裁剪并创建瓦片。'
- en: '[Averaging Color Values](nsp-venkitachalam503045-0008.xhtml#rbh0902)'
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[平均颜色值](nsp-venkitachalam503045-0008.xhtml#rbh0902)'
- en: 'Every pixel in an image has a color that can be represented numerically by
    its red, green, and blue values. In this case, you are using 8-bit images, so
    each of these three color components has an 8-bit value in the range [0, 255].
    You can therefore determine the average color of an image by taking the average
    of the red, green, and blue values for all of the image’s pixels. Given an image
    with a total of *N* pixels, the average RGB is calculated as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图像中的每个像素都有一个颜色，可以通过其红、绿、蓝值来数值表示。在这种情况下，你使用的是8位图像，因此每个颜色分量的8位值在[0, 255]范围内。因此，你可以通过计算图像所有像素的红、绿、蓝值的平均值来确定图像的平均颜色。给定一幅包含总共*N*个像素的图像，平均RGB的计算方法如下：
- en: '![](images/nsp-venkitachalam503045-m07001.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-m07001.jpg)'
- en: Like the RGB for an individual pixel, the average RGB for a whole image is a
    triplet, not a scalar or single number, because the averages are calculated separately
    for each color component. You calculate the average RGB to match the tiles from
    the target image with replacements from among the input images.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 像单个像素的RGB一样，整幅图像的平均RGB是一个三元组，而不是一个标量或单一数值，因为平均值是分别对每个颜色分量计算的。你计算平均RGB值来将目标图像的瓦片与输入图像中的替代图像进行匹配。
- en: '[Matching Images](nsp-venkitachalam503045-0008.xhtml#rbh0903)'
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[匹配图像](nsp-venkitachalam503045-0008.xhtml#rbh0903)'
- en: For each tile in the target image, you need to find a matching image from the
    images in the input folder specified by the user. To determine whether two images
    match, use the average RGB values. The best match is the input image with the
    average RGB value closest to that of the tile from the target image.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 对于目标图像中的每个瓦片，你需要从用户指定的输入文件夹中的图像中找到一个匹配的图像。为了判断两幅图像是否匹配，使用平均RGB值。最佳匹配是输入图像，其平均RGB值最接近目标图像瓦片的平均RGB值。
- en: 'The simplest way to find the best match is to calculate the distance between
    the average RGB values as if they were points in 3D space. After all, each average
    RGB consists of three numbers, which you can think of as x-, y-, and z-axis coordinates.
    You can thus use the following formula from the geometry for calculating the distance
    between two 3D points:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的找到最佳匹配的方法是计算平均RGB值之间的距离，就像它们是3D空间中的点一样。毕竟，每个平均RGB由三个数字组成，你可以将其视为x轴、y轴和z轴坐标。因此，你可以使用几何学中的以下公式来计算两个3D点之间的距离：
- en: '![](images/nsp-venkitachalam503045-m07002.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-m07002.jpg)'
- en: Here you compute the distance between the points (*r*[1], *g*[1], *b*[1]) and
    (*r*[2], *g*[2], *b*[2]). Given a target average RGB value (*r*[1], *g*[1], *b*[1]),
    you can plug a list of average RGB values from the input images into the previous
    formula as (*r*[2], *g*[2], *b*[2]) to find the closest matching image. However,
    there might be hundreds or even thousands of input images to check. We should
    therefore give some thought to how to efficiently search the set of input images
    to find the best match.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你计算点(*r*[1], *g*[1], *b*[1])和(*r*[2], *g*[2], *b*[2])之间的距离。给定一个目标平均RGB值(*r*[1],
    *g*[1], *b*[1])，你可以将输入图像中的平均RGB值列表代入先前的公式，作为(*r*[2], *g*[2], *b*[2])来找到最接近的匹配图像。然而，可能有成百上千张输入图像需要检查。因此，我们应该考虑如何高效地搜索输入图像集以找到最佳匹配。
- en: Using Linear Search
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用线性搜索
- en: 'The simplest approach to searching for a match is a *linear search*. In this
    method, you just iterate through all the RGB values one by one and find the one
    with the minimum distance to the query value. The code will look something like
    this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索匹配项的最简单方法是 *线性搜索*。在这种方法中，你只需逐个遍历所有 RGB 值，并找到与查询值之间最小距离的那个值。代码看起来大致如下：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You go through each value in the list `vals` one by one and calculate the distance
    between that value and `query`. If the result is less than `min_dist` (which was
    initialized as the maximum possible distance between two points), you update `min_dist`
    with the distance you just calculated. After checking every item in `vals`, `min_dist`
    will contain the smallest distance in the whole dataset.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你依次遍历列表中的每个值 `vals`，并计算该值与 `query` 之间的距离。如果结果小于 `min_dist`（它初始化为两个点之间的最大可能距离），你就用刚刚计算的距离更新
    `min_dist`。检查完 `vals` 中的每一项后，`min_dist` 将包含整个数据集中最小的距离。
- en: Although a linear search method is easy to understand and implement, it isn’t
    very efficient. If there are *N* values in the `vals` list, the search will take
    an amount of time proportional to *N*. You can achieve much better performance
    with a different data structure and search algorithm.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然线性搜索方法易于理解和实现，但它并不是非常高效。如果 `vals` 列表中有 *N* 个值，搜索将需要与 *N* 成正比的时间。你可以通过使用不同的数据结构和搜索算法来获得更好的性能。
- en: Using k-d Trees
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 k-d 树
- en: 'A *k-d tree*, or *k-dimensional tree*, is a data structure that partitions
    a space of *k* dimensions—that is, it divides the space into a number of non-overlapping
    subspaces. This data structure provides a way to sort and search through datasets
    whose members are points in *k*-dimensional space. The dataset is represented
    as a *binary tree*: each point in the dataset becomes a node in the tree, and
    each node can have two child nodes. In other words, each node in the tree divides
    the space into two parts, called *subtrees*. One part points to the left of the
    node (the node’s left child and its descendants), and the other points to the
    right of the node (the node’s right child and its descendants).'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*k-d 树*，或者叫做 *k 维树*，是一种数据结构，它将 *k* 维空间划分——也就是说，它将空间划分成多个不重叠的子空间。这个数据结构提供了一种方法，用于对数据集进行排序和搜索，数据集中的每个成员都是
    *k* 维空间中的一个点。数据集被表示为一个 *二叉树*：数据集中的每个点都是树中的一个节点，每个节点可以有两个子节点。换句话说，树中的每个节点将空间划分成两部分，称为
    *子树*。一部分指向节点的左侧（节点的左子节点及其后代），另一部分指向节点的右侧（节点的右子节点及其后代）。'
- en: Each node of the tree is associated with one of the dimensions of the space,
    and that’s the dimension used to determine if points belong in the node’s left
    subtree or right subtree. If a node is associated with the x-axis, for example,
    points whose x-values are less than that node’s x-value will be put in the node’s
    left subtree, and points whose x-values are greater than the node’s x-value will
    be put in the right subtree. A common method to select the dimension associated
    with each node is to cycle through them as you move down the levels of the tree.
    For example, in the case of a three-dimensional k-d tree, you could set the dimensions
    to be x, y, z, x, y, z, and so on, moving down the tree. Nodes at the same tree
    height will have the same splitting dimension.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 树的每个节点都与空间的一个维度相关联，这个维度用于决定点是属于节点的左子树还是右子树。例如，如果一个节点与 x 轴相关联，那么 x 值小于该节点的 x
    值的点将放入该节点的左子树，而 x 值大于该节点的 x 值的点将放入右子树。选择每个节点关联的维度的常见方法是，在向下遍历树的过程中按顺序循环这些维度。例如，在三维
    k-d 树的情况下，你可以设置维度为 x、y、z、x、y、z，依此类推，随着树的深入。位于相同树高度的节点将具有相同的划分维度。
- en: 'Let’s look at a simple example of a k-d tree. Say you have the following set
    of points, *P*:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个简单的 k-d 树的例子。假设你有以下点集，*P*：
- en: '*P* = {(5, 3), (2, 4), (1, 2), (6, 6), (7, 2), (4, 6), (2, 8)}'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*P* = {(5, 3), (2, 4), (1, 2), (6, 6), (7, 2), (4, 6), (2, 8)}'
- en: In this case, you’d build a two-dimensional k-d tree, since each member of *P*
    describes a point in two-dimensional space. You start by associating the first
    node, or the *root* node, (5, 3), with the x-dimension. Then you add the next
    point, (2, 4), as a left child of the root node, since the point’s x-coordinate,
    2, is less than 5, the x-coordinate of the root. The node (2, 4), being on the
    second level of the k-d tree, will use the y-dimension for partition. The next
    point in the list is (1, 2). Starting again at the root, 1 < 5, so you go to the
    left child of the root node. You then compare (1, 2) with (2, 4) using the y-dimension.
    Since 2 < 4, you add (1, 2) as the left child of (2, 4).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你将构建一个二维的 k-d 树，因为 *P* 中的每个成员都描述了二维空间中的一个点。首先将第一个节点，或者称为 *根* 节点（5, 3），与
    x 维度关联。然后将下一个点（2, 4）作为根节点的左子节点，因为该点的 x 坐标 2 小于根节点的 x 坐标 5。节点（2, 4）位于 k-d 树的第二层，将使用
    y 维度进行划分。接下来列表中的点是（1, 2）。从根节点开始，1 < 5，因此你转到根节点的左子节点。然后使用 y 维度比较（1, 2）和（2, 4）。由于
    2 < 4，你将（1, 2）作为（2, 4）的左子节点。
- en: If you continue in this fashion for all the points in *P*, you’ll create the
    tree and space partitioning shown in [Figure 7-3](nsp-venkitachalam503045-0020.xhtml#fig7-3).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你按照这种方式处理 *P* 中的所有点，你将创建[图7-3](nsp-venkitachalam503045-0020.xhtml#fig7-3)中所示的树和空间划分。
- en: '![](images/nsp-venkitachalam503045-f07003.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f07003.jpg)'
- en: 'Figure 7-3: An example of a k-d tree'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图7-3：k-d 树的示例
- en: The top image of [Figure 7-3](nsp-venkitachalam503045-0020.xhtml#fig7-3) shows
    the space partitioning scheme for the tree we just discussed. Starting with point
    (5, 3), you split the space in two along the x-dimension by drawing a vertical
    line through that point. Next, you use point (2, 4) to split the left half of
    the first partition along the y-dimension by drawing a horizontal line through
    the point, stopping when the line hits the vertical line. Continue in this fashion
    with the remaining points, and you’ll get the partitioning scheme shown in the
    figure.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[图7-3](nsp-venkitachalam503045-0020.xhtml#fig7-3)的顶部图像展示了我们刚才讨论的树的空间划分方案。从点（5,
    3）开始，通过在该点绘制一条垂直线，沿着 x 维度将空间分成两部分。接下来，使用点（2, 4）沿着 y 维度划分第一个分区的左半部分，在该点绘制一条水平线，直到线与垂直线相交。按照这种方式继续处理剩余的点，你将得到图中所示的划分方案。'
- en: Why should you care about k-d trees? The answer is that once you arrange a dataset
    this way, you can search through it much more quickly. Specifically, a *nearest-neighbor
    search*—finding the point closest to a queried point—is much faster with a k-d
    tree than a linear search. For a dataset of *N* values, the average nearest-neighbor
    search of a k-d tree takes a time proportional to log(*N*), much less than the
    time proportional to *N* that a linear search would take.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么你要关心 k-d 树？答案是，一旦你按照这种方式排列数据集，你可以更快地搜索它。具体来说，*最近邻搜索*——找到离查询点最近的点——使用 k-d
    树比线性搜索要快得多。对于一个包含 *N* 个值的数据集，k-d 树的平均最近邻搜索时间是与 log(*N*) 成正比的，而线性搜索的时间则与 *N* 成正比。
- en: To demonstrate, let’s try to find the point from *P* nearest to point *q*, (2,
    3), which is shown in [Figure 7-3](nsp-venkitachalam503045-0020.xhtml#fig7-3).
    Looking at the figure, you can see that point (2, 4) is the match. The nearest-neighbor
    algorithm will find the match by traversing down the tree from (5, 3) to (2, 4).
    The algorithm knows, for example, that the right subtree of the root can be skipped,
    since *q*’s x-coordinate is less than the root node’s x-coordinate. The spatial
    partitioning scheme thus lets you skip a larger number of comparisons than with
    a linear search. This is what makes the k-d tree useful for our problem.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示，我们来尝试找到离点 *q*（2, 3）最近的 *P* 中的点，该点显示在[图7-3](nsp-venkitachalam503045-0020.xhtml#fig7-3)中。从图中可以看出，点（2,
    4）是匹配点。最近邻算法通过从（5, 3）到（2, 4）遍历树来找到匹配点。算法知道，例如，根节点的右子树可以跳过，因为 *q* 的 x 坐标小于根节点的
    x 坐标。因此，空间划分方案让你跳过比线性搜索更多的比较。这就是 k-d 树对我们问题有用的原因。
- en: 'How can you use a k-d tree in the photomosaic code? You could try to write
    an implementation from scratch, but there’s an easier option: the `scipy` library
    already has a built-in k-d tree class. We’ll look at how to leverage this class
    later in the chapter.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如何在照片马赛克代码中使用 k-d 树？你可以尝试从头开始实现，但还有一个更简单的选项：`scipy` 库已经内置了一个 k-d 树类。我们将在本章后面介绍如何利用这个类。
- en: '[Requirements](nsp-venkitachalam503045-0008.xhtml#rah0902)'
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[要求](nsp-venkitachalam503045-0008.xhtml#rah0902)'
- en: For this project, you’ll use `Pillow` to read in the images, access their underlying
    data, and create and modify the images. You’ll also use `numpy` to manipulate
    image data and `scipy` to search the image data using a k-d tree.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将使用`Pillow`读取图像，访问它们的底层数据，并创建和修改图像。你还将使用`numpy`来操作图像数据，使用`scipy`通过k-d树查找图像数据。
- en: '[The Code](nsp-venkitachalam503045-0008.xhtml#rah0903)'
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[代码部分](nsp-venkitachalam503045-0008.xhtml#rah0903)'
- en: You’ll begin by reading in the input images that you’ll draw on to create the
    photomosaic. Next, you’ll compute the average RGB value of the images, split the
    target into a grid, and find the image that best matches each tile in the grid.
    Finally, you’ll assemble the image tiles to create the actual photomosaic. To
    see the complete project code, skip ahead to [“The Complete Code”](nsp-venkitachalam503045-0020.xhtml#ah0907)
    on [page 129](nsp-venkitachalam503045-0020.xhtml#p129). You can also find the
    code at [https://github.com/mkvenkit/pp2e/tree/main/photomosaic](https://github.com/mkvenkit/pp2e/tree/main/photomosaic).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你将首先读取输入图像，这些图像将用于创建照片马赛克。接下来，你将计算图像的平均RGB值，将目标图像划分为网格，并找到最匹配每个网格块的图像。最后，你将拼接图像块，生成实际的照片马赛克。要查看完整的项目代码，请跳到[“完整代码”](nsp-venkitachalam503045-0020.xhtml#ah0907)在[第129页](nsp-venkitachalam503045-0020.xhtml#p129)。你也可以在[https://github.com/mkvenkit/pp2e/tree/main/photomosaic](https://github.com/mkvenkit/pp2e/tree/main/photomosaic)找到代码。
- en: '[Reading In the Input Images](nsp-venkitachalam503045-0008.xhtml#rbh0904)'
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[读取输入图像](nsp-venkitachalam503045-0008.xhtml#rbh0904)'
- en: 'First read in the input images from a given folder. Here’s how to do that:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 首先从给定的文件夹中读取输入图像。以下是操作步骤：
- en: '[PRE1]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You first use `os.listdir()` to gather the filenames in the *imageDir* directory
    in a list called `files` ❶. Next, you iterate through each file in the list and
    load it into a PIL `Image` object.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先使用`os.listdir()`来收集*imageDir*目录中的文件名，并将其存储在一个名为`files`的列表中❶。接下来，你遍历列表中的每个文件并将其加载为一个PIL
    `Image`对象。
- en: You use `os.path.abspath()` and `os.path.join()` to get the complete filename
    of the image ❷. This idiom is commonly used in Python to ensure that your code
    will work with both relative paths (for example, *\foo\bar\*) and absolute paths
    (*c:\foo\bar\*), as well as across operating systems with different directory-naming
    conventions (\ in Windows versus / in Linux).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用`os.path.abspath()`和`os.path.join()`来获取图像的完整文件名❷。这种习惯用法在 Python 中非常常见，可以确保你的代码既能处理相对路径（例如，*\foo\bar\*）和绝对路径（*c:\foo\bar\*），也能在不同的操作系统之间兼容，因不同操作系统的目录命名约定（Windows
    中使用\，而 Linux 中使用/）。
- en: To load the files into PIL `Image` objects, you could pass each filename to
    the `Image.open()` method, but if your photomosaic folder had hundreds or thousands
    of images, doing so would be highly resource intensive. Instead, you can use Python
    to open each image and pass the file handle `fp` into PIL using `Image.open()`.
    Once the image has been loaded, close the file handle and release the system resources.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将文件加载为PIL `Image`对象，你可以将每个文件名传递给`Image.open()`方法，但如果你的照片马赛克文件夹中有数百或数千张图像，这样做会非常占用资源。相反，你可以使用Python打开每个图像文件，并将文件句柄`fp`传递给PIL，使用`Image.open()`方法加载图像。加载完图像后，关闭文件句柄并释放系统资源。
- en: You open the image file using `open()` ❸ and then pass the handle to `Image.open()`
    and store the resulting image, `im`, in a list called `images`. Calling `Image.load()`
    ❹ force-loads the image data inside `im` because `open()` is a lazy operation.
    It identifies the image but doesn’t actually read all the image data until you
    try to use the image. You finish by closing the file handle to release system
    resources ❺.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用`open()`打开图像文件❸，然后将文件句柄传递给`Image.open()`，并将返回的图像`im`存储到名为`images`的列表中。调用`Image.load()`❹强制加载`im`中的图像数据，因为`open()`是一个懒加载操作。它仅识别图像，但在你实际使用图像之前并不会读取所有的图像数据。最后，你通过关闭文件句柄来释放系统资源❺。
- en: '[Calculating the Average Color Value of an Image](nsp-venkitachalam503045-0008.xhtml#rbh0905)'
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[计算图像的平均颜色值](nsp-venkitachalam503045-0008.xhtml#rbh0905)'
- en: Once you’ve read in the input images, you need to calculate each image’s average
    color value. You also need to find the average color value for each section of
    the target image. Create a function `getAverageRGB()` to handle both tasks.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你读取了输入图像，你需要计算每张图像的平均颜色值。你还需要为目标图像的每个区域计算平均颜色值。创建一个`getAverageRGB()`函数来处理这两个任务。
- en: '[PRE2]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The function takes in an `Image` object—it could be one of the input images
    or a section of the target image—and uses `numpy` to convert it into a data array ❶.
    The resulting `numpy` array has the shape (`w`, `h`, `d`), where `w` is the width
    of the image, `h` is the height, and `d` is the depth, which, in the case of RGB
    images, is three units (one each for R, G, and B). You store the `shape` tuple
    ❷ and then compute the average RGB value by reshaping the array into a more convenient
    form with shape (`w*h`, `d`) so that you can compute the average using `numpy.average()`
    ❸. (You performed a similar operation in [Chapter 6](nsp-venkitachalam503045-0019.xhtml#ch06)
    to get the average brightness of a grayscale image.) You return the result as
    a tuple.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数接受一个`Image`对象——它可以是输入图像之一，或者是目标图像的一个部分——并使用`numpy`将其转换为数据数组❶。结果的`numpy`数组的形状为(`w`,
    `h`, `d`)，其中`w`是图像的宽度，`h`是高度，`d`是深度，在RGB图像的情况下，`d`的值为3（分别对应R、G和B）。你存储了`shape`元组❷，然后通过将数组重塑为更方便的形状(`w*h`,
    `d`)来计算平均RGB值，这样你就可以使用`numpy.average()`❸来计算平均值。（你在[第六章](nsp-venkitachalam503045-0019.xhtml#ch06)中执行了类似的操作，以获取灰度图像的平均亮度。）你将结果作为一个元组返回。
- en: '[Splitting the Target Image into a Grid](nsp-venkitachalam503045-0008.xhtml#rbh0906)'
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[将目标图像拆分为网格](nsp-venkitachalam503045-0008.xhtml#rbh0906)'
- en: 'Now you need to split the target image into an *M*×*N* grid of smaller images.
    Let’s create a function to do that:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你需要将目标图像拆分为一个*M*×*N*的小图像网格。让我们创建一个函数来实现这一点：
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: First you gather the dimensions of the target image ❶ and the grid size ❷. Then
    you calculate the dimensions of each tile in the target image using basic division
    ❸. Next you need to iterate through the grid dimensions and cut out and store
    each tile as a separate image. Calling `image.crop()` ❹ crops out a portion of
    the image using the upper-left and lower-right image coordinates as arguments
    (as discussed in [“Splitting the Target Image”](nsp-venkitachalam503045-0020.xhtml#bh0901)
    on [page 115](nsp-venkitachalam503045-0020.xhtml#p115)). You end up with a list
    of images—first, all the images in the first row of the grid, from left to right;
    then all the images in the second row of the grid; and so on.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你收集目标图像的尺寸❶和网格大小❷。然后，你使用基本的除法计算目标图像中每个瓷砖的尺寸❸。接下来，你需要遍历网格的尺寸，裁剪并存储每个瓷砖作为一个独立的图像。调用`image.crop()`❹可以使用图像的左上角和右下角坐标作为参数来裁剪图像的一部分（如[“拆分目标图像”](nsp-venkitachalam503045-0020.xhtml#bh0901)在[第115页](nsp-venkitachalam503045-0020.xhtml#p115)中讨论的）。最后，你会得到一系列图像——首先是网格中第一行的所有图像，从左到右；然后是第二行的所有图像；依此类推。
- en: '[Finding the Best Match for a Tile](nsp-venkitachalam503045-0008.xhtml#rbh0907)'
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[查找瓷砖的最佳匹配](nsp-venkitachalam503045-0008.xhtml#rbh0907)'
- en: 'Now let’s find the best match for a tile from the folder of input images. We’ll
    look at two ways of doing this: using a linear search and using a k-d tree. For
    the linear search method, you create a utility function, `getBestMatchIndex()`,
    as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们从输入图像的文件夹中找到最匹配的瓷砖。我们将探讨两种方法：使用线性搜索和使用k-d树。对于线性搜索方法，你创建了一个工具函数`getBestMatchIndex()`，如下所示：
- en: '[PRE4]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You’re trying to search `avgs`, a list of the average RGB values of the input
    images, to find the one closest to `input_avg`, the average RGB value of one of
    the tiles in the target image. To start, you initialize the closest match index
    to 0 ❶ and the minimum distance to infinity ❷. Then you loop through the values
    in the list of averages ❸ and start computing distances ❹ using the standard formula
    shown in [“Matching Images”](nsp-venkitachalam503045-0020.xhtml#bh0903) on [page 116](nsp-venkitachalam503045-0020.xhtml#p116).
    (You skip taking the square root to reduce computation time.) If the computed
    distance is less than the stored minimum distance `min_dist`, it’s replaced with
    the new minimum distance ❺. This test will always pass the first time, since any
    distance will be less than infinity. At the end of the iteration, `min_index`
    is the index of the average RGB value from the `avgs` list that is closest to
    `input_avg`. Now you can use this index to select the matching image from the
    list of input images.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在尝试搜索 `avgs`，一个包含输入图像的平均 RGB 值的列表，以找到与 `input_avg`（目标图像中某个瓷砖的平均 RGB 值）最接近的那个。首先，你将最接近的匹配项索引初始化为
    0 ❶，并将最小距离初始化为无穷大 ❷。然后，你循环遍历平均值列表中的值 ❸，并开始使用 [“匹配图像”](nsp-venkitachalam503045-0020.xhtml#bh0903)
    中的标准公式计算距离 ❹（你跳过计算平方根以减少计算时间）。如果计算出的距离小于存储的最小距离 `min_dist`，则用新的最小距离替换它 ❺。这个测试在第一次执行时总是会通过，因为任何距离都小于无穷大。在迭代结束时，`min_index`
    是 `avgs` 列表中与 `input_avg` 最接近的平均 RGB 值的索引。现在，你可以使用这个索引从输入图像列表中选择匹配的图像。
- en: 'Now let’s find the best matches using a k-d tree instead of a linear search.
    Here’s the function:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用 k-d 树而不是线性搜索来找到最佳匹配。以下是函数：
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `getBestMatchIndicesKDT()` function takes two arguments: `qavgs` is the
    list of average RGB values for each tile in the target image, and `kdtree` is
    the `scipy KDTree` object created using a list of average RGB values from the
    input images. (We’ll be creating the `KDTree` object in [“Creating the Photomosaic”](nsp-venkitachalam503045-0020.xhtml#bh0909)
    on [page 124](nsp-venkitachalam503045-0020.xhtml#p124).) You use the `KDTree`
    object’s `query()` method to get the points in the tree that are closest to the
    ones in `qavgs` ❶. Here, the `k` parameter is the number of nearest neighbors
    to the queried point you want to return. You just need the closest match, so you
    pass in `k=1`. The return value from the `query()` method is a tuple consisting
    of two `numpy` arrays with the distances and indices of the matches. You need
    the indices, so you pick the second value from the result ❷.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`getBestMatchIndicesKDT()` 函数接受两个参数：`qavgs` 是目标图像中每个瓷砖的平均 RGB 值列表，`kdtree`
    是使用输入图像的平均 RGB 值列表创建的 `scipy KDTree` 对象。（我们将在 [“创建照片马赛克”](nsp-venkitachalam503045-0020.xhtml#bh0909)
    中的 [第 124 页](nsp-venkitachalam503045-0020.xhtml#p124)创建 `KDTree` 对象。）你使用 `KDTree`
    对象的 `query()` 方法来获取树中与 `qavgs` 中点最接近的点 ❶。这里，`k` 参数是你想要返回的查询点的最近邻数量。你只需要最接近的匹配项，所以传入
    `k=1`。`query()` 方法的返回值是一个包含两个 `numpy` 数组的元组，分别表示匹配项的距离和索引。你需要索引，因此从结果中选择第二个值 ❷。'
- en: Notice that the `query()` method ❶ allows you to pass in a list of query points
    instead of just one. This actually runs faster than querying results one by one,
    and it means you’ll have to call the `getBestMatchIndicesKDT()` function only
    once, whereas you’ll have to call the linear search `getBestMatch()` function
    many times, once for each tile in the photomosaic.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`query()` 方法 ❶ 允许你传入一个查询点列表，而不仅仅是一个。这实际上比逐个查询结果要快，而且这意味着你只需要调用 `getBestMatchIndicesKDT()`
    函数一次，而线性搜索的 `getBestMatch()` 函数需要为照片马赛克中的每个瓷砖调用多次。
- en: The complete program will include an option to choose which of the previous
    two functions to use, the linear search version or the k-d tree version. It will
    also have a timer to test which search method is faster.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的程序将包括一个选项，用于选择使用前两个函数中的哪一个：线性搜索版本或 k-d 树版本。它还将有一个计时器，用来测试哪种搜索方法更快。
- en: '[Creating an Image Grid](nsp-venkitachalam503045-0008.xhtml#rbh0908)'
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[创建图像网格](nsp-venkitachalam503045-0008.xhtml#rbh0908)'
- en: You need one more utility function before moving on to photomosaic creation.
    The `createImageGrid()` function will create a grid of images of size *M*×*N*.
    This image grid is the final photomosaic image, created from the list of selected
    input images.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续创建照片马赛克之前，你还需要一个实用函数。`createImageGrid()` 函数将创建一个 *M*×*N* 大小的图像网格。这个图像网格是最终的照片马赛克图像，由选定的输入图像列表创建。
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The function takes two parameters: a list of images (the input images you chose
    based on the closest RGB match to the individual tiles of the target image) and
    a tuple with the photomosaic’s dimensions (the number of rows and columns you
    want it to have). You gather the dimensions of the grid ❶ and then use `assert`
    to see whether the number of images supplied to `createImageGrid()` matches the
    grid size. (The `assert` method checks assumptions in your code, especially during
    development and testing.) Then you compute the maximum width and height of the
    selected images ❷, since they may not all be the same size. You’ll use these maximum
    dimensions to set the standard tile size for the photomosaic. If an input image
    won’t completely fill a tile, the spaces between the tiles will show as solid
    black by default.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数有两个参数：一个图像列表（基于与目标图像单个图像块最接近的 RGB 匹配所选择的输入图像），以及一个包含照片马赛克尺寸的元组（你希望它具有的行数和列数）。你先收集网格的尺寸
    ❶，然后使用 `assert` 来检查传递给 `createImageGrid()` 的图像数量是否与网格大小匹配。（`assert` 方法用于检查代码中的假设，尤其是在开发和测试期间。）接下来，你计算所选图像的最大宽度和高度
    ❷，因为它们的大小可能不完全相同。你将使用这些最大尺寸来设置照片马赛克的标准图像块大小。如果输入图像无法完全填充一个图像块，默认情况下，图像块之间的空白部分将显示为纯黑色。
- en: Next, you create an empty `Image` sized to fit all images in the grid ❸; you’ll
    paste the tile images into this. Then you fill the image grid by looping through
    the selected images and pasting them into the appropriate spot on the grid using
    the `Image.paste()` method ❻. The first argument to `Image.paste()` is the `Image`
    object to be pasted, and the second is the top-left coordinate. Now you need to
    figure out in which row and column to paste an input image into the image grid.
    To do so, you express the image index in terms of rows and columns. The index
    of a tile in the image grid is given by *N* × *row* + *col*, where *N* is the
    number of cells along the width and (*row*, *col*) is the coordinate in the grid;
    at ❹, you determine the row from the previous formula, and at ❺, the column.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你创建一个空的 `Image`，其大小足以容纳网格中的所有图像 ❸；你将把图像块粘贴到这个图像中。然后，通过循环遍历选择的图像，将它们粘贴到网格中的适当位置，使用
    `Image.paste()` 方法 ❻。`Image.paste()` 的第一个参数是要粘贴的 `Image` 对象，第二个是左上角的坐标。现在你需要确定将输入图像粘贴到图像网格中的哪一行和哪一列。为此，你需要将图像索引表示为行和列的形式。图像网格中图像块的索引由
    *N* × *row* + *col* 给出，其中 *N* 是图像网格的宽度，(*row*, *col*) 是网格中的坐标；在 ❹，你根据前面的公式确定行，接着在
    ❺ 确定列。
- en: '[Creating the Photomosaic](nsp-venkitachalam503045-0008.xhtml#rbh0909)'
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[创建照片马赛克](nsp-venkitachalam503045-0008.xhtml#rbh0909)'
- en: 'Now that you have all the required utilities, let’s write the main function
    that creates the photomosaic. Here’s the start of the function:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经拥有了所有必需的工具，让我们编写创建照片马赛克的主函数。以下是函数的开始部分：
- en: '[PRE7]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `createPhotomosaic()` function takes as input the target image, the list
    of input images, the size of the generated photomosaic (number of rows and columns),
    and flags indicating whether an image can be reused and whether to use a k-d tree
    to search for image matches. The function begins by calling `splitImage()` ❶ to
    split the target into a grid of smaller image tiles. Once the image is split,
    you’re ready to start finding matches for each tile from the images in the input
    folder. Because this process can be lengthy, however, it’s a good idea to provide
    feedback to users to let them know that the program is still working. To help
    with this feedback, you set `batch_size` to one-tenth the total number of tile
    images ❷. The choice of one-tenth is arbitrary and simply a way for the program
    to say “I’m still alive.” Each time the program processes a tenth of the images,
    it will print a message indicating that it’s still running.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`createPhotomosaic()` 函数接受目标图像、输入图像列表、生成的照片马赛克的大小（行数和列数）以及标志，指示图像是否可以重用，是否使用
    k-d 树来搜索图像匹配。该函数首先调用 `splitImage()` ❶ 将目标图像拆分为一个小图像块的网格。图像拆分后，你就可以开始从输入文件夹中的图像中找到每个图像块的匹配项。然而，由于这个过程可能比较耗时，因此最好向用户提供反馈，让他们知道程序仍在运行。为此，你将
    `batch_size` 设置为图像块总数的十分之一 ❷。选择十分之一是任意的，仅仅是为了让程序告诉用户“我还在运行”。每次程序处理完十分之一的图像时，它都会打印一条消息，表明程序仍在运行。'
- en: To find image matches, you need the average RGB values. You iterate over the
    input images ❸ and use your `getAverageRGB()` function to compute the average
    RGB value for each one, storing the results in the list `avgs`. Then you do the
    same for each tile in the target image ❹, storing the average RGB values into
    the list `avgs_target`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到图像匹配，你需要计算平均RGB值。你遍历输入图像❸并使用`getAverageRGB()`函数计算每个图像的平均RGB值，将结果存储在`avgs`列表中。然后你对目标图像中的每个瓦片❹进行相同的操作，将平均RGB值存储到`avgs_target`列表中。
- en: 'The function continues with an `if...else` statement to find RGB matches using
    either a k-d tree or a linear search. Let’s look at the `if` branch first, which
    runs if the `use_kdt` flag was set to `True`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数通过`if...else`语句继续运行，使用k-d树或线性搜索来查找RGB匹配项。我们先来看`if`分支，当`use_kdt`标志被设置为`True`时，该分支会执行：
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You create a `KDTree` object using the list of average RGB values from the input
    images ❶ and retrieve the indices of the best matches by passing in `avgs_target`
    and the `KDTree` object to your `getBestMatchIndicesKDT()` helper function ❷.
    Then you iterate through all the matching indices ❸, find the corresponding input
    images, and append them to the list `output_images` ❹.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用输入图像的平均RGB值列表❶创建一个`KDTree`对象，并通过将`avgs_target`和`KDTree`对象传递给`getBestMatchIndicesKDT()`辅助函数❷来检索最佳匹配的索引。然后，你遍历所有匹配的索引❸，找到对应的输入图像，并将它们添加到`output_images`列表❹。
- en: 'Next, let’s look at the `else` branch, which performs a linear search for matches:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们来看一下`else`分支，它执行线性搜索以寻找匹配项：
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: For the linear search, you start iterating through the average RGB values of
    the target image tiles ❶. For each tile, you search for the closest match in the
    list of averages for the input images using `getBestMatchIndex()` ❷. The result
    is returned as an index, which you use to retrieve the `Image` object and store
    it in the `output_images` list ❸. For every `batch_size` number of images processed
    ❹, you print a message to the user. If the `reuse_images` flag is set to `False`
    ❺, you remove the selected input image from the list so that it won’t be reused
    in another tile. (This works best when you have a wide range of input images to
    choose from.)
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 对于线性搜索，你开始遍历目标图像瓦片的平均RGB值❶。对于每个瓦片，你使用`getBestMatchIndex()`❷在输入图像的平均RGB值列表中搜索最接近的匹配项。结果会返回一个索引，你可以使用这个索引来检索`Image`对象并将其存储在`output_images`列表中❸。对于每处理完`batch_size`个图像❹，你会打印一条消息给用户。如果`reuse_images`标志被设置为`False`❺，你会从列表中删除已选中的输入图像，以确保它不会在另一个瓦片中被重用。（当你有大量输入图像可以选择时，这种方式效果最好。）
- en: 'All that remains in the `createPhotomosaic()` function is to arrange the input
    images into the final photomosaic:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在`createPhotomosaic()`函数中剩下的就是将输入图像排列成最终的照片马赛克：
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You use the `createImageGrid()` function to build the photomosaic ❶. Then you
    return the resulting image as `mosaic_image`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用`createImageGrid()`函数构建照片马赛克❶。然后你将生成的图像作为`mosaic_image`返回。
- en: '[Writing the main() Function](nsp-venkitachalam503045-0008.xhtml#rbh0910)'
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[编写main()函数](nsp-venkitachalam503045-0008.xhtml#rbh0910)'
- en: The `main()` function of the program takes in and parses command line arguments,
    loads all the images, and does some additional setup. Then it calls the `createPhotomosaic()`
    function and saves the resulting photomosaic. As the photomosaic is built, Python
    times how long the process takes, allowing you to compare the performance of the
    k-d tree with that of the linear search.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的`main()`函数接收并解析命令行参数，加载所有图像并进行一些额外的设置。然后它调用`createPhotomosaic()`函数并保存生成的照片马赛克。随着照片马赛克的构建，Python会记录过程的时间，从而让你比较k-d树与线性搜索的性能。
- en: Adding the Command Line Options
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加命令行选项
- en: 'The `main()` function supports these command line options:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()`函数支持以下命令行选项：'
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This code contains three required command line parameters: the name of the
    target image, the name of the input folder of images, and the grid size. The fourth
    parameter is for the optional filename for the output. If the filename is omitted,
    the photomosaic will be written to a file named *mosaic.png*. The fifth argument
    is a Boolean flag that enables the k-d tree search instead of linear search for
    matching average RGB values.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码包含三个必需的命令行参数：目标图像的名称、输入图像文件夹的名称和网格大小。第四个参数是可选的输出文件名。如果省略文件名，照片马赛克将写入名为*mosaic.png*的文件。第五个参数是一个布尔标志，它启用k-d树搜索，而不是线性搜索来匹配平均RGB值。
- en: Controlling the Size of the Photomosaic
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 控制照片马赛克的大小
- en: 'Once all the images are loaded, one issue to address in the `main()` function
    is the size (in pixels) of the resulting photomosaic. If you were to blindly paste
    the input images together based on matching tiles in the target, you could end
    up with a huge photomosaic that is much bigger than the target. To avoid this,
    resize the input images to match the size of each tile in the grid. (This has
    the added benefit of speeding up the average RGB computation since you’ll be using
    smaller images.) Here’s the section of the `main()` function that handles this
    task:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有图像加载完成，`main()`函数中需要解决的一个问题是最终光拼贴图的大小（以像素为单位）。如果你仅仅根据目标中的匹配瓦片盲目地将输入图像拼接在一起，最终可能得到一个比目标图像大得多的光拼贴图。为避免这种情况，可以调整输入图像的大小，使其与网格中每个瓦片的大小匹配。（这还可以加快RGB计算的速度，因为你将使用较小的图像。）以下是`main()`函数中处理此任务的部分代码：
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You compute the target dimensions based on the specified number of rows and
    columns in the grid ❶; then you use the PIL `Image.``thumbnail()` method to resize
    the input images to fit those dimensions ❷.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你根据网格中指定的行数和列数计算目标尺寸❶；然后，使用PIL的`Image.``thumbnail()`方法调整输入图像的大小以适应这些尺寸❷。
- en: Timing the Performance
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 性能计时
- en: 'When the program is run, you’ll want to know how long it takes to execute.
    Use the Python `timeit` module for this purpose. The approach for finding execution
    time is outlined here:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序运行时，你可能想知道它执行所需的时间。为此，可以使用Python的`timeit`模块。计算执行时间的方法如下：
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You record the start time using the `timeit` module’s default timer ❶. Then,
    after running some code, you record the stop time ❷. Computing the difference
    gives you the execution time measured in seconds.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`timeit`模块的默认计时器记录开始时间❶。然后，在运行某些代码后，记录停止时间❷。计算二者的差值即可得到以秒为单位的执行时间。
- en: '[Running the Photomosaic Generator](nsp-venkitachalam503045-0008.xhtml#rah0904)'
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[运行光拼贴图生成器](nsp-venkitachalam503045-0008.xhtml#rah0904)'
- en: 'Let’s first run the program using the default linear search approach. The photomosaic
    will consist of a grid of 128×128 images:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们使用默认的线性搜索方法运行程序。光拼贴图将由128×128图像的网格组成：
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[Figure 7-4(a)](nsp-venkitachalam503045-0020.xhtml#fig7-4) shows the target
    image, and [Figure 7-4(b)](nsp-venkitachalam503045-0020.xhtml#fig7-4) shows the
    resulting photomosaic. You can see a close-up of the photomosaic in [Figure 7-4(c)](nsp-venkitachalam503045-0020.xhtml#fig7-4).
    As you can see in the output, it takes about 2.1 seconds ❶ to find the best match
    for each of the 16,384 tiles in the photomosaic using a linear search. That’s
    not bad, but we can do better.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-4(a)](nsp-venkitachalam503045-0020.xhtml#fig7-4)显示了目标图像，[图 7-4(b)](nsp-venkitachalam503045-0020.xhtml#fig7-4)显示了生成的光拼贴图。你可以在[图
    7-4(c)](nsp-venkitachalam503045-0020.xhtml#fig7-4)中看到光拼贴图的特写。正如你在输出中看到的，使用线性搜索，为光拼贴图中的每个16,384个瓦片找到最佳匹配需要大约2.1秒❶。这还不错，但我们可以做得更好。'
- en: '![](images/nsp-venkitachalam503045-f07004.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f07004.jpg)'
- en: 'Figure 7-4: A sample run of the photomosaic generator'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-4：光拼贴图生成器的一个示例运行
- en: 'Now run the same program with the `--kdt` option, which enables the use of
    a k-d tree to search for image matches. Here are the results:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用`--kdt`选项运行相同的程序，该选项启用了使用k-d树进行图像匹配搜索。以下是结果：
- en: '[PRE15]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The photomosaic creation time has dropped from about 2.1 seconds to less than
    1.1 seconds ❶ with a k-d tree. That’s almost twice the speed!
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用k-d树后，光拼贴图的创建时间从大约2.1秒降至不到1.1秒❶。这几乎是两倍的速度提升！
- en: '[Summary](nsp-venkitachalam503045-0008.xhtml#rah0905)'
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[总结](nsp-venkitachalam503045-0008.xhtml#rah0905)'
- en: In this project, you learned how to create a photomosaic, given a target image
    and a collection of input images. When viewed from a distance, the photomosaic
    looks like the original image, but up close, you can see the individual images
    that make up the mosaic. You also learned about an interesting data structure,
    the k-d tree, which significantly sped up the process of finding the closest match
    for each tile in the mosaic.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你学会了如何在给定目标图像和输入图像集合的情况下创建光拼贴图。从远处看，光拼贴图看起来像原始图像，但靠近时，你可以看到构成拼贴图的单个图像。你还学习了一种有趣的数据结构——k-d树，它显著加速了为拼贴图中的每个瓦片找到最接近匹配的过程。
- en: '[Experiments!](nsp-venkitachalam503045-0008.xhtml#rah0906)'
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[实验！](nsp-venkitachalam503045-0008.xhtml#rah0906)'
- en: 'Here are some ways to further explore photomosaics:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些进一步探索光拼贴图的方法：
- en: 1\. Write a program that creates a blocky version of any image, similar to [Figure
    7-1](nsp-venkitachalam503045-0020.xhtml#fig7-1).
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1\. 编写一个程序，创建任何图像的方块版本，类似于[图 7-1](nsp-venkitachalam503045-0020.xhtml#fig7-1)。
- en: '2\. With the code in this chapter, you created the photomosaic by pasting the
    matched images without any gaps in between. A more artistic presentation might
    include a uniform gap of a few pixels around each tile image. How would you create
    the gap? (Hint: factor in the gaps when computing the final image dimensions and
    when pasting the images in `createImageGrid()`.)'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2\. 使用本章中的代码，你通过将匹配的图像无缝拼接在一起创建了光栅马赛克。更具艺术感的呈现方式可能会在每个图像块周围加入一个均匀的间隙。你将如何创建这个间隙？（提示：在计算最终图像尺寸以及在`createImageGrid()`中粘贴图像时考虑间隙。）
- en: '[The Complete Code](nsp-venkitachalam503045-0008.xhtml#rah0907)'
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[完整代码](nsp-venkitachalam503045-0008.xhtml#rah0907)'
- en: 'Here’s the complete code for the project:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这是项目的完整代码：
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
