- en: '**5**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**5**'
- en: '**DISTRIBUTING YOUR SOFTWARE**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**分发你的软件**'
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: It’s safe to say that at some point, you will want to distribute your software.
    As tempted as you might be to just zip your code and upload it to the internet,
    Python provides tools to make it easier for your end users to get your software
    to work. You should already be familiar with using *setup.py* to install Python
    applications and libraries, but you have probably never delved into how it works
    behind the scenes or how to make a *setup.py* of your own.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 可以肯定地说，在某个时刻，你会希望分发你的软件。虽然你可能会忍不住直接将代码打包并上传到互联网，Python 提供了工具来帮助你的最终用户更轻松地使用你的软件。你应该已经熟悉使用
    *setup.py* 来安装 Python 应用程序和库，但你可能从未深入了解过它的背后原理或如何创建你自己的 *setup.py*。
- en: In this chapter, you’ll learn the history of *setup.py*, how the file works,
    and how to create your own custom *setup.py*. We’ll also take a look at some of
    the less well-known capabilities of the package installation tool pip and how
    to make your software downloadable via pip. Finally, we’ll see how to use Python’s
    entry points to make functions easy to find between programs. With these skills,
    you can make your published software accessible for end users.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍 *setup.py* 的历史、它是如何工作的以及如何创建你自己的定制 *setup.py*。我们还将看一些包安装工具 pip 的不太为人知的功能，以及如何通过
    pip 让你的软件可以下载。最后，我们将了解如何使用 Python 的入口点使得函数在程序之间更容易找到。有了这些技能，你就可以让发布的软件更容易为最终用户所使用。
- en: '**A Bit of setup.py History**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**setup.py 的一点历史**'
- en: The distutils library, originally created by software developer Greg Ward, has
    been part of the standard Python library since 1998\. Ward sought to create an
    easy way for developers to automate the installation process for their end users.
    Packages provide the *setup.py* file as the standard Python script for their installation,
    and they can use distutils to install themselves, as shown in [Listing 5-1](ch05.xhtml#ch5list1).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: distutils 库最初由软件开发者 Greg Ward 创建，自 1998 年以来一直是标准 Python 库的一部分。Ward 希望为开发者提供一种简便的方式，帮助他们自动化为最终用户安装软件包的过程。软件包提供
    *setup.py* 文件作为标准的 Python 脚本进行安装，开发者可以使用 distutils 来进行安装，如 [Listing 5-1](ch05.xhtml#ch5list1)
    所示。
- en: '#!/usr/bin/python'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '#!/usr/bin/python'
- en: from distutils.core import setup
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: from distutils.core import setup
- en: setup(name="rebuildd",
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: setup(name="rebuildd",
- en: description="Debian packages rebuild tool",
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: description="Debian 软件包重建工具",
- en: author="Julien Danjou",
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: author="Julien Danjou",
- en: author_email="acid@debian.org",
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: author_email="acid@debian.org",
- en: url="http://julien.danjou.info/software/rebuildd.html",
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: url="http://julien.danjou.info/software/rebuildd.html",
- en: packages=['rebuildd'])
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: packages=['rebuildd'])
- en: '*Listing 5-1: Building a setup.py using distutils*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 5-1: 使用 distutils 构建 setup.py*'
- en: With the *setup.py* file as the root of a project, all users have to do to build
    or install your software is run that file with the appropriate command as its
    argument. Even if your distribution includes C modules in addition to native Python
    ones, distutils can handle them automatically.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以 *setup.py* 文件为项目根基，用户只需运行该文件并传入相应的命令作为参数，即可构建或安装你的软件。即使你的分发版除了原生 Python 模块外还包含
    C 模块，distutils 也能自动处理它们。
- en: Development of distutils was abandoned in 2000; since then, other developers
    have picked up where it left off. One of the notable successors is the packaging
    library known as setuptools, which offers more frequent updates and advanced features,
    such as automatic dependency handling, the Egg distribution format, and the easy_install
    command. Since distutils was still the accepted means of packaging software included
    with the Python Standard Library at the time of development, setuptools provided
    a degree of backward compatibility with it. [Listing 5-2](ch05.xhtml#ch5list2)
    shows how you’d use setuptools to build the same installation package as in [Listing
    5-1](ch05.xhtml#ch5list1).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: distutils 的开发在 2000 年被放弃；从那时起，其他开发者接手了它的后续工作。一个显著的继承者是名为 setuptools 的打包库，它提供了更频繁的更新和更多高级功能，比如自动处理依赖关系、Egg
    分发格式以及 easy_install 命令。由于 distutils 在开发时仍是 Python 标准库中接受的软件打包方式，setuptools 提供了与其一定程度的向后兼容性。
    [Listing 5-2](ch05.xhtml#ch5list2) 展示了如何使用 setuptools 构建与 [Listing 5-1](ch05.xhtml#ch5list1)
    中相同的安装包。
- en: '#!/usr/bin/env python'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '#!/usr/bin/env python'
- en: import setuptools
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: import setuptools
- en: setuptools.setup(
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: setuptools.setup(
- en: name="rebuildd",
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: name="rebuildd",
- en: version="0.2",
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: version="0.2",
- en: author="Julien Danjou",
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: author="Julien Danjou",
- en: author_email="acid@debian.org",
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: author_email="acid@debian.org",
- en: description="Debian packages rebuild tool",
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: description="Debian 软件包重建工具",
- en: license="GPL",
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: license="GPL",
- en: url="http://julien.danjou.info/software/rebuildd/",
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: url="http://julien.danjou.info/software/rebuildd/",
- en: packages=['rebuildd'],
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: packages=['rebuildd'],
- en: classifiers=[
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: classifiers=[
- en: '"Development Status :: 2 - Pre-Alpha",'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '"开发状态 :: 2 - 初期版本",'
- en: '"Intended Audience :: Developers",'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '"目标受众 :: 开发人员",'
- en: '"Intended Audience :: Information Technology",'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '"目标受众 :: 信息技术",'
- en: '"License :: OSI Approved :: GNU General Public License (GPL)", "Operating System
    :: OS Independent",'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '"许可证 :: OSI 认可 :: GNU 通用公共许可证（GPL）", "操作系统 :: 跨平台",'
- en: '"Programming Language :: Python"'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '"编程语言 :: Python"'
- en: '],'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '],'
- en: )
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '*Listing 5-2: Building a setup.py using setuptools*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-2：使用 setuptools 构建 setup.py*'
- en: Eventually, development on setuptools slowed down too, but it wasn’t long before
    another group of developers forked it to create a new library called distribute,
    which offered several advantages over setuptools, including fewer bugs and Python
    3 support.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，setuptools 的开发也放缓了，但很快，另一组开发人员将其分支出来，创建了一个名为 distribute 的新库，该库在 setuptools
    的基础上提供了几个优点，包括减少了 bug 和对 Python 3 的支持。
- en: 'All the best stories have a twist ending, though: in March 2013, the teams
    behind setuptools and distribute decided to merge their codebases under the aegis
    of the original setuptools project. So distribute is now deprecated, and setuptools
    is once more the canonical way to handle advanced Python installations.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，所有最好的故事都有反转：在 2013 年 3 月，setuptools 和 distribute 背后的团队决定将他们的代码库合并到原始 setuptools
    项目下。因此，distribute 现在已被弃用，setuptools 再次成为处理高级 Python 安装的规范方式。
- en: While all this was happening, another project, known as distutils2, was developed
    with the intention of completely replacing distutils in the Python Standard Library.
    Unlike both distutils and setuptools, it stored package metadata in a plaintext
    file, *setup.cfg*, which was easier both for developers to write and for external
    tools to read. However, distutils2 retained some of the failings of distutils,
    such as its obtuse command-based design, and lacked support for entry points and
    native script execution on Windows—both features provided by setuptools. For these
    and other reasons, plans to include distutils2, renamed as packaging, in the Python
    3.3 Standard Library fell through, and the project was abandoned in 2012.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一切发生的同时，另一个名为 distutils2 的项目也在开发，目的是完全取代 Python 标准库中的 distutils。与 distutils
    和 setuptools 不同，distutils2 将包的元数据存储在纯文本文件 *setup.cfg* 中，这既便于开发人员编写，也便于外部工具读取。然而，distutils2
    保留了 distutils 的一些缺点，例如它难以理解的基于命令的设计，并且缺乏对入口点和 Windows 本地脚本执行的支持——这两项功能是 setuptools
    提供的。由于这些原因，原本计划将 distutils2（更名为 packaging）纳入 Python 3.3 标准库的计划未能实现，该项目在 2012 年被放弃。
- en: There is still a chance for packaging to rise from the ashes through distlib,
    an up-and-coming effort to replace distutils. Before release, it was rumored that
    the distlib package would become part of the Standard Library in Python 3.4, but
    that never came to be. Including the best features from packaging, distlib implements
    the basic groundwork described in the packaging-related PEPs.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 distlib，打破困境的打包工具仍有机会从废墟中崛起，这是一个旨在取代 distutils 的新兴项目。在发布之前，有传言称 distlib 包将成为
    Python 3.4 标准库的一部分，但这一计划并未实现。distlib 在集成打包的最佳特性基础上，实施了打包相关 PEPs 中描述的基本工作框架。
- en: 'So, to recap:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，简而言之：
- en: distutils is part of the Python Standard Library and can handle simple package
    installations.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: distutils 是 Python 标准库的一部分，可以处理简单的包安装。
- en: setuptools, the standard for advanced package installations, was at first deprecated
    but is now back in active development and the de facto standard.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: setuptools，作为高级包安装的标准，最初被弃用，但现在已经重新进入积极开发阶段，并成为事实上的标准。
- en: distribute has been merged back into setuptools as of version 0.7; distutils2
    (aka packaging) has been abandoned.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: distribute 已在版本 0.7 中并入 setuptools；distutils2（即 packaging）已被废弃。
- en: distlib *might* replace distutils in the future.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: distlib *可能* 在未来取代 distutils。
- en: 'There are other packaging libraries out there, but these are the five you’ll
    encounter the most. Be careful when researching these libraries on the internet:
    plenty of documentation is outdated due to the complicated history outlined above.
    The official documentation is up-to-date, however.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他打包库，但这五个是你最常遇到的。在互联网上查找这些库时要小心：由于上文提到的复杂历史，很多文档已经过时。不过，官方文档是最新的。
- en: In short, setuptools is the distribution library to use for the time being,
    but keep an eye out for distlib in the future.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，setuptools 目前是使用的打包库，但未来要留意 distlib 的发展。
- en: '**Packaging with setup.cfg**'
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用 setup.cfg 进行打包**'
- en: 'You’ve probably already tried to write a *setup.py* for a package at some point,
    either by copying one from another project or by skimming through the documentation
    and building it yourself. Building a *setup.py* is not an intuitive task. Choosing
    the right tool to use is just the first challenge. In this section, I want to
    introduce you to one of the recent improvements to setuptools: the *setup.cfg*
    file support.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经尝试过为某个包编写 *setup.py*，无论是通过复制另一个项目的文件，还是浏览文档后自己动手编写。构建 *setup.py* 不是一项直观的任务。选择合适的工具就是第一大挑战。在本节中，我想向你介绍
    setuptools 最近的改进之一：*setup.cfg* 文件支持。
- en: 'This is what a *setup.py* using a *setup.cfg* file looks like:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用 *setup.cfg* 文件的 *setup.py* 示例：
- en: import setuptools
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: import setuptools
- en: setuptools.setup()
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: setuptools.setup()
- en: Two lines of code—it is that simple. The actual metadata the setup requires
    is stored in *setup.cfg*, as in [Listing 5-3](ch05.xhtml#ch5list3).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 两行代码——就这么简单。setup 所需的实际元数据存储在 *setup.cfg* 中，如 [Listing 5-3](ch05.xhtml#ch5list3)
    所示。
- en: '[metadata]'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[metadata]'
- en: name = foobar
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: name = foobar
- en: author = Dave Null
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: author = Dave Null
- en: author-email = foobar@example.org
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: author-email = foobar@example.org
- en: license = MIT
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: license = MIT
- en: 'long_description = file: README.rst'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 'long_description = file: README.rst'
- en: url = http://pypi.python.org/pypi/foobar
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: url = http://pypi.python.org/pypi/foobar
- en: requires-python = >=2.6
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: requires-python = >=2.6
- en: classifiers =
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: classifiers =
- en: 'Development Status :: 4 - Beta'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 'Development Status :: 4 - Beta'
- en: 'Environment :: Console'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 'Environment :: Console'
- en: 'Intended Audience :: Developers'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 'Intended Audience :: Developers'
- en: 'Intended Audience :: Information Technology'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 'Intended Audience :: 信息技术'
- en: 'License :: OSI Approved :: Apache Software License'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 'License :: OSI 批准 :: Apache 软件许可证'
- en: 'Operating System :: OS Independent'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 'Operating System :: OS 独立'
- en: 'Programming Language :: Python'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 'Programming Language :: Python'
- en: '*Listing 5-3: The setup.cfg metadata*'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 5-3: setup.cfg 元数据*'
- en: As you can see, *setup.cfg* uses a format that’s easy to write and read, directly
    inspired by distutils2. Many other tools, such as Sphinx or Wheel, also read configuration
    from this *setup.cfg* file—that alone is a good argument to start using it.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，*setup.cfg* 使用了一种易于编写和阅读的格式，直接受 distutils2 的启发。许多其他工具，例如 Sphinx 或 Wheel，也从这个
    *setup.cfg* 文件中读取配置——这本身就是一个很好的理由，值得开始使用它。
- en: In [Listing 5-3](ch05.xhtml#ch5list3), the description of the project is read
    from the *README.rst* file. It’s good practice to always have a README file—preferably
    in the RST format—so users can quickly understand what the project is about. With
    just these basic *setup.py* and *setup.cfg* files, your package is ready to be
    published and used by other developers and applications. The setuptools documentation
    provides more details if needed, for example, if you have some extra steps in
    your installation process or want to include extra files.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [Listing 5-3](ch05.xhtml#ch5list3) 中，项目描述是从 *README.rst* 文件中读取的。保持一个 README
    文件是一个好的实践——最好使用 RST 格式——这样用户可以快速了解项目内容。仅凭这些基本的 *setup.py* 和 *setup.cfg* 文件，你的包就已经准备好发布并供其他开发者和应用使用。如果需要，setuptools
    文档提供了更多细节，例如，如果你的安装过程有额外步骤，或者你想包括额外的文件。
- en: 'Another useful packaging tool is pbr, short for *Python Build Reasonableness*.
    The project was started in OpenStack as an extension of setuptools to facilitate
    installation and deployment of packages. The pbr packaging tool, used alongside
    setuptools, implements features absent from setuptools, including these:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的打包工具是 pbr，*Python Build Reasonableness* 的缩写。该项目最初在 OpenStack 中启动，作为 setuptools
    的扩展，旨在简化包的安装和部署。与 setuptools 一起使用的 pbr 打包工具，补充了 setuptools 中缺失的一些功能，包括以下内容：
- en: Automatic generation of Sphinx documentation
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动生成 Sphinx 文档
- en: Automatic generation of *AUTHORS* and *ChangeLog* files based on git history
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于 git 历史自动生成 *AUTHORS* 和 *ChangeLog* 文件
- en: Automatic creation of file lists for git
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动创建 git 的文件列表
- en: Version management based on git tags using semantic versioning
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于 git 标签的版本管理，采用语义化版本控制
- en: And all this with little to no effort on your part. To use pbr, you just need
    to enable it, as shown in [Listing 5-4](ch05.xhtml#ch5list4).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 而且这一切几乎不需要你额外的努力。要使用 pbr，你只需要启用它，如 [Listing 5-4](ch05.xhtml#ch5list4) 所示。
- en: import setuptools
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: import setuptools
- en: setuptools.setup(setup_requires=['pbr'], pbr=True)
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: setuptools.setup(setup_requires=['pbr'], pbr=True)
- en: '*Listing 5-4: setup.py using pbr*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 5-4: 使用 pbr 的 setup.py*'
- en: The setup_requires parameter indicates to setuptools that pbr must be installed
    prior to using setuptools. The pbr=True argument makes sure that the pbr extension
    for setuptools is loaded and called.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: setup_requires 参数告诉 setuptools，必须先安装 pbr 才能使用 setuptools。pbr=True 参数确保加载并调用
    setuptools 的 pbr 扩展。
- en: Once enabled, the python setup.py command is enhanced with the pbr features.
    Calling python setup.py –version will, for example, return the version number
    of the project based on existing git tags. Running python setup.py sdist would
    create a source tarball with automatically generated *ChangeLog* and *AUTHORS*
    files.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 启用后，python setup.py 命令会增强 pbr 功能。例如，调用 python setup.py --version 将返回基于现有 git
    标签的项目版本号。运行 python setup.py sdist 将创建一个源 tarball，并自动生成 *ChangeLog* 和 *AUTHORS*
    文件。
- en: '**The Wheel Format Distribution Standard**'
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Wheel 格式分发标准**'
- en: For most of Python’s existence, there’s been no official standard distribution
    format. While different distribution tools generally use some common archive format—even
    the Egg format introduced by setuptools is just a zip file with a different extension—their
    metadata and package structures are incompatible with each other. This problem
    was compounded when an official installation standard was finally defined in PEP
    376 that was also incompatible with existing formats.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 大部分历史中，并没有官方的标准分发格式。虽然不同的分发工具通常使用一些通用的归档格式——甚至 setuptools 引入的 Egg 格式只是一个具有不同扩展名的
    zip 文件——但它们的元数据和包结构是彼此不兼容的。这个问题在 PEP 376 定义了一个官方安装标准时变得更加复杂，因为这个标准也与现有格式不兼容。
- en: To solve these problems, PEP 427 was written to define a new standard for Python
    distribution packages called Wheel. The reference implementation of this format
    is available as a tool, also called Wheel.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这些问题，PEP 427 被编写出来，定义了一种新的 Python 分发包标准，叫做 Wheel。该格式的参考实现作为一个工具提供，也叫做 Wheel。
- en: Wheel is supported by pip starting with version 1.4\. If you’re using setuptools
    and have the Wheel package installed, it automatically integrates itself as a
    setuptools command named bdist_wheel. If you don’t have Wheel installed, you can
    install it using the command pip install wheel. [Listing 5-5](ch05.xhtml#ch5list5)
    shows some of the output when calling bdist_wheel, abridged for print.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Wheel 从 pip 版本 1.4 开始得到支持。如果你正在使用 setuptools 并且安装了 Wheel 包，它会自动作为一个名为 bdist_wheel
    的 setuptools 命令进行集成。如果你没有安装 Wheel，可以通过命令 pip install wheel 来安装它。[清单 5-5](ch05.xhtml#ch5list5)
    显示了调用 bdist_wheel 时的部分输出，已缩短以便打印。
- en: $ python setup.py bdist_wheel
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: $ python setup.py bdist_wheel
- en: running bdist_wheel
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 bdist_wheel
- en: running build
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 运行构建
- en: running build_py
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 build_py
- en: creating build/lib
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 build/lib
- en: creating build/lib/daiquiri
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 build/lib/daiquiri
- en: creating build/lib/daiquiri/tests
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 build/lib/daiquiri/tests
- en: copying daiquiri/tests/__init__.py -> build/lib/daiquiri/tests
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 复制 daiquiri/tests/__init__.py -> build/lib/daiquiri/tests
- en: --snip--
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: --省略--
- en: running egg_info
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 egg_info
- en: writing requirements to daiquiri.egg-info/requires.txt
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 写入依赖项到 daiquiri.egg-info/requires.txt
- en: writing daiquiri.egg-info/PKG-INFO
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 写入 daiquiri.egg-info/PKG-INFO
- en: writing top-level names to daiquiri.egg-info/top_level.txt
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 将顶级名称写入 daiquiri.egg-info/top_level.txt
- en: writing dependency_links to daiquiri.egg-info/dependency_links.txt
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 将 dependency_links 写入 daiquiri.egg-info/dependency_links.txt
- en: writing pbr to daiquiri.egg-info/pbr.json
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 写入 pbr 到 daiquiri.egg-info/pbr.json
- en: writing manifest file 'daiquiri.egg-info/SOURCES.txt'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 写入清单文件 'daiquiri.egg-info/SOURCES.txt'
- en: installing to build/bdist.macosx-10.12-x86_64/wheel
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 安装到 build/bdist.macosx-10.12-x86_64/wheel
- en: running install
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 运行安装
- en: running install_lib
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 install_lib
- en: --snip--
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: --省略--
- en: running install_scripts
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 install_scripts
- en: creating build/bdist.macosx-10.12-x86_64/wheel/daiquiri-1.3.0.dist-info/WHEEL
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 build/bdist.macosx-10.12-x86_64/wheel/daiquiri-1.3.0.dist-info/WHEEL
- en: ➊ creating '/Users/jd/Source/daiquiri/dist/daiquiri-1.3.0-py2.py3-none-any.whl'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ 创建 '/Users/jd/Source/daiquiri/dist/daiquiri-1.3.0-py2.py3-none-any.whl'
- en: and adding '.' to it
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 并添加 '.' 到它
- en: adding 'daiquiri/__init__.py'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 添加 'daiquiri/__init__.py'
- en: adding 'daiquiri/formatter.py'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 添加 'daiquiri/formatter.py'
- en: adding 'daiquiri/handlers.py'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 添加 'daiquiri/handlers.py'
- en: --snip--
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: --省略--
- en: '*Listing 5-5: Calling setup.py bdist_wheel*'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-5：调用 setup.py bdist_wheel*'
- en: 'The bdist_wheel command creates a *.whl* file in the *dist* directory ➊. As
    with the Egg format, a Wheel archive is just a zip file with a different extension.
    However, Wheel archives do not require installation—you can load and run your
    code just by adding a slash followed by the name of your module:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: bdist_wheel 命令会在 *dist* 目录 ➊ 中创建一个 *.whl* 文件。与 Egg 格式一样，Wheel 归档也是一个具有不同扩展名的
    zip 文件。然而，Wheel 归档不需要安装——你只需添加一个斜杠，后跟模块名，就可以加载并运行代码：
- en: $ python wheel-0.21.0-py2.py3-none-any.whl/wheel -h
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: $ python wheel-0.21.0-py2.py3-none-any.whl/wheel -h
- en: 'usage: wheel [-h]'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '用法: wheel [-h]'
- en: '{keygen,sign,unsign,verify,unpack,install,install-'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '{keygen,sign,unsign,verify,unpack,install,install-'
- en: scripts,convert,help}
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本,转换,帮助}
- en: --snip--
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: --省略--
- en: 'positional arguments:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 定位参数：
- en: --snip--
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: --省略--
- en: 'You might be surprised to learn this is not a feature introduced by the Wheel
    format itself. Python can also run regular zip files, just like with Java’s *.jar*
    files:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会惊讶地发现，这并不是 Wheel 格式本身引入的功能。Python 也可以运行常规的 zip 文件，就像 Java 的 *.jar* 文件一样：
- en: python foobar.zip
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: python foobar.zip
- en: 'This is equivalent to:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这等同于：
- en: PYTHONPATH=foobar.zip python -m __main__
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: PYTHONPATH=foobar.zip python -m __main__
- en: 'In other words, the __main__ module for your program will be automatically
    imported from __main__.py. You can also import __main__ from a module you specify
    by appending a slash followed by the module name, just as with Wheel:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，你程序的 __main__ 模块会自动从 __main__.py 中导入。你也可以通过附加一个斜杠后跟模块名来从你指定的模块导入 __main__，就像
    Wheel 一样：
- en: python foobar.zip/mymod
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: python foobar.zip/mymod
- en: 'This is equivalent to:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这等同于：
- en: PYTHONPATH=foobar.zip python -m mymod.__main__
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: PYTHONPATH=foobar.zip python -m mymod.__main__
- en: One of the advantages of Wheel is that its naming conventions allow you to specify
    whether your distribution is intended for a specific architecture and/or Python
    implementation (CPython, PyPy, Jython, and so on). This is particularly useful
    if you need to distribute modules written in C.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Wheel 的一个优点是它的命名约定允许你指定你的分发是否面向特定架构和/或 Python 实现（如 CPython、PyPy、Jython 等）。如果你需要分发用
    C 编写的模块，这特别有用。
- en: By default, Wheel packages are tied to the major version of Python that you
    used to build them. When called with python2 setup.py bdist_wheel, the pattern
    of a Wheel filename will be something like *library-version-py2-none-any.whl*.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Wheel 包与构建它们时使用的 Python 主版本绑定。当用 python2 setup.py bdist_wheel 调用时，Wheel
    文件名的模式类似于 *library-version-py2-none-any.whl*。
- en: 'If your code is compatible with all major Python versions (that is, Python
    2 and Python 3), you can build a universal Wheel:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的代码兼容所有主流 Python 版本（即 Python 2 和 Python 3），你可以构建一个通用的 Wheel：
- en: python setup.py bdist_wheel --universal
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: python setup.py bdist_wheel --universal
- en: The resulting filename will be different and contains both Python major versions—something
    like *library-version-py2.py3-none-any.whl*. Building a universal Wheel avoids
    ending up with two different Wheels when only one would cover both Python major
    versions.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的文件名会有所不同，并且包含了两个 Python 主版本——类似于*library-version-py2.py3-none-any.whl*。构建一个通用的
    Wheel 可以避免只用一个 Wheel 覆盖两个 Python 主版本时，结果却生成两个不同的 Wheel。
- en: 'If you don’t want to pass the --universal flag each time you are building a
    Wheel, you can just add this to your *setup.cfg* file:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在每次构建 Wheel 时都传递 --universal 标志，你可以将以下内容添加到你的*setup.cfg*文件中：
- en: '[wheel]'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[wheel]'
- en: universal=1
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: universal=1
- en: If the Wheel you build contains binary programs or libraries (like a Python
    extension written in C), the binary Wheel might not be as portable as you imagine.
    It will work by default on some platforms, such as Darwin (macOS) or Microsoft
    Windows, but it might not work on all Linux distributions. The PEP 513 (*[https://www.python.org/dev/peps/pep-0513](https://www.python.org/dev/peps/pep-0513)*)
    targets this Linux problem by defining a new platform tag named manylinux1 and
    a minimal set of libraries that are guaranteed to be available on that platform.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你构建的 Wheel 包含二进制程序或库（例如用 C 编写的 Python 扩展），那么这个二进制 Wheel 可能并不像你想象的那样具有可移植性。它默认在一些平台上可用，比如
    Darwin（macOS）或 Microsoft Windows，但可能在所有 Linux 发行版上都无法工作。PEP 513 (*[https://www.python.org/dev/peps/pep-0513](https://www.python.org/dev/peps/pep-0513)*)
    针对这个 Linux 问题，通过定义一个名为 manylinux1 的新平台标签以及保证在该平台上可用的最小库集合来解决这个问题。
- en: Wheel is a great format for distributing ready-to-install libraries and applications,
    so you are encouraged to build and upload them to PyPI as well.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Wheel 是一个很好的格式，用于分发可直接安装的库和应用程序，因此建议你也将它们构建并上传到 PyPI。
- en: '**Sharing Your Work with the World**'
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**与世界分享你的工作**'
- en: Once you have a proper *setup.py* file, it is easy to build a source tarball
    that can be distributed. The sdist setuptools command does just that, as demonstrated
    in [Listing 5-6](ch05.xhtml#ch5list6).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了一个合适的 *setup.py* 文件，构建一个可以分发的源代码 tarball 变得很容易。sdist setuptools 命令正是做了这件事，正如
    [Listing 5-6](ch05.xhtml#ch5list6) 中所示。
- en: $ python setup.py sdist
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: $ python setup.py sdist
- en: running sdist
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 正在运行 sdist
- en: '[pbr] Generating AUTHORS'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '[pbr] 正在生成 AUTHORS'
- en: running egg_info
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 正在运行 egg_info
- en: writing requirements to ceilometer.egg-info/requires.txt
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 正在将依赖项写入 ceilometer.egg-info/requires.txt
- en: writing ceilometer.egg-info/PKG-INFO
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 正在将 ceilometer.egg-info/PKG-INFO 写入
- en: writing top-level names to ceilometer.egg-info/top_level.txt
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 正在将顶级名称写入 ceilometer.egg-info/top_level.txt
- en: writing dependency_links to ceilometer.egg-info/dependency_links.txt
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 正在将依赖链接写入 ceilometer.egg-info/dependency_links.txt
- en: writing entry points to ceilometer.egg-info/entry_points.txt
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 正在将入口点写入 ceilometer.egg-info/entry_points.txt
- en: '[pbr] Processing SOURCES.txt'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[pbr] 处理 SOURCES.txt'
- en: '[pbr] In git context, generating filelist from git'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '[pbr] 在 git 上生成文件列表'
- en: 'warning: no previously-included files matching ''*.pyc'' found anywhere in'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：没有找到任何匹配 '*.pyc' 的文件
- en: distribution
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 发布
- en: writing manifest file 'ceilometer.egg-info/SOURCES.txt'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 写入清单文件 'ceilometer.egg-info/SOURCES.txt'
- en: running check
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 运行检查
- en: copying setup.cfg -> ceilometer-2014.1.a6-g772e1a7
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 复制 setup.cfg -> ceilometer-2014.1.a6-g772e1a7
- en: Writing ceilometer-2014.1.a6-g772e1a7/setup.cfg
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 写入 ceilometer-2014.1.a6-g772e1a7/setup.cfg
- en: --snip--
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: --snip--
- en: Creating tar archive
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 tar 压缩包
- en: removing 'ceilometer-2014.1.a6.g772e1a7' (and everything under it)
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 移除 'ceilometer-2014.1.a6.g772e1a7'（以及其下的所有内容）
- en: '*Listing 5-6: Using setup.py sdist to build a source tarball*'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-6：使用 setup.py sdist 构建源代码 tar 包*'
- en: The sdist command creates a tarball under the *dist* directory of the source
    tree. The tarball contains all the Python modules that are part of the source
    tree. As seen in the previous section, you can also build Wheel archives using
    the bdist_wheel command. Wheel archives are a bit faster to install as they’re
    already in the correct format for installation.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: sdist 命令会在源代码树的 *dist* 目录下创建一个 tar 包。这个 tar 包包含了所有源代码树中的 Python 模块。如前一节所述，你也可以使用
    bdist_wheel 命令构建 Wheel 格式的归档。Wheel 格式的归档安装速度更快，因为它们已经是安装所需的正确格式。
- en: The final step to make that code accessible is to export your package somewhere
    users can install it via pip. That means publishing your project to PyPI.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让代码可以访问的最后一步是将你的包导出到用户可以通过pip安装的地方。这意味着将项目发布到PyPI。
- en: If it’s your first time exporting to PyPI, it pays to test out the publishing
    process in a safe sandbox rather than on the production server. You can use the
    PyPI staging server for this purpose; it replicates all the functionality of the
    main index but is solely for testing purposes.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是你第一次导出到PyPI，最好在一个安全的沙盒中测试发布过程，而不是在生产服务器上。你可以使用PyPI的测试服务器进行此目的；它复制了主索引的所有功能，但仅用于测试。
- en: 'The first step is to register your project on the test server. Start by opening
    your *~/.pypirc* file and adding these lines:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是将项目注册到测试服务器。首先打开你的 *~/.pypirc* 文件，并添加以下几行：
- en: '[distutils]'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '[distutils]'
- en: index-servers =
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: index-servers =
- en: testpypi [testpypi]
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: testpypi [testpypi]
- en: username = <your username>
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 用户名 = <你的用户名>
- en: password = <your password>
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: password = <你的密码>
- en: repository = https://testpypi.python.org/pypi
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库 = https://testpypi.python.org/pypi
- en: 'Save the file, and now you can register your project in the index:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件，现在你可以在索引中注册你的项目了：
- en: $ python setup.py register -r testpypi
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: $ python setup.py register -r testpypi
- en: running register
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 运行注册
- en: running egg_info
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 egg_info
- en: writing requirements to ceilometer.egg-info/requires.txt
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 写入依赖要求到 ceilometer.egg-info/requires.txt
- en: writing ceilometer.egg-info/PKG-INFO
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 写入 ceilometer.egg-info/PKG-INFO
- en: writing top-level names to ceilometer.egg-info/top_level.txt
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 写入顶级名称到 ceilometer.egg-info/top_level.txt
- en: writing dependency_links to ceilometer.egg-info/dependency_links.txt
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 写入依赖链接到 ceilometer.egg-info/dependency_links.txt
- en: writing entry points to ceilometer.egg-info/entry_points.txt
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 写入入口点到 ceilometer.egg-info/entry_points.txt
- en: '[pbr] Reusing existing SOURCES.txt'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '[pbr] 重用现有的 SOURCES.txt'
- en: running check
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 运行检查
- en: Registering ceilometer to https://testpypi.python.org/pypi
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 正在注册 ceilometer 到 https://testpypi.python.org/pypi
- en: 'Server response (200): OK'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器响应（200）：OK
- en: This connects to the test PyPI server instance and creates a new entry. Don’t
    forget to use the -r option; otherwise, the real production PyPI instance would
    be used!
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这会连接到测试 PyPI 服务器实例并创建一个新条目。别忘了使用 -r 选项；否则会使用真实的生产 PyPI 实例！
- en: Obviously, if a project with the same name is already registered there, the
    process will fail. Retry with a new name, and once you get your program registered
    and receive the OK response, you can upload a source distribution tarball, as
    shown in [Listing 5-7](ch05.xhtml#ch5list7).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，如果一个同名的项目已经在那注册过了，过程将会失败。请重新尝试使用一个新的名称，一旦你成功注册了程序并收到OK响应，你就可以上传源代码的tar包，参考[清单5-7](ch05.xhtml#ch5list7)。
- en: $ python setup.py sdist upload -r testpypi
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: $ python setup.py sdist upload -r testpypi
- en: running sdist
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 sdist
- en: '[pbr] Writing ChangeLog'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '[pbr] 写入 ChangeLog'
- en: '[pbr] Generating AUTHORS'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '[pbr] 生成 AUTHORS'
- en: running egg_info
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 egg_info
- en: writing requirements to ceilometer.egg-info/requires.txt
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 写入依赖要求到 ceilometer.egg-info/requires.txt
- en: writing ceilometer.egg-info/PKG-INFO
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 写入 ceilometer.egg-info/PKG-INFO
- en: writing top-level names to ceilometer.egg-info/top_level.txt
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 写入顶级名称到 ceilometer.egg-info/top_level.txt
- en: writing dependency_links to ceilometer.egg-info/dependency_links.txt
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 写入依赖链接到 ceilometer.egg-info/dependency_links.txt
- en: writing entry points to ceilometer.egg-info/entry_points.txt
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 写入入口点到 ceilometer.egg-info/entry_points.txt
- en: '[pbr] Processing SOURCES.txt'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '[pbr] 处理中 SOURCES.txt'
- en: '[pbr] In git context, generating filelist from git'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '[pbr] 在 git 环境中，从 git 生成文件列表'
- en: 'warning: no previously-included files matching ''*.pyc'' found anywhere in'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：没有找到匹配 '*.pyc' 的先前包含文件
- en: distribution
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 分发
- en: writing manifest file 'ceilometer.egg-info/SOURCES.txt'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 正在写入清单文件 'ceilometer.egg-info/SOURCES.txt'
- en: running check
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 正在运行检查
- en: creating ceilometer-2014.1.a6.g772e1a7
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 正在创建 ceilometer-2014.1.a6.g772e1a7
- en: --snip--
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: --省略--
- en: copying setup.cfg -> ceilometer-2014.1.a6.g772e1a7
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 正在复制 setup.cfg -> ceilometer-2014.1.a6.g772e1a7
- en: Writing ceilometer-2014.1.a6.g772e1a7/setup.cfg
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 正在写入 ceilometer-2014.1.a6.g772e1a7/setup.cfg
- en: Creating tar archive
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 正在创建 tar 存档
- en: removing 'ceilometer-2014.1.a6.g772e1a7' (and everything under it)
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 正在移除 'ceilometer-2014.1.a6.g772e1a7'（以及其下所有内容）
- en: running upload Submitting dist/ceilometer-2014.1.a6.g772e1a7.tar.gz to https://testpypi
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 正在上传 提交 dist/ceilometer-2014.1.a6.g772e1a7.tar.gz 到 https://testpypi
- en: .python.org/pypi
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: .python.org/pypi
- en: 'Server response (200): OK'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器响应 (200)：OK
- en: '*Listing 5-7: Uploading your tarball to PyPI*'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-7：将您的 tarball 上传到 PyPI*'
- en: Alternatively, you could upload a Wheel archive, as in [Listing 5-8](ch05.xhtml#ch5list8).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，您也可以上传一个 Wheel 存档，如 [清单 5-8](ch05.xhtml#ch5list8) 所示。
- en: $ python setup.py bdist_wheel upload -r testpypi
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: $ python setup.py bdist_wheel upload -r testpypi
- en: running bdist_wheel
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 正在运行 bdist_wheel
- en: running build
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 正在运行构建
- en: running build_py
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 正在运行 build_py
- en: running egg_info
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 正在运行 egg_info
- en: writing requirements to ceilometer.egg-info/requires.txt
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 正在将要求写入 ceilometer.egg-info/requires.txt
- en: writing ceilometer.egg-info/PKG-INFO
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 正在写入 ceilometer.egg-info/PKG-INFO
- en: writing top-level names to ceilometer.egg-info/top_level.txt
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 正在写入顶级名称到 ceilometer.egg-info/top_level.txt
- en: writing dependency_links to ceilometer.egg-info/dependency_links.txt
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 正在将依赖关系链接写入 ceilometer.egg-info/dependency_links.txt
- en: writing entry points to ceilometer.egg-info/entry_points.txt
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 正在将入口点写入 ceilometer.egg-info/entry_points.txt
- en: '[pbr] Reusing existing SOURCES.txt'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '[pbr] 正在重用现有 SOURCES.txt'
- en: installing to build/bdist.linux-x86_64/wheel
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 正在安装到 build/bdist.linux-x86_64/wheel
- en: running install
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 正在运行安装
- en: running install_lib
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 正在运行 install_lib
- en: creating build/bdist.linux-x86_64/wheel
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 正在创建 build/bdist.linux-x86_64/wheel
- en: --snip--
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: --省略--
- en: creating build/bdist.linux-x86_64/wheel/ceilometer-2014.1.a6.g772e1a7
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 正在创建 build/bdist.linux-x86_64/wheel/ceilometer-2014.1.a6.g772e1a7
- en: .dist-info/WHEEL
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: .dist-info/WHEEL
- en: running upload
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 正在运行上传
- en: Submitting /home/jd/Source/ceilometer/dist/ceilometer-2014.1.a6
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 正在提交 /home/jd/Source/ceilometer/dist/ceilometer-2014.1.a6
- en: .g772e1a7-py27-none-any.whl to https://testpypi.python.org/pypi
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: .g772e1a7-py27-none-any.whl 到 https://testpypi.python.org/pypi
- en: 'Server response (200): OK'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器响应 (200)：OK
- en: '*Listing 5-8: Uploading a Wheel archive to PyPI*'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-8：将 Wheel 存档上传到 PyPI*'
- en: 'Once those operations are finished, you and other users can search for the
    uploaded packages on the PyPI staging server, and even install those packages
    using pip, by specifying the test server using the -i option:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些操作后，您和其他用户可以在 PyPI 阶段服务器上搜索上传的包，甚至可以通过指定测试服务器并使用 -i 选项，使用 pip 安装这些包：
- en: $ pip install -i https://testpypi.python.org/pypi ceilometer
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: $ pip install -i https://testpypi.python.org/pypi ceilometer
- en: 'If everything checks out, you can upload your project to the main PyPI server.
    Just make sure to add your credentials and the details for the server to your
    ~/.pypirc file first, like so:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，您可以将项目上传到主 PyPI 服务器。只需确保首先将您的凭据和服务器详细信息添加到 ~/.pypirc 文件，如下所示：
- en: '[distutils]'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '[distutils]'
- en: index-servers =
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 索引服务器 =
- en: pypi
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: pypi
- en: testpypi
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: testpypi
- en: '[pypi]'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '[pypi]'
- en: username = <your username>
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 用户名 = <您的用户名>
- en: password = <your password> [testpypi]
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 密码 = <您的密码> [testpypi]
- en: repository = https://testpypi.python.org/pypi
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库 = https://testpypi.python.org/pypi
- en: username = <your username>
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 用户名 = <您的用户名>
- en: password = <your password>
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 密码 = <您的密码>
- en: Now if you run register and upload with the -r pypi switch, your package should
    be uploaded to PyPI.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您使用 -r pypi 切换运行注册和上传命令，您的包应上传到 PyPI。
- en: '**NOTE**'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*PyPI can keep several versions of your software in its index, allowing you
    to install specific and older versions, if you ever need to. Just pass the version
    number to the pip install command; for example, pip install foobar==1.0.2.*'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '*PyPI 可以在其索引中保留多个版本的您的软件，允许您在需要时安装特定或较旧的版本。只需在 pip install 命令中传递版本号；例如，pip
    install foobar==1.0.2。*'
- en: This process is straightforward to use and allows for any number of uploads.
    You can release your software as often as you want, and your users can install
    and update as often as they need.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程简单易用，允许进行任意次数的上传。您可以根据需要频繁发布您的软件，用户也可以随时安装和更新。
- en: '**Entry Points**'
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**入口点**'
- en: You may have already used setuptools entry points without knowing anything about
    them. Software distributed using setuptools includes important metadata describing
    features such as its required dependencies and—more relevantly to this topic—a
    list of *entry points*. Entry points are methods by which other Python programs
    can discover the dynamic features a package provides.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经在不知情的情况下使用过 setuptools 入口点。使用 setuptools 分发的软件包括描述其所需依赖项等特性的重要元数据——更与本主题相关的是，包含了一个
    *入口点* 的列表。入口点是其他 Python 程序可以通过它们发现一个包所提供的动态特性的方式。
- en: 'The following example shows how to provide an entry point named rebuildd in
    the console_scripts entry point group:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何在 console_scripts 入口点组中提供一个名为 rebuildd 的入口点：
- en: '#!/usr/bin/python'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '#!/usr/bin/python'
- en: from distutils.core import setup
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: from distutils.core import setup
- en: setup(name="rebuildd",
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: setup(name="rebuildd",
- en: description="Debian packages rebuild tool",
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: description="Debian 包重建工具",
- en: author="Julien Danjou",
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: author="Julien Danjou",
- en: author_email="acid@debian.org",
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: author_email="acid@debian.org",
- en: url="http://julien.danjou.info/software/rebuildd.html",
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: url="http://julien.danjou.info/software/rebuildd.html",
- en: entry_points={
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: entry_points={
- en: '''console_scripts'': ['
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '''console_scripts'': ['
- en: '''rebuildd = rebuildd:main'','
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '''rebuildd = rebuildd:main'','
- en: '],'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '],'
- en: '},'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '},'
- en: packages=['rebuildd'])
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: packages=['rebuildd'])
- en: 'Any Python package can register entry points. Entry points are organized in
    groups: each group is made of a list of key and value pairs. Those pairs use the
    format path.to.module:variable_name. In the previous example, the key is rebuildd,
    and the value is rebuildd:main.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 任何 Python 包都可以注册入口点。入口点按组进行组织：每组由一系列键值对组成。这些键值对采用 path.to.module:variable_name
    的格式。在前面的示例中，键是 rebuildd，值是 rebuildd:main。
- en: The list of entry points can be manipulated using various tools, from setuptools
    to epi, as I’ll show here. In the following sections, we discuss how we can use
    entry points to add extensibility to our software.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 入口点的列表可以使用各种工具进行操作，从 setuptools 到 epi，正如我在这里将展示的那样。在接下来的部分中，我们将讨论如何利用入口点为我们的软件添加扩展性。
- en: '***Visualizing Entry Points***'
  id: totrans-277
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***可视化入口点***'
- en: The easiest way to visualize the entry points available in a package is to use
    a package called entry point inspector. You can install it by running pip install
    entry-point-inspector. When installed, it provides the command epi that you can
    run from your terminal to interactively discover the entry points provided by
    installed packages. [Listing 5-9](ch05.xhtml#ch5list9) shows an example of running
    epi group list on my system.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 查看包中可用入口点的最简单方法是使用名为 entry point inspector 的包。你可以通过运行 `pip install entry-point-inspector`
    来安装它。安装后，它提供了一个名为 epi 的命令，你可以从终端运行该命令，交互式地发现已安装软件包提供的入口点。[列表 5-9](ch05.xhtml#ch5list9)
    展示了我在系统上运行 epi group list 的示例。
- en: $ epi group list
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: $ epi group list
- en: '---------------------------'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '---------------------------'
- en: '| Name                    |'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '| 名称                    |'
- en: '--------------------------'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '--------------------------'
- en: '| console_scripts |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| console_scripts |'
- en: '| distutils.commands |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| distutils.commands |'
- en: '| distutils.setup_keywords |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| distutils.setup_keywords |'
- en: '| egg_info.writers |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| egg_info.writers |'
- en: '| epi.commands |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| epi.commands |'
- en: '| flake8.extension |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| flake8.extension |'
- en: '| setuptools.file_finders |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| setuptools.file_finders |'
- en: '| setuptools.installation |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| setuptools.installation |'
- en: '--------------------------'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '--------------------------'
- en: '*Listing 5-9: Getting a list of entry point groups*'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-9：获取入口点组的列表*'
- en: The output from epi group list in [Listing 5-9](ch05.xhtml#ch5list9) shows the
    different packages on a system that provide entry points. Each item in this table
    is the name of an entry point group. Note that this list includes console_scripts,
    which we’ll discuss shortly. We can use the epi command with the show command
    to show details of a particular entry point group, as in [Listing 5-10](ch05.xhtml#ch5list10).
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5-9](ch05.xhtml#ch5list9) 中来自 epi group list 的输出显示了系统中提供入口点的不同软件包。表格中的每一项是一个入口点组的名称。请注意，此列表包括
    console_scripts，我们稍后会讨论。我们可以使用 epi 命令与 show 命令来显示特定入口点组的详细信息，如[列表 5-10](ch05.xhtml#ch5list10)所示。'
- en: $ epi group show console_scripts
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: $ epi group show console_scripts
- en: '-------------------------------------------------'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '-------------------------------------------------'
- en: '| Name     | Module   | Member | Distribution | Error |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| 名称     | 模块   | 成员 | 分发版本 | 错误 |'
- en: '-------------------------------------------------'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '-------------------------------------------------'
- en: '| coverage | coverage | main   | coverage 3.4 |       |'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '| coverage | coverage | main   | coverage 3.4 |       |'
- en: '*Listing 5-10: Showing details of an entry point group*'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-10：显示入口点组的详细信息*'
- en: We can see that in the group console_scripts, an entry point named coverage
    refers to the member main of the module coverage. This entry point in particular,
    provided by the package coverage 3.4, indicates which Python function to call
    when the command line script coverage is executed. Here, the function coverage.main
    is to be called.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，在 group console_scripts 中，有一个名为 coverage 的入口点指向模块 coverage 的 main 成员。这个特定的入口点由
    coverage 3.4 包提供，指示在执行命令行脚本 coverage 时调用哪个 Python 函数。在这里，调用的函数是 coverage.main。
- en: The epi tool is just a thin layer on top of the complete Python library pkg_resources.
    This module allows us to discover entry points for any Python library or program.
    Entry points are valuable for various things, including console scripts and dynamic
    code discovery, as you’ll see in the next few sections.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: epi 工具只是完整 Python 库 pkg_resources 上的一层薄薄的封装。这个模块允许我们发现任何 Python 库或程序的入口点。入口点对于多种用途都很有价值，包括控制台脚本和动态代码发现，正如你将在接下来的几节中看到的。
- en: '***Using Console Scripts***'
  id: totrans-302
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用控制台脚本***'
- en: When writing a Python application, you almost always have to provide a launchable
    program—a Python script that the end user can run—that needs to be installed inside
    a directory somewhere in the system path.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写 Python 应用程序时，几乎总是需要提供一个可启动的程序——一个最终用户可以运行的 Python 脚本——该脚本需要安装在系统路径的某个目录中。
- en: 'Most projects have a launchable program similar to this:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数项目都有一个类似这样的可启动程序：
- en: '#!/usr/bin/python'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '#!/usr/bin/python'
- en: import sys
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: import sys
- en: import mysoftware
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: import mysoftware
- en: mysoftware.SomeClass(sys.argv).run()
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: mysoftware.SomeClass(sys.argv).run()
- en: 'This kind of script is a best-case scenario: many projects have a much longer
    script installed in the system path. However, such scripts pose some major issues:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这种脚本是最理想的情况：许多项目在系统路径中安装的是更长的脚本。然而，这种脚本也带来了一些重大问题：
- en: There’s no way the user can know where the Python interpreter is or which version
    it uses.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户无法知道 Python 解释器的位置或它使用的是哪个版本。
- en: This script leaks binary code that can’t be imported by software or unit tests.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该脚本泄露了无法被软件或单元测试导入的二进制代码。
- en: There’s no easy way to define where to install this script.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有简单的方法来定义脚本的安装位置。
- en: It’s not obvious how to install this in a portable way (for example, on both
    Unix and Windows).
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种方式并不明显如何以可移植的方式安装（例如，既可以在 Unix 上，也可以在 Windows 上）。
- en: 'Helping us circumvent these problems, setuptools offers the console_scripts
    feature. This entry point can be used to make setuptools install a tiny program
    in the system path that calls a specific function in one of your modules. With
    setuptools, you can specify a function call to start your program by setting up
    a key/value pair in the console_scripts entry point group: the key is the script
    name that will be installed, and the value is the Python path to your function
    (something like my_module.main).'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助我们绕过这些问题，setuptools 提供了 console_scripts 功能。这个入口点可以用来让 setuptools 在系统路径中安装一个小程序，该程序调用你模块中的特定函数。使用
    setuptools，你可以通过在 console_scripts 入口点组中设置键/值对来指定启动程序的函数调用：键是将要安装的脚本名称，值是指向你函数的
    Python 路径（类似 my_module.main）。
- en: 'Let’s imagine a foobar program that consists of a client and a server. Each
    part is written in its module—foobar.client and foobar.server, respectively, in
    *foobar/client.py*:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一个 foobar 程序，它由客户端和服务器两部分组成。每一部分都写在自己的模块中——分别是 *foobar.client* 和 *foobar.server*，位于
    *foobar/client.py* 中：
- en: 'def main():'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 'def main():'
- en: print("Client started")
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: print("Client started")
- en: 'And in *foobar/server.py*:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 以及在 *foobar/server.py* 中：
- en: 'def main():'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 'def main():'
- en: print("Server started")
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: print("Server started")
- en: Of course, this program doesn’t do much of anything—our client and server don’t
    even talk to each other. For our example, though, they just need to print a message
    letting us know they have started successfully.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个程序并没有做太多的事情——我们的客户端和服务器甚至没有互相通信。对于我们的例子来说，它们只需要打印一条消息，告诉我们它们已经成功启动。
- en: We can now write the following *setup.py* file in the root directory with entry
    points defined in *setup.py*.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在根目录中编写以下 *setup.py* 文件，其中在 *setup.py* 中定义了入口点。
- en: from setuptools import setup
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: from setuptools import setup
- en: setup(
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: setup(
- en: name="foobar",
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: name="foobar",
- en: version="1",
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: version="1",
- en: description="Foo!",
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: description="Foo!",
- en: author="Julien Danjou",
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: author="Julien Danjou",
- en: author_email="julien@danjou.info",
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: author_email="julien@danjou.info",
- en: packages=["foobar"],
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: packages=["foobar"],
- en: entry_points={
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: entry_points={
- en: '"console_scripts": ['
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '"console_scripts": ['
- en: ➊ "foobard = foobar.server:main",
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ "foobard = foobar.server:main",
- en: '"foobar = foobar.client:main",'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '"foobar = foobar.client:main",'
- en: '],'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '],'
- en: '},'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '},'
- en: )
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: We define entry points using the format module.submodule:function. You can see
    here that we’ve defined an entry point each for both client and server ➊.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用格式 module.submodule:function 来定义入口点。你可以看到，这里我们为客户端和服务器分别定义了一个入口点 ➊。
- en: When python setup.py install is run, setuptools will create a script that will
    look like the one in [Listing 5-11](ch05.xhtml#ch5list11).
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行python setup.py install时，setuptools将创建一个类似[Listing 5-11](ch05.xhtml#ch5list11)中的脚本。
- en: '#!/usr/bin/python'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '#!/usr/bin/python'
- en: 'EASY-INSTALL-ENTRY-SCRIPT: ''foobar==1'',''console_scripts'',''foobar'''
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 'EASY-INSTALL-ENTRY-SCRIPT: ''foobar==1'',''console_scripts'',''foobar'''
- en: __requires__ = 'foobar==1'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: __requires__ = 'foobar==1'
- en: import sys
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: import sys
- en: from pkg_resources import load_entry_point
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: from pkg_resources import load_entry_point
- en: 'if __name__ == ''__main__'':'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: sys.exit(
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: sys.exit(
- en: load_entry_point('foobar==1', 'console_scripts', 'foobar')()
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: load_entry_point('foobar==1', 'console_scripts', 'foobar')()
- en: )
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '*Listing 5-11: A console script generated by setuptools*'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 5-11: setuptools生成的控制台脚本*'
- en: This code scans the entry points of the foobar package and retrieves the foobar
    key from the console_scripts group, which is used to locate and run the corresponding
    function. The return value of the load_entry_point will then be a reference to
    the function foobar.client.main, which will be called without any arguments and
    whose return value will be used as an exit code.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码扫描foobar包的入口点，并从console_scripts组中检索foobar键，用于定位并运行相应的函数。load_entry_point的返回值将是对foobar.client.main函数的引用，该函数将不带任何参数地被调用，并且它的返回值将作为退出码。
- en: Notice that this code uses pkg_resources to discover and load entry point files
    from within your Python programs.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这段代码使用pkg_resources来发现并加载Python程序中的入口点文件。
- en: '**NOTE**'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you’re using pbr on top of setuptools, the generated script is simpler
    (and therefore faster) than the default one built by setuptools, as it will call
    the function you wrote in the entry point without having to search the entry point
    list dynamically at runtime.*'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你在setuptools上使用pbr，生成的脚本比setuptools默认构建的脚本更简单（因此更快），因为它会直接调用你在入口点中编写的函数，而无需在运行时动态搜索入口点列表。*'
- en: Using console scripts is a technique that removes the burden of writing portable
    scripts, while ensuring that your code stays in your Python package and can be
    imported (and tested) by other programs.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 使用控制台脚本是一种技术，它消除了编写可移植脚本的负担，同时确保你的代码保留在Python包中，并且可以被其他程序导入（和测试）。
- en: '***Using Plugins and Drivers***'
  id: totrans-355
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用插件和驱动程序***'
- en: Entry points make it easy to discover and dynamically load code deployed by
    other packages, but this is not their only use. Any application can propose and
    register entry points and groups and then use them as it wishes.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 入口点使得发现和动态加载由其他包部署的代码变得容易，但这并不是它们唯一的用途。任何应用程序都可以提议并注册入口点和组，然后按需使用它们。
- en: In this section, we’re going to create a cron-style daemon pycrond that will
    allow any Python program to register a command to be run once every few seconds
    by registering an entry point in the group pytimed. The attribute indicated by
    this entry point should be an object that returns number_of_seconds, callable.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个类似cron风格的守护进程pycrond，它将允许任何Python程序通过在pytimed组中注册入口点来注册一个命令，使得该命令每隔几秒钟执行一次。该入口点所指示的属性应为一个返回number_of_seconds和callable的对象。
- en: 'Here’s our implementation of pycrond using pkg_resources to discover entry
    points, in a program I’ve named *pytimed.py*:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们使用pkg_resources来发现入口点并在一个名为*pytimed.py*的程序中实现pycrond的代码：
- en: import pkg_resources
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: import pkg_resources
- en: import time
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: import time
- en: 'def main():'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 'def main():'
- en: seconds_passed = 0
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: seconds_passed = 0
- en: 'while True:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: 'for entry_point in pkg_resources.iter_entry_points(''pytimed''):'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 'for entry_point in pkg_resources.iter_entry_points(''pytimed''):'
- en: 'try:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 'try:'
- en: seconds, callable = entry_point.load()()
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: seconds, callable = entry_point.load()()
- en: 'except:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 'except:'
- en: '# Ignore failure'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '# 忽略失败'
- en: pass
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: pass
- en: 'else:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: 'if seconds_passed % seconds == 0:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 'if seconds_passed % seconds == 0:'
- en: callable()
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: callable()
- en: time.sleep(1)
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: time.sleep(1)
- en: seconds_passed += 1
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: seconds_passed += 1
- en: This program consists of an infinite loop that iterates over each entry point
    of the pytimed group. Each entry point is loaded using the load() method. The
    program then calls the returned method, which needs to return the number of seconds
    to wait before calling the callable as well as the aforementioned callable.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序由一个无限循环组成，循环遍历pytimed组的每个入口点。每个入口点通过load()方法加载。程序随后调用返回的方法，该方法需要返回等待的秒数，并且还需要返回前面提到的可调用对象。
- en: 'The program in *pytimed.py* is a very simplistic and naive implementation,
    but it is sufficient for our example. Now we can write another Python program,
    named *hello.py*, that needs one of its functions called on a periodic basis:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '*pytimed.py* 中的程序是一个非常简化且天真的实现，但足以满足我们的示例需求。现在我们可以编写另一个 Python 程序，命名为 *hello.py*，它需要定期调用其中的某个函数：'
- en: 'def print_hello():'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '定义 print_hello():'
- en: print("Hello, world!")
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: print("你好，世界！")
- en: 'def say_hello():'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '定义 say_hello():'
- en: return 2, print_hello
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 2, print_hello
- en: Once we have that function defined, we register it using the appropriate entry
    points in *setup.py*.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了该函数，就使用适当的扩展点在 *setup.py* 中注册它。
- en: from setuptools import setup
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 从 setuptools 导入 setup
- en: setup(
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: setup(
- en: name="hello",
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: name="hello",
- en: version="1",
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: version="1",
- en: packages=["hello"],
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: packages=["hello"],
- en: entry_points={
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: entry_points={
- en: '"pytimed": ['
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '"pytimed": ['
- en: '"hello = hello:say_hello",'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '"hello = hello:say_hello",'
- en: '],'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '],'
- en: '},)'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '},)'
- en: The *setup.py* script registers an entry point in the group pytimed with the
    key hello and the value pointing to the function hello.say_hello. Once that package
    is installed using that *setup.py*—for example, using pip install—the pytimed
    script can detect the newly added entry point.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '*setup.py* 脚本在 pytimed 组中注册了一个名为 hello 的扩展点，其值指向函数 hello.say_hello。一旦使用该 *setup.py*
    安装了该包—例如，使用 pip install—pytimed 脚本就能检测到新添加的扩展点。'
- en: 'At startup, pytimed will scan the group pytimed and find the key hello. It
    will then call the hello.say_hello function, getting two values: the number of
    seconds to wait between each call and the function to call, 2 seconds and print_hello
    in this case. By running the program, as we do in [Listing 5-12](ch05.xhtml#ch5list12),
    you can see “Hello, world!” printed on the screen every 2 seconds.'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动时，pytimed 会扫描 pytimed 组并找到 key 为 hello 的扩展。然后，它会调用 hello.say_hello 函数，获取两个值：每次调用之间等待的秒数和要调用的函数，在此示例中为
    2 秒和 print_hello。通过运行该程序，就像我们在 [列表 5-12](ch05.xhtml#ch5list12) 中所做的那样，你可以看到每隔
    2 秒就会在屏幕上打印出“你好，世界！”。
- en: '>>> import pytimed'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 导入 pytimed'
- en: '>>> pytimed.main()'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> pytimed.main()'
- en: Hello, world!
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 你好，世界！
- en: Hello, world!
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 你好，世界！
- en: Hello, world!
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 你好，世界！
- en: '*Listing 5-12: Running pytimed*'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-12: 运行 pytimed*'
- en: 'The possibilities this mechanism offers are immense: you can build driver systems,
    hook systems, and extensions easily and generically. Implementing this mechanism
    by hand in every program you make would be tedious, but fortunately, there’s a
    Python library that can take care of the boring parts for us.'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 这个机制提供的可能性是巨大的：你可以轻松且通用地构建驱动系统、钩子系统和扩展。每个程序都手动实现这个机制会很繁琐，但幸运的是，有一个 Python 库可以为我们处理这些枯燥的部分。
- en: 'The stevedore library provides support for dynamic plugins based on the same
    mechanism demonstrated in our previous examples. The use case in this example
    is already simplistic, but we can still simplify it further in this script, *pytimed_stevedore.py*:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: stevedore 库提供了对基于相同机制的动态插件的支持，正如我们在前面的示例中所展示的那样。本示例中的用例已经非常简化，但我们仍然可以在这个脚本中进一步简化它，*pytimed_stevedore.py*：
- en: from stevedore.extension import ExtensionManager
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 从 stevedore.extension 导入 ExtensionManager
- en: import time
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 time
- en: 'def main():'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '定义 main():'
- en: seconds_passed = 0
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: seconds_passed = 0
- en: extensions = ExtensionManager('pytimed', invoke_on_load=True)
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: extensions = ExtensionManager('pytimed', invoke_on_load=True)
- en: 'while True:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: 'for extension in extensions:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 extensions 中的每个扩展：
- en: 'try:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试：
- en: 'seconds, callable = extension.obj except:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 'seconds, callable = extension.obj 除外:'
- en: '# Ignore failure'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '# 忽略失败'
- en: pass
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: pass
- en: 'else:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 否则：
- en: 'if seconds_passed % seconds == 0:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 seconds_passed % seconds == 0:'
- en: callable()
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: callable()
- en: time.sleep(1)
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: time.sleep(1)
- en: seconds_passed += 1
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: seconds_passed += 1
- en: The ExtensionManager class of stevedore provides a simple way to load all extensions
    of an entry point group. The name is passed as a first argument. The argument
    invoke_on_load=True makes sure that each function of the group is called once
    discovered. This makes the results accessible directly from the obj attribute
    of the extension.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: stevedore 的 ExtensionManager 类提供了一种简单的方法来加载所有扩展点组的扩展。名称作为第一个参数传入。参数 invoke_on_load=True
    确保在每个扩展被发现时，其组内的每个函数都会被调用一次。这使得结果可以直接通过扩展的 obj 属性访问。
- en: If you look through the stevedore documentation, you will see that ExtensionManager
    has a variety of subclasses that can handle different situations, such as loading
    specific extensions based on their names or the result of a function. All of those
    are commonly used models you can apply to your program in order to implement those
    patterns directly.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看 stevedore 文档，你会发现 ExtensionManager 有多种子类，可以处理不同的情况，比如根据扩展名称或函数的结果加载特定的扩展。这些都是常用的模式，你可以将它们应用到你的程序中，以直接实现这些模式。
- en: For example, we might want to load and run only one extension from our entry
    point group. Leveraging the stevedore.driver.DriverManager class allows us to
    do that, as [Listing 5-13](ch05.xhtml#ch5list13) shows.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可能只想从我们的入口点组加载并运行一个扩展。利用stevedore.driver.DriverManager类可以实现这一点，正如[列表5-13](ch05.xhtml#ch5list13)所示。
- en: from stevedore.driver import DriverManager
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: from stevedore.driver import DriverManager
- en: import time
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: import time
- en: 'def main(name):'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 'def main(name):'
- en: seconds_passed = 0
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: seconds_passed = 0
- en: seconds, callable = DriverManager('pytimed', name, invoke_on_load=True).
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: seconds, callable = DriverManager('pytimed', name, invoke_on_load=True).
- en: driver
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: driver
- en: 'while True:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: 'if seconds_passed % seconds == 0:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 'if seconds_passed % seconds == 0:'
- en: callable()
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: callable()
- en: time.sleep(1)
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: time.sleep(1)
- en: seconds_passed += 1
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: seconds_passed += 1
- en: main("hello")
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: main("hello")
- en: '*Listing 5-13: Using stevedore to run a single extension from an entry point*'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表5-13：使用stevedore从入口点运行单个扩展*'
- en: In this case, only one extension is loaded and selected by name. This allows
    us to quickly build a *driver system* in which only one extension is loaded and
    used by a program.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，只有一个扩展根据名称被加载并选择。这使得我们可以快速构建一个*驱动系统*，在其中只有一个扩展被程序加载并使用。
- en: '**Summary**'
  id: totrans-435
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: The packaging ecosystem in Python has a bumpy history; however, the situation
    is now settling. The setuptools library provides a complete solution to packaging,
    not only to transport your code in different formats and upload it to PyPI, but
    also to handle connection with other software and libraries via entry points.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: Python的打包生态系统有一段坎坷的历史；然而，目前情况正在稳定。setuptools库提供了完整的打包解决方案，不仅能将你的代码以不同的格式传输并上传到PyPI，还能通过入口点与其他软件和库进行连接。
- en: '**Nick Coghlan on Packaging**'
  id: totrans-437
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Nick Coghlan谈打包**'
- en: Nick is a Python core developer working at Red Hat. He has written several PEP
    proposals, including PEP 426 (Metadata for Python Software Packages 2.0), and
    he is acting as delegate for our Benevolent Dictator for Life, Guido van Rossum,
    author of Python.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: Nick是Red Hat的Python核心开发人员。他撰写了几份PEP提案，包括PEP 426（Python软件包元数据2.0），并且他作为我们的终身仁慈独裁者Guido
    van Rossum的代表，Guido是Python的作者。
- en: '**The number of packaging solutions (distutils, setuptools, distutils2, distlib,
    bento, pbr, and so on) for Python is quite extensive. In your opinion, what are
    the reasons for such fragmentation and divergence?**'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python的打包解决方案（distutils、setuptools、distutils2、distlib、bento、pbr等）种类繁多。你认为这种碎片化和分歧的原因是什么？**'
- en: The short answer is that software publication, distribution, and integration
    is a complex problem with plenty of room for multiple solutions tailored for different
    use cases. In my recent talks on this, I have noted that the problem is mainly
    one of age, with the different packaging tools being born into different eras
    of software distribution.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，软件发布、分发和集成是一个复杂的问题，仍有很多空间可以为不同的使用场景提供多种解决方案。在我最近的讲座中，我提到这个问题主要与时间有关，因为不同的打包工具诞生于软件分发的不同时代。
- en: '**PEP 426, which defines a new metadata format for Python packages, is still
    fairly recent and not yet approved. How do you think it will tackle current packaging
    problems?**'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '**PEP 426定义了Python包的新元数据格式，仍然相对较新，尚未批准。你认为它将如何解决当前的打包问题？**'
- en: PEP 426 originally started as part of the Wheel format definition, but Daniel
    Holth realized that Wheel could work with the existing metadata format defined
    by setuptools. PEP 426 is thus a consolidation of the existing setuptools metadata
    with some of the ideas from distutils2 and other packaging systems (such as RPM
    and npm). It addresses some of the frustrations encountered with existing tools
    (for example, with cleanly separating different kinds of dependencies).
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: PEP 426最初作为Wheel格式定义的一部分开始，但Daniel Holth意识到Wheel可以与setuptools定义的现有元数据格式兼容。因此，PEP
    426是现有setuptools元数据与distutils2和其他打包系统（如RPM和npm）的一些理念的整合。它解决了一些现有工具所遇到的挫折（例如，清晰地区分不同类型的依赖）。
- en: The main gains will be a REST API on PyPI offering full metadata access, as
    well as (hopefully) the ability to automatically generate distribution policy–compliant
    packages from upstream metadata.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的收益将是PyPI上的REST API，提供完整的元数据访问，以及（希望）能够根据上游元数据自动生成符合分发策略的包。
- en: '**The Wheel format is somewhat recent and not widely used yet, but it seems
    promising. Why is it not part of the Standard Library?**'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '**Wheel格式相对较新，尚未广泛使用，但它似乎很有前景。为什么它不是标准库的一部分？**'
- en: 'It turns out the Standard Library is not really a suitable place for packaging
    standards: it evolves too slowly, and an addition to a later version of the Standard
    Library cannot be used with earlier versions of Python. So, at the Python language
    summit earlier this year, we tweaked the PEP process to allow distutils-sig to
    manage the full approval cycle for packaging-related PEPs, and python-dev will
    only be involved for proposals that involve changing CPython directly (such as
    pip bootstrapping).'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，标准库并不是一个适合用于打包标准的地方：它演化得太慢，而且标准库的新增功能不能在 Python 的早期版本中使用。因此，在今年早些时候的 Python
    语言峰会上，我们调整了 PEP 流程，允许 distutils-sig 管理与打包相关的 PEP 的完整审批周期，python-dev 只会参与涉及直接修改
    CPython 的提案（如 pip 启动）。
- en: '**What is the future for **Wheel** packages?**'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '**Wheel** 包的未来是什么？'
- en: We still have some tweaks to make before Wheel is suitable for use on Linux.
    However, pip is adopting Wheel as an alternative to the Egg format, allowing local
    caching of builds for fast virtual environment creation, and PyPI allows uploads
    of Wheel archives for Windows and macOS.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Wheel 适用于 Linux 之前，我们还需要做一些调整。不过，pip 已经将 Wheel 作为替代 Egg 格式的方法，允许本地缓存构建文件，以便快速创建虚拟环境，而
    PyPI 也允许上传适用于 Windows 和 macOS 的 Wheel 包。
