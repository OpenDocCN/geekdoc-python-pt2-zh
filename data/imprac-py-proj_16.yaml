- en: '**16'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**16'
- en: FINDING FRAUDS WITH BENFORD’S LAW**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用本福德定律发现欺诈行为**
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: Prior to the invention of electronic calculators, if you needed to take the
    log of a number, you looked it up in a table. Astronomer Simon Newcomb used such
    tables, and in 1881, he noticed that the pages in the front, used for numbers
    beginning with the lowest digits, were more worn than those in the back. From
    this mundane observation, he realized that—at least for measurements and constants
    in nature—the leading digits were much more likely to be small than large. He
    published a short article about it and moved on.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在电子计算器发明之前，如果需要计算一个数字的对数，你会查找表格。天文学家西蒙·纽科姆使用了这样的表格，在1881年，他注意到，用来查找以最小数字开头的数字的前面几页比后面的页数更磨损。通过这一平凡的观察，他意识到——至少对于自然界的度量和常数——领先数字小的可能性远大于大的。他发表了一篇简短的文章，并继续前行。
- en: For decades, this statistical curiosity, like Tolkien’s One Ring, “passed out
    of all knowledge.” Then, in 1938, physicist Frank Benford rediscovered and confirmed
    the phenomenon by collecting over 20,000 samples of real-world numbers, using
    data sources as diverse as the measurements of rivers, street addresses, numbers
    contained in *Reader’s Digest* magazine, molecular weights, baseball statistics,
    death rates, and more. As the person who popularized this scientific discovery,
    he got all the credit.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 几十年来，这一统计学上的好奇现象，如同托尔金的“魔戒”，“消失在所有人的记忆中”。直到1938年，物理学家弗兰克·本福德通过收集超过20,000个真实世界数字样本重新发现并确认了这一现象，数据来源包括河流测量、街道地址、*《读者文摘》*杂志中的数字、分子质量、棒球统计、死亡率等各类数据。作为普及这一科学发现的人，他获得了所有的荣誉。
- en: According to *Benford’s law*, also known as the *first-digit law*, the frequency
    of occurrence of the leading digits in naturally occurring numerical distributions
    is predictable and nonuniform. In fact, a given number is six times more likely
    to start with a 1 than a 9! This is very counterintuitive, as most people would
    expect a uniform distribution, with each number having a one in nine (11.1 percent)
    chance of occupying the first slot. Due to this cognitive disconnect, Benford’s
    law has become a useful tool for fraud detection in financial, scientific, and
    election data.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 根据*本福德定律*，也称为*首位数字定律*，自然发生的数字分布中，领先数字的出现频率是可预测的且不均匀的。事实上，一个数字以1开头的概率是以9开头的六倍！这一点非常反直觉，因为大多数人会预期数字的分布是均匀的，每个数字有九分之一（11.1%）的概率占据首位。由于这种认知上的脱节，本福德定律已成为金融、科学和选举数据中用于欺诈检测的有力工具。
- en: In this chapter, you’ll write a Python program that compares real-life datasets
    to Benford’s law and determines whether they appear fraudulent or not. You’ll
    also dust off matplotlib one last time to add a useful visual component to the
    analysis. For a dataset, you’ll use votes cast in the contentious 2016 US presidential
    election.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将编写一个Python程序，将现实生活中的数据集与本福德定律进行比较，并判断它们是否可能存在欺诈行为。你还将最后一次使用matplotlib，为分析增添一个有用的可视化组件。数据集将使用2016年美国总统选举中的选票。
- en: '**Project #24: Benford’s Law of Leading Digits**'
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**项目#24：领先数字的本福德定律**'
- en: '[Figure 16-1](ch16.xhtml#ch16fig1) depicts a bar chart of the leading significant
    digits in a set of numbers following Benford’s law. Surprisingly, scale doesn’t
    matter. A tabulation of the length of Australian roads will follow Benford’s law
    whether it is in miles, kilometers, or cubits! As a statistical principle, it
    is *scale invariant*.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '[图16-1](ch16.xhtml#ch16fig1)展示了遵循本福德定律的一组数字中领先有效数字的条形图。令人惊讶的是，尺度并不重要。无论是以英里、公里还是古代长度单位来记录澳大利亚的道路长度，都将遵循本福德定律！作为一个统计学原理，它是*尺度不变*的。'
- en: '![image](../images/f0348-01.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0348-01.jpg)'
- en: '*Figure 16-1: The frequency of occurrence of leading digits according to Benford’s
    law*'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*图16-1：根据本福德定律，领先数字的出现频率*'
- en: It took mathematicians about a hundred years to come up with an explanation
    for Benford’s law that *they* found satisfactory. For the rest of us, let’s just
    say that there are more little things in the universe than large things. Frank
    Benford used the analogy that owning *one* acre of land is easier than owning
    *nine* acres. In fact, you can closely duplicate the frequency produced by Benford’s
    law by simply assuming that there are twice as many 1s as 2s, three times as many
    1s as 3s, and so on. You just take the inverse of each of the nine digits (1 /
    *d*) and divide by the sum of all the inverses (2.83). Then multiply the results
    by 100 to get the percentage (see [Figure 16-2](ch16.xhtml#ch16fig2)).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 数学家们花了大约一百年的时间才提出一个他们认为令人满意的本福德定律解释。对于我们其他人来说，可以这么说：宇宙中小的东西比大的东西更多。Frank Benford用了一个类比，拥有*一*英亩土地比拥有*九*英亩土地要容易。实际上，你可以通过简单地假设1的数量是2的两倍，1的数量是3的三倍，依此类推，来紧密复制本福德定律所产生的频率。你只需要取每个数字的倒数（1
    / *d*），然后除以所有倒数之和（2.83）。然后，将结果乘以100得到百分比（见[图16-2](ch16.xhtml#ch16fig2)）。
- en: '![image](../images/f0349-01.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0349-01.jpg)'
- en: '*Figure 16-2: Comparison of Benford’s law with an approximation proportional
    to the inverse of the first digit*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*图16-2：本福德定律与近似值的比较，近似值与首位数字的倒数成比例*'
- en: Because of the size relationships just discussed, Benford’s law can be visualized
    with a *logarithmic* scale, which is used to graph data that are related according
    to an exponential relationship. In *semilogarithmic* (“semilog”) plots, one variable
    tends to be restricted, like the set of leading digits (1–9), while the other
    covers a wide range of values that includes several orders of magnitude.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 由于前面讨论的大小关系，本福德定律可以通过*对数*刻度进行可视化，后者用于绘制符合指数关系的数据。在*半对数*（“semilog”）图中，一个变量通常会受到限制，比如领先数字的集合（1-9），而另一个变量则覆盖包含多个数量级的广泛值范围。
- en: On semilog graph paper, the horizontal x-axis values are log values, and the
    vertical y-axis values, represented by horizontal lines, are not (see [Figure
    16-3](ch16.xhtml#ch16fig3)). On the x-axis, the horizontal divisions aren’t regular,
    and this nonlinear pattern repeats with powers of 10\. For every *decade* on the
    log paper, such as 1 through 10 or 10 through 100, the *width* of the divisions
    between numbers is proportional to the *length* of the bars in [Figure 16-1](ch16.xhtml#ch16fig1).
    For example, the distance between the 1 and 2 in [Figure 16-3](ch16.xhtml#ch16fig3)
    is 30.1 percent of the distance between 1 and 10\. As one author put it, you could
    derive Benford’s law by simply throwing darts at a piece of log paper!
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在半对数图纸上，水平x轴的数值是对数值，垂直y轴的数值由水平线表示，并不是（见[图16-3](ch16.xhtml#ch16fig3)）。在x轴上，水平分隔线不规则，这种非线性模式以10的幂次方重复。在对数纸的每个*十年*（如从1到10，或从10到100）上，数字之间分隔线的*宽度*与[图16-1](ch16.xhtml#ch16fig1)中的条形*长度*成比例。例如，[图16-3](ch16.xhtml#ch16fig3)中1和2之间的距离是1和10之间距离的30.1%。正如一位作者所说，你可以通过简单地在对数纸上扔飞镖来推导本福德定律！
- en: '![image](../images/f0349-02.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0349-02.jpg)'
- en: '*Figure 16-3: Example of two-decade semilogarithmic graph paper*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*图16-3：两十年期半对数图纸示例*'
- en: For a collection of numeric data to conform to Benford’s law, certain conditions
    have to be met. The numbers need to be random and not assigned, with no imposed
    minimums or maximums. The numbers should cover several orders of magnitude, and
    the dataset should be large; recommendations in the literature call for 100 to
    1,000 samples as a minimum, though Benford’s law has been shown to hold true for
    datasets containing as few as 50 numbers. Examples of distributions that won’t
    follow Benford’s law are the heights of professional basketball players, US telephone
    numbers (for which only the last four digits are truly random), prices influenced
    by psychological barriers ($1.99 versus $2.00), and medical copayments.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使一组数字数据符合本福德定律，必须满足一些条件。这些数字需要是随机的，而不是指定的，不应存在强加的最小值或最大值。这些数字应涵盖多个数量级，且数据集应较大；文献中的建议是至少100到1000个样本，尽管本福德定律已被证明适用于包含多达50个数字的数据集。不会遵循本福德定律的分布示例包括职业篮球运动员的身高、美国电话号码（其中只有最后四位数字是真正随机的）、受到心理障碍影响的价格（如1.99美元与2.00美元）以及医疗共付费用。
- en: '***Applying Benford’s Law***'
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***应用本福德定律***'
- en: Most financial and accounting data conform to naturally occurring numbers and
    are thus subject to Benford’s law. For example, assume you own a stock mutual
    fund with a value of $1,000\. For your fund to reach $2,000 in value, it would
    have to double by growing 100 percent. To increase from $2,000 to $3,000, it would
    only need to grow by 50 percent. For the first digit to be a 4, it needs to grow
    by another 33 percent. As Benford’s law predicts, for the leading digit 1 to become
    2, there needs to be more growth than for the 3 to become 4, and so on. Because
    a Benford distribution is a “distribution of distributions,” financial datasets
    tend to conform, as they result from combining numbers—though exceptions do occur.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数财务和会计数据都符合自然发生的数字，因此符合本福德定律。例如，假设你拥有一个价值$1,000的股票共同基金。为了让你的基金达到$2,000的价值，它必须增长100%。而从$2,000增长到$3,000，则只需要增长50%。要让首位数字为4，基金还需要再增长33%。正如本福德定律所预测的那样，首位数字从1变为2时，需要比从3变为4时更多的增长，依此类推。因为本福德分布是一个“分布的分布”，所以财务数据集通常会符合这种模式，因为它们是由多个数字组合而成——尽管也会有例外情况。
- en: Because people are generally unaware of Benford’s law, they don’t account for
    it when falsifying numerical records. This gives forensic accountants a powerful
    tool for quickly identifying datasets that may be fraudulent. In fact, comparisons
    to Benford’s law are legally admissible as evidence in US criminal cases at the
    federal, state, and local levels.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 因为人们通常不了解本福德定律，所以在伪造数字记录时并未考虑到这一点。这为法务会计师提供了一个强大的工具，能够快速识别可能存在欺诈的数据集。事实上，与本福德定律的对比可以作为证据在美国联邦、州和地方的刑事案件中合法地作为证据使用。
- en: In the 1993 case of *State of Arizona v. Nelson*, the accused diverted nearly
    $2 million to bogus vendors in an attempt to defraud the state. Despite taking
    care to make the fake checks look legitimate, the first-digit distribution clearly
    violated Benford’s law ([Figure 16-4](ch16.xhtml#ch16fig4)), leading to a conviction.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在1993年的*亚利桑那州诉纳尔逊案*中，被告将近200万美元转移给虚假供应商，试图欺诈州政府。尽管小心地让假支票看起来合法，但首位数字的分布明显违反了本福德定律（见[图16-4](ch16.xhtml#ch16fig4)），最终导致了定罪。
- en: '![image](../images/f0350-01.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0350-01.jpg)'
- en: '*Figure 16-4: Comparison of the frequency of first digits in fraudulent checks
    to anticipated Benford’s law frequency, State of Arizona v. Wayne James Nelson
    (CV92-18841)*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*图16-4：欺诈支票的首位数字频率与预期的本福德定律频率对比，亚利桑那州诉韦恩·詹姆斯·纳尔逊案（CV92-18841）*'
- en: Benford’s law is also useful for internal business audits. Imagine a case where
    any travel and entertainment expenses over $10,000 must be approved by the company
    vice president. This type of financial threshold can tempt employees to do things
    like split invoices to game the system. [Figure 16-5](ch16.xhtml#ch16fig5) is
    based on a group of expenses ranging from $100 to $12,000, where all values greater
    than $9,999 were split into two equal halves. As you can guess, there is a spike
    in first-digit frequencies around 5 and 6, in clear violation of Benford’s law.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 本福德定律对于内部商业审计也非常有用。假设某公司要求任何超过$10,000的差旅和娱乐费用必须得到公司副总裁的批准。这类财务门槛可能会诱使员工采取分割发票等手段来规避制度。[图16-5](ch16.xhtml#ch16fig5)基于一组费用数据，范围从$100到$12,000，其中所有大于$9,999的金额都被分割为两等份。正如你所猜测的，首位数字的频率在5和6周围出现了明显的峰值，明显违反了本福德定律。
- en: '![image](../images/f0351-01.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0351-01.jpg)'
- en: '*Figure 16-5: Splitting invoices over $9,999 for a dataset ranging from $100
    to $12,000 violates Benford’s law.*'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*图16-5：将超过$9,999的发票分割成$100到$12,000区间的数据集，违反了本福德定律。*'
- en: On a grander scale, Benford’s law has revealed irregularities in the financial
    data—such as revenue numbers—of large corporations. An example from Enron, which
    practiced institutionalized accounting fraud, is shown in [Figure 16-6](ch16.xhtml#ch16fig6).
    Enron’s bankruptcy in 2001 was the largest in history at the time, and it resulted
    in the jailing of several top executives. The scandal also brought about the dissolution
    of Arthur Andersen, a “Big Five” accounting firm and one of the world’s largest
    multinational corporations.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在更宏观的层面上，本福德定律揭示了大型企业财务数据中的不规则性——例如收入数字。例如，在安然公司（Enron）的案例中，安然是一家进行制度化会计欺诈的公司，见[图16-6](ch16.xhtml#ch16fig6)。安然在2001年的破产是当时历史上最大的破产事件，导致多名高层管理人员入狱。此丑闻还导致了“全球五大”会计事务所之一的安达信会计事务所的解散，安达信曾是全球最大的跨国公司之一。
- en: '![image](../images/f0351-02.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0351-02.jpg)'
- en: '*Figure 16-6: Frequency of first digits from Enron’s year 2000 financial data
    versus anticipated frequency based on Benford’s law (after the* Wall Street Journal*)*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*图16-6：安然公司2000年财务数据的首位数字频率与根据本福德定律预测的频率（摘自《华尔街日报》）*'
- en: Obviously, Benford’s law works best for fraud detection when the criminals are
    unaware of it. If you know how the law works, you can fool it, which we’ll do
    in a practice project at the end of this chapter. As a result, you can use Benford’s
    law to flag datasets that might be fraudulent, but you can’t use it to prove the
    opposite.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，本福德定律在欺诈检测中的效果最佳，前提是犯罪分子没有意识到这一点。如果你知道定律的运作方式，你就可以欺骗它，这将在本章末的一个实操项目中展示。因此，你可以利用本福德定律标记可能存在欺诈的数据集，但不能用它来证明相反的结论。
- en: '***Performing the Chi-Square Test***'
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***执行卡方检验***'
- en: Auditors and investigators use multiple statistical methods to verify that a
    dataset obeys Benford’s law. In this project, you’ll use the *chi-square goodness-of-fit
    test*, which is a commonly used method for determining whether an empirical (observed)
    distribution differs significantly from a theoretical (expected) distribution.
    A significance level, or p*-value*, is used as the discriminator. The most common
    significance level is 0.05, but other common ones include 0.01 and 0.10\. A significance
    level of 0.05 indicates a 5 percent risk of erroneously concluding that a difference
    exists when it doesn’t.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 审计人员和调查员使用多种统计方法来验证数据集是否符合本福德定律。在本项目中，你将使用*卡方拟合优度检验*，这是一种常用的方法，用于判断经验（观察到的）分布是否与理论（期望的）分布显著不同。显著性水平或*p*-值用于作为判别标准。最常见的显著性水平是0.05，但其他常见的还包括0.01和0.10。显著性水平为0.05表示有5%的风险错误地得出存在差异的结论。
- en: 'Here are the steps for performing a chi-square goodness-of-fit test:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是进行卡方拟合优度检验的步骤：
- en: 'Find the *degrees of freedom* (*df*), defined as the number of categories (*k*)
    minus 1:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到*自由度*（*df*），它定义为类别数（*k*）减去1：
- en: '*df* = *k* – 1'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*df* = *k* – 1'
- en: For Benford’s law, the categorical levels are the first digits (1–9), so *df*
    = 8.
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于本福德定律，类别级别是首位数字（1–9），所以*df* = 8。
- en: 'Calculate the expected frequency count at each level by multiplying the sample
    size by the theoretical proportions at each level:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将样本大小与每个级别的理论比例相乘来计算每个级别的期望频数：
- en: '*E[i]* = *np*[*i*]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*E[i]* = *np*[*i*]'
- en: where *E* is the expected frequency at the *i*th level, *n* is the sample size,
    and *p* is the theoretical probability at the *i*th level. For 1,000 samples,
    the number of samples expected to start with 1 in a Benford’s law distribution
    would be 1,000 × 0.301 = 301 (see [Figure 16-1](ch16.xhtml#ch16fig1)).
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其中，*E*是第*i*级别的期望频率，*n*是样本大小，*p*是第*i*级别的理论概率。对于1,000个样本，根据本福德定律，期望以1开头的样本数量为1,000
    × 0.301 = 301（参见[图16-1](ch16.xhtml#ch16fig1)）。
- en: 'Calculate the chi-square random variable (*X*²), also known as the *test statistic*,
    which will allow you to judge whether the two distributions are the same:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算卡方随机变量（*X*²），也叫做*检验统计量*，它可以帮助你判断两个分布是否相同：
- en: '![image](../images/f0352-01.jpg)'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](../images/f0352-01.jpg)'
- en: where *O* is the observed frequency count for the *i*th level of the categorical
    variable, *E* is the expected frequency count for the *i*th level of the categorical
    variable, and *df* represents the *degrees of freedom*.
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其中，*O*是类别变量第*i*级别的观察频数，*E*是类别变量第*i*级别的期望频数，*df*表示*自由度*。
- en: Refer to the *chi-square distribution table* ([Table 16-1](ch16.xhtml#ch16tab1)),
    reading across the row corresponding to the calculated degrees of freedom. If
    the test statistic is *less than* the value shown in the *p*-value column considered
    significant, then you can’t reject the hypothesis that the observed and theoretical
    distributions are the same.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查阅*卡方分布表*（[表16-1](ch16.xhtml#ch16tab1)），读取与计算得出的自由度相对应的行。如果检验统计量*小于*在*p*-值列中显示的显著性值，则不能拒绝观察分布和理论分布相同的假设。
- en: '**Table 16-1:** Chi-Square Distribution Table'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**表16-1：卡方分布表**'
- en: '| **Degrees of freedom** | **Probability of exceeding the critical value**
    |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| **自由度** | **超过临界值的概率** |'
- en: '| --- | --- |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| **0.99** | **0.95** | **0.90** | **0.75** | **0.50** | **0.25** | **0.10**
    | **0.05** | **0.01** |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| **0.99** | **0.95** | **0.90** | **0.75** | **0.50** | **0.25** | **0.10**
    | **0.05** | **0.01** |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- | --- |'
- en: '| 1 | 0.000 | 0.004 | 0.016 | 0.102 | 0.455 | 1.32 | 2.71 | 3.84 | 6.63 |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0.000 | 0.004 | 0.016 | 0.102 | 0.455 | 1.32 | 2.71 | 3.84 | 6.63 |'
- en: '| 2 | 0.020 | 0.103 | 0.211 | 0.575 | 1.386 | 2.77 | 4.61 | 5.99 | 9.21 |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 0.020 | 0.103 | 0.211 | 0.575 | 1.386 | 2.77 | 4.61 | 5.99 | 9.21 |'
- en: '| 3 | 0.115 | 0.352 | 0.584 | 1.212 | 2.366 | 4.11 | 6.25 | 7.81 | 11.34 |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 0.115 | 0.352 | 0.584 | 1.212 | 2.366 | 4.11 | 6.25 | 7.81 | 11.34 |'
- en: '| 4 | 0.297 | 0.711 | 1.064 | 1.923 | 3.357 | 5.39 | 7.78 | 9.49 | 13.28 |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 0.297 | 0.711 | 1.064 | 1.923 | 3.357 | 5.39 | 7.78 | 9.49 | 13.28 |'
- en: '| 5 | 0.554 | 1.145 | 1.610 | 2.675 | 4.351 | 6.63 | 9.24 | 11.07 | 15.09 |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 0.554 | 1.145 | 1.610 | 2.675 | 4.351 | 6.63 | 9.24 | 11.07 | 15.09 |'
- en: '| 6 | 0.872 | 1.635 | 2.204 | 3.455 | 5.348 | 7.84 | 10.64 | 12.59 | 16.81
    |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 0.872 | 1.635 | 2.204 | 3.455 | 5.348 | 7.84 | 10.64 | 12.59 | 16.81
    |'
- en: '| 7 | 1.239 | 2.167 | 2.833 | 4.255 | 6.346 | 9.04 | 12.02 | 14.07 | 18.48
    |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 1.239 | 2.167 | 2.833 | 4.255 | 6.346 | 9.04 | 12.02 | 14.07 | 18.48
    |'
- en: '| 8 | 1.647 | 2.733 | 3.490 | 5.071 | 7.344 | 10.22 | 13.36 | 15.51 | 20.09
    |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 1.647 | 2.733 | 3.490 | 5.071 | 7.344 | 10.22 | 13.36 | 15.51 | 20.09
    |'
- en: '| 9 | 2.088 | 3.325 | 4.168 | 5.899 | 8.343 | 11.39 | 14.68 | 16.92 | 21.67
    |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 9 | 2.088 | 3.325 | 4.168 | 5.899 | 8.343 | 11.39 | 14.68 | 16.92 | 21.67
    |'
- en: '| 10 | 2.558 | 3.940 | 4.865 | 6.737 | 9.342 | 12.55 | 15.99 | 18.31 | 23.21
    |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 2.558 | 3.940 | 4.865 | 6.737 | 9.342 | 12.55 | 15.99 | 18.31 | 23.21
    |'
- en: '|  | Not significant | Significant |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '|  | 不显著 | 显著 |'
- en: In Table 16-2, the critical value for a *p*-value of 0.05—at 8 degrees of freedom—is
    15.51\. If your calculated test statistic is less than 15.51, then the corresponding
    *p*-value is greater than 0.05, and you would conclude that there is *no statistically
    significant difference* between the observed distribution and the one predicted
    by Benford’s law. The *p*-value here is the probability that a test statistic
    having 8 degrees of freedom is more extreme than 15.51.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在表16-2中，0.05 的 *p* 值对应的临界值——在 8 自由度下——为 15.51。如果你计算出的检验统计量小于 15.51，则相应的 *p*
    值大于 0.05，你将得出结论，观察到的分布与本福特定律预测的分布之间*没有统计学上的显著差异*。这里的 *p* 值是指具有 8 自由度的检验统计量超过 15.51
    的概率。
- en: Note that you should perform the chi-square test on *counts*. If your data is
    in percentages, averages, ratios, or so on, then you’ll need to convert the values
    to counts before running the test.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你应该对 *计数* 进行卡方检验。如果你的数据是百分比、平均数、比率等，你需要在进行检验前将数据转换为计数值。
- en: '**THE OBJECTIVE**'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标**'
- en: Write a Python program that loads numerical data, records the frequency of occurrence
    of the first digits, compares these to Benford’s law using the chi-square goodness-of-fit
    test, and presents the comparison in both tabular and graphical form.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个 Python 程序，加载数值数据，记录首位数字的出现频率，使用卡方拟合优度检验将这些频率与本福特定律进行比较，并以表格和图形两种形式呈现比较结果。
- en: '**The Dataset**'
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**数据集**'
- en: The 2016 US presidential election was rife with allegations of voter fraud.
    Most famously, the Russians were accused of supporting Donald Trump, and the Democratic
    National Committee was accused of favoring Hillary Clinton over Bernie Sanders
    in that party’s nomination process. President Trump also alleged that 5 to 6 million
    people voted illegally, and in May 2017, he signed an executive order that launched
    a commission to review voter fraud and voter suppression.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 2016 年美国总统选举充斥着选民欺诈的指控。最著名的是，俄罗斯被指控支持唐纳德·特朗普，民主党全国委员会被指控在该党提名过程中偏袒希拉里·克林顿而非伯尼·桑德斯。特朗普总统还声称有
    500 万到 600 万人非法投票，并且在 2017 年 5 月，他签署了一项行政命令，成立委员会来审查选民欺诈和选民压制问题。
- en: For this project, you’ll use a dataset of voting records from the 2016 presidential
    election. This consists of the final *by-county* votes for the 102 counties in
    the state of Illinois, which was won by Hillary Clinton. Starting in June 2016,
    the Illinois Voter Registration System database was the victim of a malicious
    cyberattack of unknown origin. Illinois election officials confirmed that hackers
    had accessed thousands of records but apparently didn’t alter any data.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，你将使用来自 2016 年总统选举的投票记录数据集。该数据集包含伊利诺伊州 102 个县的最终 *按县* 投票结果，希拉里·克林顿赢得了该州。从
    2016 年 6 月开始，伊利诺伊州选民注册系统数据库成为了一次来源不明的恶意网络攻击的受害者。伊利诺伊州选举官员确认黑客已经访问了成千上万的记录，但显然没有更改任何数据。
- en: 'There were a surprising number of candidates on the Illinois ballot for president,
    so the dataset has been parsed to include only Hillary Clinton, Donald Trump,
    Gary Johnson, and Jill Stein. Votes for these candidates have been lumped together
    in a 408-line text file, with these first 5 lines:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 伊利诺伊州总统选举的候选人出人意料地多，因此数据集已被解析，只包含希拉里·克林顿、唐纳德·特朗普、加里·约翰逊和吉尔·斯坦。这些候选人的选票已合并到一个包含
    408 行文本的文件中，以下是前 5 行：
- en: '962'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '962'
- en: '997'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '997'
- en: '1020'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '1020'
- en: '1025'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '1025'
- en: '1031'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '1031'
- en: You can find the complete tally of candidates and votes online at *[https://www.elections.il.gov/ElectionInformation/DownloadVoteTotals.aspx](https://www.elections.il.gov/ElectionInformation/DownloadVoteTotals.aspx)*.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在*[https://www.elections.il.gov/ElectionInformation/DownloadVoteTotals.aspx](https://www.elections.il.gov/ElectionInformation/DownloadVoteTotals.aspx)*在线查看完整的候选人和投票计数。
- en: For this project, you need only the votes, which can be downloaded from *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*
    as *Illinois_votes.txt*. You’ll need to keep this file in the same folder as your
    Python code.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，你只需要选票数据，可以从*[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*下载*Illinois_votes.txt*。你需要将这个文件与Python代码保存在同一文件夹中。
- en: '**The Strategy**'
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**策略**'
- en: Let’s pretend you’re an investigator looking into allegations of voter fraud
    in the 2016 presidential election and you’ve been assigned the state of Illinois.
    Before doing a deep dive into the data, you’ll want to flag any obvious anomalies.
    Benford’s law can’t help you determine whether people are voting illegally, but
    it’s a good place to start for detecting vote *tampering*—that is, changing votes
    after they are cast.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你是一名调查员，正在调查2016年总统选举中的选民欺诈指控，并且你被分配了伊利诺伊州。在深入分析数据之前，你需要标记任何明显的异常情况。费尔本德定律不能帮助你判断选民是否违法投票，但它是检测选票*篡改*的一个好起点——也就是说，在选票投出后修改选票。
- en: In cases like this, the ability to communicate the results is every bit as important
    as the quantitative analysis. Voting commissions don’t just include experts but
    also many laypeople with limited knowledge of statistics. And juries probably
    will not include a single expert. To convince yourself—and others—that the vote
    counts are valid (or not), you’ll want to show multiple comparisons, like a table,
    a graph, and the quantitative chi-square variable (test statistic).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，能够有效地传达结果与定量分析同样重要。投票委员会不仅包括专家，还包括许多对统计学了解有限的普通人。而陪审团可能根本没有一个专家。为了说服自己和他人——无论选票统计是否有效——你需要展示多种比较方式，比如表格、图表和定量的卡方检验统计量。
- en: 'The individual steps involved in the analysis lend themselves well to encapsulation
    in functions. So, instead of pseudocode, let’s look at what functions you may
    need:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 分析过程中涉及的各个步骤非常适合封装成函数。所以，先看一下你可能需要的函数，而不是伪代码：
- en: load_data() Load the data as a list.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: load_data() 将数据加载为列表。
- en: count_first_digits() Tabulate the first digits in each county’s observed vote
    total.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: count_first_digits() 将每个县的观察投票总数的首位数字列出。
- en: get_expected_counts() Determine the counts for each first digit as predicted
    by Benford.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: get_expected_counts() 确定每个首位数字的预期计数，这些计数是根据费尔本德定律预测的。
- en: chi_square_test() Run a chi-square goodness-of-fit test on the observed versus
    expected counts.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: chi_square_test() 对观察到的投票数据与预期数据进行卡方拟合优度检验。
- en: bar_chart() Generate a bar chart to compare observed first-digit percentages
    to those expected.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: bar_chart() 生成条形图，将观察到的首位数字百分比与预期的数字进行比较。
- en: main() Get the dataset filename, call the functions, and print the statistics.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: main() 获取数据集文件名，调用相关函数，并打印统计信息。
- en: '**The Code**'
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**代码**'
- en: You’ll use the *benford.py* code in this section to investigate voter fraud,
    but it’s flexible enough to be used on *any* dataset where categorical values
    have been counted, such as medical test results, income tax revenues, or customer
    refunds. Non-fraud-related applications are also possible, such as detecting process
    inefficiencies caused by a large number of low-value transactions; problems with
    data collection and handling, such as missing data, truncated values, or typos;
    and bias in measurement strategies or surveys, such as favoring best-case or worst-case
    sampling.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，你将使用*benford.py*代码来调查选民欺诈，但它足够灵活，可以应用于*任何*已进行计数的分类数据集，例如医疗测试结果、所得税收入或客户退款。与欺诈无关的应用也可以，例如检测由大量低价值交易引起的流程低效；数据收集和处理中的问题，如缺失数据、截断值或拼写错误；以及测量策略或调查中的偏差，例如偏向最佳或最坏情况抽样。
- en: You can download the code from *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*.
    You’ll also need the *Illinois_votes.txt* text file described in “[The Dataset](ch16.xhtml#lev381)”
    on [page 353](ch16.xhtml#page_353).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从*[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*下载代码。你还需要下载文本文件*Illinois_votes.txt*，它在[第353页](ch16.xhtml#page_353)的“[数据集](ch16.xhtml#lev381)”部分有所描述。
- en: '***Importing Modules and Loading Data***'
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***导入模块并加载数据***'
- en: '[Listing 16-1](ch16.xhtml#ch16list1) imports modules and defines a function
    to load data. For this project, you’ll use data in the form of a tab-delimited
    text file exported from Microsoft Excel, which you load as a list of strings.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 16-1](ch16.xhtml#ch16list1) 导入模块并定义一个函数来加载数据。对于这个项目，你将使用从 Microsoft Excel
    导出的以制表符分隔的文本文件形式的数据，并将其作为字符串列表加载。'
- en: '*benford.py,* part 1'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*benford.py*，第 1 部分'
- en: import sys
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 sys
- en: import math
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 math
- en: ➊ from collections import defaultdict
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ 从 collections 导入 defaultdict
- en: ➋ import matplotlib.pyplot as plt
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ 导入 matplotlib.pyplot 作为 plt
- en: '# Benford''s law percentages for leading digits 1-9'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '# Benford 法则的首位数字百分比（1-9）'
- en: ➌ BENFORD = [30.1, 17.6, 12.5, 9.7, 7.9, 6.7, 5.8, 5.1, 4.6]
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ BENFORD = [30.1, 17.6, 12.5, 9.7, 7.9, 6.7, 5.8, 5.1, 4.6]
- en: '➍ def load_data(filename):'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '➍ def load_data(filename):'
- en: '"""Open a text file & return a list of strings."""'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '"""打开文本文件并返回一个字符串列表。"""'
- en: '➎ with open(filename) as f:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '➎ 使用 open(filename) 作为 f:'
- en: return f.read().strip().split('\n')
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 f.read().strip().split('\n')
- en: '*Listing 16-1: Imports modules and defines a function for loading data*'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 16-1：导入模块并定义加载数据的函数*'
- en: Most of the imports should be familiar at this point. The collections module
    provides specialized alternatives to standard Python containers like sets, tuples,
    lists, and dictionaries ➊. For counting first-digit frequencies, you’ll need defaultdict,
    which is a dict subclass that calls a factory function to supply missing values.
    With defaultdict, you can build a dictionary using a loop, and it will automatically
    create new keys rather than throwing an error. It returns a dictionary object.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，大多数导入的模块应该已经很熟悉了。`collections` 模块提供了标准 Python 容器（如集合、元组、列表和字典）的一些专用替代品➊。对于计算首位数字频率，你需要使用
    `defaultdict`，它是 `dict` 的一个子类，通过调用工厂函数来提供缺失的值。使用 `defaultdict`，你可以通过循环构建字典，并且它会自动创建新键，而不是抛出错误。它返回一个字典对象。
- en: The final import is for plotting with matplotlib ➋. For more information on
    matplotlib and how to install it, see “[The Probability-of-Detection Code](ch10.xhtml#lev226)”
    on [page 194](ch10.xhtml#page_194).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的导入是用于绘制图形的 matplotlib ➋。有关 matplotlib 及其安装方法的更多信息，请参阅 “[检测概率代码](ch10.xhtml#lev226)”
    在 [第 194 页](ch10.xhtml#page_194)。
- en: Now, assign a variable to a list containing the Benford’s law percentages, ordered
    from 1 to 9 ➌. Then, define a function to read a text file and return a list ➍.
    As you’ve done before, use with, as it will automatically close the file when
    done ➎.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，赋一个变量给一个包含 Benford 法则百分比的列表，从 1 到 9 排序 ➌。然后，定义一个函数来读取文本文件并返回一个列表 ➍。如你之前所做，使用
    with，它将在完成时自动关闭文件 ➎。
- en: '***Counting First Digits***'
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***计数首位数字***'
- en: '[Listing 16-2](ch16.xhtml#ch16list2) defines a function to count the first
    digits and store the results in a dictionary data structure. The final counts,
    and the frequency of each count as a percentage, are returned as lists to use
    in subsequent functions. The function will also run quality control on the data.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 16-2](ch16.xhtml#ch16list2) 定义了一个函数来计算首位数字并将结果存储在字典数据结构中。最终的计数和每个计数的频率（以百分比表示）作为列表返回，供后续函数使用。该函数还会对数据进行质量控制。'
- en: '*benford.py,* part 2'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*benford.py*，第 2 部分'
- en: '➊ def count_first_digits(data_list):'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ def count_first_digits(data_list):'
- en: '"""Count 1st digits in list of numbers; return counts & frequency."""'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '"""在数字列表中计数首位数字；返回计数和频率。"""'
- en: ➋ first_digits = defaultdict(int)  # default value of int is 0
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '➋ first_digits = defaultdict(int)  # int 的默认值是 0'
- en: '➌ for sample in data_list:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '➌ 对于 sample 在 data_list 中:'
- en: '➍ if sample == '''':'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '➍ 如果 sample == '''':'
- en: continue
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: continue
- en: 'try:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '尝试:'
- en: int(sample)
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: int(样本)
- en: 'except ValueError as e:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '除了 ValueError 异常作为 e:'
- en: print(e, file=sys.stderr)
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: print(e, file=sys.stderr)
- en: print("Samples must be integers. Exiting", file=sys.stderr)
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: print("样本必须是整数。退出中", file=sys.stderr)
- en: sys.exit(1)
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: sys.exit(1)
- en: ➎ first_digits[sample[0]] += 1
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ first_digits[sample[0]] += 1
- en: '# check for missing digits'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '# 检查缺失的数字'
- en: keys = [str(digit) for digit in range(1, 10)]
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: keys = [str(digit) for digit in range(1, 10)]
- en: 'for key in keys:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '对于 key 在 keys 中:'
- en: 'if key not in first_digits:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 key 不在 first_digits 中:'
- en: first_digits[key] = 0
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: first_digits[key] = 0
- en: ➏ data_count = [v for (k, v) in sorted(first_digits.items())]
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ➏ data_count = [v for (k, v) in sorted(first_digits.items())]
- en: total_count = sum(data_count)
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: total_count = sum(data_count)
- en: data_pct = [(i / total_count) * 100 for i in data_count]
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: data_pct = [(i / total_count) * 100 for i in data_count]
- en: ➐ return data_count, data_pct, total_count
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ➐ 返回 data_count, data_pct, total_count
- en: '*Listing 16-2: Defines a function to count first digits and return counts and
    frequency*'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 16-2：定义一个函数来计算首位数字并返回计数和频率*'
- en: The count_first_digits() function takes the list of strings returned from the
    load_data() function as an argument ➊. You’ll call it in main().
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: count_first_digits() 函数接受从 load_data() 函数返回的字符串列表作为参数 ➊。你将在 main() 中调用它。
- en: Start a dictionary, named first_digits, using defaultdict ➋. This step just
    sets up the dictionary for later population. The first argument for defaultdict
    is any callable (with no arguments). In this case, the callable is the type constructor
    for int, as you want to count integers. With defaultdict, whenever an operation
    encounters a missing key, a function named default_factory is called with no arguments,
    and the output is used as the value. Nonexistent keys get the value returned by
    default_factory.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`defaultdict`➋启动一个名为`first_digits`的字典。这个步骤只是为后续填充字典做准备。`defaultdict`的第一个参数是任何可调用对象（无参数）。在这种情况下，可调用对象是`int`的类型构造器，因为你希望统计整数。在使用`defaultdict`时，每当操作遇到一个缺失的键时，会调用名为`default_factory`的函数，且该函数无参数，返回的输出将作为该键的值。不存在的键会获得`default_factory`返回的值。
- en: Now start a for loop and go through the samples in data_list ➌. If the sample
    is empty—that is, if the text file contains a blank line ➍—skip it with continue.
    Otherwise, use try to convert the sample to an integer. If an exception occurs,
    the sample isn’t a proper count value, so let the user know and exit the program.
    In the following output example, the input file contains a float value (0.01)
    and the main() function prints the filename.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在开始一个`for`循环，遍历`data_list`中的样本➌。如果样本为空——也就是说，如果文本文件包含空行 ➍——则使用`continue`跳过。否则，使用`try`尝试将样本转换为整数。如果发生异常，说明样本不是有效的计数值，程序将提示用户并退出。在以下输出示例中，输入文件包含一个浮动值（0.01），`main()`函数会打印文件名。
- en: 'Name of file with COUNT data: bad_data.txt'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 包含COUNT数据的文件名：bad_data.txt
- en: 'invalid literal for int() with base 10: ''0.01'''
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 无效的整数文字：'0.01'
- en: Samples must be integers. Exiting.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 样本必须是整数。程序退出。
- en: If the sample passes the test, make its first element (leading digit) the dictionary
    key and add 1 to the value ➎. Because you used defaultdict with int, the key is
    initially assigned a default value of 0 on the fly.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果样本通过测试，将其第一个元素（领先数字）作为字典的键，并将值➎加1。因为你使用了`defaultdict`并指定了`int`，所以键会被自动赋予默认值0。
- en: 'To compare the counts to a Benford’s law distribution, you need the keys listed
    in numerical order, so use list comprehension and sorted to make a new version
    of first_digits, named data_count ➏. This will yield the values sorted by key,
    as shown here:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将计数与本福德定律分布进行比较，你需要按数字顺序列出键，因此可以使用列表推导和`sorted`来生成`first_digits`的一个新版本，命名为`data_count`➏。这样会按键排序返回值，如下所示：
- en: '[129, 62, 45, 48, 40, 25, 23, 21, 15]'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[129, 62, 45, 48, 40, 25, 23, 21, 15]'
- en: Next, sum the counts, then make a new list and convert the counts to percentages.
    End the function by returning these two lists and the summed counts ➐. Because
    the counts in the lists are sorted from 1 to 9, you don’t need the associated
    first digit—it is implicit in the ordering.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，计算计数的总和，然后创建一个新列表，将计数转换为百分比。最后通过返回这两个列表和总计数➐来结束函数。由于列表中的计数是从1到9排序的，因此不需要关联的第一个数字——它在排序中是隐含的。
- en: '***Getting the Expected Counts***'
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***获取预期的计数***'
- en: '[Listing 16-3](ch16.xhtml#ch16list3) defines the get_expected_counts() function
    that takes the observed data and calculates what the expected counts should be
    for the leading digits, based on Benford’s law. These expected counts are returned
    as a list that you’ll use later with the chi-square goodness-of-fit test to see
    how well the observed data conform to Benford’s law.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 16-3](ch16.xhtml#ch16list3) 定义了`get_expected_counts()`函数，该函数接收观测数据并根据本福德定律计算领先数字的预期计数。这些预期计数会作为一个列表返回，之后你将使用该列表与卡方拟合度检验一起检查观测数据是否符合本福德定律。'
- en: '*benford.py,* part 3'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*benford.py,* 第三部分'
- en: '➊ def get_expected_counts(total_count):'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ def get_expected_counts(total_count):'
- en: '"""Return list of expected Benford''s law counts for a total sample count."""'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '"""返回一个包含预期本福德定律计数的列表，基于总样本数量。"""'
- en: ➋ return [round(p * total_count / 100) for p in BENFORD]
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ return [round(p * total_count / 100) for p in BENFORD]
- en: '*Listing 16-3: Defines a function to calculate expected Benford’s law counts
    for a dataset*'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 16-3: 定义了一个函数，用于计算数据集的预期本福德定律计数*'
- en: The argument for this function is the summed count that you returned from the
    count_first_digits() function in [Listing 16-2](ch16.xhtml#ch16list2) ➊. To get
    the counts you would expect for Benford’s law, you’ll need to use the frequency
    *probability* of each digit, so convert the percentages in the BENFORD list by
    dividing by 100\. Then multiply the total_count variable by this probability.
    You can do all this with list comprehension as part of the return statement ➋.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数的参数是你从 [列表 16-2](ch16.xhtml#ch16list2) 中的 count_first_digits() 函数返回的总计数值
    ➊。为了获得本福德定律的期望频数，你需要使用每个数字的频率 *概率*，因此通过将 BENFORD 列表中的百分比除以 100 来转换它们。然后，将 total_count
    变量乘以这个概率。你可以通过列表推导式在返回语句中完成这一切 ➋。
- en: '***Determining Goodness of Fit***'
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***确定拟合优度***'
- en: '[Listing 16-4](ch16.xhtml#ch16list4) defines a function to implement the chi-square
    test described in “[Performing the Chi-Square Test](ch16.xhtml#lev380)” on [page
    352](ch16.xhtml#page_352). This test calculates the goodness of fit of the observed
    counts to the expected counts predicted by Benford’s law. The function will first
    calculate the chi-square test statistic, then compare it to the chi-square distribution
    table entry at a *p*-value of 0.05 for 8 degrees of freedom. Based on the comparison,
    the function returns either True or False.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 16-4](ch16.xhtml#ch16list4) 定义了一个函数，用于实现 “[卡方检验](ch16.xhtml#lev380)” 在
    [第352页](ch16.xhtml#page_352) 中描述的卡方检验。该检验计算观测频数与根据本福德定律预测的期望频数的拟合优度。该函数首先计算卡方检验统计量，然后将其与自由度为
    8 且 *p*-值为 0.05 的卡方分布表中的临界值进行比较。根据比较结果，函数返回 True 或 False。'
- en: '*benford.py,* part 4'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*benford.py,* 第四部分'
- en: '➊ def chi_square_test(data_count, expected_counts):'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ def chi_square_test(data_count, expected_counts):'
- en: '"""Return boolean on chi-square test (8 degrees of freedom & P-val=0.05)."""'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '"""返回卡方检验的布尔值（自由度 8，P 值 = 0.05）。"""'
- en: ➋ chi_square_stat = 0  # chi-square test statistic
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ chi_square_stat = 0  # 卡方检验统计量
- en: '➌ for data, expected in zip(data_count, expected_counts):'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '➌ for data, expected in zip(data_count, expected_counts):'
- en: ➍ chi_square = math.pow(data - expected, 2)
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ chi_square = math.pow(data - expected, 2)
- en: chi_square_stat += chi_square / expected
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: chi_square_stat += chi_square / expected
- en: ➎ print("\nChi Squared Test Statistic = {:.3f}".format(chi_square_stat))
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ print("\n卡方检验统计量 = {:.3f}".format(chi_square_stat))
- en: print("Critical value at a P-value of 0.05 is 15.51.")
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: print("在 P 值为 0.05 时的临界值是 15.51。")
- en: ➏ return chi_square_stat < 15.51
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ➏ return chi_square_stat < 15.51
- en: '*Listing 16-4: Defines a function to measure goodness of fit of observed data
    versus Benford’s law*'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 16-4：定义了一个函数，用于衡量观测数据与本福德定律的拟合优度*'
- en: The chi-square test works on counts, so the function needs the lists of data
    counts and expected counts that the count_first_digits() and get_expected_counts()
    functions returned ➊. Assign a variable, named chi_square_stat, to hold the chi-square
    test statistic, and assign it a value of 0 ➋.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 卡方检验基于频数，因此该函数需要 count_first_digits() 和 get_expected_counts() 函数返回的频数列表 ➊。定义一个名为
    chi_square_stat 的变量，用于存储卡方检验统计量，并将其初始值设置为 0 ➋。
- en: Use zip to loop through the nine values in data_count and expected_counts; zip
    will pair the first item in one list with the first item in the second list, and
    so on ➌. To calculate the chi-square statistic, first subtract the counts for
    each digit and square the result ➍. Then, divide this value by the expected count
    for the digit and add the result to the chi_square_stat variable. Then print the
    result to three decimal places ➎.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 zip 函数遍历 data_count 和 expected_counts 中的九个值；zip 将把一个列表中的第一个项与另一个列表中的第一个项配对，依此类推
    ➌。为了计算卡方统计量，首先计算每个数字的观测频数与期望频数之差并平方 ➍。然后，将这个值除以该数字的期望频数，并将结果加到 chi_square_stat
    变量中。最后，打印结果，保留三位小数 ➎。
- en: Return the boolean test for the chi_square_stat variable versus 15.51, which
    is the critical value corresponding to a *p*-value of 0.05 at 8 degrees of freedom
    (see [Table 16-1](ch16.xhtml#ch16tab1)) ➏. If chi_square_stat is less than this
    value, the function will return True; otherwise, it will return False.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 返回卡方检验统计量 chi_square_stat 与 15.51 之间的布尔值，15.51 是自由度为 8 且 *p*-值为 0.05 时的临界值（参见
    [表16-1](ch16.xhtml#ch16tab1)） ➏。如果 chi_square_stat 小于此值，则函数返回 True；否则，返回 False。
- en: '***Defining the Bar Chart Function***'
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***定义柱状图函数***'
- en: '[Listing 16-5](ch16.xhtml#ch16list5) defines the first part of a function to
    display the observed count percentages as a matplotlib bar chart. You used similar
    code in [Chapter 12](ch12.xhtml#ch12) to graph the outcomes of the retirement
    nest-egg simulations. This function will also plot the Benford’s law percentages
    as red dots, so you can visually estimate how well the observed data fit the expected
    distribution.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 16-5](ch16.xhtml#ch16list5) 定义了一个函数的第一部分，用于将观察到的计数百分比显示为 matplotlib
    柱状图。你在[第 12 章](ch12.xhtml#ch12)中使用了类似的代码来绘制退休资金模拟的结果。这个函数还将把本福德定律的百分比绘制为红色圆点，以便你可以直观地估计观察数据与预期分布的吻合程度。'
- en: The matplotlib website contains many code examples for building a wide variety
    of plots. This code is partly based on the demo example at *[https://matplotlib.org/examples/api/barchart_demo.html](https://matplotlib.org/examples/api/barchart_demo.html)*.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: matplotlib 网站包含了许多构建各种图表的代码示例。这段代码部分基于 *[https://matplotlib.org/examples/api/barchart_demo.html](https://matplotlib.org/examples/api/barchart_demo.html)*
    上的示例。
- en: '*benford.py,* part 5'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*benford.py,* 第 5 部分'
- en: '➊ def bar_chart(data_pct):'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ def bar_chart(data_pct):'
- en: '"""Make bar chart of observed vs expected 1st-digit frequency (%)."""'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '"""制作观察值与预期的首位数字频率（%）的柱状图。"""'
- en: ➋ fig, ax = plt.subplots()
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ fig, ax = plt.subplots()
- en: ➌ index = [i + 1 for i in range(len(data_pct))]  # 1st digits for x-axis
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '➌ index = [i + 1 for i in range(len(data_pct))]  # x 轴的首位数字'
- en: '# text for labels, title, and ticks'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '# 标签、标题和刻度的文本'
- en: ➍ fig.canvas.set_window_title('Percentage First Digits')
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ fig.canvas.set_window_title('百分比首位数字')
- en: ➎ ax.set_title('Data vs. Benford Values', fontsize=15)
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ ax.set_title('数据 vs. 本福德值', fontsize=15)
- en: ➏ ax.set_ylabel('Frequency (%)', fontsize=16)
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ➏ ax.set_ylabel('频率（%）', fontsize=16)
- en: ➐ ax.set_xticks(index)
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: ➐ ax.set_xticks(index)
- en: ax.set_xticklabels(index, fontsize=14)
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ax.set_xticklabels(index, fontsize=14)
- en: '*Listing 16-5: Defines the first part of the* bar_chart() *function*'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 16-5: 定义了* bar_chart() *函数的第一部分*'
- en: Define the bar_chart() function that takes as an argument the list of frequencies—as
    percentages—of the first digits in the observed data ➊. The plt.subplots() function
    returns a tuple of figure and axes objects; unpack this tuple into variables named
    fig and ax ➋.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 bar_chart() 函数，接受一个参数，该参数是观察数据中首位数字的频率列表（以百分比表示）➊。plt.subplots() 函数返回一个包含图形和坐标轴对象的元组；将该元组解包为名为
    fig 和 ax 的变量➋。
- en: Next, use list comprehension to make a list of digits from 1 to 9 ➌. This index
    variable will define the x-axis location of each of the nine vertical bars in
    the chart.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用列表推导式创建一个从 1 到 9 的数字列表➌。这个索引变量将定义柱状图中每个垂直条形的位置。
- en: Set up the plot’s title, labels, and so on. Name the plot *window* 'Percentage
    First Digits' ➍, then display a title *within* the plot ➎. I am using generic
    titles, but you can customize these to be more specific. Use the fontsize keyword
    argument to set the text size to 15. Note that the window title is an attribute
    of fig, but the other labels will be attributes of ax.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 设置图表的标题、标签等。将图表的*窗口*命名为 '百分比首位数字' ➍，然后在图表*内部*显示标题 ➎。这里使用的是通用标题，你可以根据需要自定义这些标题。使用
    fontsize 关键字参数将文本大小设置为 15。注意，窗口标题是 fig 的属性，而其他标签将是 ax 的属性。
- en: Use set_ylabel() to name the y-axis “Frequency (%)” ➏, then set the x-axis tick
    marks based on the index variable ➐. The tick labels will be the numbers 1 through
    9, so use the index variable again and set the font size to 14.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 set_ylabel() 设置 y 轴的名称为“频率（%）”➏，然后根据索引变量设置 x 轴的刻度标记➐。刻度标签将是数字 1 到 9，因此再次使用索引变量，并将字体大小设置为
    14。
- en: '***Completing the Bar Chart Function***'
  id: totrans-185
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***完成柱状图函数***'
- en: '[Listing 16-6](ch16.xhtml#ch16list6) completes the bar_chart() function by
    defining the bars, annotating the top of each bar with its frequency value, and
    plotting the Benford distribution values as red-filled circles.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 16-6](ch16.xhtml#ch16list6) 完成了 bar_chart() 函数，通过定义柱形图，注释每个柱形顶部的频率值，并将本福德分布的值绘制为红色填充圆点。'
- en: '*benford.py,* part 6'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '*benford.py,* 第 6 部分'
- en: '# build bars'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '# 构建柱状图'
- en: ➊ rects = ax.bar(index, data_pct, width=0.95, color='black', label='Data')
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ rects = ax.bar(index, data_pct, width=0.95, color='black', label='数据')
- en: '# attach a text label above each bar displaying its height'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '# 在每个柱形图上方附加一个文本标签，显示其高度'
- en: '➋ for rect in rects:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '➋ for rect in rects:'
- en: ➌ height = rect.get_height()
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ height = rect.get_height()
- en: ➍ ax.text(rect.get_x() + rect.get_width()/2, height,
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ ax.text(rect.get_x() + rect.get_width()/2, height,
- en: '''{:0.1f}''.format(height), ha=''center'', va=''bottom'','
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '''{:0.1f}''.format(height), ha=''center'', va=''bottom'','
- en: fontsize=13)
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: fontsize=13)
- en: '# plot Benford values as red dots'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '# 绘制本福德值作为红点'
- en: ➎ ax.scatter(index, BENFORD, s=150, c='red', zorder=2, label='Benford')
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ ax.scatter(index, BENFORD, s=150, c='red', zorder=2, label='本福德')
- en: '# Hide the right and top spines & add legend'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '# 隐藏右边和上边的坐标轴线并添加图例'
- en: ➏ ax.spines['right'].set_visible(False)
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: ➏ ax.spines['right'].set_visible(False)
- en: ax.spines['top'].set_visible(False)
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: ax.spines['top'].set_visible(False)
- en: ➐ ax.legend(prop={'size':15}, frameon=False)
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ➐ ax.legend(prop={'size':15}, frameon=False)
- en: ➑ plt.show()
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: ➑ plt.show()
- en: '*Listing 16-6: Completes the function for generating a bar chart*'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 16-6：完成生成条形图的函数*'
- en: Name a variable, called rects, for rectangles, and use it to hold the bars for
    the bar chart ➊. You generate these with the bar() method, which returns a container
    with all the bars. Pass it the index variable and list of frequency counts as
    percentages, set the width of each bar to 0.95, fill them with black, and set
    the label argument to 'Data'. The last parameter is a very handy way to autogenerate
    a legend. You’ll take advantage of this near the end of the function.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 给矩形命名一个变量，叫做 rects，并用它来保存条形图的条形 ➊。通过 bar() 方法生成这些条形，它返回一个包含所有条形的容器。将 index 变量和按百分比表示的频率计数列表传递给它，将每个条形的宽度设置为
    0.95，填充为黑色，并将标签参数设置为 'Data'。最后一个参数是一个非常方便的方式来自动生成图例。你将在函数的后面部分利用这个功能。
- en: I’m a fan of plotting the actual bar value just above the bar so you don’t have
    to squint over at the y-axis and try to guess it. To do this, start by looping
    through each bar (rect) in rects ➋ and get its height ➌, which is its y-axis value.
    Then, call the ax object’s text() method ➍ and pass it the x-location of the left-hand
    side of the bar—obtained with the get_x() method—and add to it half the width
    of the bar in order to center the label over the bar. Because you use the get_width()
    method, you only have to assign the bar width once, which you did in step ➊. Next
    comes the bar height—formatted to one decimal place—followed by the horizontal
    and vertical alignments. Set these to the center and the bottom of the text bounding
    box, respectively. Finish by assigning the text size.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我是将实际的条形值绘制在条形上方的粉丝，这样你就不需要眯着眼睛去看 y 轴并尝试猜测它的值。为此，从遍历每个条形（矩形）开始，在 rects ➋ 中获取它的高度
    ➌，也就是它的 y 轴值。然后，调用 ax 对象的 text() 方法 ➍，传入条形左侧的 x 位置——通过 get_x() 方法获得——并加上条形宽度的一半，以便将标签居中于条形上方。由于你使用了
    get_width() 方法，你只需要在步骤 ➊ 中为条形宽度赋值一次。接下来是条形的高度——格式化为一位小数——后面是水平和垂直对齐方式。将它们分别设置为文本边框的中心和底部。最后，设置文本的大小。
- en: Now, start building the matplotlib “markers”—in this case, dots—that will flag
    the location of the Benford distribution frequencies for each first digit. Do
    this using the scatter() method, which builds scatterplots ➎.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，开始构建 matplotlib “标记”——在这种情况下是圆点——标记每个首位数字的 Benford 分布频率的位置。使用 scatter() 方法来实现，它用于构建散点图
    ➎。
- en: The first two arguments for scatter() are the x-y locations for each marker,
    represented by consecutive pairs from the index and BENFORD lists. Next is the
    marker size, set at 150, followed by a color. Both red and DodgerBlue work well.
    You want the markers to post on top of the bars, so set the zorder to 2. Elements
    in the figure are referred to as matplotlib “artists,” and artists with higher
    zorder values will plot over those with lower values. Finish with the label argument
    used to make a legend.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: scatter() 的前两个参数是每个标记的 x-y 位置，这些位置由 index 和 BENFORD 列表中的连续对组成。接下来是标记的大小，设置为
    150，然后是颜色。红色和 DodgerBlue 都很好。你希望标记显示在条形图的上方，因此将 zorder 设置为 2。图中的元素被称为 matplotlib
    “艺术家”，具有更高 zorder 值的艺术家会绘制在具有较低值的艺术家之上。最后，使用 label 参数来生成图例。
- en: The next two statements are for aesthetics. By default, matplotlib will draw
    a box around the interior of the plot, and the upper border may interfere with
    the labels posted at the top of each bar. So, remove the top and right borders
    by setting their visibility to False ➏.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两条语句是为了美观。默认情况下，matplotlib 会在图表内部绘制一个框，而上边框可能会干扰条形顶部的标签。因此，通过将它们的可见性设置为
    False ➏ 来去掉上边框和右边框。
- en: Use legend() to build a legend for the plot ➐. This will work with no arguments,
    but set its size attribute to 15 and turn off the frame around the legend for
    an arguably more attractive result. End by calling plt.show() to display the chart
    ➑. An example bar chart is shown in [Figure 16-7](ch16.xhtml#ch16fig7).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 legend() 为图表构建图例 ➐。这可以不带任何参数工作，但将其大小属性设置为 15，并关闭图例周围的框架，以获得更具吸引力的效果。最后，调用
    plt.show() 显示图表 ➑。示例条形图如 [图 16-7](ch16.xhtml#ch16fig7) 所示。
- en: '![image](../images/f0360-01.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0360-01.jpg)'
- en: '*Figure 16-7: Example output of the* bar_chart() *function*'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 16-7：* bar_chart() *函数的示例输出*'
- en: In the main() function, you will display additional information as text in the
    interpreter window. This will include the value of the chi-square test statistic.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在 main() 函数中，你将以文本形式显示更多信息，这些信息将在解释器窗口中显示。包括卡方检验统计量的值。
- en: '***Defining and Running the main() Function***'
  id: totrans-213
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***定义和运行 main() 函数***'
- en: '[Listing 16-7](ch16.xhtml#ch16list7) defines the main() function and runs the
    program as a module or stand-alone. Since most of the work is done in the individual
    functions, main() “mainly” calls these functions and prints some statistics.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 16-7](ch16.xhtml#ch16list7) 定义了 main() 函数，并以模块或独立程序的形式运行。由于大部分工作在各个单独的函数中完成，main()
    “主要”调用这些函数并打印一些统计信息。'
- en: '*benford.py,* part 7'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '*benford.py,* 第 7 部分'
- en: 'def main():'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 'def main():'
- en: '"""Call functions and print stats."""'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '"""调用函数并打印统计信息。"""'
- en: '# load data'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '# 加载数据'
- en: 'while True:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: '➊ filename = input("\nName of file with COUNT data: ")'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ filename = input("\n包含 COUNT 数据的文件名：")
- en: 'try:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 'try:'
- en: data_list = load_data(filename)
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: data_list = load_data(filename)
- en: 'except IOError as e:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 'except IOError as e:'
- en: print("{}. Try again.".format(e), file=sys.stderr)
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: print("{}. 请再试一次。".format(e), file=sys.stderr)
- en: 'else:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: break
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: break
- en: ➋ data_count, data_pct, total_count = count_first_digits(data_list)
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ data_count, data_pct, total_count = count_first_digits(data_list)
- en: ➌ expected_counts = get_expected_counts(total_count)
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ expected_counts = get_expected_counts(total_count)
- en: print("\nobserved counts = {}".format(data_count))
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: print("\n观察到的计数 = {}".format(data_count))
- en: print("expected counts = {}".format(expected_counts), "\n")
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: print("预期计数 = {}".format(expected_counts), "\n")
- en: ➍ print("First Digit Probabilities:")
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ print("首位数字概率：")
- en: '➎ for i in range(1, 10):'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '➎ for i in range(1, 10):'
- en: 'print("{}: observed: {:.3f}  expected: {:.3f}".'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 'print("{}: 观察到: {:.3f}  预期: {:.3f}"。'
- en: format(i, data_pct[i - 1] / 100, BENFORD[i - 1] / 100))
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: format(i, data_pct[i - 1] / 100, BENFORD[i - 1] / 100))
- en: '➏ if chi_square_test(data_count, expected_counts):'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '➏ if chi_square_test(data_count, expected_counts):'
- en: print("Observed distribution matches expected distribution.")
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: print("观察到的分布与预期分布一致。")
- en: 'else:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: print("Observed distribution does not match expected.",
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: print("观察到的分布与预期不符。",
- en: file=sys.stderr)
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: file=sys.stderr)
- en: ➐ bar_chart(data_pct)
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: ➐ bar_chart(data_pct)
- en: '➑ if __name__ == ''__main__'':'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '➑ if __name__ == ''__main__'':'
- en: main()
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: main()
- en: '*Listing 16-7: Defines the* main() *function and runs the program as a module
    or stand-alone*'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 16-7: 定义了* main() *函数并以模块或独立程序的形式运行*'
- en: 'Start by asking the user to input the name of the file with the count data
    to be analyzed ➊; embed this request in a while loop that will continue until
    the user enters a valid filename or closes the window. The user can enter a filename
    or a full pathname if they want to load a dataset that isn’t stored in the current
    working directory. For example, in Windows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，要求用户输入要分析的包含计数数据的文件名 ➊；将此请求嵌入一个 while 循环，直到用户输入有效的文件名或关闭窗口为止。用户可以输入文件名或完整路径名，如果他们想加载存储在当前工作目录之外的数据集。例如，在
    Windows 上：
- en: 'Name of file with COUNT data: C:\Python35\Benford\Illinois_votes.txt'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 文件名（包含 COUNT 数据）：C:\Python35\Benford\Illinois_votes.txt
- en: Use a try statement to call the load_data() function you built earlier and pass
    the function the filename. If the filename is valid, the returned list is assigned
    to the data_list variable. If an exception occurs, catch it and print the error.
    Otherwise, break from the while loop.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 try 语句调用你之前构建的 load_data() 函数，并将文件名传递给该函数。如果文件名有效，返回的列表将赋值给 data_list 变量。如果发生异常，捕获并打印错误信息。否则，跳出
    while 循环。
- en: Next, pass the returned list of data counts to the count_first_digits() function
    and unpack the results as the variables data_count, data_pct, and total_count,
    which are lists of the first-digit counts, percentages, and total number of counts,
    respectively ➋. Then, generate a list of the counts expected for a Benford’s law
    distribution by calling the get_expected_counts() function and passing it the
    total_count variable ➌. Print the lists of observed and expected counts.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将返回的数据计数列表传递给 count_first_digits() 函数，并将结果解包为变量 data_count、data_pct 和 total_count，它们分别是首位数字计数、百分比和总计数的列表
    ➋。然后，通过调用 get_expected_counts() 函数并传递 total_count 变量，生成一个符合本福特定律分布的预期计数列表 ➌。打印观察到的计数和预期计数列表。
- en: Now, make a table that compares the first-digit frequency in the data with the
    expected values. Use probabilities, as decimal values are easy to keep attractively
    aligned in the shell. Start with a header print statement ➍, then loop through
    the numbers 1 to 9, printing the results for the observed counts (data), followed
    by the expected counts, each to three decimal places ➎. Note that the indexes
    in the two lists start with zero, so you have to subtract 1 from i.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，制作一个表格，将数据中的首位数字频率与预期值进行比较。使用概率，因为十进制值在 shell 中易于对齐。首先使用一个标题打印语句 ➍，然后循环遍历数字1到9，打印观察到的计数（数据）结果，接着是预期计数，每个结果保留三位小数
    ➎。注意，两列表中的索引从零开始，因此你必须从 i 中减去1。
- en: Pass the two count lists to the chi_square_test() function in order to calculate
    how well the observed data fit the expected distribution ➏. If the function returns
    True, use a print statement to let the user know the observed distribution matches
    Benford’s law (or, more technically, *there is no significant difference* between
    the two). Otherwise, report that they don’t match, and for shell users, color
    the font red.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 将两个计数列表传递给chi_square_test()函数，以计算观察到的数据与预期分布的契合度 ➏。如果该函数返回True，使用打印语句告诉用户观察到的分布符合本福德定律（或者，更技术性地说，*两者之间没有显著差异*）。否则，报告它们不匹配，并且对于
    shell 用户，将字体颜色设置为红色。
- en: The chi_square_test() function will display its results in the interpreter window,
    so call the bar_chart() function to generate a bar chart ➐. Pass it the list of
    data counts as percentages.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: chi_square_test()函数将在解释器窗口中显示其结果，因此调用 bar_chart() 函数来生成柱状图 ➐。将数据计数的百分比列表传递给它。
- en: Back in the global space, end the program with the code for running it as a
    module or in stand-alone mode ➑.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 回到全局空间，用运行程序的代码结束它，可以作为模块或独立模式运行 ➑。
- en: If you run the program on the *Illinois_votes.txt* dataset, you will see the
    output shown in [Figure 16-8](ch16.xhtml#ch16fig8). There is no apparent anomaly
    in the voting results, based on Benford’s law.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 *Illinois_votes.txt* 数据集上运行程序，你将看到[图16-8](ch16.xhtml#ch16fig8)所示的输出。根据本福德定律，选票结果没有明显异常。
- en: '![image](../images/f0362-01.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0362-01.jpg)'
- en: '*Figure 16-8: Output of* benford.py *for the dataset* Illinois_votes.txt'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '*图16-8：* benford.py *程序对数据集 Illinois_votes.txt 的输出*'
- en: If you run the program using only the Trump votes, then only the Clinton votes,
    you get the results shown in [Figure 16-9](ch16.xhtml#ch16fig9). Trump’s distribution,
    with a test statistic of 15.129, barely passes the chi-square test.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果只使用特朗普的选票运行程序，然后再使用克林顿的选票，你将获得[图16-9](ch16.xhtml#ch16fig9)所示的结果。特朗普的分布，检验统计量为15.129，刚好通过卡方检验。
- en: '![image](../images/f0363-01.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0363-01.jpg)'
- en: '*Figure 16-9: Comparison of Trump results (left) versus Clinton results (right)
    for the state of Illinois*'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '*图16-9：特朗普结果（左）与克林顿结果（右）的比较（伊利诺伊州）*'
- en: In cases like this, you should be careful about drawing immediate conclusions.
    The dataset is small—only 102 samples per candidate—and the results may be influenced
    by things like demographic and voter turnout differences between rural and urban
    areas. An interesting article on this urban-rural divide can be found at *[http://www.chicagotribune.com/news/data/ct-illinois-election-urban-rural-divide-2016-htmlstory.html](http://www.chicagotribune.com/news/data/ct-illinois-election-urban-rural-divide-2016-htmlstory.html)*.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你应该小心立即得出结论。数据集很小——每个候选人只有102个样本——结果可能受到农村和城市地区的选民构成以及选民投票率差异的影响。有关这种城乡差距的有趣文章可以在
    *[http://www.chicagotribune.com/news/data/ct-illinois-election-urban-rural-divide-2016-htmlstory.html](http://www.chicagotribune.com/news/data/ct-illinois-election-urban-rural-divide-2016-htmlstory.html)*
    找到。
- en: 'In “[Practice Project: Beating Benford](ch16.xhtml#lev393)” on [page 364](ch16.xhtml#page_364),
    you’ll get a chance to tamper with the Illinois vote counts and alter the outcome.
    You’ll then use the preceding code to see how well the results conform to Benford’s
    law.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在“[实践项目：击败本福德](ch16.xhtml#lev393)”中，[第364页](ch16.xhtml#page_364)将有机会篡改伊利诺伊州的选票统计，并改变结果。然后你将使用前面的代码来查看结果与本福德定律的契合度。
- en: '**Summary**'
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: Way back in [Chapter 1](ch01.xhtml#ch01), we used the “[Poor Man’s Bar Chart](ch01.xhtml#lev28)”
    practice project on [page 15](ch01.xhtml#page_15) and the “[Poor Foreign Man’s
    Bar Chart](ch01.xhtml#lev30)” challenge project on [page 16](ch01.xhtml#page_16)
    to look at how the frequency of occurrence of letters in a language is both irregular
    and predictable. This provides a powerful tool for cryptanalysis. Here at the
    end of the book, we’ve come full circle and found that even numbers share this
    trait, resulting in a powerful tool for fraud detection. With a short and simple
    Python program, you can shake the very pillars of heaven and bring the high and
    mighty crashing down to earth—all because someone noticed that the front pages
    of a book were dirty.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.xhtml#ch01)中，我们使用了[第15页](ch01.xhtml#page_15)的“[穷人条形图](ch01.xhtml#lev28)”实践项目和[第16页](ch01.xhtml#page_16)的“[穷外国人条形图](ch01.xhtml#lev30)”挑战项目，分析了语言中字母出现频率的不规则性和可预测性。这为密码分析提供了强大的工具。在书的结尾，我们已经回到了起点，并发现即使是数字也具有这种特性，从而为欺诈检测提供了一个强有力的工具。只需一个简短简单的Python程序，你就能动摇天柱，把那些高高在上的人拉到地面——这一切都是因为有人注意到一本书的封面脏了。
- en: Well, that does it for *Impractical Python Projects*. I hope you had fun, learned
    something new, and were inspired to create your own set of impractical projects!
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这就是*《不实用的Python项目》*的全部内容。希望你玩得开心，学到了新知识，并且激发了你自己创造不实用项目的灵感！
- en: '**Further Reading**'
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**进一步阅读**'
- en: '*Benford’s Law: Applications for Forensic Accounting, Auditing, and Fraud Detection*
    (John Wiley & Sons, 2012) by Mark Nigrini covers the mathematics, theory, and
    testing of Benford’s law together with example applications, including fraud,
    tax evasion, and Ponzi schemes.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '*《本福德定律：法务会计、审计与欺诈检测的应用*（John Wiley & Sons，2012年）*由马克·尼格里尼（Mark Nigrini）撰写，涵盖了本福德定律的数学、理论和测试，并提供了实际应用的例子，包括欺诈、逃税和庞氏骗局。'
- en: '**Practice Project: Beating Benford**'
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**实践项目：战胜本福德**'
- en: Test your skill at rigging an election using this practice project. You can
    find a solution, *beat_benford_practice.py*, in the appendix or download it from
    *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个实践项目，测试你在操控选举方面的技能。你可以在附录中找到解决方案，文件名为*beat_benford_practice.py*，或者从*[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*下载。
- en: 'A dataset shouldn’t be considered valid just because it follows Benford’s law.
    The reason is simple: if you know about Benford’s law, then you can beat it.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 数据集仅因遵循本福德定律而不应被认为是有效的。原因很简单：如果你了解本福德定律，那么你就能战胜它。
- en: To prove this, pretend you’re a high-level hacker for a nefarious foreign government
    with access to all the voting records in the state of Illinois. Write a Python
    program that tampers with county-wide votes so that Donald Trump wins the state,
    but the vote counts still obey Benford’s law. Be careful; Illinois is a “blue”
    state, so you don’t want to engineer a landslide victory (loosely defined as a
    10–15 percentage point advantage in the popular vote). To avoid suspicion, Trump
    should squeak by with a few percentage points.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明这一点，假设你是一个为邪恶外国政府工作的高级黑客，拥有伊利诺伊州所有选票记录的访问权限。编写一个Python程序，篡改全县选票，使唐纳德·特朗普赢得该州，但选票计数仍然遵循本福德定律。小心；伊利诺伊州是一个“蓝色”州，因此你不希望制造压倒性的胜利（通常定义为流行票中10-15个百分点的优势）。为了避免引起怀疑，特朗普应该以几个百分点的微弱优势获胜。
- en: '**NOTE**'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*States have rules regarding the recount of votes. Before manipulating an election,
    a fraudster would want to be aware of these to avoid the scrutiny a recount would
    bring. The actual statutory rules for each state are no fun to read, but the Citizens
    for Election Integrity Minnesota provides approachable summaries. The one for
    Illinois can be found at* [https://ceimn.org/searchable-databases/recount-database/illinois/](https://ceimn.org/searchable-databases/recount-database/illinois/).'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '*各州对于重新计票有相应的规定。在操控选举之前，欺诈者需要了解这些规则，以避免重新计票所带来的审查。每个州的实际法定规则都不好读，但明尼苏达州选举公正市民组织提供了简明的总结。伊利诺伊州的总结可以在*
    [https://ceimn.org/searchable-databases/recount-database/illinois/](https://ceimn.org/searchable-databases/recount-database/illinois/)
    *找到。'
- en: Your program should steal votes from the other candidates, while preserving
    the by-county totals; that way, the total number of votes cast doesn’t change.
    As a quality-control step, print out the old and new vote totals by county for
    Trump and Clinton, as well as their old and new statewide totals. Then, write
    out a text file that you can input into *benford.py* so you can check how you
    did with respect to Benford’s law.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 你的程序应该从其他候选人那里偷取选票，同时保留按县划分的总票数；这样，投出的选票总数就不会改变。作为质量控制步骤，打印出特朗普和克林顿按县的旧票数和新票数，以及他们的旧的和新的全州票数。然后，写出一个文本文件，输入到*benford.py*中，这样你可以检查自己是否符合本福德定律。
- en: Datasets for each candidate are already prepared and listed here; you can download
    them from *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*.
    Each of these datasets is just a column of numbers, representing votes, that has
    been sorted alphabetically by county (so don’t change the order!).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 每个候选人的数据集已经准备好并列在这里；你可以从*[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*下载它们。每个数据集只是按县字母顺序排列的投票数列（所以不要改变顺序！）。
- en: '*Clinton_votes_Illinois.txt*'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '*Clinton_votes_Illinois.txt*'
- en: '*Johnson_votes_Illinois.txt*'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '*Johnson_votes_Illinois.txt*'
- en: '*Stein_votes_Illinois.txt*'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '*Stein_votes_Illinois.txt*'
- en: '*Trump_votes_Illinois.txt*'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '*Trump_votes_Illinois.txt*'
- en: '[Figure 16-10](ch16.xhtml#ch16fig10) shows the results of running *benford.py*
    on the output from my attempt, *beat_benford_practice.py*, which used the preceding
    datasets. The distribution passes the chi-square test and yields a visually convincing—but
    plausibly imperfect—fit to the values predicted by Benford’s law.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '[图16-10](ch16.xhtml#ch16fig10)显示了在我的尝试*beat_benford_practice.py*的输出上运行*benford.py*的结果，使用了上述数据集。该分布通过了卡方检验，并且在视觉上与本福德定律所预测的值相匹配——尽管有些不完美，但依然有说服力。'
- en: '![image](../images/f0365-01.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0365-01.jpg)'
- en: '*Figure 16-10: Results of running the distribution from* beat_benford_practice.py
    *in* benford.py*. Mischief managed!*'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '*图16-10：在*beat_benford_practice.py*输出中运行分布的结果，使用*benford.py*。恶作剧已完成！*'
- en: 'Shown here are a few lines of output from *beat_benford_practice.py*, with
    the old and new vote totals by county:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示了*beat_benford_practice.py*的一些输出行，包含按县划分的旧投票总数和新投票总数：
- en: '![image](../images/f0365-02.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0365-02.jpg)'
- en: The third line from the top represents Cook County, which contains Chicago.
    Note that Clinton still wins here, but by a lower margin. For Trump to win this
    blue county outright would be a tremendous red flag that vote tampering had occurred,
    even if he won the whole state by only a small margin!
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 从顶部第三行开始表示库克县（Cook County），该县包括芝加哥。请注意，克林顿仍然在这里获胜，但获胜幅度较小。如果特朗普直接赢得这个蓝色县，那么即使他仅凭微弱优势赢得整个州，这也会是一个巨大的红旗，表明可能发生了选举舞弊！
- en: '**Challenge Projects**'
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**挑战项目**'
- en: Try your hand at these challenge projects. No solutions are provided.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试一下这些挑战项目。没有提供解决方案。
- en: '***Benfording the Battlegrounds***'
  id: totrans-285
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***本福德定律与战场州***'
- en: No candidate needs to cheat in a state they’re guaranteed to win. If you’re
    an investigator looking into voter fraud, you would most likely start with the
    battleground states. These could swing either way, and candidates spend much of
    their war chest—and time—on these places. According to Ballotpedia (*[https://ballotpedia.org](https://ballotpedia.org)*),
    Trump’s battleground states in 2016 were Arizona, Iowa, Michigan, Wisconsin, Ohio,
    Pennsylvania, North Carolina, and Florida. Clinton’s were Colorado, Nevada, New
    Hampshire, and Virginia.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 没有候选人需要在自己必胜的州作弊。如果你是一个调查选民舞弊的调查员，你很可能会从战场州开始。战场州的选举结果可能朝任何一方倾斜，候选人会在这些地方花费大部分的选战资金和时间。根据Ballotpedia
    (*[https://ballotpedia.org](https://ballotpedia.org)*)，特朗普在2016年的战场州包括亚利桑那州、爱荷华州、密歇根州、威斯康星州、俄亥俄州、宾夕法尼亚州、北卡罗来纳州和佛罗里达州。克林顿的战场州包括科罗拉多州、内华达州、新罕布什尔州和弗吉尼亚州。
- en: 'The online voting records for states are commonly provided in a number of formats,
    such as Microsoft Excel spreadsheets. Gather the ones for the battleground states,
    convert them to text files, and run them through *benford.py*. To get you started,
    you can find the Ohio records here: *[https://www.sos.state.oh.us/elections/](https://www.sos.state.oh.us/elections/)*.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 各州的在线投票记录通常以多种格式提供，例如Microsoft Excel电子表格。收集战场州的投票记录，将其转换为文本文件，并通过*benford.py*运行它们。为了帮助你入门，你可以在这里找到俄亥俄州的记录：*[https://www.sos.state.oh.us/elections/](https://www.sos.state.oh.us/elections/)*。
- en: '***While No One Was Looking***'
  id: totrans-288
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***当无人注意时***'
- en: Former Speaker of the US House of Representatives Tip O’Neill was famous for
    saying, “All politics is local.” Take this to heart and use the *benford.py* program
    to check out some of your local area races, such as for judges, mayors, county
    supervisors, sheriffs, and city council members. These events generally attract
    less scrutiny than do races for Senate seats, governor, or president. If you find
    an irregularity, make sure the voting dataset is a valid application for Benford’s
    law before raising a stink!
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 美国众议院前议长蒂普·奥尼尔（Tip O’Neill）曾以一句话而闻名：“所有政治都是地方性的。”牢记这一点，使用*benford.py*程序查看你所在地区的一些选举，比如法官、市长、县监事、警长和市议会成员的选举。这些选举通常比参议员、州长或总统的选举吸引的关注少。如果你发现了不规则情况，务必确保选举数据集符合本福德定律的适用条件，然后再大张旗鼓地反映问题！
