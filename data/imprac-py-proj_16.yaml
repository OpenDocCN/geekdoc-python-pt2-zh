- en: '**16'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**16'
- en: FINDING FRAUDS WITH BENFORD’S LAW**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**利用本福德定律发现欺诈**'
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: Prior to the invention of electronic calculators, if you needed to take the
    log of a number, you looked it up in a table. Astronomer Simon Newcomb used such
    tables, and in 1881, he noticed that the pages in the front, used for numbers
    beginning with the lowest digits, were more worn than those in the back. From
    this mundane observation, he realized that—at least for measurements and constants
    in nature—the leading digits were much more likely to be small than large. He
    published a short article about it and moved on.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在电子计算器发明之前，如果你需要计算一个数字的对数，你需要查阅表格。天文学家西蒙·纽康（Simon Newcomb）使用过这样的表格，并且在1881年，他注意到前面几页表格上用于查找以最小数字开头的数字，比后面几页的表格更加磨损。通过这一平凡的观察，他意识到——至少对于自然界中的测量值和常数——首位数字更有可能是小数字，而不是大数字。他发表了一篇简短的文章并继续前行。
- en: For decades, this statistical curiosity, like Tolkien’s One Ring, “passed out
    of all knowledge.” Then, in 1938, physicist Frank Benford rediscovered and confirmed
    the phenomenon by collecting over 20,000 samples of real-world numbers, using
    data sources as diverse as the measurements of rivers, street addresses, numbers
    contained in *Reader’s Digest* magazine, molecular weights, baseball statistics,
    death rates, and more. As the person who popularized this scientific discovery,
    he got all the credit.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 几十年来，这一统计学现象，像托尔金的魔戒一样，“被人们所遗忘。”直到1938年，物理学家弗兰克·本福德重新发现并证实了这一现象，他收集了超过20,000个真实世界数据样本，数据来源包括河流的测量、街道地址、《读者文摘》杂志中的数字、分子质量、棒球统计、死亡率等等。作为推广这一科学发现的人，他得到了所有的荣誉。
- en: According to *Benford’s law*, also known as the *first-digit law*, the frequency
    of occurrence of the leading digits in naturally occurring numerical distributions
    is predictable and nonuniform. In fact, a given number is six times more likely
    to start with a 1 than a 9! This is very counterintuitive, as most people would
    expect a uniform distribution, with each number having a one in nine (11.1 percent)
    chance of occupying the first slot. Due to this cognitive disconnect, Benford’s
    law has become a useful tool for fraud detection in financial, scientific, and
    election data.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 根据*本福德定律*，也被称为*首位数字定律*，自然发生的数字分布中，首位数字的出现频率是可预测的，并且是不均匀的。事实上，一个数字以1开头的概率是以9开头的概率的六倍！这一点非常反直觉，因为大多数人会认为数字的分布是均匀的，每个数字以1/9（11.1%）的概率出现在第一位。由于这种认知偏差，本福德定律已成为财务、科学和选举数据中用于欺诈检测的有力工具。
- en: In this chapter, you’ll write a Python program that compares real-life datasets
    to Benford’s law and determines whether they appear fraudulent or not. You’ll
    also dust off `matplotlib` one last time to add a useful visual component to the
    analysis. For a dataset, you’ll use votes cast in the contentious 2016 US presidential
    election.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你将编写一个 Python 程序，比较现实生活中的数据集与本福德定律，并判断它们是否存在欺诈行为。你还将最后一次使用`matplotlib`，为分析添加一个有用的可视化组件。作为数据集，你将使用2016年美国总统选举中投出的选票。
- en: '**Project #24: Benford’s Law of Leading Digits**'
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**项目 #24：本福德的首位数字定律**'
- en: '[Figure 16-1](ch16.xhtml#ch16fig1) depicts a bar chart of the leading significant
    digits in a set of numbers following Benford’s law. Surprisingly, scale doesn’t
    matter. A tabulation of the length of Australian roads will follow Benford’s law
    whether it is in miles, kilometers, or cubits! As a statistical principle, it
    is *scale invariant*.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '[图16-1](ch16.xhtml#ch16fig1)显示了一组符合本福德定律的数字的首位有效数字的条形图。令人惊讶的是，尺度并不重要。无论澳大利亚道路的长度是以英里、公里还是古比特为单位，统计出来的结果都会遵循本福德定律！作为一个统计原理，它是*尺度不变*的。'
- en: '![image](../images/f0348-01.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0348-01.jpg)'
- en: '*Figure 16-1: The frequency of occurrence of leading digits according to Benford’s
    law*'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*图16-1：根据本福德定律，首位数字的出现频率*'
- en: It took mathematicians about a hundred years to come up with an explanation
    for Benford’s law that *they* found satisfactory. For the rest of us, let’s just
    say that there are more little things in the universe than large things. Frank
    Benford used the analogy that owning *one* acre of land is easier than owning
    *nine* acres. In fact, you can closely duplicate the frequency produced by Benford’s
    law by simply assuming that there are twice as many 1s as 2s, three times as many
    1s as 3s, and so on. You just take the inverse of each of the nine digits (1 /
    *d*) and divide by the sum of all the inverses (2.83). Then multiply the results
    by 100 to get the percentage (see [Figure 16-2](ch16.xhtml#ch16fig2)).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 数学家们花了大约一百年的时间来找出一个他们认为令人满意的本福特定律解释。对于我们其他人来说，让我们只说宇宙中的小事物比大事物多。弗兰克·本福特用拥有*一*英亩土地比拥有*九*英亩更容易的类比。事实上，你可以通过假设1的个数是2的两倍，3的个数是1的三倍，依此类推，来紧密地复制本福特定律产生的频率。只需取每个九个数字的倒数（1
    / *d*），然后除以所有倒数的总和（2.83）。然后将结果乘以100以获得百分比（见[图16-2](ch16.xhtml#ch16fig2)）。
- en: '![image](../images/f0349-01.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0349-01.jpg)'
- en: '*Figure 16-2: Comparison of Benford’s law with an approximation proportional
    to the inverse of the first digit*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*图16-2：本福特定律与首位数字的倒数成比例的近似比较*'
- en: Because of the size relationships just discussed, Benford’s law can be visualized
    with a *logarithmic* scale, which is used to graph data that are related according
    to an exponential relationship. In *semilogarithmic* (“semilog”) plots, one variable
    tends to be restricted, like the set of leading digits (1–9), while the other
    covers a wide range of values that includes several orders of magnitude.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 由于刚讨论的尺寸关系，本福特定律可以通过*对数*刻度进行可视化，该刻度用于绘制按指数关系相关的数据。在*半对数*（“半对数”）图中，一个变量往往受限，如前导数字集（1–9），而另一个变量则覆盖包括几个数量级的广泛数值。
- en: On semilog graph paper, the horizontal x-axis values are log values, and the
    vertical y-axis values, represented by horizontal lines, are not (see [Figure
    16-3](ch16.xhtml#ch16fig3)). On the x-axis, the horizontal divisions aren’t regular,
    and this nonlinear pattern repeats with powers of 10\. For every *decade* on the
    log paper, such as 1 through 10 or 10 through 100, the *width* of the divisions
    between numbers is proportional to the *length* of the bars in [Figure 16-1](ch16.xhtml#ch16fig1).
    For example, the distance between the 1 and 2 in [Figure 16-3](ch16.xhtml#ch16fig3)
    is 30.1 percent of the distance between 1 and 10\. As one author put it, you could
    derive Benford’s law by simply throwing darts at a piece of log paper!
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在半对数图纸上，水平x轴值为对数值，垂直y轴值由水平线表示，不是（见[图16-3](ch16.xhtml#ch16fig3)）。在x轴上，水平划分不规则，这种非线性模式随10的幂重复。在对数纸上的每*十年*，如1至10或10至100，数值之间的划分宽度与[图16-1](ch16.xhtml#ch16fig1)中条形的长度成比例。例如，[图16-3](ch16.xhtml#ch16fig3)中1和2之间的距离是1和10之间距离的30.1％。正如一位作者所说，你可以通过简单地将飞镖扔到对数纸上来得出本福特定律！
- en: '![image](../images/f0349-02.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0349-02.jpg)'
- en: '*Figure 16-3: Example of two-decade semilogarithmic graph paper*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*图16-3：两个十年半对数图纸示例*'
- en: For a collection of numeric data to conform to Benford’s law, certain conditions
    have to be met. The numbers need to be random and not assigned, with no imposed
    minimums or maximums. The numbers should cover several orders of magnitude, and
    the dataset should be large; recommendations in the literature call for 100 to
    1,000 samples as a minimum, though Benford’s law has been shown to hold true for
    datasets containing as few as 50 numbers. Examples of distributions that won’t
    follow Benford’s law are the heights of professional basketball players, US telephone
    numbers (for which only the last four digits are truly random), prices influenced
    by psychological barriers ($1.99 versus $2.00), and medical copayments.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要使数字数据集符合本福特定律，必须满足一定条件。数字必须是随机的，没有指定的最小值或最大值。数字应覆盖几个数量级，并且数据集应该足够大；文献中的建议要求至少100到1,000个样本，尽管已经证明即使包含50个数字的数据集也可以符合本福特定律。不遵循本福特定律的分布示例包括职业篮球运动员的身高、美国电话号码（仅最后四位数字是真正随机的）、受心理障碍影响的价格（$1.99与$2.00之间）以及医疗保险的赔款。
- en: '***Applying Benford’s Law***'
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***应用本福特定律***'
- en: Most financial and accounting data conform to naturally occurring numbers and
    are thus subject to Benford’s law. For example, assume you own a stock mutual
    fund with a value of $1,000\. For your fund to reach $2,000 in value, it would
    have to double by growing 100 percent. To increase from $2,000 to $3,000, it would
    only need to grow by 50 percent. For the first digit to be a 4, it needs to grow
    by another 33 percent. As Benford’s law predicts, for the leading digit 1 to become
    2, there needs to be more growth than for the 3 to become 4, and so on. Because
    a Benford distribution is a “distribution of distributions,” financial datasets
    tend to conform, as they result from combining numbers—though exceptions do occur.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数财务和会计数据遵循自然出现的数字，因此符合Benford定律。例如，假设你拥有一个价值1,000美元的股票共同基金。为了使基金的价值增长到2,000美元，它需要通过增长100%来实现翻倍。而从2,000美元增加到3,000美元，仅需增长50%。若要使首位数字为4，基金需要再增长33%。正如Benford定律预测的那样，首位数字从1变成2所需要的增长量大于从3变成4所需的增长量，依此类推。由于Benford分布是一种“分布的分布”，因此财务数据集通常符合这一规律，因为它们是由数字的组合而成——尽管也会有例外。
- en: Because people are generally unaware of Benford’s law, they don’t account for
    it when falsifying numerical records. This gives forensic accountants a powerful
    tool for quickly identifying datasets that may be fraudulent. In fact, comparisons
    to Benford’s law are legally admissible as evidence in US criminal cases at the
    federal, state, and local levels.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 因为人们通常没有意识到Benford定律，在伪造数字记录时往往没有考虑到这一点。这为法务会计师提供了一个强有力的工具，能够迅速识别可能存在欺诈行为的数据集。事实上，与Benford定律的比较在美国的联邦、州及地方刑事案件中作为证据是合法可接受的。
- en: In the 1993 case of *State of Arizona v. Nelson*, the accused diverted nearly
    $2 million to bogus vendors in an attempt to defraud the state. Despite taking
    care to make the fake checks look legitimate, the first-digit distribution clearly
    violated Benford’s law ([Figure 16-4](ch16.xhtml#ch16fig4)), leading to a conviction.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在1993年 *State of Arizona v. Nelson* 案中，被告将近200万美元转移到虚假的供应商账户，企图诈骗州政府。尽管被告小心翼翼地伪造了看似合法的支票，但首位数字的分布明显违反了Benford定律（见[图16-4](ch16.xhtml#ch16fig4)），最终导致定罪。
- en: '![image](../images/f0350-01.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0350-01.jpg)'
- en: '*Figure 16-4: Comparison of the frequency of first digits in fraudulent checks
    to anticipated Benford’s law frequency, State of Arizona v. Wayne James Nelson
    (CV92-18841)*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*图16-4：欺诈支票中的首位数字频率与预期的Benford定律频率的比较，State of Arizona v. Wayne James Nelson
    (CV92-18841)*'
- en: Benford’s law is also useful for internal business audits. Imagine a case where
    any travel and entertainment expenses over $10,000 must be approved by the company
    vice president. This type of financial threshold can tempt employees to do things
    like split invoices to game the system. [Figure 16-5](ch16.xhtml#ch16fig5) is
    based on a group of expenses ranging from $100 to $12,000, where all values greater
    than $9,999 were split into two equal halves. As you can guess, there is a spike
    in first-digit frequencies around 5 and 6, in clear violation of Benford’s law.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Benford定律对于内部商业审计也很有用。假设有一条规定，所有超过$10,000的差旅和娱乐费用必须由公司副总裁批准。这种财务阈值可能会诱使员工采取拆分发票等手段来规避系统。[图16-5](ch16.xhtml#ch16fig5)基于一组范围从$100到$12,000的费用，其中所有超过$9,999的值都被拆分为两等份。正如你可以猜到的，首位数字的频率在5和6附近出现了尖峰，明显违反了Benford定律。
- en: '![image](../images/f0351-01.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0351-01.jpg)'
- en: '*Figure 16-5: Splitting invoices over $9,999 for a dataset ranging from $100
    to $12,000 violates Benford’s law.*'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*图16-5：针对范围在$100到$12,000之间的账单，将金额超过$9,999的发票拆分，违反了Benford定律。*'
- en: On a grander scale, Benford’s law has revealed irregularities in the financial
    data—such as revenue numbers—of large corporations. An example from Enron, which
    practiced institutionalized accounting fraud, is shown in [Figure 16-6](ch16.xhtml#ch16fig6).
    Enron’s bankruptcy in 2001 was the largest in history at the time, and it resulted
    in the jailing of several top executives. The scandal also brought about the dissolution
    of Arthur Andersen, a “Big Five” accounting firm and one of the world’s largest
    multinational corporations.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在更广泛的层面上，Benford定律揭示了大型企业财务数据中的不规则性——例如收入数字。一个来自安然公司的例子，该公司曾经实行制度化的财务欺诈，见于[图16-6](ch16.xhtml#ch16fig6)。安然公司在2001年的破产是当时历史上最大的破产事件，导致多名高层管理人员入狱。此丑闻还导致了全球最大的一家跨国会计公司之一、“五大”会计事务所之一——安达信的解散。
- en: '![image](../images/f0351-02.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0351-02.jpg)'
- en: '*Figure 16-6: Frequency of first digits from Enron’s year 2000 financial data
    versus anticipated frequency based on Benford’s law (after the* Wall Street Journal*)*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*图16-6：来自恩隆2000年财务数据的首位数字频率与基于本福特定律的预期频率对比（摘自*《华尔街日报》*）*'
- en: Obviously, Benford’s law works best for fraud detection when the criminals are
    unaware of it. If you know how the law works, you can fool it, which we’ll do
    in a practice project at the end of this chapter. As a result, you can use Benford’s
    law to flag datasets that might be fraudulent, but you can’t use it to prove the
    opposite.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，当犯罪分子不知道本福特定律时，这一规律在欺诈检测中最有效。如果你了解这一规律的工作原理，你可以欺骗它，而我们将在本章末的实践项目中进行这一操作。因此，你可以使用本福特定律标记可能存在欺诈的数据集，但不能用它证明相反的情况。
- en: '***Performing the Chi-Square Test***'
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***进行卡方检验***'
- en: Auditors and investigators use multiple statistical methods to verify that a
    dataset obeys Benford’s law. In this project, you’ll use the *chi-square goodness-of-fit
    test*, which is a commonly used method for determining whether an empirical (observed)
    distribution differs significantly from a theoretical (expected) distribution.
    A significance level, or p*-value*, is used as the discriminator. The most common
    significance level is 0.05, but other common ones include 0.01 and 0.10\. A significance
    level of 0.05 indicates a 5 percent risk of erroneously concluding that a difference
    exists when it doesn’t.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 审计员和调查员使用多种统计方法验证数据集是否遵循本福特定律。在这个项目中，你将使用*卡方拟合优度检验*，这是一种常用的方法，用于确定经验（观察到的）分布是否与理论（预期）分布有显著差异。显著性水平或*p*-值用于区分两者。最常见的显著性水平是0.05，但其他常用的包括0.01和0.10。显著性水平为0.05表示5%的风险，即错误地得出存在差异的结论。
- en: 'Here are the steps for performing a chi-square goodness-of-fit test:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是进行卡方拟合优度检验的步骤：
- en: 'Find the *degrees of freedom* (*df*), defined as the number of categories (*k*)
    minus 1:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到*自由度*（*df*），它定义为类别数（*k*）减去1：
- en: '*df* = *k* – 1'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*df* = *k* – 1'
- en: For Benford’s law, the categorical levels are the first digits (1–9), so *df*
    = 8.
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于本福特定律，类别水平是首位数字（1–9），因此*df* = 8。
- en: 'Calculate the expected frequency count at each level by multiplying the sample
    size by the theoretical proportions at each level:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将样本大小乘以每个级别的理论比例来计算每个级别的预期频数：
- en: '*E[i]* = *np*[*i*]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*E[i]* = *np*[*i*]'
- en: where *E* is the expected frequency at the *i*th level, *n* is the sample size,
    and *p* is the theoretical probability at the *i*th level. For 1,000 samples,
    the number of samples expected to start with 1 in a Benford’s law distribution
    would be 1,000 × 0.301 = 301 (see [Figure 16-1](ch16.xhtml#ch16fig1)).
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其中，*E*是第*i*级的预期频率，*n*是样本大小，*p*是第*i*级的理论概率。对于1,000个样本，根据本福特定律分布，预期以1开头的样本数量为1,000
    × 0.301 = 301（见[图16-1](ch16.xhtml#ch16fig1)）。
- en: 'Calculate the chi-square random variable (*X*²), also known as the *test statistic*,
    which will allow you to judge whether the two distributions are the same:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算卡方随机变量（*X*²），也称为*检验统计量*，它可以帮助你判断两个分布是否相同：
- en: '![image](../images/f0352-01.jpg)'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](../images/f0352-01.jpg)'
- en: where *O* is the observed frequency count for the *i*th level of the categorical
    variable, *E* is the expected frequency count for the *i*th level of the categorical
    variable, and *df* represents the *degrees of freedom*.
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其中，*O*是类别变量第*i*级的观察频数，*E*是类别变量第*i*级的预期频数，*df*代表*自由度*。
- en: Refer to the *chi-square distribution table* ([Table 16-1](ch16.xhtml#ch16tab1)),
    reading across the row corresponding to the calculated degrees of freedom. If
    the test statistic is *less than* the value shown in the *p*-value column considered
    significant, then you can’t reject the hypothesis that the observed and theoretical
    distributions are the same.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查阅*卡方分布表*（[表16-1](ch16.xhtml#ch16tab1)），读取与计算得出的自由度对应的行。如果检验统计量*小于*在*p*-值列中显示的显著性值，那么你无法拒绝观察分布和理论分布相同的假设。
- en: '**Table 16-1:** Chi-Square Distribution Table'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**表16-1：** 卡方分布表'
- en: '| **Degrees of freedom** | **Probability of exceeding the critical value**
    |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| **自由度** | **超过临界值的概率** |'
- en: '| --- | --- |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| **0.99** | **0.95** | **0.90** | **0.75** | **0.50** | **0.25** | **0.10**
    | **0.05** | **0.01** |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| **0.99** | **0.95** | **0.90** | **0.75** | **0.50** | **0.25** | **0.10**
    | **0.05** | **0.01** |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- | --- |'
- en: '| 1 | 0.000 | 0.004 | 0.016 | 0.102 | 0.455 | 1.32 | 2.71 | 3.84 | 6.63 |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0.000 | 0.004 | 0.016 | 0.102 | 0.455 | 1.32 | 2.71 | 3.84 | 6.63 |'
- en: '| 2 | 0.020 | 0.103 | 0.211 | 0.575 | 1.386 | 2.77 | 4.61 | 5.99 | 9.21 |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 0.020 | 0.103 | 0.211 | 0.575 | 1.386 | 2.77 | 4.61 | 5.99 | 9.21 |'
- en: '| 3 | 0.115 | 0.352 | 0.584 | 1.212 | 2.366 | 4.11 | 6.25 | 7.81 | 11.34 |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 0.115 | 0.352 | 0.584 | 1.212 | 2.366 | 4.11 | 6.25 | 7.81 | 11.34 |'
- en: '| 4 | 0.297 | 0.711 | 1.064 | 1.923 | 3.357 | 5.39 | 7.78 | 9.49 | 13.28 |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 0.297 | 0.711 | 1.064 | 1.923 | 3.357 | 5.39 | 7.78 | 9.49 | 13.28 |'
- en: '| 5 | 0.554 | 1.145 | 1.610 | 2.675 | 4.351 | 6.63 | 9.24 | 11.07 | 15.09 |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 0.554 | 1.145 | 1.610 | 2.675 | 4.351 | 6.63 | 9.24 | 11.07 | 15.09 |'
- en: '| 6 | 0.872 | 1.635 | 2.204 | 3.455 | 5.348 | 7.84 | 10.64 | 12.59 | 16.81
    |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 0.872 | 1.635 | 2.204 | 3.455 | 5.348 | 7.84 | 10.64 | 12.59 | 16.81
    |'
- en: '| 7 | 1.239 | 2.167 | 2.833 | 4.255 | 6.346 | 9.04 | 12.02 | 14.07 | 18.48
    |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 1.239 | 2.167 | 2.833 | 4.255 | 6.346 | 9.04 | 12.02 | 14.07 | 18.48
    |'
- en: '| 8 | 1.647 | 2.733 | 3.490 | 5.071 | 7.344 | 10.22 | 13.36 | 15.51 | 20.09
    |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 1.647 | 2.733 | 3.490 | 5.071 | 7.344 | 10.22 | 13.36 | 15.51 | 20.09
    |'
- en: '| 9 | 2.088 | 3.325 | 4.168 | 5.899 | 8.343 | 11.39 | 14.68 | 16.92 | 21.67
    |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 9 | 2.088 | 3.325 | 4.168 | 5.899 | 8.343 | 11.39 | 14.68 | 16.92 | 21.67
    |'
- en: '| 10 | 2.558 | 3.940 | 4.865 | 6.737 | 9.342 | 12.55 | 15.99 | 18.31 | 23.21
    |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 2.558 | 3.940 | 4.865 | 6.737 | 9.342 | 12.55 | 15.99 | 18.31 | 23.21
    |'
- en: '|  | Not significant | Significant |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '|  | 不显著 | 显著 |'
- en: In Table 16-2, the critical value for a *p*-value of 0.05—at 8 degrees of freedom—is
    15.51\. If your calculated test statistic is less than 15.51, then the corresponding
    *p*-value is greater than 0.05, and you would conclude that there is *no statistically
    significant difference* between the observed distribution and the one predicted
    by Benford’s law. The *p*-value here is the probability that a test statistic
    having 8 degrees of freedom is more extreme than 15.51.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在表16-2中，对于*P*-值为0.05时，具有8个自由度的临界值为15.51。如果你计算出的检验统计量小于15.51，则对应的*P*-值大于0.05，你将得出结论，观察到的分布与本福德定律预测的分布之间*没有统计显著差异*。这里的*P*-值是指8个自由度的检验统计量比15.51更极端的概率。
- en: Note that you should perform the chi-square test on *counts*. If your data is
    in percentages, averages, ratios, or so on, then you’ll need to convert the values
    to counts before running the test.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你应当对*计数*进行卡方检验。如果你的数据是百分比、平均值、比率等，需先将这些值转换为计数再进行检验。
- en: '**THE OBJECTIVE**'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标**'
- en: Write a Python program that loads numerical data, records the frequency of occurrence
    of the first digits, compares these to Benford’s law using the chi-square goodness-of-fit
    test, and presents the comparison in both tabular and graphical form.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个Python程序，加载数值数据，记录首位数字的出现频率，使用卡方拟合优度检验将这些频率与本福德定律进行比较，并以表格和图形形式呈现比较结果。
- en: '**The Dataset**'
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**数据集**'
- en: The 2016 US presidential election was rife with allegations of voter fraud.
    Most famously, the Russians were accused of supporting Donald Trump, and the Democratic
    National Committee was accused of favoring Hillary Clinton over Bernie Sanders
    in that party’s nomination process. President Trump also alleged that 5 to 6 million
    people voted illegally, and in May 2017, he signed an executive order that launched
    a commission to review voter fraud and voter suppression.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 2016年美国总统选举充满了选民舞弊的指控。最著名的是，俄罗斯被指控支持唐纳德·特朗普，而民主党全国委员会被指控在党内提名过程中偏袒希拉里·克林顿，而不是伯尼·桑德斯。特朗普总统还指控有500万到600万人非法投票，并且在2017年5月签署了一项行政命令，成立了一个委员会来审查选民舞弊和选民压制问题。
- en: For this project, you’ll use a dataset of voting records from the 2016 presidential
    election. This consists of the final *by-county* votes for the 102 counties in
    the state of Illinois, which was won by Hillary Clinton. Starting in June 2016,
    the Illinois Voter Registration System database was the victim of a malicious
    cyberattack of unknown origin. Illinois election officials confirmed that hackers
    had accessed thousands of records but apparently didn’t alter any data.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，你将使用2016年总统选举的投票记录数据集。这包括了伊利诺伊州102个县的最终*按县*划分的投票结果，该州由希拉里·克林顿赢得。自2016年6月以来，伊利诺伊州选民注册系统数据库成为了一次来源不明的恶意网络攻击的受害者。伊利诺伊州选举官员确认，黑客访问了成千上万的记录，但显然没有修改任何数据。
- en: 'There were a surprising number of candidates on the Illinois ballot for president,
    so the dataset has been parsed to include only Hillary Clinton, Donald Trump,
    Gary Johnson, and Jill Stein. Votes for these candidates have been lumped together
    in a 408-line text file, with these first 5 lines:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 伊利诺伊州的总统选票上有出人意料的多位候选人，因此该数据集已被解析，仅包括希拉里·克林顿、唐纳德·特朗普、加里·约翰逊和吉尔·斯坦。这些候选人的投票结果被汇总在一个包含408行的文本文件中，前五行如下：
- en: '[PRE0]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can find the complete tally of candidates and votes online at *[https://www.elections.il.gov/ElectionInformation/DownloadVoteTotals.aspx](https://www.elections.il.gov/ElectionInformation/DownloadVoteTotals.aspx)*.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 *[https://www.elections.il.gov/ElectionInformation/DownloadVoteTotals.aspx](https://www.elections.il.gov/ElectionInformation/DownloadVoteTotals.aspx)*
    在线查找候选人和选票的完整统计信息。
- en: For this project, you need only the votes, which can be downloaded from *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*
    as *Illinois_votes.txt*. You’ll need to keep this file in the same folder as your
    Python code.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，你只需要选票，可以从 *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*
    下载 *Illinois_votes.txt*。你需要将这个文件与 Python 代码保存在同一个文件夹中。
- en: '**The Strategy**'
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**策略**'
- en: Let’s pretend you’re an investigator looking into allegations of voter fraud
    in the 2016 presidential election and you’ve been assigned the state of Illinois.
    Before doing a deep dive into the data, you’ll want to flag any obvious anomalies.
    Benford’s law can’t help you determine whether people are voting illegally, but
    it’s a good place to start for detecting vote *tampering*—that is, changing votes
    after they are cast.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你是一个调查员，正在调查2016年总统选举中的选民欺诈指控，且你被分配到伊利诺伊州。在深入分析数据之前，你需要标记任何明显的异常。贝福德定律不能帮助你确定是否有人非法投票，但它是检测选票
    *篡改* 的一个不错的起点——即，在选票投下后改变选票。
- en: In cases like this, the ability to communicate the results is every bit as important
    as the quantitative analysis. Voting commissions don’t just include experts but
    also many laypeople with limited knowledge of statistics. And juries probably
    will not include a single expert. To convince yourself—and others—that the vote
    counts are valid (or not), you’ll want to show multiple comparisons, like a table,
    a graph, and the quantitative chi-square variable (test statistic).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，沟通结果的能力与定量分析同样重要。选举委员会不仅包括专家，还包括许多对统计学知识有限的普通人。陪审团可能也不会有任何专家。为了说服自己——以及他人——投票结果是有效的（或无效的），你需要展示多个比较结果，例如表格、图表和定量卡方变量（检验统计量）。
- en: 'The individual steps involved in the analysis lend themselves well to encapsulation
    in functions. So, instead of pseudocode, let’s look at what functions you may
    need:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 分析中涉及的各个步骤非常适合封装成函数。因此，我们不看伪代码，而是来看一下你可能需要的函数：
- en: load_data() Load the data as a list.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: load_data() 将数据加载为列表。
- en: count_first_digits() Tabulate the first digits in each county’s observed vote
    total.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: count_first_digits() 统计每个县的观察选票总数中的首位数字。
- en: get_expected_counts() Determine the counts for each first digit as predicted
    by Benford.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: get_expected_counts() 确定根据本福德定律预测的每个首位数字的计数。
- en: chi_square_test() Run a chi-square goodness-of-fit test on the observed versus
    expected counts.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: chi_square_test() 对观察值与预期值进行卡方拟合优度检验。
- en: bar_chart() Generate a bar chart to compare observed first-digit percentages
    to those expected.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: bar_chart() 生成一个柱状图，将观察到的首位数字百分比与预期百分比进行比较。
- en: main() Get the dataset filename, call the functions, and print the statistics.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: main() 获取数据集文件名，调用函数并打印统计信息。
- en: '**The Code**'
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**代码**'
- en: You’ll use the *benford.py* code in this section to investigate voter fraud,
    but it’s flexible enough to be used on *any* dataset where categorical values
    have been counted, such as medical test results, income tax revenues, or customer
    refunds. Non-fraud-related applications are also possible, such as detecting process
    inefficiencies caused by a large number of low-value transactions; problems with
    data collection and handling, such as missing data, truncated values, or typos;
    and bias in measurement strategies or surveys, such as favoring best-case or worst-case
    sampling.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在本节中使用 *benford.py* 代码来研究选民欺诈，但它足够灵活，可以用于 *任何* 数据集，其中包含分类值的计数，例如医学测试结果、所得税收入或客户退款。也可以用于与欺诈无关的应用，如检测由大量低价值交易引起的流程低效；数据收集和处理中的问题，如缺失数据、截断值或拼写错误；以及测量策略或调查中的偏差，如偏向最佳情况或最差情况的抽样。
- en: You can download the code from *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*.
    You’ll also need the *Illinois_votes.txt* text file described in “[The Dataset](ch16.xhtml#lev381)”
    on [page 353](ch16.xhtml#page_353).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从 *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*
    下载代码。你还需要在[第353页](ch16.xhtml#page_353)的 “[数据集](ch16.xhtml#lev381)”中描述的 *Illinois_votes.txt*
    文本文件。
- en: '***Importing Modules and Loading Data***'
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***导入模块和加载数据***'
- en: '[Listing 16-1](ch16.xhtml#ch16list1) imports modules and defines a function
    to load data. For this project, you’ll use data in the form of a tab-delimited
    text file exported from Microsoft Excel, which you load as a list of strings.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 16-1](ch16.xhtml#ch16list1)导入模块并定义加载数据的函数。在此项目中，你将使用一种格式为制表符分隔的文本文件（从Microsoft
    Excel导出），并将其作为字符串列表加载。'
- en: '*benford.py,* part 1'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*benford.py，* 第1部分'
- en: '[PRE1]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 16-1: Imports modules and defines a function for loading data*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 16-1：导入模块并定义加载数据的函数*'
- en: Most of the imports should be familiar at this point. The `collections` module
    provides specialized alternatives to standard Python containers like sets, tuples,
    lists, and dictionaries ➊. For counting first-digit frequencies, you’ll need `defaultdict`,
    which is a `dict` subclass that calls a factory function to supply missing values.
    With `defaultdict`, you can build a dictionary using a loop, and it will automatically
    create new keys rather than throwing an error. It returns a dictionary object.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，大部分导入的模块应该已经熟悉了。`collections`模块提供了标准Python容器（如集合、元组、列表和字典）的专用替代方案 ➊。为了统计首位数字的频率，你需要`defaultdict`，它是`dict`的一个子类，通过调用工厂函数来提供缺失的值。使用`defaultdict`时，你可以通过循环构建字典，它会自动创建新键，而不是抛出错误。它返回一个字典对象。
- en: The final import is for plotting with `matplotlib` ➋. For more information on
    `matplotlib` and how to install it, see “[The Probability-of-Detection Code](ch10.xhtml#lev226)”
    on [page 194](ch10.xhtml#page_194).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的导入是用于与`matplotlib`绘图 ➋。有关`matplotlib`及其安装方法的更多信息，请参见[第194页](ch10.xhtml#page_194)的“[检测概率代码](ch10.xhtml#lev226)”。
- en: Now, assign a variable to a list containing the Benford’s law percentages, ordered
    from 1 to 9 ➌. Then, define a function to read a text file and return a list ➍.
    As you’ve done before, use `with`, as it will automatically close the file when
    done ➎.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将一个变量赋值为一个包含从1到9的本福德定律百分比的列表 ➌。然后，定义一个函数来读取文本文件并返回一个列表 ➍。像之前一样，使用`with`，因为它会在完成后自动关闭文件
    ➎。
- en: '***Counting First Digits***'
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***统计首位数字***'
- en: '[Listing 16-2](ch16.xhtml#ch16list2) defines a function to count the first
    digits and store the results in a dictionary data structure. The final counts,
    and the frequency of each count as a percentage, are returned as lists to use
    in subsequent functions. The function will also run quality control on the data.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 16-2](ch16.xhtml#ch16list2)定义了一个函数，用于统计首位数字并将结果存储在字典数据结构中。最终的计数以及每个计数的频率（以百分比形式）会作为列表返回，以便在后续函数中使用。该函数还将对数据进行质量控制。'
- en: '*benford.py,* part 2'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*benford.py，* 第2部分'
- en: '[PRE2]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 16-2: Defines a function to count first digits and return counts and
    frequency*'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 16-2：定义一个函数来统计首位数字并返回计数和频率*'
- en: The `count_first_digits()` function takes the list of strings returned from
    the `load_data()` function as an argument ➊. You’ll call it in `main()`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`count_first_digits()`函数接受由`load_data()`函数返回的字符串列表作为参数 ➊。你将在`main()`中调用它。'
- en: Start a dictionary, named `first_digits`, using `defaultdict` ➋. This step just
    sets up the dictionary for later population. The first argument for `defaultdict`
    is any callable (with no arguments). In this case, the callable is the type constructor
    for `int`, as you want to count integers. With `defaultdict`, whenever an operation
    encounters a missing key, a function named `default_factory` is called with no
    arguments, and the output is used as the value. Nonexistent keys get the value
    returned by `default_factory`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`first_digits`的字典，使用`defaultdict` ➋。这个步骤只是为后续填充字典做准备。`defaultdict`的第一个参数是一个可调用对象（无参数）。在此例中，可调用对象是`int`的类型构造器，因为你需要计数整数。使用`defaultdict`时，每当操作遇到缺失的键时，会调用一个名为`default_factory`的函数，并且不传递任何参数，返回的结果将作为该键的值。不存在的键会得到`default_factory`返回的值。
- en: Now start a `for` loop and go through the samples in `data_list` ➌. If the sample
    is empty—that is, if the text file contains a blank line ➍—skip it with `continue`.
    Otherwise, use `try` to convert the sample to an integer. If an exception occurs,
    the sample isn’t a proper count value, so let the user know and exit the program.
    In the following output example, the input file contains a float value (`0.01`)
    and the `main()` function prints the filename.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，启动一个`for`循环，遍历`data_list`中的样本 ➌。如果样本为空——即，如果文本文件中包含空行 ➍——使用`continue`跳过它。否则，使用`try`将样本转换为整数。如果发生异常，说明样本不是有效的计数值，因此通知用户并退出程序。在下面的输出示例中，输入文件包含一个浮动值（`0.01`），而`main()`函数打印出文件名。
- en: '[PRE3]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If the sample passes the test, make its first element (leading digit) the dictionary
    key and add 1 to the value ➎. Because you used `defaultdict` with `int`, the key
    is initially assigned a default value of `0` on the fly.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果样本通过了检验，将其第一个元素（前导数字）作为字典键，并将值加 1 ➎。因为你使用了`defaultdict`并设置为`int`，所以键会自动初始化为`0`。
- en: 'To compare the counts to a Benford’s law distribution, you need the keys listed
    in numerical order, so use list comprehension and `sorted` to make a new version
    of `first_digits`, named `data_count` ➏. This will yield the values sorted by
    key, as shown here:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将计数与本福德定律分布进行比较，你需要将键按数字顺序列出，因此使用列表推导式和`sorted`来创建一个新的`first_digits`版本，命名为`data_count`
    ➏。这将按键排序并返回值，如下所示：
- en: '[PRE4]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Next, sum the counts, then make a new list and convert the counts to percentages.
    End the function by returning these two lists and the summed counts ➐. Because
    the counts in the lists are sorted from 1 to 9, you don’t need the associated
    first digit—it is implicit in the ordering.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，求和计数，然后创建一个新列表并将计数转换为百分比。最后，通过返回这两个列表和总计数来结束函数 ➐。由于列表中的计数从 1 到 9 排序，因此你不需要关联的前导数字——它已隐含在排序中。
- en: '***Getting the Expected Counts***'
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***获取预期计数***'
- en: '[Listing 16-3](ch16.xhtml#ch16list3) defines the `get_expected_counts()` function
    that takes the observed data and calculates what the expected counts should be
    for the leading digits, based on Benford’s law. These expected counts are returned
    as a list that you’ll use later with the chi-square goodness-of-fit test to see
    how well the observed data conform to Benford’s law.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 16-3](ch16.xhtml#ch16list3)定义了`get_expected_counts()`函数，该函数接受观察数据并根据本福德定律计算出前导数字的预期计数。这些预期计数作为一个列表返回，稍后你将使用它与卡方拟合优度检验一起，查看观察数据与本福德定律的符合程度。'
- en: '*benford.py,* part 3'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*benford.py,* 第 3 部分'
- en: '[PRE5]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 16-3: Defines a function to calculate expected Benford’s law counts
    for a dataset*'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 16-3：定义了一个函数，用于计算数据集的预期本福德定律计数*'
- en: The argument for this function is the summed count that you returned from the
    `count_first_digits()` function in [Listing 16-2](ch16.xhtml#ch16list2) ➊. To
    get the counts you would expect for Benford’s law, you’ll need to use the frequency
    *probability* of each digit, so convert the percentages in the `BENFORD` list
    by dividing by 100\. Then multiply the `total_count` variable by this probability.
    You can do all this with list comprehension as part of the `return` statement
    ➋.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数的参数是你从[列表 16-2](ch16.xhtml#ch16list2)中的`count_first_digits()`函数返回的总计数 ➊。为了获得本福德定律下你应该预期的计数，你需要使用每个数字的频率*概率*，因此通过除以
    100 将`BENFORD`列表中的百分比转换为概率。然后将`total_count`变量乘以此概率。你可以通过列表推导式在`return`语句中完成这一切
    ➋。
- en: '***Determining Goodness of Fit***'
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***确定拟合优度***'
- en: '[Listing 16-4](ch16.xhtml#ch16list4) defines a function to implement the chi-square
    test described in “[Performing the Chi-Square Test](ch16.xhtml#lev380)” on [page
    352](ch16.xhtml#page_352). This test calculates the goodness of fit of the observed
    counts to the expected counts predicted by Benford’s law. The function will first
    calculate the chi-square test statistic, then compare it to the chi-square distribution
    table entry at a *p*-value of 0.05 for 8 degrees of freedom. Based on the comparison,
    the function returns either `True` or `False`.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 16-4](ch16.xhtml#ch16list4)定义了一个函数，用于实现“[执行卡方检验](ch16.xhtml#lev380)”中的卡方检验，该检验描述在第
    352 页中。这一检验计算观察计数与本福德定律预测的预期计数之间的拟合优度。该函数将首先计算卡方检验统计量，然后将其与卡方分布表中自由度为 8、*p* 值为
    0.05 的条目进行比较。根据比较结果，函数返回`True`或`False`。'
- en: '*benford.py,* part 4'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*benford.py,* 第 4 部分'
- en: '[PRE6]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 16-4: Defines a function to measure goodness of fit of observed data
    versus Benford’s law*'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 16-4：定义了一个函数，用于衡量观察数据与本福德定律的拟合优度*'
- en: The chi-square test works on counts, so the function needs the lists of data
    counts and expected counts that the `count_first_digits()` and `get``_expected_counts``()`
    functions returned ➊. Assign a variable, named `chi_square``_stat`, to hold the
    chi-square test statistic, and assign it a value of `0` ➋.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 卡方检验作用于计数，因此该函数需要`count_first_digits()`和`get_expected_counts()`函数返回的数据计数和预期计数列表
    ➊。定义一个名为`chi_square_stat`的变量来存储卡方检验统计量，并将其值初始化为`0` ➋。
- en: Use `zip` to loop through the nine values in `data_count` and `expected_counts`;
    `zip` will pair the first item in one list with the first item in the second list,
    and so on ➌. To calculate the chi-square statistic, first subtract the counts
    for each digit and square the result ➍. Then, divide this value by the expected
    count for the digit and add the result to the `chi_square_stat` variable. Then
    print the result to three decimal places ➎.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `zip` 遍历 `data_count` 和 `expected_counts` 中的九个值；`zip` 会将一个列表中的第一个项目与第二个列表中的第一个项目配对，依此类推
    ➌。要计算卡方统计量，首先减去每个数字的计数并平方结果 ➍。然后，将此值除以该数字的预期计数，并将结果加到 `chi_square_stat` 变量中。接着，将结果打印至小数点后三位
    ➎。
- en: Return the boolean test for the `chi_square_stat` variable versus 15.51, which
    is the critical value corresponding to a *p*-value of 0.05 at 8 degrees of freedom
    (see [Table 16-1](ch16.xhtml#ch16tab1)) ➏. If `chi_square_stat` is less than this
    value, the function will return `True`; otherwise, it will return `False`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 `chi_square_stat` 变量与 15.51 的布尔值测试，这是与 8 自由度下 *p* 值为 0.05 对应的临界值（见 [表 16-1](ch16.xhtml#ch16tab1)）
    ➏。如果 `chi_square_stat` 小于该值，函数将返回 `True`；否则返回 `False`。
- en: '***Defining the Bar Chart Function***'
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***定义条形图函数***'
- en: '[Listing 16-5](ch16.xhtml#ch16list5) defines the first part of a function to
    display the observed count percentages as a `matplotlib` bar chart. You used similar
    code in [Chapter 12](ch12.xhtml#ch12) to graph the outcomes of the retirement
    nest-egg simulations. This function will also plot the Benford’s law percentages
    as red dots, so you can visually estimate how well the observed data fit the expected
    distribution.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 16-5](ch16.xhtml#ch16list5) 定义了一个函数的第一部分，用于以 `matplotlib` 条形图的形式显示观察到的计数百分比。在[第12章](ch12.xhtml#ch12)中，你使用了类似的代码来绘制退休储备模拟的结果。这个函数还将以红点的形式绘制本福德法则的百分比，这样你可以通过视觉估算观察数据与期望分布的拟合程度。'
- en: The `matplotlib` website contains many code examples for building a wide variety
    of plots. This code is partly based on the demo example at *[https://matplotlib.org/examples/api/barchart_demo.html](https://matplotlib.org/examples/api/barchart_demo.html)*.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`matplotlib` 网站包含了许多用于构建各种图表的代码示例。此代码部分基于 *[https://matplotlib.org/examples/api/barchart_demo.html](https://matplotlib.org/examples/api/barchart_demo.html)*
    上的演示示例。'
- en: '*benford.py,* part 5'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*benford.py,* 第 5 部分'
- en: '[PRE7]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 16-5: Defines the first part of the* bar_chart() *function*'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 16-5：定义了* bar_chart() *函数的第一部分*'
- en: Define the `bar_chart()` function that takes as an argument the list of frequencies—as
    percentages—of the first digits in the observed data ➊. The `plt.subplots()` function
    returns a tuple of figure and axes objects; unpack this tuple into variables named
    `fig` and `ax` ➋.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 `bar_chart()` 函数，它接受一个参数，即观察数据中首位数字的频率列表——以百分比表示 ➊。`plt.subplots()` 函数返回一个包含图形和坐标轴对象的元组；将此元组解包到名为
    `fig` 和 `ax` 的变量中 ➋。
- en: Next, use list comprehension to make a list of digits from 1 to 9 ➌. This `index`
    variable will define the x-axis location of each of the nine vertical bars in
    the chart.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用列表推导式创建一个从 1 到 9 的数字列表 ➌。这个 `index` 变量将定义图表中每个竖直条形的 x 轴位置。
- en: Set up the plot’s title, labels, and so on. Name the plot *window* `'Percentage`
    `First Digits'` ➍, then display a title *within* the plot ➎. I am using generic
    titles, but you can customize these to be more specific. Use the `fontsize` keyword
    argument to set the text size to `15`. Note that the window title is an attribute
    of `fig`, but the other labels will be attributes of `ax`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 设置图表的标题、标签等。将图表窗口命名为*窗口* `'Percentage` `First Digits'` ➍，然后在图表内显示标题 ➎。这里我使用了通用标题，但你可以根据需要进行自定义。使用
    `fontsize` 关键字参数将文本大小设置为 `15`。请注意，窗口标题是 `fig` 的属性，而其他标签将是 `ax` 的属性。
- en: Use `set_ylabel()` to name the y-axis “Frequency (%)” ➏, then set the x-axis
    tick marks based on the `index` variable ➐. The tick labels will be the numbers
    1 through 9, so use the index variable again and set the font size to `14`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `set_ylabel()` 将 y 轴命名为 “Frequency (%)” ➏，然后根据 `index` 变量设置 x 轴的刻度标记 ➐。刻度标签将是数字
    1 到 9，因此再次使用 `index` 变量并将字体大小设置为 `14`。
- en: '***Completing the Bar Chart Function***'
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***完成条形图函数***'
- en: '[Listing 16-6](ch16.xhtml#ch16list6) completes the `bar_chart()` function by
    defining the bars, annotating the top of each bar with its frequency value, and
    plotting the Benford distribution values as red-filled circles.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 16-6](ch16.xhtml#ch16list6) 通过定义条形图、在每个条形的顶部标注其频率值，并将本福德分布的值绘制为红色圆点，完成了
    `bar_chart()` 函数。'
- en: '*benford.py,* part 6'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*benford.py,* 第 6 部分'
- en: '[PRE8]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 16-6: Completes the function for generating a bar chart*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 16-6：完成了生成条形图的函数*'
- en: Name a variable, called `rects`, for rectangles, and use it to hold the bars
    for the bar chart ➊. You generate these with the `bar()` method, which returns
    a container with all the bars. Pass it the index variable and list of frequency
    counts as percentages, set the width of each bar to 0.95, fill them with black,
    and set the `label` argument to `'Data'`. The last parameter is a very handy way
    to autogenerate a legend. You’ll take advantage of this near the end of the function.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 给变量命名为 `rects`，表示矩形，并用它来保存条形图中的条形 ➊。你可以使用 `bar()` 方法生成这些条形，它会返回一个包含所有条形的容器。传递给它索引变量和百分比频率的列表，将每个条形的宽度设置为
    0.95，填充为黑色，并将 `label` 参数设置为 `'Data'`。最后一个参数是非常方便的方式来自动生成图例。你将在函数的后面部分利用这一点。
- en: I’m a fan of plotting the actual bar value just above the bar so you don’t have
    to squint over at the y-axis and try to guess it. To do this, start by looping
    through each bar (`rect`) in `rects` ➋ and get its height ➌, which is its y-axis
    value. Then, call the `ax` object’s `text()` method ➍ and pass it the x-location
    of the left-hand side of the bar—obtained with the `get_x()` method—and add to
    it half the width of the bar in order to center the label over the bar. Because
    you use the `get_width()` method, you only have to assign the bar width once,
    which you did in step ➊. Next comes the bar height—formatted to one decimal place—followed
    by the horizontal and vertical alignments. Set these to the center and the bottom
    of the text bounding box, respectively. Finish by assigning the text size.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢在条形图上方绘制实际的条形值，这样就不需要眯眼看 y 轴并尝试猜测值了。为此，首先通过循环遍历 `rects` ➋ 中的每个条形图（`rect`），获取其高度
    ➌，即其 y 轴值。然后，调用 `ax` 对象的 `text()` 方法 ➍，并传入条形的左侧位置——通过 `get_x()` 方法获取——然后加上条形宽度的一半，以将标签居中放置在条形上方。由于使用了
    `get_width()` 方法，因此你只需为条形宽度赋值一次，这在步骤 ➊ 中已完成。接下来是条形高度——格式化为一位小数——然后是水平和垂直对齐方式。将这些设置为文本边界框的中心和底部。最后，设置文本大小。
- en: Now, start building the `matplotlib` “markers”—in this case, dots—that will
    flag the location of the Benford distribution frequencies for each first digit.
    Do this using the `scatter()` method, which builds scatterplots ➎.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，开始构建 `matplotlib` 的“标记”——在这种情况下是圆点——用于标示 Benford 分布频率在每个首位数字的位置。使用 `scatter()`
    方法来完成这项工作，它用于生成散点图 ➎。
- en: The first two arguments for `scatter()` are the x-y locations for each marker,
    represented by consecutive pairs from the `index` and `BENFORD` lists. Next is
    the marker size, set at `150`, followed by a color. Both `red` and `DodgerBlue`
    work well. You want the markers to post on top of the bars, so set the `zorder`
    to `2`. Elements in the figure are referred to as `matplotlib` “artists,” and
    artists with higher `zorder` values will plot over those with lower values. Finish
    with the `label` argument used to make a legend.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`scatter()` 的前两个参数是每个标记的 x-y 位置，由 `index` 和 `BENFORD` 列表中的连续对表示。接下来是标记的大小，设置为
    `150`，然后是颜色。`red` 和 `DodgerBlue` 都可以很好地使用。你希望标记显示在条形图的顶部，所以将 `zorder` 设置为 `2`。图形中的元素被称为
    `matplotlib` 的“艺术家”，具有较高 `zorder` 值的艺术家将覆盖具有较低值的艺术家。最后，使用 `label` 参数来创建图例。'
- en: The next two statements are for aesthetics. By default, `matplotlib` will draw
    a box around the interior of the plot, and the upper border may interfere with
    the labels posted at the top of each bar. So, remove the top and right borders
    by setting their visibility to `False` ➏.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两条语句用于美学效果。默认情况下，`matplotlib` 会在图表内部绘制一个边框，而上边框可能会干扰放置在每个条形顶部的标签。因此，通过将其可见性设置为
    `False` ➏，移除顶部和右侧的边框。
- en: Use `legend()` to build a legend for the plot ➐. This will work with no arguments,
    but set its size attribute to `15` and turn off the frame around the legend for
    an arguably more attractive result. End by calling `plt.show()` to display the
    chart ➑. An example bar chart is shown in [Figure 16-7](ch16.xhtml#ch16fig7).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `legend()` 构建图形的图例 ➐。它可以不带参数工作，但可以将其大小属性设置为 `15`，并关闭图例周围的边框，以获得一个可能更具吸引力的结果。最后调用
    `plt.show()` 来显示图表 ➑。一个示例的条形图如[图 16-7](ch16.xhtml#ch16fig7)所示。
- en: '![image](../images/f0360-01.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0360-01.jpg)'
- en: '*Figure 16-7: Example output of the* bar_chart() *function*'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 16-7：* bar_chart() *函数的示例输出*'
- en: In the `main()` function, you will display additional information as text in
    the interpreter window. This will include the value of the chi-square test statistic.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main()` 函数中，你将以文本的形式在解释器窗口中显示附加信息。包括卡方检验统计量的值。
- en: '***Defining and Running the main() Function***'
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***定义并运行 main() 函数***'
- en: '[Listing 16-7](ch16.xhtml#ch16list7) defines the `main()` function and runs
    the program as a module or stand-alone. Since most of the work is done in the
    individual functions, `main()` “mainly” calls these functions and prints some
    statistics.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 16-7](ch16.xhtml#ch16list7)定义了 `main()` 函数并以模块或独立模式运行程序。由于大部分工作都在各个函数中完成，`main()`
    “主要”调用这些函数并打印一些统计数据。'
- en: '*benford.py,* part 7'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*benford.py,* 第 7 部分'
- en: '[PRE9]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 16-7: Defines the* main() *function and runs the program as a module
    or stand-alone*'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 16-7：定义了* main() *函数并以模块或独立模式运行程序*'
- en: 'Start by asking the user to input the name of the file with the count data
    to be analyzed ➊; embed this request in a `while` loop that will continue until
    the user enters a valid filename or closes the window. The user can enter a filename
    or a full pathname if they want to load a dataset that isn’t stored in the current
    working directory. For example, in Windows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，提示用户输入需要分析的计数数据文件名 ➊；将这个请求嵌入一个 `while` 循环中，直到用户输入有效的文件名或关闭窗口为止。用户可以输入文件名或完整路径名，如果他们想加载存储在当前工作目录之外的数据集。例如，在
    Windows 中：
- en: '[PRE10]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Use a `try` statement to call the `load_data()` function you built earlier and
    pass the function the filename. If the filename is valid, the returned list is
    assigned to the `data_list` variable. If an exception occurs, catch it and print
    the error. Otherwise, `break` from the `while` loop.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `try` 语句调用之前构建的 `load_data()` 函数，并传递文件名给该函数。如果文件名有效，则返回的列表将赋值给 `data_list`
    变量。如果发生异常，则捕获并打印错误。否则，从 `while` 循环中 `break` 退出。
- en: Next, pass the returned list of data counts to the `count_first_digits()` function
    and unpack the results as the variables `data_count`, `data_pct`, and `total_count`,
    which are lists of the first-digit counts, percentages, and total number of counts,
    respectively ➋. Then, generate a list of the counts expected for a Benford’s law
    distribution by calling the `get_expected_counts()` function and passing it the
    `total_count` variable ➌. Print the lists of observed and expected counts.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将返回的数据计数列表传递给 `count_first_digits()` 函数，并解包结果为变量 `data_count`、`data_pct`
    和 `total_count`，它们分别是首位数字计数、百分比和总计数的列表 ➋。然后，通过调用 `get_expected_counts()` 函数并传递
    `total_count` 变量，生成本福德定律分布下预期的计数列表 ➌。打印观察到的计数和预期的计数列表。
- en: Now, make a table that compares the first-digit frequency in the data with the
    expected values. Use probabilities, as decimal values are easy to keep attractively
    aligned in the shell. Start with a header `print` statement ➍, then loop through
    the numbers 1 to 9, printing the results for the observed counts (data), followed
    by the expected counts, each to three decimal places ➎. Note that the indexes
    in the two lists start with zero, so you have to subtract 1 from `i`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，制作一个表格，比较数据中首位数字的频率与预期值。使用概率值，因为小数值在终端中易于对齐。首先使用一个 `print` 语句输出表头 ➍，然后循环打印数字
    1 到 9，对于每个数字，输出观察到的计数（数据），接着是预期的计数，每个值保留三位小数 ➎。注意，两个列表的索引从零开始，因此必须从 `i` 中减去 1。
- en: Pass the two count lists to the `chi_square_test()` function in order to calculate
    how well the observed data fit the expected distribution ➏. If the function returns
    `True`, use a `print` statement to let the user know the observed distribution
    matches Benford’s law (or, more technically, *there is no significant difference*
    between the two). Otherwise, report that they don’t match, and for shell users,
    color the font red.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 将这两个计数列表传递给 `chi_square_test()` 函数，以计算观察到的数据与预期分布的匹配程度 ➏。如果函数返回 `True`，使用 `print`
    语句告知用户观察到的分布符合本福德定律（或者，更准确地说，*两者之间没有显著差异*）。否则，报告它们不匹配，对于终端用户，可以将字体颜色设置为红色。
- en: The `chi_square_test()` function will display its results in the interpreter
    window, so call the `bar_chart()` function to generate a bar chart ➐. Pass it
    the list of data counts as percentages.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`chi_square_test()` 函数将在解释器窗口中显示其结果，因此调用 `bar_chart()` 函数生成柱状图 ➐。将数据计数列表作为百分比传递给它。'
- en: Back in the global space, end the program with the code for running it as a
    module or in stand-alone mode ➑.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 回到全局空间，使用运行程序作为模块或独立模式的代码结束程序 ➑。
- en: If you run the program on the *Illinois_votes.txt* dataset, you will see the
    output shown in [Figure 16-8](ch16.xhtml#ch16fig8). There is no apparent anomaly
    in the voting results, based on Benford’s law.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 *Illinois_votes.txt* 数据集上运行程序，你将看到如[图 16-8](ch16.xhtml#ch16fig8)所示的输出。根据本福德定律，投票结果没有明显的异常。
- en: '![image](../images/f0362-01.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0362-01.jpg)'
- en: '*Figure 16-8: Output of* benford.py *for the dataset* Illinois_votes.txt'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*图16-8：benford.py对数据集* Illinois_votes.txt *的输出结果*'
- en: If you run the program using only the Trump votes, then only the Clinton votes,
    you get the results shown in [Figure 16-9](ch16.xhtml#ch16fig9). Trump’s distribution,
    with a test statistic of 15.129, barely passes the chi-square test.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只使用特朗普的选票运行程序，然后只使用希拉里的选票，你将得到如[图16-9](ch16.xhtml#ch16fig9)所示的结果。特朗普的分布，检验统计量为15.129，勉强通过卡方检验。
- en: '![image](../images/f0363-01.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0363-01.jpg)'
- en: '*Figure 16-9: Comparison of Trump results (left) versus Clinton results (right)
    for the state of Illinois*'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '*图16-9：特朗普结果（左）与希拉里结果（右）在伊利诺伊州的比较*'
- en: In cases like this, you should be careful about drawing immediate conclusions.
    The dataset is small—only 102 samples per candidate—and the results may be influenced
    by things like demographic and voter turnout differences between rural and urban
    areas. An interesting article on this urban-rural divide can be found at *[http://www.chicagotribune.com/news/data/ct-illinois-election-urban-rural-divide-2016-htmlstory.html](http://www.chicagotribune.com/news/data/ct-illinois-election-urban-rural-divide-2016-htmlstory.html)*.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你应该小心得出立即结论。数据集很小——每个候选人只有102个样本——结果可能受到人口统计和城乡投票率差异等因素的影响。关于这种城乡差异的有趣文章可以在*[http://www.chicagotribune.com/news/data/ct-illinois-election-urban-rural-divide-2016-htmlstory.html](http://www.chicagotribune.com/news/data/ct-illinois-election-urban-rural-divide-2016-htmlstory.html)*找到。
- en: 'In “[Practice Project: Beating Benford](ch16.xhtml#lev393)” on [page 364](ch16.xhtml#page_364),
    you’ll get a chance to tamper with the Illinois vote counts and alter the outcome.
    You’ll then use the preceding code to see how well the results conform to Benford’s
    law.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在[“实践项目：打败本福德”](ch16.xhtml#lev393)（见[第364页](ch16.xhtml#page_364)）中，你将有机会篡改伊利诺伊州的选票计数并改变结果。然后，你将使用前面的代码查看结果与本福德定律的符合程度。
- en: '**Summary**'
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: Way back in [Chapter 1](ch01.xhtml#ch01), we used the “[Poor Man’s Bar Chart](ch01.xhtml#lev28)”
    practice project on [page 15](ch01.xhtml#page_15) and the “[Poor Foreign Man’s
    Bar Chart](ch01.xhtml#lev30)” challenge project on [page 16](ch01.xhtml#page_16)
    to look at how the frequency of occurrence of letters in a language is both irregular
    and predictable. This provides a powerful tool for cryptanalysis. Here at the
    end of the book, we’ve come full circle and found that even numbers share this
    trait, resulting in a powerful tool for fraud detection. With a short and simple
    Python program, you can shake the very pillars of heaven and bring the high and
    mighty crashing down to earth—all because someone noticed that the front pages
    of a book were dirty.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 很久以前，在[第一章](ch01.xhtml#ch01)中，我们使用了“[穷人条形图](ch01.xhtml#lev28)”实践项目（见[第15页](ch01.xhtml#page_15)）和“[穷外国人条形图](ch01.xhtml#lev30)”挑战项目（见[第16页](ch01.xhtml#page_16)），探讨了语言中字母出现频率的不规则性和可预测性。这为密码分析提供了强大的工具。在书的结尾，我们回到了原点，发现即使是数字也有这种特征，从而成为欺诈检测的强大工具。只需一段简短而简单的Python程序，你就能撼动天柱，把高高在上的人拉下凡尘——这一切都源于有人注意到书的封面很脏。
- en: Well, that does it for *Impractical Python Projects*. I hope you had fun, learned
    something new, and were inspired to create your own set of impractical projects!
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，这就是*《不切实际的Python项目》*的全部内容。希望你玩得开心，学到新知识，并受到启发，创造自己的不切实际的项目！
- en: '**Further Reading**'
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**进一步阅读**'
- en: '*Benford’s Law: Applications for Forensic Accounting, Auditing, and Fraud Detection*
    (John Wiley & Sons, 2012) by Mark Nigrini covers the mathematics, theory, and
    testing of Benford’s law together with example applications, including fraud,
    tax evasion, and Ponzi schemes.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*《本福德定律：法医会计、审计与欺诈检测的应用》（John Wiley & Sons，2012）*由马克·尼格里尼（Mark Nigrini）编著，涵盖了本福德定律的数学、理论和测试，并结合示例应用，包括欺诈、逃税和庞氏骗局。'
- en: '**Practice Project: Beating Benford**'
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**实践项目：打败本福德**'
- en: Test your skill at rigging an election using this practice project. You can
    find a solution, *beat_benford_practice.py*, in the appendix or download it from
    *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个实践项目测试你在操控选举方面的技能。你可以在附录中找到解决方案，*beat_benford_practice.py*，或者从*[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*下载。
- en: 'A dataset shouldn’t be considered valid just because it follows Benford’s law.
    The reason is simple: if you know about Benford’s law, then you can beat it.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 一个数据集不应该仅仅因为它符合本福德定律而被认为有效。原因很简单：如果你了解本福德定律，那么你就可以破解它。
- en: To prove this, pretend you’re a high-level hacker for a nefarious foreign government
    with access to all the voting records in the state of Illinois. Write a Python
    program that tampers with county-wide votes so that Donald Trump wins the state,
    but the vote counts still obey Benford’s law. Be careful; Illinois is a “blue”
    state, so you don’t want to engineer a landslide victory (loosely defined as a
    10–15 percentage point advantage in the popular vote). To avoid suspicion, Trump
    should squeak by with a few percentage points.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明这一点，假设你是一个高级黑客，受一个邪恶的外国政府指使，能够访问伊利诺伊州所有的选票记录。编写一个Python程序，篡改按县的选票，使唐纳德·特朗普赢得该州，但选票总数依然遵守本福德法则。要小心；伊利诺伊州是一个“蓝色”州，因此你不希望制造出压倒性的胜利（通常定义为在普选中领先10-15个百分点）。为了避免引起怀疑，特朗普应该以少数几个百分点险胜。
- en: '**NOTE**'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*States have rules regarding the recount of votes. Before manipulating an election,
    a fraudster would want to be aware of these to avoid the scrutiny a recount would
    bring. The actual statutory rules for each state are no fun to read, but the Citizens
    for Election Integrity Minnesota provides approachable summaries. The one for
    Illinois can be found at* [https://ceimn.org/searchable-databases/recount-database/illinois/](https://ceimn.org/searchable-databases/recount-database/illinois/).'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '*各州对选票重计有相关规定。在篡改选举之前，欺诈者需要了解这些规则，以避免重计带来的审查。每个州的实际法定规则阅读起来并不有趣，但明尼苏达州公民选举诚信组织提供了易于理解的摘要。伊利诺伊州的摘要可以在*
    [https://ceimn.org/searchable-databases/recount-database/illinois/](https://ceimn.org/searchable-databases/recount-database/illinois/)
    找到。*'
- en: Your program should steal votes from the other candidates, while preserving
    the by-county totals; that way, the total number of votes cast doesn’t change.
    As a quality-control step, print out the old and new vote totals by county for
    Trump and Clinton, as well as their old and new statewide totals. Then, write
    out a text file that you can input into *benford.py* so you can check how you
    did with respect to Benford’s law.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你的程序应该从其他候选人那里窃取选票，同时保留按县的总票数；这样，总的投票数不会发生变化。作为质量控制步骤，打印出特朗普和克林顿按县的旧票数和新票数，以及他们的旧全州票数和新全州票数。然后，写出一个文本文件，供你输入到*benford.py*中，这样你就可以检查你在本福德法则方面的表现了。
- en: Datasets for each candidate are already prepared and listed here; you can download
    them from *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*.
    Each of these datasets is just a column of numbers, representing votes, that has
    been sorted alphabetically by county (so don’t change the order!).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 每个候选人的数据集已经准备好并列在这里；你可以从*[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*下载它们。这些数据集每个都是一列数字，代表选票，按县名字母顺序排序（所以不要更改顺序！）。
- en: '*Clinton_votes_Illinois.txt*'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '*Clinton_votes_Illinois.txt*'
- en: '*Johnson_votes_Illinois.txt*'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '*Johnson_votes_Illinois.txt*'
- en: '*Stein_votes_Illinois.txt*'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '*Stein_votes_Illinois.txt*'
- en: '*Trump_votes_Illinois.txt*'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '*Trump_votes_Illinois.txt*'
- en: '[Figure 16-10](ch16.xhtml#ch16fig10) shows the results of running *benford.py*
    on the output from my attempt, *beat_benford_practice.py*, which used the preceding
    datasets. The distribution passes the chi-square test and yields a visually convincing—but
    plausibly imperfect—fit to the values predicted by Benford’s law.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 16-10](ch16.xhtml#ch16fig10) 显示了我运行*benford.py*时的结果，输出来自我的尝试 *beat_benford_practice.py*，该程序使用了前面的数据集。分布通过了卡方检验，并且在视觉上给出一个令人信服的——但可以理解为不完美的——拟合，符合本福德法则预测的值。'
- en: '![image](../images/f0365-01.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0365-01.jpg)'
- en: '*Figure 16-10: Results of running the distribution from* beat_benford_practice.py
    *in* benford.py*. Mischief managed!*'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 16-10：运行 *beat_benford_practice.py* 输出的分布结果，在 *benford.py* 中执行的结果。恶作剧成功！*'
- en: 'Shown here are a few lines of output from *beat_benford_practice.py*, with
    the old and new vote totals by county:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这里显示的是来自 *beat_benford_practice.py* 的一些输出行，包含按县的旧票数和新票数：
- en: '![image](../images/f0365-02.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0365-02.jpg)'
- en: The third line from the top represents Cook County, which contains Chicago.
    Note that Clinton still wins here, but by a lower margin. For Trump to win this
    blue county outright would be a tremendous red flag that vote tampering had occurred,
    even if he won the whole state by only a small margin!
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 从上往下的第三行代表库克县，其中包含芝加哥。注意，这里克林顿依然获胜，但胜利的幅度较小。如果特朗普在这个蓝色县城完全获胜，那将是一个巨大的红色警告，表明可能发生了选票篡改，即使他只以微弱的优势赢得整个州！
- en: '**Challenge Projects**'
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**挑战项目**'
- en: Try your hand at these challenge projects. No solutions are provided.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试完成这些挑战项目。这里不提供解决方案。
- en: '***Benfording the Battlegrounds***'
  id: totrans-190
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***本福德法则与战场州***'
- en: No candidate needs to cheat in a state they’re guaranteed to win. If you’re
    an investigator looking into voter fraud, you would most likely start with the
    battleground states. These could swing either way, and candidates spend much of
    their war chest—and time—on these places. According to Ballotpedia (*[https://ballotpedia.org](https://ballotpedia.org)*),
    Trump’s battleground states in 2016 were Arizona, Iowa, Michigan, Wisconsin, Ohio,
    Pennsylvania, North Carolina, and Florida. Clinton’s were Colorado, Nevada, New
    Hampshire, and Virginia.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个注定会获胜的州，候选人不需要作弊。如果你是调查选民舞弊的调查员，你很可能会从关键摇摆州开始。这些州的选举结果可能会有较大的波动，候选人也会在这些州花费大量的选举资金和时间。根据Ballotpedia的资料（*[https://ballotpedia.org](https://ballotpedia.org)*），特朗普2016年的关键摇摆州是亚利桑那州、爱荷华州、密歇根州、威斯康星州、俄亥俄州、宾夕法尼亚州、北卡罗来纳州和佛罗里达州。希拉里的摇摆州是科罗拉多州、内华达州、新罕布什尔州和弗吉尼亚州。
- en: 'The online voting records for states are commonly provided in a number of formats,
    such as Microsoft Excel spreadsheets. Gather the ones for the battleground states,
    convert them to text files, and run them through *benford.py*. To get you started,
    you can find the Ohio records here: *[https://www.sos.state.oh.us/elections/](https://www.sos.state.oh.us/elections/)*.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 各州的在线投票记录通常以多种格式提供，例如Microsoft Excel电子表格。收集关键摇摆州的记录，将它们转换为文本文件，并通过*benford.py*程序进行处理。为了帮助你入门，你可以在这里找到俄亥俄州的选举记录：*[https://www.sos.state.oh.us/elections/](https://www.sos.state.oh.us/elections/)*。
- en: '***While No One Was Looking***'
  id: totrans-193
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***当无人注意时***'
- en: Former Speaker of the US House of Representatives Tip O’Neill was famous for
    saying, “All politics is local.” Take this to heart and use the *benford.py* program
    to check out some of your local area races, such as for judges, mayors, county
    supervisors, sheriffs, and city council members. These events generally attract
    less scrutiny than do races for Senate seats, governor, or president. If you find
    an irregularity, make sure the voting dataset is a valid application for Benford’s
    law before raising a stink!
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 美国众议院前议长蒂普·奥尼尔（Tip O'Neill）曾著名地说：“所有政治都是地方性的。”请牢记这一点，并使用*benford.py*程序检查一些地方选举，比如法官、市长、县监督、警长和市议会成员等选举。这些选举通常比参议院席位、州长或总统选举受到的关注要少。如果你发现任何不规则现象，在大声疾呼之前，确保投票数据集符合本福德定律的有效应用！
