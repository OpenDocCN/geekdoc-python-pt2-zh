- en: '18'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '18'
- en: PRODUCING AN SVG IMAGE AND TEXT FILE
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 生成 SVG 图像和文本文件
- en: '![Image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common01.jpg)'
- en: When we solve one of our truss structures, we construct a new model with the
    solution values. If we want to explore the stress on each bar or the displacement
    of each node, we need to produce some kind of output with this information. Diagrams
    are one good way of displaying the information that results from engineering calculations,
    but we may also want a text file with the detailed values.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们解决其中一个桁架结构时，我们会用解法值构建一个新模型。如果我们想查看每根杆件的应力或每个节点的位移，我们需要生成一些带有这些信息的输出。图表是一种很好的方式来显示工程计算的结果，但我们也可能需要一个包含详细值的文本文件。
- en: In this chapter, we’ll write a module for our structural analysis application
    that produces both a vector image with all the relevant pieces of data in the
    solution, and a simpler textual representation of the structure solution.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将为我们的结构分析应用编写一个模块，该模块生成包含所有相关数据的矢量图像和更简洁的结构解法文本表示。
- en: '**Setup**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**设置**'
- en: 'Let’s add a new package in *structures* named *out*; this package will contain
    all the solution output code. Your *structures* package directory should now look
    like this:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*structures*中添加一个名为*out*的新包；这个包将包含所有解法输出代码。你的*structures*包目录现在应该如下所示：
- en: structures
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: structures
- en: '|- generation'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '|- generation'
- en: '|- model'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '|- model'
- en: '|- out'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '|- out'
- en: '|- parse'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '|- parse'
- en: '|- solution'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '|- solution'
- en: '|- tests'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '|- tests'
- en: 'We’ll start by implementing the function that produces an SVG image from the
    structure solution. Let’s create a new Python file named *svg.py* and another
    one named *config.json* that’ll contain the configuration for the drawing. Your
    *out* directory should now contain the following files:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先实现一个从结构解法生成 SVG 图像的函数。让我们创建一个新的 Python 文件，命名为*svg.py*，并再创建一个名为*config.json*的文件，用于存储绘图的配置。你的*out*目录现在应该包含以下文件：
- en: structures
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: structures
- en: '|- out'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '|- out'
- en: '|- __init__.py'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '|- __init__.py'
- en: '|- config.json'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '|- config.json'
- en: '|- svg.py'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '|- svg.py'
- en: As usual, don’t forget to include an *__init__.py* file if you didn’t use the
    IDE.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，如果你没有使用 IDE，请记得包含一个*__init__.py*文件。
- en: '**From Structure Solution to SVG**'
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**从结构解法到 SVG**'
- en: When our output code is finished, it should produce diagrams like the one in
    [Figure 18-1](ch18.xhtml#ch18fig1). Although you can’t see it in the print version
    of the book, the compression bars are red, and the tension bars are green. The
    external forces are yellow, and we’re using purple for the reactions.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的输出代码完成后，它应该能够生成像[图 18-1](ch18.xhtml#ch18fig1)中那样的图表。尽管在书籍的打印版中看不到，但压缩条是红色的，拉伸条是绿色的，外力是黄色的，而反应力用紫色表示。
- en: '![Image](../images/18fig01.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/18fig01.jpg)'
- en: '*Figure 18-1: Truss result diagram*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 18-1：桁架结果图*'
- en: This image was generated using the code we’re going to write together in the
    rest of this chapter.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这张图像是通过我们将在本章接下来一起编写的代码生成的。
- en: '***The Configuration File***'
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***配置文件***'
- en: Once your code is ready and working, you may want to play with the diagram’s
    colors and sizes to get a result you find satisfying. We want to have the liberty
    of changing these colors without needing to read through our code, so we’ll move
    them to a separate configuration file, like we’ve already done in [Chapter 9](ch09.xhtml#ch09)
    and [Chapter 12](ch12.xhtml#ch12). In fact, any parameter we want to tweak can
    be placed in the configuration file. We’ll include things such as the radius of
    the nodes, their stroke width, and the margin of the image in the configuration,
    among others.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的代码准备好并且能够正常工作时，你可能希望调整图表的颜色和大小，直到得到令你满意的结果。我们希望能够自由地更改这些颜色，而不需要查看我们的代码，因此我们将它们移动到一个单独的配置文件中，就像我们在[第
    9 章](ch09.xhtml#ch09)和[第 12 章](ch12.xhtml#ch12)中已经做过的一样。事实上，我们想调整的任何参数都可以放在配置文件中。我们将在配置文件中包括节点的半径、节点的描边宽度、图像的边距等内容。
- en: '[Figure 18-2](ch18.xhtml#ch18fig2) illustrates some of the properties we want
    to be configurable and the values we’ll assign them. Colors are represented using
    hexadecimal values prefixed with a #.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 18-2](ch18.xhtml#ch18fig2)展示了我们希望能够配置的部分属性以及我们将赋给它们的值。颜色使用以 # 开头的十六进制值表示。'
- en: '![Image](../images/18fig02.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/18fig02.jpg)'
- en: '*Figure 18-2: Output configuration values*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 18-2：输出配置值*'
- en: Open the *config.json* file we just created and enter the configuration values
    in [Listing 18-1](ch18.xhtml#ch18lis1).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 打开我们刚才创建的*config.json*文件，并在[清单 18-1](ch18.xhtml#ch18lis1)中输入配置值。
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 18-1: The default configuration for our output image*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 18-1：我们输出图像的默认配置*'
- en: These configuration values are the defaults we’ll use when no others are given.
    Feel free to personalize your app’s diagrams using different colors, sizes, or
    text font.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这些配置值是我们在没有提供其他值时使用的默认值。你可以通过使用不同的颜色、大小或文本字体来个性化你的应用程序图表。
- en: To do this, we need a way of reading the configuration JSON file into our main
    *svg.py* script. Let’s write a function to do this. In *svg.py*, enter the code
    in [Listing 18-2](ch18.xhtml#ch18lis2).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们需要一种方法，将配置 JSON 文件读取到我们的主*svg.py*脚本中。让我们编写一个函数来实现这一点。在*svg.py*中，输入[清单 18-2](ch18.xhtml#ch18lis2)中的代码。
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 18-2: Reading the configuration JSON file*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 18-2：读取配置 JSON 文件*'
- en: The __read_config function uses resource_string from the pkg_resources package
    (from Python’s standard library) to load our *config.json* file into a string.
    Then, we use json.loads to parse the string into a dictionary. We’ll use this
    function later.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: __read_config函数使用来自pkg_resources包（Python标准库中的一个包）中的resource_string来将我们的*config.json*文件加载为字符串。然后，我们使用json.loads将字符串解析为字典。稍后我们会使用这个函数。
- en: Let’s now see how we can allow the user to pass some parameters to the application;
    these will modify how the resulting diagram is drawn.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何允许用户将一些参数传递给应用程序，这些参数将修改结果图表的绘制方式。
- en: '***The Settings***'
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***设置***'
- en: We have the configuration, which contains values that determine how the diagram
    will look. These values are defined by the application, and users don’t need to
    worry about them. We allow users to pass a configuration dictionary to the application
    with values that override the default configuration.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个配置，它包含决定图表外观的值。这些值由应用程序定义，用户无需担心它们。我们允许用户将一个配置字典传递给应用程序，使用它来覆盖默认配置中的值。
- en: Apart from the configuration, there are some other values our application needs
    to draw the solution diagram for a given structure. These values include the scales
    used to draw the geometry and loads, for example. We can’t guess these beforehand,
    so we need the user to provide them to the application.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 除了配置外，我们的应用程序还需要一些其他值来绘制给定结构的解答图。这些值包括绘制几何形状和载荷时使用的比例。例如。我们无法提前猜测这些值，因此我们需要用户将它们提供给应用程序。
- en: Let’s call these one-time values *settings*. We’ll pass our function a settings
    dictionary, but these settings won’t have default values because there are no
    sensible defaults we can use here; they completely depend on the structure being
    computed and what the user wants the result to look like. Does the user want to
    exaggerate the deformations? Or do they want to see the deformations without a
    scale to get an idea of what the deformed structure actually looks like? We can’t
    guess this ourselves, and thus, we’ll let the user of the app decide on these
    values.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这些一次性使用的值称为*设置*。我们将向函数传递一个设置字典，但这些设置不会有默认值，因为没有合适的默认值可以在这里使用；它们完全依赖于正在计算的结构以及用户希望结果的外观。用户是否希望夸大变形？还是希望看到没有比例尺的变形，以便了解变形结构的实际外观？我们无法自行猜测这些，因此，我们将让应用程序的用户来决定这些值。
- en: We’ve included all the settings we want to make available to the user in [Table
    18-1](ch18.xhtml#ch18tab1).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已将所有希望提供给用户的设置列出在[表 18-1](ch18.xhtml#ch18tab1)中。
- en: '**Table 18-1:** Output Settings'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 18-1：** 输出设置'
- en: '| **Name** | **Type** | **Purpose** |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **类型** | **用途** |'
- en: '| scale | Number | Changes the scale of the resulting drawing |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| scale | 数字 | 改变结果绘图的比例 |'
- en: '| disp_scale | Number | Changes the scale of the node displacements |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| disp_scale | 数字 | 改变节点位移的比例 |'
- en: '| load_scale | Number | Changes the scale of load representation |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| load_scale | 数字 | 改变载荷表示的比例 |'
- en: '| no_draw_original | Boolean | Specifies whether to draw the original geometry
    |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| no_draw_original | 布尔值 | 指定是否绘制原始几何形状 |'
- en: Let’s write a function to validate that the dictionary contains values for all
    these settings. In your *svg.py* file, enter the function in [Listing 18-3](ch18.xhtml#ch18lis3).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个函数，验证字典中是否包含所有这些设置的值。在你的*svg.py*文件中，输入[清单 18-3](ch18.xhtml#ch18lis3)中的代码。
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 18-3: Validating the settings dictionary*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 18-3：验证设置字典*'
- en: This __validate_settings function ensures all the expected settings are in the
    settings dictionary. If any of the functions are not, we raise an error with a
    message for the user. Let’s now write the function to produce the SVG image.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个__validate_settings函数确保所有预期的设置都在设置字典中。如果缺少任何设置，它将向用户抛出带有信息的错误消息。现在，让我们编写生成SVG图像的函数。
- en: '***The Solution Drawing Function***'
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***解决方案绘制功能***'
- en: In the *svg.py* file, before the __read_config function, enter the code in [Listing
    18-4](ch18.xhtml#ch18lis4).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在*svg.py*文件中，在__read_config函数之前，输入[清单18-4](ch18.xhtml#ch18lis4)中的代码。
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 18-4: Structure solution to SVG function*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单18-4：结构解决方案到SVG函数*'
- en: 'We define the structure_solution_to_svg function, but it doesn’t draw anything
    yet; it just produces an empty SVG image. The function receives three parameters:
    the structure solution (a StructureSolution class instance), the settings dictionary,
    and the configuration dictionary. The configuration dictionary is optional, so
    we give it a default value of None.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了structure_solution_to_svg函数，但它还没有绘制任何内容；它只是生成一个空的SVG图像。该函数接收三个参数：结构解决方案（一个StructureSolution类实例）、设置字典和配置字典。配置字典是可选的，因此我们为其提供了默认值None。
- en: In the function, we first validate the passed-in settings using the function
    we wrote in the previous section. If the validation fails, we raise an error and
    halt execution of the function.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在该函数中，我们首先使用前一节中编写的函数来验证传入的设置。如果验证失败，我们将抛出一个错误并停止执行该函数。
- en: Next, we load the default configuration using the __read_config function.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用__read_config函数加载默认配置。
- en: 'The next step is merging the passed-in configuration dictionary with the default
    one ➊. The dictionaries are merged using Python’s dictionary unpacking operator:
    **. If a and b are dictionaries, using {**a, **b} will create a new dictionary
    containing all the entries from a and b. If there’s a key that’s in both dictionaries,
    the version in b, the second dictionary, is kept. Therefore, in our usage, if
    a configuration value is given by the user, this overrides the default one. We
    store the merged configuration dictionary in the config variable.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将传入的配置字典与默认字典合并➊。字典的合并使用Python的字典解包操作符：**。如果a和b是字典，使用{**a, **b}将创建一个包含a和b中所有条目的新字典。如果有一个键在两个字典中都存在，那么保留的是b中的版本，即第二个字典中的版本。因此，在我们的使用中，如果用户提供了配置值，这将覆盖默认值。我们将合并后的配置字典存储在config变量中。
- en: '**NOTE**'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The dictionary unpacking operator was added in Python version 3.5\. You can
    read more about it in PEP-448:* [https://www.python.org/dev/peps/pep-0448](https://www.python.org/dev/peps/pep-0448)*.
    PEP stands for “Python Enhancement Proposal.” These are the documents the Python
    community writes to propose new features for the language, among others.*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典解包操作符在Python 3.5版本中添加。你可以在PEP-448中阅读更多内容：* [https://www.python.org/dev/peps/pep-0448](https://www.python.org/dev/peps/pep-0448)*。PEP代表“Python增强提案”。这是Python社区编写的文档，用于提议语言的新特性等。*'
- en: Next, we compute the viewbox for the SVG image using the structure solution’s
    bounding rectangle ➋. If you recall, the StructureSolution bounds_rect method’s
    first parameter is the margin for the bounds, and the second is the scale. We
    take the value for the margin from the configuration and the scale from the settings.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用结构解决方案的边界矩形➋来计算SVG图像的视图框。如果你还记得，StructureSolution类的bounds_rect方法的第一个参数是边界的边距，第二个是缩放。我们从配置中获取边距值，从设置中获取缩放值。
- en: We then create an affine transformation that we’ll use to flip the image’s y-axis
    so that it points up.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个仿射变换，用来翻转图像的y轴，使其指向上方。
- en: Lastly, we create and return the SVG image using svg_content from our svg package
    ➌. The size of the image is given by the viewbox size; the list of primitives
    is empty at the moment. In the next sections, we’ll fill this list with the SVG
    primitives that represent the nodes, bars, and loads. First, though, let’s look
    at captions.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用来自svg包的svg_content创建并返回SVG图像➌。图像的大小由视图框的大小决定；目前，原语列表为空。在接下来的章节中，我们将用表示节点、杆件和载荷的SVG原语填充这个列表。首先，让我们看看标题。
- en: '***Captions***'
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***标题***'
- en: 'We’re going to use captions in a few places: to note the bars’ stresses, to
    number the nodes, and to give forces coordinates. Positioning these captions is
    going to be a bit tricky since we’ll want to rotate them so they align with the
    element they caption, as you can see in [Figure 18-3](ch18.xhtml#ch18fig3).'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在几个地方使用标题：标注杆件的应力、编号节点和给出力的坐标。定位这些标题会有点棘手，因为我们希望旋转它们，使其与它们所标注的元素对齐，正如你在[图
    18-3](ch18.xhtml#ch18fig3)中看到的那样。
- en: '![Image](../images/18fig03.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/18fig03.jpg)'
- en: '*Figure 18-3: Captions in our diagram*'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*图18-3：我们图中的标题*'
- en: Furthermore, since we applied an affine transformation to the SVG image that
    flips the y-axis, the captions we add will also be flipped, and if we don’t undo
    that flip, they’ll be impossible to read. We’ll correct this by scaling the caption
    so that its y-axis is flipped back.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于我们对SVG图像应用了一个翻转y轴的仿射变换，因此我们添加的标题也会被翻转。如果我们不撤销这个翻转，它们将无法阅读。我们将通过缩放标题，使其y轴被翻转回去来修正这一点。
- en: 'Create a new Python file in *structures/out* named *captions_svg.py*. Your
    *out* directory should look like the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在*structures/out*中创建一个新的Python文件，名为*captions_svg.py*。你的*out*目录应该如下所示：
- en: out
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: out
- en: '|- __init__.py'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '|- __init__.py'
- en: '|- captions_svg.py'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '|- captions_svg.py'
- en: '|- svg.py'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '|- svg.py'
- en: In this new file, enter the code in [Listing 18-5](ch18.xhtml#ch18lis5).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个新文件中，输入[Listing 18-5](ch18.xhtml#ch18lis5)中的代码。
- en: '[PRE4]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 18-5: From captions to SVG*'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 18-5: 从标题到SVG*'
- en: 'We implement a function named caption_to_svg. This function has five parameters:
    the caption’s text, a point at which the caption is located, the angle it’s rotated,
    the color, and the configuration dictionary.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了一个名为caption_to_svg的函数。这个函数有五个参数：标题文本、标题所在的点、旋转角度、颜色和配置字典。
- en: We’ll extract the font family and size from the configuration dictionary. The
    first two lines save these values into the font and size variables, respectively
    ➊.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从配置字典中提取字体系列和字体大小。前两行将这些值分别保存到font和size变量中➊。
- en: The next thing we do is compute an affine transformation that scales and rotates
    the caption. We first generate the rotation with the make_rotation function and
    then the scaling with the make_scale function; lastly, these are combined into
    a single transformation ➋. Note how both transformations are done with respect
    to the caption’s position point (see [Figure 18-4](ch18.xhtml#ch18fig4)). This
    is key. If we scaled and rotated the caption around the global origin (the ⟨0,
    0⟩ point), it would appear somewhere unexpected in the drawing.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们计算一个仿射变换来缩放和旋转标题。我们首先使用make_rotation函数生成旋转变换，然后使用make_scale函数生成缩放变换；最后，这些变换被合并成一个单一的变换➋。请注意，这两个变换都是相对于标题位置点进行的（见[Figure
    18-4](ch18.xhtml#ch18fig4)）。这一点非常关键。如果我们围绕全局原点（⟨0, 0⟩点）缩放和旋转标题，标题将在图形中出现在一个意想不到的位置。
- en: '![Image](../images/18fig04.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/18fig04.jpg)'
- en: '*Figure 18-4: Caption rotation*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*Figure 18-4: 标题旋转*'
- en: Lastly, we create the SVG text element using the svg.text function, passing
    it the caption, the center point, a zero displacement vector, and a list of attributes
    ➌. In the attributes we include the fill color, the transformation, the font family,
    and the font size.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用svg.text函数创建SVG文本元素，传递给它标题、中心点、零位移向量以及属性列表➌。在这些属性中，我们包括填充颜色、变换、字体系列和字体大小。
- en: '***The Bars***'
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***条形图***'
- en: 'Let’s now work on producing the SVG code to draw the original and deformed
    bar geometries. Bars are straight lines, so representing them won’t be too complicated.
    In the *out* directory, create a new file named *bar_svg.py*. Your *out* directory
    should look like the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续生成SVG代码，以绘制原始和变形后的条形几何形状。条形是直线，因此表示它们不会太复杂。在*out*目录下，创建一个名为*bar_svg.py*的新文件。你的*out*目录应该如下所示：
- en: out
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: out
- en: '|- __init__.py'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '|- __init__.py'
- en: '|- bar_svg.py'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '|- bar_svg.py'
- en: '|- captions_svg.py'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '|- captions_svg.py'
- en: '|- svg.py'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '|- svg.py'
- en: As we know, both the original and deformed bar geometries are straight lines.
    We’ll start by writing a helper function to generate the SVG segments that represent
    bars, both in their original and deformed states. In the file, enter the code
    in [Listing 18-6](ch18.xhtml#ch18lis6).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，原始和变形后的条形几何形状都是直线。我们将首先编写一个辅助函数，生成表示条形的SVG段落，无论是在原始状态还是变形状态。在文件中，输入[Listing
    18-6](ch18.xhtml#ch18lis6)中的代码。
- en: '[PRE5]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 18-6: Single bar to SVG*'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 18-6: 单条形到SVG*'
- en: We’ve written the __bar_svg function to generate an SVG segment using the passed-in
    geometry, which should be an instance of our Segment class; we’ve also passed
    in the color to use and the cross section of the bar.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经编写了__bar_svg函数，用来根据传入的几何形状生成一个SVG段落，该几何形状应为我们的Segment类的实例；我们还传入了要使用的颜色和条形的截面。
- en: 'Why do we need the cross-section value? We’ll use a line thickness that roughly
    represents the cross section of the bar so that bars with a larger cross section
    are drawn with a thicker line. [Figure 18-5](ch18.xhtml#ch18fig5) shows our approximation:
    we’re computing the line thickness as if it was the side of a square cross section.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们需要横截面值？我们将使用一个大致代表条形横截面的线条厚度，这样横截面较大的条形将用较粗的线条绘制。[图 18-5](ch18.xhtml#ch18fig5)
    展示了我们的近似：我们将线条厚度计算为横截面正方形一边的长度。
- en: '![Image](../images/18fig05.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/18fig05.jpg)'
- en: '*Figure 18-5: Calculating line thickness from the cross section*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 18-5：根据横截面计算线条厚度*'
- en: In the section_height variable, we store the height of the bar as if its section
    was square ➊. This value is computed from the square root of the bar’s cross section.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在 section_height 变量中，我们将条形的高度存储为其横截面为正方形的情况 ➊。这个值是通过条形横截面的平方根计算得出的。
- en: 'Lastly, we return an SVG segment using the passed-in geometry and adding two
    attributes: the stroke color and the line thickness we’ve computed ➋.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用传入的几何图形返回一个 SVG 片段，并添加两个属性：描边颜色和我们计算出的线条厚度 ➋。
- en: Let’s continue and write the first version of the bars_to_svg function. In your
    file and before the __bar_svg function we just wrote, enter the code in [Listing
    18-7](ch18.xhtml#ch18lis7).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续并编写 bars_to_svg 函数的第一个版本。在你的文件中，在我们刚刚编写的 __bar_svg 函数之前，输入 [列表 18-7](ch18.xhtml#ch18lis7)
    中的代码。
- en: '[PRE6]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 18-7: Bar to SVG*'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 18-7：条形转 SVG*'
- en: 'In this listing, we merely outline the main algorithm to generate SVG primitives
    representing the bars. There are three functions that do most of the work, but
    we haven’t written them yet: original_bar_to_svg, bar_to_svg, and bar_stress_to_svg.
    We’ll write these shortly.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个列表中，我们只是概述了生成表示条形的 SVG 原语的主要算法。虽然有三个函数负责大部分工作，但我们还没有编写它们：original_bar_to_svg、bar_to_svg
    和 bar_stress_to_svg。我们稍后会编写这些函数。
- en: Our bars_to_svg function first saves the negated value of the no_draw _original
    setting in the should_draw_original variable. If should_draw_original is true,
    our function will also include the segments representing the original bars.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 bars_to_svg 函数首先保存 no_draw_original 设置的取反值，保存在 should_draw_original 变量中。如果
    should_draw_original 为真，我们的函数也会包括表示原始条形的片段。
- en: 'Next, we declare three empty lists: original, final, and stresses ➊. The first
    one, original, stores the segments that represent the original bars; the second
    one, final, contains the final or solution bars; and the last list, stresses,
    stores the stress captions. We’ll put all the SVG primitives we generate in these
    lists.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们声明三个空列表：original、final 和 stresses ➊。第一个列表 original 存储表示原始条形的片段；第二个列表 final
    存储最终的解决方案条形；最后一个列表 stresses 存储应力标签。我们将把所有生成的 SVG 原语放入这些列表中。
- en: We then iterate through the bars. For each one, if should_draw_original is true,
    we append the result of original_bar_to_svg to the original list ➋; original_bar_to_svg
    is a function we haven’t written yet that generates the SVG segment for the original
    bar. We append the SVG representing the solution bar to the final list ➌ and the
    stress caption to stresses ➍.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们开始迭代条形。对于每个条形，如果 should_draw_original 为真，我们将 original_bar_to_svg 的结果添加到
    original 列表 ➋；original_bar_to_svg 是我们尚未编写的函数，它生成表示原始条形的 SVG 片段。我们将表示解决方案条形的 SVG
    添加到 final 列表 ➌，将应力标签添加到 stresses 列表 ➍。
- en: 'After the loop, the three lists are filled with the SVG primitives that represent
    the bars of the original and solution structures. We concatenate and return those
    lists ➎. As noted by the comment in the code, the order here is important: the
    elements that appear last in the list will be drawn on top of the rest. We want
    the original bars to be behind the solution bars; thus, they need to appear first
    in the list. You can imagine these bars as being distributed by layers, as depicted
    in [Figure 18-6](ch18.xhtml#ch18fig6).'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 循环之后，三个列表将填充表示原始和解决方案结构条形的 SVG 原语。我们将这些列表连接并返回 ➎。正如代码中的注释所指出的，这里顺序很重要：最后出现在列表中的元素将绘制在其余元素之上。我们希望原始条形位于解决方案条形的下方，因此它们需要首先出现在列表中。你可以想象这些条形是按层分布的，如
    [图 18-6](ch18.xhtml#ch18fig6) 所示。
- en: '![Image](../images/18fig06.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/18fig06.jpg)'
- en: '*Figure 18-6: Drawing the bar SVGs in layers*'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 18-6：按层绘制条形 SVG*'
- en: Let’s write the three functions we used to generate the SVG primitives.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写生成 SVG 原语所用的三个函数。
- en: '**Drawing the Original Bars**'
  id: totrans-114
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**绘制原始条形图**'
- en: For these functions, we’re going to use a technique we explored in the “Functions
    Inside Other Functions” section on [page 28](ch02.xhtml#ch00lev2sec21). We’ll
    define them as internal functions inside the bars_to_svg function so they gain
    access to the parameters passed to bars_to_svg. This spares us from having to
    pass around the settings and config dictionaries. The resulting internal functions
    will have a shorter parameter list, which makes them simpler. As the functions
    are effectively kept private in bars_to_svg, only the host function has access
    to them.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些函数，我们将使用我们在“函数内部函数”章节中探讨的一种技术，位于[第28页](ch02.xhtml#ch00lev2sec21)。我们将在 `bars_to_svg`
    函数内部定义它们，这样它们就可以访问传递给 `bars_to_svg` 的参数。这样我们就不需要传递配置和设置字典。最终的内部函数将具有更短的参数列表，使它们更加简洁。由于这些函数实际上保持在
    `bars_to_svg` 内部，因此只有宿主函数可以访问它们。
- en: Let’s write the original_bar_to_svg function first. In your file, enter the
    missing code in [Listing 18-8](ch18.xhtml#ch18lis8).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们编写 `original_bar_to_svg` 函数。在你的文件中，输入[第18-8节](ch18.xhtml#ch18lis8)中的缺失代码。
- en: '[PRE7]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 18-8: Original (nonsolution) bar to SVG*'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*第18-8节：原始（非解法）条形到SVG*'
- en: 'We’ve written the original_bar_to_svg function inside the bars_to_svg function,
    at the beginning of it. This function requires only one argument: a bar from the
    solution structure (of type StrBarSolution), which contains the original bar inside
    its original_geometry attribute.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已将 `original_bar_to_svg` 函数写在 `bars_to_svg` 函数的开头。这个函数只需要一个参数：来自解法结构的条形（类型为
    `StrBarSolution`），该条形包含在其 `original_geometry` 属性中的原始条形。
- en: First, we extract the color for the original bar from the configuration dictionary
    ➊. Then, we return the result of calling the __bar_svg function with the original
    bar’s geometry, the color, and the bar’s cross section ➋.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从配置字典中提取原始条形的颜色 ➊。然后，我们返回调用 `__bar_svg` 函数的结果，传入原始条形的几何形状、颜色和条形的横截面 ➋。
- en: '**Drawing the Solution Bars**'
  id: totrans-121
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**绘制解法条形**'
- en: Now let’s write the code to draw the solution bars. These will have a different
    color depending on if their stress is compressive or tensile. In the bars_to_svg
    function, after the original_bar_to_svg function we just wrote, enter the missing
    code in [Listing 18-9](ch18.xhtml#ch18lis9).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们编写代码来绘制解法条形。根据应力是压缩还是拉伸，它们将有不同的颜色。在 `bars_to_svg` 函数中，在我们刚刚编写的 `original_bar_to_svg`
    函数之后，输入[第18-9节](ch18.xhtml#ch18lis9)中的缺失代码。
- en: '[PRE8]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 18-9: Solution bar to SVG*'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*第18-9节：解法条形到SVG*'
- en: 'The bar_to_svg function returns the result of calling __bar_svg with the displaced
    bar as first argument, computed using the final_geometry_scaling _displacement
    method we implemented in the StrBarSolution class ➊. The second argument is the
    color, which we compute using another function that we implemented later in the
    code: bar_color ➋. The third and last argument is the bar’s cross section ➌.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`bar_to_svg` 函数返回调用 `__bar_svg` 的结果，第一个参数是已位移的条形，使用我们在 `StrBarSolution` 类中实现的
    `final_geometry_scaling_displacement` 方法计算 ➊。第二个参数是颜色，我们使用在代码中稍后实现的另一个函数 `bar_color`
    计算 ➋。第三个也是最后一个参数是条形的横截面 ➌。'
- en: The bar_color function returns the correct color from the configuration dictionary
    depending on the sign of the bar’s stress. Note, once again, how we don’t need
    the config dictionary to be passed to this function. We already have access to
    it because we are inside the bars_to_svg function.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`bar_color` 函数根据条形应力的符号从配置字典中返回正确的颜色。请注意，再次强调，我们不需要将配置字典传递给此函数。因为我们处于 `bars_to_svg`
    函数内部，已经可以访问它。'
- en: '**Drawing the Stress Captions**'
  id: totrans-127
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**绘制应力标注**'
- en: Lastly, we need to draw the stress captions. These are a bit tricky to position
    inside the drawing, but we solved the hardest part earlier in the caption_to_svg
    function.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要绘制应力标注。这些标注在绘图中定位有点棘手，但我们在 `caption_to_svg` 函数中已经解决了最难的部分。
- en: Enter the missing code in [Listing 18-10](ch18.xhtml#ch18lis10).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 输入[第18-10节](ch18.xhtml#ch18lis10)中的缺失代码。
- en: '[PRE9]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 18-10: Bar stress to SVG*'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*第18-10节：条形应力到SVG*'
- en: 'We import Vector from *geom2d* and the caption_to_svg function we implemented
    earlier in this chapter. Then, we declare three constants:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 *geom2d* 导入 `Vector` 和我们在本章前面实现的 `caption_to_svg` 函数。然后，我们声明三个常量：
- en: __I_VERSOR is the *î* versor to represent the horizontal direction.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: __I_VERSOR 是表示水平方向的 *î* 向量。
- en: __STRESS_DISP is the distance we use to separate the caption from the bar’s
    geometry.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: __STRESS_DISP 是我们用来将标注与条形几何形状分开的距离。
- en: __DECIMAL_POS is the number of decimals we use to format the stress values.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: __DECIMAL_POS 是我们用于格式化应力值的小数位数。
- en: Then comes the implementation of the bar_stress_to_svg function. The first thing
    we want to do in this function is compute the geometry of the bar we’re adding
    a caption to, with exactly the same scale as the drawing itself ➊. We want our
    caption to be aligned with the drawing of the bar; thus, we need its geometry
    as a reference.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是bar_stress_to_svg函数的实现。在这个函数中，我们首先要做的事情是计算我们要添加标题的条形图的几何形状，且该几何形状与图纸本身的比例完全一致
    ➊。我们希望标题与条形图的绘制图形对齐，因此我们需要其几何形状作为参考。
- en: Next, we compute the bar’s geometry normal versor; we need this direction to
    compute the caption’s position. Then, we compute the caption’s origin point, called
    position, by displacing the bar’s middle point in the direction of the normal
    versor an amount equal to __STRESS_DISP ➋. [Figure 18-7](ch18.xhtml#ch18fig7)
    illustrates this.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们计算条形图的几何法线方向向量；我们需要这个方向来计算标题的位置。然后，我们通过将条形图的中点沿法线方向向量移动一个等于__STRESS_DISP
    ➋的量，来计算标题的原点，即位置。此过程如[Figure 18-7](ch18.xhtml#ch18fig7)所示。
- en: '![Image](../images/18fig07.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/18fig07.jpg)'
- en: '*Figure 18-7: Positioning the bar caption*'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*Figure 18-7: 条形图标题的位置*'
- en: We also need the bar’s angle with the *î* versor ➌; this is the angle we’ll
    rotate the caption to align it with the bar.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要条形图与*î*方向向量之间的角度 ➌；这个角度将用于旋转标题，使其与条形图对齐。
- en: Now that we have the center point and the rotation angle, we simply need to
    return the result of calling the caption_to_svg function with these values as
    arguments ➍. For the caption’s text, we use the Greek letter *σ* (sigma), which
    is typically used to refer to mechanical stresses, followed by the bar’s stress
    value rounded to four decimals.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了中心点和旋转角度，我们只需调用caption_to_svg函数，并将这些值作为参数传递，返回结果 ➍。对于标题的文本，我们使用希腊字母*σ*（西格玛），通常用于表示机械应力，后面跟上条形图的应力值，四舍五入到四位小数。
- en: Lastly, note that the label color is the same as the bar, and thus we get it
    from the bar_color function.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请注意标签颜色与条形图相同，因此我们从bar_color函数中获取它。
- en: '**The Result**'
  id: totrans-143
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**结果**'
- en: After all the code we’ve written, your *bar_svg.py* file should look like [Listing
    18-11](ch18.xhtml#ch18lis11).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们编写的所有代码之后，你的*bar_svg.py*文件应该像[Listing 18-11](ch18.xhtml#ch18lis11)所示。
- en: '[PRE10]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 18-11: Bar to SVG result*'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 18-11: Bar转为SVG结果*'
- en: Make sure your code looks the same as [Listing 18-11](ch18.xhtml#ch18lis11),
    because we won’t be writing unit tests in this chapter. Covering our SVG generation
    functions with tests would be a great idea; there is quite a bit of logic here.
    But to keep the chapter a reasonable length, we won’t be doing it.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你的代码与[Listing 18-11](ch18.xhtml#ch18lis11)相同，因为我们在本章不会编写单元测试。为我们的SVG生成函数编写测试是个不错的主意，因为这里有很多逻辑。然而，为了保持本章的合理长度，我们不会这样做。
- en: Now it’s time for the nodes.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是节点的部分。
- en: '***The Nodes***'
  id: totrans-149
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***节点***'
- en: 'In the *out* directory, create a new file named *node_svg.py*:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在*out*目录下，创建一个名为*node_svg.py*的新文件：
- en: out
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: out
- en: '|- __init__.py'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '|- __init__.py'
- en: '|- bar_svg.py'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '|- bar_svg.py'
- en: '|- captions_svg.py'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '|- captions_svg.py'
- en: '|- node_svg.py'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '|- node_svg.py'
- en: '|- svg.py'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '|- svg.py'
- en: In this file, enter the code in [Listing 18-12](ch18.xhtml#ch18lis12).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在此文件中，输入[Listing 18-12](ch18.xhtml#ch18lis12)中的代码。
- en: '[PRE11]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 18-12: Node to SVG*'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 18-12: Node转为SVG*'
- en: 'We first import a few things—make sure you get them all. Then, we define the
    nodes_to_svg function with the list of StrNodeSolution instances and the settings
    and config dictionaries as input parameters. This function maps each node in the
    nodes list to its SVG representation, which is obtained by calling an internal
    function: node_to_svg ➏. The mapping is done using a list comprehension.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入一些内容—确保你全部导入了。然后，我们定义nodes_to_svg函数，输入参数为StrNodeSolution实例列表以及settings和config字典。该函数将nodes列表中的每个节点映射到其SVG表示形式，这通过调用一个内部函数node_to_svg
    ➏来实现。映射是通过列表推导完成的。
- en: The node_to_svg internal function operates on a single node, and it has access
    to the host function parameters ➊. The first thing it does is save some configuration
    parameters in variables.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: node_to_svg内部函数操作单个节点，并且可以访问主函数的参数 ➊。它首先做的事情是将一些配置参数保存到变量中。
- en: Next, we compute the displaced position of the node ➋ and the position for the
    caption, which will be the node’s ID ➌. The caption’s position is obtained by
    displacing the node’s position an amount equal to its radius both horizontally
    and vertically. [Figure 18-8](ch18.xhtml#ch18fig8) illustrates this.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们计算节点的位移位置 ➋以及标题的位置，该位置将是节点的ID ➌。标题的位置是通过将节点的位置沿水平方向和垂直方向各移动一个等于其半径的量来获得的。[Figure
    18-8](ch18.xhtml#ch18fig8)展示了这一过程。
- en: '![Image](../images/18fig08.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/18fig08.jpg)'
- en: '*Figure 18-8: Node caption positioning*'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 18-8：节点标题定位*'
- en: The node_to_svg function returns an SVG group consisting of a circle representing
    the node itself ➍ and the caption ➎.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: node_to_svg 函数返回一个 SVG 组，包含表示节点本身的圆形 ➍ 和标题 ➎。
- en: Our nodes are ready! Let’s add their external reaction forces.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的节点已经准备好了！让我们添加它们的外部反应力。
- en: '***The Node Reactions***'
  id: totrans-167
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***节点反应***'
- en: We’ll also include the reaction forces of the externally constrained nodes in
    our SVG diagram. We’ll represent these as arrows with a caption, similar to [Figure
    18-9](ch18.xhtml#ch18fig9).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将在 SVG 图中包含外部约束节点的反应力。我们将以箭头和标题的形式表示这些，就像 [图 18-9](ch18.xhtml#ch18fig9) 一样。
- en: '![Image](../images/18fig09.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/18fig09.jpg)'
- en: '*Figure 18-9: Node reaction*'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 18-9：节点反应*'
- en: Since we’ll draw external loads and reactions the same way, let’s write a function
    that draws a Vector geometric primitive as an arrow with a caption; that way we
    can use it for both cases.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将以相同的方式绘制外部荷载和反应力，让我们编写一个函数，绘制一个带有标题的箭头作为向量几何原语；这样我们就可以用于两种情况。
- en: '**Drawing Vectors**'
  id: totrans-172
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**绘制向量**'
- en: 'In the *out* directory, create a new file named *vector_svg.py*. Your *out*
    directory should look like the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *out* 目录中，创建一个新文件，命名为 *vector_svg.py*。你的 *out* 目录应如下所示：
- en: out
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: out
- en: '|- __init__.py'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '|- __init__.py'
- en: '|- bar_svg.py'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '|- bar_svg.py'
- en: '|- captions_svg.py'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '|- captions_svg.py'
- en: '|- node_svg.py'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '|- node_svg.py'
- en: '|- svg.py'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '|- svg.py'
- en: '|- vector_svg.py'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '|- vector_svg.py'
- en: In this file, enter the code in [Listing 18-13](ch18.xhtml#ch18lis13).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在此文件中，输入 [清单 18-13](ch18.xhtml#ch18lis13) 中的代码。
- en: '[PRE12]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 18-13: Vector to SVG*'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 18-13：向量到 SVG*'
- en: 'We define three constants:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了三个常量：
- en: __I_VERSOR is used to compute an angle with the horizontal direction.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: __I_VERSOR 用于计算与水平方向的角度。
- en: __CAPTION_DISP is the separation between the vector’s baseline and the caption.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: __CAPTION_DISP 是向量基准线和标题之间的间隔。
- en: __DECIMAL_POS formats the vector coordinates using a fixed number of decimals.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: __DECIMAL_POS 用固定小数位数格式化向量坐标。
- en: 'Then comes the vector_to_svg function, which has the following arguments:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是 vector_to_svg 函数，它具有以下参数：
- en: position is the vector’s base point.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: position 是向量的基准点。
- en: vector is the vector itself.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: vector 是向量本身。
- en: scale is applied to the vector to shorten or lengthen it.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: scale 应用于向量，用于缩短或延长它。
- en: color is the stroke and font colors.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: color 是描边和字体颜色。
- en: config is the configuration dictionary.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: config 是配置字典。
- en: In the function, we create a segment to represent the vector’s baseline ➊. The
    start point for the segment is the passed-in position displaced by the vector
    (also passed as an argument to the function) and using a scale of -scale. We want
    the vector’s arrow located at the origin point; thus, the end point for the segment
    is in the opposite direction of the vector. You can see this configuration of
    the vector segment points illustrated in [Figure 18-10](ch18.xhtml#ch18fig10).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数中，我们创建一个段来表示向量的基准线 ➊。该段的起点是传入位置，由向量（也作为参数传递给函数）位移，并使用 -scale 的比例。我们希望向量的箭头位于原点；因此，该段的终点位于向量的相反方向。你可以在
    [图 18-10](ch18.xhtml#ch18fig10) 中看到这种向量段端点配置。
- en: '![Image](../images/18fig10.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/18fig10.jpg)'
- en: '*Figure 18-10: Vector segment end points*'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 18-10：向量段的端点*'
- en: We also compute the caption’s origin point using the segment’s start point displaced
    in the normal direction of the segment’s direction ➋ (see [Figure 18-11](ch18.xhtml#ch18fig11)).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还通过将段的起点按段的法向方向位移来计算标题的原点 ➋（见 [图 18-11](ch18.xhtml#ch18fig11)）。
- en: '![Image](../images/18fig11.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/18fig11.jpg)'
- en: '*Figure 18-11: Node reaction caption’s position*'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 18-11：节点反应标题的位置*'
- en: 'Then there are two functions we haven’t implemented yet: svg_arrow and svg_caption.
    These are the functions that will draw the arrow and the caption. We’ll get to
    them shortly.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是两个我们还未实现的函数：svg_arrow 和 svg_caption。它们是绘制箭头和标题的函数。我们很快就会实现它们。
- en: Lastly, we return an SVG group consisting of the results of the svg_arrow and
    svg_caption functions ➌.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们返回一个包含 svg_arrow 和 svg_caption 函数结果的 SVG 组 ➌。
- en: Let’s implement the two missing functions. Enter the missing code in [Listing
    18-14](ch18.xhtml#ch18lis14).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现这两个缺失的函数。输入 [清单 18-14](ch18.xhtml#ch18lis14) 中缺失的代码。
- en: '[PRE13]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 18-14: Vector to SVG*'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 18-14：向量到 SVG*'
- en: The svg_arrow function first saves the width and arrow_size configuration values
    inside variables. Then it returns our SVG arrow primitive, passing it the segment,
    the arrow_size for both the arrow width and length, and the list of attributes
    including the stroke color and width ➊. Recall that our svg.arrow function draws
    the arrow located at the segment’s end point.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: svg_arrow 函数首先将宽度和箭头大小配置值保存在变量中。然后，它返回我们的 SVG 箭头原语，传入段落、箭头宽度和长度的箭头大小，以及包括笔触颜色和宽度的属性列表
    ➊。回顾一下，我们的 svg.arrow 函数绘制位于段落末端点的箭头。
- en: The svg_caption function returns the result of calling the svg_caption function
    with the caption string, origin point, rotation angle, color, and configuration
    dictionary ➋. The caption with the right format is computed using our Vector class’s
    to_formatted_str method. This method isn’t implemented yet, so let’s write it
    to create a string with the vector components and norm.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: svg_caption 函数返回调用 svg_caption 函数的结果，传入标题字符串、原点、旋转角度、颜色和配置字典 ➋。使用我们的 Vector
    类的 to_formatted_str 方法计算正确格式的标题。这个方法尚未实现，所以让我们编写它来创建包含向量分量和范数的字符串。
- en: Open the *geom2d/vector.py* file and enter the code in [Listing 18-15](ch18.xhtml#ch18lis15).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 *geom2d/vector.py* 文件，并输入 [列表 18-15](ch18.xhtml#ch18lis15) 中的代码。
- en: '[PRE14]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 18-15: Vector to formatted string*'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 18-15：向量到格式化字符串*'
- en: We’ll also need a similar method in the Point class to format the position of
    the nodes in the text representation of the solution. Open *geom2d/point.py* and
    enter the code in [Listing 18-16](ch18.xhtml#ch18lis16).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在 Point 类中定义一个类似的方法，用于格式化解的文本表示中的节点位置。打开 *geom2d/point.py* 并输入 [列表 18-16](ch18.xhtml#ch18lis16)
    中的代码。
- en: '[PRE15]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 18-16: Point to formatted string*'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 18-16：点到格式化字符串*'
- en: Now that we’ve implemented a way of drawing vectors with a caption for their
    coordinates, let’s use our implementation to display the node reactions.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了一种绘制带有坐标标题的向量的方法，让我们使用我们的实现来显示节点反应。
- en: '**Drawing the Reaction Forces**'
  id: totrans-214
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**绘制反应力**'
- en: 'In the *out* directory, create a new file named *reaction_svg.py*. Your *out*
    directory should look like the following:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *out* 目录中，创建一个名为 *reaction_svg.py* 的新文件。你的 *out* 目录应该如下所示：
- en: out
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: out
- en: '|- __init__.py'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '|- __init__.py'
- en: '|- bar_svg.py'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '|- bar_svg.py'
- en: '|- captions_svg.py'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '|- captions_svg.py'
- en: '|- node_svg.py'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '|- node_svg.py'
- en: '|- reaction_svg.py'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '|- reaction_svg.py'
- en: '|- svg.py'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '|- svg.py'
- en: '|- vector_svg.py'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '|- vector_svg.py'
- en: In this newly created file, enter the code in [Listing 18-17](ch18.xhtml#ch18lis17).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个新创建的文件中，输入 [列表 18-17](ch18.xhtml#ch18lis17) 中的代码。
- en: '[PRE16]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 18-17: Node reactions to SVG*'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 18-17：节点对 SVG 的反应*'
- en: In this file, we define node_reactions_to_svg. Each externally constrained node
    in the structure solution is mapped to its SVG reaction using a list comprehension
    ➍.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，我们定义了 node_reactions_to_svg。结构解中的每个外部约束节点都通过列表推导式映射到其 SVG 反应 ➍。
- en: 'We’re using an inner function to produce the SVG representation of each solution
    node: reaction_svg. This function first obtains the displaced position of the
    resulting node (with disp_scale applied) ➊. Then it asks the solution structure
    for the reaction in the node ➋. With these pieces of information, we can create
    the SVG representation of the reaction vector using the vector_to_svg function
    ➌.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个内部函数来生成每个解节点的 SVG 表示：reaction_svg。这个函数首先获取结果节点的位移位置（应用了 disp_scale） ➊。然后，它请求解结构中该节点的反应
    ➋。通过这些信息，我们可以使用 vector_to_svg 函数生成反应向量的 SVG 表示 ➌。
- en: '***The Loads***'
  id: totrans-229
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***载荷***'
- en: The last things we want to draw in the result image are the loads applied to
    the structure.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在结果图像中最后要绘制的是施加在结构上的载荷。
- en: 'In the *out* directory, create a new file named *load_svg.py*. Your *out* directory
    should look like the following:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *out* 目录中，创建一个名为 *load_svg.py* 的新文件。你的 *out* 目录应该如下所示：
- en: out
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: out
- en: '|- __init__.py'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '|- __init__.py'
- en: '|- bar_svg.py'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '|- bar_svg.py'
- en: '|- captions_svg.py'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '|- captions_svg.py'
- en: '|- load_svg.py'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '|- load_svg.py'
- en: '|- node_svg.py'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '|- node_svg.py'
- en: '|- reaction_svg.py'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '|- reaction_svg.py'
- en: '|- svg.py'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '|- svg.py'
- en: '|- vector_svg.py'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '|- vector_svg.py'
- en: In *load_svg.py*, enter the code in [Listing 18-18](ch18.xhtml#ch18lis18).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *load_svg.py* 中，输入 [列表 18-18](ch18.xhtml#ch18lis18) 中的代码。
- en: '[PRE17]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 18-18: Loads to SVG*'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 18-18：载荷到 SVG*'
- en: 'In this file, we define a function, loads_to_svg, receiving three arguments:
    the StrNodeSolution list and the settings and config dictionaries. The function
    relies on two inner functions: svg_node_loads and svg_load. We use a list comprehension
    to map each node that has external loads in the passed-in nodes list to its SVG
    representation ➍. We use the is_loaded property of each node to filter the nodes
    that are externally loaded.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，我们定义了一个函数 loads_to_svg，接收三个参数：StrNodeSolution 列表以及 settings 和 config
    字典。该函数依赖于两个内部函数：svg_node_loads 和 svg_load。我们使用列表推导将每个在传入的节点列表中有外部荷载的节点映射到其 SVG
    表示 ➍。我们使用每个节点的 is_loaded 属性来过滤出外部加载的节点。
- en: 'The svg_node_loads internal function first gets the displaced position of the
    solution node ➊ and then returns an SVG group of all the loads in the node ➋.
    Each load is mapped to an SVG vector using the second internal function: svg_load.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: svg_node_loads 内部函数首先获取解算节点 ➊ 的位移位置，然后返回节点中所有荷载的 SVG 组 ➋。每个荷载都通过第二个内部函数：svg_load，映射到一个
    SVG 向量。
- en: 'The svg_load function is straightforward: it simply calls the vector_to_svg
    function passing the appropriate parameters ➌.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: svg_load 函数非常简单：它仅调用 vector_to_svg 函数，并传递适当的参数 ➌。
- en: With this, we have all of our SVG generation code ready! We just need to put
    it all together, and we can finally start drawing structure solutions.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 到这里，我们的所有 SVG 生成代码已经准备好！我们只需将它们整合在一起，就可以开始绘制结构解算图了。
- en: '***Putting It All Together***'
  id: totrans-248
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***将所有内容结合起来***'
- en: Let’s now open the *svg.py* file and add the functions we’ve written into the
    structure_solution_to_svg function. Enter the missing code, following [Listing
    18-19](ch18.xhtml#ch18lis19).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们打开 *svg.py* 文件，将我们编写的函数添加到 structure_solution_to_svg 函数中。按照 [Listing 18-19](ch18.xhtml#ch18lis19)
    输入缺失的代码。
- en: '[PRE18]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 18-19: Structure solution to SVG*'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 18-19: 结构解算到 SVG*'
- en: First, we import the bars_to_svg, loads_to_svg, nodes_to_svg, and node _reactions_to_svg
    functions ➊.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入 bars_to_svg、loads_to_svg、nodes_to_svg 和 node_reactions_to_svg 函数 ➊。
- en: 'Then, inside structure_solution_to_svg, we call each of the functions to generate
    the corresponding SVG code ➋. The results are stored in svg_bars, svg_nodes, svg_react,
    and svg_loads. These are concatenated in one list that we pass to the svg_content
    function ➌. The order is important: the SVG primitives toward the end of the list
    will appear in front of those at the beginning of it.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 structure_solution_to_svg 函数内部，我们调用每个函数以生成相应的 SVG 代码 ➋。结果被存储在 svg_bars、svg_nodes、svg_react
    和 svg_loads 中。这些结果被连接成一个列表，我们将其传递给 svg_content 函数 ➌。顺序很重要：列表末尾的 SVG 基元会出现在前面的基元之前。
- en: '***The Final Result***'
  id: totrans-254
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***最终结果***'
- en: If you’ve followed along, your *svg.py* file should be similar to [Listing 18-20](ch18.xhtml#ch18lis20).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经跟随完成，你的 *svg.py* 文件应该与 [Listing 18-20](ch18.xhtml#ch18lis20) 类似。
- en: '[PRE19]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 18-20: Structure solution to SVG*'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 18-20: 结构解算到 SVG*'
- en: We have everything that we need, but before we put it to work in the next chapter,
    let’s also prepare a textual representation of the solution.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好了所有需要的内容，但在下一章开始使用之前，让我们准备一个解算的文本表示。
- en: '**From Structure Solution to Text**'
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**从结构解算到文本**'
- en: A visual diagram helps us understand the structural deformations; because we
    color the bars depending on the stress they’re subject to, it’s also a good way
    to see which bars are compressed and which are stretched. At the same time, it
    may be simpler to study the numeric results in a text format, and we may want
    to have them do some other calculations. The formats are complementary, and our
    structural analysis program will output both.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 通过视觉图示，我们可以更好地理解结构变形；因为我们根据条形图所受的应力对其进行着色，这也是查看哪些条形图被压缩、哪些被拉伸的好方法。同时，以文本格式研究数值结果可能更为简便，且我们可能希望它进行其他计算。这两种格式是互补的，我们的结构分析程序将同时输出这两者。
- en: 'We will write the displacement of each node in a text file using the following
    format:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下格式将每个节点的位移写入文本文件：
- en: '[PRE20]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If the node has external constraints, we want to check its reactions as well.
    In this case, we can include one last line:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如果节点有外部约束，我们还需要检查它的反应。在这种情况下，我们可以添加最后一行：
- en: '[PRE21]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The bars will follow this format:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 条形图将遵循以下格式：
- en: '[PRE22]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Let’s write a function that generates this plaintext representation of a structure
    solution.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个生成结构解算的纯文本表示的函数。
- en: '***Structure Solution’s String***'
  id: totrans-268
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结构解算的字符串***'
- en: Before we write the function that generates the plaintext representation, let’s
    write a useful helper function that takes a list of strings and returns a single
    string with all those strings concatenated by a “newline” character.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们编写生成纯文本表示的函数之前，先编写一个有用的辅助函数，该函数接受一个字符串列表并返回一个单一的字符串，将所有字符串通过“换行”字符连接在一起。
- en: We want to define each of the result values as a string of its own, but the
    function we’ll implement returns one and only one string, which is then written
    into a file.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将每个结果值定义为独立的字符串，但我们实现的函数只能返回一个字符串，该字符串随后会被写入文件。
- en: 'Let’s create a new file for this helper function. In your *utils* package,
    create a new Python file named *strings.py*. This package should now have the
    following contents:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为这个辅助函数创建一个新的文件。在你的*utils*包中，创建一个新的Python文件，命名为*strings.py*。该包现在应包含以下内容：
- en: utils
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: utils
- en: '|- __init__.py'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '|- __init__.py'
- en: '|- lists.py'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '|- lists.py'
- en: '|- pairs.py'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '|- pairs.py'
- en: '|- strings.py'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '|- strings.py'
- en: In this *strings.py* file, enter the function in [Listing 18-21](ch18.xhtml#ch18lis21).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个*strings.py*文件中，输入[Listing 18-21](ch18.xhtml#ch18lis21)中的函数。
- en: '[PRE23]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 18-21: List to string*'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 18-21: 列表转字符串*'
- en: This list_to_string function maps a list of strings into a single string where
    each entry is separated from the next using the ’\n’ (newline) character.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`list_to_string`函数将一个字符串列表映射为一个单一的字符串，每个条目之间使用‘\n’（换行符）字符分隔。
- en: 'Let’s now outline the text output function’s logic. First, create a new *text.py*
    file inside the *structures/out* package, which now should have the following
    files:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们概述一下文本输出函数的逻辑。首先，在*structures/out*包内创建一个新的*text.py*文件，该包现在应包含以下文件：
- en: out
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: out
- en: '|- __init__.py'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '|- __init__.py'
- en: '|- bar_svg.py'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '|- bar_svg.py'
- en: '|- captions_svg.py'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '|- captions_svg.py'
- en: '|- load_svg.py'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '|- load_svg.py'
- en: '|- node_svg.py'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '|- node_svg.py'
- en: '|- reaction_svg.py'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '|- reaction_svg.py'
- en: '|- svg.py'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '|- svg.py'
- en: '|- text.py'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '|- text.py'
- en: '|- vector_svg.py'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '|- vector_svg.py'
- en: In this *text.py* file, enter the code in [Listing 18-22](ch18.xhtml#ch18lis22).
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个*text.py*文件中，输入[Listing 18-22](ch18.xhtml#ch18lis22)中的代码。
- en: '[PRE24]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Listing 18-22: Structure solution to text*'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 18-22: 结构解决方案转文本*'
- en: In this listing, we import the StrBarSolution, StrNodeSolution, and Structure
    Solution classes, as well as the list_to_string function. We define two constants,
    one to specify the number of decimal positions we want to use to format the resulting
    values, __DECIMAL_POS ➊, and a separation string list, __SEPARATION, which we
    use to separate the different sections in the result string.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个列表中，我们导入了`StrBarSolution`、`StrNodeSolution`和`Structure Solution`类，以及`list_to_string`函数。我们定义了两个常量，一个用于指定要用来格式化结果值的小数位数，`__DECIMAL_POS`
    ➊，另一个是分隔字符串列表`__SEPARATION`，用于在结果字符串中分隔不同的部分。
- en: 'Then comes the main function, structure_solution_to_string. This function receives
    only one parameter: the structure solution. It uses two private functions: one
    to convert the string representation of the nodes ➋ and another to convert the
    bars ➌. The results are stored as list strings in the nodes_text and bars_text
    variables. These lists are concatenated with the __SEPARATION strings in the middle
    and passed to list_to_string ➍.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是主函数`structure_solution_to_string`。这个函数只接收一个参数：结构解决方案。它使用两个私有函数：一个用于转换节点的字符串表示
    ➋，另一个用于转换条形 ➌。结果存储在`nodes_text`和`bars_text`变量中，这两个列表通过`__SEPARATION`字符串连接，并传递给`list_to_string`
    ➍。
- en: After this main function, we define the rest of the private functions, but they’ve
    yet to be implemented. Let’s do that now.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个主函数之后，我们定义了其余的私有函数，但它们尚未实现。现在让我们来实现它们。
- en: '***The Nodes***'
  id: totrans-298
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***节点***'
- en: Let’s start with the nodes. Fill the __nodes_to_string and __node_to_string
    functions with the code in [Listing 18-23](ch18.xhtml#ch18lis23).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从节点开始。将代码填入[Listing 18-23](ch18.xhtml#ch18lis23)中的`__nodes_to_string`和`__node_to_string`函数。
- en: '[PRE25]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 18-23: Nodes to text*'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 18-23: 节点转文本*'
- en: The first function, __nodes_to_string, uses a list comprehension to map each
    node in the result to its textual representation, for which it uses the __node_to_string
    function ➊. This function requires not only the node but also the entire structure
    object as parameters. Recall that the reaction force of a node is computed by
    the structure solution instances, not by the nodes themselves.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数`__nodes_to_string`使用列表推导将结果中的每个节点映射到其文本表示，为此它使用了`__node_to_string`函数 ➊。此函数不仅需要节点本身，还需要整个结构对象作为参数。请记住，节点的反作用力是由结构解决方案实例计算的，而不是由节点本身计算的。
- en: The __node_to_string function first obtains the formatted strings for the node’s
    original position ➋, the global displacement vector, and the displaced position.
    We use the to_formatted_str method from the Point and Vector classes to handle
    the point coordinates formatting.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: __node_to_string函数首先获取节点原始位置 ➋、全局位移向量和位移位置的格式化字符串。我们使用Point和Vector类的to_formatted_str方法来处理点坐标的格式化。
- en: 'Next, we declare a list, strings ➌, where we place the strings we just obtained.
    Note that, except for the first one, which serves as header, the strings all start
    with the tab (\t) character. With this, we achieve the nice formatting we defined
    earlier:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们声明一个列表strings ➌，将刚才获得的字符串放入其中。注意，除了第一个作为标题，其他字符串都以制表符（\t）字符开始。这样，我们就实现了之前定义的良好格式化：
- en: '[PRE26]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Next, we generate the reaction force string if the node is externally constrained
    ➍. For this, we first use the structure solution class to compute the reaction
    for the given node, then format it using the to_formatted_str method, and lastly
    append it to the strings list.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，如果节点受到外部约束 ➍，我们生成反作用力字符串。为此，我们首先使用结构解算类计算给定节点的反作用力，然后使用to_formatted_str方法格式化它，最后将其附加到字符串列表中。
- en: The last step is to convert the obtained string list into a single string using
    the helper list_to_string function with a newline character appended to the end
    ➎.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是使用辅助函数list_to_string将得到的字符串列表转换为单个字符串，并在末尾附加换行符 ➎。
- en: '***The Bars***'
  id: totrans-308
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***条形***'
- en: Let’s now fill in the functions for the bars. We’ll use some UTF-8 characters
    to make the text a bit more visual. These characters are optional; you can decide
    not to add them in your code and just go with the labels. If you decide to use
    them, we’ll explain how to do this in the section “The Unicode Characters” on
    [page 18](ch01.xhtml#page_18).
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来填充条形的函数。我们将使用一些UTF-8字符，使文本更具视觉效果。这些字符是可选的；你可以决定不在代码中添加它们，只使用标签。如果决定使用它们，我们将在“Unicode字符”部分解释如何操作，详情见[第18页](ch01.xhtml#page_18)。
- en: Enter the code in [Listing 18-24](ch18.xhtml#ch18lis24).
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 输入[清单18-24](ch18.xhtml#ch18lis24)中的代码。
- en: '[PRE27]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 18-24: Bars to text*'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单18-24：条形转文本*'
- en: The __bars_to_string function uses a list comprehension to map each bar in the
    list to its textual representation ➊. This text is produced by the second function,
    __bar_to_string.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: __bars_to_string函数使用列表推导式将列表中的每个条形映射到其文本表示形式 ➊。这个文本是由第二个函数__bar_to_string生成的。
- en: In __bar_to_string, we first prepare some strings ➋ that we later return concatenated
    using the list_to_string function ➌ and nodes_str indicates the bar’s node IDs,
    with a → character separating them.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在__bar_to_string中，我们首先准备一些字符串 ➋，然后使用list_to_string函数 ➌将它们连接返回，而nodes_str表示条形的节点ID，用→字符分隔它们。
- en: The type_str indicates whether the bar is in traction or compression, depending
    on the sign of the bar’s stress. We’re using the ⊕ symbol to decorate the TENSION
    text and ⊖ for the COMPRESSION text. This detail makes the result stand out more
    to the eye.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: type_str表示条形是受拉还是受压，取决于条形应力的符号。我们使用⊕符号来装饰TENSION文本，使用⊖来装饰COMPRESSION文本。这个细节使得结果在视觉上更为突出。
- en: 'Then comes the elongation, strain, and stress strings. These are the bar’s
    result values formatted to have __DECIMAL_POS decimal positions. Here strain is
    the exception; instead of rounding it, we want to use scientific notation with
    three decimal positions (’{:.3e}’). The strain is usually a small value, orders
    of magnitude smaller than the stress, so if we try to round it to, say, four decimal
    positions, the result will still be zero: 0.0000$. Using the ’{:.3e}’ format,
    we’ll get things like 1.259e–05 instead.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是延伸、应变和应力字符串。这些是条形结果值，格式化为具有__DECIMAL_POS小数位数。这里应变是个例外；我们不是进行四舍五入，而是希望使用科学计数法，并保留三位小数（’{:.3e}’）。应变通常是一个较小的值，比应力小几个数量级，因此如果我们尝试将其四舍五入到四位小数，比如0.0000$，结果仍然是零。使用’{:.3e}’格式，我们会得到像1.259e–05这样的值。
- en: When formatting values in our engineering applications, we have to be aware
    of the orders of magnitude. A wrongly formatted value, where the precision required
    is lost, renders the app useless.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的工程应用中格式化值时，必须注意数量级。格式错误的值，如果失去了所需的精度，会导致应用程序无法使用。
- en: '***The Unicode Characters***'
  id: totrans-318
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Unicode字符***'
- en: The icons we’re using in the code, →, *Δ*, *ϵ*, ⊕, and ⊖, are all Unicode characters.
    Every operating system has a way of inserting these characters. If you do a quick
    Google search, you should be able to find how to access them in your OS. For instance,
    macOS uses the CMD-CTRL-spacebar key combination to open the symbols dialog, which
    is how I inserted those in the code.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在代码中使用的图标，→、*Δ*、*ϵ*、⊕ 和 ⊖，都是 Unicode 字符。每个操作系统都有插入这些字符的方式。如果你进行一个简单的 Google
    搜索，你应该能找到如何在你的操作系统中访问它们。例如，macOS 使用 CMD-CTRL-空格键组合打开符号对话框，这就是我在代码中插入这些符号的方式。
- en: 'You may also insert these characters using their code in a Python string like
    so:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过在 Python 字符串中插入这些字符的代码来使用它们，方法如下：
- en: '[PRE28]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If you opt for this alternative, you’ll need to replace the characters in the
    listings with their code. [Table 18-2](ch18.xhtml#ch18tab2) shows the characters
    we’ve used and their Unicode code.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择这种替代方法，你需要用字符的代码替换列表中的字符。[表 18-2](ch18.xhtml#ch18tab2)展示了我们使用的字符及其 Unicode
    代码。
- en: '**Table 18-2:** Unicode Characters'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 18-2：** Unicode 字符'
- en: '| **Character** | **Unicode** | **Usage** |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '| **字符** | **Unicode** | **用途** |'
- en: '| ⊕ | \u2295 | Tension stress |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
  zh: '| ⊕ | \u2295 | 拉伸应力 |'
- en: '| ⊖ | \u2296 | Compression stress |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '| ⊖ | \u2296 | 压缩应力 |'
- en: '| → | \u279c | Separates the node IDs of a bar (1 →2) |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '| → | \u279c | 分隔一个条形的节点 ID（1 →2） |'
- en: '| *Δ* | \u0394 | Length increment (*Δl*) |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '| *Δ* | \u0394 | 长度增量（*Δl*） |'
- en: '| *ϵ* | \u03f5 | Strain |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '| *ϵ* | \u03f5 | 应变 |'
- en: '| *σ* | \u03c3 | Stress |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '| *σ* | \u03c3 | 应力 |'
- en: '***Putting It All Together***'
  id: totrans-331
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***将所有内容整合起来***'
- en: If you’ve followed along, your result should look like [Listing 18-25](ch18.xhtml#ch18lis25).
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你跟着做，你的结果应该像 [列表 18-25](ch18.xhtml#ch18lis25) 所示。
- en: '[PRE29]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*Listing 18-25: Structure solution to text*'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 18-25：结构解决方案转为文本*'
- en: In less than 70 lines of code we’ve written a function capable of generating
    a text representation of the structure solution model.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用不到 70 行代码编写了一个能够生成结构解决方案模型文本表示的函数。
- en: '**Summary**'
  id: totrans-336
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter, we implemented the code that creates vector diagrams representing
    the structure solution model. We split the resulting drawing process into chunks
    to make the code more manageable, and then we put it all together in the *svg.py*
    file, specifically, in the structure_solution_to_svg function.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们实现了创建表示结构解决方案模型的矢量图的代码。我们将生成图形的过程拆分成若干部分，以便让代码更易管理，然后我们将其全部整合在 *svg.py*
    文件中，特别是在 structure_solution_to_svg 函数中。
- en: We then implemented a function, structure_solution_to_string, that produces
    a plaintext representation of the structure solution.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着实现了一个函数，structure_solution_to_string，用于生成结构解决方案的纯文本表示。
- en: Now we have everything we need to put our application together. In the final
    chapter, we’ll do just that.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好将我们的应用程序整合起来了。在最后一章，我们将做到这一点。
