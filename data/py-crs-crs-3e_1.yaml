- en: Part I
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一部分
- en: Basics
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 基础知识
- en: Part I of this book teaches you the basic concepts you’ll need to write Python
    programs. Many of these concepts are common to all programming languages, so they’ll
    be useful throughout your life as a programmer.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的第一部分将教授你编写Python程序所需的基本概念。这些概念在所有编程语言中都是通用的，因此它们将在你作为程序员的一生中始终有用。
- en: In **Chapter 1** you’ll install Python on your computer and run your first program,
    which prints the message *Hello world!* to the screen.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在**第1章**中，你将安装Python，并运行你的第一个程序，它会将*Hello world!*消息打印到屏幕上。
- en: In **Chapter 2** you’ll learn to assign information to variables and work with
    text and numerical values.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在**第2章**中，你将学习如何将信息赋值给变量，并处理文本和数值数据。
- en: '**Chapters 3** and **4** introduce lists. Lists can store as much information
    as you want in one place, allowing you to work with that data efficiently. You’ll
    be able to work with hundreds, thousands, and even millions of values in just
    a few lines of code.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '**第3章**和**第4章**介绍了列表。列表可以将你想要的所有信息存储在一个地方，使你能够高效地处理这些数据。你将能够在几行代码中处理数百、数千甚至数百万个值。'
- en: In **Chapter 5** you’ll use `if` statements to write code that responds one
    way if certain conditions are true, and responds in a different way if those conditions
    are not true.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在**第5章**中，你将使用`if`语句编写代码，当某些条件为真时以一种方式响应，当这些条件不为真时则以另一种方式响应。
- en: '**Chapter 6** shows you how to use Python’s dictionaries, which let you make
    connections between different pieces of information. Like lists, dictionaries
    can contain as much information as you need to store.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**第6章**展示了如何使用Python的字典，它允许你在不同的信息之间建立联系。像列表一样，字典可以存储你需要的所有信息。'
- en: In **Chapter 7** you’ll learn how to accept input from users to make your programs
    interactive. You’ll also learn about `while` loops, which run blocks of code repeatedly
    as long as certain conditions remain true.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在**第7章**中，你将学习如何接受用户输入，使你的程序变得互动。你还将学习`while`循环，它会在某些条件为真时反复执行代码块。
- en: In **Chapter 8** you’ll write functions, which are named blocks of code that
    perform a specific task and can be run whenever you need them.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在**第8章**中，你将编写函数，函数是执行特定任务的命名代码块，可以在需要时运行。
- en: '**Chapter 9** introduces classes, which allow you to model real-world objects.
    You’ll write code that represents dogs, cats, people, cars, rockets, and more.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**第9章**介绍了类，它允许你模拟现实世界中的对象。你将编写代码来表示狗、猫、人、车、火箭等等。'
- en: '**Chapter 10** shows you how to work with files and handle errors so your programs
    won’t crash unexpectedly. You’ll store data before your program closes and read
    the data back in when the program runs again. You’ll learn about Python’s exceptions,
    which allow you to anticipate errors and make your programs handle those errors
    gracefully.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**第10章**展示了如何处理文件和错误，以防止程序意外崩溃。你将学会在程序关闭前保存数据，并在程序再次运行时读取数据。你将了解Python的异常，它们让你能够预见错误并使程序优雅地处理这些错误。'
- en: In **Chapter 11** you’ll learn to write tests for your code, to check that your
    programs work the way you intend them to. As a result, you’ll be able to expand
    your programs without worrying about introducing new bugs. Testing your code is
    one of the first skills that will help you transition from beginner to intermediate
    programmer.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在**第11章**中，你将学习如何为代码编写测试，以确保程序按预期工作。因此，你可以在不担心引入新错误的情况下扩展程序。编写测试是帮助你从初学者过渡到中级程序员的第一项技能。
- en: '1'
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Getting Started
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 入门
- en: '![](Images/chapterart.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: In this chapter, you’ll run your first Python program, *hello_world.py*. First,
    you’ll need to check whether a recent version of Python is installed on your computer;
    if it isn’t, you’ll install it. You’ll also install a text editor to work with
    your Python programs. Text editors recognize Python code and highlight sections
    as you write, making it easy to understand your code’s structure.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你将运行你的第一个Python程序，*hello_world.py*。首先，你需要检查计算机上是否安装了最新版本的Python；如果没有，你将安装它。你还将安装一个文本编辑器来处理你的Python程序。文本编辑器会识别Python代码，并在你编写时突出显示代码部分，使你更容易理解代码的结构。
- en: Setting Up Your Programming Environment
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置你的编程环境
- en: Python differs slightly on different operating systems, so you’ll need to keep
    a few considerations in mind. In the following sections, we’ll make sure Python
    is set up correctly on your system.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Python在不同的操作系统上略有不同，因此你需要记住一些注意事项。在接下来的章节中，我们将确保Python在你的系统上正确设置。
- en: Python Versions
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python版本
- en: Every programming language evolves as new ideas and technologies emerge, and
    the developers of Python have continually made the language more versatile and
    powerful. As of this writing, the latest version is Python 3.11, but everything
    in this book should run on Python 3.9 or later. In this section, we’ll find out
    if Python is already installed on your system and whether you need to install
    a newer version. Appendix A contains additional details about installing the latest
    version of Python on each major operating system as well.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 每种编程语言都会随着新想法和新技术的出现而不断发展，Python的开发者们也不断让这门语言变得更加多功能和强大。截至目前，本书的内容应该可以在Python
    3.9或更高版本上运行，但目前最新版本是Python 3.11。在本节中，我们将检查你的系统是否已经安装了Python，以及是否需要安装更新的版本。附录A还包含了在各大操作系统上安装最新版本Python的详细信息。
- en: Running Snippets of Python Code
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行Python代码片段
- en: You can run Python’s interpreter in a terminal window, allowing you to try bits
    of Python code without having to save and run an entire program.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在终端窗口中运行Python的解释器，允许你尝试Python代码的片段，而不必保存并运行整个程序。
- en: 'Throughout this book, you’ll see code snippets that look like this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，你将看到如下所示的代码片段：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The three angle brackets (`>>>`) prompt, which we’ll refer to as a *Python prompt*,
    indicates that you should be using the terminal window. The bold text is the code
    you should type in and then execute by pressing ENTER. Most of the examples in
    this book are small, self-contained programs that you’ll run from your text editor
    rather than the terminal, because you’ll write most of your code in the text editor.
    But sometimes, basic concepts will be shown in a series of snippets run through
    a Python terminal session to demonstrate particular concepts more efficiently.
    When you see three angle brackets in a code listing, you’re looking at code and
    output from a terminal session. We’ll try coding in the interpreter on your system
    in a moment.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 三个尖括号（`>>>`）提示符，我们称之为*Python提示符*，表示你应该使用终端窗口。粗体文本是你应该输入并通过按下ENTER键执行的代码。本书中的大部分示例是小型、独立的程序，你将在文本编辑器中运行它们，而不是通过终端，因为你将大部分代码编写在文本编辑器中。但有时，基本概念会通过一系列在Python终端会话中运行的代码片段来展示，以便更高效地演示特定概念。当你在代码列表中看到三个尖括号时，你正在查看来自终端会话的代码和输出。稍后我们将尝试在你的系统中运行解释器进行编码。
- en: We’ll also use a text editor to create a simple program called *Hello World!*
    that has become a staple of learning to program. There’s a long-held tradition
    in the programming world that printing the message `Hello world!` to the screen
    as your first program in a new language will bring you good luck. Such a simple
    program serves a very real purpose. If it runs correctly on your system, then
    any Python program you write should work as well.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用文本编辑器创建一个简单的程序，名为*Hello World!*，它已经成为学习编程的必备程序。在编程界有一个长期的传统，认为将`Hello
    world!`消息输出到屏幕作为新语言的第一个程序，会带来好运。如此简单的程序有着非常实际的用途。如果它在你的系统上正确运行，那么你编写的任何Python程序也应该能够正常运行。
- en: About the VS Code Editor
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关于VS Code编辑器
- en: '*VS Code* is a powerful, professional-quality text editor that’s free and beginner-friendly.
    VS Code is great for both simple and complex projects, so if you become comfortable
    using it while learning Python, you can continue using it as you progress to larger
    and more complicated projects. VS Code can be installed on all modern operating
    systems, and it supports most programming languages, including Python.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*VS Code* 是一个功能强大、专业级的文本编辑器，免费且适合初学者。VS Code非常适合简单和复杂的项目，因此如果你在学习Python的过程中熟悉使用它，你可以继续使用它来处理更大更复杂的项目。VS
    Code可以安装在所有现代操作系统上，并且支持包括Python在内的大多数编程语言。'
- en: Appendix B provides information on other text editors. If you’re curious about
    the other options, you might want to skim that appendix at this point. If you
    want to begin programming quickly, you can use VS Code to start. Then you can
    consider other editors, once you’ve gained some experience as a programmer. In
    this chapter, I’ll walk you through installing VS Code on your operating system.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 附录B提供了关于其他文本编辑器的信息。如果你对其他选项感兴趣，可以在此时浏览该附录。如果你想快速开始编程，可以使用VS Code来启动。然后，在你积累了一些编程经验后，你可以考虑使用其他编辑器。在这一章中，我将带你完成在你的操作系统上安装VS
    Code的过程。
- en: Python on Different Operating Systems
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不同操作系统上的Python
- en: Python is a cross-platform programming language, which means it runs on all
    the major operating systems. Any Python program you write should run on any modern
    computer that has Python installed. However, the methods for setting up Python
    on different operating systems vary slightly.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Python 是一种跨平台编程语言，这意味着它可以在所有主流操作系统上运行。你编写的任何 Python 程序应该可以在任何安装了 Python 的现代计算机上运行。然而，在不同操作系统上设置
    Python 的方法略有不同。
- en: In this section, you’ll learn how to set up Python on your system. You’ll first
    check whether a recent version of Python is installed on your system, and install
    it if it’s not. Then you’ll install VS Code. These are the only two steps that
    are different for each operating system.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分中，你将学习如何在你的系统上设置 Python。你将首先检查是否安装了最新版本的 Python，如果没有安装，则进行安装。然后，你将安装 VS
    Code。这是每个操作系统中唯一不同的两步。
- en: In the sections that follow, you’ll run *hello_world.py* and troubleshoot anything
    that doesn’t work. I’ll walk you through this process for each operating system,
    so you’ll have a Python programming environment that you can rely on.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，你将运行 *hello_world.py* 并解决任何无法正常工作的部分。我将为每个操作系统带你完成这个过程，这样你就能拥有一个可靠的
    Python 编程环境。
- en: Python on Windows
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Windows 上的 Python
- en: Windows doesn’t usually come with Python, so you’ll probably need to install
    it and then install VS Code.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 通常不会预装 Python，因此你可能需要先安装它，然后再安装 VS Code。
- en: Installing Python
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 安装 Python
- en: First, check whether Python is installed on your system. Open a command window
    by entering `command` into the Start menu and clicking the **Command Prompt**
    app. In the terminal window, enter `python` in lowercase. If you get a Python
    prompt (`>>>`) in response, Python is installed on your system. If you see an
    error message telling you that `python` is not a recognized command, or if the
    Microsoft store opens, Python isn’t installed. Close the Microsoft store if it
    opens; it’s better to download an official installer than to use Microsoft’s version.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，检查你的系统是否已安装 Python。通过在开始菜单中输入 `command` 并点击 **命令提示符** 应用来打开命令窗口。在终端窗口中，输入小写的
    `python`。如果你看到 Python 提示符（`>>>`），则表示 Python 已安装在你的系统中。如果你看到错误信息，告诉你 `python` 不是一个已识别的命令，或者如果
    Microsoft Store 被打开，那么 Python 就没有安装。如果 Microsoft Store 打开，关闭它；最好从官方渠道下载安装程序，而不是使用
    Microsoft 版本。
- en: If Python is not installed on your system, or if you see a version earlier than
    Python 3.9, you need to download a Python installer for Windows. Go to [https://python.org](https://python.org)
    and hover over the **Downloads** link. You should see a button for downloading
    the latest version of Python. Click the button, which should automatically start
    downloading the correct installer for your system. After you’ve downloaded the
    file, run the installer. Make sure you select the option **Add Python to PATH**,
    which will make it easier to configure your system correctly. [Figure 1-1](#figure1-1)
    shows this option selected.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的系统上没有安装 Python，或者你看到的版本早于 Python 3.9，那么你需要下载 Windows 版本的 Python 安装程序。访问
    [https://python.org](https://python.org)，将鼠标悬停在 **Downloads** 链接上。你应该看到一个按钮，点击该按钮即可自动下载适合你系统的最新版本的
    Python 安装程序。下载完成后，运行安装程序。确保你选择了 **Add Python to PATH** 选项，这将使配置系统更加方便。[图 1-1](#figure1-1)
    显示了该选项已被选中。
- en: '![](Images/f01001.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/f01001.png)'
- en: 'Figure 1-1: Make sure you select the checkbox labeled *Add Python to PATH*.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-1：确保你勾选了标有 *Add Python to PATH* 的复选框。
- en: Running Python in a Terminal Session
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在终端会话中运行 Python
- en: Open a new command window and enter `python` in lowercase. You should see a
    Python prompt (`>>>`), which means Windows has found the version of Python you
    just installed.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个新的命令窗口并输入小写的 `python`。你应该看到 Python 提示符（`>>>`），这意味着 Windows 找到了你刚安装的 Python
    版本。
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Enter the following line in your Python session:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 Python 会话中输入以下命令：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You should see the output `Hello Python interpreter!` Anytime you want to run
    a snippet of Python code, open a command window and start a Python terminal session.
    To close the terminal session, press CTRL-Z and then press ENTER, or enter the
    command `exit()`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到输出 `Hello Python interpreter!`。每当你想运行一段 Python 代码时，只需打开命令窗口并启动一个 Python
    终端会话。要关闭终端会话，按 CTRL-Z 然后按 ENTER，或者输入命令 `exit()`。
- en: Installing VS Code
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 安装 VS Code
- en: You can download an installer for VS Code at [https://code.visualstudio.com](https://code.visualstudio.com).
    Click the **Download for Windows** button and run the installer. Skip the following
    sections about macOS and Linux, and follow the steps in “Running a Hello World
    Program” on page 9.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://code.visualstudio.com](https://code.visualstudio.com) 下载 VS Code
    安装程序。点击 **Download for Windows** 按钮并运行安装程序。跳过接下来的 macOS 和 Linux 部分，按照第 9 页的“运行
    Hello World 程序”步骤操作。
- en: Python on macOS
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: macOS 上的 Python
- en: Python is not installed by default on the latest versions of macOS, so you’ll
    need to install it if you haven’t already done so. In this section, you’ll install
    the latest version of Python, and then install VS Code and make sure it’s configured
    correctly.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在最新版本的 macOS 上，Python 默认没有安装，因此如果你还没有安装，你需要进行安装。在本节中，你将安装最新版本的 Python，然后安装 VS
    Code 并确保其正确配置。
- en: Checking Whether Python 3 Is Installed
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 检查是否安装了 Python 3
- en: Open a terminal window by going to **Applications**▶**Utilities**▶**Terminal**.
    You can also press ⌘-spacebar, type `terminal`, and then press ENTER. To see if
    you have a recent enough version of Python installed, enter `python3`. You’ll
    most likely see a message about installing the *command line developer tools*.
    It’s better to install these tools after installing Python, so if this message
    appears, cancel the pop-up window.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 通过访问 **应用程序**▶**实用工具**▶**终端** 来打开终端窗口。你也可以按 ⌘-空格键，输入 `terminal`，然后按回车键。要检查是否安装了足够新的
    Python 版本，输入 `python3`。你很可能会看到一条关于安装 *命令行开发工具* 的消息。最好在安装 Python 后再安装这些工具，所以如果出现此消息，请取消弹出的窗口。
- en: If the output shows you have Python 3.9 or a later version installed, you can
    skip the next section and go to “Running Python in a Terminal Session.” If you
    see any version earlier than Python 3.9, follow the instructions in the next section
    to install the latest version.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输出显示你安装了 Python 3.9 或更高版本，可以跳过下一节，直接进入“在终端会话中运行 Python”。如果你看到任何早于 Python 3.9
    的版本，请按照下一节的说明安装最新版本。
- en: Note that on macOS, whenever you see the `python` command in this book, you
    need to use the `python3` command instead to make sure you’re using Python 3\.
    On most macOS systems, the `python` command either points to an outdated version
    of Python that should only be used by internal system tools, or it points to nothing
    and generates an error message.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在 macOS 上，每当你在本书中看到 `python` 命令时，你需要使用 `python3` 命令来确保你正在使用 Python 3。大多数
    macOS 系统中，`python` 命令要么指向一个过时的 Python 版本，只应由内部系统工具使用，要么指向空白并产生错误信息。
- en: Installing the Latest Version of Python
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 安装最新版本的 Python
- en: You can find a Python installer for your system at [https://python.org](https://python.org).
    Hover over the **Download** link, and you should see a button for downloading
    the latest version of Python. Click the button, which should automatically start
    downloading the correct installer for your system. After the file downloads, run
    the installer.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://python.org](https://python.org) 找到适用于你的系统的 Python 安装程序。将鼠标悬停在
    **Download** 链接上，你应该会看到一个下载最新版本 Python 的按钮。点击该按钮，应该会自动开始下载适用于你系统的正确安装程序。文件下载后，运行该安装程序。
- en: After the installer runs, a Finder window should appear. Double-click the *Install
    Certificates.command* file. Running this file will allow you to more easily install
    additional libraries that you’ll need for real-world projects, including the projects
    in the second half of this book.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 安装程序运行后，应该会出现一个 Finder 窗口。双击 *Install Certificates.command* 文件。运行此文件将帮助你更轻松地安装你在现实项目中需要的附加库，包括本书后半部分的项目。
- en: Running Python in a Terminal Session
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在终端会话中运行 Python
- en: 'You can now try running snippets of Python code by opening a new terminal window
    and typing `python3`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以通过打开一个新的终端窗口并输入 `python3` 来尝试运行 Python 代码片段：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This command starts a Python terminal session. You should see a Python prompt
    (`>>>`), which means macOS has found the version of Python you just installed.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令会启动 Python 终端会话。你应该会看到 Python 提示符（`>>>`），这意味着 macOS 已经找到了你刚刚安装的 Python 版本。
- en: 'Enter the following line in the terminal session:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端会话中输入以下命令：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You should see the message `Hello Python interpreter!`, which should print directly
    in the current terminal window. You can close the Python interpreter by pressing
    CTRL-D or by entering the command `exit()`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到消息 `Hello Python interpreter!`，它应该会直接在当前终端窗口中打印出来。你可以通过按 CTRL-D 或输入命令
    `exit()` 来关闭 Python 解释器。
- en: Installing VS Code
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 安装 VS Code
- en: To install the VS Code editor, you need to download the installer at [https://code.visualstudio.com](https://code.visualstudio.com).
    Click the **Download** button, and then open a **Finder** window and go to the
    **Downloads** folder. Drag the **Visual Studio Code** installer to your Applications
    folder, then double-click the installer to run it.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 VS Code 编辑器，你需要在 [https://code.visualstudio.com](https://code.visualstudio.com)
    下载安装程序。点击**下载**按钮，然后打开**Finder**窗口，进入**下载**文件夹。将**Visual Studio Code**安装程序拖到应用程序文件夹，然后双击安装程序运行。
- en: Skip over the following section about Python on Linux, and follow the steps
    in “Running a Hello World Program” on page 9.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 跳过接下来的关于 Linux 上 Python 的部分，按照第 9 页“运行 Hello World 程序”中的步骤进行操作。
- en: Python on Linux
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Linux 上的 Python
- en: Linux systems are designed for programming, so Python is already installed on
    most Linux computers. The people who write and maintain Linux expect you to do
    your own programming at some point, and encourage you to do so. For this reason,
    there’s very little to install and only a few settings to change to start programming.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 系统专为编程设计，因此大多数 Linux 计算机上已经安装了 Python。编写和维护 Linux 的人期望你在某个时候自己进行编程，并鼓励你这样做。因此，开始编程时几乎没有需要安装的内容，只有少量的设置需要更改。
- en: Checking Your Version of Python
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 检查你的 Python 版本
- en: 'Open a terminal window by running the Terminal application on your system (in
    Ubuntu, you can press CTRL-ALT-T). To find out which version of Python is installed,
    enter `python3` with a lowercase *p*. When Python is installed, this command starts
    the Python interpreter. You should see output indicating which version of Python
    is installed. You should also see a Python prompt (`>>>`) where you can start
    entering Python commands:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行系统上的终端应用程序打开终端窗口（在 Ubuntu 中，你可以按 CTRL-ALT-T）。要查找安装的 Python 版本，输入小写的`python3`。当
    Python 安装完成时，这个命令会启动 Python 解释器。你应该能看到显示已安装 Python 版本的输出。你还应该看到一个 Python 提示符（`>>>`），在这里你可以开始输入
    Python 命令：
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This output indicates that Python 3.10.4 is currently the default version of
    Python installed on this computer. When you’ve seen this output, press CTRL-D
    or enter `exit()` to leave the Python prompt and return to a terminal prompt.
    Whenever you see the `python` command in this book, enter `python3` instead.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出表示 Python 3.10.4 是当前安装在这台计算机上的默认 Python 版本。当你看到这个输出时，按 CTRL-D 或输入`exit()`以退出
    Python 提示符并返回终端提示符。每当你在本书中看到`python`命令时，应该输入`python3`代替。
- en: You’ll need Python 3.9 or later to run the code in this book. If the Python
    version installed on your system is earlier than Python 3.9, or if you want to
    update to the latest version currently available, refer to the instructions in
    Appendix A.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要 Python 3.9 或更高版本才能运行本书中的代码。如果你系统上安装的 Python 版本低于 3.9，或者如果你想更新到当前可用的最新版本，请参考附录
    A 中的说明。
- en: Running Python in a Terminal Session
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在终端会话中运行 Python
- en: 'You can try running snippets of Python code by opening a terminal and entering
    `python3`, as you did when checking your version. Do this again, and when you
    have Python running, enter the following line in the terminal session:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过打开终端并输入`python3`来尝试运行 Python 代码片段，正如你在检查版本时所做的那样。再次执行此操作，当 Python 正在运行时，在终端会话中输入以下行：
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The message should print directly in the current terminal window. Remember that
    you can close the Python interpreter by pressing CTRL-D or by entering the command
    `exit()`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 消息应该直接显示在当前的终端窗口中。记住，你可以通过按 CTRL-D 或输入命令`exit()`来关闭 Python 解释器。
- en: Installing VS Code
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 安装 VS Code
- en: On Ubuntu Linux, you can install VS Code from the Ubuntu Software Center. Click
    the Ubuntu Software icon in your menu and search for *vscode*. Click the app called
    **Visual Studio Code** (sometimes called *code*), and then click **Install**.
    Once it’s installed, search your system for *VS Code* and launch the app.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ubuntu Linux 上，你可以通过 Ubuntu 软件中心安装 VS Code。点击菜单中的 Ubuntu 软件图标，然后搜索*vscode*。点击名为**Visual
    Studio Code**的应用（有时也叫*code*），然后点击**安装**。安装完成后，搜索你的系统，找到*VS Code*，然后启动该应用。
- en: Running a Hello World Program
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行 Hello World 程序
- en: With a recent version of Python and VS Code installed, you’re almost ready to
    run your first Python program written in a text editor. But before doing so, you
    need to install the Python extension for VS Code.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装了最新版本的 Python 和 VS Code 后，你几乎准备好在文本编辑器中运行你的第一个 Python 程序了。但在此之前，你需要为 VS Code
    安装 Python 扩展。
- en: Installing the Python Extension for VS Code
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为 VS Code 安装 Python 扩展
- en: VS Code works with many different programming languages; to get the most out
    of it as a Python programmer, you’ll need to install the Python extension. This
    extension adds support for writing, editing, and running Python programs.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: VS Code 支持多种编程语言；作为 Python 开发者，想要最大限度地发挥它的作用，你需要安装 Python 扩展。这个扩展提供了编写、编辑和运行
    Python 程序的支持。
- en: To install the Python extension, click the Manage icon, which looks like a gear
    in the lower-left corner of the VS Code app. In the menu that appears, click **Extensions**.
    Enter `python` in the search box and click the **Python** extension. (If you see
    more than one extension named *Python*, choose the one supplied by Microsoft.)
    Click **Install** and install any additional tools that your system needs to complete
    the installation. If you see a message that you need to install Python, and you’ve
    already done so, you can ignore this message.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 Python 扩展，点击 VS Code 应用程序左下角的齿轮图标。在出现的菜单中，点击 **扩展**。在搜索框中输入 `python`，然后点击
    **Python** 扩展。（如果你看到多个名为 *Python* 的扩展，请选择由 Microsoft 提供的那个。）点击 **安装**，并安装任何你的系统需要的附加工具来完成安装。如果看到提示需要安装
    Python，而你已经安装了，可以忽略此消息。
- en: Running hello_world.py
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行 hello_world.py
- en: Before you write your first program, make a folder called *python_work* on your
    desktop for your projects. It’s best to use lowercase letters and underscores
    for spaces in file and folder names, because Python uses these naming conventions.
    You can make this folder somewhere other than the desktop, but it will be easier
    to follow some later steps if you save the *python_work* folder directly on your
    desktop.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写第一个程序之前，在桌面上创建一个名为 *python_work* 的文件夹来存放你的项目。最好在文件和文件夹名称中使用小写字母和下划线代替空格，因为
    Python 使用这种命名惯例。你可以在桌面以外的地方创建此文件夹，但如果直接将 *python_work* 文件夹保存在桌面上，之后的一些步骤会更容易跟随。
- en: Open VS Code, and close the **Get Started** tab if it’s still open. Make a new
    file by clicking **File**▶**New File** or pressing CTRL-N (⌘-N on macOS). Save
    the file as *hello_world.py* in your *python_work* folder. The extension *.py*
    tells VS Code that your file is written in Python, and tells it how to run the
    program and highlight the text in a helpful way.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 VS Code，如果 **Get Started** 标签页还未关闭，请关闭它。通过点击 **文件**▶**新建文件**，或者按 CTRL-N（在
    macOS 上为 ⌘-N）来创建一个新文件。将文件保存为 *hello_world.py*，保存在你的 *python_work* 文件夹中。扩展名 *.py*
    告诉 VS Code 你的文件是用 Python 编写的，并且告诉它如何运行程序并以有帮助的方式高亮显示文本。
- en: 'After you’ve saved your file, enter the following line in the editor:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件后，在编辑器中输入以下内容：
- en: '**hello_world.py**'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**hello_world.py**'
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To run your program, select **Run**▶**Run Without Debugging** or press CTRL-F5\.
    A terminal screen should appear at the bottom of the VS Code window, showing your
    program’s output:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行程序，选择 **运行**▶**无调试运行**，或者按 CTRL-F5。VS Code 窗口底部应该出现一个终端屏幕，显示你程序的输出：
- en: '[PRE8]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You’ll likely see some additional output showing the Python interpreter that
    was used to run your program. If you want to simplify the information that’s displayed
    so you only see your program’s output, see Appendix B. You can also find helpful
    suggestions about how to use VS Code more efficiently in Appendix B.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会看到一些额外的输出，显示用于运行程序的 Python 解释器。如果你想简化显示的信息，只看到程序的输出，请参阅附录 B。附录 B 中也提供了关于如何更高效使用
    VS Code 的一些有用建议。
- en: If you don’t see this output, something might have gone wrong in the program.
    Check every character on the line you entered. Did you accidentally capitalize
    `print`? Did you forget one or both of the quotation marks or parentheses? Programming
    languages expect very specific syntax, and if you don’t provide that, you’ll get
    errors. If you can’t get the program to run, see the suggestions in the next section.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有看到这个输出，可能程序出了问题。检查你输入的每个字符。你是否不小心把 `print` 大小写写错了？你是否忘记了一个或两个引号或括号？编程语言要求非常具体的语法，如果你没有遵循，程序就会出错。如果你无法运行程序，请参阅下一节中的建议。
- en: Troubleshooting
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 故障排除
- en: 'If you can’t get *hello_world.py* to run, here are a few remedies you can try
    that are also good general solutions for any programming problem:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果无法运行 *hello_world.py*，这里有一些可以尝试的解决办法，它们也是解决任何编程问题的常见方法：
- en: When a program contains a significant error, Python displays a *traceback*,
    which is an error report. Python looks through the file and tries to identify
    the problem. Check the traceback; it might give you a clue as to what issue is
    preventing the program from running.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当程序包含重大错误时，Python会显示一个*traceback*（回溯），这是一个错误报告。Python会浏览文件并尝试识别问题。检查回溯，它可能会给你一个线索，指示是什么问题导致程序无法运行。
- en: Step away from your computer, take a short break, and then try again. Remember
    that syntax is very important in programming, so something as simple as mismatched
    quotation marks or mismatched parentheses can prevent a program from running properly.
    Reread the relevant parts of this chapter, look over your code, and try to find
    the mistake.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 离开电脑，休息一下，然后再试一次。记住，编程中语法非常重要，因此像引号不匹配或括号不匹配这样的简单问题就可能导致程序无法正常运行。重新阅读本章相关部分，检查你的代码，试着找到问题所在。
- en: Start over again. You probably don’t need to uninstall any software, but it
    might make sense to delete your *hello_world.py* file and re-create it from scratch.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从头开始。你可能不需要卸载任何软件，但删除你的*hello_world.py*文件并从头创建它可能更有意义。
- en: Ask someone else to follow the steps in this chapter, on your computer or a
    different one, and watch what they do carefully. You might have missed one small
    step that someone else happens to catch.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请别人按照本章中的步骤在你的电脑或其他电脑上操作，仔细观察他们的操作。你可能会错过一个小步骤，而别人恰好会发现。
- en: See the additional installation instructions in Appendix A; some of the details
    included in the Appendix may help you solve your issue.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅附录A中的额外安装说明；附录中包含的一些细节可能会帮助你解决问题。
- en: Find someone who knows Python and ask them to help you get set up. If you ask
    around, you might find that you unexpectedly know someone who uses Python.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找一个懂Python的人，向他们求助帮助你完成设置。如果你问问周围的人，你可能会意外地发现有认识的人会使用Python。
- en: The setup instructions in this chapter are also available through this book’s
    companion website at [https://ehmatthes.github.io/pcc_3e](https://ehmatthes.github.io/pcc_3e).
    The online version of these instructions might work better because you can simply
    cut and paste code and click links to the resources you need.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的设置说明也可以通过本书的伴随网站访问：[https://ehmatthes.github.io/pcc_3e](https://ehmatthes.github.io/pcc_3e)。在线版本的这些说明可能会更有效，因为你可以直接剪切粘贴代码并点击链接获取所需资源。
- en: Ask for help online. Appendix C provides a number of resources, such as forums
    and live chat sites, where you can ask for solutions from people who’ve already
    worked through the issue you’re currently facing.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在线寻求帮助。附录C提供了许多资源，例如论坛和在线聊天网站，你可以在这些地方向已经解决过你当前问题的人寻求解决方案。
- en: Never worry that you’re bothering experienced programmers. Every programmer
    has been stuck at some point, and most programmers are happy to help you set up
    your system correctly. As long as you can state clearly what you’re trying to
    do, what you’ve already tried, and the results you’re getting, there’s a good
    chance someone will be able to help you. As mentioned in the introduction, the
    Python community is very friendly and welcoming to beginners.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要担心打扰经验丰富的程序员。每个程序员都曾经卡在某个点上，而且大多数程序员都很乐意帮助你正确设置系统。只要你能清楚地说明你在做什么，已经尝试了哪些方法，得到了什么结果，那么很有可能有人能够帮助你。正如在导言中提到的，Python社区对初学者非常友好和欢迎。
- en: Python should run well on any modern computer. Early setup issues can be frustrating,
    but they’re well worth sorting out. Once you get *hello_world.py* running, you
    can start to learn Python, and your programming work will become more interesting
    and satisfying.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Python应该能在任何现代计算机上良好运行。最初的设置问题可能令人沮丧，但完全值得解决。一旦你成功运行*hello_world.py*，你就可以开始学习Python，并且你的编程工作将变得更加有趣和令人满足。
- en: Running Python Programs from a Terminal
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从终端运行Python程序
- en: You’ll run most of your programs directly in your text editor. However, sometimes
    it’s useful to run programs from a terminal instead. For example, you might want
    to run an existing program without opening it for editing.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你将大部分程序直接在文本编辑器中运行。但是，有时从终端运行程序更有用。例如，你可能想运行一个现有的程序，而无需打开它进行编辑。
- en: You can do this on any system with Python installed if you know how to access
    the directory where the program file is stored. To try this, make sure you’ve
    saved the *hello_world.py* file in the *python_work* folder on your desktop.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 只要你知道如何访问存储程序文件的目录，你可以在任何安装了Python的系统上进行此操作。为了尝试这个，确保你已将*hello_world.py*文件保存在桌面上的*python_work*文件夹中。
- en: On Windows
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Windows上
- en: You can use the terminal command `cd`, for *change directory*, to navigate through
    your filesystem in a command window. The command `dir`, for *directory*, shows
    you all the files that exist in the current directory.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用终端命令`cd`，即*切换目录*，在命令窗口中浏览你的文件系统。命令`dir`，即*目录*，会显示当前目录下所有存在的文件。
- en: 'Open a new terminal window and enter the following commands to run *hello_world.py*:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个新的终端窗口，输入以下命令来运行*hello_world.py*：
- en: '[PRE9]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: First, use the `cd` command to navigate to the *python_work* folder, which is
    in the *Desktop* folder. Next, use the `dir` command to make sure *hello_world.py*
    is in this folder. Then run the file using the command `python hello_world.py`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用`cd`命令导航到*python_work*文件夹，该文件夹位于*Desktop*文件夹中。接下来，使用`dir`命令确认*hello_world.py*在该文件夹中。然后，使用命令`python
    hello_world.py`来运行该文件。
- en: Most of your programs will run fine directly from your editor. However, as your
    work becomes more complex, you’ll want to run some of your programs from a terminal.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数程序可以直接从编辑器运行。然而，随着工作变得更加复杂，你可能会希望从终端运行一些程序。
- en: On macOS and Linux
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在macOS和Linux上
- en: Running a Python program from a terminal session is the same on Linux and macOS.
    You can use the terminal command `cd`, for *change directory*, to navigate through
    your filesystem in a terminal session. The command `ls`, for *list*, shows you
    all the nonhidden files that exist in the current directory.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端会话中运行Python程序在Linux和macOS上是相同的。你可以使用终端命令`cd`，即*切换目录*，在终端会话中浏览你的文件系统。命令`ls`，即*列出*，会显示当前目录下所有非隐藏的文件。
- en: 'Open a new terminal window and enter the following commands to run *hello_world.py*:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个新的终端窗口，输入以下命令来运行*hello_world.py*：
- en: '[PRE10]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: First, use the `cd` command to navigate to the *python_work* folder, which is
    in the *Desktop* folder. Next, use the `ls` command to make sure *hello_world.py*
    is in this folder. Then run the file using the command `python3 hello_world.py`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用`cd`命令导航到*python_work*文件夹，该文件夹位于*Desktop*文件夹中。接下来，使用`ls`命令确认*hello_world.py*在该文件夹中。然后，使用命令`python3
    hello_world.py`来运行该文件。
- en: Most of your programs will run fine directly from your editor. But as your work
    becomes more complex, you’ll want to run some of your programs from a terminal.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数程序可以直接从编辑器运行。但随着工作变得更加复杂，你可能会希望从终端运行一些程序。
- en: Summary
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 小结
- en: In this chapter, you learned a bit about Python in general, and you installed
    Python on your system if it wasn’t already there. You also installed a text editor
    to make it easier to write Python code. You ran snippets of Python code in a terminal
    session, and you ran your first program, *hello_world.py*. You probably learned
    a bit about troubleshooting as well.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你了解了Python的基本知识，如果你的系统尚未安装Python，你也安装了它。你还安装了一个文本编辑器，以便更轻松地编写Python代码。你在终端会话中运行了Python代码片段，并运行了第一个程序*hello_world.py*。你可能还学到了一些故障排除的知识。
- en: In the next chapter, you’ll learn about the different kinds of data you can
    work with in your Python programs, and you’ll start to use variables as well.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习可以在Python程序中使用的不同数据类型，并且你也将开始使用变量。
- en: '2'
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Variables and Simple Data Types
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 变量和简单数据类型
- en: '![](Images/chapterart.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: In this chapter you’ll learn about the different kinds of data you can work
    with in your Python programs. You’ll also learn how to use variables to represent
    data in your programs.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习到可以在Python程序中使用的各种数据类型。你还将学习如何使用变量来表示程序中的数据。
- en: What Really Happens When You Run hello_world.py
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 当你运行`hello_world.py`时，会发生什么
- en: 'Let’s take a closer look at what Python does when you run *hello_world.py*.
    As it turns out, Python does a fair amount of work, even when it runs a simple
    program:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看，当你运行*hello_world.py*时，Python到底做了什么。事实证明，即使是运行一个简单的程序，Python也要做相当多的工作：
- en: '**hello_world.py**'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**hello_world.py**'
- en: '[PRE11]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When you run this code, you should see the following output:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这段代码时，你应该会看到以下输出：
- en: '[PRE12]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When you run the file *hello_world.py*, the ending *.py* indicates that the
    file is a Python program. Your editor then runs the file through the *Python interpreter*,
    which reads through the program and determines what each word in the program means.
    For example, when the interpreter sees the word `print` followed by parentheses,
    it prints to the screen whatever is inside the parentheses.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行文件*hello_world.py*时，文件名以*.py*结尾，表示该文件是一个Python程序。然后，编辑器通过*Python解释器*运行该文件，解释器逐行读取程序并确定每个单词的含义。例如，当解释器看到`print`后跟括号时，它会将括号内的内容打印到屏幕上。
- en: As you write your programs, your editor highlights different parts of your program
    in different ways. For example, it recognizes that `print()` is the name of a
    function and displays that word in one color. It recognizes that `"Hello Python
    world!"` is not Python code, and displays that phrase in a different color. This
    feature is called *syntax highlighting* and is quite useful as you start to write
    your own programs.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写程序时，编辑器会以不同的方式突出显示程序的不同部分。例如，它会识别 `print()` 是一个函数的名称，并将该词以一种颜色显示。它会识别 `"Hello
    Python world!"` 不是 Python 代码，并将该短语以不同的颜色显示。此功能称为 *语法高亮*，当你开始编写自己的程序时非常有用。
- en: Variables
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量
- en: 'Let’s try using a variable in *hello_world.py*. Add a new line at the beginning
    of the file, and modify the second line:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试在 *hello_world.py* 中使用一个变量。为文件开头添加一行，并修改第二行：
- en: '**hello_world.py**'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**hello_world.py**'
- en: '[PRE13]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Run this program to see what happens. You should see the same output you saw
    previously:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个程序看看会发生什么。你应该看到与之前相同的输出：
- en: '[PRE14]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We’ve added a *variable* named `message`. Every variable is connected to a *value*,
    which is the information associated with that variable. In this case the value
    is the `"Hello Python world!"` text.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经添加了一个名为 *message* 的变量。每个变量都与一个 *值* 相关联，这个值就是与该变量相关的信息。在此情况下，值为 `"Hello Python
    world!"` 文本。
- en: Adding a variable makes a little more work for the Python interpreter. When
    it processes the first line, it associates the variable `message` with the `"Hello
    Python world!"` text. When it reaches the second line, it prints the value associated
    with `message` to the screen.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 添加变量会稍微增加 Python 解释器的工作量。当它处理第一行时，会将变量 `message` 与 `"Hello Python world!"` 文本关联。当它处理到第二行时，会将与
    `message` 相关联的值打印到屏幕上。
- en: 'Let’s expand on this program by modifying *hello_world.py* to print a second
    message. Add a blank line to *hello_world.py*, and then add two new lines of code:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过修改 *hello_world.py* 来扩展这个程序，使其打印第二条消息。为 *hello_world.py* 添加一个空行，然后再添加两行新代码：
- en: '[PRE15]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now when you run *hello_world.py*, you should see two lines of output:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你运行 *hello_world.py* 时，你应该会看到两行输出：
- en: '[PRE16]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You can change the value of a variable in your program at any time, and Python
    will always keep track of its current value.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以随时更改程序中变量的值，Python 会始终跟踪其当前值。
- en: Naming and Using Variables
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命名和使用变量
- en: 'When you’re using variables in Python, you need to adhere to a few rules and
    guidelines. Breaking some of these rules will cause errors; other guidelines just
    help you write code that’s easier to read and understand. Be sure to keep the
    following rules in mind when working with variables:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Python 变量时，你需要遵守一些规则和准则。违反其中某些规则会导致错误；其他准则则有助于你编写更易于阅读和理解的代码。编写变量时请务必记住以下规则：
- en: Variable names can contain only letters, numbers, and underscores. They can
    start with a letter or an underscore, but not with a number. For instance, you
    can call a variable `message_1` but not `1_message`.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量名只能包含字母、数字和下划线。它们可以以字母或下划线开头，但不能以数字开头。例如，你可以将变量命名为 `message_1`，但不能命名为 `1_message`。
- en: Spaces are not allowed in variable names, but underscores can be used to separate
    words in variable names. For example, `greeting_message` works but `greeting message`
    will cause errors.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量名中不允许有空格，但可以使用下划线分隔变量名中的单词。例如，`greeting_message` 可行，但 `greeting message` 会导致错误。
- en: Avoid using Python keywords and function names as variable names. For example,
    do not use the word `print` as a variable name; Python has reserved it for a particular
    programmatic purpose. (See “Python Keywords and Built-in Functions” on page 466.)
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免使用 Python 的关键字和函数名作为变量名。例如，不能使用 `print` 作为变量名；Python 已经将其保留为特定的程序用途。（请参阅第466页的“Python关键字和内置函数”）
- en: Variable names should be short but descriptive. For example, `name` is better
    than `n`, `student_name` is better than `s_n`, and `name_length` is better than
    `length_of_persons_name`.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量名应该简洁且具有描述性。例如，`name` 比 `n` 更好，`student_name` 比 `s_n` 更好，`name_length` 比 `length_of_persons_name`
    更好。
- en: Be careful when using the lowercase letter *l* and the uppercase letter *O*
    because they could be confused with the numbers *1* and *0*.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用小写字母 *l* 和大写字母 *O* 时要小心，因为它们可能会与数字 *1* 和 *0* 混淆。
- en: It can take some practice to learn how to create good variable names, especially
    as your programs become more interesting and complicated. As you write more programs
    and start to read through other people’s code, you’ll get better at coming up
    with meaningful names.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 学习如何创建好的变量名可能需要一些练习，尤其是当你的程序变得越来越有趣和复杂时。随着你写更多的程序，并开始阅读其他人的代码，你会越来越擅长为变量命名并赋予它们有意义的名字。
- en: Avoiding Name Errors When Using Variables
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 避免在使用变量时出现名称错误
- en: Every programmer makes mistakes, and most make mistakes every day. Although
    good programmers might create errors, they also know how to respond to those errors
    efficiently. Let’s look at an error you’re likely to make early on and learn how
    to fix it.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 每个程序员都会犯错误，大多数程序员每天都会犯错误。虽然优秀的程序员也可能会产生错误，但他们知道如何高效地应对这些错误。让我们看看你可能会在早期犯的一个错误，并学习如何修复它。
- en: 'We’ll write some code that generates an error on purpose. Enter the following
    code, including the misspelled word `mesage`*,* which is shown in bold:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一些故意生成错误的代码。输入以下代码，其中包含拼写错误的单词`mesage`*，*该单词用粗体显示：
- en: '[PRE17]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'When an error occurs in your program, the Python interpreter does its best
    to help you figure out where the problem is. The interpreter provides a traceback
    when a program cannot run successfully. A *traceback* is a record of where the
    interpreter ran into trouble when trying to execute your code. Here’s an example
    of the traceback that Python provides after you’ve accidentally misspelled a variable’s
    name:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序出现错误时，Python 解释器会尽力帮助你找出问题所在。如果程序无法成功运行，解释器会提供回溯信息。*回溯*是记录解释器在执行代码时遇到问题的位置。以下是
    Python 提供的回溯示例，当你不小心拼写错了变量名时：
- en: '[PRE18]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The output reports that an error occurs in line 2 of the file *hello_world.py*
    ❶. The interpreter shows this line ❷ to help us spot the error quickly and tells
    us what kind of error it found ❸. In this case it found a *name error* and reports
    that the variable being printed, `mesage`, has not been defined. Python can’t
    identify the variable name provided. A name error usually means we either forgot
    to set a variable’s value before using it, or we made a spelling mistake when
    entering the variable’s name. If Python finds a variable name that’s similar to
    the one it doesn’t recognize, it will ask if that’s the name you meant to use.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 输出报告了文件 *hello_world.py* 第 2 行发生了错误 ❶。解释器显示了这一行 ❷，帮助我们快速找到错误，并告诉我们它发现了什么类型的错误
    ❸。在这个例子中，它发现了一个 *名称错误*，并报告说正在打印的变量 `mesage` 尚未定义。Python 无法识别提供的变量名。名称错误通常意味着我们要么忘记在使用变量之前设置它的值，要么在输入变量名时拼写错误。如果
    Python 找到一个与它无法识别的变量名相似的名字，它会询问这是否是你想使用的名称。
- en: 'In this example we omitted the letter *s* in the variable name `message` in
    the second line. The Python interpreter doesn’t spellcheck your code, but it does
    ensure that variable names are spelled consistently. For example, watch what happens
    when we spell *message* incorrectly in the line that defines the variable:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们在第二行的变量名 `message` 中漏掉了字母 *s*。Python 解释器不会检查你的代码拼写，但它会确保变量名拼写一致。例如，当我们在定义变量的那一行错误拼写
    *message* 时，看看会发生什么：
- en: '[PRE19]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this case, the program runs successfully!
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，程序成功运行！
- en: '[PRE20]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The variable names match, so Python sees no issue. Programming languages are
    strict, but they disregard good and bad spelling. As a result, you don’t need
    to consider English spelling and grammar rules when you’re trying to create variable
    names and writing code.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 变量名称匹配，因此 Python 没有问题。编程语言是严格的，但它们忽略了拼写的好坏。因此，当你在创建变量名并编写代码时，你不需要考虑英语的拼写和语法规则。
- en: Many programming errors are simple, single-character typos in one line of a
    program. If you find yourself spending a long time searching for one of these
    errors, know that you’re in good company. Many experienced and talented programmers
    spend hours hunting down these kinds of tiny errors. Try to laugh about it and
    move on, knowing it will happen frequently throughout your programming life.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 许多编程错误是程序中单行的简单字符错误。如果你发现自己花了很长时间寻找这些错误，知道你并不孤单。许多经验丰富且才华横溢的程序员也会花几个小时寻找这些微小的错误。尽量笑对它，继续前进，知道在你的编程生涯中，这种事情会经常发生。
- en: Variables Are Labels
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变量是标签
- en: Variables are often described as boxes you can store values in. This idea can
    be helpful the first few times you use a variable, but it isn’t an accurate way
    to describe how variables are represented internally in Python. It’s much better
    to think of variables as labels that you can assign to values. You can also say
    that a variable references a certain value.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 变量通常被描述为可以存储值的盒子。这个概念在你第一次使用变量时可能会有所帮助，但它并不准确地描述了变量在 Python 中是如何表示的。更好的方式是将变量视为你可以分配给值的标签。你也可以说，变量引用了某个特定的值。
- en: This distinction probably won’t matter much in your initial programs, but it’s
    worth learning earlier rather than later. At some point, you’ll see unexpected
    behavior from a variable, and an accurate understanding of how variables work
    will help you identify what’s happening in your code.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这种区分在你最初的程序中可能并不重要，但早点学习总比晚学要好。到某个时候，你可能会遇到变量的意外行为，而准确理解变量的工作原理将帮助你找出代码中的问题。
- en: Strings
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串
- en: Because most programs define and gather some sort of data and then do something
    useful with it, it helps to classify different types of data. The first data type
    we’ll look at is the string. Strings are quite simple at first glance, but you
    can use them in many different ways.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大多数程序会定义和收集某种数据，然后对其执行有用的操作，因此分类不同类型的数据很有帮助。我们将要查看的第一个数据类型是字符串。字符串乍看之下很简单，但你可以以多种方式使用它们。
- en: 'A *string* is a series of characters. Anything inside quotes is considered
    a string in Python, and you can use single or double quotes around your strings
    like this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '*字符串* 是一系列字符。Python 中任何引号内的内容都被视为字符串，你可以像这样使用单引号或双引号包围字符串：'
- en: '[PRE21]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This flexibility allows you to use quotes and apostrophes within your strings:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这种灵活性允许你在字符串中使用引号和撇号：
- en: '[PRE22]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Let’s explore some of the ways you can use strings.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索一下使用字符串的一些方法。
- en: Changing Case in a String with Methods
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用方法更改字符串的大小写
- en: 'One of the simplest tasks you can do with strings is change the case of the
    words in a string. Look at the following code, and try to determine what’s happening:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以对字符串执行的最简单操作之一是更改字符串中单词的大小写。看看下面的代码，尝试理解发生了什么：
- en: '**name.py**'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**name.py**'
- en: '[PRE23]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Save this file as *name.py* and then run it. You should see this output:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存为 *name.py* 然后运行，你应该会看到如下输出：
- en: '[PRE24]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this example, the variable `name` refers to the lowercase string `"ada lovelace"`.
    The method `title()` appears after the variable in the `print()` call. A *method*
    is an action that Python can perform on a piece of data. The dot (`.`) after `name`
    in `name.title()` tells Python to make the `title()` method act on the variable
    `name`. Every method is followed by a set of parentheses, because methods often
    need additional information to do their work. That information is provided inside
    the parentheses. The `title()` function doesn’t need any additional information,
    so its parentheses are empty.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，变量 `name` 引用了小写字符串 `"ada lovelace"`。方法 `title()` 出现在 `print()` 调用中的变量后面。*方法*
    是 Python 可以对一块数据执行的操作。`name` 后的点号（`.`）告诉 Python 执行 `title()` 方法对变量 `name` 进行操作。每个方法后面都有一对括号，因为方法通常需要额外的信息来完成工作。这些信息在括号内提供。`title()`
    方法不需要额外的信息，因此其括号是空的。
- en: The `title()` method changes each word to title case, where each word begins
    with a capital letter. This is useful because you’ll often want to think of a
    name as a piece of information. For example, you might want your program to recognize
    the input values `Ada`, `ADA`, and `ada` as the same name, and display all of
    them as `Ada`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`title()` 方法将每个单词的首字母改为大写，这对于将名字视作信息非常有用。比如，你可能希望你的程序能够识别输入值 `Ada`、`ADA` 和
    `ada` 为相同的名字，并将它们都显示为 `Ada`。'
- en: 'Several other useful methods are available for dealing with case as well. For
    example, you can change a string to all uppercase or all lowercase letters like
    this:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他有用的方法可以处理大小写。例如，你可以将字符串转换为全大写或全小写字母，像这样：
- en: '[PRE25]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This will display the following:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示以下内容：
- en: '[PRE26]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `lower()` method is particularly useful for storing data. You typically
    won’t want to trust the capitalization that your users provide, so you’ll convert
    strings to lowercase before storing them. Then when you want to display the information,
    you’ll use the case that makes the most sense for each string.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`lower()` 方法在存储数据时特别有用。你通常不希望完全信任用户提供的大小写，因此你会将字符串转换为小写再存储。然后当你想显示信息时，你会使用最适合每个字符串的大小写形式。'
- en: Using Variables in Strings
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在字符串中使用变量
- en: 'In some situations, you’ll want to use a variable’s value inside a string.
    For example, you might want to use two variables to represent a first name and
    a last name, respectively, and then combine those values to display someone’s
    full name:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你可能想在字符串中使用变量的值。例如，你可能希望分别使用两个变量来表示名字和姓氏，然后将这些值组合在一起显示某人的全名：
- en: '**full_name.py**'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '**full_name.py**'
- en: '[PRE27]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: To insert a variable’s value into a string, place the letter `f` immediately
    before the opening quotation mark ❶. Put braces around the name or names of any
    variable you want to use inside the string. Python will replace each variable
    with its value when the string is displayed.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 要将变量的值插入到字符串中，需在开头的引号前面立即加上字母`f` ❶。将大括号包围你想在字符串中使用的变量名称。Python会在显示字符串时，将每个变量替换为它的值。
- en: 'These strings are called *f-strings*. The *f* is for *format*, because Python
    formats the string by replacing the name of any variable in braces with its value.
    The output from the previous code is:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这些字符串被称为*f-strings*。*f*代表*format*，因为Python通过将大括号内的变量名替换为其值来格式化字符串。前面代码的输出是：
- en: '[PRE28]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You can do a lot with f-strings. For example, you can use f-strings to compose
    complete messages using the information associated with a variable, as shown here:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用f-strings做很多事情。例如，你可以使用f-strings通过与变量相关联的信息来组成完整的消息，如下所示：
- en: '[PRE29]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The full name is used in a sentence that greets the user ❶, and the `title()`
    method changes the name to title case. This code returns a simple but nicely formatted
    greeting:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 全名被用在一个句子中来问候用户 ❶，而`title()`方法将名称转换为标题格式。此代码返回一个简单而格式化良好的问候语：
- en: '[PRE30]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You can also use f-strings to compose a message, and then assign the entire
    message to a variable:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用f-strings来组合一条消息，然后将整个消息赋值给一个变量：
- en: '[PRE31]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This code displays the message `Hello, Ada Lovelace!` as well, but by assigning
    the message to a variable ❶ we make the final `print()` call much simpler ❷.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码同样显示消息`Hello, Ada Lovelace!`，但通过将消息赋值给变量 ❶，我们使得最后的`print()`调用变得更加简洁 ❷。
- en: Adding Whitespace to Strings with Tabs or Newlines
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用制表符或换行符向字符串添加空白
- en: In programming, *whitespace* refers to any nonprinting characters, such as spaces,
    tabs, and end-of-line symbols. You can use whitespace to organize your output
    so it’s easier for users to read.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，*空白字符*指的是任何非打印字符，如空格、制表符和行尾符号。你可以使用空白字符来组织输出，使其更易于用户阅读。
- en: 'To add a tab to your text, use the character combination `\t`:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 要在文本中添加制表符，使用字符组合`\t`：
- en: '[PRE32]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To add a newline in a string, use the character combination `\n`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 要在字符串中添加换行符，使用字符组合`\n`：
- en: '[PRE33]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'You can also combine tabs and newlines in a single string. The string `"\n\t"`
    tells Python to move to a new line, and start the next line with a tab. The following
    example shows how you can use a one-line string to generate four lines of output:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在一个字符串中结合制表符和换行符。字符串`"\n\t"`告诉Python跳到新的一行，并在新的一行开始时插入一个制表符。下面的示例展示了如何用单行字符串生成四行输出：
- en: '[PRE34]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Newlines and tabs will be very useful in the next two chapters, when you start
    to produce many lines of output from just a few lines of code.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 换行符和制表符将在接下来的两章中非常有用，当你开始用少量代码生成许多行输出时。
- en: Stripping Whitespace
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 去除空白字符
- en: Extra whitespace can be confusing in your programs. To programmers, `'python'`
    and `'python '` look pretty much the same. But to a program, they are two different
    strings. Python detects the extra space in `'python '` and considers it significant
    unless you tell it otherwise.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 额外的空白字符在你的程序中可能会让人困惑。对于程序员来说，`'python'`和`'python '`看起来几乎是一样的。但对于程序来说，它们是两个不同的字符串。Python会检测到`'python
    '`中的额外空格，并将其视为重要，除非你告诉它不这么做。
- en: It’s important to think about whitespace, because often you’ll want to compare
    two strings to determine whether they are the same. For example, one important
    instance might involve checking people’s usernames when they log in to a website.
    Extra whitespace can be confusing in much simpler situations as well. Fortunately,
    Python makes it easy to eliminate extra whitespace from data that people enter.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 思考空白字符非常重要，因为你通常需要比较两个字符串来判断它们是否相同。例如，一个重要的情况可能是检查人们登录网站时的用户名。额外的空白字符在很多简单情况下也会让人困惑。幸运的是，Python让你可以轻松地去除用户输入数据中的额外空白。
- en: 'Python can look for extra whitespace on the right and left sides of a string.
    To ensure that no whitespace exists at the right side of a string, use the `rstrip()`
    method:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Python可以查找字符串左右两侧的额外空白字符。为了确保字符串右侧没有空白字符，可以使用`rstrip()`方法：
- en: '[PRE35]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The value associated with `favorite_language` ❶ contains extra whitespace at
    the end of the string. When you ask Python for this value in a terminal session,
    you can see the space at the end of the value ❷. When the `rstrip()` method acts
    on the variable `favorite_language` ❸, this extra space is removed. However, it
    is only removed temporarily. If you ask for the value of `favorite_language` again,
    the string looks the same as when it was entered, including the extra whitespace
    ❹.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `favorite_language` 变量 ❶ 关联的值包含了字符串末尾的额外空白字符。当你在终端会话中请求这个值时，你可以看到末尾有一个空格 ❷。当
    `rstrip()` 方法作用于变量 `favorite_language` ❸ 时，这个额外的空格会被移除。然而，这只是暂时移除。如果你再次请求 `favorite_language`
    的值，字符串会和输入时一样，包括多余的空白字符 ❹。
- en: 'To remove the whitespace from the string permanently, you have to associate
    the stripped value with the variable name:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 要永久移除字符串中的空白字符，你需要将去除空白后的值与变量名关联：
- en: '[PRE36]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: To remove the whitespace from the string, you strip the whitespace from the
    right side of the string and then associate this new value with the original variable
    ❶. Changing a variable’s value is done often in programming. This is how a variable’s
    value can be updated as a program is executed or in response to user input.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 要去除字符串中的空白字符，你可以先去除右侧的空白字符，然后将这个新值与原始变量关联 ❶。在编程中，经常会修改变量的值。这就是如何在程序执行过程中或者响应用户输入时更新变量的值。
- en: 'You can also strip whitespace from the left side of a string using the `lstrip()`
    method, or from both sides at once using `strip()`:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 `lstrip()` 方法去除字符串左侧的空白字符，或者使用 `strip()` 一次性去除两侧的空白字符：
- en: '[PRE37]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In this example, we start with a value that has whitespace at the beginning
    and the end ❶. We then remove the extra space from the right side ❷, from the
    left side ❸, and from both sides ❹. Experimenting with these stripping functions
    can help you become familiar with manipulating strings. In the real world, these
    stripping functions are used most often to clean up user input before it’s stored
    in a program.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们从一个字符串开始，该字符串的开头和结尾有空白字符 ❶。接着，我们移除右侧的额外空白字符 ❷、左侧的空白字符 ❸，以及两侧的空白字符 ❹。通过尝试这些去除空白字符的函数，你可以熟悉如何处理字符串。在现实中，这些去除空白的函数通常用于清理用户输入的数据，确保它们在程序中存储之前是干净的。
- en: Removing Prefixes
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 去除前缀
- en: 'When working with strings, another common task is to remove a prefix. Consider
    a URL with the common prefix *https://*. We want to remove this prefix, so we
    can focus on just the part of the URL that users need to enter into an address
    bar. Here’s how to do that:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理字符串时，另一个常见的任务是去除前缀。以带有常见前缀 *https://* 的 URL 为例。我们希望去除这个前缀，这样就可以专注于用户需要在地址栏中输入的
    URL 部分。以下是如何做到这一点：
- en: '[PRE38]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Enter the name of the variable followed by a dot, and then the method `removeprefix()`.
    Inside the parentheses, enter the prefix you want to remove from the original
    string.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 输入变量名，后跟一个点，然后是方法 `removeprefix()`。在括号内，输入你想从原始字符串中移除的前缀。
- en: 'Like the methods for removing whitespace, `removeprefix()` leaves the original
    string unchanged. If you want to keep the new value with the prefix removed, either
    reassign it to the original variable or assign it to a new variable:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 与去除空白字符的方法类似，`removeprefix()` 不会改变原始字符串。如果你希望保留去掉前缀后的新值，可以将其重新赋值给原变量，或者赋值给一个新变量：
- en: '[PRE39]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: When you see a URL in an address bar and the *https://* part isn’t shown, the
    browser is probably using a method like `removeprefix()` behind the scenes.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在地址栏中看到一个 URL，且 *https://* 部分没有显示时，浏览器可能在后台使用了类似 `removeprefix()` 的方法。
- en: Avoiding Syntax Errors with Strings
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 避免字符串中的语法错误
- en: One kind of error that you might see with some regularity is a syntax error.
    A *syntax error* occurs when Python doesn’t recognize a section of your program
    as valid Python code. For example, if you use an apostrophe within single quotes,
    you’ll produce an error. This happens because Python interprets everything between
    the first single quote and the apostrophe as a string. It then tries to interpret
    the rest of the text as Python code, which causes errors.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会经常看到的一种错误是语法错误。*语法错误* 发生在 Python 无法将程序的某一部分识别为有效的 Python 代码时。例如，如果你在单引号中使用了撇号，程序就会报错。这是因为
    Python 会把第一个单引号和撇号之间的内容当作字符串处理，然后试图将剩余的文本解释为 Python 代码，导致错误。
- en: 'Here’s how to use single and double quotes correctly. Save this program as
    *apostrophe.py* and then run it:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何正确使用单引号和双引号。将这个程序保存为 *apostrophe.py* 然后运行它：
- en: '**apostrophe.py**'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '**apostrophe.py**'
- en: '[PRE40]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The apostrophe appears inside a set of double quotes, so the Python interpreter
    has no trouble reading the string correctly:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 单引号出现在一对双引号内部，所以 Python 解释器能够正确地读取字符串：
- en: '[PRE41]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'However, if you use single quotes, Python can’t identify where the string should
    end:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你使用单引号，Python 就无法识别字符串应该在哪里结束：
- en: '[PRE42]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'You’ll see the following output:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到以下输出：
- en: '[PRE43]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In the output you can see that the error occurs right after the final single
    quote ❶. This syntax error indicates that the interpreter doesn’t recognize something
    in the code as valid Python code, and it thinks the problem might be a string
    that’s not quoted correctly. Errors can come from a variety of sources, and I’ll
    point out some common ones as they arise. You might see syntax errors often as
    you learn to write proper Python code. Syntax errors are also the least specific
    kind of error, so they can be difficult and frustrating to identify and correct.
    If you get stuck on a particularly stubborn error, see the suggestions in Appendix
    C.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出中，你可以看到错误发生在最后一个单引号之后 ❶。这个语法错误表示解释器无法将代码中的某些内容识别为有效的 Python 代码，并且它认为问题可能出在未正确引用的字符串。错误的来源有很多种，我会在出现时指出一些常见的错误。当你学习编写正确的
    Python 代码时，可能会经常遇到语法错误。语法错误也是最不具体的一种错误，因此它们可能很难识别和修正。如果你在解决特别棘手的错误时卡住了，可以参考附录
    C 中的建议。
- en: Numbers
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数字
- en: Numbers are used quite often in programming to keep score in games, represent
    data in visualizations, store information in web applications, and so on. Python
    treats numbers in several different ways, depending on how they’re being used.
    Let’s first look at how Python manages integers, because they’re the simplest
    to work with.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，数字经常用于游戏中的得分、数据可视化、存储 Web 应用中的信息等。Python 根据数字的使用方式以几种不同的方式处理数字。我们首先来看 Python
    如何处理整数，因为它们是最简单的。
- en: Integers
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 整数
- en: You can add (`+`), subtract (`-`), multiply (`*`), and divide (`/`) integers
    in Python.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Python 中对整数进行加法（`+`）、减法（`-`）、乘法（`*`）和除法（`/`）。
- en: '[PRE44]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In a terminal session, Python simply returns the result of the operation. Python
    uses two multiplication symbols to represent exponents:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端会话中，Python 会直接返回运算结果。Python 使用两个乘号来表示指数：
- en: '[PRE45]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Python supports the order of operations too, so you can use multiple operations
    in one expression. You can also use parentheses to modify the order of operations
    so Python can evaluate your expression in the order you specify. For example:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: Python 也支持运算顺序，因此你可以在一个表达式中使用多个运算符。你还可以使用括号来修改运算顺序，这样 Python 就能按照你指定的顺序计算表达式。例如：
- en: '[PRE46]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The spacing in these examples has no effect on how Python evaluates the expressions;
    it simply helps you more quickly spot the operations that have priority when you’re
    reading through the code.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例中的空格对 Python 计算表达式没有影响；它们只是帮助你在阅读代码时更快速地识别优先级较高的运算。
- en: Floats
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 浮点数
- en: Python calls any number with a decimal point a *float*. This term is used in
    most programming languages, and it refers to the fact that a decimal point can
    appear at any position in a number. Every programming language must be carefully
    designed to properly manage decimal numbers so numbers behave appropriately, no
    matter where the decimal point appears.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: Python 将任何带有小数点的数字称为 *浮点数*。这个术语在大多数编程语言中都使用，它指的是小数点可以出现在数字的任何位置。每种编程语言都必须精心设计，以正确地处理小数数字，使得数字无论小数点出现在什么位置都能正确表现。
- en: 'For the most part, you can use floats without worrying about how they behave.
    Simply enter the numbers you want to use, and Python will most likely do what
    you expect:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分情况下，你可以使用浮点数而不需要担心它们的表现。只需输入你想要使用的数字，Python 很可能会按你预期的方式进行计算：
- en: '[PRE47]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'However, be aware that you can sometimes get an arbitrary number of decimal
    places in your answer:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，有时你会得到一个任意的小数位数作为答案：
- en: '[PRE48]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This happens in all languages and is of little concern. Python tries to find
    a way to represent the result as precisely as possible, which is sometimes difficult
    given how computers have to represent numbers internally. Just ignore the extra
    decimal places for now; you’ll learn ways to deal with the extra places when you
    need to in the projects in Part II.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况在所有语言中都会发生，通常不需要担心。Python 尝试以尽可能精确的方式表示结果，这有时很困难，因为计算机需要内部表示数字。现在先忽略额外的小数位；当你在第二部分的项目中需要处理这些额外的位数时，你将学习如何应对。
- en: Integers and Floats
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 整数和浮点数
- en: 'When you divide any two numbers, even if they are integers that result in a
    whole number, you’ll always get a float:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将两个数字相除时，即使它们是整数并且结果是一个整数，你仍然会得到一个浮点数：
- en: '[PRE49]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'If you mix an integer and a float in any other operation, you’ll get a float
    as well:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在其他操作中混合使用整数和浮点数，你也会得到一个浮点数：
- en: '[PRE50]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Python defaults to a float in any operation that uses a float, even if the output
    is a whole number.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: Python 在任何涉及浮点数的操作中默认会使用浮点数，即使输出结果是一个整数。
- en: Underscores in Numbers
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数字中的下划线
- en: 'When you’re writing long numbers, you can group digits using underscores to
    make large numbers more readable:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写长数字时，可以使用下划线将数字分组，使大数字更易读：
- en: '[PRE51]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'When you print a number that was defined using underscores, Python prints only
    the digits:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打印一个使用下划线定义的数字时，Python 只会打印出数字本身：
- en: '[PRE52]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Python ignores the underscores when storing these kinds of values. Even if you
    don’t group the digits in threes, the value will still be unaffected. To Python,
    `1000` is the same as `1_000`, which is the same as `10_00`. This feature works
    for both integers and floats.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: Python 在存储这些类型的值时会忽略下划线。即使你没有将数字分为三位一组，值也不会受到影响。对 Python 来说，`1000` 和 `1_000`，以及
    `10_00` 都是一样的。这一特性适用于整数和浮点数。
- en: Multiple Assignment
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多重赋值
- en: You can assign values to more than one variable using just a single line of
    code. This can help shorten your programs and make them easier to read; you’ll
    use this technique most often when initializing a set of numbers.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用一行代码为多个变量赋值。这有助于缩短你的程序并使其更易读；你通常在初始化一组数字时使用这种技巧。
- en: 'For example, here’s how you can initialize the variables `x`, `y`, and `z`
    to zero:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，下面是如何将变量 `x`、`y` 和 `z` 初始化为零：
- en: '[PRE53]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: You need to separate the variable names with commas, and do the same with the
    values, and Python will assign each value to its respective variable. As long
    as the number of values matches the number of variables, Python will match them
    up correctly.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要使用逗号分隔变量名，并且对值也要做同样的处理，Python 会将每个值分配给相应的变量。只要值的数量与变量的数量相匹配，Python 会正确地进行匹配。
- en: Constants
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 常量
- en: 'A *constant* is a variable whose value stays the same throughout the life of
    a program. Python doesn’t have built-in constant types, but Python programmers
    use all capital letters to indicate a variable should be treated as a constant
    and never be changed:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '*常量* 是一个在程序生命周期内其值保持不变的变量。Python 没有内建的常量类型，但 Python 程序员通过使用全大写字母来表示一个变量应视为常量且永远不应改变：'
- en: '[PRE54]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: When you want to treat a variable as a constant in your code, write the name
    of the variable in all capital letters.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想在代码中将一个变量视为常量时，可以将该变量的名称写成全大写字母。
- en: Comments
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注释
- en: Comments are an extremely useful feature in most programming languages. Everything
    you’ve written in your programs so far is Python code. As your programs become
    longer and more complicated, you should add notes within your programs that describe
    your overall approach to the problem you’re solving. A *comment* allows you to
    write notes in your spoken language, within your programs.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 注释是大多数编程语言中非常有用的功能。到目前为止，你在程序中编写的所有内容都是 Python 代码。随着程序变得越来越长且复杂，你应该在程序中添加注释，描述你解决问题的整体思路。*注释*
    允许你在程序中以口语化的语言编写说明。
- en: How Do You Write Comments?
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何编写注释？
- en: 'In Python, the hash mark (`#`) indicates a comment. Anything following a hash
    mark in your code is ignored by the Python interpreter. For example:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，井号（`#`）表示注释。井号后面的所有内容都将被 Python 解释器忽略。例如：
- en: '**comment.py**'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '**comment.py**'
- en: '[PRE55]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Python ignores the first line and executes the second line.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: Python 会忽略第一行并执行第二行。
- en: '[PRE56]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: What Kinds of Comments Should You Write?
  id: totrans-295
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你应该写什么样的注释？
- en: The main reason to write comments is to explain what your code is supposed to
    do and how you are making it work. When you’re in the middle of working on a project,
    you understand how all of the pieces fit together. But when you return to a project
    after some time away, you’ll likely have forgotten some of the details. You can
    always study your code for a while and figure out how segments were supposed to
    work, but writing good comments can save you time by summarizing your overall
    approach clearly.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 编写注释的主要原因是解释你的代码应该做什么，以及你如何使其工作。当你正在进行项目时，你会明白所有部分是如何配合工作的。但当你在一段时间后回到项目时，你很可能会忘记一些细节。你可以总是花时间去研究代码，弄明白各个部分应该如何工作，但编写好的注释可以通过清晰地总结你的整体思路，节省你时间。
- en: If you want to become a professional programmer or collaborate with other programmers,
    you should write meaningful comments. Today, most software is written collaboratively,
    whether by a group of employees at one company or a group of people working together
    on an open source project. Skilled programmers expect to see comments in code,
    so it’s best to start adding descriptive comments to your programs now. Writing
    clear, concise comments in your code is one of the most beneficial habits you
    can form as a new programmer.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想成为一名专业程序员或与其他程序员合作，你应该编写有意义的评论。如今，大多数软件都是以协作的方式编写的，无论是由一家公司的员工团队，还是由一群人在一个开源项目中合作。技术熟练的程序员期望在代码中看到评论，因此最好从现在开始为你的程序添加描述性的评论。编写清晰、简洁的评论是你作为新程序员可以培养的最有益的习惯之一。
- en: When you’re deciding whether to write a comment, ask yourself if you had to
    consider several approaches before coming up with a reasonable way to make something
    work; if so, write a comment about your solution. It’s much easier to delete extra
    comments later than to go back and write comments for a sparsely commented program.
    From now on, I’ll use comments in examples throughout this book to help explain
    sections of code.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 当你决定是否写评论时，问问自己是否在考虑了几种方法之后，才想出了一个合理的解决方案；如果是这样，那就写一个关于你解决方案的评论。比起回头为一段评论稀少的程序写评论，稍后删除多余的评论要容易得多。从现在开始，我将在本书的示例中使用评论，帮助解释代码部分。
- en: The Zen of Python
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python 之禅
- en: Experienced Python programmers will encourage you to avoid complexity and aim
    for simplicity whenever possible. The Python community’s philosophy is contained
    in “The Zen of Python” by Tim Peters. You can access this brief set of principles
    for writing good Python code by entering `import this` into your interpreter.
    I won’t reproduce the entire “Zen of Python” here, but I’ll share a few lines
    to help you understand why they should be important to you as a beginning Python
    programmer.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 经验丰富的 Python 程序员会鼓励你避免复杂性，尽可能追求简单。Python 社区的哲学体现在 Tim Peters 的《Python 之禅》中。你可以通过在解释器中输入
    `import this` 来查看这组简短的编写优秀 Python 代码的原则。我不会在这里完整地重现《Python 之禅》，但我会分享其中几行，帮助你理解它们为什么对你作为一个初学者非常重要。
- en: '[PRE57]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Python programmers embrace the notion that code can be beautiful and elegant.
    In programming, people solve problems. Programmers have always respected well-designed,
    efficient, and even beautiful solutions to problems. As you learn more about Python
    and use it to write more code, someone might look over your shoulder one day and
    say, “Wow, that’s some beautiful code!”
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: Python 程序员认同代码可以是美丽且优雅的这个概念。在编程中，人们是用来解决问题的。程序员一直尊重那些设计良好、高效甚至美丽的解决方案。当你对 Python
    了解得更多，并用它写更多代码时，有一天可能会有人站在你肩膀上，说：“哇，那是一些美丽的代码！”
- en: '[PRE58]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: If you have a choice between a simple and a complex solution, and both work,
    use the simple solution. Your code will be easier to maintain, and it will be
    easier for you and others to build on that code later on.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在简单和复杂的解决方案之间有选择，而且两者都有效，那就选择简单的解决方案。你的代码将更容易维护，并且以后你和其他人也能更轻松地在这段代码上进行扩展。
- en: '[PRE59]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Real life is messy, and sometimes a simple solution to a problem is unattainable.
    In that case, use the simplest solution that works.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 现实生活是混乱的，有时候简单的解决方案是无法实现的。在这种情况下，使用最简单的有效解决方案。
- en: '[PRE60]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Even when your code is complex, aim to make it readable. When you’re working
    on a project that involves complex coding, focus on writing informative comments
    for that code.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你的代码很复杂，也要尽量使它易于阅读。当你在一个涉及复杂编码的项目中工作时，专注于为这些代码编写具有信息量的评论。
- en: '[PRE61]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: If two Python programmers are asked to solve the same problem, they should come
    up with fairly compatible solutions. This is not to say there’s no room for creativity
    in programming. On the contrary, there is plenty of room for creativity! However,
    much of programming consists of using small, common approaches to simple situations
    within a larger, more creative project. The nuts and bolts of your programs should
    make sense to other Python programmers.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个 Python 程序员被要求解决同一个问题，他们应该会提出相当兼容的解决方案。这并不是说编程中没有创造性的空间。相反，编程中有很多创造性空间！然而，编程的许多部分是利用小而常见的方法来解决较大、更具创意项目中的简单问题。你程序中的基础部分应该能让其他
    Python 程序员理解。
- en: '[PRE62]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: You could spend the rest of your life learning all the intricacies of Python
    and of programming in general, but then you’d never complete any projects. Don’t
    try to write perfect code; write code that works, and then decide whether to improve
    your code for that project or move on to something new.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以花费余生学习 Python 和编程的所有细节，但那样你将永远无法完成任何项目。不要试图编写完美的代码；编写能工作的代码，然后决定是改进该项目的代码，还是继续做新的项目。
- en: As you continue to the next chapter and start digging into more involved topics,
    try to keep this philosophy of simplicity and clarity in mind. Experienced programmers
    will respect your code more and will be happy to give you feedback and collaborate
    with you on interesting projects.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 当你继续进入下一章并开始深入探讨更复杂的话题时，试着保持这个简单明了的哲学理念。经验丰富的程序员会更尊重你的代码，并乐意为你提供反馈，并与你一起合作进行有趣的项目。
- en: Summary
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter you learned how to work with variables. You learned to use descriptive
    variable names and resolve name errors and syntax errors when they arise. You
    learned what strings are and how to display them using lowercase, uppercase, and
    title case. You started using whitespace to organize output neatly, and you learned
    how to remove unneeded elements from a string. You started working with integers
    and floats, and you learned some of the ways you can work with numerical data.
    You also learned to write explanatory comments to make your code easier for you
    and others to read. Finally, you read about the philosophy of keeping your code
    as simple as possible, whenever possible.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何使用变量。你学会了使用描述性变量名，并在出现名称错误和语法错误时进行解决。你了解了什么是字符串，并学习了如何使用小写字母、大写字母和标题大小写显示字符串。你开始使用空格来整理输出，使其整洁，并学习了如何从字符串中删除不需要的元素。你开始使用整数和浮动小数，学习了处理数字数据的一些方法。你还学会了编写解释性注释，使你的代码更容易被你和他人阅读。最后，你阅读了保持代码尽可能简单的哲学理念，无论何时可能。
- en: In Chapter 3, you’ll learn how to store collections of information in data structures
    called *lists*. You’ll also learn how to work through a list, manipulating any
    information in that list.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3章中，你将学习如何在数据结构中存储信息集合，这些数据结构被称为*列表*。你还将学习如何遍历列表，操作列表中的任何信息。
- en: '3'
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Introducing Lists
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 介绍列表
- en: '![](Images/chapterart.png)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: In this chapter and the next you’ll learn what lists are and how to start working
    with the elements in a list. Lists allow you to store sets of information in one
    place, whether you have just a few items or millions of items. Lists are one of
    Python’s most powerful features readily accessible to new programmers, and they
    tie together many important concepts in programming.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章及下一章中，你将学习什么是列表，以及如何开始处理列表中的元素。列表允许你将一组信息存储在一个地方，无论你有几个项目还是数百万个项目。列表是 Python
    中最强大的功能之一，易于新程序员使用，并且它连接了编程中的许多重要概念。
- en: What Is a List?
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是列表？
- en: A *list* is a collection of items in a particular order. You can make a list
    that includes the letters of the alphabet, the digits from 0 to 9, or the names
    of all the people in your family. You can put anything you want into a list, and
    the items in your list don’t have to be related in any particular way. Because
    a list usually contains more than one element, it’s a good idea to make the name
    of your list plural, such as `letters`, `digits`, or `names`.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表*是按特定顺序排列的项目集合。你可以创建一个包含字母表的字母、从 0 到 9 的数字，或你家里所有人的名字的列表。你可以将任何想要的东西放入列表中，且列表中的项目不需要以任何特定方式相关。因为列表通常包含多个元素，所以最好将列表的名称设置为复数形式，比如
    `letters`、`digits` 或 `names`。'
- en: 'In Python, square brackets (`[]`) indicate a list, and individual elements
    in the list are separated by commas. Here’s a simple example of a list that contains
    a few kinds of bicycles:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，方括号（`[]`）表示一个列表，列表中的单个元素用逗号分隔。以下是一个简单的包含几种自行车的列表示例：
- en: '**bicycles.py**'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '**bicycles.py**'
- en: '[PRE63]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'If you ask Python to print a list, Python returns its representation of the
    list, including the square brackets:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你要求 Python 打印一个列表，Python 会返回它对该列表的表示，包括方括号：
- en: '[PRE64]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Because this isn’t the output you want your users to see, let’s learn how to
    access the individual items in a list.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这不是你希望用户看到的输出，让我们学习如何访问列表中的单个项目。
- en: Accessing Elements in a List
  id: totrans-329
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问列表中的元素
- en: Lists are ordered collections, so you can access any element in a list by telling
    Python the position, or *index*, of the item desired. To access an element in
    a list, write the name of the list followed by the index of the item enclosed
    in square brackets.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 列表是有序的集合，因此你可以通过告诉Python项的*位置*或*索引*来访问列表中的任何元素。要访问列表中的元素，写出列表名称，然后用方括号括起该项的索引。
- en: 'For example, let’s pull out the first bicycle in the list `bicycles`:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们从列表`bicycles`中提取第一辆自行车：
- en: '[PRE65]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'When we ask for a single item from a list, Python returns just that element
    without square brackets:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从列表中请求单个元素时，Python只返回该元素，而不带方括号：
- en: '[PRE66]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'This is the result you want your users to see: clean, neatly formatted output.'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你希望用户看到的结果：干净、整齐格式化的输出。
- en: 'You can also use the string methods from Chapter 2 on any element in this list.
    For example, you can format the element `''trek''` to look more presentable by
    using the `title()` method:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以对列表中的任何元素使用第二章中的字符串方法。例如，你可以使用`title()`方法将元素`'trek'`格式化为更整洁的外观：
- en: '[PRE67]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This example produces the same output as the preceding example, except `'Trek'`
    is capitalized.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子产生的输出与前一个例子相同，不同之处在于`'Trek'`被大写了。
- en: Index Positions Start at 0, Not 1
  id: totrans-339
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 索引位置从0开始，而不是从1开始
- en: Python considers the first item in a list to be at position 0, not position
    1\. This is true of most programming languages, and the reason has to do with
    how the list operations are implemented at a lower level. If you’re receiving
    unexpected results, ask yourself if you’re making a simple but common off-by-one
    error.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: Python认为列表中的第一个项目位于位置0，而不是位置1。这在大多数编程语言中都是如此，原因与列表操作在较低层次上如何实现有关。如果你遇到意外结果，问问自己是否犯了一个简单但常见的错位错误。
- en: The second item in a list has an index of 1\. Using this counting system, you
    can get any element you want from a list by subtracting one from its position
    in the list. For instance, to access the fourth item in a list, you request the
    item at index 3.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的第二项的索引是1。使用这种计数系统，你可以通过从元素在列表中的位置减去1来获取任何你想要的元素。例如，要访问列表中的第四项，你请求索引为3的元素。
- en: 'The following asks for the bicycles at index `1` and index `3`:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 以下请求的是索引`1`和索引`3`处的自行车：
- en: '[PRE68]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'This code returns the second and fourth bicycles in the list:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码返回列表中的第二和第四辆自行车：
- en: '[PRE69]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Python has a special syntax for accessing the last element in a list. If you
    ask for the item at index `-1`, Python always returns the last item in the list:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: Python有一种特殊的语法来访问列表中的最后一个元素。如果你请求索引`-1`的项，Python总是返回列表中的最后一个元素：
- en: '[PRE70]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This code returns the value `'specialized'`. This syntax is quite useful, because
    you’ll often want to access the last items in a list without knowing exactly how
    long the list is. This convention extends to other negative index values as well.
    The index `-2` returns the second item from the end of the list, the index `-3`
    returns the third item from the end, and so forth.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码返回值`'specialized'`。这种语法非常有用，因为你经常希望在不知道列表长度的情况下访问列表中的最后一个元素。这个约定也适用于其他负索引值。索引`-2`返回列表倒数第二项，索引`-3`返回倒数第三项，依此类推。
- en: Using Individual Values from a List
  id: totrans-349
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从列表中使用单个值
- en: You can use individual values from a list just as you would any other variable.
    For example, you can use f-strings to create a message based on a value from a
    list.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像使用任何其他变量一样使用列表中的单个值。例如，你可以使用f-string根据列表中的一个值创建消息。
- en: 'Let’s try pulling the first bicycle from the list and composing a message using
    that value:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试着从列表中提取第一辆自行车，并使用该值组成一条消息：
- en: '[PRE71]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'We build a sentence using the value at `bicycles[0]` and assign it to the variable
    `message`. The output is a simple sentence about the first bicycle in the list:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`bicycles[0]`中的值构建一句话，并将其赋值给变量`message`。输出是关于列表中第一辆自行车的简单句子：
- en: '[PRE72]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Modifying, Adding, and Removing Elements
  id: totrans-355
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改、添加和删除元素
- en: Most lists you create will be *dynamic*, meaning you’ll build a list and then
    add and remove elements from it as your program runs its course. For example,
    you might create a game in which a player has to shoot aliens out of the sky.
    You could store the initial set of aliens in a list and then remove an alien from
    the list each time one is shot down. Each time a new alien appears on the screen,
    you add it to the list. Your list of aliens will increase and decrease in length
    throughout the course of the game.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 你创建的大多数列表都是*动态的*，这意味着你将构建一个列表，并在程序运行过程中添加和删除元素。例如，你可能会创建一个游戏，玩家需要把外星人从天上击落。你可以将初始的外星人集合存储在一个列表中，每次击落一个外星人时，就从列表中移除它。每当一个新的外星人出现在屏幕上时，你就将它添加到列表中。你的外星人列表将在游戏过程中不断增加和减少长度。
- en: Modifying Elements in a List
  id: totrans-357
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改列表中的元素
- en: The syntax for modifying an element is similar to the syntax for accessing an
    element in a list. To change an element, use the name of the list followed by
    the index of the element you want to change, and then provide the new value you
    want that item to have.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 修改元素的语法与访问列表中元素的语法相似。要更改某个元素，使用列表的名称，后跟你想更改的元素的索引，然后提供你希望该项具有的新值。
- en: 'For example, say we have a list of motorcycles and the first item in the list
    is `''honda''`. We can change the value of this first item after the list has
    been created:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一个摩托车列表，列表中的第一项是`'honda'`。在列表创建后，我们可以更改第一项的值：
- en: '**motorcycles.py**'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '**motorcycles.py**'
- en: '[PRE73]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Here we define the list `motorcycles`, with `''honda''` as the first element.
    Then we change the value of the first item to `''ducati''`. The output shows that
    the first item has been changed, while the rest of the list stays the same:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们定义了列表`motorcycles`，并将`'honda'`作为第一项。然后我们将第一项的值更改为`'ducati'`。输出显示，第一项已被更改，而其余的列表保持不变：
- en: '[PRE74]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: You can change the value of any item in a list, not just the first item.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以更改列表中任何项的值，而不仅仅是第一项。
- en: Adding Elements to a List
  id: totrans-365
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向列表添加元素
- en: You might want to add a new element to a list for many reasons. For example,
    you might want to make new aliens appear in a game, add new data to a visualization,
    or add new registered users to a website you’ve built. Python provides several
    ways to add new data to existing lists.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会出于许多原因向列表添加新元素。例如，你可能想要在游戏中让新的外星人出现，向可视化中添加新数据，或者向你构建的网站中添加新的注册用户。Python
    提供了几种向现有列表添加新数据的方法。
- en: Appending Elements to the End of a List
  id: totrans-367
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将元素附加到列表的末尾
- en: 'The simplest way to add a new element to a list is to *append* the item to
    the list. When you append an item to a list, the new element is added to the end
    of the list. Using the same list we had in the previous example, we’ll add the
    new element `''ducati''` to the end of the list:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 向列表添加新元素的最简单方法是将该项*附加*到列表中。当你将一个元素附加到列表时，新的元素会被添加到列表的末尾。使用我们在前面示例中的同一个列表，我们将新元素`'ducati'`添加到列表的末尾：
- en: '[PRE75]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Here the `append()` method adds `''ducati''` to the end of the list, without
    affecting any of the other elements in the list:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`append()`方法将`'ducati'`添加到列表的末尾，而不会影响列表中的其他元素：
- en: '[PRE76]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The `append()` method makes it easy to build lists dynamically. For example,
    you can start with an empty list and then add items to the list using a series
    of `append()` calls. Using an empty list, let’s add the elements `''honda''`,
    `''yamaha''`, and `''suzuki''` to the list:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '`append()`方法使动态构建列表变得非常简单。例如，你可以从一个空列表开始，然后使用一系列`append()`调用将项添加到列表中。使用一个空列表，我们将元素`''honda''`、`''yamaha''`和`''suzuki''`添加到列表中：'
- en: '[PRE77]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The resulting list looks exactly the same as the lists in the previous examples:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 结果列表与前面的示例中的列表完全相同：
- en: '[PRE78]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Building lists this way is very common, because you often won’t know the data
    your users want to store in a program until after the program is running. To put
    your users in control, start by defining an empty list that will hold the users’
    values. Then append each new value provided to the list you just created.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式构建列表非常常见，因为通常在程序运行之前你无法知道用户想要存储的数据。为了让用户掌控，首先定义一个空列表来保存用户的值。然后将每个新提供的值附加到你刚创建的列表中。
- en: Inserting Elements into a List
  id: totrans-377
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 向列表中插入元素
- en: 'You can add a new element at any position in your list by using the `insert()`
    method. You do this by specifying the index of the new element and the value of
    the new item:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用`insert()`方法将新元素添加到列表中的任何位置。你通过指定新元素的索引和值来实现这一点：
- en: '[PRE79]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'In this example, we insert the value `''ducati''` at the beginning of the list.
    The `insert()` method opens a space at position `0` and stores the value `''ducati''`
    at that location:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将值`'ducati'`插入到列表的开头。`insert()`方法在位置`0`处开辟一个空间，并将值`'ducati'`存储在该位置：
- en: '[PRE80]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: This operation shifts every other value in the list one position to the right.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作会将列表中的其他每个值向右移动一个位置。
- en: Removing Elements from a List
  id: totrans-383
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从列表中移除元素
- en: Often, you’ll want to remove an item or a set of items from a list. For example,
    when a player shoots down an alien from the sky, you’ll most likely want to remove
    it from the list of active aliens. Or when a user decides to cancel their account
    on a web application you created, you’ll want to remove that user from the list
    of active users. You can remove an item according to its position in the list
    or according to its value.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你可能希望从列表中移除一个元素或一组元素。例如，当玩家击落一个外星人时，你通常会希望将其从活动外星人列表中移除。或者，当用户决定取消他们在你创建的Web应用程序中的账户时，你会希望将该用户从活动用户列表中移除。你可以根据元素在列表中的位置或其值来移除元素。
- en: Removing an Item Using the del Statement
  id: totrans-385
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用del语句移除元素
- en: 'If you know the position of the item you want to remove from a list, you can
    use the `del` statement:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道想从列表中移除的元素的位置，可以使用`del`语句：
- en: '[PRE81]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Here we use the `del` statement to remove the first item, `''honda''`, from
    the list of motorcycles:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`del`语句从摩托车列表中移除第一个项目`'honda'`：
- en: '[PRE82]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'You can remove an item from any position in a list using the `del` statement
    if you know its index. For example, here’s how to remove the second item, `''yamaha''`,
    from the list:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道元素的索引，可以使用`del`语句从列表中的任何位置移除元素。例如，下面是如何从列表中移除第二个元素`'yamaha'`：
- en: '[PRE83]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The second motorcycle is deleted from the list:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 第二辆摩托车已从列表中删除：
- en: '[PRE84]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: In both examples, you can no longer access the value that was removed from the
    list after the `del` statement is used.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个例子中，使用`del`语句后，你将无法再访问被移除的列表元素。
- en: Removing an Item Using the pop() Method
  id: totrans-395
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用pop()方法移除元素
- en: Sometimes you’ll want to use the value of an item after you remove it from a
    list. For example, you might want to get the *x* and *y* position of an alien
    that was just shot down, so you can draw an explosion at that position. In a web
    application, you might want to remove a user from a list of active members and
    then add that user to a list of inactive members.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你可能希望在从列表中移除元素后使用该元素的值。例如，你可能想获取刚被击落的外星人的*x*和*y*位置，然后在该位置绘制爆炸效果。在一个Web应用程序中，你可能希望将一个用户从活动成员列表中移除，然后将该用户添加到非活动成员列表中。
- en: The `pop()` method removes the last item in a list, but it lets you work with
    that item after removing it. The term *pop* comes from thinking of a list as a
    stack of items and popping one item off the top of the stack. In this analogy,
    the top of a stack corresponds to the end of a list.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '`pop()`方法移除列表中的最后一个元素，但它允许你在移除后继续使用该元素。术语*pop*来源于将列表看作一个堆叠的元素，从堆叠顶部弹出一个元素。在这个类比中，堆叠的顶部对应于列表的末尾。'
- en: 'Let’s pop a motorcycle from the list of motorcycles:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从摩托车列表中弹出一辆摩托车：
- en: '[PRE85]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: We start by defining and printing the list `motorcycles` ❶. Then we pop a value
    from the list, and assign that value to the variable `popped_motorcycle` ❷. We
    print the list ❸ to show that a value has been removed from the list. Then we
    print the popped value ❹ to prove that we still have access to the value that
    was removed.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义并打印列表`motorcycles` ❶。然后我们从列表中弹出一个值，并将该值赋给变量`popped_motorcycle` ❷。我们打印列表
    ❸ 来展示某个值已从列表中移除。接着我们打印弹出的值 ❹ 来证明我们仍然可以访问被移除的值。
- en: 'The output shows that the value `''suzuki''` was removed from the end of the
    list and is now assigned to the variable `popped_motorcycle`:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示值`'suzuki'`已从列表末尾移除，并且现在被赋值给变量`popped_motorcycle`：
- en: '[PRE86]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'How might this `pop()` method be useful? Imagine that the motorcycles in the
    list are stored in chronological order, according to when we owned them. If this
    is the case, we can use the `pop()` method to print a statement about the last
    motorcycle we bought:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`pop()`方法有什么用呢？假设摩托车列表是按我们拥有它们的时间顺序存储的。如果是这种情况，我们可以使用`pop()`方法打印一条关于我们最后购买的摩托车的语句：
- en: '[PRE87]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The output is a simple sentence about the most recent motorcycle we owned:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是关于我们最近拥有的摩托车的一句简单话语：
- en: '[PRE88]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Popping Items from Any Position in a List
  id: totrans-407
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从列表中的任何位置弹出元素
- en: 'You can use `pop()` to remove an item from any position in a list by including
    the index of the item you want to remove in parentheses:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`pop()`方法通过在括号中指定要删除的项的索引，来从列表中的任何位置删除一个项：
- en: '[PRE89]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'We start by popping the first motorcycle in the list, and then we print a message
    about that motorcycle. The output is a simple sentence describing the first motorcycle
    I ever owned:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过`pop()`删除列表中的第一辆摩托车，然后打印关于这辆摩托车的信息。输出是描述我曾拥有的第一辆摩托车的简单句子：
- en: '[PRE90]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Remember that each time you use `pop()`, the item you work with is no longer
    stored in the list.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，每次使用`pop()`时，你处理的项将不再存储在列表中。
- en: 'If you’re unsure whether to use the `del` statement or the `pop()` method,
    here’s a simple way to decide: when you want to delete an item from a list and
    not use that item in any way, use the `del` statement; if you want to use an item
    as you remove it, use the `pop()` method.'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不确定是使用`del`语句还是`pop()`方法，以下是一个简单的判断方法：当你想从列表中删除一个项并且不再使用该项时，使用`del`语句；如果你在删除项的同时还希望使用该项，使用`pop()`方法。
- en: Removing an Item by Value
  id: totrans-414
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 按值删除项
- en: Sometimes you won’t know the position of the value you want to remove from a
    list. If you only know the value of the item you want to remove, you can use the
    `remove()` method.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你并不知道要从列表中删除的值的位置。如果你只知道要删除的项的值，可以使用`remove()`方法。
- en: 'For example, say we want to remove the value `''ducati''` from the list of
    motorcycles:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们想从摩托车列表中删除值`'ducati'`：
- en: '[PRE91]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Here the `remove()` method tells Python to figure out where `''ducati''` appears
    in the list and remove that element:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 这里`remove()`方法告诉Python找到`'ducati'`在列表中出现的位置，并删除该元素：
- en: '[PRE92]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'You can also use the `remove()` method to work with a value that’s being removed
    from a list. Let’s remove the value `''ducati''` and print a reason for removing
    it from the list:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用`remove()`方法来处理从列表中删除的值。让我们删除值`'ducati'`并打印删除该项的原因：
- en: '[PRE93]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'After defining the list ❶, we assign the value `''ducati''` to a variable called
    `too_expensive` ❷. We then use this variable to tell Python which value to remove
    from the list ❸. The value `''ducati''` has been removed from the list ❹ but is
    still accessible through the variable `too_expensive`, allowing us to print a
    statement about why we removed `''ducati''` from the list of motorcycles:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义列表❶之后，我们将值`'ducati'`赋给一个名为`too_expensive`的变量❷。然后，我们使用这个变量告诉Python要从列表中删除哪个值❸。值`'ducati'`已经从列表中删除❹，但仍可以通过变量`too_expensive`访问，从而允许我们打印一条关于为什么从摩托车列表中删除`'ducati'`的声明：
- en: '[PRE94]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Organizing a List
  id: totrans-424
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组织列表
- en: Often, your lists will be created in an unpredictable order, because you can’t
    always control the order in which your users provide their data. Although this
    is unavoidable in most circumstances, you’ll frequently want to present your information
    in a particular order. Sometimes you’ll want to preserve the original order of
    your list, and other times you’ll want to change the original order. Python provides
    a number of different ways to organize your lists, depending on the situation.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，列表会以不可预测的顺序创建，因为你无法总是控制用户提供数据的顺序。虽然在大多数情况下这是不可避免的，但你经常会希望以特定的顺序展示信息。有时你想保留列表的原始顺序，其他时候你可能想改变原始顺序。Python根据不同情况提供了多种方法来组织列表。
- en: Sorting a List Permanently with the sort() Method
  id: totrans-426
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`sort()`方法永久排序列表
- en: 'Python’s `sort()` method makes it relatively easy to sort a list. Imagine we
    have a list of cars and want to change the order of the list to store them alphabetically.
    To keep the task simple, let’s assume that all the values in the list are lowercase:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: Python的`sort()`方法使得排序列表变得相对简单。假设我们有一份汽车列表，并且想要将列表的顺序改为按字母顺序排列。为了简化任务，假设列表中的所有值都是小写字母：
- en: '**cars.py**'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '**cars.py**'
- en: '[PRE95]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The `sort()` method changes the order of the list permanently. The cars are
    now in alphabetical order, and we can never revert to the original order:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort()`方法会永久改变列表的顺序。现在这些汽车已经按字母顺序排列，我们将无法恢复到原来的顺序：'
- en: '[PRE96]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'You can also sort this list in reverse-alphabetical order by passing the argument
    `reverse=True` to the `sort()` method. The following example sorts the list of
    cars in reverse-alphabetical order:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过向`sort()`方法传递参数`reverse=True`，按逆字母顺序对列表进行排序。以下示例将汽车列表按逆字母顺序排序：
- en: '[PRE97]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Again, the order of the list is permanently changed:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，列表的顺序已经永久改变：
- en: '[PRE98]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Sorting a List Temporarily with the sorted() Function
  id: totrans-436
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`sorted()`函数临时排序列表
- en: To maintain the original order of a list but present it in a sorted order, you
    can use the `sorted()` function. The `sorted()` function lets you display your
    list in a particular order, but doesn’t affect the actual order of the list.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望保持列表的原始顺序，但以排序的顺序显示列表，可以使用`sorted()`函数。`sorted()`函数允许你以特定的顺序显示列表，但不会影响列表的实际顺序。
- en: Let’s try this function on the list of cars.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在汽车列表上尝试这个函数。
- en: '[PRE99]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'We first print the list in its original order ❶ and then in alphabetical order
    ❷. After the list is displayed in the new order, we show that the list is still
    stored in its original order ❸:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先按原始顺序打印列表❶，然后按字母顺序打印❷。在列表按照新顺序显示后，我们展示该列表仍然以原始顺序存储❸：
- en: '[PRE100]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Notice that the list still exists in its original order ❶ after the `sorted()`
    function has been used. The `sorted()` function can also accept a `reverse=True`
    argument if you want to display a list in reverse-alphabetical order.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在使用`sorted()`函数之后，列表仍然保留原始顺序❶。如果你希望列表按反字母顺序显示，`sorted()`函数还可以接受`reverse=True`参数。
- en: Printing a List in Reverse Order
  id: totrans-443
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 以相反的顺序打印列表
- en: 'To reverse the original order of a list, you can use the `reverse()` method.
    If we originally stored the list of cars in chronological order according to when
    we owned them, we could easily rearrange the list into reverse-chronological order:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 要反转列表的原始顺序，你可以使用`reverse()`方法。如果我们最初按照拥有这些车的时间顺序存储了这些车的列表，我们可以很容易地将列表按时间倒序排列：
- en: '[PRE101]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Notice that `reverse()` doesn’t sort backward alphabetically; it simply reverses
    the order of the list:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`reverse()`不会按照字母顺序倒排；它只是反转列表的顺序：
- en: '[PRE102]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: The `reverse()` method changes the order of a list permanently, but you can
    revert to the original order anytime by applying `reverse()` to the same list
    a second time.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '`reverse()`方法会永久改变列表的顺序，但你可以通过再次对同一个列表调用`reverse()`来恢复原来的顺序。'
- en: Finding the Length of a List
  id: totrans-449
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查找列表的长度
- en: 'You can quickly find the length of a list by using the `len()` function. The
    list in this example has four items, so its length is `4`:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用`len()`函数快速找到列表的长度。这个示例中的列表有四个元素，所以它的长度是`4`：
- en: '[PRE103]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: You’ll find `len()` useful when you need to identify the number of aliens that
    still need to be shot down in a game, determine the amount of data you have to
    manage in a visualization, or figure out the number of registered users on a website,
    among other tasks.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现，`len()`在你需要确定游戏中仍需击落的外星人数量、确定你需要管理的可视化数据量或计算网站上注册用户数量等任务时非常有用。
- en: Avoiding Index Errors When Working with Lists
  id: totrans-453
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在处理列表时避免索引错误
- en: 'There’s one type of error that’s common to see when you’re working with lists
    for the first time. Let’s say you have a list with three items, and you ask for
    the fourth item:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 在你第一次使用列表时，有一种常见的错误类型。假设你有一个包含三个元素的列表，而你请求第四个元素：
- en: '**motorcycles.py**'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '**motorcycles.py**'
- en: '[PRE104]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'This example results in an *index error*:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子会导致一个*索引错误*：
- en: '[PRE105]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Python attempts to give you the item at index 3\. But when it searches the list,
    no item in `motorcycles` has an index of 3\. Because of the off-by-one nature
    of indexing in lists, this error is typical. People think the third item is item
    number 3, because they start counting at 1\. But in Python the third item is number
    2, because it starts indexing at 0.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: Python试图给你索引为3的元素。但当它查找列表时，`motorcycles`中没有索引为3的元素。由于列表索引的下标从0开始，这种错误是常见的。人们通常认为第三个元素是索引3的元素，因为他们习惯从1开始计数。但在Python中，第三个元素的索引是2，因为索引从0开始。
- en: An index error means Python can’t find an item at the index you requested. If
    an index error occurs in your program, try adjusting the index you’re asking for
    by one. Then run the program again to see if the results are correct.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 索引错误意味着Python无法找到你请求的索引位置的元素。如果你的程序中发生了索引错误，试着调整你请求的索引值，然后再次运行程序看看结果是否正确。
- en: 'Keep in mind that whenever you want to access the last item in a list, you
    should use the index `-1`. This will always work, even if your list has changed
    size since the last time you accessed it:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，每当你想访问列表中的最后一个元素时，你应该使用索引`-1`。即使你的列表自上次访问以来发生了变化，这个方法也始终有效：
- en: '[PRE106]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'The index `-1` always returns the last item in a list, in this case the value
    `''suzuki''`:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 索引`-1`总是返回列表中的最后一个元素，在这个例子中是值`suzuki`：
- en: '[PRE107]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'The only time this approach will cause an error is when you request the last
    item from an empty list:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法唯一会引发错误的情况是，当你请求一个空列表中的最后一个元素时：
- en: '[PRE108]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'No items are in `motorcycles`, so Python returns another index error:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '`motorcycles` 中没有项目，因此 Python 返回另一个索引错误：'
- en: '[PRE109]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: If an index error occurs and you can’t figure out how to resolve it, try printing
    your list or just printing the length of your list. Your list might look much
    different than you thought it did, especially if it has been managed dynamically
    by your program. Seeing the actual list, or the exact number of items in your
    list, can help you sort out such logical errors.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生索引错误，并且你无法弄清楚如何解决它，可以尝试打印你的列表或仅打印列表的长度。你的列表可能与你想象的非常不同，尤其是当它由程序动态管理时。查看实际的列表或列表中项目的确切数量，可以帮助你理清这些逻辑错误。
- en: Summary
  id: totrans-470
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned what lists are and how to work with the individual
    items in a list. You learned how to define a list and how to add and remove elements.
    You learned how to sort lists permanently and temporarily for display purposes.
    You also learned how to find the length of a list and how to avoid index errors
    when you’re working with lists.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了什么是列表以及如何处理列表中的各个项目。你学习了如何定义列表，如何添加和移除元素。你还学习了如何对列表进行永久和临时排序，以便展示。你还学习了如何查找列表的长度，以及如何在处理列表时避免索引错误。
- en: In Chapter 4 you’ll learn how to work with items in a list more efficiently.
    By looping through each item in a list using just a few lines of code you’ll be
    able to work efficiently, even when your list contains thousands or millions of
    items.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 4 章中，你将学习如何更高效地处理列表中的项目。通过仅使用几行代码遍历列表中的每一项，你将能够高效地工作，即使列表包含数千或数百万个项目。
- en: '4'
  id: totrans-473
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Working with Lists
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 处理列表
- en: '![](Images/chapterart.png)'
  id: totrans-475
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: In Chapter 3 you learned how to make a simple list, and you learned to work
    with the individual elements in a list. In this chapter you’ll learn how to loop
    through an entire list using just a few lines of code, regardless of how long
    the list is. *Looping* allows you to take the same action, or set of actions,
    with every item in a list. As a result, you’ll be able to work efficiently with
    lists of any length, including those with thousands or even millions of items.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 3 章中，你学习了如何创建一个简单的列表，并学习了如何处理列表中的单个元素。在本章中，你将学习如何使用仅几行代码遍历整个列表，无论列表有多长。*循环*允许你对列表中的每一项执行相同的操作或一组操作。因此，你将能够高效地处理任何长度的列表，包括那些包含数千或甚至数百万个项目的列表。
- en: Looping Through an Entire List
  id: totrans-477
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遍历整个列表
- en: You’ll often want to run through all entries in a list, performing the same
    task with each item. For example, in a game you might want to move every element
    on the screen by the same amount. In a list of numbers, you might want to perform
    the same statistical operation on every element. Or perhaps you’ll want to display
    each headline from a list of articles on a website. When you want to do the same
    action with every item in a list, you can use Python’s `for` loop.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 你常常需要遍历列表中的所有条目，对每一项执行相同的任务。例如，在游戏中，你可能想要将屏幕上的每个元素移动相同的距离。在一个数字列表中，你可能想对每个元素执行相同的统计操作。或者，你可能想在一个网站上显示每篇文章的标题。当你想对列表中的每一项执行相同的操作时，可以使用
    Python 的 `for` 循环。
- en: Say we have a list of magicians’ names, and we want to print out each name in
    the list. We could do this by retrieving each name from the list individually,
    but this approach could cause several problems. For one, it would be repetitive
    to do this with a long list of names. Also, we’d have to change our code each
    time the list’s length changed. Using a `for` loop avoids both of these issues
    by letting Python manage these issues internally.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个魔术师名字的列表，并且我们想打印出列表中的每个名字。我们可以通过单独取出列表中的每个名字来做到这一点，但这种方法可能会导致几个问题。首先，对于一个很长的名字列表，重复这样的操作会很繁琐。其次，每次列表长度发生变化时，我们必须修改代码。使用
    `for` 循环可以避免这两个问题，因为 Python 会内部处理这些问题。
- en: 'Let’s use a `for` loop to print out each name in a list of magicians:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 `for` 循环打印出魔术师名单中的每个名字：
- en: '**magicians.py**'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '**magicians.py**'
- en: '[PRE110]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'We begin by defining a list, just as we did in Chapter 3. Then we define a
    `for` loop. This line tells Python to pull a name from the list `magicians`, and
    associate it with the variable `magician`. Next, we tell Python to print the name
    that’s just been assigned to `magician`. Python then repeats these last two lines,
    once for each name in the list. It might help to read this code as “For every
    magician in the list of magicians, print the magician’s name.” The output is a
    simple printout of each name in the list:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从定义一个列表开始，就像我们在第3章中做的那样。然后我们定义一个`for`循环。这一行告诉Python从列表`magicians`中取出一个名字，并将其与变量`magician`关联。接下来，我们告诉Python打印刚刚分配给`magician`的名字。Python接着重复这两行代码，每个列表中的名字执行一次。你可以将这段代码理解为“对于`magicians`列表中的每个魔术师，打印该魔术师的名字。”输出将是列表中每个名字的简单打印：
- en: '[PRE111]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: A Closer Look at Looping
  id: totrans-485
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更深入地了解循环
- en: 'Looping is important because it’s one of the most common ways a computer automates
    repetitive tasks. For example, in a simple loop like we used in *magicians.py*,
    Python initially reads the first line of the loop:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 循环很重要，因为它是计算机自动化重复任务的最常见方式之一。例如，在像我们在*magicians.py*中使用的简单循环中，Python首先读取循环的第一行：
- en: '[PRE112]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'This line tells Python to retrieve the first value from the list `magicians`
    and associate it with the variable `magician`. This first value is `''alice''`.
    Python then reads the next line:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行告诉Python从列表`magicians`中提取第一个值，并将其与变量`magician`关联。这个第一个值是`'alice'`。然后，Python继续读取下一行：
- en: '[PRE113]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Python prints the current value of `magician`, which is still `''alice''`.
    Because the list contains more values, Python returns to the first line of the
    loop:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: Python再次打印当前`magician`的值，仍然是`'alice'`。由于列表中还有更多值，Python返回到循环的第一行：
- en: '[PRE114]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Python retrieves the next name in the list, `''david''`, and associates that
    value with the variable `magician`. Python then executes the line:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: Python检索列表中的下一个名字`'david'`，并将该值与变量`magician`关联。然后，Python执行这一行：
- en: '[PRE115]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Python prints the current value of `magician` again, which is now `'david'`.
    Python repeats the entire loop once more with the last value in the list, `'carolina'`.
    Because no more values are in the list, Python moves on to the next line in the
    program. In this case nothing comes after the `for` loop, so the program ends.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: Python再次打印当前`magician`的值，这次是`'david'`。Python再次执行整个循环，使用列表中的最后一个值`'carolina'`。由于列表中没有更多的值，Python转到程序中的下一行。在这种情况下，`for`循环后面没有更多的代码，所以程序结束。
- en: When you’re using loops for the first time, keep in mind that the set of steps
    is repeated once for each item in the list, no matter how many items are in the
    list. If you have a million items in your list, Python repeats these steps a million
    times—and usually very quickly.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 当你第一次使用循环时，请记住，这些步骤会针对列表中的每个项目重复执行一次，不管列表中有多少项。如果列表中有一百万个项目，Python将这些步骤重复执行一百万次——通常执行得非常快。
- en: 'Also keep in mind when writing your own `for` loops that you can choose any
    name you want for the temporary variable that will be associated with each value
    in the list. However, it’s helpful to choose a meaningful name that represents
    a single item from the list. For example, here’s a good way to start a `for` loop
    for a list of cats, a list of dogs, and a general list of items:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，在编写你自己的`for`循环时，记住你可以为与列表中每个值关联的临时变量选择任何你想要的名称。然而，选择一个有意义的名称来表示列表中的单个项是很有帮助的。例如，以下是为猫的列表、狗的列表和一般物品列表编写`for`循环的一个好方法：
- en: '[PRE116]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: These naming conventions can help you follow the action being done on each item
    within a `for` loop. Using singular and plural names can help you identify whether
    a section of code is working with a single element from the list or the entire
    list.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命名约定可以帮助你跟踪在`for`循环中每个项所执行的操作。使用单数和复数名称可以帮助你识别代码的某一部分是在处理列表中的单个元素还是整个列表。
- en: Doing More Work Within a for Loop
  id: totrans-499
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在`for`循环中做更多的工作
- en: 'You can do just about anything with each item in a `for` loop. Let’s build
    on the previous example by printing a message to each magician, telling them that
    they performed a great trick:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以对`for`循环中的每个项目做几乎任何事情。让我们在之前的例子基础上，向每个魔术师打印一条消息，告诉他们他们表演了一个很棒的魔术：
- en: '**magicians.py**'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: '**magicians.py**'
- en: '[PRE117]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: The only difference in this code is where we compose a message to each magician,
    starting with that magician’s name. The first time through the loop the value
    of `magician` is `'alice'`, so Python starts the first message with the name `'Alice'`.
    The second time through, the message will begin with `'David'`, and the third
    time through, the message will begin with `'Carolina'`.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码唯一的区别在于我们为每个魔术师构建消息，消息从该魔术师的名字开始。在第一次执行循环时，`magician`的值是`'alice'`，所以Python会用名字`'Alice'`开始第一条消息。第二次执行时，消息会以`'David'`开头，第三次执行时，消息会以`'Carolina'`开头。
- en: 'The output shows a personalized message for each magician in the list:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示了列表中每位魔术师的个性化消息：
- en: '[PRE118]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: You can also write as many lines of code as you like in the `for` loop. Every
    indented line following the line `for magician in magicians` is considered *inside
    the loop*, and each indented line is executed once for each value in the list.
    Therefore, you can do as much work as you like with each value in the list.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在`for`循环中写任意多行代码。在`for magician in magicians`这一行之后的每一行缩进代码都被认为是在*循环内*，并且每一行会为列表中的每个值执行一次。因此，你可以在每个列表项上执行任意多的操作。
- en: 'Let’s add a second line to our message, telling each magician that we’re looking
    forward to their next trick:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为消息添加第二行，告诉每位魔术师我们期待他们的下一个魔术：
- en: '[PRE119]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Because we have indented both calls to `print()`, each line will be executed
    once for every magician in the list. The newline (`"\n"`) in the second `print()`
    call inserts a blank line after each pass through the loop. This creates a set
    of messages that are neatly grouped for each person in the list:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经缩进了两次`print()`的调用，因此每一行会为列表中的每个魔术师执行一次。第二次`print()`调用中的换行符（`"\n"`）会在每次循环后插入一个空行。这就创建了一组整齐分组的消息，每个人都有一条：
- en: '[PRE120]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: You can use as many lines as you like in your `for` loops. In practice, you’ll
    often find it useful to do a number of different operations with each item in
    a list when you use a `for` loop.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`for`循环中使用任意多的行。实际上，你会发现，在使用`for`循环时，通常需要对列表中的每个项目执行多种不同的操作。
- en: Doing Something After a for Loop
  id: totrans-512
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在`for`循环后做一些事情
- en: What happens once a `for` loop has finished executing? Usually, you’ll want
    to summarize a block of output or move on to other work that your program must
    accomplish.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`for`循环执行完毕会发生什么？通常，你会希望总结输出块，或者继续执行程序中必须完成的其他工作。
- en: 'Any lines of code after the `for` loop that are not indented are executed once
    without repetition. Let’s write a thank you to the group of magicians as a whole,
    thanking them for putting on an excellent show. To display this group message
    after all of the individual messages have been printed, we place the thank you
    message after the `for` loop, without indentation:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 在`for`循环后面任何没有缩进的代码行都只会执行一次，而不会重复执行。我们来为魔术师们写一条感谢信息，感谢他们为大家呈现了一场精彩的表演。为了在打印完所有个人消息后显示这条群体消息，我们将感谢信息写在`for`循环之后，且不缩进：
- en: '[PRE121]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'The first two calls to `print()` are repeated once for each magician in the
    list, as you saw earlier. However, because the last line is not indented, it’s
    printed only once:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 前两次调用`print()`会为列表中的每个魔术师重复一次，正如你之前所看到的。然而，由于最后一行没有缩进，它只会执行一次：
- en: '[PRE122]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: When you’re processing data using a `for` loop, you’ll find that this is a good
    way to summarize an operation that was performed on an entire dataset. For example,
    you might use a `for` loop to initialize a game by running through a list of characters
    and displaying each character on the screen. You might then write some additional
    code after this loop that displays a *Play Now* button after all the characters
    have been drawn to the screen.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用`for`循环处理数据时，你会发现这是总结对整个数据集执行的操作的好方法。例如，你可能会用`for`循环来初始化一个游戏，遍历角色列表并在屏幕上显示每个角色。然后你可能会在循环后写一些额外的代码，在所有角色都显示在屏幕后显示一个*现在开始游戏*按钮。
- en: Avoiding Indentation Errors
  id: totrans-519
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免缩进错误
- en: Python uses indentation to determine how a line, or group of lines, is related
    to the rest of the program. In the previous examples, the lines that printed messages
    to individual magicians were part of the `for` loop because they were indented.
    Python’s use of indentation makes code very easy to read. Basically, it uses whitespace
    to force you to write neatly formatted code with a clear visual structure. In
    longer Python programs, you’ll notice blocks of code indented at a few different
    levels. These indentation levels help you gain a general sense of the overall
    program’s organization.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: Python 使用缩进来确定某一行或一组行与程序其余部分的关系。在之前的示例中，打印每个魔术师消息的那些行属于 `for` 循环，因为它们是缩进的。Python
    使用缩进使得代码非常容易阅读。基本上，它通过空白符强制你编写格式整洁且具有清晰视觉结构的代码。在更长的 Python 程序中，你会注意到有些代码块在不同的缩进级别上。这些缩进级别帮助你对整个程序的组织结构有一个大致的了解。
- en: As you begin to write code that relies on proper indentation, you’ll need to
    watch for a few common *indentation errors*. For example, people sometimes indent
    lines of code that don’t need to be indented or forget to indent lines that need
    to be indented. Seeing examples of these errors now will help you avoid them in
    the future and correct them when they do appear in your own programs.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始编写依赖于正确缩进的代码时，你需要注意一些常见的*缩进错误*。例如，人们有时会缩进不需要缩进的代码行，或者忘记缩进需要缩进的代码行。现在看到这些错误的示例会帮助你在将来避免它们，并在自己的程序中出现时修正它们。
- en: Let’s examine some of the more common indentation errors.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看一些更常见的缩进错误。
- en: Forgetting to Indent
  id: totrans-523
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 忘记缩进
- en: 'Always indent the line after the `for` statement in a loop. If you forget,
    Python will remind you:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环中的 `for` 语句后总是需要缩进。如果你忘记了，Python 会提醒你：
- en: '**magicians.py**'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: '**magicians.py**'
- en: '[PRE123]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'The call to `print()` ❶ should be indented, but it’s not. When Python expects
    an indented block and doesn’t find one, it lets you know which line it had a problem
    with:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `print()` ❶ 应该缩进，但它没有缩进。当 Python 期望一个缩进块却没有找到时，它会告诉你它在哪一行出现了问题：
- en: '[PRE124]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: You can usually resolve this kind of indentation error by indenting the line
    or lines immediately after the `for` statement.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你可以通过在 `for` 语句后立即缩进该行或多行来解决这种缩进错误。
- en: Forgetting to Indent Additional Lines
  id: totrans-530
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 忘记缩进额外的行
- en: Sometimes your loop will run without any errors but won’t produce the expected
    result. This can happen when you’re trying to do several tasks in a loop and you
    forget to indent some of its lines.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你的循环会在没有错误的情况下运行，但却没有产生预期的结果。这种情况通常发生在你试图在循环中执行多个任务，却忘记缩进其中的一些行时。
- en: 'For example, this is what happens when we forget to indent the second line
    in the loop that tells each magician we’re looking forward to their next trick:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当我们忘记缩进循环中的第二行（这行代码告诉每个魔术师我们期待他们的下一个魔术时），就会发生以下情况：
- en: '[PRE125]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'The second call to `print()` ❶ is supposed to be indented, but because Python
    finds at least one indented line after the `for` statement, it doesn’t report
    an error. As a result, the first `print()` call is executed once for each name
    in the list because it is indented. The second `print()` call is not indented,
    so it is executed only once after the loop has finished running. Because the final
    value associated with `magician` is `''carolina''`, she is the only one who receives
    the “looking forward to the next trick” message:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次调用 `print()` ❶ 应该缩进，但由于 Python 在 `for` 语句后发现至少有一行缩进的代码，它并不会报错。因此，第一个 `print()`
    调用会针对列表中的每个名字执行一次，因为它是缩进的。第二个 `print()` 调用没有缩进，所以它只会在循环结束后执行一次。由于与 `magician`
    关联的最终值是 `'carolina'`，因此只有她收到了“期待下一场魔术”的消息：
- en: '[PRE126]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: This is a *logical error*. The syntax is valid Python code, but the code does
    not produce the desired result because a problem occurs in its logic. If you expect
    to see a certain action repeated once for each item in a list and it’s executed
    only once, determine whether you need to simply indent a line or a group of lines.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个*逻辑错误*。语法上是有效的 Python 代码，但由于逻辑上出现问题，代码并没有产生预期的结果。如果你期望看到某个操作对列表中的每个项都执行一次，而它只执行了一次，请检查是否需要缩进某一行或一组行。
- en: Indenting Unnecessarily
  id: totrans-537
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不必要的缩进
- en: 'If you accidentally indent a line that doesn’t need to be indented, Python
    informs you about the unexpected indent:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不小心缩进了一个不需要缩进的行，Python 会提示你关于意外缩进的错误：
- en: '**hello_world.py**'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: '**hello_world.py**'
- en: '[PRE127]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'We don’t need to indent the `print()` call, because it isn’t part of a loop;
    hence, Python reports that error:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要缩进 `print()` 调用，因为它不是循环的一部分；因此，Python 会报告这个错误：
- en: '[PRE128]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: You can avoid unexpected indentation errors by indenting only when you have
    a specific reason to do so. In the programs you’re writing at this point, the
    only lines you should indent are the actions you want to repeat for each item
    in a `for` loop.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 通过只有在有特定理由时才进行缩进，你可以避免意外的缩进错误。在你此时编写的程序中，唯一需要缩进的行是你希望在每次 `for` 循环中的每个项目上重复执行的操作。
- en: Indenting Unnecessarily After the Loop
  id: totrans-544
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 循环后不必要的缩进
- en: If you accidentally indent code that should run after a loop has finished, that
    code will be repeated once for each item in the list. Sometimes this prompts Python
    to report an error, but often this will result in a logical error.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不小心缩进了应当在循环结束后运行的代码，这段代码将在列表中的每一项上都执行一次。有时这会导致 Python 报告错误，但通常会导致逻辑错误。
- en: 'For example, let’s see what happens when we accidentally indent the line that
    thanked the magicians as a group for putting on a good show:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，看看当我们不小心缩进了感谢魔术师们集体表现出色的那一行时会发生什么：
- en: '**magicians.py**'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: '**magicians.py**'
- en: '[PRE129]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Because the last line ❶ is indented, it’s printed once for each person in the
    list:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 由于最后一行❶有缩进，它会为列表中的每一个人都执行一次：
- en: '[PRE130]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: This is another logical error, similar to the one in “Forgetting to Indent Additional
    Lines” on page 54. Because Python doesn’t know what you’re trying to accomplish
    with your code, it will run all code that is written in valid syntax. If an action
    is repeated many times when it should be executed only once, you probably need
    to unindent the code for that action.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个逻辑错误，类似于第54页中“忘记缩进额外的行”中的错误。由于 Python 不知道你想通过代码实现什么，它会运行所有符合语法规则的代码。如果某个操作应当仅执行一次，却被多次重复执行，你可能需要取消该操作的缩进。
- en: Forgetting the Colon
  id: totrans-552
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 忘记冒号
- en: The colon at the end of a `for` statement tells Python to interpret the next
    line as the start of a loop.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`语句末尾的冒号告诉 Python 将下一行解释为循环的开始。'
- en: '[PRE131]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'If you accidentally forget the colon ❶, you’ll get a syntax error because Python
    doesn’t know exactly what you’re trying to do:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不小心忘记了冒号❶，你会得到语法错误，因为 Python 不知道你到底想做什么：
- en: '[PRE132]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: Python doesn’t know if you simply forgot the colon, or if you meant to write
    additional code to set up a more complex loop. If the interpreter can identify
    a possible fix it will suggest one, like adding a colon at the end of a line,
    as it does here with the response `expected ':'`. Some errors have easy, obvious
    fixes, thanks to the suggestions in Python’s tracebacks. Some errors are much
    harder to resolve, even when the eventual fix only involves a single character.
    Don’t feel bad when a small fix takes a long time to find; you are absolutely
    not alone in this experience.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: Python 不知道你是仅仅忘记了冒号，还是打算写额外的代码来设置一个更复杂的循环。如果解释器能够识别出一个可能的修复，它会给出建议，比如在行尾加上冒号，就像这里的
    `expected ':'` 响应一样。有些错误有简单、显而易见的修复，这要归功于 Python 错误追踪中提供的建议。也有一些错误，即使最终的修复仅涉及一个字符，也更难解决。当一个小修复花费很长时间才找到时，不必感到沮丧；你绝对不是唯一有这种经历的人。
- en: Making Numerical Lists
  id: totrans-558
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建数字列表
- en: Many reasons exist to store a set of numbers. For example, you’ll need to keep
    track of the positions of each character in a game, and you might want to keep
    track of a player’s high scores as well. In data visualizations, you’ll almost
    always work with sets of numbers, such as temperatures, distances, population
    sizes, or latitude and longitude values, among other types of numerical sets.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 存储一组数字有很多理由。例如，你可能需要跟踪游戏中每个角色的位置，也许还想记录玩家的最高分。在数据可视化中，你几乎总是会处理一组数字，比如温度、距离、人口大小，或者经纬度值等各种类型的数字集合。
- en: Lists are ideal for storing sets of numbers, and Python provides a variety of
    tools to help you work efficiently with lists of numbers. Once you understand
    how to use these tools effectively, your code will work well even when your lists
    contain millions of items.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 列表非常适合存储数字集合，Python 提供了多种工具来帮助你高效地处理数字列表。一旦你理解了如何有效地使用这些工具，即使你的列表包含数百万个项目，代码也能顺利运行。
- en: Using the range() Function
  id: totrans-561
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `range()` 函数
- en: 'Python’s `range()` function makes it easy to generate a series of numbers.
    For example, you can use the `range()` function to print a series of numbers like
    this:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的 `range()` 函数使得生成一系列数字变得简单。例如，你可以使用 `range()` 函数像这样打印一系列数字：
- en: '**first_numbers.py**'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: '**first_numbers.py**'
- en: '[PRE133]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Although this code looks like it should print the numbers from 1 to 5, it doesn’t
    print the number 5:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这段代码看起来应该打印从 1 到 5 的数字，但它没有打印数字 5：
- en: '[PRE134]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: In this example, `range()` prints only the numbers 1 through 4\. This is another
    result of the off-by-one behavior you’ll see often in programming languages. The
    `range()` function causes Python to start counting at the first value you give
    it, and it stops when it reaches the second value you provide. Because it stops
    at that second value, the output never contains the end value, which would have
    been 5 in this case.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`range()`只打印1到4之间的数字。这是编程语言中常见的“偏差一”行为的另一个例子。`range()`函数会让Python从你提供的第一个值开始计数，并在达到你提供的第二个值时停止。因为它会在第二个值时停止，输出中永远不会包含结束值，而在这个例子中，结束值本应是5。
- en: 'To print the numbers from 1 to 5, you would use `range(1, 6)`:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 要打印从1到5的数字，你可以使用`range(1, 6)`：
- en: '[PRE135]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'This time the output starts at 1 and ends at 5:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 这次输出从1开始，到5结束：
- en: '[PRE136]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: If your output is different from what you expect when you’re using `range()`,
    try adjusting your end value by 1.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在使用`range()`时，输出与预期不符，尝试调整结束值加1。
- en: You can also pass `range()` only one argument, and it will start the sequence
    of numbers at 0\. For example, `range(6)` would return the numbers from 0 through
    5.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以只传递一个参数给`range()`，它会从0开始生成数字序列。例如，`range(6)`将返回从0到5的数字。
- en: Using range() to Make a List of Numbers
  id: totrans-574
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`range()`创建一个数字列表
- en: If you want to make a list of numbers, you can convert the results of `range()`
    directly into a list using the `list()` function. When you wrap `list()` around
    a call to the `range()` function, the output will be a list of numbers.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想制作一个数字列表，你可以使用`list()`函数将`range()`的结果直接转换为列表。当你将`list()`包裹在对`range()`函数的调用周围时，输出将是一个数字列表。
- en: 'In the example in the previous section, we simply printed out a series of numbers.
    We can use `list()` to convert that same set of numbers into a list:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面章节的例子中，我们仅仅是打印了一系列数字。我们可以使用`list()`将这组数字转换为列表：
- en: '[PRE137]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'This is the result:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 这是结果：
- en: '[PRE138]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: We can also use the `range()` function to tell Python to skip numbers in a given
    range. If you pass a third argument to `range()`, Python uses that value as a
    step size when generating numbers.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`range()`函数告诉Python跳过给定范围内的数字。如果你传递第三个参数给`range()`，Python会使用该值作为生成数字时的步长。
- en: 'For example, here’s how to list the even numbers between 1 and 10:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，下面是如何列出1到10之间的偶数：
- en: '**even_numbers.py**'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: '**even_numbers.py**'
- en: '[PRE139]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'In this example, the `range()` function starts with the value 2 and then adds
    2 to that value. It adds 2 repeatedly until it reaches or passes the end value,
    11, and produces this result:'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`range()`函数从值2开始，然后将2加到这个值上。它会重复加2，直到达到或超过结束值11，并产生如下结果：
- en: '[PRE140]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'You can create almost any set of numbers you want to using the `range()` function.
    For example, consider how you might make a list of the first 10 square numbers
    (that is, the square of each integer from 1 through 10). In Python, two asterisks
    (`**`) represent exponents. Here’s how you might put the first 10 square numbers
    into a list:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`range()`函数创建几乎任何你想要的数字集。例如，考虑如何制作一个包含前10个平方数的列表（即从1到10的每个整数的平方）。在Python中，两个星号（`**`）表示指数运算。下面是如何将前10个平方数放入列表的示例：
- en: '**square_numbers.py**'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: '**square_numbers.py**'
- en: '[PRE141]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'We start with an empty list called `squares`. Then, we tell Python to loop
    through each value from 1 to 10 using the `range()` function. Inside the loop,
    the current value is raised to the second power and assigned to the variable `square`
    ❶. Each new value of `square` is then appended to the list `squares` ❷. Finally,
    when the loop has finished running, the list of squares is printed:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个空列表`squares`。然后，告诉Python使用`range()`函数循环遍历1到10之间的每个值。在循环内部，当前值被平方并赋值给变量`square`
    ❶。每次新的`square`值都会被追加到`squares`列表中 ❷。最后，当循环结束时，平方数的列表会被打印出来：
- en: '[PRE142]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'To write this code more concisely, omit the temporary variable `square` and
    append each new value directly to the list:'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这段代码更简洁，可以省略临时变量`square`，并将每个新值直接添加到列表中：
- en: '[PRE143]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: This line does the same work as the lines inside the `for` loop in the previous
    listing. Each value in the loop is raised to the second power and then immediately
    appended to the list of squares.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行完成了与前面列表中`for`循环内部相同的工作。循环中的每个值都会被平方，然后立即追加到平方数列表中。
- en: You can use either of these approaches when you’re making more complex lists.
    Sometimes using a temporary variable makes your code easier to read; other times
    it makes the code unnecessarily long. Focus first on writing code that you understand
    clearly, and does what you want it to do. Then look for more efficient approaches
    as you review your code.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 在制作更复杂的列表时，你可以使用这两种方法中的任何一种。有时使用临时变量可以让你的代码更易读；有时则可能使代码变得冗长。首先关注编写自己清楚理解的代码，并确保它能按预期执行。然后，在复查代码时，寻找更高效的方法。
- en: Simple Statistics with a List of Numbers
  id: totrans-595
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用数字列表进行简单统计
- en: 'A few Python functions are helpful when working with lists of numbers. For
    example, you can easily find the minimum, maximum, and sum of a list of numbers:'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理数字列表时，几个 Python 函数非常有用。例如，你可以轻松地找到数字列表中的最小值、最大值和总和：
- en: '[PRE144]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: List Comprehensions
  id: totrans-598
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列表推导式
- en: The approach described earlier for generating the list `squares` consisted of
    using three or four lines of code. A *list comprehension* allows you to generate
    this same list in just one line of code. A list comprehension combines the `for`
    loop and the creation of new elements into one line, and automatically appends
    each new element. List comprehensions are not always presented to beginners, but
    I’ve included them here because you’ll most likely see them as soon as you start
    looking at other people’s code.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 前面描述的生成 `squares` 列表的方法需要使用三到四行代码。一个 *列表推导式* 可以让你仅用一行代码生成相同的列表。列表推导式将 `for`
    循环和新元素的创建合并为一行，并自动附加每个新元素。列表推导式通常不会首先介绍给初学者，但我在这里包含它们，因为一旦你开始查看其他人的代码，你很可能会看到它们。
- en: 'The following example builds the same list of square numbers you saw earlier
    but uses a list comprehension:'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例构建了与之前相同的平方数列表，但使用了列表推导式：
- en: '**squares.py**'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: '**squares.py**'
- en: '[PRE145]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: To use this syntax, begin with a descriptive name for the list, such as `squares`.
    Next, open a set of square brackets and define the expression for the values you
    want to store in the new list. In this example the expression is `value**2`, which
    raises the value to the second power. Then, write a `for` loop to generate the
    numbers you want to feed into the expression, and close the square brackets. The
    `for` loop in this example is `for value in range(1, 11)`, which feeds the values
    1 through 10 into the expression `value**2`. Note that no colon is used at the
    end of the `for` statement.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这种语法，首先为列表取一个描述性名称，例如 `squares`。接着，打开一对方括号，定义你想存储到新列表中的表达式。在这个例子中，表达式是 `value**2`，它将值提升到二次方。然后，写一个
    `for` 循环来生成你想要传入表达式的数字，最后关闭方括号。这个例子中的 `for` 循环是 `for value in range(1, 11)`，它将值
    1 到 10 传入表达式 `value**2`。注意，在 `for` 语句末尾不使用冒号。
- en: 'The result is the same list of square numbers you saw earlier:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是你之前看到的相同的平方数列表：
- en: '[PRE146]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: It takes practice to write your own list comprehensions, but you’ll find them
    worthwhile once you become comfortable creating ordinary lists. When you’re writing
    three or four lines of code to generate lists and it begins to feel repetitive,
    consider writing your own list comprehensions.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 编写你自己的列表推导式需要练习，但一旦你熟悉了创建普通列表，你会发现它们非常值得。当你编写三到四行代码来生成列表，并开始觉得重复时，考虑编写你自己的列表推导式。
- en: Working with Part of a List
  id: totrans-607
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作列表的一部分
- en: In Chapter 3 you learned how to access single elements in a list, and in this
    chapter you’ve been learning how to work through all the elements in a list. You
    can also work with a specific group of items in a list, called a *slice* in Python.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三章，你学习了如何访问列表中的单个元素，而在本章，你正在学习如何遍历列表中的所有元素。你还可以操作列表中的特定项集合，这在 Python 中称为 *切片*。
- en: Slicing a List
  id: totrans-609
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 切片列表
- en: To make a slice, you specify the index of the first and last elements you want
    to work with. As with the `range()` function, Python stops one item before the
    second index you specify. To output the first three elements in a list, you would
    request indices `0` through `3`, which would return elements `0`, `1`, and `2`.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 要制作切片，你需要指定你想操作的第一个和最后一个元素的索引。与 `range()` 函数一样，Python 会在你指定的第二个索引之前停止。所以，要输出列表中的前三个元素，你需要请求索引
    `0` 到 `3`，这将返回元素 `0`、`1` 和 `2`。
- en: 'The following example involves a list of players on a team:'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例涉及一个团队的玩家列表：
- en: '**players.py**'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: '**players.py**'
- en: '[PRE147]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'This code prints a slice of the list. The output retains the structure of the
    list, and includes the first three players in the list:'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码打印了列表的一个切片。输出保留了列表的结构，并包括了列表中的前三个玩家：
- en: '[PRE148]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'You can generate any subset of a list. For example, if you want the second,
    third, and fourth items in a list, you would start the slice at index `1` and
    end it at index `4`:'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以生成列表的任何子集。例如，如果你想要列表中的第二、第三和第四个项目，你可以从索引`1`开始切片，结束于索引`4`：
- en: '[PRE149]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'This time the slice starts with `''martina''` and ends with `''florence''`:'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 这次切片从`'martina'`开始，直到`'florence'`结束：
- en: '[PRE150]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'If you omit the first index in a slice, Python automatically starts your slice
    at the beginning of the list:'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在切片中省略第一个索引，Python 会自动从列表的开头开始切片：
- en: '[PRE151]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'Without a starting index, Python starts at the beginning of the list:'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 没有起始索引时，Python 会从列表的开头开始：
- en: '[PRE152]'
  id: totrans-623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'A similar syntax works if you want a slice that includes the end of a list.
    For example, if you want all items from the third item through the last item,
    you can start with index `2` and omit the second index:'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要包括列表末尾的切片，类似的语法也适用。例如，如果你想要从第三个项目到最后一个项目的所有项，可以从索引`2`开始，省略第二个索引：
- en: '[PRE153]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'Python returns all items from the third item through the end of the list:'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: Python 会返回从第三个项目到列表末尾的所有项目：
- en: '[PRE154]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'This syntax allows you to output all of the elements from any point in your
    list to the end, regardless of the length of the list. Recall that a negative
    index returns an element a certain distance from the end of a list; therefore,
    you can output any slice from the end of a list. For example, if we want to output
    the last three players on the roster, we can use the slice `players[-3:]`:'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法允许你从列表的任何位置输出所有元素到列表的末尾，无论列表的长度如何。记住，负索引返回距离列表末尾一定距离的元素；因此，你可以从列表的末尾输出任何切片。例如，如果我们想要输出名册中的最后三位玩家，我们可以使用切片`players[-3:]`：
- en: '[PRE155]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: This prints the names of the last three players and will continue to work as
    the list of players changes in size.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 这会打印出最后三位玩家的名字，并且会随着玩家列表的变化继续有效。
- en: Looping Through a Slice
  id: totrans-631
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遍历切片
- en: 'You can use a slice in a `for` loop if you want to loop through a subset of
    the elements in a list. In the next example, we loop through the first three players
    and print their names as part of a simple roster:'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要遍历列表中某个子集的元素，可以在`for`循环中使用切片。在下一个例子中，我们遍历前三个玩家，并将他们的名字作为简单名册的一部分打印出来：
- en: '[PRE156]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'Instead of looping through the entire list of players, Python loops through
    only the first three names ❶:'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: Python 并不是遍历整个玩家列表，而是只遍历前三个名字 ❶：
- en: '[PRE157]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: Slices are very useful in a number of situations. For instance, when you’re
    creating a game, you could add a player’s final score to a list every time that
    player finishes playing. You could then get a player’s top three scores by sorting
    the list in decreasing order and taking a slice that includes just the first three
    scores. When you’re working with data, you can use slices to process your data
    in chunks of a specific size. Or, when you’re building a web application, you
    could use slices to display information in a series of pages with an appropriate
    amount of information on each page.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 切片在许多情况下非常有用。例如，当你创建游戏时，每次玩家完成游戏后，你可以将该玩家的最终得分添加到列表中。然后，你可以通过将列表按降序排序，并提取一个包含前三个得分的切片，来获取玩家的前三个得分。当你处理数据时，你可以使用切片将数据分成特定大小的块进行处理。或者，当你构建一个Web应用程序时，你可以使用切片在一系列页面中显示信息，每个页面显示适量的信息。
- en: Copying a List
  id: totrans-637
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 复制列表
- en: Often, you’ll want to start with an existing list and make an entirely new list
    based on the first one. Let’s explore how copying a list works and examine one
    situation in which copying a list is useful.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你会想从一个现有的列表开始，并根据第一个列表创建一个全新的列表。让我们来探索如何复制一个列表，并看看在什么情况下复制列表是有用的。
- en: To copy a list, you can make a slice that includes the entire original list
    by omitting the first index and the second index (`[:]`). This tells Python to
    make a slice that starts at the first item and ends with the last item, producing
    a copy of the entire list.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 要复制一个列表，你可以通过省略第一个索引和第二个索引（`[:]`）来创建一个包含原始列表所有元素的切片。这告诉 Python 从第一个项目开始切片，到最后一个项目结束，从而生成整个列表的副本。
- en: 'For example, imagine we have a list of our favorite foods and want to make
    a separate list of foods that a friend likes. This friend likes everything in
    our list so far, so we can create their list by copying ours:'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一个关于我们最喜欢的食物的列表，并想创建一个包含朋友喜欢的食物的单独列表。这个朋友喜欢我们列表中的所有食物，因此我们可以通过复制我们的列表来创建他们的列表：
- en: '**foods.py**'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: '**foods.py**'
- en: '[PRE158]'
  id: totrans-642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'First, we make a list of the foods we like called `my_foods`. Then we make
    a new list called `friend_foods`. We make a copy of `my_foods` by asking for a
    slice of `my_foods` without specifying any indices ❶, and assign the copy to `friend_foods`.
    When we print each list, we see that they both contain the same foods:'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个包含我们喜欢的食物的列表，叫做 `my_foods`。然后，我们创建一个新列表，叫做 `friend_foods`。我们通过请求 `my_foods`
    的切片而不指定任何索引❶，并将复制品赋值给 `friend_foods`。当我们打印每个列表时，我们会看到它们都包含相同的食物：
- en: '[PRE159]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'To prove that we actually have two separate lists, we’ll add a new food to
    each list and show that each list keeps track of the appropriate person’s favorite
    foods:'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明我们实际上有两个独立的列表，我们将向每个列表中添加新的食物，并展示每个列表是如何追踪相应人物的最爱食物的：
- en: '[PRE160]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'We copy the original items in `my_foods` to the new list `friend_foods`, as
    we did in the previous example ❶. Next, we add a new food to each list: we add
    `''cannoli''` to `my_foods` ❷, and we add `''ice cream''` to `friend_foods` ❸.
    We then print the two lists to see whether each of these foods is in the appropriate
    list:'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将原始的 `my_foods` 中的项目复制到新列表 `friend_foods` 中，就像在之前的示例中一样❶。接下来，我们向每个列表中添加新食物：我们将
    `'cannoli'` 添加到 `my_foods` ❷，将 `'ice cream'` 添加到 `friend_foods` ❸。然后我们打印这两个列表，看看这些食物是否出现在相应的列表中：
- en: '[PRE161]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'The output shows that `''cannoli''` now appears in our list of favorite foods
    but `''ice cream''` does not. We can see that `''ice cream''` now appears in our
    friend’s list but `''cannoli''` does not. If we had simply set `friend_foods`
    equal to `my_foods`, we would not produce two separate lists. For example, here’s
    what happens when you try to copy a list without using a slice:'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果显示，`'cannoli'` 现在出现在我们的最爱食物列表中，但 `'ice cream'` 没有。我们可以看到，`'ice cream'` 现在出现在朋友的列表中，但
    `'cannoli'` 没有。如果我们只是将 `friend_foods` 设置为 `my_foods`，我们就不会得到两个独立的列表。例如，下面是当你尝试在没有使用切片的情况下复制列表时发生的情况：
- en: '[PRE162]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: Instead of assigning a copy of `my_foods` to `friend_foods`, we set `friend_foods`
    equal to `my_foods`. This syntax actually tells Python to associate the new variable
    `friend_foods` with the list that is already associated with `my_foods`, so now
    both variables point to the same list. As a result, when we add `'cannoli'` to
    `my_foods`, it will also appear in `friend_foods`. Likewise `'ice cream'` will
    appear in both lists, even though it appears to be added only to `friend_foods`.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是将 `my_foods` 的副本赋给 `friend_foods`，而是将 `friend_foods` 设置为 `my_foods`。这种语法实际上告诉
    Python，将新的变量 `friend_foods` 与已经与 `my_foods` 关联的列表关联起来，因此现在两个变量都指向同一个列表。因此，当我们将
    `'cannoli'` 添加到 `my_foods` 时，它也会出现在 `friend_foods` 中。同样，`'ice cream'` 会出现在两个列表中，即使它似乎只被添加到了
    `friend_foods`。
- en: 'The output shows that both lists are the same now, which is not what we wanted:'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果显示，两个列表现在是相同的，这不是我们想要的：
- en: '[PRE163]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: Tuples
  id: totrans-654
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元组
- en: Lists work well for storing collections of items that can change throughout
    the life of a program. The ability to modify lists is particularly important when
    you’re working with a list of users on a website or a list of characters in a
    game. However, sometimes you’ll want to create a list of items that cannot change.
    Tuples allow you to do just that. Python refers to values that cannot change as
    *immutable*, and an immutable list is called a *tuple*.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 列表适用于存储在程序运行期间可能会发生变化的项目集合。当你在网站上处理用户列表或游戏中的角色列表时，能够修改列表尤其重要。然而，有时你希望创建一个不能改变的项目列表。元组可以让你做到这一点。Python
    将不能更改的值称为*不可变*，而不可变的列表称为*元组*。
- en: Defining a Tuple
  id: totrans-656
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义元组
- en: A tuple looks just like a list, except you use parentheses instead of square
    brackets. Once you define a tuple, you can access individual elements by using
    each item’s index, just as you would for a list.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 元组看起来就像列表，只不过使用圆括号而不是方括号。一旦定义了元组，你可以通过使用每个项的索引来访问个别元素，就像访问列表一样。
- en: 'For example, if we have a rectangle that should always be a certain size, we
    can ensure that its size doesn’t change by putting the dimensions into a tuple:'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们有一个矩形，它的大小应该始终保持不变，我们可以通过将其尺寸放入元组中来确保其大小不会改变：
- en: '**dimensions.py**'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: '**dimensions.py**'
- en: '[PRE164]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'We define the tuple `dimensions`, using parentheses instead of square brackets.
    Then we print each element in the tuple individually, using the same syntax we’ve
    been using to access elements in a list:'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了元组 `dimensions`，使用圆括号而不是方括号。然后，我们使用与访问列表元素相同的语法，逐个打印元组中的每个元素：
- en: '[PRE165]'
  id: totrans-662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'Let’s see what happens if we try to change one of the items in the tuple `dimensions`:'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如果尝试改变元组 `dimensions` 中的某个项目会发生什么：
- en: '[PRE166]'
  id: totrans-664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'This code tries to change the value of the first dimension, but Python returns
    a type error. Because we’re trying to alter a tuple, which can’t be done to that
    type of object, Python tells us we can’t assign a new value to an item in a tuple:'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码试图更改第一个维度的值，但 Python 返回了类型错误。因为我们试图修改元组的值，而元组是不可更改的对象类型，Python 告诉我们不能为元组中的项赋予新值：
- en: '[PRE167]'
  id: totrans-666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: This is beneficial because we want Python to raise an error when a line of code
    tries to change the dimensions of the rectangle.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 这是有益的，因为我们希望在代码行尝试更改矩形的维度时，Python 能引发错误。
- en: Looping Through All Values in a Tuple
  id: totrans-668
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遍历元组中的所有值
- en: 'You can loop over all the values in a tuple using a `for` loop, just as you
    did with a list:'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像遍历列表一样，使用`for`循环遍历元组中的所有值：
- en: '[PRE168]'
  id: totrans-670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'Python returns all the elements in the tuple, just as it would for a list:'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: Python 返回元组中的所有元素，就像它对待列表一样：
- en: '[PRE169]'
  id: totrans-672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: Writing Over a Tuple
  id: totrans-673
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重写元组
- en: 'Although you can’t modify a tuple, you can assign a new value to a variable
    that represents a tuple. For example, if we wanted to change the dimensions of
    this rectangle, we could redefine the entire tuple:'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你不能修改元组，但你可以为表示元组的变量赋予新值。例如，如果我们想改变这个矩形的维度，我们可以重新定义整个元组：
- en: '[PRE170]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'The first four lines define the original tuple and print the initial dimensions.
    We then associate a new tuple with the variable `dimensions`, and print the new
    values. Python doesn’t raise any errors this time, because reassigning a variable
    is valid:'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 前四行定义了原始元组并打印了初始维度。然后，我们将一个新元组与变量`dimensions`关联，并打印新值。这次 Python 不会引发错误，因为重新赋值变量是有效的：
- en: '[PRE171]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: When compared with lists, tuples are simple data structures. Use them when you
    want to store a set of values that should not be changed throughout the life of
    a program.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 与列表相比，元组是简单的数据结构。当你想存储一组在程序生命周期中不应更改的值时，使用元组。
- en: Styling Your Code
  id: totrans-679
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码风格
- en: Now that you’re writing longer programs, it’s a good idea to learn how to style
    your code consistently. Take the time to make your code as easy as possible to
    read. Writing easy-to-read code helps you keep track of what your programs are
    doing and helps others understand your code as well.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你正在编写更长的程序，学习如何一致地编写代码风格是一个好主意。花时间让你的代码尽可能易读。编写易读的代码有助于你跟踪程序的运行，并且也能帮助别人理解你的代码。
- en: Python programmers have agreed on a number of styling conventions to ensure
    that everyone’s code is structured in roughly the same way. Once you’ve learned
    to write clean Python code, you should be able to understand the overall structure
    of anyone else’s Python code, as long as they follow the same guidelines. If you’re
    hoping to become a professional programmer at some point, you should begin following
    these guidelines as soon as possible to develop good habits.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: Python 程序员已达成共识，遵循一系列的代码风格规范，以确保每个人的代码结构大致相同。一旦你学会了编写干净的 Python 代码，你应该能够理解任何其他人写的
    Python 代码，只要他们遵循相同的规范。如果你希望将来成为一名专业程序员，你应该尽早开始遵循这些规范，养成良好的编程习惯。
- en: The Style Guide
  id: totrans-682
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 风格指南
- en: When someone wants to make a change to the Python language, they write a *Python
    Enhancement Proposal (PEP)*. One of the oldest PEPs is *PEP 8*, which instructs
    Python programmers on how to style their code. PEP 8 is fairly lengthy, but much
    of it relates to more complex coding structures than what you’ve seen so far.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 当有人想对 Python 语言做出更改时，他们会写一份*Python 增强提案（PEP）*。最早的 PEP 之一是*PEP 8*，它指导 Python
    程序员如何规范代码风格。PEP 8 内容相当长，但其中很多内容涉及到比你当前看到的更复杂的编码结构。
- en: The Python style guide was written with the understanding that code is read
    more often than it is written. You’ll write your code once and then start reading
    it as you begin debugging. When you add features to a program, you’ll spend more
    time reading your code. When you share your code with other programmers, they’ll
    read your code as well.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的风格指南写作时考虑到代码比编写的更常被阅读。你编写代码一次后，就会在开始调试时反复阅读它。当你向程序添加新功能时，你会花更多时间阅读代码。当你与其他程序员分享代码时，他们也会阅读你的代码。
- en: Given the choice between writing code that’s easier to write or code that’s
    easier to read, Python programmers will almost always encourage you to write code
    that’s easier to read. The following guidelines will help you write clear code
    from the start.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 在写代码时，如果面临选择更容易写的代码和更容易读的代码之间的抉择，Python 程序员几乎总是会鼓励你写易读的代码。以下规范将帮助你从一开始就编写清晰的代码。
- en: Indentation
  id: totrans-686
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缩进
- en: PEP 8 recommends that you use four spaces per indentation level. Using four
    spaces improves readability while leaving room for multiple levels of indentation
    on each line.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: PEP 8 推荐每个缩进级别使用四个空格。使用四个空格可以提高可读性，同时在每一行留出空间以支持多个缩进级别。
- en: In a word processing document, people often use tabs rather than spaces to indent.
    This works well for word processing documents, but the Python interpreter gets
    confused when tabs are mixed with spaces. Every text editor provides a setting
    that lets you use the TAB key but then converts each tab to a set number of spaces.
    You should definitely use your TAB key, but also make sure your editor is set
    to insert spaces rather than tabs into your document.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 在文字处理文档中，人们通常使用制表符而非空格来进行缩进。这对文字处理文档非常有效，但当制表符与空格混合时，Python 解释器会感到困惑。每个文本编辑器都提供一个设置，允许你使用
    TAB 键，但会将每个制表符转换为一定数量的空格。你应该使用 TAB 键，但也要确保编辑器设置为将制表符转换为空格，而不是直接插入制表符。
- en: Mixing tabs and spaces in your file can cause problems that are very difficult
    to diagnose. If you think you have a mix of tabs and spaces, you can convert all
    tabs in a file to spaces in most editors.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件中混合使用制表符和空格可能会导致很难诊断的问题。如果你怀疑文件中混用了制表符和空格，大多数编辑器允许你将文件中的所有制表符转换为空格。
- en: Line Length
  id: totrans-690
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 行长度
- en: Many Python programmers recommend that each line should be less than 80 characters.
    Historically, this guideline developed because most computers could fit only 79
    characters on a single line in a terminal window. Currently, people can fit much
    longer lines on their screens, but other reasons exist to adhere to the 79-character
    standard line length.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 Python 程序员建议每行字符数不应超过 80 个。这个指导方针最初源于大多数计算机只能在终端窗口的单行中显示 79 个字符。现在，人们可以在屏幕上显示更长的行，但仍然有其他原因支持遵循
    79 字符的标准行长度。
- en: Professional programmers often have several files open on the same screen, and
    using the standard line length allows them to see entire lines in two or three
    files that are open side by side onscreen. PEP 8 also recommends that you limit
    all of your comments to 72 characters per line, because some of the tools that
    generate automatic documentation for larger projects add formatting characters
    at the beginning of each commented line.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 专业程序员通常会在同一屏幕上打开多个文件，使用标准的行长度使他们能够同时查看屏幕上并排显示的两个或三个文件中的完整行。PEP 8 还建议将所有注释的每行字符数限制为
    72 个，因为一些为大型项目生成自动文档的工具会在每行注释的开头添加格式字符。
- en: The PEP 8 guidelines for line length are not set in stone, and some teams prefer
    a 99-character limit. Don’t worry too much about line length in your code as you’re
    learning, but be aware that people who are working collaboratively almost always
    follow the PEP 8 guidelines. Most editors allow you to set up a visual cue, usually
    a vertical line on your screen, that shows you where these limits are.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: PEP 8 关于行长度的指导方针并非一成不变，某些团队偏好99字符的限制。作为初学者，你不必过于担心代码行的长度，但要注意，协作开发的人员几乎总是遵循
    PEP 8 的规范。大多数编辑器允许你设置一个视觉提示，通常是在屏幕上显示一条垂直线，帮助你了解行长度的限制。
- en: Blank Lines
  id: totrans-694
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 空白行
- en: To group parts of your program visually, use blank lines. You should use blank
    lines to organize your files, but don’t do so excessively. By following the examples
    provided in this book, you should strike the right balance. For example, if you
    have five lines of code that build a list and then another three lines that do
    something with that list, it’s appropriate to place a blank line between the two
    sections. However, you should not place three or four blank lines between the
    two sections.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在视觉上分组程序的各个部分，使用空白行。你应该使用空白行来组织文件，但不要过度使用。通过遵循本书中提供的示例，你应该能够找到合适的平衡。例如，如果你有五行代码用于构建一个列表，接着再有三行代码操作该列表，那么在这两部分之间插入一个空白行是合适的。然而，你不应在这两部分之间插入三到四个空白行。
- en: Blank lines won’t affect how your code runs, but they will affect the readability
    of your code. The Python interpreter uses horizontal indentation to interpret
    the meaning of your code, but it disregards vertical spacing.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 空白行不会影响代码的运行，但会影响代码的可读性。Python 解释器使用水平缩进来解释代码的含义，但它忽略垂直空白。
- en: Other Style Guidelines
  id: totrans-697
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他样式指南
- en: PEP 8 has many additional styling recommendations, but most of the guidelines
    refer to more complex programs than what you’re writing at this point. As you
    learn more complex Python structures, I’ll share the relevant parts of the PEP
    8 guidelines.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: PEP 8 提供了许多额外的样式建议，但大多数指导原则适用于比你目前编写的更复杂的程序。当你学习更复杂的 Python 结构时，我会分享 PEP 8 指南中相关的部分。
- en: Summary
  id: totrans-699
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how to work efficiently with the elements in a
    list. You learned how to work through a list using a `for` loop, how Python uses
    indentation to structure a program, and how to avoid some common indentation errors.
    You learned to make simple numerical lists, as well as a few operations you can
    perform on numerical lists. You learned how to slice a list to work with a subset
    of items and how to copy lists properly using a slice. You also learned about
    tuples, which provide a degree of protection to a set of values that shouldn’t
    change, and how to style your increasingly complex code to make it easy to read.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了如何高效地处理列表中的元素。你学会了如何使用 `for` 循环遍历列表，Python 如何使用缩进来结构化程序，以及如何避免一些常见的缩进错误。你学会了创建简单的数字列表，以及你可以对数字列表执行的一些操作。你学会了如何切片列表以处理子集项，以及如何通过切片正确地复制列表。你还学习了元组，它提供了一定的保护，防止一组值被改变，以及如何使你越来越复杂的代码具有可读性。
- en: In Chapter 5, you’ll learn to respond appropriately to different conditions
    by using `if` statements. You’ll learn to string together relatively complex sets
    of conditional tests to respond appropriately to exactly the kind of situation
    or information you’re looking for. You’ll also learn to use `if` statements while
    looping through a list to take specific actions with selected elements from a
    list.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 5 章中，你将学习通过使用 `if` 语句来对不同的条件做出适当的反应。你将学会将相对复杂的条件测试组合起来，以准确应对你所寻找的特定情况或信息。你还将学习在循环遍历列表时使用
    `if` 语句，以对列表中的特定元素执行特定操作。
- en: '5'
  id: totrans-702
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: if Statements
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: '`if` 语句'
- en: '![](Images/chapterart.png)'
  id: totrans-704
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: Programming often involves examining a set of conditions and deciding which
    action to take based on those conditions. Python’s `if` statement allows you to
    examine the current state of a program and respond appropriately to that state.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 编程通常涉及检查一组条件，并根据这些条件决定采取什么行动。Python 的 `if` 语句允许你检查程序的当前状态，并对该状态做出适当的响应。
- en: In this chapter, you’ll learn to write conditional tests, which allow you to
    check any condition of interest. You’ll learn to write simple `if` statements,
    and you’ll learn how to create a more complex series of `if` statements to identify
    when the exact conditions you want are present. You’ll then apply this concept
    to lists, so you’ll be able to write a `for` loop that handles most items in a
    list one way but handles certain items with specific values in a different way.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何编写条件测试，以检查你感兴趣的任何条件。你将学会编写简单的 `if` 语句，还将学习如何创建更复杂的 `if` 语句系列，以识别出你需要的确切条件。然后，你将把这个概念应用到列表中，这样你就能够编写一个
    `for` 循环，以一种方式处理列表中的大多数项，但以另一种方式处理具有特定值的某些项。
- en: A Simple Example
  id: totrans-707
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个简单的例子
- en: 'The following example shows how `if` tests let you respond to special situations
    correctly. Imagine you have a list of cars and you want to print out the name
    of each car. Car names are proper names, so the names of most cars should be printed
    in title case. However, the value `''bmw''` should be printed in all uppercase.
    The following code loops through a list of car names and looks for the value `''bmw''`.
    Whenever the value is `''bmw''`, it’s printed in uppercase instead of title case:'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了 `if` 测试如何让你正确地响应特殊情况。假设你有一个汽车名称的列表，你想打印出每辆车的名字。汽车名字是专有名词，因此大多数车的名字应该以标题格式打印。然而，`'bmw'`
    的值应该以全大写形式打印。以下代码会遍历汽车名称列表，查找值为 `'bmw'` 的项。每当遇到 `'bmw'` 时，它就会以大写形式打印，而不是标题格式：
- en: '**cars.py**'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: '**cars.py**'
- en: '[PRE172]'
  id: totrans-710
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'The loop in this example first checks if the current value of `car` is `''bmw''`
    ❶. If it is, the value is printed in uppercase. If the value of `car` is anything
    other than `''bmw''`, it’s printed in title case:'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例中的循环首先检查 `car` 的当前值是否为 `'bmw'` ❶。如果是，它将值以大写形式打印。如果 `car` 的值不是 `'bmw'`，它将以标题格式打印：
- en: '[PRE173]'
  id: totrans-712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: This example combines a number of the concepts you’ll learn about in this chapter.
    Let’s begin by looking at the kinds of tests you can use to examine the conditions
    in your program.
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例结合了你将在本章中学习的多个概念。让我们先看看你可以用来检查程序中条件的各种测试。
- en: Conditional Tests
  id: totrans-714
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 条件测试
- en: At the heart of every `if` statement is an expression that can be evaluated
    as `True` or `False` and is called a *conditional test*. Python uses the values
    `True` and `False` to decide whether the code in an `if` statement should be executed.
    If a conditional test evaluates to `True`, Python executes the code following
    the `if` statement. If the test evaluates to `False`, Python ignores the code
    following the `if` statement.
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`if`语句的核心是一个可以被评估为`True`或`False`的表达式，这被称为*条件测试*。Python使用`True`和`False`的值来决定是否执行`if`语句中的代码。如果条件测试评估为`True`，Python就会执行`if`语句后的代码。如果测试评估为`False`，Python则会忽略`if`语句后的代码。
- en: Checking for Equality
  id: totrans-716
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查相等性
- en: 'Most conditional tests compare the current value of a variable to a specific
    value of interest. The simplest conditional test checks whether the value of a
    variable is equal to the value of interest:'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数条件测试将一个变量的当前值与一个特定的目标值进行比较。最简单的条件测试检查一个变量的值是否等于目标值：
- en: '[PRE174]'
  id: totrans-718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: The first line sets the value of `car` to `'bmw'` using a single equal sign,
    as you’ve seen many times already. The next line checks whether the value of `car`
    is `'bmw'` by using a double equal sign (`==`). This *equality operator* returns
    `True` if the values on the left and right side of the operator match, and `False`
    if they don’t match. The values in this example match, so Python returns `True`.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行使用单等号将`car`的值设置为`'bmw'`，你已经看到了很多次。接下来的一行使用双等号(`==`)检查`car`的值是否为`'bmw'`。这个*相等运算符*如果左右两边的值相同，则返回`True`，如果不同，则返回`False`。在这个例子中，两个值是匹配的，所以Python返回`True`。
- en: 'When the value of `car` is anything other than `''bmw''`, this test returns
    `False`:'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 当`car`的值不是`'bmw'`时，这个测试返回`False`：
- en: '[PRE175]'
  id: totrans-721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: 'A single equal sign is really a statement; you might read the first line of
    code here as “Set the value of `car` equal to `''audi''`.” On the other hand,
    a double equal sign asks a question: “Is the value of `car` equal to `''bmw''`?”
    Most programming languages use equal signs in this way.'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 一个等号实际上是一个赋值语句；你可以把这里的第一行代码读作“将`car`的值设置为`'audi'`。”另一方面，双等号是在问一个问题：“`car`的值是否等于`'bmw'`？”大多数编程语言都以这种方式使用等号。
- en: Ignoring Case When Checking for Equality
  id: totrans-723
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查相等性时忽略大小写
- en: 'Testing for equality is case sensitive in Python. For example, two values with
    different capitalization are not considered equal:'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，检查相等性是区分大小写的。例如，两个大小写不同的值不会被认为是相等的：
- en: '[PRE176]'
  id: totrans-725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'If case matters, this behavior is advantageous. But if case doesn’t matter
    and instead you just want to test the value of a variable, you can convert the
    variable’s value to lowercase before doing the comparison:'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 如果大小写很重要，这种行为是有利的。但是，如果大小写不重要，而你只想测试变量的值，可以在进行比较之前将变量的值转换为小写：
- en: '[PRE177]'
  id: totrans-727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'This test will return `True` no matter how the value `''Audi''` is formatted
    because the test is now case insensitive. The `lower()` method doesn’t change
    the value that was originally stored in `car`, so you can do this kind of comparison
    without affecting the original variable:'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试会返回`True`，无论`'Audi'`的格式如何，因为现在测试是大小写不敏感的。`lower()`方法不会改变最初存储在`car`中的值，因此你可以在不影响原始变量的情况下进行这种比较：
- en: '[PRE178]'
  id: totrans-729
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: We first assign the capitalized string `'Audi'` to the variable `car`. Then,
    we convert the value of `car` to lowercase and compare the lowercase value to
    the string `'audi'`. The two strings match, so Python returns `True`. We can see
    that the value stored in `car` has not been affected by the `lower()` method.
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将大写字符串`'Audi'`赋值给变量`car`。然后，我们将`car`的值转换为小写，并将小写值与字符串`'audi'`进行比较。两个字符串匹配，所以Python返回`True`。我们可以看到，存储在`car`中的值没有受到`lower()`方法的影响。
- en: Websites enforce certain rules for the data that users enter in a manner similar
    to this. For example, a site might use a conditional test like this to ensure
    that every user has a truly unique username, not just a variation on the capitalization
    of another person’s username. When someone submits a new username, that new username
    is converted to lowercase and compared to the lowercase versions of all existing
    usernames. During this check, a username like `'John'` will be rejected if any
    variation of `'john'` is already in use.
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 网站会像这样强制执行用户输入数据的某些规则。例如，一个网站可能会使用类似的条件测试来确保每个用户都有一个真正唯一的用户名，而不仅仅是另一个人用户名的大小写变化。当有人提交一个新用户名时，这个新用户名会被转换为小写，并与所有现有用户名的小写版本进行比较。在这个检查过程中，如果`'John'`的任何变体（如`'john'`）已经被使用，新的用户名将被拒绝。
- en: Checking for Inequality
  id: totrans-732
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查不相等性
- en: 'When you want to determine whether two values are not equal, you can use the
    *inequality operator* (`!=`). Let’s use another `if` statement to examine how
    to use the inequality operator. We’ll store a requested pizza topping in a variable
    and then print a message if the person did not order anchovies:'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想确定两个值是否不相等时，可以使用*不等运算符*（`!=`）。我们再用一个`if`语句来演示如何使用不等运算符。我们将把请求的披萨配料存储在一个变量中，然后如果这个人没有点凤尾鱼，就打印一条消息：
- en: '**toppings.py**'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: '**toppings.py**'
- en: '[PRE179]'
  id: totrans-735
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: This code compares the value of `requested_topping` to the value `'anchovies'`.
    If these two values do not match, Python returns `True` and executes the code
    following the `if` statement. If the two values match, Python returns `False`
    and does not run the code following the `if` statement.
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将`requested_topping`的值与`'anchovies'`进行比较。如果这两个值不匹配，Python返回`True`并执行`if`语句后的代码。如果两个值匹配，Python返回`False`，并且不会执行`if`语句后的代码。
- en: 'Because the value of `requested_topping` is not `''anchovies''`, the `print()`
    function is executed:'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`requested_topping`的值不是`'anchovies'`，因此执行了`print()`函数：
- en: '[PRE180]'
  id: totrans-738
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: Most of the conditional expressions you write will test for equality, but sometimes
    you’ll find it more efficient to test for inequality.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 你编写的大多数条件表达式都会测试相等性，但有时你会发现测试不等式更高效。
- en: Numerical Comparisons
  id: totrans-740
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数值比较
- en: 'Testing numerical values is pretty straightforward. For example, the following
    code checks whether a person is 18 years old:'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 测试数值是相当简单的。例如，下面的代码检查一个人是否已经18岁：
- en: '[PRE181]'
  id: totrans-742
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'You can also test to see if two numbers are not equal. For example, the following
    code prints a message if the given answer is not correct:'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以测试两个数字是否不相等。例如，下面的代码如果给定的答案不正确，就会打印一条消息：
- en: '**magic_number.py**'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: '**magic_number.py**'
- en: '[PRE182]'
  id: totrans-745
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'The conditional test passes, because the value of `answer` (`17`) is not equal
    to `42`. Because the test passes, the indented code block is executed:'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 条件测试通过，因为`answer`（`17`）的值不等于`42`。由于测试通过，缩进的代码块被执行：
- en: '[PRE183]'
  id: totrans-747
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'You can include various mathematical comparisons in your conditional statements
    as well, such as less than, less than or equal to, greater than, and greater than
    or equal to:'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在条件语句中包含各种数学比较，例如小于、小于或等于、大于、大于或等于：
- en: '[PRE184]'
  id: totrans-749
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: Each mathematical comparison can be used as part of an `if` statement, which
    can help you detect the exact conditions of interest.
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 每个数学比较都可以作为`if`语句的一部分，这有助于你检测感兴趣的具体条件。
- en: Checking Multiple Conditions
  id: totrans-751
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查多个条件
- en: You may want to check multiple conditions at the same time. For example, sometimes
    you might need two conditions to be `True` to take an action. Other times, you
    might be satisfied with just one condition being `True`. The keywords `and` and
    `or` can help you in these situations.
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望同时检查多个条件。例如，有时你可能需要两个条件都为`True`才能采取某个动作。其他时候，你可能只需要一个条件为`True`就满足了。`and`和`or`关键字可以在这些情况下帮到你。
- en: Using and to Check Multiple Conditions
  id: totrans-753
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用`and`检查多个条件
- en: To check whether two conditions are both `True` simultaneously, use the keyword
    `and` to combine the two conditional tests; if each test passes, the overall expression
    evaluates to `True`. If either test fails or if both tests fail, the expression
    evaluates to `False`.
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查两个条件是否同时都为`True`，可以使用`and`关键字将两个条件测试结合起来；如果每个测试都通过，整体表达式就为`True`。如果任何一个测试失败，或者两个测试都失败，表达式就为`False`。
- en: 'For example, you can check whether two people are both over 21 by using the
    following test:'
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以使用以下测试来检查两个人是否都超过21岁：
- en: '[PRE185]'
  id: totrans-756
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: First, we define two ages, `age_0` and `age_1`. Then we check whether both ages
    are 21 or older ❶. The test on the left passes, but the test on the right fails,
    so the overall conditional expression evaluates to `False`. We then change `age_1`
    to 22 ❷. The value of `age_1` is now greater than 21, so both individual tests
    pass, causing the overall conditional expression to evaluate as `True`.
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义两个年龄，`age_0`和`age_1`。然后我们检查这两个年龄是否都大于或等于21岁❶。左边的测试通过了，但右边的测试失败了，因此整个条件表达式的结果为`False`。然后我们将`age_1`改为22❷。`age_1`的值现在大于21，因此两个单独的测试都通过了，导致整个条件表达式的结果为`True`。
- en: 'To improve readability, you can use parentheses around the individual tests,
    but they are not required. If you use parentheses, your test would look like this:'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高可读性，你可以在单独的测试条件周围使用括号，但这不是必需的。如果使用括号，测试将像这样：
- en: '[PRE186]'
  id: totrans-759
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: Using or to Check Multiple Conditions
  id: totrans-760
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用`or`检查多个条件
- en: The keyword `or` allows you to check multiple conditions as well, but it passes
    when either or both of the individual tests pass. An `or` expression fails only
    when both individual tests fail.
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字 `or` 允许你检查多个条件，但只要其中一个或两个测试通过，它就会通过。`or` 表达式只有在两个测试都失败时才会失败。
- en: 'Let’s consider two ages again, but this time we’ll look for only one person
    to be over 21:'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次考虑两个年龄，但这次我们只关注是否有一个人超过 21 岁：
- en: '[PRE187]'
  id: totrans-763
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: We start with two age variables again. Because the test for `age_0` ❶ passes,
    the overall expression evaluates to `True`. We then lower `age_0` to 18\. In the
    final test ❷, both tests now fail and the overall expression evaluates to `False`.
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次开始使用两个年龄变量。由于对 `age_0` ❶ 的测试通过，整个表达式评估为 `True`。然后我们将 `age_0` 降到 18。在最后的测试
    ❷ 中，两个测试都失败，整个表达式评估为 `False`。
- en: Checking Whether a Value Is in a List
  id: totrans-765
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查值是否在列表中
- en: Sometimes it’s important to check whether a list contains a certain value before
    taking an action. For example, you might want to check whether a new username
    already exists in a list of current usernames before completing someone’s registration
    on a website. In a mapping project, you might want to check whether a submitted
    location already exists in a list of known locations.
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在执行某个操作之前，检查列表是否包含某个值很重要。例如，在完成某人注册之前，你可能想检查一个新的用户名是否已经存在于当前的用户名列表中。在一个制图项目中，你可能想检查一个提交的地点是否已经存在于已知地点列表中。
- en: To find out whether a particular value is already in a list, use the keyword
    `in`. Let’s consider some code you might write for a pizzeria. We’ll make a list
    of toppings a customer has requested for a pizza and then check whether certain
    toppings are in the list.
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查某个特定值是否已经在列表中，可以使用关键字 `in`。让我们考虑一些你可能为披萨店编写的代码。我们将创建一个顾客请求的披萨配料列表，然后检查某些配料是否在该列表中。
- en: '[PRE188]'
  id: totrans-768
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: The keyword `in` tells Python to check for the existence of `'mushrooms'` and
    `'pepperoni'` in the list `requested_toppings`. This technique is quite powerful
    because you can create a list of essential values, and then easily check whether
    the value you’re testing matches one of the values in the list.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字 `in` 告诉 Python 检查 `'mushrooms'` 和 `'pepperoni'` 是否存在于列表 `requested_toppings`
    中。这种技术非常强大，因为你可以创建一个包含基本值的列表，然后轻松检查你正在测试的值是否与列表中的某个值匹配。
- en: Checking Whether a Value Is Not in a List
  id: totrans-770
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查值是否不在列表中
- en: 'Other times, it’s important to know if a value does not appear in a list. You
    can use the keyword `not` in this situation. For example, consider a list of users
    who are banned from commenting in a forum. You can check whether a user has been
    banned before allowing that person to submit a comment:'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，了解某个值是否不存在于列表中也很重要。在这种情况下，你可以使用关键字 `not`。例如，考虑一个在论坛中被禁止评论的用户列表。你可以在允许用户提交评论之前，检查该用户是否已被禁止：
- en: '**banned_users.py**'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: '**banned_users.py**'
- en: '[PRE189]'
  id: totrans-773
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: The `if` statement here reads quite clearly. If the value of `user` is not in
    the list `banned_users`, Python returns `True` and executes the indented line.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的 `if` 语句很清晰。如果 `user` 的值不在 `banned_users` 列表中，Python 返回 `True` 并执行缩进的语句。
- en: 'The user `''marie''` is not in the list `banned_users`, so she sees a message
    inviting her to post a response:'
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 用户 `'marie'` 不在 `banned_users` 列表中，因此她会看到一条邀请她发布回应的消息：
- en: '[PRE190]'
  id: totrans-776
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: Boolean Expressions
  id: totrans-777
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 布尔表达式
- en: As you learn more about programming, you’ll hear the term *Boolean expression*
    at some point. A Boolean expression is just another name for a conditional test.
    A *Boolean value* is either `True` or `False`, just like the value of a conditional
    expression after it has been evaluated.
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 当你进一步学习编程时，你会在某个时刻听到 *布尔表达式* 这个术语。布尔表达式就是条件测试的另一种说法。*布尔值* 只有 `True` 或 `False`，就像条件表达式在评估后的值一样。
- en: 'Boolean values are often used to keep track of certain conditions, such as
    whether a game is running or whether a user can edit certain content on a website:'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值常用于跟踪某些条件，例如游戏是否正在运行，或用户是否可以编辑网站上的某些内容：
- en: '[PRE191]'
  id: totrans-780
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: Boolean values provide an efficient way to track the state of a program or a
    particular condition that is important in your program.
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值提供了一种高效的方式来跟踪程序的状态或程序中某个重要条件的状态。
- en: if Statements
  id: totrans-782
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: if 语句
- en: When you understand conditional tests, you can start writing `if` statements.
    Several different kinds of `if` statements exist, and your choice of which to
    use depends on the number of conditions you need to test. You saw several examples
    of `if` statements in the discussion about conditional tests, but now let’s dig
    deeper into the topic.
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 当你理解了条件测试后，你可以开始编写 `if` 语句。存在几种不同类型的 `if` 语句，你选择使用哪种类型取决于你需要测试的条件数量。在关于条件测试的讨论中，你已经看到了几个
    `if` 语句的例子，现在让我们更深入地探讨这个话题。
- en: Simple if Statements
  id: totrans-784
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简单的 if 语句
- en: 'The simplest kind of `if` statement has one test and one action:'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的 `if` 语句类型有一个测试和一个操作：
- en: '[PRE192]'
  id: totrans-786
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: You can put any conditional test in the first line and just about any action
    in the indented block following the test. If the conditional test evaluates to
    `True`, Python executes the code following the `if` statement. If the test evaluates
    to `False`, Python ignores the code following the `if` statement.
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在第一行中放置任何条件测试，并且在测试后面的缩进块中放置几乎任何操作。如果条件测试的结果为 `True`，Python 将执行 `if` 语句后的代码。如果测试结果为
    `False`，Python 会忽略 `if` 语句后的代码。
- en: 'Let’s say we have a variable representing a person’s age, and we want to know
    if that person is old enough to vote. The following code tests whether the person
    can vote:'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个表示某人年龄的变量，我们想知道这个人是否足够大，可以投票。以下代码测试该人是否可以投票：
- en: '**voting.py**'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: '**voting.py**'
- en: '[PRE193]'
  id: totrans-790
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: 'Python checks to see whether the value of `age` is greater than or equal to
    18\. It is, so Python executes the indented `print()` call:'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: Python 检查 `age` 的值是否大于或等于 18。它是成立的，因此 Python 执行缩进的 `print()` 调用：
- en: '[PRE194]'
  id: totrans-792
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: Indentation plays the same role in `if` statements as it did in `for` loops.
    All indented lines after an `if` statement will be executed if the test passes,
    and the entire block of indented lines will be ignored if the test does not pass.
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 缩进在 `if` 语句中的作用与在 `for` 循环中相同。`if` 语句后的所有缩进行将会在测试通过时执行，如果测试不通过，则整个缩进块会被忽略。
- en: 'You can have as many lines of code as you want in the block following the `if`
    statement. Let’s add another line of output if the person is old enough to vote,
    asking if the individual has registered to vote yet:'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 `if` 语句后的块中放置任意多行代码。如果该人足够大，可以投票，我们可以添加另一行输出，询问该人是否已经注册投票：
- en: '[PRE195]'
  id: totrans-795
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: 'The conditional test passes, and both `print()` calls are indented, so both
    lines are printed:'
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 条件测试通过，且两个 `print()` 调用都已缩进，因此两行都被打印出来：
- en: '[PRE196]'
  id: totrans-797
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: If the value of `age` is less than 18, this program would produce no output.
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `age` 的值小于 18，则此程序将不会产生任何输出。
- en: if-else Statements
  id: totrans-799
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: if-else 语句
- en: Often, you’ll want to take one action when a conditional test passes and a different
    action in all other cases. Python’s `if`-`else` syntax makes this possible. An
    `if`-`else` block is similar to a simple `if` statement, but the `else` statement
    allows you to define an action or set of actions that are executed when the conditional
    test fails.
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你希望在条件测试通过时执行某个操作，在所有其他情况下执行不同的操作。Python 的 `if`-`else` 语法使得这一点成为可能。`if`-`else`
    块类似于简单的 `if` 语句，但 `else` 语句允许你定义在条件测试失败时执行的操作或操作集。
- en: 'We’ll display the same message we had previously if the person is old enough
    to vote, but this time we’ll add a message for anyone who is not old enough to
    vote:'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个人足够大可以投票，我们将显示与之前相同的消息，但这次我们还会为那些不够大不能投票的人添加一条消息：
- en: '[PRE197]'
  id: totrans-802
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: 'If the conditional test ❶ passes, the first block of indented `print()` calls
    is executed. If the test evaluates to `False`, the `else` block ❷ is executed.
    Because `age` is less than 18 this time, the conditional test fails and the code
    in the `else` block is executed:'
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 如果条件测试 ❶ 通过，则执行第一个缩进的 `print()` 调用块。如果测试结果为 `False`，则执行 `else` 块 ❷。因为这次 `age`
    小于 18，条件测试失败，执行 `else` 块中的代码：
- en: '[PRE198]'
  id: totrans-804
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: 'This code works because it has only two possible situations to evaluate: a
    person is either old enough to vote or not old enough to vote. The `if`-`else`
    structure works well in situations in which you want Python to always execute
    one of two possible actions. In a simple `if-else` chain like this, one of the
    two actions will always be executed.'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码有效，因为它只有两种可能的情况：一个人要么足够大可以投票，要么不够大不能投票。`if`-`else` 结构在你希望 Python 总是执行两种可能操作之一的情况下工作得很好。在像这样的简单
    `if-else` 链中，总会执行两种操作中的一种。
- en: The if-elif-else Chain
  id: totrans-806
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: if-elif-else 链
- en: Often, you’ll need to test more than two possible situations, and to evaluate
    these you can use Python’s `if`-`elif`-`else` syntax. Python executes only one
    block in an `if`-`elif`-`else` chain. It runs each conditional test in order,
    until one passes. When a test passes, the code following that test is executed
    and Python skips the rest of the tests.
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你需要测试两个以上的可能情况，而要评估这些情况，你可以使用Python的`if`-`elif`-`else`语法。Python只会在`if`-`elif`-`else`链中执行一个代码块。它按顺序运行每个条件测试，直到某个测试通过。当某个测试通过时，紧跟着该测试的代码会被执行，然后Python会跳过其余的测试。
- en: 'Many real-world situations involve more than two possible conditions. For example,
    consider an amusement park that charges different rates for different age groups:'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 许多现实世界的情况涉及两个以上的可能条件。例如，考虑一个根据不同年龄段收取不同费用的游乐园：
- en: Admission for anyone under age 4 is free.
  id: totrans-809
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何未满4岁的人可以免费入场。
- en: Admission for anyone between the ages of 4 and 18 is $25.
  id: totrans-810
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何4岁至18岁之间的人入场费用为$25。
- en: Admission for anyone age 18 or older is $40.
  id: totrans-811
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何18岁或以上的人入场费用为$40。
- en: 'How can we use an `if` statement to determine a person’s admission rate? The
    following code tests for the age group of a person and then prints an admission
    price message:'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何使用`if`语句来确定一个人的入场费用？以下代码测试一个人的年龄段，然后打印入场价格消息：
- en: '**amusement_park.py**'
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: '**amusement_park.py**'
- en: '[PRE199]'
  id: totrans-814
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: The `if` test ❶ checks whether a person is under 4 years old. When the test
    passes, an appropriate message is printed and Python skips the rest of the tests.
    The `elif` line ❷ is really another `if` test, which runs only if the previous
    test failed. At this point in the chain, we know the person is at least 4 years
    old because the first test failed. If the person is under 18, an appropriate message
    is printed and Python skips the `else` block. If both the `if` and `elif` tests
    fail, Python runs the code in the `else` block ❸.
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`测试❶检查一个人是否未满4岁。当测试通过时，会打印相应的消息，Python跳过剩余的测试。`elif`行❷实际上是另一个`if`测试，只有在前一个测试失败时才会执行。在链中的这一点，我们知道这个人至少4岁，因为第一个测试失败了。如果这个人未满18岁，会打印相应的消息，Python跳过`else`块。如果`if`和`elif`测试都失败，Python会执行`else`块中的代码❸。'
- en: 'In this example the `if` test ❶ evaluates to `False`, so its code block is
    not executed. However, the `elif` test evaluates to `True` (12 is less than 18)
    so its code is executed. The output is one sentence, informing the user of the
    admission cost:'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`if`测试❶的结果为`False`，因此它的代码块没有被执行。然而，`elif`测试的结果为`True`（12小于18），因此它的代码被执行。输出是一个句子，通知用户入场费用：
- en: '[PRE200]'
  id: totrans-817
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: Any age greater than 17 would cause the first two tests to fail. In these situations,
    the `else` block would be executed and the admission price would be $40.
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 任何大于17岁的年龄都会导致前两个测试失败。在这些情况下，`else`块会被执行，入场费用为$40。
- en: 'Rather than printing the admission price within the `if`-`elif`-`else` block,
    it would be more concise to set just the price inside the `if`-`elif`-`else` chain
    and then have a single `print()` call that runs after the chain has been evaluated:'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 与其在`if`-`elif`-`else`块中打印入场价格，不如在`if`-`elif`-`else`链中仅设置价格，然后在链评估后执行一个单独的`print()`调用，这样更简洁：
- en: '[PRE201]'
  id: totrans-820
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: The indented lines set the value of `price` according to the person’s age, as
    in the previous example. After the price is set by the `if`-`elif`-`else` chain,
    a separate unindented `print()` call uses this value to display a message reporting
    the person’s admission price.
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 缩进的行根据人的年龄设置`price`的值，就像前一个示例一样。在`if`-`elif`-`else`链设置了价格后，一个独立的未缩进的`print()`调用使用这个值来显示一条消息，报告这个人的入场价格。
- en: This code produces the same output as the previous example, but the purpose
    of the `if`-`elif`-`else` chain is narrower. Instead of determining a price and
    displaying a message, it simply determines the admission price. In addition to
    being more efficient, this revised code is easier to modify than the original
    approach. To change the text of the output message, you would need to change only
    one `print()` call rather than three separate `print()` calls.
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码产生与前一个示例相同的输出，但`if`-`elif`-`else`链的作用更窄。它不是用来确定价格并显示消息，而是简单地确定入场价格。除了更高效外，修改后的代码也比原始方法更容易修改。如果要更改输出消息的文本，只需要修改一个`print()`调用，而不是三个单独的`print()`调用。
- en: Using Multiple elif Blocks
  id: totrans-823
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用多个`elif`块
- en: 'You can use as many `elif` blocks in your code as you like. For example, if
    the amusement park were to implement a discount for seniors, you could add one
    more conditional test to the code to determine whether someone qualifies for the
    senior discount. Let’s say that anyone 65 or older pays half the regular admission,
    or $20:'
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在代码中使用任意多个`elif`块。例如，如果游乐园实施了老年人折扣，你可以在代码中添加一个条件测试来确定某人是否符合老年人折扣的条件。假设65岁或以上的人只需支付常规入场费的一半，即20美元：
- en: '[PRE202]'
  id: totrans-825
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: Most of this code is unchanged. The second `elif` block now checks to make sure
    a person is less than age 65 before assigning them the full admission rate of
    $40\. Notice that the value assigned in the `else` block needs to be changed to
    $20, because the only ages that make it to this block are for people 65 or older.
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的大部分内容保持不变。第二个`elif`块现在会检查确保一个人的年龄小于65岁，然后才会将其分配为40美元的全额入场费。请注意，`else`块中分配的值需要改为20美元，因为只有年龄在65岁及以上的人才会进入这个块。
- en: Omitting the else Block
  id: totrans-827
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 忽略`else`块
- en: 'Python does not require an `else` block at the end of an `if`-`elif` chain.
    Sometimes, an `else` block is useful. Other times, it’s clearer to use an additional
    `elif` statement that catches the specific condition of interest:'
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: Python并不要求在`if`-`elif`链的末尾必须有`else`块。有时，`else`块是有用的。其他时候，使用额外的`elif`语句来捕获感兴趣的特定条件会更清晰：
- en: '[PRE203]'
  id: totrans-829
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: The final `elif` block assigns a price of $20 when the person is 65 or older,
    which is a little clearer than the general `else` block. With this change, every
    block of code must pass a specific test in order to be executed.
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的`elif`块在一个人65岁或以上时分配20美元的价格，这比一般的`else`块更清晰。通过这个变化，每一块代码必须通过一个特定的测试才能执行。
- en: The `else` block is a catchall statement. It matches any condition that wasn’t
    matched by a specific `if` or `elif` test, and that can sometimes include invalid
    or even malicious data. If you have a specific final condition you’re testing
    for, consider using a final `elif` block and omit the `else` block. As a result,
    you’ll be more confident that your code will run only under the correct conditions.
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: '`else`块是一个兜底语句。它匹配任何没有被特定`if`或`elif`测试匹配的条件，这有时可能包括无效或甚至恶意的数据。如果你有一个具体的最终条件要测试，可以考虑使用最后一个`elif`块，并省略`else`块。这样，你会更有信心代码只会在正确的条件下运行。'
- en: Testing Multiple Conditions
  id: totrans-832
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试多个条件
- en: The `if`-`elif`-`else` chain is powerful, but it’s only appropriate to use when
    you just need one test to pass. As soon as Python finds one test that passes,
    it skips the rest of the tests. This behavior is beneficial, because it’s efficient
    and allows you to test for one specific condition.
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`-`elif`-`else`链非常强大，但仅在你只需要通过一个测试时才适合使用。一旦Python找到一个通过的测试，它就会跳过剩下的测试。这种行为是有益的，因为它高效，并且允许你仅测试一个特定的条件。'
- en: However, sometimes it’s important to check all conditions of interest. In this
    case, you should use a series of simple `if` statements with no `elif` or `else`
    blocks. This technique makes sense when more than one condition could be `True`,
    and you want to act on every condition that is `True`.
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时检查所有感兴趣的条件是很重要的。在这种情况下，你应该使用一系列简单的`if`语句，而不使用`elif`或`else`块。当多个条件可能为`True`时，这种技术很有意义，并且你希望对每个为`True`的条件做出响应。
- en: 'Let’s reconsider the pizzeria example. If someone requests a two-topping pizza,
    you’ll need to be sure to include both toppings on their pizza:'
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新考虑披萨店的例子。如果有人请求一个双配料的披萨，你需要确保披萨上有两个配料：
- en: '**toppings.py**'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: '**toppings.py**'
- en: '[PRE204]'
  id: totrans-837
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: We start with a list containing the requested toppings. The first `if` statement
    checks to see whether the person requested mushrooms on their pizza. If so, a
    message is printed confirming that topping. The test for pepperoni ❶ is another
    simple `if` statement, not an `elif` or `else` statement, so this test is run
    regardless of whether the previous test passed or not. The last `if` statement
    checks whether extra cheese was requested, regardless of the results from the
    first two tests. These three independent tests are executed every time this program
    is run.
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个包含请求的配料的列表开始。第一个`if`语句检查这个人是否请求了蘑菇。如果是这样，则打印一条消息确认这个配料。辣香肠的测试❶是另一个简单的`if`语句，而不是`elif`或`else`语句，因此无论前面的测试是否通过，这个测试都会被执行。最后一个`if`语句检查是否请求了额外的奶酪，无论前两个测试的结果如何。这三个独立的测试每次运行这个程序时都会执行。
- en: 'Because every condition in this example is evaluated, both mushrooms and extra
    cheese are added to the pizza:'
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 因为在这个例子中每个条件都会被评估，所以蘑菇和额外的奶酪都会被添加到披萨上：
- en: '[PRE205]'
  id: totrans-840
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: 'This code would not work properly if we used an `if`-`elif`-`else` block, because
    the code would stop running after only one test passes. Here’s what that would
    look like:'
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`if`-`elif`-`else`块，这段代码将无法正常工作，因为代码在只有一个测试通过后就会停止运行。下面是它的样子：
- en: '[PRE206]'
  id: totrans-842
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: 'The test for `''mushrooms''` is the first test to pass, so mushrooms are added
    to the pizza. However, the values `''extra cheese''` and `''pepperoni''` are never
    checked, because Python doesn’t run any tests beyond the first test that passes
    in an `if-elif-else` chain. The customer’s first topping will be added, but all
    of their other toppings will be missed:'
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: 对`'mushrooms'`的测试是第一个通过的测试，所以蘑菇被添加到比萨上。然而，值`'extra cheese'`和`'pepperoni'`永远不会被检查，因为在`if-elif-else`链中，Python不会运行通过的第一个测试后的任何其他测试。顾客的第一个配料会被添加，但所有其他配料都会被遗漏：
- en: '[PRE207]'
  id: totrans-844
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: In summary, if you want only one block of code to run, use an `if`-`elif`-`else`
    chain. If more than one block of code needs to run, use a series of independent
    `if` statements.
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，如果你希望只有一个代码块运行，使用`if`-`elif`-`else`链。如果需要多个代码块运行，使用一系列独立的`if`语句。
- en: Using if Statements with Lists
  id: totrans-846
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在列表中使用`if`语句
- en: You can do some interesting work when you combine lists and `if` statements.
    You can watch for special values that need to be treated differently than other
    values in the list. You can efficiently manage changing conditions, such as the
    availability of certain items in a restaurant throughout a shift. You can also
    begin to prove that your code works as you expect it to in all possible situations.
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将列表和`if`语句结合起来时，可以做一些有趣的工作。你可以观察需要与列表中其他值不同对待的特殊值。你可以有效地管理变化的条件，比如餐厅在一个班次中的某些物品的可用性。你还可以开始证明你的代码在所有可能的情况下都能按预期工作。
- en: Checking for Special Items
  id: totrans-848
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查特殊项
- en: This chapter began with a simple example that showed how to handle a special
    value like `'bmw'`, which needed to be printed in a different format than other
    values in the list. Now that you have a basic understanding of conditional tests
    and `if` statements, let’s take a closer look at how you can watch for special
    values in a list and handle those values appropriately.
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 本章开始时展示了一个简单的例子，演示了如何处理像`'bmw'`这样的特殊值，特别是它需要以不同于其他列表值的格式打印。现在你已经对条件测试和`if`语句有了基本的理解，我们来仔细看看如何在列表中检查特殊值并适当地处理这些值。
- en: 'Let’s continue with the pizzeria example. The pizzeria displays a message whenever
    a topping is added to your pizza, as it’s being made. The code for this action
    can be written very efficiently by making a list of toppings the customer has
    requested and using a loop to announce each topping as it’s added to the pizza:'
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续以比萨店的例子。每当在制作比萨时添加配料，比萨店会显示一条消息。这个操作的代码可以通过列出顾客请求的配料，并使用循环在每次配料添加到比萨上时宣布它，来高效地编写：
- en: '**toppings.py**'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: '**toppings.py**'
- en: '[PRE208]'
  id: totrans-852
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: 'The output is straightforward because this code is just a simple `for` loop:'
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是直观的，因为这段代码只是一个简单的`for`循环：
- en: '[PRE209]'
  id: totrans-854
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: 'But what if the pizzeria runs out of green peppers? An `if` statement inside
    the `for` loop can handle this situation appropriately:'
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 那如果比萨店没有绿椒了怎么办？`for`循环中的`if`语句可以适当地处理这种情况：
- en: '[PRE210]'
  id: totrans-856
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: This time, we check each requested item before adding it to the pizza. The `if`
    statement checks to see if the person requested green peppers. If so, we display
    a message informing them why they can’t have green peppers. The `else` block ensures
    that all other toppings will be added to the pizza.
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，在将配料添加到比萨之前，我们检查每个请求的项。`if`语句检查顾客是否请求了绿椒。如果是，我们会显示一条消息告知他们为什么不能要绿椒。`else`块确保所有其他配料都将添加到比萨上。
- en: The output shows that each requested topping is handled appropriately.
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示每个请求的配料都得到了适当的处理。
- en: '[PRE211]'
  id: totrans-859
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: Checking That a List Is Not Empty
  id: totrans-860
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查列表是否为空
- en: 'We’ve made a simple assumption about every list we’ve worked with so far: we’ve
    assumed that each list has at least one item in it. Soon we’ll let users provide
    the information that’s stored in a list, so we won’t be able to assume that a
    list has any items in it each time a loop is run. In this situation, it’s useful
    to check whether a list is empty before running a `for` loop.'
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们对每个使用过的列表做了一个简单的假设：我们假设每个列表至少有一个项目。很快，我们将允许用户提供存储在列表中的信息，因此每次运行循环时，我们不能假设列表中有任何项目。在这种情况下，在运行`for`循环之前检查列表是否为空是很有用的。
- en: 'As an example, let’s check whether the list of requested toppings is empty
    before building the pizza. If the list is empty, we’ll prompt the user and make
    sure they want a plain pizza. If the list is not empty, we’ll build the pizza
    just as we did in the previous examples:'
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例，让我们在制作披萨之前检查请求的配料列表是否为空。如果列表为空，我们将提示用户并确认他们是否想要一份普通披萨。如果列表不为空，我们将像之前的示例一样制作披萨：
- en: '[PRE212]'
  id: totrans-863
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: This time we start out with an empty list of requested toppings. Instead of
    jumping right into a `for` loop, we do a quick check first. When the name of a
    list is used in an `if` statement, Python returns `True` if the list contains
    at least one item; an empty list evaluates to `False`. If `requested_toppings`
    passes the conditional test, we run the same `for` loop we used in the previous
    example. If the conditional test fails, we print a message asking the customer
    if they really want a plain pizza with no toppings.
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们从一个空的请求配料列表开始。我们没有直接进入 `for` 循环，而是先做一个快速检查。当列表的名称在 `if` 语句中使用时，如果列表包含至少一个项，Python
    会返回 `True`；如果是空列表，则返回 `False`。如果 `requested_toppings` 通过条件测试，我们就运行与前一个示例中相同的 `for`
    循环。如果条件测试失败，我们会打印一条消息，询问顾客是否真的想要没有配料的普通披萨。
- en: 'The list is empty in this case, so the output asks if the user really wants
    a plain pizza:'
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，列表为空，因此输出会询问用户是否真的想要一份普通披萨：
- en: '[PRE213]'
  id: totrans-866
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: If the list is not empty, the output will show each requested topping being
    added to the pizza.
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 如果列表不为空，输出将显示每个请求的配料被添加到披萨上。
- en: Using Multiple Lists
  id: totrans-868
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用多个列表
- en: People will ask for just about anything, especially when it comes to pizza toppings.
    What if a customer actually wants french fries on their pizza? You can use lists
    and `if` statements to make sure your input makes sense before you act on it.
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 人们对配料的请求几乎无所不包，特别是涉及披萨配料时。如果顾客真的想要在披萨上放薯条呢？你可以使用列表和 `if` 语句，确保在执行操作之前输入是合理的。
- en: 'Let’s watch out for unusual topping requests before we build a pizza. The following
    example defines two lists. The first is a list of available toppings at the pizzeria,
    and the second is the list of toppings that the user has requested. This time,
    each item in `requested_toppings` is checked against the list of available toppings
    before it’s added to the pizza:'
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: 在制作披萨之前，让我们留意一些不寻常的配料请求。以下示例定义了两个列表。第一个是披萨店提供的配料列表，第二个是用户请求的配料列表。这一次，`requested_toppings`
    中的每个项在添加到披萨之前都会与可用配料列表进行检查：
- en: '[PRE214]'
  id: totrans-871
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: 'First, we define a list of available toppings at this pizzeria. Note that this
    could be a tuple if the pizzeria has a stable selection of toppings. Then, we
    make a list of toppings that a customer has requested. There’s an unusual request
    for a topping in this example: `''french fries''` ❶. Next we loop through the
    list of requested toppings. Inside the loop, we check to see if each requested
    topping is actually in the list of available toppings ❷. If it is, we add that
    topping to the pizza. If the requested topping is not in the list of available
    toppings, the `else` block will run ❸. The `else` block prints a message telling
    the user which toppings are unavailable.'
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义了这家披萨店提供的配料列表。请注意，如果披萨店提供稳定的配料选择，这个可以是一个元组。然后，我们创建了一个客户请求的配料列表。在这个示例中，有一个不寻常的配料请求：`'french
    fries'` ❶。接下来，我们遍历请求的配料列表。在循环内，我们检查每个请求的配料是否实际上在可用配料列表中 ❷。如果有，我们就将该配料添加到披萨上。如果请求的配料不在可用配料列表中，`else`
    块将执行 ❸。`else` 块会打印一条消息，告诉用户哪些配料不可用。
- en: 'This code syntax produces clean, informative output:'
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码语法产生了干净且富有信息的输出：
- en: '[PRE215]'
  id: totrans-874
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: In just a few lines of code, we’ve managed a real-world situation pretty effectively!
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 仅凭几行代码，我们就有效地处理了一个现实世界中的情况！
- en: Styling Your if Statements
  id: totrans-876
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 给你的 `if` 语句添加样式
- en: 'In every example in this chapter, you’ve seen good styling habits. The only
    recommendation PEP 8 provides for styling conditional tests is to use a single
    space around comparison operators, such as `==`, `>=`, and `<=`. For example:'
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的每个示例中，你都看到了良好的样式习惯。PEP 8 对条件测试样式的唯一建议是，在比较运算符（如 `==`、`>=` 和 `<=`）周围使用单个空格。例如：
- en: '[PRE216]'
  id: totrans-878
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: 'is better than:'
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: 比下面这种写法更好：
- en: '[PRE217]'
  id: totrans-880
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: Such spacing does not affect the way Python interprets your code; it just makes
    your code easier for you and others to read.
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的空格不会影响 Python 解释代码的方式；它只是让你的代码更容易阅读，无论是你自己还是其他人。
- en: Summary
  id: totrans-882
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter you learned how to write conditional tests, which always evaluate
    to `True` or `False`. You learned to write simple `if` statements, `if`-`else`
    chains, and `if`-`elif`-`else` chains. You began using these structures to identify
    particular conditions you need to test and to know when those conditions have
    been met in your programs. You learned to handle certain items in a list differently
    than all other items while continuing to utilize the efficiency of a `for` loop.
    You also revisited Python’s style recommendations to ensure that your increasingly
    complex programs are still relatively easy to read and understand.
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何编写条件测试，这些测试总是返回`True`或`False`。你学习了如何编写简单的`if`语句、`if`-`else`链式结构以及`if`-`elif`-`else`链式结构。你开始使用这些结构来识别你需要测试的特定条件，并知道在你的程序中何时满足这些条件。你学会了如何在列表中处理某些项目与其他项目不同，同时继续利用`for`循环的高效性。你还重新回顾了Python的编码风格建议，以确保你日益复杂的程序仍然相对容易阅读和理解。
- en: In Chapter 6 you’ll learn about Python’s dictionaries. A dictionary is similar
    to a list, but it allows you to connect pieces of information. You’ll learn how
    to build dictionaries, loop through them, and use them in combination with lists
    and `if` statements. Learning about dictionaries will enable you to model an even
    wider variety of real-world situations.
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: 在第6章中，你将了解Python的字典。字典类似于列表，但它允许你将信息片段连接在一起。你将学习如何构建字典、遍历字典，并将它们与列表和`if`语句结合使用。学习字典将使你能够建模更广泛的现实世界情况。
- en: '6'
  id: totrans-885
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Dictionaries
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: 字典
- en: '![](Images/chapterart.png)'
  id: totrans-887
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: In this chapter you’ll learn how to use Python’s dictionaries, which allow you
    to connect pieces of related information. You’ll learn how to access the information
    once it’s in a dictionary and how to modify that information. Because dictionaries
    can store an almost limitless amount of information, I’ll show you how to loop
    through the data in a dictionary. Additionally, you’ll learn to nest dictionaries
    inside lists, lists inside dictionaries, and even dictionaries inside other dictionaries.
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何使用Python的字典，它们允许你将相关信息连接在一起。你将学习如何访问存储在字典中的信息，并如何修改这些信息。由于字典可以存储几乎无限量的信息，我将向你展示如何遍历字典中的数据。此外，你将学习如何将字典嵌套在列表中，将列表嵌套在字典中，甚至将字典嵌套在其他字典中。
- en: Understanding dictionaries allows you to model a variety of real-world objects
    more accurately. You’ll be able to create a dictionary representing a person and
    then store as much information as you want about that person. You can store their
    name, age, location, profession, and any other aspect of a person you can describe.
    You’ll be able to store any two kinds of information that can be matched up, such
    as a list of words and their meanings, a list of people’s names and their favorite
    numbers, a list of mountains and their elevations, and so forth.
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: 理解字典可以让你更准确地建模各种现实世界中的对象。你可以创建一个字典来表示一个人，并存储关于这个人的所有信息。你可以存储他们的名字、年龄、地点、职业以及任何你能描述的关于这个人的其他方面。你将能够存储任何两种可以配对的信息，比如单词及其意思、人的名字和他们的最爱数字、山脉及其海拔等等。
- en: A Simple Dictionary
  id: totrans-890
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个简单的字典
- en: 'Consider a game featuring aliens that can have different colors and point values.
    This simple dictionary stores information about a particular alien:'
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个包含外星人的游戏，外星人可以具有不同的颜色和点数。这个简单的字典存储了一个特定外星人的信息：
- en: '**alien.py**'
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: '**alien.py**'
- en: '[PRE218]'
  id: totrans-893
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: 'The dictionary `alien_0` stores the alien’s color and point value. The last
    two lines access and display that information, as shown here:'
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 字典`alien_0`存储了外星人的颜色和点数。最后两行访问并显示了这些信息，如下所示：
- en: '[PRE219]'
  id: totrans-895
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: As with most new programming concepts, using dictionaries takes practice. Once
    you’ve worked with dictionaries for a bit, you’ll see how effectively they can
    model real-world situations.
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数新的编程概念一样，使用字典需要练习。一旦你使用字典一段时间后，你会发现它们在建模现实世界情况方面是多么高效。
- en: Working with Dictionaries
  id: totrans-897
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用字典
- en: A *dictionary* in Python is a collection of *key-value pairs*. Each *key* is
    connected to a value, and you can use a key to access the value associated with
    that key. A key’s value can be a number, a string, a list, or even another dictionary.
    In fact, you can use any object that you can create in Python as a value in a
    dictionary.
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，*字典*是一种由*键-值对*组成的集合。每个*键*与一个值相连，你可以使用键来访问与该键关联的值。一个键的值可以是一个数字、一个字符串、一个列表，甚至是另一个字典。实际上，你可以使用Python中可以创建的任何对象作为字典中的值。
- en: 'In Python, a dictionary is wrapped in braces (`{}`) with a series of key-value
    pairs inside the braces, as shown in the earlier example:'
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，字典是用大括号`{}`包裹的，里面包含一系列键值对，如之前的示例所示：
- en: '[PRE220]'
  id: totrans-900
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: A *key-value pair* is a set of values associated with each other. When you provide
    a key, Python returns the value associated with that key. Every key is connected
    to its value by a colon, and individual key-value pairs are separated by commas.
    You can store as many key-value pairs as you want in a dictionary.
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: '*键值对*是一组相互关联的值。当你提供一个键时，Python会返回与该键相关联的值。每个键通过冒号与其值连接，单独的键值对通过逗号分隔。你可以在字典中存储任意数量的键值对。'
- en: 'The simplest dictionary has exactly one key-value pair, as shown in this modified
    version of the `alien_0` dictionary:'
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的字典只有一个键值对，如下所示，这是修改后的`alien_0`字典版本：
- en: '[PRE221]'
  id: totrans-903
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: 'This dictionary stores one piece of information about `alien_0`: the alien’s
    color. The string `''color''` is a key in this dictionary, and its associated
    value is `''green''`.'
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: 这个字典存储了关于`alien_0`的一条信息：外星人的颜色。字符串`'color'`是字典中的一个键，而与之关联的值是`'green'`。
- en: Accessing Values in a Dictionary
  id: totrans-905
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问字典中的值
- en: 'To get the value associated with a key, give the name of the dictionary and
    then place the key inside a set of square brackets, as shown here:'
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取与键相关联的值，给出字典的名称，然后将键放在一对方括号内，如下所示：
- en: '**alien.py**'
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: '**alien.py**'
- en: '[PRE222]'
  id: totrans-908
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: 'This returns the value associated with the key `''color''` from the dictionary
    `alien_0`:'
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回字典`alien_0`中与键`'color'`关联的值：
- en: '[PRE223]'
  id: totrans-910
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: 'You can have an unlimited number of key-value pairs in a dictionary. For example,
    here’s the original `alien_0` dictionary with two key-value pairs:'
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在字典中拥有无限数量的键值对。例如，这里是原始的`alien_0`字典，包含两个键值对：
- en: '[PRE224]'
  id: totrans-912
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: 'Now you can access either the color or the point value of `alien_0`. If a player
    shoots down this alien, you can look up how many points they should earn using
    code like this:'
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以访问`alien_0`的颜色或积分值。如果玩家击败了这个外星人，你可以使用如下代码查找他们应该获得多少积分：
- en: '[PRE225]'
  id: totrans-914
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: 'Once the dictionary has been defined, we pull the value associated with the
    key `''points''` from the dictionary. This value is then assigned to the variable
    `new_points`. The last line prints a statement about how many points the player
    just earned:'
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦字典被定义，我们就从字典中提取与键`'points'`相关联的值。然后将这个值赋给变量`new_points`。最后一行打印出玩家刚刚获得的积分：
- en: '[PRE226]'
  id: totrans-916
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: If you run this code every time an alien is shot down, the alien’s point value
    will be retrieved.
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你每次击败外星人时都运行这段代码，外星人的积分值将会被检索出来。
- en: Adding New Key-Value Pairs
  id: totrans-918
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加新键值对
- en: Dictionaries are dynamic structures, and you can add new key-value pairs to
    a dictionary at any time. To add a new key-value pair, you would give the name
    of the dictionary followed by the new key in square brackets, along with the new
    value.
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: 字典是动态结构，你可以随时向字典添加新的键值对。要添加新的键值对，你只需给出字典的名称，后跟新键的方括号，并指定新值。
- en: 'Let’s add two new pieces of information to the `alien_0` dictionary: the alien’s
    *x*- and *y*-coordinates, which will help us display the alien at a particular
    position on the screen. Let’s place the alien on the left edge of the screen,
    25 pixels down from the top. Because screen coordinates usually start at the upper-left
    corner of the screen, we’ll place the alien on the left edge of the screen by
    setting the *x*-coordinate to 0 and 25 pixels from the top by setting its *y*-coordinate
    to positive 25, as shown here:'
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们向`alien_0`字典添加两个新的信息：外星人的*x*坐标和*y*坐标，这将帮助我们在屏幕上的特定位置显示外星人。我们将外星人放置在屏幕的左边缘，距离顶部25像素。由于屏幕坐标通常从屏幕的左上角开始，我们通过将*x*坐标设置为0来把外星人放在屏幕的左边缘，并通过将*y*坐标设置为正25来把它放置在距离顶部25像素的位置，如下所示：
- en: '**alien.py**'
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: '**alien.py**'
- en: '[PRE227]'
  id: totrans-922
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: 'We start by defining the same dictionary that we’ve been working with. We then
    print this dictionary, displaying a snapshot of its information. Next, we add
    a new key-value pair to the dictionary: the key `''x_position''` and the value
    `0`. We do the same for the key `''y_position''`. When we print the modified dictionary,
    we see the two additional key-value pairs:'
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义与之前相同的字典，然后打印这个字典，展示其信息快照。接下来，我们向字典中添加一个新的键值对：键`'x_position'`和值`0`。我们对键`'y_position'`做同样的操作。当我们打印修改后的字典时，我们看到这两个新增的键值对：
- en: '[PRE228]'
  id: totrans-924
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: The final version of the dictionary contains four key-value pairs. The original
    two specify color and point value, and two more specify the alien’s position.
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: 字典的最终版本包含四个键值对。原来的两个指定了颜色和得分值，再加上两个指定了外星人位置的键值对。
- en: Dictionaries retain the order in which they were defined. When you print a dictionary
    or loop through its elements, you will see the elements in the same order they
    were added to the dictionary.
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: 字典会保留定义时的顺序。当你打印字典或遍历其元素时，你会看到元素按添加到字典的顺序出现。
- en: Starting with an Empty Dictionary
  id: totrans-927
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从一个空字典开始
- en: 'It’s sometimes convenient, or even necessary, to start with an empty dictionary
    and then add each new item to it. To start filling an empty dictionary, define
    a dictionary with an empty set of braces and then add each key-value pair on its
    own line. For example, here’s how to build the `alien_0` dictionary using this
    approach:'
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，开始时使用一个空字典，然后再逐个添加新的项是方便的，甚至是必要的。要开始填充一个空字典，定义一个空的大括号字典，然后将每个键值对单独添加在每一行。例如，以下是如何使用这种方法构建`alien_0`字典：
- en: '**alien.py**'
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: '**alien.py**'
- en: '[PRE229]'
  id: totrans-930
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: 'We first define an empty `alien_0` dictionary, and then add color and point
    values to it. The result is the dictionary we’ve been using in previous examples:'
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义一个空的`alien_0`字典，然后向其中添加颜色和得分值。结果是我们在之前示例中使用的字典：
- en: '[PRE230]'
  id: totrans-932
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: Typically, you’ll use empty dictionaries when storing user-supplied data in
    a dictionary or when writing code that generates a large number of key-value pairs
    automatically.
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在存储用户提供的数据时，或者在编写生成大量键值对的代码时，你会使用空字典。
- en: Modifying Values in a Dictionary
  id: totrans-934
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改字典中的值
- en: 'To modify a value in a dictionary, give the name of the dictionary with the
    key in square brackets and then the new value you want associated with that key.
    For example, consider an alien that changes from green to yellow as a game progresses:'
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: 要修改字典中的值，给出字典的名称并用方括号括住键，然后指定你希望与该键关联的新值。例如，考虑一个外星人，在游戏进程中从绿色变为黄色：
- en: '**alien.py**'
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: '**alien.py**'
- en: '[PRE231]'
  id: totrans-937
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: 'We first define a dictionary for `alien_0` that contains only the alien’s color;
    then we change the value associated with the key `''color''` to `''yellow''`.
    The output shows that the alien has indeed changed from green to yellow:'
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义一个仅包含外星人颜色的`alien_0`字典；然后我们将与`'color'`键关联的值更改为`'yellow'`。输出显示外星人确实从绿色变成了黄色：
- en: '[PRE232]'
  id: totrans-939
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: 'For a more interesting example, let’s track the position of an alien that can
    move at different speeds. We’ll store a value representing the alien’s current
    speed and then use it to determine how far to the right the alien should move:'
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个更有趣的例子，让我们跟踪一个可以以不同速度移动的外星人。我们将存储一个表示外星人当前速度的值，然后用它来决定外星人应该向右移动多远：
- en: '[PRE233]'
  id: totrans-941
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: We start by defining an alien with an initial *x* position and *y* position,
    and a speed of `'medium'`. We’ve omitted the color and point values for the sake
    of simplicity, but this example would work the same way if you included those
    key-value pairs as well. We also print the original value of `x_position` to see
    how far the alien moves to the right.
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义一个外星人，初始的*x*位置和*y*位置为`'medium'`速度。为了简化，我们省略了颜色和得分值，但如果你包括这些键值对，示例仍然适用。我们还打印了`x_position`的原始值，看看外星人向右移动了多少。
- en: An `if`-`elif`-`else` chain determines how far the alien should move to the
    right, and assigns this value to the variable `x_increment` ❶. If the alien’s
    speed is `'slow'`, it moves one unit to the right; if the speed is `'medium'`,
    it moves two units to the right; and if it’s `'fast'`, it moves three units to
    the right. Once the increment has been calculated, it’s added to the value of
    `x_position` ❷, and the result is stored in the dictionary’s `x_position`.
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`if`-`elif`-`else`链决定外星人应该向右移动多远，并将这个值赋给变量`x_increment` ❶。如果外星人的速度是`'slow'`，它向右移动一个单位；如果速度是`'medium'`，它向右移动两个单位；如果是`'fast'`，它向右移动三个单位。计算出增量后，它会加到`x_position`
    ❷的值上，并将结果存储在字典的`x_position`中。
- en: 'Because this is a medium-speed alien, its position shifts two units to the
    right:'
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个中等速度的外星人，它的位置向右移动了两个单位：
- en: '[PRE234]'
  id: totrans-945
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: 'This technique is pretty cool: by changing one value in the alien’s dictionary,
    you can change the overall behavior of the alien. For example, to turn this medium-speed
    alien into a fast alien, you would add this line:'
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: 这个技巧非常酷：通过改变外星人字典中的一个值，你可以改变外星人的整体行为。例如，要将这个中等速度的外星人变成一个快速的外星人，你需要添加这一行：
- en: '[PRE235]'
  id: totrans-947
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: The `if`-`elif`-`else` block would then assign a larger value to `x_increment`
    the next time the code runs.
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`-`elif`-`else` 代码块将在下一次代码运行时将更大的值分配给 `x_increment`。'
- en: Removing Key-Value Pairs
  id: totrans-949
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除键值对
- en: When you no longer need a piece of information that’s stored in a dictionary,
    you can use the `del` statement to completely remove a key-value pair. All `del`
    needs is the name of the dictionary and the key that you want to remove.
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: 当你不再需要字典中存储的信息时，可以使用 `del` 语句完全删除一个键值对。`del` 只需要字典的名称和你想要删除的键。
- en: 'For example, let’s remove the key `''points''` from the `alien_0` dictionary,
    along with its value:'
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们从 `alien_0` 字典中删除键 `'points'`，以及它的值：
- en: '**alien.py**'
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: '**alien.py**'
- en: '[PRE236]'
  id: totrans-953
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: 'The `del` statement ❶ tells Python to delete the key `''points''` from the
    dictionary `alien_0` and to remove the value associated with that key as well.
    The output shows that the key `''points''` and its value of `5` are deleted from
    the dictionary, but the rest of the dictionary is unaffected:'
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: '`del` 语句❶告诉 Python 删除字典 `alien_0` 中的键 `''points''`，并移除与该键关联的值。输出显示，键 `''points''`
    和其值 `5` 被从字典中删除，但字典中的其他部分没有受到影响：'
- en: '[PRE237]'
  id: totrans-955
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: A Dictionary of Similar Objects
  id: totrans-956
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 相似对象的字典
- en: 'The previous example involved storing different kinds of information about
    one object, an alien in a game. You can also use a dictionary to store one kind
    of information about many objects. For example, say you want to poll a number
    of people and ask them what their favorite programming language is. A dictionary
    is useful for storing the results of a simple poll, like this:'
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个示例涉及存储关于一个对象（游戏中的外星人）的不同信息。你还可以使用字典存储关于许多对象的一种信息。例如，假设你想对一些人进行调查，询问他们最喜欢的编程语言是什么。字典非常适合存储这种简单调查的结果，如下所示：
- en: '**favorite_languages.py**'
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: '**favorite_languages.py**'
- en: '[PRE238]'
  id: totrans-959
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: As you can see, we’ve broken a larger dictionary into several lines. Each key
    is the name of a person who responded to the poll, and each value is their language
    choice. When you know you’ll need more than one line to define a dictionary, press
    ENTER after the opening brace. Then indent the next line one level (four spaces)
    and write the first key-value pair, followed by a comma. From this point forward
    when you press ENTER, your text editor should automatically indent all subsequent
    key-value pairs to match the first key-value pair.
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们将一个较大的字典分成了几行。每个键都是参与调查的人的名字，每个值是他们选择的语言。当你知道定义字典时需要多行时，按 ENTER 键后，输入一个新的左大括号。接着将下一行缩进一个级别（四个空格），然后写入第一个键值对，后面跟着一个逗号。从此以后，每次按
    ENTER 键时，你的文本编辑器应自动缩进所有后续的键值对，以匹配第一个键值对。
- en: Once you’ve finished defining the dictionary, add a closing brace on a new line
    after the last key-value pair, and indent it one level so it aligns with the keys
    in the dictionary. It’s good practice to include a comma after the last key-value
    pair as well, so you’re ready to add a new key-value pair on the next line.
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你完成了字典的定义，在最后一个键值对后添加一个闭括号，并在新的一行上进行缩进，使其与字典中的键对齐。将逗号添加到最后一个键值对后也是一个好习惯，这样你就可以在下一行准备添加新的键值对。
- en: 'To use this dictionary, given the name of a person who took the poll, you can
    easily look up their favorite language:'
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用这个字典，给定一个参与调查的人的名字，你可以轻松查找他们最喜欢的编程语言：
- en: '**favorite_languages.py**'
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: '**favorite_languages.py**'
- en: '[PRE239]'
  id: totrans-964
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: 'To see which language Sarah chose, we ask for the value at:'
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看 Sarah 选择了哪种语言，我们请求该值：
- en: '[PRE240]'
  id: totrans-966
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: 'We use this syntax to pull Sarah’s favorite language from the dictionary ❶
    and assign it to the variable `language`. Creating a new variable here makes for
    a much cleaner `print()` call. The output shows Sarah’s favorite language:'
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用这种语法从字典❶中提取 Sarah 最喜欢的编程语言，并将其赋值给变量 `language`。创建一个新的变量使得 `print()` 调用更加简洁。输出显示了
    Sarah 最喜欢的编程语言：
- en: '[PRE241]'
  id: totrans-968
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: You could use this same syntax with any individual represented in the dictionary.
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用相同的语法与字典中的任何单个对象。
- en: Using get() to Access Values
  id: totrans-970
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 get() 访问值
- en: 'Using keys in square brackets to retrieve the value you’re interested in from
    a dictionary might cause one potential problem: if the key you ask for doesn’t
    exist, you’ll get an error.'
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方括号中的键从字典中检索你感兴趣的值可能会导致一个潜在的问题：如果你请求的键不存在，你将得到一个错误。
- en: 'Let’s see what happens when you ask for the point value of an alien that doesn’t
    have a point value set:'
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当你请求一个没有设置点数值的外星人的点数值时会发生什么：
- en: '**alien_no_points.py**'
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: '**alien_no_points.py**'
- en: '[PRE242]'
  id: totrans-974
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: 'This results in a traceback, showing a `KeyError`:'
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: 这会导致一个追溯错误，显示一个 `KeyError`：
- en: '[PRE243]'
  id: totrans-976
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: You’ll learn more about how to handle errors like this in general in Chapter
    10. For dictionaries specifically, you can use the `get()` method to set a default
    value that will be returned if the requested key doesn’t exist.
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在第10章中了解如何处理类似的错误。针对字典，你可以使用`get()`方法来设置一个默认值，当请求的键不存在时，返回该默认值。
- en: 'The `get()` method requires a key as a first argument. As a second optional
    argument, you can pass the value to be returned if the key doesn’t exist:'
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: '`get()`方法需要一个键作为第一个参数。作为第二个可选参数，你可以传递一个当键不存在时返回的默认值：'
- en: '[PRE244]'
  id: totrans-979
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: 'If the key `''points''` exists in the dictionary, you’ll get the corresponding
    value. If it doesn’t, you get the default value. In this case, `points` doesn’t
    exist, and we get a clean message instead of an error:'
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字典中存在键`'points'`，你将得到对应的值。如果不存在，则会返回默认值。在这种情况下，`points`不存在，我们得到的是一个干净的消息，而不是错误：
- en: '[PRE245]'
  id: totrans-981
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: If there’s a chance the key you’re asking for might not exist, consider using
    the `get()` method instead of the square bracket notation.
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你请求的键可能不存在，考虑使用`get()`方法，而不是方括号表示法。
- en: Looping Through a Dictionary
  id: totrans-983
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遍历字典
- en: A single Python dictionary can contain just a few key-value pairs or millions
    of pairs. Because a dictionary can contain large amounts of data, Python lets
    you loop through a dictionary. Dictionaries can be used to store information in
    a variety of ways; therefore, several different ways exist to loop through them.
    You can loop through all of a dictionary’s key-value pairs, through its keys,
    or through its values.
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Python字典可以包含少量的键值对，也可以包含数百万个键值对。由于字典可以存储大量数据，Python允许你遍历字典。字典可以用多种方式存储信息，因此也有多种方式可以遍历它们。你可以遍历字典的所有键值对、遍历它的键，或者遍历它的值。
- en: Looping Through All Key-Value Pairs
  id: totrans-985
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遍历所有键值对
- en: 'Before we explore the different approaches to looping, let’s consider a new
    dictionary designed to store information about a user on a website. The following
    dictionary would store one person’s username, first name, and last name:'
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探索不同的遍历方法之前，让我们考虑一个新的字典，用来存储网站上某个用户的信息。以下字典将存储一个人的用户名、名字和姓氏：
- en: '**user.py**'
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: '**user.py**'
- en: '[PRE246]'
  id: totrans-988
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: 'You can access any single piece of information about `user_0` based on what
    you’ve already learned in this chapter. But what if you wanted to see everything
    stored in this user’s dictionary? To do so, you could loop through the dictionary
    using a `for` loop:'
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: 基于你在本章中学到的知识，你可以访问`user_0`的任何信息。但是，如果你想查看该用户字典中存储的所有内容怎么办？你可以使用`for`循环遍历字典：
- en: '[PRE247]'
  id: totrans-990
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: 'To write a `for` loop for a dictionary, you create names for the two variables
    that will hold the key and value in each key-value pair. You can choose any names
    you want for these two variables. This code would work just as well if you had
    used abbreviations for the variable names, like this:'
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: 要为字典编写`for`循环，你需要为每一对键值对创建两个变量名，用于存储键和值。你可以为这两个变量选择任何你喜欢的名字。如果你使用缩写作为变量名，代码依然能够正常工作，例如：
- en: '[PRE248]'
  id: totrans-992
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: 'The second half of the `for` statement includes the name of the dictionary
    followed by the method `items()`, which returns a sequence of key-value pairs.
    The `for` loop then assigns each of these pairs to the two variables provided.
    In the preceding example, we use the variables to print each `key`, followed by
    the associated `value`. The `"\n"` in the first `print()` call ensures that a
    blank line is inserted before each key-value pair in the output:'
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`语句的第二部分包括字典的名称，后跟`items()`方法，该方法返回键值对的序列。然后，`for`循环将这些对分配给提供的两个变量。在前面的示例中，我们使用这些变量打印每个`key`，后跟相应的`value`。第一个`print()`调用中的`"\n"`确保在输出的每个键值对之前插入一个空行：'
- en: '[PRE249]'
  id: totrans-994
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: 'Looping through all key-value pairs works particularly well for dictionaries
    like the *favorite_languages.py* example on page 96, which stores the same kind
    of information for many different keys. If you loop through the `favorite_languages`
    dictionary, you get the name of each person in the dictionary and their favorite
    programming language. Because the keys always refer to a person’s name and the
    value is always a language, we’ll use the variables `name` and `language` in the
    loop instead of `key` and `value`. This will make it easier to follow what’s happening
    inside the loop:'
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历所有键值对在字典中尤其有效，比如第96页的*favorite_languages.py*示例，它存储了许多不同键的相同类型的信息。如果你遍历`favorite_languages`字典，你将得到字典中每个人的名字和他们最喜欢的编程语言。因为键总是指向一个人的名字，值总是指向一种语言，所以我们在循环中会使用变量`name`和`language`，而不是`key`和`value`。这样可以让你更容易理解循环内发生的事情：
- en: '**favorite_languages.py**'
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: '**favorite_languages.py**'
- en: '[PRE250]'
  id: totrans-997
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: This code tells Python to loop through each key-value pair in the dictionary.
    As it works through each pair the key is assigned to the variable `name`, and
    the value is assigned to the variable `language`. These descriptive names make
    it much easier to see what the `print()` call is doing.
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码告诉Python遍历字典中的每个键值对。它在处理每个键值对时，将键分配给变量`name`，将值分配给变量`language`。这些描述性的变量名使得你更容易理解`print()`语句在做什么。
- en: 'Now, in just a few lines of code, we can display all of the information from
    the poll:'
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，只需几行代码，我们就可以显示民意调查的所有信息：
- en: '[PRE251]'
  id: totrans-1000
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: This type of looping would work just as well if our dictionary stored the results
    from polling a thousand or even a million people.
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的字典存储了对一千人甚至一百万人的调查结果，这种类型的循环同样有效。
- en: Looping Through All the Keys in a Dictionary
  id: totrans-1002
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遍历字典中的所有键
- en: 'The `keys()` method is useful when you don’t need to work with all of the values
    in a dictionary. Let’s loop through the `favorite_languages` dictionary and print
    the names of everyone who took the poll:'
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: 当你不需要处理字典中的所有值时，`keys()`方法非常有用。让我们遍历`favorite_languages`字典，并打印出所有参与调查的人的名字：
- en: '[PRE252]'
  id: totrans-1004
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: 'This `for` loop tells Python to pull all the keys from the dictionary `favorite_languages`
    and assign them one at a time to the variable `name`. The output shows the names
    of everyone who took the poll:'
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`for`循环告诉Python从字典`favorite_languages`中提取所有的键，并一次性将它们分配给变量`name`。输出结果显示了所有参与调查的人的名字：
- en: '[PRE253]'
  id: totrans-1006
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: 'Looping through the keys is actually the default behavior when looping through
    a dictionary, so this code would have exactly the same output if you wrote:'
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历键实际上是默认的行为，因此，如果你写成：
- en: '[PRE254]'
  id: totrans-1008
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: 'rather than:'
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是：
- en: '[PRE255]'
  id: totrans-1010
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: You can choose to use the `keys()` method explicitly if it makes your code easier
    to read, or you can omit it if you wish.
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你觉得这样能让代码更易读，可以显式使用`keys()`方法，或者如果你愿意，也可以省略它。
- en: 'You can access the value associated with any key you care about inside the
    loop, by using the current key. Let’s print a message to a couple of friends about
    the languages they chose. We’ll loop through the names in the dictionary as we
    did previously, but when the name matches one of our friends, we’ll display a
    message about their favorite language:'
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在循环内通过当前的键来访问任何你关心的键值对的值。让我们打印一些朋友选择的编程语言的消息。我们将像之前那样遍历字典中的名字，但当名字与我们的朋友之一匹配时，我们将显示关于他们最喜欢的语言的消息：
- en: '[PRE256]'
  id: totrans-1013
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: First, we make a list of friends that we want to print a message to. Inside
    the loop, we print each person’s name. Then we check whether the `name` we’re
    working with is in the list `friends` ❶. If it is, we determine the person’s favorite
    language using the name of the dictionary and the current value of `name` as the
    key ❷. We then print a special greeting, including a reference to their language
    of choice.
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们列出一些朋友的名字，准备给他们打印一条消息。在循环中，我们打印每个人的名字。然后，我们检查当前正在处理的`name`是否在`friends`列表中❶。如果在，我们使用字典的名字和当前`name`的值作为键来确定这个人最喜欢的语言❷。接着，我们打印一条特别的问候语，包含他们选择的编程语言。
- en: 'Everyone’s name is printed, but our friends receive a special message:'
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: 每个人的名字都会被打印出来，但我们的朋友们会收到一条特别的消息：
- en: '[PRE257]'
  id: totrans-1016
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: 'You can also use the `keys()` method to find out if a particular person was
    polled. This time, let’s find out if Erin took the poll:'
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用`keys()`方法来检查某个人是否参与了调查。这次，让我们来看看Erin是否参与了调查：
- en: '[PRE258]'
  id: totrans-1018
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: 'The `keys()` method isn’t just for looping: it actually returns a sequence
    of all the keys, and the `if` statement simply checks if `''erin''` is in this
    sequence. Because she’s not, a message is printed inviting her to take the poll:'
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: '`keys()` 方法不仅用于循环：它实际上返回所有键的序列，而 `if` 语句仅检查 `''erin''` 是否在这个序列中。因为她不在，所以打印出一条信息邀请她参与调查：'
- en: '[PRE259]'
  id: totrans-1020
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: Looping Through a Dictionary’s Keys in a Particular Order
  id: totrans-1021
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 按特定顺序遍历字典的键
- en: Looping through a dictionary returns the items in the same order they were inserted.
    Sometimes, though, you’ll want to loop through a dictionary in a different order.
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历字典时，返回的项与它们插入字典的顺序相同。不过，有时你可能希望以不同的顺序遍历字典。
- en: 'One way to do this is to sort the keys as they’re returned in the `for` loop.
    You can use the `sorted()` function to get a copy of the keys in order:'
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是在 `for` 循环中按返回的顺序对键进行排序。你可以使用 `sorted()` 函数来按顺序获取键的副本：
- en: '[PRE260]'
  id: totrans-1024
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: 'This `for` statement is like other `for` statements, except that we’ve wrapped
    the `sorted()` function around the `dictionary.keys()` method. This tells Python
    to get all the keys in the dictionary and sort them before starting the loop.
    The output shows everyone who took the poll, with the names displayed in order:'
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `for` 语句与其他 `for` 语句类似，唯一的区别是我们在 `dictionary.keys()` 方法周围包裹了 `sorted()` 函数。这告诉
    Python 获取字典中的所有键，并在开始循环之前将其排序。输出结果显示所有参与调查的人，名字按顺序排列：
- en: '[PRE261]'
  id: totrans-1026
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: Looping Through All Values in a Dictionary
  id: totrans-1027
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遍历字典中的所有值
- en: 'If you are primarily interested in the values that a dictionary contains, you
    can use the `values()` method to return a sequence of values without any keys.
    For example, say we simply want a list of all languages chosen in our programming
    language poll, without the name of the person who chose each language:'
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你主要对字典中包含的值感兴趣，可以使用 `values()` 方法返回一个值的序列，而不包含任何键。例如，假设我们只想要一个所有语言的列表，而不包含选择每种语言的人的名字：
- en: '[PRE262]'
  id: totrans-1029
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: 'The `for` statement here pulls each value from the dictionary and assigns it
    to the variable `language`. When these values are printed, we get a list of all
    chosen languages:'
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的 `for` 语句从字典中提取每个值，并将其分配给变量 `language`。当这些值被打印时，我们得到一个所有选择语言的列表：
- en: '[PRE263]'
  id: totrans-1031
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: 'This approach pulls all the values from the dictionary without checking for
    repeats. This might work fine with a small number of values, but in a poll with
    a large number of respondents, it would result in a very repetitive list. To see
    each language chosen without repetition, we can use a set. A *set* is a collection
    in which each item must be unique:'
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法从字典中提取所有值，而不检查是否有重复项。对于较少的值数量，这可能没问题，但如果是调查中有大量回应者时，结果会是一个非常重复的列表。为了查看每种语言而不重复，我们可以使用集合。*集合*
    是一个其中每个项必须唯一的集合：
- en: '[PRE264]'
  id: totrans-1033
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: When you wrap `set()` around a collection of values that contains duplicate
    items, Python identifies the unique items in the collection and builds a set from
    those items. Here we use `set()` to pull out the unique languages in `favorite_languages.values()`.
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将 `set()` 包裹在包含重复项的值集合周围时，Python 会识别集合中唯一的项，并根据这些项构建一个集合。这里我们使用 `set()` 从
    `favorite_languages.values()` 中提取唯一语言。
- en: 'The result is a nonrepetitive list of languages that have been mentioned by
    people taking the poll:'
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个没有重复项的语言列表，这些语言是参与调查的人提到的：
- en: '[PRE265]'
  id: totrans-1036
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: As you continue learning about Python, you’ll often find a built-in feature
    of the language that helps you do exactly what you want with your data.
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你继续学习 Python，你会经常发现语言内置的某个特性可以帮助你精确地处理数据。
- en: Nesting
  id: totrans-1038
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套
- en: Sometimes you’ll want to store multiple dictionaries in a list, or a list of
    items as a value in a dictionary. This is called *nesting*. You can nest dictionaries
    inside a list, a list of items inside a dictionary, or even a dictionary inside
    another dictionary. Nesting is a powerful feature, as the following examples will
    demonstrate.
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你可能需要将多个字典存储在一个列表中，或者将一个列表作为字典的值。这被称为 *嵌套*。你可以在列表中嵌套字典，在字典中嵌套项的列表，甚至将字典嵌套在另一个字典中。嵌套是一个强大的特性，接下来的示例将演示这一点。
- en: A List of Dictionaries
  id: totrans-1040
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字典的列表
- en: 'The `alien_0` dictionary contains a variety of information about one alien,
    but it has no room to store information about a second alien, much less a screen
    full of aliens. How can you manage a fleet of aliens? One way is to make a list
    of aliens in which each alien is a dictionary of information about that alien.
    For example, the following code builds a list of three aliens:'
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: '`alien_0`字典包含有关一个外星人的各种信息，但它没有空间存储第二个外星人的信息，更不用说一整屏外星人了。你如何管理一支外星人舰队呢？一种方法是创建一个外星人列表，其中每个外星人都是一个包含该外星人信息的字典。例如，以下代码构建了一个包含三个外星人的列表：'
- en: '**aliens.py**'
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: '**aliens.py**'
- en: '[PRE266]'
  id: totrans-1043
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: 'We first create three dictionaries, each representing a different alien. We
    store each of these dictionaries in a list called `aliens` ❶. Finally, we loop
    through the list and print out each alien:'
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建三个字典，每个字典代表一个不同的外星人。我们将这些字典存储在一个名为`aliens`的列表中❶。最后，我们遍历列表并打印出每个外星人：
- en: '[PRE267]'
  id: totrans-1045
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: 'A more realistic example would involve more than three aliens with code that
    automatically generates each alien. In the following example, we use `range()`
    to create a fleet of 30 aliens:'
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更现实的例子可能包含超过三个外星人，并且代码会自动生成每个外星人。在下面的示例中，我们使用`range()`来创建一个30个外星人的舰队：
- en: '[PRE268]'
  id: totrans-1047
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: 'This example begins with an empty list to hold all of the aliens that will
    be created. The `range()` function ❶ returns a series of numbers, which just tells
    Python how many times we want the loop to repeat. Each time the loop runs, we
    create a new alien ❷ and then append each new alien to the list `aliens` ❸. We
    use a slice to print the first five aliens ❹, and finally, we print the length
    of the list to prove we’ve actually generated the full fleet of 30 aliens:'
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例从一个空的列表开始，用来保存将要创建的所有外星人。`range()`函数❶返回一系列数字，它只是告诉Python我们希望循环重复多少次。每次循环运行时，我们创建一个新的外星人❷，然后将每个新的外星人追加到列表`aliens`中❸。我们使用切片打印前五个外星人❹，最后，我们打印列表的长度，以证明我们已经生成了完整的30个外星人的舰队：
- en: '[PRE269]'
  id: totrans-1049
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: These aliens all have the same characteristics, but Python considers each one
    a separate object, which allows us to modify each alien individually.
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: 这些外星人都有相同的特征，但Python将每个外星人视为一个独立的对象，这使得我们可以单独修改每个外星人。
- en: 'How might you work with a group of aliens like this? Imagine that one aspect
    of a game has some aliens changing color and moving faster as the game progresses.
    When it’s time to change colors, we can use a `for` loop and an `if` statement
    to change the color of the aliens. For example, to change the first three aliens
    to yellow, medium-speed aliens worth 10 points each, we could do this:'
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何处理这样一组外星人呢？假设游戏的某个环节中，外星人随着游戏的进展改变颜色并且移动得更快。当是时候改变颜色时，我们可以使用`for`循环和`if`语句来改变外星人的颜色。例如，为了将前三个外星人改为黄色的、中等速度的外星人，每个外星人值10分，我们可以这样做：
- en: '[PRE270]'
  id: totrans-1052
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: 'Because we want to modify the first three aliens, we loop through a slice that
    includes only the first three aliens. All of the aliens are green now, but that
    won’t always be the case, so we write an `if` statement to make sure we’re only
    modifying green aliens. If the alien is green, we change the color to `''yellow''`,
    the speed to `''medium''`, and the point value to `10`, as shown in the following
    output:'
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们想要修改前三个外星人，所以我们遍历一个只包含前三个外星人的切片。现在所有外星人都是绿色的，但并不总是这样，因此我们写一个`if`语句来确保只修改绿色外星人。如果外星人是绿色的，我们将其颜色改为`'yellow'`，速度改为`'medium'`，分值改为`10`，如下所示的输出：
- en: '[PRE271]'
  id: totrans-1054
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: 'You could expand this loop by adding an `elif` block that turns yellow aliens
    into red, fast-moving ones worth 15 points each. Without showing the entire program
    again, that loop would look like this:'
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过添加一个`elif`块来扩展这个循环，将黄色的外星人变成红色的、快速移动的外星人，每个外星人的分数为15分。省略完整程序的情况下，这个循环看起来像这样：
- en: '[PRE272]'
  id: totrans-1056
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: It’s common to store a number of dictionaries in a list when each dictionary
    contains many kinds of information about one object. For example, you might create
    a dictionary for each user on a website, as we did in *user.py* on page 99, and
    store the individual dictionaries in a list called `users`. All of the dictionaries
    in the list should have an identical structure, so you can loop through the list
    and work with each dictionary object in the same way.
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: 当每个字典包含关于一个对象的多种信息时，将多个字典存储在列表中是很常见的做法。例如，你可以为网站上的每个用户创建一个字典，就像我们在第99页的*user.py*中所做的那样，并将这些字典存储在一个名为`users`的列表中。列表中的所有字典应该具有相同的结构，这样你就可以遍历列表，并以相同的方式处理每个字典对象。
- en: A List in a Dictionary
  id: totrans-1058
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字典中的列表
- en: Rather than putting a dictionary inside a list, it’s sometimes useful to put
    a list inside a dictionary. For example, consider how you might describe a pizza
    that someone is ordering. If you were to use only a list, all you could really
    store is a list of the pizza’s toppings. With a dictionary, a list of toppings
    can be just one aspect of the pizza you’re describing.
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，将列表放入字典中比将字典放入列表中更为有用。例如，考虑一下如何描述一个人正在点的披萨。如果你只使用列表，实际上你只能存储披萨的配料列表。使用字典时，配料列表可以仅仅是你描述的披萨的一个方面。
- en: 'In the following example, two kinds of information are stored for each pizza:
    a type of crust and a list of toppings. The list of toppings is a value associated
    with the key `''toppings''`. To use the items in the list, we give the name of
    the dictionary and the key `''toppings''`, as we would any value in the dictionary.
    Instead of returning a single value, we get a list of toppings:'
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，每个披萨都存储了两种信息：一种是饼皮类型，另一种是配料列表。配料列表是与键 `'toppings'` 关联的值。为了使用列表中的项目，我们只需给出字典的名称和键
    `'toppings'`，就像访问字典中的任何值一样。返回的不是单个值，而是一个配料列表：
- en: '**pizza.py**'
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: '**pizza.py**'
- en: '[PRE273]'
  id: totrans-1062
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: We begin with a dictionary that holds information about a pizza that has been
    ordered. One key in the dictionary is `'crust'`, and the associated value is the
    string `'thick'`. The next key, `'toppings'`, has a list as its value that stores
    all requested toppings. We summarize the order before building the pizza ❶. When
    you need to break up a long line in a `print()` call, choose an appropriate point
    at which to break the line being printed, and end the line with a quotation mark.
    Indent the next line, add an opening quotation mark, and continue the string.
    Python will automatically combine all of the strings it finds inside the parentheses.
    To print the toppings, we write a `for` loop ❷. To access the list of toppings,
    we use the key `'toppings'`, and Python grabs the list of toppings from the dictionary.
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个字典开始，字典中包含已点披萨的信息。字典中的一个键是 `'crust'`，其对应的值是字符串 `'thick'`。下一个键 `'toppings'`
    的值是一个存储所有请求配料的列表。在制作披萨之前，我们先总结一下订单❶。当你需要在 `print()` 调用中拆分一行时，选择一个适当的位置拆分打印的行，并以引号结束该行。接下来缩进新的一行，添加开引号，并继续字符串。Python
    会自动将括号内的所有字符串组合在一起。为了打印配料，我们写一个 `for` 循环❷。要访问配料列表，我们使用键 `'toppings'`，然后 Python
    会从字典中获取配料列表。
- en: 'The following output summarizes the pizza that we plan to build:'
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出总结了我们计划制作的披萨：
- en: '[PRE274]'
  id: totrans-1065
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: 'You can nest a list inside a dictionary anytime you want more than one value
    to be associated with a single key in a dictionary. In the earlier example of
    favorite programming languages, if we were to store each person’s responses in
    a list, people could choose more than one favorite language. When we loop through
    the dictionary, the value associated with each person would be a list of languages
    rather than a single language. Inside the dictionary’s `for` loop, we use another
    `for` loop to run through the list of languages associated with each person:'
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以随时将列表嵌套在字典中，只要你希望将多个值与字典中的单个键相关联。在之前的最喜欢编程语言的示例中，如果我们将每个人的回答存储在一个列表中，那么人们可以选择多个最喜欢的语言。当我们遍历字典时，与每个人相关联的值将是一个语言列表，而不是单一的语言。在字典的
    `for` 循环内部，我们使用另一个 `for` 循环来遍历与每个人相关联的语言列表：
- en: '**favorite_languages.py**'
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: '**favorite_languages.py**'
- en: '[PRE275]'
  id: totrans-1068
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: 'The value associated with each name in `favorite_languages` is now a list.
    Note that some people have one favorite language and others have multiple favorites.
    When we loop through the dictionary ❶, we use the variable name `languages` to
    hold each value from the dictionary, because we know that each value will be a
    list. Inside the main dictionary loop, we use another `for` loop ❷ to run through
    each person’s list of favorite languages. Now each person can list as many favorite
    languages as they like:'
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`favorite_languages` 中每个名字所对应的值都是一个列表。注意，有些人只有一个最喜欢的语言，而有些人有多个最喜欢的语言。当我们遍历字典❶时，我们使用变量名
    `languages` 来存储字典中的每个值，因为我们知道每个值将是一个列表。在主字典循环内部，我们再用一个 `for` 循环❷来遍历每个人的最喜欢语言列表。现在，每个人都可以列出他们喜欢的多个编程语言：
- en: '[PRE276]'
  id: totrans-1070
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: To refine this program even further, you could include an `if` statement at
    the beginning of the dictionary’s `for` loop to see whether each person has more
    than one favorite language by examining the value of `len(languages)`. If a person
    has more than one favorite, the output would stay the same. If the person has
    only one favorite language, you could change the wording to reflect that. For
    example, you could say, “Sarah’s favorite language is C.”
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步优化这个程序，你可以在字典的`for`循环开始时加入一个`if`语句，检查每个人是否有多个喜欢的编程语言，方法是检查`len(languages)`的值。如果某人有多个喜欢的语言，输出保持不变。如果某人只有一个喜欢的语言，你可以修改措辞以反映这一点。例如，你可以说：“Sarah最喜欢的编程语言是C。”
- en: A Dictionary in a Dictionary
  id: totrans-1072
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字典中的字典
- en: 'You can nest a dictionary inside another dictionary, but your code can get
    complicated quickly when you do. For example, if you have several users for a
    website, each with a unique username, you can use the usernames as the keys in
    a dictionary. You can then store information about each user by using a dictionary
    as the value associated with their username. In the following listing, we store
    three pieces of information about each user: their first name, last name, and
    location. We’ll access this information by looping through the usernames and the
    dictionary of information associated with each username:'
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将一个字典嵌套在另一个字典中，但这样做时你的代码可能会迅速变得复杂。例如，如果你为一个网站拥有多个用户，每个用户都有一个唯一的用户名，你可以使用用户名作为字典中的键。然后，你可以使用字典作为与用户名相关联的值来存储每个用户的信息。在下面的代码中，我们存储了每个用户的三项信息：名字、姓氏和位置。我们将通过遍历用户名和与每个用户名相关联的字典来访问这些信息：
- en: '**many_users.py**'
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: '**many_users.py**'
- en: '[PRE277]'
  id: totrans-1075
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: 'We first define a dictionary called `users` with two keys: one each for the
    usernames `''aeinstein''` and `''mcurie''`. The value associated with each key
    is a dictionary that includes each user’s first name, last name, and location.
    Then, we loop through the `users` dictionary ❶. Python assigns each key to the
    variable `username`, and the dictionary associated with each username is assigned
    to the variable `user_info`. Once inside the main dictionary loop, we print the
    username ❷.'
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义一个名为`users`的字典，它包含两个键：分别对应用户名`'aeinstein'`和`'mcurie'`。与每个键关联的值是一个字典，包含每个用户的名字、姓氏和位置。接着，我们遍历`users`字典
    ❶。Python将每个键赋值给变量`username`，与每个用户名相关联的字典则赋值给变量`user_info`。进入主字典循环后，我们打印出用户名 ❷。
- en: 'Then, we start accessing the inner dictionary ❸. The variable `user_info`,
    which contains the dictionary of user information, has three keys: `''first''`,
    `''last''`, and `''location''`. We use each key to generate a neatly formatted
    full name and location for each person, and then print a summary of what we know
    about each user ❹:'
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们开始访问内层字典 ❸。包含用户信息的字典`user_info`有三个键：`'first'`、`'last'`和`'location'`。我们使用每个键来生成每个人整齐格式化的全名和位置，然后打印出我们对每个用户的总结
    ❹：
- en: '[PRE278]'
  id: totrans-1078
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: Notice that the structure of each user’s dictionary is identical. Although not
    required by Python, this structure makes nested dictionaries easier to work with.
    If each user’s dictionary had different keys, the code inside the `for` loop would
    be more complicated.
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，每个用户字典的结构是相同的。虽然Python没有强制要求这一点，但这种结构使得嵌套字典更容易操作。如果每个用户字典的键不同，`for`循环中的代码将更加复杂。
- en: Summary
  id: totrans-1080
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how to define a dictionary and how to work with
    the information stored in a dictionary. You learned how to access and modify individual
    elements in a dictionary, and how to loop through all of the information in a
    dictionary. You learned to loop through a dictionary’s key-value pairs, its keys,
    and its values. You also learned how to nest multiple dictionaries in a list,
    nest lists in a dictionary, and nest a dictionary inside a dictionary.
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何定义字典以及如何操作字典中存储的信息。你学习了如何访问和修改字典中的单个元素，以及如何遍历字典中的所有信息。你学会了如何遍历字典的键值对、键和值。你还学会了如何将多个字典嵌套在列表中，将列表嵌套在字典中，和将字典嵌套在字典中。
- en: 'In the next chapter you’ll learn about `while` loops and how to accept input
    from people who are using your programs. This will be an exciting chapter, because
    you’ll learn to make all of your programs interactive: they’ll be able to respond
    to user input.'
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，你将学习`while`循环以及如何接受使用你程序的人的输入。这将是一个令人兴奋的章节，因为你将学习如何让你的程序变得互动：它们将能够响应用户输入。
- en: '7'
  id: totrans-1083
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: User Input and while Loops
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: 用户输入与while循环
- en: '![](Images/chapterart.png)'
  id: totrans-1085
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: Most programs are written to solve an end user’s problem. To do so, you usually
    need to get some information from the user. For example, say someone wants to
    find out whether they’re old enough to vote. If you write a program to answer
    this question, you need to know the user’s age before you can provide an answer.
    The program will need to ask the user to enter, or *input*, their age; once the
    program has this input, it can compare it to the voting age to determine if the
    user is old enough and then report the result.
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数程序是为了解决最终用户的问题而编写的。为此，你通常需要从用户那里获取一些信息。例如，假设有人想知道自己是否足够老，可以投票。如果你编写一个程序来回答这个问题，你需要知道用户的年龄，才能给出答案。程序将要求用户输入或*提供*他们的年龄；一旦程序获得了这个输入，它就可以将其与投票年龄进行比较，以判断用户是否足够老，然后报告结果。
- en: In this chapter you’ll learn how to accept user input so your program can then
    work with it. When your program needs a name, you’ll be able to prompt the user
    for a name. When your program needs a list of names, you’ll be able to prompt
    the user for a series of names. To do this, you’ll use the `input()` function.
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你将学习如何接受用户输入，以便你的程序可以使用这些输入。当程序需要一个名字时，你可以提示用户输入名字。当程序需要一系列名字时，你也可以提示用户输入多个名字。为此，你将使用`input()`函数。
- en: You’ll also learn how to keep programs running as long as users want them to,
    so they can enter as much information as they need to; then, your program can
    work with that information. You’ll use Python’s `while` loop to keep programs
    running as long as certain conditions remain true.
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
  zh: 你还将学习如何让程序持续运行，直到用户希望它停止，这样他们可以输入所需的所有信息；然后，你的程序可以利用这些信息进行处理。你将使用Python的`while`循环来让程序在特定条件成立时持续运行。
- en: With the ability to work with user input and the ability to control how long
    your programs run, you’ll be able to write fully interactive programs.
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: 通过能够处理用户输入以及控制程序运行时间的能力，你将能够编写完全互动的程序。
- en: How the input() Function Works
  id: totrans-1090
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`input()`函数的工作原理'
- en: The `input()` function pauses your program and waits for the user to enter some
    text. Once Python receives the user’s input, it assigns that input to a variable
    to make it convenient for you to work with.
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: '`input()`函数会暂停程序并等待用户输入文本。一旦Python接收到用户的输入，它会将输入赋值给一个变量，以便你方便地使用它。'
- en: 'For example, the following program asks the user to enter some text, then displays
    that message back to the user:'
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，下面的程序会要求用户输入一些文本，然后将该消息显示给用户：
- en: '**parrot.py**'
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: '**parrot.py**'
- en: '[PRE279]'
  id: totrans-1094
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: 'The `input()` function takes one argument: the *prompt* that we want to display
    to the user, so they know what kind of information to enter. In this example,
    when Python runs the first line, the user sees the prompt `Tell me something,
    and I will repeat it back to you:` . The program waits while the user enters their
    response and continues after the user presses ENTER. The response is assigned
    to the variable `message`, then `print(message)` displays the input back to the
    user:'
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: '`input()`函数接受一个参数：*提示信息*，用于告诉用户需要输入什么类型的信息。在这个例子中，当Python运行第一行时，用户会看到提示信息`Tell
    me something, and I will repeat it back to you:`。程序在等待用户输入响应，用户按下回车键后，程序继续执行。响应被赋值给变量`message`，然后`print(message)`会将输入内容显示给用户：'
- en: '[PRE280]'
  id: totrans-1096
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: Writing Clear Prompts
  id: totrans-1097
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写清晰的提示信息
- en: 'Each time you use the `input()` function, you should include a clear, easy-to-follow
    prompt that tells the user exactly what kind of information you’re looking for.
    Any statement that tells the user what to enter should work. For example:'
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: 每次使用`input()`函数时，你都应该包含一个清晰、易于理解的提示，告诉用户你需要什么类型的信息。任何能告诉用户需要输入什么内容的语句都可以。例如：
- en: '**greeter.py**'
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: '**greeter.py**'
- en: '[PRE281]'
  id: totrans-1100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: 'Add a space at the end of your prompts (after the colon in the preceding example)
    to separate the prompt from the user’s response and to make it clear to your user
    where to enter their text. For example:'
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: 在提示信息末尾添加一个空格（在前面的示例中冒号后面）来将提示与用户的响应分开，并且清晰地告诉用户应该在何处输入他们的文本。例如：
- en: '[PRE282]'
  id: totrans-1102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: Sometimes you’ll want to write a prompt that’s longer than one line. For example,
    you might want to tell the user why you’re asking for certain input. You can assign
    your prompt to a variable and pass that variable to the `input()` function. This
    allows you to build your prompt over several lines, then write a clean `input()`
    statement.
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你可能需要编写一个超过一行的提示信息。例如，你可能想告诉用户你为何要求提供某些输入。你可以将提示信息赋值给一个变量，并将该变量传递给`input()`函数。这使得你能够在多行中构建提示信息，然后编写一个简洁的`input()`语句。
- en: '**greeter.py**'
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: '**greeter.py**'
- en: '[PRE283]'
  id: totrans-1105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: This example shows one way to build a multiline string. The first line assigns
    the first part of the message to the variable `prompt`. In the second line, the
    operator `+=` takes the string that was assigned to `prompt` and adds the new
    string onto the end.
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了构建多行字符串的一种方式。第一行将消息的第一部分赋值给变量 `prompt`。在第二行，运算符 `+=` 将赋值给 `prompt` 的字符串与新的字符串连接起来。
- en: 'The prompt now spans two lines, again with space after the question mark for
    clarity:'
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在提示符跨越了两行，再次在问号后留有空格以增强清晰度：
- en: '[PRE284]'
  id: totrans-1108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: Using int() to Accept Numerical Input
  id: totrans-1109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `int()` 接受数值输入
- en: 'When you use the `input()` function, Python interprets everything the user
    enters as a string. Consider the following interpreter session, which asks for
    the user’s age:'
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 `input()` 函数时，Python 将用户输入的所有内容都视为字符串。考虑以下的解释器会话，它询问用户的年龄：
- en: '[PRE285]'
  id: totrans-1111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: 'The user enters the number `21`, but when we ask Python for the value of `age`,
    it returns `''21''`, the string representation of the numerical value entered.
    We know Python interpreted the input as a string because the number is now enclosed
    in quotes. If all you want to do is print the input, this works well. But if you
    try to use the input as a number, you’ll get an error:'
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: 用户输入数字 `21`，但是当我们请求 Python 获取 `age` 的值时，它返回了 `'21'`，即输入的数值的字符串表示。我们知道 Python
    将输入解释为字符串，因为该数字现在被引号括起来。如果你只是想打印输入内容，这样没问题。但如果你尝试将输入作为数字使用，你将遇到错误：
- en: '[PRE286]'
  id: totrans-1113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: 'When you try to use the input to do a numerical comparison ❶, Python produces
    an error because it can’t compare a string to an integer: the string `''21''`
    that’s assigned to `age` can’t be compared to the numerical value `18` ❷.'
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: 当你尝试使用输入进行数值比较 ❶ 时，Python 会产生错误，因为它不能将字符串与整数进行比较：分配给 `age` 的字符串 `'21'` 不能与数值
    `18` ❷ 进行比较。
- en: 'We can resolve this issue by using the `int()` function, which converts the
    input string to a numerical value. This allows the comparison to run successfully:'
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用 `int()` 函数来解决这个问题，它将输入的字符串转换为数值。这使得比较能够成功执行：
- en: '[PRE287]'
  id: totrans-1116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: 'In this example, when we enter `21` at the prompt, Python interprets the number
    as a string, but the value is then converted to a numerical representation by
    `int()` ❶. Now Python can run the conditional test: it compares `age` (which now
    represents the numerical value 21) and `18` to see if `age` is greater than or
    equal to 18\. This test evaluates to `True`.'
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当我们在提示符下输入 `21` 时，Python 将该数字解释为字符串，但该值随后通过 `int()` ❶ 被转换为数值表示。现在，Python
    可以执行条件测试：它将 `age`（现在表示数值 21）与 `18` 进行比较，判断 `age` 是否大于或等于 18。这个测试的结果是 `True`。
- en: 'How do you use the `int()` function in an actual program? Consider a program
    that determines whether people are tall enough to ride a roller coaster:'
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: 如何在实际程序中使用 `int()` 函数？考虑一个程序，判断人们是否足够高，能够坐过山车：
- en: '**rollercoaster.py**'
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: '**rollercoaster.py**'
- en: '[PRE288]'
  id: totrans-1120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: 'The program can compare `height` to `48` because `height = int(height)` converts
    the input value to a numerical representation before the comparison is made. If
    the number entered is greater than or equal to 48, we tell the user that they’re
    tall enough:'
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序可以将 `height` 与 `48` 进行比较，因为 `height = int(height)` 在进行比较之前将输入值转换为数值表示。如果输入的数字大于或等于
    48，我们会告诉用户他们的身高足够高：
- en: '[PRE289]'
  id: totrans-1122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: When you use numerical input to do calculations and comparisons, be sure to
    convert the input value to a numerical representation first.
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用数值输入进行计算和比较时，请务必先将输入值转换为数值表示。
- en: The Modulo Operator
  id: totrans-1124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 取余运算符
- en: 'A useful tool for working with numerical information is the *modulo operator*
    (`%`), which divides one number by another number and returns the remainder:'
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: 处理数值信息时，一个有用的工具是 *取余运算符*（`%`），它将一个数字除以另一个数字并返回余数：
- en: '[PRE290]'
  id: totrans-1126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: The modulo operator doesn’t tell you how many times one number fits into another;
    it only tells you what the remainder is.
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
  zh: 取余运算符不会告诉你一个数字能被另一个数字整除多少次；它只告诉你余数是多少。
- en: 'When one number is divisible by another number, the remainder is 0, so the
    modulo operator always returns 0\. You can use this fact to determine if a number
    is even or odd:'
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个数字能被另一个数字整除时，余数为 0，因此取余运算符总是返回 0。你可以利用这一点来判断一个数字是偶数还是奇数：
- en: '**even_or_odd.py**'
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
  zh: '**even_or_odd.py**'
- en: '[PRE291]'
  id: totrans-1130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: Even numbers are always divisible by two, so if the modulo of a number and two
    is zero (here, `if number % 2 == 0`) the number is even. Otherwise, it’s odd.
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: 偶数总是可以被二整除，因此如果一个数字与 2 的取余为零（在这里，`if number % 2 == 0`），则该数字是偶数。否则，它是奇数。
- en: '[PRE292]'
  id: totrans-1132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: Introducing while Loops
  id: totrans-1133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引入 while 循环
- en: The `for` loop takes a collection of items and executes a block of code once
    for each item in the collection. In contrast, the `while` loop runs as long as,
    or *while*, a certain condition is true.
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环会遍历一个集合中的每个项，并为集合中的每个项执行一次代码块。相比之下，`while`循环则是只要某个条件为真，就继续运行。'
- en: The while Loop in Action
  id: totrans-1135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`while`循环的实际运行'
- en: 'You can use a `while` loop to count up through a series of numbers. For example,
    the following `while` loop counts from 1 to 5:'
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`while`循环来通过一系列数字进行计数。例如，以下`while`循环从1计数到5：
- en: '**counting.py**'
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
  zh: '**counting.py**'
- en: '[PRE293]'
  id: totrans-1138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: In the first line, we start counting from 1 by assigning `current_number` the
    value 1\. The `while` loop is then set to keep running as long as the value of
    `current_number` is less than or equal to 5\. The code inside the loop prints
    the value of `current_number` and then adds 1 to that value with `current_number
    += 1`. (The `+=` operator is shorthand for `current_number = current_number +
    1`.)
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行中，我们通过将`current_number`赋值为1来开始计数。然后，`while`循环被设置为在`current_number`的值小于或等于5时持续运行。循环中的代码打印`current_number`的值，然后使用`current_number
    += 1`将该值加1。（`+=`运算符是`current_number = current_number + 1`的简写。）
- en: 'Python repeats the loop as long as the condition `current_number <= 5` is true.
    Because 1 is less than 5, Python prints `1` and then adds 1, making the current
    number `2`. Because 2 is less than 5, Python prints `2` and adds 1 again, making
    the current number `3`, and so on. Once the value of `current_number` is greater
    than 5, the loop stops running and the program ends:'
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
  zh: 只要`current_number <= 5`的条件为真，Python就会重复执行循环。因为1小于5，所以Python打印`1`，然后加1，使当前数字变为`2`。因为2小于5，所以Python打印`2`，再次加1，使当前数字变为`3`，依此类推。当`current_number`的值大于5时，循环停止，程序结束：
- en: '[PRE294]'
  id: totrans-1141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: The programs you use every day most likely contain `while` loops. For example,
    a game needs a `while` loop to keep running as long as you want to keep playing,
    and so it can stop running as soon as you ask it to quit. Programs wouldn’t be
    fun to use if they stopped running before we told them to or kept running even
    after we wanted to quit, so `while` loops are quite useful.
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
  zh: 你每天使用的程序很可能包含`while`循环。例如，一个游戏需要使用`while`循环来保持运行，直到你想停止为止，这样它就能在你要求退出时停止运行。如果程序在我们要求退出之前就停止运行，或者在我们想退出后仍然运行，那就不好玩了，所以`while`循环非常有用。
- en: Letting the User Choose When to Quit
  id: totrans-1143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 让用户选择何时退出
- en: 'We can make the *parrot.py* program run as long as the user wants by putting
    most of the program inside a `while` loop. We’ll define a *quit value* and then
    keep the program running as long as the user has not entered the quit value:'
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将大部分程序放入`while`循环中，让*parrot.py*程序运行直到用户想退出为止。我们将定义一个*退出值*，然后只要用户没有输入退出值，就继续运行程序：
- en: '**parrot.py**'
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
  zh: '**parrot.py**'
- en: '[PRE295]'
  id: totrans-1146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: 'We first define a prompt that tells the user their two options: entering a
    message or entering the quit value (in this case, `''quit''`). Then we set up
    a variable `message` to keep track of whatever value the user enters. We define
    `message` as an empty string, `""`, so Python has something to check the first
    time it reaches the `while` line. The first time the program runs and Python reaches
    the `while` statement, it needs to compare the value of `message` to `''quit''`,
    but no user input has been entered yet. If Python has nothing to compare, it won’t
    be able to continue running the program. To solve this problem, we make sure to
    give `message` an initial value. Although it’s just an empty string, it will make
    sense to Python and allow it to perform the comparison that makes the `while`
    loop work. This `while` loop runs as long as the value of `message` is not `''quit''`.'
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义一个提示，告诉用户他们的两个选项：输入一条信息或输入退出值（在此案例中为`'quit'`）。然后，我们设置一个变量`message`来跟踪用户输入的值。我们将`message`定义为空字符串`""`，这样Python在第一次进入`while`语句时会有东西可以检查。当程序第一次运行并且Python到达`while`语句时，它需要将`message`的值与`'quit'`进行比较，但此时用户尚未输入任何内容。如果Python没有东西可以比较，它将无法继续执行程序。为了解决这个问题，我们确保给`message`一个初始值。虽然它只是一个空字符串，但它对Python是有意义的，并且可以让Python进行比较，从而使`while`循环得以正常工作。这个`while`循环会在`message`的值不是`'quit'`时继续运行。
- en: 'The first time through the loop, `message` is just an empty string, so Python
    enters the loop. At `message = input(prompt)`, Python displays the prompt and
    waits for the user to enter their input. Whatever they enter is assigned to `message`
    and printed; then, Python reevaluates the condition in the `while` statement.
    As long as the user has not entered the word `''quit''`, the prompt is displayed
    again and Python waits for more input. When the user finally enters `''quit''`,
    Python stops executing the `while` loop and the program ends:'
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次循环时，`message`只是一个空字符串，因此Python进入循环。在`message = input(prompt)`时，Python显示提示并等待用户输入。当用户输入的内容被赋值给`message`并打印后，Python会重新评估`while`语句中的条件。只要用户没有输入`'quit'`，提示就会再次显示，Python会等待更多输入。当用户最终输入`'quit'`时，Python会停止执行`while`循环，程序结束：
- en: '[PRE296]'
  id: totrans-1149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: 'This program works well, except that it prints the word `''quit''` as if it
    were an actual message. A simple `if` test fixes this:'
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序运行良好，唯一的问题是它像打印一个实际的消息一样打印了单词`'quit'`。一个简单的`if`测试就能解决这个问题：
- en: '[PRE297]'
  id: totrans-1151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: 'Now the program makes a quick check before displaying the message and only
    prints the message if it does not match the quit value:'
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在程序在显示消息之前进行快速检查，只有在消息与退出值不匹配时才会打印该消息：
- en: '[PRE298]'
  id: totrans-1153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: Using a Flag
  id: totrans-1154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用标志
- en: In the previous example, we had the program perform certain tasks while a given
    condition was true. But what about more complicated programs in which many different
    events could cause the program to stop running?
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们让程序在给定条件为真时执行某些任务。但如果是更复杂的程序，其中许多不同的事件可能导致程序停止运行呢？
- en: For example, in a game, several different events can end the game. When the
    player runs out of ships, their time runs out, or the cities they were supposed
    to protect are all destroyed, the game should end. It needs to end if any one
    of these events happens. If many possible events might occur to stop the program,
    trying to test all these conditions in one `while` statement becomes complicated
    and difficult.
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在游戏中，几个不同的事件可能会结束游戏。当玩家的舰船耗尽、时间用完，或者他们应该保护的城市全部被摧毁时，游戏应该结束。只要发生了其中任何一个事件，游戏就应结束。如果有很多可能的事件可能导致程序停止，尝试在一个`while`语句中测试所有这些条件会变得复杂且困难。
- en: 'For a program that should run only as long as many conditions are true, you
    can define one variable that determines whether or not the entire program is active.
    This variable, called a *flag*, acts as a signal to the program. We can write
    our programs so they run while the flag is set to `True` and stop running when
    any of several events sets the value of the flag to `False`. As a result, our
    overall `while` statement needs to check only one condition: whether the flag
    is currently `True`. Then, all our other tests (to see if an event has occurred
    that should set the flag to `False`) can be neatly organized in the rest of the
    program.'
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个应在多个条件都为真时才运行的程序，你可以定义一个变量来决定程序是否继续运行。这个变量被称为*标志*，它充当程序的信号。我们可以编写程序，使其在标志被设置为`True`时运行，并在多个事件之一将标志的值设置为`False`时停止运行。结果，我们的`while`语句只需要检查一个条件：标志是否当前为`True`。然后，所有其他的测试（检查是否发生了某个事件应该将标志设置为`False`）可以在程序的其余部分整齐地组织。
- en: 'Let’s add a flag to *parrot.py* from the previous section. This flag, which
    we’ll call `active` (though you can call it anything), will monitor whether or
    not the program should continue running:'
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在前一节的*parrot.py*程序中添加一个标志。这个标志，我们称之为`active`（当然你也可以用其他名称），将监控程序是否应该继续运行：
- en: '[PRE299]'
  id: totrans-1159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: We set the variable `active` to `True` so the program starts in an active state.
    Doing so makes the `while` statement simpler because no comparison is made in
    the `while` statement itself; the logic is taken care of in other parts of the
    program. As long as the `active` variable remains `True`, the loop will continue
    running ❶.
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将变量`active`设置为`True`，以便程序在活动状态下启动。这样，`while`语句就变得更简洁，因为在`while`语句本身没有进行任何比较；逻辑被转移到程序的其他部分。只要`active`变量保持`True`，循环就会继续运行❶。
- en: In the `if` statement inside the `while` loop, we check the value of `message`
    once the user enters their input. If the user enters `'quit'`, we set `active`
    to `False`, and the `while` loop stops. If the user enters anything other than
    `'quit'`, we print their input as a message.
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
  zh: 在`while`循环中的`if`语句里，我们在用户输入后检查`message`的值。如果用户输入`'quit'`，我们将`active`设置为`False`，然后`while`循环停止。如果用户输入除`'quit'`以外的任何内容，我们将他们的输入打印为消息。
- en: This program has the same output as the previous example where we placed the
    conditional test directly in the `while` statement. But now that we have a flag
    to indicate whether the overall program is in an active state, it would be easy
    to add more tests (such as `elif` statements) for events that should cause `active`
    to become `False`. This is useful in complicated programs like games, in which
    there may be many events that should each make the program stop running. When
    any of these events causes the active flag to become `False`, the main game loop
    will exit, a *Game Over* message can be displayed, and the player can be given
    the option to play again.
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序与之前的示例有相同的输出，后者是将条件测试直接放在`while`语句中。但现在，由于我们有一个标志来指示整体程序是否处于活动状态，因此可以很容易地添加更多的测试（例如`elif`语句），用于处理应使`active`变为`False`的事件。这在复杂的程序中很有用，比如游戏，在这些程序中可能有许多事件应该导致程序停止运行。当这些事件中的任何一个导致活动标志变为`False`时，主游戏循环将退出，可以显示*游戏结束*消息，并且玩家可以选择重新开始游戏。
- en: Using break to Exit a Loop
  id: totrans-1163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用break退出循环
- en: To exit a `while` loop immediately without running any remaining code in the
    loop, regardless of the results of any conditional test, use the `break` statement.
    The `break` statement directs the flow of your program; you can use it to control
    which lines of code are executed and which aren’t, so the program only executes
    code that you want it to, when you want it to.
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
  zh: 要立即退出`while`循环而不运行循环中剩余的任何代码（无论条件测试的结果如何），请使用`break`语句。`break`语句控制程序的流程；你可以使用它来控制哪些代码行被执行，哪些不被执行，从而让程序仅在你希望的时刻执行你想要的代码。
- en: 'For example, consider a program that asks the user about places they’ve visited.
    We can stop the `while` loop in this program by calling `break` as soon as the
    user enters the `''quit''` value:'
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个询问用户曾经去过哪些地方的程序。我们可以通过在用户输入`'quit'`值时调用`break`来停止此程序中的`while`循环：
- en: '**cities.py**'
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
  zh: '**cities.py**'
- en: '[PRE300]'
  id: totrans-1167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: 'A loop that starts with `while True` ❶ will run forever unless it reaches a
    `break` statement. The loop in this program continues asking the user to enter
    the names of cities they’ve been to until they enter `''quit''`. When they enter
    `''quit''`, the `break` statement runs, causing Python to exit the loop:'
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
  zh: 一个以`while True` ❶开头的循环将永远运行，除非遇到`break`语句。这个程序中的循环会不断询问用户输入他们去过的城市名，直到他们输入`'quit'`。当他们输入`'quit'`时，`break`语句会执行，导致Python退出循环：
- en: '[PRE301]'
  id: totrans-1169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: Using continue in a Loop
  id: totrans-1170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在循环中使用continue
- en: 'Rather than breaking out of a loop entirely without executing the rest of its
    code, you can use the `continue` statement to return to the beginning of the loop,
    based on the result of a conditional test. For example, consider a loop that counts
    from 1 to 10 but prints only the odd numbers in that range:'
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
  zh: 与其完全跳出循环而不执行其余的代码，不如使用`continue`语句根据条件测试的结果返回到循环的开头。例如，考虑一个从1到10计数但仅打印该范围内奇数的循环：
- en: '**counting.py**'
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: '**counting.py**'
- en: '[PRE302]'
  id: totrans-1173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE302]'
- en: 'First, we set `current_number` to 0\. Because it’s less than 10, Python enters
    the `while` loop. Once inside the loop, we increment the count by 1 ❶, so `current_number`
    is 1\. The `if` statement then checks the modulo of `current_number` and 2\. If
    the modulo is 0 (which means `current_number` is divisible by 2), the `continue`
    statement tells Python to ignore the rest of the loop and return to the beginning.
    If the current number is not divisible by 2, the rest of the loop is executed
    and Python prints the current number:'
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将`current_number`设置为0。因为它小于10，Python进入了`while`循环。进入循环后，我们将计数器增加1 ❶，因此`current_number`变为1。接着，`if`语句检查`current_number`与2的模。如果模为0（这意味着`current_number`可以被2整除），`continue`语句告诉Python忽略循环的其余部分并返回到开头。如果当前数字不能被2整除，循环的其余部分将继续执行，Python打印当前的数字：
- en: '[PRE303]'
  id: totrans-1175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE303]'
- en: Avoiding Infinite Loops
  id: totrans-1176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 避免无限循环
- en: 'Every `while` loop needs a way to stop running so it won’t continue to run
    forever. For example, this counting loop should count from 1 to 5:'
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`while`循环都需要一种停止运行的方法，以免它继续无限运行。例如，这个计数循环应该从1计数到5：
- en: '**counting.py**'
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
  zh: '**counting.py**'
- en: '[PRE304]'
  id: totrans-1179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE304]'
- en: 'However, if you accidentally omit the line `x += 1`, the loop will run forever:'
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果不小心省略了`x += 1`这一行，循环将永远运行：
- en: '[PRE305]'
  id: totrans-1181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE305]'
- en: 'Now the value of `x` will start at `1` but never change. As a result, the conditional
    test `x <= 5` will always evaluate to `True` and the `while` loop will run forever,
    printing a series of 1s, like this:'
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`x`的值将从`1`开始，但永远不会改变。因此，条件测试`x <= 5`将始终返回`True`，`while`循环将永远运行，打印一系列的1，如下所示：
- en: '[PRE306]'
  id: totrans-1183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE306]'
- en: Every programmer accidentally writes an infinite `while` loop from time to time,
    especially when a program’s loops have subtle exit conditions. If your program
    gets stuck in an infinite loop, press CTRL-C or just close the terminal window
    displaying your program’s output.
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
  zh: 每个程序员偶尔都会不小心写出无限`while`循环，尤其是当程序的循环有微妙的退出条件时。如果程序陷入了无限循环，可以按CTRL-C或者直接关闭显示程序输出的终端窗口。
- en: To avoid writing infinite loops, test every `while` loop and make sure the loop
    stops when you expect it to. If you want your program to end when the user enters
    a certain input value, run the program and enter that value. If the program doesn’t
    end, scrutinize the way your program handles the value that should cause the loop
    to exit. Make sure at least one part of the program can make the loop’s condition
    `False` or cause it to reach a `break` statement.
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免写出无限循环，测试每个`while`循环，确保循环在你预期的时刻停止。如果你希望程序在用户输入某个特定值时结束，运行程序并输入该值。如果程序没有结束，仔细检查程序是如何处理应导致循环退出的值的。确保程序中至少有一部分可以使循环的条件变为`False`，或使其到达`break`语句。
- en: Using a while Loop with Lists and Dictionaries
  id: totrans-1186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`while`循环与列表和字典
- en: So far, we’ve worked with only one piece of user information at a time. We received
    the user’s input and then printed the input or a response to it. The next time
    through the `while` loop, we’d receive another input value and respond to that.
    But to keep track of many users and pieces of information, we’ll need to use lists
    and dictionaries with our `while` loops.
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只处理一次一个用户的信息。我们接收用户的输入，然后打印该输入或对此的响应。在下次执行`while`循环时，我们会接收另一个输入值并对此做出回应。但为了跟踪多个用户和信息，我们需要在`while`循环中使用列表和字典。
- en: A `for` loop is effective for looping through a list, but you shouldn’t modify
    a list inside a `for` loop because Python will have trouble keeping track of the
    items in the list. To modify a list as you work through it, use a `while` loop.
    Using `while` loops with lists and dictionaries allows you to collect, store,
    and organize lots of input to examine and report on later.
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环适合遍历列表，但你不应该在`for`循环中修改列表，因为 Python 在跟踪列表中的项时会遇到困难。要在遍历列表时修改它，应该使用`while`循环。使用`while`循环与列表和字典结合，可以收集、存储和组织大量输入，以供后续检查和报告。'
- en: Moving Items from One List to Another
  id: totrans-1189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将项目从一个列表移动到另一个列表
- en: 'Consider a list of newly registered but unverified users of a website. After
    we verify these users, how can we move them to a separate list of confirmed users?
    One way would be to use a `while` loop to pull users from the list of unconfirmed
    users as we verify them and then add them to a separate list of confirmed users.
    Here’s what that code might look like:'
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一个新注册但未验证的网站用户列表。在验证这些用户后，我们如何将他们移动到一个单独的已确认用户列表中呢？一种方法是使用`while`循环从未确认用户列表中提取用户进行验证，然后将他们添加到已确认用户的单独列表中。以下是该代码的示例：
- en: '**confirmed_users.py**'
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
  zh: '**confirmed_users.py**'
- en: '[PRE307]'
  id: totrans-1192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE307]'
- en: We begin with a list of unconfirmed users ❶ (Alice, Brian, and Candace) and
    an empty list to hold confirmed users. The `while` loop runs as long as the list
    `unconfirmed_users` is not empty ❷. Within this loop, the `pop()` method removes
    unverified users one at a time from the end of `unconfirmed_users` ❸. Because
    Candace is last in the `unconfirmed_users` list, her name will be the first to
    be removed, assigned to `current_user`, and added to the `confirmed_users` list
    ❹. Next is Brian, then Alice.
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个包含未确认用户的列表❶（Alice、Brian 和 Candace）开始，并有一个空列表来存放已确认的用户。只要`unconfirmed_users`列表不为空❷，`while`循环就会继续执行。在这个循环中，`pop()`方法会一次从`unconfirmed_users`列表的末尾移除一个未验证的用户❸。因为Candace是`unconfirmed_users`列表中的最后一个，所以她的名字会首先被移除，赋值给`current_user`，然后添加到`confirmed_users`列表中❹。接下来是Brian，然后是Alice。
- en: 'We simulate confirming each user by printing a verification message and then
    adding them to the list of confirmed users. As the list of unconfirmed users shrinks,
    the list of confirmed users grows. When the list of unconfirmed users is empty,
    the loop stops and the list of confirmed users is printed:'
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过打印确认消息来模拟确认每个用户，然后将他们添加到已确认用户的列表中。当未确认用户列表缩小时，已确认用户列表会增加。当未确认用户列表为空时，循环停止，并打印已确认用户列表：
- en: '[PRE308]'
  id: totrans-1195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE308]'
- en: Removing All Instances of Specific Values from a List
  id: totrans-1196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从列表中移除特定值的所有实例
- en: In Chapter 3, we used `remove()` to remove a specific value from a list. The
    `remove()` function worked because the value we were interested in appeared only
    once in the list. But what if you want to remove all instances of a value from
    a list?
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3章中，我们使用了`remove()`函数从列表中移除特定的值。`remove()`函数之所以有效，是因为我们关心的值在列表中只出现一次。但是，如果你想从列表中移除某个值的所有实例呢？
- en: 'Say you have a list of pets with the value `''cat''` repeated several times.
    To remove all instances of that value, you can run a `while` loop until `''cat''`
    is no longer in the list, as shown here:'
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个包含多个`'cat'`值的宠物列表。要移除该值的所有实例，你可以运行一个`while`循环，直到`'cat'`不再出现在列表中，如下所示：
- en: '**pets.py**'
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
  zh: '**pets.py**'
- en: '[PRE309]'
  id: totrans-1200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE309]'
- en: 'We start with a list containing multiple instances of `''cat''`. After printing
    the list, Python enters the `while` loop because it finds the value `''cat''`
    in the list at least once. Once inside the loop, Python removes the first instance
    of `''cat''`, returns to the `while` line, and then reenters the loop when it
    finds that `''cat''` is still in the list. It removes each instance of `''cat''`
    until the value is no longer in the list, at which point Python exits the loop
    and prints the list again:'
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个包含多个`'cat'`实例的列表开始。打印列表后，Python进入`while`循环，因为它至少发现一次`'cat'`出现在列表中。一旦进入循环，Python会移除第一个`'cat'`实例，返回到`while`行，然后当它发现`'cat'`仍然在列表中时再次进入循环。它会移除每一个`'cat'`实例，直到列表中不再有该值，此时Python退出循环并再次打印列表：
- en: '[PRE310]'
  id: totrans-1202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE310]'
- en: Filling a Dictionary with User Input
  id: totrans-1203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用用户输入填充字典
- en: 'You can prompt for as much input as you need in each pass through a `while`
    loop. Let’s make a polling program in which each pass through the loop prompts
    for the participant’s name and response. We’ll store the data we gather in a dictionary,
    because we want to connect each response with a particular user:'
  id: totrans-1204
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在每次通过`while`循环时提示用户输入所需的内容。让我们制作一个投票程序，其中每次通过循环时都提示参与者输入名字和回答。我们将把收集的数据存储在字典中，因为我们希望将每个回答与特定的用户关联：
- en: '**mountain_poll.py**'
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
  zh: '**mountain_poll.py**'
- en: '[PRE311]'
  id: totrans-1206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE311]'
- en: The program first defines an empty dictionary (`responses`) and sets a flag
    (`polling_active`) to indicate that polling is active. As long as `polling_active`
    is `True`, Python will run the code in the `while` loop.
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
  zh: 程序首先定义一个空字典（`responses`），并设置一个标志（`polling_active`）来指示投票处于激活状态。只要`polling_active`为`True`，Python就会执行`while`循环中的代码。
- en: Within the loop, the user is prompted to enter their name and a mountain they’d
    like to climb ❶. That information is stored in the `responses` dictionary ❷, and
    the user is asked whether or not to keep the poll running ❸. If they enter `yes`,
    the program enters the `while` loop again. If they enter `no`, the `polling_active`
    flag is set to `False`, the `while` loop stops running, and the final code block
    ❹ displays the results of the poll.
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环中，用户被提示输入他们的名字和想要攀登的山峰❶。这些信息会存储在`responses`字典中❷，然后用户会被询问是否继续进行投票❸。如果他们输入`yes`，程序会再次进入`while`循环。如果他们输入`no`，`polling_active`标志被设置为`False`，`while`循环停止运行，最后的代码块❹会显示投票结果。
- en: 'If you run this program and enter sample responses, you should see output like
    this:'
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这个程序并输入一些示例响应，你应该看到类似这样的输出：
- en: '[PRE312]'
  id: totrans-1210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE312]'
- en: Summary
  id: totrans-1211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to use `input()` to allow users to provide
    their own information in your programs. You learned to work with both text and
    numerical input and how to use `while` loops to make your programs run as long
    as your users want them to. You saw several ways to control the flow of a `while`
    loop by setting an `active` flag, using the `break` statement, and using the `continue`
    statement. You learned how to use a `while` loop to move items from one list to
    another and how to remove all instances of a value from a list. You also learned
    how `while` loops can be used with dictionaries.
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学习了如何使用`input()`让用户在程序中提供自己的信息。你学会了处理文本和数字输入，并且掌握了如何使用`while`循环让程序根据用户的需求运行。你还看到几种控制`while`循环流程的方法，诸如设置`active`标志、使用`break`语句以及使用`continue`语句。你学习了如何使用`while`循环将项目从一个列表移动到另一个列表，并且如何从列表中移除某个值的所有实例。你还学到了如何在字典中使用`while`循环。
- en: In Chapter 8 you’ll learn about functions. *Functions* allow you to break your
    programs into small parts, each of which does one specific job. You can call a
    function as many times as you want, and you can store your functions in separate
    files. By using functions, you’ll be able to write more efficient code that’s
    easier to troubleshoot and maintain and that can be reused in many different programs.
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
  zh: 在第8章中，你将学习函数。*函数*允许你将程序分解成小块，每一块都执行一个特定的任务。你可以根据需要调用一个函数任意次数，也可以将函数存储在单独的文件中。通过使用函数，你将能够编写更高效的代码，这些代码更容易排除故障和维护，并且可以在多个不同的程序中重复使用。
- en: '8'
  id: totrans-1214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Functions
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
  zh: 函数
- en: '![](Images/chapterart.png)'
  id: totrans-1216
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: In this chapter you’ll learn to write *functions*, which are named blocks of
    code designed to do one specific job. When you want to perform a particular task
    that you’ve defined in a function, you *call* the function responsible for it.
    If you need to perform that task multiple times throughout your program, you don’t
    need to type all the code for the same task again and again; you just call the
    function dedicated to handling that task, and the call tells Python to run the
    code inside the function. You’ll find that using functions makes your programs
    easier to write, read, test, and fix.
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习编写*函数*，它们是用于执行特定任务的命名代码块。当你想执行某个已经在函数中定义的特定任务时，你需要*调用*该函数。如果你需要在程序中多次执行该任务，你不需要一次又一次地编写相同的代码；只需调用专门处理该任务的函数，调用会告诉
    Python 执行函数内的代码。你会发现，使用函数会使得你的程序更容易编写、阅读、测试和修复。
- en: In this chapter you’ll also learn a variety of ways to pass information to functions.
    You’ll learn how to write certain functions whose primary job is to display information
    and other functions designed to process data and return a value or set of values.
    Finally, you’ll learn to store functions in separate files called *modules* to
    help organize your main program files.
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你还将学习多种将信息传递给函数的方式。你将学习如何编写一些主要用于显示信息的函数，以及一些用于处理数据并返回一个或多个值的函数。最后，你将学习如何将函数存储在单独的文件中，这些文件被称为*模块*，以帮助组织你的主程序文件。
- en: Defining a Function
  id: totrans-1219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义一个函数
- en: 'Here’s a simple function named `greet_user()` that prints a greeting:'
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的名为`greet_user()`的函数，用于打印问候语：
- en: '**greeter.py**'
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
  zh: '**greeter.py**'
- en: '[PRE313]'
  id: totrans-1222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE313]'
- en: This example shows the simplest structure of a function. The first line uses
    the keyword `def` to inform Python that you’re defining a function. This is the
    *function definition*, which tells Python the name of the function and, if applicable,
    what kind of information the function needs to do its job. The parentheses hold
    that information. In this case, the name of the function is `greet_user()`, and
    it needs no information to do its job, so its parentheses are empty. (Even so,
    the parentheses are required.) Finally, the definition ends in a colon.
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例展示了函数最简单的结构。第一行使用关键字`def`来通知 Python 你正在定义一个函数。这是*函数定义*，它告诉 Python 函数的名称以及（如果适用）该函数执行任务所需的信息。括号中包含这些信息。在这个例子中，函数的名称是`greet_user()`，它不需要任何信息来完成工作，因此它的括号是空的。（尽管如此，括号仍然是必须的。）最后，定义以冒号结尾。
- en: Any indented lines that follow `def greet_user():` make up the *body* of the
    function. The text on the second line is a comment called a *docstring*, which
    describes what the function does. When Python generates documentation for the
    functions in your programs, it looks for a string immediately after the function's
    definition. These strings are usually enclosed in triple quotes, which lets you
    write multiple lines.
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
  zh: 紧跟在`def greet_user():`之后的所有缩进行构成了函数的*主体*。第二行的文本是一个注释，称为*文档字符串*，它描述了该函数的功能。当
    Python 为程序中的函数生成文档时，它会查找函数定义后的字符串。这些字符串通常用三重引号括起来，这样你就可以写多行文本。
- en: 'The line `print("Hello!")` is the only line of actual code in the body of this
    function, so `greet_user()` has just one job: `print("Hello!")`.'
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
  zh: '`print("Hello!")`这一行是该函数主体中唯一的实际代码，因此`greet_user()`只有一个任务：`print("Hello!")`。'
- en: 'When you want to use this function, you have to call it. A *function call*
    tells Python to execute the code in the function. To *call* a function, you write
    the name of the function, followed by any necessary information in parentheses.
    Because no information is needed here, calling our function is as simple as entering
    `greet_user()`. As expected, it prints `Hello!`:'
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想使用这个函数时，必须调用它。*函数调用*告诉Python执行函数中的代码。要*调用*一个函数，你需要写出函数的名字，后面跟上括号内的必要信息。因为这里不需要额外的信息，所以调用我们的函数只需输入`greet_user()`。如预期，它会打印`Hello!`：
- en: '[PRE314]'
  id: totrans-1227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE314]'
- en: Passing Information to a Function
  id: totrans-1228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向函数传递信息
- en: 'If you modify the function `greet_user()` slightly, it can greet the user by
    name. For the function to do this, you enter `username` in the parentheses of
    the function’s definition at `def greet_user()`. By adding `username` here, you
    allow the function to accept any value of `username` you specify. The function
    now expects you to provide a value for `username` each time you call it. When
    you call `greet_user()`, you can pass it a name, such as `''jesse''`, inside the
    parentheses:'
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你稍微修改`greet_user()`函数，它可以通过名字问候用户。为了让函数实现这一功能，你需要在函数定义的`def greet_user()`的括号内输入`username`。通过在这里添加`username`，你允许函数接受你指定的任何`username`值。现在，每次调用该函数时，它都期望你提供一个`username`值。当你调用`greet_user()`时，你可以在括号内传递一个名字，比如`'jesse'`：
- en: '[PRE315]'
  id: totrans-1230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE315]'
- en: 'Entering `greet_user(''jesse'')` calls `greet_user()` and gives the function
    the information it needs to execute the `print()` call. The function accepts the
    name you passed it and displays the greeting for that name:'
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
  zh: 输入`greet_user('jesse')`调用`greet_user()`并为函数提供执行`print()`调用所需的信息。函数接受你传递的名字，并显示该名字的问候语：
- en: '[PRE316]'
  id: totrans-1232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE316]'
- en: Likewise, entering `greet_user('sarah')` calls `greet_user()`, passes it `'sarah'`,
    and prints `Hello, Sarah!` You can call `greet_user()` as often as you want and
    pass it any name you want to produce a predictable output every time.
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，输入`greet_user('sarah')`会调用`greet_user()`，并将`sarah`传递给它，然后打印`Hello, Sarah!`。你可以多次调用`greet_user()`并传递任何你想要的名字，每次都会产生可预测的输出。
- en: Arguments and Parameters
  id: totrans-1234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参数和参数值
- en: In the preceding `greet_user()` function, we defined `greet_user()` to require
    a value for the variable `username`. Once we called the function and gave it the
    information (a person’s name), it printed the right greeting.
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的`greet_user()`函数中，我们定义了`greet_user()`需要一个`username`变量的值。当我们调用该函数并提供信息（一个人的名字）时，它打印出正确的问候语。
- en: The variable `username` in the definition of `greet_user()` is an example of
    a *parameter*, a piece of information the function needs to do its job. The value
    `'jesse'` in `greet_user('jesse')` is an example of an argument. An *argument*
    is a piece of information that’s passed from a function call to a function. When
    we call the function, we place the value we want the function to work with in
    parentheses. In this case the argument `'jesse'` was passed to the function `greet_user()`,
    and the value was assigned to the parameter `username`.
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
  zh: 在`greet_user()`的定义中，变量`username`是*参数*的一个例子，它是函数完成任务所需的信息。在`greet_user('jesse')`中，值`'jesse'`是一个参数值，它是从函数调用传递给函数的信息。我们调用函数时，将我们希望函数处理的值放入括号内。在这个例子中，参数值`'jesse'`被传递给函数`greet_user()`，并赋值给参数`username`。
- en: Passing Arguments
  id: totrans-1237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传递参数
- en: Because a function definition can have multiple parameters, a function call
    may need multiple arguments. You can pass arguments to your functions in a number
    of ways. You can use *positional arguments*, which need to be in the same order
    the parameters were written; *keyword arguments*, where each argument consists
    of a variable name and a value; and lists and dictionaries of values. Let’s look
    at each of these in turn.
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
  zh: 由于一个函数定义可以有多个参数，函数调用可能需要多个参数。你可以通过多种方式向函数传递参数。你可以使用*位置参数*，它们需要按参数定义时的顺序传递；*关键字参数*，每个参数由变量名和值组成；以及值的列表和字典。我们将逐一看看这些方法。
- en: Positional Arguments
  id: totrans-1239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 位置参数
- en: When you call a function, Python must match each argument in the function call
    with a parameter in the function definition. The simplest way to do this is based
    on the order of the arguments provided. Values matched up this way are called
    *positional arguments*.
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用一个函数时，Python必须将函数调用中的每个参数与函数定义中的一个参数进行匹配。实现这一点最简单的方法是根据提供参数的顺序进行匹配。通过这种方式匹配的值被称为*位置参数*。
- en: 'To see how this works, consider a function that displays information about
    pets. The function tells us what kind of animal each pet is and the pet’s name,
    as shown here:'
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解它是如何工作的，考虑一个展示宠物信息的函数。该函数告诉我们每只宠物是什么种类的动物以及宠物的名字，如下所示：
- en: '**pets.py**'
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
  zh: '**pets.py**'
- en: '[PRE317]'
  id: totrans-1243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE317]'
- en: The definition shows that this function needs a type of animal and the animal’s
    name ❶. When we call `describe_pet()`, we need to provide an animal type and a
    name, in that order. For example, in the function call, the argument `'hamster'`
    is assigned to the parameter `animal_type` and the argument `'harry'` is assigned
    to the parameter `pet_name` ❷. In the function body, these two parameters are
    used to display information about the pet being described.
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
  zh: 定义表明这个函数需要一个动物的种类和动物的名字❶。当我们调用`describe_pet()`时，我们需要按顺序提供动物种类和名字。例如，在函数调用中，参数`'hamster'`被分配给`animal_type`，参数`'harry'`被分配给`pet_name`❷。在函数体内，这两个参数被用来显示正在描述的宠物信息。
- en: 'The output describes a hamster named Harry:'
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
  zh: 输出描述了一只名叫Harry的仓鼠：
- en: '[PRE318]'
  id: totrans-1246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE318]'
- en: Multiple Function Calls
  id: totrans-1247
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 多次函数调用
- en: 'You can call a function as many times as needed. Describing a second, different
    pet requires just one more call to `describe_pet()`:'
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以根据需要多次调用一个函数。描述第二个不同的宠物只需要再调用一次`describe_pet()`：
- en: '[PRE319]'
  id: totrans-1249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE319]'
- en: 'In this second function call, we pass `describe_pet()` the arguments `''dog''`
    and `''willie''`. As with the previous set of arguments we used, Python matches
    `''dog''` with the parameter `animal_type` and `''willie''` with the parameter
    `pet_name`. As before, the function does its job, but this time it prints values
    for a dog named Willie. Now we have a hamster named Harry and a dog named Willie:'
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二次函数调用中，我们将`describe_pet()`的参数设置为`'dog'`和`'willie'`。和之前使用的参数组一样，Python将`'dog'`与参数`animal_type`匹配，将`'willie'`与参数`pet_name`匹配。和之前一样，函数执行其功能，但这次它打印出一只名叫Willie的狗的值。现在我们有一只名叫Harry的仓鼠和一只名叫Willie的狗：
- en: '[PRE320]'
  id: totrans-1251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE320]'
- en: Calling a function multiple times is a very efficient way to work. The code
    describing a pet is written once in the function. Then, anytime you want to describe
    a new pet, you call the function with the new pet’s information. Even if the code
    for describing a pet were to expand to 10 lines, you could still describe a new
    pet in just one line by calling the function again.
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
  zh: 多次调用一个函数是一个非常高效的工作方式。描述宠物的代码在函数中只需要写一次。然后，每当你想描述一只新宠物时，只需要用新宠物的信息再次调用该函数。即使描述宠物的代码扩展到10行，你依然可以通过调用函数一次，用一行代码描述一只新宠物。
- en: Order Matters in Positional Arguments
  id: totrans-1253
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 位置参数中的顺序很重要
- en: 'You can get unexpected results if you mix up the order of the arguments in
    a function call when using positional arguments:'
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在函数调用中混淆了位置参数的顺序，可能会得到意想不到的结果：
- en: '[PRE321]'
  id: totrans-1255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE321]'
- en: 'In this function call, we list the name first and the type of animal second.
    Because the argument `''harry''` is listed first this time, that value is assigned
    to the parameter `animal_type`. Likewise, `''hamster''` is assigned to `pet_name`.
    Now we have a “harry” named “Hamster”:'
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数调用中，我们将名字列在前面，动物种类列在后面。因为这次`'harry'`被列在前面，所以这个值被分配给`animal_type`。同样，`'hamster'`被分配给`pet_name`。现在我们得到了一只名叫“Harry”的仓鼠：
- en: '[PRE322]'
  id: totrans-1257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE322]'
- en: If you get funny results like this, check to make sure the order of the arguments
    in your function call matches the order of the parameters in the function’s definition.
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你得到像这样的奇怪结果，请检查确保函数调用中的参数顺序与函数定义中的参数顺序一致。
- en: Keyword Arguments
  id: totrans-1259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关键字参数
- en: A *keyword argument* is a name-value pair that you pass to a function. You directly
    associate the name and the value within the argument, so when you pass the argument
    to the function, there’s no confusion (you won’t end up with a harry named Hamster).
    Keyword arguments free you from having to worry about correctly ordering your
    arguments in the function call, and they clarify the role of each value in the
    function call.
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*关键字参数*是你传递给函数的一个名称-值对。你在参数中直接关联名称和值，因此当你将参数传递给函数时，不会产生混淆（你不会把一只名为“哈利”的仓鼠变成狗）。关键字参数让你不必担心在函数调用中正确地排列参数的顺序，同时它们清晰地指明了每个值在函数调用中的角色。
- en: 'Let’s rewrite *pets.py* using keyword arguments to call `describe_pet()`:'
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用关键字参数重写*pets.py*来调用`describe_pet()`：
- en: '[PRE323]'
  id: totrans-1262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE323]'
- en: The function `describe_pet()` hasn’t changed. But when we call the function,
    we explicitly tell Python which parameter each argument should be matched with.
    When Python reads the function call, it knows to assign the argument `'hamster'`
    to the parameter `animal_type` and the argument `'harry'` to `pet_name`. The output
    correctly shows that we have a hamster named Harry.
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
  zh: '`describe_pet()`函数本身没有改变。但是当我们调用该函数时，我们显式告诉Python每个参数应与哪个实参匹配。当Python读取函数调用时，它知道将实参`''hamster''`分配给参数`animal_type`，并将实参`''harry''`分配给`pet_name`。输出结果正确地显示我们有一只名叫Harry的仓鼠。'
- en: 'The order of keyword arguments doesn’t matter because Python knows where each
    value should go. The following two function calls are equivalent:'
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字参数的顺序不重要，因为Python知道每个值应该放在哪个位置。以下两个函数调用是等效的：
- en: '[PRE324]'
  id: totrans-1265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE324]'
- en: Default Values
  id: totrans-1266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 默认值
- en: When writing a function, you can define a *default value* for each parameter.
    If an argument for a parameter is provided in the function call, Python uses the
    argument value. If not, it uses the parameter’s default value. So when you define
    a default value for a parameter, you can exclude the corresponding argument you’d
    usually write in the function call. Using default values can simplify your function
    calls and clarify the ways your functions are typically used.
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
  zh: 编写函数时，你可以为每个参数定义*默认值*。如果在函数调用中为某个参数提供了实参，Python 会使用该实参的值。如果没有提供，Python 会使用该参数的默认值。因此，当你为参数定义了默认值时，可以省略通常需要在函数调用中编写的相应实参。使用默认值可以简化你的函数调用，并明确函数通常的使用方式。
- en: 'For example, if you notice that most of the calls to `describe_pet()` are being
    used to describe dogs, you can set the default value of `animal_type` to `''dog''`.
    Now anyone calling `describe_pet()` for a dog can omit that information:'
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你注意到大多数调用`describe_pet()`的地方都是用来描述狗的，你可以将`animal_type`的默认值设置为`'dog'`。现在，任何调用`describe_pet()`来描述狗的人都可以省略这一信息：
- en: '[PRE325]'
  id: totrans-1269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE325]'
- en: 'We changed the definition of `describe_pet()` to include a default value, `''dog''`,
    for `animal_type`. Now when the function is called with no `animal_type` specified,
    Python knows to use the value `''dog''` for this parameter:'
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更改了`describe_pet()`的定义，为`animal_type`添加了默认值`'dog'`。现在，当函数调用时没有指定`animal_type`，Python
    会使用`'dog'`作为该参数的值：
- en: '[PRE326]'
  id: totrans-1271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE326]'
- en: Note that the order of the parameters in the function definition had to be changed.
    Because the default value makes it unnecessary to specify a type of animal as
    an argument, the only argument left in the function call is the pet’s name. Python
    still interprets this as a positional argument, so if the function is called with
    just a pet’s name, that argument will match up with the first parameter listed
    in the function’s definition. This is the reason the first parameter needs to
    be `pet_name`.
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，函数定义中参数的顺序必须更改。由于默认值使得不需要将动物类型作为实参，因此函数调用中唯一需要提供的实参就是宠物的名字。Python 仍然将其解释为位置参数，因此如果函数仅使用宠物的名字进行调用，该实参将与函数定义中列出的第一个参数匹配。这就是第一个参数需要是`pet_name`的原因。
- en: 'The simplest way to use this function now is to provide just a dog’s name in
    the function call:'
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用此函数的最简单方法是只在函数调用中提供一只狗的名字：
- en: '[PRE327]'
  id: totrans-1274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE327]'
- en: This function call would have the same output as the previous example. The only
    argument provided is `'willie'`, so it is matched up with the first parameter
    in the definition, `pet_name`. Because no argument is provided for `animal_type`,
    Python uses the default value `'dog'`.
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数调用的输出与之前的示例相同。唯一提供的实参是`'willie'`，因此它与函数定义中的第一个参数`pet_name`匹配。因为没有为`animal_type`提供实参，Python
    会使用默认值`'dog'`。
- en: 'To describe an animal other than a dog, you could use a function call like
    this:'
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
  zh: 要描述一只不是狗的动物，你可以使用如下的函数调用：
- en: '[PRE328]'
  id: totrans-1277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE328]'
- en: Because an explicit argument for `animal_type` is provided, Python will ignore
    the parameter’s default value.
  id: totrans-1278
  prefs: []
  type: TYPE_NORMAL
  zh: 因为提供了`animal_type`的显式实参，Python 会忽略该参数的默认值。
- en: Equivalent Function Calls
  id: totrans-1279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 等效的函数调用
- en: 'Because positional arguments, keyword arguments, and default values can all
    be used together, you’ll often have several equivalent ways to call a function.
    Consider the following definition for `describe_pet()` with one default value
    provided:'
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
  zh: 因为位置参数、关键字参数和默认值可以一起使用，所以你通常会有几种等效的方式来调用一个函数。考虑以下为`describe_pet()`提供一个默认值的定义：
- en: '[PRE329]'
  id: totrans-1281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE329]'
- en: With this definition, an argument always needs to be provided for `pet_name`,
    and this value can be provided using the positional or keyword format. If the
    animal being described is not a dog, an argument for `animal_type` must be included
    in the call, and this argument can also be specified using the positional or keyword
    format.
  id: totrans-1282
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这个定义，`pet_name`始终需要提供参数，这个值可以通过位置参数或关键字参数的形式提供。如果描述的动物不是狗，那么调用时必须包括`animal_type`的参数，这个参数也可以通过位置参数或关键字参数的形式指定。
- en: 'All of the following calls would work for this function:'
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
  zh: 以下所有调用都会适用于这个函数：
- en: '[PRE330]'
  id: totrans-1284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE330]'
- en: Each of these function calls would have the same output as the previous examples.
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数调用的输出都将与之前的示例相同。
- en: It doesn’t really matter which calling style you use. As long as your function
    calls produce the output you want, just use the style you find easiest to understand.
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用哪种调用风格并不重要。只要你的函数调用能产生你想要的输出，就使用你最容易理解的风格。
- en: Avoiding Argument Errors
  id: totrans-1287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 避免参数错误
- en: 'When you start to use functions, don’t be surprised if you encounter errors
    about unmatched arguments. Unmatched arguments occur when you provide fewer or
    more arguments than a function needs to do its work. For example, here’s what
    happens if we try to call `describe_pet()` with no arguments:'
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始使用函数时，如果遇到关于不匹配参数的错误，不要感到惊讶。不匹配参数的错误发生在你提供的参数数量比函数所需的少或多。例如，如果我们尝试调用`describe_pet()`而不提供任何参数，会发生以下情况：
- en: '[PRE331]'
  id: totrans-1289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE331]'
- en: 'Python recognizes that some information is missing from the function call,
    and the traceback tells us that:'
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
  zh: Python 识别出函数调用中缺少了一些信息，错误追踪告诉我们：
- en: '[PRE332]'
  id: totrans-1291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE332]'
- en: The traceback first tells us the location of the problem ❶, allowing us to look
    back and see that something went wrong in our function call. Next, the offending
    function call is written out for us to see ❷. Last, the traceback tells us the
    call is missing two arguments and reports the names of the missing arguments ❸.
    If this function were in a separate file, we could probably rewrite the call correctly
    without having to open that file and read the function code.
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
  zh: 错误追踪首先告诉我们问题所在的位置 ❶，让我们回过头来看，发现问题出现在函数调用中。接下来，错误的函数调用被列出 ❷。最后，错误追踪告诉我们调用缺少两个参数，并报告缺少的参数名称
    ❸。如果这个函数在一个独立的文件中，我们可能不需要打开文件并阅读函数代码，就能正确地重写调用。
- en: Python is helpful in that it reads the function’s code for us and tells us the
    names of the arguments we need to provide. This is another motivation for giving
    your variables and functions descriptive names. If you do, Python’s error messages
    will be more useful to you and anyone else who might use your code.
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
  zh: Python 很有帮助，它会读取函数的代码并告诉我们需要提供的参数名称。这也是给变量和函数命名时使用描述性名称的另一个原因。如果这样做，Python 的错误信息将更有用，帮助你或其他使用你代码的人解决问题。
- en: If you provide too many arguments, you should get a similar traceback that can
    help you correctly match your function call to the function definition.
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你提供了太多参数，你应该会得到类似的错误追踪信息，帮助你正确匹配函数调用与函数定义。
- en: Return Values
  id: totrans-1295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 返回值
- en: A function doesn’t always have to display its output directly. Instead, it can
    process some data and then return a value or set of values. The value the function
    returns is called a *return value*. The `return` statement takes a value from
    inside a function and sends it back to the line that called the function. Return
    values allow you to move much of your program’s grunt work into functions, which
    can simplify the body of your program.
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
  zh: 一个函数并不总是需要直接显示它的输出。相反，它可以处理一些数据，然后返回一个值或一组值。函数返回的值称为*返回值*。`return`语句将函数内部的值取出，并发送回调用该函数的行。返回值使得你可以将程序中许多繁琐的工作移到函数中，从而简化程序的主体部分。
- en: Returning a Simple Value
  id: totrans-1297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 返回一个简单的值
- en: 'Let’s look at a function that takes a first and last name, and returns a neatly
    formatted full name:'
  id: totrans-1298
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个接受名字和姓氏并返回格式化全名的函数：
- en: '**formatted_name.py**'
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
  zh: '**formatted_name.py**'
- en: '[PRE333]'
  id: totrans-1300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE333]'
- en: The definition of `get_formatted_name()` takes as parameters a first and last
    name. The function combines these two names, adds a space between them, and assigns
    the result to `full_name` ❶. The value of `full_name` is converted to title case,
    and then returned to the calling line ❷.
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_formatted_name()`的定义接受两个参数：名字和姓氏。该函数将这两个名字组合起来，在它们之间添加一个空格，并将结果赋值给`full_name`
    ❶。`full_name`的值被转换为标题大小写，然后返回给调用行 ❷。'
- en: 'When you call a function that returns a value, you need to provide a variable
    that the return value can be assigned to. In this case, the returned value is
    assigned to the variable `musician` ❸. The output shows a neatly formatted name
    made up of the parts of a person’s name:'
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用一个返回值的函数时，需要提供一个变量来接收返回的值。在这种情况下，返回的值被赋值给变量`musician` ❸。输出显示了一个整齐格式化的名字，由一个人的名字部分组成：
- en: '[PRE334]'
  id: totrans-1303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE334]'
- en: 'This might seem like a lot of work to get a neatly formatted name when we could
    have just written:'
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来像是为了得到一个格式化好的名字而做了很多工作，但我们也可以直接写成：
- en: '[PRE335]'
  id: totrans-1305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE335]'
- en: However, when you consider working with a large program that needs to store
    many first and last names separately, functions like `get_formatted_name()` become
    very useful. You store first and last names separately and then call this function
    whenever you want to display a full name.
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当你考虑在一个需要分别存储许多名和姓的大型程序时，像`get_formatted_name()`这样的函数就变得非常有用。你可以分别存储名和姓，然后每当你想要显示全名时调用这个函数。
- en: Making an Argument Optional
  id: totrans-1307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使参数变为可选
- en: Sometimes it makes sense to make an argument optional, so that people using
    the function can choose to provide extra information only if they want to. You
    can use default values to make an argument optional.
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
  zh: 有时将一个参数设为可选是有意义的，这样使用该函数的人可以根据需要提供额外的信息。你可以使用默认值来使参数成为可选项。
- en: 'For example, say we want to expand `get_formatted_name()` to handle middle
    names as well. A first attempt to include middle names might look like this:'
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们想要扩展`get_formatted_name()`以处理中间名。首次尝试包括中间名可能如下所示：
- en: '[PRE336]'
  id: totrans-1310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE336]'
- en: 'This function works when given a first, middle, and last name. The function
    takes in all three parts of a name and then builds a string out of them. The function
    adds spaces where appropriate and converts the full name to title case:'
  id: totrans-1311
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数在提供名、中间名和姓时能正常工作。该函数接受名字的三个部分，然后将它们组合成一个字符串。函数会在适当的位置添加空格，并将全名转换为标题大小写：
- en: '[PRE337]'
  id: totrans-1312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE337]'
- en: 'But middle names aren’t always needed, and this function as written would not
    work if you tried to call it with only a first name and a last name. To make the
    middle name optional, we can give the `middle_name` argument an empty default
    value and ignore the argument unless the user provides a value. To make `get_formatted_name()`
    work without a middle name, we set the default value of `middle_name` to an empty
    string and move it to the end of the list of parameters:'
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
  zh: 但是中间名并非总是需要的，这个函数的写法如果你只传入名和姓时将无法正常工作。为了使中间名成为可选项，我们可以给`middle_name`参数一个空的默认值，并且只有在用户提供值时才处理该参数。为了让`get_formatted_name()`在没有中间名的情况下工作，我们将`middle_name`的默认值设为空字符串，并将其移动到参数列表的最后：
- en: '[PRE338]'
  id: totrans-1314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE338]'
- en: In this example, the name is built from three possible parts. Because there’s
    always a first and last name, these parameters are listed first in the function’s
    definition. The middle name is optional, so it’s listed last in the definition,
    and its default value is an empty string.
  id: totrans-1315
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，名字由三个可能的部分组成。因为总是有姓和名，所以这些参数在函数定义中列出。中间名是可选的，因此它在定义中列出最后，并且其默认值为空字符串。
- en: In the body of the function, we check to see if a middle name has been provided.
    Python interprets non-empty strings as `True`, so the conditional test `if middle_name`
    evaluates to `True` if a middle name argument is in the function call ❶. If a
    middle name is provided, the first, middle, and last names are combined to form
    a full name. This name is then changed to title case and returned to the function
    call line, where it’s assigned to the variable `musician` and printed. If no middle
    name is provided, the empty string fails the `if` test and the `else` block runs
    ❷. The full name is made with just a first and last name, and the formatted name
    is returned to the calling line where it’s assigned to `musician` and printed.
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们检查是否提供了中间名。Python 将非空字符串解释为`True`，因此条件测试`if middle_name`如果函数调用中有中间名参数，结果会评估为`True`
    ❶。如果提供了中间名，首先、其次和最后的名字将被组合成一个全名。这个名字然后被转换为标题大小写，并返回到函数调用行，在那里它被赋值给变量`musician`并打印。如果没有提供中间名，空字符串将使`if`测试失败，`else`块将执行
    ❷。全名将只由名和姓组成，格式化后的名字返回到调用行，在那里它被赋值给`musician`并打印。
- en: Calling this function with a first and last name is straightforward. If we’re
    using a middle name, however, we have to make sure the middle name is the last
    argument passed so Python will match up the positional arguments correctly ❸.
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
  zh: 用名字和姓氏调用这个函数非常简单。然而，如果我们使用中间名，就必须确保中间名是最后一个传入的参数，这样Python才能正确匹配位置参数 ❸。
- en: 'This modified version of our function works for people with just a first and
    last name, and it works for people who have a middle name as well:'
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
  zh: 这个修改后的版本适用于只有名字和姓氏的人，也适用于有中间名的人：
- en: '[PRE339]'
  id: totrans-1319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE339]'
- en: Optional values allow functions to handle a wide range of use cases while letting
    function calls remain as simple as possible.
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
  zh: 可选值使得函数能够处理广泛的使用场景，同时保持函数调用尽可能简洁。
- en: Returning a Dictionary
  id: totrans-1321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 返回字典
- en: 'A function can return any kind of value you need it to, including more complicated
    data structures like lists and dictionaries. For example, the following function
    takes in parts of a name and returns a dictionary representing a person:'
  id: totrans-1322
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以返回任何你需要的值，包括更复杂的数据结构，如列表和字典。例如，以下函数接受姓名的各个部分，并返回一个表示人的字典：
- en: '**person.py**'
  id: totrans-1323
  prefs: []
  type: TYPE_NORMAL
  zh: '**person.py**'
- en: '[PRE340]'
  id: totrans-1324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE340]'
- en: 'The function `build_person()` takes in a first and last name, and puts these
    values into a dictionary ❶. The value of `first_name` is stored with the key `''first''`,
    and the value of `last_name` is stored with the key `''last''`. Then, the entire
    dictionary representing the person is returned ❷. The return value is printed
    ❸ with the original two pieces of textual information now stored in a dictionary:'
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`build_person()`接受名字和姓氏，并将这些值放入一个字典中 ❶。`first_name`的值被存储在键`'first'`下，`last_name`的值被存储在键`'last'`下。然后，表示这个人的整个字典被返回
    ❷。返回值被打印 ❸，原始的两条文本信息现在被存储在字典中：
- en: '[PRE341]'
  id: totrans-1326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE341]'
- en: 'This function takes in simple textual information and puts it into a more meaningful
    data structure that lets you work with the information beyond just printing it.
    The strings `''jimi''` and `''hendrix''` are now labeled as a first name and last
    name. You can easily extend this function to accept optional values like a middle
    name, an age, an occupation, or any other information you want to store about
    a person. For example, the following change allows you to store a person’s age
    as well:'
  id: totrans-1327
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受简单的文本信息，并将其放入更有意义的数据结构中，这样你就可以在打印信息之外，对其进行更多操作。字符串`'jimi'`和`'hendrix'`现在被标记为名字和姓氏。你可以轻松地扩展这个函数，使其接受可选的值，比如中间名、年龄、职业或你想要存储的任何其他个人信息。例如，以下的更改允许你同时存储一个人的年龄：
- en: '[PRE342]'
  id: totrans-1328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE342]'
- en: We add a new optional parameter `age` to the function definition and assign
    the parameter the special value `None`, which is used when a variable has no specific
    value assigned to it. You can think of `None` as a placeholder value. In conditional
    tests, `None` evaluates to `False`. If the function call includes a value for
    `age`, that value is stored in the dictionary. This function always stores a person’s
    name, but it can also be modified to store any other information you want about
    a person.
  id: totrans-1329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在函数定义中添加了一个新的可选参数`age`，并为该参数赋予特殊值`None`，用于表示一个变量没有具体的值。你可以把`None`看作占位符值。在条件测试中，`None`会被评估为`False`。如果函数调用中包含`age`的值，那么该值将被存储在字典中。这个函数始终存储一个人的名字，但也可以修改以存储关于此人的任何其他信息。
- en: Using a Function with a while Loop
  id: totrans-1330
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用带`while`循环的函数
- en: 'You can use functions with all the Python structures you’ve learned about so
    far. For example, let’s use the `get_formatted_name()` function with a `while`
    loop to greet users more formally. Here’s a first attempt at greeting people using
    their first and last names:'
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用所有迄今为止学过的Python结构与函数。例如，让我们使用`get_formatted_name()`函数与`while`循环结合，来更正式地问候用户。这里是第一次尝试使用用户的名字和姓氏来问候他们：
- en: '**greeter.py**'
  id: totrans-1332
  prefs: []
  type: TYPE_NORMAL
  zh: '**greeter.py**'
- en: '[PRE343]'
  id: totrans-1333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE343]'
- en: For this example, we use a simple version of `get_formatted_name()` that doesn’t
    involve middle names. The `while` loop asks the user to enter their name, and
    we prompt for their first and last name separately ❶.
  id: totrans-1334
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们使用了一个简单版本的`get_formatted_name()`，它不涉及中间名。`while`循环会要求用户输入他们的名字，我们分别提示用户输入他们的名字和姓氏
    ❶。
- en: 'But there’s one problem with this `while` loop: We haven’t defined a quit condition.
    Where do you put a quit condition when you ask for a series of inputs? We want
    the user to be able to quit as easily as possible, so each prompt should offer
    a way to quit. The `break` statement offers a straightforward way to exit the
    loop at either prompt:'
  id: totrans-1335
  prefs: []
  type: TYPE_NORMAL
  zh: 但是这个`while`循环有一个问题：我们没有定义退出条件。当你请求一系列输入时，应该在哪里设置退出条件呢？我们希望用户尽可能容易地退出，因此每个提示都应提供一种退出方式。`break`语句为在任意提示中退出循环提供了一种简便的方法：
- en: '[PRE344]'
  id: totrans-1336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE344]'
- en: 'We add a message that informs the user how to quit, and then we break out of
    the loop if the user enters the quit value at either prompt. Now the program will
    continue greeting people until someone enters `q` for either name:'
  id: totrans-1337
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一条消息，告知用户如何退出，然后如果用户在任意提示中输入退出值，我们就跳出循环。现在，程序将继续向用户问候，直到有人输入`q`作为名字：
- en: '[PRE345]'
  id: totrans-1338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE345]'
- en: Passing a List
  id: totrans-1339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传递一个列表
- en: You’ll often find it useful to pass a list to a function, whether it’s a list
    of names, numbers, or more complex objects, such as dictionaries. When you pass
    a list to a function, the function gets direct access to the contents of the list.
    Let’s use functions to make working with lists more efficient.
  id: totrans-1340
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是名字、数字还是更复杂的对象（例如字典），将一个列表传递给函数通常是非常有用的。当你将列表传递给函数时，函数可以直接访问列表的内容。让我们通过使用函数来提高处理列表的效率。
- en: 'Say we have a list of users and want to print a greeting to each. The following
    example sends a list of names to a function called `greet_users()`, which greets
    each person in the list individually:'
  id: totrans-1341
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个用户列表，并希望向每个用户打印问候语。以下示例将一个名字列表传递给一个名为`greet_users()`的函数，该函数会逐一向列表中的每个人问好：
- en: '**greet_users.py**'
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
  zh: '**greet_users.py**'
- en: '[PRE346]'
  id: totrans-1343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE346]'
- en: 'We define `greet_users()` so it expects a list of names, which it assigns to
    the parameter `names`. The function loops through the list it receives and prints
    a greeting to each user. Outside of the function, we define a list of users and
    then pass the list `usernames` to `greet_users()` in the function call:'
  id: totrans-1344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了`greet_users()`，使其期望接收一个名字列表，并将其分配给参数`names`。该函数会遍历它收到的列表，并向每个用户打印问候语。在函数外部，我们定义了一个用户列表，然后在函数调用中将列表`usernames`传递给`greet_users()`：
- en: '[PRE347]'
  id: totrans-1345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE347]'
- en: This is the output we wanted. Every user sees a personalized greeting, and you
    can call the function anytime you want to greet a specific set of users.
  id: totrans-1346
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们想要的输出。每个用户都会看到个性化的问候语，且你可以在任何时候调用该函数来问候特定的用户群体。
- en: Modifying a List in a Function
  id: totrans-1347
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在函数中修改一个列表
- en: When you pass a list to a function, the function can modify the list. Any changes
    made to the list inside the function’s body are permanent, allowing you to work
    efficiently even when you’re dealing with large amounts of data.
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个列表传递给函数时，函数可以修改这个列表。在函数体内对列表所做的任何更改都是永久性的，这样即使你处理大量数据，也能高效工作。
- en: 'Consider a company that creates 3D printed models of designs that users submit.
    Designs that need to be printed are stored in a list, and after being printed
    they’re moved to a separate list. The following code does this without using functions:'
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个公司，该公司创建用户提交的设计的 3D 打印模型。需要打印的设计存储在一个列表中，打印完成后，它们会被移动到另一个单独的列表。以下代码在不使用函数的情况下实现这一功能：
- en: '**printing_models.py**'
  id: totrans-1350
  prefs: []
  type: TYPE_NORMAL
  zh: '**printing_models.py**'
- en: '[PRE348]'
  id: totrans-1351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE348]'
- en: 'This program starts with a list of designs that need to be printed and an empty
    list called `completed_models` that each design will be moved to after it has
    been printed. As long as designs remain in `unprinted_designs`, the `while` loop
    simulates printing each design by removing a design from the end of the list,
    storing it in `current_design`, and displaying a message that the current design
    is being printed. It then adds the design to the list of completed models. When
    the loop is finished running, a list of the designs that have been printed is
    displayed:'
  id: totrans-1352
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序以一个需要打印的设计列表开始，并有一个空列表`completed_models`，每个设计在打印完成后会被移到该列表中。只要`unprinted_designs`列表中还有设计，`while`循环就会通过从列表末尾移除一个设计、将其存储到`current_design`中，并显示当前设计正在打印的消息来模拟打印每个设计。然后，它会将该设计添加到已完成模型列表中。当循环完成后，将显示打印过的设计列表：
- en: '[PRE349]'
  id: totrans-1353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE349]'
- en: 'We can reorganize this code by writing two functions, each of which does one
    specific job. Most of the code won’t change; we’re just structuring it more carefully.
    The first function will handle printing the designs, and the second will summarize
    the prints that have been made:'
  id: totrans-1354
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过编写两个函数来重新组织这段代码，每个函数执行一个特定的任务。大部分代码不会改变；我们只是更仔细地进行结构化。第一个函数将处理打印设计，第二个函数将总结已打印的设计：
- en: '[PRE350]'
  id: totrans-1355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE350]'
- en: 'We define the function `print_models()` with two parameters: a list of designs
    that need to be printed and a list of completed models ❶. Given these two lists,
    the function simulates printing each design by emptying the list of unprinted
    designs and filling up the list of completed models. We then define the function
    `show_completed_models()` with one parameter: the list of completed models ❷.
    Given this list, `show_completed_models()` displays the name of each model that
    was printed.'
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了`print_models()`函数，它有两个参数：一个是需要打印的设计列表，另一个是已完成模型列表❶。给定这两个列表，该函数通过清空未打印设计的列表并填充已完成模型的列表来模拟打印每个设计。然后我们定义了`show_completed_models()`函数，它有一个参数：已完成模型的列表❷。根据这个列表，`show_completed_models()`会显示每个已打印模型的名称。
- en: 'This program has the same output as the version without functions, but the
    code is much more organized. The code that does most of the work has been moved
    to two separate functions, which makes the main part of the program easier to
    understand. Look at the body of the program and notice how easily you can follow
    what’s happening:'
  id: totrans-1357
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序的输出与没有函数的版本相同，但代码更有条理。做大部分工作的代码已被移到两个单独的函数中，这使得程序的主体部分更容易理解。看看程序主体，注意你能多么轻松地跟随发生的事情：
- en: '[PRE351]'
  id: totrans-1358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE351]'
- en: We set up a list of unprinted designs and an empty list that will hold the completed
    models. Then, because we’ve already defined our two functions, all we have to
    do is call them and pass them the right arguments. We call `print_models()` and
    pass it the two lists it needs; as expected, `print_models()` simulates printing
    the designs. Then we call `show_completed_models()` and pass it the list of completed
    models so it can report the models that have been printed. The descriptive function
    names allow others to read this code and understand it, even without comments.
  id: totrans-1359
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建立了一个未打印设计的列表和一个空的已完成模型列表。然后，因为我们已经定义了两个函数，我们所需要做的就是调用它们并传递正确的参数。我们调用`print_models()`并传递它所需要的两个列表；正如预期的那样，`print_models()`模拟打印这些设计。然后我们调用`show_completed_models()`并传递已完成模型的列表，以便它能报告已打印的模型。描述性的函数名称让其他人即使没有注释也能阅读这段代码并理解它。
- en: This program is easier to extend and maintain than the version without functions.
    If we need to print more designs later on, we can simply call `print_models()
    again. If we realize the printing code needs to be modified, we can change the
    code once, and our changes will take place everywhere the function is called.
    This technique is more efficient than having to update code separately in several
    places in the program.`
  id: totrans-1360
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序比没有函数的版本更容易扩展和维护。如果我们以后需要打印更多设计，只需再次调用`print_models()`。如果我们意识到打印代码需要修改，我们只需修改一次代码，这些修改就会在函数被调用的所有地方生效。这种方法比在程序中的多个地方分别更新代码更高效。
- en: '[PRE352] `function_name`(`list_name`[:]) [PRE353] print_models(unprinted_designs[:],
    completed_models) [PRE354] def make_pizza(*toppings):     """Print the list of
    toppings that have been requested."""     print(toppings)  make_pizza(''pepperoni'')
    make_pizza(''mushrooms'', ''green peppers'', ''extra cheese'') [PRE355] (''pepperoni'',)
    (''mushrooms'', ''green peppers'', ''extra cheese'') [PRE356] def make_pizza(*toppings):   """Summarize
    the pizza we are about to make."""  print("\nMaking a pizza with the following
    toppings:")     for topping in toppings:         print(f"- {topping}")  make_pizza(''pepperoni'')
    make_pizza(''mushrooms'', ''green peppers'', ''extra cheese'') [PRE357] Making
    a pizza with the following toppings: - pepperoni  Making a pizza with the following
    toppings: - mushrooms - green peppers - extra cheese [PRE358] def make_pizza(size,
    *toppings):     """Summarize the pizza we are about to make."""     print(f"\nMaking
    a {size}-inch pizza with the following toppings:")     for topping in toppings:  print(f"-
    {topping}")  make_pizza(16, ''pepperoni'') make_pizza(12, ''mushrooms'', ''green
    peppers'', ''extra cheese'') [PRE359] Making a 16-inch pizza with the following
    toppings: - pepperoni  Making a 12-inch pizza with the following toppings: - mushrooms
    - green peppers - extra cheese [PRE360] def build_profile(first, last, **user_info):     """Build
    a dictionary containing everything we know about a user.""" ❶     user_info[''first_name'']
    = first     user_info[''last_name''] = last     return user_info  user_profile
    = build_profile(''albert'', ''einstein'',                              location=''princeton'',                              field=''physics'')
    print(user_profile) [PRE361] {''location'': ''princeton'', ''field'': ''physics'',
    ''first_name'': ''albert'', ''last_name'': ''einstein''} [PRE362] def make_pizza(size,
    *toppings):     """Summarize the pizza we are about to make."""     print(f"\nMaking
    a {size}-inch pizza with the following toppings:")     for topping in toppings:         print(f"-
    {topping}") [PRE363] import pizza  ❶ pizza.make_pizza(16, ''pepperoni'') pizza.make_pizza(12,
    ''mushrooms'', ''green peppers'', ''extra cheese'') [PRE364] Making a 16-inch
    pizza with the following toppings: - pepperoni  Making a 12-inch pizza with the
    following toppings: - mushrooms - green peppers - extra cheese [PRE365] `module_name`.`function_name`()
    [PRE366] from `module_name` import `function_name` [PRE367] from `module_name`
    import `function_0`, `function_1`, `function_2` [PRE368] from pizza import make_pizza  make_pizza(16,
    ''pepperoni'') make_pizza(12, ''mushrooms'', ''green peppers'', ''extra cheese'')
    [PRE369] from pizza import make_pizza as mp  mp(16, ''pepperoni'') mp(12, ''mushrooms'',
    ''green peppers'', ''extra cheese'') [PRE370] from `module_name` import `function_name`
    as `fn` [PRE371] import pizza as p  p.make_pizza(16, ''pepperoni'') p.make_pizza(12,
    ''mushrooms'', ''green peppers'', ''extra cheese'') [PRE372] import `module_name`
    as `mn` [PRE373] from pizza import *  make_pizza(16, ''pepperoni'') make_pizza(12,
    ''mushrooms'', ''green peppers'', ''extra cheese'') [PRE374] from `module_name`
    import * [PRE375] def `function_name`(`parameter_0`, `parameter_1`=''`default
    value`'') [PRE376] `function_name`(`value_0`, `parameter_1`=''`value`'') [PRE377]
    def `function_name`(         `parameter_0`, `parameter_1`, `parameter_2`,         `parameter_3`,
    `parameter_4`, `parameter_5`):     `function body...` [PRE378]`  [PRE379] ❶ class
    Dog:     """A simple attempt to model a dog."""  ❷     def __init__(self, name,
    age):         """Initialize name and age attributes.""" ❸         self.name =
    name         self.age = age  ❹     def sit(self):         """Simulate a dog sitting
    in response to a command."""         print(f"{self.name} is now sitting.")      def
    roll_over(self):         """Simulate rolling over in response to a command."""         print(f"{self.name}
    rolled over!") [PRE380] class Dog:  *--snip--*  ❶ my_dog = Dog(''Willie'', 6)  ❷
    print(f"My dog''s name is {my_dog.name}.") ❸ print(f"My dog is {my_dog.age} years
    old.") [PRE381] my_dog.name [PRE382] My dog''s name is Willie. My dog is 6 years
    old. [PRE383] class Dog:  *--snip--*  my_dog = Dog(''Willie'', 6) my_dog.sit()
    my_dog.roll_over() [PRE384] Willie is now sitting. Willie rolled over! [PRE385]
    class Dog:  *--snip--*  my_dog = Dog(''Willie'', 6) your_dog = Dog(''Lucy'', 3)  print(f"My
    dog''s name is {my_dog.name}.") print(f"My dog is {my_dog.age} years old.") my_dog.sit()  print(f"\nYour
    dog''s name is {your_dog.name}.") print(f"Your dog is {your_dog.age} years old.")
    your_dog.sit() [PRE386] My dog''s name is Willie. My dog is 6 years old. Willie
    is now sitting.  Your dog''s name is Lucy. Your dog is 3 years old. Lucy is now
    sitting. [PRE387] class Car:     """A simple attempt to represent a car."""  ❶     def
    __init__(self, make, model, year):         """Initialize attributes to describe
    a car."""         self.make = make         self.model = model         self.year
    = year  ❷     def get_descriptive_name(self):         """Return a neatly formatted
    descriptive name."""         long_name = f"{self.year} {self.make} {self.model}"  return
    long_name.title()  ❸ my_new_car = Car(''audi'', ''a4'', 2024) print(my_new_car.get_descriptive_name())
    [PRE388] 2024 Audi A4 [PRE389] class Car:   def __init__(self, make, model, year):  """Initialize
    attributes to describe a car."""  self.make = make  self.model = model  self.year
    = year ❶         self.odometer_reading = 0      def get_descriptive_name(self):  *--snip--*  ❷     def
    read_odometer(self):         """Print a statement showing the car''s mileage."""         print(f"This
    car has {self.odometer_reading} miles on it.")  my_new_car = Car(''audi'', ''a4'',
    2024) print(my_new_car.get_descriptive_name()) my_new_car.read_odometer() [PRE390]
    2024 Audi A4 This car has 0 miles on it. [PRE391] class Car:  *--snip--*  my_new_car
    = Car(''audi'', ''a4'', 2024) print(my_new_car.get_descriptive_name())  my_new_car.odometer_reading
    = 23 my_new_car.read_odometer() [PRE392] 2024 Audi A4 This car has 23 miles on
    it. [PRE393] class Car:  *--snip--*      def update_odometer(self, mileage):         """Set
    the odometer reading to the given value."""         self.odometer_reading = mileage  my_new_car
    = Car(''audi'', ''a4'', 2024) print(my_new_car.get_descriptive_name())  ❶ my_new_car.update_odometer(23)
    my_new_car.read_odometer() [PRE394] 2024 Audi A4 This car has 23 miles on it.
    [PRE395] class Car:  *--snip--*   def update_odometer(self, mileage):         """         Set
    the odometer reading to the given value.         Reject the change if it attempts
    to roll the odometer back.         """ ❶         if mileage >= self.odometer_reading:  self.odometer_reading
    = mileage         else: ❷             print("You can''t roll back an odometer!")
    [PRE396] class Car:     *--snip--*   def update_odometer(self, mileage):  *--snip--*      def
    increment_odometer(self, miles):         """Add the given amount to the odometer
    reading."""         self.odometer_reading += miles  ❶ my_used_car = Car(''subaru'',
    ''outback'', 2019) print(my_used_car.get_descriptive_name())  ❷ my_used_car.update_odometer(23_500)
    my_used_car.read_odometer()  my_used_car.increment_odometer(100) my_used_car.read_odometer()
    [PRE397] 2019 Subaru Outback This car has 23500 miles on it. This car has 23600
    miles on it. [PRE398] ❶ class Car:  """A simple attempt to represent a car."""   def
    __init__(self, make, model, year):  """Initialize attributes to describe a car.""  self.make
    = make  self.model = model  self.year = year  self.odometer_reading = 0   def
    get_descriptive_name(self):  """Return a neatly formatted descriptive name."""  long_name
    = f"{self.year} {self.make} {self.model}"  return long_name.title()   def read_odometer(self):  """Print
    a statement showing the car''s mileage."""  print(f"This car has {self.odometer_reading}
    miles on it.")   def update_odometer(self, mileage):  """Set the odometer reading
    to the given value."""  if mileage >= self.odometer_reading:  self.odometer_reading
    = mileage  else:  print("You can''t roll back an odometer!")   def increment_odometer(self,
    miles):  """Add the given amount to the odometer reading."""  self.odometer_reading
    += miles  ❷ class ElectricCar(Car):     """Represent aspects of a car, specific
    to electric vehicles."""  ❸     def __init__(self, make, model, year):         """Initialize
    attributes of the parent class.""" ❹         super().__init__(make, model, year)   ❺
    my_leaf = ElectricCar(''nissan'', ''leaf'', 2024) print(my_leaf.get_descriptive_name())
    [PRE399] 2024 Nissan Leaf [PRE400] class Car:  *--snip--*  class ElectricCar(Car):  """Represent
    aspects of a car, specific to electric vehicles."""   def __init__(self, make,
    model, year):   """         Initialize attributes of the parent class.         Then
    initialize attributes specific to an electric car.         """  super().__init__(make,
    model, year) ❶         self.battery_size = 40  ❷     def describe_battery(self):         """Print
    a statement describing the battery size."""         print(f"This car has a {self.battery_size}-kWh
    battery.")  my_leaf = ElectricCar(''nissan'', ''leaf'', 2024) print(my_leaf.get_descriptive_name())
    my_leaf.describe_battery() [PRE401] 2024 Nissan Leaf This car has a 40-kWh battery.
    [PRE402] class ElectricCar(Car):  *--snip--*      def fill_gas_tank(self):         """Electric
    cars don''t have gas tanks."""         print("This car doesn''t have a gas tank!")
    [PRE403] class Car:  *--snip--*  class Battery:     """A simple attempt to model
    a battery for an electric car."""  ❶     def __init__(self, battery_size=40):  """Initialize
    the battery''s attributes."""         self.battery_size = battery_size  ❷     def
    describe_battery(self):         """Print a statement describing the battery size."""         print(f"This
    car has a {self.battery_size}-kWh battery.")   class ElectricCar(Car):  """Represent
    aspects of a car, specific to electric vehicles."""   def __init__(self, make,
    model, year):  """  Initialize attributes of the parent class.  Then initialize
    attributes specific to an electric car.  """  super().__init__(make, model, year)
    ❸         self.battery = Battery()  my_leaf = ElectricCar(''nissan'', ''leaf'',
    2024) print(my_leaf.get_descriptive_name()) my_leaf.battery.describe_battery()
    [PRE404] my_leaf.battery.describe_battery() [PRE405] 2024 Nissan Leaf This car
    has a 40-kWh battery. [PRE406] class Car:  *--snip--*  class Battery:  *--snip--*      def
    get_range(self):         """Print a statement about the range this battery provides."""         if
    self.battery_size == 40:             range = 150         elif self.battery_size
    == 65:             range = 225          print(f"This car can go about {range}
    miles on a full charge.")  class ElectricCar(Car):  *--snip--*  my_leaf = ElectricCar(''nissan'',
    ''leaf'', 2024) print(my_leaf.get_descriptive_name()) my_leaf.battery.describe_battery()
    ❶ my_leaf.battery.get_range() [PRE407] 2024 Nissan Leaf This car has a 40-kWh
    battery. This car can go about 150 miles on a full charge. [PRE408] ❶ """A class
    that can be used to represent a car."""  class Car:  """A simple attempt to represent
    a car."""   def __init__(self, make, model, year):  """Initialize attributes to
    describe a car."""  self.make = make  self.model = model  self.year = year  self.odometer_reading
    = 0   def get_descriptive_name(self):  """Return a neatly formatted descriptive
    name."""  long_name = f"{self.year} {self.make} {self.model}"  return long_name.title()   def
    read_odometer(self):  """Print a statement showing the car''s mileage."""  print(f"This
    car has {self.odometer_reading} miles on it.")   def update_odometer(self, mileage):  """  Set
    the odometer reading to the given value.  Reject the change if it attempts to
    roll the odometer back.  """  if mileage >= self.odometer_reading:  self.odometer_reading
    = mileage  else:  print("You can''t roll back an odometer!")   def increment_odometer(self,
    miles):  """Add the given amount to the odometer reading."""  self.odometer_reading
    += miles [PRE409] ❶ from car import Car  my_new_car = Car(''audi'', ''a4'', 2024)
    print(my_new_car.get_descriptive_name())  my_new_car.odometer_reading = 23 my_new_car.read_odometer()
    [PRE410] 2024 Audi A4 This car has 23 miles on it. [PRE411] """A set of classes
    used to represent gas and electric cars."""  class Car:  *--snip--*  class Battery:  """A
    simple attempt to model a battery for an electric car."""   def __init__(self,
    battery_size=40):  """Initialize the battery''s attributes."""  self.battery_size
    = battery_size   def describe_battery(self):  """Print a statement describing
    the battery size."""  print(f"This car has a {self.battery_size}-kWh battery.")   def
    get_range(self):  """Print a statement about the range this battery provides."""  if
    self.battery_size == 40:  range = 150  elif self.battery_size == 65:  range =
    225   print(f"This car can go about {range} miles on a full charge.")  class ElectricCar(Car):  """Models
    aspects of a car, specific to electric vehicles."""   def __init__(self, make,
    model, year):  """  Initialize attributes of the parent class.  Then initialize
    attributes specific to an electric car.  """  super().__init__(make, model, year)  self.battery
    = Battery() [PRE412] from car import ElectricCar  my_leaf = ElectricCar(''nissan'',
    ''leaf'', 2024) print(my_leaf.get_descriptive_name()) my_leaf.battery.describe_battery()
    my_leaf.battery.get_range() [PRE413] 2024 Nissan Leaf This car has a 40-kWh battery.
    This car can go about 150 miles on a full charge. [PRE414] ❶ from car import Car,
    ElectricCar  ❷ my_mustang = Car(''ford'', ''mustang'', 2024) print(my_mustang.get_descriptive_name())
    ❸ my_leaf = ElectricCar(''nissan'', ''leaf'', 2024) print(my_leaf.get_descriptive_name())
    [PRE415] 2024 Ford Mustang 2024 Nissan Leaf [PRE416] ❶ import car  ❷ my_mustang
    = car.Car(''ford'', ''mustang'', 2024) print(my_mustang.get_descriptive_name())  ❸
    my_leaf = car.ElectricCar(''nissan'', ''leaf'', 2024) print(my_leaf.get_descriptive_name())
    [PRE417] from `module_name` import * [PRE418] """A set of classes that can be
    used to represent electric cars."""  from car import Car  class Battery:  *--snip--*  class
    ElectricCar(Car):  *--snip--* [PRE419] """A class that can be used to represent
    a car."""  class Car:  *--snip--* [PRE420] from car import Car from electric_car
    import ElectricCar  my_mustang = Car(''ford'', ''mustang'', 2024) print(my_mustang.get_descriptive_name())  my_leaf
    = ElectricCar(''nissan'', ''leaf'', 2024) print(my_leaf.get_descriptive_name())
    [PRE421] 2024 Ford Mustang 2024 Nissan Leaf [PRE422] from electric_car import
    ElectricCar as EC [PRE423] my_leaf = EC(''nissan'', ''leaf'', 2024) [PRE424] import
    electric_car as ec [PRE425] my_leaf = ec.ElectricCar(''nissan'', ''leaf'', 2024)
    [PRE426] >>> **from random import randint** >>> **randint(1, 6)** 3 [PRE427] >>>
    **from random import choice** >>> **players = [''charles'', ''martina'', ''michael'',
    ''florence'', ''eli'']** >>> **first_up = choice(players)** >>> **first_up** ''florence''
    [PRE428] 3.1415926535   8979323846   2643383279 [PRE429] from pathlib import Path  ❶
    path = Path(''pi_digits.txt'') ❷ contents = path.read_text() print(contents) [PRE430]
    3.1415926535   8979323846   2643383279  [PRE431] from pathlib import Path  path
    = Path(''pi_digits.txt'') contents = path.read_text() contents = contents.rstrip()
    print(contents) [PRE432] 3.1415926535   8979323846   2643383279 [PRE433] contents
    = path.read_text().rstrip() [PRE434] path = Path(''text_files/`filename`.txt'')
    [PRE435] path = Path(''/home/eric/data_files/text_files/`filename`.txt'') [PRE436]
    from pathlib import Path  path = Path(''pi_digits.txt'') ❶ contents = path.read_text()  ❷
    lines = contents.splitlines() for line in lines:     print(line) [PRE437] 3.1415926535   8979323846   2643383279
    [PRE438] from pathlib import Path  path = Path(''pi_digits.txt'') contents = path.read_text()  lines
    = contents.splitlines() pi_string = '''' ❶ for line in lines:     pi_string +=
    line  print(pi_string) print(len(pi_string)) [PRE439] 3.1415926535  8979323846  2643383279
    36 [PRE440] *--snip--* for line in lines:   pi_string += line.lstrip()  print(pi_string)
    print(len(pi_string)) [PRE441] 3.141592653589793238462643383279 32 [PRE442] from
    pathlib import Path  path = Path(''pi_million_digits.txt'') contents = path.read_text()  lines
    = contents.splitlines() pi_string = '''' for line in lines:  pi_string += line.lstrip()  print(f"{pi_string[:52]}...")
    print(len(pi_string)) [PRE443] 3.14159265358979323846264338327950288419716939937510...
    1000002 [PRE444] *--snip--* for line in lines:  pi_string += line.strip()  birthday
    = input("Enter your birthday, in the form mmddyy: ") if birthday in pi_string:     print("Your
    birthday appears in the first million digits of pi!") else:     print("Your birthday
    does not appear in the first million digits of pi.") [PRE445] Enter your birthdate,
    in the form mmddyy: **120372** Your birthday appears in the first million digits
    of pi! [PRE446] from pathlib import Path  path = Path(''programming.txt'') path.write_text("I
    love programming.") [PRE447] I love programming. [PRE448] from pathlib import
    Path  contents = "I love programming.\n" contents += "I love creating new games.\n"
    contents += "I also love working with data.\n"  path = Path(''programming.txt'')
    path.write_text(contents) [PRE449] I love programming. I love creating new games.
    I also love working with data. [PRE450] print(5/0) [PRE451] Traceback (most recent
    call last):   File "division_calculator.py", line 1, in <module>     print(5/0)           ~^~
    ❶ ZeroDivisionError: division by zero [PRE452] try:     print(5/0) except ZeroDivisionError:     print("You
    can''t divide by zero!") [PRE453] You can''t divide by zero! [PRE454] print("Give
    me two numbers, and I''ll divide them.") print("Enter ''q'' to quit.")  while
    True: ❶     first_number = input("\nFirst number: ")     if first_number == ''q'':         break
    ❷     second_number = input("Second number: ")     if second_number == ''q'':         break
    ❸     answer = int(first_number) / int(second_number)     print(answer) [PRE455]
    Give me two numbers, and I''ll divide them. Enter ''q'' to quit.  First number:
    **5** Second number: **0** Traceback (most recent call last):   File "division_calculator.py",
    line 11, in <module>     answer = int(first_number) / int(second_number)              ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
    ZeroDivisionError: division by zero [PRE456] *--snip--* while True:   *--snip--*  if
    second_number == ''q'':  break ❶     try:         answer = int(first_number) /
    int(second_number) ❷     except ZeroDivisionError:         print("You can''t divide
    by 0!") ❸     else:  print(answer) [PRE457] Give me two numbers, and I''ll divide
    them. Enter ''q'' to quit.  First number: **5** Second number: **0** You can''t
    divide by 0!  First number: **5** Second number: **2** 2.5  First number: **q**
    [PRE458] from pathlib import Path  path = Path(''alice.txt'') contents = path.read_text(encoding=''utf-8'')
    [PRE459] Traceback (most recent call last): ❶   File "alice.py", line 4, in <module>
    ❷     contents = path.read_text(encoding=''utf-8'')                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  File
    "/.../pathlib.py", line 1056, in read_text     with self.open(mode=''r'', encoding=encoding,
    errors=errors) as f:          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   File
    "/.../pathlib.py", line 1042, in open     return io.open(self, mode, buffering,
    encoding, errors, newline)            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    ❸ FileNotFoundError: [Errno 2] No such file or directory: ''alice.txt'' [PRE460]
    from pathlib import Path  path = Path(''alice.txt'') try:     contents = path.read_text(encoding=''utf-8'')
    ❶ except FileNotFoundError:     print(f"Sorry, the file {path} does not exist.")
    [PRE461] Sorry, the file alice.txt does not exist. [PRE462] from pathlib import
    Path  path = Path(''alice.txt'') try:  contents = path.read_text(encoding=''utf-8'')
    except FileNotFoundError:  print(f"Sorry, the file {path} does not exist.") else:     #
    Count the approximate number of words in the file: ❶     words = contents.split()
    ❷     num_words = len(words)     print(f"The file {path} has about {num_words}
    words.") [PRE463] The file alice.txt has about 29594 words. [PRE464] from pathlib
    import Path  def count_words(path): ❶     """Count the approximate number of words
    in a file."""     try:  contents = path.read_text(encoding=''utf-8'')  except
    FileNotFoundError:  print(f"Sorry, the file {path} does not exist.")  else:  #
    Count the approximate number of words in the file:  words = contents.split()  num_words
    = len(words)  print(f"The file {path} has about {num_words} words.")  path = Path(''alice.txt'')
    count_words(path) [PRE465] from pathlib import Path  def count_words(filename):   *--snip--*  filenames
    = [''alice.txt'', ''siddhartha.txt'', ''moby_dick.txt'',          ''little_women.txt'']
    for filename in filenames: ❶     path = Path(filename)     count_words(path) [PRE466]
    The file alice.txt has about 29594 words. Sorry, the file siddhartha.txt does
    not exist. The file moby_dick.txt has about 215864 words. The file little_women.txt
    has about 189142 words. [PRE467] def count_words(path):  """Count the approximate
    number of words in a file."""  try:   *--snip--*  except FileNotFoundError:         pass  else:   *--snip--*
    [PRE468] The file alice.txt has about 29594 words. The file moby_dick.txt has
    about 215864 words. The file little_women.txt has about 189142 words. [PRE469]
    from pathlib import Path import json  numbers = [2, 3, 5, 7, 11, 13]  ❶ path =
    Path(''numbers.json'') ❷ contents = json.dumps(numbers) path.write_text(contents)
    [PRE470] [2, 3, 5, 7, 11, 13] [PRE471] from pathlib import Path import json  ❶
    path = Path(''numbers.json'') ❷ contents = path.read_text() ❸ numbers = json.loads(contents)  print(numbers)
    [PRE472] [2, 3, 5, 7, 11, 13] [PRE473] from pathlib import Path import json  ❶
    username = input("What is your name? ")  ❷ path = Path(''username.json'') contents
    = json.dumps(username) path.write_text(contents)  ❸ print(f"We''ll remember you
    when you come back, {username}!") [PRE474] What is your name? **Eric** We''ll
    remember you when you come back, Eric! [PRE475] from pathlib import Path import
    json  ❶ path = Path(''username.json'') contents = path.read_text() ❷ username
    = json.loads(contents)  print(f"Welcome back, {username}!") [PRE476] Welcome back,
    Eric! [PRE477] from pathlib import Path import json  path = Path(''username.json'')
    ❶ if path.exists():     contents = path.read_text()     username = json.loads(contents)     print(f"Welcome
    back, {username}!") ❷ else:     username = input("What is your name? ")     contents
    = json.dumps(username)     path.write_text(contents)     print(f"We''ll remember
    you when you come back, {username}!") [PRE478] What is your name? **Eric** We''ll
    remember you when you come back, Eric! [PRE479] Welcome back, Eric! [PRE480] from
    pathlib import Path import json  def greet_user(): ❶     """Greet the user by
    name."""     path = Path(''username.json'')  if path.exists():  contents = path.read_text()  username
    = json.loads(contents)  print(f"Welcome back, {username}!")  else:  username =
    input("What is your name? ")  contents = json.dumps(username)  path.write_text(contents)  print(f"We''ll
    remember you when you come back, {username}!")  greet_user() [PRE481] from pathlib
    import Path import json  def get_stored_username(path): ❶     """Get stored username
    if available."""  if path.exists():  contents = path.read_text()  username = json.loads(contents)         return
    username     else: ❷         return None  def greet_user():  """Greet the user
    by name."""     path = Path(''username.json'')     username = get_stored_username(path)
    ❸     if username:         print(f"Welcome back, {username}!")     else:  username
    = input("What is your name? ")  contents = json.dumps(username)  path.write_text(contents)  print(f"We''ll
    remember you when you come back, {username}!")  greet_user() [PRE482] from pathlib
    import Path import json  def get_stored_username(path):  """Get stored username
    if available."""     *--snip--*  def get_new_username(path):     """Prompt for
    a new username."""     username = input("What is your name? ")  contents = json.dumps(username)  path.write_text(contents)     return
    username  def greet_user():  """Greet the user by name."""  path = Path(''username.json'')
    ❶ username = get_stored_username(path)  if username:  print(f"Welcome back, {username}!")  else:
    ❷         username = get_new_username(path)         print(f"We''ll remember you
    when you come back, {username}!")  greet_user() [PRE483] $ **python -m pip install
    --upgrade pip** ❶ Requirement already satisfied: pip in /.../python3.11/site-packages
    (22.0.4) `--snip--` ❷ Successfully installed pip-22.1.2 [PRE484] $ **python -m
    pip install --upgrade** `package_name` [PRE485] $ **python -m pip install --user
    pytest** Collecting pytest  `--snip--` Successfully installed attrs-21.4.0 iniconfig-1.1.1
    ...pytest-7.`x`.`x` [PRE486] $ **python -m pip install --user** `package_name`
    [PRE487] def get_formatted_name(first, last):     """Generate a neatly formatted
    full name."""     full_name = f"{first} {last}"     return full_name.title() [PRE488]
    from name_function import get_formatted_name  print("Enter ''q'' at any time to
    quit.") while True:     first = input("\nPlease give me a first name: ")     if
    first == ''q'':         break     last = input("Please give me a last name: ")     if
    last == ''q'':         break      formatted_name = get_formatted_name(first, last)     print(f"\tNeatly
    formatted name: {formatted_name}.") [PRE489] Enter ''q'' at any time to quit.  Please
    give me a first name: **janis** Please give me a last name: **joplin**        Neatly
    formatted name: Janis Joplin.  Please give me a first name: **bob** Please give
    me a last name: **dylan**         Neatly formatted name: Bob Dylan.  Please give
    me a first name: **q** [PRE490] from name_function import get_formatted_name  ❶
    def test_first_last_name():     """Do names like ''Janis Joplin'' work?""" ❷     formatted_name
    = get_formatted_name(''janis'', ''joplin'') ❸     assert formatted_name == ''Janis
    Joplin'' [PRE491] $ **pytest** ========================= test session starts =========================
    ❶ platform darwin -- Python 3.`x`.`x`, pytest-7.`x`.`x`, pluggy-1.`x`.`x` ❷ rootdir:
    /.../python_work/chapter_11 ❸ collected 1 item  ❹ test_name_function.py .                                          [100%]
    ========================== 1 passed in 0.00s ========================== [PRE492]
    def get_formatted_name(first, middle, last):     """Generate a neatly formatted
    full name."""     full_name = f"{first} {middle} {last}"     return full_name.title()
    [PRE493] $ **pytest** ========================= test session starts =========================
    `--snip--` ❶ test_name_function.py F                                          [100%]
    ❷ ============================== FAILURES =============================== ❸ ________________________
    test_first_last_name _________________________     def test_first_last_name():         """Do
    names like ''Janis Joplin'' work?""" ❹ >       formatted_name = get_formatted_name(''janis'',
    ''joplin'') ❺ E       TypeError: get_formatted_name() missing 1 required positional             argument:
    ''last''  test_name_function.py:5: TypeError ======================= short test
    summary info ======================= FAILED test_name_function.py::test_first_last_name
    - TypeError:     get_formatted_name() missing 1 required positional argument:
    ''last'' ========================== 1 failed in 0.04s ==========================
    [PRE494] def get_formatted_name(first, last, middle=''''):     """Generate a neatly
    formatted full name."""     if middle:         full_name = f"{first} {middle}
    {last}"     else:         full_name = f"{first} {last}"     return full_name.title()
    [PRE495] $ **pytest** ========================= test session starts =========================
    `--snip--` test_name_function.py .                                       [100%]
    ========================== 1 passed in 0.00s ========================== [PRE496]
    from name_function import get_formatted_name  def test_first_last_name():   *--snip--*  def
    test_first_last_middle_name():     """Do names like ''Wolfgang Amadeus Mozart''
    work?""" ❶     formatted_name = get_formatted_name(         ''wolfgang'', ''mozart'',
    ''amadeus'') ❷     assert formatted_name == ''Wolfgang Amadeus Mozart'' [PRE497]
    $ pytest ========================= test session starts =========================
    `--snip--` collected 2 items  ❶ test_name_function.py ..                                         [100%]
    ========================== 2 passed in 0.01s ========================== [PRE498]
    class AnonymousSurvey:     """Collect anonymous answers to a survey question."""  ❶     def
    __init__(self, question):         """Store a question, and prepare to store responses."""         self.question
    = question         self.responses = []  ❷     def show_question(self):         """Show
    the survey question."""         print(self.question)  ❸     def store_response(self,
    new_response):         """Store a single response to the survey."""         self.responses.append(new_response)  ❹     def
    show_results(self):         """Show all the responses that have been given."""         print("Survey
    results:")         for response in self.responses:             print(f"- {response}")
    [PRE499] from survey import AnonymousSurvey  # Define a question, and make a survey.
    question = "What language did you first learn to speak?" language_survey = AnonymousSurvey(question)  #
    Show the question, and store responses to the question. language_survey.show_question()
    print("Enter ''q'' at any time to quit.\n") while True:     response = input("Language:
    ")     if response == ''q'':         break     language_survey.store_response(response)  #
    Show the survey results. print("\nThank you to everyone who participated in the
    survey!") language_survey.show_results() [PRE500] What language did you first
    learn to speak? Enter ''q'' at any time to quit.  Language: **English** Language:
    **Spanish** Language: **English** Language: **Mandarin** Language: **q**  Thank
    you to everyone who participated in the survey! Survey results: - English - Spanish
    - English - Mandarin [PRE501] from survey import AnonymousSurvey  ❶ def test_store_single_response():     """Test
    that a single response is stored properly."""     question = "What language did
    you first learn to speak?" ❷     language_survey = AnonymousSurvey(question)     language_survey.store_response(''English'')
    ❸     assert ''English'' in language_survey.responses [PRE502] $ **pytest test_survey.py**
    ========================= test session starts ========================= `--snip--`
    test_survey.py .                                                 [100%] ==========================
    1 passed in 0.01s ========================== [PRE503] from survey import AnonymousSurvey  def
    test_store_single_response():  *--snip--*  def test_store_three_responses():     """Test
    that three individual responses are stored properly."""     question = "What language
    did you first learn to speak?"     language_survey = AnonymousSurvey(question)
    ❶     responses = [''English'', ''Spanish'', ''Mandarin'']     for response in
    responses:         language_survey.store_response(response)  ❷     for response
    in responses:         assert response in language_survey.responses [PRE504] $
    **pytest test_survey.py** ========================= test session starts =========================
    `--snip--` test_survey.py ..                                                [100%]
    ========================== 2 passed in 0.01s ========================== [PRE505]
    import pytest from survey import AnonymousSurvey  ❶ @pytest.fixture ❷ def language_survey():     """A
    survey that will be available to all test functions."""  question = "What language
    did you first learn to speak?"     language_survey = AnonymousSurvey(question)     return
    language_survey  ❸ def test_store_single_response(language_survey):     """Test
    that a single response is stored properly.""" ❹     language_survey.store_response(''English'')  assert
    ''English'' in language_survey.responses  ❺ def test_store_three_responses(language_survey):     """Test
    that three individual responses are stored properly."""     responses = [''English'',
    ''Spanish'', ''Mandarin'']  for response in responses: ❻ language_survey.store_response(response)   for
    response in responses:  assert response in language_survey.responses [PRE506]`'
  id: totrans-1361
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE352] `function_name`(`list_name`[:]) [PRE353] print_models(unprinted_designs[:],
    completed_models) [PRE354] def make_pizza(*toppings): """打印请求的配料列表。""" print(toppings)
    make_pizza(''pepperoni'') make_pizza(''mushrooms'', ''green peppers'', ''extra
    cheese'') [PRE355] (''pepperoni'',) (''mushrooms'', ''green peppers'', ''extra
    cheese'') [PRE356] def make_pizza(*toppings): """总结一下我们要做披萨。""" print("\nMaking
    a pizza with the following toppings:") for topping in toppings: print(f"- {topping}")
    make_pizza(''pepperoni'') make_pizza(''mushrooms'', ''green peppers'', ''extra
    cheese'') [PRE357] Making a pizza with the following toppings: - pepperoni Making
    a pizza with the following toppings: - mushrooms - green peppers - extra cheese
    [PRE358] def make_pizza(size, *toppings): """总结一下我们要做披萨。""" print(f"\nMaking a
    {size}-inch pizza with the following toppings:") for topping in toppings: print(f"-
    {topping}") make_pizza(16, ''pepperoni'') make_pizza(12, ''mushrooms'', ''green
    peppers'', ''extra cheese'') [PRE359] Making a 16-inch pizza with the following
    toppings: - pepperoni Making a 12-inch pizza with the following toppings: - mushrooms
    - green peppers - extra cheese [PRE360] def build_profile(first, last, **user_info):
    """创建一个包含用户所有信息的字典。""" ❶ user_info[''first_name''] = first user_info[''last_name'']
    = last return user_info user_profile = build_profile(''albert'', ''einstein'',
    location=''princeton'', field=''physics'') print(user_profile) [PRE361] {''location'':
    ''princeton'', ''field'': ''physics'', ''first_name'': ''albert'', ''last_name'':
    ''einstein''} [PRE362] def make_pizza(size, *toppings): """总结一下我们要做披萨。""" print(f"\nMaking
    a {size}-inch pizza with the following toppings:") for topping in toppings: print(f"-
    {topping}") [PRE363] import pizza ❶ pizza.make_pizza(16, ''pepperoni'') pizza.make_pizza(12,
    ''mushrooms'', ''green peppers'', ''extra cheese'') [PRE364] Making a 16-inch
    pizza with the following toppings: - pepperoni Making a 12-inch pizza with the
    following toppings: - mushrooms - green peppers - extra cheese [PRE365] `module_name`.`function_name`()
    [PRE366] from `module_name` import `function_name` [PRE367] from `module_name`
    import `function_0`, `function_1`, `function_2` [PRE368] from pizza import make_pizza
    make_pizza(16, ''pepperoni'') make_pizza(12, ''mushrooms'', ''green peppers'',
    ''extra cheese'') [PRE369] from pizza import make_pizza as mp mp(16, ''pepperoni'')
    mp(12, ''mushrooms'', ''green peppers'', ''extra cheese'') [PRE370] from `module_name`
    import `function_name` as `fn` [PRE371] import pizza as p p.make_pizza(16, ''pepperoni'')
    p.make_pizza(12, ''mushrooms'', ''green peppers'', ''extra cheese'') [PRE372]
    import `module_name` as `mn` [PRE373] from pizza import * make_pizza(16, ''pepperoni'')
    make_pizza(12, ''mushrooms'', ''green peppers'', ''extra cheese'') [PRE374] from
    `module_name` import * [PRE375] def `function_name`(`parameter_0`, `parameter_1`=''`default
    value`'') [PRE376] `function_name`(`value_0`, `parameter_1`=''`value`'') [PRE377]
    def `function_name`( `parameter_0`, `parameter_1`, `parameter_2`, `parameter_3`,
    `parameter_4`, `parameter_5`): `function body...` [PRE378] `  [PRE379] ❶ class
    Dog: """一个简单的模拟狗的尝试。""" ❷ def __init__(self, name, age): """初始化姓名和年龄属性。""" ❸ self.name
    = name self.age = age ❹ def sit(self): """模拟狗根据命令坐下。""" print(f"{self.name} is
    now sitting.") def roll_over(self): """模拟根据命令翻滚。""" print(f"{self.name} rolled
    over!") [PRE380] class Dog: *--snip--* ❶ my_dog = Dog(''Willie'', 6) ❷ print(f"My
    dog''s name is {my_dog.name}.") ❸ print(f"My dog is {my_dog.age} years old.")
    [PRE381] my_dog.name [PRE382] My dog''s name is Willie. My dog is 6 years old.
    [PRE383] class Dog: *--snip--* my_dog = Dog(''Willie'', 6) my_dog.sit() my_dog.roll_over()
    [PRE384] Willie is now sitting. Willie rolled over! [PRE385] class Dog: *--snip--*
    my_dog = Dog(''Willie'', 6) your_dog = Dog(''Lucy'', 3) print(f"My dog''s name
    is {my_dog.name}.") print(f"My dog is {my_dog.age} years old.") my_dog.sit() print(f"\nYour
    dog''s name is {your_dog.name}.") print(f"Your dog is {your_dog.age} years old.")
    your_dog.sit() [PRE386] My dog''s name is Willie. My dog is 6 years old. Willie
    is now sitting. Your dog''s name is Lucy. Your dog is 3 years old. Lucy is now
    sitting. [PRE387] class Car: """一个简单的表示汽车的尝试。""" ❶ def __init__(self, make, model,
    year): """初始化属性以描述汽车。""" self.make = make self.model = model self.year = year
    ❷ def get_descriptive_name(self): """返回一个格式整洁的描述性名称。""" long_name = f"{self.year}
    {self.make} {self.model}" return long_name.title() ❸ my_new_car = Car(''audi'',
    ''a4'', 2024) print(my_new_car.get_descriptive_name()) [PRE388] 2024 Audi A4 [PRE389]
    class Car: def __init__(self, make, model, year): """初始化属性以描述汽车。""" self.make
    = make self.model = model self.year = year ❶ self.odometer_reading = 0 def get_descriptive_name(self):
    *--snip--* ❷ def read_odometer(self): """打印一条显示汽车里程的语句。""" print(f"This car has
    {self.odometer_reading} miles on it.") my_new_car = Car(''audi'', ''a4'', 2024)
    print(my_new_car.get_descriptive_name()) my_new_car.read_odometer() [PRE390] 2024
    Audi A4 This car has 0 miles on it. [PRE391] class Car: *--snip--* my_new_car
    = Car(''audi'', ''a4'', 2024) print(my_new_car.get_descriptive_name()) my_new_car.odometer_reading
    = 23 my_new_car.read_odometer() [PRE392] 2024 Audi A4 This car has 23 miles on
    it. [PRE393] class Car: *--snip--* def update_odometer(self, mileage): """将里程表读数设置为给定值。"""
    self.odometer_reading = mileage my_new_car = Car(''audi'', ''a4'', 2024) print(my_new_car.get_descriptive_name())
    ❶ my_new_car.update_odometer(23) my_new_car.read_odometer() [PRE394] 2024 Audi
    A4 This car has 23 miles on it. [PRE395] class Car: *--snip--* def update_odometer(self,
    mileage): """ 将里程表读数设置为给定值。 如果尝试倒转里程表，则拒绝更改。 """ ❶ if mileage >= self.odometer_reading:
    self.odometer_reading = mileage else: ❷ print("You can''t roll back an odometer!")
    [PRE396] class Car: *--snip--* def update_odometer(self, mileage): *--snip--*
    def increment_odometer(self, miles): """将给定的量添加到里程表读数。""" self.odometer_reading
    += miles ❶ my_used_car = Car(''subaru'', ''outback'', 2019) print(my_used_car.get_descriptive_name())
    ❷ my_used_car.update_odometer(23_500) my_used_car.read_odometer() my_used_car.increment_odometer(100)
    my_used_car.read_odometer() [PRE397] 2019 Subaru Outback This car has 23500 miles
    on it. This car has 23600 miles on it. [PRE398] ❶ class Car: """一个简单的表示汽车的尝试。"""
    def __init__(self, make, model, year): """初始化属性以描述汽车。""" self.make = make self.model
    = model self.year = year self.odometer_reading = 0 def get_descriptive_name(self):
    """返回一个格式整洁的描述性名称。""" long_name = f"{self.year} {self.make} {self.model}" return
    long_name.title() def read_odometer(self): """打印一条显示汽车里程的语句。""" print(f"This car
    has {self.odometer_reading} miles on it.") def update_odometer(self, mileage):
    """将里程表读数设置为给定值。""" if mileage >= self.odometer_reading: self.odometer_reading
    = mileage else: print("You can''t roll back an odometer!") def increment_odometer(self,
    miles): """将给定的量添加到里程表读数。""" self.odometer_reading += miles ❷ class ElectricCar(Car):
    """表示汽车的各个方面，特别是电动汽车。""" ❸ def __init__(self, make, model, year): """初始化父类的属性。"""
    ❹ super().__init__(make, model, year) ❺ my_leaf = ElectricCar(''nissan'', ''leaf'',
    2024) print(my_leaf.get_descriptive_name()) [PRE399] 2024 Nissan Leaf [PRE400]
    class Car: *--snip--* class ElectricCar(Car): """表示汽车的各个方面，特别是电动汽车。""" def __init__(self,
    make, model, year): """ 初始化父类的属性。 然后初始化电动汽车特有的属性。 """ super().__init__(make, model,
    year) ❶ self.battery_size = 40 ❷ def describe_battery(self): """打印一条描述电池大小的语句。"""
    print(f"This car has a {self.battery_size}-kWh battery.") my_leaf = ElectricCar(''nissan'',
    ''leaf'', 2024) print(my_leaf.get_descriptive_name()) my_leaf.describe_battery()
    [PRE401] 2024 Nissan Leaf This car has a 40-kWh battery. [PRE402] class ElectricCar(Car):
    *--snip--* def fill_gas_tank(self): """电动汽车没有油箱。""" print("This car doesn''t have
    a gas tank!") [PRE403] class Car: *--snip--* class Battery: """一个简单的电动汽车电池模型。"""
    ❶ def __init__(self, battery_size=40): """初始化电池的属性。""" self.battery_size = battery_size
    ❷ def describe_battery(self): """打印一条描述电池大小的语句。""" print(f"This car has a {self.battery_size}-kWh
    battery.") class ElectricCar(Car): """表示汽车的各个方面，特别是电动汽车。""" def __init__(self,
    make, model, year): """ 初始化父类的属性。 然后初始化电动汽车特有的属性。 """ super().__init__(make, model,
    year) ❸ self.battery = Battery() my_leaf = ElectricCar(''nissan'', ''leaf'', 2024)
    print(my_leaf.get_descriptive_name()) my_leaf.battery.describe_battery() [PRE404]
    my_leaf.battery.describe_battery() [PRE405] 2024 Nissan Leaf This car has a 40-kWh
    battery. [PRE406] class Car: *--snip--* class Battery: *--snip--* def get_range(self):
    """打印一条关于此电池提供的续航里程的语句。""" if self.battery_size == 40: range = 150 elif self.battery_size
    == 65: range = 225 print(f"This car can go about {range} miles on a full charge.")
    class ElectricCar(Car): *--snip--* my_leaf = ElectricCar(''nissan'', ''leaf'',
    2024) print(my_leaf.get_descriptive_name()) my_leaf.battery.describe_battery()
    ❶ my_leaf.battery.get_range() [PRE407] 2024 Nissan Leaf This car has a 40-kWh
    battery. This car can go about 150 miles on a full charge. [PRE408] ❶ """一个可用于表示汽车的类。"""
    class Car: """一个简单的表示汽车的尝试。""" def __init__(self, make, model, year): """初始化属性以描述汽车。"""
    self.make = make self.model = model self.year = year self.odometer_reading = 0
    def get_descriptive_name(self): """返回一个格式整洁的描述性名称。""" long_name = f"{self.year}
    {self.make} {self.model}" return long_name.title() def read_odometer(self): """打印一条显示汽车里程的语句。"""
    print(f"This car has {self.odometer_reading} miles on it.") def update_odometer(self,
    mileage): """ 将里程表读数设置为给定值。 如果尝试倒转里程表，则拒绝更改。 """ if mileage >= self.odometer_reading:
    self.odometer_reading = mileage else: print("You can''t roll back an odometer!")
    def increment_odometer(self, miles): """将给定的量添加到里程表读数。""" self.odometer_reading
    += miles [PRE409] ❶ from car import Car my_new_car = Car(''audi'', ''a4'', 2024)
    print(my_new_car.get_descriptive_name()) my_new_car.odometer_reading = 23 my_new_car.read_odometer()
    [PRE410] 2024 Audi A4 This car has 23 miles on it. [PRE411] """一组用于表示汽油和电动汽车的类。"""
    class Car: *--snip--* class Battery: """一个简单的电动汽车电池模型。""" def __init__(self, battery_size=40):
    """初始化电池的属性。""" self.battery_size = battery_size def describe_battery(self): """打印一条描述电池大小的语句。"""
    print(f"This car has a {self.battery_size}-kWh battery.") def get_range(self):
    """打印一条关于此电池提供的续航里程的语句。""" if self.battery_size == 40: range = 150 elif self.battery_size
    == 65: range = 225 print(f"This car can go about {range} miles on a full charge.")
    class ElectricCar(Car): """模拟汽车的各个方面，特别是电动汽车。""" def __init__(self, make, model,
    year): """ 初始化父类的属性。 然后初始化电动汽车特有的属性。 """ super().__init__(make, model, year) self.battery
    = Battery() [PRE412] from car import ElectricCar my_leaf = ElectricCar(''nissan'',
    ''leaf'', 2024) print(my_leaf.get_descriptive_name()) my_leaf.battery.describe_battery()
    my_leaf.battery.get_range() [PRE413] 2024 Nissan Leaf This car has a 40-kWh battery.
    This car can go about 150 miles on a full charge. [PRE414] ❶ from car import Car,
    ElectricCar ❷ my_mustang = Car(''ford'', ''mustang'', 2024) print(my_mustang.get_descriptive_name())
    ❸ my_leaf = ElectricCar(''nissan'', ''leaf'', 2024) print(my_leaf.get_descriptive_name())
    [PRE415] 2024 Ford Mustang 2024 Nissan Leaf [PRE416] ❶ import car ❷ my_mustang
    = car.Car(''ford'', ''mustang'', 2024) print(my_mustang.get_descriptive_name())
    ❸ my_leaf = car.ElectricCar(''nissan'', ''leaf'', 2024) print(my_leaf.get_descriptive_name())
    [PRE417] from `module_name` import * [PRE418] """一组可用于表示电动汽车的类。""" from car import
    Car class Battery: *--snip--* class ElectricCar(Car): *--snip--* [PRE419] """一个可用于表示汽车的类。"""
    class Car: *--snip--* [PRE420] from car import Car from electric_car import ElectricCar
    my_mustang = Car(''ford'', ''mustang'', 2024) print(my_mustang.get_descriptive_name())
    my_leaf = ElectricCar(''nissan'', ''leaf'', 2024) print(my_leaf.get_descriptive_name())
    [PRE421] 2024 Ford Mustang 2024 Nissan Leaf [PRE422] from electric_car import
    ElectricCar as EC [PRE423] my_leaf = EC(''nissan'', ''leaf'', 2024) [PRE424] import
    electric_car as ec [PRE425] my_leaf = ec.ElectricCar(''nissan'', ''leaf'', 2024)
    [PRE426] >>> **from random import randint** >>> **randint(1, 6)** 3 [PRE427] >>>
    **from random import choice** >>> **players = [''charles'', ''martina'', ''michael'',
    ''florence'', ''eli'']** >>> **first_up = choice(players)** >>> **first_up** ''florence''
    [PRE428] 3.1415926535 8979323846 2643383279 [PRE429] from pathlib import Path
    ❶ path = Path(''pi_digits.txt'') ❷ contents = path.read_text() print(contents)
    [PRE430] 3.1415926535 8979323846 2643383279 [PRE431] from pathlib import Path
    path = Path(''pi_digits.txt'') contents = path.read_text() contents = contents.rstrip()
    print(contents) [PRE432] 3.1415926535 8979323846 2643383279 [PRE433] contents
    = path.read_text().rstrip() [PRE434] path = Path(''text_files/`filename`.txt'')
    [PRE435] path = Path(''/home/eric/data_files/text_files/`filename`.txt'') [PRE436]
    from pathlib import Path path = Path(''pi_digits.txt'') ❶ contents = path.read_text()
    ❷ lines = contents.splitlines() for line in lines: print(line) [PRE437] 3.1415926535
    8979323846 2643383279 [PRE438] from pathlib import Path path = Path(''pi_digits.txt'')
    contents = path.read_text() lines = contents.splitlines() pi_string = '''' ❶ for
    line in lines: pi_string += line print(pi_string) print(len(pi_string)) [PRE439]
    3.1415926535 8979323846 2643383279 36 [PRE440] *--snip--* for line in lines: pi_string
    += line.lstrip() print(pi_string) print(len(pi_string)) [PRE441] 3.141592653589793238462643383279
    32 [PRE442] from pathlib import Path path = Path(''pi_million_digits.txt'') contents
    = path.read_text() lines = contents.splitlines() pi_string = '''' for line in
    lines: pi_string += line.lstrip() print(f"{pi_string[:52]}...") print(len(pi_string))
    [PRE443] 3.14159265358979323846264338327950288419716939937510... 1000002 [PRE444]
    *--snip--* for line in lines: pi_string += line.strip() birthday = input("Enter
    your birthday, in the form mmddyy: ") if birthday in pi_string: print("Your birthday
    appears in the first million digits of pi!") else: print("Your birthday does not
    appear in the first million digits of pi.") [PRE445] Enter your birthdate, in
    the form mmddyy: **120372** Your birthday appears in the first million digits
    of pi! [PRE446] from pathlib import Path path = Path(''programming.txt'') path.write_text("I
    love programming.") [PRE447] I love programming. [PRE448] from pathlib import
    Path contents = "I love programming.\n" contents += "I love creating new games.\n"
    contents += "I also love working with data.\n" path = Path(''programming.txt'')
    path.write_text(contents) [PRE449] I love programming. I love creating new games.
    I also love working with data. [PRE450] print(5/0) [PRE451] Traceback (most recent
    call last): File "division_calculator.py", line 1, in <module> print(5/0) ~^~
    ❶ ZeroDivisionError: division by zero [PRE452] try: print(5/0) except ZeroDivisionError:
    print("You can''t divide by zero!") [PRE453] You can''t divide by zero! [PRE454]
    print("Give me two numbers, and I''ll divide them.") print("Enter ''q'' to quit.")
    while True: ❶ first_number = input("\nFirst number: ") if first_number == ''q'':
    break ❷ second_number = input("Second number: ") if second_number == ''q'': break
    ❸ answer = int(first_number) / int(second_number) print(answer) [PRE455] Give
    me two numbers, and I''ll divide them. Enter ''q'' to quit. First number: **5**
    Second number: **0** Traceback (most recent call last): File "division_calculator.py",
    line 11, in <module> answer = int(first_number) / int(second_number) ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
    ZeroDivisionError: division by zero [PRE456] *--snip--* while True: *--snip--*
    if second_number == ''q'': break ❶ try: answer = int(first_number) / int(second_number)
    ❷ except ZeroDivisionError: print("You can''t divide by 0!") ❸ else: print(answer)
    [PRE457] Give me two numbers, and I''ll divide them. Enter ''q'' to quit. First
    number: **5** Second number: **0** You can''t divide by 0! First number: **5**
    Second number: **2** 2.5 First number: **q** [PRE458] from pathlib import Path
    path = Path(''alice.txt'') contents = path.read_text(encoding=''utf-8'') [PRE459]
    Traceback (most recent call last): ❶ File "alice.py", line 4, in <module> ❷ contents
    = path.read_text(encoding=''utf-8'') ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ File "/.../pathlib.py",
    line 1056, in read_text with self.open(mode=''r'', encoding=encoding, errors=errors)
    as f: ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ File "/.../pathlib.py",
    line 1042, in open return io.open(self, mode, buffering, encoding, errors, newline)
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ❸ FileNotFoundError:
    [Errno 2] No such file or directory: ''alice.txt'' [PRE460] from pathlib import
    Path path = Path(''alice.txt'') try: contents = path.read_text(encoding=''utf-8'')
    ❶ except FileNotFoundError: print(f"Sorry, the file {path} does not exist.") [PRE461]
    Sorry, the file alice.txt does not exist. [PRE462] from pathlib import Path path
    = Path(''alice.txt'') try: contents = path.read_text(encoding=''utf-8'') except
    FileNotFoundError: print(f"Sorry, the file {path} does not exist.") else: # Count
    the approximate number of words in the file: ❶ words = contents.split() ❷ num_words
    = len(words) print(f"The file {path} has about {num_words} words.") [PRE463] The
    file alice.txt has about 29594 words. [PRE464] from pathlib import Path def count_words(path):
    ❶ """计算文件中单词的大概数量。""" try: contents = path.read_text(encoding=''utf-8'') except
    FileNotFoundError: print(f"Sorry, the file {path} does not exist.") else: # Count
    the approximate number of words in the file: words = contents.split() num_words
    = len(words) print(f"The file {path} has about {num_words} words.") path = Path(''alice.txt'')
    count_words(path) [PRE465] from pathlib import Path def count_words(filename):
    *--snip--* filenames = [''alice.txt'', ''siddhartha.txt'', ''moby_dick.txt'',
    ''little_women.txt''] for filename in filenames: ❶ path = Path(filename) count_words(path)
    [PRE466] The file alice.txt has about 29594 words. Sorry, the file siddhartha.txt
    does not exist. The file moby_dick.txt has about 215864 words. The file little_women.txt
    has about 189142 words. [PRE467] def count_words(path): """计算文件中单词的大概数量。""" try:
    *--snip--* except FileNotFoundError: pass else: *--snip--* [PRE468] The file alice.txt
    has about 29594 words. The file moby_dick.txt has about 215864 words. The file
    little_women.txt has about 189142 words. [PRE469] from pathlib import Path import
    json numbers = [2, 3, 5, 7, 11, 13] ❶ path = Path(''numbers.json'') ❷ contents
    = json.dumps(numbers) path.write_text(contents) [PRE470] [2, 3, 5, 7, 11, 13]
    [PRE471] from pathlib import Path import json ❶ path = Path(''numbers.json'')
    ❷ contents = path.read_text() ❸ numbers = json.loads(contents) print(numbers)
    [PRE472] [2, 3, 5, 7, 11, 13] [PRE473] from pathlib import Path import json ❶
    username = input("What is your name? ") ❷ path = Path(''username.json'') contents
    = json.dumps(username) path.write_text(contents) ❸ print(f"We''ll remember you
    when you come back, {username}!") [PRE474] What is your name? **Eric** We''ll
    remember you when you come back, Eric! [PRE475] from pathlib import Path import
    json ❶ path = Path(''username.json'') contents = path.read_text() ❷ username =
    json.loads(contents) print(f"Welcome back, {username}!") [PRE476] Welcome back,
    Eric! [PRE477] from pathlib import Path import json path = Path(''username.json'')
    ❶ if path.exists(): contents = path.read_text() username = json.loads(contents)
    print(f"Welcome back, {username}!") ❷ else: username = input("What is your name?
    ") contents = json.dumps(username) path.write_text(contents) print(f"We''ll remember
    you when you come back, {username}!") [PRE478] What is your name? **Eric** We''ll
    remember you when you come back, Eric! [PRE479] Welcome back, Eric! [PRE480] from
    pathlib import Path import json def greet_user(): ❶ """通过姓名问候用户。""" path = Path(''username.json'')
    if path.exists(): contents = path.read_text() username = json.loads(contents)
    print(f"Welcome back, {username}!") else: username = input("What is your name?
    ") contents = json.dumps(username) path.write_text(contents) print(f"We''ll remember
    you when you come back, {username}!") greet_user() [PRE481] from pathlib import
    Path import json def get_stored_username(path): ❶ """如果可用，获取存储的用户名。""" if path.exists():
    contents = path.read_text() username = json.loads(contents) return username else:
    ❷ return None def greet_user(): """通过姓名问候用户。""" path = Path(''username.json'')
    username = get_stored_username(path) ❸ if username: print(f"Welcome back, {username}!")
    else: username = input("What is your name? ") contents = json.dumps(username)
    path.write_text(contents) print(f"We''ll remember you when you come back, {username}!")
    greet_user() [PRE482] from pathlib import Path import json def get_stored_username(path):
    """如果可用，获取存储的用户名。""" *--snip--* def get_new_username(path): """提示输入新用户名。""" username
    = input("What is your name? ") contents = json.dumps(username) path.write_text(contents)
    return username def greet_user(): """通过姓名问候用户。""" path = Path(''username.json'')
    ❶ username = get_stored_username(path) if username: print(f"Welcome back, {username}!")
    else: ❷ username = get_new_username(path) print(f"We''ll remember you when you
    come back, {username}!") greet_user() [PRE483] $ **python -m pip install --upgrade
    pip** ❶ Requirement already satisfied: pip in /.../python3.11/site-packages (22.0.4)
    `--snip--` ❷ Successfully installed pip-22.1.2 [PRE484] $ **python -m pip install
    --upgrade** `package_name` [PRE485] $ **python -m pip install --user pytest**
    Collecting pytest `--snip--` Successfully installed attrs-21.4.0 iniconfig-1.1.1
    ...pytest-7.`x`.`x` [PRE486] $ **python -m pip install --user** `package_name`
    [PRE487] def get_formatted_name(first, last): """生成一个格式整洁的全名。""" full_name = f"{first}
    {last}" return full_name.title() [PRE488] from name_function import get_formatted_name
    print("Enter ''q'' at any time to quit.") while True: first = input("\nPlease
    give me a first name: ") if first == ''q'': break last = input("Please give me
    a last name: ") if last == ''q'': break formatted_name = get_formatted_name(first,
    last) print(f"\tNeatly formatted name: {formatted_name}.") [PRE489] Enter ''q''
    at any time to quit. Please give me a first name: **janis** Please give me a last
    name: **joplin** Neatly formatted name: Janis Joplin. Please give me a first name:
    **bob** Please give me a last name: **dylan** Neatly formatted name: Bob Dylan.
    Please give me a first name: **q** [PRE490] from name_function import get_formatted_name
    ❶ def test_first_last_name(): """像“Janis Joplin”这样的名字有效吗？""" ❷ formatted_name
    = get_formatted_name(''janis'', ''joplin'') ❸ assert formatted_name == ''Janis
    Joplin'' [PRE491] $ **pytest** ========================= test session starts =========================
    ❶ platform darwin -- Python 3.`x`.`x`, pytest-7.`x`.`x`, pluggy-1.`x`.`x` ❷ rootdir:
    /.../python_work/chapter_11 ❸ collected 1 item ❹ test_name_function.py . [100%]
    ========================== 1 passed in 0.00s ========================== [PRE492]
    def get_formatted_name(first, middle, last): """生成一个格式整洁的全名。""" full_name = f"{first}
    {middle} {last}" return full_name.title() [PRE493] $ **pytest** =========================
    test session starts ========================= `--snip--` ❶ test_name_function.py
    F [100%] ❷ ============================== FAILURES ===============================
    ❸ ________________________ test_first_last_name'
