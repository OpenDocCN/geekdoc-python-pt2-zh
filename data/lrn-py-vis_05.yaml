- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Iteration and Randomness
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代与随机性
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: In Chapter 4, you learned how to program divergent paths for Python to follow.
    In this chapter, you’ll create looped paths with `while` and `for` loop statements.
    *Loop statements* repeat actions, so you don’t need to rewrite the same or similar
    code multiple times, resulting in fewer lines of code. In other words, you can
    solve problems more efficiently with code that’s easier to adapt. You’ll use these
    loop statements to generate visual patterns in Processing.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4章中，你学习了如何为Python编程实现分支路径。在本章中，你将使用`while`和`for`循环语句创建循环路径。*循环语句*重复动作，这样你就无需多次编写相同或相似的代码，从而减少了代码行数。换句话说，你可以使用更易于适应的代码更高效地解决问题。你将使用这些循环语句在Processing中生成视觉图案。
- en: You’ll also learn to apply randomness to your patterns to make them more compelling
    and unpredictable. Processing’s `random()` function is useful for generating randomized
    arguments in your shape functions, allowing you to create irregular designs. You
    can also randomize the conditions for your control flow statements so that your
    code executes differently on each run. Randomness is, undoubtedly, one of the
    most useful and exciting tools in the creative coder’s toolset, because it allows
    you to write programs that can produce unpredictable results.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你还将学习如何将随机性应用到你的图案中，使其更加引人注目且不可预测。Processing的`random()`函数非常有用，可以为你的形状函数生成随机化的参数，允许你创建不规则的设计。你还可以随机化控制流语句的条件，使得每次运行时你的代码都会有所不同。毫无疑问，随机性是创意编程工具集中最有用且最激动人心的工具之一，因为它使你能够编写出能够产生不可预测结果的程序。
- en: Iteration
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代
- en: In computer programming, *iteration* is the process of repeating a series of
    instructions a specified number of times or until a condition is met. As an example,
    say you want to tile a floor. Starting in one corner, you lay one tile. Then you
    place another tile next to it, repeating the process until you’ve reached the
    opposite wall, at which point you move down a row and continue. In this scenario,
    placing an individual tile is a single iteration. In many iterative processes,
    the result of a previous iteration defines the starting point of the next.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机编程中，*迭代*是重复一系列指令指定次数或直到满足某个条件的过程。举个例子，假设你要铺设地板。你从一个角落开始，放置一块瓷砖。然后你将另一块瓷砖放在它旁边，重复这个过程直到你到达对面的墙壁，然后向下移动一行继续。在这个场景中，放置一块瓷砖就是一次迭代。在许多迭代过程中，前一次迭代的结果定义了下一次迭代的起始点。
- en: Tasks like tiling can be tedious work, though. Humans are exemplary in reasoning
    and creative thought, but if not sufficiently stimulated, they tend to lose interest
    in performing such monotonous activities. Computers, however, excel at performing
    repetitive tasks rapidly and accurately, especially when numbers are involved.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，像铺设瓷砖这样的任务可能是繁琐的工作。人类在推理和创造性思维方面非常出色，但如果没有足够的刺激，他们往往会失去对执行这种单调活动的兴趣。然而，计算机在执行重复性任务时，尤其是在涉及数字时，能够迅速且精确地完成。
- en: Using Iteration to Draw Concentric Circles
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用迭代绘制同心圆
- en: 'To begin exploring iteration in Processing, create a new sketch and save it
    as *concentric_circles*. Add the following code:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始在Processing中探索迭代，创建一个新的草图并将其保存为*concentric_circles*。然后添加以下代码：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Each `circle()` function has its x-y coordinate placed in the center of the
    display window. The first circle is the smallest, with a diameter argument of
    `30`; each subsequent circle is 30 pixels larger in diameter than the one preceding
    it. The program runs each `circle()` function line by line, advancing toward a
    display window filled with concentric circles ([Figure 5-1](#figure5-1)).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`circle()`函数的x-y坐标都放置在显示窗口的中心。第一个圆是最小的，直径参数为`30`；每个后续的圆直径比前一个大30像素。程序逐行运行每个`circle()`函数，向着一个充满同心圆的显示窗口（[图
    5-1](#figure5-1)）推进。
- en: '![f05001](image_fi/500969c05/f05001.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![f05001](image_fi/500969c05/f05001.png)'
- en: 'Figure 5-1: Three circles rendered using three `circle()` functions'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-1：使用三个`circle()`函数绘制的三圆
- en: However, to fill the entire window, you’d need to write many more `circle()`
    lines. Instead of adding `circle()` functions manually, you can use a Python `while`loop
    to run them iteratively.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，要填满整个窗口，你需要写更多的`circle()`行代码。你可以使用Python的`while`循环来迭代运行这些`circle()`函数，而不是手动添加`circle()`函数。
- en: while Loops
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: while 循环
- en: A `while` loop is a control flow statement that looks and behaves much like
    `if`. The key difference is that `while` continues to execute the lines indented
    beneath it *until* its accompanying condition is no longer true.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环是一种控制流语句，类似于`if`语句。关键区别在于`while`会继续执行它下方缩进的代码*直到*条件不再成立。'
- en: 'Back in your *concentric_circles* sketch, comment out the `circle()` lines
    by using `''''''` for multiline comments, and add a basic `while` loop structure:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的*同心圆*草图中，通过使用`'''`进行多行注释，将`circle()`行注释掉，并添加一个基本的`while`循环结构：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `i` variable is defined to serve as your *loop counter*, controlling the
    iterations of the `while` statement. For the `while` expression, `i` is equal
    to 0 and, therefore, is less than 24\. Unlike an `if` statement that would execute
    the `print()` function a single time, the `while` repeatedly executes the `print`
    line until the value of `i` reaches 24—which, in this case, is never.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`i`变量被定义为*循环计数器*，控制`while`语句的迭代。对于`while`表达式，`i`等于0，因此小于24。与仅执行一次`print()`函数的`if`语句不同，`while`会重复执行`print`语句，直到`i`的值达到24——而在此情况下，永远不会达到。'
- en: Running the sketch should print an endless list of `0` digits to the console
    ([Figure 5-2](#figure5-2)).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 运行草图时，控制台将打印出一连串的`0`（[图5-2](#figure5-2)）。
- en: '![f05002](image_fi/500969c05/f05002.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![f05002](image_fi/500969c05/f05002.png)'
- en: 'Figure 5-2: The console lists endless lines of zeros.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-2：控制台列出了无尽的零。
- en: This code has crashed your program by sending it into an infinitive loop! To
    exit the program, click the **Stop** button. Processing may take some time to
    respond. The variable `i` remains 0, and the `i < 24` condition never achieves
    the `False` required to conclude the loop.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使你的程序崩溃，进入了一个无限循环！要退出程序，请点击**停止**按钮。处理可能需要一些时间才能响应。变量`i`保持为0，且`i < 24`条件永远无法达到`False`，因此循环无法结束。
- en: 'To correct this, add 1 to `i` with each iteration of the `while` loop:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了纠正这个问题，在每次`while`循环迭代时将`i`加1：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This new line states that the loop counter, `i`, is equal to itself plus 1\.
    On the first iteration, `i` is 0, which is less than 24, so the program prints
    `0`, adds 1 to `i`, and then begins the process again. On the next iteration,
    `i` is 1, which is still less than 24, so the program prints `1`, adds 1 to it,
    and restarts the process. The iteration continues as long as `i < 24` evaluates
    to `True`. Once `i` reaches 24, the program exits the loop and runs any other
    code that follows the `while` block.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码表示循环计数器`i`等于其自身加1。在第一次迭代时，`i`为0，满足小于24的条件，程序打印`0`，然后将`i`加1，开始下一次迭代。在下次迭代中，`i`为1，依然小于24，程序打印`1`，将`i`加1，并再次执行这个过程。只要`i
    < 24`的条件为`True`，迭代将继续。当`i`达到24时，程序将退出循环并执行`while`块之后的其他代码。
- en: Note that the output never reaches 24 ([Figure 5-3](#figure5-3)), because the
    `while` condition states “where `i` is less than 24,” not “less than or equal
    to 24.”
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，输出永远不会达到24（[图5-3](#figure5-3)），因为`while`条件语句中写的是“`i`小于24”，而不是“`i`小于或等于24”。
- en: 'To draw 24 circles, place a `circle()` function within the loop:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要绘制24个圆形，请在循环内放置`circle()`函数：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '![f05003](image_fi/500969c05/f05003.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![f05003](image_fi/500969c05/f05003.png)'
- en: 'Figure 5-3: The console displays 0 to 23, but not 24.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-3：控制台显示0到23，但不显示24。
- en: To avoid drawing 24 circles of exactly the same size, in the same position,
    use `i` as a multiplier for the `circle()` diameter argument. On the first iteration,
    the diameter argument is equal to `30*0`. Therefore, the first circle, placed
    in the very center of the display window, has a diameter of 0 and doesn’t render
    ([Figure 5-4](#figure5-4)).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免绘制24个大小完全相同、位置相同的圆形，可以将`i`作为`circle()`直径参数的乘数。在第一次迭代时，直径参数等于`30*0`。因此，第一个圆形位于显示窗口的正中心，直径为0，因此不会渲染出来（[图5-4](#figure5-4)）。
- en: The other 23 circles are enough to fill the 500 × 500 pixel area. By changing
    the number in the `while` statement, you may draw as many (or as few) circles
    as you like.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 其他23个圆形足以填满500 × 500像素的区域。通过修改`while`语句中的数字，你可以绘制任意数量的圆形（多或少）。
- en: '![f05004](image_fi/500969c05/f05004.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![f05004](image_fi/500969c05/f05004.png)'
- en: 'Figure 5-4: The drawing now has 24 circles (one invisible, and some partially
    cropped).'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-4：图形现在有24个圆形（其中一个不可见，另一些部分被裁剪）。
- en: for Loops
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: for 循环
- en: The Python `for` loop executes a given block of code a specified number of times.
    Unlike the `while` loop that relies on a conditional expression, the `for` loop
    iterates a sequence. A *sequence* is a collection of values; for instance, string
    data is a sequence of characters. Python *lists* are particularly versatile sequences,
    which I cover in Chapter 7. To generate sequences for the `for` loops in this
    section, you’ll use the `range()` function.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的 `for` 循环会执行指定次数的代码块。不同于依赖条件表达式的 `while` 循环，`for` 循环是对一个序列进行迭代。*序列*
    是一组值的集合；例如，字符串数据是字符的序列。Python 的 *列表* 是特别灵活的序列，关于列表的内容我将在第 7 章讲解。为了在本节的 `for` 循环中生成序列，你将使用
    `range()` 函数。
- en: A `for` loop is more appropriate than a `while` loop when you’ve established
    the number of iterations required before entering the loop. Generally speaking,
    the `for` loop is shorter and simpler, and won’t trigger infinite loops. When
    either a `while` or `for` will do, opt for the `for` loop.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在进入循环之前已经确定了所需的迭代次数时，`for` 循环比 `while` 循环更合适。一般来说，`for` 循环更简洁，且不会触发无限循环。当
    `while` 循环或 `for` 循环都能满足需求时，选择 `for` 循环。
- en: 'One of the easiest ways to understand the `for` loop is to convert something
    you already wrote that uses a `while` statement. Save *concentric_circles* as
    a new sketch called *for_loop* by using **File**▶**Save As**. Comment out the
    `while` loop parts, and add the following `for` loop:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 `for` 循环的最简单方法之一是将你已经写过的使用 `while` 语句的代码进行转换。通过使用 **文件**▶**另存为**，将 *concentric_circles*
    保存为一个名为 *for_loop* 的新草图。将 `while` 循环的部分注释掉，并添加以下 `for` 循环：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the `while` loop version, recall that you had to define the `i` variable
    to serve as a loop counter. With each iteration of the `while` block, you also
    had to increment `i` to avoid entering an endless loop. The `for` statement does
    away with the need to define and manage a separate counter variable.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `while` 循环版本中，记得你必须定义 `i` 变量作为循环计数器。每次 `while` 块迭代时，你还必须递增 `i` 以避免进入无限循环。`for`
    语句则不需要定义和管理一个单独的计数器变量。
- en: So, `i = 0` 1 is no longer necessary, nor is the nested statement to increment
    it 2. Instead, the `range()` function takes its argument of `24` to generate a
    sequence from 0 up to but not including 24 that controls the `for` 3 loop iteration
    behavior. On the first iteration, `i` is equal to 0, the first value in the sequence.
    With each subsequent iteration, the next value in the `range()` sequence is assigned
    to `i`. When `i` reaches 23, the `for` block runs for the last time, and then
    Python exits the loop. Run the sketch to confirm that the display window looks
    the same as [Figure 5-4](#figure5-4).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`i = 0` 1 就不再需要，也不再需要嵌套语句来递增它 2。相反，`range()` 函数接受 `24` 作为参数，生成从 0 到不包括 24
    的序列，控制 `for` 循环 3 的迭代行为。在第一次迭代时，`i` 等于 0，即序列中的第一个值。每次迭代后，`range()` 序列中的下一个值将赋给
    `i`。当 `i` 达到 23 时，`for` 块会执行最后一次，然后 Python 退出循环。运行草图以确认显示窗口与 [图 5-4](#figure5-4)
    看起来相同。
- en: 'The `range()` function can handle up to three parameters. Provide two arguments
    for a start and end value, respectively:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`range()` 函数最多可以接受三个参数。分别提供起始值和结束值两个参数：'
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this instance, the `circle()` function should execute three times, for `i`
    = 10, `i` = 11, and `i` = 12\. Run the sketch to see the result ([Figure 5-5](#figure5-5)).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`circle()` 函数应该执行三次，分别是 `i` = 10, `i` = 11 和 `i` = 12。运行草图以查看结果（[图 5-5](#figure5-5)）。
- en: You should see three concentric rings.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能看到三个同心圆。
- en: '![f05005](image_fi/500969c05/f05005.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![f05005](image_fi/500969c05/f05005.png)'
- en: 'Figure 5-5: Result for `range(10, 13)`'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-5：`range(10, 13)` 的结果
- en: 'Now use three range arguments to represent a start, end, and step size, respectively.
    The *step size* is the difference between each integer in the sequence:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用三个范围参数来分别表示起始、结束和步长。*步长* 是序列中每个整数之间的差值：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this instance, the `circle()` function should execute four times, for `i`
    = 3, `i` = 6, `i` = 9, and `i` = 12\. The result should be four rings with enlarged
    spacing ([Figure 5-6](#figure5-6)).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`circle()` 函数应该执行四次，分别是 `i` = 3, `i` = 6, `i` = 9 和 `i` = 12。结果应该是四个间距增大的环（[图
    5-6](#figure5-6)）。
- en: '![f05006](image_fi/500969c05/f05006.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![f05006](image_fi/500969c05/f05006.png)'
- en: 'Figure 5-6: Result for `range(3, 13, 3)`'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-6：`range(3, 13, 3)` 的结果
- en: Experiment with different range arguments to see how the circles are affected.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试不同的范围参数，观察圆形是如何被影响的。
- en: 'Challenge #4: Create Line Patterns'
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '挑战 #4：创建线条图案'
- en: In this challenge, recreate the three patterns shown in [Figure 5-7](#figure5-7)
    by using the `line()` function and one `for` loop for each. Don’t worry if your
    code produces a slightly different result, as long as the basic pattern remains
    the same.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个挑战中，使用`line()`函数和每个图案一个`for`循环，重新创建[图5-7](#figure5-7)中展示的三个图案。如果你的代码产生的结果与示例稍有不同，也不要担心，只要基本图案保持不变即可。
- en: 'If you’re not sure where to begin, here are a few clues to help you approach
    each pattern:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不确定从哪里开始，这里有一些线索可以帮助你处理每个图案：
- en: The left pattern is similar to the concentric circles, except it has 12 diagonal
    lines.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 左侧的图案类似于同心圆，只是它有12条对角线。
- en: For the middle pattern, the line spacing increases by a multiple of 1.5 with
    each `for` loop iteration. Defining an additional variable may help.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于中间的图案，行间距随着每次`for`循环迭代增加1.5倍。定义一个额外的变量可能会有所帮助。
- en: The right pattern requires an `if...else` structure nested within the `for`
    loop. You might consider using a modulo (`%`) operator, described in Chapter 1,
    to establish whether `i` is odd or even.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右侧的图案需要在`for`循环中嵌套`if...else`结构。你可以考虑使用第1章中描述的取余（`%`）运算符来判断`i`是奇数还是偶数。
- en: If you need help, you can find the solution at [https://github.com/tabreturn/processing.py-book/tree/master/chapter-05-iteration_and_randomness/for_loop_patterns/](https://github.com/tabreturn/processing.py-book/tree/master/chapter-05-iteration_and_randomness/for_loop_patterns/).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要帮助，可以在[https://github.com/tabreturn/processing.py-book/tree/master/chapter-05-iteration_and_randomness/for_loop_patterns/](https://github.com/tabreturn/processing.py-book/tree/master/chapter-05-iteration_and_randomness/for_loop_patterns/)找到解决方案。
- en: '![f05007](image_fi/500969c05/f05007.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![f05007](image_fi/500969c05/f05007.png)'
- en: 'Figure 5-7: Three `for` loop patterns'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-7：三种`for`循环图案
- en: break and continue Statements
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`break`和`continue`语句'
- en: Loops provide an efficient way to automate and repeat tasks. Sometimes, though,
    you need to exit a loop prematurely. For example, when you draw a series of concentric
    circles to fill the display window, like in the earlier task, you might want to
    *break* the loop if the circles reach the edge of the display window before exhausting
    the sequence of `range()` values. If Python encounters a `break` statement within
    a `for` or `while` loop, it will immediately terminate the loop. Once the loop
    is terminated, your program will move along as usual.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 循环提供了一种高效的方式来自动化和重复任务。不过，有时你可能需要提前退出循环。例如，当你绘制一系列同心圆来填充显示窗口时（如前面的任务所示），如果圆形在`range()`值序列耗尽之前到达显示窗口的边缘，你可能想要*break*循环。如果Python在`for`或`while`循环中遇到`break`语句，它会立即终止该循环。循环终止后，程序会照常继续执行。
- en: Sometimes you need to terminate an iteration (not the entire loop), prompting
    Python to begin the next iteration immediately. For this, use the `continue` statement.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你需要终止一次迭代（而不是整个循环），让Python立即开始下一次迭代。为此，可以使用`continue`语句。
- en: Let’s look at a brief example comparing an ordinary loop, a loop with a `break`
    statement, and a loop with a `continue` statement. There’s no need to write any
    code. [Figure 5-8](#figure5-8) depicts three dotted lines, drawn from left to
    right using each type of loop.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个简单的示例，比较普通的循环、带有`break`语句的循环和带有`continue`语句的循环。无需编写任何代码。[图5-8](#figure5-8)展示了三条虚线，从左到右使用每种循环类型绘制。
- en: 'The loop for the pale blue (top) dotted line looks like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 淡蓝色（上方）虚线的循环如下所示：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: With each iteration, the `circle()` function draws a new dot, placing it 20
    pixels to the right of its predecessor. The first dot has an x-coordinate of 20;
    the loop completes as the dotted line reaches the `width` of the display window.
    This loop is not concerned with the two vertical red bands and draws dots right
    through them.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 每次迭代时，`circle()`函数绘制一个新的点，将其放置在前一个点右侧20像素的位置。第一个点的x坐标是20；当虚线达到显示窗口的`width`时，循环完成。这个循环不关心两个垂直的红色带，并会直接穿过它们绘制点。
- en: '![f05008](image_fi/500969c05/f05008.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![f05008](image_fi/500969c05/f05008.png)'
- en: 'Figure 5-8: Drawing dotted lines using different loops'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-8：使用不同循环绘制虚线
- en: 'The loop for the orange (middle) dotted line looks like this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 橙色（中间）虚线的循环如下所示：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `get()` function accepts an x-y coordinate and returns the color for the
    pixel at that position; to extract the red value for the pixel, you wrap the `get()`
    function with a `red()` function. This will return a red value between 0 and 255
    based on the RGB mixture, which means a value of 255 for any pixels in the bright
    red bands (`#FF0000`). The loop will check for a red pixel before it draws a dot;
    if detected, the `break` statement will terminate the loop. The `fill()` and `circle()`
    functions do not draw a dot on the final iteration, because the `break` statement
    exits the loop immediately.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`get()` 函数接受一个 x-y 坐标并返回该位置的像素颜色；要提取该像素的红色值，你需要将 `get()` 函数包裹在 `red()` 函数中。这会根据
    RGB 混合返回一个介于 0 和 255 之间的红色值，对于任何在亮红色带中的像素（`#FF0000`），其值为 255。循环会在绘制点之前检查是否有红色像素；如果检测到，`break`
    语句会终止循环。由于 `break` 语句会立即退出循环，`fill()` 和 `circle()` 函数在最后一次迭代时不会绘制任何点。'
- en: 'The loop for the green (bottom) dotted line looks like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 绿色（底部）虚线的循环如下所示：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This loop will check for a red pixel before it draws a dot; if the pixel is
    detected, the `continue` statement immediately terminates the current iteration
    of the loop to start at the beginning of the next, skipping over the `fill()`
    and `circle()` functions.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个循环会在绘制点之前检查是否有红色像素；如果检测到像素，`continue` 语句会立即终止当前循环的迭代，并开始下一次迭代，跳过 `fill()`
    和 `circle()` 函数。
- en: Randomness
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 随机性
- en: Randomness is an important concept in computer programming because of its applications
    in cryptography. Moreover, randomness is programmed into everything from video
    games to simulations to gambling software. However, computer-generated random
    numbers aren’t truly random, because they’re created using a specific algorithm.
    If you know the algorithm and the conditions used to generate “random” numbers,
    you can predict patterns in the sequence. Therefore, a computer can simulate randomness
    only by generating *pseudorandom* numbers, which are not truly random but statistically
    similar enough to actual random numbers.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 随机性是计算机编程中的一个重要概念，因为它在加密学中的应用。此外，随机性被编程应用于从视频游戏到模拟到赌博软件的各个领域。然而，计算机生成的随机数并不是真正的随机，因为它们是通过特定的算法生成的。如果你知道生成“随机”数所用的算法和条件，你就可以预测序列中的模式。因此，计算机只能通过生成*伪随机*数来模拟随机性，这些数并不是真正的随机数，但在统计上足够接近实际的随机数。
- en: In this section, you’ll use the Processing `random()` and `randomSeed()` functions
    to generate pseudorandom values. With these randomized values, you’ll draw more
    interesting patterns than you might be able to create with predefined values.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将使用 Processing 的 `random()` 和 `randomSeed()` 函数来生成伪随机值。利用这些随机值，你将绘制出比使用预定义值时更有趣的图案。
- en: random() Function
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: random() 函数
- en: 'Each time you call Processing’s `random()` function, it produces an unexpected
    value within a specified range. To begin experimenting with randomness, create
    a new sketch and save it as *random_functions*. Add the following setup code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用 Processing 的 `random()` 函数时，它会在指定的范围内生成一个意想不到的值。为了开始实验随机性，创建一个新的草图并将其保存为
    *random_functions*。添加以下设置代码：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The new sketch has a blue background. Soon, you’ll draw points; the size of
    your points is affected by the `strokeWeight()` function.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 新的草图有一个蓝色背景。很快，你将绘制点；点的大小受到 `strokeWeight()` 函数的影响。
- en: 'The `random()` function can accept up to two arguments. In the case of a single
    argument, you’re defining an upper limit:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`random()` 函数最多可以接受两个参数。如果只有一个参数，表示你定义了一个上限：'
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This code will display a random floating-point value ranging from 0 up to but
    not including 5.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码会显示一个范围从 0 到但不包括 5 的随机浮动值。
- en: 'Two arguments represent an upper and lower limit, respectively:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 两个参数分别表示上限和下限：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This time around, the console displays a random floating-point number ranging
    from 5 up to but not including 10.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，控制台会显示一个范围从 5 到但不包括 10 的随机浮动数。
- en: 'If you want a random integer instead, wrap the `random()` function in `int()`.
    This converts the floating point to an integer by removing the decimal point and
    everything that follows it:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要一个随机整数，可以将 `random()` 函数包裹在 `int()` 中。这会通过去掉小数点及其后的所有内容，将浮动数转换为整数：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[Figure 5-9](#figure5-9) shows what you can expect to see. Of course, given
    that the values are random, the console output will appear differently on your
    computer, as well as each time you run the sketch.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-9](#figure5-9) 显示了你可以预期看到的内容。当然，由于值是随机的，控制台输出在你的计算机上会有所不同，每次运行草图时也会有所不同。'
- en: '![f05009](image_fi/500969c05/f05009.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![f05009](image_fi/500969c05/f05009.png)'
- en: 'Figure 5-9: Experimenting with different `random``()` arguments'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-9：尝试不同的 `random()` 参数
- en: 'Next, let’s generate 50 random values. Rather than print a long list in the
    console area, plot them as a series of points sharing a y-coordinate. Add the
    following code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们生成50个随机值。与其在控制台区域打印一长串数据，不如将它们作为一系列共享 y 坐标的点进行绘制。添加以下代码：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This `point()` function uses the `random()` function to define its x-coordinate.
    The y-coordinate is always `height/2`. The points should distribute differently
    each time you run the sketch ([Figure 5-10](#figure5-10)).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `point()` 函数使用 `random()` 函数来定义其 x 坐标。y 坐标始终为 `height/2`。每次运行草图时，点的位置应该会有所不同（[图
    5-10](#figure5-10)）。
- en: '![f05010](image_fi/500969c05/f05010.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![f05010](image_fi/500969c05/f05010.png)'
- en: 'Figure 5-10: Random values distributed along a line'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-10：沿一条直线分布的随机值
- en: 'Now change the `range` argument from `50` to `500`, and plot the point using
    random x- and y-coordinates:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将 `range` 参数从 `50` 改为 `500`，并使用随机的 x 和 y 坐标绘制点：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The result should be a display window filled with 500 randomly positioned points
    ([Figure 5-11](#figure5-11)).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应该是一个显示窗口，里面填充了500个随机位置的点（[图 5-11](#figure5-11)）。
- en: '![f05011](image_fi/500969c05/f05011.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![f05011](image_fi/500969c05/f05011.png)'
- en: 'Figure 5-11: Filling the display window with randomly positioned points'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-11：用随机摆放的点填充显示窗口
- en: Each time you run the sketch, it produces a (slightly) different arrangement.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 每次运行草图时，它都会生成一个（略微）不同的排列。
- en: Random Seed
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 随机种子
- en: In Figures 5-10 and 5-11, Processing picks the coordinates from a pseudorandom
    *sequence* of numbers. This pseudorandom sequence itself relies on a *random seed*,
    which is an initial number the random function selects based on something unpredictable,
    like keystroke timing. For instance, you may have pressed your last key 684 milliseconds
    past the tick of the previous second. For a random number between 0 and 9, your
    computer can grab the last digit of the 684 (which is a 4). The random seed determines
    what you’ll get from your first `random()` call as well as all subsequent calls.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在图 5-10 和图 5-11 中，Processing 从伪随机的 *序列* 中选择坐标。这个伪随机序列本身依赖于一个 *随机种子*，这是一个随机函数根据不可预测的因素（如按键时间）选择的初始数字。例如，你可能在上一秒的时刻过去684毫秒时按下了最后一个键。对于
    0 到 9 之间的随机数，你的计算机会抓取 684 的最后一位数字（即 4）。随机种子决定了你从第一次 `random()` 调用中得到的结果以及后续所有调用的结果。
- en: 'You can use Processing’s `randomSeed()` function to set the random seed manually.
    Change the range argument to `10`, and insert a `randomSeed()` line at the very
    top of your working sketch:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 Processing 的 `randomSeed()` 函数手动设置随机种子。将范围参数改为 `10`，并在工作草图的最顶部插入一行 `randomSeed()`：
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This `randomSeed()` function accepts a single argument, any integer of your
    choice, but you’ll use `213` for this example. Unlike the 500-point ([Figure 5-11](#figure5-11))
    version in which no random seed had been defined, every run of the code produces
    the same pattern, on any computer that executes it.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `randomSeed()` 函数接受一个单一的参数，任何你选择的整数，不过在本例中我们使用 `213`。与 500 个点的（[图 5-11](#figure5-11)）版本不同，该版本没有定义随机种子，每次运行代码时都会产生相同的模式，在任何执行它的计算机上都是如此。
- en: This ability to ensure that the program generates the same sequence of pseudorandom
    numbers with every run is useful in many applications. For example, suppose you
    developed a platform game using levels composed of randomly positioned obstacles.
    Not having to place obstacles manually would save a lot of time. However, you
    discover that specific sequences of pseudorandom numbers produce more engaging
    levels than others. What’s more, the resulting levels vary in difficulty, so you
    need to control the order in which the player progresses through them. If you’re
    aware of the seed values that produce each level, you can reproduce any of them,
    on demand, with just an integer.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这种确保程序每次运行时生成相同伪随机数序列的能力在许多应用中非常有用。例如，假设你开发了一个平台游戏，关卡中包含随机摆放的障碍物。不需要手动摆放障碍物可以节省大量时间。然而，你发现某些伪随机数序列生成的关卡比其他的更具吸引力。而且，生成的关卡难度不同，所以你需要控制玩家通过关卡的顺序。如果你知道哪些种子值生成了每个关卡，你就可以仅通过一个整数按需重现任何一个关卡。
- en: In the next section, you’ll combine a `for` loop and the `random()` function
    to create interesting tile arrangements.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一部分，你将结合 `for` 循环和 `random()` 函数来创建有趣的瓷砖排列。
- en: Truchet Tiles
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Truchet 瓷砖
- en: Sébastien Truchet (1657–1729), a French Dominican priest, was active in the
    fields of mathematics, hydraulics, graphics, and typography. Among his many contributions,
    he developed a scheme for creating interesting patterns using tiles, which have
    since become known as *Truchet tiles*. The original Truchet tile is square and
    divided by a diagonal line between its opposing corners. This tile can be rotated
    in multiples of 90 degrees to produce four variants, as shown in [Figure 5-12](#figure5-12).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 塞巴斯蒂安·特鲁谢（Sébastien Truchet，1657–1729），一位法国多米尼加修道士，活跃于数学、水利学、图形学和排版学等领域。在他众多的贡献中，他开发了一种利用瓷砖创建有趣图案的方案，这些瓷砖后来被称为*Truchet
    瓷砖*。原始的 Truchet 瓷砖是方形的，并通过对角线将其对角角落分割。这个瓷砖可以以 90 度的倍数旋转，产生四种变体，如[图 5-12](#figure5-12)所示。
- en: '![f05012](image_fi/500969c05/f05012.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![f05012](image_fi/500969c05/f05012.png)'
- en: 'Figure 5-12: A Truchet tile, presented in its four possible orientations'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-12：一块 Truchet 瓷砖，展示了其四种可能的方向
- en: These tiles are arranged on a square grid, either randomly or according to a
    pattern, to create aesthetically pleasing designs. [Figure 5-13](#figure5-13)
    presents just four possible arrangements, including a randomized tiling (bottom
    right) with some ordered approaches.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这些瓷砖排列在一个方形网格上，可以是随机的或根据某种模式排列，以创建美观的设计。[图 5-13](#figure5-13) 展示了四种可能的排列，包括一个随机的瓷砖排列（右下角）以及一些有序的排列方法。
- en: '![f05013](image_fi/500969c05/f05013.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![f05013](image_fi/500969c05/f05013.png)'
- en: 'Figure 5-13: Four Truchet tile layouts'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-13：四种 Truchet 瓷砖布局
- en: Next, you’ll use the quarter-circle Truchet tile, shown in [Figure 5-14](#figure5-14),
    in its two possible orientations.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将使用[图 5-14](#figure5-14)中展示的四分之一圆 Truchet 瓷砖，并以其两种可能的方向进行排列。
- en: 'Let’s apply the looping and randomness techniques you learned in this chapter
    to create different patterns using this tile. Create a new sketch and save it
    as *truchet_tiles*. Add the following setup code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运用你在本章中学到的循环和随机性技术，使用这种瓷砖创建不同的图案。创建一个新的草图，并将其保存为 *truchet_tiles*。添加以下设置代码：
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The new sketch has a blue background. Every shape you draw will have no fill
    and a white stroke of 3 pixels. This is for drawing the quarter-circle designs
    shown in [Figure 5-14](#figure5-14). Each tile is 50 × 50 pixels, so there’s room
    for exactly 12 (600 ÷ 50) columns and 12 rows. Filling the display window, therefore,
    requires 144 (12 × 12) tiles, hence the `range(1, 145)`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 新的草图有一个蓝色背景。你绘制的每个形状将没有填充，只有 3 像素宽的白色轮廓线。这是为了绘制[图 5-14](#figure5-14)中展示的四分之一圆设计。每块瓷砖的大小是
    50 × 50 像素，因此显示窗口可以正好放下 12 列（600 ÷ 50）和 12 行。因此，填满显示窗口需要 144 块（12 × 12）瓷砖，这就是
    `range(1, 145)` 的由来。
- en: '![f05014](image_fi/500969c05/f05014.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![f05014](image_fi/500969c05/f05014.png)'
- en: 'Figure 5-14: Quarter-circle Truchet tiles'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-14：四分之一圆 Truchet 瓷砖
- en: Run the sketch. A single tile should appear in the upper left corner ([Figure
    5-15](#figure5-15)).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 运行草图。一个瓷砖应出现在左上角（[图 5-15](#figure5-15)）。
- en: '![f05015](image_fi/500969c05/f05015.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![f05015](image_fi/500969c05/f05015.png)'
- en: 'Figure 5-15: All 144 tiles placed in the upper left corner'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-15：所有 144 块瓷砖放置在左上角
- en: In actuality, in [Figure 5-15](#figure5-15), you’re looking at all 144 tiles
    placed in the same position!
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在[图 5-15](#figure5-15)中，你看到的是所有 144 块瓷砖放置在同一个位置！
- en: 'To control the column and row positioning, use `col` and `row` variables. Amend
    your script as per the boldface code:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要控制列和行的位置，使用 `col` 和 `row` 变量。根据粗体代码修改你的脚本：
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: With each iteration of the loop, the `col` variable (tile y-coordinate) is increased
    by `50`. The result should be that each tile is placed to the right of its predecessor,
    as shown in [Figure 5-16](#figure5-16).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 每次循环迭代时，`col` 变量（瓷砖的 y 坐标）增加 `50`。结果应当是每个瓷砖放置在其前一个瓷砖的右边，如[图 5-16](#figure5-16)所示。
- en: '![f05016](image_fi/500969c05/f05016.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![f05016](image_fi/500969c05/f05016.png)'
- en: 'Figure 5-16: The remaining 132 tiles lie beyond the right edge.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-16：剩余的 132 块瓷砖位于右边缘之外。
- en: 'There’s a problem, though: the program doesn’t know when to return to the left
    edge and begin a new row. Instead, the tiles overflow, extending out beyond the
    right edge where you cannot see them.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个问题：程序不知道何时返回左边缘并开始新的一行。相反，瓷砖溢出，延伸到右边缘，超出了可见范围。
- en: 'To correct this, nest an `if` statement within the loop:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了纠正这一点，在循环中嵌套一个 `if` 语句：
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `i % 12` will return 0 for any value of `i` divisible by 12\. In other words,
    if the remainder of a divide-by-12 operation is equal to 0, you know that you’ve
    just laid another 12 tiles. At this moment, the `row` variable is advanced by
    50, and the `col` resets to 0\. The next tile is now set up for placement at the
    beginning of a new row, which should result in a display window filled with tiles
    ([Figure 5-17](#figure5-17)).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`i % 12`对于任何能够被12整除的`i`值都会返回0。换句话说，如果一个除以12的操作余数为0，就表示你刚刚放置了另外12个瓷砖。此时，`row`变量会增加50，`col`会重置为0。下一个瓷砖会被放置在新一行的开头，这将导致显示窗口充满瓷砖（[图5-17](#figure5-17)）。'
- en: '![f05017](image_fi/500969c05/f05017.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![f05017](image_fi/500969c05/f05017.png)'
- en: 'Figure 5-17: The display window filled with quarter-circle Truchet tiles'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-17：充满四分之一圆形Truchet瓷砖的显示窗口
- en: 'To make things more interesting, randomize the orientation of each tile by
    adding this `if...else` structure:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了增加趣味性，通过添加以下`if...else`结构来随机化每个瓷砖的方向：
- en: '[PRE20]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: A `random(2)` function 1 will return a floating-point value ranging from 0 up
    to but not including 2\. Converting the result to an integer by wrapping it in
    an `int()`, therefore, produces a 0 or 1\. This is akin to flipping a coin, which
    is now performed with each iteration to decide which of the two tile orientations
    to pick. Because this “coin flip” operation returns a Boolean-compatible value—a
    0 or 1—it can stand alone as the `if` statement’s condition, no relational operators
    necessary. The `else` code 2 runs if the result of the coin flip is a 0, because
    a `0` is equivalent to `False` (and `if` runs only on a `True`).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`random(2)`函数会返回一个从0到不包括2的浮点值。因此，将结果通过`int()`转换为整数，便会得到0或1。这就像是抛硬币，每次迭代时会决定选择哪种瓷砖方向。因为这个“抛硬币”操作返回的是一个布尔兼容的值——0或1——它可以作为`if`语句的条件，完全不需要关系运算符。如果抛硬币的结果是0，`else`代码2将会运行，因为`0`等同于`False`（而`if`只在`True`时运行）。'
- en: Each time you run the sketch, the display window presents a different pattern
    ([Figure 5-18](#figure5-18)).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 每次运行草图时，显示窗口都会呈现不同的图案（[图5-18](#figure5-18)）。
- en: '![f05018](image_fi/500969c05/f05018.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![f05018](image_fi/500969c05/f05018.png)'
- en: 'Figure 5-18: An arrangement of randomized quarter-circle Truchet tiles'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-18：随机排列的四分之一圆形Truchet瓷砖
- en: If you’ve ever played the strategy game *Trax*, this pattern will look familiar.
    Another tile-based strategy game, *Tantrix*, uses a hexagonal adaptation of a
    Truchet tile. Of course, there’s far more to tiles than the Truchet variety. You
    can try adding fills, switching out semicircles for diagonal lines, adding extra
    tiles to the set, or adding rules about which tiles can be placed next to one
    another ([Figure 5-19](#figure5-19)). If you’re looking for some fun projects,
    plenty of tiling patterns are available for inspiration.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经玩过策略游戏*Trax*，这个图案应该很熟悉。另一个基于瓷砖的策略游戏*Tantrix*使用了Truchet瓷砖的六边形变体。当然，瓷砖的种类远不止Truchet这一种。你可以尝试添加填充、将半圆形替换为对角线、增加额外的瓷砖或添加有关瓷砖之间可以相邻的规则（[图5-19](#figure5-19)）。如果你在寻找有趣的项目，许多瓷砖图案可供灵感参考。
- en: '![f05019](image_fi/500969c05/f05019.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![f05019](image_fi/500969c05/f05019.png)'
- en: 'Figure 5-19: Variations of Truchet tiles'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-19：Truchet瓷砖的变体
- en: You can find code for some Truchet tile variations at [https://github.com/tabreturn/processing.py-book/tree/master/chapter-05-iteration_and_randomness/truchet_tiles_variations](https://github.com/tabreturn/processing.py-book/tree/master/chapter-05-iteration_and_randomness/truchet_tiles_variations).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://github.com/tabreturn/processing.py-book/tree/master/chapter-05-iteration_and_randomness/truchet_tiles_variations](https://github.com/tabreturn/processing.py-book/tree/master/chapter-05-iteration_and_randomness/truchet_tiles_variations)找到一些Truchet瓷砖变体的代码。
- en: As your programs grow more complex, you’ll find multiple ways to code the same
    outcome. For example, you could have laid the quarter-circle Truchet tiles by
    using a loop within a loop, using `range()` functions with a step-size argument,
    in various combinations. Among the Truchet tile variations on Github, you’ll find
    an example named *loop_within_a_loop* that uses this approach. Now that you understand
    control flow, you can begin thinking about how to optimize your algorithms for
    improved readability and efficiency.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你的程序变得越来越复杂，你会发现有多种方法可以编码出相同的结果。例如，你可以通过在一个循环内使用另一个循环，利用带步长参数的`range()`函数，或是各种组合方式来铺设四分之一圆形的Truchet瓷砖。在Github上的Truchet瓷砖变体中，你会找到一个名为*loop_within_a_loop*的示例，它采用了这种方法。现在你已经理解了控制流，你可以开始思考如何优化算法以提高可读性和效率。
- en: Summary
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: You’ve now learned about iteration and how to program loops using `while` and
    `for` statements; this allows you to accomplish more in fewer lines of code, with
    code that’s more adaptable. Loops will reappear throughout the course of this
    book, providing plenty more opportunities for you to master them.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经学习了迭代以及如何使用`while`和`for`语句编写循环；这让您能够用更少的代码行完成更多的任务，且代码更加灵活。循环将在本书的后续章节中不断出现，为您提供更多掌握它们的机会。
- en: This chapter also introduced randomness, which is useful in a variety of computing
    applications, including creative coding. The Processing `random()` function generates
    sequences of pseudorandom numbers, which you can control using a random seed in
    order to produce the same sequence of values each time you run your sketch.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还介绍了随机性，它在各种计算应用中都很有用，包括创意编程。Processing 的`random()`函数生成伪随机数序列，您可以通过使用随机种子来控制这些序列，从而确保每次运行草图时产生相同的值序列。
- en: The next chapter deals with motion. You’ll learn how to add movement to your
    Processing sketches, and you’ll also look at transformation functions as efficient
    ways to move, rotate, and scale your elements, which is especially useful for
    groups of shapes.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍运动。您将学习如何为您的Processing草图添加运动，同时也会学习变换函数，作为高效的方式来移动、旋转和缩放您的元素，特别适用于一组形状。
