- en: '[3](nsp-venkitachalam503045-0008.xhtml#rch03)'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[3](nsp-venkitachalam503045-0008.xhtml#rch03)'
- en: Conway’s Game of Life
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 康威生命游戏
- en: '![](images/nsp-venkitachalam503045-circle-image.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-circle-image.jpg)'
- en: You can use a computer to study a system by creating a mathematical model for
    that system, writing a program to represent the model, and then letting the model
    evolve over time. There are many kinds of computer simulations, but I’ll focus
    on a famous one called Conway’s Game of Life, the work of the British mathematician
    John Conway. The Game of Life is an example of a *cellular automaton*, a collection
    of colored cells on a grid that evolve through a number of time steps according
    to a set of rules defining the states of neighboring cells.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用计算机通过创建一个系统的数学模型，编写程序来表示该模型，然后让模型随时间演化，来研究一个系统。有许多种计算机模拟方法，但我将重点介绍一个著名的模拟——康威的生命游戏，这是英国数学家约翰·康威的作品。生命游戏是一个*细胞自动机*的例子，细胞自动机是一个在网格上由彩色单元格组成的集合，按照一组定义邻居单元格状态的规则，通过多个时间步演化。
- en: In this project, you’ll create an *N*×*N* grid of cells and simulate the evolution
    of the system over time by applying the rules of Conway’s Game of Life. You’ll
    display the state of the game at each time step and provide ways to save the output
    to a file. You’ll set the initial condition of the system to either a random distribution
    or a predesigned pattern.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将创建一个 *N*×*N* 的单元格网格，并通过应用康威生命游戏的规则来模拟系统随时间的演变。你将在每个时间步显示游戏的状态，并提供将输出保存到文件的方法。你将设置系统的初始条件，可以选择随机分布或预设计模式。
- en: 'This simulation consists of the following components:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 该模拟由以下几个组件组成：
- en: • A property defined in one- or two-dimensional space
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 在一维或二维空间中定义的属性
- en: • A mathematical rule to change this property for each step in the simulation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 用于在模拟中每一步改变该属性的数学规则
- en: • A way to display or capture the state of the system as it evolves
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 一种显示或捕获系统随时间演变状态的方法
- en: The cells in Conway’s Game of Life can be either ON or OFF. The game starts
    with an initial condition, in which each cell is assigned one of these states.
    Then, mathematical rules determine how each cell’s state will change over time.
    The amazing thing about Conway’s Game of Life is that with just four simple rules
    the system evolves to produce patterns that behave in incredibly complex ways,
    almost as if they were alive. Patterns include “gliders” that slide across the
    grid, “blinkers” that flash on and off, and even replicating patterns.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 康威生命游戏中的单元格可以是开启状态（ON）或关闭状态（OFF）。游戏从一个初始条件开始，其中每个单元格被分配一个这些状态之一。然后，数学规则决定每个单元格的状态如何随时间变化。康威生命游戏的惊人之处在于，仅仅通过四条简单的规则，系统就能演化出以令人难以置信复杂的方式表现的模式，几乎就像它们是活的一样。这些模式包括“滑行者”，它们在网格上滑动，“闪光灯”，它们闪烁开关，甚至是复制的模式。
- en: Of course, the philosophical implications of this game are also significant
    because they suggest that complex structures can evolve from simple rules without
    following any sort of preset pattern.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个游戏的哲学意义也很重大，因为它暗示着复杂的结构可以从简单的规则中演变出来，而无需遵循任何预设的模式。
- en: 'Here are some of the main concepts covered in this project:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本项目涉及的一些主要概念：
- en: • Using `matplotlib imshow` to represent a 2D grid of data
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用 `matplotlib imshow` 来表示二维数据网格
- en: • Using `matplotlib` for animation
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用 `matplotlib` 进行动画制作
- en: • Using the `numpy` array
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用 `numpy` 数组
- en: • Using the `%` operator for boundary conditions
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用 `%` 操作符处理边界条件
- en: • Setting up a random distribution of values
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 设置随机分布的值
- en: '[How It Works](nsp-venkitachalam503045-0008.xhtml#rah0501)'
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[它是如何工作的](nsp-venkitachalam503045-0008.xhtml#rah0501)'
- en: Because the Game of Life is built on a grid of nine squares, every cell has
    eight neighboring cells, as shown in [Figure 3-1](nsp-venkitachalam503045-0015.xhtml#fig3-1).
    A given cell (*i*, *j*) in the simulation is accessed on a grid [*i*][*j*], where
    *i* and *j* are the row and column indices, respectively. The value of a given
    cell at a given instant of time depends on the state of its neighbors at the previous
    time step.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 由于生命游戏是基于九个方格的网格构建的，每个单元格有八个邻居单元格，如[图 3-1](nsp-venkitachalam503045-0015.xhtml#fig3-1)所示。在模拟中，给定的单元格
    (*i*, *j*) 在网格 [*i*][*j*] 上访问，其中 *i* 和 *j* 分别是行和列的索引。给定单元格在某一时刻的值取决于其邻居在前一时间步的状态。
- en: '![](images/nsp-venkitachalam503045-f03001.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f03001.jpg)'
- en: 'Figure 3-1: A central cell (*i*, *j*) with eight neighboring cells'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-1：一个中心单元格 (*i*, *j*) 与八个邻居单元格
- en: 'Conway’s Game of Life has four rules:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 康威生命游戏有四条规则：
- en: 1\. If a cell is ON and has fewer than two neighbors that are ON, it turns OFF.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1\. 如果一个单元格是开启的，并且有少于两个邻居是开启的，它将关闭。
- en: 2\. If a cell is ON and has either two or three neighbors that are ON, it remains
    ON.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2\. 如果一个单元格是开启的，并且有两个或三个邻居也是开启的，它保持开启状态。
- en: 3\. If a cell is ON and has more than three neighbors that are ON, it turns OFF.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3\. 如果一个单元格是开启的，并且有超过三个邻居是开启的，它将关闭。
- en: 4\. If a cell is OFF and has exactly three neighbors that are ON, it turns ON.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 4\. 如果一个单元格是关闭的，并且恰好有三个邻居是开启的，它将开启。
- en: 'These rules are meant to mirror some basic ways that a group of organisms might
    fare over time: underpopulation and overpopulation kill cells by turning a cell
    OFF when it has fewer than two neighbors or more than three, but when the population
    is balanced, cells stay ON and reproduce by turning another cell from OFF to ON.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规则旨在模拟一群有机体随着时间推移的基本生存状态：人口不足和人口过多通过将单元格关闭来“杀死”它们，当单元格的邻居少于两个或多于三个时，但当人口平衡时，单元格保持开启并通过将另一个单元格从关闭变为开启来繁殖。
- en: I said that each cell has eight neighboring cells, but what about cells at the
    edge of the grid? Which cells are their neighbors? To answer this question, you
    need to think about *boundary conditions*, the rules that govern what happens
    to cells at the edges or boundaries of the grid. I’ll address this question by
    using *toroidal boundary conditions*, meaning that the square grid wraps around
    as if its shape were a torus. As shown in [Figure 3-2](nsp-venkitachalam503045-0015.xhtml#fig3-2),
    the grid is first warped so that its horizontal edges (A and B) join to form a
    cylinder, and then the cylinder’s vertical edges (C and D) are joined to form
    a torus. Once the torus has been formed, all cells have neighbors because the
    whole space has no edge.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我说每个单元格有八个邻居，但网格边缘的单元格呢？它们的邻居是哪些？为了回答这个问题，你需要考虑*边界条件*，即控制网格边缘或边界上单元格行为的规则。我将通过使用*环面边界条件*来解决这个问题，这意味着方形网格会像环面一样进行包装。如[图
    3-2](nsp-venkitachalam503045-0015.xhtml#fig3-2)所示，首先将网格的水平边缘（A 和 B）弯曲连接形成一个圆柱体，然后将圆柱体的垂直边缘（C
    和 D）连接起来形成一个环面。一旦形成环面，所有单元格都有邻居，因为整个空间没有边缘。
- en: '![](images/nsp-venkitachalam503045-f03002.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f03002.jpg)'
- en: 'Figure 3-2: A conceptual visualization of toroidal boundary conditions'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-2：环面边界条件的概念性可视化
- en: 'Toroidal boundary conditions are common in 2D simulations and games. For example,
    the game *Pac-Man* uses them. If you go off the top of the screen, you reappear
    on the bottom. If you go off the left side of the screen, you reappear on the
    right side. You’ll follow the same logic for the Game of Life simulation: for
    the cell in the top-left corner of the grid, for example, the neighbor directly
    above it will be the cell in the bottom-left corner, and the neighbor directly
    to the left of it will be in the cell in the top-right corner.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 环面边界条件在二维模拟和游戏中非常常见。例如，游戏*吃豆人*使用了这些条件。如果你从屏幕顶部离开，你会从底部重新出现。如果你从屏幕左侧离开，你会从右侧重新出现。你将在“生命游戏”的模拟中使用相同的逻辑：例如，对于网格左上角的单元格，它上方的邻居将是左下角的单元格，而它左侧的邻居将是右上角的单元格。
- en: 'Here’s a description of the algorithm you’ll use to apply the four rules and
    run the simulation:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是你将用于应用四条规则并运行模拟的算法描述：
- en: 1\. Initialize the cells in the grid.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1\. 初始化网格中的单元格。
- en: '2\. At each time step in the simulation, for each cell (*i*, *j*) in the grid,
    do the following:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2\. 在模拟的每一个时间步，对于网格中的每个单元格（*i*, *j*），执行以下操作：
- en: a. Update the value of cell (*i*, *j*) based on its neighbors, taking into account
    the boundary conditions.
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: a. 基于邻居的状态更新单元格（*i*, *j*）的值，并考虑边界条件。
- en: b. Update the display of grid values.
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: b. 更新网格值的显示。
- en: '[Requirements](nsp-venkitachalam503045-0008.xhtml#rah0502)'
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[需求](nsp-venkitachalam503045-0008.xhtml#rah0502)'
- en: You’ll use `numpy` arrays and the `matplotlib` library to display the simulation
    output, and you’ll use the `matplotlib` `animation` module to update the simulation.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用`numpy`数组和`matplotlib`库来显示模拟输出，并使用`matplotlib`的`animation`模块来更新模拟。
- en: '[The Code](nsp-venkitachalam503045-0008.xhtml#rah0503)'
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[代码](nsp-venkitachalam503045-0008.xhtml#rah0503)'
- en: We’ll examine key aspects of the program piece by piece, including how to represent
    the simulation grid using `numpy` and `matplotlib`, how to set the initial conditions
    for the simulation, how to account for toroidal boundary conditions, and how to
    implement the Game of Life rules. We’ll also look at the program’s `main()` function,
    which sends command line arguments to the program and sets the simulation into
    motion. To see the full project code, skip ahead to [“The Complete Code”](nsp-venkitachalam503045-0015.xhtml#ah0507)
    on [page 56](nsp-venkitachalam503045-0015.xhtml#p56). You can also download the
    code from [https://github.com/mkvenkit/pp2e/tree/main/conway](https://github.com/mkvenkit/pp2e/tree/main/conway).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐步分析程序的关键部分，包括如何使用`numpy`和`matplotlib`表示模拟网格，如何设置模拟的初始条件，如何考虑环形边界条件，以及如何实现生命游戏规则。我们还将讨论程序的`main()`函数，它接收命令行参数并启动模拟。若要查看完整的项目代码，请跳至[“完整代码”](nsp-venkitachalam503045-0015.xhtml#ah0507)部分，位于[第56页](nsp-venkitachalam503045-0015.xhtml#p56)。你还可以从[https://github.com/mkvenkit/pp2e/tree/main/conway](https://github.com/mkvenkit/pp2e/tree/main/conway)下载代码。
- en: '[Representing the Grid](nsp-venkitachalam503045-0008.xhtml#rbh0501)'
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[表示网格](nsp-venkitachalam503045-0008.xhtml#rbh0501)'
- en: 'To represent whether a cell is alive (ON) or dead (OFF) on the grid, you’ll
    use the values `255` and `0` for ON and OFF, respectively. You’ll display the
    current state of the grid using the `imshow()` method in `matplotlib`, which represents
    a matrix of numbers as an image. To get a feel for how it works, let’s try a simple
    example inside the Python interpreter. Enter the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了表示一个单元格是活的（ON）还是死的（OFF），你将使用值`255`表示ON，`0`表示OFF。你将使用`matplotlib`中的`imshow()`方法显示当前网格的状态，该方法将数字矩阵表示为图像。为了了解它是如何工作的，我们可以在Python解释器中尝试一个简单的例子。输入以下内容：
- en: '>>> `import numpy as np`'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> `import numpy as np`'
- en: '>>> `import matplotlib.pyplot as plt`'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> `import matplotlib.pyplot as plt`'
- en: ❶ >>> `x = np.array([[0, 0, 255], [255, 255, 0], [0, 255, 0]])`
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ >>> `x = np.array([[0, 0, 255], [255, 255, 0], [0, 255, 0]])`
- en: ❷ >>> `plt.imshow(x, interpolation='nearest')`
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ >>> `plt.imshow(x, interpolation='nearest')`
- en: '>>> `plt.show()`'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> `plt.show()`'
- en: You define a 2D `numpy` array of shape (3, 3) ❶, meaning the array has three
    rows and three columns. Each element of the array is an integer value. You then
    use the `plt.imshow()` method to display this matrix of values as an image ❷,
    passing in the interpolation option as `'nearest'` to get sharp edges for the
    cells (otherwise, they’d be fuzzy). [Figure 3-3](nsp-venkitachalam503045-0015.xhtml#fig3-3)
    shows the output of this code.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你定义了一个形状为（3，3）的二维`numpy`数组❶，这意味着数组有三行三列。数组的每个元素都是一个整数值。然后你使用`plt.imshow()`方法将这些值的矩阵显示为图像❷，并传入插值选项`'nearest'`，以确保单元格的边缘清晰（否则它们会显得模糊）。[图3-3](nsp-venkitachalam503045-0015.xhtml#fig3-3)展示了这段代码的输出。
- en: '![](images/nsp-venkitachalam503045-f03003.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f03003.jpg)'
- en: 'Figure 3-3: Displaying a grid of values'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-3：显示一个值的网格
- en: Notice that squares with a value of `0` (OFF) are given a darker color, while
    squares with a value of `255` (ON) are given a lighter color.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，值为`0`（OFF）的方格会显示较暗的颜色，而值为`255`（ON）的方格则显示较亮的颜色。
- en: '[Setting the Initial Conditions](nsp-venkitachalam503045-0008.xhtml#rbh0502)'
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[设置初始条件](nsp-venkitachalam503045-0008.xhtml#rbh0502)'
- en: To begin the simulation, set an initial state for each cell in the 2D grid.
    You can use a random distribution of ON and OFF cells and see what kinds of patterns
    emerge, or you can add some specific patterns and see how they evolve. We’ll look
    at both approaches.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始模拟，需要为二维网格中的每个单元格设置一个初始状态。你可以使用随机分布的ON和OFF单元格，看看会出现什么样的模式，或者可以添加一些特定的模式，看看它们如何演变。我们将同时讨论这两种方法。
- en: 'For a random initial state, use the `choice()` method from the `random` module
    in `numpy`. Enter the following in the Python interpreter to see how it works:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对于随机初始状态，可以使用`numpy`中`random`模块的`choice()`方法。请在Python解释器中输入以下内容，看看它是如何工作的：
- en: '>>> `np.random.choice([0, 255], 4*4, p=[0.1, 0.9]).reshape(4, 4)`'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> `np.random.choice([0, 255], 4*4, p=[0.1, 0.9]).reshape(4, 4)`'
- en: 'The output will be something like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将类似于以下内容：
- en: array([[255, 255, 255, 255],
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: array([[255, 255, 255, 255],
- en: '[255, 255, 255, 255],'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '[255, 255, 255, 255]，'
- en: '[255, 255, 255, 255],'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[255, 255, 255, 255]，'
- en: '[255, 255, 255, 0]])'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '[255, 255, 255, 0]])'
- en: '`np.random.choice()` chooses a value from the given list `[0, 255]`, with the
    probability of the appearance of each value given in the parameter `p=[0.1, 0.9]`.
    Here you ask for 0 to appear with a probability of 0.1 (or 10 percent) and for
    255 to appear with a probability of 90 percent. (The two values in `p` must add
    up to 1.) The `choice()` method creates a one-dimensional array, in this case
    with 16 values (specified with `4*4`). You use `reshape()` to make it a two-dimensional
    array with four rows and four columns.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`np.random.choice()`从给定的列表`[0, 255]`中选择一个值，选择每个值的概率由参数`p=[0.1, 0.9]`给出。在这里，你请求0出现的概率为0.1（或10%），而255出现的概率为90%。(`p`中的两个值必须加起来等于1。）`choice()`方法创建一个一维数组，在这个例子中，数组包含16个值（由`4*4`指定）。你使用`reshape()`将其转换为一个具有四行四列的二维数组。'
- en: 'To set up the initial condition to match a particular pattern instead of just
    filling in a random set of values, first use `np.zeros()` to initialize the grid
    with all zeros:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置初始条件以匹配特定的图案，而不是仅仅填充一个随机值集合，首先使用`np.zeros()`初始化网格，使所有值都为零：
- en: grid = np.zeros(N*N).reshape(N, N)
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: grid = np.zeros(N*N).reshape(N, N)
- en: 'This creates an *N*×*N* array of zeros. Now define a function to add a pattern
    at a particular row and column in the grid:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这会创建一个*N*×*N*的零数组。现在定义一个函数，在网格的特定行和列添加图案：
- en: 'def addGlider(i, j, grid):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 'def addGlider(i, j, grid):'
- en: '"""adds a glider with top left cell at (i, j)"""'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '"""在(i, j)位置添加一个滑翔机图案"""'
- en: ❶ glider = np.array([[0, 0, 255],
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ glider = np.array([[0, 0, 255],
- en: '[255, 0, 255],'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[255, 0, 255],'
- en: '[0, 255, 255]])'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '[0, 255, 255]])'
- en: ❷ grid[i:i+3, j:j+3] = glider
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ grid[i:i+3, j:j+3] = glider
- en: You define the glider pattern (an observed pattern that moves steadily across
    the grid) using a `numpy` array of shape (3, 3) ❶. Then you use the `numpy` slice
    operation to copy the `glider` array into the simulation’s two-dimensional grid
    ❷, with the pattern’s top-left corner placed at the coordinates you specify as
    `i` and `j`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过使用一个形状为(3, 3)的`numpy`数组定义滑翔机图案 ❶（一个在网格上稳定移动的观察到的图案）。然后，你使用`numpy`切片操作将`glider`数组复制到模拟的二维网格
    ❷，并将图案的左上角放置在你指定的`i`和`j`坐标上。
- en: 'Now you can add a glider pattern to the grid of zeros with a call to the `addGlider()`
    function you just defined:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以通过调用你刚才定义的`addGlider()`函数将滑翔机图案添加到全零的网格中：
- en: addGlider(1, 1, grid)
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: addGlider(1, 1, grid)
- en: You specify coordinates of (1, 1) to add the glider near the top-left corner
    of the grid, which is (0, 0). Note that for `grid[i, j]`, `i` starts at `0` and
    runs from top to bottom, and `j` starts at `0` and runs from left to right.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你指定坐标(1, 1)将滑翔机添加到接近网格左上角的地方，即(0, 0)。请注意，对于`grid[i, j]`，`i`从`0`开始，按从上到下的顺序排列，而`j`从`0`开始，按从左到右的顺序排列。
- en: '[Enforcing the Boundary Conditions](nsp-venkitachalam503045-0008.xhtml#rbh0503)'
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[强制边界条件](nsp-venkitachalam503045-0008.xhtml#rbh0503)'
- en: 'Now we can think about how to implement the toroidal boundary conditions. First,
    let’s see what happens at the right edge of a grid of size *N*×*N*. The cell at
    the end of row *i* is accessed as `grid[i, N-1]`. Its neighbor to the right is
    `grid[i, N]`, but according to the toroidal boundary conditions, the value accessed
    as `grid[i, N]` should be replaced by `grid[i, 0]`. Here’s one way to do that:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以考虑如何实现环形边界条件。首先，让我们看看在大小为*N*×*N*的网格的右边缘会发生什么。位于第*i*行末尾的单元格可以通过`grid[i,
    N-1]`访问。它右边的邻居是`grid[i, N]`，但根据环形边界条件，访问`grid[i, N]`时应该被替换为`grid[i, 0]`。以下是一种实现方法：
- en: 'if j == N-1:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 'if j == N-1:'
- en: right = grid[i, 0]
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: right = grid[i, 0]
- en: 'else:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: right = grid[i, j+1]
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: right = grid[i, j+1]
- en: 'Of course, you’d need to apply similar boundary conditions to the left, top,
    and bottom sides of the grid, but doing so would require adding a lot more code
    because each of the four edges of the grid would need to be tested. A much more
    compact way to implement the boundary conditions is with Python’s modulus (`%`)
    operator, demonstrated here in the Python interpreter:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你需要对网格的左侧、顶部和底部应用类似的边界条件，但这样做需要添加更多代码，因为网格的四个边缘都需要进行测试。实现边界条件的一个更加简洁的方法是使用Python的取余（`%`）运算符，下面的Python解释器演示了这一点：
- en: '>>> `N = 16`'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> `N = 16`'
- en: '>>> `i1 = 14`'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> `i1 = 14`'
- en: '>>> `i2 = 15`'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> `i2 = 15`'
- en: '>>> `(i1+1)%N`'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> `(i1+1)%N`'
- en: '15'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '15'
- en: '>>> `(i2+1)%N`'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> `(i2+1)%N`'
- en: '0'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: 'As you can see, the `%` operator gives the remainder for the integer division
    by `N`. In this example, `15%16` yields `15`, but `16%16` yields `0`. You can
    use the `%` operator to make the values wrap around at the right edge by rewriting
    the grid access code like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`%`运算符给出了整数除法的余数。在这个例子中，`15%16`的结果是`15`，而`16%16`的结果是`0`。你可以通过重写网格访问代码，使用`%`运算符使值在右边缘处环绕：
- en: right = grid[i, (j+1)%N]
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: right = grid[i, (j+1)%N]
- en: 'Now when a cell is on the edge of the grid (in other words, when `j = N-1`),
    asking for the cell to the right with this method will give you `(j+1)%N`, which
    sets `j` back to `0`, making the right side of the grid wrap to the left side.
    When you do the same for the bottom of the grid, it wraps around to the top:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当一个单元格位于网格的边缘时（换句话说，当 `j = N-1` 时），用这种方法请求右侧的单元格会返回 `(j+1)%N`，这会将 `j` 重置为
    `0`，使得网格的右侧与左侧连接。当你对网格底部做同样操作时，它会回绕到顶部：
- en: bottom = grid[(i+1)%N, j]
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: bottom = grid[(i+1)%N, j]
- en: '[Implementing the Rules](nsp-venkitachalam503045-0008.xhtml#rbh0504)'
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[实现规则](nsp-venkitachalam503045-0008.xhtml#rbh0504)'
- en: 'The rules of the Game of Life are based on the number of neighboring cells
    that are ON or OFF. To simplify the application of these rules, you can just calculate
    the total number of neighboring cells in the ON state. Because ON corresponds
    to a value of 255, simply sum the values of all the neighbors and divide by 255
    to get the number of ON cells. Here’s the relevant code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 生命游戏的规则基于邻近单元格的 ON 或 OFF 状态数量。为了简化这些规则的应用，你可以直接计算邻居单元格的 ON 状态总数。因为 ON 对应的值为
    255，所以只需要加总所有邻居的值，再除以 255 得到 ON 单元格的数量。以下是相关代码：
- en: total = int((grid[i, (j-1)%N] + grid[i, (j+1)%N] +
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: total = int((grid[i, (j-1)%N] + grid[i, (j+1)%N] +
- en: grid[(i-1)%N, j] + grid[(i+1)%N, j] +
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: grid[(i-1)%N, j] + grid[(i+1)%N, j] +
- en: grid[(i-1)%N, (j-1)%N] + grid[(i-1)%N, (j+1)%N] +
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: grid[(i-1)%N, (j-1)%N] + grid[(i-1)%N, (j+1)%N] +
- en: grid[(i+1)%N, (j-1)%N] + grid[(i+1)%N, (j+1)%N])/255)
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: grid[(i+1)%N, (j-1)%N] + grid[(i+1)%N, (j+1)%N])/255)
- en: 'For any given cell (*i*, *j*), you sum the value of its eight neighbors, using
    the `%` operator to account for toroidal boundary conditions. Dividing the result
    by 255 gives you the number of neighbors that are ON, which you store in the variable
    `total`. Now you can use `total` to apply the Game of Life rules:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何给定的单元格 (*i*, *j*)，你需要加总它的八个邻居的值，使用 `%` 运算符来处理环形边界条件。将结果除以 255 得到 ON 状态的邻居数量，这个值存储在变量
    `total` 中。现在你可以使用 `total` 来应用生命游戏规则：
- en: apply Conway's rules
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用康威的规则
- en: 'if grid[i, j] == ON:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 grid[i, j] == ON:'
- en: '❶ if (total < 2) or (total > 3):'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如果 (total < 2) 或 (total > 3)：
- en: newGrid[i, j] = OFF
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: newGrid[i, j] = OFF
- en: 'else:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 否则：
- en: '❷ if total == 3:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如果 total == 3：
- en: newGrid[i, j] = ON
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: newGrid[i, j] = ON
- en: 'Any cell that is ON is turned OFF if it has fewer than two neighbors that are
    ON or if it has more than three neighbors that are ON ❶. The code in the `else`
    branch applies only to OFF cells: a cell is turned ON if exactly three neighbors
    are ON ❷. The changes are applied to the corresponding cells in `newGrid`, which
    starts as a copy of `grid`. Once every cell has been evaluated and updated, `newGrid`
    contains the data for displaying the next time step in the simulation. You can’t
    make changes directly to `grid`, or the states of the cells would keep changing
    as you try to evaluate them.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 任意处于 ON 状态的单元格，如果它周围有少于两个 ON 邻居或超过三个 ON 邻居，则会变为 OFF ❶。`else` 分支中的代码仅适用于 OFF
    单元格：如果恰好有三个 ON 邻居，单元格会变为 ON ❷。这些更改会应用到 `newGrid` 中相应的单元格，`newGrid` 最初是 `grid`
    的副本。一旦每个单元格都被评估和更新，`newGrid` 就包含了下一时刻显示的数据。你不能直接更改 `grid`，否则在尝试评估时单元格的状态会不断变化。
- en: '[Sending Command Line Arguments to the Program](nsp-venkitachalam503045-0008.xhtml#rbh0505)'
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[发送命令行参数到程序](nsp-venkitachalam503045-0008.xhtml#rbh0505)'
- en: 'Now you can begin writing the `main()` function of the simulation, which starts
    by sending command line arguments to the program:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以开始编写模拟的`main()`函数，它通过将命令行参数传递给程序来启动：
- en: 'def main():'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 'def main():'
- en: '# command line arguments are in sys.argv[1], sys.argv[2], ...'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '# 命令行参数在 sys.argv[1], sys.argv[2], ...'
- en: '# sys.argv[0] is the script name and can be ignored'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '# sys.argv[0] 是脚本名称，可以忽略'
- en: '# parse arguments'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '# 解析参数'
- en: ❶ parser = argparse.ArgumentParser(description="Runs Conway's Game of Life
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ parser = argparse.ArgumentParser(description="运行康威的生命游戏
- en: simulation.")
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟。")
- en: '# add arguments'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '# 添加参数'
- en: ❷ parser.add_argument('--grid-size', dest='N', required=False)
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ parser.add_argument('--grid-size', dest='N', required=False)
- en: ❸ parser.add_argument('--interval', dest='interval', required=False)
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ parser.add_argument('--interval', dest='interval', required=False)
- en: ❹ parser.add_argument('--glider', action='store_true', required=False)
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ parser.add_argument('--glider', action='store_true', required=False)
- en: args = parser.parse_args()
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: args = parser.parse_args()
- en: You create an `argparse.ArgumentParser` object to add command line options to
    the code ❶, and then you add various options to it in the following lines. The
    option at ❷ specifies the simulation grid size *N*, and the option at ❸ sets the
    animation update interval in milliseconds. You also create an option to start
    the simulation with a glider pattern ❹. If this option isn’t set, the simulation
    will start with random ON and OFF values.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你创建了一个`argparse.ArgumentParser`对象，以将命令行选项添加到代码中❶，然后在接下来的行中添加了各种选项。❷的选项指定了模拟的网格大小*N*，❸的选项设置了动画更新间隔（以毫秒为单位）。你还创建了一个选项来启动一个滑行器模式的模拟❹。如果没有设置此选项，模拟将以随机的开/关值开始。
- en: '[Initializing the Simulation](nsp-venkitachalam503045-0008.xhtml#rbh0506)'
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[初始化模拟](nsp-venkitachalam503045-0008.xhtml#rbh0506)'
- en: 'Continuing through the `main()` function, you come to the following section,
    which initializes the simulation:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main()`函数中继续，你会进入以下部分，这部分初始化了模拟：
- en: '# set grid size'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置网格大小'
- en: ❶ N = 100
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ N = 100
- en: '# set animation update interval'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置动画更新间隔'
- en: ❷ updateInterval = 50
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ updateInterval = 50
- en: 'if args.interval:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 args.interval:'
- en: updateInterval = int(args.interval)
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: updateInterval = int(args.interval)
- en: '# declare grid'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '# 声明网格'
- en: grid = np.array([])
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: grid = np.array([])
- en: '# check if "glider" demo flag is specified'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '# 检查是否指定了“滑行器”演示标志'
- en: '❸ if args.glider:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '❸ 如果 args.glider:'
- en: grid = np.zeros(N*N).reshape(N, N)
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: grid = np.zeros(N*N).reshape(N, N)
- en: addGlider(1, 1, grid)
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: addGlider(1, 1, grid)
- en: '❹ else:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 否则：
- en: '# set N if specified and valid'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '# 如果指定且有效，设置 N'
- en: 'if args.N and int(args.N) > 8:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 args.N 且 int(args.N) > 8:'
- en: N = int(args.N)
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: N = int(args.N)
- en: '# populate grid with random on/off - more off than on'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '# 用随机的开/关填充网格——关的比开的多'
- en: grid = randomGrid(N)
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: grid = randomGrid(N)
- en: This portion of the code applies any parameters called at the command line,
    once the command line options have been parsed. First, a default grid size of
    100×100 cells ❶ and an update interval of 50 milliseconds ❷ are set, in case these
    options aren’t set at the command line. Then you set up the initial conditions,
    either a random pattern by default ❹ or a glider pattern ❸.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分代码应用命令行中调用的任何参数，命令行选项解析完成后。首先，设置默认的网格大小为100×100个单元格❶和50毫秒的更新间隔❷，以防这些选项在命令行中没有设置。然后设置初始条件，默认是随机模式❹，或者使用滑行器模式❸。
- en: 'Finally, you set up the animation:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你设置动画：
- en: '# set up the animation'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置动画'
- en: ❶ fig, ax = plt.subplots()
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ fig, ax = plt.subplots()
- en: img = ax.imshow(grid, interpolation='nearest')
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: img = ax.imshow(grid, interpolation='nearest')
- en: ❷ ani = animation.FuncAnimation(fig, update, fargs=(img, grid, N, ),
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ ani = animation.FuncAnimation(fig, update, fargs=(img, grid, N,  ),
- en: interval=updateInterval,
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: interval=updateInterval,
- en: save_count=50)
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: save_count=50)
- en: plt.show()
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: plt.show()
- en: Still within the `main()` function, you configure the `matplotlib` plot and
    animation parameters ❶. Then you set `animation.FuncAnimation()` to regularly
    call the function `update()`, defined earlier in the program, which updates the
    grid according to the rules of Conway’s Game of Life using toroidal boundary conditions
    ❷.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然在`main()`函数中，你配置了`matplotlib`绘图和动画参数❶。然后设置`animation.FuncAnimation()`，定期调用之前在程序中定义的`update()`函数，该函数根据康威生命游戏的规则，使用环形边界条件❷来更新网格。
- en: '[Running the Game of Life Simulation](nsp-venkitachalam503045-0008.xhtml#rah0504)'
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[运行生命游戏模拟](nsp-venkitachalam503045-0008.xhtml#rah0504)'
- en: 'Now run the code:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行代码：
- en: $ `python conway.py`
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: $ `python conway.py`
- en: 'This uses the default parameters for the simulation: a grid of 100×100 cells
    and an update interval of 50 milliseconds. As you watch the simulation, you’ll
    see how it progresses to create and sustain various patterns over time, as in
    [Figure 3-4 (a) and (b)](nsp-venkitachalam503045-0015.xhtml#fig3-4).'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用了模拟的默认参数：100×100个单元格的网格和50毫秒的更新间隔。随着模拟的进行，你将看到它如何在时间推移中创建并维持各种模式，如[图 3-4
    (a) 和 (b)](nsp-venkitachalam503045-0015.xhtml#fig3-4)所示。
- en: '![](images/nsp-venkitachalam503045-f03004a.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f03004a.jpg)'
- en: (a)
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: (a)
- en: '![](images/nsp-venkitachalam503045-f03004b.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f03004b.jpg)'
- en: (b)
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: (b)
- en: 'Figure 3-4: The Game of Life in progress'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-4：生命游戏进行中
- en: '[Figure 3-5](nsp-venkitachalam503045-0015.xhtml#fig3-5) shows some of the patterns
    to look for in the simulation. Besides the glider, look for a three-cell blinker
    and static patterns such as a block or loaf shape.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3-5](nsp-venkitachalam503045-0015.xhtml#fig3-5)展示了模拟中可能出现的一些模式。除了滑行器外，还可以看到三单元的闪烁器和静态模式，如块状或面包形态。'
- en: '![](images/nsp-venkitachalam503045-f03005.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f03005.jpg)'
- en: 'Figure 3-5: Some patterns in the Game of Life'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-5：生命游戏中的一些模式
- en: 'Now change things up a bit by running the simulation with these parameters:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在通过以下参数运行模拟，稍微改变一下设置：
- en: $ `python conway.py --grid-size 32 --interval 500 --glider`
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: $ `python conway.py --grid-size 32 --interval 500 --glider`
- en: This creates a simulation grid of 32×32, updates the animation every 500 milliseconds,
    and uses the initial glider pattern shown in the bottom right of [Figure 3-5](nsp-venkitachalam503045-0015.xhtml#fig3-5).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这会创建一个32×32的模拟网格，每500毫秒更新一次动画，并使用右下角显示的初始滑翔机模式，[图3-5](nsp-venkitachalam503045-0015.xhtml#fig3-5)。
- en: '[Summary](nsp-venkitachalam503045-0008.xhtml#rah0505)'
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[摘要](nsp-venkitachalam503045-0008.xhtml#rah0505)'
- en: In this project, you explored Conway’s Game of Life. You learned how to set up
    a basic computer simulation based on some rules and how to use `matplotlib` to
    visualize the state of the system as it evolves.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你探索了康威的生命游戏。你学习了如何基于一些规则建立一个基本的计算机模拟，并如何使用`matplotlib`来可视化系统随时间的演变状态。
- en: My implementation of Conway’s Game of Life emphasizes simplicity over performance.
    You can speed up the computations in the Game of Life in many different ways,
    and a tremendous amount of research has been done on how to do this. You’ll find
    a lot of this research through a quick internet search.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我的生命游戏实现强调简洁性而非性能。你可以通过多种方式加速生命游戏中的计算，并且有大量的研究探讨了如何做到这一点。你可以通过快速的互联网搜索找到很多相关研究。
- en: '[Experiments!](nsp-venkitachalam503045-0008.xhtml#rah0506)'
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[实验！](nsp-venkitachalam503045-0008.xhtml#rah0506)'
- en: 'Here are some ways to experiment further with Conway’s Game of Life:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些进一步实验生命游戏的方式：
- en: 1\. Write an `addGosperGun()` method to add the pattern shown in [Figure 3-6](nsp-venkitachalam503045-0015.xhtml#fig3-6)
    to the grid. This pattern is called the *Gosper Glider Gun*. Run the simulation
    and observe what the gun does.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1\. 编写一个`addGosperGun()`方法，将[图3-6](nsp-venkitachalam503045-0015.xhtml#fig3-6)中显示的模式添加到网格中。这个模式叫做*戈斯帕滑翔机枪*。运行模拟并观察枪械的行为。
- en: '![](images/nsp-venkitachalam503045-f03006.jpg)'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f03006.jpg)'
- en: 'Figure 3-6: The Gosper Glider Gun'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图3-6：戈斯帕滑翔机枪
- en: '2\. Write a `readPattern()` method that reads in an initial pattern from a
    text file and uses it to set the initial conditions for the simulation. You can
    use Python methods such as `open` and `file.read` to do this. Here’s a suggested
    format for the input file:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2\. 编写一个`readPattern()`方法，从文本文件中读取初始模式，并用它来设置模拟的初始条件。你可以使用Python方法，如`open`和`file.read`来实现。这里是输入文件的建议格式：
- en: '8'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '8'
- en: 0 0 0 255...
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 0 0 0 255...
- en: The first line of the file defines *N*, and the rest of the file is just *N*×*N*
    integers (0 or 255) separated by whitespace. This exploration will help you study
    how any given pattern evolves with the rules of the Game of Life. Add a `--pattern-file`
    command line option to use this file while running the program.
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 文件的第一行定义了*N*，接下来的内容是*N*×*N*的整数（0或255），并由空格分隔。这个探索将帮助你研究任何给定模式在“生命游戏”规则下的演变。添加一个`--pattern-file`命令行选项，用于在运行程序时使用此文件。
- en: '[The Complete Code](nsp-venkitachalam503045-0008.xhtml#rah0507)'
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[完整代码](nsp-venkitachalam503045-0008.xhtml#rah0507)'
- en: 'Here’s the complete code for the Game of Life project:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是生命游戏项目的完整代码：
- en: '"""'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: conway.py
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: conway.py
- en: A simple Python/matplotlib implementation of Conway's Game of Life.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的Python/matplotlib实现的康威生命游戏。
- en: 'Author: Mahesh Venkitachalam'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 作者：Mahesh Venkitachalam
- en: '"""'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: import sys, argparse
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: import sys, argparse
- en: import numpy as np
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: import numpy as np
- en: import matplotlib.pyplot as plt
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: import matplotlib.pyplot as plt
- en: import matplotlib.animation as animation
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: import matplotlib.animation as animation
- en: 'def randomGrid(N):'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: def randomGrid(N)
- en: '"""returns a grid of NxN random values"""'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '"""返回一个NxN随机值的网格"""'
- en: return np.random.choice([255, 0], N*N, p=[0.2, 0.8]).reshape(N, N)
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: return np.random.choice([255, 0], N*N, p=[0.2, 0.8]).reshape(N, N)
- en: 'def addGlider(i, j, grid):'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 'def addGlider(i, j, grid):'
- en: '"""adds a glider with top left cell at (i, j)"""'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '"""在(i, j)位置添加一个滑翔机"""'
- en: glider = np.array([[0,    0, 255],
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: glider = np.array([[0,  0, 255],
- en: '[255,  0, 255],'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '[255,  0, 255],'
- en: '[0,  255, 255]])'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '[0,  255, 255]])'
- en: grid[i:i+3, j:j+3] = glider
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: grid[i:i+3, j:j+3] = glider
- en: 'def update(frameNum, img, grid, N):'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 'def update(frameNum, img, grid, N):'
- en: '# copy grid since we require 8 neighbors for calculation'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '# 复制网格，因为我们需要8个邻居来进行计算'
- en: '# and we go line by line'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '# 并且我们按行进行处理'
- en: newGrid = grid.copy()
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: newGrid = grid.copy()
- en: 'for i in range(N):'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(N):'
- en: 'for j in range(N):'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 'for j in range(N):'
- en: '# compute 8-neighbor sum'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '# 计算8个邻居的和'
- en: '# using toroidal boundary conditions - x and y wrap around'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '# 使用环形边界条件 - x和y会循环'
- en: '# so that the simulation takes place on a toroidal surface'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '# 这样模拟就发生在一个环形表面上'
- en: total = int((grid[i, (j-1)%N] + grid[i, (j+1)%N] +
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: total = int((grid[i, (j-1)%N] + grid[i, (j+1)%N] +
- en: grid[(i-1)%N, j] + grid[(i+1)%N, j] +
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: grid[(i-1)%N, j] + grid[(i+1)%N, j] +
- en: grid[(i-1)%N, (j-1)%N] + grid[(i-1)%N, (j+1)%N] +
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: grid[(i-1)%N, (j-1)%N] + grid[(i-1)%N, (j+1)%N] +
- en: grid[(i+1)%N, (j-1)%N] + grid[(i+1)%N, (j+1)%N])/255)
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 'grid[(i+1)%N, (j-1)%N] + grid[(i+1)%N, (j+1)%N])/255)  '
- en: '# apply Conway''s rules'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '# 应用康威的规则  '
- en: 'if grid[i, j]  == 255:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 'if grid[i, j] == 255:  '
- en: 'if (total < 2) or (total > 3):'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 'if (total < 2) or (total > 3):  '
- en: newGrid[i, j] = 0
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 'newGrid[i, j] = 0  '
- en: 'else:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:  '
- en: 'if total == 3:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 'if total == 3:  '
- en: newGrid[i, j] = 255
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: newGrid[i, j] = 255
- en: '# update data'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '# 更新数据  '
- en: img.set_data(newGrid)
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 'img.set_data(newGrid)  '
- en: grid[:] = newGrid[:]
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 'grid[:] = newGrid[:]  '
- en: '# need to return a tuple here, since this callback'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '# 这里需要返回一个元组，因为这个回调  '
- en: '# function needs to return an iterable'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '# 函数需要返回一个可迭代对象  '
- en: return img,
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 'return img,  '
- en: main() function
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 'main() 函数  '
- en: 'def main():'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 'def main():  '
- en: '# command line args are in sys.argv[1], sys.argv[2]...'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '# 命令行参数在 sys.argv[1], sys.argv[2]...  '
- en: '# sys.argv[0] is the script name itself and can be ignored'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '# sys.argv[0] 是脚本名本身，可以忽略  '
- en: '# parse arguments'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '# 解析参数  '
- en: parser = argparse.ArgumentParser(description="Runs Conway's Game of Life
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 'parser = argparse.ArgumentParser(description="运行康威的生命游戏")  '
- en: simulation.")
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 'simulation.")  '
- en: '# add arguments'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '# 添加参数  '
- en: parser.add_argument('--grid-size', dest='N', required=False)
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 'parser.add_argument(''--grid-size'', dest=''N'', required=False)  '
- en: parser.add_argument('--interval', dest='interval', required=False)
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 'parser.add_argument(''--interval'', dest=''interval'', required=False)  '
- en: parser.add_argument('--glider', action='store_true', required=False)
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 'parser.add_argument(''--glider'', action=''store_true'', required=False)  '
- en: parser.add_argument('--gosper', action='store_true', required=False)
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 'parser.add_argument(''--gosper'', action=''store_true'', required=False)  '
- en: args = parser.parse_args()
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 'args = parser.parse_args()  '
- en: '# set grid size'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置网格大小  '
- en: N = 100
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 'N = 100  '
- en: '# set animation update interval'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置动画更新间隔  '
- en: updateInterval = 50
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 'updateInterval = 50  '
- en: 'if args.interval:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 'if args.interval:  '
- en: updateInterval = int(args.interval)
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 'updateInterval = int(args.interval)  '
- en: '# declare grid'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '# 声明网格  '
- en: grid = np.array([])
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 'grid = np.array([])  '
- en: '# check if "glider" demo flag is specified'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '# 检查是否指定了 "glider" 演示标志  '
- en: 'if args.glider:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 'if args.glider:  '
- en: grid = np.zeros(N*N).reshape(N, N)
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 'grid = np.zeros(N*N).reshape(N, N)  '
- en: addGlider(1, 1, grid)
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 'addGlider(1, 1, grid)  '
- en: 'elif args.gosper:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif args.gosper:  '
- en: grid = np.zeros(N*N).reshape(N, N)
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 'grid = np.zeros(N*N).reshape(N, N)  '
- en: addGosperGliderGun(10, 10, grid)
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 'addGosperGliderGun(10, 10, grid)  '
- en: 'else:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:  '
- en: '# set N if specified and valid'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置 N（如果指定且有效）  '
- en: 'if args.N and int(args.N) > 8:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 'if args.N and int(args.N) > 8:  '
- en: N = int(args.N)
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 'N = int(args.N)  '
- en: '# populate grid with random on/off - more off than on'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '# 使用随机的开/关值填充网格——关闭的比打开的多  '
- en: grid = randomGrid(N)
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 'grid = randomGrid(N)  '
- en: '# set up animation'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置动画  '
- en: fig, ax = plt.subplots()
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 'fig, ax = plt.subplots()  '
- en: img = ax.imshow(grid, interpolation='nearest')
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 'img = ax.imshow(grid, interpolation=''nearest'')  '
- en: ani = animation.FuncAnimation(fig, update, fargs=(img, grid, N, ),
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 'ani = animation.FuncAnimation(fig, update, fargs=(img, grid, N, )  '
- en: frames = 10,
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 'frames = 10,  '
- en: interval=updateInterval)
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 'interval=updateInterval)  '
- en: plt.show()
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 'plt.show()  '
- en: call main
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 'call main  '
- en: 'if __name__ == ''__main__'':'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':  '
- en: main()
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 'main()  '
