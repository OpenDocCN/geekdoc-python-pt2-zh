- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: A Ship That Fires Bullets
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 一艘发射子弹的飞船
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: Let’s build a game called *Alien Invasion*! We’ll use Pygame, a collection of
    fun, powerful Python modules that manage graphics, animation, and even sound,
    making it easier for you to build sophisticated games. With Pygame handling tasks
    like drawing images to the screen, you can focus on the higher-level logic of
    game dynamics.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来制作一个名为*外星人入侵*的游戏！我们将使用 Pygame，一个强大而有趣的 Python 模块集合，能够处理图形、动画，甚至音效，让你更容易构建复杂的游戏。借助
    Pygame 来处理诸如绘制图像到屏幕等任务，你可以专注于游戏动态的更高级逻辑。
- en: In this chapter, you’ll set up Pygame and then create a rocket ship that moves
    right and left and fires bullets in response to player input. In the next two
    chapters, you’ll create a fleet of aliens to destroy, and then continue to refine
    the game by setting limits on the number of ships you can use and adding a scoreboard.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将设置 Pygame，并创建一艘能够响应玩家输入左右移动并发射子弹的火箭飞船。在接下来的两章中，你将创建一支外星舰队进行摧毁，然后继续通过设置飞船数量限制和添加记分板来完善游戏。
- en: While building this game, you’ll also learn how to manage large projects that
    span multiple files. We’ll refactor a lot of code and manage file contents to
    organize the project and make the code efficient.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建这个游戏的过程中，你还将学习如何管理跨多个文件的大型项目。我们将重构大量代码并管理文件内容，以组织项目并使代码高效。
- en: Making games is an ideal way to have fun while learning a language. It’s deeply
    satisfying to play a game you wrote, and writing a simple game will teach you
    a lot about how professionals develop games. As you work through this chapter,
    enter and run the code to identify how each code block contributes to overall
    gameplay. Experiment with different values and settings to better understand how
    to refine interactions in your games.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 制作游戏是学习语言的理想方式，它既有趣又富有挑战性。玩自己写的游戏是一种极大的满足感，编写一个简单的游戏将让你学到很多关于专业人士如何开发游戏的知识。在本章过程中，输入并运行代码，找出每个代码块如何为整体游戏玩法做出贡献。尝试不同的值和设置，更好地理解如何优化游戏中的交互。
- en: Planning Your Project
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目规划
- en: When you’re building a large project, it’s important to prepare a plan before
    you begin to write code. Your plan will keep you focused and make it more likely
    that you’ll complete the project.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在构建一个大型项目时，重要的是在开始编写代码之前先准备一个计划。你的计划将帮助你保持专注，并使你更有可能完成项目。
- en: 'Let’s write a description of the general gameplay. Although the following description
    doesn’t cover every detail of *Alien Invasion*, it provides a clear idea of how
    to start building the game:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一个关于游戏玩法的一般描述。尽管以下描述没有涵盖*外星人入侵*的每个细节，但它提供了一个清晰的思路，帮助你开始构建游戏：
- en: In *Alien Invasion*, the player controls a rocket ship that appears at the bottom
    center of the screen. The player can move the ship right and left using the arrow
    keys and shoot bullets using the spacebar. When the game begins, a fleet of aliens
    fills the sky and moves across and down the screen. The player shoots and destroys
    the aliens. If the player destroys all the aliens, a new fleet appears that moves
    faster than the previous fleet. If any alien hits the player’s ship or reaches
    the bottom of the screen, the player loses a ship. If the player loses three ships,
    the game ends.
  id: totrans-10
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在*外星人入侵*中，玩家控制一艘出现在屏幕底部中央的火箭飞船。玩家可以使用箭头键控制飞船左右移动，使用空格键发射子弹。当游戏开始时，一支外星舰队充满了天空，并向屏幕的两侧和下方移动。玩家射击并摧毁外星人。如果玩家摧毁了所有外星人，新的舰队会出现，且它的移动速度比前一支更快。如果任何外星人撞到玩家的飞船或到达屏幕底部，玩家会失去一艘飞船。如果玩家失去了三艘飞船，游戏结束。
- en: For the first development phase, we’ll make a ship that can move right and left
    when the player presses the arrow keys and fire bullets when the player presses
    the spacebar. After setting up this behavior, we can create the aliens and refine
    the gameplay.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发的第一阶段，我们将制作一艘能够在玩家按下箭头键时左右移动，并在玩家按下空格键时发射子弹的飞船。在设置好这一行为后，我们可以创建外星人并优化游戏玩法。
- en: Installing Pygame
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Pygame
- en: 'Before you begin coding, install Pygame. We’ll do this the same way we installed
    pytest in Chapter 11: with pip. If you skipped Chapter 11 or need a refresher
    on pip, see “Installing pytest with pip” on page 210.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编写代码之前，先安装 Pygame。我们将以与第11章安装 pytest 相同的方式进行安装：使用 pip。如果你跳过了第11章或需要复习 pip，请参阅第210页的“使用
    pip 安装 pytest”。
- en: 'To install Pygame, enter the following command at a terminal prompt:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 Pygame，在终端提示符下输入以下命令：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you use a command other than `python` to run programs or start a terminal
    session, such as `python3`, make sure you use that command instead.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用除`python`之外的命令来运行程序或启动终端会话，例如`python3`，请确保使用该命令来代替。
- en: Starting the Game Project
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动游戏项目
- en: We’ll begin building the game by creating an empty Pygame window. Later, we’ll
    draw the game elements, such as the ship and the aliens, on this window. We’ll
    also make our game respond to user input, set the background color, and load a
    ship image.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过创建一个空的Pygame窗口来开始构建游戏。稍后，我们将在该窗口上绘制游戏元素，例如飞船和外星人。我们还将使游戏响应用户输入，设置背景颜色，并加载飞船图像。
- en: Creating a Pygame Window and Responding to User Input
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建Pygame窗口并响应用户输入
- en: 'We’ll make an empty Pygame window by creating a class to represent the game.
    In your text editor, create a new file and save it as *alien_invasion.py*; then
    enter the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过创建一个类来表示游戏，从而制作一个空的Pygame窗口。在文本编辑器中，创建一个新文件并将其保存为*alien_invasion.py*；然后输入以下内容：
- en: '**alien_invasion.py**'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**alien_invasion.py**'
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: First, we import the `sys` and `pygame` modules. The `pygame` module contains
    the functionality we need to make a game. We’ll use tools in the `sys` module
    to exit the game when the player quits.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入`sys`和`pygame`模块。`pygame`模块包含了制作游戏所需的功能。我们将使用`sys`模块中的工具来在玩家退出时退出游戏。
- en: '*Alien Invasion* starts as a class called `AlienInvasion`. In the `__init__()`
    method, the `pygame.init()` function initializes the background settings that
    Pygame needs to work properly ❶. Then we call `pygame.display.set_mode()` to create
    a display window ❷, on which we’ll draw all the game’s graphical elements. The
    argument `(1200, 800)` is a tuple that defines the dimensions of the game window,
    which will be 1,200 pixels wide by 800 pixels high. (You can adjust these values
    depending on your display size.) We assign this display window to the attribute
    `self.screen`, so it will be available in all methods in the class.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*Alien Invasion*从一个名为`AlienInvasion`的类开始。在`__init__()`方法中，`pygame.init()`函数初始化Pygame正常工作所需的背景设置❶。然后，我们调用`pygame.display.set_mode()`来创建一个显示窗口❷，在该窗口上我们将绘制所有游戏的图形元素。参数`(1200,
    800)`是一个元组，定义了游戏窗口的尺寸，宽度为1,200像素，高度为800像素。（你可以根据显示器的大小调整这些值。）我们将这个显示窗口分配给属性`self.screen`，这样它将在类中的所有方法中可用。'
- en: The object we assigned to `self.screen` is called a surface. A *surface* in
    Pygame is a part of the screen where a game element can be displayed. Each element
    in the game, like an alien or a ship, is its own surface. The surface returned
    by `display.set_mode()` represents the entire game window. When we activate the
    game’s animation loop, this surface will be redrawn on every pass through the
    loop, so it can be updated with any changes triggered by user input.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们分配给`self.screen`的对象称为表面。在Pygame中，*表面*是屏幕上的一部分，用于显示游戏元素。游戏中的每个元素，例如外星人或飞船，都是一个独立的表面。`display.set_mode()`返回的表面表示整个游戏窗口。当我们激活游戏的动画循环时，这个表面会在每次通过循环时重新绘制，因此可以更新任何由用户输入触发的变化。
- en: The game is controlled by the `run_game()` method. This method contains a `while`
    loop ❸ that runs continually. The `while` loop contains an event loop and code
    that manages screen updates. An *event* is an action that the user performs while
    playing the game, such as pressing a key or moving the mouse. To make our program
    respond to events, we write an *event loop* to *listen* for events and perform
    appropriate tasks depending on the kinds of events that occur. The `for` loop
    ❹ nested inside the `while` loop is an event loop.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏由`run_game()`方法控制。这个方法包含一个`while`循环❸，它会持续运行。`while`循环中包含一个事件循环和管理屏幕更新的代码。*事件*是用户在游戏过程中执行的操作，例如按下某个键或移动鼠标。为了使我们的程序响应事件，我们编写一个*事件循环*来*监听*事件，并根据发生的事件类型执行相应的任务。嵌套在`while`循环内的`for`循环就是一个事件循环。
- en: To access the events that Pygame detects, we’ll use the `pygame.event.get()`
    function. This function returns a list of events that have taken place since the
    last time this function was called. Any keyboard or mouse event will cause this
    `for` loop to run. Inside the loop, we’ll write a series of `if` statements to
    detect and respond to specific events. For example, when the player clicks the
    game window’s close button, a `pygame.QUIT` event is detected and we call `sys.exit()`
    to exit the game ❺.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问Pygame检测到的事件，我们将使用`pygame.event.get()`函数。该函数返回自上次调用该函数以来发生的事件列表。任何键盘或鼠标事件都会导致该`for`循环运行。在循环内部，我们将编写一系列`if`语句来检测并响应特定事件。例如，当玩家点击游戏窗口的关闭按钮时，会检测到`pygame.QUIT`事件，并调用`sys.exit()`来退出游戏❺。
- en: The call to `pygame.display.flip()` ❻ tells Pygame to make the most recently
    drawn screen visible. In this case, it simply draws an empty screen on each pass
    through the `while` loop, erasing the old screen so only the new screen is visible.
    When we move the game elements around, `pygame.display.flip()` continually updates
    the display to show the new positions of game elements and hide the old ones,
    creating the illusion of smooth movement.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`pygame.display.flip()` ❻ 告诉Pygame显示最近绘制的屏幕。在这种情况下，它会在每次通过`while`循环时绘制一个空白屏幕，抹去旧屏幕，只显示新屏幕。当我们移动游戏元素时，`pygame.display.flip()`会持续更新显示，以显示游戏元素的新位置并隐藏旧位置，创造出流畅运动的错觉。
- en: At the end of the file, we create an instance of the game and then call `run_game()`.
    We place `run_game()` in an `if` block that only runs if the file is called directly.
    When you run this *alien_invasion.py* file, you should see an empty Pygame window.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件末尾，我们创建一个游戏实例，然后调用`run_game()`。我们将`run_game()`放在一个`if`语句块中，只有在文件被直接调用时才会运行。当你运行这个*alien_invasion.py*文件时，应该能看到一个空白的Pygame窗口。
- en: Controlling the Frame Rate
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制帧率
- en: Ideally, games should run at the same speed, or *frame rate*, on all systems.
    Controlling the frame rate of a game that can run on multiple systems is a complex
    issue, but Pygame offers a relatively simple way to accomplish this goal. We’ll
    make a clock, and ensure the clock ticks once on each pass through the main loop.
    Anytime the loop processes faster than the rate we define, Pygame will calculate
    the correct amount of time to pause so that the game runs at a consistent rate.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，游戏应该在所有系统上以相同的速度，或称为*帧率*运行。控制一个可以在多个系统上运行的游戏的帧率是一个复杂的问题，但Pygame提供了一种相对简单的方法来实现这一目标。我们将创建一个时钟，并确保时钟在每次主循环中滴答一次。任何时候如果循环处理速度超过我们定义的帧率，Pygame将计算正确的暂停时间，以确保游戏以一致的速度运行。
- en: 'We’ll define the clock in the `__init__()` method:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`__init__()`方法中定义时钟：
- en: '**alien_invasion.py**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**alien_invasion.py**'
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After initializing `pygame`, we create an instance of the class `Clock`, from
    the `pygame.time` module. Then we’ll make the clock tick at the end of the `while`
    loop in `run_game()`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化`pygame`后，我们创建一个`Clock`类的实例，来自`pygame.time`模块。然后我们将在`run_game()`的`while`循环末尾让时钟滴答作响：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `tick()` method takes one argument: the frame rate for the game. Here I’m
    using a value of 60, so Pygame will do its best to make the loop run exactly 60
    times per second.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`tick()`方法接受一个参数：游戏的帧率。在这里，我使用的是60的值，这样Pygame将尽力确保循环每秒运行60次。'
- en: Setting the Background Color
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置背景颜色
- en: Pygame creates a black screen by default, but that’s boring. Let’s set a different
    background color. We’ll do this at the end of the `__init__()` method.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Pygame默认会创建一个黑色屏幕，但那太无聊了。让我们设置一个不同的背景颜色。我们将在`__init__()`方法的末尾进行设置。
- en: '**alien_invasion.py**'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**alien_invasion.py**'
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Colors in Pygame are specified as RGB colors: a mix of red, green, and blue.
    Each color value can range from 0 to 255\. The color value `(255, 0, 0)` is red,
    `(0, 255, 0)` is green, and `(0, 0, 255)` is blue. You can mix different RGB values
    to create up to 16 million colors. The color value `(230, 230, 230)` mixes equal
    amounts of red, blue, and green, which produces a light gray background color.
    We assign this color to `self.bg_color` ❶.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Pygame中的颜色是通过RGB颜色指定的：由红色、绿色和蓝色混合而成。每个颜色值的范围是从0到255。颜色值`(255, 0, 0)`是红色，`(0,
    255, 0)`是绿色，`(0, 0, 255)`是蓝色。你可以混合不同的RGB值来创建多达1600万种颜色。颜色值`(230, 230, 230)`混合了相同数量的红色、绿色和蓝色，产生一种浅灰色背景颜色。我们将这种颜色赋值给`self.bg_color`
    ❶。
- en: 'We fill the screen with the background color using the `fill()` method ❷, which
    acts on a surface and takes only one argument: a color.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`fill()`方法 ❷ 填充背景颜色，该方法作用于一个表面，并且只接受一个参数：颜色。
- en: Creating a Settings Class
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个设置类
- en: Each time we introduce new functionality into the game, we’ll typically create
    some new settings as well. Instead of adding settings throughout the code, let’s
    write a module called `settings` that contains a class called `Settings` to store
    all these values in one place. This approach allows us to work with just one `settings`
    object anytime we need to access an individual setting. This also makes it easier
    to modify the game’s appearance and behavior as our project grows. To modify the
    game, we’ll change the relevant values in *settings.py*, which we’ll create next,
    instead of searching for different settings throughout the project.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们向游戏中引入新功能时，通常也会创建一些新的设置。我们不再在代码中到处添加设置，而是编写一个名为`settings`的模块，其中包含一个叫做`Settings`的类来存储所有这些值。这个方法让我们每次需要访问单个设置时，只需操作一个`settings`对象。这也使得在项目发展过程中，修改游戏的外观和行为变得更加容易。为了修改游戏，我们将在接下来的*settings.py*中更改相关值，而不是在整个项目中搜索不同的设置。
- en: 'Create a new file named *settings.py* inside your *alien_invasion* folder,
    and add this initial `Settings` class:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在*alien_invasion*文件夹中创建一个名为*settings.py*的新文件，并添加这个初始的`Settings`类：
- en: '**settings.py**'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**settings.py**'
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To make an instance of `Settings` in the project and use it to access our settings,
    we need to modify *alien_invasion.py* as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在项目中创建一个`Settings`实例，并使用它来访问我们的设置，我们需要按如下方式修改*alien_invasion.py*：
- en: '**alien_invasion.py**'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**alien_invasion.py**'
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We import `Settings` into the main program file. Then we create an instance
    of `Settings` and assign it to `self.settings` ❶, after making the call to `pygame.init()`.
    When we create a screen ❷, we use the `screen_width` and `screen_height` attributes
    of `self.settings`, and then we use `self.settings` to access the background color
    when filling the screen ❸ as well.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`Settings`导入到主程序文件中。然后我们创建一个`Settings`实例，并将其赋值给`self.settings` ❶，在调用`pygame.init()`之后。当我们创建屏幕
    ❷时，我们使用`self.settings`中的`screen_width`和`screen_height`属性，然后在填充屏幕时也使用`self.settings`来访问背景颜色
    ❸。
- en: When you run *alien_invasion.py* now you won’t yet see any changes, because
    all we’ve done is move the settings we were already using elsewhere. Now we’re
    ready to start adding new elements to the screen.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当你现在运行*alien_invasion.py*时，你不会看到任何变化，因为我们所做的只是将已经在其他地方使用的设置移动过来。现在我们已经准备好开始向屏幕添加新元素了。
- en: Adding the Ship Image
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加飞船图像
- en: Let’s add the ship to our game. To draw the player’s ship on the screen, we’ll
    load an image and then use the Pygame `blit()` method to draw the image.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将飞船添加到游戏中。为了在屏幕上绘制玩家的飞船，我们将加载一张图像，然后使用Pygame的`blit()`方法来绘制这张图像。
- en: When you’re choosing artwork for your games, be sure to pay attention to licensing.
    The safest and cheapest way to start is to use freely licensed graphics that you
    can use and modify, from a website like [https://opengameart.org](https://opengameart.org).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择游戏的艺术作品时，一定要注意授权。最安全且最便宜的起步方式是使用可以自由使用和修改的授权图形，可以从像[https://opengameart.org](https://opengameart.org)这样的网站找到。
- en: You can use almost any type of image file in your game, but it’s easiest when
    you use a bitmap (*.bmp*) file because Pygame loads bitmaps by default. Although
    you can configure Pygame to use other file types, some file types depend on certain
    image libraries that must be installed on your computer. Most images you’ll find
    are in *.jpg* or *.png* formats, but you can convert them to bitmaps using tools
    like Photoshop, GIMP, and Paint.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你几乎可以在游戏中使用任何类型的图像文件，但使用位图(*.bmp*)文件是最简单的，因为Pygame默认加载位图。虽然你可以配置Pygame使用其他文件类型，但某些文件类型依赖于必须安装在你计算机上的特定图像库。你会发现大多数图像都是*.jpg*或*.png*格式，但你可以使用像Photoshop、GIMP和Paint这样的工具将它们转换为位图。
- en: Pay particular attention to the background color in your chosen image. Try to
    find a file with a transparent or solid background that you can replace with any
    background color, using an image editor. Your games will look best if the image’s
    background color matches your game’s background color. Alternatively, you can
    match your game’s background to the image’s background.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 特别注意所选图像的背景颜色。尽量找到一个背景透明或背景是实色的文件，你可以使用图像编辑器将其替换为任何背景颜色。如果图像的背景颜色与你游戏的背景颜色相匹配，游戏的效果最好。或者，你也可以将游戏的背景颜色与图像的背景颜色匹配。
- en: For *Alien Invasion*, you can use the file *ship.bmp* ([Figure 12-1](#figure12-1)),
    which is available in this book’s resources at [https://ehmatthes.github.io/pcc_3e](https://ehmatthes.github.io/pcc_3e).
    The file’s background color matches the settings we’re using in this project.
    Make a folder called *images* inside your main *alien_invasion* project folder.
    Save the file *ship.bmp* in the *images* folder.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 对于*外星入侵*，你可以使用文件*ship.bmp*（[图12-1](#figure12-1)），该文件可以在本书的资源中找到：[https://ehmatthes.github.io/pcc_3e](https://ehmatthes.github.io/pcc_3e)。该文件的背景颜色与我们在此项目中使用的设置相匹配。在你的主*alien_invasion*项目文件夹内创建一个名为*images*的文件夹，并将*ship.bmp*文件保存在该文件夹中。
- en: '![](image_fi/502703c12/f12001.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502703c12/f12001.png)'
- en: 'Figure 12-1: The ship for *Alien Invasion*'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-1：*外星入侵*的飞船
- en: Creating the Ship Class
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建Ship类
- en: 'After choosing an image for the ship, we need to display it on the screen.
    To use our ship, we’ll create a new `ship` module that will contain the class
    `Ship`. This class will manage most of the behavior of the player’s ship:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 选择完飞船图像后，我们需要将其显示在屏幕上。为了使用我们的飞船，我们将创建一个新的`ship`模块，其中包含`Ship`类。这个类将管理玩家飞船的大部分行为：
- en: '**ship.py**'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**ship.py**'
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Pygame is efficient because it lets you treat all game elements like rectangles
    (*rects*), even if they’re not exactly shaped like rectangles. Treating an element
    as a rectangle is efficient because rectangles are simple geometric shapes. When
    Pygame needs to figure out whether two game elements have collided, for example,
    it can do this more quickly if it treats each object as a rectangle. This approach
    usually works well enough that no one playing the game will notice that we’re
    not working with the exact shape of each game element. We’ll treat the ship and
    the screen as rectangles in this class.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Pygame非常高效，因为它让你将所有游戏元素都当作矩形（*rects*）来处理，即使它们的形状并不完全是矩形。将元素当作矩形处理非常高效，因为矩形是简单的几何形状。例如，当Pygame需要判断两个游戏元素是否发生碰撞时，如果将每个对象视为矩形，它就能更快地完成这项任务。这种方法通常足够有效，以至于游戏中的玩家不会注意到我们并没有使用每个游戏元素的确切形状。在这个类中，我们将飞船和屏幕都当作矩形来处理。
- en: 'We import the `pygame` module before defining the class. The `__init__()` method
    of `Ship` takes two parameters: the `self` reference and a reference to the current
    instance of the `AlienInvasion` class. This will give `Ship` access to all the
    game resources defined in `AlienInvasion`. We then assign the screen to an attribute
    of `Ship` ❶, so we can access it easily in all the methods in this class. We access
    the screen’s `rect` attribute using the `get_rect()` method and assign it to `self.screen_rect`
    ❷. Doing so allows us to place the ship in the correct location on the screen.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义类之前，我们导入了`pygame`模块。`Ship`类的`__init__()`方法接收两个参数：`self`引用和当前`AlienInvasion`类实例的引用。这样，`Ship`类就可以访问`AlienInvasion`中定义的所有游戏资源。然后，我们将屏幕赋值给`Ship`的一个属性❶，这样在该类中的所有方法中都能方便地访问它。我们通过`get_rect()`方法访问屏幕的`rect`属性，并将其赋值给`self.screen_rect`❷。这样做允许我们将飞船放置在屏幕上的正确位置。
- en: To load the image, we call `pygame.image.load()` ❸ and give it the location
    of our ship image. This function returns a surface representing the ship, which
    we assign to `self.image`. When the image is loaded, we call `get_rect()` to access
    the ship surface’s `rect` attribute so we can later use it to place the ship.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加载图像，我们调用`pygame.image.load()`❸，并给它传入飞船图像的路径。此函数返回一个代表飞船的表面，我们将其赋值给`self.image`。图像加载完成后，我们调用`get_rect()`来访问飞船表面的`rect`属性，以便以后用来放置飞船。
- en: When you’re working with a `rect` object, you can use the *x*- and *y*-coordinates
    of the top, bottom, left, and right edges of the rectangle, as well as the center,
    to place the object. You can set any of these values to establish the current
    position of the `rect`. When you’re centering a game element, work with the `center`,
    `centerx`, or `centery` attributes of a `rect`. When you’re working at an edge
    of the screen, work with the `top`, `bottom`, `left`, or `right` attributes. There
    are also attributes that combine these properties, such as `midbottom`, `midtop`,
    `midleft`, and `midright`. When you’re adjusting the horizontal or vertical placement
    of the `rect`, you can just use the `x` and `y` attributes, which are the *x*-
    and *y*-coordinates of its top-left corner. These attributes spare you from having
    to do calculations that game developers formerly had to do manually, and you’ll
    use them often.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用`rect`对象时，可以使用矩形的顶部、底部、左边和右边的* x *和* y *坐标，以及中心坐标来定位对象。你可以设置这些值中的任何一个来确定`rect`的位置。当你居中一个游戏元素时，可以使用`rect`的`center`、`centerx`或`centery`属性。当你在屏幕边缘工作时，可以使用`top`、`bottom`、`left`或`right`属性。还有一些属性是这些属性的组合，比如`midbottom`、`midtop`、`midleft`和`midright`。当你调整`rect`的水平或垂直位置时，可以直接使用`x`和`y`属性，这些属性是矩形左上角的*
    x *和* y *坐标。这些属性可以避免你进行游戏开发者以前需要手动计算的操作，且你会频繁使用它们。
- en: We’ll position the ship at the bottom center of the screen. To do so, make the
    value of `self.rect.midbottom` match the `midbottom` attribute of the screen’s
    `rect` ❹. Pygame uses these `rect` attributes to position the ship image so it’s
    centered horizontally and aligned with the bottom of the screen.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把飞船定位在屏幕的底部中央。为此，需要将`self.rect.midbottom`的值与屏幕`rect`的`midbottom`属性对齐❹。Pygame使用这些`rect`属性来定位飞船图像，使其水平居中并与屏幕底部对齐。
- en: Finally, we define the `blitme()` method ❺, which draws the image to the screen
    at the position specified by `self.rect`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们定义了`blitme()`方法❺，该方法将图像绘制到由`self.rect`指定的位置的屏幕上。
- en: Drawing the Ship to the Screen
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将飞船绘制到屏幕上
- en: 'Now let’s update *alien_invasion.py* so it creates a ship and calls the ship’s
    `blitme()` method:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们更新*alien_invasion.py*，使其创建一个飞船并调用飞船的`blitme()`方法：
- en: '**alien_invasion.py**'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**alien_invasion.py**'
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We import `Ship` and then make an instance of `Ship` after the screen has been
    created ❶. The call to `Ship()` requires one argument: an instance of `AlienInvasion`.
    The `self` argument here refers to the current instance of `AlienInvasion`. This
    is the parameter that gives `Ship` access to the game’s resources, such as the
    `screen` object. We assign this `Ship` instance to `self.ship`.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入了`Ship`，并在屏幕创建之后实例化了`Ship`❶。调用`Ship()`时需要传递一个参数：`AlienInvasion`的实例。这里的`self`参数指的是当前的`AlienInvasion`实例。这个参数使得`Ship`可以访问游戏的资源，例如`screen`对象。我们将这个`Ship`实例赋值给`self.ship`。
- en: After filling the background, we draw the ship on the screen by calling `ship.blitme()`,
    so the ship appears on top of the background ❷.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在填充背景之后，我们通过调用`ship.blitme()`来绘制飞船，这样飞船就会显示在背景之上❷。
- en: When you run *alien_invasion.py* now, you should see an empty game screen with
    the rocket ship sitting at the bottom center, as shown in [Figure 12-2](#figure12-2).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行*alien_invasion.py*时，你应该能看到一个空的游戏屏幕，火箭飞船位于屏幕的底部中央，如[图12-2](#figure12-2)所示。
- en: '![](image_fi/502703c12/f12002.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502703c12/f12002.png)'
- en: 'Figure 12-2: *Alien Invasion* with the ship at the bottom center of the screen'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-2：*Alien Invasion*游戏中，飞船位于屏幕底部中央
- en: 'Refactoring: The _check_events() and _update_screen() Methods'
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重构：_check_events()和_update_screen()方法
- en: In large projects, you’ll often refactor code you’ve written before adding more
    code. Refactoring simplifies the structure of the code you’ve already written,
    making it easier to build on. In this section, we’ll break the `run_game()` method,
    which is getting lengthy, into two helper methods. A *helper method* does work
    inside a class but isn’t meant to be used by code outside the class. In Python,
    a single leading underscore indicates a helper method.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在大型项目中，你通常会在添加更多代码之前重构已经写好的代码。重构简化了你已编写的代码结构，使得后续的扩展更加容易。在这一部分中，我们将把变得冗长的`run_game()`方法分解成两个辅助方法。*辅助方法*是在类内执行工作的，但不打算被类外的代码使用的。在Python中，单个前导下划线表示这是一个辅助方法。
- en: The _check_events() Method
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: _check_events()方法
- en: We’ll move the code that manages events to a separate method called `_check_events()`.
    This will simplify `run_game()` and isolate the event management loop. Isolating
    the event loop allows you to manage events separately from other aspects of the
    game, such as updating the screen.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将管理事件的代码移到一个名为`_check_events()`的单独方法中。这将简化`run_game()`并隔离事件管理循环。隔离事件循环使得你可以将事件管理与游戏的其他部分（如更新屏幕）分开处理。
- en: 'Here’s the `AlienInvasion` class with the new `_check_events()` method, which
    only affects the code in `run_game()`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是带有新`_check_events()`方法的`AlienInvasion`类，这只影响`run_game()`中的代码：
- en: '**alien_invasion.py**'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**alien_invasion.py**'
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We make a new `_check_events()` method ❷ and move the lines that check whether
    the player has clicked to close the window into this new method.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个新的`_check_events()`方法❷，并将检查玩家是否点击关闭窗口的代码移入这个新方法中。
- en: To call a method from within a class, use dot notation with the variable `self`
    and the name of the method ❶. We call the method from inside the `while` loop
    in `run_game()`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要从类内部调用方法，使用点符号和变量`self`以及方法名❶。我们在`run_game()`中的`while`循环内调用该方法。
- en: The _update_screen() Method
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`_update_screen()` 方法'
- en: 'To further simplify `run_game()`, we’ll move the code for updating the screen
    to a separate method called `_update_screen()`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步简化`run_game()`，我们将更新屏幕的代码移到一个名为`_update_screen()`的单独方法中：
- en: '**alien_invasion.py**'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**alien_invasion.py**'
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We moved the code that draws the background and the ship and flips the screen
    to `_update_screen()`. Now the body of the main loop in `run_game()` is much simpler.
    It’s easy to see that we’re looking for new events, updating the screen, and ticking
    the clock on each pass through the loop.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将绘制背景、飞船和翻转屏幕的代码移到了`_update_screen()`中。现在`run_game()`中主循环的主体部分简单多了。很容易看出，在每次循环中，我们都在寻找新事件、更新屏幕并更新时间。
- en: 'If you’ve already built a number of games, you’ll probably start out by breaking
    your code into methods like these. But if you’ve never tackled a project like
    this, you probably won’t know exactly how to structure your code at first. This
    approach gives you an idea of a realistic development process: you start out writing
    your code as simply as possible, and then refactor it as your project becomes
    more complex.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经开发了多个游戏，你可能会从将代码拆分成像这样的不同方法开始。但如果你从未尝试过这样的项目，你可能一开始并不知道如何构建你的代码。这个方法为你提供了一个现实的开发过程的思路：你开始时尽可能简单地编写代码，随着项目的复杂化再进行重构。
- en: Now that we’ve restructured the code to make it easier to add to, we can work
    on the dynamic aspects of the game!
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经重构了代码，使其更容易扩展，我们可以开始处理游戏的动态部分了！
- en: Piloting the Ship
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 驾驶飞船
- en: Next, we’ll give the player the ability to move the ship right and left. We’ll
    write code that responds when the player presses the right or left arrow key.
    We’ll focus first on movement to the right, and then we’ll apply the same principles
    to control movement to the left. As we add this code, you’ll learn how to control
    the movement of images on the screen and respond to user input.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将赋予玩家控制飞船左右移动的能力。我们将编写响应玩家按下右箭头或左箭头的代码。我们首先关注向右移动的实现，然后将相同的原则应用到控制向左移动上。当我们添加这段代码时，你将学习如何控制屏幕上图像的移动并响应用户输入。
- en: Responding to a Keypress
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 响应按键输入
- en: Whenever the player presses a key, that keypress is registered in Pygame as
    an event. Each event is picked up by the `pygame.event.get()` method. We need
    to specify in our `_check_events()` method what kinds of events we want the game
    to check for. Each keypress is registered as a `KEYDOWN` event.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 每当玩家按下某个键时，Pygame会将该按键记录为一个事件。每个事件都会被`pygame.event.get()`方法捕获。我们需要在`_check_events()`方法中指定游戏要检查哪些类型的事件。每个按键都会被记录为`KEYDOWN`事件。
- en: 'When Pygame detects a `KEYDOWN` event, we need to check whether the key that
    was pressed is one that triggers a certain action. For example, if the player
    presses the right arrow key, we want to increase the ship’s `rect.x` value to
    move the ship to the right:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当Pygame检测到`KEYDOWN`事件时，我们需要检查按下的键是否是触发某个动作的键。例如，如果玩家按下右箭头键，我们希望增加飞船的`rect.x`值，使飞船向右移动：
- en: '**alien_invasion.py**'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**alien_invasion.py**'
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Inside `_check_events()` we add an `elif` block to the event loop, to respond
    when Pygame detects a `KEYDOWN` event ❶. We check whether the key pressed, `event.key`,
    is the right arrow key ❷. The right arrow key is represented by `pygame.K_RIGHT`.
    If the right arrow key was pressed, we move the ship to the right by increasing
    the value of `self.ship.rect.x` by 1 ❸.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在`_check_events()`内部，我们在事件循环中添加了一个`elif`块，以响应Pygame检测到的`KEYDOWN`事件 ❶。我们检查按下的键`event.key`是否是右箭头键
    ❷。右箭头键由`pygame.K_RIGHT`表示。如果按下了右箭头键，我们通过增加`self.ship.rect.x`的值1来将船向右移动 ❸。
- en: When you run *alien_invasion.py* now, the ship should move to the right one
    pixel every time you press the right arrow key. That’s a start, but it’s not an
    efficient way to control the ship. Let’s improve this control by allowing continuous
    movement.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你运行*alien_invasion.py*时，每次按下右箭头键，船只应该向右移动一个像素。虽然这是一个开始，但这并不是一种高效的控制船只的方式。我们可以通过允许连续移动来改善这种控制方式。
- en: Allowing Continuous Movement
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 允许连续移动
- en: When the player holds down the right arrow key, we want the ship to continue
    moving right until the player releases the key. We’ll have the game detect a `pygame.KEYUP`
    event so we’ll know when the right arrow key is released; then we’ll use the `KEYDOWN`
    and `KEYUP` events together with a flag called `moving_right` to implement continuous
    motion.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家按住右箭头键时，我们希望船持续向右移动，直到玩家松开按键。我们将让游戏检测`pygame.KEYUP`事件，这样我们就能知道什么时候松开右箭头键；然后，我们将使用`KEYDOWN`和`KEYUP`事件结合一个名为`moving_right`的标志来实现连续运动。
- en: When the `moving_right` flag is `False`, the ship will be motionless. When the
    player presses the right arrow key, we’ll set the flag to `True`, and when the
    player releases the key, we’ll set the flag to `False` again.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当`moving_right`标志为`False`时，船将停止不动。当玩家按下右箭头键时，我们将该标志设置为`True`，当玩家松开键时，我们将该标志再次设置为`False`。
- en: The `Ship` class controls all attributes of the ship, so we’ll give it an attribute
    called `moving_right` and an `update()` method to check the status of the `moving_right`
    flag. The `update()` method will change the position of the ship if the flag is
    set to `True`. We’ll call this method once on each pass through the `while` loop
    to update the position of the ship.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ship`类控制船的所有属性，所以我们将为其添加一个名为`moving_right`的属性，以及一个`update()`方法来检查`moving_right`标志的状态。如果该标志被设置为`True`，`update()`方法将改变船的位置。我们将在每次循环中调用此方法一次，以更新船的位置。'
- en: 'Here are the changes to `Ship`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对`Ship`的修改：
- en: '**ship.py**'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**ship.py**'
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We add a `self.moving_right` attribute in the `__init__()` method and set it
    to `False` initially ❶. Then we add `update()`, which moves the ship right if
    the flag is `True` ❷. The `update()` method will be called from outside the class,
    so it’s not considered a helper method.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`__init__()`方法中添加了一个`self.moving_right`属性，并将其初始值设置为`False` ❶。然后我们添加了`update()`方法，如果标志为`True`，它会将船向右移动
    ❷。`update()`方法将在类外部调用，因此它不被视为辅助方法。
- en: 'Now we need to modify `_check_events()` so that `moving_right` is set to `True`
    when the right arrow key is pressed and `False` when the key is released:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要修改`_check_events()`，使得在按下右箭头键时将`moving_right`设置为`True`，在松开按键时将其设置为`False`：
- en: '**alien_invasion.py**'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**alien_invasion.py**'
- en: '[PRE13]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here, we modify how the game responds when the player presses the right arrow
    key: instead of changing the ship’s position directly, we merely set `moving_right`
    to `True` ❶. Then we add a new `elif` block, which responds to `KEYUP` events
    ❷. When the player releases the right arrow key (`K_RIGHT`), we set `moving_right`
    to `False`.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们修改了游戏对玩家按下右箭头键的响应方式：我们不直接改变船的位置，而是将`moving_right`设置为`True` ❶。然后我们添加了一个新的`elif`块，用于响应`KEYUP`事件
    ❷。当玩家松开右箭头键（`K_RIGHT`）时，我们将`moving_right`设置为`False`。
- en: 'Next, we modify the `while` loop in `run_game()` so it calls the ship’s `update()`
    method on each pass through the loop:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们修改`run_game()`中的`while`循环，使其在每次循环时调用船的`update()`方法：
- en: '**alien_invasion.py**'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**alien_invasion.py**'
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The ship’s position will be updated after we’ve checked for keyboard events
    and before we update the screen. This allows the ship’s position to be updated
    in response to player input and ensures the updated position will be used when
    drawing the ship to the screen.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 船的位置将在检查键盘事件并更新屏幕之前进行更新。这使得船的位置可以根据玩家输入进行更新，并确保更新后的位置会用于绘制船只到屏幕上。
- en: When you run *alien_invasion.py* and hold down the right arrow key, the ship
    should move continuously to the right until you release the key.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行*alien_invasion.py*并按住右箭头键时，船应该会持续向右移动，直到你松开按键。
- en: Moving Both Left and Right
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现左右移动
- en: 'Now that the ship can move continuously to the right, adding movement to the
    left is straightforward. Again, we’ll modify the `Ship` class and the `_check_events()`
    method. Here are the relevant changes to `__init__()` and `update()` in `Ship`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 既然飞船现在可以持续向右移动，添加向左移动就变得很简单了。我们再次修改 `Ship` 类和 `_check_events()` 方法。以下是对 `__init__()`
    和 `update()` 在 `Ship` 中的相关修改：
- en: '**ship.py**'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**ship.py**'
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In `__init__()`, we add a `self.moving_left` flag. In `update()`, we use two
    separate `if` blocks, rather than an `elif`, to allow the ship’s `rect.x` value
    to be increased and then decreased when both arrow keys are held down. This results
    in the ship standing still. If we used `elif` for motion to the left, the right
    arrow key would always have priority. Using two `if` blocks makes the movements
    more accurate when the player might momentarily hold down both keys when changing
    directions.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `__init__()` 中，我们添加了一个 `self.moving_left` 标志。在 `update()` 中，我们使用两个独立的 `if`
    块，而不是 `elif`，这样可以让飞船的 `rect.x` 值在按住两个箭头键时先增加然后减少。这样可以使飞船保持静止。如果我们对左移使用 `elif`，右箭头键将始终具有优先权。使用两个
    `if` 块可以使飞船在玩家可能会短暂按住两个键时改变方向时更精确地移动。
- en: 'We have to make two additions to `_check_events()`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在 `_check_events()` 中做两项新增操作：
- en: '**alien_invasion.py**'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**alien_invasion.py**'
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If a `KEYDOWN` event occurs for the `K_LEFT` key, we set `moving_left` to `True`.
    If a `KEYUP` event occurs for the `K_LEFT` key, we set `moving_left` to `False`.
    We can use `elif` blocks here because each event is connected to only one key.
    If the player presses both keys at once, two separate events will be detected.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `K_LEFT` 键发生 `KEYDOWN` 事件，我们将 `moving_left` 设置为 `True`。如果 `K_LEFT` 键发生 `KEYUP`
    事件，我们将 `moving_left` 设置为 `False`。由于每个事件只与一个按键相关联，所以这里可以使用 `elif` 块。如果玩家同时按下两个按键，将会检测到两个独立的事件。
- en: When you run *alien_invasion.py* now, you should be able to move the ship continuously
    to the right and left. If you hold down both keys, the ship should stop moving.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当你现在运行 *alien_invasion.py* 时，应该能够让飞船持续向左和向右移动。如果同时按住两个方向键，飞船应该会停止移动。
- en: Next, we’ll further refine the ship’s movement. Let’s adjust the ship’s speed
    and limit how far the ship can move so it can’t disappear off the sides of the
    screen.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将进一步优化飞船的移动。让我们调整飞船的速度，并限制飞船的移动范围，以防止它消失在屏幕的边缘。
- en: Adjusting the Ship’s Speed
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调整飞船的速度
- en: 'Currently, the ship moves one pixel per cycle through the `while` loop, but
    we can take finer control of the ship’s speed by adding a `ship_speed` attribute
    to the `Settings` class. We’ll use this attribute to determine how far to move
    the ship on each pass through the loop. Here’s the new attribute in *settings.py*:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，飞船每次通过 `while` 循环时移动一个像素，但我们可以通过向 `Settings` 类中添加 `ship_speed` 属性来更精细地控制飞船的速度。我们将使用这个属性来确定飞船在每次循环中应移动的距离。以下是
    *settings.py* 中的新属性：
- en: '**settings.py**'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**settings.py**'
- en: '[PRE17]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We set the initial value of `ship_speed` to `1.5`. When the ship moves now,
    its position is adjusted by 1.5 pixels (rather than 1 pixel) on each pass through
    the loop.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `ship_speed` 的初始值设置为 `1.5`。现在飞船移动时，它的位置在每次循环中调整 1.5 像素（而不是 1 像素）。
- en: 'We’re using a float for the speed setting to give us finer control of the ship’s
    speed when we increase the tempo of the game later on. However, `rect` attributes
    such as `x` store only integer values, so we need to make some modifications to
    `Ship`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用浮动数值来设置速度，以便在稍后增加游戏节奏时更精细地控制飞船的速度。然而，`rect` 属性如 `x` 只存储整数值，因此我们需要对 `Ship`
    做一些修改：
- en: '**ship.py**'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**ship.py**'
- en: '[PRE18]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We create a `settings` attribute for `Ship`, so we can use it in `update()`
    ❶. Because we’re adjusting the position of the ship by fractions of a pixel, we
    need to assign the position to a variable that can have a float assigned to it.
    You can use a float to set an attribute of a `rect`, but the `rect` will only
    keep the integer portion of that value. To keep track of the ship’s position accurately,
    we define a new `self.x` ❷. We use the `float()` function to convert the value
    of `self.rect.x` to a float and assign this value to `self.x`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为 `Ship` 创建了一个 `settings` 属性，这样就可以在 `update()` ❶ 中使用它。因为我们是通过像素的分数来调整飞船的位置，所以我们需要将位置赋值给一个可以存储浮动值的变量。你可以使用浮动数值来设置
    `rect` 的属性，但 `rect` 只会保留该值的整数部分。为了精确追踪飞船的位置，我们定义了一个新的 `self.x` ❷。我们使用 `float()`
    函数将 `self.rect.x` 的值转换为浮动数值，并将该值赋给 `self.x`。
- en: Now when we change the ship’s position in `update()`, the value of `self.x`
    is adjusted by the amount stored in `settings.ship_speed` ❸. After `self.x` has
    been updated, we use the new value to update `self.rect.x`, which controls the
    position of the ship ❹. Only the integer portion of `self.x` will be assigned
    to `self.rect.x`, but that’s fine for displaying the ship.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们在`update()`方法中改变飞船的位置时，`self.x`的值会根据`settings.ship_speed`中存储的数值进行调整 ❸。在更新了`self.x`之后，我们使用这个新值来更新`self.rect.x`，控制飞船的位置
    ❹。只有`self.x`的整数部分会被赋给`self.rect.x`，但这对于显示飞船来说已经足够了。
- en: Now we can change the value of `ship_speed`, and any value greater than 1 will
    make the ship move faster. This will help make the ship respond quickly enough
    to shoot down aliens, and it will let us change the tempo of the game as the player
    progresses in gameplay.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以改变`ship_speed`的值，任何大于1的值都会让飞船加速。这将有助于让飞船快速响应，打败外星人，并且随着玩家在游戏中的进展，我们可以改变游戏的节奏。
- en: Limiting the Ship’s Range
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 限制飞船的活动范围
- en: 'At this point, the ship will disappear off either edge of the screen if you
    hold down an arrow key long enough. Let’s correct this so the ship stops moving
    when it reaches the screen’s edge. We do this by modifying the `update()` method
    in `Ship`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，如果你长时间按住箭头键，飞船会消失在屏幕的两边。让我们修正这个问题，让飞船在到达屏幕边缘时停止移动。我们通过修改`Ship`中的`update()`方法来实现这个目标：
- en: '**ship.py**'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**ship.py**'
- en: '[PRE19]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This code checks the position of the ship before changing the value of `self.x`.
    The code `self.rect.right` returns the *x*-coordinate of the right edge of the
    ship’s `rect`. If this value is less than the value returned by `self.screen_rect.right`,
    the ship hasn’t reached the right edge of the screen ❶. The same goes for the
    left edge: if the value of the left side of the `rect` is greater than 0, the
    ship hasn’t reached the left edge of the screen ❷. This ensures the ship is within
    these bounds before adjusting the value of `self.x`.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码在修改`self.x`的值之前会检查飞船的位置。代码`self.rect.right`返回的是飞船`rect`右边缘的* x *坐标。如果这个值小于`self.screen_rect.right`返回的值，那么飞船还没有到达屏幕的右边缘
    ❶。左边缘的情况也是一样：如果`rect`左边的值大于0，那么飞船还没有到达屏幕的左边缘 ❷。这确保了在调整`self.x`的值之前，飞船位于这些边界内。
- en: When you run *alien_invasion.py* now, the ship should stop moving at either
    edge of the screen. This is pretty cool; all we’ve done is add a conditional test
    in an `if` statement, but it feels like the ship hits a wall or force field at
    either edge of the screen!
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行*alien_invasion.py*时，飞船应该会在屏幕的两边停止移动。这真的很酷，我们所做的仅仅是添加了一个`if`语句中的条件测试，但感觉飞船在屏幕的两边像撞上了墙或者力场一样！
- en: Refactoring _check_events()
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重构`_check_events()`
- en: 'The `_check_events()` method will increase in length as we continue to develop
    the game, so let’s break `_check_events()` into two separate methods: one that
    handles `KEYDOWN` events and another that handles `KEYUP` events:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们不断开发游戏，`_check_events()`方法会变得越来越长，所以让我们把`_check_events()`分解成两个独立的方法：一个处理`KEYDOWN`事件，另一个处理`KEYUP`事件：
- en: '**alien_invasion.py**'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**alien_invasion.py**'
- en: '[PRE20]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We make two new helper methods: `_check_keydown_events()` and `_check_keyup_events()`.
    Each needs a `self` parameter and an `event` parameter. The bodies of these two
    methods are copied from `_check_events()`, and we’ve replaced the old code with
    calls to the new methods. The `_check_events()` method is simpler now with this
    cleaner code structure, which will make it easier to develop further responses
    to player input.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了两个新的辅助方法：`_check_keydown_events()`和`_check_keyup_events()`。每个方法都需要一个`self`参数和一个`event`参数。这两个方法的代码体是从`_check_events()`中复制过来的，我们用调用新方法的代码替换了旧的代码。现在，`_check_events()`方法变得更加简洁，这种清晰的代码结构将使得进一步开发对玩家输入的响应更加容易。
- en: Pressing Q to Quit
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 按下Q退出
- en: 'Now that we’re responding to keypresses efficiently, we can add another way
    to quit the game. It gets tedious to click the X at the top of the game window
    to end the game every time you test a new feature, so we’ll add a keyboard shortcut
    to end the game when the player presses Q:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经高效地响应了按键输入，我们可以添加另一种退出游戏的方式。每次测试新功能时，点击游戏窗口顶部的X来结束游戏会变得很麻烦，所以我们将添加一个快捷键，当玩家按下Q时结束游戏：
- en: '**alien_invasion.py**'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**alien_invasion.py**'
- en: '[PRE21]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In `_check_keydown_events()`, we add a new block that ends the game when the
    player presses Q. Now, when testing, you can press Q to close the game instead
    of using your cursor to close the window.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在`_check_keydown_events()`方法中，我们添加了一个新的代码块，当玩家按下Q时结束游戏。现在，在测试时，你可以按下Q来关闭游戏，而不需要使用光标关闭窗口。
- en: Running the Game in Fullscreen Mode
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在全屏模式下运行游戏
- en: Pygame has a fullscreen mode that you might like better than running the game
    in a regular window. Some games look better in fullscreen mode, and on some systems,
    the game may perform better overall in fullscreen mode.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Pygame 有一个全屏模式，你可能会比在常规窗口中运行游戏更喜欢它。有些游戏在全屏模式下看起来更好，在某些系统上，游戏在全屏模式下可能整体表现得更好。
- en: 'To run the game in fullscreen mode, make the following changes in `__init__()`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要以全屏模式运行游戏，请在 `__init__()` 方法中进行以下更改：
- en: '**alien_invasion.py**'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**alien_invasion.py**'
- en: '[PRE22]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: When creating the screen surface, we pass a size of `(0, 0)` and the parameter
    `pygame.FULLSCREEN` ❶. This tells Pygame to figure out a window size that will
    fill the screen. Because we don’t know the width and height of the screen ahead
    of time, we update these settings after the screen is created ❷. We use the `width`
    and `height` attributes of the screen’s `rect` to update the `settings` object.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建屏幕表面时，我们传递了 `(0, 0)` 的大小和 `pygame.FULLSCREEN` 参数 ❶。这告诉 Pygame 计算一个将填充屏幕的窗口大小。因为我们无法提前知道屏幕的宽度和高度，所以在屏幕创建后我们更新这些设置
    ❷。我们使用屏幕 `rect` 的 `width` 和 `height` 属性来更新 `settings` 对象。
- en: If you like how the game looks or behaves in fullscreen mode, keep these settings.
    If you liked the game better in its own window, you can revert back to the original
    approach where we set a specific screen size for the game.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢游戏在全屏模式下的外观或表现，可以保持这些设置。如果你更喜欢游戏在自己的窗口中运行，可以恢复到原始方法，在该方法中我们为游戏设置了一个特定的屏幕尺寸。
- en: A Quick Recap
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速回顾
- en: In the next section, we’ll add the ability to shoot bullets, which involves
    adding a new file called *bullet.py* and making some modifications to some of
    the files we’re already using. Right now, we have three files containing a number
    of classes and methods. To be clear about how the project is organized, let’s
    review each of these files before adding more functionality.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一部分，我们将增加开火的功能，这涉及添加一个名为 *bullet.py* 的新文件，并对我们已经使用的一些文件进行一些修改。目前，我们有三个文件包含多个类和方法。为了更清楚地了解项目的组织方式，在添加更多功能之前，让我们回顾一下这些文件。
- en: alien_invasion.py
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: alien_invasion.py
- en: 'The main file, *alien_invasion.py*, contains the `AlienInvasion` class. This
    class creates a number of important attributes used throughout the game: the settings
    are assigned to `settings`, the main display surface is assigned to `screen`,
    and a `ship` instance is created in this file as well. The main loop of the game,
    a `while` loop, is also stored in this module. The `while` loop calls `_check_events()`,
    `ship.update()`, and `_update_screen()`. It also ticks the clock on each pass
    through the loop.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 主要文件 *alien_invasion.py* 包含 `AlienInvasion` 类。此类创建了许多在整个游戏中使用的重要属性：设置被分配给 `settings`，主显示表面被分配给
    `screen`，并且在此文件中也创建了一个 `ship` 实例。游戏的主循环，一个 `while` 循环，也存储在这个模块中。`while` 循环调用 `_check_events()`、`ship.update()`
    和 `_update_screen()` 方法。它还在每次通过循环时更新时钟。
- en: The `_check_events()` method detects relevant events, such as keypresses and
    releases, and processes each of these types of events through the methods `_check_keydown_events()`
    and `_check_keyup_events()`. For now, these methods manage the ship’s movement.
    The `AlienInvasion` class also contains `_update_screen()`, which redraws the
    screen on each pass through the main loop.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`_check_events()` 方法检测相关事件，如按键和释放，并通过 `_check_keydown_events()` 和 `_check_keyup_events()`
    方法处理这些事件。目前，这些方法管理船只的移动。`AlienInvasion` 类还包含 `_update_screen()`，该方法在每次通过主循环时重绘屏幕。'
- en: The *alien_invasion.py* file is the only file you need to run when you want
    to play *Alien Invasion*. The other files, *settings.py* and *ship.py*, contain
    code that is imported into this file.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '*alien_invasion.py* 文件是你运行游戏时唯一需要的文件。其他文件 *settings.py* 和 *ship.py* 包含的代码会被导入到这个文件中。'
- en: settings.py
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: settings.py
- en: The *settings.py* file contains the `Settings` class. This class only has an
    `__init__()` method, which initializes attributes controlling the game’s appearance
    and the ship’s speed.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '*settings.py* 文件包含 `Settings` 类。此类只有一个 `__init__()` 方法，用于初始化控制游戏外观和船只速度的属性。'
- en: ship.py
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ship.py
- en: The *ship.py* file contains the `Ship` class. The `Ship` class has an `__init__()`
    method, an `update()` method to manage the ship’s position, and a `blitme()` method
    to draw the ship to the screen. The image of the ship is stored in *ship.bmp*,
    which is in the *images* folder.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '*ship.py* 文件包含 `Ship` 类。`Ship` 类具有 `__init__()` 方法，一个用于管理船只位置的 `update()` 方法，以及一个用于将船只绘制到屏幕上的
    `blitme()` 方法。船只的图像存储在 *ship.bmp* 文件中，该文件位于 *images* 文件夹内。'
- en: Shooting Bullets
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开火
- en: Now let’s add the ability to shoot bullets. We’ll write code that fires a bullet,
    which is represented by a small rectangle, when the player presses the spacebar.
    Bullets will then travel straight up the screen until they disappear off the top
    of the screen.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们添加射击子弹的功能。当玩家按下空格键时，我们将编写代码发射子弹，子弹以小矩形的形式表示。子弹将一直向上移动，直到从屏幕顶部消失。
- en: Adding the Bullet Settings
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加子弹设置
- en: 'At the end of the `__init__()` method, we’ll update *settings.py* to include
    the values we’ll need for a new `Bullet` class:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在`__init__()`方法的末尾，我们将更新*settings.py*，以包含我们为新的`Bullet`类所需的值：
- en: '**settings.py**'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**settings.py**'
- en: '[PRE23]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: These settings create dark gray bullets with a width of `3` pixels and a height
    of `15` pixels. The bullets will travel slightly faster than the ship.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设置创建了深灰色的子弹，宽度为`3`像素，高度为`15`像素。子弹的移动速度将略快于飞船。
- en: Creating the Bullet Class
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建子弹类
- en: 'Now create a *bullet.py* file to store our `Bullet` class. Here’s the first
    part of *bullet.py*:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建一个*bullet.py*文件来存储我们的`Bullet`类。以下是*bullet.py*的第一部分：
- en: '**bullet.py**'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**bullet.py**'
- en: '[PRE24]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `Bullet` class inherits from `Sprite`, which we import from the `pygame.sprite`
    module. When you use sprites, you can group related elements in your game and
    act on all the grouped elements at once. To create a bullet instance, `__init__()`
    needs the current instance of `AlienInvasion`, and we call ``super() to inherit
    properly from `Sprite`. We also set attributes for the screen and settings objects,
    and for the bullet’s color.``
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bullet`类继承自`Sprite`，我们从`pygame.sprite`模块导入它。使用精灵时，您可以将游戏中相关的元素分组，并同时对所有分组的元素进行操作。为了创建一个子弹实例，`__init__()`需要当前的`AlienInvasion`实例，并且我们调用`super()`以正确继承自`Sprite`。我们还为屏幕和设置对象以及子弹的颜色设置了属性。'
- en: '[PRE25] def update(self):     """Move the bullet up the screen."""     # Update
    the exact position of the bullet. ❶     self.y -= self.settings.bullet_speed     #
    Update the rect position. ❷     self.rect.y = self.y  def draw_bullet(self):     """Draw
    the bullet to the screen.""" ❸     pygame.draw.rect(self.screen, self.color, self.rect)
    [PRE26] *--snip--* from ship import Ship from bullet import Bullet [PRE27]  def
    __init__(self):   *--snip--*  self.ship = Ship(self)   self.bullets = pygame.sprite.Group()
    [PRE28]  def run_game(self):  """Start the main loop for the game."""  while True:  self._check_events()  self.ship.update()   self.bullets.update()  self._update_screen()  self.clock.tick(60)
    [PRE29]  def _check_keydown_events(self, event):   *--snip--*  elif event.key
    == pygame.K_q:  sys.exit() ❶         elif event.key == pygame.K_SPACE:             self._fire_bullet()   def
    _check_keyup_events(self, event):   *--snip--*      def _fire_bullet(self):         """Create
    a new bullet and add it to the bullets group.""" ❷         new_bullet = Bullet(self)
    ❸         self.bullets.add(new_bullet)   def _update_screen(self):  """Update
    images on the screen, and flip to the new screen."""  self.screen.fill(self.settings.bg_color)
    ❹       for bullet in self.bullets.sprites():             bullet.draw_bullet()  self.ship.blitme()   pygame.display.flip()
    *--snip--* [PRE30]  def run_game(self):  """Start the main loop for the game."""  while
    True:  self._check_events()  self.ship.update()  self.bullets.update()              #
    Get rid of bullets that have disappeared. ❶             for bullet in self.bullets.copy():
    ❷                 if bullet.rect.bottom <= 0: ❸                     self.bullets.remove(bullet)
    ❹             print(len(self.bullets))   self._update_screen()  self.clock.tick(60)
    [PRE31]  # Bullet settings   *--snip--*  self.bullet_color = (60, 60, 60)   self.bullets_allowed
    = 3 [PRE32]  def _fire_bullet(self):  """Create a new bullet and add it to the
    bullets group."""   if len(self.bullets) < self.settings.bullets_allowed:  new_bullet
    = Bullet(self)  self.bullets.add(new_bullet) [PRE33]  def _update_bullets(self):         """Update
    position of bullets and get rid of old bullets."""         # Update bullet positions.  self.bullets.update()   #
    Get rid of bullets that have disappeared.  for bullet in self.bullets.copy():  if
    bullet.rect.bottom <= 0:  self.bullets.remove(bullet) [PRE34]  while True:  self._check_events()  self.ship.update()   self._update_bullets()  self._update_screen()  self.clock.tick(60)
    [PRE35]`'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE25] def update(self):     """将子弹向屏幕上移."""     # 更新子弹的准确位置。 ❶     self.y
    -= self.settings.bullet_speed     # 更新矩形的位置。 ❷     self.rect.y = self.y  def draw_bullet(self):     """将子弹绘制到屏幕上."""
    ❸     pygame.draw.rect(self.screen, self.color, self.rect) [PRE26] *--snip--*
    from ship import Ship from bullet import Bullet [PRE27]  def __init__(self):   *--snip--*  self.ship
    = Ship(self)   self.bullets = pygame.sprite.Group() [PRE28]  def run_game(self):  """启动游戏的主循环."""  while
    True:  self._check_events()  self.ship.update()   self.bullets.update()  self._update_screen()  self.clock.tick(60)
    [PRE29]  def _check_keydown_events(self, event):   *--snip--*  elif event.key
    == pygame.K_q:  sys.exit() ❶         elif event.key == pygame.K_SPACE:             self._fire_bullet()   def
    _check_keyup_events(self, event):   *--snip--*      def _fire_bullet(self):         """创建一个新的子弹并将其添加到子弹组中."""
    ❷         new_bullet = Bullet(self) ❸         self.bullets.add(new_bullet)   def
    _update_screen(self):  """更新屏幕上的图像，并切换到新屏幕."""  self.screen.fill(self.settings.bg_color)
    ❹       for bullet in self.bullets.sprites():             bullet.draw_bullet()  self.ship.blitme()   pygame.display.flip()
    *--snip--* [PRE30]  def run_game(self):  """启动游戏的主循环."""  while True:  self._check_events()  self.ship.update()  self.bullets.update()              #
    去除已经消失的子弹。 ❶             for bullet in self.bullets.copy(): ❷                 if
    bullet.rect.bottom <= 0: ❸                     self.bullets.remove(bullet) ❹             print(len(self.bullets))   self._update_screen()  self.clock.tick(60)
    [PRE31]  # 子弹设置   *--snip--*  self.bullet_color = (60, 60, 60)   self.bullets_allowed
    = 3 [PRE32]  def _fire_bullet(self):  """创建一个新的子弹并将其添加到子弹组中."""   if len(self.bullets)
    < self.settings.bullets_allowed:  new_bullet = Bullet(self)  self.bullets.add(new_bullet)
    [PRE33]  def _update_bullets(self):         """更新子弹位置并去除旧的子弹."""         # 更新子弹位置。  self.bullets.update()   #
    去除已经消失的子弹。  for bullet in self.bullets.copy():  if bullet.rect.bottom <= 0:  self.bullets.remove(bullet)
    [PRE34]  while True:  self._check_events()  self.ship.update()   self._update_bullets()  self._update_screen()  self.clock.tick(60)
    [PRE35]'
