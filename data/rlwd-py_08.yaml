- en: '8'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '8'
- en: DETECTING DISTANT EXOPLANETS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 探测遥远系外行星
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/common.jpg)'
- en: Extrasolar planets, called exoplanets for short, are planets that orbit alien
    suns. By the end of 2019, more than 4,000 exoplanets had been discovered. That’s
    an average of 150 per year since the first confirmed discovery in 1992! These
    days, finding a faraway planet seems as easy as catching a cold, yet it took almost
    all human history—up to 1930—to discover the eight planets, plus Pluto, that make
    up our own solar system.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 系外行星，简称外行星，是围绕外星太阳公转的行星。到2019年底，已发现超过4000颗系外行星。这意味着自1992年首次确认发现系外行星以来，平均每年发现150颗！如今，发现一颗遥远的行星似乎像感冒一样容易，但人类几乎花费了整个历史——直到1930年——才发现了构成我们太阳系的八颗行星以及冥王星。
- en: Astronomers detected the first exoplanets by observing gravitationally induced
    wobble in the motion of stars. Today, they rely mainly on the slight dimming of
    a star’s light as the exoplanet passes between the star and Earth. And with powerful
    next-generation devices like the James Webb Space Telescope, they’ll directly
    image exoplanets and learn about their rotation, seasons, weather, vegetation,
    and more.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 天文学家通过观察恒星运动中的引力诱发摆动，首次探测到系外行星。如今，他们主要依赖于当系外行星从恒星与地球之间经过时，恒星光线的微弱变暗。借助强大的下一代设备，如詹姆斯·韦伯太空望远镜，他们将能够直接拍摄系外行星的图像，并了解其旋转、季节、天气、植被等更多信息。
- en: In this chapter, you’ll use OpenCV and matplotlib to simulate an exoplanet passing
    before its sun. You’ll record the resulting light curve and then use it to detect
    the planet and estimate its diameter. Then, you’ll simulate how an exoplanet might
    look to the James Webb Space Telescope. In the “Practice Project” sections, you’ll
    investigate unusual light curves that may represent enormous alien megastructures
    designed to harness a star’s energy.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将使用OpenCV和matplotlib模拟一个系外行星在其太阳前经过的过程。你将记录下由此产生的光曲线，然后利用它来探测行星并估算其直径。接着，你将模拟系外行星如何呈现给詹姆斯·韦伯太空望远镜。在“实践项目”部分，你将研究一些异常的光曲线，这些曲线可能代表巨大的外星巨型结构，这些结构是为了利用恒星的能量而设计的。
- en: '**Transit Photometry**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**凌星光度法**'
- en: In astronomy, a *transit* occurs when a relatively small celestial body passes
    directly between the disc of a larger body and an observer. When the small body
    moves across the face of the larger body, the larger body dims slightly. The best-known
    transits are those of Mercury and Venus against our own sun ([Figure 8-1](ch08.xhtml#ch08fig1)).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在天文学中，*凌星*是指相对较小的天体直接穿过较大天体的盘面与观察者之间。当小天体移动到较大天体的面前时，较大天体会略微变暗。最著名的凌星现象是水星和金星凌日（参见[图8-1](ch08.xhtml#ch08fig1)）。
- en: '![Image](../images/fig08_01.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/fig08_01.jpg)'
- en: 'Figure 8-1: Clouds and Venus (the black dot) passing before the sun in June
    2012'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-1：2012年6月，云层和金星（黑点）在太阳前经过
- en: With today’s technology, astronomers can detect the subtle dimming of a faraway
    star’s light during a transit event. The technique, called *transit photometry*,
    outputs a plot of a star’s brightness over time ([Figure 8-2](ch08.xhtml#ch08fig2)).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 通过今天的技术，天文学家可以在凌星事件中探测到遥远恒星光线的微弱变暗。这一技术称为*凌星光度法*，其结果是绘制出恒星亮度随时间变化的图表（参见[图8-2](ch08.xhtml#ch08fig2)）。
- en: '![Image](../images/fig08_02.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/fig08_02.jpg)'
- en: 'Figure 8-2: The transit photometry technique for detecting exoplanets'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-2：用凌星光度法探测系外行星的技术
- en: In [Figure 8-2](ch08.xhtml#ch08fig2), the dots on the light curve graph represent
    measurements of the light given off by a star. When a planet is not positioned
    over the star ➊, the measured brightness is at a maximum. (We’ll ignore light
    reflected off the exoplanet as it goes through its phases, which would very slightly
    increase the apparent brightness of the star). As the leading edge of a planet
    moves onto the disc ➋, the emitted light progressively dims, forming a ramp in
    the light curve. When the entire planet is visible against the disc ➌, the light
    curve flattens, and it remains flat until the planet begins exiting the far side
    of the disc. This creates another ramp ➍, which rises until the planet passes
    completely off the disc ➎. At that point, the light curve flattens at its maximum
    value, as the star is no longer obscured.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图8-2](ch08.xhtml#ch08fig2)中，光度曲线图上的点表示恒星发出的光的测量值。当行星不位于恒星上方 ➊ 时，测得的亮度是最大的。（我们将忽略系外行星在经历其不同相位时反射的光，这会非常轻微地增加恒星的表观亮度）。随着行星的前缘开始进入恒星盘面
    ➋，发出的光逐渐变暗，形成光度曲线中的上升段。当整个行星出现在盘面上 ➌ 时，光度曲线变平，并保持平稳，直到行星开始从盘面的远端退出。这时形成另一段上升段
    ➍，直到行星完全离开盘面 ➎。此时，光度曲线恢复到最大值，因为恒星不再被遮挡。
- en: 'Because the amount of light blocked during a transit is proportional to the
    size of the planet’s disc, you can calculate the radius of the planet using the
    following formula:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 由于过境期间阻挡的光量与行星盘面的大小成正比，因此你可以使用以下公式来计算行星的半径：
- en: '![Image](../images/equ_page_179_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/equ_page_179_01.jpg)'
- en: where *R*[p] is the planet’s radius and *R*[*s*] is the star’s radius. Astronomers
    determine the star’s radius using its distance, brightness, and color, which relates
    to its temperature. *Depth* refers to the total change in brightness during the
    transit ([Figure 8-3](ch08.xhtml#ch08fig3)).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *R*[p] 是行星的半径，*R*[*s*] 是恒星的半径。天文学家通过恒星的距离、亮度和颜色（与恒星的温度相关）来确定恒星的半径。*深度*指的是在过境期间亮度的总变化量（见[图8-3](ch08.xhtml#ch08fig3)）。
- en: '![Image](../images/fig08_03.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig08_03.jpg)'
- en: 'Figure 8-3: Depth represents the total change in brightness observed in a light
    curve.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-3：深度代表在光度曲线中观察到的亮度变化总量。
- en: Of course, these calculations assume that the whole exoplanet, not just part
    of it, moved over the face of the star. The latter may occur if the exoplanet
    skims either the top or bottom of the star (from our point of view). We’ll look
    at this case in “Experimenting with Transit Photometry” on [page 182](ch08.xhtml#page_182).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这些计算假设整个系外行星，而不是它的一部分，都会经过恒星的表面。如果系外行星只掠过恒星的上方或下方（从我们的视角来看），则可能会出现后者的情况。我们将在“过境光度测量实验”中探讨这种情况，见[第182页](ch08.xhtml#page_182)。
- en: '**Project #11: Simulating an Exoplanet Transit**'
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**项目 #11：模拟系外行星过境**'
- en: Before I flew to Idaho to photograph the Great American Eclipse of 2017, I did
    my homework. The totality event, when the moon completely covered the sun, lasted
    only 2 minutes and 10 seconds. That left no time for experimenting, testing, or
    figuring things out on the fly. To successfully capture images of the penumbra,
    umbra, solar flares, and diamond ring effect ([Figure 8-4](ch08.xhtml#ch08fig4)),
    I had to know exactly what equipment to take, what camera settings to use, and
    when these events would occur.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在我飞往爱达荷州拍摄2017年“大美洲日全食”之前，我做了充分的准备。全食事件，即月亮完全遮住太阳的那段时间，仅持续了2分钟10秒。这几乎没有时间进行实验、测试或临时处理。为了成功捕捉到半影、影子、太阳耀斑和钻石戒指效应（见[图8-4](ch08.xhtml#ch08fig4)），我必须精确知道带什么设备、使用什么相机设置，以及这些事件的发生时间。
- en: '![Image](../images/fig08_04.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig08_04.jpg)'
- en: 'Figure 8-4: Diamond ring effect at the end of totality, 2017 solar eclipse'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-4：2017年日全食末期的钻石戒指效应
- en: In a similar fashion, computer simulations prepare you for making observations
    of the natural world. They help you understand what to expect, when to expect
    it, and how to calibrate your instruments. In this project, you’ll create a simulation
    of an exoplanet transit event. You can run this simulation with different planet
    sizes to understand the impact of a transit’s size on the light curve. Later,
    you’ll use this simulation to evaluate light curves related to asteroid fields
    and possible alien megastructures.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，计算机模拟帮助你为观察自然世界做准备。它们帮助你理解预期的内容、何时发生，以及如何校准你的仪器。在本项目中，你将创建一个系外行星过境事件的模拟。你可以通过不同的行星大小来运行此模拟，从而理解过境大小对光度曲线的影响。稍后，你将使用该模拟来评估与小行星带和可能的外星超级结构相关的光度曲线。
- en: THE OBJECTIVE
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 目标
- en: Write a Python program that simulates an exoplanet transit, plots the resulting
    light curve, and calculates the radius of the exoplanet.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个Python程序来模拟系外行星凌星，绘制结果的光变曲线，并计算系外行星的半径。
- en: '***The Strategy***'
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***策略***'
- en: To generate a light curve, you need to be able to measure changes in brightness.
    You can do this by performing mathematical operations on pixels, such as finding
    mean, minimum, and maximum values, with OpenCV.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成光变曲线，您需要能够测量亮度的变化。您可以通过对像素进行数学运算来实现这一点，比如计算均值、最小值和最大值，使用OpenCV进行处理。
- en: Instead of using an image of a real transit and star, you’ll draw circles on
    a black rectangle, just as you drew rectangles on the Mars map in the previous
    chapter. To plot the light curve, you can use matplotlib, Python’s main plotting
    library. You installed matplotlib in “Installing NumPy and Other Scientific Packages
    with pip” on [page 8](ch01.xhtml#page_8) and began using it to make graphs in
    [Chapter 2](ch02.xhtml).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 您将不使用真实的凌星和恒星图像，而是会在黑色矩形上绘制圆形，正如您在上一章中绘制火星地图时所做的那样。为了绘制光变曲线，您可以使用matplotlib，Python的主要绘图库。您已经在“使用pip安装NumPy及其他科学包”中安装了matplotlib，并在[第二章](ch02.xhtml)开始使用它绘制图形。
- en: '***The Transit Code***'
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***凌星代码***'
- en: The *transit.py* program uses OpenCV to generate a visual simulation of an exoplanet
    transiting a star, plots the resulting light curve with matplotlib, and estimates
    the size of the planet using the planetary radius equation from [page 179](ch08.xhtml#page_179).
    You can enter the code yourself or download it from *[https://nostarch.com/real-world-python/](https://nostarch.com/real-world-python/)*.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*transit.py*程序使用OpenCV生成系外行星凌过恒星的视觉模拟，使用matplotlib绘制结果的光变曲线，并使用来自[第179页](ch08.xhtml#page_179)的行星半径方程来估算行星的大小。您可以自己输入代码或从*
    [https://nostarch.com/real-world-python/](https://nostarch.com/real-world-python/)*
    下载它。'
- en: '**Importing Modules and Assigning Constants**'
  id: totrans-32
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**导入模块和赋值常量**'
- en: '[Listing 8-1](ch08.xhtml#ch08list1) imports modules and assigns constants representing
    user input.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 8-1](ch08.xhtml#ch08list1)导入模块并赋值常量，表示用户输入的值。'
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 8-1: Importing modules and assigning constants'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 8-1：导入模块和赋值常量
- en: Import the math module for the planetary radius equation, NumPy for calculating
    the brightness of the image, OpenCV for drawing the simulation, and matplotlib
    for plotting the light curve. Then start assigning constants that will represent
    user-input values.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 导入math模块来计算行星半径方程，导入NumPy来计算图像的亮度，导入OpenCV来绘制模拟图像，导入matplotlib来绘制光变曲线。然后开始赋值常量，表示用户输入的值。
- en: Start with a height and width for the simulation window. The window will be
    a black, rectangular image built using the np.zeros() method, which returns an
    array of a given shape and type filled with zeros.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 从模拟窗口的高度和宽度开始。窗口将是一个黑色的矩形图像，通过使用np.zeros()方法创建，该方法返回一个形状和类型指定的、填充为零的数组。
- en: Recall that OpenCV images are NumPy arrays and items in the arrays must have
    the same type. The uint8 data type represents an unsigned integer from 0 to 255\.
    You can find a useful listing of other data types and their descriptions at *[https://numpy.org/devdocs/user/basics.types.html](https://numpy.org/devdocs/user/basics.types.html)*.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，OpenCV图像是NumPy数组，数组中的项必须具有相同的类型。uint8数据类型表示一个无符号整数，范围从0到255。您可以在* [https://numpy.org/devdocs/user/basics.types.html](https://numpy.org/devdocs/user/basics.types.html)*
    上找到其他数据类型及其描述的有用列表。
- en: Next, assign radius values, in pixels, for the star and exoplanet. OpenCV will
    use these constants when it draws circles representing them.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，赋值恒星和系外行星的半径值（以像素为单位）。OpenCV将在绘制它们的圆形时使用这些常量。
- en: The exoplanet will move across the face of the star, so you need to define how
    quickly it will move. The EXO_DX constant will increment the exoplanet’s *x* position
    by three pixels with each programming loop, causing the exoplanet to move left
    to right.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 系外行星将穿过恒星的面，因此您需要定义它的移动速度。EXO_DX常量将在每次编程循环中将系外行星的* x *位置增加三像素，使其从左到右移动。
- en: Assign two constants to set the exoplanet’s starting position. Then assign a
    NUM_FRAMES constant to control the number of simulation updates. Although you
    can calculate this number (IMG_WIDTH/EXO_DX), assigning it lets you fine-tune
    the duration of the simulation.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值两个常量来设置系外行星的起始位置。然后赋值一个NUM_FRAMES常量来控制模拟更新的次数。尽管您可以通过计算该数字（IMG_WIDTH/EXO_DX）来得到，但赋值可以让您微调模拟的持续时间。
- en: '**Defining the main() Function**'
  id: totrans-42
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**定义 main() 函数**'
- en: '[Listing 8-2](ch08.xhtml#ch08list2) defines the main() function used to run
    the program. Although you can define main() anywhere, placing it at the start
    lets it serve as a summary for the whole program, thus giving context to the functions
    defined later. As part of main(), you’ll calculate the exoplanet’s radius, nesting
    the equation within the call to the print() function.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表8-2](ch08.xhtml#ch08list2)定义了用于运行程序的main()函数。虽然你可以在任何位置定义main()，但将其放在开始部分使其成为整个程序的总结，从而为后面定义的函数提供上下文。作为main()的一部分，你将计算外行星的半径，将方程嵌套在print()函数的调用中。'
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 8-2: Defining the main() function'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8-2：定义main()函数
- en: After defining the main() function, name a variable intensity_samples and call
    the record_transit() function. *Intensity* refers to the amount of light, represented
    by the numerical value of a pixel. The record_transit() function draws the simulation
    to the screen, measures its intensity, appends the measurement to a list called
    intensity_samples, and returns the list. It needs the starting point (*x*, *y*)
    coordinates for the exoplanet. Pass it the starting constants EXO_START_X and
    EXO_START_Y, which will place the planet in a position similar to ➊ in [Figure
    8-2](ch08.xhtml#ch08fig2). Note that if you increase the exoplanet’s radius significantly,
    you may need to move the starting point farther to the left (negative values are
    acceptable).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义main()函数后，命名一个变量intensity_samples并调用record_transit()函数。*强度*指的是光的强度，用像素的数值表示。record_transit()函数将模拟画面绘制到屏幕上，测量其强度，将测量值附加到名为intensity_samples的列表中，并返回该列表。它需要外行星的起始点（*x*，*y*）坐标。传递起始常量EXO_START_X和EXO_START_Y，它们将把行星放置在类似于[图8-2](ch08.xhtml#ch08fig2)中➊的位置。注意，如果显著增加外行星的半径，可能需要将起始点向左移动（负值是可以接受的）。
- en: Next, name a variable relative_brightness and call the calc_rel_brightness()
    function. As its name suggests, this function calculates *relative* brightness,
    which is the measured intensity divided by the maximum recorded intensity. It
    takes the list of intensity measurements as an argument, converts the measurements
    to relative brightness, and returns the new list.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，命名一个变量relative_brightness并调用calc_rel_brightness()函数。顾名思义，该函数计算*相对*亮度，即测量的强度除以最大记录强度。它接受强度测量列表作为参数，将测量值转换为相对亮度，并返回新的列表。
- en: You’ll use the list of relative brightness values to calculate the radius of
    the exoplanet, in pixels, using the equation from [page 179](ch08.xhtml#page_179).
    You can perform the calculation as part of the print() function. Use the {:.2f}
    format to report the answer to two decimal points.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用相对亮度值的列表，通过[第179页](ch08.xhtml#page_179)的方程计算外行星的半径（以像素为单位）。你可以在print()函数中执行此计算。使用{:.2f}格式将答案保留两位小数。
- en: End the main() function by calling the function to plot the light curve. Pass
    it the relative_brightness list.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用绘制光曲线的函数结束main()函数。传递相对亮度列表。
- en: '**Recording the Transit**'
  id: totrans-50
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**记录穿越事件**'
- en: '[Listing 8-3](ch08.xhtml#ch08list3) defines a function to simulate and record
    the transit event. It draws the star and exoplanet on a black rectangular image
    and then moves the exoplanet. It also calculates and displays the average intensity
    of the image with each move, appends the intensity to a list, and returns the
    list at the end.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表8-3](ch08.xhtml#ch08list3)定义了一个函数，用于模拟并记录穿越事件。它在黑色矩形图像上绘制恒星和外行星，然后移动外行星。它还计算并显示每次移动时图像的平均强度，将强度附加到一个列表中，并在最后返回该列表。'
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 8-3: Drawing the simulation, calculating the image intensity, and returning
    it as a list'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8-3：绘制模拟图像，计算图像强度，并将其作为列表返回
- en: The record_transit() function takes a pair of (*x*, *y*) coordinates as arguments.
    These represent the starting point for the exoplanet or, more specifically, the
    pixel to use as the center of the first circle drawn in the simulation. It should
    not overlap with the star’s circle, which will be centered in the image.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: record_transit()函数接受一对(*x*，*y*)坐标作为参数。这些坐标代表外行星的起始点，或者更具体地说，是用于作为模拟中绘制的第一个圆心的像素。它不应与图像中心的恒星圆重叠。
- en: Next, create an empty list to hold the intensity measurements. Then start a
    for loop that uses the NUM_FRAMES constant to repeat the simulation a certain
    number of times. The simulation should last slightly longer than it takes for
    the exoplanet to exit the face of the star. That way, you get a full light curve
    that includes post-transit measurements.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个空列表来保存强度测量值。然后，启动一个for循环，使用NUM_FRAMES常量重复模拟一定次数。模拟的持续时间应该稍微超过系外行星离开恒星面所需的时间。这样，你就可以获得包含掩星后测量的完整光变曲线。
- en: Drawings and text placed on an image with OpenCV become part of that image.
    Consequently, you need to replace the previous image with each loop by copying
    the original BLACK_IMG to a local variable called temp_img.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用OpenCV在图像上绘制的图形和文本将成为该图像的一部分。因此，你需要通过将原始BLACK_IMG复制到名为temp_img的本地变量中，替换每次循环中的前一个图像。
- en: Now you can draw the star by using the OpenCV circle() method. Pass it the temporary
    image, the (*x*, *y*) coordinates for the center of the circle that correspond
    to the center of the image, the STAR_RADIUS constant, a fill color of white, and
    a line thickness. Using a negative number for thickness fills the circle with
    color.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用OpenCV的circle()方法绘制恒星。传递给它临时图像、对应于图像中心的圆心坐标（*x*，*y*）、STAR_RADIUS常量、白色填充颜色和线条厚度。使用负数作为厚度值可以将圆填充为颜色。
- en: Draw the exoplanet circle next. Use the exo_x and exo_y coordinates as its starting
    point, the EXO_RADIUS constant as its size, and a black fill color ➊.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，绘制系外行星圆圈。使用exo_x和exo_y坐标作为起点，EXO_RADIUS常量作为大小，黑色填充颜色 ➊。
- en: At this point, you should record the intensity of the image. Since the pixels
    already represent intensity, all you need to do is take the mean of the image.
    The number of measurements you take is dependent on the EXO_DX constant. The larger
    this value, the faster the exoplanet will move, and the fewer times you will record
    the mean intensity.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这时，你应该记录图像的强度。由于像素已经代表强度，因此你需要做的就是计算图像的平均值。你所采集的测量次数取决于EXO_DX常量。这个值越大，系外行星移动越快，你记录平均强度的次数就越少。
- en: Display the intensity reading on the image using OpenCV’s putText() method.
    Pass it the temporary image, a text string that includes the measurement, the
    (*x*, *y*) coordinates for the bottom-left corner of the text string, a font,
    a text size, and a color.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 使用OpenCV的putText()方法在图像上显示强度读数。传递给它临时图像、包含测量值的文本字符串、文本字符串的左下角坐标（*x*，*y*）、字体、文本大小和颜色。
- en: Now, name the window Transit and display it using OpenCV’s imshow() method.
    [Figure 8-5](ch08.xhtml#ch08fig5) shows a loop iteration.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，命名窗口为Transit，并使用OpenCV的imshow()方法显示它。[图 8-5](ch08.xhtml#ch08fig5)展示了一个循环迭代过程。
- en: '![Image](../images/fig08_05.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig08_05.jpg)'
- en: 'Figure 8-5: The exoplanet transiting the star'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-5：系外行星掩过恒星
- en: After showing the image, use the OpenCV waitKey() method to update it every
    30 milliseconds. The lower the number passed to waitKey(), the faster the exoplanet
    will move across the star.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 显示图像后，使用OpenCV的waitKey()方法每30毫秒更新一次图像。传递给waitKey()的数字越小，系外行星穿越恒星的速度就越快。
- en: Append the intensity measurement to the intensity_samples list and then advance
    the exoplanet circle by incrementing its exo_x value by the EXO_DX constant ➋.
    Finish the function by returning the list of mean intensity measurements.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 将强度测量值追加到intensity_samples列表中，然后通过将exo_x值增加EXO_DX常量来推进系外行星圆圈 ➋。最后，通过返回平均强度测量值的列表来结束该函数。
- en: '**Calculating Relative Brightness and Plotting the Light Curve**'
  id: totrans-66
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**计算相对亮度并绘制光变曲线**'
- en: '[Listing 8-4](ch08.xhtml#ch08list4) defines functions to calculate the relative
    brightness of each intensity sample and display the light curve graph. It then
    calls the main() function if the program is not being used as a module in another
    program.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 8-4](ch08.xhtml#ch08list4)定义了计算每个强度样本相对亮度并显示光变曲线图的函数。如果该程序不是作为模块在其他程序中使用，还会调用main()函数。'
- en: '[PRE3]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 8-4: Calculating relative brightness, plotting the light curve, and
    calling main()'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-4：计算相对亮度、绘制光变曲线并调用main()
- en: Light curves display the *relative* brightness over time so that an un-obscured
    star has a value of 1.0 and a totally eclipsed star has a value of 0.0\. To convert
    the mean intensity measurements to relative values, define the calc_rel_brightness()
    function, which takes a list of mean intensity measurements as an argument.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 光变曲线显示了随时间变化的*相对*亮度，未被遮挡的恒星的亮度为1.0，而完全被掩盖的恒星亮度为0.0。为了将平均强度测量转换为相对值，定义一个calc_rel_brightness()函数，该函数接受一个平均强度测量值的列表作为参数。
- en: Within the function, start an empty list to hold the converted values and then
    use Python’s built-in max() function to find the maximum value in the intensity_samples
    list. To get relative brightness, loop through the items in this list and divide
    them by the maximum value. Append the result to the rel_brightness list as you
    go. End the function by returning the new list.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数中，首先创建一个空列表来保存转换后的值，然后使用Python的内置max()函数来查找intensity_samples列表中的最大值。为了获得相对亮度，遍历列表中的每个元素，并将其除以最大值。然后将结果添加到rel_brightness列表中。最后，返回新列表，结束函数。
- en: Define a second function to plot the light curve and pass it the rel_brightness
    list ➊. Use the matplotlib plot() method and pass it the list, a line color, a
    line style, a line width, and a label for the plot legend. Add the legend and
    plot title and then show the plot. You should see the chart in [Figure 8-6](ch08.xhtml#ch08fig6).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 定义第二个函数来绘制光变曲线，并将rel_brightness列表传递给它➊。使用matplotlib的plot()方法，并传递列表、线条颜色、线条样式、线宽和图例标签。添加图例和图表标题，然后显示图表。你应该会看到[图
    8-6](ch08.xhtml#ch08fig6)中的图表。
- en: '![Image](../images/fig08_06.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig08_06.jpg)'
- en: 'Figure 8-6: Example light curve plot from transit.py'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-6：来自transit.py的示例光变曲线图
- en: 'The brightness variation on the plot might seem extreme at first glance, but
    if you look closely at the *y*-axis, you’ll see that the exoplanet diminished
    the star’s brightness by only 0.175 percent! To see how this looks on a plot of
    the star’s absolute brightness ([Figure 8-7](ch08.xhtml#ch08fig7)), add the following
    line just before plt.show():'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图表上的亮度变化乍一看可能会显得非常剧烈，但如果仔细观察*y*轴，你会发现外行星仅将恒星的亮度降低了0.175%！为了查看恒星的绝对亮度图（[图 8-7](ch08.xhtml#ch08fig7)）上的效果，可以在plt.show()之前添加以下行：
- en: '[PRE4]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The deflection in the light curve caused by the transit is subtle but detectable.
    Still, you don’t want to go blind squinting at a light curve, so continue to let
    matplotlib automatically fit the *y*-axis as in [Figure 8-6](ch08.xhtml#ch08fig6).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 光变曲线因过境而发生的偏折微妙但可检测。不过，你不希望盯着光变曲线看得眼睛花，所以继续让matplotlib像[图 8-6](ch08.xhtml#ch08fig6)那样自动调整*y*轴。
- en: Finish the program by calling the main() function ➋. In addition to the light
    curve, you should see the estimated radius of the exoplanet in the shell.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用main()函数来完成程序➋。除了光变曲线，你应该在命令行中看到估算的外行星半径。
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: That’s all there is to it. With fewer than 50 lines of Python code, you’ve developed
    a means of discovering exoplanets!
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。不到50行Python代码，你已经开发出了发现外行星的方法！
- en: '![Image](../images/fig08_07.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig08_07.jpg)'
- en: 'Figure 8-7: Light curve from [Figure 8-6](ch08.xhtml#ch08fig6) with rescaled
    y-axis'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-7：从[图 8-6](ch08.xhtml#ch08fig6)中重新缩放y轴的光变曲线
- en: '***Experimenting with Transit Photometry***'
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***实验过境光度测量***'
- en: Now that you have a working simulation, you can use it to model the behavior
    of transits, allowing you to better analyze real-life observations you’ll make
    in the future. One approach would be to run a lot of possible cases and produce
    an “atlas” of expected exoplanet responses. Researchers could use this atlas to
    help them interpret actual light curves.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了一个可运行的模拟，你可以使用它来模拟过境的行为，从而更好地分析将来在实际观察中获得的数据。一种方法是运行大量可能的情况，并生成预期外行星反应的“图谱”。研究人员可以使用这个图谱来帮助解读实际的光变曲线。
- en: For example, what if the plane of an exoplanet’s orbit is tilted with respect
    to Earth so that the exoplanet only partly crosses the star during transit? Would
    researchers be able to detect its position from its light curve signature, or
    would it just look like a smaller exoplanet doing a complete transit?
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果外行星的轨道平面相对于地球倾斜，使得外行星在过境过程中只部分穿过恒星？研究人员能否通过它的光变曲线特征来检测到它的位置，还是它只会像一个较小的外行星进行完整的过境？
- en: If you run the simulation with an exoplanet radius of 7 and let it skim the
    base of the star, you should get a U-shaped curve ([Figure 8-8](ch08.xhtml#ch08fig8)).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用半径为7的外行星并让它掠过恒星的底部运行模拟，你应该会得到一个U形曲线（[图 8-8](ch08.xhtml#ch08fig8)）。
- en: '![Image](../images/fig08_08.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig08_08.jpg)'
- en: 'Figure 8-8: Light curve for an exoplanet with a radius of 7 that only partly
    crosses its star'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-8：一个半遮挡其恒星的外星行星的光变曲线，半径为7
- en: If you run the simulation again with an exoplanet radius of 5 and let the exoplanet
    pass fully over the face of the star, you get the graph in [Figure 8-9](ch08.xhtml#ch08fig9).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你重新运行模拟，设置外星行星的半径为5，并让外星行星完全经过恒星的面前，你将得到[图 8-9](ch08.xhtml#ch08fig9)中的图表。
- en: '![Image](../images/fig08_09.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig08_09.jpg)'
- en: 'Figure 8-9: Light curve for an exoplanet with a radius of 5 that fully crosses
    its star'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-9：一个完全遮挡其恒星的外星行星的光变曲线，半径为5
- en: When an exoplanet skims the side of a star, never fully passing over it, the
    overlapping area changes constantly, generating the U-shaped curve in [Figure
    8-8](ch08.xhtml#ch08fig8). If the entire exoplanet passes over the face of the
    star, the base of the curve is flatter, as in [Figure 8-9](ch08.xhtml#ch08fig9).
    And because you never see the planet’s full disc against the star in a partial
    transit, you have no way to measure its true size. Thus, size estimates should
    be taken with a grain of salt if your light curve lacks a flattish bottom.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当外星行星掠过恒星的一侧，未完全遮挡它时，重叠区域会不断变化，产生[图 8-8](ch08.xhtml#ch08fig8)中的U型曲线。如果整个外星行星完全经过恒星的面前，曲线的底部则会较平坦，如[图
    8-9](ch08.xhtml#ch08fig9)所示。而由于在部分掩星过程中你无法看到行星的完整盘面，你也无法测量其真实大小。因此，如果光变曲线底部没有平坦部分，大小的估计就应当谨慎对待。
- en: If you run a range of exoplanet sizes, you’ll see that the light curve changes
    in predictable ways. As size increases, the curve deepens, with longer ramps on
    either side, because a larger fraction of the star’s brightness is diminished
    ([Figures 8-10](ch08.xhtml#ch08fig10) and [8-11](ch08.xhtml#ch08fig11)).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行一系列不同大小的外星行星，你会看到光变曲线以可预测的方式变化。随着行星大小的增加，曲线会加深，曲线两侧的坡度变长，因为恒星亮度的较大部分被遮挡了（参见[图
    8-10](ch08.xhtml#ch08fig10)和[图 8-11](ch08.xhtml#ch08fig11)）。
- en: '![Image](../images/fig08_10.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig08_10.jpg)'
- en: 'Figure 8-10: Light curve for EXO_RADIUS = 28'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-10：EXO_RADIUS = 28的光变曲线
- en: '![Image](../images/fig08_11.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig08_11.jpg)'
- en: 'Figure 8-11: Light curve for EXO_RADIUS = 145'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-11：EXO_RADIUS = 145的光变曲线
- en: Because exoplanets are circular objects with smooth edges, they should produce
    light curves with smooth ramps that continuously increase or decrease. This is
    important knowledge, as astronomers have recorded decidedly bumpy curves when
    looking for exoplanets. In the “Practice Project” sections at the end of the chapter,
    you’ll use your program to explore oddly shaped light curves that might be explained
    by extraterrestrial engineering!
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 由于外星行星是圆形的、边缘光滑的物体，它们应当产生平滑的光变曲线，曲线的变化应持续增加或减少。这是非常重要的知识，因为天文学家在寻找外星行星时，记录到了显著的起伏曲线。在本章末的“实践项目”部分，你将利用你的程序探索那些形状奇怪的光变曲线，它们可能是外星工程的结果！
- en: '**Project #12: Imaging Exoplanets**'
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**项目 #12：成像外星行星**'
- en: By 2025, three powerful telescopes—two on Earth and one in space—will use infrared
    and visible light to directly image Earth-sized exoplanets. In the best-case scenario,
    the exoplanet will show up as a single saturated pixel with some bleed into the
    surrounding pixels, but that’s enough to tell whether the planet rotates, has
    continents and seas, experiences weather and seasons, and could support life as
    we know it!
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 到2025年，三台强大的望远镜——两台在地球上，一台在太空中——将使用红外线和可见光直接成像地球大小的外星行星。在最佳情况下，外星行星将以一个饱和的像素显示出来，周围的像素会有所溢出，但这足以判断行星是否自转，是否有大陆和海洋，是否有气候和季节变化，以及是否能够支持我们所知道的生命！
- en: In this project, you’ll simulate the process of analyzing an image taken from
    those telescopes. You’ll use Earth as a stand-in for a distant exoplanet. This
    way, you can easily relate known features, such as continents and oceans, to what
    you see in a single pixel. You’ll focus on the color composition and intensity
    of reflected light and make inferences about the exoplanet’s atmosphere, surface
    features, and rotation.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将模拟分析来自这些望远镜拍摄的图像的过程。你将以地球作为一个遥远外星行星的代替，这样你可以轻松地将已知的特征（如大陆和海洋）与单个像素中看到的内容联系起来。你将关注反射光的颜色成分和强度，并推测外星行星的大气层、地表特征以及自转情况。
- en: THE OBJECTIVE
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 目标
- en: Write a Python program that pixelates images of Earth and plots the intensity
    of the red, green, and blue color channels.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个Python程序，对地球的图像进行像素化处理，并绘制红色、绿色和蓝色通道的强度。
- en: '***The Strategy***'
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***策略***'
- en: 'To demonstrate that you can capture different surface features and cloud formations
    with a single saturated pixel, you need only two images: one of the western hemisphere
    and one of the eastern. Conveniently, NASA has already photographed both hemispheres
    of Earth from space ([Figure 8-12](ch08.xhtml#ch08fig12)).'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示你可以通过单一的饱和像素捕获不同的表面特征和云层，你只需要两张图像：一张是西半球的图像，另一张是东半球的图像。方便的是，NASA 已经从太空拍摄了地球的东西半球图像（[图
    8-12](ch08.xhtml#ch08fig12)）。
- en: '![Image](../images/fig08_12.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig08_12.jpg)'
- en: 'Figure 8-12: Images of the western and eastern hemispheres'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-12：东西半球的图像
- en: The size of these images is 474×474 pixels, a resolution far too high for a
    future exoplanet image, where the exoplanet is expected to occupy 9 pixels, with
    only the center pixel fully covered by the planet ([Figure 8-13](ch08.xhtml#ch08fig13)).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这些图像的大小为 474×474 像素，分辨率对于未来的系外行星图像来说过高，因为系外行星预计只会占据 9 个像素，其中只有中心像素完全被行星覆盖（[图
    8-13](ch08.xhtml#ch08fig13)）。
- en: '![Image](../images/fig08_13.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig08_13.jpg)'
- en: 'Figure 8-13: The earth_west.png and earth_east.png images overlaid with a 9-pixel
    grid'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-13：覆盖有 9 像素网格的 earth_west.png 和 earth_east.png 图像
- en: You’ll need to degrade the Earth images by mapping them into a 3×3 array. Since
    OpenCV uses NumPy, this will be easy to do. To detect changes in the exoplanet’s
    surface, you’ll need to extract the dominant colors (blue, green, and red). OpenCV
    will let you average these color channels. Then you can display the results with
    matplotlib.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要通过将地球图像映射到 3×3 数组来降解图像。由于 OpenCV 使用 NumPy，这将非常容易实现。为了检测系外行星表面的变化，你需要提取主要的颜色（蓝色、绿色和红色）。OpenCV
    允许你对这些颜色通道进行平均。然后，你可以使用 matplotlib 显示结果。
- en: '***The Pixelator Code***'
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***像素化器代码***'
- en: The *pixelator.py* program loads the two images of Earth, resizes them to 3×3
    pixels, and then resizes them again to 300×300 pixels. These final images are
    just for visualization; they have the same color information as the 3×3 images.
    The program then averages the color channels in both resized images and plots
    the results as pie charts that you can compare. You can download the code and
    two images (*earth_west.png* and *earth_east.png*) from the book’s website. Keep
    them in the same folder and don’t rename the images.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*pixelator.py* 程序加载这两张地球图像，将它们调整为 3×3 像素，然后再将它们调整为 300×300 像素。这些最终图像仅用于可视化，它们拥有与
    3×3 图像相同的颜色信息。程序随后对两张调整过的图像的颜色通道进行平均，并将结果以饼图形式绘制出来，你可以进行比较。你可以从本书的网站下载代码和两张图像（*earth_west.png*
    和 *earth_east.png*）。将它们保存在同一文件夹中，并且不要重命名图像。'
- en: '**Importing Modules and Downscaling Images**'
  id: totrans-114
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**导入模块和降采样图像**'
- en: '[Listing 8-5](ch08.xhtml#ch08list5) imports modules for plotting and image
    processing and then loads and degrades two images of Earth. It first reduces each
    to 9 pixels in a 3×3 array. It then enlarges the decimated images to 300×300 pixels
    so they are large enough to see and posts them to the screen.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 8-5](ch08.xhtml#ch08list5) 导入用于绘图和图像处理的模块，然后加载并降解两张地球图像。它首先将每张图像缩小为 9 像素的
    3×3 数组。接着，它将降采样后的图像放大为 300×300 像素，以便足够大可以查看，并将它们显示在屏幕上。'
- en: '[PRE6]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 8-5: Importing modules and loading, degrading, and showing images'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 8-5：导入模块并加载、降解和显示图像
- en: Import NumPy and OpenCV to work with the images and use matplotlib to plot their
    color components as pie charts. Then start a list of filenames containing the
    two images of Earth.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 NumPy 和 OpenCV 来处理图像，并使用 matplotlib 将它们的颜色组件绘制为饼图。然后，开始列出包含两张地球图像的文件名。
- en: Now start looping through the files in the list and use OpenCV to load them
    as NumPy arrays. Recall that OpenCV loads color images by default, so you don’t
    need to add an argument for this.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在开始循环遍历列表中的文件，使用 OpenCV 将它们加载为 NumPy 数组。回想一下，OpenCV 默认加载彩色图像，因此你不需要为此添加任何参数。
- en: Your goal is to reduce the image of Earth into a single saturated pixel surrounded
    by partially saturated pixels. To degrade the images from their original 474×474
    size to 3×3, use OpenCV’s resize() method. First, name the new image *pixelated*
    and pass the method the current image, the new width and height in pixels, and
    an interpolation method. *Interpolation* occurs when you resize an image and use
    known data to estimate values at unknown points. The OpenCV documentation recommends
    the INTER_AREA interpolation method for shrinking images (see the geometric image
    transformations at *[https://docs.opencv.org/4.3.0/da/d54/group__imgproc__transform.html](https://docs.opencv.org/4.3.0/da/d54/group__imgproc__transform.html)*).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你的目标是将地球图像缩小为一个单一的饱和像素，周围是部分饱和的像素。要将图像从原始的474×474大小降到3×3，使用OpenCV的resize()方法。首先，将新图像命名为*pixelated*，并传递给方法当前图像、新的宽度和高度（像素单位）以及插值方法。*插值*发生在调整图像大小时，使用已知数据来估算未知点的值。OpenCV文档建议在缩小图像时使用INTER_AREA插值方法（参见几何图像转换：*[https://docs.opencv.org/4.3.0/da/d54/group__imgproc__transform.html](https://docs.opencv.org/4.3.0/da/d54/group__imgproc__transform.html)*）。
- en: At this point, you have a tiny image that’s too small to visualize, so resize
    it again to 300×300 so you can check the results. Use either INTER_NEAREST or
    INTER_AREA as the interpolation method, as these will preserve the pixel boundaries.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你有一个太小的图像，无法直观查看，因此将其重新调整为300×300，以便检查结果。使用INTER_NEAREST或INTER_AREA作为插值方法，这些方法将保留像素边界。
- en: Show the image ([Figure 8-14](ch08.xhtml#ch08fig14)) and delay the program for
    two seconds using waitKey().
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 显示图像 ([图 8-14](ch08.xhtml#ch08fig14))，并使用waitKey()延迟程序两秒。
- en: '![Image](../images/fig08_14.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig08_14.jpg)'
- en: 'Figure 8-14: Grayscale view of the pixelated color images'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-14：像素化颜色图像的灰度视图
- en: Note that you can’t restore the images to their original state by resizing them
    to 474×474\. Once you average the pixel values down to a 3×3 matrix, all the detailed
    information is lost forever.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你不能通过将图像调整回474×474来恢复其原始状态。一旦将像素值平均至3×3矩阵，所有细节信息就永远丢失了。
- en: '**Averaging the Color Channels and Making the Pie Charts**'
  id: totrans-126
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**平均颜色通道并制作饼图**'
- en: Still in the for loop, [Listing 8-6](ch08.xhtml#ch08list6) makes and displays
    pie charts of the blue, green, and red color components of each pixelated image.
    You can compare these to make inferences about the planet’s weather, landmasses,
    rotation, and so on.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然在for循环中，[清单 8-6](ch08.xhtml#ch08list6)制作并显示每个像素化图像的蓝色、绿色和红色分量的饼图。你可以将这些图表进行比较，从中推测行星的天气、陆地、旋转等信息。
- en: '[PRE7]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 8-6: Splitting out and averaging color channels and making a pie chart
    of colors'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 8-6：拆分和平均颜色通道并制作颜色的饼图
- en: 'Use OpenCV’s split() method to break out the blue, green, and red color channels
    in the pixelated image and unpack the results into b, g, and r variables. These
    are arrays, and if you call print(b), you should see this output:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用OpenCV的split()方法分离像素化图像中的蓝色、绿色和红色颜色通道，并将结果解包到b、g、r变量中。这些是数组，如果你调用print(b)，你应该会看到如下输出：
- en: '[PRE8]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Each number represents a pixel—specifically, the pixel’s blue value—in the 3×3
    pixelated image. To average the arrays, first make an empty list to hold the averages
    and then loop through the arrays and call the NumPy average method, appending
    the results to the list.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 每个数字代表一个像素——具体来说，是该像素的蓝色值——在3×3像素化图像中。要计算数组的平均值，首先创建一个空列表来存储平均值，然后遍历数组，调用NumPy的平均方法，并将结果附加到列表中。
- en: Now you’re ready to make pie charts of the color averages in each pixelated
    image. Start by assigning color names to a variable named labels, which you’ll
    use to annotate the pie wedges. Next, specify the colors you want to use in the
    pie chart. These will override the matplotlib default choices. To make the chart,
    use the fig, ax naming convention for figure and axis, call the subplots() method,
    and pass it a figure size in inches.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经准备好制作每个像素化图像的颜色平均值饼图了。首先，将颜色名称分配给一个名为labels的变量，用于标注饼图的扇区。接着，指定你希望在饼图中使用的颜色，这些颜色将覆盖matplotlib的默认选择。要制作图表，使用fig和ax命名约定来代表图形和坐标轴，调用subplots()方法，并传入图形的尺寸（单位：英寸）。
- en: Because the colors will vary only slightly between images, you’ll want to post
    the percentage of each color in its pie wedge so you can easily see whether there’s
    a difference between them. Unfortunately, the matplotlib default is to use black
    text that can be hard to see against a dark background. To fix this, call the
    ax.pie() method for making pie charts and use its autotexts list ➊. The method
    returns three lists, one concerning the pie wedges, one concerning the labels,
    and one for numeric labels, called *autotexts*. You need only the last one, so
    treat the first two as unused variables by assigning them to an underscore symbol.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 由于图像之间的颜色差异只有很小的变化，你希望在每个颜色的饼图楔形中显示该颜色的百分比，这样你可以轻松查看它们之间是否存在差异。不幸的是，matplotlib的默认设置是使用黑色文本，这在深色背景下可能难以看清。为了解决这个问题，调用ax.pie()方法生成饼图，并使用它的autotexts列表
    ➊。该方法返回三个列表，一个与饼图楔形相关，一个与标签相关，一个与数字标签相关，称为*autotexts*。你只需要最后一个列表，因此将前两个列表当作未使用的变量，赋值为下划线符号。
- en: Pass ax.pie() the list of color averages and the list of labels and set its
    autopct parameter to show numbers to one decimal place. If this parameter is set
    to None, the autotexts list will not be returned. Finish the arguments by passing
    the list of colors to use for the pie wedges.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 将色彩平均值列表和标签列表传递给ax.pie()，并设置其autopct参数以显示小数点后一位的数字。如果该参数设置为None，则不会返回autotexts列表。最后，传递用于饼图楔形的颜色列表，完成参数设置。
- en: 'The autotexts list for the first image looks like this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 第一幅图像的autotexts列表如下：
- en: '[PRE9]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Each Text object has (*x*, *y*) coordinates and a percent value as a text string.
    These will still post in black, so you need to loop through the objects and change
    the color to white using their set_color() method. Now all you need to do is set
    the chart title to the filename and show the plots ([Figure 8-15](ch08.xhtml#ch08fig15)).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Text对象都有(*x*, *y*)坐标和百分比值作为文本字符串。由于这些仍然会以黑色显示，你需要遍历这些对象并使用它们的set_color()方法将颜色更改为白色。现在，你只需要将图表标题设置为文件名并显示图表（[图
    8-15](ch08.xhtml#ch08fig15)）。
- en: '![Image](../images/fig08_15.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig08_15.jpg)'
- en: 'Figure 8-15: The pie charts produced by pixelator.py'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-15：pixelator.py生成的饼图
- en: Although the pie charts are similar, the differences are meaningful. If you
    compare the original color images, you’ll see that the *earth_west.png* photograph
    includes more ocean and should produce a larger blue wedge.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管饼图相似，但其差异是有意义的。如果你比较原始的彩色图像，你会看到*earth_west.png*照片包含更多的海洋，因此应该产生更大的蓝色楔形。
- en: '**Plotting a Single Pixel**'
  id: totrans-142
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**绘制单个像素**'
- en: The charts in [Figure 8-15](ch08.xhtml#ch08fig15) are for the whole image, which
    includes a sampling of black space. For an uncontaminated sample, you could use
    the single saturated pixel at the center of each image, as shown in [Listing 8-7](ch08.xhtml#ch08list7).
    This code represents an edited copy of *pixelator.py*, with the lines that change
    annotated. You can find a digital copy in the *Chapter_8* folder as *pixelator_saturated_only.py*.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8-15](ch08.xhtml#ch08fig15)中的图表是针对整个图像的，包括对黑色区域的采样。为了获取一个未被污染的样本，你可以使用每个图像中心的单个饱和像素，如[清单
    8-7](ch08.xhtml#ch08list7)所示。此代码代表了编辑后的*pixelator.py*副本，标注了更改的行。你可以在*Chapter_8*文件夹中找到数字副本，名为*pixelator_saturated_only.py*。'
- en: '[PRE10]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 8-7: Plotting pie charts for the colors in the center pixel of the
    pixelated image'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 8-7：绘制像素化图像中心像素的颜色饼图
- en: The four lines of code in [Listing 8-6](ch08.xhtml#ch08list6) that split the
    image and averaged the color channels can be replaced with one line ➊. The pixelated
    variable is a NumPy array, and [1, 1] represents row 1, column 1 in the array.
    Remember that Python starts counting at 0, so these values correspond to the center
    of a 3×3 array. If you print the color_values variable, you’ll see another array.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 8-6](ch08.xhtml#ch08list6)中的四行代码，用于分割图像并计算颜色通道的平均值，可以替换为一行代码 ➊。pixelated变量是一个NumPy数组，[1,
    1]表示数组中的第1行第1列。记住，Python的计数从0开始，因此这些值对应于一个3×3数组的中心。如果你打印color_values变量，你将看到另一个数组。'
- en: '[PRE11]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: These are the blue, green, and red color channel values for the center pixel,
    and you can pass them directly to matplotlib ➋. For clarity, change the plot title
    so it indicates that you’re analyzing the center pixel only ➌. [Figure 8-16](ch08.xhtml#ch08fig16)
    shows the resulting plots.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是中心像素的蓝色、绿色和红色通道值，你可以直接将它们传递给matplotlib ➋。为了清晰起见，更改图表标题，使其表明你仅分析中心像素 ➌。[图
    8-16](ch08.xhtml#ch08fig16)显示了生成的图表。
- en: '![Image](../images/fig08_16.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig08_16.jpg)'
- en: 'Figure 8-16: The single-pixel pie charts produced by pixelator_saturated_only.py'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-16：pixelator_saturated_only.py生成的单像素饼图
- en: The color differences between the western and eastern hemispheres in [Figures
    8-15](ch08.xhtml#ch08fig15) and [8-16](ch08.xhtml#ch08fig16) are subtle, but you
    know they’re real because you *forward modeled* the response. That is, you produced
    the result from actual observations, so you know the result is meaningful, repeatable,
    and unique.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8-15](ch08.xhtml#ch08fig15) 和 [8-16](ch08.xhtml#ch08fig16) 中西半球的颜色差异很微妙，但你知道它们是真实的，因为你*前向建模*了反应。也就是说，你通过实际观测得出了结果，所以你知道这个结果是有意义的、可重复的，并且是独一无二的。'
- en: In a real exoplanet survey, you’d want to take as many images as possible. If
    similar intensity and color patterns persist over time, then you can rule out
    stochastic effects such as weather. If the color patterns change predictably over
    long time periods, you may be seeing the effect of seasons, such as the presence
    of white polar caps in the winter and the spread of green vegetation in the spring
    and summer.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际的系外行星调查中，你会希望拍摄尽可能多的图像。如果相似的强度和颜色模式在时间上持续存在，那么你可以排除诸如天气等随机效应。如果颜色模式在较长时间内发生可预测的变化，你可能在观察季节效应，比如冬季出现白色极地冰盖，春夏季节绿植扩展的现象。
- en: If measurements repeat periodically over relatively short time spans, you can
    infer that the planet is rotating on its axis. In the “Practice Project” sections
    at the end of the chapter, you’ll get a chance to calculate the length of an exoplanet’s
    day.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果测量周期性地重复，并且时间跨度相对较短，你可以推测行星正在自转。在本章末尾的“实践项目”部分，你将有机会计算系外行星的一天长度。
- en: '**Summary**'
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter, you used OpenCV, NumPy, and matplotlib to create images and
    measure their properties. You also resized images to different resolutions and
    plotted image intensity and color channel information. With short and simple Python
    programs, you simulated important methods that astronomers use to discover and
    study distant exoplanets.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你使用了 OpenCV、NumPy 和 matplotlib 创建图像并测量它们的属性。你还将图像调整为不同的分辨率，并绘制了图像强度和颜色通道信息。通过简短而简单的
    Python 程序，你模拟了天文学家用来发现和研究遥远系外行星的重要方法。
- en: '**Further Reading**'
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**进一步阅读**'
- en: '*How to Search for Exoplanets*, by the Planetary Society (*[https://www.planetary.org/](https://www.planetary.org/)*),
    is a good overview of the techniques used to search for exoplanets, including
    the strengths and weaknesses of each method.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '*如何搜索系外行星*，由行星学会（Planetary Society）出版，(*[https://www.planetary.org/](https://www.planetary.org/)*)，这是一本关于搜索系外行星技术的好概述，涵盖了每种方法的优缺点。'
- en: “Transit Light Curve Tutorial,” by Andrew Vanderburg, explains the basics of
    the transit photometry method and provides links to Kepler Space Observatory transit
    data. You can find it at *[https://www.cfa.harvard.edu/~avanderb/tutorial/tutorial.html](https://www.cfa.harvard.edu/~avanderb/tutorial/tutorial.html)*.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: “过境光变曲线教程”，由安德鲁·范德堡（Andrew Vanderburg）编写，解释了过境光度法的基础，并提供了开普勒太空望远镜的过境数据链接。你可以在
    *[https://www.cfa.harvard.edu/~avanderb/tutorial/tutorial.html](https://www.cfa.harvard.edu/~avanderb/tutorial/tutorial.html)*
    上找到它。
- en: “NASA Wants to Photograph the Surface of an Exoplanet” (Wired, 2020), by Daniel
    Oberhaus, describes the effort to turn the sun into a giant camera lens for studying
    exoplanets.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: “NASA 想要拍摄系外行星表面”（*Wired*，2020），由丹尼尔·奥伯豪斯（Daniel Oberhaus）编写，描述了将太阳变成一个巨大的相机镜头来研究系外行星的努力。
- en: '“Dyson Spheres: How Advanced Alien Civilizations Would Conquer the Galaxy”
    ([Space.com](http://Space.com), 2014), by Karl Tate, is an infographic on how
    an advanced civilization could capture the power of a star using vast arrays of
    solar panels.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: “戴森球：高级外星文明如何征服银河系”（*Space.com*，2014），由卡尔·塔特（Karl Tate）编写，是一张信息图，展示了一个高级文明如何利用巨大的太阳能面板阵列捕获恒星的能量。
- en: '*Ringworld* (Ballantine Books, 1970), by Larry Niven, is one of the classic
    novels of science fiction. It tells the story of a mission to a massive abandoned
    alien construct—the Ringworld—that encircles an alien star.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*环世界*（Ringworld），由拉里·尼文（Larry Niven）编写，出版于1970年，是科幻小说的经典之作。故事讲述了一个任务，目的地是一个巨大的废弃外星建筑——环世界，它环绕着一颗外星星球。'
- en: '**Practice Project: Detecting Alien Megastructures**'
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**实践项目：探测外星巨型结构**'
- en: In 2015, citizen scientists working on data from the Kepler space telescope
    noticed something odd about Tabby’s Star, located in the constellation Cygnus.
    The star’s light curve, recorded in 2013, exhibited irregular changes in brightness
    that were far too large to be caused by a planet ([Figure 8-17](ch08.xhtml#ch08fig17)).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 2015年，正在处理开普勒太空望远镜数据的业余天文学家注意到天鹅座中的塔比星（Tabby’s Star）出现了异常现象。这颗星星的光变曲线记录于2013年，显示出亮度变化不规则，这种变化远远大于行星所能引起的变化（[图
    8-17](ch08.xhtml#ch08fig17)）。
- en: '![Image](../images/fig08_17.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig08_17.jpg)'
- en: 'Figure 8-17: Light curve for Tabby’s Star, measured by the Kepler Space Observatory'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-17：由开普勒太空天文台测量的Tabby星的光变曲线
- en: Besides the dramatic drop in brightness, the light curve was asymmetrical and
    included weird bumps that aren’t seen in typical planetary transits. Proposed
    explanations posited that the light curve was caused by the consumption of a planet
    by the star, the transit of a cloud of disintegrating comets, a large ringed planet
    trailed by swarms of asteroids, or an *alien megastructure*.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 除了亮度的剧烈下降外，光变曲线还表现出不对称性，并且包含一些奇怪的凸起，这在典型的行星凌日中并未见过。提出的解释认为，这个光变曲线可能是由于星体吞噬行星、由解体彗星云凌日、一个被小行星群包围的大型环状行星，或者是*外星巨型结构*所致。
- en: Scientists speculated that an artificial structure of this size was most likely
    an attempt by an alien civilization to collect energy from its sun. Both science
    literature and science fiction describe these staggeringly large solar panel projects.
    Examples include Dyson swarms, Dyson spheres, ringworlds, and Pokrovsky shells
    ([Figure 8-18](ch08.xhtml#ch08fig18)).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 科学家推测，这样大小的人造结构很可能是外星文明试图从其太阳收集能量的尝试。科学文献和科幻小说中都描述了这些惊人的大型太阳能电池板项目。例如包括戴森群、戴森球、环世界和波克罗夫斯基壳（[图
    8-18](ch08.xhtml#ch08fig18)）。
- en: '![Image](../images/fig08_18.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/fig08_18.jpg)'
- en: 'Figure 8-18: Pokrovsky shell system of rings around a star designed to intercept
    the star’s radiation'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-18：围绕恒星的波克罗夫斯基壳系统，旨在拦截恒星的辐射
- en: In this practice project, use the *transit.py* program to approximate the shape
    and depth of the Tabby’s Star light curve. Replace the circular exoplanet used
    in the program with other simple geometric shapes. You don’t need to match the
    curve exactly; just capture key features such as the asymmetry, the “bump” seen
    around February 28, and the large drop in brightness.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实践项目中，使用*transit.py*程序来逼近Tabby星光变曲线的形状和深度。用其他简单的几何形状替换程序中使用的圆形外星行星。你不需要完全匹配曲线，只需捕捉到关键特征，如不对称性、2月28日左右看到的“凸起”，以及亮度的大幅下降。
- en: You can find my attempt, *practice_tabbys_star.py*, in the *Chapter_8* folder,
    downloadable from the book’s website at *[https://nostarch.com/real-world-python/](https://nostarch.com/real-world-python/),*
    and in the appendix. It produces the light curve shown in [Figure 8-19](ch08.xhtml#ch08fig19).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在*Chapter_8*文件夹中找到我尝试编写的程序*practice_tabbys_star.py*，该文件可以从本书网站下载，网址为*[https://nostarch.com/real-world-python/](https://nostarch.com/real-world-python/)*，并且可以在附录中找到。它会生成[图
    8-19](ch08.xhtml#ch08fig19)所示的光变曲线。
- en: '![Image](../images/fig08_19.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/fig08_19.jpg)'
- en: 'Figure 8-19: Light curve produced by practice_tabbys_star.py'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-19：由practice_tabbys_star.py产生的光变曲线
- en: We now know that whatever is orbiting Tabby’s Star allows some wavelengths of
    light to pass, so it can’t be a solid object. Based on this behavior and the wavelengths
    it absorbed, scientists believe dust is responsible for the weird shape of the
    star’s light curve. Other stars, however, like HD 139139 in the constellation
    Libra, have bizarre light curves that remain unexplained at the time of this writing.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道，无论是什么环绕Tabby星，都会允许某些波长的光通过，所以它不可能是一个实心物体。基于这种行为和它吸收的波长，科学家们认为尘埃是导致这颗星光变曲线形状怪异的原因。然而，像天秤座中的HD
    139139等其他恒星，至今仍然没有解释它们奇异的光变曲线。
- en: '**Practice Project: Detecting Asteroid Transits**'
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**实践项目：检测小行星凌日**'
- en: 'Asteroid fields may be responsible for some bumpy and asymmetrical light curves.
    These belts of debris often originate from planetary collisions or the creation
    of a solar system, like the Trojan asteroids in Jupiter’s orbit ([Figure 8-20](ch08.xhtml#ch08fig20)).
    You can find an interesting animation of the Trojan asteroids on the web page
    “Lucy: The First Mission to the Trojan Asteroids” at *[https://www.nasa.gov/](https://www.nasa.gov/)*.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 小行星带可能是一些曲折和不对称光变曲线的罪魁祸首。这些碎片带通常来自行星碰撞或太阳系的形成，就像木星轨道中的特洛伊小行星（[图 8-20](ch08.xhtml#ch08fig20)）。你可以在网页“Lucy：首次任务探索特洛伊小行星”中找到一段有趣的特洛伊小行星动画，网址为*[https://www.nasa.gov/](https://www.nasa.gov/)*。
- en: '![Image](../images/fig08_20.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/fig08_20.jpg)'
- en: 'Figure 8-20: More than one million Trojan asteroids share Jupiter’s orbit.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-20：超过一百万颗特洛伊小行星共享木星的轨道。
- en: Modify the *transit.py* program so that it randomly creates asteroids with radii
    between 1 and 3, weighted heavily toward 1\. Allow the user to input the number
    of asteroids. Don’t bother calculating the exoplanet radius, since the calculation
    assumes you’re dealing with a single spherical object, which you’re not. Experiment
    with the number of asteroids, the size of the asteroids, and the spread (the *x*-range
    and *y*-range in which the asteroids exist) to see the impact on the light curve.
    [Figure 8-21](ch08.xhtml#ch08fig21) shows one such example.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 修改 *transit.py* 程序，使其随机生成半径在 1 到 3 之间的小行星，且小行星的生成概率偏向于 1。允许用户输入小行星的数量。无需计算外行星半径，因为该计算假设你处理的是单个球形物体，而你不是。试验小行星的数量、大小和分布范围（小行星存在的
    *x*-范围和 *y*-范围），观察其对光变曲线的影响。[图 8-21](ch08.xhtml#ch08fig21) 展示了一个这样的例子。
- en: '![Image](../images/fig08_21.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig08_21.jpg)'
- en: 'Figure 8-21: Irregular, asymmetrical light curve produced by a randomly generated
    asteroid field'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-21：由随机生成的 asteroids（小行星）场产生的不规则、非对称光变曲线
- en: You can find a solution, *practice_asteroids.py*, in the appendix and on the
    book’s web page. This program uses object-oriented programming (OOP) to simplify
    the management of multiple asteroids.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在附录和本书网站上找到解决方案 *practice_asteroids.py*。该程序使用面向对象编程（OOP）来简化多个小行星的管理。
- en: '**Practice Project: Incorporating Limb Darkening**'
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**实践项目：加入光球暗化**'
- en: The *photosphere* is the luminous outer layer of a star that radiates light
    and heat. Because the temperature of the photosphere falls as the distance from
    the star’s center increases, the edges of a star’s disk are cooler and therefore
    appear dimmer than the center of the star ([Figure 8-22](ch08.xhtml#ch08fig22)).
    This effect is known as *limb darkening*.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '*光球* 是恒星的发光外层，辐射光和热。由于光球的温度随着离恒星中心的距离增加而降低，恒星盘的边缘比中心更冷，因此看起来比中心更暗（[图 8-22](ch08.xhtml#ch08fig22)）。这一现象被称为
    *光球暗化*。'
- en: '![Image](../images/fig08_22.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig08_22.jpg)'
- en: 'Figure 8-22: Limb darkening and sunspots on the sun'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-22：太阳的光球暗化和太阳黑子
- en: Rewrite the *transit.py* program so that it addresses limb darkening. Rather
    than draw the star, use the image *limb_darkening.png* in the *Chapter_8* folder,
    downloadable from the book’s website.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 重写 *transit.py* 程序，使其能够处理光球暗化。不要再绘制恒星，而是使用 *Chapter_8* 文件夹中的图片 *limb_darkening.png*，该文件可以从本书网站下载。
- en: Limb darkening will affect the light curves produced by planetary transits.
    Compared to the theoretical curves you produced in Project 11, they will appear
    less boxy, with rounder, softer edges and a curved bottom ([Figure 8-23](ch08.xhtml#ch08fig23)).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 光球暗化会影响行星过境产生的光变曲线。与项目 11 中你产生的理论曲线相比，这些曲线将显得不那么方形，边缘更加圆润柔和，底部呈弯曲状（[图 8-23](ch08.xhtml#ch08fig23)）。
- en: '![Image](../images/fig08_23.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig08_23.jpg)'
- en: 'Figure 8-23: The effect of limb darkening on a light curve'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-23：光球暗化对光变曲线的影响
- en: Use your modified program to revisit “Experimenting with Transit Photometry”
    on [page 186](ch08.xhtml#page_186), where you analyzed the light curves produced
    by partial transits. You should see that, compared to partial transits, full transits
    still produce broader dips with flattish bottoms ([Figure 8-24](ch08.xhtml#ch08fig24)).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你修改后的程序重新访问“实验：过境光度法”中的[第 186 页](ch08.xhtml#page_186)，在那里你分析了部分过境产生的光变曲线。你应该会看到，相比部分过境，完全过境仍然产生较宽的波谷，并且波谷底部较为平坦（[图
    8-24](ch08.xhtml#ch08fig24)）。
- en: '![Image](../images/fig08_24.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig08_24.jpg)'
- en: 'Figure 8-24: Limb-darkened light curves for full and partial transits (R =
    exoplanet radius)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-24：完全与部分过境的光变曲线（R = 外行星半径）
- en: If the full transit of a small planet occurs near the edge of a star, limb darkening
    may make it difficult to distinguish from the partial transit of a larger planet.
    You can see this in [Figure 8-25](ch08.xhtml#ch08fig25), where arrows denote the
    location of the planets.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个小行星的完全过境发生在恒星的边缘，光球暗化可能使其与一个大行星的部分过境难以区分。你可以在[图 8-25](ch08.xhtml#ch08fig25)中看到这一点，箭头表示行星的位置。
- en: '![Image](../images/fig08_25.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig08_25.jpg)'
- en: 'Figure 8-25: Partial transit of planet with a radius of 8 pixels versus full
    transit of planet with a radius of 5 pixels'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-25：半径为 8 像素的行星的部分过境与半径为 5 像素的行星的完全过境
- en: Astronomers have many tools for extracting information entangled in a light
    curve. By recording multiple transit events, they can determine an exoplanet’s
    orbital parameters, such as the distance between the planet and the star. They
    can use subtle inflections in the light curve to tease out the amount of time
    the planet is fully over the surface of the star. They can estimate the theoretical
    amount of limb darkening, and they can use modeling, as you’re doing here, to
    bring it all together and test their assumptions against actual observations.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 天文学家有许多工具可以提取光变曲线中的信息。通过记录多个过境事件，他们可以确定系外行星的轨道参数，比如行星与恒星之间的距离。他们可以利用光变曲线中的细微变化来推算行星完全遮盖恒星表面的时间。他们还可以估计理论上的边缘变暗程度，并可以使用建模方法，正如你在这里所做的那样，将所有信息结合起来，并用实际观测数据验证他们的假设。
- en: You can find a solution, *practice_limb_darkening.py*, in the appendix and in
    the *Chapter_8* folder downloadable from the book’s website.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在附录和 *Chapter_8* 文件夹中找到一个解决方案，*practice_limb_darkening.py*，并从书籍网站下载。
- en: '**Practice Project: Detecting Starspots**'
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**实践项目：检测恒星斑点**'
- en: Sunspots—called *starspots* on alien suns—are regions of reduced surface temperature
    caused by variations in the star’s magnetic field. Starspots can darken the face
    of stars and do interesting things to light curves. In [Figure 8-26](ch08.xhtml#ch08fig26),
    an exoplanet passes over a starspot, causing a “bump” in the light curve.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 太阳黑子——在外星太阳上被称为 *星斑*——是由恒星磁场变化引起的表面温度降低区域。星斑会使恒星的表面变暗，并对光变曲线产生有趣的影响。在 [图 8-26](ch08.xhtml#ch08fig26)
    中，一颗系外行星经过星斑，造成了光变曲线中的一个“突起”。
- en: '![Image](../images/fig08_26.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/fig08_26.jpg)'
- en: 'Figure 8-26: An exoplanet (arrow, left image) passing over a starspot produces
    a bump in the light curve.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-26：一颗系外行星（箭头，左图）经过恒星斑点时，会在光变曲线中产生一个“突起”。
- en: To experiment with starspots, use the *practice_limb_darkening.py* code from
    the previous practice project and edit it so that an exoplanet roughly the same
    size as the starspots passes over them during its transit. To reproduce [Figure
    8-26](ch08.xhtml#ch08fig26), use EXO_RADIUS = 4, EXO_DX = 3, and EXO_START_Y =
    205.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实验星斑，使用前一个实践项目中的 *practice_limb_darkening.py* 代码，并编辑它，使一颗大致与星斑大小相同的系外行星在横越过程中经过这些星斑。为了重现
    [图 8-26](ch08.xhtml#ch08fig26)，设置 EXO_RADIUS = 4，EXO_DX = 3，EXO_START_Y = 205。
- en: '**Practice Project: Detecting an Alien Armada**'
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**实践项目：检测外星舰队**'
- en: The hyper-evolved beavers of exoplanet BR549 have been as busy as, well, beavers.
    They’ve amassed an armada of colossal colony ships that are now loaded and ready
    to leave orbit. Thanks to some exoplanet detection of their own, they’ve decided
    to abandon their chewed-out homeworld for the lush green forests of Earth!
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 系外行星 BR549 上的超级进化的海狸们忙得不可开交，就像海狸一样。它们已经集结了一支庞大的殖民舰队，这些舰船已经装载完毕，准备离开轨道。由于自己也能进行系外行星探测，它们决定抛弃已经啃噬殆尽的家园，前往地球那片郁郁葱葱的绿树成荫的森林！
- en: Write a Python program that simulates multiple spaceships transiting a star.
    Give the ships different sizes, shapes, and speeds (such as those in [Figure 8-27](ch08.xhtml#ch08fig27)).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个 Python 程序，模拟多艘太空飞船横越一颗恒星。给飞船设置不同的大小、形状和速度（如图 [8-27](ch08.xhtml#ch08fig27)
    所示）。
- en: '![Image](../images/fig08_27.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/fig08_27.jpg)'
- en: 'Figure 8-27: An armada of alien colony ships preparing to invade Earth'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-27：一支外星殖民舰队准备入侵地球
- en: Compare the resultant light curves to those from Tabby’s Star ([Figure 8-17](ch08.xhtml#ch08fig17))
    and the asteroids practice project. Do the ships produce distinctive curves, or
    can you get similar patterns from asteroid swarms, starspots, or other natural
    phenomena?
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 将得到的光变曲线与 Tabby 星的光变曲线（图 [8-17](ch08.xhtml#ch08fig17)）以及小行星实践项目的光变曲线进行比较。这些飞船会产生独特的曲线吗，还是你能从小行星群、恒星斑点或其他自然现象中得到相似的模式？
- en: You can find a solution, *practice_alien_armada.py*, in the appendix and in
    the *Chapter_8* folder, downloadable from the book’s website.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在附录和 *Chapter_8* 文件夹中找到一个解决方案，*practice_alien_armada.py*，并从书籍网站下载。
- en: '**Practice Project: Detecting a Planet with a Moon**'
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**实践项目：检测具有卫星的行星**'
- en: What kind of light curve would an exoplanet with an orbiting moon produce? Write
    a Python program that simulates a small exomoon orbiting a larger exoplanet and
    calculate the resulting light curve. You can find a solution, *practice_planet_moon.py*,
    in the appendix and on the book’s website.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 一个拥有卫星的系外行星会产生怎样的光变曲线？编写一个 Python 程序，模拟一个小型外卫星绕着更大的系外行星轨道运行，并计算出由此产生的光变曲线。你可以在附录和书籍网站上找到一个解决方案，*practice_planet_moon.py*。
- en: '**Practice Project: Measuring the Length of an Exoplanet’s Day**'
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**实践项目：测量系外行星的一天长度**'
- en: Your astronomer boss has given you 34 images of an exoplanet designated BR549\.
    The images were taken an hour apart. Write a Python program that loads the images
    in order, measures the intensity of each image, and plots the measurements as
    a single light curve ([Figure 8-28](ch08.xhtml#ch08fig28)). Use the curve to determine
    the length of a day on BR549.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 你的天文学家老板给了你34张外行星BR549的图像。图像拍摄时间间隔为一小时。编写一个Python程序，按顺序加载这些图像，测量每张图像的强度，并将这些测量值绘制成单一的光曲线（[图8-28](ch08.xhtml#ch08fig28)）。使用该曲线来确定BR549的白昼长度。
- en: '![Image](../images/fig08_28.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig08_28.jpg)'
- en: 'Figure 8-28: Composite light curve for 34 images of exoplanet BR549'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-28：外行星BR549的34张图像合成光曲线
- en: You can find a solution, *practice_length_of_day.py,* in the appendix. The digital
    version of the code, along with the folder of images (*br549_pixelated*), are
    in the *Chapter_8* folder downloadable from the book’s website.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在附录中找到一个解决方案，*practice_length_of_day.py*。代码的数字版本以及图像文件夹（*br549_pixelated*）都位于从本书网站可下载的*Chapter_8*文件夹中。
- en: '**Challenge Project: Generating a Dynamic Light Curve**'
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**挑战项目：生成动态光曲线**'
- en: Rewrite *transit.py* so that the light curve dynamically updates as the simulation
    runs, rather than just appearing at the end.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 重新编写*transit.py*，使得光曲线在模拟运行时动态更新，而不是仅在结束时显示。
