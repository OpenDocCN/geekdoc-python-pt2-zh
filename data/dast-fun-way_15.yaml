- en: '15'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '15'
- en: Graphs
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 图
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: Graphs are one of the fundamental data structures in computer science. They
    arise throughout numerous problems and programming tasks. Unlike the other data
    structures in this book, designed to optimize certain computations, the structure
    of *graphs* arises naturally from the data itself. In other words, graphs mirror
    the data they represent. Examining graph algorithms gives us insight into how
    we can define algorithms to utilize the inherent structure of the data.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 图是计算机科学中的基础数据结构之一。它们在许多问题和编程任务中出现。与本书中其他旨在优化特定计算的数据结构不同，*图*的结构是由数据本身自然产生的。换句话说，图反映了它们所代表的数据。研究图算法为我们提供了洞察力，让我们了解到如何定义算法以利用数据固有的结构。
- en: 'Previous chapters focused on the problem of structuring the data to aid the
    algorithms; high-level problems, such as searching for a value, motivated and
    drove the design of the facilitating data structures. This chapter covers the
    opposite problem: graphs show us how the structure of the data can drive the development
    of new algorithms. In other words, given data in the form of a graph, we examine
    how to create algorithms that will use it. This chapter examines three graph algorithms
    that use different aspects of the graph’s structure: Dijkstra’s algorithm for
    shortest paths, Prim’s algorithm for minimum-cost spanning trees, and Kahn’s algorithm
    for topological sort.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的章节集中讨论了如何构建数据结构来帮助算法；高层次的问题，如寻找一个值，激发并推动了有助于数据结构设计的想法。本章讨论的是相反的问题：图展示了数据的结构如何推动新算法的发展。换句话说，给定一个图形结构的数据，我们将研究如何创建利用这种数据的算法。本章讨论了三种图算法，它们利用图结构的不同方面：迪杰斯特拉算法用于最短路径，普里姆算法用于最小生成树，卡恩算法用于拓扑排序。
- en: Introducing Graphs
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引入图
- en: Graphs are composed of a set of *nodes* and a set of *edges*. As shown in [Figure
    15-1](#figure15-1), each edge connects a pair of nodes. This structure is similar
    to a large number of real-world systems, including social networks (nodes are
    people and edges are their connections), transportation networks (nodes are cities
    and edges represent paths), and computer networks (nodes are computers and edges
    represent the connections between them). This variety of real-world analogs makes
    graph algorithms fun to visualize, as simple searches transform into careful exploration
    of castles or frantic sprints through a city’s crowded alleys.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 图由一组*节点*和一组*边*组成。如[图 15-1](#figure15-1)所示，每条边连接一对节点。这种结构类似于大量的现实世界系统，包括社交网络（节点是人，边是他们之间的联系）、交通网络（节点是城市，边表示路径）和计算机网络（节点是计算机，边表示它们之间的连接）。这种现实世界的类比使得图算法在可视化时更加有趣，简单的搜索变成了对城堡的细致探索或在城市繁忙小巷中疯狂奔跑。
- en: '![A graph with nodes labeled A through H and lines between the linked nodes.](image_fi/502604c15/f15001.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![一个包含标记为 A 到 H 的节点并且节点之间有线条相连的图。](image_fi/502604c15/f15001.png)'
- en: 'Figure 15-1: A graph with undirected edges'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15-1：一个带有无向边的图
- en: 'A graph’s edges can have additional properties to capture the real-world complexities
    of the data such as whether or not the edges are directional. *Undirected edges*,
    like those in the graph in [Figure 15-1](#figure15-1), represent two-way relationships
    such as most roads and happy friendships. *Directed edges*, as illustrated in
    [Figure 15-2](#figure15-2),are like one-way streets and indicate a flow in a single
    direction. To represent undirected access, we use a pair of directed edges—one
    in each direction—between nodes. In a social context, directed edges could represent
    romantic interest in a television teen drama: an edge from Alice to Bob indicates
    Alice likes Bob, while the lack of an edge from Bob to Alice illustrates the devastating
    lack of reciprocity.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图的边可以具有附加属性，以捕捉数据的现实世界复杂性，例如边是否是有向的。*无向边*，如[图 15-1](#figure15-1)中所示，表示双向关系，例如大多数道路和美好的友谊。*有向边*，如[图
    15-2](#figure15-2)所示，类似于单行道，表示单向流动。为了表示无向访问，我们在节点之间使用一对有向边—每个方向一条。在社交语境中，有向边可以表示电视剧中青少年浪漫兴趣：从爱丽丝到鲍勃的边表示爱丽丝喜欢鲍勃，而鲍勃到爱丽丝的边缺失则说明了缺乏互惠的悲哀。
- en: '![A graph with nodes labeled A through H and arrows between the linked nodes.
    Some nodes are connected by two arrows, pointing in both directions, and some
    nodes have only one arrow. ](image_fi/502604c15/f15002.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![一个包含标记为 A 到 H 的节点并且节点之间有箭头相连的图。某些节点之间由两条箭头连接，箭头指向相反的方向，某些节点仅由一条箭头连接。](image_fi/502604c15/f15002.png)'
- en: 'Figure 15-2: A graph with directed edges'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15-2：带有有向边的图
- en: In addition to allowing us to model one-way streets or unrequited love, directed
    edges allow us to model more abstract problems, such as task dependence. We can
    specify a set of tasks as nodes and use directed edges to indicate the order dependency
    between tasks. In this way, we could create a graph to represent the tasks required
    for brewing the perfect cup of coffee, as shown in [Figure 15-3](#figure15-3).
    Nodes include such steps as heating the water, measuring out the beans, grinding
    the beans, and adding water to the grounds. The edges represent dependencies between
    these steps. We need to add a directed edge from the node for “grinding beans”
    to the node for “putting the grounds in the filter” to indicate that we must grind
    the beans first. The order of these two steps is critical, as anyone who has tried
    brewing unground beans can attest. However, we wouldn’t need an edge between “heating
    the water” and “grinding the beans” in either direction. We can perform those
    tasks in parallel.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 除了允许我们模拟单行街道或单相思之外，有向边还使我们能够模拟更抽象的问题，例如任务依赖关系。我们可以将一组任务表示为节点，并使用有向边表示任务之间的顺序依赖关系。通过这种方式，我们可以创建一个图来表示冲泡完美一杯咖啡所需的任务，如[图
    15-3](#figure15-3)所示。节点包括加热水、称量豆子、研磨豆子和将水加入咖啡粉等步骤。边表示这些步骤之间的依赖关系。我们需要从“研磨豆子”节点到“将咖啡粉放入过滤器”节点添加一条有向边，以表明我们必须先研磨豆子。这两个步骤的顺序至关重要，任何尝试过用未研磨的豆子冲泡咖啡的人都会知道这一点。然而，我们不需要在“加热水”和“研磨豆子”之间添加任何方向的边。我们可以并行执行这两个任务。
- en: '![Six tasks involved in making coffee such as Measure beans, Fill Kettle, Heat
    Water, and so forth. An arrow from Measure Beans pointing to Grind Beans indicates
    the necessary ordering. ](image_fi/502604c15/f15003.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![制作咖啡的六个任务，如称量豆子、填充水壶、加热水等。一个从“称量豆子”指向“研磨豆子”的箭头表示必要的顺序。](image_fi/502604c15/f15003.png)'
- en: 'Figure 15-3: Using a graph to represent the order of operations for a task'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15-3：使用图来表示任务操作顺序
- en: Edge weights further increase the modeling power of graphs. *Weighted edges*
    capture not only the link between nodes but also the cost of that link. For example,
    we could weight the edges in a transportation graph by the distance between locations.
    We could augment our social network with a measure of closeness, such as a count
    of how many times two nodes have spoken in the last month. [Figure 15-4](#figure15-4)
    shows our example graph with weighted edges.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 边权重进一步增强了图的建模能力。*加权边*不仅捕捉节点之间的连接，还捕捉该连接的成本。例如，我们可以通过地点之间的距离对交通图中的边进行加权。我们可以通过一种亲密度度量（例如过去一个月内两节点之间的对话次数）来增强我们的社交网络。[图
    15-4](#figure15-4)展示了我们的示例图以及加权边。
- en: '![A graph contains nodes labeled A through H with lines between the linked
    nodes. Each line is labeled with a number. For example, the edge between A and
    C has weight 0.5.](image_fi/502604c15/f15004.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![一个图包含从 A 到 H 标记的节点，节点之间有连接线。每条连接线都标有一个数字。例如，A 和 C 之间的边的权重为 0.5。](image_fi/502604c15/f15004.png)'
- en: 'Figure 15-4: A graph with weighted edges'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15-4：带有加权边的图
- en: Using a combination of weighted and directed edges allows us to capture complex
    interrelations among the nodes. Entire social dramas can be represented and played
    out through the nodes and edges of a well-constructed graph.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用加权边和有向边的组合，使我们能够捕捉节点之间复杂的相互关系。通过一个构造良好的图，整个社交剧本可以通过节点和边来表示和演绎。
- en: Representing Graphs
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 表示图
- en: While the abstract structure of a graph is relatively simple, there are multiple
    ways to represent nodes and edges in the computer’s memory. Two of the most common
    representations are *adjacency matrices* and *adjacency lists*. Both representations
    can handle directed, undirected, weighted, and unweighted edges. As with all the
    other data structures in this book, the difference between these structures lies
    in how the data is stored in memory and thus how different algorithms can access
    it.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管图的抽象结构相对简单，但在计算机内存中表示节点和边的方式有多种。最常见的两种表示方法是*邻接矩阵*和*邻接表*。这两种表示法都可以处理有向边、无向边、加权边和无权边。与本书中的所有其他数据结构一样，这些结构之间的区别在于数据在内存中的存储方式，从而影响不同算法对其的访问方式。
- en: 'The adjacency list formulation stores a separate list of neighbors for each
    node. We could use an array or linked list of neighbors within the node composite
    data structure:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 邻接表表示法为每个节点存储一个单独的邻居列表。我们可以在节点复合数据结构中使用数组或链表来存储邻居：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Or we could even create a separate edge data structure to store auxiliary information
    about the edges, such as their directionality or weights. For the examples below,
    we also provide a single numerical ID for each of the nodes, corresponding to
    the node’s index in the parent graph data structure:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以创建一个独立的边数据结构来存储关于边的辅助信息，例如它们的方向性或权重。以下示例中，我们还为每个节点提供了一个唯一的数字 ID，对应于该节点在父图数据结构中的索引：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In either case, the graph itself would contain an array of nodes:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，图本身将包含一个节点数组：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Regardless of the exact implementation, we can access the neighbors of any given
    node through a list linked from the node itself. [Figure 15-5](#figure15-5) shows
    an example of this structure.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 无论具体实现如何，我们都可以通过一个与节点本身相连接的列表来访问任何给定节点的邻居。[图 15-5](#figure15-5)展示了这种结构的一个例子。
- en: In the case of directed edges, a node’s list of edges or neighboring nodes contains
    only those that can be accessed when *leaving* the node. For example, node A may
    contain an edge to node B while B does not contain an edge to A.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 对于有向边，一个节点的边列表或邻接节点列表仅包含那些在*离开*节点时可以访问的边。例如，节点 A 可能包含指向节点 B 的边，而节点 B 不包含指向节点
    A 的边。
- en: Adjacency lists provide a localized view of neighbor relationships that mirrors
    real-world cases such as social networks. Each node tracks only the node to which
    it has connections. Similarly, in a social network, each person determines who
    qualifies as their friend, thus maintaining a list of their own connections. We
    don’t need a separate central repository to tell us who our friends are, and we
    might not have a full view into anyone else’s friends. Arguably, we might not
    even know which of our friends (outgoing edge) actually consider us a friend in
    return (incoming edge). We know only about our own outgoing connections.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 邻接列表提供了一种局部化的邻居关系视图，类似于社交网络等现实世界的情况。每个节点只跟踪它所连接的节点。同样，在社交网络中，每个人决定谁是他们的朋友，从而维护他们自己的连接列表。我们不需要一个独立的中央仓库来告诉我们谁是我们的朋友，并且我们可能无法全面了解其他人的朋友。可以说，我们甚至可能不知道哪些朋友（出边）实际上会把我们当作朋友（入边）。我们只了解自己发出的连接。
- en: '![On the left is a graph with nodes represented as circles and edges as lines.
    On the right is the same graph represented as an array of nodes with a list of
    edges. For example, node A has a list of neighbors B, C, and D.](image_fi/502604c15/f15005b.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![左侧是一个图，节点用圆圈表示，边用线条表示。右侧是相同图的节点数组表示，包含边的列表。例如，节点 A 有一个邻居节点 B、C 和 D 的列表。](image_fi/502604c15/f15005b.png)'
- en: 'Figure 15-5: A graph (left) and its adjacency list representation (right).
    Each node stores a list of neighboring nodes.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15-5：一个图（左）及其邻接列表表示（右）。每个节点存储一个邻接节点的列表。
- en: In contrast, an adjacency matrix represents a graph as a matrix, as shown in
    [Figure 15-6](#figure15-6), with one row and one column for each node. The value
    in row *i*, column *j* represents the weight of the edge from node *i* to node
    *j*. A value of zero indicates that no such edge exists. This representation allows
    us to directly look up whether an edge exists between any two nodes from a single
    central data source.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，邻接矩阵将图表示为一个矩阵，如[图 15-6](#figure15-6)所示，每个节点对应一行一列。第 *i* 行，第 *j* 列的值表示从节点
    *i* 到节点 *j* 的边的权重。零值表示没有这样的边。此表示方法使我们能够从单一的中央数据源直接查找任意两个节点之间是否存在边。
- en: '![The graph from Figure 15‐5 shown as a matrix. The row for node A is all zeros
    except entries of 1 for the columns B, C, and D.](image_fi/502604c15/f15006.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图 15-5 中的图表示为矩阵。节点 A 的行全是零，除了 B、C 和 D 列的值为 1。](image_fi/502604c15/f15006.png)'
- en: 'Figure 15-6: The adjacency matrix representation of a graph'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15-6：图的邻接矩阵表示
- en: This global view of the graph arises in real-world situations where a single
    planner is viewing the entire network. For instance, an airline company may use
    a global view of flight routes, where nodes are airports and edges indicate flights
    between them, to plan new service.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这种图的全局视图出现在现实世界的情况中，当一个单一的规划者在查看整个网络时。例如，航空公司可能会使用航班路线的全局视图，其中节点是机场，边表示它们之间的航班，以规划新的服务。
- en: While the adjacency graph representation is useful in some cases, we will focus
    on the adjacency list representation for the remainder of this chapter. The list
    representation fits naturally with the pointer-based approach we’ve been using
    for other data structures. Further, the use of individual node data structures
    allows additional flexibility in terms of storing auxiliary data.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然邻接图表示在某些情况下很有用，但在本章剩余部分我们将重点讨论邻接表表示。列表表示法与我们在其他数据结构中使用的基于指针的方法自然契合。此外，使用单独的节点数据结构还允许在存储辅助数据时提供额外的灵活性。
- en: Searching Graphs
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 图形搜索
- en: If we look back to our web-crawling example from Chapter 4, where we explored
    our favorite online encyclopedia for information related to coffee grinders, we
    can immediately see how the links in our favorite online encyclopedia form a graph
    of topics, with each page representing a node and each hyperlink representing
    a directed edge. We can progressively explore topics, diving deeper and deeper
    into the world of coffee grinders, by iteratively exploring each node and adding
    new nodes onto our list of topics to explore in the future. This type of exploration
    forms the basis of a graph search.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回顾第 4 章中的网页爬虫示例，假设我们在寻找与咖啡研磨机相关的信息，我们可以立即看到我们最喜欢的在线百科全书中的链接形成了一个主题图，每一页代表一个节点，每个超链接代表一条有向边。通过逐步探索每个节点，我们可以不断深入了解咖啡研磨机的世界，并将新的节点添加到我们未来要探索的主题列表中。这种探索方式构成了图形搜索的基础。
- en: Imagine that we are interested in finding a specific node in the graph. Perhaps
    we are conducting online research and looking for a coffee brand whose name we
    have long forgotten. We explore the relevant web pages (graph nodes) one at a
    time, reading the information on one page before moving to another. As we saw
    in Chapter 4, the order in which we explore the nodes greatly influences our search
    pattern. By using a stack data structure to track our future exploration options,
    we conduct a depth-first search over the graph. We pursue individual paths deeper
    and deeper until we hit a dead end. Then we backtrack and try other options we
    skipped along the way. If we instead use a queue to track our future search states,
    we perform a breadth-first search over the nodes. We check the nodes closer to
    our starting location before venturing further and further into the graph. Of
    course, there are a variety of other ways we could order our search. For example,
    best-first search orders the future nodes according to a ranking function, focusing
    on exploring high-scoring nodes first. In our search for nearby coffee shops in
    a new city, this prioritization of nodes can keep us from wasting hours wandering
    through residential neighborhoods instead of focusing on commercial areas.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想在图中找到一个特定的节点。也许我们正在进行在线研究，寻找一个我们早已忘记名字的咖啡品牌。我们一次探索相关的网页（图形节点），在浏览完一个页面的信息后再转到下一个页面。正如我们在第
    4 章中看到的，我们探索节点的顺序对搜索模式有很大的影响。通过使用栈数据结构来跟踪我们未来的探索选项，我们可以对图进行深度优先搜索。我们沿着单一路径越来越深入，直到遇到死胡同。然后我们回溯并尝试之前跳过的其他选项。如果我们改为使用队列来跟踪未来的搜索状态，我们就对节点进行广度优先搜索。我们会先检查离起始位置较近的节点，然后再逐步深入图中。当然，还有许多其他方式可以安排我们的搜索顺序。例如，最佳优先搜索根据排名函数对未来节点进行排序，优先探索得分较高的节点。在我们寻找新城市附近的咖啡店时，这种节点优先级排序可以避免我们浪费时间在居民区游荡，而是集中精力在商业区域。
- en: Regardless of the order, the concept of searching a graph by exploring one node
    at a time illustrates the impact of the data’s structure on the algorithm. We
    use the links between nodes (edges) to constrain and guide the exploration. In
    the next few sections, we look at common useful algorithms that do exactly this.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 无论顺序如何，通过一次探索一个节点来搜索图形的概念，展示了数据结构对算法的影响。我们使用节点之间的连接（边）来限制并引导探索。在接下来的几节中，我们将介绍一些常见的有用算法，它们正是这样工作的。
- en: Finding Shortest Paths with Dijkstra’s Algorithm
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Dijkstra 算法寻找最短路径
- en: Probably the single most common task when dealing with real-world graphs is
    to find the shortest distance between two nodes. Imagine we’re visiting a new
    city for the first time. As morning dawns, we stumble out of our hotel room, jetlagged
    and in search of refreshment. As good travelers, we’ve done copious research on
    the city’s coffee scene and created a list of four coffee shops to sample while
    in town. As the elevator reaches the lobby, we pull out a street map of the city,
    carefully marked with the location of the hotel and those coffee shops. It’s time
    to determine how to get to the shops on our list.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 处理实际世界中的图时，可能最常见的任务就是找到两个节点之间的最短距离。假设我们第一次访问一个新城市。清晨，我们从酒店房间迷迷糊糊地走出来，时差反应严重，正在寻找饮品。作为称职的旅行者，我们已做了大量关于城市咖啡文化的研究，并创建了一个包含四家咖啡店的清单，打算在这个城市品尝一下。当电梯到达大堂时，我们拿出了一张城市街道地图，上面标明了酒店和那些咖啡店的位置。现在是时候决定如何前往我们清单上的咖啡店了。
- en: '*Dijkstra’s algorithm*, invented by the computer scientist Edsger W. Dijkstra,
    finds the shortest path from any given starting node to all other nodes in the
    graph. It can work on directed, undirected, weighted, or unweighted graphs. The
    only constraint is that all the edge weights must be non-negative. You can never
    decrease the total path length by adding an edge. In our coffee-themed sightseeing
    example, we search for the shortest path from the hotel to each of the coffee
    shops. As shown in [Figure 15-7](#figure15-7), nodes represent either street intersections
    or shops along the street. Weighted, undirected edges represent the distance along
    the roads between these points.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**戴克斯特拉算法**（*Dijkstra’s algorithm*）由计算机科学家埃兹格尔·W·戴克斯特拉（Edsger W. Dijkstra）发明，用于从任何给定的起始节点找到图中到所有其他节点的最短路径。它可以应用于有向图、无向图、加权图或无加权图。唯一的限制是所有边的权重必须是非负的。通过添加边，路径总长度永远不会减少。在我们以咖啡为主题的观光示例中，我们寻找从酒店到每个咖啡店的最短路径。如[图
    15-7](#figure15-7)所示，节点代表街道交叉口或街道上的商店。加权、无向的边表示这些点之间的道路距离。'
- en: '![The top shows a map with one hotel, four coffee shops, and four street intersections.
    The figure at the bottom shows the graph representation. The weight of the edge
    between the hotel (a) and the first intersection (b) is 11 to indicate the distance.](image_fi/502604c15/f15007b.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![顶部显示一张地图，包含一个酒店、四家咖啡店和四个街道交叉口。底部的图形显示了该图的表示形式。酒店（a）和第一个交叉口（b）之间的边的权重为11，表示距离。](image_fi/502604c15/f15007b.png)'
- en: 'Figure 15-7: Points along a map with corresponding distances (top) can be represented
    as a weighted graph (bottom).'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15-7：上面显示的是一张带有相应距离的地图（顶部），下面则是该地图的加权图表示（底部）。
- en: Our goal is to find the shortest path from the starting node to each of the
    coffee shop nodes. The intersection nodes aren’t goals in their own right but
    allow our path to branch over different streets.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是找到从起始节点到每个咖啡店节点的最短路径。交叉口节点本身不是目标节点，而是允许我们在不同的街道上分支的途径。
- en: Dijkstra’s algorithm operates by maintaining a set of unvisited nodes and continually
    updating the *tentative* distance to each unvisited node. At each iteration, we
    visit the closest unvisited node. Upon doing so, we remove this new node from
    our unvisited set and update the distances to each of its unvisited neighbors.
    Specifically, we examine the new node’s neighbors and ask whether we have found
    a better path to each neighbor. We compute the length of the new proposed path
    by taking the distance to the current node and adding the distance (edge weight)
    to the neighbor. If this new distance is less than the best distance seen so far,
    we update the distance.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**戴克斯特拉算法**通过保持一组未访问的节点，并不断更新每个未访问节点的*临时*距离来工作。在每次迭代中，我们访问距离最近的未访问节点。这样做之后，我们从未访问节点集中移除这个新节点，并更新到它的每个未访问邻居的距离。具体来说，我们检查新节点的邻居，并询问是否已经找到到每个邻居的更短路径。我们通过将当前节点的距离与到邻居的距离（边的权重）相加来计算新提出路径的长度。如果这个新距离比到目前为止看到的最佳距离更短，则更新该距离。'
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The code starts by creating a series of helper data structures ❶, including
    an array of distances to each node (`distance`), an array indicating the last
    node visited before a given node (`last`), and a set of unvisited nodes (`unvisited`).
    The code then processes the unvisited nodes one by one. A `WHILE` loop iterates
    until the set of unvisited nodes is empty ❷. In each iteration, the code chooses
    the node with the minimal distance and removes it from the unvisited set ❸. A
    `FOR` loop iterates over each of the node’s neighbors ❹, computing the distance
    to that neighbor through the current node ❺ and updating the `distance` and `last`
    arrays if the code has found a better path ❻.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 代码开始时会创建一系列辅助数据结构❶，包括到每个节点的距离数组（`distance`）、表示访问某个节点前的最后一个节点的数组（`last`）以及未访问节点的集合（`unvisited`）。然后，代码会逐一处理未访问的节点。`WHILE`循环会一直迭代，直到未访问节点集合为空❷。在每次迭代中，代码选择距离最小的节点并将其从未访问集合中移除❸。`FOR`循环会遍历该节点的每个邻居❹，计算通过当前节点到该邻居的距离❺，并在找到更短路径时更新`distance`和`last`数组❻。
- en: '[Figure 15-8](#figure15-8) shows an example shortest-path search from node
    A in [Figure 15-4](#figure15-4)’s weighted graph. The circled node is the one
    currently being examined. The grayed-out nodes and list entries represent nodes
    that have been removed from the unvisited list and thus are no longer available
    for consideration.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[图15-8](#figure15-8)展示了从[图15-4](#figure15-4)的加权图中节点A开始的最短路径搜索示例。圈出的节点是当前正在被检查的节点。灰色的节点和列表项表示已经从未访问列表中移除的节点，因此不再参与考虑。'
- en: For the search in [Figure 15-8](#figure15-8), we start Dijkstra’s algorithm
    with all distances at infinity except for node A, which is set to zero ([Figure
    15-8](#figure15-8)(1)). This starting configuration corresponds to our initial
    knowledge about the best paths. We are already at node A, so the best path there
    is trivial. Since we have not found paths to any of the other nodes, they could
    be any distance away. We also maintain information for each node of which node
    precedes it in our search. The `Last` column indicates the preceding node. This
    information allows us to trace paths backward. While not all uses will need to
    reconstruct the path, our coffee search certainly does. It is pointless to find
    the shortest distance to coffee if we don’t also find the actual path. To construct
    the path to node F, we follow the last pointers back until we reach node A.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对于[图15-8](#figure15-8)中的搜索，我们从所有距离设置为无穷大开始，除了节点A，它的距离被设为零（[图15-8](#figure15-8)(1)）。这种起始配置对应于我们关于最佳路径的初步了解。我们已经在节点A，所以从那里到达的最佳路径是显而易见的。由于我们还没有找到到其他节点的路径，它们可能距离我们有任何距离。我们还保持每个节点的前驱节点的信息。`Last`列表示前驱节点。这个信息使我们能够追踪路径的回溯。虽然并非所有的应用都需要重建路径，但我们的咖啡搜索确实需要。要找到到咖啡的最短距离，如果我们没有找到实际路径，那就毫无意义了。为了构造到节点F的路径，我们沿着最后指针向回追踪，直到到达节点A。
- en: Our search starts, as shown in [Figure 15-8](#figure15-8)(2), by selecting the
    node with the smallest distance (node A), removing it from the unvisited list,
    and examining its neighbors. For each of A’s neighbors, we test whether traveling
    to that neighbor through A is shorter than any path seen so far. Since the distance
    to Node A is zero, the distance through A to each of its neighbors will be equal
    to the corresponding edge weights. Each time we update the distance to an unvisited
    node, we also update the back pointer to reflect the best path so far. Three nodes
    now point to A ([Figure 15-8](#figure15-8)(2)).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索从[图15-8](#figure15-8)(2)所示开始，通过选择距离最小的节点（节点A），将其从未访问列表中移除，并检查其邻居。对于A的每个邻居，我们测试通过A到达该邻居的路径是否比迄今为止发现的任何路径都更短。由于到节点A的距离为零，因此通过A到达每个邻居的距离将等于相应的边权重。每次我们更新一个未访问节点的距离时，我们还会更新返回指针，以反映迄今为止的最佳路径。现在有三个节点指向A（[图15-8](#figure15-8)(2)）。
- en: 'The search progresses, choosing the next closest, unvisited node. In this case,
    it could be either C or D. We break the tie using the node’s order in our list:
    node C wins! Again, we consider C’s neighbors and update their best distances
    ([Figure 15-8](#figure15-8)(3)). Remember the distances represent the best total
    distance from our starting node. The new distances are the sum of the distance
    to C and the distance from C to each neighbor.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索过程继续进行，选择下一个最接近的、未访问的节点。在这种情况下，它可以是C或D。我们使用节点在列表中的顺序来打破平局：节点C获胜！然后，我们考虑C的邻居并更新它们的最佳距离（[图15-8](#figure15-8)(3)）。请记住，这些距离代表从起始节点到当前节点的最佳总距离。新的距离是到C的距离与从C到每个邻居的距离之和。
- en: '![Nine subfigures show each step of Dijkstra’s algorithm. In subfigure 2, node
    A is grayed out and circled. The table to the right of each graph shows the current
    best distance from each node and the last node along that path.](image_fi/502604c15/f15008.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![九个子图展示了 Dijkstra 算法的每一步。在子图 2 中，节点 A 被灰显并圈出。每个图的右侧表格显示了从每个节点到达当前最佳距离以及沿着该路径的最后一个节点。](image_fi/502604c15/f15008.png)'
- en: 'Figure 15-8: An example of Dijkstra’s algorithm on a weighted graph'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15-8：Dijkstra 算法在加权图上的示例
- en: The search progresses to node D—the new unvisited node with the minimum distance
    ([Figure 15-8](#figure15-8)(4)). While examining node D’s neighbors, we find new
    shortest distances to both nodes E and F. Node E is particularly interesting,
    as we already had a candidate path to E through C. We can travel from A to C to
    E with a distance of 1.0\. However, this is not the best possible path. Our search
    revealed a new path, through D, that is slightly shorter with a total distance
    of 0.9\. We update both the potential distance and the backward pointer. Our best
    path to E now goes through D. On to the next closest node in our unvisited set,
    node F!
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索继续前进到节点 D——新的未访问节点，且具有最小距离（[图 15-8](#figure15-8)(4)）。在检查节点 D 的邻居时，我们发现到节点
    E 和 F 的新最短距离。节点 E 特别有趣，因为我们之前已经通过 C 有了到 E 的候选路径。我们可以从 A 到 C，再到 E，距离为 1.0。然而，这并不是最佳路径。我们的搜索揭示了一条新的路径，通过
    D，这条路径稍微短一些，总距离为 0.9。我们更新了潜在距离和反向指针。现在，我们到 E 的最佳路径是通过 D。接下来，我们继续查看下一个最接近的未访问节点，节点
    F！
- en: The search continues through the remaining nodes, but nothing else interesting
    occurs. The remaining nodes are all at the end of the shortest paths and don’t
    offer opportunities for shorter paths. For example, when considering node E’s
    neighbors ([Figure 15-8](#figure15-8)(6)), we examine both nodes C and D. The
    distance to either node when traveling through E would be 1.4, longer than the
    paths we’ve already discovered. In fact, both C and D have already been visited,
    so we wouldn’t even consider them. Similar logic applies when considering nodes
    B, H, and G as shown in [Figure 15-8](#figure15-8)(7), 15-8(8), and 15-8(9). Since
    those nodes’ neighbors have all been visited, we do not consider them.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索继续遍历剩余的节点，但没有出现其他有趣的情况。剩下的节点都位于最短路径的末端，不提供更短路径的机会。例如，在考虑节点 E 的邻居时（[图 15-8](#figure15-8)(6)），我们检查了节点
    C 和 D。当通过 E 时，到任一节点的距离为 1.4，比我们已发现的路径更长。事实上，C 和 D 都已经被访问过，因此我们甚至不会考虑它们。在考虑节点 B、H
    和 G 时，类似的逻辑也适用，如 [图 15-8](#figure15-8)(7)、15-8(8) 和 15-8(9) 所示。由于这些节点的邻居都已经被访问过，我们不会再考虑它们。
- en: In examining how Dijkstra’s algorithm traverses a graph while finding the shortest
    path, we can see the clear interrelation between the structure of the data and
    the algorithm itself. Shortest-path algorithms like Dijkstra’s are only necessary
    because of the structure of the problem. If we could effortlessly hop from any
    node to any other node, there would be no need to find a path along the edges.
    This is the real-world equivalent of teleporting from our hotel lobby to the target
    coffeeshop—convenient, but not allowed by the structure of the physical world.
    Thus, while searching for these shortest paths, we need to obey the structure
    of the graph itself.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查 Dijkstra 算法如何遍历图并找到最短路径时，我们可以清晰地看到数据结构与算法之间的相互关系。像 Dijkstra 这样的最短路径算法之所以必要，是因为问题本身的结构。如果我们能够轻松地从任何一个节点跳到任何其他节点，那么就不需要沿着边缘寻找路径了。这就像现实世界中的瞬间传送：从酒店大厅传送到目标咖啡店——虽然方便，但在物理世界的结构中并不允许。因此，在寻找这些最短路径时，我们需要遵守图的结构本身。
- en: Finding Minimum Spanning Trees with Prim’s Algorithm
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Prim 算法寻找最小生成树
- en: 'The problem of finding the *minimum spanning tree* of a graph provides another
    example of how the structure of graph data enables us to ask new questions and
    thus create new algorithms suited to answering these questions. The minimum spanning
    tree of an undirected graph is the smallest set of edges such that all of the
    nodes are connected (if possible). We can think of these trees in terms of a budget-conscious
    city planner, trying to determine which roads to pave. What is the absolute minimal
    set of roads needed in order to ensure that anyone can get from one place (node)
    to any other place (node) on a paved road? If the edges are weighted, such as
    by the distance or the cost of paving a road, we extend the concept to finding
    the set that minimizes the total weight: the *minimum-cost spanning tree* is the
    set of edges with the minimum total weight that connect all the nodes.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找图的*最小生成树*问题提供了另一个示例，说明了图数据的结构如何使我们能够提出新问题，从而创造出适合回答这些问题的新算法。无向图的最小生成树是一个包含最少边的集合，使得所有节点都能连接起来（如果可能的话）。我们可以将这些树类比为一位精打细算的城市规划师，试图确定应该铺设哪些道路。为了确保任何人都能通过一条铺设好的路从一个地方（节点）到达另一个地方（节点），所需的最小道路集合是什么？如果边有权重，例如距离或铺设道路的成本，我们将概念扩展为找到一个最小化总权重的集合：*最小成本生成树*是一个最小化总权重的边集合，能够连接所有节点。
- en: One method of finding the minimum spanning tree is *Prim’s algorithm*, which
    was independently proposed by multiple people, including computer scientist R.
    C. Prim and mathematician Vojtˇech Jarník. The algorithm operates very similarly
    to Dijkstra’s algorithm in the previous section, working through an unvisited
    set and building up a minimum spanning tree one node at a time. We start with
    an unvisited set of all nodes and randomly choose one to visit. This visited node
    forms the start of our minimum spanning tree. Then, on each iteration, we find
    the unvisited node with the minimum edge weight when compared to *any* of the
    nodes that we’ve previously visited. We are asking, “Which node is closest to
    our set’s periphery and thus can be added with the least cost?” We remove this
    new node from the unvisited set and add the corresponding edge to our minimum-cost
    spanning tree. We keep adding nodes and edges, one per iteration, until every
    node has been visited.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找最小生成树的一种方法是*普里姆算法*，该算法由包括计算机科学家R. C. 普里姆和数学家Vojtˇech Jarník在内的多位人士独立提出。该算法与上一节中的Dijkstra算法非常相似，通过遍历未访问的节点集并一次构建一个最小生成树。我们从一个未访问的所有节点集合开始，随机选择一个进行访问。这个访问过的节点成为我们最小生成树的起始节点。然后，在每次迭代中，我们找到一个未访问节点，并与我们之前访问过的*任何*节点进行比较，选择具有最小边权重的未访问节点。我们的问题是：“哪个节点最接近我们集合的边缘，因此可以以最小成本添加？”我们将这个新节点从未访问节点集合中移除，并将相应的边添加到我们的最小成本生成树中。我们不断添加节点和边，每次迭代添加一个，直到所有节点都被访问。
- en: We can picture Prim’s algorithm as a construction company hired to build bridges
    between islands in an archipelago. The builders start at a single island and work
    outward, connecting more and more islands. At each step, they choose the closest
    island to the ones in the currently connected set. One end of the bridge sits
    on an island in the connected set and one end sits on an island outside the connected
    set (bringing the new island into the connected set). By always starting new bridges
    from an island in the connected set, the builders are able to move their equipment
    to the starting island using the existing bridges. And by always ending bridges
    on islands outside the connected set, the builders increase the coverage of the
    connected set at every stage.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将普里姆算法想象为一家被聘请来在群岛之间架设桥梁的建筑公司。工人们从一个岛屿开始，向外扩展，连接越来越多的岛屿。在每个步骤中，他们选择与当前连接集中的岛屿最接近的岛屿。桥梁的一端坐落在连接集中的岛屿上，另一端坐落在连接集外的岛屿上（将新的岛屿引入连接集）。通过始终从连接集中的岛屿开始建造新桥，工人们能够使用现有的桥梁将设备移动到起始岛屿。而通过始终在连接集外的岛屿上结束桥梁，工人们在每个阶段都扩大了连接集的覆盖范围。
- en: We can simplify the algorithm’s code by tracking additional information. At
    each step, we maintain a list of the best edge (including weight) that we have
    encountered to each node. Every time we remove a new node from the unvisited set,
    we examine that node’s unvisited neighbors and check whether there are better
    (i.e., lower-cost) edges to any of its neighbors. If there are, we update the
    neighbor’s entry in the list with the new edge and weight.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过跟踪额外信息来简化算法的代码。在每一步中，我们保持一份到每个节点的最佳边（包括权重）的列表。每次从未访问节点集中移除一个新节点时，我们检查该节点的未访问邻居，并检查是否有更好的（即，低成本的）边指向它们的邻居。如果有，我们更新邻居在列表中的条目，替换为新的边和权重。
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The code starts by creating a series of helper data structures ❶, including
    an array of distances to each node (`distance`), an array indicating the last
    node visited before a given node (`last`), a set of unvisited nodes (`unvisited`),
    and the final set of edges for the minimal spanning tree (`mst_edges`). As with
    Dijkstra’s algorithm, the pseudocode (and the figures we’ll discuss in a moment)
    use a combination of lists and sets for the sake of illustration. We can more
    efficiently implement the algorithm by storing the unvisited nodes in a min-heap
    keyed by the distance. For now, we will list all the values in order to explicitly
    illustrate what is happening.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先创建一系列辅助数据结构 ❶，包括到每个节点的距离数组（`distance`）、指示访问给定节点之前最后访问节点的数组（`last`）、未访问节点集合（`unvisited`）以及最小生成树的最终边集（`mst_edges`）。与
    Dijkstra 算法一样，伪代码（以及我们稍后讨论的图）使用了列表和集合的组合来做说明。我们可以通过将未访问节点存储在一个按距离排序的最小堆中来更高效地实现算法。目前，我们将列出所有值，以便清楚地说明正在发生的过程。
- en: The code then proceeds like Dijkstra’s algorithm, processing the unvisited nodes
    one at a time. A `WHILE` loop iterates until the set of unvisited nodes is empty
    ❷. During each iteration, the node with the minimal distance to any of the visited
    nodes is chosen and removed from the unvisited set ❸. The code checks whether
    an incoming edge to the node exists, which is necessary because the first node
    visited will not have an incoming edge ❹, and adds the corresponding edges to
    the minimum spanning tree. After adding the new node, a `FOR` loop iterates over
    each of the node’s neighbors ❺, checking whether the neighbor is unvisited and,
    if so, checking its distance to the current node. In this case, the distance is
    simply the weight of the edge. The code finishes by returning the set of edges
    making up the minimum spanning tree.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 代码然后像 Dijkstra 算法一样执行，逐一处理未访问节点。`WHILE` 循环在未访问节点集为空时停止 ❷。在每次迭代中，选择距离任何已访问节点最短的节点，并将其从未访问节点集中移除
    ❸。代码检查是否存在指向该节点的入边，因为第一个访问的节点将没有入边 ❹，并将相应的边添加到最小生成树中。添加新节点后，`FOR` 循环遍历每个邻居 ❺，检查邻居是否未访问，如果是，则检查其到当前节点的距离。在此情况下，距离就是边的权重。代码最后返回组成最小生成树的边集。
- en: Consider what happens when we run Prim’s algorithm on the weighted graph from
    [Figure 15-4](#figure15-4), as illustrated in [Figure 15-9](#figure15-9). We start
    with all last edges set to null (we have not found any yet) and all “best” distances
    to infinity. For simplicity’s sake, we’ll break ties in alphabetical order of
    the nodes.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑当我们在[图 15-4](#figure15-4)中的加权图上运行 Prim 算法时会发生什么，正如[图 15-9](#figure15-9)所示。我们从所有边设置为
    null（尚未找到任何边）以及所有“最佳”距离为无穷大开始。为了简化，我们将按节点的字母顺序打破平局。
- en: 'To begin, we remove the first node A from our unvisited set. We then consider
    all of A’s neighbors and check whether there is a lower-cost edge from A to that
    neighbor. Given that all our current best distances are infinity, this isn’t difficult.
    We find lower-cost edges for all of A’s neighbors: (A, B), (A, C), and (A, D).
    [Figure 15-9](#figure15-9)(1) shows this new state.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从未访问节点集中移除第一个节点 A。然后，我们考虑 A 的所有邻居，并检查是否存在从 A 到该邻居的低成本边。鉴于我们当前的最短距离都为无穷大，这并不难。我们为
    A 的所有邻居找到低成本边： (A, B)、(A, C) 和 (A, D)。[图 15-9](#figure15-9)(1) 显示了这一新状态。
- en: 'During the second iteration, we find two potential nodes in our unvisited set
    to use: C and D. Using alphabetical order to break the tie, we select C. We remove
    C from the unvisited set and add the edge (A, C) to our minimum-cost spanning
    tree. Examining C’s unvisited neighbors, we find better candidate edges to nodes
    E and G ([Figure 15-9](#figure15-9)(2)).'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二轮迭代中，我们在未访问节点集合中找到了两个潜在节点：C 和 D。使用字母顺序打破平局时，我们选择了 C。我们将 C 从未访问节点集合中移除，并将边（A,
    C）添加到最小成本生成树中。在检查 C 的未访问邻居时，我们发现通往节点 E 和 G 的边是更好的候选边（见[图 15-9](#figure15-9)(2)）。
- en: The next closest node is D. We remove that from our unvisited set and add the
    edge (A, D) to the minimum-cost spanning tree. When we examine D’s unvisited neighbors,
    we find new, lower-cost edges to both nodes E and F ([Figure 15-9](#figure15-9)(3)).
    Our best candidate edge to node E now originates from node D instead of node C.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个最接近的节点是 D。我们将其从未访问节点集合中移除，并将边（A, D）添加到最小成本生成树中。当我们检查 D 的未访问邻居时，发现通往节点 E 和
    F 的边具有更低的成本（见[图 15-9](#figure15-9)(3)）。此时，通向节点 E 的最佳候选边来自节点 D，而非节点 C。
- en: 'The algorithm progresses through the remaining nodes in our unvisited set.
    Next, we visit node F, adding the edge (D, F), as shown in [Figure 15-9](#figure15-9)(4).
    Then, as shown in [Figure 15-9](#figure15-9)(5), we add node E and edge (D, E).
    The algorithm completes by adding nodes H, B, and G in that order. At each step,
    we add the corresponding best edge seen so far: (F, H), (F, B), and (C, G). The
    final three steps are shown in [Figure 15-9](#figure15-9)(6), [Figure 15-9](#figure15-9)(7),
    and [Figure 15-9](#figure15-9)(8), respectively.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 算法继续处理未访问节点集合中的其余节点。接下来，我们访问节点 F，添加边（D, F），如[图 15-9](#figure15-9)(4)所示。然后，如[图
    15-9](#figure15-9)(5)所示，我们添加节点 E 和边（D, E）。算法完成时，按顺序添加节点 H、B 和 G。在每一步中，我们都添加了目前为止看到的最佳边：（F,
    H）、（F, B）和（C, G）。最后三步分别如[图 15-9](#figure15-9)(6)、[图 15-9](#figure15-9)(7) 和 [图
    15-9](#figure15-9)(8) 所示。
- en: '![Eight subfigures show each step of Prim’s algorithm. In subfigure 1, node
    A is grayed out. The table to the right of each graph shows the current best distance
    to each remaining node and the corresponding edge.](image_fi/502604c15/f15009.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![八个子图展示了普里姆算法的每一步。在子图 1 中，节点 A 被灰色标出。每个图的右侧表格显示了当前每个剩余节点的最佳距离及相应的边。](image_fi/502604c15/f15009.png)'
- en: 'Figure 15-9: An example of Prim’s algorithm on a weighted graph'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15-9：普里姆算法在加权图上的示例
- en: Prim’s algorithm doesn’t care about the total path lengths from our starting
    node. We’re only interested in the cost of adding the new node to our connected
    set—the edge weight that will link that node to any other node in the visited
    set. We are not optimizing for final drive times between nodes, just for minimizing
    the cost of paving roads or building new bridges.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 普里姆算法不关心从起始节点到其他节点的总路径长度。我们只关心将新节点添加到已访问节点集合的成本——即将该节点连接到已访问集合中任何其他节点的边权重。我们并不是在优化节点间的最终行驶时间，而是在最小化铺设道路或建设新桥的成本。
- en: What if we had broken ties randomly instead of by alphabetical order? When deciding
    between choosing nodes D or E from our unvisited set after [Figure 15-9](#figure15-9)(2),
    we could have used either one. If we had chosen E instead of D, we would have
    found a lower-cost edge weight linking D into our graph. The algorithm would link
    in node D through E rather than through A. This means that we can find different
    minimum-cost spanning trees for the same graph. Multiple different trees may have
    the same cost. Prim’s algorithm only guarantees that we find one of the trees
    with the minimal cost.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在打破平局时随机选择而不是按字母顺序排列，会怎样？在决定从我们的未访问节点集合中选择节点 D 或 E 时（见[图 15-9](#figure15-9)(2)），我们本可以选择任何一个。如果我们选择
    E 而不是 D，我们会发现连接 D 的边权重较低。算法会通过 E 而不是 A 将节点 D 链接进图中。这意味着我们可以为相同的图找到不同的最小成本生成树。多个不同的树可能具有相同的成本。普里姆算法只保证我们找到其中一棵具有最小成本的树。
- en: Topological Sort with Kahn’s Algorithm
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用卡恩算法的拓扑排序
- en: Our final example of a graph algorithm uses the edges of a *directed acyclic
    graph* *(DAG)* to sort the nodes. A directed acyclic graph is a graph with directed
    edges arranged such that the graph contains no *cycles*, or paths that return
    to the same node, as shown in [Figure 15-10](#figure15-10). Cycles are critical
    in real-world road networks. It would be terrible if roads were constructed such
    that we could get from our apartment to our favorite coffee shop but could never
    navigate back. Yet this is exactly what happens in an acyclic graph—the path out
    of any node will never return to that same node.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最后一个图算法示例使用*有向无环图*（*DAG*）的边来对节点进行排序。 有向无环图是一种具有有向边的图，其边的排列方式使得图中没有*环*，即没有返回到同一节点的路径，如[图
    15-10](#figure15-10)所示。环在现实世界的道路网络中至关重要。如果道路被建造得使得我们可以从公寓到达我们最喜欢的咖啡馆，但却永远无法返回，那将是非常糟糕的。然而，这正是无环图的特性——任何节点的出边路径永远不会返回到该节点。
- en: '![The graph has nodes labeled A through F with arrows between linked nodes.
    Node A is linked to nodes C and D.](image_fi/502604c15/f15010.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图中有从A到F标记的节点，并且节点之间有箭头链接。A节点连接到C节点和D节点。](image_fi/502604c15/f15010.png)'
- en: 'Figure 15-10: A directed acyclic graph'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15-10：有向无环图
- en: 'We can use directed edges to indicate an ordering of the nodes. If the graph
    has an edge from A to B, node A must come before node B. We ordered nodes in this
    way in our coffee-brewing example at the beginning of the chapter: each node represented
    a step in the process, and each edge indicated one step’s dependency on the next.
    The person brewing the coffee has to perform a given step before they can perform
    any of the following steps. These types of dependencies arise throughout both
    computer science and the rest of life. An algorithm that sorts the nodes in order
    of their edges is called a *topological sort*.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用有向边来表示节点的顺序。如果图中有一条从 A 到 B 的边，则节点 A 必须出现在节点 B 之前。我们在章节开头的咖啡冲泡示例中以这种方式对节点进行了排序：每个节点代表一个步骤，每条边表示一个步骤对下一个步骤的依赖关系。冲泡咖啡的人必须先执行某个步骤，然后才能进行后续的步骤。这些类型的依赖关系在计算机科学和日常生活中都很常见。一个按照边的顺序对节点进行排序的算法称为*拓扑排序*。
- en: Computer scientist Arthur B. Kahn developed one approach, now called *Kahn’s
    algorithm,* to perform topological sort on a directed acyclic graph representing
    events. This algorithm operates by finding the nodes with no incoming edges, removing
    them from our list of pending nodes, adding them to our sorted list, and then
    removing the outbound edges from that node. The algorithm repeats until we have
    added every node to our sorted list. Intuitively, this sort mirrors how we might
    perform a complex task in the real world. We start with a subtask that we can
    accomplish—one with no dependencies. We perform that subtask and then chose another
    to do. Any subtask that requires us to have performed a yet uncompleted task needs
    to wait on our list until we have finished all its dependencies.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机科学家 Arthur B. Kahn 开发了一种方法，现在称为*Kahn 算法*，用于对表示事件的有向无环图执行拓扑排序。该算法通过找到没有入边的节点，将它们从待处理节点列表中移除，加入已排序的列表，然后删除该节点的出边来操作。算法重复此过程，直到所有节点都被加入已排序列表中。直观地说，这种排序方法类似于我们在现实世界中执行复杂任务的方式。我们从一个可以完成的子任务开始——即没有依赖关系的任务。我们完成该子任务后，再选择另一个任务。如果某个子任务要求我们在完成某个尚未完成的任务后才能进行，它必须在列表中等待，直到我们完成所有依赖任务。
- en: When implementing Kahn’s algorithm, we don’t need to actually remove edges from
    our graph. It’s sufficient to keep an auxiliary array counting the number of incoming
    edges to each node and modifying those counts.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现 Kahn 算法时，我们不需要真正从图中删除边。只需保持一个辅助数组来计算每个节点的入边数量，并修改这些计数即可。
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The code starts by creating several helper data structures ❶, including an array
    to hold the sorted list of nodes (`sorted`), an array storing the count of incoming
    edges for each node (`count`), and a stack of the next node to add to `sorted`
    (`next`). The code uses a pair of nested `FOR` loops over the nodes (outer loop)
    and each node’s edges (inner loop) to count the number of incoming edges for each
    node ❷. Then a `FOR` loop over the `count` array finds nodes that have no incoming
    edges and inserts them into `next` ❸.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先创建多个辅助数据结构❶，包括一个用于保存已排序节点列表的数组（`sorted`），一个存储每个节点入边数量的数组（`count`），以及一个用于存放下一个要加入`sorted`的节点的栈（`next`）。代码使用一对嵌套的`FOR`循环遍历节点（外层循环）和每个节点的边（内层循环）来计算每个节点的入边数量❷。然后，通过遍历`count`数组，找到没有入边的节点，并将其插入`next`中❸。
- en: The code then uses a `WHILE` loop to process the `next` stack until it is empty
    ❹. During each iteration, the code pops a node off the stack and adds it to the
    end of the `sorted` array. A `FOR` loop iterates over the node’s edges and reduces
    the count (effectively removing the incoming edge) for each neighbor ❺. Any neighbor
    with an incoming count of zero is added to `next` ❻. Finally, the code returns
    the array of sorted nodes.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 代码随后使用`WHILE`循环处理`next`栈，直到栈为空 ❹。在每次迭代中，代码从栈中弹出一个节点并将其添加到`sorted`数组的末尾。`FOR`循环遍历节点的边，并减少每个邻居的计数（有效地删除传入边）
    ❺。任何邻居的传入计数为零时，将其添加到`next`中 ❻。最后，代码返回排序后的节点数组。
- en: If our graph does contain cycles, our sorted list will be incomplete. We may
    want to add an additional check at the end of the function to test that the number
    of elements in our sorted list equals the number of nodes in the graph.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的图包含循环，排序后的列表将不完整。我们可能需要在函数的末尾添加额外的检查，测试排序列表中的元素数量是否等于图中的节点数。
- en: Consider running this algorithm on the graph from [Figure 15-10](#figure15-10),
    as is illustrated in [Figure 15-11](#figure15-11). We start off by counting the
    number of incoming edges (shown as the number adjacent to each node) and determining
    that node A is the only node without any incoming edges ([Figure 15-11](#figure15-11)(1)).
    Kahn’s algorithm then adds A to the sorted list and removes its outgoing edges
    (by decreasing the corresponding counts), as shown in [Figure 15-11](#figure15-11)(2).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑对来自[图 15-10](#figure15-10)的图运行此算法，如[图 15-11](#figure15-11)所示。我们首先统计每个节点的传入边数（显示为每个节点旁边的数字），并确定节点
    A 是唯一没有传入边的节点（[图 15-11](#figure15-11)(1)）。然后，卡恩算法将 A 添加到排序列表，并删除它的传出边（通过减少相应的计数），如[图
    15-11](#figure15-11)(2)所示。
- en: '![Seven subfigures show each step of a topological sort. In subfigure 2, node
    A is grayed out. The next list contains node C and the sorted list contains node
    A.](image_fi/502604c15/f15011.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![七个子图展示了拓扑排序的每一步。在子图 2 中，节点 A 被灰色显示。接下来的列表包含节点 C，排序后的列表包含节点 A。](image_fi/502604c15/f15011.png)'
- en: 'Figure 15-11: A topological sort on a directed acyclic graph'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15-11：对有向无环图进行拓扑排序
- en: We continue the algorithm on node C ([Figure 15-11](#figure15-11)(3)), which
    no longer has any incoming edges. We removed the only such edge when we processed
    node A. We remove C from our list of nodes under consideration (our stack `next`),
    remove its edges from the graph, and add it to the end of our sorted list. In
    the process, we’ve left node E without any incoming neighbors. E goes onto our
    stack.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续在节点 C 上执行算法（[图 15-11](#figure15-11)(3)），此时它没有任何传入边。我们在处理节点 A 时移除了唯一的传入边。我们将
    C 从待处理节点列表（栈`next`）中移除，删除其边并将其添加到排序列表的末尾。在这个过程中，节点 E 没有任何传入邻居。E 被加入到我们的栈中。
- en: The sort progresses through the remainder of the list. While processing node
    E, we remove the last incoming edges to node D, making it the next up for the
    algorithm ([Figure 15-11](#figure15-11)(4)). The sort then adds D, then F, then
    B to our sorted list as shown in [Figure 15-11](#figure15-11)(5), [Figure 15-11](#figure15-11)(6),
    and [Figure 15-11](#figure15-11)(7), respectively.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 排序继续处理列表的其余部分。在处理节点 E 时，我们删除到节点 D 的最后一条传入边，使其成为下一个要处理的节点（[图 15-11](#figure15-11)(4)）。然后，排序将
    D、F 和 B 依次添加到排序列表中，如[图 15-11](#figure15-11)(5)、[图 15-11](#figure15-11)(6) 和 [图
    15-11](#figure15-11)(7)所示。
- en: Kahn’s algorithm presents an example of both the usefulness of directed edges
    in a graph and how we can design an algorithm to operate on them. The directionality
    of the edges further constrains how we explore nodes.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 卡恩算法展示了有向图中有向边的实用性，以及我们如何设计一个算法来处理这些边。边的方向性进一步限制了我们探索节点的方式。
- en: Why This Matters
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么这很重要
- en: Graphs are pervasive throughout computer science. Their structure allows them
    to mirror a large variety of real-world phenomena, from streets to social or computer
    networks to sets of complex tasks. Graphs are useful for tasks like path planning
    and determining the order in which to compile a program’s source code. There are
    a myriad of algorithms designed to operate over these data structures, performing
    such tasks as searching the graph, determining the minimum spanning tree, or determining
    the maximum flow through a graph. We could devote an entire book to this single
    vastly impactful data structure.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图形在计算机科学中无处不在。它们的结构使其能够模拟各种真实世界的现象，从街道到社交网络或计算机网络，再到一系列复杂的任务。图形在路径规划和确定编译程序源代码顺序等任务中非常有用。为了处理这些数据结构，已经设计了无数算法，执行诸如图形搜索、确定最小生成树或确定图形的最大流等任务。我们甚至可以为这种具有巨大影响力的数据结构编写一本完整的书籍。
- en: For the purposes of this chapter, however, we focus on the tight coupling between
    the structure of the data and the algorithms that operate on it. The graph structure
    of data drives new problems, such as finding the minimum spanning tree, and thus
    new algorithms. In turn, the algorithms use the graph structure of the data, traversing
    the edges and exploring from node to node. This interplay demonstrates the importance
    of understanding the structure of data when defining both problems and new solutions.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，针对本章的目的，我们关注的是数据结构与操作其上的算法之间的紧密耦合。数据的图形结构引发了新问题，例如寻找最小生成树，从而也催生了新的算法。反过来，算法则利用数据的图形结构，遍历边缘并从一个节点探索到另一个节点。这种相互作用展示了在定义问题和新解决方案时，理解数据结构的重要性。
