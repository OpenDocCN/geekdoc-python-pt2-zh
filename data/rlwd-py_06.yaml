- en: '6'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '6'
- en: WINNING THE MOON RACE WITH APOLLO 8
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 阿波罗 8 号赢得月球竞赛
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: In the summer of 1968, America was losing the space race. The Soviet Zond spacecraft
    appeared moon-ready, the Central Intelligence Agency had photographed a giant
    Soviet N-1 rocket sitting on its launch pad, and the Americans’ troubled Apollo
    program still needed three more test flights. But in August, NASA manager George
    Low had an audacious idea. Let’s go to the moon *now*. Instead of more tests in
    the earth’s orbit, let’s circle the moon in December and let *that* be the test.
    In that moment, the space race was essentially over. Less than a year later, the
    Soviets had capitulated, and Neil Armstrong had taken his great leap for all mankind.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 1968年夏，美国在太空竞赛中处于下风。苏联的“宗德”号飞船看起来已经准备好登月，中央情报局拍摄到了停在发射台上的巨型苏联 N-1 火箭，而美国的阿波罗计划仍然需要三次测试飞行。但在8月，NASA经理乔治·洛提出了一个大胆的想法。我们*现在*就去月球吧！与其在地球轨道上做更多测试，不如让我们在12月绕月飞行，让*那*成为测试。就在那一刻，太空竞赛几乎已经结束。不到一年后，苏联投降了，尼尔·阿姆斯特朗为全人类迈出了伟大的一步。
- en: The decision to take the Apollo 8 spacecraft to the moon was hardly trivial.
    In 1967, three men had died in the Apollo 1 capsule, and multiple unmanned missions
    had blown up or otherwise failed. Against this backdrop and with so much at stake,
    everything hinged on the concept of the *free return*. The mission was designed
    so that if the service module engine failed to fire, the ship would simply swing
    around the moon and return to the earth like a boomerang ([Figure 6-1](ch06.xhtml#ch06fig1)).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 将阿波罗 8 号宇宙飞船送上月球的决定绝非轻松之举。1967年，三名宇航员在阿波罗 1 号舱内遇难，多次无人驾驶任务爆炸或以其他方式失败。在这种背景下，且事关重大，一切都取决于*自由返回*的概念。任务的设计是，如果服务舱的引擎未能点燃，飞船将直接绕月飞行，然后像回旋镖一样返回地球（[图
    6-1](ch06.xhtml#ch06fig1)）。
- en: '![Image](../images/fig06_01.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig06_01.jpg)'
- en: 'Figure 6-1: The Apollo 8 insignia, with the circumlunar free return trajectory
    serving as the mission number'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-1：阿波罗 8 号徽标，其中绕月自由返回轨道作为任务编号
- en: 'In this chapter, you’ll write a Python program that uses a drawing board module
    called turtle to simulate Apollo 8’s free return trajectory. You’ll also work
    with one of the classic conundrums in physics: the three-body problem.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你将编写一个使用名为 turtle 的绘图板模块的 Python 程序，用来模拟阿波罗 8 号的自由返回轨道。你还将研究物理学中的一个经典难题：三体问题。
- en: '**Understanding the Apollo 8 Mission**'
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**理解阿波罗 8 号任务**'
- en: The goal of the Apollo 8 mission was merely to circle the moon, so there was
    no need to take a lunar lander component. The astronauts traveled in the command
    and service modules, collectively known as the *CSM* ([Figure 6-2](ch06.xhtml#ch06fig2)).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 阿波罗 8 号任务的目标仅仅是绕月飞行，因此不需要携带月球着陆舱组件。宇航员们乘坐的是指令舱和服务舱，统称为*CSM*（[图 6-2](ch06.xhtml#ch06fig2)）。
- en: '![Image](../images/fig06_02.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig06_02.jpg)'
- en: 'Figure 6-2: Apollo command and service modules'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-2：阿波罗指令舱与服务舱模块
- en: In the fall of 1968, the CSM engine had been tested in the earth’s orbit only,
    and there were legitimate concerns about its reliability. To orbit the moon, the
    engine would have to fire twice, once to slow the spacecraft to enter lunar orbit
    and then again to leave orbit. With the free return trajectory, if the first maneuver
    failed, the astronauts could still coast home. As it turned out, the engine fired
    perfectly both times, and Apollo 8 orbited the moon 10 times. (The ill-fated Apollo
    13, however, made great use of its free return trajectory!)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 1968年秋，CSM 引擎仅在地球轨道上进行了测试，且存在关于其可靠性的正当担忧。为了绕月飞行，引擎需要两次点火：第一次是减速以进入月球轨道，第二次是离开轨道。使用自由返回轨道时，如果第一次操作失败，宇航员仍然可以滑行返回地球。事实证明，引擎两次点火都非常成功，阿波罗
    8 号绕月飞行了 10 次。（然而，命运多舛的阿波罗 13 号则充分利用了其自由返回轨道！）
- en: '***The Free Return Trajectory***'
  id: totrans-13
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***自由返回轨道***'
- en: Plotting a free return trajectory requires a lot of intense mathematics. It
    *is* rocket science, after all! Fortunately, you can simulate the trajectory in
    a two-dimensional graph with a few simplified parameters ([Figure 6-3](ch06.xhtml#ch06fig3)).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制自由返回轨道需要大量复杂的数学运算。毕竟，这*就是*火箭科学！幸运的是，你可以用几个简化的参数在二维图表中模拟该轨道（[图 6-3](ch06.xhtml#ch06fig3)）。
- en: '![Image](../images/fig06_03.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig06_03.jpg)'
- en: 'Figure 6-3: The free return trajectory (not to scale)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-3：自由返回轨道（非比例图）
- en: 'This 2D simulation of the free return uses a few key values: the starting position
    of the CSM (R[0]), the velocity and orientation of the CSM (V[0]), and the phase
    angle between the CSM and the moon (γ[0]). The *phase angle*, also called the
    *lead angle*, is the change in the orbital time position of the CSM required to
    get from a starting position to a final position. The *translunar injection velocity*
    (V[0]) is a propulsive maneuver used to set the CSM on a trajectory to the moon.
    It’s achieved from a *parking orbit* around the earth, where the spacecraft performs
    internal checks and waits until the phase angle with the moon is optimal. At this
    point, the third stage of the *Saturn V* rocket fires and falls away, leaving
    the CSM to coast to the moon.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这个自由返回的二维模拟使用了几个关键值：指令舱的起始位置（R[0]）、指令舱的速度和方向（V[0]）以及指令舱和月球之间的相位角（γ[0]）。*相位角*，也叫做*领先角度*，是从起始位置到最终位置所需的指令舱轨道时间位置的变化。*跨月注入速度*（V[0]）是一种推进操作，用来将指令舱设置为月球轨迹。它通过从绕地轨道（*停车轨道*）中实现，航天器在此轨道上进行内部检查，并等待与月球的相位角达到最优。这时，*土星五号*火箭的第三级发动机会点燃并脱落，指令舱则继续滑行向月球。
- en: 'Because the moon is moving, before you perform the translunar injection, you
    have to predict its future position, or *lead* it, like when you’re shooting skeet
    with a shotgun. This requires knowing the phase angle (γ[0]) at the time of translunar
    injection. Leading the moon is a little different from shooting a shotgun, however,
    as space is curved and you need to factor in the gravity of the earth and the
    moon. The tug of these two bodies on the spacecraft creates perturbations that
    are difficult to calculate—so difficult, in fact, that the calculation has earned
    its own special name in the field of physics: the three-body problem.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 由于月球在移动，在执行跨月注入之前，你必须预测月球的未来位置，或者*领先*它，就像用霰弹枪打飞碟一样。然而，这个过程与射击霰弹枪略有不同，因为太空是弯曲的，你需要考虑地球和月球的引力。这两个天体对航天器的拉力会产生难以计算的扰动——这些扰动甚至难度之大，以至于这个计算问题在物理学领域有了一个专门的名字：三体问题。
- en: '***The Three-Body Problem***'
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***三体问题***'
- en: The *three-body problem* is the challenge of predicting the behavior of three
    interacting bodies. Isaac Newton’s gravity equations work great for predicting
    the behavior of two orbiting bodies, such as the earth and the moon, but add one
    more body to the mix, whether a spacecraft, comet, moon, or so on, and things
    get complicated. Newton was never able to encapsulate the behavior of three or
    more bodies into a simple equation. For 275 years— even with kings offering prizes
    for a solution—the world’s greatest mathematicians worked the problem in vain.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*三体问题*是预测三个相互作用的天体行为的挑战。艾萨克·牛顿的引力方程在预测两个天体（如地球和月球）之间的行为时非常有效，但如果再加上第三个天体，无论是航天器、彗星、月亮等，问题就变得复杂。牛顿从未能够将三体或更多天体的行为归纳成一个简单的方程式。275年来——即便有国王提供奖金奖励解决方案——世界上最伟大的数学家们也一直未能解开这个问题。'
- en: The issue is that the three-body problem can’t be solved using simple algebraic
    expressions or integrals. Calculating the impact of multiple gravitational fields
    requires numerical iteration on a scale that’s impractical without a high-speed
    computer, such as your laptop.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，三体问题不能通过简单的代数表达式或积分来解决。计算多个引力场的影响需要进行数值迭代，这样的计算规模没有高速计算机（如你的笔记本电脑）是无法实现的。
- en: In 1961, Michael Minovitch, a summer intern at the Jet Propulsion Laboratory,
    found the first numerical solution using an IBM 7090 mainframe, at the time the
    fastest computer in the world. He discovered that mathematicians could reduce
    the number of computations needed to solve a restricted three-body problem, like
    our earth-moon-CSM problem, by using a patched conic method.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 1961年，迈克尔·米诺维奇（Michael Minovitch），当时是喷气推进实验室的暑期实习生，使用当时世界上最快的计算机——IBM 7090主机，找到了第一个数值解。他发现，数学家可以通过使用修正圆锥法，减少解决一个限制性三体问题（如我们地球-月球-指令舱问题）所需的计算量。
- en: The *patched conic method* is an analytical approximation that assumes you’re
    working with a simple two-body problem while the spacecraft is in the earth’s
    gravitational sphere of influence and another when you’re within the moon’s sphere
    of influence. It’s a rough, “back-of-the-envelope” calculation that provides reasonable
    estimates of departure and arrival conditions, reducing the number of choices
    for initial velocity and position vectors. All that’s left is to refine the flight
    path with repeated computer simulations.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*修正圆锥方法*是一种分析近似方法，它假设在航天器位于地球的引力影响范围内时，你正在处理一个简单的双体问题，而在月球的引力影响范围内又是另一个问题。这是一种粗略的“便签纸”计算方法，能提供合理的出发和到达条件估算，减少初始速度和位置向量的选择范围。剩下的就是通过重复的计算机模拟来精细化飞行路径。'
- en: Because researchers have already found and documented the Apollo 8 mission’s
    patched conic solution, you won’t need to calculate it. I’ve already adapted it
    to the 2D scenario you’ll be doing here. You can experiment with alternative solutions
    later, however, by varying parameters such as R[0] and V[0] and rerunning the
    simulation.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 由于研究人员已经找到并记录了阿波罗8号任务的修正圆锥解法，你不需要重新计算它。我已经将其调整为你将在此处使用的二维场景。不过，之后你可以通过改变像R[0]和V[0]这样的参数并重新运行模拟来实验其他解法。
- en: '**Project #9: To the Moon with Apollo 8!**'
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**项目#9：与阿波罗8号一起飞往月球！**'
- en: As a summer intern at NASA, you’ve been asked to create a simple simulation
    of the Apollo 8 free return trajectory for consumption by the press and general
    public. As NASA is always strapped for cash, you’ll need to use open source software
    and complete the project quickly and cheaply.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 作为NASA的暑期实习生，你被要求为媒体和公众制作一个简单的阿波罗8号自由返回轨迹模拟。由于NASA资金紧张，你需要使用开源软件，并尽可能快速和低成本地完成这个项目。
- en: THE OBJECTIVE
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 目标
- en: Write a Python program that graphically simulates the free return trajectory
    proposed for the Apollo 8 mission.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个Python程序，图形化地模拟阿波罗8号任务提出的自由返回轨迹。
- en: '***Using the turtle Module***'
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用turtle模块***'
- en: To simulate the flight of Apollo 8, you’ll need a way to draw and move images
    on the screen. There are a lot of third-party modules that can help you do this,
    but we’ll keep things simple by using the preinstalled turtle module. Although
    originally invented to help kids learn programming, turtle can easily be adapted
    to more sophisticated uses.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟阿波罗8号的飞行，你需要一种在屏幕上绘制和移动图像的方法。虽然有很多第三方模块可以帮助你完成这项工作，但我们会通过使用预安装的turtle模块来保持简单。尽管turtle最初是为帮助孩子们学习编程而发明的，但它可以轻松地适应更复杂的用途。
- en: The turtle module lets you use Python commands to move a small image, called
    a *turtle*, around a screen. The image can be invisible, an actual image, a custom
    shape, or one of the predefined shapes shown in [Figure 6-4](ch06.xhtml#ch06fig4).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: turtle模块允许你使用Python命令在屏幕上移动一个小图像，称为*turtle*。该图像可以是不可见的、实际的图像、自定义形状或[图6-4](ch06.xhtml#ch06fig4)中显示的预定义形状之一。
- en: '![Image](../images/fig06_04.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig06_04.jpg)'
- en: 'Figure 6-4: Standard turtle shapes provided with the turtle module'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-4：turtle模块提供的标准turtle形状
- en: As the turtle moves, you can choose to draw a line behind it to trace its movement
    ([Figure 6-5](ch06.xhtml#ch06fig5)).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 随着turtle的移动，你可以选择在它的后面画一条线来追踪它的运动([图6-5](ch06.xhtml#ch06fig5))。
- en: '![Image](../images/fig06_05.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig06_05.jpg)'
- en: 'Figure 6-5: Moving the turtle around the Turtle Graphics window'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-5：在Turtle图形窗口中移动turtle
- en: 'This simple drawing was made with the following script:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的图形是通过以下脚本制作的：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can use Python functionality with turtle to write more concise code. For
    example, you can use a for loop to create the same pattern.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用Python的turtle功能编写更简洁的代码。例如，你可以使用for循环来创建相同的图案。
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, steve moves forward 50 pixels and then turns to the left at a right angle.
    These steps are repeated three times by the for loop.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，steve前进50个像素，然后向左转90度。这些步骤通过for循环重复三次。
- en: Other turtle methods let you change the shape of the turtle, change its color,
    lift the pen so no path is drawn, “stamp” its current position on the screen,
    set the heading of the turtle, and get its position on the screen. [Figure 6-6](ch06.xhtml#ch06fig6)
    shows this functionality, which is described in the script that follows.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 其他turtle方法允许你更改turtle的形状、改变其颜色、抬起笔不绘制路径、在屏幕上“印章”当前的位置、设置turtle的朝向，并获取它在屏幕上的位置。[图6-6](ch06.xhtml#ch06fig6)展示了这些功能，并在接下来的脚本中进行了描述。
- en: '![Image](../images/fig06_06.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig06_06.jpg)'
- en: 'Figure 6-6: More examples of turtle behaviors. Numbers refer to script annotations.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-6：更多海龟行为的示例。数字指代脚本注释。
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: After importing the turtle module and instantiating a turtle object named steve,
    leave behind an image of steve using the stamp() method ➊. Then use the position()
    method ➋ to get the turtle’s current (*x*, *y*) coordinates as a tuple ➌. This
    will come in handy when calculating the distance between objects for the gravity
    equation.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 导入海龟模块并实例化一个名为steve的海龟对象后，使用stamp()方法 ➊留下steve的图像。然后使用position()方法 ➋获取海龟当前的(*x*,
    *y*)坐标，并将其作为元组 ➌。这个方法在计算物体之间的距离时会很有用，尤其是在重力方程中。
- en: Move the turtle forward 150 spaces and change its color to gray ➍. Then leave
    a stamp behind, rotate the turtle 45 degrees, and move it backward 75 spaces using
    the bk() (backward) method ➎.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 将海龟向前移动150个单位，并将其颜色更改为灰色 ➍。然后留下印章，旋转海龟45度，再使用bk()（向后）方法将其向后移动75个单位 ➎。
- en: Leave another stamp and then stop drawing the turtle’s path by using the penup()
    method ➏. Move steve backward another 75 spaces and color him black. Now use an
    alternative to rotate(), which is to directly set the heading of the turtle ➐.
    The heading is simply the direction the turtle is traveling. Note that the default
    “standard mode” directions are referenced to the east, not the north ([Table 6-1](ch06.xhtml#ch06table1)).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 先留下另一个印章，然后使用penup()方法停止绘制海龟的路径 ➏。将steve向后移动75个单位，并将其颜色改为黑色。现在，使用rotate()方法的替代方法，直接设置海龟的朝向
    ➐。朝向就是海龟当前移动的方向。请注意，默认的“标准模式”方向是以东为参考，而非北方（[表 6-1](ch06.xhtml#ch06table1)）。
- en: '**Table 6-1:** Common Directions in Degrees for the turtle Module in Standard
    Mode'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 6-1：** 海龟模块在标准模式下的常见方向（角度）'
- en: '| Degrees | Direction |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 角度 | 方向 |'
- en: '| 0 | East |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 东 |'
- en: '| 90 | North |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 90 | 北 |'
- en: '| 180 | West |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 180 | 西 |'
- en: '| 270 | South |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 270 | 南 |'
- en: Leave another stamp and then put the pen down to once more draw a path behind
    the turtle ➑. Move steve forward 50 spaces and then change his shape to a triangle
    ➒. That completes the drawing.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 先留下另一个印章，然后放下画笔再次绘制海龟后面的路径 ➑。将steve向前移动50个单位，然后将其形状改为三角形 ➒。这完成了绘图。
- en: Don’t be fooled by the simplicity of what we’ve done so far. With the right
    commands, you can draw intricate designs, such as the Penrose tiling in [Figure
    6-7](ch06.xhtml#ch06fig7).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 不要被我们目前所做的简单操作迷惑。通过正确的命令，你可以绘制复杂的设计，例如[图 6-7](ch06.xhtml#ch06fig7)中的Penrose镶嵌。
- en: '![Image](../images/fig06_07.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/fig06_07.jpg)'
- en: 'Figure 6-7: A Penrose tiling produced by the turtle module demo, penrose.py'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-7：海龟模块演示生成的Penrose镶嵌，penrose.py
- en: The turtle module is part of the Python Standard Library, and you can find the
    official documentation at *[https://docs.python.org/3/library/turtle.html?highlight=turtle#module-turtle/](https://docs.python.org/3/library/turtle.html?highlight=turtle#module-turtle/)*.
    For a quick tutorial, do an online search for Al Sweigart’s *Simple Turtle Tutorial
    for Python*.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 海龟模块是Python标准库的一部分，官方文档可以在*[https://docs.python.org/3/library/turtle.html?highlight=turtle#module-turtle/](https://docs.python.org/3/library/turtle.html?highlight=turtle#module-turtle/)*找到。对于快速教程，可以在线搜索Al
    Sweigart的*Simple Turtle Tutorial for Python*。
- en: '***The Strategy***'
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***策略***'
- en: We’ve now made a strategic decision to use turtle to draw the simulation, but
    how should the simulation look? For convenience, I’d suggest basing it on [Figure
    6-3](ch06.xhtml#ch06fig3). You’ll start with the CSM in the same parking orbit
    position around the earth (R[0]) and the moon at the same approximate phase angle
    (γ[0]). You can use images to represent the earth and the moon and custom turtle
    shapes to build the CSM.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经做出战略决策，使用海龟绘制模拟图，但模拟图应该是什么样子呢？为了方便起见，我建议基于[图 6-3](ch06.xhtml#ch06fig3)来设计。你将从地球附近的相同停泊轨道位置（R[0]）和月球的相同大致相位角（γ[0]）开始。你可以使用图像表示地球和月球，并使用自定义的海龟形状构建CSM。
- en: Another big decision at this point is whether to use procedural or object-oriented
    programming (OOP). When you plan to generate multiple objects that behave similarly
    and interact with each other, OOP is a good choice. You can use an OOP class as
    a blueprint for the earth, the moon, and the CSM objects and automatically update
    the object attributes as the simulation runs.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的决策是是否使用过程式编程或面向对象编程（OOP）。当你计划生成多个行为相似且相互作用的对象时，OOP是一个不错的选择。你可以使用OOP类作为地球、月球和CSM对象的蓝图，并在模拟运行时自动更新对象属性。
- en: You can run the simulation using *time steps*. Basically, each program loop
    will represent one unit of dimensionless time. With each loop, you’ll need to
    calculate each object’s position and update (redraw) it on the screen. This requires
    solving the three-body problem. Fortunately, not only has someone done this already,
    they’ve done it using turtle.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用*时间步长*来运行模拟。基本上，每个程序循环代表一个无量纲的时间单位。每次循环，你都需要计算每个物体的位置并更新（重绘）它在屏幕上的位置。这需要解决三体问题。幸运的是，已经有人做过这个工作，而且他们是用turtle来实现的。
- en: Python modules often include example scripts to show you how to use the product.
    For instance, the matplotlib gallery includes code snippets and tutorials for
    making a huge number of charts and plots. Likewise, the turtle module comes with
    *turtle-example-suite*, which includes demonstrations of turtle applications.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Python模块通常会包括示例脚本，向你展示如何使用该产品。例如，matplotlib画廊包括用于制作大量图表和绘图的代码片段和教程。同样，turtle模块附带了*turtle-example-suite*，其中包含turtle应用的演示。
- en: One of the demos, *planet_and_moon.py*, provides a nice “recipe” for handling
    a three-body problem in turtle ([Figure 6-8](ch06.xhtml#ch06fig8)). To see the
    demos, open a PowerShell or terminal window and enter python –m turtledemo. Depending
    on your platform and how many versions of Python you have installed, you may need
    to use python3 -m turtledemo.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 示例之一，*planet_and_moon.py*，提供了一个处理三体问题的好“配方”，使用了turtle（参见[图6-8](ch06.xhtml#ch06fig8)）。要查看这些示例，打开PowerShell或终端窗口并输入`python
    -m turtledemo`。根据你的平台和安装的Python版本数量，你可能需要使用`python3 -m turtledemo`。
- en: '![Image](../images/fig06_08.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig06_08.jpg)'
- en: 'Figure 6-8: Screen capture of the planet_and_moon.py turtle demo'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-8：planet_and_moon.py海龟示例的屏幕截图
- en: This demo addresses the sun-earth-moon three-body problem, but it can be easily
    adapted to handle an earth-moon-CSM problem. Again, for the specific Apollo 8
    situation, you’ll use [Figure 6-3](ch06.xhtml#ch06fig3) to guide development of
    the program.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例处理的是太阳-地球-月球三体问题，但它可以很容易地适应处理地球-月球-CSM问题。同样，对于特定的阿波罗8号情况，你将使用[图6-3](ch06.xhtml#ch06fig3)来指导程序的开发。
- en: '***The Apollo 8 Free Return Code***'
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***阿波罗8号自由回归代码***'
- en: The *apollo_8_free_return.py* program uses turtle graphics to generate a top-down
    view of the Apollo 8 CSM leaving the earth’s orbit, circling the moon, and returning
    to the earth. The core of the program is based on the *planet_and_moon.py* demo
    discussed in the previous section.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*apollo_8_free_return.py*程序使用turtle图形生成阿波罗8号CSM离开地球轨道、环绕月球并返回地球的俯视图。程序的核心基于上一节讨论的*planet_and_moon.py*示例。'
- en: You can find the program in the *Chapter_6* folder, downloadable from the book’s
    website at *[https://nostarch.com/real-world-python/](https://nostarch.com/real-world-python/)*.
    You’ll also need the earth and moon images found there ([Figure 6-9](ch06.xhtml#ch06fig9)).
    Be sure to keep them in the same folder as the code and don’t rename them.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在*Chapter_6*文件夹中找到该程序，文件可以从书籍的官网上下载，网址为*[https://nostarch.com/real-world-python/](https://nostarch.com/real-world-python/)*。你还需要从该网站获取地球和月球图像（参见[图6-9](ch06.xhtml#ch06fig9)）。请确保将它们与代码放在同一文件夹中，并且不要更改文件名。
- en: '![Image](../images/fig06_09.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig06_09.jpg)'
- en: 'Figure 6-9: earth_100x100.gif and moon_27x27.gif images used in the simulation'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-9：在模拟中使用的earth_100x100.gif和moon_27x27.gif图像
- en: '**Importing turtle and Assigning Constants**'
  id: totrans-74
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**导入turtle并赋值常量**'
- en: '[Listing 6-1](ch06.xhtml#ch06list1) imports the turtle module and assigns constants
    that represent key parameters: the gravitational constant, the number of times
    to run the main loop, and the *x* and *y* values for R[0] and V[0] (see [Figure
    6-3](ch06.xhtml#ch06fig3)). Listing these values near the top of the program makes
    them easy to find and alter later.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表6-1](ch06.xhtml#ch06list1)导入了turtle模块并赋值了表示关键参数的常量：引力常数、主循环运行的次数，以及R[0]和V[0]的*x*和*y*值（参见[图6-3](ch06.xhtml#ch06fig3)）。将这些值列在程序的顶部使得它们易于查找和修改。'
- en: '[PRE3]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 6-1: Importing turtle and assigning constants'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6-1：导入turtle并赋值常量
- en: You’ll need to import four helper classes from turtle. You’ll use the Shape
    class to make a custom turtle that looks like the CSM. The Screen subclass makes
    the screen, called a *drawing board* in turtle parlance. The Turtle subclass creates
    the turtle objects. The Vec2D import is a two-dimensional vector class. It will
    help you define velocity as a vector of magnitude and direction.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要从turtle导入四个辅助类。你将使用Shape类来制作一个看起来像CSM的自定义海龟。Screen子类用于创建屏幕，turtle术语中称之为*绘图板*。Turtle子类用于创建海龟对象。Vec2D导入的是一个二维向量类，它将帮助你定义速度，作为一个具有大小和方向的向量。
- en: Next, assign some variables that the user may want to tweak later. Start with
    the gravitational constant, used in Newton’s gravity equations to ensure the units
    come out right. Assign it 8, the value used in the turtle demo. Think of this
    as a *scaled* gravitational constant. You can’t use the true constant, as the
    simulation doesn’t use real-world units.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，分配一些变量，用户以后可能希望调整它们。首先是引力常数，它用于牛顿引力方程中，以确保单位的正确性。将其设置为 8，这是 turtle 演示中使用的值。可以将其视为一个
    *缩放过* 的引力常数。你不能使用真实的常数，因为模拟并不使用现实世界的单位。
- en: You’ll run the simulation in a loop, and each iteration will represent a time
    step. With each step, the program will recalculate the position of the CSM as
    it moves through the gravity fields of the earth and the moon. The value of 4100,
    arrived at by trial and error, will stop the simulation just after the spacecraft
    arrives back on the earth.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在一个循环中运行模拟，每次迭代代表一个时间步长。每个步骤，程序都会重新计算 CSM 的位置，随着它穿越地球和月球的引力场。通过反复试验得出的 4100
    的值，将在宇宙飞船返回地球后停止模拟。
- en: In 1968, a round-trip to the moon took about six days. Since you’re incrementing
    the time unit by 0.001 with each loop and running 4,100 loops, this means a time
    step in the simulation represents about two minutes of time in the real world.
    The longer the time step, the faster the simulation but the less accurate the
    results, as small errors compound over time. In actual fight path simulations,
    you can optimize the time step by first running a small step, for maximum accuracy,
    and then using the results to find the largest time step that yields a similar
    result.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 1968 年，往返月球大约需要六天。由于你每次循环增加 0.001 的时间单位，并运行 4,100 次循环，这意味着模拟中的一个时间步长大约代表现实世界中的两分钟。时间步长越长，模拟运行得越快，但结果的准确性越差，因为小错误会随着时间的推移积累。在实际的飞行路径模拟中，你可以通过先运行一个小的时间步长（以获得最大的准确性），然后使用结果来找到一个能产生相似结果的最大时间步长，从而优化时间步长。
- en: The next two variables, Ro_X and Ro_Y, represent the (*x*, *y*) coordinates
    of the CSM at the time of the translunar injection (see [Figure 6-3](ch06.xhtml#ch06fig3)).
    Likewise, Vo_X and Vo_Y represent the *x*- and *y*-direction components of the
    translunar injection velocity, which is applied by the third stage of the *Saturn
    V* rocket. These values started out as best guesses and were refined with repeated
    simulations.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个变量 Ro_X 和 Ro_Y 表示 CSM 在月球转移注入（translunar injection）时的（*x*，*y*）坐标（见[图 6-3](ch06.xhtml#ch06fig3)）。同样，Vo_X
    和 Vo_Y 表示月球转移注入速度的 *x* 和 *y* 分量，这个速度由土星五号火箭的第三阶段提供。这些值最初是通过猜测得出的，然后通过反复模拟进行优化。
- en: '**Creating a Gravity System**'
  id: totrans-83
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**创建引力系统**'
- en: Because the earth, the moon, and CSM form a continuously interacting gravity
    system, you’ll want a convenient way to represent them and their respective forces.
    For this, you’ll need two classes, one to create a gravity system and one to create
    the bodies within it. [Listing 6-2](ch06.xhtml#ch06list2) defines the GravSys
    class that helps you create a mini solar system. This class will use a list to
    keep track of all the bodies in motion and loop them through a series of time
    steps. It’s based on the *planet_and_moon.py* demo in the turtle library.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于地球、月球和 CSM 形成了一个持续互动的引力系统，你需要一种方便的方式来表示它们及其相应的力。为此，你需要两个类，一个用于创建引力系统，另一个用于创建其中的天体。[清单
    6-2](ch06.xhtml#ch06list2)定义了 GravSys 类，帮助你创建一个迷你太阳系。这个类将使用一个列表来跟踪所有在运动中的天体，并将它们通过一系列时间步长循环。它基于
    turtle 库中的 *planet_and_moon.py* 演示。
- en: '[PRE4]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 6-2: Defining a class to manage the bodies in the gravity system'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 6-2：定义一个类来管理引力系统中的天体
- en: The GravSys class defines how long the simulation will run, how much time will
    pass between time steps (loops), and what bodies will be involved. It also calls
    the step() method of the Body class you’ll define in [Listing 6-3](ch06.xhtml#ch06list3).
    This method will update each body’s position as a result of gravitational acceleration.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: GravSys 类定义了模拟运行的时间、时间步长（循环之间的时间间隔）以及参与的天体。它还调用了你将在[清单 6-3](ch06.xhtml#ch06list3)中定义的
    Body 类的 step() 方法。这个方法将根据引力加速度更新每个天体的位置。
- en: Define the initialization method and, as per convention, pass it self as a parameter.
    The self parameter represents the GravSys object you’ll create later in the main()
    function.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 定义初始化方法，并按照惯例将 self 作为参数传递。self 参数表示你将在 main() 函数中创建的 GravSys 对象。
- en: Create an empty list named bodies to hold the earth, the moon, and the CSM objects.
    Then assign attributes for when the simulation starts and the amount to increment
    time with each loop, known as *delta time* or dt. Set the starting time to 0 and
    set the dt time step to 0.001. As discussed in the previous section, this time
    step will correspond to about two minutes in the real world and will produce a
    smooth, accurate, and fast simulation.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个空列表，命名为 bodies，用于存放地球、月球和 CSM 对象。接着，设置模拟开始时的属性以及每次循环时递增的时间量，这个量被称为 *delta
    time* 或 dt。将起始时间设置为 0，并将 dt 时间步长设置为 0.001。如前一节所讨论的，这个时间步长大约对应现实世界中的两分钟，并且会产生一个平滑、准确且快速的模拟。
- en: The last method controls the time steps in the simulation ➊. It uses a for loop
    with the range set to the NUM_LOOPS variable. Use a single underscore (_) rather
    than i to indicate the use of an insignificant variable (see [Listing 5-3](ch05.xhtml#ch05list3)
    in [Chapter 5](ch05.xhtml) for details).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个方法控制模拟中的时间步长 ➊。它使用一个 for 循环，范围设置为 NUM_LOOPS 变量。使用单个下划线 (_) 而不是 i 来表示使用一个不重要的变量（有关详细信息，请参见
    [列表 5-3](ch05.xhtml#ch05list3) 以及 [第 5 章](ch05.xhtml)）。
- en: With each loop, increment the gravity system’s time variable by dt. Then, apply
    the time shift to each body by looping through the list of bodies and calling
    the body.step() method, which you’ll define later within the Body class. This
    method updates the position and velocity of the bodies due to gravitational attraction.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次循环中，增加重力系统的时间变量 dt。然后，通过遍历物体列表并调用 body.step() 方法（稍后会在 Body 类中定义）来对每个物体应用时间偏移。此方法更新物体由于引力作用而改变的位置和速度。
- en: '**Creating Celestial Bodies**'
  id: totrans-92
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**创建天体**'
- en: '[Listing 6-3](ch06.xhtml#ch06list3) defines the Body class used to build the
    earth, the moon, and the CSM Body objects. Although no one would ever mistake
    a planet for a small spacecraft, they’re not that different from a gravitational
    standpoint, and you can stamp them both out of the same mold.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 6-3](ch06.xhtml#ch06list3) 定义了 Body 类，用于构建地球、月球和 CSM Body 对象。尽管没有人会把行星误认为是小型航天器，但从引力角度来看，它们差别并不大，因此你可以将它们都用相同的模板创建出来。'
- en: '[PRE5]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 6-3: Defining a class to create objects for the earth, the moon, and
    the CSM'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6-3：定义一个类来创建地球、月球和 CSM 的对象
- en: Define a new class by using the Turtle class as its *ancestor*. This means the
    Body class will conveniently inherit all the Turtle class’s methods and attributes.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 Turtle 类作为 *祖先* 来定义一个新类。这意味着 Body 类将方便地继承 Turtle 类的所有方法和属性。
- en: Next, define an initializer method for the body object. You’ll use this to create
    new Body objects in the simulation, a process called *instantiation* in OOP. As
    parameters, the initialize method takes itself, a mass attribute, a starting location,
    a starting velocity, the gravity system object, and a shape.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为 body 对象定义一个初始化方法。你将用它在模拟中创建新的 Body 对象，这个过程在面向对象编程中称为 *实例化*。作为参数，初始化方法接收自身、质量属性、起始位置、起始速度、重力系统对象和形状。
- en: The super() function lets you invoke the method of a superclass to gain access
    to inherited methods from the ancestor class. This allows your Body objects to
    use attributes from the prebuilt Turtle class. Pass it the shape attribute, which
    will allow you to pass a custom shape or image to your bodies when you build them
    in the main() function.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: super() 函数允许你调用父类的方法，以访问从祖先类继承的方法。这使得你的 Body 对象能够使用预构建的 Turtle 类的属性。将形状属性传递给它，这样你在
    main() 函数中创建物体时，就能为物体传递自定义的形状或图像。
- en: Next, assign an instance attribute for the gravsys object. This will allow the
    gravity system and body to interact. Note that it’s best to initialize attributes
    through the __init__() method, as we do in this case, since it’s the first method
    called after the object is created. This way, these attributes will be immediately
    available to any other methods in the class, and other developers can see a list
    of all the attributes in one place.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为 gravsys 对象分配一个实例属性。这将允许重力系统和物体进行交互。请注意，最好通过 __init__() 方法初始化属性，就像我们在这里做的那样，因为它是创建对象后第一个被调用的方法。这样，这些属性将立即对类中的其他方法可用，并且其他开发者可以在一个地方看到所有属性的列表。
- en: The following penup() method of the Turtle class will remove the drawing pen
    so the object doesn’t leave a path behind it as it moves. This gives you the option
    of running the simulation with and without visible orbital paths.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 Turtle 类的 penup() 方法，它将移除绘图笔，使得物体在移动时不会留下路径。这样，你就可以选择运行带有或不带有可视轨道路径的模拟。
- en: Initialize a mass attribute for the body. You’ll need this to calculate the
    force of gravity. Next, assign the body’s starting position using the setpos()
    method of the Turtle class. The starting position of each body will be an (*x*,
    *y*) tuple. The origin point (0, 0) will be at the center of the screen. The *x*-coordinate
    increases to the right, and the *y*-coordinate increases upward.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为物体初始化一个质量属性。你需要这个属性来计算重力。接下来，使用Turtle类的setpos()方法为物体分配起始位置。每个物体的起始位置将是一个(*x*,
    *y*)元组。原点(0, 0)将在屏幕中央，*x*坐标向右增加，*y*坐标向上增加。
- en: Assign an initialization attribute for velocity. This will hold the starting
    velocity for each object. For the CSM, this value will change throughout the simulation
    as the ship moves through the gravity fields of the earth and the moon.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为速度分配一个初始化属性。它将保存每个物体的起始速度。对于CSM，这个值将在模拟过程中随着飞船穿越地球和月球的引力场而变化。
- en: As each body is instantiated, use dot notation to append it to the list of bodies
    in the gravity system. You’ll create the gravsys object from the GravSys() class
    in the main() function.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个物体实例化时，使用点符号将其附加到重力系统中的物体列表中。你将在main()函数中从GravSys()类创建gravsys对象。
- en: The final two lines, commented out, allow the user to change the simulation
    window size and choose to draw a path behind each object. Start out with a full-screen
    display and keep the pen in the up position to let the simulation run quickly.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的两行，已注释掉，允许用户更改模拟窗口的大小，并选择在每个物体后面绘制路径。先从全屏显示开始，并保持笔的位置在上方，以便快速运行模拟。
- en: '**Calculating Acceleration Due to Gravity**'
  id: totrans-105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**计算重力加速度**'
- en: The Apollo 8 simulation will begin immediately after the translunar injection.
    At this point, the third stage of the *Saturn V* has fired and fallen away, and
    the CSM is beginning its coast to the moon. All changes in velocity or direction
    will be entirely due to changes in gravitational force.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 阿波罗8号模拟将在月际注入后立即开始。此时，*土星V*的第三级已经点燃并脱落，CSM开始向月球行进。所有的速度或方向变化将完全由于重力变化。
- en: The method in [Listing 6-4](ch06.xhtml#ch06list4) loops through the bodies in
    the bodies list, calculates acceleration due to gravity for each body, and returns
    a vector representing the body’s acceleration in the *x* and *y* directions.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 6-4](ch06.xhtml#ch06list4)中的方法遍历物体列表中的物体，计算每个物体的重力加速度，并返回一个表示物体在*x*和*y*方向上的加速度的向量。'
- en: '[PRE6]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 6-4: Calculating acceleration due to gravity'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 6-4：计算重力加速度
- en: 'Still within the Body class, define the acceleration method, called acc(),
    and pass it self. Within the method, name a local variable a, again for acceleration,
    and assign it to a vector tuple using the Vec2D helper class. A 2D vector is a
    pair of real numbers (*a*, *b*), which in this case represent *x* and *y* components,
    respectively. The Vec2D helper class enforces rules that permit easy mathematical
    operations using vectors, as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然在Body类内，定义加速度方法，命名为acc()，并传入self。在方法内，定义一个局部变量a，再次代表加速度，并将其赋值为一个使用Vec2D辅助类的向量元组。2D向量是一个由实数（*a*,
    *b*）组成的对，这里分别表示*x*和*y*分量。Vec2D辅助类强制执行规则，允许使用向量进行简便的数学运算，如下所示：
- en: (*a*, *b*) + (*c*, *d*) = (*a* + *c*, *b* + *d*)
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (*a*, *b*) + (*c*, *d*) = (*a* + *c*, *b* + *d*)
- en: (*a*, *b*) – (*c*, *d*) = (*a* – *c*, *b* – *d*)
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (*a*, *b*) – (*c*, *d*) = (*a* – *c*, *b* – *d*)
- en: (*a*, *b*) × (*c*, *d*) = *ac* + *bd*
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (*a*, *b*) × (*c*, *d*) = *ac* + *bd*
- en: Next, start looping through the items in the bodies list, which contains the
    earth, the moon, and the CSM. You’ll use the gravitational force of each body
    to determine the acceleration of the object for which you’re calling the acc()
    method. It doesn’t make sense for a body to accelerate itself, so exclude the
    body if it’s the same as self.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，开始遍历物体列表中的项，该列表包含地球、月球和指令服务舱（CSM）。你将使用每个物体的重力来确定你正在调用acc()方法的物体的加速度。物体不应自我加速，因此如果物体与自身相同，则排除它。
- en: 'To calculate gravitational acceleration (stored in the g variable) at a point
    in space, you’ll use the following formula:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算空间中某一点的重力加速度（存储在g变量中），你需要使用以下公式：
- en: '![Image](../images/equ_page_136_01.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/equ_page_136_01.jpg)'
- en: 'where *M* is the mass of the attracting body, *r* is the distance (radius)
    between bodies, *G* is the gravitational constant you defined earlier, and *r*
    is the unit vector from the center of mass of the attracting body to the center
    of mass of the body being accelerated. The *unit vector*, also known as the *direction
    vector* or *normalized vector*, can be described as *r/|r|*, or:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，*M* 是吸引物体的质量，*r* 是物体之间的距离（半径），*G* 是你之前定义的引力常数，*r* 是从吸引物体的质心到被加速物体质心的单位向量。*单位向量*，也称为*方向向量*或*归一化向量*，可以表示为
    *r/|r|*，或者：
- en: '![Image](../images/equ_page_136_02.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/equ_page_136_02.jpg)'
- en: The unit vector allows you to capture the direction of acceleration, which will
    be either positive or negative. To calculate the unit vector, you’ll have to calculate
    the distance between bodies by using the turtle pos() method to get each body’s
    current position as a Vec2D vector. As described previously, this is a tuple of
    the (*x*, *y*) coordinates.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 单位向量可以帮助你捕捉加速度的方向，方向可以是正值或负值。要计算单位向量，你需要通过使用海龟的 pos() 方法获取每个物体当前的位置，并将其表示为一个
    Vec2D 向量来计算物体之间的距离。如前所述，这个向量是一个由 (*x*, *y*) 坐标组成的元组。
- en: You’ll then input that tuple into the acceleration equation. Each time you loop
    through a new body, you’ll change the a variable based on the gravitational pull
    of the body being examined. For example, while the earth’s gravity may slow the
    CSM, the moon’s gravity may pull in the opposite direction and cause it to speed
    up. The a variable will capture the net effect at the end of the loop. Complete
    the method by returning a.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你将把这个元组输入到加速度方程中。每次循环遍历一个新的物体时，你将根据正在检查物体的引力来更改 a 变量。例如，虽然地球的引力可能会减缓 CSM
    的速度，月球的引力可能会朝相反方向拉动并使其加速。a 变量将捕捉到循环结束时的净效应。通过返回 a 来完成方法。
- en: '**Stepping Through the Simulation**'
  id: totrans-121
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**逐步模拟**'
- en: '[Listing 6-5](ch06.xhtml#ch06list5), still in the Body class, defines a method
    to solve the three-body problem. It updates the position, orientation, and velocity
    of bodies in the gravity system with each time step. The shorter the time steps,
    the more accurate the solution, though at the cost of computational efficiency.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 6-5](ch06.xhtml#ch06list5)，仍然在 Body 类中，定义了一个方法来解决三体问题。它会在每个时间步长中更新引力系统中物体的位置、方向和速度。时间步长越短，解的准确性越高，但也会牺牲计算效率。'
- en: '[PRE7]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 6-5: Applying the time step and rotating the CSM'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 6-5: 应用时间步长并旋转 CSM'
- en: Define a step() method to calculate position, orientation, and velocity of a
    body. Assign it self as an argument.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个 step() 方法来计算物体的位置、方向和速度。将 self 作为参数传递给它。
- en: Within the method definition, set a local variable, dt, to the gravsys object
    of the same name. This variable has no link to any real-time system; it’s just
    a floating-point number that you’ll use to increment velocity with each time step.
    The larger the dt variable is, the faster the simulation will run.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法定义中，设置一个本地变量 dt，赋值为同名的 gravsys 对象。这个变量与任何实时系统没有关联；它只是一个浮动的数字，你将用它来在每个时间步长中增加速度。dt
    变量的值越大，模拟的运行速度就越快。
- en: Now call the self.acc() method to calculate the acceleration that the current
    body experiences due to the combined gravitational fields of the other bodies.
    This method returns a vector tuple of (*x*, *y*) coordinates. Multiply it by dt
    and add the results to self.vel(), which is also a vector, to update the body’s
    velocity for the current time step. Recall that, behind the scenes, the Vec2D
    class will manage the vector arithmetic.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，调用 self.acc() 方法来计算当前物体由于其他物体的引力场的合力所经历的加速度。该方法返回一个 (*x*, *y*) 坐标的向量元组。将其乘以
    dt 并将结果加到 self.vel() 上，后者也是一个向量，从而更新当前时间步长的物体速度。回想一下，背后 Vec2D 类将负责处理向量运算。
- en: To update the body’s position in the turtle graphics window, multiply the body’s
    velocity by the time step and add the result to the body’s position attribute.
    Now each body will move according to the gravitational pull of the other bodies.
    You just solved the three-body problem!
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新海龟图形窗口中物体的位置，将物体的速度乘以时间步长，并将结果加到物体的位置信息上。现在，每个物体将根据其他物体的引力来移动。你刚刚解决了三体问题！
- en: Next, add some code to refine the CSM’s behavior. Thrust comes out of the back
    of the CSM, so in real missions, the rear of the spacecraft is oriented toward
    its target. This way, the engine can fire and slow the ship enough to enter lunar
    orbit or the earth’s atmosphere. Orienting the ship this way isn’t necessary with
    a free return trajectory, but since Apollo 8 planned to fire its engines and enter
    lunar orbit (and did), you should orient the ship properly throughout its journey.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加一些代码来精细化 CSM 的行为。推力从 CSM 后部喷射，因此在实际任务中，航天器的后部朝向目标。这样，发动机就能启动并减速，足以进入月球轨道或地球大气层。对于自由返回轨迹来说，航天器不需要以这种方式朝向目标，但由于阿波罗
    8号计划发射发动机并进入月球轨道（并成功完成），你应该在整个旅程中正确地调整航天器的朝向。
- en: Start by selecting the CSM from the list of bodies ➊. In the main() function,
    you’ll create the bodies in order of size, so the CSM will be the third item in
    the list, at index 2.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 从物体列表 ➊ 中选择 CSM。你将在 `main()` 函数中按大小顺序创建物体，因此 CSM 将是列表中的第三个项目，索引为 2。
- en: To get the CSM to rotate as it coasts through space, assign a small number to
    a local variable named rotate_factor. I arrived at this number through trial and
    error. Next, set the heading of the CSM turtle object using its selfheading attribute.
    Instead of passing it (*x*, *y*) coordinates, call the self.heading() method,
    which returns the object’s current heading in degrees, and subtract from it the
    rotate_factor variable multiplied by the body’s current *x* location, obtained
    by calling the self.xcor() method. This will cause the CSM to rotate faster as
    it approaches the moon to keep its tail pointed in the direction of travel.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让 CSM 在太空中滑行时旋转，给一个名为`rotate_factor`的局部变量赋值一个小的数值。我是通过反复试验得出这个数字的。接下来，使用 CSM
    海龟对象的`self.heading`属性设置其航向。你无需传入 (*x*, *y*) 坐标，而是调用`self.heading()`方法，它会返回对象当前的航向角度，然后从中减去`rotate_factor`变量乘以当前的
    *x* 位置，该位置通过调用`self.xcor()`方法获取。这样，随着 CSM 靠近月球，它的旋转速度会加快，以保持尾部指向运动方向。
- en: You’ll need to eject the service module before the spacecraft enters the earth’s
    atmosphere. To do this at a position similar to that in real Apollo missions,
    use another conditional to check the spacecraft’s *x*-coordinate ➋. The simulation
    expects the earth to be near the center of the screen, at coordinates (0, 0).
    In turtle, the *x*-coordinate will decrease as you move left of the center and
    increase as you move to the right. If the CSM’s *x*-coordinate is less than –20
    pixels, you can assume that it’s returning home and that it’s time to part company
    with the service module.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在航天器进入地球大气层之前，你需要将服务舱分离。为了在一个与实际阿波罗任务相似的位置进行分离，使用另一个条件来检查航天器的 *x* 坐标 ➋。模拟中假定地球位于屏幕中心，坐标为
    (0, 0)。在海龟中，*x* 坐标会随着你向左移动而减小，向右移动则增大。如果 CSM 的 *x* 坐标小于 –20 像素，你可以假设它正在返回地球，并且是时候与服务舱分离了。
- en: You’ll model this event by changing the shape of the turtle representing the
    CSM. Since turtle includes a standard shape—called arrow—that looks similar to
    the command module, all you need to do now is call the self.shape() method and
    pass it the name of the shape. Then call the self.shapesize() method and halve
    the size of the arrow to make it match the command module in the CSM custom shape,
    which you’ll make later. When the CSM passes the –20 *x*-position, the service
    module will magically disappear, leaving the command module to complete the voyage
    home.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你将通过改变代表 CSM（指令舱）的海龟形状来模拟这个事件。由于海龟包含一个标准形状——叫做箭头——它与指令舱相似，因此你现在只需调用`self.shape()`方法，并传入该形状的名称。然后调用`self.shapesize()`方法，将箭头的大小减半，使其匹配后续自定义的指令舱形状。当
    CSM 通过 –20 *x* 位置时，服务舱将神奇地消失，留下指令舱完成回程任务。
- en: Finally, you’ll want to orient the base of the command module, with its heat-resistant
    shielding, toward the earth. Do this by setting the arrow shape’s heading to 105
    degrees.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你需要将指令舱的底部朝向地球，确保热防护罩朝向地球。通过将箭头形状的航向设置为 105 度来实现这一点。
- en: '**Defining main(), Setting Up the Screen, and Instantiating the Gravity System**'
  id: totrans-135
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**定义 `main()`，设置屏幕，并实例化引力系统**'
- en: You used object-oriented programming to build the gravity system and the bodies
    within it. To run the simulation, you’ll return to procedural programming and
    use a main() function. This function sets up the turtle graphics screen, instantiates
    objects for the gravity system and the three bodies, builds a custom shape for
    the CSM, and calls the gravity system’s sim_loop() method to walk through the
    time steps.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用面向对象编程构建了引力系统和其中的天体。为了运行仿真，你将回到过程式编程并使用main()函数。此函数设置海龟图形屏幕，为引力系统和三个天体实例化对象，构建指令舱的自定义形状，并调用引力系统的sim_loop()方法以逐步进行时间步长。
- en: '[Listing 6-6](ch06.xhtml#ch06list6) defines main() and sets up the screen.
    It also creates a gravity system object to manage your mini solar system.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 6-6](ch06.xhtml#ch06list6)定义了main()并设置了屏幕。它还创建了一个引力系统对象来管理你的迷你太阳系。'
- en: '[PRE8]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 6-6: Setting up the screen and making a gravsys object in main()'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 6-6：在main()中设置屏幕并创建gravsys对象
- en: Define main() and then instantiate a screen object (a drawing window) based
    on the TurtleScreen subclass. Then invoke the screen object’s setup() method to
    set the size of screen to full. Do this by passing width and height arguments
    of 1.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 定义main()函数，然后基于TurtleScreen子类实例化一个屏幕对象（绘图窗口）。接着调用该屏幕对象的setup()方法，将屏幕大小设置为全屏。通过传递宽度和高度参数为1来实现这一点。
- en: 'If you don’t want the drawing window to take up the full screen, pass setup()
    the pixel arguments shown in the following snippet:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不希望绘图窗口占满整个屏幕，可以将以下代码片段中的像素参数传递给setup()：
- en: '[PRE9]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that a negative startx value uses right justification, a negative starty
    uses bottom alignment, and the default settings create a centered window. Feel
    free to experiment with these parameters to get the best fit to your monitor.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，负值的startx表示右对齐，负值的starty表示底部对齐，默认设置会创建一个居中的窗口。可以随意尝试这些参数，以找到最适合你显示器的设置。
- en: Complete setting up the screen by setting its background color to black and
    giving it a title. Next, instantiate a gravity system object, gravsys, using the
    GravSys class. This object will give you access to the attributes and methods
    in the GravSys class. You’ll pass it to each body when you instantiate them shortly.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 完成屏幕设置后，将背景颜色设置为黑色并为其设置标题。接下来，使用GravSys类实例化一个引力系统对象gravsys。这个对象将使你能够访问GravSys类中的属性和方法。稍后在实例化每个天体时，你将把它传递给每个天体。
- en: '**Creating the Earth and Moon**'
  id: totrans-145
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**创建地球和月球**'
- en: '[Listing 6-7](ch06.xhtml#ch06list7), still in the main() function, creates
    turtle objects for the earth and the moon using the Body class you defined earlier.
    The earth will remain stationary at the center of the screen, while the moon will
    revolve around the earth.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 6-7](ch06.xhtml#ch06list7)仍然在main()函数中，使用你之前定义的Body类创建地球和月球的海龟对象。地球将保持在屏幕中心不动，而月球将绕着地球旋转。'
- en: When you create these objects, you’ll set their starting coordinates. The starting
    position of the earth is near the center of the screen, biased downward a bit
    to give the moon and CSM room to interact near the top of the window.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建这些对象时，你需要设置它们的起始坐标。地球的起始位置接近屏幕中心，稍微偏向下方一点，以便为月球和指令舱留出空间，使它们可以在窗口的顶部互动。
- en: The starting position of the moon and CSM should reflect what you see in [Figure
    6-3](ch06.xhtml#ch06fig3), with the CSM vertically beneath the center of the earth.
    This way, you only need to thrust in the *x* direction, rather than calculate
    a vector component velocity that includes some movement in the *x* direction and
    some in the *y* direction.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 月球和指令舱的起始位置应该与[图 6-3](ch06.xhtml#ch06fig3)中的内容一致，指令舱位于地球中心正下方。这样，你只需在*x*方向施加推力，而不需要计算一个包含*x*方向和*y*方向运动的向量分量速度。
- en: '[PRE10]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 6-7: Instantiating turtles for the earth and moon'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 6-7：实例化地球和月球的海龟对象
- en: Start by assigning the image of the earth, which is included in the folder for
    this project, to a variable. Note that images should be *gif* files and cannot
    be rotated to show the turtle’s heading. So that turtle recognizes the new shape,
    add it to the TurtleScreen shapelist using the screen.register_shape() method.
    Pass it the variable that references the earth image.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 首先将地球的图像赋值给一个变量，该图像包含在此项目的文件夹中。注意，图像应该是*gif*文件，并且不能旋转以显示海龟的朝向。为了让海龟识别新的形状，使用screen.register_shape()方法将其添加到TurtleScreen的shapelist中，并将引用地球图像的变量传给它。
- en: Now it’s time to instantiate the turtle object for the earth. You call the Body
    class and pass it the arguments for mass, starting position, starting velocity,
    gravity system, and turtle shape—in this case, the image. Let’s talk about each
    of these arguments in more detail.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候为地球实例化 turtle 对象了。你调用 Body 类并传入质量、起始位置、起始速度、引力系统和 turtle 形状（在这种情况下是图像）的参数。接下来，我们将更详细地讨论每个参数。
- en: You’re not using real-world units here, so mass is an arbitrary number. I started
    with the value used for the sun in the turtle demo *planet_and_moon.py*, on which
    this program is based.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这里并没有使用真实世界的单位，因此质量是一个任意数字。我从 turtle 示例程序 *planet_and_moon.py* 中使用的太阳质量值开始，这个程序是本程序的基础。
- en: The starting position is an (*x*, *y*) tuple that places the earth near the
    center of the screen. It’s biased downward 25 pixels, however, as most of the
    action will take place in the upper quadrant of the screen. This placement will
    provide a little more room in that region.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 起始位置是一个 (*x*, *y*) 元组，将地球放置在屏幕的中心附近。然而，它向下偏移了 25 像素，因为大部分动作会发生在屏幕的上半部分。这个位置将为该区域提供更多空间。
- en: The starting velocity is a simple (*x*, *y*) tuple provided as an argument to
    the Vec2D helper class. As discussed previously, this will allow later methods
    to alter the velocity attribute using vector arithmetic. Note that the earth’s
    velocity is not (0, 0), but (0, -2.5). In real life and in the simulation, the
    moon is massive enough to affect the earth so that the center of gravity between
    the two is not at the center of the earth, but farther out. This will cause the
    earth turtle to wobble and shift positions in a distracting manner during the
    simulation. Because the moon will be in the upper part of the screen during simulation,
    shifting the earth downward a small amount each time step will dampen the wobbling.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 起始速度是一个简单的 (*x*, *y*) 元组，作为参数传递给 Vec2D 辅助类。如前所述，这将允许后续的方法通过向量运算来改变速度属性。需要注意的是，地球的速度不是
    (0, 0)，而是 (0, -2.5)。在现实世界中以及模拟中，月球足够大，会影响地球，使得地球和月球之间的重心不在地球的中心，而是在更远的地方。这会导致地球
    turtle 在模拟过程中出现摆动，并且位置发生干扰性的变化。由于月球将在模拟过程中出现在屏幕的上半部分，每个时间步长地球向下移动少许将减缓这种摆动。
- en: The last two arguments are the gravsys object you instantiated in the previous
    listing and the image variable for the earth. Passing gravsys means the earth
    turtle will be added to the list of bodies and included in the sim_loop() class
    method.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个参数是你在之前列表中实例化的 gravsys 对象和地球的图像变量。传递 gravsys 意味着地球 turtle 将被添加到物体列表中，并包含在
    sim_loop() 类方法中。
- en: Note that if you don’t want to use a lot of arguments when instantiating an
    object, you can change an object’s attributes after it’s created. For example,
    when defining the Body class, you could’ve set self.mass = 0, rather than using
    an argument for mass. Then, after instantiating the earth body, you could reset
    the mass value using earth.mass = 1000000.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果你不想在实例化对象时使用大量参数，可以在创建对象后更改其属性。例如，在定义 Body 类时，你本可以设置 self.mass = 0，而不是为质量使用一个参数。然后，在实例化地球对象后，你可以通过
    earth.mass = 1000000 来重设质量值。
- en: Because the earth wobbles a little, its orbital path will form a tight circle
    at the top of the planet. To hide it in the polar cap, use the turtle pencolor()
    method and set the line color to white.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 因为地球略有摆动，它的轨道路径会在行星的顶部形成一个紧密的圆圈。为了将其隐藏在极地帽中，可以使用 turtle 的 pencolor() 方法，并将线条颜色设置为白色。
- en: Finish the earth turtle with code that delays the start of the simulation and
    prevents the various turtles from flashing on the screen as the program first
    draws and resizes them. The getscreen() method returns the TurtleScreen object
    the turtle is drawing on. TurtleScreen methods can then be called for that object.
    In the same line, call the tracer() method that turns the turtle animation on
    or off and sets a delay for drawing updates. The *n* parameter determines the
    number of times the screen updates. A value of 0 means the screen updates with
    every loop; larger values progressively repress the updates. This can be used
    to accelerate the drawing of complex graphics, but at the cost of image quality.
    The second argument sets a delay value, in milliseconds, between screen updates.
    Increasing the delay slows the animation.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 使用代码使地球的海龟在模拟开始前延迟启动，并防止各种海龟在程序第一次绘制和调整大小时在屏幕上闪烁。getscreen() 方法返回海龟正在绘制的 TurtleScreen
    对象。然后，可以对该对象调用 TurtleScreen 方法。在同一行中，调用 tracer() 方法，该方法用于打开或关闭海龟动画并设置绘图更新的延迟。*n*
    参数决定了屏幕更新的次数。值为 0 表示每次循环屏幕都会更新；较大的值会逐渐抑制更新。这可以加速复杂图形的绘制，但会以图像质量为代价。第二个参数设置屏幕更新之间的延迟时间，单位为毫秒。增加延迟会减慢动画速度。
- en: You’ll build the moon turtle in a similar fashion to the one for the earth.
    Start by assigning a new variable to hold the moon image ➊. The moon’s mass is
    only a few percent of the earth’s mass, so use a much smaller value for the moon.
    I started out with a mass of around 16,000 and tweaked the value until the CSM’s
    flight path produced a visually pleasing loop around the moon.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你将以类似地球海龟的方式构建月球海龟。首先分配一个新变量来保存月球的图像 ➊。月球的质量只有地球质量的几分之一，因此要为月球使用一个较小的值。我开始时使用了大约16,000的质量，并调整该值，直到
    CSM 的飞行路径在月球周围产生了一个视觉上令人满意的循环。
- en: The moon’s starting position is controlled by the phase angle shown in [Figure
    6-3](ch06.xhtml#ch06fig3). Like this figure, the simulation you’re creating here
    is not to scale. Although the earth and moon images will have the correct relative
    sizes, the distance between the two is smaller than the actual distance, so the
    phase angle will need to be adjusted accordingly. I’ve reduced the distance in
    the model because space is big. Really big. If you want to show the simulation
    to scale and fit it all on your computer monitor, then you must settle for a ridiculously
    tiny earth and moon ([Figure 6-10](ch06.xhtml#ch06fig10)).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 月球的起始位置由[图6-3](ch06.xhtml#ch06fig3)中显示的相位角控制。像这个图一样，你在这里创建的模拟并非按比例显示。尽管地球和月球的图像将具有正确的相对大小，但它们之间的距离小于实际距离，因此需要相应地调整相位角。我在模型中减少了距离，因为太空非常广阔，真的非常大。如果你想要按比例显示模拟并将其完全适应你的计算机显示器，那么你只能接受一个极其小的地球和月球([图6-10](ch06.xhtml#ch06fig10))。
- en: '![Image](../images/fig06_10.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig06_10.jpg)'
- en: 'Figure 6-10: Earth and moon system at closest approach, or perigee, shown to
    scale'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-10：地球与月球系统在最近接近时，或称近地点，按比例显示
- en: To keep the two bodies recognizable, you’ll instead use larger, properly scaled
    images but reduce the distance between them ([Figure 6-11](ch06.xhtml#ch06fig11)).
    This configuration will be more relatable to the viewer and still allow you to
    replicate the free return trajectory.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让这两个天体仍然易于识别，你将使用更大的、经过适当缩放的图像，但减少它们之间的距离([图6-11](ch06.xhtml#ch06fig11))。这种配置对观众来说更加直观，同时仍然能够复制自由返回轨道。
- en: Because the earth and the moon are closer together in the simulation, the moon’s
    orbital velocity will be faster than in real life, as per Kepler’s second law
    of planetary motion. To compensate for this, the moon’s starting position is designed
    to reduce the phase angle compared to that shown in [Figure 6-3](ch06.xhtml#ch06fig3).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在模拟中地球和月球之间的距离较近，根据开普勒的第二定律，月球的轨道速度会比实际情况快。为了解决这个问题，月球的起始位置设计得比[图6-3](ch06.xhtml#ch06fig3)所示的相位角要小。
- en: '![Image](../images/fig06_11.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig06_11.jpg)'
- en: 'Figure 6-11: The earth and moon system in the simulation, with only the body
    sizes at the correct scale'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-11：模拟中的地球与月球系统，仅有正确比例的天体大小
- en: Finally, you’ll want the option to draw a line behind the moon to trace its
    orbit. Use the turtle pencolor() method and set the line color to gray.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你需要一个选项来在月球后面画一条线，以追踪它的轨道。使用海龟的 pencolor() 方法，并将线条颜色设置为灰色。
- en: '**NOTE**'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Parameters such as mass, initial position, and initial velocity are good candidates
    for global constants. Despite this, I chose to enter them as method arguments
    to avoid overloading the user with too many input variables at the start of the
    program.*'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '*例如质量、初始位置和初始速度等参数是全局常量的理想候选项。尽管如此，我选择将它们作为方法参数输入，以避免在程序开始时让用户承受过多的输入变量。*'
- en: '**Building a Custom Shape for the CSM**'
  id: totrans-171
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**为 CSM 构建自定义形状**'
- en: Now it’s time to instantiate a turtle object to represent the CSM. This requires
    a little more work than the last two objects.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候实例化一个 turtle 对象来表示 CSM 了。这比创建最后两个对象需要更多的工作。
- en: First, there’s no way to show the CSM at the same scale as the earth and the
    moon. To do that, you’d need *less than* a pixel, which is impossible. Plus, where’s
    the fun in that? So, once again, you’ll take liberties with scale and make the
    CSM large enough to be recognizable as an Apollo spacecraft.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，无法将 CSM 显示为与地球和月球相同的比例。要做到这一点，你需要*小于*一个像素，但这是不可能的。而且，这样做还有什么乐趣呢？所以，再次，你将不拘一格地调整比例，使
    CSM 足够大，以便能被识别为阿波罗飞船。
- en: Second, you won’t use an image for the CSM, as you did with the other two bodies.
    Because image shapes don’t automatically rotate when a turtle turns and you want
    to orient the CSM tail-first through most of its journey, you must instead customize
    your own shape.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，你不会像处理其他两个物体时那样使用图像来表示 CSM。因为图像形状在 turtle 转动时不会自动旋转，而你希望在大部分旅程中使 CSM 尾部朝前，所以必须自定义自己的形状。
- en: '[Listing 6-8](ch06.xhtml#ch06list8), still in main(), builds a representation
    of the CSM by drawing basic shapes, such as rectangles and triangles. You then
    combine these individual primitives into a final compound shape.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 6-8](ch06.xhtml#ch06list8)，仍然在 main() 中，通过绘制基本形状（如矩形和三角形）来构建 CSM 的表示。然后，你将这些单独的基本图形组合成一个最终的复合形状。'
- en: '[PRE11]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 6-8: Building a custom shape for the CSM turtle'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6-8：为 CSM turtle 构建自定义形状
- en: Name a variable csm and call the turtle Shape class. Pass it 'compound', indicating
    you want to build the shape using multiple components.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 命名一个变量 csm 并调用 turtle Shape 类。传递参数 'compound'，表示你希望使用多个组件构建形状。
- en: The first component will be the command module. Name a variable cm and assign
    it to a tuple of coordinate pairs, known as a *polygon type* in turtle. These
    coordinates build a triangle, as shown in [Figure 6-12](ch06.xhtml#ch06fig12).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个组件将是指令模块。命名一个变量 cm，并将其赋值为坐标对的元组，这些坐标在 turtle 中称为*多边形类型*。这些坐标构建一个三角形，如[图 6-12](ch06.xhtml#ch06fig12)所示。
- en: '![Image](../images/fig06_12.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/fig06_12.jpg)'
- en: 'Figure 6-12: CSM compound shape with coordinates for nozzle, service module,
    and command module'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-12：包含喷嘴、服务模块和指令模块坐标的 CSM 复合形状
- en: Add this triangle component to the csm shape using the addcomponent() method,
    called with dot notation. Pass it the cm variable, a fill color, and an outline
    color. Good fill colors are white, silver, gray, or red.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 addcomponent() 方法将这个三角形组件添加到 csm 形状中，方法通过点号符号调用。传递 cm 变量、填充颜色和轮廓颜色。合适的填充颜色包括白色、银色、灰色或红色。
- en: Repeat this general process for the service module rectangle. Set the outline
    color to black when you add the component to delineate the service and command
    modules (see [Figure 6-12](ch06.xhtml#ch06fig12)).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 对服务模块矩形重复此一般过程。在将组件添加到服务和指令模块时，设置轮廓颜色为黑色，以便区分服务模块和指令模块（参见[图 6-12](ch06.xhtml#ch06fig12)）。
- en: Use another triangle for the nozzle, also called the *engine bell*. Add the
    component and then register the new csm compound shape to the screen. Pass the
    method a name for the shape and then the variable referencing the shape.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 使用另一个三角形表示喷嘴，也称为*发动机喇叭*。添加组件后，将新的 csm 复合形状注册到屏幕上。传递方法时需要提供形状的名称以及引用该形状的变量。
- en: '**Creating the CSM, Starting the Simulation, and Calling main()**'
  id: totrans-185
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**创建 CSM，启动仿真并调用 main()**'
- en: '[Listing 6-9](ch06.xhtml#ch06list9) completes the main() function by instantiating
    a turtle for the CSM and calling the simulation loop that runs the time steps.
    It then calls main() if the program is run in stand-alone mode.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 6-9](ch06.xhtml#ch06list9) 完成 main() 函数，通过实例化一个 CSM 的 turtle 并调用运行时间步骤的仿真循环。然后，如果程序在独立模式下运行，它将调用
    main()。'
- en: '[PRE12]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 6-9: Instantiating a CSM turtle, calling the simulation loop and main()'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6-9：实例化 CSM turtle，调用仿真循环和 main()
- en: Create a turtle named ship to represent the CSM. The starting position is an
    (*x*, *y*) tuple that places the CSM in a parking orbit directly below the earth
    on the screen. I first approximated the proper height for the parking orbit (R[0]
    in [Figure 6-3](ch06.xhtml#ch06fig3)) and then fine-tuned it by repeatedly running
    the simulation. Note that you use the constants assigned at the start of the program,
    rather than actual values. This is to make it easier for you to experiment with
    these values later.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为ship的海龟来表示指令模块。起始位置是一个(*x*, *y*)元组，将指令模块放置在屏幕上地球正下方的停泊轨道。我首先大致估算了停泊轨道的合适高度（[图6-3](ch06.xhtml#ch06fig3)中的R[0]），然后通过反复运行仿真进行微调。注意，你使用的是程序开始时分配的常量，而非实际值。这是为了方便你以后实验这些值。
- en: The velocity argument (Vo_X, Vo_Y) represents the speed of the CSM at the moment
    the Saturn third stage stops firing during translunar injection. All the thrust
    is in the *x* direction, but the earth’s gravity will cause the flight path to
    immediately curve upward. Like the R[0] parameter, a best-guess velocity was input
    and refined through simulation. Note that the velocity is a tuple input using
    the Vec2D helper class, which allows later methods to alter the velocity using
    vector arithmetic.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 速度参数（Vo_X, Vo_Y）表示指令模块在土星第三阶段停止点火时的速度，即在向月球注入过程中。所有的推力都朝*X*方向，但地球的引力将使飞行轨迹立刻向上弯曲。像R[0]参数一样，一个最佳猜测的速度被输入并通过仿真进行优化。注意，速度是一个使用Vec2D辅助类输入的元组，这使得后续方法能够通过向量运算改变速度。
- en: Next, set the size of the ship turtle using the shapesize() method. Then set
    its path color to white so it will match the ship color. Other attractive colors
    are silver, gray, and red.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用shapesize()方法设置飞船海龟的大小。然后将其路径颜色设置为白色，这样它就能与飞船的颜色匹配。其他吸引人的颜色有银色、灰色和红色。
- en: Control the screen updates with the getscreen() and tracer() methods, described
    in [Listing 6-7](ch06.xhtml#ch06list7), and then set the ship’s heading to 90
    degrees, which will point it due east on the screen.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[getscreen()](ch06.xhtml#ch06list7)和tracer()方法控制屏幕更新，然后将飞船的航向设置为90度，使其在屏幕上指向正东方。
- en: That completes the body objects. Now all that’s left is to launch the simulation
    loop, using the gravsys object’s sim_loop() method. Back in the global space,
    finish the program with the code to run the program as an imported module or in
    stand-alone mode.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了天体对象的定义。现在剩下的就是启动仿真循环，使用gravsys对象的sim_loop()方法。在全局空间中，使用代码运行程序，可以作为导入模块或独立模式运行。
- en: 'As the program is currently written, you’ll have to manually close the Turtle
    Graphics window. If you want the window to close automatically, add the following
    command as the last line in main():'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 按照当前的程序，你必须手动关闭Turtle Graphics窗口。如果你希望窗口自动关闭，可以在main()函数的最后一行添加以下命令：
- en: '[PRE13]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '***Running the Simulation***'
  id: totrans-196
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行仿真***'
- en: When you first run the simulation, the pen will be up, and none of the bodies
    will draw their orbital path ([Figure 6-13](ch06.xhtml#ch06fig13)). The CSM will
    smoothly rotate and reorient itself as it approaches the moon and then the earth.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当你第一次运行仿真时，笔尖会抬起，且所有天体的轨道路径不会绘制出来（[图6-13](ch06.xhtml#ch06fig13)）。指令模块会平滑地旋转并重新定位自己，接近月球然后是地球。
- en: '![Image](../images/fig06_13.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/fig06_13.jpg)'
- en: 'Figure 6-13: The simulation run with the pen up and the CSM approaching the
    moon'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-13：仿真运行时，笔尖抬起，指令模块接近月球
- en: 'To trace the journey of the CSM, go to the definition of the Body class and
    uncomment this line:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 要追踪指令模块的轨迹，去到Body类的定义并取消注释这行代码：
- en: '[PRE14]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You should now see the figure-eight shape of the free return trajectory ([Figure
    6-14](ch06.xhtml#ch06fig14)).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该能看到自由返回轨迹的“8字形”轨迹（[图6-14](ch06.xhtml#ch06fig14)）。
- en: '![Image](../images/fig06_14.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/fig06_14.jpg)'
- en: 'Figure 6-14: The simulation run with the pen down and the CM at splashdown
    in the Pacific'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-14：仿真运行时，笔尖下压，指令舱在太平洋迫降
- en: You can also simulate *gravity propulsion*—otherwise known as a *slingshot maneuver*—by
    setting the Vo_X velocity variable to a value between 520 and 540 and rerunning
    the simulation. This will cause the CSM to pass behind the moon and steal some
    of its momentum, increasing the ship’s velocity and deflecting its flight path
    ([Figure 6-15](ch06.xhtml#ch06fig15)). Bye-bye Apollo 8!
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以模拟*引力推进*—也叫做*弹弓机动*—通过将Vo_X速度变量设置为520到540之间的某个值，然后重新运行仿真。这将导致指令模块绕月球飞行，并窃取一些月球的动量，从而增加飞船的速度并偏转飞行路径（[图6-15](ch06.xhtml#ch06fig15)）。拜拜，阿波罗8号！
- en: '![Image](../images/fig06_15.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/fig06_15.jpg)'
- en: 'Figure 6-15: The gravitational slingshot maneuver achieved with Vo_X = 520'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-15：通过 Vo_X = 520 实现的引力弹弓机动
- en: This project should teach you that space travel is a game of seconds and centimeters.
    If you continue to experiment with value of the Vo_X variable, you’ll find that
    even small changes can doom the mission. If you don’t crash into the moon, you’ll
    reenter the earth’s atmosphere too steeply or miss it entirely!
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目应该教会你，太空旅行是与秒与厘米赛跑的游戏。如果你继续尝试不同的 Vo_X 变量值，你会发现即便是微小的变化也可能让任务失败。如果你没有撞向月球，你可能会过于陡峭地重新进入地球大气层，或者完全错过月球！
- en: The nice thing about simulations is that, if you fail, you can live to try again.
    NASA runs countless simulations for all its proposed missions. The results help
    NASA choose between competing flight plans, find the most efficient routes, decide
    what to do if things go wrong, and much more.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟的好处在于，如果失败了，你仍然可以继续尝试。NASA 为其所有提出的任务进行无数次模拟。模拟结果帮助 NASA 在多个飞行计划中做出选择，找到最有效的航线，决定在出现问题时该怎么做，以及更多内容。
- en: Simulations are especially important for outer solar system exploration, where
    great distances make real-time communications impossible. The timing of key events,
    such as firing thrusters, taking photographs, or dropping probes, are all preprogrammed
    based on meticulous simulations.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟对于外太阳系探索尤为重要，因为巨大的距离使得实时通信变得不可能。关键事件的时间安排，如喷射推进器、拍摄照片或释放探测器，都是基于精确模拟进行预编程的。
- en: '**Summary**'
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter, you learned how to use the turtle drawing program, including
    how to make customized turtle shapes. You also learned how to use Python to simulate
    gravity and solve the famous three-body problem.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何使用 turtle 绘图程序，包括如何制作自定义的 turtle 形状。你还学习了如何使用 Python 模拟引力并解决著名的三体问题。
- en: '**Further Reading**'
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**进一步阅读**'
- en: '*Apollo 8: The Thrilling Story of the First Mission to the Moon* (Henry Holt
    and Co., 2017), by Jeffrey Kluger, covers the historic Apollo 8 mission from its
    unlikely beginning to its “unimaginable triumph.”'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '*《阿波罗 8号：第一次登月任务的惊心动魄故事》*（亨利·霍尔特出版社，2017年），作者杰弗里·克鲁格，讲述了历史性的阿波罗8号任务，从其不太可能的起点到其“难以想象的胜利”。'
- en: An online search for *PBS Nova How Apollo 8 Left Earth Orbit* should return
    a short video clip on the Apollo 8 translunar injection maneuver, marking the
    first time humans left the earth’s orbit and traveled to another celestial body.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在线搜索 *PBS Nova How Apollo 8 Left Earth Orbit* 应该能返回一个简短的视频片段，讲解阿波罗8号的月际转移机动，标志着人类首次离开地球轨道并前往另一个天体。
- en: '*NASA Voyager 1 & 2 Owner’s Workshop Manual* (Haynes, 2015), by Christopher
    Riley, Richard Corfield, and Philip Dolling, provides interesting background on
    the three-body problem and Michael Minovitch’s many contributions to space travel.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '*《NASA 旅行者1号与2号用户手册》*（海恩斯出版社，2015年），作者克里斯托弗·赖利、理查德·科菲尔德和菲利普·多林，提供了关于三体问题以及迈克尔·米诺维奇对太空旅行贡献的有趣背景。'
- en: The Wikipedia *Gravity assist* page contains lots of interesting animations
    of various gravity-assist maneuvers and historic planetary flybys that you can
    reproduce with your Apollo 8 simulation.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 维基百科上的 *引力辅助* 页面包含了许多有趣的引力辅助机动动画和历史性的行星飞掠，你可以在阿波罗8号模拟中重现这些内容。
- en: '*Chasing New Horizons: Inside the Epic First Mission to Pluto* (Picador, 2018),
    by Alan Stern and David Grinspoon, documents the importance—and ubiquity—of simulations
    in NASA missions.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '*《追寻新视野：深入探秘第一次冯向冥王星的史诗任务》*（皮卡多出版社，2018年），作者艾伦·斯特恩和大卫·格林斯普恩，记录了模拟在 NASA 任务中的重要性和普及性。'
- en: '**Practice Project: Simulating a Search Pattern**'
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**实践项目：模拟搜索模式**'
- en: In [Chapter 1](ch01.xhtml), you used Bayes’ rule to help the Coast Guard search
    for a sailor lost at sea. Now, use turtle to design a helicopter search pattern
    to find the missing sailor. Assume the spotters can see for 20 pixels and make
    the spacing between long tracks 40 pixels (see [Figure 6-16](ch06.xhtml#ch06fig16)).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.xhtml)中，你使用贝叶斯定理帮助海岸警卫队寻找失踪的海员。现在，使用 turtle 设计一个直升机搜索模式，以寻找失踪的海员。假设观察员能够看到
    20 像素远的区域，并且长航迹之间的间隔为 40 像素（见[图 6-16](ch06.xhtml#ch06fig16)）。
- en: '![Image](../images/fig06_16.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/fig06_16.jpg)'
- en: 'Figure 6-16: Two screenshots from practice_search_pattern.py'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-16：来自 practice_search_pattern.py 的两个截图
- en: For fun, add a helicopter turtle and orient it properly for each pass. Also
    add a randomly positioned sailor turtle, stop the simulation when the sailor is
    found, and post the joyous news to the screen ([Figure 6-17](ch06.xhtml#ch06fig17)).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 为了好玩，添加一个直升机 turtle，并在每次飞行时正确调整它的方向。还可以添加一个随机位置的海员 turtle，在找到海员时停止模拟，并在屏幕上显示喜讯（见[图
    6-17](ch06.xhtml#ch06fig17)）。
- en: '![Image](../images/fig06_17.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig06_17.jpg)'
- en: 'Figure 6-17: The sailor is spotted in practice_search_pattern.py.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-17：海员在 *practice_search_pattern.py* 中被发现。
- en: You can find a solution, *practice_search_pattern.py*, in the appendix. I’ve
    included a digital version, along with helicopter and sailor images, in the *Chapter_6*
    folder, downloadable from the book’s website.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在附录中找到解决方案，*practice_search_pattern.py*。我已将数字版本和直升机、海员图像一并包含在 *Chapter_6*
    文件夹中，可以从书籍网站下载。
- en: '**Practice Project: Start Me Up!**'
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**练习项目：启动我！**'
- en: Rewrite *apollo_8_free_return.py* so that a moving moon approaches a stationary
    CSM, causes the CSM to start moving, and then swings it up and away. For fun,
    orient the CSM turtle so that it always points in the direction of travel, as
    if under its own propulsion (see [Figure 6-18](ch06.xhtml#ch06fig18)).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 重写 *apollo_8_free_return.py* 使得移动的月球接近静止的指令舱，导致指令舱开始移动，然后将其甩向远方。为了增加趣味，调整指令舱的方向，使其始终指向前进的方向，仿佛在自身的推动下行进（见
    [图6-18](ch06.xhtml#ch06fig18)）。
- en: '![Image](../images/fig06_18.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig06_18.jpg)'
- en: 'Figure 6-18: The moon approaches a stationary CSM (left) and then flings it
    to the stars (right).'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-18：月球接近静止的指令舱（左），然后将其抛向星空（右）。
- en: For a solution, see *practice_grav_assist_stationary.py* in the appendix or
    download it from *[https://nostarch.com/real-world-python/](https://nostarch.com/real-world-python/)*.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如需解决方案，请参见附录中的 *practice_grav_assist_stationary.py*，或从 *[https://nostarch.com/real-world-python/](https://nostarch.com/real-world-python/)*
    下载。
- en: '**Practice Project: Shut Me Down!**'
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**练习项目：关闭我！**'
- en: Rewrite *apollo_8_free_return.py* so that the CSM and moon have crossing orbits,
    the CSM passes before the moon, and the moon’s gravity slows the CSM’s progress
    to a crawl while changing its direction by about 90 degrees. As in the previous
    practice project, have the CSM point in the direction of travel (see [Figure 6-19](ch06.xhtml#ch06fig19)).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 重写 *apollo_8_free_return.py* 使得指令舱和月球的轨道交叉，指令舱在月球之前通过，而月球的引力减缓指令舱的速度，并使其改变方向约90度。与之前的练习项目一样，让指令舱始终指向行进的方向（见
    [图6-19](ch06.xhtml#ch06fig19)）。
- en: '![Image](../images/fig06_19.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig06_19.jpg)'
- en: 'Figure 6-19: The moon and CSM cross orbits, and the moon slows and turns the
    CSM.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-19：月球与指令舱交叉轨道，月球减慢并转向指令舱。
- en: For a solution, see *practice_grav_assist_intersecting.py* in the appendix or
    download it from *[https://nostarch.com/real-world-python/](https://nostarch.com/real-world-python/)*.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如需解决方案，请参见附录中的 *practice_grav_assist_intersecting.py*，或从 *[https://nostarch.com/real-world-python/](https://nostarch.com/real-world-python/)*
    下载。
- en: '**Challenge Project: True-Scale Simulation**'
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**挑战项目：真实比例模拟**'
- en: Rewrite *apollo_8_free_return.py* so that the earth, the moon, and the distance
    between them are all accurately scaled, as shown in [Figure 6-10](ch06.xhtml#ch06fig10).
    Use colored circles, rather than images, for the earth and the moon and make the
    CSM invisible (just draw a line behind it). Use [Table 6-2](ch06.xhtml#ch06table2)
    to help determine the relative sizes and distances to use.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 重写 *apollo_8_free_return.py* 使得地球、月球及其之间的距离都能准确缩放，如 [图6-10](ch06.xhtml#ch06fig10)
    所示。使用彩色圆圈代替图像表示地球和月球，且使指令舱不可见（只绘制其后方的线条）。使用 [表6-2](ch06.xhtml#ch06table2) 来帮助确定相对的大小和距离。
- en: '**Table 6-2:** Length Parameters for the Earth-Moon System'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '**表6-2：地月系统的长度参数**'
- en: '| Earth radius | 6,371 km |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| 地球半径 | 6,371 公里 |'
- en: '| Moon radius | 1,737 km |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| 月球半径 | 1,737 公里 |'
- en: '| Earth-moon distance | 356,700 km* |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| 地月距离 | 356,700 公里* |'
- en: '*Closest approach during Apollo 8 mission in December 1968'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '*阿波罗8号任务在1968年12月的最接近接触'
- en: '**Challenge Project: The Real Apollo 8**'
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**挑战项目：真实的阿波罗8号**'
- en: Rewrite *apollo_8_free_return.py* so that it simulates the entire Apollo 8 mission,
    not just the free return component. The CSM should orbit the moon 10 times before
    returning to the earth.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 重写 *apollo_8_free_return.py* 使其模拟整个阿波罗8号任务，而不仅仅是自由返回组件。指令舱应绕月球轨道飞行10圈后再返回地球。
