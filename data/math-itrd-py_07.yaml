- en: '5'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '5'
- en: TRANSFORMING SHAPES WITH GEOMETRY
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 用几何学变换形状
- en: '*In the teahouse one day Nasrudin announced he was selling his house. When
    the other patrons asked him to describe it, he brought out a brick. “It’s just
    a collection of these.”—Idries Shah*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*有一天，在茶馆里，纳斯鲁丁宣布他要卖掉自己的房子。当其他顾客问他如何描述房子时，他拿出了一个砖块。“它只是这些的集合。”——伊德里斯·沙阿*'
- en: '![image](../images/fintro-01.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fintro-01.jpg)'
- en: In geometry class, everything you learn about involves dimensions in space using
    shapes. You typically start by examining one-dimensional lines and two-dimensional
    circles, squares, or triangles, then move on to three-dimensional objects like
    spheres and cubes. These days, creating geometric shapes is easy with technology
    and free software, though manipulating and changing the shapes you create can
    be more of a challenge.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在几何课上，你学到的所有内容都涉及通过形状来表示空间中的维度。通常你会从一维的线条和二维的圆、方形或三角形开始，然后转向三维物体，如球体和立方体。现在，借助技术和免费的软件，创建几何形状变得简单，但操控和改变这些形状可能会更具挑战性。
- en: In this chapter, you’ll learn how to manipulate and transform geometric shapes
    using the Processing graphics package. You’ll start with basic shapes like circles
    and triangles, which will allow you to work with complicated shapes like fractals
    and cellular automata in later chapters. You will also learn how to break down
    some complicated-looking designs into simple components.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何使用Processing图形包操作和变换几何形状。你将从基本形状如圆形和三角形开始，这将为你在后续章节中处理更复杂的形状如分形和细胞自动机奠定基础。你还将学会如何将一些看似复杂的设计分解为简单的组件。
- en: DRAWING A CIRCLE
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绘制一个圆
- en: Let’s start with a simple one-dimensional circle. Open a new sketch in Processing
    and save it as *geometry.pyde*. Then enter the code in [Listing 5-1](ch05.xhtml#ch05list1)
    to create a circle on the screen.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个简单的二维圆开始。在Processing中打开一个新草图并保存为*geometry.pyde*。然后输入[Listing 5-1](ch05.xhtml#ch05list1)中的代码，在屏幕上绘制一个圆。
- en: '*geometry.pyde*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*geometry.pyde*'
- en: 'def setup():'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 'def setup():'
- en: size(600,600)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: size(600,600)
- en: 'def draw():'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 'def draw():'
- en: ellipse(200,100,20,20)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: ellipse(200,100,20,20)
- en: '*Listing 5-1: Drawing a circle*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 5-1: 绘制一个圆*'
- en: Before we draw the shape, we first define the size of our sketchbook, known
    as the *coordinate plane*. In this example, we use the size() function to say
    that our grid will be 600 pixels wide and 600 pixels tall.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在绘制形状之前，我们首先定义草图本的大小，也就是*坐标平面*。在这个例子中，我们使用size()函数来表示我们的网格将是600像素宽，600像素高。
- en: With our coordinate plane set up, we then use the drawing function ellipse()
    to create our circle on this plane. The first two parameters, 200 and 100, show
    where the center of the circle is located. Here, 200 is the x-coordinate and the
    second number, 100, is the y-coordinate of this circle’s center, which places
    it at (200,100) on the plane.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好坐标平面后，我们使用绘图函数ellipse()在平面上创建一个圆。前两个参数200和100表示圆心的位置。这里，200是x坐标，第二个数字100是圆心的y坐标，将圆心定位在平面上的(200,100)。
- en: The last two parameters determine the width and height of the shape in pixels.
    In the example, the shape is 20 pixels wide and 20 pixels tall. Because the two
    parameters are the same, it means that the points on the circumference are equidistant
    from the center, forming a perfectly round circle.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个参数决定了形状的宽度和高度，以像素为单位。在这个例子中，形状的宽度和高度都是20像素。因为这两个参数相同，意味着圆周上的点到圆心的距离是相等的，从而形成了一个完美的圆形。
- en: Click the **Run** button (it looks like a play symbol), and a new window with
    a small circle should open, like in [Figure 5-1](ch05.xhtml#ch05fig1).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**运行**按钮（它看起来像一个播放符号），一个带有小圆的新窗口应该会打开，就像在[图 5-1](ch05.xhtml#ch05fig1)中一样。
- en: '![image](../images/f078-01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f078-01.jpg)'
- en: '*Figure 5-1: The output of [Listing 5-1](ch05.xhtml#ch05list1) showing a small
    circle*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-1: [Listing 5-1](ch05.xhtml#ch05list1) 显示的小圆的输出*'
- en: Processing has a number of functions you can use to draw shapes. Check out the
    full list at [*https://processing.org/reference/*](https://processing.org/reference/)
    to explore other shape functions.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Processing提供了多个可以用来绘制形状的函数。请查看完整列表：[*https://processing.org/reference/*](https://processing.org/reference/)，探索其他形状函数。
- en: Now that you know how to draw a circle in Processing, you’re almost ready to
    use these simple shapes to create dynamic, interactive graphics. In order to do
    that, you’ll first need to learn about location and transformations. Let’s start
    with location.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何在Processing中绘制圆形，接下来，你几乎准备好利用这些简单的形状来创建动态的、交互式的图形了。为了做到这一点，你首先需要了解位置和变换。我们先从位置开始。
- en: SPECIFYING LOCATION USING COORDINATES
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用坐标指定位置
- en: 'In [Listing 5-1](ch05.xhtml#ch05list1), we used the first two parameters of
    the ellipse() function to specify our circle’s location on the grid. Likewise,
    each shape we create using Processing needs a location that we specify with the
    coordinate system, where each point on the graph is represented by two numbers:
    (x,y). In traditional math graphs, the origin (where x=0 and y=0) is at the center
    of the graph, as shown in [Figure 5-2](ch05.xhtml#ch05fig2).'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在[代码清单 5-1](ch05.xhtml#ch05list1)中，我们使用ellipse()函数的前两个参数指定了圆形在网格上的位置。同样，每个我们使用
    Processing 创建的形状也需要一个位置，我们通过坐标系统指定，在该系统中，图上的每个点由两个数字表示：(x,y)。在传统的数学图形中，原点（即x=0且y=0的位置）位于图形的中心，如[图
    5-2](ch05.xhtml#ch05fig2)所示。
- en: '![image](../images/f079-01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f079-01.jpg)'
- en: '*Figure 5-2: A traditional coordinate system with the origin in the center*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-2：传统坐标系，原点位于中心*'
- en: In computer graphics, however, the coordinate system is a little different.
    Its origin is in the top-left corner of the screen so that x and y increase as
    you move right and down, respectively, as you can see in [Figure 5-3](ch05.xhtml#ch05fig3).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在计算机图形学中，坐标系稍有不同。它的原点位于屏幕的左上角，因此 x 和 y 分别在向右和向下移动时增加，正如在[图 5-3](ch05.xhtml#ch05fig3)中所示。
- en: '![image](../images/f079-02.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f079-02.jpg)'
- en: '*Figure 5-3: The coordinate system for computer graphics, with the origin in
    the top-left corner*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-3：计算机图形学的坐标系统，原点位于左上角*'
- en: Each coordinate on this plane represents a pixel on the screen. As you can see,
    this means you don’t have to deal with negative coordinates. We’ll use functions
    to transform and translate increasingly complex shapes around this coordinate
    system.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 该平面上的每个坐标表示屏幕上的一个像素。如你所见，这意味着你无需处理负坐标。我们将使用函数在这个坐标系统中变换和移动越来越复杂的形状。
- en: Drawing a single circle was fairly easy, but drawing multiple shapes can get
    complicated pretty quickly. For example, imagine drawing a design like the one
    shown in [Figure 5-4](ch05.xhtml#ch05fig4).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制一个单一的圆形相当简单，但绘制多个形状则很快变得复杂。例如，想象一下绘制如[图 5-4](ch05.xhtml#ch05fig4)所示的设计。
- en: '![image](../images/f080-01.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f080-01.jpg)'
- en: '*Figure 5-4: A circle made of circles*'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-4：由圆形构成的圆*'
- en: Specifying the size and location of each individual circle and spacing them
    out perfectly evenly would involve entering many lines of similar code. Fortunately,
    you don’t really need to know the absolute x- and y-coordinates of each circle
    to do this. With Processing, you can easily place objects wherever you want on
    the grid.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 指定每个圆形的大小和位置，并将它们均匀地间隔开来，将涉及输入许多相似的代码行。幸运的是，你其实不需要知道每个圆形的绝对 x 和 y 坐标就可以做到这一点。使用
    Processing，你可以轻松地将物体放置在网格上的任意位置。
- en: Let’s see how you can do this using a simple example to start.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个简单的例子来看看如何开始做这个。
- en: TRANSFORMATION FUNCTIONS
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变换函数
- en: You might remember doing transformations with pencil and paper in geometry class,
    which you performed on a collection of points to laboriously move a shape around.
    It’s much more fun when you let a computer do the transforming. In fact, there
    wouldn’t be any computer graphics worth looking at without transformations! Geometric
    transformations like translation and rotation let you change where and how your
    objects appear without altering the objects themselves. For example, you can use
    transformations to move a triangle to a different location or spin it around without
    changing its shape. Processing has a number of built-in transformation functions
    that make it easy to translate and rotate objects.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得在几何课上用铅笔和纸做过变换，你需要对一组点进行操作，费力地移动一个形状。让计算机来进行变换则有趣得多。事实上，没有变换，就不会有任何值得一看的计算机图形！像平移和旋转这样的几何变换让你在不改变物体本身的情况下，改变物体的出现位置和方式。例如，你可以使用变换将三角形移动到不同的位置，或者旋转它而不改变其形状。Processing
    提供了许多内建的变换函数，方便你平移和旋转物体。
- en: TRANSLATING OBJECTS WITH TRANSLATE()
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用TRANSLATE()平移对象
- en: To *translate* means to move a shape on a grid so that all points of the shape
    move in the same direction and the same distance. In other words, translations
    let you move a shape on a grid without changing the shape itself and without tilting
    it in the slightest.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*平移*意味着在网格上移动一个形状，使形状的所有点都沿相同方向和相同距离移动。换句话说，平移让你在不改变形状本身，也不倾斜形状的情况下，移动形状。'
- en: Translating an object in math class involves manually changing the coordinates
    of all the points in the object. But in Processing, you translate an object by
    moving the *grid* itself, while the object’s coordinates stay the same! For an
    example of this, let’s put a rectangle on the screen. Revise your existing code
    in *geometry.pyde* with the code in [Listing 5-2](ch05.xhtml#ch05list2).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学课上，平移一个物体需要手动更改物体中所有点的坐标。但在 Processing 中，你通过移动 *网格* 本身来平移物体，而物体的坐标保持不变！为了演示这一点，让我们在屏幕上放一个矩形。请根据
    [列表 5-2](ch05.xhtml#ch05list2) 中的代码修改你现有的 *geometry.pyde* 代码。
- en: '*geometry.pyde*'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*geometry.pyde*'
- en: 'def setup():'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 'def setup():'
- en: size(600,600)
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: size(600,600)
- en: 'def draw():'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 'def draw():'
- en: rect(20,40,50,30)
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: rect(20,40,50,30)
- en: '*Listing 5-2: Drawing a rectangle to translate*'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-2：绘制一个矩形以进行平移*'
- en: Here, we use the rect() function to draw the rectangle. The first two parameters
    are the x- and y-coordinates telling Processing where the top-left corner of the
    rectangle should be. The third and fourth parameters indicate its width and its
    height, respectively.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们使用 rect() 函数来绘制矩形。前两个参数是 x 和 y 坐标，告诉 Processing 矩形的左上角应该在哪里。第三个和第四个参数分别表示矩形的宽度和高度。
- en: Run this code, and you should see the rectangle shown in [Figure 5-5](ch05.xhtml#ch05fig5).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码，你应该看到 [图 5-5](ch05.xhtml#ch05fig5) 中显示的矩形。
- en: '![image](../images/f081-01.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f081-01.jpg)'
- en: '*Figure 5-5: The default coordinate setup with the origin at the top left*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-5：原点位于左上角的默认坐标设置*'
- en: '**NOTE**'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: In these examples, I’m showing the grid for reference, but you won’t see it
    on your screen.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些示例中，我显示了网格以供参考，但你在屏幕上是看不到它的。
- en: Now let’s tell Processing to translate the rectangle using the code in [Listing
    5-3](ch05.xhtml#ch05list3). Notice that we don’t change the coordinates of the
    rectangle.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们告诉 Processing 使用 [列表 5-3](ch05.xhtml#ch05list3) 中的代码来平移矩形。注意，我们并没有改变矩形的坐标。
- en: '*geometry.pyde*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*geometry.pyde*'
- en: 'def setup():'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 'def setup():'
- en: size(600,600)
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: size(600,600)
- en: 'def draw():'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 'def draw():'
- en: translate(50,80);
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: translate(50,80);
- en: rect(50,100,100,60)
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: rect(50,100,100,60)
- en: '*Listing 5-3: Translating the rectangle*'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-3：平移矩形*'
- en: 'Here, we use translate() to move the rectangle. We provide two parameters:
    the first tells Processing how far to move the grid in the horizontal (x) direction,
    and the second parameter is for how far to move the grid vertically, in the y-direction.
    So translate(50,80) should move the entire grid 50 pixels to the right and 80
    pixels down, as shown in [Figure 5-6](ch05.xhtml#ch05fig6).'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 translate() 来移动矩形。我们提供两个参数：第一个告诉 Processing 网格水平（x）方向上应该移动多少距离，第二个参数表示网格在垂直（y）方向上应该移动的距离。所以
    translate(50,80) 应该将整个网格向右移动 50 像素并向下移动 80 像素，如 [图 5-6](ch05.xhtml#ch05fig6) 所示。
- en: '![image](../images/f082-01.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f082-01.jpg)'
- en: '*Figure 5-6: Translating a rectangle by moving the grid 50 pixels to the right
    and 80 pixels down*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-6：通过将网格右移 50 像素并向下移动 80 像素来平移矩形*'
- en: Very often it’s useful (and easier!) to have the origin (0,0) in the center
    of the canvas. You can use translate() to easily move the origin to the center
    of your grid. You can also use it to change the width and height of your canvas
    if you want it bigger or smaller. Let’s explore Processing’s built-in width and
    height variables, which let you update the size of your canvas without having
    to change the numbers manually. To see this in action, update the existing code
    in [Listing 5-3](ch05.xhtml#ch05list3) so it looks like [Listing 5-4](ch05.xhtml#ch05list4).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 很多时候，将原点（0,0）放在画布中心是很有用的（而且更简单！）。你可以使用 translate() 函数轻松地将原点移动到网格的中心。你也可以用它来改变画布的宽度和高度，如果你希望它更大或更小的话。接下来，我们来探索
    Processing 内置的宽度和高度变量，它们可以让你在不手动更改数值的情况下更新画布的大小。为了看到效果，更新 [列表 5-3](ch05.xhtml#ch05list3)
    中的现有代码，使其看起来像 [列表 5-4](ch05.xhtml#ch05list4)。
- en: '*geometry.pyde*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*geometry.pyde*'
- en: 'def setup():'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 'def setup():'
- en: size(600,600)
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: size(600,600)
- en: 'def draw():'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 'def draw():'
- en: translate(width/2, height/2)
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: translate(width/2, height/2)
- en: rect(50,100,100,60)
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: rect(50,100,100,60)
- en: '*Listing 5-4: Using the width and height variables to translate the rectangle*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-4：使用宽度和高度变量来平移矩形*'
- en: Whatever numbers you put in the size declaration in the setup() function will
    become the “width” and “height” of the canvas. In this case, because I used size(600,600),
    they’re both 600 pixels. When we change the translate() line to translate(width/2,
    height/2) using variables instead of specific numbers, we tell Processing to move
    the location (0,0) to the center of the display window, no matter what the size
    is. This means that if you change the size of the window, Processing will automatically
    update width and height, and you won’t have to go through all your code and change
    the numbers manually.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在setup()函数中的size声明里输入的任何数字都会变成画布的“宽度”和“高度”。在这个例子中，因为我使用了size(600,600)，它们都是600像素。当我们将translate()这一行更改为translate(width/2,
    height/2)，使用变量而不是具体数字时，我们告诉Processing将位置(0,0)移到显示窗口的中心，不管窗口大小如何。这意味着如果你改变窗口的大小，Processing会自动更新宽度和高度，你就不需要去修改所有代码中的数字了。
- en: Run the updated code, and you should see something like [Figure 5-7](ch05.xhtml#ch05fig7).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 运行更新后的代码，你应该能看到类似于[图 5-7](ch05.xhtml#ch05fig7)的效果。
- en: '![image](../images/f083-01.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f083-01.jpg)'
- en: '*Figure 5-7: The grid is translated to the center of the screen*.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-7：网格被平移到屏幕中央*。'
- en: Notice that the origin is still labeled as (0,0), which shows that we haven’t
    actually moved the origin point but rather the entire coordinate plane itself
    so that the origin point falls in the middle of our canvas.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，原点仍然标记为(0,0)，这表明我们实际上并没有移动原点，而是移动了整个坐标平面，使得原点位于画布的中央。
- en: ROTATING OBJECTS WITH ROTATE()
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用ROTATE()旋转物体
- en: In geometry, *rotation* is a kind of transformation that turns an object around
    a center point, as if it’s turning on an axis. The rotate() function in Processing
    rotates the grid around the origin (0,0). It takes a single number as its argument
    to specify the angle at which you want to rotate the grid around the point (0,0).
    The units for the rotation angle are radians, which you learn about in precalculus
    class. Instead of using 360 degrees to do a full rotation, we can use 2π (around
    6.28) radians. If you think in degrees, like I do, you can use the radians() function
    to easily convert your degrees to radians so you don’t have to do the math yourself.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在几何学中，*旋转*是一种变换，它将物体围绕一个中心点旋转，就像绕轴旋转一样。Processing中的rotate()函数会绕原点(0,0)旋转网格。它接受一个数字作为参数，指定你希望围绕点(0,0)旋转的角度。旋转角度的单位是弧度，你可以在预备数学课程中学习到这一点。我们可以使用2π（约为6.28）弧度来完成一次旋转，而不是使用360度。如果你像我一样习惯使用度数，可以使用radians()函数轻松地将度数转换为弧度，这样你就不必自己做数学计算了。
- en: To see how the rotate() function works, enter the code shown in [Figure 5-8](ch05.xhtml#ch05fig8)
    into your existing sketch by replacing the translate() code inside the draw()
    function with each of these examples, and then run them. [Figure 5-8](ch05.xhtml#ch05fig8)
    shows the results.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看rotate()函数是如何工作的，将[图 5-8](ch05.xhtml#ch05fig8)中显示的代码输入到现有的草图中，通过用这些示例替换draw()函数中的translate()代码，然后运行它们。[图
    5-8](ch05.xhtml#ch05fig8)展示了结果。
- en: '![image](../images/f084-01.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f084-01.jpg)'
- en: '*Figure 5-8: The grid always rotates around (0,0)*'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-8：网格总是围绕(0,0)旋转*'
- en: On the left side of [Figure 5-8](ch05.xhtml#ch05fig8), the grid is rotated 20
    degrees around (0,0), which is at the top-left corner of the screen. In the example
    on the right, the origin is first translated 200 units to the right and 200 units
    down and *then* the grid is rotated.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 5-8](ch05.xhtml#ch05fig8)的左侧，网格围绕(0,0)旋转了20度，而(0,0)位于屏幕的左上角。在右侧的示例中，原点首先被平移到右边200个单位并向下平移200个单位，*然后*网格才开始旋转。
- en: 'The rotate() function makes it easy to draw a circle of objects like the one
    in [Figure 5-4](ch05.xhtml#ch05fig4) using the following steps:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: rotate()函数使得绘制像[图 5-4](ch05.xhtml#ch05fig4)中的物体圆圈变得简单，可以按照以下步骤进行：
- en: Translate to where you want the center of the circle to be.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 平移到你想要设置圆心的位置。
- en: Rotate the grid and put the objects along the circumference of the circle.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 旋转网格并将物体放置在圆的周长上。
- en: Now that you know how to use transformation functions to manipulate the location
    of different objects on your canvas, let’s actually re-create [Figure 5-4](ch05.xhtml#ch05fig4)
    in Processing.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何使用变换函数来操作画布上不同物体的位置，接下来让我们在Processing中重新创建[图 5-4](ch05.xhtml#ch05fig4)。
- en: DRAWING A CIRCLE OF CIRCLES
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 绘制一个圆形的圆圈
- en: To create the circles arranged in a circle in [Figure 5-4](ch05.xhtml#ch05fig4),
    we’ll use a for i in range() loop to repeat the circles and make sure the circles
    are evenly spaced. First, let’s think about how many degrees should be between
    the circles to make a full circle, remembering that a circle is 360 degrees.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建[图 5-4](ch05.xhtml#ch05fig4)中排列成圆形的圆圈，我们将使用 for i in range() 循环来重复绘制圆形，并确保圆形均匀间隔。首先，让我们思考圆形之间的角度间隔应该是多少，以完成一个完整的圆，记住圆的总角度是
    360 度。
- en: Enter the code shown in [Listing 5-5](ch05.xhtml#ch05list5) to create this design.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 输入[列表 5-5](ch05.xhtml#ch05list5)中显示的代码来创建这个设计。
- en: '*geometry.pyde*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*geometry.pyde*'
- en: 'def setup():'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 'def setup():'
- en: size(600,600)
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: size(600,600)
- en: 'def draw():'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 'def draw():'
- en: translate(width/2,height/2)
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: translate(width/2,height/2)
- en: 'for i in range(12):'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(12):'
- en: ellipse(200,0,50,50)
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ellipse(200,0,50,50)
- en: rotate(radians(360/12))
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: rotate(radians(360/12))
- en: '*Listing 5-5: Drawing a circular design*'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-5：绘制圆形设计*'
- en: Note that the translate(width/2,height/2) function inside the draw() function
    translates the grid to the center of the screen. Then, we start a for loop to
    create an ellipse at a point on the grid, starting at (200,0), as you can see
    from the first two parameters of the function. Then we set the size of each small
    circle by setting both the width and height of the ellipse to 50. Finally, we
    rotate the grid by 360/12, or 30 degrees, before creating the next ellipse. Note
    that we use radians() to convert 30 degrees into radians inside the rotate() function.
    This means that each circle will be 30 degrees away from the next one.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，draw() 函数中的 translate(width/2,height/2) 将网格平移到屏幕中心。接下来，我们启动一个 for 循环，在网格上的某个点创建一个椭圆，从
    (200,0) 开始，如函数的前两个参数所示。然后，我们通过设置椭圆的宽度和高度都为 50 来设定每个小圆的大小。最后，我们在创建下一个椭圆之前将网格旋转
    360/12 或 30 度。请注意，我们在 rotate() 函数中使用 radians() 将 30 度转换为弧度。这意味着每个圆形与下一个圆形的角度间隔为
    30 度。
- en: When you run this, you should see what’s shown in [Figure 5-9](ch05.xhtml#ch05fig9).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个代码时，你应该能看到[图 5-9](ch05.xhtml#ch05fig9)中显示的内容。
- en: '![image](../images/f085-01.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f085-01.jpg)'
- en: '*Figure 5-9: Using transformation to create a circular design*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-9：使用变换创建圆形设计*'
- en: We have successfully arranged a bunch of circles into a circular shape!
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功地将一堆圆形排列成了一个圆形！
- en: DRAWING A CIRCLE OF SQUARES
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 绘制方形圆圈
- en: 'Modify the program you wrote in [Listing 5-5](ch05.xhtml#ch05list5) and change
    the circles into squares. To do this, just change ellipse in the existing code
    to rect to make the circles into squares, as shown here:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 修改你在[列表 5-5](ch05.xhtml#ch05list5)中写的程序，将圆形改为方形。要做到这一点，只需将现有代码中的 ellipse 改为
    rect，将圆形变成方形，如下所示：
- en: '*geometry.pyde*'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*geometry.pyde*'
- en: 'def setup():'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 'def setup():'
- en: size(600,600)
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: size(600,600)
- en: 'def draw():'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 'def draw():'
- en: translate(width/2,height/2)
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: translate(width/2,height/2)
- en: 'for i in range(12):'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(12):'
- en: rect(200,0,50,50)
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: rect(200,0,50,50)
- en: rotate(radians(360/12))
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: rotate(radians(360/12))
- en: That was easy!
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 很简单！
- en: ANIMATING OBJECTS
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动画对象
- en: Processing is great for animating your objects to create dynamic graphics. For
    your first animation, you’ll use the rotate() function. Normally, rotate happens
    instantly, so you don’t get to see the action take place—only the result of the
    rotation. But this time, we’ll use a time variable t, which allows us to see the
    rotation unfold in real time!
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Processing 非常适合用来为你的对象创建动画，以制作动态图形。在你的第一个动画中，你将使用 rotate() 函数。通常，rotate() 发生得非常迅速，因此你不会看到旋转过程——只会看到旋转后的结果。但这次，我们将使用时间变量
    t，允许我们实时看到旋转的展开过程！
- en: CREATING THE T VARIABLE
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建 t 变量
- en: Let’s use our circle of squares to write an animated program. To start, create
    the t variable and initialize it to 0 by adding t = 0 before the setup() function.
    Then insert the code in [Listing 5-6](ch05.xhtml#ch05list6) before the for loop.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用方形圆圈来写一个动画程序。首先，创建 t 变量，并将其初始化为 0，方法是在 setup() 函数之前添加 t = 0。然后，在 for 循环之前插入[列表
    5-6](ch05.xhtml#ch05list6)中的代码。
- en: '*geometry.pyde*'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*geometry.pyde*'
- en: t = 0
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: t = 0
- en: 'def setup():'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 'def setup():'
- en: size(600,600)
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: size(600,600)
- en: 'def draw():'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 'def draw():'
- en: translate(width/2,height/2)
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: translate(width/2,height/2)
- en: rotate(radians(t))
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: rotate(radians(t))
- en: 'for i in range(12):'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(12):'
- en: rect(200,0,50,50)
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: rect(200,0,50,50)
- en: rotate(radians(360/12))
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: rotate(radians(360/12))
- en: '*Listing 5-6: Adding the t variable*'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-6：添加 t 变量*'
- en: 'However, if you try to run this code, you’ll get the following error message:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你尝试运行这个代码，你会收到以下错误信息：
- en: 'UnboundLocalError: local variable ''t'' referenced before assignment'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 'UnboundLocalError: 本地变量 ''t'' 在赋值前被引用'
- en: This is because Python doesn’t know whether we’re creating a new local variable
    named t *inside* the function that doesn’t have anything to do with the global
    variable t *outside* the function, or just calling the global variable. Because
    we want to use the global variable, add global t at the beginning of the draw()
    function so the program knows which one we’re referring to.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 Python 不知道我们是否在函数内部创建了一个与全局变量 t 无关的局部变量 t，还是仅仅在调用全局变量 t。因为我们想使用全局变量，所以在
    draw() 函数的开始处添加 global t，这样程序就知道我们指的是哪个变量。
- en: 'Enter the complete code shown here:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 输入完整的代码如下：
- en: '*geometry.pyde*'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*geometry.pyde*'
- en: t = 0
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: t = 0
- en: 'def setup():'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 'def setup():'
- en: size(600,600)
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: size(600,600)
- en: 'def draw():'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 'def draw():'
- en: global t
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: global t
- en: '#set background white'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '#将背景设置为白色'
- en: background(255)
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: background(255)
- en: translate(width/2,height/2)
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: translate(width/2,height/2)
- en: rotate(radians(t))
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: rotate(radians(t))
- en: 'for i in range(12):'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(12):'
- en: rect(200,0,50,50)
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: rect(200,0,50,50)
- en: rotate(radians(360/12))
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: rotate(radians(360/12))
- en: t += 1
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: t += 1
- en: This code starts t at 0, rotates the grid that number of degrees, increments
    t by 1, and then repeats. Run it, and you should see the squares start to rotate
    in a circular pattern, as in [Figure 5-10](ch05.xhtml#ch05fig10).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将 t 初始化为 0，将网格旋转指定角度，t 增加 1，然后重复此过程。运行它，你应该会看到方块开始以圆形的模式旋转，正如[图 5-10](ch05.xhtml#ch05fig10)所示。
- en: '![image](../images/f087-01.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f087-01.jpg)'
- en: '*Figure 5-10: Making squares rotate in a circle*'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-10：让方块围绕圆形旋转*'
- en: Pretty cool! Now let’s try rotating each individual square.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 太酷了！现在让我们尝试让每个单独的方块旋转。
- en: ROTATING THE INDIVIDUAL SQUARES
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 旋转单个方块
- en: Because rotating is done around (0,0) in Processing, inside the loop we first
    have to translate to where each square needs to be, then rotate, and finally draw
    the square. Change the loop in your code to look like [Listing 5-7](ch05.xhtml#ch05list7).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 因为在 Processing 中旋转是围绕 (0,0) 进行的，所以在循环内我们首先需要将位置平移到每个方块应在的位置，然后进行旋转，最后绘制方块。请将代码中的循环修改为类似于[列表
    5-7](ch05.xhtml#ch05list7)的样子。
- en: '*geometry.pyde*'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*geometry.pyde*'
- en: 'for i in range(12):'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(12):'
- en: translate(200,0)
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: translate(200,0)
- en: rotate(radians(t))
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: rotate(radians(t))
- en: rect(0,0,50,50)
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: rect(0,0,50,50)
- en: rotate(radians(360/12))
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: rotate(radians(360/12))
- en: '*Listing 5-7: Rotating each square*'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-7：旋转每个方块*'
- en: This translates the grid to where we want to place the square, rotates the grid
    so the square rotates, and then draws the square using the rect() function.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把网格平移到方块的位置，旋转网格使得方块旋转，然后使用 rect() 函数绘制方块。
- en: SAVING ORIENTATION WITH PUSHMATRIX() AND POPMATRIX()
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 PUSHMATRIX() 和 POPMATRIX() 保存方向
- en: When you run [Listing 5-7](ch05.xhtml#ch05list7), you should see that it creates
    some strange behavior. The squares don’t rotate around the center, but keep moving
    around the screen instead, as shown in [Figure 5-11](ch05.xhtml#ch05fig11).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行[列表 5-7](ch05.xhtml#ch05list7)时，你应该会看到它产生了一些奇怪的行为。方块不是围绕中心旋转，而是持续在屏幕上移动，正如[图
    5-11](ch05.xhtml#ch05fig11)所示。
- en: '![image](../images/f088-01.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f088-01.jpg)'
- en: '*Figure 5-11: The squares are flying all over!*'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-11：方块飞得四处乱飘！*'
- en: This is due to changing the center and changing the orientation of the grid
    so much. After translating to the location of the square, we need to rotate back
    to the center of the circle before translating to the next square. We could use
    another translate() function to undo the first one, but we might have to undo
    more transformations, and that could get confusing. Fortunately, there’s an easier
    way.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为改变了中心和网格的方向。将方块的位置平移后，我们需要旋转回圆心，再平移到下一个方块的位置。我们本可以使用另一个 translate() 函数来撤销第一个平移，但可能还需要撤销更多的变换，这样会变得比较混乱。幸运的是，有一种更简单的方法。
- en: 'Processing has two built-in functions that save the orientation of the grid
    at a certain point and then return to that orientation: pushMatrix() and popMatrix().
    In this case, we want to save the orientation when we’re in the center of the
    screen. To do this, revise the loop to look like [Listing 5-8](ch05.xhtml#ch05list8).'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Processing 有两个内置函数，pushMatrix() 和 popMatrix()，它们可以保存当前网格的方向，并且在之后恢复到该方向。在这里，我们希望在屏幕中心保存方向。为了做到这一点，请修改循环，使其看起来像[列表
    5-8](ch05.xhtml#ch05list8)一样。
- en: '*geometry.pyde*'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '*geometry.pyde*'
- en: 'for i in range(12):'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(12):'
- en: 'pushMatrix() #save this orientation'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 'pushMatrix() #保存当前方向'
- en: translate(200,0)
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: translate(200,0)
- en: rotate(radians(t))
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: rotate(radians(t))
- en: rect(0,0,50,50)
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: rect(0,0,50,50)
- en: 'popMatrix() #return to the saved orientation'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 'popMatrix() #返回到保存的方向'
- en: rotate(radians(360/12))
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: rotate(radians(360/12))
- en: '*Listing 5-8: Using pushMatrix() and popMatrix()*'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-8：使用 pushMatrix() 和 popMatrix()*'
- en: The pushMatrix() function saves the position of the coordinate system at the
    center of the circle of squares. Then we translate to the location of the square,
    rotate the grid so the square will spin, and then draw the square. Then we use
    popMatrix() to return instantly to the center of the circle of squares and repeat
    for all 12 squares.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: pushMatrix()函数保存了方格圆圈中心的坐标系位置。然后我们将坐标系统转换到方格位置，旋转网格使方格旋转，然后绘制方格。接着，我们使用popMatrix()立刻返回到方格圆圈的中心，并对所有12个方格重复此过程。
- en: ROTATING AROUND THE CENTER
  id: totrans-177
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 绕中心旋转
- en: 'The preceding code should work perfectly, but the rotation may look strange;
    that’s because Processing by default locates a rectangle at its top-left corner
    and rotates it about its top-left corner. This makes the squares look like they’re
    veering off the path of the larger circle. If you want your squares to rotate
    around their centers, add this line to your setup() function:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码应该可以完美运行，但旋转可能看起来有些奇怪；这是因为Processing默认将矩形定位在其左上角，并围绕左上角进行旋转。这使得方格看起来似乎偏离了大圆的路径。如果你希望方格绕其中心旋转，可以在setup()函数中添加以下这行代码：
- en: rectMode(CENTER)
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: rectMode(CENTER)
- en: 'Note that the all-uppercase CENTER in rectMode() matters. (You can also experiment
    with other types of rectMode(), like CORNER, CORNERS, and RADIUS.) Adding rectMode(CENTER)
    should make each square rotate around its center. If you want the squares to spin
    more quickly, change the rotate() line to increase the time in t, like so:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，rectMode()中的全大写的CENTER很重要。（你还可以尝试其他类型的rectMode()，例如CORNER、CORNERS和RADIUS。）添加rectMode(CENTER)应该使每个方格绕其中心旋转。如果你希望方格旋转得更快，可以修改rotate()行，增加t中的时间，如下所示：
- en: rotate(radians(5*t))
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: rotate(radians(5*t))
- en: Here, 5 is the frequency of the rotation. This means the program multiplies
    the value of t by 5 and rotates by the product. Therefore, the square will rotate
    five times as far as before. Change it to see what happens! Comment out the rotate()
    line outside the loop (by adding a hashtag at the beginning) to make the squares
    rotate in place, as shown in [Listing 5-9](ch05.xhtml#ch05list9).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，5是旋转的频率。这意味着程序将t的值乘以5并根据乘积进行旋转。因此，方格将比之前旋转五倍远。试着修改它，看看会发生什么！将rotate()行注释掉（在行前加一个井号），让方格在原地旋转，如[Listing
    5-9](ch05.xhtml#ch05list9)所示。
- en: translate(width/2,height/2)
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: translate(width/2,height/2)
- en: '#rotate(radians(t))'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '#rotate(radians(t))'
- en: 'for i in range(12):'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(12):'
- en: rect(200,0,50,50)
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: rect(200,0,50,50)
- en: '*Listing 5-9: Commenting out a line instead of deleting it*'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 5-9: 注释掉一行代码而不是删除它*'
- en: Being able to use transformations like translate() and rotate() to create dynamic
    graphics is a very powerful technique, but it can produce unexpected results if
    you do things in the wrong order!
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 能够使用变换函数如translate()和rotate()来创建动态图形是一项非常强大的技巧，但如果操作顺序不对，可能会产生意想不到的结果！
- en: CREATING AN INTERACTIVE RAINBOW GRID
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建互动彩虹网格
- en: 'Now that you’ve learned how to create designs using loops and to rotate them
    in different ways, we’ll create something pretty awesome: a grid of squares whose
    rainbow colors follow your mouse cursor! The first step is to make a grid.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学会了如何使用循环创建设计并以不同的方式旋转它们，我们将创造一些非常酷的东西：一个方格网格，其彩虹色会随着你的鼠标光标移动！第一步是制作一个网格。
- en: DRAWING A GRID OF OBJECTS
  id: totrans-191
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 绘制对象网格
- en: Many tasks involved in math and in creating games like Minesweeper require a
    grid. Grids are necessary for some of the models and all the cellular automata
    we’ll create in later chapters, so it’s worth learning how to write code for making
    a grid that we can reuse. To begin with, we’ll make a 12 × 12 grid of squares,
    evenly sized and spaced. Making a grid this size may seem like a time-consuming
    task, but in fact it’s easy to do using a loop.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 许多数学任务和像扫雷这样的游戏创建任务都需要一个网格。网格对于一些模型以及我们在后续章节中将要创建的所有元胞自动机来说都是必需的，因此学习如何编写代码来创建一个可重复使用的网格是很值得的。首先，我们将制作一个12
    × 12的方格网格，大小均匀且间隔一致。制作如此大小的网格可能看起来是一个耗时的任务，但实际上使用循环就能轻松完成。
- en: 'Open a new Processing sketch and save as *colorGrid.pyde*. Too bad we used
    the name “grid” previously. We’ll make a 20 × 20 grid of squares on a white background.
    The squares need to be rect, and we need to use a for loop within a for loop to
    make sure they are all the same size and spaced equally. Also, we need our 25
    × 25 pixel squares to be drawn every 30 pixels, using this line:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个新的Processing草图并保存为*colorGrid.pyde*。真可惜我们之前已经用了“grid”这个名字。我们将在白色背景上制作一个20
    × 20的方格网格。这些方格需要是矩形，并且我们需要在一个for循环内再嵌套一个for循环，确保它们的大小相同且间隔均匀。此外，我们需要让每个25 × 25像素的方格按每30像素绘制一次，使用如下代码：
- en: rect(30*x,30*y,25,25)
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: rect(30*x,30*y,25,25)
- en: As the x and y variables go up by 1, squares are drawn at 50-pixel intervals
    in two dimensions. We’ll start off, as usual, by writing our setup() and draw()
    functions, as in the previous sketch (see [Listing 5-10](ch05.xhtml#ch05list10)).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当 x 和 y 变量增加 1 时，方块将在两个维度上以 50 像素的间隔绘制。我们将像往常一样，从编写 setup() 和 draw() 函数开始，就像之前的草图（参见
    [列表 5-10](ch05.xhtml#ch05list10)）中一样。
- en: '*colorGrid.pyde*'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '*colorGrid.pyde*'
- en: 'def setup():'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 'def setup():'
- en: size(600,600)
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: size(600,600)
- en: 'def draw():'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 'def draw():'
- en: '#set background white'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '#设置背景为白色'
- en: background(255)
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: background(255)
- en: '*Listing 5-10: The standard structure for a Processing sketch: setup() and
    draw()*'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-10：Processing 草图的标准结构：setup() 和 draw()*'
- en: This sets the size of the window at 600 by 600 pixels, and sets the background
    color to white. Next we’ll create a nested loop, where two variables will both
    go from 0 to 19, for a total of 20 numbers, since we want 20 rows of 20 squares.
    [Listing 5-11](ch05.xhtml#ch05list11) shows the code that creates the grid.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这设置了窗口的大小为 600 × 600 像素，并将背景颜色设置为白色。接下来，我们将创建一个嵌套循环，其中两个变量都将从 0 到 19， 总共 20
    个数字，因为我们想要 20 行 20 个方块。[列表 5-11](ch05.xhtml#ch05list11) 显示了创建网格的代码。
- en: 'def setup():'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 'def setup():'
- en: size(600,600)
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: size(600,600)
- en: 'def draw():'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 'def draw():'
- en: '#set background white'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '#设置背景为白色'
- en: background(255)
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: background(255)
- en: 'for x in range(20):'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 'for x in range(20):'
- en: 'for y in range(20):'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 'for y in range(20):'
- en: rect(30*x,30*y,25,25)
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: rect(30*x,30*y,25,25)
- en: '*Listing 5-11: The code for a grid*'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-11：网格的代码*'
- en: This should create a 20 × 20 grid of squares, as you can see in [Figure 5-12](ch05.xhtml#ch05fig12).
    Time to add some colors to our grid.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会创建一个 20 × 20 的方块网格，正如你在 [图 5-12](ch05.xhtml#ch05fig12) 中看到的那样。现在是时候为我们的网格添加一些颜色了。
- en: '![image](../images/f091-01.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f091-01.jpg)'
- en: '*Figure 5-12: A 20 × 20 grid!*'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-12：一个 20 × 20 的网格！*'
- en: ADDING THE RAINBOW COLOR TO OBJECTS
  id: totrans-216
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 向物体添加彩虹色
- en: Processing’s colorMode() function helps us add some cool color to our sketches!
    It’s used to switch between the RGB and HSB modes. Recall that RGB uses three
    numbers indicating amounts of red, green, and blue. In HSB, the three numbers
    represent levels of hue, saturation, and brightness. The only one we need to change
    here is the first number, which represents the hue. The other two numbers can
    be the maximum value, 255\. [Figure 5-13](ch05.xhtml#ch05fig13) shows how to make
    rainbow colors by changing only the first value, the hue. Here, the 10 squares
    have the hue values shown in the figure, with 255 for saturation and 255 for brightness.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: Processing 的 colorMode() 函数帮助我们为草图添加一些酷炫的颜色！它用于在 RGB 和 HSB 模式之间切换。回想一下，RGB 使用三个数字表示红色、绿色和蓝色的数量。在
    HSB 模式中，三个数字表示色相、饱和度和亮度的级别。我们这里唯一需要改变的是第一个数字，即色相。其他两个数字可以使用最大值 255。[图 5-13](ch05.xhtml#ch05fig13)
    显示了如何仅通过改变第一个值——色相来制作彩虹色。在这里，10 个方块的色相值如图所示，饱和度为 255，亮度为 255。
- en: '![image](../images/f091-02.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f091-02.jpg)'
- en: '*Figure 5-13: The colors of the rainbow using HSB mode and changing the hue
    value*'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-13：使用 HSB 模式并改变色相值绘制彩虹色*'
- en: 'Since we’re locating the rectangles at (30*x,30*y) in [Listing 5-11](ch05.xhtml#ch05list11),
    we’ll create a variable that measures the distance of the mouse from that location:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在 [列表 5-11](ch05.xhtml#ch05list11) 中将矩形定位在 (30*x,30*y) 处，我们将创建一个变量来测量鼠标与该位置的距离：
- en: d = dist(30*x,30*y,mouseX,mouseY)
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: d = dist(30*x,30*y,mouseX,mouseY)
- en: Processing has a dist() function that finds the distance between two points,
    and in this case it’s the distance between the square and the mouse. It saves
    the distance to a variable called d, and we’ll link the hue to that variable.
    [Listing 5-12](ch05.xhtml#ch05list12) shows the changes to the code.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Processing 有一个 dist() 函数，可以计算两点之间的距离，在这种情况下，它是方块和鼠标之间的距离。它将距离保存到一个名为 d 的变量中，我们将色相与该变量关联。[列表
    5-12](ch05.xhtml#ch05list12) 显示了代码的更改。
- en: '*colorGrid.pyde*'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '*colorGrid.pyde*'
- en: 'def setup():'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 'def setup():'
- en: size(600,600)
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: size(600,600)
- en: rectMode(CENTER)
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: rectMode(CENTER)
- en: ➊ colorMode(HSB)
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ colorMode(HSB)
- en: 'def draw():'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 'def draw():'
- en: '#set background black'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '#设置背景为黑色'
- en: ➋ background(0)
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ background(0)
- en: translate(20,20)
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: translate(20,20)
- en: 'for x in range(30):'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 'for x in range(30):'
- en: 'for y in range(30):'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 'for y in range(30):'
- en: ➌ d = dist(30*x,30*y,mouseX,mouseY)
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ d = dist(30*x,30*y,mouseX,mouseY)
- en: fill(0.5*d,255,255)
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: fill(0.5*d,255,255)
- en: rect(30*x,30*y,25,25)
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: rect(30*x,30*y,25,25)
- en: '*Listing 5-12: Using the dist() function*'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-12：使用 dist() 函数*'
- en: We insert the colorMode() function and pass HSB to it ➊. In the draw() function,
    we set the background to black first ➋. Then we calculate the distance from the
    mouse to the square, which is at (30*x,30*y) ➌. In the next line, we set the fill
    color using HSB numbers. The hue value is half the distance, while the saturation
    and brightness numbers are both 255, the maximum.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们插入 colorMode() 函数并将 HSB 传递给它 ➊。在 draw() 函数中，我们首先将背景设置为黑色 ➋。然后，我们计算鼠标与位于 (30*x,30*y)
    的方块之间的距离 ➌。接下来的一行，我们使用 HSB 数值设置填充颜色。色调值是距离的一半，而饱和度和亮度的数值都为 255，即最大值。
- en: 'The hue is the only thing we change: we update the hue according to the distance
    the rectangle is from the mouse. We do this with the dist() function, which takes
    four arguments: the x- and y-coordinates of two points. It returns the distance
    between the points.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色的色调是我们唯一改变的部分：我们根据矩形与鼠标的距离更新色调。我们通过 dist() 函数来实现，这个函数有四个参数：两个点的 x 和 y 坐标。它返回这两个点之间的距离。
- en: Run this code and you should see a very colorful design that changes colors
    according to the mouse’s location, as shown in [Figure 5-14](ch05.xhtml#ch05fig14).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这段代码，你应该会看到一个非常多彩的设计，它会根据鼠标的位置改变颜色，如[图 5-14](ch05.xhtml#ch05fig14)所示。
- en: Now that you’ve learned how to add colors to your objects, let’s explore how
    we can create more complicated shapes.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学会如何为对象添加颜色，接下来让我们探索如何创建更复杂的形状。
- en: '![image](../images/f092-01.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f092-01.jpg)'
- en: '*Figure 5-14: Adding colors to your grid*'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-14：为你的网格添加颜色*'
- en: DRAWING COMPLEX PATTERNS USING TRIANGLES
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用三角形绘制复杂图案
- en: '![image](../images/f093-01.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f093-01.jpg)'
- en: '*Figure 5-15: Sketch of 90 rotating equilateral triangles by Roger Antonsen.
    See it in motion at* [https://rantonse.no/en/art/2016-11-30](https://rantonse.no/en/art/2016-11-30).'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-15：由罗杰·安顿森（Roger Antonsen）绘制的90个旋转的等边三角形草图。可以在* [https://rantonse.no/en/art/2016-11-30](https://rantonse.no/en/art/2016-11-30)
    *查看动画。*'
- en: In this section, we create more complicated, Spirograph-style patterns using
    triangles. For example, take a look at the sketch made up of rotating triangles
    in [Figure 5-15](ch05.xhtml#ch05fig15), created by the University of Oslo’s Roger
    Antonsen.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用三角形创建更复杂的、类似圆规图案的设计。例如，看看由奥斯陆大学的罗杰·安顿森（Roger Antonsen）制作的旋转三角形草图，见[图
    5-15](ch05.xhtml#ch05fig15)。
- en: The original design moves, but in this book you’ll have to imagine all the triangles
    rotating. This sketch blew me away! Although this design looks very complicated,
    it’s not that difficult to make. Remember Nasrudin’s joke about the brick from
    the beginning of the chapter? Like Nasrudin’s house, this complicated design is
    just a collection of identical shapes. But what shape? Antonsen gave us a helpful
    clue to creating this design when he named the sketch “90 Rotating Equilateral
    Triangles.” It tells us that all we have to do is figure out how to draw an equilateral
    triangle, rotate it, and then repeat that for a total of 90 triangles. Let’s first
    discuss how to draw an equilateral triangle using the triangle() function. To
    start, open a new Processing sketch and name it *triangles.pyde*. The code in
    [Listing 5-13](ch05.xhtml#ch05list13) shows one way to create a rotating triangle
    but not an equilateral one.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 原始设计会动，但在这本书里你得想象所有三角形都在旋转。这幅草图让我震撼！虽然这个设计看起来很复杂，但制作起来并不难。还记得章节开头纳斯鲁丁关于砖块的笑话吗？就像纳斯鲁丁的房子一样，这个复杂的设计其实就是一堆相同形状的集合。但是什么形状呢？安顿森在命名这幅草图为“90个旋转的等边三角形”时给了我们一个有用的线索。这告诉我们，我们所要做的就是弄清楚如何绘制一个等边三角形，旋转它，然后重复这个过程，直到有90个三角形。首先，让我们讨论如何使用
    triangle() 函数绘制等边三角形。首先，打开一个新的 Processing 草图并命名为 *triangles.pyde*。[列表 5-13](ch05.xhtml#ch05list13)
    中的代码展示了创建一个旋转的三角形的其中一种方法，但它不是等边三角形。
- en: '*triangles.pyde*'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '*triangles.pyde*'
- en: 'def setup():'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 'def setup():'
- en: size(600,600)
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: size(600,600)
- en: rectMode(CENTER)
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: rectMode(CENTER)
- en: t = 0
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: t = 0
- en: 'def draw():'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 'def draw():'
- en: global t
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: global t
- en: translate(width/2,height/2)
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: translate(width/2,height/2)
- en: rotate(radians(t))
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: rotate(radians(t))
- en: triangle(0,0,100,100,200,-200)
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: triangle(0,0,100,100,200,-200)
- en: t += 0.5
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: t += 0.5
- en: '*Listing 5-13: Drawing a rotating triangle, but not the right kind*'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-13：绘制旋转三角形，但不是正确的类型*'
- en: 'Listing 5-13 uses the lessons you learned previously: it creates a t variable
    (for time), translates to where we want the triangle to be, rotates the grid,
    and then draws the triangle. Finally, it increments t. When you run this code,
    you should see something like [Figure 5-16](ch05.xhtml#ch05fig16).'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5-13 使用了你之前学到的知识：它创建了一个 t 变量（用于时间），将坐标平移到我们想要放置三角形的位置，旋转网格，然后绘制三角形。最后，它递增
    t。当你运行这段代码时，你应该会看到类似于[图 5-16](ch05.xhtml#ch05fig16)的效果。
- en: '![image](../images/f094-01.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f094-01.jpg)'
- en: '*Figure 5-16: Rotating a triangle around one of its vertices*'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-16：围绕一个顶点旋转三角形*'
- en: As you can see in [Figure 5-16](ch05.xhtml#ch05fig16), the triangle rotates
    around one of its *vertices*, or points, and thus creates a circle with the outer
    point. You’ll also notice that this is a right triangle (a triangle containing
    a 90-degree angle), not an equilateral one.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在[图 5-16](ch05.xhtml#ch05fig16)中看到的，三角形围绕其一个*顶点*，或点旋转，从而形成一个以外部点为圆周的圆。你还会注意到，这是一个直角三角形（包含
    90 度角的三角形），而不是等边三角形。
- en: To re-create Antonsen’s sketch, we need to draw an equilateral triangle, which
    is a triangle with equal sides. We also need to find the center of the equilateral
    triangle to be able to rotate it about its center. To do this, we need to find
    the location of the three vertices of the triangle. Let’s discuss how to draw
    an equilateral triangle by locating it at its center and specifying the location
    of its vertices.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 为了重新创建 Antonsen 的草图，我们需要绘制一个等边三角形，它是一个各边相等的三角形。我们还需要找到等边三角形的中心，以便围绕其中心旋转它。为此，我们需要找到三角形三个顶点的位置。让我们讨论如何通过确定其中心并指定顶点位置来绘制等边三角形。
- en: A 30-60-90 TRIANGLE
  id: totrans-266
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 一个 30-60-90 三角形
- en: '![image](../images/f094-02.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f094-02.jpg)'
- en: '*Figure 5-17: An equilateral triangle divided into three equal parts*'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-17：将等边三角形分成三等份*'
- en: 'To find the location of the three vertices of our equilateral triangle, we’ll
    review a particular type of triangle you’ve likely seen in geometry class: the
    *30-60-90 triangle*, which is a special *right triangle*. First, we need an equilateral
    triangle, as shown in [Figure 5-17](ch05.xhtml#ch05fig17).'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到我们等边三角形三个顶点的位置，我们将回顾一种你在几何课上可能见过的特定类型的三角形：*30-60-90 三角形*，这是一种特殊的*直角三角形*。首先，我们需要一个等边三角形，如[图
    5-17](ch05.xhtml#ch05fig17)所示。
- en: 'This equilateral triangle is made up of three equal parts. The point in the
    middle is the center of the triangle, with the three dissecting lines meeting
    at 120 degree angles. To draw a triangle in Processing, we give the triangle()
    function six numbers: the x- and y-coordinates of all three vertices. To find
    the coordinates of the vertices of the equilateral triangle shown in [Figure 5-17](ch05.xhtml#ch05fig17),
    let’s cut the bottom triangle in half, as shown in [Figure 5-18](ch05.xhtml#ch05fig18).'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这个等边三角形由三等分组成。中间的点是三角形的中心，三条分割线在 120 度角处相交。为了在 Processing 中绘制三角形，我们给 triangle()
    函数传入六个数字：三个顶点的 x 和 y 坐标。为了找到[图 5-17](ch05.xhtml#ch05fig17)中所示等边三角形的顶点坐标，我们将底部三角形对半分割，如[图
    5-18](ch05.xhtml#ch05fig18)所示。
- en: '![image](../images/f095-01.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f095-01.jpg)'
- en: '*Figure 5-18: Dividing up the equilateral triangle into special triangles*'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-18：将等边三角形分割成特殊的三角形*'
- en: Dividing the bottom triangle in half creates two right triangles, which are
    classic 30-60-90 triangles. As you might recall, the ratio between the sides of
    a 30-60-90 triangle can be expressed as shown in [Figure 5-19](ch05.xhtml#ch05fig19).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 将底部三角形对半分割，得到两个直角三角形，这些是经典的 30-60-90 三角形。你可能还记得，30-60-90 三角形各边的比率可以如[图 5-19](ch05.xhtml#ch05fig19)所示表示。
- en: '![image](../images/f095-02.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f095-02.jpg)'
- en: '*Figure 5-19: The ratios of the sides in a 30-60-90 triangle, from the legend
    on an SAT test*'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-19：30-60-90 三角形中各边的比率，来自 SAT 测试中的图例*'
- en: If we call the length of the smaller leg *x*, the hypotenuse is twice that length,
    or 2*x*, and the longer leg is *x* times the square root of 3, or approximately
    1.732*x*. We’re going to be creating our function using the length from the center
    of the big equilateral triangle in [Figure 5-18](ch05.xhtml#ch05fig18) to one
    of its vertices, which happens to be the hypotenuse of the 30-60-90 triangle.
    That means we can measure everything in terms of that length. For example, if
    we call the hypotenuse length, then the smaller leg will be half that length,
    or length/2. Finally, the longer leg will be length divided by 2 times the square
    root of 3\. [Figure 5-20](ch05.xhtml#ch05fig20) zooms in on the 30-60-90 triangle.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将较小的直角边长度称为 *x*，则斜边的长度是该长度的两倍，或者 2*x*，而较长的直角边是 *x* 乘以 3 的平方根，大约是 1.732*x*。我们将使用从[图
    5-18](ch05.xhtml#ch05fig18)中大等边三角形的中心到其一个顶点的长度来创建我们的函数，这个顶点恰好是 30-60-90 三角形的斜边。意味着我们可以用这个长度来测量所有内容。例如，如果我们将斜边长度称为
    `length`，那么较小的直角边将是该长度的一半，或者 `length/2`。最后，较长的直角边将是 `length` 除以 2 乘以 3 的平方根。[图
    5-20](ch05.xhtml#ch05fig20)对 30-60-90 三角形进行了放大展示。
- en: '![image](../images/f095-03.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f095-03.jpg)'
- en: '*Figure 5-20: The 30-60-90 triangle up close and personal*'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-20：近距离查看 30-60-90 三角形*'
- en: As you can see, a 30-60-90 triangle has internal angles of 30, 60, and 90 degrees,
    and the lengths of the sides are in known proportions. You may be familiar with
    this from the Pythagorean Theorem, which will come up again shortly.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，30-60-90三角形的内部角度为30度、60度和90度，并且其边长具有已知比例。你可能熟悉这个比例，它与勾股定理有关，稍后我们会再次用到它。
- en: We’ll call the distance from the center of the larger equilateral triangle to
    its vertex the “length,” which is also the *hypotenuse* of the 30-60-90 triangle.
    You’ll need to know the ratios between the lengths of the sides of this special
    triangle in order to find the three vertices of the equilateral triangle with
    respect to the center—you can draw it (the big equilateral triangle we’re trying
    to draw) by specifying where each point of the triangle should be.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从大等边三角形的中心到其顶点的距离称为“长度”，它也是30-60-90三角形的*斜边*。你需要知道这个特殊三角形各边长度之间的比例，才能找到等边三角形相对于中心的三个顶点——你可以通过指定三角形的每个点的位置来绘制它（我们要绘制的大等边三角形）。
- en: The shorter leg of the right triangle opposite the 30 degree angle is always
    half the hypotenuse, and the longer leg is the measure of the shorter leg times
    the square root of 3\. So if we use the center point for drawing the big equilateral
    triangle, the coordinates of the three vertices would be as shown in [Figure 5-21](ch05.xhtml#ch05fig21).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这个直角三角形中，30度角对面的短腿总是斜边的一半，长腿则是短腿长度乘以3的平方根。因此，如果我们使用中心点来绘制大等边三角形，则三个顶点的坐标将如[图
    5-21](ch05.xhtml#ch05fig21)所示。
- en: '![image](../images/f096-01.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f096-01.jpg)'
- en: '*Figure 5-21: The vertices of the equilateral triangle*'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-21：等边三角形的顶点*'
- en: As you can see, because this triangle is made up of 30-60-90 triangles on all
    sides, we can use the special relation between them to figure out how far each
    vertex of the equilateral triangle should be from the origin.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，由于这个三角形由所有边上的30-60-90三角形组成，我们可以利用它们之间的特殊关系来计算等边三角形每个顶点与原点之间的距离。
- en: DRAWING AN EQUILATERAL TRIANGLE
  id: totrans-285
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 绘制等边三角形
- en: Now we can use the vertices we derived from the 30-60-90 triangle to create
    an equilateral triangle, using the code in [Listing 5-14](ch05.xhtml#ch05list14).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以利用从30-60-90三角形中推导出的顶点来绘制等边三角形，使用[清单 5-14](ch05.xhtml#ch05list14)中的代码。
- en: '*triangles.pyde*'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '*triangles.pyde*'
- en: 'def setup():'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 'def setup():'
- en: size(600,600)
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: size(600,600)
- en: rectMode(CENTER)
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: rectMode(CENTER)
- en: t = 0
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: t = 0
- en: 'def draw():'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 'def draw():'
- en: global t
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: global t
- en: translate(width/2,height/2)
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: translate(width/2,height/2)
- en: rotate(radians(t))
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: rotate(radians(t))
- en: 'tri(200) #draw the equilateral triangle'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 'tri(200) #绘制等边三角形'
- en: t += 0.5
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: t += 0.5
- en: '➊ def tri(length):'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ def tri(length):'
- en: '''''''Draws an equilateral triangle'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '''''''绘制等边三角形'
- en: around center of triangle'''
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 绕三角形的中心旋转'''
- en: ➋ triangle(0,-length,
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ triangle(0,-length,
- en: -length*sqrt(3)/2, length/2,
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: -length*sqrt(3)/2, length/2,
- en: length*sqrt(3)/2, length/2)
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: length*sqrt(3)/2, length/2)
- en: '*Listing 5-14: The complete code for making a rotating equilateral triangle*'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-14：绘制旋转等边三角形的完整代码*'
- en: 'First, we write the tri() function to take the variable length ➊, which is
    the hypotenuse of the special 30-60-90 triangles we cut the equilateral triangle
    into. We then make a triangle using the three vertices we found. Inside the call
    to the triangle() function ➋, we specify the location of each of the three vertices
    of the triangle: (0,-length), (-length*sqrt(3)/2, length/2), and (length*sqrt(3)/2,
    length/2).'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们编写tri()函数，接受变量length ➊，这个值是我们将等边三角形分割成的特殊30-60-90三角形的斜边。然后，我们使用找到的三个顶点绘制一个三角形。在调用triangle()函数
    ➋ 时，我们指定三角形三个顶点的位置： (0,-length)、(-length*sqrt(3)/2, length/2) 和 (length*sqrt(3)/2,
    length/2)。
- en: When you run the code, you should see something like [Figure 5-22](ch05.xhtml#ch05fig22).
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行代码时，你应该看到类似于[图 5-22](ch05.xhtml#ch05fig22)的内容。
- en: '![image](../images/f097-01.jpg)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f097-01.jpg)'
- en: '*Figure 5-22: A rotating equilateral triangle!*'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-22：旋转的等边三角形！*'
- en: 'Now we can cover up all the triangles created during rotation by adding this
    line to the beginning of the draw() function:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过在draw()函数的开始处添加这一行来遮盖掉所有在旋转过程中创建的三角形：
- en: 'background(255) #white'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 'background(255) #白色背景'
- en: This should erase all the rotating triangles except for one, so we just have
    a single equilateral triangle on the screen. All we have to do is put 90 of them
    in a circle, just like we did earlier in this chapter, using the rotate() function.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会擦除所有旋转的三角形，除了一个，所以屏幕上只会显示一个等边三角形。我们所要做的，就是像本章前面一样，将90个等边三角形放置在一个圆形中，使用rotate()函数。
- en: 'EXERCISE 5-1: SPIN CYCLE'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 5-1：旋转周期
- en: Create a circle of equilateral triangles in a Processing sketch and rotate them
    using the rotate() function.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在Processing草图中创建一个等边三角形的圆，并使用rotate()函数旋转它们。
- en: DRAWING MULTIPLE ROTATING TRIANGLES
  id: totrans-314
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 绘制多个旋转的三角形
- en: Now that you’ve learned how to rotate a single equilateral triangle, we need
    to figure out how to arrange multiple equilateral triangles into a circle. This
    is similar to what you created while rotating squares, but this time we’ll use
    our tri() function. Enter the code in [Listing 5-15](ch05.xhtml#ch05list15) in
    place of the def draw() section in Processing and then run it.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学会了如何旋转单个等边三角形，我们需要找出如何将多个等边三角形排列成一个圆形。这与旋转方形时的做法类似，但这次我们将使用我们的tri()函数。在Processing中将[代码清单
    5-15](ch05.xhtml#ch05list15)的代码替换为def draw()部分，然后运行它。
- en: '*triangles.pyde*'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '*triangles.pyde*'
- en: 'def setup():'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 'def setup():'
- en: size(600,600)
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: size(600,600)
- en: rectMode(CENTER)
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: rectMode(CENTER)
- en: t = 0
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: t = 0
- en: 'def draw():'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 'def draw():'
- en: global t
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: global t
- en: background(255)#white
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: background(255)#白色
- en: translate(width/2,height/2)
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: translate(width/2,height/2)
- en: '➊ for i in range(90):'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ for i in range(90):'
- en: '#space the triangles evenly'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '#将三角形均匀分布'
- en: '#around the circle'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '#在圆周上'
- en: rotate(radians(360/90))
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: rotate(radians(360/90))
- en: '➋ pushMatrix() #save this orientation'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '➋ pushMatrix() #保存此方向'
- en: '#go to circumference of circle'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '#移至圆周上的位置'
- en: translate(200,0)
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: translate(200,0)
- en: '#spin each triangle'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '#旋转每个三角形'
- en: rotate(radians(t))
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: rotate(radians(t))
- en: '#draw the triangle'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '#绘制三角形'
- en: tri(100)
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: tri(100)
- en: '#return to saved orientation'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '#返回到保存的方向'
- en: ➌ popMatrix()
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ popMatrix()
- en: t += 0.5
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: t += 0.5
- en: 'def tri(length):'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 'def tri(length):'
- en: '➍ noFill() #makes the triangle transparent'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '➍ noFill() #使三角形透明'
- en: triangle(0,-length,
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: triangle(0,-length,
- en: -length*sqrt(3)/2, length/2,
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: -length*sqrt(3)/2, length/2,
- en: length*sqrt(3)/2, length/2)
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: length*sqrt(3)/2, length/2)
- en: '*Listing 5-15: Creating 90 rotating triangles*'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '*代码清单 5-15：创建90个旋转的三角形*'
- en: At ➊, we use the for loop to arrange 90 triangles around the circle, making
    sure they’re evenly spaced by dividing 360 by 90\. Then at ➋ we use pushMatrix()
    to save this position before moving the grid around. At the end of the loop at
    ➌ we use popMatrix() to return to the saved position. In the tri() function at
    ➍, we add the noFill() line to make the triangles transparent.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们使用for循环将90个三角形均匀地排列在圆周上，确保它们通过将360除以90来保持均匀间隔。然后在➋处，我们使用pushMatrix()保存当前位置，再移动网格。在循环的最后，在➌处使用popMatrix()返回到保存的位置。在tri()函数的➍处，我们添加了noFill()语句来使三角形透明。
- en: Now we have 90 rotating transparent triangles, but they’re all rotating in exactly
    the same way. It’s kind of cool, but not as cool as Antonsen’s sketch yet. Next,
    you’ll learn how to make each triangle rotate a little differently from the adjacent
    ones to make the pattern more interesting.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有90个旋转的透明三角形，但它们的旋转方式完全相同。这看起来很酷，但还没有达到Antonsen草图的效果。接下来，你将学习如何让每个三角形相对于相邻的三角形略微不同地旋转，从而使图案更加有趣。
- en: PHASE-SHIFTING THE ROTATION
  id: totrans-347
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 相位偏移旋转
- en: 'We can change the pattern in which the triangles rotate with a *phase shift*,
    which makes each triangle lag a little bit behind its neighbor, giving the sketch
    a “wave” or “cascade” effect. Each triangle has been assigned a number in the
    loop, represented by i. We need to add i to t in the rotate(radians(t)) function,
    like this:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过*相位偏移*改变三角形的旋转模式，这使得每个三角形稍微滞后于它的邻居，给草图带来“波浪”或“级联”的效果。每个三角形在循环中都有一个编号，表示为i。我们需要在rotate(radians(t))函数中将i加到t上，如下所示：
- en: rotate(radians(t+i))
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: rotate(radians(t+i))
- en: When you run this, you should see something like [Figure 5-23](ch05.xhtml#ch05fig23).
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行此代码时，你应该会看到类似于[图 5-23](ch05.xhtml#ch05fig23)的效果。
- en: '![image](../images/f099-01.jpg)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f099-01.jpg)'
- en: '*Figure 5-23: Rotating triangles with phase shift*'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-23：带相位偏移的旋转三角形*'
- en: 'Notice there’s a break in the pattern on the right side of the screen. This
    break in the pattern is caused by the phase shifts not matching up from the beginning
    triangle to the last triangle. We want a nice, seamless pattern, so we have to
    make the phase shifts add up to a multiple of 360 degrees to complete the circle.
    Because there are 90 triangles in the design, we’ll divide 360 by 90 and multiply
    that by i:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在屏幕的右侧有一个图案中断。这个中断是由于从第一个三角形到最后一个三角形的相位偏移没有对齐造成的。我们希望图案无缝连接，因此我们必须让相位偏移的总和是360度的倍数，从而完成一个圆圈。因为设计中有90个三角形，所以我们将360除以90，然后再乘以i：
- en: rotate(radians(t+i*360/90))
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: rotate(radians(t+i*360/90))
- en: It’s easy enough to calculate 360/90, which is 4, and then use that number to
    plug into the code, but I’m leaving the expression in because we’ll need it in
    case we want to change the number of triangles later. For now, this should create
    a nice seamless pattern, as shown in [Figure 5-24](ch05.xhtml#ch05fig24).
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 计算360/90很简单，结果是4，然后用这个数字代入代码中，但我还是保留了这个表达式，因为如果以后我们想改变三角形的数量时，我们会用到它。现在，这应该会创建一个像[图5-24](ch05.xhtml#ch05fig24)所示的无缝图案。
- en: '![image](../images/f100-01.jpg)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f100-01.jpg)'
- en: '*Figure 5-24: Seamlessly rotating triangles with phase shift*'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-24：带相位偏移的无缝旋转三角形*'
- en: By making our phase shifts add up to a multiple of 360, we were able to remove
    the break in the pattern.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使我们的相位偏移量加起来成为360的倍数，我们能够去除图案中的断裂。
- en: FINALIZING THE DESIGN
  id: totrans-359
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 完成设计
- en: To make the design look more like the one in [Figure 5-15](ch05.xhtml#ch05fig15),
    we need to change the phase shift a little. Play around with it yourself to see
    how you can change the look of the sketch!
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使设计看起来更像[图5-15](ch05.xhtml#ch05fig15)中的设计，我们需要稍微调整相位偏移量。自己动手试试，看看你能如何改变草图的外观！
- en: 'Here, we’re going to change the phase shift by multiplying i by 2, which will
    increase the shift between each triangle and its neighbor. Change the rotate()
    line in your code to the following:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将通过将i乘以2来改变相位偏移量，这将增加每个三角形与其相邻三角形之间的偏移量。将代码中的rotate()行更改为以下内容：
- en: rotate(radians(t+2*i*360/90))
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: rotate(radians(t+2*i*360/90))
- en: After making this change, run the code. As you can see in [Figure 5-25](ch05.xhtml#ch05fig25),
    our design now looks very close to the design we were trying to re-create.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在做出这个更改后，运行代码。正如你在[图5-25](ch05.xhtml#ch05fig25)中看到的，我们的设计现在看起来非常接近我们想要重建的设计。
- en: '![image](../images/f101-01.jpg)'
  id: totrans-364
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f101-01.jpg)'
- en: '*Figure 5-25: Re-creation of Antonsen’s “90 Rotating Equilateral Triangles”
    from [Figure 5-15](ch05.xhtml#ch05fig15)*'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-25：重建Antonsen的“90度旋转等边三角形”来自[图5-15](ch05.xhtml#ch05fig15)*'
- en: Now that you’ve learned how to re-create a complicated design like this, try
    the next exercise to test your transformation skills!
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学会了如何重建像这样的复杂设计，试试下一个练习，来测试你的变换技巧吧！
- en: 'EXERCISE 5-2: RAINBOW TRIANGLES'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 5-2：彩虹三角形
- en: Color each triangle of the rotating triangle sketch using stroke(). It should
    look like this.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 使用stroke()为旋转三角形草图中的每个三角形着色。它应该看起来像这样。
- en: '![image](../images/f101-02.jpg)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f101-02.jpg)'
- en: SUMMARY
  id: totrans-370
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how to draw shapes like circles, squares, and triangles
    and arrange them into different patterns using Processing’s built-in transformation
    functions. You also learned how to make your shapes dynamic by animating your
    graphics and adding color. Just like how Nasrudin’s house was just a collection
    of bricks, the complicated code examples in this chapter are just a collection
    of simpler shapes or functions.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何绘制圆形、正方形和三角形等形状，并使用Processing内置的变换函数将它们排列成不同的图案。你还学习了如何通过动画化图形和添加颜色使你的形状变得动态。就像Nasrudin的房子只是砖块的集合一样，本章中的复杂代码示例也只是由更简单的形状或函数组成。
- en: In the next chapter, you’ll build on what you learned in this chapter and expand
    your skills to using trigonometric functions like sine and cosine. You’ll draw
    even cooler designs and write new functions to create even more complicated behaviors,
    like leaving a trail and creating any shape from a bunch of vertices.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，你将基于本章所学，扩展技能，学习使用三角函数，如正弦和余弦。你将绘制更酷的设计，并编写新的函数，创造出更复杂的行为，例如留下轨迹，并从一堆顶点创建任何形状。
