- en: '[6](nsp-venkitachalam503045-0008.xhtml#rch06)'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[6](nsp-venkitachalam503045-0008.xhtml#rch06)'
- en: ASCII Art
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ASCII 艺术
- en: '![](images/nsp-venkitachalam503045-circle-image.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-circle-image.jpg)'
- en: In the 1990s, when email ruled and graphics capabilities were limited, it was
    common to include a signature in your email that contained a graphic made of text,
    commonly called *ASCII art*. (ASCII is simply a character-encoding scheme.) [Figure
    6-1](nsp-venkitachalam503045-0019.xhtml#fig6-1) shows a couple of examples. Although
    the internet has made sharing images immeasurably easier, the humble text graphic
    isn’t quite dead yet.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在 1990 年代，当电子邮件盛行而图形处理能力有限时，通常会在电子邮件中附上一个由文本组成的图形签名，通常称为 *ASCII 艺术*。（ASCII 只是一个字符编码方案。）[图
    6-1](nsp-venkitachalam503045-0019.xhtml#fig6-1) 显示了几个例子。虽然互联网让图像共享变得无比容易，但这种简朴的文本图形并没有完全消失。
- en: ASCII art has its origins in typewriter art created in the late 1800s. In the
    1960s, when computers had minimal graphics processing hardware, ASCII was used
    to represent images. These days, ASCII art continues as a form of expression on
    the internet, and you can find a variety of creative examples online.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: ASCII 艺术起源于 19 世纪末的打字机艺术。到了 1960 年代，当时计算机的图形处理硬件非常有限，ASCII 被用来表示图像。如今，ASCII
    艺术仍然作为一种表达形式存在于互联网上，你可以在线找到各种创意的例子。
- en: '![](images/nsp-venkitachalam503045-f06001.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f06001.jpg)'
- en: 'Figure 6-1: Examples of ASCII art'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-1：ASCII 艺术示例
- en: 'In this project, you’ll use Python to create a program that generates ASCII
    art from graphical images. The program will let you specify the width of the output
    (the number of columns of text) and set a vertical scale factor. It also supports
    two mappings of grayscale values to ASCII characters: a sparse 10-level mapping
    and a more finely calibrated 70-level mapping.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将使用 Python 创建一个程序，将图形图像转换为 ASCII 艺术。该程序将允许你指定输出的宽度（文本的列数）并设置垂直缩放因子。它还支持两种将灰度值映射到
    ASCII 字符的方式：一种是稀疏的 10 级映射，另一种是更精细的 70 级映射。
- en: 'To generate your ASCII art from an image, you’ll learn how to do the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要从图像生成你的 ASCII 艺术，你将学习以下内容：
- en: • Convert images to grayscale using `Pillow`, a fork of the Python Imaging Library
    (PIL).
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用 `Pillow`（Python 图像库 PIL 的一个分支）将图像转换为灰度。
- en: • Compute the average brightness of a grayscale image using `numpy`.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用 `numpy` 计算灰度图像的平均亮度。
- en: • Use a string as a quick lookup table for grayscale values.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用字符串作为灰度值的快速查找表。
- en: '[How It Works](nsp-venkitachalam503045-0008.xhtml#rah0801)'
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[它是如何工作的](nsp-venkitachalam503045-0008.xhtml#rah0801)'
- en: This project takes advantage of the fact that from a distance, we perceive grayscale
    images as the average value of their brightness. For example, in [Figure 6-2](nsp-venkitachalam503045-0019.xhtml#fig6-2),
    you can see a grayscale image of a building and, next to it, an image filled with
    the average brightness value of the building image. If you look at the images
    from across the room, they will look similar.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目利用了这样一个事实：从远处看，我们将灰度图像感知为其亮度的平均值。例如，在[图 6-2](nsp-venkitachalam503045-0019.xhtml#fig6-2)中，你可以看到一张建筑物的灰度图像，以及它旁边的另一张图像，显示了建筑物图像的平均亮度值。如果你从远处看这些图像，它们会显得相似。
- en: ASCII art is generated by splitting an image into tiles and replacing each tile
    with an ASCII character, based on the tile’s average brightness value. Brighter
    tiles are replaced with sparser ASCII characters (that is, characters that contain
    a lot of whitespace), such as a period (`.`) or colon (`:`), while darker tiles
    are replaced with denser ASCII characters, such as an ampersand (`@`) or dollar
    sign (`$`). From a distance, since our eyes have limited resolution, we sort of
    see the “average” values in ASCII art while losing the details that would otherwise
    make the art look less real.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: ASCII 艺术是通过将图像分割成多个小块，并根据每个小块的平均亮度值，用 ASCII 字符替换每个小块来生成的。较亮的小块会被替换为稀疏的 ASCII
    字符（即包含大量空白的字符），如句点（`.`）或冒号（`:`），而较暗的小块则会被替换为更密集的 ASCII 字符，如“@”或“$”。从远处看，由于我们的眼睛分辨率有限，我们在
    ASCII 艺术中看到的是“平均”值，而失去了本来能使艺术作品看起来更真实的细节。
- en: '![](images/nsp-venkitachalam503045-f06002.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f06002.jpg)'
- en: 'Figure 6-2: The average value of a grayscale image'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-2：灰度图像的平均值
- en: This program will take a given image and first convert it to 8-bit grayscale
    so that each pixel has a grayscale value in the range [0, 255] (the range of an
    8-bit integer). Think of this 8-bit value as the pixel’s *brightness*, with 0
    being black, 255 being white, and the values in between being shades of gray.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序将接受给定的图像，并首先将其转换为8位灰度图像，这样每个像素的灰度值将在[0, 255]范围内（8位整数的范围）。可以把这个8位值看作是像素的*亮度*，其中0代表黑色，255代表白色，介于两者之间的是灰度色调。
- en: Next, it will split the image into a grid of *M*×*N* tiles (where *M* is the
    number of rows and *N* the number of columns in the ASCII image). The program
    will then calculate the average brightness value for each tile in the grid and
    match it with an appropriate ASCII character by predefining a *ramp* (an increasing
    set of values) of ASCII characters to represent grayscale values in the range
    [0, 255]. It will use these ramp values as a lookup table for the brightness values.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，程序会将图像拆分成一个 *M*×*N* 的网格（其中 *M* 是ASCII图像中的行数，*N* 是列数）。然后，程序会计算每个网格块的平均亮度值，并通过预定义的*色阶*（一个递增的ASCII字符集合）来匹配合适的ASCII字符，表示灰度值范围[0,
    255]。它将使用这些色阶值作为亮度值的查找表。
- en: The finished ASCII art is just a bunch of lines of text. To display the text,
    you’ll use a constant-width (also called *monospace*) font such as Courier because
    unless each text character has the same width, the characters in the image won’t
    line up properly along a grid, and you’ll end up with unevenly spaced and scrambled
    output.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 完成的ASCII艺术仅仅是一堆文本行。为了显示这些文本，你需要使用一个等宽字体（也叫做*等距*字体），例如Courier，因为如果每个文本字符的宽度不相同，图像中的字符将无法沿着网格正确排列，最终输出将变得不均匀且混乱。
- en: The *aspect ratio* (the ratio of width to height) of the font used also affects
    the final image. If the aspect ratio of the space taken up by a character is different
    from the aspect ratio of the image tile the character is replacing, the final
    ASCII image will appear distorted. In effect, you’re trying to replace an image
    tile with an ASCII character, so their shapes need to match. For example, if you
    were to split your image into square tiles and then replace each of the tiles
    with a font where characters are taller than they are wide, the final output would
    appear stretched vertically. To address this issue, you’ll scale the rows in your
    grid to match the Courier aspect ratio. (You can send the program command line
    arguments to modify the scaling to match other fonts.)
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的*纵横比*（宽度与高度的比值）也会影响最终图像。如果字符所占空间的纵横比与字符替代的图像块的纵横比不同，最终的ASCII图像会显得扭曲。实际上，你是在尝试用ASCII字符替代图像块，所以它们的形状需要匹配。例如，如果你将图像拆分成正方形块，然后将每个块替换为字符比宽度更高的字体，最终输出的图像会显得垂直拉伸。为了解决这个问题，你需要调整网格中的行以匹配Courier字体的纵横比。（你可以通过命令行参数修改程序的缩放，以匹配其他字体。）
- en: 'In sum, here are the steps the program takes to generate the ASCII image:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，程序生成ASCII图像的步骤如下：
- en: 1\. Convert the input image to grayscale.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1\. 将输入图像转换为灰度图像。
- en: 2\. Split the image into *M*×*N* tiles.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2\. 将图像拆分成 *M*×*N* 个小块。
- en: 3\. Correct *M* (the number of rows) to match the image and font aspect ratio.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3\. 修正 *M*（行数），使其与图像和字体的纵横比匹配。
- en: 4\. Compute the average brightness for each image tile and then look up a suitable
    ASCII character for each.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 4\. 计算每个图像块的平均亮度，然后为每个块查找一个合适的ASCII字符。
- en: 5\. Assemble rows of ASCII character strings and print them to a file to form
    the final image.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 5\. 拼接ASCII字符字符串的行，并将其打印到文件中，形成最终图像。
- en: '[Requirements](nsp-venkitachalam503045-0008.xhtml#rah0802)'
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[要求](nsp-venkitachalam503045-0008.xhtml#rah0802)'
- en: In this project, you’ll use `Pillow`, the friendly fork of the Python Imaging
    Library, to read in the images, access their underlying data, and create and modify
    them. You’ll also use the `numpy` library to compute averages.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将使用`Pillow`，Python图像库的友好分支，来读取图像，访问它们的底层数据，并创建和修改它们。你还将使用`numpy`库来计算平均值。
- en: '[The Code](nsp-venkitachalam503045-0008.xhtml#rah0803)'
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[代码](nsp-venkitachalam503045-0008.xhtml#rah0803)'
- en: You’ll begin by defining the grayscale levels used to generate the ASCII art.
    Then you’ll look at how the image is split into tiles and how average brightness
    is computed for those tiles. Next, you’ll work on replacing the tiles with ASCII
    characters to generate the final output. Finally, you’ll set up command line parsing
    for the program to allow users to specify the output size, output filename, and
    so on.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你将首先定义用于生成ASCII艺术的灰度级别。然后你会查看如何将图像拆分成小块，以及如何计算这些小块的平均亮度。接下来，你将替换小块中的内容，使用ASCII字符生成最终输出。最后，你将为程序设置命令行解析，允许用户指定输出大小、输出文件名等。
- en: For the full project code, skip to [“The Complete Code”](nsp-venkitachalam503045-0019.xhtml#ah0807)
    on [page 109](nsp-venkitachalam503045-0019.xhtml#p109). You can also download
    the code for this project from [https://github.com/mkvenkit/pp2e/blob/main/ascii/ascii.py](https://github.com/mkvenkit/pp2e/blob/main/ascii/ascii.py).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看完整的项目代码，请跳转至[“完整代码”](nsp-venkitachalam503045-0019.xhtml#ah0807)的[第109页](nsp-venkitachalam503045-0019.xhtml#p109)。你也可以从[https://github.com/mkvenkit/pp2e/blob/main/ascii/ascii.py](https://github.com/mkvenkit/pp2e/blob/main/ascii/ascii.py)下载该项目的代码。
- en: '[Defining the Grayscale Levels and Grid](nsp-venkitachalam503045-0008.xhtml#rbh0801)'
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[定义灰度级别和网格](nsp-venkitachalam503045-0008.xhtml#rbh0801)'
- en: As the first step in creating your program, define the scales you’ll use to
    convert image brightness values to ASCII characters as global values.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 创建程序的第一步是定义用于将图像亮度值转换为ASCII字符的灰度级别，将其设为全局值。
- en: 70 levels of gray
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 70级灰度
- en: gscale1 = "$@B%8&WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\|()1{}[]?-_+~<>i!lI;:,\"^`'.
    "
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: gscale1 = "$@B%8&WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\|()1{}[]?-_+~<>i!lI;:,\"^`'.
    "
- en: 10 levels of gray
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10级灰度
- en: gscale2 = "@%#*+=-:. "
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: gscale2 = "@%#*+=-:. "
- en: The value `gscale1` is a 70-level grayscale ramp, while `gscale2` is a simpler
    10-level grayscale ramp. Both of these values are stored as strings, with a range
    of characters that progress from darkest to lightest. The program will use the
    `gscale2` ramp by default, but you’ll include a command line option to use the
    more nuanced `gscale1` ramp instead.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 值`gscale1`是一个70级灰度渐变，而`gscale2`是一个更简单的10级灰度渐变。这两个值都作为字符串存储，字符的范围从最暗到最亮。程序默认使用`gscale2`渐变，但你可以通过命令行选项来使用更细致的`gscale1`渐变。
- en: NOTE To learn more about how characters are represented as grayscale values,
    see Paul Bourke’s “Character Representation of Grey Scale Images” at [http://paulbourke.net/dataformats/asciiart/](http://paulbourke.net/dataformats/asciiart/).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：要了解更多关于字符如何表示为灰度值的信息，请参阅Paul Bourke的《灰度图像的字符表示》：[http://paulbourke.net/dataformats/asciiart/](http://paulbourke.net/dataformats/asciiart/)。
- en: 'Now that you have your grayscale ramps, you can set up the image. The following
    code opens the image using `Pillow` and splits it into a grid:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了灰度渐变，你可以开始设置图像。以下代码使用`Pillow`打开图像并将其分割成网格：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: First, `Image.``open()` opens the input image file, and `Image.``convert()`
    converts the image to grayscale. The `"L"` stands for *luminance*, a measure of
    the brightness of an image. You store the width and height (measured in pixels)
    of the input image ❶. Then you compute the width of a tile for the number of columns
    (`cols`) specified by the user ❷. (The program uses a default of 80 columns if
    the user doesn’t set another value in the command line.) You use floating-point,
    not integer, division to avoid truncation errors while calculating the dimensions
    of the tiles.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`Image.``open()`打开输入图像文件，`Image.``convert()`将图像转换为灰度。“L”代表*亮度*，是图像亮度的度量。你存储输入图像的宽度和高度（以像素为单位）
    ❶。然后你计算一个小块的宽度，这个宽度是由用户指定的列数（`cols`）决定的 ❷。（如果用户没有在命令行中设置其他值，程序将使用80列作为默认值。）你使用浮点数而不是整数除法，以避免在计算小块尺寸时发生截断误差。
- en: Once you know the width of a tile, you compute its height using the vertical
    scale factor passed in as `scale` ❸. This way, each tile will match the aspect
    ratio of the font you’re using to display the text so that the final image won’t
    be distorted. The value for `scale` can be passed in as an argument, or it’s set
    to a default of `0.43`, which works well for displaying the result in Courier.
    Having calculated the height of each row, you compute the number of rows in the
    grid ❹.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你知道了一个小块的宽度，你就可以使用传入的垂直缩放因子`scale` ❸来计算它的高度。这样，每个小块将匹配你用来显示文本的字体的纵横比，从而确保最终图像不会变形。`scale`的值可以作为参数传递，或者默认为`0.43`，这个值在Courier字体中显示效果很好。在计算完每行的高度后，你可以计算网格中的行数
    ❹。
- en: '[Computing the Average Brightness](nsp-venkitachalam503045-0008.xhtml#rbh0802)'
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[计算平均亮度](nsp-venkitachalam503045-0008.xhtml#rbh0802)'
- en: Next, you need a way to compute the average brightness for a tile in the grayscale
    image. The function `getAverageL()` does the job.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要一种方法来计算灰度图像中某个瓦片的平均亮度。`getAverageL()`函数可以完成这个任务。
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The image tile is passed into the function as a PIL `Image` object. You convert
    the image into a `numpy` array ❶, at which point `im` becomes a two-dimensional
    array containing the brightness values of the image’s pixels. You store the dimensions
    (width and height) of the array and then use `numpy.reshape()` to convert the
    two-dimensional array into a flat one-dimensional array whose length is a product
    of the original array’s width and height (`w*h`). You pass the reshaped array
    to `numpy.average()`, which sums the array values and computes the average brightness
    level of the entire image tile ❷.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图像瓦片作为一个PIL `Image`对象传递到函数中。你将图像转换成一个`numpy`数组❶，此时`im`变成了一个二维数组，包含了图像像素的亮度值。你存储数组的维度（宽度和高度），然后使用`numpy.reshape()`将二维数组转换成一个一维的扁平数组，其长度是原数组宽度和高度的乘积（`w*h`）。你将重塑后的数组传递给`numpy.average()`，该函数会对数组的值进行求和，并计算整个图像瓦片的平均亮度值❷。
- en: '[Generating the ASCII Content from the Image](nsp-venkitachalam503045-0008.xhtml#rbh0803)'
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[从图像生成ASCII内容](nsp-venkitachalam503045-0008.xhtml#rbh0803)'
- en: 'The main part of the program generates the ASCII content from the image:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的主要部分从图像生成ASCII内容：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this section of the program, the ASCII image is first stored as a list of
    strings, which you initialize ❶. Next, you iterate through the rows of image tiles
    ❷, calculating the top and bottom y-coordinates of each image tile in a given
    row as *y1* and *y2*. These are floating-point calculations, but you truncate
    them to integers before passing them to an image-cropping method.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序的这一部分，首先将ASCII图像存储为一个字符串列表，你将其初始化❶。接下来，你迭代图像瓦片的行❷，计算给定行中每个图像瓦片的上下y坐标，分别记为*y1*和*y2*。这些是浮点数计算，但在将它们传递给图像裁剪方法之前，你将其截断为整数。
- en: Next, because dividing the image into tiles creates edge tiles of the same size
    only when the image width is an integer multiple of the number of columns, you
    correct for the bottom y-coordinate of the tiles in the last row by setting the
    y-coordinate to the image’s actual height (`H`) ❸. By doing so, you ensure that
    the bottom edge of the image isn’t truncated.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，因为将图像划分成瓦片时，只有当图像宽度是列数的整数倍时，才会创建大小相同的边缘瓦片，所以你通过将最后一行瓦片的底部y坐标设置为图像的实际高度（`H`）来修正它❸。这样做可以确保图像的底部边缘不会被截断。
- en: You add an empty string into the ASCII image list as a compact way to represent
    the current image row ❹. You’ll fill in this string next. Essentially, you’re
    treating the string as a list of characters that you can append to. Then you iterate
    over all the tiles in a given row of the image, column by column ❺. You compute
    the left and right x-coordinates of each tile as *x1* and *x2*. When you get to
    the last tile in the row, you set the right x-coordinate to the width of the image
    (`W`), for the same reasons you corrected the final y-coordinate to the image’s
    height.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你在ASCII图像列表中添加一个空字符串，以简洁的方式表示当前的图像行❹。接下来，你会填充这个字符串。实际上，你将这个字符串当作一个可以追加字符的字符列表。然后，你按列遍历图像中给定行的所有瓦片❺。你计算每个瓦片的左右x坐标，分别记为*x1*和*x2*。当你到达行中的最后一个瓦片时，你将右边的x坐标设置为图像的宽度（`W`），理由与之前修正y坐标的方式相同。
- en: You’ve now calculated (*x1*, *y1*) and (*x2*, *y2*), the coordinates of the
    top-left and bottom-right corners of the current image tile. You pass these coordinates
    to `image.crop()` to extract the tile from the complete image ❻. Then you pass
    that tile (which takes the form of a PIL `Image` object) to the `getAverageL()`
    function ❼, defined in [“Computing the Average Brightness”](nsp-venkitachalam503045-0019.xhtml#bh0802)
    on [page 105](nsp-venkitachalam503045-0019.xhtml#p105), to get the average brightness
    of the tile. You scale the average brightness value from [0, 255] to [0, 9], the
    range of values for the default 10-level grayscale ramp ❾. You then use `gscale2`
    (the stored ramp string) as a lookup table for the relevant ASCII character. The
    line at ❽ is similar, except it scales the brightness value to the [0, 69] range
    of the 70-level grayscale ramp. This line will be used only when the `moreLevels`
    command line flag has been set. Finally, you append the looked-up ASCII character,
    `gsval`, to the text row ❿, and the code loops until all rows are processed.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经计算出了(*x1*, *y1*) 和 (*x2*, *y2*)，即当前图像块的左上角和右下角的坐标。你将这些坐标传递给 `image.crop()`
    来从完整的图像中提取图像块 ❻。然后，你将该图像块（它是一个 PIL `Image` 对象）传递给 `getAverageL()` 函数 ❼，该函数在 [“计算平均亮度”](nsp-venkitachalam503045-0019.xhtml#bh0802)
    的 [第 105 页](nsp-venkitachalam503045-0019.xhtml#p105) 中定义，用于获取该图像块的平均亮度。你将平均亮度值从
    [0, 255] 范围缩放到 [0, 9]，这是默认的 10 级灰度阶梯的值范围 ❾。然后，你使用 `gscale2`（存储的阶梯字符串）作为查找表，找到对应的
    ASCII 字符。❽ 处的代码类似，但它将亮度值缩放到 70 级灰度阶梯的 [0, 69] 范围。此行代码仅在设置了 `moreLevels` 命令行标志时使用。最后，你将查找出的
    ASCII 字符 `gsval` 添加到文本行 ❿，代码会循环直到所有行都处理完成。
- en: '[Creating Command Line Options](nsp-venkitachalam503045-0008.xhtml#rbh0804)'
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[创建命令行选项](nsp-venkitachalam503045-0008.xhtml#rbh0804)'
- en: 'Next, define some command line options for the program. This code uses the
    built-in `argparse.ArgumentParser` class:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为程序定义一些命令行选项。此代码使用内置的 `argparse.ArgumentParser` 类：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You include the following options:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以包含以下选项：
- en: --file Specifies the image file to input. This is the only required argument.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: --file 指定要输入的图像文件。这是唯一必需的参数。
- en: --scale Sets the vertical scale factor for a font other than Courier.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: --scale 设置其他字体的垂直缩放因子，而不是 Courier 字体。
- en: --out Sets the output filename for the generated ASCII art. Defaults to *out.txt*.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: --out 设置生成的 ASCII 艺术的输出文件名。默认为 *out.txt*。
- en: --cols Sets the number of text columns in the ASCII output.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: --cols 设置 ASCII 输出中的文本列数。
- en: --morelevels Selects the 70-level grayscale ramp instead of the default 10-level
    ramp.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: --morelevels 选择 70 级灰度阶梯，而不是默认的 10 级阶梯。
- en: '[Writing the ASCII Art Strings to a Text File](nsp-venkitachalam503045-0008.xhtml#rbh0805)'
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[将 ASCII 艺术字符串写入文本文件](nsp-venkitachalam503045-0008.xhtml#rbh0805)'
- en: 'Finally, take the generated list of ASCII character strings and write those
    strings to a text file:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，获取生成的 ASCII 字符串列表，并将这些字符串写入文本文件：
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You use the built-in `open()` function to open a new text file for writing ❶.
    Then you iterate through each string in the `aimg` list and write it to the file
    ❷. When you’re done, you close the file object to release system resources ❸.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用内置的 `open()` 函数打开一个新的文本文件进行写入 ❶。然后，你遍历 `aimg` 列表中的每个字符串，并将其写入文件 ❷。完成后，你关闭文件对象以释放系统资源
    ❸。
- en: '[Running the ASCII Art Generator](nsp-venkitachalam503045-0008.xhtml#rah0804)'
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[运行 ASCII 艺术生成器](nsp-venkitachalam503045-0008.xhtml#rah0804)'
- en: 'To run your finished program, enter a command like the following one, replacing
    `data/robot.jpg` with the relative path to the image file you want to use:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行你的完成程序，输入如下命令，将`data/robot.jpg`替换为你想使用的图片文件的相对路径：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[Figure 6-3](nsp-venkitachalam503045-0019.xhtml#fig6-3) shows the ASCII art
    that results from sending the image *robot.jpg* (at the left). Try adding the
    `--morelevels` option to see how the 70-level grayscale ramp compares to the 10-level
    ramp.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-3](nsp-venkitachalam503045-0019.xhtml#fig6-3) 显示了发送图像 *robot.jpg*（左侧）生成的
    ASCII 艺术。试着添加 `--morelevels` 选项，看看 70 级灰度阶梯与 10 级灰度阶梯的对比。'
- en: '![](images/nsp-venkitachalam503045-f06003.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f06003.jpg)'
- en: 'Figure 6-3: A sample run of *ascii.py*'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-3：*ascii.py* 的示例运行
- en: Now you’re all set to create your own ASCII art!
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已准备好创建自己的 ASCII 艺术了！
- en: '[Summary](nsp-venkitachalam503045-0008.xhtml#rah0805)'
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[总结](nsp-venkitachalam503045-0008.xhtml#rah0805)'
- en: In this project, you learned how to generate ASCII art from any input image.
    In the process, you learned how to split an image into a grid of tiles, how to
    compute the average brightness value of each tile, and how to replace each tile
    with a character based on the brightness values. Have fun creating your own ASCII
    art!
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你学会了如何将任何输入图像转换为ASCII艺术。在这个过程中，你学会了如何将图像分割成瓦片网格，如何计算每个瓦片的平均亮度值，以及如何根据亮度值用字符替换每个瓦片。享受创作你自己的ASCII艺术吧！
- en: '[Experiments!](nsp-venkitachalam503045-0008.xhtml#rah0806)'
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[实验！](nsp-venkitachalam503045-0008.xhtml#rah0806)'
- en: 'Here are some ideas for exploring ASCII art further:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些进一步探索ASCII艺术的想法：
- en: 1\. Run the program with the command line option `--scale 1.0`. How does the
    resulting image look? Experiment with different values for `scale`. Copy the output
    to a text editor and try setting the text to different fixed-width fonts to see
    how doing so affects the appearance of the final image.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1\. 使用命令行选项`--scale 1.0`运行程序。结果图像看起来如何？尝试不同的`scale`值。将输出复制到文本编辑器并尝试设置为不同的等宽字体，以查看这样做如何影响最终图像的外观。
- en: '2\. Add a command line option `--invert` to the program to invert the generated
    ASCII images so that black appears white, and vice versa. (Hint: try subtracting
    the tile brightness value from 255 during lookup.)'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2\. 向程序添加命令行选项`--invert`，以反转生成的ASCII图像，使黑色变为白色，反之亦然。（提示：尝试在查找时从255中减去瓦片亮度值。）
- en: '3\. In this project, you created lookup tables for grayscale values based on
    two hardcoded character ramps. Implement a command line option to pass in a different
    character ramp to create the ASCII art, like so:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3\. 在这个项目中，你根据两个硬编码字符坡道创建了灰度值查找表。实现一个命令行选项，传递不同的字符坡道来创建ASCII艺术，像这样：
- en: '[PRE6]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This should create the ASCII output using the given six-character ramp, where
    `@` maps to a brightness value of 0 and `.` maps to a value of 255.
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该使用给定的六字符坡道创建ASCII输出，其中`@`映射到亮度值0，`.`映射到亮度值255。
- en: '[The Complete Code](nsp-venkitachalam503045-0008.xhtml#rah0807)'
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[完整代码](nsp-venkitachalam503045-0008.xhtml#rah0807)'
- en: Here is the complete ASCII art program.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这是完整的ASCII艺术程序。
- en: '"""'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: ascii.py
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ascii.py
- en: A Python program that convert images to ASCII art.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一个将图像转换为ASCII艺术的Python程序。
- en: 'Author: Mahesh Venkitachalam'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 作者：马赫什·文基塔查拉姆
- en: '"""'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: import sys, random, argparse
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: import sys, random, argparse
- en: import numpy as np
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: import numpy as np
- en: import math
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: import math
- en: from PIL import Image
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: from PIL import Image
- en: 'grayscale level values from:'
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 灰度级值来自：
- en: http://paulbourke.net/dataformats/asciiart/
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: http://paulbourke.net/dataformats/asciiart/
- en: 70 levels of gray
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 70级灰度
- en: gscale1 = "$@B%8&WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\|()1{}[]?-_+~<>i!lI;:,\"^`'.
    "
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: gscale1 = "$@B%8&WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\|()1{}[]?-_+~<>i!lI;:,\"^`'.
    "
- en: 10 levels of gray
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10级灰度
- en: gscale2 = '@%#*+=-:. '
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: gscale2 = '@%#*+=-:. '
- en: 'def getAverageL(image):'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 'def getAverageL(image):'
- en: '"""'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: given PIL Image, return average value of grayscale value
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 给定PIL图像，返回灰度值的平均值
- en: '"""'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: '# get image as numpy array'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '# 将图像转换为numpy数组'
- en: im = np.array(image)
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: im = np.array(image)
- en: '# get shape'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '# 获取形状'
- en: w,h = im.shape
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: w,h = im.shape
- en: '# get average'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '# 获取平均值'
- en: return np.average(im.reshape(w*h))
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: return np.average(im.reshape(w*h))
- en: 'def convertImageToAscii(fileName, cols, scale, moreLevels):'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 'def convertImageToAscii(fileName, cols, scale, moreLevels):'
- en: '"""'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: given Image and dims (rows, cols) returns an m*n list of Images
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 给定图像和尺寸（行数，列数）返回一个m*n的图像列表
- en: '"""'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: '# declare globals'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '# 声明全局变量'
- en: global gscale1, gscale2
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: global gscale1, gscale2
- en: '# open image and convert to grayscale'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '# 打开图像并转换为灰度'
- en: image = Image.open(fileName).convert('L')
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: image = Image.open(fileName).convert('L')
- en: '# store dimensions'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '# 存储尺寸'
- en: W, H = image.size[0], image.size[1]
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: W, H = image.size[0], image.size[1]
- en: 'print("input image dims: {} x {}".format(W, H))'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 'print("输入图像尺寸: {} x {}".format(W, H))'
- en: '# compute width of tile'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '# 计算瓦片的宽度'
- en: w = W/cols
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: w = W/cols
- en: '# compute tile height based on aspect ratio and scale'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '# 根据长宽比和缩放计算瓦片高度'
- en: h = w/scale
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: h = w/scale
- en: '# compute number of rows'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '# 计算行数'
- en: rows = int(H/h)
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: rows = int(H/h)
- en: 'print("cols: {}, rows: {}".format(cols, rows))'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 'print("列数: {}, 行数: {}".format(cols, rows))'
- en: 'print("tile dims: {} x {}".format(w, h))'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 'print("瓦片尺寸: {} x {}".format(w, h))'
- en: '# check if image size is too small'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '# 检查图像尺寸是否过小'
- en: 'if cols > W or rows > H:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 'if cols > W or rows > H:'
- en: print("Image too small for specified cols!")
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: print("图片太小，无法满足指定的列数！")
- en: exit(0)
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: exit(0)
- en: '# an ASCII image is a list of character strings'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '# 一个ASCII图像是一个字符字符串的列表'
- en: aimg = []
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: aimg = []
- en: '# generate list of dimensions'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '# 生成尺寸列表'
- en: 'for j in range(rows):'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 'for j in range(rows):'
- en: y1 = int(j*h)
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: y1 = int(j*h)
- en: y2 = int((j+1)*h)
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: y2 = int((j+1)*h)
- en: '# correct last tile'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '# 修正最后一个瓦片'
- en: 'if j == rows-1:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 'if j == rows-1:'
- en: y2 = H
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: y2 = H
- en: '# append an empty string'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '# 添加一个空字符串'
- en: aimg.append("")
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: aimg.append("")
- en: 'for i in range(cols):'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(cols):'
- en: '# crop image to tile'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '# 裁剪图像为瓦片'
- en: x1 = int(i*w)
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: x1 = int(i*w)
- en: x2 = int((i+1)*w)
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: x2 = int((i+1)*w)
- en: '# correct last tile'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '# 修正最后一个块'
- en: 'if i == cols-1:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 'if i == cols-1:'
- en: x2 = W
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: x2 = W
- en: '# crop image to extract tile'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '# 裁剪图像以提取块'
- en: img = image.crop((x1, y1, x2, y2))
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: img = image.crop((x1, y1, x2, y2))
- en: '# get average luminance'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '# 获取平均亮度'
- en: avg = int(getAverageL(img))
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: avg = int(getAverageL(img))
- en: '# look up ASCII char'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '# 查找 ASCII 字符'
- en: 'if moreLevels:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 'if moreLevels:'
- en: gsval = gscale1[int((avg*69)/255)]
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: gsval = gscale1[int((avg*69)/255)]
- en: 'else:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: gsval = gscale2[int((avg*9)/255)]
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: gsval = gscale2[int((avg*9)/255)]
- en: '# append ASCII char to string'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '# 将 ASCII 字符添加到字符串'
- en: aimg[j] += gsval
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: aimg[j] += gsval
- en: '# return image'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '# 返回图像'
- en: return aimg
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: return aimg
- en: main() function
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: main() 函数
- en: 'def main():'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 'def main():'
- en: '# create parser'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '# 创建解析器'
- en: descStr = "This program converts an image into ASCII art."
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: descStr = "该程序将图像转换为 ASCII 艺术。"
- en: parser = argparse.ArgumentParser(description=descStr)
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: parser = argparse.ArgumentParser(description=descStr)
- en: '# add expected arguments'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '# 添加预期的参数'
- en: parser.add_argument('--file', dest='imgFile', required=True)
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: parser.add_argument('--file', dest='imgFile', required=True)
- en: parser.add_argument('--scale', dest='scale', required=False)
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: parser.add_argument('--scale', dest='scale', required=False)
- en: parser.add_argument('--out', dest='outFile', required=False)
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: parser.add_argument('--out', dest='outFile', required=False)
- en: parser.add_argument('--cols', dest='cols', required=False)
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: parser.add_argument('--cols', dest='cols', required=False)
- en: parser.add_argument('--morelevels',dest='moreLevels',action='store_true')
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: parser.add_argument('--morelevels',dest='moreLevels',action='store_true')
- en: '# parse args'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '# 解析参数'
- en: args = parser.parse_args()
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: args = parser.parse_args()
- en: imgFile = args.imgFile
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: imgFile = args.imgFile
- en: '# set output file'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置输出文件'
- en: outFile = 'out.txt'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: outFile = 'out.txt'
- en: 'if args.outFile:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 'if args.outFile:'
- en: outFile = args.outFile
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: outFile = args.outFile
- en: '# set scale default as 0.43, which suits a Courier font'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置默认缩放比例为 0.43，适用于 Courier 字体'
- en: scale = 0.43
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: scale = 0.43
- en: 'if args.scale:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 'if args.scale:'
- en: scale = float(args.scale)
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: scale = float(args.scale)
- en: '# set cols'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置列数'
- en: cols = 80
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: cols = 80
- en: 'if args.cols:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 'if args.cols:'
- en: cols = int(args.cols)
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: cols = int(args.cols)
- en: print('generating ASCII art...')
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: print('生成 ASCII 艺术中...')
- en: '# convert image to ASCII text'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '# 将图像转换为 ASCII 文本'
- en: aimg = convertImageToAscii(imgFile, cols, scale, args.moreLevels)
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: aimg = convertImageToAscii(imgFile, cols, scale, args.moreLevels)
- en: '# open file'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '# 打开文件'
- en: f = open(outFile, 'w')
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: f = open(outFile, 'w')
- en: '# write to file'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '# 写入文件'
- en: 'for row in aimg:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 'for row in aimg:'
- en: f.write(row + '\n')
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: f.write(row + '\n')
- en: '# clean up'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '# 清理'
- en: f.close()
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: f.close()
- en: print("ASCII art written to {}.".format(outFile))
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: print("ASCII 艺术已写入 {}.".format(outFile))
- en: call main
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用 main
- en: 'if __name__ == ''__main__'':'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: main()
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: main()
