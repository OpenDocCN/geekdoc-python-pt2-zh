- en: '[14](nsp-venkitachalam503045-0008.xhtml#rch14)'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[14](nsp-venkitachalam503045-0008.xhtml#rch14)'
- en: IoT Garden
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 物联网花园
- en: '![](images/nsp-venkitachalam503045-circle-image.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-circle-image.jpg)'
- en: We live in an era where our phones talk to light bulbs and where toothbrushes
    want to access the internet. This is possible through the *Internet of Things
    (**IoT**)*, networks of everyday devices embedded with sensors that communicate
    with each other and the internet, usually in a wireless fashion. In this chapter,
    you’ll build your own IoT sensor network to monitor the temperature and humidity
    conditions in your garden. The network will consist of one or more low-power devices
    running Python code and transmitting real-time sensor data wirelessly to a Raspberry
    Pi. The Pi will log the data and make it available over a local web server. You’ll
    be able to view the sensor data through a web browser, as well as receive real-time
    alerts on your mobile device when extreme conditions occur.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们生活在一个手机与灯泡对话、牙刷也想连接互联网的时代。这一切通过*物联网（**IoT**）*成为可能，物联网是由嵌入传感器的日常设备组成的网络，这些设备彼此和互联网进行通信，通常是无线方式。在本章中，你将构建自己的物联网传感器网络来监控花园中的温湿度状况。这个网络将由一个或多个低功耗设备组成，这些设备运行Python代码并将实时传感器数据通过无线方式传输到树莓派。树莓派将记录数据并通过本地Web服务器提供数据。你将能够通过Web浏览器查看传感器数据，并且在出现极端情况时，通过移动设备实时接收警报。
- en: 'Some of the concepts you’ll learn about through this project are:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个项目，你将学习到一些概念：
- en: • Putting together a low-power IoT sensor network
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 组建低功耗物联网传感器网络
- en: • Understanding the basics of the Bluetooth Low Energy (BLE) protocol
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 理解低功耗蓝牙（BLE）协议的基础
- en: • Building a BLE scanner on the Raspberry Pi
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 在树莓派上构建BLE扫描器
- en: • Using a SQLite database to store sensor data
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用SQLite数据库存储传感器数据
- en: • Running a web server on the Pi using `Bottle`
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 在树莓派上使用`Bottle`运行Web服务器
- en: • Using If This Then That (IFTTT) to send alerts to your mobile phone
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用IFTTT向你的手机发送警报
- en: '[How It Works](nsp-venkitachalam503045-0008.xhtml#rah1601)'
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[工作原理](nsp-venkitachalam503045-0008.xhtml#rah1601)'
- en: The IoT devices you’ll use for this project are Adafruit BLE Sense boards, which
    have built-in temperature and humidity sensors. The devices periodically take
    measurements and transmit the sensor data wirelessly using Bluetooth Low Energy
    (BLE), which we’ll discuss soon. This data is picked up by the Raspberry Pi running
    a BLE scanner. The Pi uses a database to store and retrieve the data, and it also
    runs a web server so it can display the data on a web page. Additionally, the
    Pi has logic to detect anomalies in the temperature and humidity data and to send
    an alert to a user’s mobile device via the IFTTT service when such anomalies occur.
    [Figure 14-1](nsp-venkitachalam503045-0029.xhtml#fig14-1) summarizes the architecture
    of the project.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目中使用的物联网（IoT）设备是Adafruit BLE Sense开发板，它们内置了温度和湿度传感器。设备会定期进行测量，并通过低功耗蓝牙（BLE）无线传输传感器数据，我们将在接下来讨论。数据通过运行BLE扫描器的树莓派（Raspberry
    Pi）接收。树莓派使用数据库存储和检索数据，并且运行一个Web服务器，使其能够在网页上显示数据。此外，树莓派还具有检测温湿度数据异常的逻辑，并在发生异常时通过IFTTT服务向用户的移动设备发送警报。[图14-1](nsp-venkitachalam503045-0029.xhtml#fig14-1)总结了项目的架构。
- en: '![](images/nsp-venkitachalam503045-f14001.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f14001.jpg)'
- en: 'Figure 14-1: The IoT garden system architecture'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图14-1：物联网花园系统架构
- en: You may wonder why you need the Raspberry Pi at all. Why can’t the sensor devices
    talk directly to the internet instead of going through the Pi? The answer lies
    in power consumption. If the devices were talking directly to the internet via
    a protocol like Wi-Fi, they would typically consume more than 10 times the power
    compared to using BLE. This is important, because IoT devices are usually powered
    by batteries, and we expect them to last a very long time. The arrangement in
    [Figure 14-1](nsp-venkitachalam503045-0029.xhtml#fig14-1), where you have a network
    of low-power wireless devices talking to a gateway (the Raspberry Pi, in this
    case), is a common architecture in the world of IoT.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，为什么一定需要树莓派呢？为什么传感器设备不能直接与互联网通信，而是通过树莓派进行中转？答案在于功耗。如果设备通过像Wi-Fi这样的协议直接与互联网连接，它们通常会消耗比使用BLE高出10倍以上的电量。这非常重要，因为物联网设备通常由电池供电，我们期望它们能够持续很长时间。[图14-1](nsp-venkitachalam503045-0029.xhtml#fig14-1)中展示的这种架构，其中低功耗无线设备通过网关（在此为树莓派）进行通信，是物联网世界中常见的架构。
- en: Another feature of this project’s architecture is that your data remains in
    your hands—inside a database on your Pi, to be precise. You aren’t blasting it
    over the internet, but rather confining it to your local network. This may not
    be critical for basic garden data, but it’s still good to know that an IoT device
    doesn’t always *need* to send everything over the internet for it to be useful.
    Privacy and security are two good reasons for exposing your data to the internet
    only when it’s really necessary. In this case, you’ll still make use of the internet
    a little bit to send the IFTTT alerts.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目架构的另一个特点是你的数据始终掌握在自己手中——准确地说，是存储在树莓派上的数据库中。你不会将数据上传到互联网，而是将其局限于本地网络。这对于基础的园艺数据来说可能不那么关键，但依然值得知道，物联网设备并不总是*需要*将所有数据通过互联网发送出去才能发挥作用。隐私和安全是两个重要原因，确保数据只有在真正必要时才暴露到互联网。在本项目中，你依然会稍微利用互联网，发送IFTTT警报。
- en: '[Bluetooth Low Energy](nsp-venkitachalam503045-0008.xhtml#rbh1601)'
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[蓝牙低功耗](nsp-venkitachalam503045-0008.xhtml#rbh1601)'
- en: BLE is a subset of the same wireless technology standard that enables Bluetooth
    headphones and speakers, but it’s optimized for low-power, battery-operated devices.
    BLE is how your smartphone speaks to your smartwatch or your fitness tracker,
    for example. Devices that communicate over BLE can be categorized as either *central*
    or *peripheral*. Usually, central devices are more capable hardware such as laptops
    and phones, while peripheral devices are less capable hardware such as fitness
    bands and beacons. In this project, the Raspberry Pi is the central device, and
    the Adafruit BLE Sense boards are the peripherals.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: BLE是与蓝牙耳机和扬声器相同无线技术标准的子集，但它针对低功耗、使用电池的设备进行了优化。例如，BLE就是你的智能手机与智能手表或健身追踪器之间通信的方式。通过BLE通信的设备可以分为*中央设备*和*外围设备*。通常，中央设备是功能更强的硬件，如笔记本电脑和手机，而外围设备则是功能较弱的硬件，如健身带和信标。在这个项目中，树莓派是中央设备，Adafruit
    BLE Sense板是外围设备。
- en: NOTE The distinction between central and peripheral devices isn’t always clear-cut.
    Modern BLE chips allow the same piece of hardware to function as a central device,
    a peripheral, or a combination of both.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：中央设备和外围设备之间的区别并非总是那么明确。现代的BLE芯片允许同一硬件既能作为中央设备，也能作为外围设备，甚至两者兼有。
- en: A BLE peripheral makes its presence known via *advertisement packets*, as shown
    in [Figure 14-2](nsp-venkitachalam503045-0029.xhtml#fig14-2). These packets of
    data, which are typically sent out every few milliseconds, contain information
    such as the name of the peripheral, its transmission power, its manufacturer data,
    whether the central device can connect to it, and so on. The central device continuously
    scans for advertisement packets, and it can use information in the packets to
    establish communication with the peripheral.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一个BLE外围设备通过*广告数据包*向外界表明其存在，如[图14-2](nsp-venkitachalam503045-0029.xhtml#fig14-2)所示。这些数据包通常每隔几毫秒就会发送一次，包含的信息有外围设备的名称、传输功率、制造商数据、是否可以与中央设备连接等。中央设备持续扫描广告数据包，并可以利用包中的信息与外围设备建立通信。
- en: '![](images/nsp-venkitachalam503045-f14002.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f14002.jpg)'
- en: 'Figure 14-2: The BLE advertising scheme'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图14-2：BLE广告方案
- en: The amount of data in an advertisement packet is limited to just 31 bytes to
    conserve the peripheral’s battery, but the peripheral can optionally send an additional
    packet of information via a separate transmission called a *scan response*. The
    peripheral indicates whether a scan response is available as part of its normal
    advertisement packet. If the central device wants the extra data, it then sends
    a scan response request, which prompts the peripheral to take a break from sending
    advertisement packets and send the scan response instead. For this project, though,
    you need very little data from the sensors, so you can just put the temperature
    and humidity data directly in the advertisement packets.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 广告数据包的大小限制为仅31字节，以节省外围设备的电池，但外围设备可以选择通过单独的传输发送额外的信息包，这个过程被称为*扫描响应*。外围设备会在其正常广告数据包中指示是否有扫描响应可用。如果中央设备需要额外的数据，它会发送扫描响应请求，这会促使外围设备暂停发送广告数据包，改为发送扫描响应。不过，对于这个项目，你只需要传感器提供的非常少量的数据，因此你可以直接将温湿度数据放入广告数据包中。
- en: 'On the Raspberry Pi side, you’ll build a BLE scanner using BlueZ, the official
    Bluetooth protocol stack on Linux. Specifically, you’ll make use of the following
    three command line programs:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在树莓派侧，你将使用BlueZ（Linux上的官方蓝牙协议栈）构建一个BLE扫描器。具体来说，你将使用以下三个命令行程序：
- en: hciconfig Resets BLE on the Pi during program initialization
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: hciconfig 在程序初始化时重置树莓派上的BLE
- en: hcitool       Scans for BLE peripherals
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: hcitool       扫描BLE外设
- en: hcidump       Reads the advertisement data from the BLE peripherals
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: hcidump       读取来自BLE外设的广告数据
- en: '`hciconfig` and `hcitool` come as part of the Raspberry Pi OS installation,
    but you’ll need to install `hcidump` from a terminal, as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`hciconfig`和`hcitool`是树莓派操作系统安装的一部分，但你需要通过终端安装`hcidump`，如下所示：'
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here’s what a typical command line session on the Raspberry Pi looks like with
    these tools. First, run `hcidump` in a shell to get ready to output data packets
    once the scan begins:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是树莓派上使用这些工具的典型命令行会话。首先，在终端中运行`hcidump`，准备在扫描开始时输出数据包：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This tells you that `hcidump` is waiting for BLE input. Next, run the `lescan`
    command with `hcitool` in a different shell to start scanning for BLE devices:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉你`hcidump`正在等待BLE输入。接下来，在另一个终端中运行`hcitool`的`lescan`命令，开始扫描BLE设备：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This indicates that the scanner has detected a whole lot of BLE devices (they’re
    everywhere these days!). The moment you run the `lescan` command, `hcidump` starts
    printing out advertisement packet data, so your `hcidump` shell should now be
    full of messages like the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示扫描器已经检测到大量BLE设备（现在它们无处不在！）。当你运行`lescan`命令时，`hcidump`开始输出广告包数据，因此你的`hcidump`终端现在应该充满了如下信息：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The messages are output as hexadecimal bytes (rather than human-readable text)
    because you started `hcidump` with the `--raw` option.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你使用`--raw`选项启动了`hcidump`，所以消息作为十六进制字节输出（而不是人类可读的文本）。
- en: This example illustrated using the BlueZ tools manually at the command line.
    For the project, you’ll instead execute the commands from inside the Python code
    running on your Pi. The Python code will also read the advertisement packets and
    get the sensor data.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例展示了如何在命令行中手动使用BlueZ工具。对于这个项目，你将从树莓派上运行的Python代码中执行这些命令。Python代码还会读取广告包并获取传感器数据。
- en: '[The Bottle Web Framework](nsp-venkitachalam503045-0008.xhtml#rbh1602)'
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[Bottle Web框架](nsp-venkitachalam503045-0008.xhtml#rbh1602)'
- en: 'To monitor the sensor data via a web interface, you’ll need to have the Pi
    run a web server. To do this, you’ll use `Bottle`, a Python web framework with
    a simple interface. (In fact, the entire library consists of a single source file
    named *bottle.py*.) Here’s the code needed to serve a simple web page from a Pi
    using `Bottle`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过网页接口监控传感器数据，你需要让树莓派运行一个web服务器。为此，你将使用`Bottle`，一个具有简单界面的Python web框架。（实际上，整个库由一个名为*bottle.py*的源文件组成。）以下是使用`Bottle`从树莓派提供一个简单网页所需的代码：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This code first defines a route to a URL or path (in this case, `/hello`) where
    the client can send data requests ❶, and it uses the `route()` method from `Bottle`
    as a Python decorator to bind to the `hello()` function, which will act as a handler
    for that route. This way, when the user navigates to the route, `Bottle` will
    call the `hello()` function, which returns a string ❷. The `run()` method ❸ starts
    the `Bottle` server, which can now accept connections from clients. Here we’re
    assuming that the server is running on port 8080 on a Pi called `iotgarden`. Notice
    that the `debug` flag is set to `True` to make it easier to diagnose problems.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码首先定义了一个URL或路径（在本例中是`/hello`），客户端可以在该路径上发送数据请求 ❶，并使用`Bottle`中的`route()`方法作为Python装饰器绑定到`hello()`函数，后者将作为该路径的处理函数。这样，当用户访问该路径时，`Bottle`将调用`hello()`函数，返回一个字符串
    ❷。`run()`方法 ❸ 启动`Bottle`服务器，现在可以接受客户端的连接。这里我们假设服务器在名为`iotgarden`的树莓派的8080端口上运行。注意，`debug`标志已设置为`True`，以便更容易诊断问题。
- en: Run this code on your Wi-Fi–connected Pi, open a browser on any computer connected
    to the local network, and visit *http://<iotgarden>.local:8080/hello/*, substituting
    in your Pi’s name as appropriate. `Bottle` should serve you a web page with the
    text “Hello Bottle World!” With just a few lines of code, you’ve created a web
    server.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的Wi-Fi连接的树莓派上运行这段代码，在任何连接到本地网络的计算机上打开浏览器，并访问*http://<iotgarden>.local:8080/hello/*，根据需要替换为你树莓派的名称。`Bottle`应该会为你提供一个显示“Hello
    Bottle World！”的网页。只需几行代码，你就创建了一个web服务器。
- en: Note that you’ll be using `Bottle` routing functions slightly differently in
    your project compared to this simple example, because you’ll be binding the routes
    to class methods rather than free functions like `hello()` shown previously. There
    will be more on this later.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在你的项目中，你将稍微不同地使用`Bottle`路由函数，因为你将把路由绑定到类方法，而不是像之前的`hello()`那样绑定到自由函数。稍后会详细讲解这一点。
- en: '[The SQLite Database](nsp-venkitachalam503045-0008.xhtml#rbh1603)'
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[SQLite数据库](nsp-venkitachalam503045-0008.xhtml#rbh1603)'
- en: You need a place to store the sensor data so you can retrieve it in the future.
    You could write the data to a text file, but the retrieval process would quickly
    get cumbersome. Instead, you’ll store the data with SQLite, a lightweight, easy-to-use
    database perfect for embedded systems like the Raspberry Pi. To access SQLite
    in Python, you’ll use the `sqlite3` library.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要一个地方来存储传感器数据，以便将来可以检索它。你可以将数据写入文本文件，但检索过程会很快变得繁琐。相反，你将使用SQLite来存储数据，SQLite是一个轻量级、易于使用的数据库，非常适合像树莓派这样的嵌入式系统。为了在Python中访问SQLite，你需要使用`sqlite3`库。
- en: 'SQLite databases are manipulated using SQL, a standard language for database
    systems. The SQL statements are written as strings in your Python code. You don’t
    need to be a SQL expert to use SQLite for this project, however. You’ll need only
    a few commands, which we’ll discuss as they arise. To get a feel for how it works,
    let’s look at a simple example of using SQLite in a Python interpreter session.
    First, here’s how to create a database and add some entries to it:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite数据库是通过SQL来操作的，SQL是数据库系统的标准语言。这些SQL语句在你的Python代码中作为字符串编写。然而，对于这个项目，你不需要成为SQL专家。你只需要掌握几个基本命令，我们会在它们出现时逐一讲解。为了让你更好地了解它的工作方式，下面我们看一个简单的例子，展示如何在Python解释器会话中使用SQLite。首先，下面是如何创建数据库并向其中添加一些条目的代码：
- en: '>>> `import sqlite3`'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> `import sqlite3`'
- en: '>>> `con = sqlite3.``connect(''test.db'')` ❶'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> `con = sqlite3.``connect(''test.db'')` ❶'
- en: '>>> `cur = con.``cursor()` ❷'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> `cur = con.``cursor()` ❷'
- en: '>>> `cur.``execute("``CREATE TABLE sensor_data (``TS datetime,` `ID text,`
    `VAL numeric)")` ❸'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> `cur.``execute("``CREATE TABLE sensor_data (``TS datetime,` `ID text,`
    `VAL numeric)")` ❸'
- en: '>>> `for i in range(10):`'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> `for i in range(10):`'
- en: '...   `cur.execute("INSERT into sensor_data VALUES (datetime(''now''),''ABC'', ?)",
    (i, ))` ❹'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '...   `cur.execute("INSERT into sensor_data VALUES (datetime(''now''),''ABC'',  ?)",
    (i, ))` ❹'
- en: '>>> `con.``commit()` ❺'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> `con.``commit()` ❺'
- en: '>>> `con.``close()`'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> `con.``close()`'
- en: '>>> `exit()`'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> `exit()`'
- en: 'Here you call the `sqlite3.connect()` method with the name of the database
    (`test.db` in this case) ❶. This method either returns a connection to an existing
    database or creates a new one if the database with the given name doesn’t exist.
    Then you create a *cursor* using the connection object ❷. This is a construct
    that lets you interact with the database to create tables, make new entries, and
    retrieve data. You use the cursor to execute a SQL statement that creates a database
    table called `sensor_data` with the following columns: `TS` (timestamp), which
    is of the type `datetime`; `ID` of type `text`; and `VAL` of type `numeric` ❸.
    Next, you add 10 entries to this database by executing SQL `INSERT` statements
    in a `for` loop. Each statement adds the entry with the current timestamp, the
    string `''ABC''`, and the loop index `i` ❹. The `?` is a formatting placeholder
    used by SQLite, and the actual values are specified using a tuple. Finally, you
    commit the changes to the database to make them permanent ❺, before closing the
    database connection.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你使用`sqlite3.connect()`方法并传入数据库的名称（在这个例子中是`test.db`）❶。该方法要么返回一个已存在数据库的连接，要么如果数据库不存在则创建一个新的数据库。然后，你使用连接对象创建一个*cursor*❷。这是一种构造，它允许你与数据库进行交互，创建表格、插入新条目和检索数据。你通过游标执行一个SQL语句，创建一个名为`sensor_data`的数据库表，其中包含以下列：`TS`（时间戳），类型为`datetime`；`ID`，类型为`text`；`VAL`，类型为`numeric`❸。接下来，你通过在`for`循环中执行SQL
    `INSERT`语句，向这个数据库添加10个条目。每个语句都添加当前时间戳、字符串`'ABC'`和循环索引`i`❹。`?`是SQLite使用的格式占位符，实际值通过元组来指定。最后，你将更改提交到数据库，以使其永久生效❺，然后关闭数据库连接。
- en: 'Now let’s retrieve some values from the database:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们从数据库中检索一些值：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Once again, you establish a connection to the database and create a cursor to
    interact with it. Then you execute a `SELECT` SQL query to retrieve some data
    ❶. In this query, you ask for all rows (`SELECT *`) from the `sensor_data` table
    for which the entry in the `VAL` column is greater than `5`. You print the results
    of the query, which are accessible through the cursor’s `fetchall()` method.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，你需要连接数据库并创建一个游标以与其交互。然后执行一个 `SELECT` SQL 查询来检索一些数据 ❶。在这个查询中，你请求从 `sensor_data`
    表中选择所有行（`SELECT *`），并且 `VAL` 列中的值大于 `5`。你通过游标的 `fetchall()` 方法打印查询结果。
- en: '[Requirements](nsp-venkitachalam503045-0008.xhtml#rah1602)'
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[要求](nsp-venkitachalam503045-0008.xhtml#rah1602)'
- en: On the Raspberry Pi, you’ll need the `bottle` module to create a web server,
    the `sqlite3` module to work with a SQLite database, and `matplotlib` to plot
    the sensor data. The BLE Sense boards don’t have enough computing power to run
    a full version of Python, so instead you’ll program them using CircuitPython,
    an open source derivative of MicroPython maintained by Adafruit. We’re using CircuitPython
    for this project, rather than MicroPython as you saw in [Chapter 12](nsp-venkitachalam503045-0027.xhtml#ch12),
    since the former has more library support for the Adafruit-made devices.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Raspberry Pi 上，你需要使用 `bottle` 模块来创建一个 Web 服务器，使用 `sqlite3` 模块来操作 SQLite 数据库，并使用
    `matplotlib` 来绘制传感器数据。由于 BLE Sense 开发板的计算能力不足以运行完整的 Python 版本，因此你将使用 CircuitPython
    编程，这是一种由 Adafruit 维护的开源 MicroPython 衍生版本。我们在这个项目中使用 CircuitPython，而不是你在 [第 12
    章](nsp-venkitachalam503045-0027.xhtml#ch12) 中看到的 MicroPython，因为前者对 Adafruit 制作的设备有更多的库支持。
- en: 'You’ll also need the following hardware for this project:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要以下硬件来完成此项目：
- en: • One or more Adafruit Feather Bluefruit nRF52840 Sense boards, as per your
    need
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 一个或多个 Adafruit Feather Bluefruit nRF52840 Sense 开发板，根据需求选择
- en: • One Raspberry Pi 3B+ (or newer) board with SD card and power supply adapter
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 一块 Raspberry Pi 3B+（或更新版）开发板，带有 SD 卡和电源适配器
- en: • One 3.7 V LiPo battery or USB power supply per BLE Sense board
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 每个 BLE Sense 开发板需要一个 3.7 V LiPo 电池或 USB 电源
- en: '[Figure 14-3](nsp-venkitachalam503045-0029.xhtml#fig14-3) shows the required
    hardware.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 14-3](nsp-venkitachalam503045-0029.xhtml#fig14-3) 显示了所需的硬件。'
- en: '![](images/nsp-venkitachalam503045-f14003.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f14003.jpg)'
- en: 'Figure 14-3: The hardware required for the project'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14-3：项目所需的硬件
- en: You can hook up your Raspberry Pi indoors, close to your garden, and place your
    BLE Sense boards with suitable power supply units and protective enclosures in
    the garden.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 Raspberry Pi 安装在室内，靠近你的花园，并将你的 BLE Sense 开发板与适当的电源和保护外壳放置在花园中。
- en: '[Raspberry Pi Setup](nsp-venkitachalam503045-0008.xhtml#rbh1604)'
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[Raspberry Pi 设置](nsp-venkitachalam503045-0008.xhtml#rbh1604)'
- en: To start this project, you’ll need to set up your Raspberry Pi. Please follow
    the instructions in [Appendix B](nsp-venkitachalam503045-0032.xhtml#appb). The
    project code that follows assumes that you’ve named you Pi `iotgarden`, which
    allows you to access it on the network as `iotgarden.local`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始此项目，你需要设置你的 Raspberry Pi。请按照 [附录 B](nsp-venkitachalam503045-0032.xhtml#appb)
    中的说明操作。接下来的项目代码假设你已将 Pi 命名为 `iotgarden`，这使得你可以通过网络访问它，地址为 `iotgarden.local`。
- en: '[CircuitPython Setup](nsp-venkitachalam503045-0008.xhtml#rbh1605)'
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[CircuitPython 设置](nsp-venkitachalam503045-0008.xhtml#rbh1605)'
- en: 'To install CircuitPython, follow these steps for each of your Adafruit BLE
    Sense boards:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 CircuitPython，请按照以下步骤操作，为你的每个 Adafruit BLE Sense 开发板安装：
- en: 1\. Visit [https://circuitpython.org/downloads](https://circuitpython.org/downloads),
    search for your Bluefruit Sense board, and download the board’s CircuitPython
    installer file, which has a *.uf2* extension. Take note of the CircuitPython version
    number you’re downloading.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1\. 访问 [https://circuitpython.org/downloads](https://circuitpython.org/downloads)，搜索你的
    Bluefruit Sense 开发板，并下载该开发板的 CircuitPython 安装文件，该文件具有 *.uf2* 扩展名。请注意你正在下载的 CircuitPython
    版本号。
- en: 2\. Connect the Adafuit board to a USB port on your computer and double-click
    the Reset button on the board. The LED on the board should turn green, and you
    should see a new drive appear on your computer called FTHRSNSBOOT.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2\. 将 Adafruit 开发板连接到计算机的 USB 端口，并双击开发板上的重置按钮。开发板上的 LED 应该会变绿，并且你应该会看到一个新的驱动器出现在你的计算机上，名为
    FTHRSNSBOOT。
- en: 3\. Drag the *.uf2* file into the FTHRSNSBOOT drive. Once the file is copied,
    the LED on the board will flash, and a new drive called CIRCUITPY will appear
    on your computer.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3\. 将 *.uf2* 文件拖动到 FTHRSNSBOOT 驱动器中。一旦文件复制完成，开发板上的 LED 会闪烁，计算机上将会出现一个名为 CIRCUITPY
    的新驱动器。
- en: 'Next, you need to install the required Adafruit libraries on your board. Here’s
    how:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要在开发板上安装所需的 Adafruit 库。操作步骤如下：
- en: 1\. Visit [https://circuitpython.org/libraries](https://circuitpython.org/libraries)
    and download the *.zip* file with the library bundle corresponding to your version
    of CircuitPython.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1\. 访问[https://circuitpython.org/libraries](https://circuitpython.org/libraries)并下载与你的CircuitPython版本对应的*.zip*文件，其中包含库的捆绑包。
- en: 2\. Unzip the downloaded file and copy the following files/folders into a folder
    called *lib* inside the CIRCUITPY drive. (Create the *lib* folder if it doesn’t
    exist.)
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2\. 解压下载的文件，并将以下文件/文件夹复制到CIRCUITPY驱动器中的一个名为*lib*的文件夹内。（如果*lib*文件夹不存在，请创建它。）
- en: ◦ *adafruit_apds9960*
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ◦ *adafruit_apds9960*
- en: ◦ *adafruit_ble*
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ◦ *adafruit_ble*
- en: ◦ *adafruit_bme280*
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ◦ *adafruit_bme280*
- en: ◦ *adafruit_bmp280.mpy*
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ◦ *adafruit_bmp280.mpy*
- en: ◦ *adafruit_bus_device*
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ◦ *adafruit_bus_device*
- en: ◦ *adafruit_lis3mdl.mpy*
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ◦ *adafruit_lis3mdl.mpy*
- en: ◦ *adafruit_lsm6ds*
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ◦ *adafruit_lsm6ds*
- en: ◦ *adafruit_register*
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ◦ *adafruit_register*
- en: ◦ *adafruit_sht31d.mpy*
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ◦ *adafruit_sht31d.mpy*
- en: ◦ *neopixel.mpy*
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ◦ *neopixel.mpy*
- en: 3\. Press Reset on the board and you’re all set to use the board for this project.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3\. 按下板上的重置按钮，项目就可以开始使用了。
- en: By default, CircuitPython will run code from any file in CIRCUITPY named *code.py*.
    You’ll need to copy to the drive the *ble_sensors.py* file discussed in the following
    section and rename it *code.py* to run the project.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，CircuitPython会运行CIRCUITPY驱动器中任何名为*code.py*的文件中的代码。你需要将以下章节中讨论的*ble_sensors.py*文件复制到驱动器，并将其重命名为*code.py*，才能运行该项目。
- en: '[If This Then That Setup](nsp-venkitachalam503045-0008.xhtml#rbh1606)'
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[If This Then That 设置](nsp-venkitachalam503045-0008.xhtml#rbh1606)'
- en: 'IFTTT is a web service that lets you create automated responses to specific
    actions. You’ll use IFTTT to send alerts to your mobile phone when something is
    really off with the temperature or humidity levels your sensors are picking up.
    Follow these steps to get set up to receive IFTTT alerts:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: IFTTT是一个Web服务，可以让你为特定的操作创建自动响应。你将使用IFTTT在传感器检测到温湿度异常时向你的手机发送警报。按照以下步骤设置以接收IFTTT警报：
- en: 1\. Visit the IFTTT website ([https://ifttt.com](https://ifttt.com)) and sign
    up for an account.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1\. 访问IFTTT网站([https://ifttt.com](https://ifttt.com))并注册一个账户。
- en: 2\. Download the IFTTT app to your smartphone and set it up.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2\. 下载并设置IFTTT应用程序到你的智能手机。
- en: 3\. While signed into your IFTTT account in your browser, click **Create**.
    Then click the **Add** button in the If This box.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3\. 在浏览器中登录到你的IFTTT账户后，点击**创建**。然后点击“If This”框中的**添加**按钮。
- en: 4\. Search for and select **Webhooks** on the Choose a Service page that comes
    up. Then select **Receive a Web Request with a JSON Payload**.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 4\. 在弹出的“选择服务”页面上，搜索并选择**Webhooks**。然后选择**接收带JSON负载的Web请求**。
- en: 5\. Under Event Name, enter **TH_alert** (note the capitalization) and press
    **Create Trigger**.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 5\. 在事件名称下，输入**TH_alert**（注意大小写），然后按**创建触发器**。
- en: 6\. You should now be back on the Create page. Click the **Add** button in the
    Then That box.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 6\. 现在你应该已经回到创建页面。点击“Then That”框中的**添加**按钮。
- en: 7\. Search for and select **Notifications**. Then click **Send a Notification
    from the IFTTT App**.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 7\. 搜索并选择**通知**。然后点击**从IFTTT应用发送通知**。
- en: 8\. In the page that comes up, add the text “T/H Alert!” to the Message box.
    Then click **Add Ingredient** and select **OccuredAt**. Click **Add Ingredient**
    again and select **JsonPayload**.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 8\. 在弹出的页面中，将文本“T/H Alert！”添加到消息框中。然后点击**添加成分**并选择**OccuredAt**。再点击**添加成分**并选择**JsonPayload**。
- en: 9\. Click the **Create Action** button to return to the Create screen. Then
    click **Continue** and **Finish** to finalize the alert.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 9\. 点击**创建动作**按钮返回到创建页面。然后点击**继续**和**完成**以最终确认警报。
- en: 'You’ll need your IFTTT key to trigger alerts from your Python code. To look
    it up, follow these steps:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要IFTTT密钥才能通过Python代码触发警报。要查找它，请按照以下步骤操作：
- en: 1\. On the IFTTT website, click the round account icon in the top-right corner
    of the screen and select **My Services**.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1\. 在IFTTT网站上，点击屏幕右上角的圆形账户图标并选择**我的服务**。
- en: 2\. Click the **Webhooks** link, and then click the **Documentation** button.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2\. 点击**Webhooks**链接，然后点击**文档**按钮。
- en: 3\. A page should load with your key written across the top. Take note of the
    key. You’ll also find information on this page about how to send a test alert
    to your smartphone. Be sure to fill in **TH_alert** as the event name if you run
    a test.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3\. 页面加载时，顶部会显示你的密钥。记下这个密钥。你还会在此页面上找到如何将测试警报发送到你的智能手机的信息。如果进行测试，请确保填入**TH_alert**作为事件名称。
- en: '[The Code](nsp-venkitachalam503045-0008.xhtml#rah1603)'
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[代码](nsp-venkitachalam503045-0008.xhtml#rah1603)'
- en: 'The code for this project is spread over these Python files:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目的代码分布在以下Python文件中：
- en: ble_sensors.py The CircuitPython code that runs in the Adafruit BLE Sense boards.
    It reads from the temperature and humidity sensors and puts the data in BLE advertisement
    packets.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ble_sensors.py 运行在 Adafruit BLE Sense 板上的 CircuitPython 代码。它从温湿度传感器读取数据，并将数据放入
    BLE 广告数据包中。
- en: BLEScanner.py Implements the BLE scanner on the Raspberry Pi, using BlueZ tools
    to read advertisement data. This code also sends the IFTTT alerts.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: BLEScanner.py 实现了在 Raspberry Pi 上运行的 BLE 扫描器，使用 BlueZ 工具读取广告数据。此代码还会发送 IFTTT
    警报。
- en: server.py Implements the `Bottle` web server on the Raspberry Pi.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: server.py 实现了在 Raspberry Pi 上运行的`Bottle` Web 服务器。
- en: iotgarden.py The main program file. This code sets up the SQLite database and
    starts the BLE scanner and the web server.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: iotgarden.py 主程序文件。此代码设置 SQLite 数据库，并启动 BLE 扫描器和 Web 服务器。
- en: 'In addition to the Python files, the project has a subfolder called *static*
    with some extra files used by the `Bottle` web server:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 Python 文件，项目中还有一个名为*static*的子文件夹，里面包含一些由`Bottle` Web 服务器使用的额外文件：
- en: static/style.css The style sheet for the HTML returned by the server
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: static/style.css 服务器返回的 HTML 页面的样式表。
- en: static/server.js The JavaScript code returned by the server that fetches sensor
    data
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: static/server.js 由服务器返回的 JavaScript 代码，用于获取传感器数据。
- en: The full code for the project is available at [https://github.com/mkvenkit/pp2e/tree/main/iotgarden](https://github.com/mkvenkit/pp2e/tree/main/iotgarden).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 项目的完整代码可以在 [https://github.com/mkvenkit/pp2e/tree/main/iotgarden](https://github.com/mkvenkit/pp2e/tree/main/iotgarden)
    上找到。
- en: '[The CircuitPython Code](nsp-venkitachalam503045-0008.xhtml#rbh1607)'
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[CircuitPython 代码](nsp-venkitachalam503045-0008.xhtml#rbh1607)'
- en: 'The CircuitPython code running on the BLE Sense board has a straightforward
    purpose: it reads data from the built-in temperature and humidity sensors and
    puts that data in the board’s BLE advertisement packets. This deceptively simple
    task requires you to import a surprising number of modules. To see the complete
    code listing, skip ahead to [“The Complete CircuitPython Code”](nsp-venkitachalam503045-0029.xhtml#ah1607)
    on [page 343](nsp-venkitachalam503045-0029.xhtml#p343). The code is also available
    at [https://github.com/mkvenkit/pp2e/blob/main/iotgarden/ble_sensors/ble_sensors.py](https://github.com/mkvenkit/pp2e/blob/main/iotgarden/ble_sensors/ble_sensors.py).'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 运行在 BLE Sense 板上的 CircuitPython 代码有一个直接的目的：它从内置的温湿度传感器读取数据，并将这些数据放入板上的 BLE 广告数据包中。这个看似简单的任务需要导入意想不到数量的模块。要查看完整的代码列表，请跳到
    [“完整的 CircuitPython 代码”](nsp-venkitachalam503045-0029.xhtml#ah1607)，该内容位于 [第 343
    页](nsp-venkitachalam503045-0029.xhtml#p343)。代码也可以在 [https://github.com/mkvenkit/pp2e/blob/main/iotgarden/ble_sensors/ble_sensors.py](https://github.com/mkvenkit/pp2e/blob/main/iotgarden/ble_sensors/ble_sensors.py)
    找到。
- en: '[PRE6]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You import Python’s built-in `time` and `struct` modules for sleeping and packing
    data, respectively. The `board` module gives you access to the `I2C` library,
    which allows the BLE chip on the board to communicate with the sensors using the
    I²C protocol (pronounced ``“eye-squared-C”). The `adafruit_bmp280` and `adafruit_sht31d`
    modules are required for communicating with the sensors, and the `BLERadio` class
    is for enabling BLE and sending advertisement packets. The imports at ❶ and ❷
    give you access to the Adafruit BLE advertising modules necessary for creating
    your own custom advertisement packets featuring the sensor data. Additionally,
    you’ll use the `_bleio` module to get the MAC address of the device and `neopixel`
    to control the board’s LED.``
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你导入了 Python 的内建模块`time`和`struct`，分别用于睡眠和打包数据。`board`模块让你能够访问`I2C`库，允许板上的 BLE
    芯片通过 I²C 协议（读作“eye-squared-C”）与传感器进行通信。`adafruit_bmp280`和`adafruit_sht31d`模块用于与传感器通信，而`BLERadio`类用于启用
    BLE 并发送广告数据包。在❶和❷位置的导入语句使你能够访问 Adafruit BLE 广告模块，这些模块对于创建你自己定制的、包含传感器数据的广告数据包是必要的。此外，你还将使用`_bleio`模块获取设备的
    MAC 地址，并使用`neopixel`控制板上的 LED。
- en: '[PRE7] class IOTGAdvertisement(Advertisement):     flags = None   ❶ match_prefixes
    = (         struct.pack(             "<BHBH",  # prefix format             0xFF,     #
    0xFF is "Manufacturer Specific Data" as per BLE spec             0x0822,   # 2-byte
    company ID             struct.calcsize("<H9s"), # data format             0xabcd
    # our ID         ), # comma required - a tuple is expected     )   ❷ manufacturer_data
    = LazyObjectField(         ManufacturerData,         "manufacturer_data",         advertising_data_type=0xFF,
    # 0xFF is "Manufacturer Specific Data"                                     # as
    per BLE spec         company_id=0x0822,          # 2-byte company ID         key_encoding="<H",
        )     # set manufacturer data field   ❸ md_field = ManufacturerDataField(0xabcd,
    "<9s")  [PRE8] def main():     # initialize I2C   ❶ i2c = board.I2C()     # initialize
    sensors   ❷ bmp280 = adafruit_bmp280.Adafruit_BMP280_I2C(i2c)   ❸ sht31d = adafruit_sht31d.SHT31D(i2c)
        # initialize BLE   ❹ ble = BLERadio()     # create custom advertisement object
      ❺ advertisement = IOTGAdvertisement()     # append first 2 hex bytes (4 characters)
    of MAC address to name   ❻ addr_bytes = _bleio.adapter.address.address_bytes     name
    = "{0:02x}{1:02x}".format(addr_bytes[5], addr_bytes[4]).upper()     # set device
    name   ❼ ble.name = "IG" + name  [PRE9]     # set initial value     # will use
    only first 5 chars of name   ❶ advertisement.md_field = ble.name[:5] + "0000"
        # BLE advertising interval in seconds     BLE_ADV_INT = 0.2     # start BLE
    advertising   ❷ ble.start_advertising(advertisement, interval=BLE_ADV_INT)     #
    set up NeoPixels and turn them all off      pixels = neopixel.NeoPixel(board.NEOPIXEL,
    1,                                 brightness=0.1, auto_write=False)  [PRE10]
        # main loop     while True:         # print values - this will be available
    on serial       ❶ print("Temperature: {:.1f} C".format(bmp280.temperature))         print("Humidity:
    {:.1f} %".format(sht31d.relative_humidity))         # get sensor data       ❷
    T = int(bmp280.temperature)+ 40         H = int(sht31d.relative_humidity)         #
    stop advertising       ❸ ble.stop_advertising()         # update advertisement
    data       ❹ advertisement.md_field = ble.name[:5] + chr(T) + chr(H) + "00"         #
    start advertising       ❺ ble.start_advertising(advertisement, interval=BLE_ADV_INT)
            # blink neopixel LED         pixels.fill((255, 255, 0))         pixels.show()
            time.sleep(0.1)         pixels.fill((0, 0, 0))         pixels.show()         #
    sleep for 2 seconds       ❻ time.sleep(2)  [PRE11] Temperature: 26.7 C Humidity:
    55.6 %  [PRE12]`  [PRE13] class BLEScanner:     def __init__(self, dbname):         """BLEScanner
    constructor"""         self.T = 0         self.H = 0         # max values         self.TMAX
    = 30         self.HMIN = 20         # timestamp for last alert       ❶ self.last_alert
    = time.time()         # alert interval in seconds       ❷ self.ALERT_INT = 60
            # scan interval in seconds       ❸ self.SCAN_INT = 10       ❹ self._dbname
    = dbname       ❺ self.hcitool = None         self.hcidump = None       ❻ self.task
    = None         # -----------------------------------------------         # peripheral
    allow list - add your devices here!         # -----------------------------------------------
          ❼ self.allowlist = ["`DE:74:03:D9:3D:8B`"]  [PRE14] def start_scan(self):
        """starts the BlueZ tools required for scanning"""     print("BLE scan started...")
        # reset device   ❶ ret = subprocess.run([''sudo'', ''-n'', ''hciconfig'',
    ''hci0'', ''reset''],                          stdout=subprocess.DEVNULL)     print(ret)
        # start hcitool process   ❷ self.hcitool = subprocess.Popen([''sudo'', ''-n'',
    ''hcitool'',                                      ''lescan'', ''--duplicates''],
                                        stdout=subprocess.DEVNULL)     # start hcidump
    process   ❸ self.hcidump = subprocess.Popen([''sudo'', ''-n'', ''hcidump'', ''--raw''],
                                        stdout=subprocess.PIPE)  [PRE15] def stop_scan(self):
        """stops BLE scan by killing BlueZ tools processes"""     subprocess.run([''sudo'',
    ''kill'', str(self.hcidump.pid), ''-s'', ''SIGINT''])     subprocess.run([''sudo'',
    ''-n'', ''kill'', str(self.hcitool.pid),                      ''-s'', "SIGINT"])
        print("BLE scan stopped.")  [PRE16] def parse_hcidump(self):     data = ""
        (macid, name, T, H) = (None, None, None, None)     while True:       ❶ line
    = self.hcidump.stdout.readline()       ❷ line = line.decode()         if line.startswith(''>
    ''):             data = line[2:]         elif line.startswith(''< ''):             data
    = ""         else:             if data:               ❸ data += line               ❹
    data = " ".join(data.split())               ❺ fields = self.parse_data(data)                     success
    = False                   ❻ try:                         macid = fields["macid"]
                            T = fields["T"]                         H = fields["H"]
                            name = fields["name"]                         success
    = True                     except KeyError:                         # skip this
    error, since this indicates                         # invalid data                       ❼
    pass                     if success:                       ❽ return (macid, name,
    T, H)  [PRE17] > 04 3E 1B 02 01 02 01 8B 3D D9 03 74 DE 0F 0E FF 22 08 0A 31   FE
    49 4F 54 47 31 1B 36 30 CB  [PRE18] >>> `x = "ab cd\n ef\tff\r\n"` >>> `x.split()`
    [''ab'', ''cd'', ''ef'', ''ff''] >>> `" ".join(x.split())` ''ab cd ef ff''  [PRE19]
    def parse_data(self, data):     fields = {}     # parse MACID   ❶ x = [int(val,
    16) for val in data.split()]   ❷ macid = ":".join([format(val, ''02x'').upper()
    for val in x[7:13][::-1]])     # check if MACID is in allowlist   ❸ if macid in
    self.allowlist:         # look at 6th byte to see PDU type       ❹ if (x[5] ==
    0x02): # ADV_IND           ❺ fields["macid"] = macid             # parse data
              ❻ fields["T"] = x[26]             fields["H"] = x[27]           ❼ name
    = "".join([format(val, ''02x'').upper() for val in x[21:26]])           ❽ name
    = bytearray.fromhex(name).decode()             fields["name"] = name     return
    fields  [PRE20] >>> `data = "04 3E 1C 02 01 02 01 8B 3D D9 03 74 DE 10 0F FF 22`
    `            08 0B 31 FE 49 4F 54 47 31 61 62 63 64 BD"` >>> `x = [int(val, 16)
    for val in data.split()]` >>> `x` [4, 62, 28, 2, 1, 2, 1, 139, 61, 217, 3, 116,
    222, 16, 15, 255, 34,  8, 11, 49, 254, 73, 79, 84, 71, 49, 97, 98, 99, 100, 189]
    >>> `x[7:13][::-1`] [222, 116, 3, 217, 61, 139] >>> `[format(val, ''02x'').upper()
    for val in x[7:13][::-1]]` [''DE'', ''74'', ''03'', ''D9'', ''3D'', ''8B''] >>>
    `":".join([format(val, ''02x'').upper() for val in x[7:13][::-1]])` ''DE:74:03:D9:3D:8B''  [PRE21]
    def send_alert(self):     # check T, H   ❶ delta = time.time() - self.last_alert
      ❷ if ((self.T > self.TMAX) or (self.H < self.HMIN)) and                                      (delta
    > self.ALERT_INT):         print("Triggering IFTTT alert!")       ❸ key = ''`ABCDEF`''
    # USE YOUR KEY HERE!       ❹ url = ''https://maker.ifttt.com/trigger/TH_alert/json/with/key/''
    + key         json_data = {"T": self.T, "H": self.H}       ❺ r = requests.post(url,
    data = json_data)         # save last alert         self.last_alert = time.time()  [PRE22]
    def scan_task(self):     """the scanning task which is run on a separate thread"""
        # start BLE scan   ❶ self.start_scan()     # get data   ❷ (macid, name, self.T,
    self.H) = self.parse_hcidump()     # correct temperature offset     self.T = self.T
    - 40     print(self.T, self.H)     # stop BLE scan   ❸ self.stop_scan()     #
    send alert if required   ❹ self.send_alert()     # write to db     # connect to
    database     con = sqlite3.connect(self._dbname)     cur = con.cursor()     devID
    = macid     # add data     with con:       ❺ cur.execute("INSERT INTO iotgarden_data
    VALUES (?, ?, ?, ?, ?)",                 (devID, name, datetime.now(), self.T,
    self.H))     # commit changes     con.commit()     # close db     con.close()
        # schedule the next task   ❻ self.task = Timer(self.SCAN_INT, self.scan_task)
      ❼ self.task.start()  [PRE23] class IOTGServer:     def __init__(self, dbname,
    host, port):         self._dbname = dbname         self._host = host         self._port
    = port         # create bottle object       ❶ self._app = Bottle()  [PRE24] def
    run(self):     # ----------     # add routes:     # ----------     # T/H data
      ❶ self._app.route(''/thdata'')(self.thdata)     # plot image   ❷ self._app.route(''/image/<macid>'')(self.plot_image)
        # static files - CSS, JavaScript   ❸ self._app.route(''/static/<filename>'')(self.st_file)
        # main HTML page   ❹ self._app.route(''/'')(self.main_page)     # start server
      ❺ self._app.run(host=self._host, port=self._port)  [PRE25]     def main_page(self):
            """main HTML page"""       ❶ response.content_type = ''text/html''         strHTML
    = """ <!DOCTYPE html> <html> <head> ❷ <link href="static/style.css" rel="stylesheet">
    ❸ <script src="static/server.js"></script> </head> <body> <div id = "title">The
    IoT Garden </div> <hr/> ❹ <div id="sensors"></div> </body> </html>"""         return
    strHTML  [PRE26] def st_file(self, filename):     """serves static files"""     return
    static_file(filename, root=''./static'')  [PRE27] def plot_image(self, macid):
        """create a plot of sensor data by reading database"""     # get data   ❶
    data = self.get_data(macid)     # create plot     plt.legend([''T'', ''H''], loc=''upper
    left'')   ❷ plt.plot(data)     # save to a buffer   ❸ buf = io.BytesIO()   ❹ plt.savefig(buf,
    format=''png'')     # reset stream position to start     buf.seek(0)     # read
    image data as bytes   ❺ img_data = buf.read()     # set response type     response.content_type
    = ''image/png''     # return image data as bytes   ❻ return img_data  [PRE28]
    def get_data(self, macid):     # connect to database     con = sqlite3.connect(self._dbname)
        cur = con.cursor()     data = []   ❶ for row in cur.execute("SELECT * FROM
    iotgarden_data                         where DEVID = :dev_id LIMIT 100", {"dev_id" :
    macid}):       ❷ data.append((row[3], row[4]))     # commit changes     con.commit()
        # close db     con.close()     return data  [PRE29] def thdata(self):     """connect
    to database and retrieve latest sensor data"""     # connect to database     con
    = sqlite3.connect(self._dbname)     cur = con.cursor()     macid = ""     name
    = ""     # set up a device list     devices = []     # get unique device list
    from db   ❶ devid_list = cur.execute("SELECT DISTINCT DEVID FROM iotgarden_data")
        for devid in devid_list:       ❷ for row in cur.execute("SELECT * FROM iotgarden_data
                where DEVID = :devid ORDER BY TS DESC LIMIT 1",             {"devid" :
    devid[0]}):           ❸ devices.append({''macid'': macid, ''name'': name, ''T'' :
    T, ''H'': H})         # commit changes     con.commit()     # close db     con.close()
        # return device dictionary   ❹ return {"devices" : devices}  [PRE30] // async
    function that fetches data from server async function fetch_data() {   ❶ let response
    = await fetch(''thdata'');   ❷ devices_json = await response.json();     console.log(''updating
    HTML...'');   ❸ devices = devices_json["devices"];   ❹ let strHTML = "";   ❺ var
    ts = new Date().getTime();   ❻ for (let i = 0; i < devices.length; i++) {         //
    console.log(devices[i].macid)         strHTML = ''<div class="thdata">'';         strHTML
    += ''<span>'' + devices[i].name + ''('' + devices[i].macid             + ''):
    </span>'';         strHTML += ''<span>T = '' + devices[i].T +                    ''
    C ('' + (9.0*devices[i].T/5.0 + 32.0) + '' F),</span>'';         strHTML += ''<span>
    H = '' + devices[i].H + '' % </span>'';         strHTML += ''</div>''; // thdata
            // create image div       ❼ strHTML += ''<div class="imdiv"><img src="image/''
    +             devices[i]["macid"] + ''?ts='' + ts + ''"></div>'';         // add
    divider         strHTML += ''<hr/>'';     }     // set HTML data   ❽ document.getElementById("sensors").innerHTML
    = strHTML; };  [PRE31] ❶ <div class="thdata">     <span>IGDE74(DE:74:03:D9:3D:8B):
    </span>     <span>T = 26 C, (73.4 F),</span>     <span>H = 55 % </span> </div>
    ❷ <div class="imdiv">   ❸ <img src="image/DE:74:03:D9:3D:8B?ts=1635673486192">
    </div> ❹ <hr>  [PRE32] // fetch once on load ❶ window.onload = function() {     fetch_data();
    }; // now fetch data every 30 seconds ❷ setInterval(fetch_data, 30000)  [PRE33]
    html {     background-color: gray; } body {     min-height: 100vh;     max-width:
    800px;     background-color: #444444;     margin-left: auto;     margin-right:
    auto;     margin-top: 0; } h1 {     color: #aaaaaa;     font-family: "Times New
    Roman", Times, serif; } #title {     font-family: "Times New Roman", Times, serif;
        font-size: 40px;     text-align: center; } ❶ .thdata {     display: flex;
        justify-content: center;     width: 80%;     color: #aaaaaa;     font-family:
    Arial, Helvetica, sans-serif;     font-size: 24px;     margin: auto; } ❷ .imdiv
    {     display: flex;     justify-content: center; }  [PRE34] def setup_db(dbname):
        """set up the database"""     # connect to database - will create new if needed
      ❶ con = sqlite3.connect(dbname)     cur = con.cursor()     # drop if table exists
      ❷ cur.execute("DROP TABLE IF EXISTS iotgarden_data")     # create table   ❸
    cur.execute("CREATE TABLE iotgarden_data(DEVID TEXT, NAME TEXT,                  TS
    DATETIME, T NUMERIC, H NUMERIC)")  [PRE35] def print_db(dbname):     """prints
    contents of database"""     # connect to database     con = sqlite3.connect(dbname)
        cur = con.cursor()   ❶ for row in cur.execute("SELECT * FROM iotgarden_data"):
           print(row)  [PRE36] def main():     print("starting iotgarden...")     #
    set up cmd line argument parser     parser = argparse.ArgumentParser(description="iotgarden.")
        # add arguments   ❶ parser.add_argument(''--createdb'', action=''store_true'',
    required=False)   ❷ parser.add_argument(''--lsdb'', action=''store_true'', required=False)
      ❸ parser.add_argument(''--hostname'', dest=''hostname'', required=False)     args
    = parser.parse_args()     # set database name   ❹ dbname = ''iotgarden.db''     if
    (args.createdb):         print("Setting up database...")       ❺ setup_db(dbname)
            print("done. exiting.")         exit(0)     if (args.lsdb):         print("Listing
    database contents...")       ❻ print_db(dbname)         print("done. exiting.")
            exit(0)     # set hostname   ❼ hostname = ''iotgarden.local''     if (args.hostname):
            hostname = args.hostname     # create BLE scanner   ❽ bs = BLEScanner(dbname)
        # start BLE     bs.start()     # create server   ❾ server = IOTGServer(dbname,
    hostname, 8080)     # run server     server.run()  [PRE37]`  [PRE38] $ `sudo hcitool
    lescan`  [PRE39] LE Scan... 57:E0:F5:93:AD:B1 (unknown) 57:E0:F5:93:AD:B1 (unknown)
    DE:74:03:D9:3D:8B (unknown) DE:74:03:D9:3D:8B IOTG1 27:FE:36:49:F0:2E (unknown)
    7A:17:EB:3C:04:A5 (unknown) 7A:17:EB:3C:04:A5 (unknown)  [PRE40] $ `sudo python
    iotgarden.py`  [PRE41] starting iotgarden... BLE scan started... CompletedProcess(args=[''sudo'',
    ''hciconfig'', ''hci0'', ''reset''], returncode=0) 04 3E 1C 02 01 02 01 8B 3D
    D9 03 74 DE 10 0F FF 22 08 0B CD AB 49 4F 54 47 31 1A 3A 30 30 C9 26 58 BLE scan
    stopped. Bottle v0.12.19 server starting up (using WSGIRefServer())... Listening
    on http://iotgarden.local:8080/ Hit Ctrl-C to quit.  [PRE42] Triggering IFTTT
    alert!  [PRE43] """ iotgarden.py Main program for the IoT Garden project. Sets
    up database, starts the Bottle web server, and the BLE scanner. Author: Mahesh
    Venkitachalam """ import argparse import sqlite3 from BLEScanner import BLEScanner
    from server import IOTGServer def print_db(dbname):     """prints contents of
    database"""     # connect to database     con = sqlite3.connect(dbname)     cur
    = con.cursor()     for row in cur.execute("SELECT * FROM iotgarden_data"):         print(row)
    def setup_db(dbname):     """set up the database"""     # connect to database
    - will create new if needed     con = sqlite3.connect(dbname)     cur = con.cursor()
        # drop if table exists     cur.execute("DROP TABLE IF EXISTS iotgarden_data")
        # create table     cur.execute("CREATE TABLE iotgarden_data(DEVID TEXT, NAME
    TEXT,                  TS DATETIME, T NUMERIC, H NUMERIC)") def main():     print("starting
    iotgarden...")     # set up cmd line argument parser     parser = argparse.ArgumentParser(description="iotgarden.")
        # add arguments     parser.add_argument(''--createdb'', action=''store_true'',
    required=False)     parser.add_argument(''--lsdb'', action=''store_true'', required=False)
        parser.add_argument(''--hostname'', dest=''hostname'', required=False)     args
    = parser.parse_args()     # set database name     dbname = ''iotgarden.db''     if
    (args.createdb):         print("Setting up database...")         setup_db(dbname)
            print("done. exiting.")         exit(0)     if (args.lsdb):         print("Listing
    database contents...")         print_db(dbname)         print("done. exiting.")
            exit(0)     # set hostname     hostname = ''iotgarden.local''     if (args.hostname):
            hostname = args.hostname     # create BLE scanner     bs = BLEScanner(dbname)
        # start BLE     bs.start()     # create server     server = IOTGServer(dbname,
    hostname, 8080)     # run server     server.run() # call main if __name__ == "__main__":
        main()  [PRE44]`'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE7] 类 IOTGAdvertisement(Advertisement):     flags = None   ❶ match_prefixes
    = (         struct.pack(             "<BHBH",  # 前缀格式             0xFF,     #
    0xFF 是根据 BLE 规范定义的 "厂商特定数据"             0x0822,   # 2 字节公司 ID             struct.calcsize("<H9s"),
    # 数据格式             0xabcd # 我们的 ID         ), # 需要逗号 - 期望元组     )   ❷ manufacturer_data
    = LazyObjectField(         ManufacturerData,         "manufacturer_data",         advertising_data_type=0xFF,
    # 0xFF 是根据 BLE 规范定义的 "厂商特定数据"                                     # 根据 BLE 规范
            company_id=0x0822,          # 2 字节公司 ID         key_encoding="<H",     )
        # 设置厂商数据字段   ❸ md_field = ManufacturerDataField(0xabcd, "<9s")  [PRE8] def
    main():     # 初始化 I2C   ❶ i2c = board.I2C()     # 初始化传感器   ❷ bmp280 = adafruit_bmp280.Adafruit_BMP280_I2C(i2c)
      ❸ sht31d = adafruit_sht31d.SHT31D(i2c)     # 初始化 BLE   ❹ ble = BLERadio()     #
    创建自定义广告对象   ❺ advertisement = IOTGAdvertisement()     # 将 MAC 地址的前 2 个十六进制字节（4
    个字符）附加到名称中   ❻ addr_bytes = _bleio.adapter.address.address_bytes     name = "{0:02x}{1:02x}".format(addr_bytes[5],
    addr_bytes[4]).upper()     # 设置设备名称   ❼ ble.name = "IG" + name  [PRE9]     # 设置初始值
        # 仅使用名称的前 5 个字符   ❶ advertisement.md_field = ble.name[:5] + "0000"     # BLE
    广播间隔，单位秒     BLE_ADV_INT = 0.2     # 启动 BLE 广播   ❷ ble.start_advertising(advertisement,
    interval=BLE_ADV_INT)     # 设置 NeoPixels 并关闭它们      pixels = neopixel.NeoPixel(board.NEOPIXEL,
    1,                                 brightness=0.1, auto_write=False)  [PRE10]
        # 主循环     while True:         # 打印值 - 这将通过串行接口显示       ❶ print("Temperature:
    {:.1f} C".format(bmp280.temperature))         print("Humidity: {:.1f} %".format(sht31d.relative_humidity))
            # 获取传感器数据       ❷ T = int(bmp280.temperature)+ 40         H = int(sht31d.relative_humidity)
            # 停止广播       ❸ ble.stop_advertising()         # 更新广告数据       ❹ advertisement.md_field
    = ble.name[:5] + chr(T) + chr(H) + "00"         # 启动广播       ❺ ble.start_advertising(advertisement,
    interval=BLE_ADV_INT)         # 闪烁 NeoPixel LED         pixels.fill((255, 255,
    0))         pixels.show()         time.sleep(0.1)         pixels.fill((0, 0, 0))
            pixels.show()         # 睡眠 2 秒       ❻ time.sleep(2)  [PRE11] 温度: 26.7
    C 湿度: 55.6 %  [PRE12]`  [PRE13] 类 BLEScanner:     def __init__(self, dbname):
            """BLEScanner 构造函数"""         self.T = 0         self.H = 0         #
    最大值         self.TMAX = 30         self.HMIN = 20         # 上次警报的时间戳       ❶ self.last_alert
    = time.time()         # 警报间隔，单位秒       ❷ self.ALERT_INT = 60         # 扫描间隔，单位秒
          ❸ self.SCAN_INT = 10         ❹ self._dbname = dbname         ❺ self.hcitool
    = None         self.hcidump = None         ❻ self.task = None         # -----------------------------------------------
            # 外围设备允许列表 - 在此添加您的设备！         # -----------------------------------------------
            ❼ self.allowlist = ["`DE:74:03:D9:3D:8B`"]  [PRE14] def start_scan(self):
        """启动扫描所需的 BlueZ 工具"""     print("BLE 扫描启动...")     # 重置设备   ❶ ret = subprocess.run([''sudo'',
    ''-n'', ''hciconfig'', ''hci0'', ''reset''],                          stdout=subprocess.DEVNULL)
        print(ret)     # 启动 hcitool 进程   ❷ self.hcitool = subprocess.Popen([''sudo'',
    ''-n'', ''hcitool'',                                      ''lescan'', ''--duplicates''],
                                        stdout=subprocess.DEVNULL)     # 启动 hcidump
    进程   ❸ self.hcidump = subprocess.Popen([''sudo'', ''-n'', ''hcidump'', ''--raw''],
                                        stdout=subprocess.PIPE)  [PRE15] def stop_scan(self):
        """通过结束 BlueZ 工具进程来停止 BLE 扫描"""     subprocess.run([''sudo'', ''kill'', str(self.hcidump.pid),
    ''-s'', ''SIGINT''])     subprocess.run([''sudo'', ''-n'', ''kill'', str(self.hcitool.pid),
                         ''-s'', "SIGINT"])     print("BLE 扫描停止.")  [PRE16] def parse_hcidump(self):
        data = ""     (macid, name, T, H) = (None, None, None, None)     while True:
          ❶ line = self.hcidump.stdout.readline()       ❷ line = line.decode()         if
    line.startswith(''> ''):             data = line[2:]         elif line.startswith(''<
    ''):             data = ""         else:             if data:               ❸
    data += line               ❹ data = " ".join(data.split())               ❺ fields
    = self.parse_data(data)                     success = False                   ❻
    try:                         macid = fields["macid"]                         T
    = fields["T"]                         H = fields["H"]                         name
    = fields["name"]                         success = True                     except
    KeyError:                         # 跳过此错误，因为它表示                         # 数据无效
                          ❼ pass                     if success:                       ❽
    return (macid, name, T, H)  [PRE17] > 04 3E 1B 02 01 02 01 8B 3D D9 03 74 DE 0F
    0E FF 22 08 0A 31   FE 49 4F 54 47 31 1B 36 30 CB  [PRE18] >>> `x = "ab cd\n ef\tff\r\n"`
    >>> `x.split()` [''ab'', ''cd'', ''ef'', ''ff''] >>> `" ".join(x.split())` ''ab
    cd ef ff''  [PRE19] def parse_data(self, data):     fields = {}     # 解析 MACID
      ❶ x = [int(val, 16) for val in data.split()]   ❷ macid = ":".join([format(val,
    ''02x'').upper() for val in x[7:13][::-1]])     # 检查 MACID 是否在允许列表中   ❸ if macid
    in self.allowlist:         # 查看第 6 字'
