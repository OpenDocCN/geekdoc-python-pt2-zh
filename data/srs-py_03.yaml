- en: '**3**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**3**'
- en: '**DOCUMENTATION AND GOOD API PRACTICE**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**文档编写与良好的 API 实践**'
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: In this chapter, we’ll discuss documentation; specifically, how to automate
    the trickier and more tedious aspects of documenting your project with *Sphinx*.
    While you will still have to write the documentation yourself, Sphinx will simplify
    your task. As it is common to provide features using a Python library, we’ll also
    look at how to manage and document your public API changes. Because your API will
    have to evolve as you make changes to its features, it’s rare to get everything
    built perfectly from the outset, but I’ll show you a few things you can do to
    ensure your API is as user-friendly as possible.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论文档编写；具体来说，我们将探讨如何通过 *Sphinx* 自动化文档编写中更棘手和更繁琐的部分。虽然你仍然需要自己编写文档，但 Sphinx
    将简化你的任务。由于通常使用 Python 库提供功能，我们还将讨论如何管理和记录你的公共 API 变更。因为你的 API 必须随着功能的更改而不断演变，从一开始就完美构建一切是很罕见的，但我将展示一些方法，帮助你确保你的
    API 尽可能地对用户友好。
- en: We’ll end this chapter with an interview with Christophe de Vienne, author of
    the Web Services Made Easy framework, in which he discusses best practices for
    developing and maintaining APIs.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最后，我们将进行一次与 Christophe de Vienne 的采访，他是《Web Services Made Easy》框架的作者，在采访中他将讨论开发和维护
    API 的最佳实践。
- en: '**Documenting with Sphinx**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用 Sphinx 编写文档**'
- en: 'Documentation is one of the most important parts of writing software. Unfortunately,
    a lot of projects don’t provide proper documentation. Writing documentation is
    seen as complicated and daunting, but it doesn’t have to be: with the tools available
    to Python programmers, documenting your code can be just as easy as writing it.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 文档编写是软件开发中最重要的部分之一。不幸的是，许多项目没有提供适当的文档。编写文档被认为是复杂且令人生畏的，但其实不必如此：借助 Python 程序员可用的工具，编写文档和编写代码一样简单。
- en: One of the biggest reasons for sparse or nonexistent documentation is that many
    people assume the only way to document code is by hand. Even with multiple people
    on a project, this means one or more of your team will end up having to juggle
    contributing code with maintaining documentation—and if you ask any developer
    which job they’d prefer, you can be sure they’ll say they’d rather write software
    than write *about* software.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 缺乏或没有文档的最大原因之一是许多人认为编写文档的唯一方式是手动编写。即使项目中有多人，这也意味着团队中的一位或多位成员将不得不在贡献代码和维护文档之间权衡——如果你问任何开发人员他们更愿意做哪项工作，可以确定他们会说更愿意编写软件，而不是编写
    *关于* 软件的文档。
- en: 'Sometimes the documentation process is completely separate from the development
    process, meaning that the documentation is written by people who did not write
    the actual code. Furthermore, any documentation produced this way is likely to
    be out-of-date: it’s almost impossible for manual documentation to keep up with
    the pace of development, regardless of who handles it.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，文档编写过程与开发过程是完全分开的，这意味着文档是由没有编写实际代码的人编写的。此外，以这种方式生成的任何文档都可能是过时的：手动编写的文档几乎不可能跟上开发的步伐，无论由谁负责。
- en: 'Here’s the bottom line: the more degrees of separation between your code and
    your documentation, the harder it will be to keep the latter properly maintained.
    So why keep them separate at all? It’s not only possible to put your documentation
    directly in the code itself, but it’s also simple to convert that documentation
    into easy-to-read HTML and PDF files.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 结论是：你的代码和文档之间的隔离程度越高，维护文档的难度就越大。那么，为什么要把它们分开呢？不仅可以直接在代码中编写文档，而且将这些文档转换为易于阅读的
    HTML 和 PDF 文件也很简单。
- en: The most common format for Python documentation is *reStructuredText*, or *reST*
    for short. It’s a lightweight markup language (like Markdown) that’s as easy to
    read and write for humans as it is for computers. Sphinx is the most commonly
    used tool for working with this format; Sphinx can read reST-formatted content
    and output documentation in a variety of other formats.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Python 文档编写的最常见格式是 *reStructuredText*，简称 *reST*。它是一种轻量级标记语言（类似 Markdown），既易于人类阅读和编写，也易于计算机处理。Sphinx
    是处理这种格式的最常用工具；Sphinx 可以读取 reST 格式的内容，并将文档输出为多种其他格式。
- en: 'I recommend that your project documentation always include the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你的项目文档始终包含以下内容：
- en: The problem your project is intended to solve, in one or two sentences.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的项目旨在解决的问题，简明扼要地用一两句话说明。
- en: The license your project is distributed under. If your software is open source,
    you should also include this information in a header in each code file; just because
    you’ve uploaded your code to the Internet doesn’t mean that people will know what
    they’re allowed to do with it.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的项目所采用的许可协议。如果您的软件是开源的，您还应在每个代码文件的头部包含此信息；仅仅因为您已将代码上传到互联网上，并不意味着其他人会知道他们可以对其做什么。
- en: A small example of how your code works.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个小示例，展示您的代码是如何工作的。
- en: Installation instructions.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装说明。
- en: Links to community support, mailing list, IRC, forums, and so on.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指向社区支持、邮件列表、IRC、论坛等的链接。
- en: A link to your bug tracker system.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个指向您的错误跟踪系统的链接。
- en: A link to your source code so that developers can download and start delving
    into it right away.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指向您的源代码的链接，方便开发者下载并立即开始研究。
- en: You should also include a *README.rst* file that explains what your project
    does. This README should be displayed on your GitHub or PyPI project page; both
    sites know how to handle reST formatting.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您还应包含一个 *README.rst* 文件，解释您的项目功能。此 README 应显示在您的 GitHub 或 PyPI 项目页面上；这两个网站都知道如何处理
    reST 格式。
- en: '**NOTE**'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you’re using GitHub, you can also add a CONTRIBUTING.rst file that will
    be displayed when someone submits a pull request. It should provide a checklist
    for users to follow before they submit the request, including things like whether
    your code follows PEP 8 and reminders to run the unit tests. Read the Docs ([http://readthedocs.org/](http://readthedocs.org/))
    allows you to build and publish your documentation online automatically. Signing
    up and configuring a project is straightforward. Then Read the Docs searches for
    your Sphinx configuration file, builds your documentation, and makes it available
    for your users to access. It’s a great companion to code-hosting sites.*'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果您使用 GitHub，您还可以添加一个 CONTRIBUTING.rst 文件，当有人提交拉取请求时，这个文件将会显示。它应提供一个用户在提交请求前遵循的清单，包括代码是否遵循
    PEP 8，以及提醒用户运行单元测试等事项。[Read the Docs](http://readthedocs.org/) 允许您自动在线构建和发布文档。注册和配置项目非常简单。然后
    Read the Docs 会搜索您的 Sphinx 配置文件，构建文档并使其可以供用户访问。这是一个非常适合与代码托管网站配合使用的工具。*'
- en: '***Getting Started with Sphinx and reST***'
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***开始使用 Sphinx 和 reST***'
- en: You can get Sphinx from *[http://www.sphinx-doc.org/](http://www.sphinx-doc.org/)*.
    There are installation instructions on the site, but the easiest method is to
    install with `pip install sphinx`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从 *[http://www.sphinx-doc.org/](http://www.sphinx-doc.org/)* 获取 Sphinx。网站上有安装说明，但最简单的方法是通过
    `pip install sphinx` 安装。
- en: 'Once Sphinx is installed, run `sphinx-quickstart` in your project’s top-level
    directory. This will create the directory structure that Sphinx expects to find,
    along with two files in the *doc/source* folder: *conf.py*, which contains Sphinx’s
    configuration settings (and is absolutely required for Sphinx to work), and *index.rst*,
    which serves as the front page of your documentation. Once you run the quick-start
    command, you’ll be taken through a series of steps to designate naming conventions,
    version conventions, and options for other useful tools and standards.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Sphinx 后，在项目的顶层目录中运行 `sphinx-quickstart`。这将创建 Sphinx 所需的目录结构，并在 *doc/source*
    文件夹中生成两个文件：*conf.py*，它包含 Sphinx 的配置设置（这是 Sphinx 正常运行所必需的），以及 *index.rst*，它作为文档的首页。一旦运行了快速启动命令，您将依次完成一系列步骤，用以指定命名约定、版本约定以及其他工具和标准的选项。
- en: The *conf.py* file contains a few documented variables, such as the project
    name, the author, and the theme to use for HTML output. Feel free to edit this
    file at your convenience.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*conf.py* 文件包含一些文档化的变量，例如项目名称、作者以及用于 HTML 输出的主题。您可以随时编辑此文件。'
- en: Once you’ve built your structure and set your defaults, you can build your documentation
    in HTML by calling `sphinx-build` with your source directory and output directory
    as arguments, as shown in [Listing 3-1](ch03.xhtml#ch3list1). The command `sphinx-build`
    reads the *conf.py* file from the source directory and parses all the *.rst* files
    from this directory. It renders them in HTML in the output directory.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 创建好结构并设置好默认值后，您可以通过调用 `sphinx-build` 命令，传入源目录和输出目录作为参数，将文档构建为 HTML，如[示例 3-1](ch03.xhtml#ch3list1)所示。`sphinx-build`
    命令会读取源目录中的 *conf.py* 文件，解析该目录中的所有 *.rst* 文件，并将其渲染为 HTML 输出到目标目录。
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 3-1: Building a basic Sphinx HTML document*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 3-1：构建一个基本的 Sphinx HTML 文档*'
- en: Now you can open *[doc/build/index.html](http://doc/build/index.html)* in your
    favorite browser and read your documentation.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以在你最喜欢的浏览器中打开 *[doc/build/index.html](http://doc/build/index.html)* 并阅读你的文档。
- en: '**NOTE**'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you’re using setuptools or pbr (see [Chapter 5](ch05.xhtml#ch05)) for packaging,
    Sphinx extends them to support the command setup.py build_sphinx, which will run
    sphinx-build automatically. The pbr integration of Sphinx has some saner defaults,
    such as outputting the documentation in the /doc subdirectory.*'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你正在使用 setuptools 或 pbr（参见 [第 5 章](ch05.xhtml#ch05)）进行打包，Sphinx 扩展了它们以支持命令
    setup.py build_sphinx，这将自动运行 sphinx-build。Sphinx 的 pbr 集成具有一些更合理的默认值，例如将文档输出到
    /doc 子目录。*'
- en: 'Your documentation begins with the *index.rst* file, but it doesn’t have to
    end there: reST supports `include` directives to include reST files from other
    reST files, so there’s nothing stopping you from dividing your documentation into
    multiple files. Don’t worry too much about syntax and semantics to start; reST
    offers a lot of formatting possibilities, but you’ll have plenty of time to dive
    into the reference later. The complete reference (*[http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html](http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html)*)
    explains how to create titles, bulleted lists, tables, and more.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你的文档从 *index.rst* 文件开始，但不一定要以此结束：reST 支持 `include` 指令从其他 reST 文件中包含 reST 文件，因此没有什么能阻止你将文档分成多个文件。刚开始时不要太担心语法和语义；reST
    提供了很多格式化选项，但你有足够的时间稍后深入参考文档。完整的参考文档（*[http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html](http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html)*)
    解释了如何创建标题、项目符号列表、表格等。
- en: '***Sphinx Modules***'
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Sphinx 模块***'
- en: 'Sphinx is highly extensible: its basic functionality supports only manual documentation,
    but it comes with a number of useful modules that enable automatic documentation
    and other features. For example, `sphinx.ext.autodoc` extracts reST-formatted
    docstrings from your modules and generates *.rst* files for inclusion. This is
    one of the options `sphinx-quickstart` will ask if you want to activate. If you
    didn’t select that option, however, you can still edit your *conf.py* file and
    add it as an extension like so:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Sphinx 的扩展性非常强：它的基本功能仅支持手动文档，但它附带了一些有用的模块，可以启用自动文档生成和其他功能。例如，`sphinx.ext.autodoc`
    会从你的模块中提取 reST 格式的文档字符串并生成 *.rst* 文件以供包含。这是 `sphinx-quickstart` 会询问你是否想要启用的选项之一。如果你没有选择该选项，你仍然可以编辑你的
    *conf.py* 文件，并像这样将其作为扩展添加：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that `autodoc` will *not* automatically recognize and include your modules.
    You need to explicitly indicate which modules you want documented by adding something
    like [Listing 3-2](ch03.xhtml#ch3list2) to one of your *.rst* files.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`autodoc` *不会* 自动识别并包含你的模块。你需要明确指定你想要文档化的模块，通过在你的 *.rst* 文件中添加类似 [清单 3-2](ch03.xhtml#ch3list2)
    的内容。
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 3-2: Indicating the modules for autodoc to document*'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-2：指定自动文档化的模块*'
- en: 'In [Listing 3-2](ch03.xhtml#ch3list2), we make three requests, all of which
    are optional: that all documented members be printed ➊, that all undocumented
    members be printed ➋, and that inheritance be shown ➌. Also note the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [清单 3-2](ch03.xhtml#ch3list2) 中，我们提出了三个请求，所有这些请求都是可选的：打印所有已记录的成员 ➊，打印所有未记录的成员
    ➋，以及显示继承关系 ➌。还需要注意以下几点：
- en: If you don’t include any directives, Sphinx won’t generate any output.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你没有包含任何指令，Sphinx 将不会生成任何输出。
- en: If you only specify `:members:`, undocumented nodes on your module, class, or
    method tree will be skipped, even if all their members are documented. For example,
    if you document the methods of a class but not the class itself, `:members:` will
    exclude both the class and its methods. To keep this from happening, you’d have
    to write a docstring for the class or specify `:undoc-members:` as well.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你只指定 `:members:`，模块、类或方法树中的未记录节点将被跳过，即使它们的所有成员都有文档。举例来说，如果你文档化了一个类的方法，但没有文档化类本身，`:members:`
    会排除该类及其方法。为了防止这种情况发生，你需要为该类写文档字符串，或者也可以指定 `:undoc-members:`。
- en: Your module needs to be where Python can import it. Adding `.`, `..`, and/or
    `../..` to `sys.path` can help.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的模块需要位于 Python 可以导入的地方。将 `.`, `..`, 和/或 `../..` 添加到 `sys.path` 可以帮助解决此问题。
- en: The `autodoc` extension gives you the power to include most of your documentation
    in your source code. You can even pick and choose which modules and methods to
    document—it’s not an “all-or-nothing” solution. By maintaining your documentation
    directly alongside your source code, you can easily ensure it stays up to date.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`autodoc` 扩展使你能够将大部分文档内容直接包含在源代码中。你甚至可以选择哪些模块和方法进行文档化——这不是一个“全有或全无”的解决方案。通过将文档与源代码直接维护在一起，你可以轻松确保它始终保持最新。'
- en: '**Automating the Table of Contents with autosummary**'
  id: totrans-44
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用 autosummary 自动生成目录**'
- en: If you’re writing a Python library, you’ll usually want to format your API documentation
    with a table of contents containing links to individual pages for each module.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在编写一个 Python 库，通常你会希望用一个包含指向每个模块单独页面链接的目录来格式化你的 API 文档。
- en: 'The `sphinx.ext.autosummary` module was created specifically to handle this
    common use case. First, you need to enable it in your *conf.py* by adding the
    following line:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`sphinx.ext.autosummary` 模块是专门为处理这种常见用例而创建的。首先，你需要在 *conf.py* 中启用它，通过添加以下行：'
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, you can add something like the following to an *.rst* file to automatically
    generate a table of contents for the specified modules:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以将以下内容添加到 *.rst* 文件中，自动为指定的模块生成目录：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This will create files called *generated/mymodule.rst* and *generated/mymodule.submodule.rst*
    containing the autodoc directives described earlier. Using this same format, you
    can specify which parts of your module API you want included in your documentation.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建名为 *generated/mymodule.rst* 和 *generated/mymodule.submodule.rst* 的文件，其中包含前面提到的
    autodoc 指令。使用相同的格式，你可以指定要包含在文档中的模块 API 部分。
- en: '**NOTE**'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The sphinx-apidoc command can automatically create these files for you; check
    out the Sphinx documentation to find out more.*'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*Sphinx-apidoc 命令可以自动为你创建这些文件；查看 Sphinx 文档了解更多信息。*'
- en: '**Automating Testing with doctest**'
  id: totrans-53
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用 doctest 自动化测试**'
- en: 'Another useful feature of Sphinx is the ability to run `doctest` on your examples
    automatically when you build your documentation. The standard Python `doctest`
    module searches your documentation for code snippets and tests whether they accurately
    reflect what your code does. Every paragraph starting with the primary prompt
    `>>>` is treated as a code snippet to test. For example, if you wanted to document
    the standard `print` function from Python, you could write this documentation
    snippet and `doctest` would check the result:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Sphinx 的另一个有用功能是能够在你构建文档时自动运行`doctest`来测试示例。标准的 Python `doctest` 模块会在文档中搜索代码片段，并测试它们是否准确地反映了代码的实际行为。每一个以主提示符
    `>>>` 开头的段落都会被视为一个代码片段来进行测试。例如，如果你想文档化 Python 的标准 `print` 函数，你可以编写如下的文档片段，`doctest`
    会检查结果：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Having such examples in your documentation lets users understand your API. However,
    it’s easy to put off and eventually forget to update your examples as your API
    evolves. Fortunately, `doctest` helps make sure this doesn’t happen. If your documentation
    includes a step-by-step tutorial, `doctest` will help you keep it up to date throughout
    development by testing every line it can.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在文档中包含此类示例可以让用户理解你的 API。然而，随着 API 的发展，更新示例可能会被推迟，甚至忘记更新。幸运的是，`doctest` 帮助确保这一点不会发生。如果你的文档包括逐步教程，`doctest`
    会通过测试每一行代码，确保它在开发过程中始终保持最新。
- en: 'You can also use `doctest` for *documentation-driven development (DDD)*: write
    your documentation and examples first and then write code to match your documentation.
    Taking advantage of this feature is as simple as running `sphinx-build` with the
    special `doctest` builder, like this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以将 `doctest` 用于 *文档驱动开发（DDD）*：先编写文档和示例，然后编写与文档相匹配的代码。利用这个功能非常简单，只需使用特殊的 `doctest`
    构建器运行 `sphinx-build`，就像这样：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When using the `doctest` builder, Sphinx reads the usual *.rst* files and executes
    code examples that are contained in those files.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `doctest` 构建器时，Sphinx 会读取常规的 *.rst* 文件，并执行其中包含的代码示例。
- en: 'Sphinx also provides a bevy of other features, either out of the box or through
    extension modules, including these:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Sphinx 还提供了许多其他功能，无论是开箱即用的，还是通过扩展模块提供的，包括以下功能：
- en: Linking between projects
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目之间的链接
- en: HTML themes
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTML 主题
- en: Diagrams and formulas
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图表和公式
- en: Output to Texinfo and EPUB format
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出到 Texinfo 和 EPUB 格式
- en: Linking to external documentation
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链接到外部文档
- en: You might not need all this functionality right away, but if you ever need it
    in the future, it’s good to know about in advance. Again, check out the full Sphinx
    documentation to find out more.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能不会立刻需要所有这些功能，但如果将来需要，提前了解这些是很有帮助的。再次查看完整的Sphinx文档，了解更多信息。
- en: '***Writing a Sphinx Extension***'
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***编写Sphinx扩展***'
- en: Sometimes off-the-shelf solutions just aren’t enough and you need to create
    custom tools to deal with a situation.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候现成的解决方案不足以应对，你需要创建自定义工具来处理特定情况。
- en: 'Say you’re writing an HTTP REST API. Sphinx will only document the Python side
    of your API, forcing you to write your REST API documentation by hand, with all
    the problems that entails. The creators of Web Services Made Easy (WSME) (interviewed
    at the end of this chapter) have come up with a solution: a Sphinx extension called
    `sphinxcontrib-pecanwsme` that analyzes docstrings and actual Python code to generate
    REST API documentation automatically.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在编写一个HTTP REST API。Sphinx只会记录你的API的Python部分，迫使你手动编写REST API文档，带来所有相关问题。Web
    Services Made Easy（WSME）的创建者（在本章末尾采访）提出了一个解决方案：一个名为`sphinxcontrib-pecanwsme`的Sphinx扩展，它分析docstring和实际的Python代码，自动生成REST
    API文档。
- en: '**NOTE**'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*For other HTTP frameworks, such as Flask, Bottle, and Tornado, you can use
    sphinxcontrib.httpdomain.*'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*对于其他HTTP框架，例如Flask、Bottle和Tornado，你可以使用sphinxcontrib.httpdomain。*'
- en: My point is that whenever you know you could extract information from your code
    to build documentation, you should, and you should also automate the process.
    This is better than trying to maintain manually written documentation, especially
    when you can leverage auto-publication tools such as Read the Docs.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我的观点是，每当你知道可以从代码中提取信息来构建文档时，你应该这么做，并且你也应该自动化这个过程。这比试图维护手动编写的文档要好，尤其是当你可以利用像Read
    the Docs这样的自动发布工具时。
- en: We’ll examine the `sphinxcontrib-pecanwsme` extension as an example of writing
    your own Sphinx extension. The first step is to write a module—preferably as a
    submodule of `sphinxcontrib`, as long as your module is generic enough—and pick
    a name for it. Sphinx requires this module to have one predefined function called
    `setup(app)`, which contains the methods you’ll use to connect your code to Sphinx
    events and directives. The full list of methods is available in the Sphinx extension
    API at *[http://www.sphinx-doc.org/en/master/extdev/appapi.html](http://www.sphinx-doc.org/en/master/extdev/appapi.html)*.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以`sphinxcontrib-pecanwsme`扩展为例，展示如何编写你自己的Sphinx扩展。第一步是编写一个模块——最好作为`sphinxcontrib`的子模块，只要你的模块足够通用——并为其选择一个名称。Sphinx要求这个模块具有一个预定义的函数`setup(app)`，该函数包含你将用来将代码连接到Sphinx事件和指令的方法。完整的方法列表可以在Sphinx扩展API中找到，地址是*[http://www.sphinx-doc.org/en/master/extdev/appapi.html](http://www.sphinx-doc.org/en/master/extdev/appapi.html)*。
- en: For example, the `sphinxcontrib-pecanwsme` extension includes a single directive
    called `rest-controller`, added using the `setup(app)` function. This added directive
    needs a fully qualified controller class name to generate documentation for, as
    shown in [Listing 3-3](ch03.xhtml#ch3list3).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`sphinxcontrib-pecanwsme`扩展包含一个名为`rest-controller`的指令，可以通过`setup(app)`函数添加。这个添加的指令需要一个完全限定的控制器类名来生成文档，如[清单3-3](ch03.xhtml#ch3list3)所示。
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 3-3: Code from sphinxcontrib.pecanwsme.rest.setup that adds the rest-controller
    directive*'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单3-3：来自sphinxcontrib.pecanwsme.rest.setup的代码，添加了rest-controller指令*'
- en: The `add_directive` method in [Listing 3-3](ch03.xhtml#ch3list3) registers the
    `rest-controller` directive and delegates its handling to the `RESTControllerDirective`
    class. This `RESTControllerDirective` class exposes certain attributes that indicate
    how the directive treats content, whether it has arguments, and so on. The class
    also implements a `run()` method that actually extracts the documentation from
    your code and returns parsed data to Sphinx.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单3-3](ch03.xhtml#ch3list3)中的`add_directive`方法注册了`rest-controller`指令，并将其处理委托给`RESTControllerDirective`类。这个`RESTControllerDirective`类暴露了某些属性，指示指令如何处理内容，是否有参数等等。该类还实现了一个`run()`方法，实际上从代码中提取文档并将解析后的数据返回给Sphinx。'
- en: The repository at *[https://bitbucket.org/birkenfeld/sphinx-contrib/src/](https://bitbucket.org/birkenfeld/sphinx-contrib/src/)*
    has many small modules that can help you develop your own extensions.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在*[https://bitbucket.org/birkenfeld/sphinx-contrib/src/](https://bitbucket.org/birkenfeld/sphinx-contrib/src/)*的代码库中，有许多小模块可以帮助你开发自己的扩展。
- en: '**NOTE**'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Even though Sphinx is written in Python and targets it by default, extensions
    are available that allow it to support other languages as well. You can use Sphinx
    to document your project in full, even if it uses multiple languages at once.*'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*尽管Sphinx是用Python编写并默认针对Python，但也有扩展可用，允许它支持其他语言。即使你的项目使用多种语言，你也可以使用Sphinx对你的项目进行全面文档化。*'
- en: As another example, in one of my projects named Gnocchi—a database for storing
    and indexing time series data at a large scale—I’ve used a custom Sphinx extension
    to autogenerate documentation. Gnocchi provides a REST API, and usually to document
    such an API, projects will manually write examples of what an API request and
    its response should look like. Unfortunately, this approach is error prone and
    out of sync with reality.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 作为另一个例子，在我的一个项目Gnocchi中——这是一个用于大规模存储和索引时间序列数据的数据库——我使用了一个自定义的Sphinx扩展来自动生成文档。Gnocchi提供了一个REST
    API，通常为了文档化这样的API，项目会手动编写API请求及其响应的示例。不幸的是，这种方法容易出错并且与实际情况不同步。
- en: 'Using the unit-testing code available to test the Gnocchi API, we built a Sphinx
    extension to run Gnocchi and generate an *.rst* file containing HTTP requests
    and responses run against a real Gnocchi server. In this way, we ensure the documentation
    is up to date: the server responses are not manually crafted, and if a manually
    written request fails, then the documentation process fails, and we know that
    we must fix the documentation.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 使用可用的单元测试代码来测试Gnocchi API，我们构建了一个Sphinx扩展来运行Gnocchi，并生成一个包含HTTP请求和响应的*.rst*文件，这些请求和响应是在真实的Gnocchi服务器上运行的。通过这种方式，我们确保文档是最新的：服务器响应不是手动编写的，如果手动编写的请求失败，那么文档过程也会失败，我们就知道必须修复文档。
- en: Including that code in the book would be too verbose, but you can check the
    sources of Gnocchi online and look at the `gnocchi.gendoc` module to get an idea
    of how it works.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些代码包括在书中会显得过于冗长，但你可以在线查看Gnocchi的源代码，并查看`gnocchi.gendoc`模块，以了解它是如何工作的。
- en: '***Managing Changes to Your APIs***'
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***管理API的变化***'
- en: Well-documented code is a sign to other developers that the code is suitable
    to be imported and used to build something else. When building a library and exporting
    an API for other developers to use, for example, you want to provide the reassurance
    of solid documentation.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的文档化代码向其他开发者表明该代码适合被导入并用于构建其他内容。例如，在构建一个库并导出API供其他开发者使用时，你需要提供稳固文档的保证。
- en: This section will cover best practices for public APIs. These will be exposed
    to users of your library or application, and while you can do whatever you like
    with internal APIs, public APIs should be handled with care.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将介绍公共API的最佳实践。这些API将暴露给你库或应用的用户，虽然你可以随意处理内部API，但公共API应当小心对待。
- en: 'To distinguish between public and private APIs, the Python convention is to
    prefix the symbol for a private API with an underscore: `foo` is public, but `_bar`
    is private. You should use this convention both to recognize whether another API
    is public or private and to name your own APIs. In contrast to other languages,
    such as Java, Python does not enforce any restriction on accessing code marked
    as private or public. The naming conventions are just to facilitate understanding
    among programmers.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了区分公共和私有API，Python的约定是将私有API的符号前缀加上下划线：`foo`是公共的，而`_bar`是私有的。你应该使用这种约定来判断另一个API是公共的还是私有的，并且用来命名你自己的API。与其他语言（如Java）不同，Python并不强制限制访问标记为私有或公共的代码。命名约定仅仅是为了方便程序员之间的理解。
- en: '***Numbering API Versions***'
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***API版本编号***'
- en: When properly constructed, the version number of an API can give users a great
    deal of information. Python has no particular system or convention in place for
    numbering API versions, but we can take inspiration from Unix platforms, which
    use a complex management system for libraries with fine-grained version identifiers.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当正确构建时，API的版本号可以为用户提供大量信息。Python没有特别的系统或约定来对API版本进行编号，但我们可以从Unix平台中汲取灵感，后者使用一个复杂的管理系统来处理库并使用细粒度的版本标识符。
- en: Generally, your version numbering should reflect changes in the API that will
    impact users. For example, when the API has a major change, the major version
    number might change from 1 to 2\. When only a few new API calls are added, the
    lesser number might go from 2.2 to 2.3\. If a change only involves bug fixes,
    the version might bump from 2.2.0 to 2.2.1\. A good example of how to use version
    numbering is the Python `requests` library (*[https://pypi.python.org/pypi/requests/](https://pypi.python.org/pypi/requests/)*).
    This library increments its API numbers based on the number of changes in each
    new version and the impact the changes might have on consuming programs.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你的版本编号应该反映会影响用户的API变更。例如，当API有重大变化时，主版本号可能会从1变为2；当仅添加了一些新的API调用时，次版本号可能会从2.2变为2.3；如果只是修复了bug，版本号可能会从2.2.0变为2.2.1。一个很好的版本编号使用示例是
    Python 的`requests`库（*[https://pypi.python.org/pypi/requests/](https://pypi.python.org/pypi/requests/)*）。该库根据每个新版本中的变更数量和这些变更可能对使用程序的影响来递增API编号。
- en: 'Version numbers hint to developers that they should look at changes between
    two releases of a library, but alone they are not enough to fully guide a developer:
    you must provide detailed documentation to describe those changes.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 版本号提示开发者应查看两个版本之间的变化，但单独使用版本号不足以完全指导开发者：你必须提供详细的文档来描述这些变化。
- en: '***Documenting Your API Changes***'
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***记录你的API变更***'
- en: 'Whenever you make changes to an API, the first and most important thing to
    do is to heavily document them so that a consumer of your code can get a quick
    overview of what’s changing. Your document should cover the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你对API进行更改时，首先也是最重要的事情就是进行详细的文档记录，以便代码的使用者能够快速了解正在发生的变化。你的文档应涵盖以下内容：
- en: New elements of the new interface
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新接口的元素
- en: Elements of the old interface that are deprecated
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被弃用的旧接口元素
- en: Instructions on how to migrate to the new interface
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何迁移到新接口的说明
- en: You should also make sure that you don’t remove the old interface right away.
    I recommend keeping the old interface until it becomes too much trouble to do
    so. If you have marked it as deprecated, users will know not to use it.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你还应确保不要立即删除旧接口。我建议在接口变得太麻烦之前保留旧接口。如果你已标记其为弃用，用户就会知道不要再使用它。
- en: '[Listing 3-4](ch03.xhtml#ch3list4) is an example of good API change documentation
    for code that provides a representation of a car object that can turn in any direction.
    For whatever reason, the developers decided to retract the `turn_left` method
    and instead provide a generic `turn` method that can take the direction as an
    argument.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 3-4](ch03.xhtml#ch3list4)是良好API变更文档的示例，展示了一个可以朝任意方向转向的汽车对象代码。由于某种原因，开发者决定撤回`turn_left`方法，取而代之的是提供一个通用的`turn`方法，该方法可以将方向作为参数传递。'
- en: '[PRE8]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 3-4: An example of API change documentation for a car object*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-4：汽车对象API变更文档示例*'
- en: The triple quotes here, `"""`, indicate the start and end of the docstrings,
    which will be pulled into the documentation when the user enters `help(Car.turn_left)`
    into the terminal or extracts the documentation with an external tool such as
    Sphinx. The deprecation of the `car.turn_left` method is indicated by `.. deprecated
    1.1`, where `1.1` refers to the first version released that ships this code as
    deprecated.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的三重引号`"""`表示文档字符串的开始和结束，当用户在终端输入`help(Car.turn_left)`或使用外部工具如 Sphinx 提取文档时，这些内容会被提取到文档中。`car.turn_left`方法的弃用通过`..
    deprecated 1.1`来标示，其中`1.1`指的是发布此弃用代码的第一个版本。
- en: Using this deprecation method and making it visible via Sphinx clearly tells
    users that the function should not be used and gives them direct access to the
    new function along with an explanation of how to migrate old code.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种弃用方法并通过 Sphinx 显示出来，清晰地告诉用户该函数不应再使用，并为他们提供直接访问新函数的途径，同时解释如何迁移旧代码。
- en: '[Figure 3-1](ch03.xhtml#ch3fig1) shows Sphinx documentation that explains some
    deprecated functions.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3-1](ch03.xhtml#ch3fig1)展示了 Sphinx 文档，解释了一些弃用的函数。'
- en: '![image](../images/f03-01.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f03-01.jpg)'
- en: '*Figure 3-1: Explanation of some deprecated functions*'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-1：一些弃用函数的解释*'
- en: 'The downside of this approach is that it relies on developers reading your
    changelog or documentation when they upgrade to a newer version of your Python
    package. However, there is a solution for that: mark your deprecated functions
    with the `warnings` module.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是，它依赖于开发者在升级到新版Python包时阅读你的变更日志或文档。然而，有一个解决方案：使用`warnings`模块标记你的弃用函数。
- en: '***Marking Deprecated Functions with the warnings Module***'
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用warnings模块标记弃用函数***'
- en: Though deprecated modules should be marked well enough in documentation that
    users will not attempt to call them, Python also provides the `warnings` module,
    which allows your code to issue various kinds of warnings when a deprecated function
    is called. These warnings, `DeprecationWarning` and `PendingDeprecationWarning`,
    can be used to tell the developer that a function they’re calling is deprecated
    or going to be deprecated, respectively.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管过时的模块应当在文档中标注清楚，以免用户尝试调用它们，Python还提供了`warnings`模块，允许你的代码在调用已弃用的函数时发出各种警告。这些警告——`DeprecationWarning`和`PendingDeprecationWarning`——可以分别用来告诉开发者他们调用的函数已弃用或将被弃用。
- en: '**NOTE**'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*For those who work with C, this is a handy counterpart to the __attribute__
    ((deprecated)) GCC extension.*'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*对于那些从事C语言工作的人来说，这是`__attribute__((deprecated))`GCC扩展的一个方便的对照物。*'
- en: To go back to the car object example in [Listing 3-4](ch03.xhtml#ch3list4),
    we can use this to warn users when they are attempting to call deprecated functions,
    as shown in [Listing 3-5](ch03.xhtml#ch3list5).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 回到[列表3-4](ch03.xhtml#ch3list4)中的汽车对象示例，我们可以使用这个方法来警告用户当他们试图调用已弃用的函数时，如[列表3-5](ch03.xhtml#ch3list5)所示。
- en: '[PRE9]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 3-5: A documented change to the car object API using the warnings
    module*'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表3-5：使用warnings模块对汽车对象API进行的文档化更改*'
- en: 'Here, the `turn_left` function has been deprecated ➊. By adding the `warnings.warn`
    line, we can write our own error message ➋. Now, if any code should call the `turn_left`
    function, a warning will appear that looks like this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`turn_left`函数已经被弃用 ➊。通过添加`warnings.warn`这一行，我们可以编写我们自己的错误信息 ➋。现在，如果任何代码调用`turn_left`函数，都会出现如下警告：
- en: '[PRE10]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Python 2.7 and later versions, by default, do not print any warnings emitted
    by the `warnings` module because the warnings are filtered. To see those warnings
    printed, you need to pass the `-W` option to the Python executable. The option
    `-W` all will print all warnings to `stderr`. See the Python man page for more
    information on the possible values for `-W`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Python 2.7及以后的版本默认不会打印`warnings`模块发出的任何警告，因为这些警告会被过滤。若要查看这些警告，需要将`-W`选项传递给Python可执行文件。选项`-W
    all`会将所有警告打印到`stderr`。有关`-W`可能值的更多信息，请参见Python手册页。
- en: When running test suites, developers can run Python with the `-W` error option,
    which will raise an error every time an obsolete function is called. Developers
    using your library can readily find exactly where their code needs to be fixed.
    [Listing 3-6](ch03.xhtml#ch3list6) shows how Python transforms warnings into fatal
    exceptions when Python is called with the `-W` error option.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行测试套件时，开发者可以使用带有`-W`错误选项的Python命令，这样每当调用过时的函数时，就会抛出一个错误。使用你库的开发者可以很容易地找到需要修复的代码位置。[列表3-6](ch03.xhtml#ch3list6)展示了当Python使用`-W`错误选项时，如何将警告转换为致命异常。
- en: '[PRE11]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 3-6: Running Python with the -W error option and getting a deprecation
    error*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表3-6：使用-W错误选项运行Python并获得弃用错误*'
- en: Warnings are usually missed at runtime, and running a production system with
    the `-W` error option is rarely a good idea. Running the test suite of a Python
    application with the `-W` error option, on the other hand, can be a good way to
    catch warnings and fix them early on.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 警告通常在运行时被忽略，而在生产系统中运行带有`-W`错误选项的Python命令通常不是一个好主意。另一方面，使用`-W`错误选项运行Python应用程序的测试套件，则是一个很好的捕获警告并及早修复它们的方法。
- en: However, manually writing all those warnings, docstring updates, and so on can
    become tedious, so the `debtcollector` library has been created to help automate
    some of that. The `debtcollector` library provides a few decorators that you can
    use with your functions to make sure the correct warnings are emitted and the
    docstring is updated correctly. [Listing 3-7](ch03.xhtml#ch3list7) shows how you
    can, with a simple decorator, indicate that a function has been moved to some
    other place.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，手动编写所有这些警告、文档字符串更新等可能会变得乏味，因此创建了`debtcollector`库来帮助自动化其中的一部分。`debtcollector`库提供了一些装饰器，你可以在函数中使用它们，确保正确的警告被触发，并且文档字符串被正确更新。[列表3-7](ch03.xhtml#ch3list7)展示了你可以通过一个简单的装饰器，标明一个函数已经被移动到其他地方。
- en: '[PRE12]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 3-7: An API change automated with debtcollector*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-7：通过 debtcollector 自动化的 API 变更*'
- en: Here we’re using the `moves()` method from `debtcollector`, whose `moved_method`
    decorator makes `turn_left` emit a `DeprecationWarning` whenever it’s called.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了来自 `debtcollector` 的 `moves()` 方法，其 `moved_method` 装饰器使得每次调用 `turn_left`
    时都会发出一个 `DeprecationWarning`。
- en: '**Summary**'
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: Sphinx is the de facto standard for documenting Python projects. It supports
    a wide variety of syntax, and it is easy to add new syntax or features if your
    project has particular needs. Sphinx can also automate tasks such as generating
    indexes or extracting documentation from your code, making it easy to maintain
    documentation in the long run.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Sphinx 是 Python 项目的事实标准文档工具。它支持多种语法，如果你的项目有特定需求，添加新语法或功能也很容易。Sphinx 还可以自动化任务，如生成索引或从代码中提取文档，使得长期维护文档变得更加轻松。
- en: Documenting changes to your API is critical, especially when you deprecate functionality,
    so that users are not caught unawares. Ways to document deprecations include the
    Sphinx deprecated keyword and the `warnings` module, and the `debtcollector` library
    can automate maintaining this documentation.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 记录 API 的变更至关重要，尤其是在你弃用某些功能时，这样用户就不会感到意外。记录弃用方法的方式包括使用 Sphinx 的 `deprecated`
    关键字和 `warnings` 模块，而 `debtcollector` 库可以自动化维护这些文档。
- en: '**Christophe de Vienne on Developing APIs**'
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Christophe de Vienne 关于开发 API 的看法**'
- en: Christophe is a Python developer and the author of the WSME (Web Services Made
    Easy) framework, which allows developers to define web services in a Pythonic
    way and supports a wide variety of APIs, allowing it to be plugged into many other
    web frameworks.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Christophe 是一名 Python 开发者，也是 WSME（Web Services Made Easy）框架的作者，该框架允许开发者以 Pythonic
    的方式定义 web 服务，并支持多种 API，使得它可以与许多其他 web 框架兼容。
- en: '**What mistakes do developers tend to make when designing a Python API?**'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**开发者在设计 Python API 时倾向于犯哪些错误？**'
- en: 'There are a few common mistakes I avoid when designing a Python API by following
    these rules:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计 Python API 时，我通过遵循这些规则避免了几种常见的错误：
- en: '**Don’t make it too complicated.** Keep it simple. Complicated APIs are hard
    to understand and hard to document. While the actual library functionality doesn’t
    *have* to be simple as well, it’s smart to make it simple so users can’t easily
    make mistakes. For example, the library is very simple and intuitive, but it does
    complex things behind the scenes. The `urllib` API, by contrast, is almost as
    complicated as the things it does, making it hard to use.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不要让它太复杂。** 保持简单。复杂的 API 很难理解，也难以文档化。虽然实际的库功能不一定需要简单，但将其设计得简单是明智的，这样用户就不会轻易犯错。例如，这个库非常简单直观，但它在背后做了复杂的事情。相比之下，`urllib`
    的 API 几乎与其所做的事情一样复杂，使得它很难使用。'
- en: '**Make the magic visible.** When your API does things that your documentation
    doesn’t explain, your end users will want to crack open your code and see what’s
    going on under the hood. It’s okay if you’ve got some magic happening behind the
    scenes, but your end users should never see anything unexpected happening up front,
    or they could become confused or rely on a behavior that may change.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**让魔法显现出来。** 当你的 API 做了文档中没有解释的事情时，最终用户可能会想要打开代码，看看底层发生了什么。如果你背后有一些“魔法”在发生，这是可以的，但最终用户永远不应看到任何意外发生的情况，否则他们可能会感到困惑，或依赖于可能会改变的行为。'
- en: '**Don’t forget use cases.** When you’re so focused on writing code, it’s easy
    to forget to think about how your library will actually be used. Thinking up good
    use cases makes it easier to design an API.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不要忘记使用案例。** 当你全身心投入编写代码时，很容易忘记思考你的库实际上会如何被使用。构思良好的使用案例有助于更容易地设计 API。'
- en: '**Write unit tests.** *TDD (test-driven development)* is a very efficient way
    to write libraries, especially in Python, because it forces the developer to assume
    the role of the end user from the very beginning, which leads the developer to
    design for usability. It’s the only approach I know of that allows a programmer
    to completely rewrite a library, as a last resort.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编写单元测试。** *TDD（测试驱动开发）* 是编写库的一个非常有效的方法，尤其是在 Python 中，因为它迫使开发者从一开始就以最终用户的身份来设计，这有助于开发者设计出易于使用的
    API。它是我所知道的唯一一种允许程序员彻底重写库作为最后手段的方法。'
- en: '**What aspects of Python may affect how easy it is to design a library API?**'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python 的哪些方面可能影响设计库 API 的难易程度？**'
- en: Python has no built-in way to define which sections of the API are public and
    which are private, which can be both a problem and an advantage.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Python 没有内建的方式来定义哪些 API 部分是公开的，哪些是私有的，这既是一个问题也是一个优势。
- en: It’s a problem because it can lead the developer to not fully consider which
    parts of their API are public and which parts should remain private. But with
    a little discipline, documentation, and (if needed) tools like `zope.interface`,
    it doesn’t stay a problem for long.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个问题，因为它可能导致开发者没有完全考虑哪些 API 部分是公开的，哪些应该保持私有。但只要有一点自律、文档和（如果需要的话）类似 `zope.interface`
    的工具，这个问题很快就能解决。
- en: It’s an advantage when it makes it quicker and easier to refactor APIs while
    keeping compatibility with previous versions.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当能够更快速、更轻松地重构 API，同时保持与先前版本的兼容性时，这是一个优势。
- en: '**What do you consider when thinking about your API’s evolution, deprecation,
    and removal?**'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**在考虑 API 的演进、弃用和移除时，你会考虑什么？**'
- en: 'There are several criteria I weigh when making any decision regarding API development:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在做出任何关于 API 开发的决策时，我会权衡以下几个标准：
- en: '**How difficult will it be for users of the library to adapt their code?**
    Considering that there are people relying on your API, any change you make has
    to be worth the effort needed to adopt it. This rule is intended to prevent incompatible
    changes to the parts of the API that are in common use. That said, one of the
    advantages of Python is that it’s relatively easy to refactor code to adopt an
    API change.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户适应库代码的难度有多大？** 考虑到有些人依赖你的 API，任何修改都必须值得付出适应它的努力。这个规则旨在防止对常用的 API 部分进行不兼容的更改。话虽如此，Python
    的一个优点是相对容易重构代码以适应 API 的更改。'
- en: '**How easy will it be to maintain my API?** Simplifying the implementation,
    cleaning up the codebase, making the API easier to use, having more complete unit
    tests, making the API easier to understand at first glance . . . all of these
    things will make your life as a maintainer easier.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**如何保证我的 API 易于维护？** 简化实现，清理代码库，让 API 更易于使用，编写更完整的单元测试，使 API 一目了然……这些都会让你作为维护者的工作变得更加轻松。'
- en: '**How can I keep my API consistent when applying a change?** If all the functions
    in your API follow a similar pattern (such as requiring the same parameter in
    the first position), make sure new functions follow that pattern as well. Also,
    doing too many things at once is a great way to end up doing none of them right:
    keep your API focused on what it’s meant to do.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**如何在应用变更时保持 API 的一致性？** 如果你的 API 中所有函数都遵循类似的模式（比如要求第一个参数位置相同），那么确保新函数也遵循该模式。此外，一次做太多事情很容易导致什么都做不好：保持
    API 聚焦于它的核心功能。'
- en: '**How will users benefit from the change?** Last but not least, always consider
    the users’ point of view.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户从变更中能获得什么好处？** 最后但同样重要的一点，始终考虑用户的视角。'
- en: '**What advice do you have regarding API documentation in Python?**'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于 Python 中的 API 文档，你有什么建议？**'
- en: Good documentation makes it easy for newcomers to adopt your library. Neglecting
    it will drive away a lot of potential users—not just beginners, either. The problem
    is, documenting is difficult, so it gets neglected all the time!
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 好的文档使新用户能够轻松采用你的库。忽视文档会把很多潜在用户拒之门外——不仅仅是初学者。问题在于，编写文档是困难的，因此常常被忽视！
- en: '**Document early and include your documentation build in continuous integration.**
    With the Read the Docs tool for creating and hosting documentation, there’s no
    excuse for not having documentation built and published (at least for open source
    software).'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**尽早编写文档，并将文档构建集成到持续集成中。** 使用 Read the Docs 工具来创建和托管文档，没理由不构建和发布文档（至少对于开源软件而言）。'
- en: '**Use docstrings to document classes and functions in your API.** If you follow
    the PEP 257 (*[https://www.python.org/dev/peps/pep-0257/](https://www.python.org/dev/peps/pep-0257/)*)
    guidelines, developers won’t have to read your source to understand what your
    API does. Generate HTML documentation from your docstrings—and don’t limit it
    to the API reference.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用 docstring 来记录 API 中的类和函数。** 如果你遵循 PEP 257（*[https://www.python.org/dev/peps/pep-0257/](https://www.python.org/dev/peps/pep-0257/)*)
    的指南，开发者就不必阅读你的源码就能理解你的 API 功能。可以从 docstring 生成 HTML 文档——而且不要仅限于 API 参考文档。'
- en: '**Give practical examples throughout.** Have at least one “startup guide” that
    will show newcomers how to build a working example. The first page of the documentation
    should give a quick overview of your API’s basic and representative use case.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**始终提供实际的示例。** 至少提供一个“入门指南”，向新手展示如何构建一个工作示例。文档的第一页应简要概述你 API 的基本和代表性用例。'
- en: '**Document the evolution of your API in detail, version by version.** Version
    control system (VCS) logs are not enough!'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**详细记录你的 API 演变过程，按版本逐一记录。** 版本控制系统（VCS）日志是不够的！'
- en: '**Make your documentation accessible and, if possible, comfortable to read.**
    Your users need to be able to find it easily and get the information they need
    without feeling like they’re being tortured. Publishing your documentation through
    PyPI is one way to achieve this; publishing on Read the Docs is also a good idea,
    since users will expect to find your documentation there.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**让你的文档易于访问，并尽可能使其舒适易读。** 用户需要能够轻松找到它，并获得他们所需的信息，而不会感觉像在受折磨。通过 PyPI 发布文档是实现这一点的一种方式；在
    Read the Docs 上发布也是一个不错的选择，因为用户会期望在那里找到你的文档。'
- en: '**Finally, choose a theme that is both efficient and attractive.** I chose
    the “Cloud” Sphinx theme for WSME, but there are plenty of other themes out there
    to choose from. You don’t have to be a web expert to produce nice-looking documentation.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最后，选择一个既高效又吸引人的主题。** 我为 WSME 选择了 “Cloud” Sphinx 主题，但也有许多其他主题可以选择。你不需要是一个网页专家就能制作出漂亮的文档。'
