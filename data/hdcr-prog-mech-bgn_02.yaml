- en: '1'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '1'
- en: A SHORT PYTHON PRIMER
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 简短的 Python 入门
- en: '![Image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common01.jpg)'
- en: In this first chapter, we’ll take a look at some of the Python features we’ll
    use throughout the book. This is not meant to be an introduction to Python; I’m
    assuming you have a basic understanding of the language. If you don’t, there are
    plenty of good books and online tutorials that’ll get you started.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将查看一些我们将在全书中使用的 Python 特性。这不是 Python 的介绍；我假设你已经具备了基本的语言理解。如果你没有基础，有很多优秀的书籍和在线教程可以帮助你入门。
- en: We’ll first explore how Python code can be split into packages and how to import
    these packages into our programs. We’ll learn how to document Python code and
    how to consult this documentation using Python. Then, we’ll review tuples, lists,
    sets, and dictionaries, which are the most popular Python collections.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先探讨如何将 Python 代码拆分成包，并将这些包导入到我们的程序中。我们将学习如何文档化 Python 代码，以及如何使用 Python 查阅这些文档。接着，我们将回顾元组、列表、集合和字典，这些是最常用的
    Python 集合类型。
- en: '**Python Packages and Modules**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Python 包和模块**'
- en: 'Software projects of a reasonable size usually consist of lots of source files,
    also called *modules*. A coherent bundle of Python modules is referred to as a
    *package*. Let’s start our discussion on Python by taking a look at these two
    concepts: modules and packages.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 合理大小的软件项目通常包含大量源文件，也称为*模块*。一组相关的 Python 模块被称为*包*。让我们通过讨论这两个概念：模块和包，来开始我们对 Python
    的探讨。
- en: '***Modules***'
  id: totrans-7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***模块***'
- en: A Python *module* is a file that contains Python code that’s meant to be imported
    by other Python modules or scripts. A *script*, on the other hand, is a Python
    file that’s meant to be run.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 Python *模块*是一个包含 Python 代码的文件，该代码旨在被其他 Python 模块或脚本导入。另一方面，*脚本*是一个旨在被执行的
    Python 文件。
- en: Python modules allow us to share code between files, which spares us from having
    to write the same code over and over again.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Python 模块允许我们在文件之间共享代码，从而避免重复编写相同的代码。
- en: 'Every Python file has access to a global variable named __name__. This variable
    can have two possible values:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 Python 文件都可以访问一个名为 __name__ 的全局变量。这个变量可以有两个可能的值：
- en: The name of the module, that is, the name of the file without the *.py* extension
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块的名称，即文件名，去掉 *.py* 扩展名
- en: The string ’__main__’
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串 '__main__'
- en: Python determines the value of __name__ based on whether the file is imported
    by some other module or run as a script. When the module is imported inside another
    module or script, __name__ is set to the name of the module. If we run the module
    as a script, for example,
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Python 根据文件是被其他模块导入还是作为脚本运行来确定 __name__ 的值。当模块被导入到另一个模块或脚本中时，__name__ 被设置为模块的名称。如果我们将模块作为脚本运行，例如，
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: then the value of __name__ is set to ’__main__’. This may seem a bit abstract
    at the moment, but we’ll explain why we care about the __name__ global variable
    later in the chapter. As we’ll see, knowing if a given module is being imported
    or run as a script is an important piece of information we’ll want to consider.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，__name__ 的值会被设置为 '__main__'。这现在可能显得有些抽象，但我们将在本章稍后解释为什么我们关心 __name__ 这个全局变量。如我们所见，知道一个给定的模块是作为脚本执行还是被导入是一个重要的信息，我们需要考虑。
- en: As we write more and more Python modules for our project, it makes sense to
    separate them into groups according to functionality. These groups of modules
    are called *packages*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们为项目编写越来越多的 Python 模块，将它们按功能分组是有意义的。这些模块组被称为*包*。
- en: '***Packages***'
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***包***'
- en: A *package* is a directory containing Python modules and a special file whose
    name is required to be *__init__.py*. Python’s interpreter will understand any
    folder containing an *__init__.py* file as a package.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *包*是一个包含 Python 模块和一个特殊文件的目录，该文件的名称必须是 *__init__.py*。Python 解释器会将任何包含 *__init__.py*
    文件的文件夹理解为一个包。
- en: 'For instance, a folder structure like:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，像这样的文件夹结构：
- en: geom2d
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: geom2d
- en: '|- __init__.py'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '|- __init__.py'
- en: '|- point.py'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '|- point.py'
- en: '|- vector.py'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '|- vector.py'
- en: 'is a Python package called *geom2d* containing two files, or modules: *point.py*
    and *vector.py*.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 是一个名为*geom2d*的 Python 包，包含两个文件或模块：*point.py* 和 *vector.py*。
- en: The *__init__.py* file is executed whenever something is imported from the package.
    This means that the *__init__.py* file can contain Python code, usually initialization
    code. Most of the time, however, this *__init__.py* file remains empty.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 每当从包中导入内容时，*__init__.py* 文件都会被执行。这意味着*__init__.py* 文件可以包含 Python 代码，通常是初始化代码。然而，大多数时候，这个*__init__.py*
    文件是空的。
- en: '**Running Files**'
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**运行文件**'
- en: When Python imports a file, it reads its contents. If this file contains only
    functions and data, Python loads these definitions, but no code is actually executed.
    However, if there are top-level instructions or function calls, Python will execute
    them as part of the import process—something we usually don’t want.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Python 导入一个文件时，它会读取该文件的内容。如果该文件只包含函数和数据，Python 只会加载这些定义，但不会实际执行代码。然而，如果文件中有顶层指令或函数调用，Python
    会在导入过程中执行它们——这是我们通常不希望发生的。
- en: 'Earlier, we saw how when a file is run (as opposed to imported), Python sets
    the __name__ global variable to be the string ’__main__’. We can use this fact
    to execute the main logic only when the file is being run, and not when the file
    is imported:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们看到当文件被运行时（与导入不同），Python 会将`__name__`全局变量设置为字符串’__main__’。我们可以利用这一点来确保只有在文件被运行时才执行主要逻辑，而在文件被导入时则不执行：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We’ll refer to this pattern as the “if name is main” pattern, and we’ll use
    it in the applications we’ll write in this book.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这种模式称为“if name is main”模式，并且在本书中我们将使用这一模式来编写应用程序。
- en: Remember that when a file is imported, Python sets the __name__ variable to
    the name of that module.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，当文件被导入时，Python 会将`__name__`变量设置为该模块的名称。
- en: '**Importing Code**'
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**导入代码**'
- en: 'Let’s say you had some Python code you wanted to use in multiple files. One
    way to do that would be to copy and paste the code every time you wanted to use
    it. Not only would this be tedious and boring, but imagine what would happen if
    you changed your mind about how that code works: you’d need to open every single
    file where you pasted the code and modify it in the same way. As you can imagine,
    this is not a productive way of writing software.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一些 Python 代码，你希望在多个文件中使用它。一种方法是每次需要使用它时都复制粘贴代码。这不仅会显得繁琐和无聊，而且想象一下如果你改变了代码的某些功能：你需要打开每个粘贴了代码的文件，并以相同的方式进行修改。正如你能想象的，这并不是一种高效的软件编写方式。
- en: 'Fortunately, Python provides a powerful system to share code: importing modules.
    When *module_b* imports *module_a*, *module_b* gains access to the code written
    in *module_a*. This lets us write algorithms in a single place and then share
    that code across files. Let’s look at an example using two modules we’ll write
    in the next part of the book.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Python 提供了一个强大的代码共享系统：导入模块。当*module_b*导入*module_a*时，*module_b*可以访问*module_a*中编写的代码。这让我们可以在一个地方编写算法，然后在多个文件中共享这些代码。让我们看一个示例，使用我们将在本书下一部分编写的两个模块。
- en: 'Say we have two modules: *point.py* and *vector.py*. Both modules are inside
    the package we saw earlier:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有两个模块：*point.py* 和 *vector.py*。这两个模块位于我们之前看到的包中：
- en: geom2d
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: geom2d
- en: '|- __init__.py'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '|- __init__.py'
- en: '|- point.py'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '|- point.py'
- en: '|- vector.py'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '|- vector.py'
- en: 'The first module, named *point.py*, defines the geometric primitive Point,
    and the second one, *vector.py*, defines the Vector, another geometric primitive.
    [Figure 1-1](ch01.xhtml#ch1fig1) illustrates these two modules. Each module is
    divided into two sections: a section in gray, for the code in the module that
    has been imported from somewhere else, and a section in white, for the code defined
    by the module itself.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个模块名为*point.py*，它定义了几何原始类型 Point，第二个模块*vector.py*定义了另一个几何原始类型 Vector。[图 1-1](ch01.xhtml#ch1fig1)展示了这两个模块。每个模块分为两个部分：一部分是灰色的，表示该模块从其他地方导入的代码；另一部分是白色的，表示模块本身定义的代码。
- en: '![Image](../images/01fig01.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/01fig01.jpg)'
- en: '*Figure 1-1: Two Python modules*'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-1：两个 Python 模块*'
- en: Now, say we need our *point.py* module to implement some functionality that
    uses a Vector (like, for example, displacing a point by a given vector). We can
    gain access to the Vector code in *vector.py* using Python’s import command. [Figure
    1-2](ch01.xhtml#ch1fig2) illustrates this process, which brings the Vector code
    to the “imported” section of the *point.py* module, making it available inside
    the entire module.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们需要我们的*point.py*模块实现一些使用 Vector 的功能（比如，按给定的向量移动一个点）。我们可以通过 Python 的 import
    命令访问 *vector.py* 中的 Vector 代码。[图 1-2](ch01.xhtml#ch1fig2)展示了这一过程，它将 Vector 代码引入到*point.py*模块的“导入”部分，使其在整个模块中都可以使用。
- en: '![Image](../images/01fig02.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/01fig02.jpg)'
- en: '*Figure 1-2: Importing the Vector class from the* vector.py'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-2：从 vector.py 导入 Vector 类*'
- en: 'In [Figure 1-2](ch01.xhtml#ch1fig2), we use the following Python command:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 1-2](ch01.xhtml#ch1fig2)中，我们使用了以下 Python 命令：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This command brings just the Vector class from *vector.py*. We’re not importing
    anything else defined in *vector.py*.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令仅从*vector.py*中引入了Vector类。我们并没有引入*vector.py*中定义的其他任何内容。
- en: As you’ll see in the next section, there are a few ways to import from modules.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你将在下一部分看到的那样，导入模块有几种方式。
- en: '***Different Import Forms***'
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***不同的导入形式***'
- en: To understand the different ways we can import modules and names inside a module,
    let’s use two packages from our *Mechanics* project.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解我们可以如何导入模块和模块中的名称，我们来使用我们*力学*项目中的两个包。
- en: Mechanics
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Mechanics
- en: '|- geom2d'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '|- geom2d'
- en: '|    |- __init__.py'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- __init__.py'
- en: '|    |- point.py'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- point.py'
- en: '|    |- vector.py'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- vector.py'
- en: '|'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|- eqs'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '|- eqs'
- en: '|    |- __init__.py'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- __init__.py'
- en: '|    |- matrix.py'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- matrix.py'
- en: '|    |- vector.py'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- vector.py'
- en: For this example, we’ll use the *geom2d* and *eqs* packages, using two files,
    or modules, inside of each. Each of these modules defines a single class that
    has the same name as the module, only capitalized. For example, the module in
    *point.py* defines the Point class, *vector.py* defines the Vector class, and
    *matrix.py* defines the Matrix class. [Figure 1-3](ch01.xhtml#ch1fig3) illustrates
    this package structure.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用*geom2d*和*eqs*两个包，每个包内都有两个文件或模块。每个模块定义一个类，类的名称与模块名称相同，只是首字母大写。例如，*point.py*模块定义了Point类，*vector.py*定义了Vector类，*matrix.py*定义了Matrix类。[图
    1-3](ch01.xhtml#ch1fig3)展示了这个包的结构。
- en: '![Image](../images/01fig03.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/01fig03.jpg)'
- en: '*Figure 1-3: Two packages from our Mechanics project and some of their modules*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-3：来自我们力学项目的两个包及其部分模块*'
- en: With this directory set up in our minds, let’s analyze several scenarios.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在心中建立这个目录结构，让我们分析几个场景。
- en: '**Importing from a Module in the Same Package**'
  id: totrans-66
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**从同一包中导入模块**'
- en: 'If we are in module *point.py* from the package *geom2d* and we want to import
    the entire *vector.py* module, we can use the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在包*geom2d*中的模块*point.py*中，并且想要导入整个*vector.py*模块，我们可以使用以下代码：
- en: '[PRE3]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now we can use the *vector.py* module’s contents like so:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以像下面这样使用*vector.py*模块的内容：
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'It’s important to note that since we imported the entire module and not any
    of its individual entities, we have to refer to the module-defined entities using
    the module name. If we want to refer to the module using a different name, we
    can alias it:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，由于我们导入了整个模块，而不是其中的单独实体，因此我们必须使用模块名称来引用模块定义的实体。如果我们想使用不同的名称来引用该模块，我们可以为其起别名：
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then we can use it like so:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以像这样使用它：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can also import specific names from a module instead of importing the entire
    module. As you saw earlier, the syntax for this is as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以只导入模块中的特定名称，而不是导入整个模块。正如你之前看到的，语法如下：
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'With this import, we can instead do the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个导入，我们可以改为执行以下操作：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In this case, we can also alias the imported name:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们还可以为导入的名称起别名：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When we *alias* an imported name, we simply rename it to something else. In
    this case, we can now write it as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们*别名*一个导入的名称时，我们只是将它重命名为其他名字。在这种情况下，我们现在可以这样写：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '**Importing from a Module in a Different Package**'
  id: totrans-83
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**从不同包中导入模块**'
- en: 'If we wanted to import the *point.py* module from inside the *matrix.py* module,
    which is in a different package, we could do the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想从不同的包中导入*matrix.py*模块内的*point.py*模块，我们可以做如下操作：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: or equivalently
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 或者等效地
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This lets us use the entire *point.py* module inside *matrix.py*:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就可以在*matrix.py*中使用整个*point.py*模块：
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Once again, we can choose to alias the imported module:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们可以选择为导入的模块起别名：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: or equivalently
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 或者等效地
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Either way, we can use pt as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种方式，我们都可以像这样使用pt：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can also import names from the module, instead of bringing the entire module,
    like so:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以从模块中导入名称，而不是导入整个模块，方法如下：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As before, we can use an alias:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如之前所示，我们可以使用别名：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '**Relative Imports**'
  id: totrans-100
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**相对导入**'
- en: Finally, we have relative imports. A *relative import* is one that refers to
    a module using a route whose start point is the file’s current location.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有相对导入。*相对导入*是指使用以文件当前所在位置为起点的路径来引用模块。
- en: We use one dot (.) to refer to modules or packages inside the same package and
    two dots (..) to refer to the parent directory.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个点（.）来引用同一包中的模块或包，使用两个点（..）来引用父目录。
- en: 'Following our previous example, we could import the *point.py* module from
    within *matrix.py* using a relative import:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们之前的示例，我们可以通过相对导入的方式，从*matrix.py*中导入*point.py*模块：
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In this case, the route ..geom.point means this: from the current directory
    move to our parent’s directory and look for the *point.py* module.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，路径..geom.point的意思是：从当前目录移动到父目录，然后寻找*point.py*模块。
- en: '**Documenting the Code with Docstrings**'
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用文档字符串文档化代码**'
- en: When we write code that other developers will use, it’s good practice to document
    it. This documentation should include information about how to use our code, what
    assumptions the code makes, and what each function does.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写其他开发者会使用的代码时，良好的实践是进行文档化。这些文档应包括如何使用我们的代码、代码做出了哪些假设以及每个函数的功能。
- en: Python uses *docstrings* to document code. These docstrings are defined between
    triple quotes (""") and appear as the first statement of the function, class,
    or module they document.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Python 使用 *文档字符串* 来记录代码。这些文档字符串被定义在三重引号（"""）之间，并出现在它们所记录的函数、类或模块的第一条语句中。
- en: 'You may have noticed how the code for the *Mechanics* project you downloaded
    earlier uses these docstrings. For example, if you open the *matrix.py* file,
    the methods of the Matrix class are documented this way:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，你之前下载的 *Mechanics* 项目的代码如何使用这些文档字符串。例如，如果你打开 *matrix.py* 文件，Matrix
    类的方法就是这样进行文档化的：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If you ever find yourself using this code and can’t figure something out, Python
    has the help global function; if you give help a module, function, class, or method,
    it returns that code’s docstring. For example, we could get the documentation
    for this set_data method inside a Python interpreter console as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在使用这段代码时遇到问题，Python 提供了 `help` 全局函数；如果你将 `help` 应用于模块、函数、类或方法，它将返回该代码的文档字符串。例如，我们可以在
    Python 解释器控制台中这样获取 `set_data` 方法的文档：
- en: '[PRE21]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: There are automated tools, like Sphinx ([*https://www.sphinx-doc.org/*](https://www.sphinx-doc.org/)),
    that generate documentation reports in HTML, PDF, or plaintext using the docstrings
    in a project. You can distribute this documentation along with your code so that
    other developers have a good place to start learning about the code you write.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些自动化工具，比如 Sphinx（[*https://www.sphinx-doc.org/*](https://www.sphinx-doc.org/)），可以使用项目中的文档字符串生成
    HTML、PDF 或纯文本的文档报告。你可以将这些文档与代码一起分发，方便其他开发者开始学习你编写的代码。
- en: We won’t be writing the docstrings in this book as they take up considerable
    space. But they should all be in the code you downloaded, and you can look at
    them there.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中我们不会编写文档字符串，因为它们占用的空间比较大。但它们应该都包含在你下载的代码中，你可以在那里查看。
- en: '**Collections in Python**'
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Python 中的集合**'
- en: Our programs often work with collections of items, sometimes very large ones.
    We want to store these items in a way that is convenient for our purposes. Sometimes
    we’ll be interested in knowing whether a collection includes a particular item,
    and other times we’ll need to know the order of our items; we may also want a
    fast way of finding a given item, maybe one that fulfills a particular condition.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序经常需要处理一系列项目，有时这些集合非常庞大。我们希望以便捷的方式存储这些项目。有时我们会关心某个集合是否包含特定项目，而有时我们需要知道项目的顺序；我们也可能希望有一种快速查找给定项目的方法，或许是找到一个满足特定条件的项目。
- en: As you can see, there are many ways to interact with a collection of items.
    As it turns out, choosing the right way to store data is crucial for our programs
    to perform well. There are different collection flavors, each good for certain
    cases; knowing which type of collection to use in each particular situation is
    an important skill every software developer should master.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，处理集合项的方式有很多种。事实证明，选择正确的数据存储方式对我们的程序性能至关重要。每种集合都有其适用的场景；知道在每个特定情境下使用哪种类型的集合是每个软件开发者应当掌握的重要技能。
- en: 'Python offers us four main collections: the set, the tuple, the list, and the
    dictionary. Let’s explain how each of these collections stores elements and how
    to use them.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Python 提供了四种主要的集合：集合、元组、列表和字典。接下来我们将解释每种集合如何存储元素以及如何使用它们。
- en: '***Sets***'
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***集合***'
- en: The *set* is an unordered collection of unique elements. Sets are most useful
    when we need to quickly determine whether an element exists in a collection.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*集合*是一个无序的独特元素集合。当我们需要快速确定某个元素是否存在于集合中时，集合非常有用。'
- en: 'To create a set in Python, we can use the set function:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Python 中创建一个集合，我们可以使用 `set` 函数：
- en: '[PRE22]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can also use the literal syntax:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用字面量语法：
- en: '[PRE23]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Notice that when using the literal syntax, we define the set using curly brackets
    ({}).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当使用字面量语法时，我们通过花括号（{}）来定义集合。
- en: 'We can get the number of elements contained inside a set using the global len
    function:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用全局的 `len` 函数来获取集合中包含的元素数量：
- en: '[PRE24]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Checking whether an element exists in the set is a fast operation and can be
    done using the in operator:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 检查某个元素是否存在于集合中是一个快速操作，可以使用 `in` 运算符来完成：
- en: '[PRE25]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can add new elements to the set using the add method:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用add方法向集合中添加新元素：
- en: '[PRE26]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If we try to add an element that’s already present, nothing happens because
    a set doesn’t allow repeated elements:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试添加一个已经存在的元素，什么也不会发生，因为集合不允许重复元素：
- en: '[PRE27]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We can remove an element from a set using the remove method:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用remove方法从集合中移除一个元素：
- en: '[PRE28]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can operate with sets using the familiar mathematical operations for sets.
    For example, we can compute the difference between two sets, which is the set
    containing the elements of the first set that aren’t in the second set:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用熟悉的数学操作处理集合。例如，我们可以计算两个集合的差集，即包含第一个集合中不在第二个集合中的元素的集合：
- en: '[PRE29]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can also compute the union of two sets, which is the set containing all
    the elements that appear in both sets:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以计算两个集合的并集，即包含出现在两个集合中的所有元素的集合：
- en: '[PRE30]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can iterate through sets, but the order of the iteration is not guaranteed:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以遍历集合，但遍历的顺序是不确定的：
- en: '[PRE31]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '***Tuples***'
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***元组***'
- en: '*Tuples* are immutable and ordered sequences of elements. *Immutable* means
    that, once created, the tuple cannot be changed in any way. Elements in a tuple
    are referred to with the index they occupy, starting with zero. Counting in Python
    always starts from zero.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*元组*是不可变且有序的元素序列。*不可变*意味着，一旦创建，元组无法以任何方式更改。元组中的元素是通过它们所占的索引来引用的，索引从零开始。在Python中，计数总是从零开始。'
- en: 'Tuples are a good option when we’re passing a collection of ordered data around
    our code but don’t want the collection to be mutated in any way. For example,
    in code like:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在代码中传递有序数据的集合时，元组是一个不错的选择，因为它们不会被任何方式改变。例如，在如下代码中：
- en: '[PRE32]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'you can be sure the names tuple won’t be changed by some_function in any way.
    By contrast, if you decided to use a set like:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以确信，`names`元组不会被某个函数（如some_function）以任何方式修改。相反，如果你决定使用一个集合，比如：
- en: '[PRE33]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: nothing would prevent some_function from adding or removing elements from the
    passed-in names, so you’d need to check the function’s code to understand whether
    the code alters the elements.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 什么也不会阻止some_function向传入的`names`集合中添加或移除元素，因此你需要检查函数的代码，了解代码是否会改变这些元素。
- en: '**NOTE**'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In any case, as we’ll see later, functions shouldn’t mutate their parameters,
    so the functions we’ll write in this book will never modify their input parameters
    in any way. You might, nevertheless, use functions written by other developers
    who didn’t follow the same rule, so you want to check whether those functions
    have these kinds of side effects.*'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*无论如何，正如我们稍后看到的，函数不应该修改它们的参数，所以我们在本书中写的函数将永远不会修改它们的输入参数。尽管如此，你可能会使用由其他开发者编写的函数，而这些开发者没有遵循同样的规则，因此你需要检查这些函数是否有这种副作用。*'
- en: 'Tuples are defined between parentheses, and the elements inside a tuple are
    comma-separated. Here’s a tuple, defined using literal syntax, containing my name
    and age:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 元组是用圆括号定义的，元组中的元素是用逗号分隔的。这里有一个元组，使用字面量语法定义，包含了我的名字和年龄：
- en: '[PRE34]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If we want to create a tuple with only one element, we need to write a comma
    after it:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想创建一个只有一个元素的元组，我们需要在元素后写一个逗号：
- en: '[PRE35]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'It can also be created using the tuple function, passing it a list of items:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以通过tuple函数创建元组，传入一个包含元素的列表：
- en: '[PRE36]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can get the number of items in a tuple using the len global function:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用len全局函数获取元组中元素的数量：
- en: '[PRE37]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We can also count how many times a given value appears inside a tuple using
    the tuple’s count method:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用元组的count方法计算某个值在元组中出现的次数：
- en: '[PRE38]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We can get the index of the first occurrence of a given item using the index
    method:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用index方法获取某个项第一次出现的索引：
- en: '[PRE39]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In this example, we’re looking for the index of the string ’Alvaro’, which
    appears twice: at indices 1 and 5\. The index method yields the first occurrence’s
    index, which is 1 in this case.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们要查找字符串'Alvaro'的索引，它出现了两次：分别在索引1和索引5。index方法返回第一次出现的索引，在这个例子中是1。
- en: 'The in operator can be used to check whether an element exists inside a tuple:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用in运算符检查某个元素是否存在于元组中：
- en: '[PRE40]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Tuples can be multiplied by numbers, a peculiar operation that yields a new
    tuple with the original elements repeated as many times as the multiplier number:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 元组可以被数字乘以，这是一个特殊的操作，会生成一个新元组，原始元素会按照乘数重复：
- en: '[PRE41]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We can iterate through tuple values using for loops:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用for循环遍历元组的值：
- en: '[PRE42]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Using Python’s built-in enumerate function, we can iterate through the items
    in the tuple with their indices:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Python的内建enumerate函数，我们可以遍历元组中的项及其索引：
- en: '[PRE43]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '***Lists***'
  id: totrans-172
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***列表***'
- en: The *list* is an ordered collection of nonunique elements referenced by their
    index. Lists are well suited for cases where we need to keep elements in order
    and where we know the index at which they appear.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表* 是一个有序的非唯一元素集合，通过它们的索引进行引用。列表非常适合需要按顺序保存元素并且我们知道它们出现位置的情况。'
- en: Lists and tuples are similar, with the tuple’s immutability being the only difference;
    items in a list move around, and items can be added and removed. If you are sure
    the items in a large collection won’t be modified, use a tuple instead of a list;
    tuple manipulations are faster than their list equivalents. Python can do some
    optimizations if it knows the items in the collection won’t change.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 列表和元组相似，唯一的区别是元组是不可变的；列表中的元素可以移动，可以添加和删除元素。如果你确定一个大型集合中的元素不会被修改，使用元组而不是列表；元组的操作比列表的操作更快。如果
    Python 知道集合中的元素不会改变，它可以做一些优化。
- en: 'To create a list in Python, we can use the list function:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中创建一个列表，我们可以使用 list 函数：
- en: '[PRE44]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Or we can use the literal syntax:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可以使用字面量语法：
- en: '[PRE45]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Note the usage of the square brackets ([]).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用方括号（[]）的方式。
- en: 'We can check the number of items in a list using the len function:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 len 函数来检查列表中元素的数量：
- en: '[PRE46]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'List elements can be accessed by index (the index of the first element is zero):'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 列表元素可以通过索引访问（第一个元素的索引是零）：
- en: '[PRE47]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We can also replace an existing element in the list:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以替换列表中的现有元素：
- en: '[PRE48]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Be careful not to use an index that doesn’t exist in the list; it’ll raise
    an IndexError:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 小心不要使用列表中不存在的索引；这会引发 IndexError：
- en: '[PRE49]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Items can be appended to the end of the list using the append method:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 append 方法将项目追加到列表的末尾：
- en: '[PRE50]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Lists can be iterated, and the order of iteration is guaranteed:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 列表可以被迭代，且迭代的顺序是有保证的：
- en: '[PRE51]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Often enough, we’re interested not only in the element itself but also in its
    index in the list. In those cases, we can use the enumerate function, which yields
    a tuple of the index and element:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 很多时候，我们不仅对元素本身感兴趣，还对它在列表中的索引感兴趣。在这种情况下，我们可以使用 enumerate 函数，它返回一个包含索引和元素的元组：
- en: '[PRE52]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: A new list can be created by taking contiguous elements from another list. This
    process is called *slicing*. Slicing is a big topic that requires a section of
    its own.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过从另一个列表中取连续元素来创建新列表。这个过程叫做 *切片*。切片是一个重要的话题，需要单独的一节来讲解。
- en: '**Slicing Lists**'
  id: totrans-195
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**切片列表**'
- en: 'Slicing a list looks a bit like indexing into the list using square brackets,
    except we use two indices separated by a colon: [*<start>* : *<end>*]. Here’s
    an example:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '切片列表看起来有点像使用方括号进行索引，只是我们使用两个由冒号分隔的索引：[*<start>* : *<end>*]。以下是一个例子：'
- en: '[PRE53]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In the previous example, we have a list a with values [1, 2, 3, 4]. We create
    a new list, b, by slicing the original list and taking the items starting at index
    1 (inclusive) and ending at index 3 (noninclusive).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们有一个包含值 [1, 2, 3, 4] 的列表 a。我们通过切片原始列表，创建了一个新列表 b，从索引 1（包含）开始，到索引 3（不包含）结束。
- en: '**NOTE**'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Don’t forget that slices in Python always include the element in the start
    index and exclude the element in the end index.*'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '*不要忘记，Python 中的切片总是包括起始索引的元素，并且排除结束索引的元素。*'
- en: '[Figure 1-4](ch01.xhtml#ch1fig4) illustrates this process.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 1-4](ch01.xhtml#ch1fig4) 展示了这一过程。'
- en: '![Image](../images/01fig04.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/01fig04.jpg)'
- en: '*Figure 1-4: Slicing a list*'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-4：切片一个列表*'
- en: Both the start and end indices in the slice operator are optional because they
    have a default value. By default, the start index is assigned the first index
    in the list, which is always zero. The end index is assigned the last index in
    the list plus one, which is equal to len(the_list).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 切片操作符中的起始和结束索引是可选的，因为它们有默认值。默认情况下，起始索引被赋值为列表中的第一个索引，始终为零。结束索引被赋值为列表中的最后一个索引加一，这等于
    len(the_list)。
- en: '[PRE54]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In this example, both b_1 and b_2 lists are a copy of the original a list.
    By copy we really mean they’re different lists; you can safely modify b_1 or b_2,
    and list a remains unchanged. You can test this by doing the following:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，b_1 和 b_2 列表都是原始 a 列表的副本。我们所说的副本意味着它们是不同的列表；你可以安全地修改 b_1 或 b_2，而列表 a
    保持不变。你可以通过以下方式来验证：
- en: '[PRE55]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Negative indices are another trick you can use. A negative index is an index
    that is counted starting from the end of the list and moving toward the beginning
    of the list. Negative indices can be used in slicing operations the same way as
    positive indices, with a small exception: negative indices start at –1, not at
    –0\. We could, for instance, slice a list to get its two last values as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 负索引是你可以使用的另一个技巧。负索引是从列表的末尾开始计算并向列表的开头移动的索引。负索引可以像正索引一样用于切片操作，唯一的区别是：负索引从 -1
    开始，而不是从 -0 开始。例如，我们可以通过以下方式切片列表，获取它的最后两个值：
- en: '[PRE56]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Here we’re creating a new list starting at the second position from the end
    all the way to the last element of the list. [Figure 1-5](ch01.xhtml#ch1fig5)
    illustrates this.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在创建一个新列表，从倒数第二个位置开始，一直到列表的最后一个元素。[图 1-5](ch01.xhtml#ch1fig5)展示了这一点。
- en: Slicing lists is a versatile operation in Python.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 切片列表是 Python 中的一项多功能操作。
- en: '![Image](../images/01fig05.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/01fig05.jpg)'
- en: '*Figure 1-5: Slicing a list using negative indices*'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-5：使用负索引切片列表*'
- en: '***Dictionaries***'
  id: totrans-214
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***字典***'
- en: A *dictionary* is a collection of key-value pairs. Values in a dictionary are
    mapped to their key; we retrieve elements from a dictionary using their key. Finding
    a value in a dictionary is fast.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *字典* 是由键值对组成的集合。字典中的值与它们的键相关联；我们通过键从字典中检索元素。在字典中查找值的速度非常快。
- en: Dictionaries are useful when we want to store elements referenced by some key.
    For example, if we wanted to store information about our siblings and wanted to
    be able to retrieve it by the name of the sibling, we could use a dictionary.
    We’ll take a look at this in the following code.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想存储由某些键引用的元素时，字典非常有用。例如，如果我们想存储关于兄弟姐妹的信息，并且希望能通过兄弟姐妹的名字来检索这些信息，我们可以使用字典。我们将在接下来的代码中查看这一点。
- en: To create a dictionary in Python, you can either use the dict function,
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中创建字典，你可以使用 `dict` 函数，
- en: '[PRE57]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: or use the literal syntax,
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 或者使用字面量语法，
- en: '[PRE58]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The dict function expects a list of tuples. These tuples should contain two
    values: the first one is used as the key, and the second is used as the value.
    The literal version for creating dictionaries is much less verbose, and in both
    cases the resulting dictionary is the same.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`dict` 函数期望传入一个包含元组的列表。这些元组应包含两个值：第一个值作为键，第二个值作为值。创建字典的字面量版本要简洁得多，并且在两种情况下，最终生成的字典是一样的。'
- en: 'As with a list, we access values in a dictionary using square brackets. However,
    this time we use the key of the value between the brackets, as opposed to the
    index:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 和列表一样，我们可以使用方括号访问字典中的值。然而，这次我们在方括号中使用的是值的键，而不是索引：
- en: '[PRE59]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: You can use anything that’s immutable as the key in a dictionary. Remember that
    tuples are immutable, whereas lists are not. Numbers, strings, and booleans are
    also immutable and thus can be used as dictionary keys.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用任何不可变的对象作为字典中的键。记住，元组是不可变的，而列表则不是。数字、字符串和布尔值也是不可变的，因此可以用作字典键。
- en: 'Let’s create a dictionary where the keys are tuples:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个字典，键是元组：
- en: '[PRE60]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'In this example, we map the age to a key composed of a name and a surname in
    a tuple. If we want to know Jen’s age, we can ask for the value in a dictionary
    by using its key:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将年龄映射到由名字和姓氏组成的键（一个元组）。如果我们想知道 Jen 的年龄，我们可以通过使用其键在字典中获取相应的值：
- en: '[PRE61]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: What happens when we look for a key that’s not in the dictionary?
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查找一个字典中不存在的键时，会发生什么？
- en: '[PRE62]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We get an error. We can check whether a key is in a dictionary before getting
    its value using the in operator:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会得到一个错误。我们可以在获取字典中的值之前，使用 `in` 操作符检查键是否存在：
- en: '[PRE63]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We can also get a set-like view of all the keys in the dictionary:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以获得一个类似集合的视图，包含字典中的所有键：
- en: '[PRE64]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We can do the same for the values:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对值做同样的操作：
- en: '[PRE65]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We can use the in operator to check for the existence of a value in both the
    keys and values stored in Python dictionaries:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `in` 操作符检查字典中键和值的存在情况：
- en: '[PRE66]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Dictionaries can be iterated in a few ways. Let’s imagine we have the following
    ages dictionary:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 字典可以通过几种方式进行遍历。假设我们有以下的年龄字典：
- en: '[PRE67]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We can use for loops to iterate through the dictionary keys:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `for` 循环遍历字典的键：
- en: '[PRE68]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We can do the same for the values:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对值做同样的操作：
- en: '[PRE69]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'And we can do the same for the key-value tuples:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以对键值元组做同样的操作：
- en: '[PRE70]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: That’s about all we need to know about Python’s collections for now. Let’s continue
    our Python tour by looking at destructuring collections.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 目前为止，这就是我们需要了解的 Python 集合内容。接下来让我们继续 Python 之旅，学习如何解构集合。
- en: '**Destructuring**'
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**解构**'
- en: '*Destructuring* or *unpacking* is a technique that allows us to assign values
    inside a collection to variables. Let’s look at some examples.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '*解构* 或 *拆解* 是一种技术，它允许我们将集合中的值分配给变量。让我们看一些例子。'
- en: 'Imagine we have a tuple containing information about a person, including her
    name and favorite beverage:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个包含某个人信息的元组，其中包括她的姓名和最喜欢的饮料：
- en: '[PRE71]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Say we want to have those two pieces of information in separate variables.
    We could separate them out like so:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想将这两条信息分配给两个单独的变量。我们可以这样分开：
- en: '[PRE72]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'This is perfectly fine, but we can do it in a more elegant way using destructuring
    syntax. To destructure the two strings inside the tuple into two variables, we
    have to use another tuple with the variable names on the left side of the assignment:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做完全可以，但我们可以使用解构语法以更优雅的方式来实现。为了将元组中的两个字符串解构到两个变量中，我们需要在赋值的左侧使用另一个元组，包含变量名：
- en: '[PRE73]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: We can also destructure lists. For example, if we had a list containing similar
    information about another person, like
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以解构列表。例如，如果我们有一个列表，包含另一个人的类似信息，如
- en: '[PRE74]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'we could destructure the name and favorite beverage using a list on the left
    side of the assignment:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用左侧的列表解构出姓名和最喜欢的饮料：
- en: '[PRE75]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The left-side tuple or list has to match the size of the one on the right side,
    but there might be cases where we’re not interested in all of the unpacked values.
    In such cases, you can use an underscore in those positions where you want to
    ignore the corresponding value. For example,
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧的元组或列表必须与右侧的大小匹配，但有时我们并不关心解构出来的所有值。在这种情况下，可以在不想获取对应值的位置使用下划线。例如，
- en: '[PRE76]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: assigns the value 1 to variable a and assigns 3 to variable c, but it discards
    the value 2.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 将值 1 分配给变量 a，将值 3 分配给变量 c，但会丢弃值 2。
- en: This is another technique that helps us write more concise code.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种帮助我们编写更简洁代码的技巧。
- en: '**Summary**'
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: This chapter has been a tour of some intermediate and advanced Python techniques
    we’ll use throughout the book. We took a look at how Python programs are made
    of modules bundled into packages and how to import these modules from other parts
    of our code.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了一些中级和高级的 Python 技巧，这些技巧我们将在整本书中使用。我们了解了 Python 程序是由模块组成，这些模块打包成包，并且如何从代码的其他部分导入这些模块。
- en: We also explained the “if name is main” pattern, which is used to avoid executing
    portions of the code when the file is imported.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还解释了“if name is main”模式，它用于避免在文件被导入时执行部分代码。
- en: 'Then, we briefly touched on the four basic Python collections: tuples, lists,
    sets, and dictionaries. We also looked at how to destructure, or unpack, these
    collections.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们简要介绍了四种基本的 Python 集合：元组、列表、集合和字典。我们还学习了如何解构或拆解这些集合。
- en: Now let’s shift gears and talk about a few programming paradigms.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们换个话题，谈谈几种编程范式。
