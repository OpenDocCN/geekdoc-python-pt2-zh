- en: '8'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '8'
- en: DRAWING VECTOR IMAGES
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制矢量图像
- en: '![Image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/common01.jpg)'
- en: We’re about to start drawing images described by mathematical equations, a topic
    as fascinating as it is entertaining. We call images consisting of geometric primitives
    *vector images*, as opposed to *bitmap images*, which are sometimes also called
    *raster images*. Vector images are perfect for plotting the results of engineering
    problems that often come in the form of diagrams and simplified problem geometries.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将开始绘制由数学方程式描述的图像，这是一个既有趣又富有娱乐性的主题。我们称由几何原始元素构成的图像为*矢量图像*，与*位图图像*相对，后者有时也被称为*光栅图像*。矢量图像非常适合绘制工程问题的结果，这些问题通常以图表和简化的几何形式呈现。
- en: 'In this chapter, we’ll create our own Python package capable of creating SVG
    images out of the geometric primitives we created in [Part II](part02.xhtml#part02)
    of the book: points, segments, circles, polygons, and so on. In later chapters,
    when we use code to solve actual mechanics problems, this package will help us
    produce graphical results.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将创建自己的 Python 包，能够从我们在[第二部分](part02.xhtml#part02)中创建的几何原始元素（如点、线段、圆、
    多边形等）生成 SVG 图像。在后面的章节中，当我们使用代码解决实际的力学问题时，这个包将帮助我们生成图形结果。
- en: There are good SVG packages out there (such as *svgwrite*, for instance), and
    we could just import them, but this book is about learning by doing, so we won’t
    be using anything besides the Python Standard Library and our own code.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 市面上有许多优秀的 SVG 包（例如 *svgwrite*），我们可以直接导入它们，但本书的重点是通过实践学习，所以除了 Python 标准库和我们自己的代码，我们不会使用任何外部库。
- en: For the sake of brevity, we won’t be writing unit tests in this chapter, but
    if you download the code, you’ll see I wrote them to make sure everything works
    as it should. I encourage you to try to write your own unit tests for functions
    in this chapter and then compare them to the code I provided.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，我们在这一章中不会编写单元测试，但如果你下载代码，你会看到我已经写好了单元测试，以确保一切正常工作。我鼓励你尝试为本章中的函数编写自己的单元测试，然后将其与我提供的代码进行比较。
- en: 'This chapter will introduce a powerful concept: *templating*. When templating,
    we have a piece of text, the *template*, that can be customized by filling in
    different placeholders. This technique is widely used in web development to produce
    the HTML document that gets rendered in your browser. Here again, there are many
    good templating libraries (such as *jinja2* or *mako*), but we want to learn how
    they work behind the scenes, so instead of using any of them, we’ll write our
    own templating logic.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍一个强大的概念：*模板化*。在模板化时，我们有一段文本，称为*模板*，它可以通过填充不同的占位符来定制。这项技术在 web 开发中广泛使用，用于生成在浏览器中渲染的
    HTML 文档。在这里，确实有很多优秀的模板库（如 *jinja2* 或 *mako*），但我们希望了解它们背后的工作原理，因此我们将自己编写模板逻辑，而不是使用现成的库。
- en: '**Bitmaps and Vector Images**'
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**位图和矢量图像**'
- en: 'There are two types of images: *bitmaps* and *vectors*. You’ve likely seen
    bitmap images before: *.jpeg*, *.gif*, and *.png* are all examples of bitmap image
    formats. A bitmap is an image defined over a grid of pixels where each individual
    pixel is assigned a particular color. These images look nice in their original
    size, but if you zoom in, you may start to distinguish those squares, the pixels.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图像有两种类型：*位图*和*矢量图*。你可能以前见过位图图像：*.jpeg*、*.gif* 和 *.png* 都是位图图像格式的例子。位图是一种在像素网格上定义的图像，每个像素都会被赋予一个特定的颜色。这些图像在原始尺寸下看起来很漂亮，但如果你放大，可能会开始看到那些小方格——像素。
- en: Vector images, on the other hand, define their content by means of mathematical
    equations. This has the advantage of scaling smoothly without losing any quality.
    Let’s explore *.svg*, the most widely used vector image format and the one we’ll
    be using in this book.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，矢量图像通过数学方程式定义其内容。这具有平滑缩放而不失真质量的优势。让我们来探索 *.svg*，这是最广泛使用的矢量图像格式，也是我们在本书中将使用的格式。
- en: '**The SVG Format**'
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**SVG 格式**'
- en: SVG stands for Scalable Vector Graphics. Its specification was developed by
    the *World Wide Web Consortium (W3C)* and is an open standard. I recommend that
    you open [*https://developer.mozilla.org/en-US/docs/Web/SVG*](https://developer.mozilla.org/en-US/docs/Web/SVG)
    and have it with you as a reference to look at; it’ll provide more complete descriptions
    and examples that can complement the ones in this book. If you ever need to add
    something new to your SVG package, this page will be your ally.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: SVG 代表可缩放矢量图形。其规范由*万维网联盟 (W3C)* 开发，并且是一个开放标准。我建议你打开 [*https://developer.mozilla.org/en-US/docs/Web/SVG*](https://developer.mozilla.org/en-US/docs/Web/SVG)，将其作为参考，查看更完整的描述和示例，这些内容可以补充书中所述的内容。如果你需要向你的
    SVG 包添加新内容，这个页面将是你的好帮手。
- en: 'Let’s look at the following definition from the Mozilla website mentioned above
    for a quick reference on how these kinds of images are defined, as it beautifully
    describes the process:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速参考一下上面提到的 Mozilla 网站中的定义，它优美地描述了这些图像是如何定义的：
- en: SVG images and their related behaviors are defined in XML text files, which
    means they can be searched, indexed, scripted, and compressed. Additionally, this
    means they can be created and edited with any text editor and with drawing software.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: SVG 图像及其相关行为是通过 XML 文本文件定义的，这意味着它们可以被搜索、索引、脚本化和压缩。此外，这也意味着它们可以使用任何文本编辑器和绘图软件创建和编辑。
- en: Note that SVG images are defined as plaintext, whereas most other image formats
    are binary encoded. This means we can readily automate the creation of SVG images
    and even inspect the contents of an existing image.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，SVG 图像是以纯文本格式定义的，而大多数其他图像格式是以二进制编码的。这意味着我们可以轻松地自动化创建 SVG 图像，甚至检查现有图像的内容。
- en: '**NOTE**'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*This chapter assumes you have a basic understanding of XML format, but if
    you don’t, don’t worry; it’s quite simple to learn. Check the following resources
    to get started with it:* [https://www.w3schools.com/xml](https://www.w3schools.com/xml)
    *and* [https://www.xmlfiles.com/xml](https://www.xmlfiles.com/xml).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章假设你已经对 XML 格式有基本了解，但如果你没有，也不用担心；它非常容易学习。可以查看以下资源开始学习：* [https://www.w3schools.com/xml](https://www.w3schools.com/xml)
    *和* [https://www.xmlfiles.com/xml](https://www.xmlfiles.com/xml)。'
- en: Let’s try to create our first SVG image. Open your favorite plaintext editor
    such as Sublime Text, Visual Studio Code, Atom, or even PyCharm if you want, and
    write [Listing 8-1](ch08.xhtml#ch8lis1).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试创建第一个 SVG 图像。打开你喜欢的纯文本编辑器，如 Sublime Text、Visual Studio Code、Atom，或者如果你喜欢，也可以使用
    PyCharm，然后编写 [清单 8-1](ch08.xhtml#ch8lis1)。
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 8-1: SVG description of several circles*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-1：多个圆形的 SVG 描述*'
- en: Note that you shouldn’t create SVG files using a rich-text editor such as Word.
    These rich-text editors add their own markings into the raw file and break the
    SVG format.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你不应使用富文本编辑器（如 Word）创建 SVG 文件。这些富文本编辑器会在原始文件中添加自己的标记，破坏 SVG 格式。
- en: Once you’ve copied what’s in [Listing 8-1](ch08.xhtml#ch8lis1), save the file
    as *circles.svg*, and open it using either Chrome or Firefox. Believe it or not,
    browsers are some of the best SVG image viewers. Using their *developer tools*,
    we can inspect the different parts that make up an image, something that will
    prove useful later when we build more complex images. You should see something
    like [Figure 8-1](ch08.xhtml#ch8fig1) (there’ll be colors on your screen, but
    the print version of the book is in grayscale). Zoom in on the image, and you’ll
    see how it retains its crispness.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你复制了 [清单 8-1](ch08.xhtml#ch8lis1) 中的内容，保存文件为 *circles.svg*，并使用 Chrome 或 Firefox
    打开它。信不信由你，浏览器是一些最好的 SVG 图像查看器。通过使用它们的 *开发者工具*，我们可以检查组成图像的不同部分，这在稍后构建更复杂的图像时将非常有用。你应该看到类似
    [图 8-1](ch08.xhtml#ch8fig1) 的图像（屏幕上会有颜色，但书籍的印刷版是灰度的）。放大图像，你会看到它如何保持清晰。
- en: '![Image](../images/08fig01.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/08fig01.jpg)'
- en: '*Figure 8-1: Examples of SVG circles*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-1：SVG 圆形示例*'
- en: Let’s break down the code in [Listing 8-1](ch08.xhtml#ch8lis1). The first and
    most cryptic line contains the *XML namespace* (xmln) attribute.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一下 [清单 8-1](ch08.xhtml#ch8lis1) 中的代码。第一行最为晦涩，包含了 *XML 命名空间*（xmln）属性。
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We have to include this namespace definition in every svg opening tag. The width
    and height attributes determine the size of the image in pixels. SVG *attributes*
    are modifiers that affect how a particular element is rendered. The width and
    height attributes, for example, determine the size of the drawing.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须在每个 svg 开始标签中包含这个命名空间定义。width 和 height 属性确定图像的像素大小。SVG *属性* 是影响特定元素如何呈现的修饰符。例如，width
    和 height 属性决定了绘图的大小。
- en: 'Then, between the svg open and close tags is the actual definition of what
    is drawn, in this case three circles:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 svg 开始和结束标签之间是实际的绘制定义，在这种情况下是三个圆形：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As you may have guessed, cx and cy correspond to the coordinates of the center
    point; r is the radius of the circle. The attribute fill determines the fill color
    for the circles in hexadecimal format: #rrggbbaa, where rr is the red value, gg
    is the green value, bb is the blue value, and aa is the alpha or opacity value
    (see [Figure 8-2](ch08.xhtml#ch8fig2)).'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经猜到的，cx 和 cy 对应的是圆心的坐标；r 是圆的半径。属性 fill 确定圆形的填充颜色，采用十六进制格式：#rrggbbaa，其中
    rr 是红色值，gg 是绿色值，bb 是蓝色值，aa 是 alpha 或透明度值（参见 [图 8-2](ch08.xhtml#ch8fig2)）。
- en: '![Image](../images/08fig02.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/08fig02.jpg)'
- en: '*Figure 8-2: Hexadecimal color components*'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-2：十六进制颜色组件*'
- en: 'For example, the color #ff000077 has the following components:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '例如，颜色 #ff000077 具有以下组成部分：'
- en: '**red**    ff, the maximum value (255 in base 10)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**红色**    ff，最大值（十进制中的 255）'
- en: '**green**    00, the minimum value (0 in base 10)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**绿色**    00，最小值（十进制中的 0）'
- en: '**blue**    00, the minimum value (0 in base 10)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**蓝色**    00，最小值（十进制中的 0）'
- en: '**alpha**    77, a value of 119 out of 255, which equals an alpha percentage
    of around 47%'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**透明度**    77，255 中的 119，相当于约 47% 的透明度'
- en: This color is a perfect red with some transparency added to it.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这种颜色是纯正的红色，并加入了一些透明度。
- en: 'You may not have realized, but the origin of coordinates for SVG images is
    located in the upper-left corner, with its y-axis pointing down. You may not be
    used to this orientation of the vertical axis, but don’t worry: by using one of
    our affine transformations, we can easily transform space so that the y-axis points
    upward, as you’ll see later in the chapter. [Figure 8-3](ch08.xhtml#ch8fig3) shows
    the geometry and arrangement of coordinates for the image we created.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能没有意识到，但 SVG 图像的坐标原点位于左上角，y 轴指向下方。你可能不习惯这种垂直轴的方向，但别担心：通过使用我们的仿射变换之一，我们可以轻松地将空间变换，使
    y 轴指向上方，正如你将在本章后面看到的那样。[图 8-3](ch08.xhtml#ch8fig3) 展示了我们创建的图像的几何形状和坐标布局。
- en: '![Image](../images/08fig03.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/08fig03.jpg)'
- en: '*Figure 8-3: The geometry of our first SVG image*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-3：我们第一个 SVG 图像的几何形状*'
- en: '***The viewBox***'
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***viewBox***'
- en: A useful attribute that we can define for the svg tag is the viewBox. The viewBox
    is the rectangular portion of the image the user sees. It’s defined using four
    numbers,
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为 svg 标签定义的一个有用属性是 viewBox。viewBox 是用户看到的图像的矩形部分。它由四个数字定义，
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: where x and y are the coordinates of the rectangle’s origin, and w and h are
    the width and height of the rectangle.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 x 和 y 是矩形原点的坐标，w 和 h 是矩形的宽度和高度。
- en: Let’s add a viewBox to our circles image to see its effect (see [Listing 8-2](ch08.xhtml#ch8lis2)).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们给圆形图像添加一个 viewBox 来查看其效果（参见 [列表 8-2](ch08.xhtml#ch8lis2)）。
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 8-2: SVG viewBox*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-2：SVG viewBox*'
- en: Save the changes we made in [Listing 8-2](ch08.xhtml#ch8lis2) and reload the
    image in the browser to see the change. To understand what’s happened, take a
    look at [Figure 8-4](ch08.xhtml#ch8fig4).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 保存我们在 [列表 8-2](ch08.xhtml#ch8lis2) 中所做的更改，并在浏览器中重新加载图像以查看变化。要理解发生了什么，查看 [图 8-4](ch08.xhtml#ch8fig4)。
- en: 'We’ve defined a rectangle whose origin is at (100, 100), with a width of 300
    and a height of 300: a rectangle that contains all three circles without any margin.
    Notice the image retains its size of 500 by 500 pixels, as defined by the width
    and height attributes. If the size of the viewBox is not the same as the size
    of the SVG itself, the content is scaled.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个矩形，其原点在 (100, 100)，宽度为 300，高度为 300：一个包含所有三个圆形且没有任何边距的矩形。注意，图像保持其 500x500
    像素的大小，这是由 width 和 height 属性定义的。如果 viewBox 的大小与 SVG 本身的大小不同，内容会被缩放。
- en: '![Image](../images/08fig04.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/08fig04.jpg)'
- en: '*Figure 8-4: The *viewBox* of an SVG image*'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-4：SVG 图像的 *viewBox*'
- en: The viewBox is therefore the rectangular portion from the infinite canvas that’s
    displayed to the user. It’s optional, and it defaults to the rectangle with the
    size defined by width and height, with its origin at (0, 0).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，viewBox 是从无限画布中显示给用户的矩形部分。它是可选的，默认为由宽度和高度定义的矩形，原点在 (0, 0)。
- en: '***Space Transformation***'
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***空间变换***'
- en: 'Remember the concept of affine transformations from [Chapter 7](ch07.xhtml#ch07)?
    SVG images use them to transform their content. The attribute transform can be
    used to define the affine transformation matrix as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得[第 7 章](ch07.xhtml#ch07)中讲解的仿射变换概念吗？SVG 图像使用它们来变换内容。属性 transform 可以用来定义仿射变换矩阵，如下所示：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The confusing order of the matrix terms may seem surprising at first, but it
    actually makes sense, at least for the people behind the SVG standard. The SVG
    documentation defines the affine transformation matrix as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵项的顺序看起来可能一开始有些令人困惑，但对于 SVG 标准的制定者来说，这其实是有意义的。SVG 文档定义了仿射变换矩阵，如下所示：
- en: '![Image](../images/f0208-01.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0208-01.jpg)'
- en: 'So these are the terms of the transform attribute:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是 transform 属性的术语：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Translated to our less cryptic language, the terms are *a* = *s*[*x*], *b*
    = *sh*[*y*], *c* = *sh*[*x*], *d* = *s*[*y*], *e* = *t*[*x*], and *f* = *t*[*y*]:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 用我们更易理解的语言来表达，这些术语是 *a* = *s*[*x*]，*b* = *sh*[*y*]，*c* = *sh*[*x*]，*d* = *s*[*y*]，*e*
    = *t*[*x*]，*f* = *t*[*y*]：
- en: '![Image](../images/f0208-02.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0208-02.jpg)'
- en: Let’s see it in action. We’ll apply a shear in the x direction by setting *sh*[*x*]
    to be 1\. Remember that both *s*[*x*] and *s*[*y*] have to be 1; otherwise, if
    set as zero, the image would collapse in a line or point, and we wouldn’t see
    anything. [Listing 8-3](ch08.xhtml#ch8lis3) has the added transform attribute.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它如何运作。我们将通过将 *sh*[*x*] 设置为 1 来应用 x 方向上的剪切变换。记住，*s*[*x*] 和 *s*[*y*] 必须都为
    1；否则，如果设置为零，图像将会塌缩成一条线或一个点，我们将看不到任何东西。[清单 8-3](ch08.xhtml#ch8lis3)中已经包含了 transform
    属性。
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 8-3: Shear transformation in circles image*'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-3：圆形图像中的剪切变换*'
- en: Remember to remove the viewBox attribute so the resulting geometry doesn’t get
    cropped. You should see something like [Figure 8-5](ch08.xhtml#ch8fig5).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 记得删除 viewBox 属性，以免结果几何形状被裁剪。你应该看到类似[图 8-5](ch08.xhtml#ch8fig5)的内容。
- en: '![Image](../images/08fig05.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/08fig05.jpg)'
- en: '*Figure 8-5: Our circles once transformed*'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-5：变换后的圆形*'
- en: 'What about inverting the y-axis so that it points upward, like we’re used to?
    Easy! Edit the transform matrix to the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 那么如何反转 y 轴，使其朝上，就像我们习惯的那样？很简单！编辑 transform 矩阵如下：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The resulting geometry you should see is outlined in [Figure 8-6](ch08.xhtml#ch8fig6).
    Compare it with [Figure 8-1](ch08.xhtml#ch8fig1). See what happened? The picture
    flipped vertically.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到的结果几何形状在[图 8-6](ch08.xhtml#ch8fig6)中有所概述。将其与[图 8-1](ch08.xhtml#ch8fig1)进行比较。发生了什么？图像进行了垂直翻转。
- en: '![Image](../images/08fig06.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/08fig06.jpg)'
- en: '*Figure 8-6: Transformed circles, with the y-axis inverted*'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-6：变换后的圆形，y 轴反转*'
- en: Now that you have a basic understanding of how to create SVG images, let’s do
    some Python coding. We’ll create a package in our project to draw SVG images.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经基本理解了如何创建 SVG 图像，让我们开始做一些 Python 编程。我们将在项目中创建一个包来绘制 SVG 图像。
- en: '**The svg Package**'
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**svg 包**'
- en: Let’s create a new package for graphics in our project, which will contain a
    subpackage to produce SVG images. Later in the book we’ll add other subpackages
    for other kinds of graphical operations. Right-click the project name in the **Project
    Tool** window and choose **New** ▸ **Python Package**. Name it *graphic*. You
    can also create a new folder yourself, but don’t forget to add the *__init__.py*
    file to instruct Python this is a package.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为项目创建一个新的图形包，它将包含一个用于生成 SVG 图像的子包。稍后在本书中，我们将为其他类型的图形操作添加更多子包。右键点击 **项目工具**
    窗口中的项目名称，选择 **新建** ▸ **Python 包**。将其命名为 *graphic*。你也可以自己创建一个新文件夹，但别忘了添加 *__init__.py*
    文件，告诉 Python 这是一个包。
- en: 'You should have the package at the same level as *geom2d*, and it should contain
    only an *__init__.py* file. Your project’s directory structure should look like
    this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该将包放置在与 *geom2d* 同一级别，并且只包含一个 *__init__.py* 文件。你的项目目录结构应该如下所示：
- en: Mechanics
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 机械学
- en: '|- geom2d'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '|- geom2d'
- en: '|    |- tests'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- tests'
- en: '|- graphic'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '|- graphic'
- en: '|- utils'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '|- utils'
- en: 'Now let’s add the *svg* subpackage: right-click the package you just created
    and choose **New** ▸ **Python Package** again, but this time name it *svg*. Now
    we’re ready to start adding our code.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们添加 *svg* 子包：右键点击刚刚创建的包，再次选择 **新建** ▸ **Python 包**，但这次将其命名为 *svg*。现在我们可以开始添加代码了。
- en: '***Templates***'
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***模板***'
- en: A template is a document with some placeholders in it. By assigning values to
    these placeholders we can produce a complete version of the document. Think, for
    instance, about those email campaigns that greet you by your name. The company
    sending them probably has a template like
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 模板是一个包含占位符的文档。通过为这些占位符赋值，我们可以生成文档的完整版本。例如，想想那些通过你名字来问候你的邮件营销活动。发送这些邮件的公司可能有一个像这样的模板。
- en: Hello, {{name}}!
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你好，{{name}}！
- en: Here are some book recommendations we think you may like.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些我们认为你可能喜欢的书籍推荐。
- en: '...'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: and an automatic process that substitutes the {{name}} placeholder with each
    of their clients’ names and then sends the final composed email.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 并且通过一个自动化过程，将 {{name}} 占位符替换为每个客户的名字，然后发送最终生成的邮件。
- en: The placeholders in a template may also be called *variables*. Variables are
    given values in the process of rendering the template, which produces the final
    document with everything defined in it. [Figure 8-7](ch08.xhtml#ch8fig7) illustrates
    the process of rendering the same template with two different sets of values.
    The template has the variables place-from, place-to, distance, and units, which
    we assign different values to produce different versions of the same template.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 模板中的占位符也可以称为 *变量*。在渲染模板的过程中，变量会被赋值，从而生成最终的文档，文档中包含了所有已定义的内容。[图 8-7](ch08.xhtml#ch8fig7)
    演示了使用两组不同值渲染相同模板的过程。模板中有变量 place-from、place-to、distance 和 units，我们为这些变量赋不同的值，生成相同模板的不同版本。
- en: '![Image](../images/08fig07.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/08fig07.jpg)'
- en: '*Figure 8-7: Template rendering process*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-7：模板渲染过程*'
- en: Using templates is a powerful technique that solves a variety of problems where
    text of any shape and format needs to be generated. Most web frameworks, for instance,
    use some kind of templating to produce the rendered HTML document. We’ll employ
    a template to generate our SVG images.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模板是一种强大的技术，解决了需要生成任何形状和格式的文本的各种问题。例如，大多数 web 框架使用某种形式的模板来生成渲染后的 HTML 文档。我们将使用模板来生成我们的
    SVG 图像。
- en: '**An Example Using Python’s String Replacement**'
  id: totrans-94
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用 Python 字符串替换的示例**'
- en: 'Let’s work on a template example in code. Open Python’s shell and enter the
    following template string:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在代码中做一个模板示例。打开 Python 的 shell，并输入以下模板字符串：
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, let’s create a greeting by substituting the {{name}} variable with a real
    name:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过将 {{name}} 变量替换为真实名字来创建一个问候语：
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As you can see, we can use Python’s replace string method to create a new string
    where {{name}} has been replaced by ’Angel’. Since replace returns a new instance,
    we can chain the calls like so:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们可以使用 Python 的 replace 字符串方法来创建一个新的字符串，其中 {{name}} 已被 'Angel' 替换。由于 replace
    返回一个新的实例，我们可以像这样链式调用：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this example, we first replaced the {{name}} variable with the string ’Angel’.
    Then, we called the replace method on the resulting string to substitute the word
    ’Hello’ with ’Hi there’.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们首先将 {{name}} 变量替换为字符串 'Angel'。然后，我们在结果字符串上调用 replace 方法，将单词 'Hello'
    替换为 'Hi there'。
- en: 'Note that we can substitute whatever sequence of characters we want using the
    replace method; there’s no need for our replacement targets to appear between
    braces, like for instance we did with {{name}}. Using the double braces is a convention
    for us to quickly identify a variable inside a template. This convention also
    serves the purpose of preventing unwanted replacements: it’s unlikely that our
    templates include anything inside two levels of braces, except for our variables.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们可以使用 replace 方法替换任何我们想要的字符序列；无需让我们的替换目标出现在大括号中，就像我们之前用 {{name}} 那样。使用双大括号是一种约定，用于帮助我们快速识别模板中的变量。这个约定也有助于防止不必要的替换：我们的模板中不太可能包含两个大括号之间的任何内容，除非是我们的变量。
- en: Now that we know how to work with template strings in Python, let’s see how
    we can define templates in separate files and load them into strings in our code.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何在 Python 中使用模板字符串，让我们看看如何在单独的文件中定义模板，并将其加载到代码中的字符串中。
- en: '***Loading Templates***'
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***加载模板***'
- en: 'To avoid mixing XML and Python code, we want to separate the definitions of
    SVG tags into their own files. The files containing the XML need to have placeholders
    where the actual data will be inserted. For example, our circle definition file
    could look something like this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免混合 XML 和 Python 代码，我们希望将 SVG 标签的定义分离到各自的文件中。包含 XML 的文件需要有占位符，以便插入实际数据。例如，我们的圆形定义文件可能如下所示：
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here we’ve put placeholders using double braces. We’ll use code to load this
    definition into a string and replace the placeholders with the actual coordinates
    of the center and the radius of the circle.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们使用了双大括号来放置占位符。我们将使用代码将此定义加载到一个字符串中，并将占位符替换为圆心的实际坐标和半径。
- en: We’ll be creating a few templates, so let’s create a folder named *templates*
    inside the *svg* package by right-clicking the package name and choosing **New**
    ▸ **Directory**. We need a function that reads the templates inside this folder
    by their name and returns their content as a string. In the *svg* package, but
    not in the *templates* folder, create a new file named *read.py* and add the code
    in [Listing 8-4](ch08.xhtml#ch8lis4).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建几个模板，因此让我们在*svg*包内创建一个名为*templates*的文件夹，通过右键单击包名并选择**新建** ▸ **目录**。我们需要一个函数，它可以根据名称读取此文件夹中的模板并将其内容作为字符串返回。在*svg*包中，但不在*templates*文件夹内，创建一个名为*read.py*的新文件，并添加[列表
    8-4](ch08.xhtml#ch8lis4)中的代码。
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 8-4: Reading the content of a template file*'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-4：读取模板文件的内容*'
- en: Let’s break [Listing 8-4](ch08.xhtml#ch8lis4) down. The first thing we do in
    the function is obtain the path inside *templates* where the file lives. We do
    this using the os.path module’s join function. This function computes the path
    by joining the parts passed as arguments and using the correct separator for your
    operating system. For instance, Unix-based operating systems use the / character.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下[列表 8-4](ch08.xhtml#ch8lis4)。函数中首先要做的事情是获取*templates*文件夹内文件的路径。我们通过使用os.path模块的join函数来实现这一点。此函数通过连接作为参数传递的各部分并使用适合操作系统的分隔符来计算路径。例如，基于Unix的操作系统使用/字符。
- en: Then, using resource_string from the *pkg_resources* module, we read the file
    as a *byte string*. A file is stored to disk as a sequence of bytes, so when we
    read it using the resource_string function, we get this byte string. To convert
    it to a Unicode character string, we need to *decode* it. For this, byte strings
    have the method decode, which accepts the encoding as an argument.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用*pkg_resources*模块中的resource_string，我们将文件作为*字节字符串*读取。文件以字节序列存储到磁盘中，因此当我们使用resource_string函数读取它时，得到的是字节字符串。为了将其转换为Unicode字符字符串，我们需要对其进行*解码*。为此，字节字符串具有decode方法，该方法接受编码作为参数。
- en: We return the result of decoding the string of bytes using UTF-8 encoding. This
    will give us a string version of the template we can easily work with.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们返回使用UTF-8编码解码字节字符串的结果。这将给我们一个字符串版本的模板，便于操作。
- en: '***Image Templates***'
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***图像模板***'
- en: The most important template we want to define is the template for the SVG image.
    Create a new text file named *img* (without an extension; we don’t need one) in
    the *templates* folder and include the definition in [Listing 8-5](ch08.xhtml#ch8lis5).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要定义的最重要的模板是SVG图像的模板。在*templates*文件夹中创建一个新的文本文件，命名为*img*（不带扩展名；我们不需要扩展名），并在其中包含[列表
    8-5](ch08.xhtml#ch8lis5)中的定义。
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 8-5: SVG image template*'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-5：SVG 图像模板*'
- en: 'This template includes five placeholders that need to be replaced with the
    actual values from the resulting image. We can try to load the template in Python’s
    shell using the read_template function we defined earlier:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 该模板包括五个占位符，需要用实际的图像值进行替换。我们可以尝试使用之前定义的read_template函数，在Python的shell中加载模板：
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Let’s create a new file *image.py* in the *svg* directory (but outside the *templates*
    folder!) and define a function that reads in the file and does the replacement.
    In your *image.py* file, enter the code in [Listing 8-6](ch08.xhtml#ch8lis6).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在*svg*目录中（但在*templates*文件夹外）创建一个新的文件*image.py*，并定义一个函数，该函数读取文件并进行替换。在你的*image.py*文件中，输入[列表
    8-6](ch08.xhtml#ch8lis6)中的代码。
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 8-6: SVG image*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-6：SVG 图像*'
- en: The svg_content function takes four parameters; the last two, viewbox_rect and
    transform, are given a default value of None. We can use or so that viewbox _rect
    keeps its value if it’s not None and otherwise gets a default instance created
    by __default_viewbox_rect ➊ (we’ll write this function next). We do the same with
    transform ➋, using an affine transformation constructed with the default values.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: svg_content函数有四个参数；最后两个参数viewbox_rect和transform的默认值为None。我们可以使用“或”操作符，这样当viewbox_rect不是None时，它保持其值，否则将由__default_viewbox_rect
    ➊（我们接下来将编写此函数）创建一个默认实例。我们对transform ➋做同样的处理，使用默认值构造一个仿射变换。
- en: Then, using the function we prepared in the previous section, we load the template
    stored in *templates/img* ➌.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用我们在前一节准备的函数，我们加载存储在*templates/img*中的模板 ➌。
- en: The last and most important step is to replace all placeholders in the loaded
    template string with the values we’ve been passed.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个也是最重要的步骤是将加载的模板字符串中的所有占位符替换为我们传入的值。
- en: '**NOTE**'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*One nice property of strings in Python, as in most programming languages,
    is that they’re immutable; you can’t take a string and change a character in it.
    What you do instead is create a new string with the desired change. This is how
    the* replace *string method works: it replaces a given sequence of characters
    with another and returns a new string with the result. Thanks to this nice property,
    we can beautifully chain several* replace *calls to the result of the call to*
    read_template.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*Python 中字符串的一个优点，与大多数编程语言类似，是它们是不可变的；你不能直接修改字符串中的某个字符。相反，你需要创建一个包含所需更改的新字符串。这就是*
    replace *字符串方法的工作原理：它将给定的字符序列替换为另一个序列，并返回一个新的字符串作为结果。得益于这个特性，我们可以漂亮地链式调用多个* replace
    *来处理对* read_template* 方法的结果。*'
- en: The replacements for the {{width}} and {{height}} placeholders are straightforward;
    just keep in mind that the passed-in size.width and size.height properties are
    numbers, so we need to convert them to their string representation using str.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '{{width}} 和 {{height}} 占位符的替换非常直接；只需记住，传入的 size.width 和 size.height 属性是数字，因此我们需要使用
    str 将它们转换为字符串表示。'
- en: The primitives parameter contains a sequence of strings representing the content
    of the image. We need to collect these strings in a single string. The join string
    method joins all the elements in a list together into a single string using the
    string it was called on as a separator. To obtain a string including all the primitives,
    we’ll use join ➍ on the list, with a new line and a tab character (\n\t) as the
    separator.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: primitives 参数包含了一系列字符串，这些字符串代表了图像的内容。我们需要将这些字符串收集到一个单独的字符串中。join 字符串方法将列表中的所有元素连接成一个单一的字符串，并以它被调用时的字符串作为分隔符。为了获取包含所有
    primitives 的字符串，我们将使用 join ➍ 方法对列表进行操作，并以换行符和制表符（\n\t）作为分隔符。
- en: For viewBox we need to convert the Rect instance into the four numbers that
    define it ➎; this is done with __viewbox_from_rect, which we’ll define in a minute.
    The same goes for transf ➏.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 viewBox，我们需要将 Rect 实例转换为定义它的四个数字 ➎；这通过 __viewbox_from_rect 实现，我们稍后将定义它。transf
    ➏ 的处理方式也是如此。
- en: Let’s write the missing helping functions after svg_content. The code is in
    [Listing 8-7](ch08.xhtml#ch8lis7).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 svg_content 后编写缺失的辅助函数。代码见 [列表 8-7](ch08.xhtml#ch8lis7)。
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 8-7: SVG image helper functions*'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-7：SVG 图像辅助函数*'
- en: The first function (__default_viewbox_rect) creates a rectangle for the viewBox
    using the point (0, 0) as the origin and the provided size. This function, as
    its name indicates, is used to provide a default value for the viewbox _rect parameter
    in case it wasn’t given by the user.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数 (__default_viewbox_rect) 使用点 (0, 0) 作为原点和提供的尺寸来创建一个矩形用于 viewBox。正如它的名字所示，这个函数用于提供
    viewbox _rect 参数的默认值，以防用户没有提供。
- en: 'The __viewbox_from_rect function returns a string formatted to be used as viewBox
    inside the SVG definition. The last function, __transf_matrix_vals, does something
    similar: it converts an affine transformation into a string with the format expected
    by SVG.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: __viewbox_from_rect 函数返回一个格式化字符串，可以用作 SVG 定义中的 viewBox。最后一个函数 __transf_matrix_vals
    做的事情类似：它将一个仿射变换转换为 SVG 期望的字符串格式。
- en: Great! We now have a function that renders the SVG template into a string. Let’s
    take a look at some attributes we’ll add to almost all primitives.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒！我们现在有了一个函数，可以将 SVG 模板渲染为一个字符串。接下来，让我们看一下我们将添加到几乎所有图形元素中的一些属性。
- en: '***Attributes***'
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***属性***'
- en: 'The appearance of SVG elements can be modified using *attributes*. SVG attributes
    are defined following the XML attribute syntax (don’t forget that SVG images are
    defined following the XML format):'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 *属性* 来修改 SVG 元素的外观。SVG 属性是按照 XML 属性语法定义的（别忘了 SVG 图像是按照 XML 格式定义的）：
- en: '[PRE18]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'For example, we can use the stroke attribute to set a primitive’s stroke color:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用 stroke 属性来设置图形的描边颜色：
- en: '[PRE19]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note that, in the previous example, the circle’s center coordinates (cx and
    cy) and radius (r) are also defined as attributes in the circle SVG element.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在前面的例子中，圆形的中心坐标（cx 和 cy）以及半径（r）也作为属性定义在圆形的 SVG 元素中。
- en: As we’re about to see, many SVG geometry primitives have shared attributes to
    define things such as the color of their stroke, the stroke’s width, the fill
    color, etc. To reuse this logic, we’ll place it in a file that all primitive generation
    functions will use. As these attribute definitions are short, we won’t include
    them in templates that need to be loaded; instead, we’ll define them inside the
    function that replaces the placeholders.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '正如我们将看到的，许多 SVG 几何基本图形都有共享的属性，用于定义诸如笔触颜色、笔触宽度、填充颜色等。为了重用这部分逻辑，我们将其放在一个所有基本图形生成函数都会使用的文件中。由于这些属性定义较短，我们不会将它们包括在需要加载的模板中；相反，我们将在替换占位符的函数内部定义它们。  '
- en: 'Create a new file named *attributes.py* inside the *svg* directory. Your *graphic/svg*
    folder should look like the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '在 *svg* 目录中创建一个名为 *attributes.py* 的新文件。你的 *graphic/svg* 文件夹应该如下所示：  '
- en: svg
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 'svg  '
- en: '|- templates'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '|- templates  '
- en: '|    |- img'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- img  '
- en: '|- __init__.py'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '|- __init__.py  '
- en: '|- attributes.py'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '|- attributes.py  '
- en: '|- image.py'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '|- image.py  '
- en: '|- read.py'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '|- read.py  '
- en: Enter the functions in [Listing 8-8](ch08.xhtml#ch8lis8).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '输入 [列表 8-8](ch08.xhtml#ch8lis8) 中的函数。  '
- en: '[PRE20]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 8-8: SVG attributes*'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-8：SVG 属性*  '
- en: All the functions are quite straightforward; they receive a value and return
    a string with the definition of an SVG attribute. We use single quotes around
    the returned strings, and this allows us to use double quotes inside without the
    need of escaping them. The SVG attributes are defined using double quotes, like,
    for example, stroke="blue".
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '所有函数都非常简单；它们接收一个值并返回一个包含 SVG 属性定义的字符串。我们使用单引号括起来返回的字符串，这样就可以在字符串中使用双引号，而无需转义它们。SVG
    属性使用双引号定义，例如 stroke="blue"。  '
- en: 'The last function takes some attributes and joins them into a string separating
    them with spaces. We achieve this using a single space (’ ’) as a separator for
    the join function. To fully understand how this works, give this a try in the
    shell:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '最后的函数接受一些属性，并将它们通过空格分隔连接成一个字符串。我们通过使用单个空格（’ ’）作为 join 函数的分隔符来实现这一点。为了完全理解这个如何工作，可以在
    shell 中试一试：  '
- en: '[PRE21]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '**The SVG Primitives**'
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**SVG 基本图形**  '
- en: We’ve written the foundations of our *svg* package; we can now produce empty
    images, a process that involves reading the *img* template and replacing its variables.
    If we called our svg_content function from Python’s shell,
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '我们已经编写了 *svg* 包的基础；现在我们可以生成空白图像，这一过程涉及读取 *img* 模板并替换其变量。如果我们在 Python 的 Shell
    中调用 svg_content 函数，  '
- en: '[PRE22]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'we’d get the following SVG content:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '我们将得到以下 SVG 内容：  '
- en: '[PRE23]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: It’s a great beginning, but who wants blank images?
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '这是一个很好的开始，但谁希望有空白的图像呢？  '
- en: 'In the next sections, we’ll create a couple basic SVG primitives to add between
    the <svg></svg> tags: lines, rectangles, circles, polygons, and text labels, to
    name a few. As we’ll see throughout the book, we don’t need a lot of primitives
    to draw our engineering drawings; we can get pretty far with only straight lines,
    circles, and rectangles.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '在接下来的章节中，我们将创建一些基本的 SVG 基本图形，以便在 <svg></svg> 标签之间添加：线条、矩形、圆形、多边形和文本标签，等等。正如我们在整本书中将看到的那样，我们并不需要很多基本图形来绘制我们的工程图；仅凭直线、圆形和矩形就能做得相当好。  '
- en: 'The strategy we’ll follow to produce these SVG primitives is the same we used
    for the SVG content: we’ll use a template to define the SVG code with variables
    that we’ll replace inside a function.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '我们生成这些 SVG 基本图形的策略与生成 SVG 内容时使用的策略相同：我们将使用一个模板来定义带有变量的 SVG 代码，并在函数中替换这些变量。  '
- en: '***Lines***'
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***线条***  '
- en: 'The first primitive we’ll implement in our *svg* package is the line segment,
    or line in SVG parlance. This may be a little unfortunate, as segments and lines
    are different concepts. (Recall that lines are infinite, but segments are not;
    they have a finite length.) At any rate, we’ll use the SVG terminology here, so
    let’s create a new template file named *line* inside the *templates* folder and
    add the code in [Listing 8-9](ch08.xhtml#ch8lis9):'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '我们将在 *svg* 包中实现的第一个基本图形是线段，或者用 SVG 术语来说是直线。这可能有点不太合适，因为线段和直线是不同的概念。（回想一下，直线是无限的，而线段则不是；它们有有限的长度。）无论如何，我们在这里使用
    SVG 术语，所以我们将在 *templates* 文件夹中创建一个名为 *line* 的新模板文件，并在其中添加 [列表 8-9](ch08.xhtml#ch8lis9)
    中的代码：  '
- en: '[PRE24]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Listing 8-9: Line template*'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-9：线条模板*  '
- en: 'The template for a line is simple. The placeholders define the following:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '线条的模板很简单。占位符定义了以下内容：  '
- en: x1 and y1, the coordinates of the start point
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'x1 和 y1，起点的坐标  '
- en: x2 and y2, the coordinates of the end point
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'x2 和 y2，终点的坐标  '
- en: attrs, where the attributes will be inserted
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: attrs，属性将被插入的位置
- en: '[Figure 8-8](ch08.xhtml#ch8fig8) depicts the line with its attributes using
    the default coordinate system for SVG images.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '[图8-8](ch08.xhtml#ch8fig8)展示了使用SVG图像的默认坐标系统的线条及其属性。'
- en: '![Image](../images/08fig08.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/08fig08.jpg)'
- en: '*Figure 8-8: An example of an SVG line*'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8-8：SVG线条的例子*'
- en: Let’s now create a function that reads the template and inserts the values of
    a segment. We need a new file; let’s create it inside *svg* with the name *primitives.py*.
    Enter the function in [Listing 8-10](ch08.xhtml#ch8lis10).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来创建一个函数，它读取模板并插入一个片段的值。我们需要一个新文件；让我们在*svg*文件夹中创建它，命名为*primitives.py*。输入[清单8-10](ch08.xhtml#ch8lis10)中的函数。
- en: '[PRE25]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 8-10: SVG line*'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单8-10：SVG线*'
- en: 'One thing to note is that the parameter attributes has a default value of (),
    that is, an empty tuple. We could have also used an empty list [] as the default
    for the parameter, but there’s an important difference between those two options:
    tuples are immutable, and lists are mutable. Function default arguments are evaluated
    only once when the file is loaded into the interpreter, so if a mutable default
    parameter is mutated, all subsequent calls to the same function would get the
    mutated value as the default, and that’s something we want to avoid.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一点是，参数属性的默认值是()，也就是一个空元组。我们也可以使用一个空列表[]作为参数的默认值，但这两者之间有一个重要的区别：元组是不可变的，而列表是可变的。函数的默认参数只会在文件加载到解释器时评估一次，因此，如果一个可变的默认参数被修改，那么对同一函数的所有后续调用都会得到修改后的默认值，而这正是我们想避免的。
- en: In the shell, try the code below to create an SVG line in order to see the result
    and make sure that all placeholders are properly replaced.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在shell中，尝试以下代码来创建一个SVG线条，以查看结果并确保所有占位符都已正确替换。
- en: '[PRE26]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This line inside an SVG file would be drawn as in [Figure 8-9](ch08.xhtml#ch8fig9).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这行位于SVG文件中的代码将像[图8-9](ch08.xhtml#ch8fig9)那样绘制。
- en: '![Image](../images/08fig09.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/08fig09.jpg)'
- en: '*Figure 8-9: SVG line*'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8-9：SVG线*'
- en: Bear in mind the arrows and position captions are added in this figure for clarity
    but won’t appear in the image itself.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，图中为了清晰起见添加了箭头和位置说明，但它们不会出现在图片本身中。
- en: '***Rectangles***'
  id: totrans-187
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***矩形***'
- en: 'Our next primitive is the rectangle, so inside *templates* create a new file
    named *rect* (remember, we’re not using any extension in our template files) with
    the definition shown in [Listing 8-11](ch08.xhtml#ch8lis11):'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一个原语是矩形，因此在*templates*中创建一个名为*rect*的新文件（记住，我们的模板文件没有使用扩展名），文件内容如[清单8-11](ch08.xhtml#ch8lis11)所示：
- en: '[PRE27]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 8-11: The rectangle template*'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单8-11：矩形模板*'
- en: You can write the template in a single line; here we used several lines because
    in the print version, the code didn’t fit in just one. The attributes that define
    a rectangle are, as expected, the coordinates of the origin x and y and its size
    given by width and height. In *primitives.py*, add the function in [Listing 8-12](ch08.xhtml#ch8lis12).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将模板写成一行；我们这里使用了多行，因为在印刷版中，代码无法放在一行内。定义矩形的属性是，按照预期，原点的坐标x和y以及由宽度和高度给定的大小。在*primitives.py*中，添加[清单8-12](ch08.xhtml#ch8lis12)中的函数。
- en: '[PRE28]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*Listing 8-12: SVG rectangle*'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单8-12：SVG矩形*'
- en: 'To gain a better understanding of the attributes that define a rectangle in
    the SVG format, take a look at [Figure 8-10](ch08.xhtml#ch8fig10). The figure
    uses the default coordinate system from SVG: the y-axis pointing downward. This
    is why the origin of the rectangle is the upper-left corner. If we were using
    a coordinate system whose y-axis pointed upward, the origin would be the lower-left
    corner.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解定义SVG格式矩形的属性，可以查看[图8-10](ch08.xhtml#ch8fig10)。该图使用了SVG的默认坐标系统：y轴向下。这也是为什么矩形的原点是左上角。如果我们使用的是y轴向上的坐标系统，原点将是左下角。
- en: '![Image](../images/08fig10.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/08fig10.jpg)'
- en: '*Figure 8-10: An example of an SVG rectangle*'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8-10：一个SVG矩形的例子*'
- en: 'Give it a try in the shell, as we did with the segment, to check that all placeholders
    are properly replaced:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在shell中试试，就像我们对片段做的那样，检查所有占位符是否已正确替换：
- en: '[PRE29]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: It’s a good idea to check that everything works as expected, since later in
    the book we’ll be creating lots of diagrams using these simple primitives. Unit
    testing is the best option, much better than testing manually in the shell. If
    you downloaded the code for the book, you’ll see all these primitive rendering
    functions are covered by tests. Try to write them yourself so you get used to
    writing unit tests and then compare them to the ones that I’ve provided you.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 确保一切按预期工作是个好主意，因为在本书后续章节中，我们将使用这些简单的基本图形创建许多图表。单元测试是最佳选择，比在命令行中手动测试要好得多。如果你下载了本书的代码，你会发现所有这些基本图形渲染函数都已覆盖了测试。尝试自己编写测试，这样你可以习惯编写单元测试，然后将它们与我提供的测试进行对比。
- en: '***Circles***'
  id: totrans-200
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***圆形***'
- en: We’ll take a similar approach to rectangles to create circles. Create the template
    in a file named *circle* (see [Listing 8-13](ch08.xhtml#ch8lis13)).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将采用类似于矩形的方式来创建圆形。创建一个名为*circle*的模板文件（请参见[清单 8-13](ch08.xhtml#ch8lis13)）。
- en: '[PRE30]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*Listing 8-13: The circle template*'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-13: 圆形模板*'
- en: Then add the function to render the circle inside *primitives.py* (see [Listing
    8-14](ch08.xhtml#ch8lis14)).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将渲染圆形的函数添加到*primitives.py*中（请参见[清单 8-14](ch08.xhtml#ch8lis14)）。
- en: '[PRE31]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '*Listing 8-14: SVG circle*'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-14: SVG 圆形*'
- en: Nothing unexpected here! You can take a look at [Figure 8-11](ch08.xhtml#ch8fig11)
    to see the attributes we used to define the circle in the SVG format.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么意外的！你可以查看[图 8-11](ch08.xhtml#ch8fig11)，查看我们用来定义 SVG 格式中圆形的属性。
- en: '![Image](../images/08fig11.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/08fig11.jpg)'
- en: '*Figure 8-11: An example of an SVG circle*'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-11: SVG 圆形示例*'
- en: 'Let’s give it a try in the shell:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在命令行中试试：
- en: '[PRE32]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '***Polygons***'
  id: totrans-212
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***多边形***'
- en: Polygons are simple to define; we simply need to provide the list of vertex
    coordinates formatted in a specific way. Create the template file *polygon* in
    *templates* (see [Listing 8-15](ch08.xhtml#ch8lis15)).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 多边形很容易定义；我们只需要提供按特定方式格式化的顶点坐标列表。创建一个名为*polygon*的模板文件，放在*templates*中（请参见[清单 8-15](ch08.xhtml#ch8lis15)）。
- en: '[PRE33]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '*Listing 8-15: The polygon template*'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-15: 多边形模板*'
- en: Then inside *primitives.py* include the function in [Listing 8-16](ch08.xhtml#ch8lis16).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在*primitives.py*中包含[清单 8-16](ch08.xhtml#ch8lis16)中的函数。
- en: '[PRE34]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '*Listing 8-16: SVG polygon*'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-16: SVG 多边形*'
- en: 'The placeholder {{points}} is replaced with the result of applying __format_points
    to the list of vertices. Let’s write that function here, inside the *primitives.py*
    file (see [Listing 8-16](ch08.xhtml#ch8lis16)):'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 占位符{{points}}将被应用__format_points函数处理顶点列表后的结果替换。让我们在*primitives.py*文件中编写这个函数（请参见[清单
    8-16](ch08.xhtml#ch8lis16)）：
- en: '[PRE35]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '*Listing 8-17: Format points*'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-17: 格式化点*'
- en: As you can see, the list of vertices is converted into a string where each vertex
    is separated by a space,
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，顶点列表被转换为一个字符串，其中每个顶点通过空格分隔，
- en: '[PRE36]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'and the two coordinates, x and y, are separated with a comma:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 两个坐标，x 和 y，通过逗号分隔：
- en: '[PRE37]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'For example, a polygon with vertices (1, 2), (5, 6), and (8, 9) would result
    in the following:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个顶点为 (1, 2)，(5, 6) 和 (8, 9) 的多边形将会得到如下结果：
- en: '[PRE38]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '***Polylines***'
  id: totrans-228
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***多边形线***'
- en: '*Polylines* are defined the same way as polygons—the only difference is that
    the last vertex isn’t connected with the first one. Create the template in a file
    named *polyline* in *templates* (see [Listing 8-18](ch08.xhtml#ch8lis18)).'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '*多边形线*的定义与多边形相同，唯一的区别是最后一个顶点未与第一个顶点连接。创建一个名为*polyline*的模板文件，放在*templates*中（请参见[清单
    8-18](ch08.xhtml#ch8lis18)）。'
- en: '[PRE39]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '*Listing 8-18: The polyline template*'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-18: 多边形线模板*'
- en: Include the rendering function inside file *primitives.py* (see [Listing 8-19](ch08.xhtml#ch8lis19)).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 将渲染函数包含在文件*primitives.py*中（请参见[清单 8-19](ch08.xhtml#ch8lis19)）。
- en: '[PRE40]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '*Listing 8-19: SVG polyline*'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-19: SVG 多边形线*'
- en: Again, no surprises here. [Figure 8-12](ch08.xhtml#ch8fig12) shows the difference
    between a polygon and a polyline. The definition for both is the same; the only
    difference is that last segment connecting vertex (*x*[4], *y*[4]) back to (*x*[1],
    *y*[1]) appears only in the case of a polygon.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这里没有什么惊讶的。[图 8-12](ch08.xhtml#ch8fig12)展示了多边形和多边形线之间的区别。它们的定义是相同的，唯一的区别是最后一个连接顶点
    (*x*[4], *y*[4]) 和 (*x*[1], *y*[1]) 的段，只有在多边形中才会出现。
- en: '![Image](../images/08fig12.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/08fig12.jpg)'
- en: '*Figure 8-12: An SVG polygon and polyline*'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-12: 一个 SVG 多边形和多边形线*'
- en: 'Let’s try a polygon and a polyline in the shell to see the results:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在命令行中试试多边形和多边形线，看看结果：
- en: '[PRE41]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Both the polygon and the polyline have the same sequence of points, but in an
    SVG image, the polygon will have a segment connecting the first and last vertices,
    whereas the polyline will remain open.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 多边形和折线有相同的点序列，但在SVG图像中，多边形将连接第一个和最后一个顶点，而折线将保持开放。
- en: '***Text***'
  id: totrans-241
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***文本***'
- en: Our diagrams will contain captions (like the structural analysis result diagrams
    in [Chapter 18](ch18.xhtml#ch18)), so we need to be able to include text in our
    images. Create a new template file named *text* in folder *templates* with the
    code in [Listing 8-20](ch08.xhtml#ch8lis20).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的图表将包含标题（就像[第18章](ch18.xhtml#ch18)中的结构分析结果图表），因此我们需要能够在图像中包含文本。创建一个新的模板文件，命名为*text*，并将其保存在*templates*文件夹中，代码见[列表
    8-20](ch08.xhtml#ch8lis20)。
- en: '[PRE42]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '*Listing 8-20: The text template*'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-20：文本模板*'
- en: The placeholder {{text}} has to be between the open and close tags <text> and
    </text>; this is where the actual text will be inserted. The attributes x and
    y define the position where the text will be located; then dx and dy displace
    that original position. We’ll find this displacement handy when, for instance,
    we want to add the coordinates of a point next to it. We can choose the position
    of the point itself as the base, which we then displace a given amount so that
    the text and the drawing of the point don’t overlap.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 占位符{{text}}必须位于打开和关闭标签<text>和</text>之间；这里将插入实际的文本。属性x和y定义了文本的位置；然后dx和dy用于偏移该原始位置。我们会发现这种偏移在某些情况下非常有用，例如当我们想在文本旁边添加一个点的坐标时。我们可以选择点本身的位置作为基准位置，然后偏移一定的量，这样文本和点的绘制就不会重叠。
- en: 'In *primitives.py* add the function shown in [Listing 8-21](ch08.xhtml#ch8lis21)
    to render text:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在*primitives.py*中添加[列表 8-21](ch08.xhtml#ch8lis21)中显示的函数来渲染文本：
- en: '[PRE43]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '*Listing 8-21: SVG text*'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-21：SVG文本*'
- en: 'Let’s give it a try in the shell:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在Shell中试试：
- en: '[PRE44]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'If we format the result string, the result is as follows:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们格式化结果字符串，结果如下所示：
- en: '[PRE45]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '***Groups***'
  id: totrans-253
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***分组***'
- en: Oftentimes we want to group a bunch of elements so we can add a common attribute
    to all of them, such as an affine transformation or fill color. This is what groups
    are for. They’re nothing to be rendered by themselves, but they group a bunch
    of primitives in a neat way. Create the file *group* inside the *templates* folder
    (see [Listing 8-22](ch08.xhtml#ch8lis22)).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常希望将一组元素分组，以便可以为它们所有的元素添加一个共同的属性，比如仿射变换或填充颜色。这就是分组的用途。它们本身没有什么可渲染的内容，但它们以整洁的方式将一组原始元素分组在一起。在*templates*文件夹中创建一个*group*文件（见[列表
    8-22](ch08.xhtml#ch8lis22)）。
- en: '[PRE46]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '*Listing 8-22: The group template*'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-22：分组模板*'
- en: To render the group, we’ll add the function shown in [Listing 8-23](ch08.xhtml#ch8lis23)
    to file *primitives.py*.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 为了渲染该分组，我们将在*primitives.py*文件中添加[列表 8-23](ch08.xhtml#ch8lis23)中显示的函数。
- en: '[PRE47]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '*Listing 8-23: SVG group*'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-23：SVG分组*'
- en: This time, all primitives passed as a sequence are joined into a string separated
    by line breaks (\n). This is so that each primitive is inserted in a new line,
    which will make the file easier to read.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，所有作为序列传递的原始元素将被连接成一个由换行符（\n）分隔的字符串。这样做是为了让每个原始元素都被插入到新的一行中，这将使文件更易于阅读。
- en: '***Arrows***'
  id: totrans-261
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***箭头***'
- en: 'In this section, we’re going to add a different primitive, one that’s built
    not by loading and rendering a template but by using other primitives: an arrow.
    In [Chapter 18](ch18.xhtml#ch18), when we draw structure diagrams, we’ll use arrows
    to represent forces, so this is a good moment to implement them.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将添加一个不同的原始元素，它不是通过加载和渲染模板来构建的，而是通过使用其他原始元素来创建：箭头。在[第18章](ch18.xhtml#ch18)中，当我们绘制结构图时，我们将使用箭头来表示力，因此现在正是实现箭头的好时机。
- en: The arrow consists of a line segment with a small triangle at one of its ends,
    the arrow’s head (see [Figure 8-13](ch08.xhtml#ch8fig13)).
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头由一条线段和一个位于其一端的小三角形构成，即箭头的头部（见[图 8-13](ch08.xhtml#ch8fig13)）。
- en: '![Image](../images/08fig13.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/08fig13.jpg)'
- en: '*Figure 8-13: An SVG arrow*'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-13：SVG箭头*'
- en: 'Drawing the arrow’s segment is simple: we just need a line segment. Drawing
    the head is a bit more involved, because it needs to always be aligned with the
    segment. Using a bit of elementary geometry we can figure out the points that
    define the arrow’s head. Take a look at [Figure 8-14](ch08.xhtml#ch8fig14).'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制箭头的线段非常简单：我们只需要一个线段。绘制箭头头部稍微复杂一些，因为它需要始终与线段对齐。通过一点基本几何知识，我们可以找出定义箭头头部的点。请查看[图
    8-14](ch08.xhtml#ch8fig14)。
- en: '![Image](../images/08fig14.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/08fig14.jpg)'
- en: '*Figure 8-14: Key points in an arrow*'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-14：箭头中的关键点*'
- en: Our arrow’s head is a triangle defined between points *C*[1], *E* (the segment’s
    end point), and *C*[2]. The size of the arrow is given by a length and a height,
    sizes that we’ll use to locate the *C*[1] and *C*[2] points.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的箭头头部是由点*C*[1]、*E*（线段的终点）和*C*[2]定义的一个三角形。箭头的大小由长度和高度决定，我们将使用这些尺寸来定位*C*[1]和*C*[2]点。
- en: The figure uses three vectors to position these two points.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 该图使用三个向量来定位这两点。
- en: '![Image](../images/vlvictorit.jpg)    This is a vector in the direction opposite
    to the segment’s direction vector and is the same length as the arrow.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/vlvictorit.jpg)    这是一个与线段方向向量相反方向的向量，长度与箭头相同。'
- en: '![Image](../images/vh1victorit.jpg)    This is a vector perpendicular to the
    segment, and the length is half the arrow’s head height.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/vh1victorit.jpg)    这是一个垂直于线段的向量，长度是箭头头部高度的一半。'
- en: '![Image](../images/vh2victorit.jpg)    This is similar to ![Image](../images/vh1victorit.jpg),
    but in the opposite direction.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/vh2victorit.jpg)    这与![Image](../images/vh1victorit.jpg)类似，但方向相反。'
- en: 'Using these vectors, we can now compute the points as follows:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些向量，我们现在可以按如下方式计算这些点：
- en: '![Image](../images/f00227-p1.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f00227-p1.jpg)'
- en: and
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: '![Image](../images/f00227-p2.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f00227-p2.jpg)'
- en: Without further ado, let’s write the code to draw arrows. Inside *primitives.py*,
    enter the code in [Listing 8-24](ch08.xhtml#ch8lis24).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 毫不拖延，让我们编写绘制箭头的代码。在*primitives.py*中，输入[列表 8-24](ch08.xhtml#ch8lis24)中的代码。
- en: '[PRE48]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '*Listing 8-24: SVG arrow*'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-24：SVG 箭头*'
- en: We’ve defined the arrow function that accepts as parameters a segment, the length
    and height of the arrow, and the SVG attributes. Note that the _segment parameter
    starts with an underscore. This is to avoid a clash with the file’s segment function.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了箭头函数，该函数接受线段、箭头的长度和高度以及SVG属性作为参数。请注意，_segment 参数以一个下划线开头，这是为了避免与文件中的segment函数发生冲突。
- en: In this function we first store the segment’s director vector in the variable
    director. We then compute the ![Image](../images/vlvictorit.jpg) vector taking
    director’s opposite vector scaled to the passed-in length ➊. The ![Image](../images/vh1victorit.jpg)
    vector is obtained by taking director’s perpendicular vector scaled to the arrow’s
    half-height ➋. Then, ![Image](../images/vh2victorit.jpg) is simply the opposite
    of it ➌.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们首先将线段的方向向量存储在变量director中。然后，我们通过将director的相反向量按传入的长度➊进行缩放来计算![Image](../images/vlvictorit.jpg)向量。![Image](../images/vh1victorit.jpg)向量通过将director的垂直向量按箭头的半高度➋进行缩放得到。然后，![Image](../images/vh2victorit.jpg)就是它的相反向量➌。
- en: The function returns an SVG group including the arrow’s segment ➍ and a polyline
    ➎. This polyline defines the arrow’s head using the three points we discussed
    earlier.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数返回一个SVG组，包含箭头的线段➍和一个折线➎。这条折线使用我们之前讨论的三个点来定义箭头的头部。
- en: The first point, *C*[1], is computed by displacing the segment’s end point by
    the result of adding vectors ![Image](../images/vlvictorit.jpg) and ![Image](../images/vh1victorit.jpg).
    Then comes the segment’s end point. Lastly comes *C*[2], resulting from the displacement
    of the segment’s end point by a vector that’s the result of adding ![Image](../images/vlvictorit.jpg)
    and ![Image](../images/vh2victorit.jpg).
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个点*C*[1]是通过将线段的终点平移到向量![Image](../images/vlvictorit.jpg)和![Image](../images/vh1victorit.jpg)相加的结果来计算的。接下来是线段的终点。最后是*C*[2]，它是通过将线段的终点平移到一个向量，该向量是将![Image](../images/vlvictorit.jpg)和![Image](../images/vh2victorit.jpg)相加的结果。
- en: '**Primitives Result**'
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**原始结果**'
- en: We’ve added a few functions to our *primitives.py* file. If you followed along,
    your file should look similar to [Listing 8-25](ch08.xhtml#ch8lis25).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向我们的*primitives.py*文件中添加了一些函数。如果你跟着做，你的文件应该和[列表 8-25](ch08.xhtml#ch8lis25)类似。
- en: '[PRE49]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '*Listing 8-25: SVG primitives result*'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-25：SVG 原始结果*'
- en: We have everything we need to start drawing images. In the next chapter, we’ll
    use our *svg* package to plot the result of a geometrical problem. But first,
    let’s provide a convenient way of importing the contents of this package.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好开始绘制图像了。在下一章中，我们将使用我们的*svg*包绘制几何问题的结果。但首先，让我们提供一个方便的方式来导入该包的内容。
- en: '**Package Imports**'
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**包导入**'
- en: 'Similar to what we did with the *geom2d* package, we want to give the option
    of importing everything from *svg* with a single import line:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在*geom2d*包中所做的类似，我们希望提供一个选项，通过一行导入语句将*svg*包中的所有内容导入：
- en: '[PRE50]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The only thing we have to do is import all relevant modules inside the *svg*
    package’s *__init__.py* file file:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的唯一事情是将所有相关模块导入到*svg*包的*__init__.py*文件中：
- en: '[PRE51]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '**Summary**'
  id: totrans-295
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: Graphics are key to engineering applications. Many involve creating diagrams
    made of simple geometric primitives such as segments and rectangles. We created
    a geometry package in [Part II](part02.xhtml#part02) of this book; in this chapter,
    we learned how to turn those primitives into vector images.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 图形在工程应用中至关重要。许多应用涉及创建由简单几何原语（如线段和矩形）构成的图表。我们在本书的[第二部分](part02.xhtml#part02)中创建了一个几何包；在本章中，我们学习了如何将这些原语转换为矢量图像。
- en: We started with a quick introduction to the SVG format and saw how easy it is
    to create SVG images using just a few lines of XML data. We then learned about
    templates, extensionless plaintext files that define the SVG structure using placeholders.
    The placeholders, which have the form of {{name}}, are replaced by concrete data
    using code. Templates are widely used, and there are some complex packages for
    rendering templates. Our use case was pretty simple, so we did the replacement
    using the replace method from Python strings.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先简要介绍了SVG格式，并展示了如何通过几行XML数据轻松创建SVG图像。接着，我们了解了模板，这是一种无扩展名的纯文本文件，通过占位符定义SVG结构。占位符的形式是{{name}}，它们会通过代码替换为具体的数据。模板被广泛使用，并且有一些复杂的包用于渲染模板。我们的使用案例相对简单，因此我们使用Python字符串的`replace`方法进行了替换。
- en: 'Lastly, we created functions to obtain the SVG representation for our geometric
    primitives: line segments, circles, rectangles, and polygons. From now on, creating
    vector diagrams should be straightforward, something that we’ll prove in the next
    chapter.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建了函数，以获取几何原语的SVG表示：线段、圆形、矩形和多边形。从现在开始，创建矢量图应该是直接的，我们将在下一章中证明这一点。
