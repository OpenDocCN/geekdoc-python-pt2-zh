- en: '**1**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**1**'
- en: '**Working with Numbers**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**与数字打交道**'
- en: '![image](images/common-01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/common-01.jpg)'
- en: Let’s take our first steps toward using Python to explore the world of math
    and science. We’ll keep it simple now so you can get a handle on using Python
    itself. We’ll start by performing basic mathematical operations, and then we’ll
    write simple programs for manipulating and understanding numbers. Let’s get started!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们迈出使用 Python 探索数学和科学世界的第一步。现在我们保持简单，帮助你掌握如何使用 Python 本身。我们将从执行基本的数学运算开始，然后编写简单的程序来操作和理解数字。让我们开始吧！
- en: '**Basic Mathematical Operations**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**基本数学运算**'
- en: The *Python interactive shell* is going to be our friend in this book. Start
    the Python 3 IDLE shell and say “hello” (see [Figure 1-1](ch01.html#ch1fig1))
    by typing `print('Hello IDLE')` and then pressing ENTER. (For instructions on
    how to install Python and start IDLE, see [Appendix A](app01.html#app01).) IDLE
    obeys your command and prints the words back to the screen. Congratulations—you
    just wrote a program!
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*Python 交互式 shell* 将成为我们在本书中的好朋友。启动 Python 3 IDLE shell 并打个“招呼”（见 [图 1-1](ch01.html#ch1fig1)），通过输入
    `print(''Hello IDLE'')` 然后按 ENTER。 （有关如何安装 Python 和启动 IDLE 的说明，请参见 [附录 A](app01.html#app01)）。IDLE
    会执行你的命令并将文字打印回屏幕。恭喜——你刚刚编写了一个程序！'
- en: When you see the `>>>` prompt again, IDLE is ready for more instructions.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当你再次看到 `>>>` 提示符时，IDLE 准备好接受更多指令。
- en: '![image](images/f01-01.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f01-01.jpg)'
- en: '*Figure 1-1: Python 3 IDLE shell*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-1：Python 3 IDLE shell*'
- en: Python can act like a glorified calculator, doing simple computations. Just
    type an expression and Python will evaluate it. After you press ENTER, the result
    appears immediately.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Python 可以像一个高级计算器一样进行简单的计算。只需输入表达式，Python 就会评估它。按下 ENTER 后，结果会立即显示。
- en: 'Give it a try. You can add and subtract numbers using the addition (`+`) and
    subtraction (`–`) operators. For example:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 试试吧。你可以使用加法（`+`）和减法（`–`）运算符来进行加减法运算。例如：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To multiply, use the multiplication (`*`) operator:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行乘法运算，使用乘法（`*`）运算符：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To divide, use the division (`/`) operator:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行除法运算，使用除法（`/`）运算符：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As you can see, when you ask Python to perform a division operation, it returns
    the fractional part of the number as well. If you want the result in the form
    of an integer, with any decimal values removed, you should use the floor division
    (`//`) operator:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，当你让 Python 执行除法运算时，它还会返回数字的小数部分。如果你希望结果是整数形式，并去掉任何小数值，你应该使用 floor 除法（`//`）运算符：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The floor division operator divides the first number by the second number and
    then rounds down the result to the next lowest integer. This becomes interesting
    when one of the numbers is negative. For example:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: floor 除法运算符将第一个数字除以第二个数字，然后将结果向下舍入到下一个最小整数。当其中一个数字为负时，这个操作会变得有趣。例如：
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The final result is the integer lower than the result of the division operation
    (`-3/2 = -1.5`, so the final result is `-2`).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果是除法操作结果的下一个整数（`-3/2 = -1.5`，因此最终结果为 `-2`）。
- en: 'On the other hand, if you want just the remainder, you should use the modulo
    (`%`) operator:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果你只需要余数，应该使用模运算符（`%`）：
- en: '[PRE5]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can calculate the power of numbers using the exponential (`**`) operator.
    The examples below illustrate this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用指数（`**`）运算符计算数字的幂。以下示例演示了这一点：
- en: '[PRE6]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can also use the exponential symbol to calculate powers less than 1\. For
    example, the square root of a number *n* can be expressed as *n*^(1/2) and the
    cube root as *n*^(1/3):'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用指数符号来计算小于 1 的幂。例如，数字 *n* 的平方根可以表示为 *n*^(1/2)，立方根可以表示为 *n*^(1/3)：
- en: '[PRE7]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As this example shows, you can use parentheses to combine mathematical operations
    into more complicated expressions. Python will evaluate the expression following
    the standard *PEMDAS* rule for the order of calculations—parentheses, exponents,
    multiplication, division, addition, and subtraction. Consider the following two
    expressions—one without parentheses and one with:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 正如这个例子所示，你可以使用括号将数学运算结合成更复杂的表达式。Python 将按照标准的 *PEMDAS* 规则来评估表达式的计算顺序——括号、指数、乘法、除法、加法和减法。考虑以下两个表达式——一个没有括号，一个有括号：
- en: '[PRE8]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the first example, Python calculates the multiplication first: 5 times 5
    is 25; 25 plus 5 is 30\. In the second example, the expression within the parentheses
    is evaluated first, just as we’d expect: 5 plus 5 is 10; 10 times 5 is 50.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，Python 先进行乘法运算：5 乘以 5 得 25；25 加 5 得 30。在第二个例子中，括号内的表达式首先被评估，正如我们所期望的那样：5
    加 5 得 10；10 乘以 5 得 50。
- en: These are the absolute basics of manipulating numbers in Python. Let’s now learn
    how we can assign names to numbers.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是在 Python 中操作数字的基本知识。现在让我们学习如何将数字赋予名称。
- en: '**Labels: Attaching Names to Numbers**'
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**标签：为数字附加名称**'
- en: 'As we start designing more complex Python programs, we’ll assign names to numbers—at
    times for convenience, but mostly out of necessity. Here’s a simple example:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们开始设计更复杂的 Python 程序，我们会给数字赋予名称——有时是为了方便，但大多数时候是出于必要性。这里有一个简单的例子：
- en: '[PRE9]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: At ➊, we assign the name `a` to the number 3\. When we ask Python to evaluate
    the result of the expression `a + 1`, it sees that the number that `a` refers
    to is 3, and then it adds 1 and displays the output (4). At ➋, we change the value
    of `a` to 5, and this is reflected in the second addition operation. Using the
    name `a` is convenient because you can simply change the number that `a` points
    to and Python uses this new value when `a` is referred to anywhere after that.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊，我们将名称 `a` 赋给数字 3。当我们让 Python 计算表达式 `a + 1` 的结果时，它看到 `a` 所代表的数字是 3，然后它加上
    1 并显示结果（4）。在 ➋，我们将 `a` 的值改为 5，这个变化反映在第二次加法操作中。使用名称 `a` 很方便，因为你可以简单地改变 `a` 所指向的数字，之后每次引用
    `a` 时，Python 都会使用这个新的值。
- en: This kind of name is called a *label*. You may have been introduced to the term
    *variable* to describe the same idea elsewhere. However, considering that *variable*
    is also a mathematical term (used to refer to something like *x* in the equation
    *x* + 2 = 3), in this book I use the term *variable* only in the context of mathematical
    equations and expressions.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这种名称被称为*标签*。你可能在其他地方接触过术语 *变量* 来描述相同的概念。然而，考虑到 *变量* 也是一个数学术语（用于表示像 *x* 这样的东西，比如在方程
    *x* + 2 = 3 中），在本书中我仅在数学方程和表达式的上下文中使用术语 *变量*。
- en: '**Different Kinds of Numbers**'
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**不同种类的数字**'
- en: You may have noticed that I’ve used two kinds of numbers to demonstrate the
    mathematical operations—numbers without a decimal point, which you already know
    as *integers*, and numbers with a decimal point, which programmers call *floating
    point numbers*. We humans have no trouble recognizing and working with numbers
    whether they’re written as integers, floating point decimals, fractions, or roman
    numerals. But in some of the programs that we write in this book, it will only
    make sense to perform a task on a particular type of number, so we’ll often have
    to write a bit of code to have the programs check whether the numbers we input
    are of the right type.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到，我用两种不同的数字来演示数学运算——没有小数点的数字，你已经知道是*整数*，以及带有小数点的数字，程序员称之为*浮点数*。我们人类在识别和处理数字时，无论它们是以整数、浮点小数、分数还是罗马数字形式出现，都不会遇到问题。但在我们在本书中编写的一些程序中，只对某种特定类型的数字执行任务才有意义，因此我们通常需要编写一些代码，检查我们输入的数字是否属于正确的类型。
- en: 'Python considers integers and floating point numbers to be different *types*.
    If you use the function `type()`, Python will tell you what kind of number you’ve
    just input. For example:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Python 将整数和浮点数视为不同的*类型*。如果你使用 `type()` 函数，Python 会告诉你你输入的数字是哪种类型。例如：
- en: '[PRE10]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, you can see that Python classifies the number 3 as an integer (type `'int'`)
    but classifies 3.0 as a floating point number (type `'float'`). We all know that
    3 and 3.0 are mathematically equivalent, but in many situations, Python will treat
    these two numbers differently because they are two different types.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到 Python 将数字 3 分类为整数（类型 `'int'`），而将 3.0 分类为浮点数（类型 `'float'`）。我们都知道 3
    和 3.0 在数学上是等价的，但在许多情况下，Python 会将这两个数字视为不同的类型。
- en: 'Some of the programs we write in this chapter will work properly only with
    an integer as an input. As we just saw, Python won’t recognize a number like 1.0
    or 4.0 as an integer, so if we want to accept numbers like that as valid input
    in these programs, we’ll have to convert them from floating point numbers to integers.
    Luckily, there’s a function built in to Python that does just that:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们编写的一些程序只有在输入为整数时才能正确工作。正如我们刚才看到的，Python 不会将像 1.0 或 4.0 这样的数字识别为整数，所以如果我们想让这些数字在程序中作为有效输入，我们需要将它们从浮点数转换为整数。幸运的是，Python
    中有一个内置函数可以完成这项转换：
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The function `int()` takes the input floating point number, gets rid of anything
    that comes after the decimal point, and returns the resulting integer. The `float()`
    function works similarly to perform the reverse conversion:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `int()` 接受输入的浮点数字，去掉小数点后的部分，并返回结果整数。`float()` 函数类似，用于执行反向转换：
- en: '[PRE12]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`float()` takes the integer that was input and adds a decimal point to turn
    it into a floating point number.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`float()` 函数接收输入的整数，并在其后添加小数点，将其转换为浮动点数。'
- en: '***Working with Fractions***'
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***分数操作***'
- en: Python can also handle fractions, but to do that, we’ll need to use Python’s
    `fractions` module. You can think of a *module* as a program written by someone
    else that you can use in your own programs. A module can include classes, functions,
    and even label definitions. It can be part of Python’s standard library or distributed
    from a third-party location. In the latter case, you would have to install the
    module before you could use it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Python 也可以处理分数，但为了实现这一点，我们需要使用 Python 的 `fractions` 模块。你可以将*模块*视为他人编写的程序，你可以在自己的程序中使用。一个模块可以包含类、函数，甚至是标签定义。它可以是
    Python 的标准库的一部分，或者来自第三方的位置。在后一种情况下，你需要在使用之前先安装该模块。
- en: 'The `fractions` module is part of the standard library, meaning that it’s already
    installed. It defines a class `Fraction`, which is what we’ll use to enter fractions
    into our programs. Before we can use it, we’ll need to *import* it, which is a
    way of telling Python that we want to use the class from this module. Let’s see
    a quick example—we’ll create a new label, `f`, which refers to the fraction 3/4:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`fractions` 模块是标准库的一部分，这意味着它已经安装好了。它定义了一个 `Fraction` 类，我们将使用这个类将分数输入到程序中。在使用之前，我们需要先*导入*它，这是一种告诉
    Python 我们希望使用该模块中类的方法。让我们看一个简单的例子——我们将创建一个新标签 `f`，它表示分数 3/4：'
- en: '[PRE13]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We first import the `Fraction` class from the `fractions` module ➊. Next, we
    create an object of this class by passing the numerator and denominator as parameters
    ➋. This creates a `Fraction` object for the fraction 3/4\. When we print the object
    ➌, Python displays the fraction in the form `Fraction(numerator`, denominator).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先从 `fractions` 模块导入 `Fraction` 类 ➊。接下来，我们通过传入分子和分母作为参数来创建该类的一个对象 ➋。这将创建一个表示分数
    3/4 的 `Fraction` 对象。当我们打印该对象 ➌ 时，Python 会以 `Fraction(numerator, denominator)`
    的形式显示该分数。
- en: 'The basic mathematical operations, including the comparison operations, are
    all valid for fractions. You can also combine a fraction, an integer, and a floating
    point number in a single expression:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的数学运算，包括比较运算，对于分数都是有效的。你还可以将分数、整数和浮动点数结合在一个表达式中：
- en: '[PRE14]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When you have a floating point number in an expression, the result of the expression
    is returned as a floating point number.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当表达式中包含浮动点数时，表达式的结果将返回浮动点数。
- en: On the other hand, when you have only a fraction and an integer in the expression,
    the result is a fraction, even if the result has a denominator of 1.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当表达式中只有分数和整数时，结果将是分数，即使结果的分母为 1。
- en: '[PRE15]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now you know the basics of working with fractions in Python. Let’s move on to
    a different kind of number.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了在 Python 中使用分数的基本知识。接下来我们将介绍另一种数字类型。
- en: '***Complex Numbers***'
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***复数***'
- en: 'The numbers we’ve seen so far are the so-called *real numbers*. Python also
    supports *complex numbers* with the imaginary part identified by the letter *j*
    or *J* (as opposed to the letter *i* used in mathematical notation). For example,
    the complex number 2 + 3*i* would be written in Python as 2 + 3*j*:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们看到的数字是所谓的*实数*。Python 还支持*复数*，其虚部用字母 *j* 或 *J* 表示（而不是数学符号中使用的字母 *i*）。例如，复数
    2 + 3*i* 在 Python 中将写作 2 + 3*j*：
- en: '[PRE16]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, when we use the `type()` function on a complex number, Python
    tells us that this is an object of type `complex`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，当我们在复数上使用 `type()` 函数时，Python 会告诉我们这是一个 `complex` 类型的对象。
- en: 'You can also define complex numbers using the `complex()` function:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 `complex()` 函数来定义复数：
- en: '[PRE17]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here we pass the real and imaginary parts of the complex number as two arguments
    to the `complex()` function, and it returns a complex number.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将复数的实部和虚部分别作为两个参数传递给 `complex()` 函数，它会返回一个复数。
- en: 'You can add and subtract complex numbers in the same way as real numbers:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像处理实数一样处理复数的加法和减法：
- en: '[PRE18]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Multiplication and division of complex numbers are also carried out similarly:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 复数的乘法和除法也采用类似的方式进行：
- en: '[PRE19]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The modulus (`%`) and the floor division (`//`) operations are not valid for
    complex numbers.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 模运算符（`%`）和地板除法（`//`）运算符对复数无效。
- en: 'The real and imaginary parts of a complex number can be retrieved using its
    `real` and `imag` attributes, as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 复数的实部和虚部可以通过其 `real` 和 `imag` 属性来获取，如下所示：
- en: '[PRE20]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The *conjugate* of a complex number has the same real part but an imaginary
    part with an equal magnitude and an opposite sign. It can be obtained using the
    `conjugate()` method:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 复数的*共轭*具有相同的实部，但虚部的大小相同并且符号相反。它可以通过`conjugate()`方法获得：
- en: '[PRE21]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Both the real and imaginary parts are floating point numbers. Using the real
    and imaginary parts, you can then calculate the *magnitude* of a complex number
    with the following formula, where *x* and *y* are the real and imaginary parts
    of the number, respectively: ![image](images/e0007-01.jpg). In Python, this would
    look like the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 实部和虚部都是浮点数。使用实部和虚部，你可以使用以下公式计算复数的*大小*，其中*x*和*y*分别是复数的实部和虚部：![image](images/e0007-01.jpg)。在Python中，这样写：
- en: '[PRE22]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'A simpler way to find the magnitude of a complex number is with the `abs()`
    function. The `abs()` function returns the absolute value when called with a real
    number as its argument. For example, `abs(5)` and `abs(-5)` both return 5\. However,
    for complex numbers, it returns the magnitude:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 找到复数的大小的一种更简单的方法是使用`abs()`函数。`abs()`函数在传入实数时返回绝对值。例如，`abs(5)`和`abs(-5)`都返回5。然而，对于复数，它返回的是复数的大小：
- en: '[PRE23]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The standard library’s `cmath` module (`cmath` for *complex math*) provides
    access to a number of other specialized functions to work with complex numbers.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库的`cmath`模块（`cmath`代表*复数数学*）提供了许多其他专门的函数，用于处理复数。
- en: '**Getting User Input**'
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**获取用户输入**'
- en: 'As we start to write programs, it will help to have a nice, simple way to accept
    user input via the `input()` function. That way, we can write programs that ask
    a user to input a number, perform specific operations on that number, and then
    display the results of the operations. Let’s see it in action:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始编写程序时，拥有一个简单的方式通过`input()`函数接受用户输入会非常有帮助。这样，我们可以编写要求用户输入数字、对数字执行特定操作并显示操作结果的程序。让我们看看它的实际应用：
- en: '[PRE24]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'At ➊, we call the `input()` function, which waits for you to type something,
    as shown at ➋, and press ENTER. The input provided is stored in `a`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们调用了`input()`函数，它会等待你输入内容，如➋所示，按下ENTER键。输入的内容会存储在`a`中：
- en: '[PRE25]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Notice the single quotes around 1 at ➌. The `input()` function returns the
    input as a *string*. In Python, a string is any set of characters between two
    quotes. When you want to create a string, either single quotes or double quotes
    can be used:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在➌处1周围的单引号。`input()`函数返回的输入是一个*字符串*。在Python中，字符串是任何位于两个引号之间的字符集合。当你想创建一个字符串时，可以使用单引号或双引号：
- en: '[PRE26]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, both `s1` and `s2` refer to the same string.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`s1`和`s2`都指向相同的字符串。
- en: 'Even if the only characters in a string are numbers, Python won’t treat that
    string as a number unless we get rid of those quotation marks. So before we can
    perform any mathematical operations with the input, we’ll have to convert it into
    the correct number type. A string can be converted to an integer or floating point
    number using the `int()` or `float()` function, respectively:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 即使字符串中的唯一字符是数字，Python也不会将该字符串视为数字，除非我们去除这些引号。因此，在进行任何数学运算之前，我们需要将其转换为正确的数字类型。字符串可以分别通过`int()`或`float()`函数转换为整数或浮点数：
- en: '[PRE27]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'These are the same `int()` and `float()` functions we saw earlier, but this
    time instead of converting the input from one kind of number to another, they
    take a string as input (`''1''`) and return a number (`2` or `2.0`). It’s important
    to note, however, that the `int()` function cannot convert a string containing
    a floating point decimal into an integer. If you take a string that has a floating
    point number (like `''2.5''` or even `''2.0''`) and input that string into the
    `int()` function, you’ll get an error message:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们之前看到的相同的`int()`和`float()`函数，但这次它们不是将输入从一种数字类型转换为另一种，而是将一个字符串作为输入（如`'1'`）并返回一个数字（`2`或`2.0`）。然而，需要注意的是，`int()`函数不能将包含浮点小数的字符串转换为整数。如果你将一个包含浮点数的字符串（如`'2.5'`甚至`'2.0'`）传递给`int()`函数，它会返回一个错误信息：
- en: '[PRE28]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This is an example of an *exception*—Python’s way of telling you that it cannot
    continue executing your program because of an error. In this case, the exception
    is of the type `ValueError`. (For a quick refresher on exceptions, see [Appendix
    B](app02.html#app02).)
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个*异常*的例子——Python用来告诉你，由于错误它无法继续执行程序。在这种情况下，异常的类型是`ValueError`。（有关异常的快速复习，请参见[附录B](app02.html#app02)）
- en: 'Similarly, when you supply a fractional number such as 3/4 as an input, Python
    cannot convert it into an equivalent floating point number or integer. Once again,
    a `ValueError` exception is raised:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，当你输入像 3/4 这样的分数时，Python 无法将其转换为等效的浮点数或整数。再次出现 `ValueError` 异常：
- en: '[PRE29]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You may find it useful to perform the conversion in a `try...except` block so
    that you can *handle* this exception and alert the user that the program has encountered
    an invalid input. We’ll look at `try...except` blocks next.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会发现将转换操作放在 `try...except` 块中很有用，这样你就可以*处理*这个异常，并提醒用户程序遇到了无效输入。接下来，我们将讨论 `try...except`
    块。
- en: '***Handling Exceptions and Invalid Input***'
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***处理异常和无效输入***'
- en: 'If you’re not familiar with `try...except`, the basic idea is this: if you
    execute one or more statements in a `try...except` block and there’s an error
    while executing, your program will not crash and print a `Traceback`. Instead,
    the execution is transferred to the `except` block, where you can perform an appropriate
    operation, for instance, printing a helpful error message or trying something
    else.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不熟悉 `try...except`，其基本思想是这样的：如果你在 `try...except` 块中执行一个或多个语句，并且执行时发生了错误，程序不会崩溃并打印出
    `Traceback`。相反，执行会转移到 `except` 块，在这里你可以执行适当的操作，例如打印一条有帮助的错误信息或尝试其他方法。
- en: 'This is how you would perform the above conversion in a `try...except` block
    and print a helpful error message on invalid input:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何在 `try...except` 块中执行上述转换并在输入无效时打印有帮助的错误信息：
- en: '[PRE30]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note that we need to specify the type of exception we want to handle. Here,
    we want to handle the `ValueError` exception, so we specify it as `except ValueError`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们需要指定要处理的异常类型。在这里，我们要处理 `ValueError` 异常，所以我们指定为 `except ValueError`。
- en: 'Now, when you give an invalid input, such as 3/4, it prints a helpful error
    message, as shown at ➊:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你输入无效的内容时，例如 3/4，它会打印出一个有帮助的错误信息，如 ➊ 所示：
- en: '[PRE31]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You can also specify a prompt with the `input()` function to tell the user
    what kind of input is expected. For example:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在 `input()` 函数中指定一个提示信息，告诉用户期望的输入类型。例如：
- en: '[PRE32]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The user will now see the message hinting to enter an integer as input:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 用户现在会看到提示信息，提示输入一个整数：
- en: '[PRE33]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In many programs in this book, we’ll ask the user to enter a number as input,
    so we’ll have to make sure we take care of conversion before we attempt to perform
    any operations on these numbers. You can combine the input and conversion in a
    single statement, as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的许多程序中，我们会要求用户输入一个数字，因此我们必须确保在执行任何操作之前处理好转换。你可以将输入和转换结合在一条语句中，如下所示：
- en: '[PRE34]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This works great if the user inputs an integer. But as we saw earlier, if the
    input is a floating point number (even one that’s equivalent to an integer, like
    1.0), this will produce an error:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户输入的是整数，这个方法运行得非常好。但正如我们之前看到的，如果输入的是浮点数（即使是与整数等价的数字，比如 1.0），这会导致错误：
- en: '[PRE35]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In order to avoid this error, we could set up a `ValueError` catch like the
    one we saw earlier for fractions. That way the program would catch floating point
    numbers, which won’t work in a program meant for integers. However, it would also
    flag numbers like 1.0 and 2.0, which Python *sees* as floating point numbers but
    that are equivalent to integers and would work just fine if they were entered
    as the right Python type.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这个错误，我们可以像之前处理分数那样设置一个 `ValueError` 捕获机制。这样，程序就会捕获浮点数，这在处理整数的程序中是不可行的。然而，它也会标记像
    1.0 和 2.0 这样的数字，虽然 Python *视为* 浮点数，但它们等价于整数，如果按正确的 Python 类型输入，它们完全能正常工作。
- en: To get around all this, we will use the `is_integer()` method to filter out
    any numbers with a significant digit after the decimal point. (This method is
    only defined for `float` type numbers in Python; it won’t work with numbers that
    are already entered in integer form.)
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这个问题，我们将使用 `is_integer()` 方法来过滤掉小数点后有有效数字的数字。（此方法仅适用于 Python 中的 `float`
    类型数字；它无法处理已经以整数形式输入的数字。）
- en: 'Here’s an example:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个例子：
- en: '[PRE36]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Here, we call the method `is_integer()` to check if 1.1 is an integer, and
    the result is `False` because 1.1 really is a floating point number. On the other
    hand, when the method is called with 1.0 as the floating point number, the result
    is `True`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们调用 `is_integer()` 方法来检查 1.1 是否为整数，结果是 `False`，因为 1.1 确实是浮点数。另一方面，当使用 1.0
    这个浮点数调用该方法时，结果是 `True`：
- en: '[PRE37]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We can use `is_integer()` to filter out noninteger input while keeping inputs
    like 1.0, which is expressed as a floating point number but is equivalent to an
    integer. We’ll see how the method would fit into a larger program a bit later.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `is_integer()` 来过滤掉非整数输入，同时保留像 1.0 这样的输入，虽然它是浮点数表示，但与整数等价。稍后我们将看到该方法如何融入一个更大的程序中。
- en: '***Fractions and Complex Numbers as Input***'
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***分数和复数作为输入***'
- en: 'The `Fraction` class we learned about earlier is also capable of converting
    a string such as `''3/4''` to a `Fraction` object. In fact, this is how we can
    accept a fraction as an input:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前学习过的 `Fraction` 类也可以将类似 `'3/4'` 的字符串转换为 `Fraction` 对象。实际上，这就是我们接受分数作为输入的方式：
- en: '[PRE38]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Try entering a fraction such as 3/0 as input:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试输入一个分数，如 3/0：
- en: '[PRE39]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `ZeroDivisionError` exception message tells you (as you already know) that
    a fraction with a denominator of 0 is invalid. If you’re planning on having users
    enter fractions as input in one of your programs, it’s a good idea to always catch
    such exceptions. Here is how you can do something like that:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`ZeroDivisionError` 异常消息告诉你（如你所知），分母为0的分数是无效的。如果你计划让用户在你的程序中输入分数作为输入，最好总是捕获此类异常。以下是你如何处理类似情况的示例：'
- en: '[PRE40]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now, whenever your program’s user enters a fraction with 0 in the denominator,
    it’ll print the message `Invalid fraction`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当程序的用户输入一个分母为0的分数时，它会打印出 `Invalid fraction` 消息。
- en: 'Similarly, the `complex()` function can convert a string such as `''2+3j''`
    into a complex number:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`complex()` 函数可以将类似 `'2+3j'` 的字符串转换为复数：
- en: '[PRE41]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'If you enter the string as `''2 + 3j''` (with spaces), it will result in a
    `ValueError` error message:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你输入的字符串是 `'2 + 3j'`（带有空格），将会导致 `ValueError` 错误消息：
- en: '[PRE42]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: It’s a good idea to catch the `ValueError` exception when converting a string
    to a complex number, as we’ve done for other number types.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在将字符串转换为复数时，像我们对其他数字类型所做的那样，捕获 `ValueError` 异常是一个好主意。
- en: '**Writing Programs That Do the Math for You**'
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**编写为你做数学运算的程序**'
- en: Now that we have learned some of the basic concepts, we can combine them with
    Python’s conditional and looping statements to make some programs that are a little
    more advanced and useful.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学习了一些基本概念，我们可以将它们与 Python 的条件语句和循环语句结合起来，编写一些稍微复杂一些的有用程序。
- en: '***Calculating the Factors of an Integer***'
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***计算整数的因子***'
- en: 'When a nonzero integer, `a`, divides another integer, `b`, leaving a remainder
    0, `a` is said to be a *factor* of `b`. As an example, 2 is a factor of all even
    integers. We can write a function such as the one below to find whether a nonzero
    integer, `a`, is a factor of another integer, `b`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个非零整数 `a` 能够整除另一个整数 `b` 并且余数为0时，称 `a` 为 `b` 的 *因子*。例如，2 是所有偶数的因子。我们可以编写如下函数来判断一个非零整数
    `a` 是否是另一个整数 `b` 的因子：
- en: '[PRE43]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We use the `%` operator introduced earlier in this chapter to calculate the
    remainder. If you ever find yourself asking a question like “Is 4 a factor of
    1024?”, you can use the `is_factor()` function:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用本章前面介绍的 `%` 运算符来计算余数。如果你曾经问过类似“4 是 1024 的因子吗？”这样的问题，你可以使用 `is_factor()`
    函数：
- en: '[PRE44]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: For any positive integer *n*, how do we find all its positive factors? For each
    of the integers between 1 and *n*, we check the remainder after dividing *n* by
    this integer. If it leaves a remainder of 0, it’s a factor. We’ll use the `range()`
    function to write a program that will go through each of those numbers between
    1 and *n*.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何正整数 *n*，我们如何找到它的所有正因子？对于从 1 到 *n* 之间的每个整数，我们检查将 *n* 除以该整数后的余数。如果余数为0，它就是一个因子。我们将使用
    `range()` 函数编写一个程序，遍历 1 到 *n* 之间的每个数字。
- en: 'Before we write the full program, let’s take a look at how `range()` works.
    A typical use of the `range()` function looks like this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写完整程序之前，让我们先看看 `range()` 是如何工作的。`range()` 函数的典型用法如下：
- en: '[PRE45]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Here, we set up a `for` loop and gave the range function two arguments. The
    `range()` function starts from the integer stated as the first argument (the *start
    value*) and continues up to the integer just *before* the one stated by the second
    argument (the *stop value*). In this case, we told Python to print out the numbers
    in that range, beginning with 1 and stopping at 4\. Note that this means Python
    doesn’t print 4, so the last number it prints is the number before the stop value
    (3). It’s also important to note that the `range()` function accepts only integers
    as its arguments.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们设置了一个`for`循环，并给`range()`函数传递了两个参数。`range()`函数从作为第一个参数给定的整数（*起始值*）开始，一直到第二个参数给定的整数的*前一个*整数（*停止值*）。在这个例子中，我们告诉Python打印出这个范围内的数字，从1开始，停在4之前。注意，这意味着Python不会打印4，因此它打印的最后一个数字是停止值之前的那个数字（3）。同样需要注意的是，`range()`函数只接受整数作为其参数。
- en: 'You can also use the `range()` function without specifying the start value,
    in which case it’s assumed to be 0\. For example:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在不指定起始值的情况下使用`range()`函数，这时默认的起始值为0。例如：
- en: '[PRE46]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The difference between two consecutive integers produced by the `range()` function
    is known as the *step value*. By default, the step value is 1\. To specify a different
    step value, specify it as the third argument (the start value is *not* optional
    when you specify a step value). For example, the following program prints the
    odd numbers *below* 10:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`range()`函数产生的两个连续整数之间的差值被称为*步长值*。默认情况下，步长值为1。如果你想指定不同的步长值，可以将其作为第三个参数来指定（当你指定步长值时，起始值*不是*可选的）。例如，下面的程序打印出小于10的奇数：'
- en: '[PRE47]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Okay, now that we see how the `range()` function works, we’re ready to look
    at a factor-calculating program. Because I’m writing a fairly long program, instead
    of writing this program in the interactive IDLE prompt, I write it in the IDLE
    editor. You can start the editor by selecting **File**▸**New Window** in IDLE.
    Notice that we start out by commenting our code with three straight single quotes
    (`'`). The text in between those quotes won’t be executed by Python as part of
    the program; it’s just commentary for us humans.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们已经了解了`range()`函数的工作原理，我们可以开始编写一个计算因子的程序了。因为我要写一个比较长的程序，所以我不在交互式的IDLE提示符中编写程序，而是使用IDLE编辑器。在IDLE中，你可以通过选择**文件**▸**新建窗口**来启动编辑器。注意，我们在代码中开始时用三个连续的单引号（`'`）来注释代码。单引号之间的文本不会被Python执行，它只是供我们人类参考的注释。
- en: '[PRE48]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `factors()` function defines a `for` loop that iterates once for every integer
    between 1 and the input integer at ➊ using the `range()` function. Here, we want
    to iterate up to the integer entered by the user, `b`, so the stop value is stated
    as `b+1`. For each of these integers, `i`, the program checks whether it divides
    the input number with no remainder and prints it if so.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`factors()`函数定义了一个`for`循环，使用`range()`函数迭代从1到输入整数之间的每个整数，在➊处迭代。这里，我们想要迭代到用户输入的整数`b`，所以停止值设置为`b+1`。对于每一个整数`i`，程序会检查它是否能整除输入的数字，并在能够整除时打印该整数。'
- en: 'When you run this program (by selecting **Run**▸**Run Module**), it asks you
    to input a number. If your number is a positive integer, its factors are printed.
    For example:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个程序（通过选择**运行**▸**运行模块**），它会要求你输入一个数字。如果你的数字是一个正整数，它会打印出这个数字的因子。例如：
- en: '[PRE49]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'If you enter a non-integer or a negative integer as an input, the program prints
    an error message asking you to input a positive integer:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你输入一个非整数或负整数作为输入，程序会打印一条错误信息，要求你输入一个正整数：
- en: '[PRE50]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This is an example of how we can make programs more user friendly by always
    checking for invalid input in the program itself. Because our program works only
    for finding the factors of a positive integer, we check whether the input number
    is greater than 0 and is an integer using the `is_integer()` method ➋ to make
    sure the input is valid. If the input isn’t a positive integer, the program prints
    a user-friendly instruction instead of just a big error message.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个例子，展示了我们如何通过在程序中检查无效输入来让程序更具用户友好性。因为我们的程序仅适用于查找正整数的因子，所以我们使用`is_integer()`方法➋来检查输入的数字是否大于0且为整数，从而确保输入有效。如果输入的不是正整数，程序会打印一条用户友好的提示信息，而不是一个错误信息。
- en: '***Generating Multiplication Tables***'
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***生成乘法表***'
- en: Consider three numbers, *a*, *b*, and *n*, where *n* is an integer, such that
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑三个数字，*a*、*b* 和 *n*，其中 *n* 是一个整数，满足
- en: '*a* × *n* = *b*.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*a* × *n* = *b*。'
- en: We can say here that *b* is the *n*th *multiple* of *a*. For example, 4 is the
    2nd multiple of 2, and 1024 is the 512nd multiple of 2.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在这里说 *b* 是 *a* 的 *n* 次倍数。例如，4 是 2 的第二个倍数，1024 是 2 的第 512 个倍数。
- en: 'A multiplication table for a number lists all of that number’s multiples. For
    example, the multiplication table of 2 looks like this (first three multiples
    shown here):'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 一个数字的乘法表列出了该数字的所有倍数。例如，2 的乘法表如下（这里展示前三个倍数）：
- en: 2 × 1 = 2
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 2 × 1 = 2
- en: 2 × 2 = 4
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 2 × 2 = 4
- en: 2 × 3 = 6
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 2 × 3 = 6
- en: Our next program generates the multiplication number up to 10 for any number
    input by the user. In this program, we’ll use the `format()` method with the `print()`
    function to help make the program’s output look nicer and more readable. In case
    you haven’t seen it before, I’ll now briefly explain how it works.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一个程序会生成用户输入的任意数字的乘法表，最高到 10。在这个程序中，我们将使用 `format()` 方法配合 `print()` 函数，以帮助使程序的输出看起来更加美观和易读。如果你以前没有见过这个方法，我现在简要说明一下它是如何工作的。
- en: 'The `format()` method lets you plug in labels and set it up so that they get
    printed out in a nice, readable string with extra formatting around it. For example,
    if I had the names of all the fruits I bought at the grocery store with separate
    labels created for each and wanted to print them out to make a coherent sentence,
    I could use the `format()` method as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`format()` 方法允许你插入标签并设置它们，以便它们以漂亮、可读的字符串格式打印出来，并且加上一些额外的格式化。例如，如果我有一个我在杂货店买的所有水果的名字，每个名字都有单独的标签，并且我想把它们打印成一个连贯的句子，我可以使用
    `format()` 方法，像这样：'
- en: '[PRE51]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'First, we created three labels (`item1`, `item2`, and `item3`), each referring
    to a different string (`apples`, `bananas`, and `grapes`). Then, in the `print()`
    function, we typed a string with three placeholders in curly brackets: `{0}`,
    `{1}`, and `{2}`. We followed this with `.format()`, which holds the three labels
    we created. This tells Python to fill those three placeholders with the values
    stored in those labels in the order listed, so Python prints the text with `{0}`
    replaced by the first label, `{1}` replaced by the second label, and so on.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建了三个标签（`item1`、`item2` 和 `item3`），每个标签对应一个不同的字符串（`apples`、`bananas` 和
    `grapes`）。然后，在 `print()` 函数中，我们输入了一个包含三个占位符的字符串，分别是 `{0}`、`{1}` 和 `{2}`。接着我们使用
    `.format()`，它包含了我们创建的三个标签。这告诉 Python 用这些标签中存储的值按顺序替换这些占位符，从而 Python 会打印出文本，`{0}`
    被第一个标签替换，`{1}` 被第二个标签替换，以此类推。
- en: 'It’s not necessary to have labels pointing to the values we want to print.
    We can also just type values into `.format()`, as in the following example:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 不一定需要有标签来指向我们想要打印的值。我们也可以直接将值输入到 `.format()` 中，像下面这个例子：
- en: '[PRE52]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Note that the number of placeholders and the number of labels or values must
    be equal.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，位置占位符的数量和标签或值的数量必须相等。
- en: 'Now that we’ve seen how `format()` works, we’re ready to take a look at the
    program for our multiplication table printer:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 `format()` 是如何工作的，我们可以来看看我们乘法表打印程序的代码：
- en: '[PRE53]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The function `multi_table()` implements the main functionality of the program.
    It takes the number for which the multiplication table will be printed as a parameter,
    `a`. Because we want to print the multiplication table from 1 to 10, we have a
    `for` loop at ➊ that iterates over each of these numbers, printing the product
    of itself and the number, `a`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `multi_table()` 实现了程序的主要功能。它接收一个参数 `a`，这个参数是将要打印乘法表的数字。因为我们想打印从 1 到 10 的乘法表，所以我们在
    ➊ 处有一个 `for` 循环，它会遍历这些数字，打印出该数字和 `a` 的乘积。
- en: 'When you execute the program, it asks you to input a number, and the program
    prints its multiplication table:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当你执行程序时，它会要求你输入一个数字，然后程序打印出该数字的乘法表：
- en: '[PRE54]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: See how nice and orderly that table looks? That’s because we used the `.format()`
    method to print the output according to a readable, uniform template.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这张表格多么整齐和有序？这正是因为我们使用了 `.format()` 方法按可读的、统一的模板打印了输出。
- en: 'You can use the `format()` method to further control how numbers are printed.
    For example, if you want numbers with only two decimal places, you can specify
    that with the `format()` method. Here is an example:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `format()` 方法进一步控制数字的打印方式。例如，如果你想显示只有两位小数的数字，可以通过 `format()` 方法来指定。下面是一个例子：
- en: '[PRE55]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The first format statement above simply prints the number exactly as we entered
    it. In the second statement, we modify the place holder to `{0:.2f}`, meaning
    that we want only two numbers after the decimal point, with the `f` indicating
    a floating point number. As you can see, there are only two numbers after the
    decimal point in the next output. Note that the number is rounded if there are
    more numbers after the decimal point than you specified. For example:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的第一个格式语句仅仅是按照我们输入的方式打印数字。在第二个语句中，我们修改了占位符为`{0:.2f}`，意味着我们只想保留小数点后两位，`f`表示浮动小数点数。如你所见，接下来的输出中只有两个小数位。请注意，如果小数点后有比指定更多的数字，数字会四舍五入。例如：
- en: '[PRE56]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Here, 1.25556 is rounded up to the nearest hundredth and printed as 1.26\.
    If you use `.2f` and the number you are printing is an integer, zeros are added
    at the end:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，1.25556被四舍五入到最接近的百分位，并打印为1.26。如果你使用`.2f`并且你要打印的数字是整数，零会被加在末尾：
- en: '[PRE57]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Two zeros are added because we specified that we should print exactly two numbers
    after the decimal point.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 添加两个零是因为我们指定了要在小数点后打印出恰好两个数字。
- en: '***Converting Units of Measurement***'
  id: totrans-180
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***单位转换***'
- en: 'The International System of Units defines seven *base quantities*. These are
    then used to derive other quantities, referred to as *derived quantities*. Length
    (including width, height, and depth), time, mass, and temperature are four of
    the seven base quantities. Each of these quantities has a standard unit of measurement:
    meter, second, kilogram, and kelvin, respectively.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 国际单位制定义了七个*基本量*。这些基本量用于推导其他量，称为*导出量*。长度（包括宽度、高度和深度）、时间、质量和温度是七个基本量中的四个。每个基本量都有一个标准的计量单位：米、秒、千克和开尔文，分别对应。
- en: But each of these standard measurement units also has multiple nonstandard measurement
    units. You are more familiar with the temperature being reported as 30 degrees
    Celsius or 86 degrees Fahrenheit than as 303.15 kelvin. Does that mean 303.15
    kelvin feels three times hotter than 86 degrees Fahrenheit? No way! We can’t compare
    86 degrees Fahrenheit to 303.15 kelvin only by their numerical values because
    they’re expressed in different measurement units, even though they measure the
    same physical quantity—temperature. You can compare two measurements of a physical
    quantity only when they’re expressed in the same unit of measurement.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 但这些标准计量单位也有多个非标准的计量单位。你更熟悉将温度报告为30摄氏度或86华氏度，而不是303.15开尔文。这是否意味着303.15开尔文比86华氏度热三倍？当然不是！我们不能仅通过数值比较86华氏度和303.15开尔文，因为它们使用了不同的计量单位，尽管它们衡量的是相同的物理量——温度。只有当物理量的两个测量值使用相同的计量单位时，才能进行比较。
- en: Conversions between different units of measurement can be tricky, and that’s
    why you’re often asked to solve problems that involve conversion between different
    units of measurement in high school. It’s a good way to test your basic mathematical
    skills. But Python has plenty of math skills, too, and, unlike some high school
    students, it doesn’t get tired of crunching numbers over and over again in a loop!
    Next, we’ll explore writing programs to perform those unit conversions for you.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 不同计量单位之间的转换可能比较复杂，这也是为什么在高中时你经常被要求解决涉及单位转换的问题。这是测试你基本数学技能的好方法。但Python也有很多数学技能，而且与一些高中生不同，它不会在循环中反复进行数值计算时感到疲倦！接下来，我们将探索编写程序来为你执行这些单位转换。
- en: We’ll start with length. In the United States and United Kingdom, inches and
    miles are often used for measuring length, while most other countries use centimeters
    and kilometers.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从长度开始。在美国和英国，英寸和英里通常用于衡量长度，而大多数其他国家使用厘米和公里。
- en: 'An inch is equal to 2.54 centimeters, and you can use the multiplication operation
    to convert a measurement in inches to centimeters. You can then divide the measurement
    in centimeters by 100 to obtain the measurement in meters. For example, here’s
    how you can convert 25.5 inches to meters:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 一英寸等于2.54厘米，你可以使用乘法运算将英寸单位转换为厘米单位。然后，你可以将厘米单位的测量值除以100以得到米单位的测量值。例如，下面是如何将25.5英寸转换为米：
- en: '[PRE58]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'On the other hand, a mile is roughly equivalent to 1.609 kilometers. So if
    you see that your destination is 650 miles away, you’re 650 × 1.609 kilometers
    away:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，一英里大约等于1.609公里。所以如果你看到目的地距离650英里，你实际上是650 × 1.609公里远：
- en: '[PRE59]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Now let’s take a look at *temperature* conversion—converting temperature from
    Fahrenheit to Celsius and vice versa. Temperature expressed in Fahrenheit is converted
    into its equivalent value in Celsius using the formula
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看*温度*转换——将温度从华氏度转换为摄氏度，反之亦然。用华氏度表示的温度可以使用公式转换为其等效的摄氏度值。
- en: '![image](images/e0018-01.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/e0018-01.jpg)'
- en: '*F* is the temperature in Fahrenheit, and *C* is its equivalent in Celsius.
    You know that 98.6 degrees Fahrenheit is said to be the normal human body temperature.
    To find the corresponding temperature in degrees Celsius, we evaluate the above
    formula in Python:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '*F* 是华氏温度，*C* 是其等效的摄氏温度。你知道98.6华氏度是正常人体体温。要找出其对应的摄氏温度，我们在Python中计算上述公式：'
- en: '[PRE60]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: First, we create a label, `F`, with the temperature in Fahrenheit, 98.6\. Next,
    we evaluate the formula for converting this temperature to its equivalent in Celsius,
    which turns out be 37.0 degrees Celsius.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个标签`F`，其值为华氏温度98.6。接着，我们使用公式将此温度转换为其等效的摄氏度，结果是37.0摄氏度。
- en: To convert temperature from Celsius to Fahrenheit, you would use the formula
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 要将温度从摄氏度转换为华氏度，你需要使用以下公式：
- en: '![image](images/e0018-02.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/e0018-02.jpg)'
- en: 'You can evaluate this formula in a similar manner:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以以类似的方式来评估这个公式：
- en: '[PRE61]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: We create a label, `C`, with the value 37 (the normal human body temperature
    in Celsius). Then, we convert it into Fahrenheit using the formula, and the result
    is 98.6 degrees.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个标签`C`，其值为37（正常人体体温，摄氏度）。然后，我们使用公式将其转换为华氏度，结果是98.6度。
- en: 'It’s a chore to have to write these conversion formulas over and over again.
    Let’s write a unit conversion program that will do the conversions for us. This
    program will present a menu to allow users to select the conversion they want
    to perform, ask for relevant input, and then print the calculated result. The
    program is shown below:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 一遍又一遍地编写这些转换公式真是麻烦。让我们写一个单位转换程序来帮助我们进行转换。这个程序会展示一个菜单，允许用户选择他们想要执行的转换，要求输入相关数据，然后打印计算结果。程序如下：
- en: '[PRE62]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This is a slightly longer program than the others, but not to worry. It’s actually
    simple. Let’s start from ➊. The `print_menu()` function is called, which prints
    a menu with two unit conversion choices. At ➋, the user is asked to select one
    of the two conversions. If the choice is entered as 1 (kilometers to miles), the
    function `km_miles()` is called. If the choice is entered as 2 (miles to kilometers),
    the function `miles_km()` is called. In both of these functions, the user is first
    asked to enter a distance in the unit chosen for conversion (kilometers for `km_miles()`
    and miles for `miles_km()`). The program then performs the conversion using the
    corresponding formula and displays the result.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个稍微长一点的程序，但不用担心，实际上很简单。我们从➊开始。调用`print_menu()`函数，它会打印一个包含两种单位转换选择的菜单。在➋，程序会要求用户选择其中一个转换。如果选择输入为1（公里到英里），则调用`km_miles()`函数。如果选择输入为2（英里到公里），则调用`miles_km()`函数。在这两个函数中，程序首先会要求用户输入所选择单位的距离（`km_miles()`使用公里，`miles_km()`使用英里）。然后，程序使用对应的公式进行转换，并显示结果。
- en: 'Here is a sample run of the program:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是该程序的一个示例运行：
- en: '[PRE63]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The user is asked to enter a choice at ➊. The choice is entered as 2 (miles
    to kilometers). The program then asks the user to enter the distance in miles
    to be converted to kilometers and prints the conversion.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 用户在➊处被要求输入选择。用户选择了2（英里转公里）。程序接着要求用户输入需要转换为公里的英里数，并打印转换结果。
- en: This program just converts between miles and kilometers, but in a programming
    challenge later, you’ll extend this program so that it can perform conversions
    of other units.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序仅仅是进行英里与公里之间的转换，但在以后的编程挑战中，你将扩展这个程序，使其能够进行其他单位的转换。
- en: '***Finding the Roots of a Quadratic Equation***'
  id: totrans-206
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***求解二次方程的根***'
- en: 'What do you do when you have an equation such as *x* + 500 – 79 = 10 and you
    need to find the value of the unknown variable, *x*? You rearrange the terms such
    that you have only the constants (500, –79, and 10) on one side of the equation
    and the variable (*x*) on the other side. This results in the following equation:
    *x* = 10 – 500 + 79.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有一个像 *x* + 500 – 79 = 10 这样的方程，并且需要找出未知变量 *x* 的值时，你需要重新排列方程，使得常数（500、-79 和
    10）在方程的一边，变量 (*x*) 在另一边。这样就得到了以下方程： *x* = 10 – 500 + 79。
- en: 'Finding the value of the expression on the right gives you the value of *x*,
    your solution, which is also called the *root* of this equation. In Python, you
    can do this as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 通过求解右边表达式的值，你将得到 *x* 的值，这个值就是该方程的解，也称为该方程的 *根*。在 Python 中，你可以按如下方式进行计算：
- en: '[PRE64]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'This is an example of a *linear equation*. Once you have rearranged the terms
    on both sides, the expression is simple enough to evaluate. On the other hand,
    for equations such as *x*² + 2*x* + 1 = 0, finding the roots of *x* usually involves
    evaluating a complex expression known as the *quadratic formula*. Such equations
    are known as *quadratic equations*, generally expressed as *ax*² + *bx* + *c*
    = 0, where *a*, *b*, and *c* are constants. The quadratic formula for calculating
    the roots is given as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 *线性方程* 的例子。一旦你将方程两边的项重新排列，该表达式就足够简单，能够进行求解。另一方面，对于如 *x*² + 2*x* + 1 = 0
    这样的方程，求解 *x* 的根通常涉及到求解一个复杂的表达式，称为 *二次公式*。这样的方程被称为 *二次方程*，通常表示为 *ax*² + *bx* +
    *c* = 0，其中 *a*、*b* 和 *c* 是常数。用于计算根的二次公式如下所示：
- en: '![image](images/e0020-01.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/e0020-01.jpg)'
- en: A quadratic equation has two roots—two values of *x* for which the two sides
    of the quadratic equation are equal (although sometimes these two values may turn
    out to be the same). This is indicated here by the *x*[1] and *x*[2] in the quadratic
    formula.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 二次方程有两个根——即使这两个根的值有时可能相同，它们也表示 *x* 的两个值，使得二次方程的两边相等。这一点在二次公式中的 *x*[1] 和 *x*[2]
    处有所体现。
- en: 'Comparing the equation *x*² + 2*x* + 1 = 0 to the generic quadratic equation,
    we see that *a* = 1, *b* = 2, and *c* = 1\. We can substitute these values directly
    into the quadratic formula to calculate the value of *x*[1] and *x*[2]. In Python,
    we first store the values of *a*, *b*, and *c* as the labels `a`, `b`, and `c`
    with the appropriate values:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 将方程 *x*² + 2*x* + 1 = 0 与通用的二次方程进行比较，我们可以看到 *a* = 1，*b* = 2，*c* = 1。我们可以将这些值直接代入二次公式中来计算
    *x*[1] 和 *x*[2] 的值。在 Python 中，我们首先将 *a*、*b* 和 *c* 的值存储为标签 `a`、`b` 和 `c`，并赋予相应的数值：
- en: '[PRE65]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Then, considering that both the formulas have the term *b*² – 4*ac*, we’ll
    define a new label with *D*, such that ![image](images/e0021-01.jpg):'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，考虑到两个公式中都有 *b*² – 4*ac* 这一项，我们将定义一个新的标签 *D*，使得 ![image](images/e0021-01.jpg)：
- en: '[PRE66]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'As you can see, we evaluate the square root of *b*² – 4*ac* by raising it to
    the 0.5th power. Now, we can write the expressions for evaluating *x*[1] and *x*[2]:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们通过将 *b*² – 4*ac* 的平方根提升到 0.5 次方来进行计算。现在，我们可以写出求解 *x*[1] 和 *x*[2] 的表达式：
- en: '[PRE67]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: In this case, the values of both the roots are the same, and if you substitute
    that value into the equation *x*² + 2*x* + 1, the equation will evaluate to 0.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，两个根的值是相同的，如果你将这个值代入方程 *x*² + 2*x* + 1，方程的结果将为 0。
- en: 'Our next program combines all these steps in a function `roots()`, which takes
    the values of *a*, *b*, and *c* as parameters, calculates the roots, and prints
    them:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一个程序将这些步骤整合在一个名为 `roots()` 的函数中，该函数将 *a*、*b* 和 *c* 的值作为参数，计算出根并打印出来：
- en: '[PRE68]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: At first, we use the labels `a`, `b`, and `c` to reference the values of the
    three constants of a quadratic equation. Then, we call the `roots()` function
    with these three values as arguments (after converting them to floating point
    numbers). This function plugs `a`, `b`, and `c` into the quadratic formula, finds
    the roots for that equation, and prints them.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，我们使用标签 `a`、`b` 和 `c` 来引用二次方程中三个常数的值。然后，我们调用 `roots()` 函数，将这三个值作为参数（在将它们转换为浮动点数之后）。该函数将
    `a`、`b` 和 `c` 代入二次公式，计算该方程的根，并打印出来。
- en: When you execute the program, it will ask the user to input values of *a*, *b*,
    and *c* corresponding to a quadratic equation they want to find the roots for.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当你执行程序时，它将要求用户输入对应二次方程的 *a*、*b* 和 *c* 的值，用以求解该方程的根。
- en: '[PRE69]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Try solving a few more quadratic equations with different values for the constants,
    and the program will find the roots correctly.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试解决一些具有不同常数值的二次方程，程序将正确地找到根。
- en: 'You most likely know that quadratic equations can have complex numbers as roots,
    too. For example, the roots of the equation *x*² + *x* + 1 = 0 are both complex
    numbers. The above program can find those for you as well. Let’s give it a shot
    by executing the program again (the constants are *a* = 1, *b* = 1, and *c* =
    1):'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 你很可能知道，二次方程也可以有复数根。例如，方程 *x*² + *x* + 1 = 0 的根就是复数。上述程序也可以找到这些根。让我们再次运行程序试试看（常数为
    *a* = 1，*b* = 1，*c* = 1）：
- en: '[PRE70]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The roots printed above are complex numbers (indicated by `j`), and the program
    has no problem calculating or displaying them.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 上面打印出的根是复数（由`j`表示），程序能够正确计算和显示它们。
- en: '**What You Learned**'
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: Great work on finishing the first chapter! You learned to write programs that
    recognize integers, floating point numbers, fractional numbers (expressed as a
    fraction or a floating point number), and complex numbers. You wrote programs
    that generate multiplication tables, perform unit conversions, and find the roots
    of a quadratic equation. I’m sure you’re already excited about having taken the
    first steps toward writing programs that will do mathematical calculations for
    you. Before we move on, here are some programming challenges that will give you
    a chance to further apply what you’ve learned.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你完成了第一章！你学会了编写识别整数、浮点数、分数（可以用分数或浮点数表示）和复数的程序。你编写了生成乘法表、执行单位转换和求解二次方程根的程序。我相信你已经很激动，因为你已经迈出了编写能为你做数学计算的程序的第一步。在我们继续之前，以下是一些编程挑战，给你提供了一个进一步应用所学知识的机会。
- en: '**Programming Challenges**'
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**编程挑战**'
- en: Here are a few challenges that will give you a chance to practice the concepts
    from this chapter. Each problem can be solved in multiple ways, but you can find
    sample solutions at *[http://www.nostarch.com/doingmathwithpython/](http://www.nostarch.com/doingmathwithpython/)*.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些挑战，给你一个机会来练习这一章的概念。每个问题都有多种解法，你可以在*[http://www.nostarch.com/doingmathwithpython/](http://www.nostarch.com/doingmathwithpython/)*找到示例解答。
- en: '***#1: Even-Odd Vending Machine***'
  id: totrans-233
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***#1: 偶数-奇数自动售货机***'
- en: 'Try writing an “even-odd vending machine,” which will take a number as input
    and do two things:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 试着编写一个“偶数-奇数自动售货机”，它将接受一个数字作为输入，并做两件事：
- en: 1\. Print whether the number is even or odd.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 打印数字是偶数还是奇数。
- en: 2\. Display the number followed by the next 9 even or odd numbers.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 显示数字后跟着下一个 9 个偶数或奇数。
- en: If the input is `2`, the program should print `even` and then print `2, 4, 6,
    8, 10, 12, 14, 16, 18, 20`. Similarly, if the input is `1`, the program should
    print `odd` and then print `1, 3, 5, 7, 9, 11, 13, 15, 17, 19`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输入是`2`，程序应该打印`even`，然后打印`2, 4, 6, 8, 10, 12, 14, 16, 18, 20`。同样，如果输入是`1`，程序应该打印`odd`，然后打印`1,
    3, 5, 7, 9, 11, 13, 15, 17, 19`。
- en: Your program should use the `is_integer()` method to display an error message
    if the input is a number with significant digits beyond the decimal point.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 你的程序应该使用`is_integer()`方法，如果输入的是小数点后有显著数字的数字，则显示错误消息。
- en: '***#2: Enhanced Multiplication Table Generator***'
  id: totrans-239
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***#2: 增强型乘法表生成器***'
- en: Our multiplication table generator is cool, but it prints only the first 10
    multiples. Enhance the generator so that the user can specify both the number
    and up to *which* multiple. For example, I should be able to input that I want
    to see a table listing the first 15 multiples of 9.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的乘法表生成器很酷，但它只打印前 10 个倍数。增强该生成器，使用户可以指定数字和最多显示到*哪个*倍数。例如，我应该能够输入我想查看列出 9 的前
    15 个倍数的表格。
- en: '***#3: Enhanced Unit Converter***'
  id: totrans-241
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***#3: 增强型单位转换器***'
- en: The unit conversion program we wrote in this chapter is limited to conversions
    between kilometers and miles. Try extending the program to convert between units
    of mass (such as kilograms and pounds) and between units of temperature (such
    as Celsius and Fahrenheit).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这一章写的单位转换程序仅限于公里与英里之间的转换。试着扩展该程序，使其支持质量单位（如千克和磅）和温度单位（如摄氏度和华氏度）之间的转换。
- en: '***#4: Fraction Calculator***'
  id: totrans-243
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***#4: 分数计算器***'
- en: 'Write a calculator that can perform the basic mathematical operations on two
    fractions. It should ask the user for two fractions and the operation the user
    wants to carry out. As a head start, here’s how you can write the program with
    only the addition operation:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个可以对两个分数进行基本数学运算的计算器。它应该询问用户两个分数以及用户想要执行的操作。作为起点，这里是只实现加法操作的程序示例：
- en: '[PRE71]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'You’ve already seen most of the elements in this program. At ➊ and ➋, we ask
    the user to input the two fractions. Then, we ask the user which operation is
    to be performed on the two fractions. If the user enters `''Add''` as input, we
    call the function `add()`, which we’ve defined to find the sum of the two fractions
    passed as arguments. The `add()` function performs the operation and prints the
    result. For example:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了该程序中的大部分元素。在➊和➋，我们让用户输入两个分数。然后，我们询问用户对这两个分数要进行什么操作。如果用户输入`'Add'`作为操作，程序会调用我们定义的`add()`函数，用于计算传入的两个分数的和。`add()`函数执行操作并打印结果。例如：
- en: '[PRE72]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Try adding support for other operations such as subtraction, division, and
    multiplication. For example, here’s how your program should be able to calculate
    the difference of two fractions:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试添加对其他操作的支持，比如减法、除法和乘法。例如，下面是你的程序应该如何计算两个分数之差：
- en: '[PRE73]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: In the case of division, you should let the user know whether the first fraction
    is divided by the second fraction or vice versa.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在除法的情况下，你应该让用户知道是第一个分数除以第二个分数，还是相反。
- en: '***#5: Give Exit Power to the User***'
  id: totrans-251
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***#5：赋予用户退出的权力***'
- en: 'All the programs we have written so far work only for one iteration of input
    and output. For example, consider the program to print the multiplication table:
    the user executes the program and enters a number; then the program prints the
    multiplication table and exits. If the user wanted to print the multiplication
    table of another number, the program would have to be rerun.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们写的所有程序只适用于一次输入和输出。例如，考虑打印乘法表的程序：用户执行程序并输入一个数字；然后程序打印乘法表并退出。如果用户想要打印另一个数字的乘法表，就必须重新运行程序。
- en: 'It would be more convenient if the user could choose whether to exit or continue
    using the program. The key to writing such programs is to set up an *infinite
    loop*, or a loop that doesn’t exit unless explicitly asked to do so. Below, you
    can see an example of the layout for such a program:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户可以选择是否退出或继续使用程序，那会更方便。编写这类程序的关键是设置一个*无限循环*，即一个除非明确要求退出，否则不会结束的循环。下面，你可以看到这种程序布局的示例：
- en: '[PRE74]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'We define an infinite loop using `while True` at ➊. A `while` loop continues
    to execute unless the condition evaluates to `False`. Because we chose the loop’s
    condition to be the constant value `True`, it will keep running forever unless
    we interrupt it somehow. Inside the loop, we call the function `fun()`, which
    prints the string `I am in an endless loop`. At ➋, the user is asked “Do you want
    to exit?” If the user enters `y` as the input, the program exits out of the loop
    using the `break` statement (`break` exits out of the innermost loop without executing
    any other statement in that loop). If the user enters any other input (or none
    at all, just pressing ENTER), the `while` loop continues execution—that is, it
    prints the string again and continues doing so until the user wishes to exit.
    Here is a sample run of the program:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在➊使用`while True`定义了一个无限循环。`while`循环会持续执行，除非条件评估为`False`。因为我们选择了循环条件为常量值`True`，所以它会一直运行，除非我们以某种方式中断它。在循环内部，我们调用`fun()`函数，它打印字符串`I
    am in an endless loop`。在➋，会询问用户“你想退出吗？”如果用户输入`y`，程序就会通过`break`语句退出循环（`break`语句会退出最内层循环，不执行该循环中的任何其他语句）。如果用户输入其他内容（或者什么也不输入，只按ENTER键），`while`循环将继续执行——也就是说，它会再次打印字符串，并且会继续这样做，直到用户希望退出。以下是程序的示例运行：
- en: '[PRE75]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Based on this example, let’s rewrite the multiplication table generator so
    that it keeps going until the user wants to exit. The new version of the program
    is shown below:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这个例子，让我们重新编写乘法表生成器，使其在用户希望退出之前一直运行。程序的新版本如下所示：
- en: '[PRE76]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: If you compare this program to the one we wrote earlier, you’ll see that the
    only change is the addition of the `while` loop, which includes the prompt asking
    the user to input a number and the call to the `multi_table()` function.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将这个程序与我们之前写的程序进行对比，你会发现唯一的变化就是添加了`while`循环，该循环包含了提示用户输入数字的部分，以及调用`multi_table()`函数的部分。
- en: 'When you run the program, the program will ask for a number and print its multiplication
    table, as before. However, it will also subsequently ask whether the user wants
    to exit the program. If the user doesn’t want to exit, the program will be ready
    to print the table for another number. Here is a sample run:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行程序时，程序会像以前一样要求输入一个数字并打印它的乘法表。然而，它还会接着询问用户是否希望退出程序。如果用户不想退出，程序将准备好打印另一个数字的乘法表。以下是一个示例运行：
- en: '[PRE77]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Try rewriting some of the other programs in this chapter so that they continue
    executing until asked by the user to exit.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试重写本章中的一些其他程序，使它们在用户要求退出之前持续执行。
