- en: '**12'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**12'
- en: IMPLEMENTING WEB DATA AND PROCESSING IMAGES**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 实现网页数据与图像处理**
- en: '![Image](../Images/comm1.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../Images/comm1.jpg)'
- en: Real-life chatbots should respond to a variety of inputs, such as questions
    from users on unfamiliar topics or even images sent through messaging apps. For
    example, chatbot app users can send not only text messages, but also photos, and
    the bot is supposed to react appropriately to both.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现实生活中的聊天机器人应该能够应对各种输入，例如用户提出的关于不熟悉话题的问题，甚至是通过消息应用发送的图片。例如，聊天机器人应用的用户不仅可以发送文本消息，还可以发送照片，机器人应能适当地回应这两者。
- en: This chapter provides some examples of how to use other libraries from Python’s
    AI ecosystem when developing a bot application. First, you’ll combine spaCy with
    Wikipedia to find information about keywords taken from a user’s question. Next,
    you’ll obtain descriptive tags for a submitted image with the help of Clarifai,
    an image and video recognition tool, so your app can interpret visual content.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了一些示例，展示如何在开发机器人应用时使用 Python 人工智能生态系统中的其他库。首先，你将结合 spaCy 和 Wikipedia，查找来自用户问题的关键词的信息。接下来，你将借助
    Clarifai（一个图像和视频识别工具）获取提交图像的描述标签，从而使你的应用能够解释视觉内容。
- en: Then you’ll put all the components together to build a Telegram bot that can
    generate relevant responses to text and images by extracting information from
    Wikipedia.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你将把所有组件组合在一起，构建一个 Telegram 机器人，通过从 Wikipedia 提取信息来生成与文本和图片相关的回应。
- en: '**How It Works**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**工作原理**'
- en: '[Figure 12-1](../Text/ch12.xhtml#ch12fig01) shows a diagram of the bot we’ll
    build in this chapter. The bot is designed to understand text messages and pictures,
    and respond with text from Wikipedia.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 12-1](../Text/ch12.xhtml#ch12fig01) 显示了我们将在本章中构建的机器人示意图。这个机器人设计用于理解文本消息和图片，并通过
    Wikipedia 返回文本回应。'
- en: '![image](../Images/fig12-1.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/fig12-1.jpg)'
- en: '*Figure 12-1: How a bot that can process text messages and pictures works*'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-1：一个可以处理文本消息和图片的机器人的工作原理*'
- en: Using this bot, the user can post either a text message or a picture. If the
    post is a picture, the bot sends it to an image recognition tool for processing.
    This tool returns a verbal description of the picture in the form of descriptive
    tags. If the post is a text message, the bot uses an NLP tool like spaCy to extract
    a keyword or a keyphrase from it. The bot then uses either the tag or the keyphrase
    to find the most relevant content on Wikipedia (or somewhere else on the web)
    and return a piece of it to the user. You can use this scenario in chatbots you
    design to hold a conversation on various topics for fun, learning, or personal
    use.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个机器人，用户可以发送文本消息或图片。如果发布的是图片，机器人会将其发送到图像识别工具进行处理。该工具会返回一组描述标签，提供图片的文字描述。如果发布的是文本消息，机器人将使用像
    spaCy 这样的 NLP 工具从中提取关键词或关键短语。然后，机器人使用标签或关键短语在 Wikipedia（或互联网上的其他地方）找到最相关的内容，并将其中的一部分返回给用户。你可以在你设计的聊天机器人中使用这种场景来进行各种话题的对话，无论是娱乐、学习还是个人使用。
- en: '**Making Your Bot Find Answers to Questions from Wikipedia**'
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**让你的机器人从 Wikipedia 中找到问题的答案**'
- en: Let’s start with a discussion of techniques that you can implement in your bot
    to make it interpret a wide range of text messages. Previous chapters talked about
    how bots used for business purposes typically ask for certain information from
    the user and then use the answer to fill an order or booking request. In contrast,
    a bot designed to hold informal conversations should be able to answer a diverse
    range of user questions.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先讨论一下你可以在机器人中实现的技术，使其能够解释广泛的文本消息。前面的章节讨论了通常用于商业目的的机器人如何向用户询问特定信息，然后使用答案来填充订单或预订请求。相比之下，设计用来进行非正式对话的机器人应该能够回答用户的各种问题。
- en: One way to help a chatbot answer user questions is to choose a keyword or keyphrase
    in the question that provides a clue as to what information should be included
    in the answer. Once you have this keyword or keyphrase, you can use it to search
    for the answer using tools like the Wikipedia API for Python. Wikipedia’s API
    lets you access and parse Wikipedia content programmatically, performing a search
    for a keyword to retrieve content from the most relevant Wikipedia article. The
    following sections describe how to do this.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 帮助聊天机器人回答用户问题的一种方法是选择问题中的关键词或关键短语，作为提示，以确定答案中应包含的信息。一旦得到了这个关键词或关键短语，就可以使用它来搜索答案，使用像
    Python 的 Wikipedia API 等工具。Wikipedia 的 API 允许你以编程方式访问和解析 Wikipedia 内容，通过搜索关键词来检索最相关的
    Wikipedia 文章中的内容。以下章节将描述如何做到这一点。
- en: 'But before proceeding to the examples, make sure you’re using one of the most
    recent spaCy models, because the accuracy of the dependency parsing is higher
    in newer versions. You can check the version of your current model using the following
    command:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 但是在继续看例子之前，请确保你正在使用最新的spaCy模型，因为新版本的依存分析准确性更高。你可以使用以下命令检查当前模型的版本：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Then visit the *[https://explosion.ai/demos/displacy/](https://explosion.ai/demos/displacy/)*
    demo page (discussed in [Chapter 7](../Text/ch07.xhtml#ch07)) to see the latest
    stable versions of spaCy models available. Alternatively, you can visit spaCy’s
    documentation at *[https://spacy.io/usage/](https://spacy.io/usage/)* to check
    for the newest version of spaCy. Both spaCy and its models follow the same versioning
    scheme. Based on that information, you might want to update the model you currently
    use. Refer to [Chapter 2](../Text/ch02.xhtml#ch02) for details on how to download
    and install a spaCy model.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然后访问 *[https://explosion.ai/demos/displacy/](https://explosion.ai/demos/displacy/)*
    演示页面（在[第7章](../Text/ch07.xhtml#ch07)中讨论过）查看最新的spaCy模型稳定版本。或者，你也可以访问spaCy的文档 *[https://spacy.io/usage/](https://spacy.io/usage/)*
    来查看spaCy的最新版本。spaCy及其模型遵循相同的版本控制方案。根据这些信息，你可能希望更新你当前使用的模型。有关如何下载和安装spaCy模型的详细信息，请参见[第2章](../Text/ch02.xhtml#ch02)。
- en: '***Determining What the Question Is About***'
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***确定问题的主题***'
- en: 'Some words in a question are more important than others when you’re trying
    to determine what the speaker is asking about. Sometimes it’s enough to look at
    a single word in the question, such as the noun that follows a preposition. For
    example, a user might use any of the following questions to ask the bot to find
    some information about rhinos:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个问题中，某些词比其他词更为重要，特别是当你试图确定说话者想要询问的内容时。有时候，仅仅看问题中的一个词就足够了，比如跟在介词后面的名词。例如，用户可能会用以下任何问题让机器人寻找关于犀牛的信息：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Let’s look at what the dependency parsing of such sentences might look like.
    [Figure 12-2](../Text/ch12.xhtml#ch12fig02) shows a graphical representation of
    the parsing of the first sentence.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这种句子的依存分析可能是什么样的。[图12-2](../Text/ch12.xhtml#ch12fig02)展示了第一句话依存分析的图形表示。
- en: '![image](../Images/fig12-2.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/fig12-2.jpg)'
- en: '*Figure 12-2: The dependency parsing of a sentence containing an object of
    a preposition*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-2：包含介词宾语的句子的依存分析*'
- en: 'The parsing illustrates that in this kind of question you can get the word
    “rhinos” by extracting the object of the preposition. “Rhinos” would be the most
    helpful word in the question for finding an answer. The following code fragment
    shows how you might extract the first occurrence of an object of the preposition
    in the question:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 该分析展示了在这类问题中，通过提取介词宾语，可以获得“犀牛”这个词。“犀牛”将是该问题中最有助于找到答案的词。以下代码片段展示了如何提取问题中第一次出现的介词宾语：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the code, we also pick up the left children of the object of the preposition,
    because the object might have important modifiers, as in the following example:
    “What can you say about wild mountain goats?” When given this question, the code
    should assign “wild mountain goats” to the `phrase` variable.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，我们还会提取介词宾语的左孩子节点，因为该宾语可能有重要的修饰成分，如下例所示：“你能告诉我关于野生山羊的事吗？”当给出这个问题时，代码应将“野生山羊”赋值给`phrase`变量。
- en: Notice the use of the `break` statement at the end, which guarantees that only
    the first object of a preposition in a sentence will be picked up. For example,
    in the sentence, “Tell me about the United States of America,” the phrase “the
    United States” would be picked up, but not “America.”
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在末尾使用了`break`语句，它确保只有句子中介词的第一个宾语会被提取出来。例如，在句子“告诉我关于美利坚合众国的事”中，“美利坚合众国”这一短语会被提取出来，但“美国”不会。
- en: But this is not always desirable behavior. What if a user asked, “Tell me about
    the color of the sky.”? This is where we need to apply more complicated logic.
    In particular, we might want to to pick up any prepositional object that follows
    the first prepositional object, provided the latter is dependent on the former.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 但这种行为并不总是理想的。那么，如果用户问：“告诉我关于天空颜色的事”呢？这时我们需要应用更复杂的逻辑。特别是，我们可能希望提取紧跟第一个介词宾语之后的任何介词宾语，前提是后者依赖于前者。
- en: 'Here is how you might implement this logic:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你可能实现该逻辑的方法：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that this code will process a prepositional object that is a dependent
    of the first prepositional object only if the former exists in the sentence. Otherwise,
    this code will work the same as the code shown previously.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，只有当第一个介词对象的依赖项中存在前述的介词对象时，这段代码才会处理作为第一个介词对象依赖项的介词对象。否则，这段代码将与前面展示的代码一样工作。
- en: 'Now let’s look at another type of question in the following examples where
    two words, a verb and its subject, provide the best information about what a user
    wants in response to the questions:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下以下示例中的另一种问题类型，其中两个词——一个动词和它的主语——提供了最有信息量的内容，用来回应用户的问题：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[Figure 12-3](../Text/ch12.xhtml#ch12fig03) shows what a dependency parsing
    for one of these sentences might look like.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '[图12-3](../Text/ch12.xhtml#ch12fig03)展示了这类句子的依存句法解析可能是什么样的。'
- en: '![image](../Images/fig12-3.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/fig12-3.jpg)'
- en: '*Figure 12-3: The dependency parsing of a sentence in which a subject/verb
    pair is the most informative element for discovering what the speaker wants to
    know*'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-3：句子的依存句法解析，其中主语/动词对是发现发言者想要了解的最有信息量的元素*'
- en: 'Looking through the parsing shown in the figure, notice that the subject/verb
    pair that occurs at the end of the sentence is the most informative when trying
    to determine what the speaker asks about. Programmatically, you can extract the
    subject and verb pair from a sentence using the following code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看图中的解析，请注意，在试图确定发言者询问内容时，句子末尾出现的主语/动词对是最有信息量的。程序上，你可以使用以下代码从句子中提取主语和动词对：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'While examining this code, notice that we loop backward from the end of the
    sentence using Python’s `reversed()` function. The reason is that we need to pick
    up the last subject/verb pair in the sentence, as in this example: “Do you know
    what an elephant eats?” In this sentence, we’re interested in the phrase “elephant
    eats” rather than “you know,” which is also a subject/verb pair.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查这段代码时，请注意我们使用 Python 的`reversed()`函数从句子的末尾反向遍历。原因是我们需要找到句子中的最后一个主语/动词对，就像这个例子一样：“你知道大象吃什么吗？”在这个句子中，我们关注的是“elephant
    eats”这一短语，而不是“you know”，尽管它也是一个主语/动词对。
- en: 'Additionally, in some questions, the last noun in the sentence is the direct
    object of a verb that matters to determine what the question is about, as in the
    following example:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在某些问题中，句子中的最后一个名词是一个动词的直接宾语，对于确定问题的内容至关重要，就像以下示例一样：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this sentence, extracting the direct object “cat” wouldn’t be sufficient,
    because we also need the word “feed” to understand the question. Ideally, we’d
    generate the keyphrase “feeding a cat.” That is, we’d replace the infinitive “to”
    form of the verb with a gerund by adding “-ing,” optimizing the keyphrase for
    an internet search. [Figure 12-4](../Text/ch12.xhtml#ch12fig04) shows the dependency
    parsing for this sentence.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个句子中，单独提取直接宾语“cat”是不够的，因为我们还需要“feed”这个词来理解问题。理想情况下，我们会生成关键短语“feeding a cat”。也就是说，我们会将动词的“to”不定式形式替换为动名词形式，通过添加“-ing”，优化这个关键短语以便进行网络搜索。[图12-4](../Text/ch12.xhtml#ch12fig04)展示了这个句子的依存句法解析。
- en: '![image](../Images/fig12-4.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/fig12-4.jpg)'
- en: '*Figure 12-4: Dependency parsing of a sentence with a verb/direct object pair
    as the most informative phrase*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-4：包含动词/直接宾语对作为最具信息量短语的句子的依存句法解析*'
- en: This syntactic parsing shows that extracting the required phrase is easy, because
    the direct object and its transitive verb are connected with a direct link.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这段句法解析表明，提取所需的短语是容易的，因为直接宾语和其及物动词通过直接连接相互关联。
- en: 'The code implementation for the extraction discussed here might look like this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这里讨论的提取的代码实现可能看起来像这样：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In this case, we once again loop backward from the end of the sentence. To
    understand why, consider the following sentence: “Tell me something about how
    to feed a cat.” It contains two verb/direct object pairs, but we’re interested
    only in the one that occurs at the end of the sentence.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们再次从句子的末尾反向遍历。为了理解为什么这样做，可以考虑以下句子：“告诉我关于如何喂猫的一些事情。”它包含了两个动词/直接宾语对，但我们只关心句子末尾的那个。
- en: '***Try This***'
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***试试看***'
- en: Modify the code in the previous section that extracts the phrase “elephant eats”
    so the keyphrase being extracted from the sentence includes possible modifiers
    of the subject, excluding a possible determiner. For example, in the sentence,
    “Tell me how a female cheetah hunts,” your script should return “female cheetah
    hunts” and remove the “a” determiner from the noun chunk. As an example of how
    you might implement this, look at the code that follows [Figure 12-2](../Text/ch12.xhtml#ch12fig02).
    In that code, you picked up modifiers for the object of the preposition being
    extracted.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 修改上一部分中提取短语“elephant eats”的代码，使得从句子中提取的关键短语包括主语可能的修饰词，而不包括可能的限定词。例如，在句子“告诉我雌性猎豹是如何捕猎的”中，你的脚本应该返回“雌性猎豹捕猎”，并去掉名词短语中的“a”限定词。作为你可能如何实现这一点的示例，请参阅下面的代码[图12-2](../Text/ch12.xhtml#ch12fig02)。在那段代码中，你提取了介词的宾语的修饰词。
- en: 'Also, add a check to see whether the verb included in the phrase being extracted
    has a direct object, and if so, append the direct object to the keyphrase. For
    example, the question “Do you know how many eggs a sea turtle lays?” should give
    you the following keyphrase: “sea turtle lays eggs.”'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还要添加检查，以查看被提取的短语中的动词是否有直接宾语，如果有，将直接宾语附加到关键短语中。例如，问题“你知道海龟每次产多少个蛋吗？”应该返回以下关键短语：“海龟产蛋”。
- en: '***Using Wikipedia to Answer User Questions***'
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用维基百科回答用户问题***'
- en: Now that you have a keyphrase that can help you find the information needed
    to generate a relevant response to the user’s question, you need to retrieve the
    information. A bot can get answers to user questions from several places, and
    the proper source to use depends on the application, but Wikipedia is a good place
    to start. The `wikipedia` Python library (*[https://pypi.org/project/wikipedia/](https://pypi.org/project/wikipedia/)*)
    allows you to access Wikipedia articles from within your Python code.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有了一个关键短语，它可以帮助你找到生成与用户问题相关的回答所需的信息，你需要检索这些信息。机器人可以从多个地方获取用户问题的答案，选择合适的来源取决于应用场景，但维基百科是一个很好的起点。`wikipedia`
    Python 库（* [https://pypi.org/project/wikipedia/](https://pypi.org/project/wikipedia/)
    *）允许你在 Python 代码中访问维基百科文章。
- en: 'You can install the library via `pip` as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过 `pip` 安装该库，方法如下：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: To test the newly installed library, use the following script, which relies
    on a code fragment from the previous section to extract a keyword from a submitted
    sentence. Then it uses that keyword as a Wikipedia search term.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试新安装的库，请使用以下脚本，它依赖于上一部分的代码片段，从提交的句子中提取关键字。然后，它将该关键字用作维基百科搜索词。
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this script, we extract a keyword or keyphrase from the submitted sentence
    ➊ and send it to the `wikipedia.page()` function, which returns the most relevant
    article for the given keyword ➋. Then we simply print out the article’s title,
    URL, and first sentence.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个脚本中，我们从提交的句子中提取一个关键字或关键短语 ➊，并将其发送到 `wikipedia.page()` 函数，后者返回与给定关键字最相关的文章
    ➋。然后我们只需打印出文章的标题、URL 和第一句。
- en: 'The output this script generates should look like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本生成的输出应该如下所示：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '***Try This***'
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***试试看***'
- en: Enhance the script in the previous section so it can “see” the children of the
    first prepositional object and the dependent prepositional objects. For example,
    in the question, “Have you heard of fried eggs with yellow tomatoes?” it should
    extract the keyphrase “fried eggs with yellow tomatoes.”
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 增强上一部分的脚本，使它能够“看到”第一个介词宾语及其依赖的介词宾语的子元素。例如，在问题“你听说过黄番茄炒蛋吗？”中，它应该提取关键短语“黄番茄炒蛋”。
- en: '**Reacting to Images Sent in a Chat**'
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**对聊天中发送的图片作出反应**'
- en: 'In addition to text messages, users of messenger apps often post images. Other
    people usually respond to these with comments about what is shown in the picture.
    For example, a user posts a photo of grapes, to which another user leaves the
    following comment: “I love fruit. It contains lots of fiber and vitamins.” How
    can you teach a bot to do the same? One way is to generate descriptive tags for
    an image that the bot can use in processing. This is where you need an image recognition
    tool, like Clarifai, which provides built-in models trained with photos from different
    domains, such as apparel, travel, or celebrities.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 除了文本消息，消息应用的用户通常还会发布图片。其他人通常会根据图片的内容发表评论。例如，一个用户发布了一张葡萄的照片，另一个用户留下了这样的评论：“我喜欢水果，它含有丰富的纤维和维生素。”你如何教一个机器人做同样的事情呢？一种方法是为图像生成描述性标签，机器人可以利用这些标签进行处理。这时，你需要一个图像识别工具，比如Clarifai，它提供了内置的模型，这些模型通过来自不同领域（如服装、旅游或名人）的照片进行训练。
- en: Clarifai allows a bot to obtain a set of categories for a submitted photo, making
    it possible for the bot to guess what is depicted in the image. You can get useful
    categories for a photo in two steps. First, you use Clarifai’s general image recognition
    model to obtain descriptive tags (objects with probabilities) that can give you
    a general idea of what is shown in the photo. For example, the presence of the
    “no person” tag indicates that no people are in the photo.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Clarifai允许一个机器人为提交的照片获取一组类别，使得机器人能够猜测图像中展示的内容。你可以通过两步获取照片的有用类别。首先，使用Clarifai的通用图像识别模型获取描述性标签（带有概率的对象），这可以大致告诉你照片展示的是什么内容。例如，“没有人”标签的出现意味着照片中没有人。
- en: Second, after examining the tags, you can apply more specific models to the
    same photo, such as Clarifai’s Food or Apparel models. Both are trained to recognize
    food and fashion-related items, respectively. This time, you’ll obtain another,
    more granular set of tags to give you a better idea of the contents of the photo.
    For the entire list of Clarifai’s image recognition models, visit its Models page
    at *[https://www.clarifai.com/models/](https://www.clarifai.com/models/)*.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，在检查标签之后，你可以对同一张照片应用更具体的模型，比如Clarifai的食品或服装模型。这两个模型分别训练用于识别食品和时尚相关的物品。这一次，你将获得另一组更细致的标签，从而更好地了解照片的内容。欲了解Clarifai的所有图像识别模型，请访问其模型页面：[https://www.clarifai.com/models/](https://www.clarifai.com/models/)。
- en: '***Generating Descriptive Tags for Images Using Clarifai***'
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用Clarifai生成图像描述性标签***'
- en: 'Clarifai offers a Python client to interact with its recognition API. You can
    install the latest stable package using `pip`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Clarifai提供了一个Python客户端与其识别API进行交互。你可以使用`pip`安装最新的稳定包：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Before you can start using the Clarifai library, you must obtain an API key
    by creating an account and then clicking the **GET API KEY** button at *[https://www.clarifai.com/](https://www.clarifai.com/)*.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始使用Clarifai库之前，你必须通过创建一个账户并点击**GET API KEY**按钮来获取API密钥，网址为*[https://www.clarifai.com/](https://www.clarifai.com/)*。
- en: 'Once you have the key, you can test the Clarifai library. The following simple
    script passes an image to a Clarifai model and prints a list of tags expressing
    possible categories for the image:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你获得密钥，就可以测试Clarifai库。以下简单脚本将一张图片传递给Clarifai模型，并打印出一组表达图片可能类别的标签：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this example, we call Clarifai’s Predict API with the general model ➊. Clarifai
    takes only the pixels as input, so make sure you’re opening an image file in `'rb'`
    mode ➋, which opens the file in binary format for reading. The Predict API generates
    a list of descriptive tags, such as fruit, grape, health, and so on ➌, for the
    submitted photo, allowing the code to “understand” what it shows.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用Clarifai的Predict API与通用模型进行调用➊。Clarifai只接受像素作为输入，因此请确保以`'rb'`模式打开图像文件➋，该模式以二进制格式打开文件供读取。Predict
    API会为提交的照片生成一系列描述性标签，如水果、葡萄、健康等➌，让代码能够“理解”图像内容。
- en: The *grape.jpg* file used in this example contains the photo shown in [Figure
    12-5](../Text/ch12.xhtml#ch12fig05).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例中使用的*grape.jpg*文件包含了[图12-5](../Text/ch12.xhtml#ch12fig05)中显示的照片。
- en: '![image](../Images/fig12-5.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/fig12-5.jpg)'
- en: '*Figure 12-5: The photo submitted to Clarifai in the preceding script*'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-5：前述脚本中提交给Clarifai的照片*'
- en: 'The list of concepts that the script generates for the photo should look as
    follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本为照片生成的概念列表应该如下所示：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Each entry represents a category and the probability that the image fits within
    the category. Thus, the first tag in the list tells us that the submitted photo
    contains no person with a probability of 0.99\. Note that not all the tags will
    provide a direct description of the depicted content. For example, the tag “wine”
    is included here, perhaps because wine is made from grapes. The presence of indirect
    tags in the list gives your bot more options to interpret the image.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 每个条目代表一个类别，以及图像符合该类别的概率。因此，列表中的第一个标签告诉我们，提交的照片中没有人，概率为0.99。请注意，并非所有标签都会直接描述所呈现的内容。例如，标签“葡萄酒”被包含在内，可能是因为葡萄酒是由葡萄制成的。标签列表中间接标签的存在为你的机器人提供了更多的选项来解读图像。
- en: '***Using Tags to Generate Text Responses to Images***'
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***利用标签生成图像的文本回应***'
- en: 'Now that you know how to obtain descriptive tags for an image, how can you
    use these tags to respond to the image? Or how can you choose the most important
    tags from the generated list? Think about the following general considerations:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何为图像获取描述性标签，那么你如何利用这些标签来回应图像呢？或者你如何从生成的标签列表中选择最重要的标签？考虑以下一般性问题：
- en: You might want to take into account only the tags with high likelihoods. For
    that, you can choose a threshold of likelihood for the tags. For example, consider
    only the top five or 10 tags.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可能只希望考虑那些具有高概率的标签。为此，你可以为标签选择一个概率阈值。例如，只考虑前五个或十个标签。
- en: You might choose only those tags that are in the context of the current chat.
    [Chapter 11](../Text/ch11.xhtml#ch11) showed an example of how to maintain the
    context of the current chat in a Telegram bot using the `context.user_data` dictionary.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可能只会选择与当前聊天上下文相关的标签。[第11章](../Text/ch11.xhtml#ch11)展示了如何使用`context.user_data`字典在Telegram机器人中保持当前聊天的上下文。
- en: You might iterate over the generated tags, searching for a particular tag. For
    example, you might search for the tag “fruit” or “health” to determine whether
    you should continue the conversation on this topic.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可能会遍历生成的标签，搜索某个特定的标签。例如，你可能会搜索“水果”或“健康”标签，以确定是否继续在这个话题上展开对话。
- en: The bot discussed in the next section will implement the third option.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节中讨论的机器人将实现第三种选项。
- en: '**Putting All the Pieces Together in a Telegram Bot**'
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**将所有模块整合到一个Telegram机器人中**'
- en: In the rest of this chapter, we’ll build a Telegram chatbot that uses the Wikipedia
    API and the Clarifai API. This bot will respond intelligently to text and images
    of food. Refer back to [Chapter 11](../Text/ch11.xhtml#ch11) for details on how
    to create a new bot in Telegram.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，我们将构建一个使用Wikipedia API和Clarifai API的Telegram聊天机器人。这个机器人将能够智能地响应食物的文本和图像。有关如何在Telegram中创建新机器人的详细信息，请参考[第11章](../Text/ch11.xhtml#ch11)。
- en: '***Importing the Libraries***'
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***导入库***'
- en: The import section of the code must include all the libraries that we’ll use
    in the bot’s code. In this example, we include the libraries required to access
    the Telegram Bot API, Wikipedia API, Clarifai API, and spaCy.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的导入部分必须包括我们将在机器人代码中使用的所有库。在本例中，我们导入了访问Telegram Bot API、Wikipedia API、Clarifai
    API和spaCy所需的库。
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If you’ve followed the instructions provided in this chapter and [Chapter 11](../Text/ch11.xhtml#ch11),
    all of these libraries should be available on your system.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你按照本章和[第11章](../Text/ch11.xhtml#ch11)中的指示操作，所有这些库应该已经安装在你的系统中。
- en: '***Writing the Helper Functions***'
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***编写助手函数***'
- en: 'Next, we need to implement the helper functions that will be invoked from within
    the bot’s callback functions. The `keyphrase()` function takes a sentence as a
    Doc object and tries to extract the most informative word or a phrase from it,
    as discussed earlier in “[Determining What the Question Is About](../Text/ch12.xhtml#lev159)”
    on [page 171](../Text/ch12.xhtml#page_171). The following implementation uses
    the code fragments you saw in that section, adjusting them so we can use them
    within a single function:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要实现助手函数，这些函数将在机器人的回调函数中被调用。`keyphrase()`函数接收一个句子作为Doc对象，并尝试从中提取出最具信息量的单词或短语，正如我们在“[确定问题的主题是什么](../Text/ch12.xhtml#lev159)”一节中讨论的那样，在[第171页](../Text/ch12.xhtml#page_171)有详细说明。以下实现使用了你在该节中看到的代码片段，并对其进行了调整，以便在一个函数中使用：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note that the conditions are arranged in order of priority in this code. Thus,
    if the object of the preposition is found, we extract it and quit without checking
    for the other conditions. Of course, some complicated questions might meet multiple
    conditions, but checking for this would complicate the function implementation.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，代码中的条件是按优先级排序的。因此，如果找到了介词的宾语，我们就提取它并退出，而不再检查其他条件。当然，一些复杂的问题可能会符合多个条件，但如果检查这一点，会使函数实现变得更加复杂。
- en: 'Like the `keyphrase()` function, the `photo_tags()` function is supposed to
    determine the most descriptive word for a user’s input. But unlike `keyphrase()`,
    it analyzes a photo. It performs the analysis with the help of Clarifai, which
    generates a set of descriptive tags for a submitted photo. This implementation
    uses only two Clarifai models: the general model and the food model.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `keyphrase()` 函数类似，`photo_tags()` 函数旨在为用户的输入确定最具描述性的词。但与 `keyphrase()` 不同，它分析的是一张照片。它通过
    Clarifai 来帮助进行分析，Clarifai 为提交的照片生成一组描述性标签。此实现只使用了两个 Clarifai 模型：通用模型和食品模型。
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This code starts by applying the general model. If the tag `'food'` is found
    in the generated list, it applies the food model to obtain more descriptive tags
    for the food items shown in the image. This implementation will use the first
    tag only as the keyword for the search.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码首先应用通用模型。如果在生成的标签列表中找到 `'food'` 标签，它将应用食品模型来为图像中显示的食物项目获取更多描述性标签。此实现将只使用第一个标签作为搜索的关键字。
- en: 'Now that we have the keyword or keyphrase, determined either in the `keyphrase()`
    function or in the `photo_tags()` function, we need to obtain a piece of information
    that is closely related to this keyword or keyphrase. The following `wiki()` function
    does the trick:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经得到了关键字或关键短语，无论是通过 `keyphrase()` 函数还是通过 `photo_tags()` 函数，我们需要获取与该关键字或关键短语紧密相关的信息。以下
    `wiki()` 函数完成了这项工作：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The algorithm we use here searches for a sentence in the retrieved content that
    includes the keyword as the direct object.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用的算法会在检索到的内容中搜索包含关键字作为直接宾语的句子。
- en: But this simple implementation can intelligently process only a single-word
    input. When a word is submitted, the algorithm we use here just extracts the first
    sentence from the Wikipedia article found with the help of this word.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这个简单的实现只能智能处理单个词输入。当提交一个词时，我们在这里使用的算法只会从维基百科文章中提取与该词相关的第一个句子。
- en: '***Writing the Callback and main() Functions***'
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***编写回调和 main() 函数***'
- en: Next, we add the bot’s callback functions. The `start()` function simply sends
    a greeting to the user in response to the `/start` command.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加机器人的回调函数。`start()` 函数简单地在收到 `/start` 命令时向用户发送问候。
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `text_msg()` function is the callback for the bot’s user text messages handler.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`text_msg()` 函数是处理机器人用户文本消息的回调函数。'
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: First, we apply spaCy’s pipeline to the message, converting it to a Doc object.
    Then we send the Doc to the `keyphrase()` function discussed earlier to extract
    a keyword or keyphrase from the message. The returned keyword or keyphrase is
    then sent to the `wiki()` function to obtain a piece of relevant information,
    which should be a single sentence in this implementation.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将 spaCy 的管道应用于消息，将其转换为 Doc 对象。然后，我们将 Doc 发送到之前讨论过的 `keyphrase()` 函数，从消息中提取关键字或关键短语。返回的关键字或关键短语随后会传递给
    `wiki()` 函数，以获取相关的信息，这在本实现中应该是一个单独的句子。
- en: 'The `photo()` function shown in the following code is the callback for the
    bot’s handler for the photos submitted by the user:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码中显示的 `photo()` 函数是处理用户提交照片的机器人回调函数：
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The function retrieves the submitted image as a file and sends it for further
    processing to the helper functions discussed earlier in “[Writing the Helper Functions](../Text/ch12.xhtml#lev168)”
    on [page 178](../Text/ch12.xhtml#page_178).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数将提交的图像作为文件进行检索，并将其发送给前面讨论过的帮助函数进行进一步处理，相关内容可以参考“[编写帮助函数](../Text/ch12.xhtml#lev168)”在[第178页](../Text/ch12.xhtml#page_178)的内容。
- en: Finally, we add the `main()` function in which we register handlers for both
    text messages and photos.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们添加了 `main()` 函数，在其中为文本消息和照片注册处理程序。
- en: '[PRE21]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `main()` function for this Telegram bot is quite concise. We create the
    `Updater` and pass the bot’s token to it. Then we obtain the dispatcher to register
    handlers. In this example, we register just three handlers. The first one is the
    handler for the `/start` command. The second handles text messages coming from
    the user. The third one handles photos posted by the user. After registering handlers,
    we start the bot by invoking `updater.start_polling()` and then invoking `updater.idle()`
    to block the script to wait for a user message or an exit shortcut (CTRL-C).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Telegram机器人的`main()`函数非常简洁。我们创建了`Updater`并将机器人的令牌传递给它。接着我们获取调度器以注册处理程序。在这个示例中，我们注册了三个处理程序。第一个是`/start`命令的处理程序。第二个处理来自用户的文本消息。第三个处理用户发布的照片。注册处理程序后，我们通过调用`updater.start_polling()`启动机器人，然后调用`updater.idle()`来阻塞脚本，等待用户消息或退出快捷键（CTRL-C）。
- en: '***Testing the Bot***'
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***测试机器人***'
- en: Now that we’ve created the bot, it’s time to test it. You can test it either
    on a smartphone or a computer. On a smartphone, in the Telegram app search for
    your bot’s name followed by the @ sign, and then enter the `/start` command to
    start a chat. On a computer, use Telegram Web at *[https://web.telegram.org](https://web.telegram.org)*.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了机器人，是时候测试它了。你可以在智能手机或电脑上测试它。在智能手机上，在Telegram应用中搜索你的机器人名称，后跟@符号，然后输入`/start`命令开始聊天。在电脑上，使用Telegram
    Web访问* [https://web.telegram.org](https://web.telegram.org)*。
- en: After receiving a greeting from the bot, send it a simple request, such as “Tell
    me about fruit.” The bot should respond with a single sentence that it extracts
    from a relevant Wikipedia article. For simplicity, choose a sentence that uses
    the direct object from the sentence (“fruit” in this example) as the keyword.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在收到机器人的问候后，发送一个简单的请求，例如“告诉我关于水果的事。”机器人应该会回应一个从相关的维基百科文章中提取的单句。为了简化起见，选择一个使用直接宾语（此示例中的“水果”）作为关键词的句子。
- en: You can also submit a photo to check which comment the bot will give in response.
    [Figure 12-6](../Text/ch12.xhtml#ch12fig06) illustrates a screenshot of such a
    test.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以提交一张照片，检查机器人会给出什么样的评论。[图12-6](../Text/ch12.xhtml#ch12fig06)展示了这样的测试截图。
- en: '![image](../Images/fig12-6.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/fig12-6.jpg)'
- en: '*Figure 12-6: A screenshot of the bot we created*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-6：我们创建的机器人的截图*'
- en: Remember that this implementation can properly process only photos of food.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，此实现只能正确处理食物照片。
- en: '***Try This***'
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***试试这个***'
- en: Note that the bot implementation provided in the preceding section can’t generate
    smart responses to many different types of user input. The `wiki()` function we
    used can properly process only those requests for which `keyphrase()` returns
    a single word. It also works best if that keyword is a direct object. Also, the
    bot can only intelligently respond to images of food.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前一部分提供的机器人实现无法生成对许多不同类型用户输入的智能响应。我们使用的`wiki()`函数只能正确处理那些`keyphrase()`返回单一单词的请求。如果该关键词是一个直接宾语，它的效果会更好。此外，机器人只能对食物图片做出智能回应。
- en: Enhance the `wiki()` function so it can process phrases instead of only one
    word, such as “dolphins sleep.” Finding an appropriate sentence for such a phrase
    requires using dependency labels, because you’ll need to find a subject/verb pair.
    In addition, you’ll need to reduce the words to their lemmas. For example, “dolphins
    sleep” and “dolphin sleeps” should satisfy the search criteria.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 增强`wiki()`函数，使其能够处理短语，而不仅仅是一个单词，例如“海豚睡觉”。对于这样的短语，找到合适的句子需要使用依存标签，因为你需要找到一个主语/动词对。此外，你还需要将词语还原为它们的基本词形。例如，“海豚睡觉”和“海豚睡着”应该符合搜索条件。
- en: You might also want to enhance the functionality of the `photo_tags()` function
    so it can process not only food photos, but also those that show something else—for
    example, apparel.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还想增强`photo_tags()`函数的功能，使其不仅可以处理食物照片，还可以处理显示其他物品的照片——例如衣物。
- en: '**Summary**'
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter, you saw examples of how to use spaCy along with other libraries
    in Python’s AI ecosystem to build an AI-powered application that can process data
    of different types. By using the Wikipedia and Clarifai Python APIs, we designed
    a chatbot that could react to images and pull text from Wikipedia, techniques
    that make the bot a smarter interlocutor.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你看到了如何将spaCy与Python的其他库结合使用，构建一个能够处理不同类型数据的AI应用程序。通过使用Wikipedia和Clarifai的Python
    API，我们设计了一个可以对图片做出反应并从维基百科中提取文本的聊天机器人，这些技术使得机器人成为一个更智能的对话者。
- en: After reading this book, you might want to expand and improve on what you’ve
    learned. The most natural way to enhance your knowledge is to continue to experiment
    with chatbots. Start by building a Telegram script with Python using the instructions
    provided in [Chapter 11](../Text/ch11.xhtml#ch11); next, enhance its functionality
    using instructions provided in this chapter. Then work on improving the algorithms
    you learned in this book to make them more suitable for your use cases.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读完这本书后，你可能想要扩展和提升你所学的知识。最自然的方式是继续通过与聊天机器人进行实验来增强你的知识。从使用[第11章](../Text/ch11.xhtml#ch11)中提供的说明，使用Python构建一个Telegram脚本开始；接下来，按照本章提供的说明增强其功能。然后，继续改进你在本书中学到的算法，使它们更加适合你的应用场景。
