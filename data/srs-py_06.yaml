- en: '**6**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**6**'
- en: '**UNIT TESTING**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**单元测试**'
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: Many find unit testing to be arduous and time-consuming, and some people and
    projects have no testing policy. This chapter assumes that you see the wisdom
    of unit testing! Writing code that is not tested is fundamentally useless, as
    there’s no way to conclusively prove that it works. If you need convincing, I
    suggest you start by reading about the benefits of test-driven development.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 很多人觉得单元测试既繁琐又耗时，一些人和项目甚至没有测试政策。本章假设你理解单元测试的重要性！编写未经测试的代码是毫无意义的，因为无法确凿地证明它是否有效。如果你还需要说服自己，我建议你先阅读关于测试驱动开发的好处。
- en: In this chapter you’ll learn about the Python tools you can use to construct
    a comprehensive suite of tests that will make testing simpler and more automated.
    We’ll talk about how you can use tools to make your software rock solid and regression-free.
    We’ll cover creating reusable test objects, running tests in parallel, revealing
    untested code, and using virtual environments to make sure your tests are clean,
    as well as some other good-practice methods and ideas.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍你可以用来构建完整测试套件的 Python 工具，从而使测试变得更简单、更自动化。我们将讨论如何使用工具确保你的软件稳定无回归。我们将涵盖创建可重用的测试对象、并行运行测试、揭示未测试的代码，以及使用虚拟环境确保测试清洁的内容，还会涉及一些其他的最佳实践方法和思路。
- en: '**The Basics of Testing**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**测试基础**'
- en: Writing and running unit tests is uncomplicated in Python. The process is not
    intrusive or disruptive, and unit testing will greatly help you and other developers
    in maintaining your software. Here I’ll discuss some of the absolute basics of
    testing that will make things easier for you.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，编写和运行单元测试并不复杂。这个过程既不干扰也不破坏现有的代码，单元测试将大大帮助你和其他开发人员维护软件。在这里，我将讨论一些测试的基本知识，以帮助你更轻松地进行测试。
- en: '***Some Simple Tests***'
  id: totrans-7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***一些简单的测试***'
- en: First, you should store tests inside a `tests` submodule of the application
    or library they apply to. Doing so will allow you to ship the tests as part of
    your module so that they can be run or reused by anyone—even after your software
    is installed—without necessarily using the source package. Making the tests a
    submodule of your main module also prevents them from being installed by mistake
    in a top-level `tests` module.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你应该将测试保存在应用程序或库的 `tests` 子模块中。这样做可以将测试作为模块的一部分一起发布，以便任何人都能运行或重用它们——即使在你的软件安装后，也不一定需要使用源代码包。将测试作为主模块的子模块，也可以防止它们被误安装在顶级的
    `tests` 模块中。
- en: Using a hierarchy in your test tree that mimics the hierarchy of your module
    tree will make the tests more manageable. This means that the tests covering the
    code of *mylib/foobar.py* should be stored inside *mylib/tests/test_foobar.py*.
    Consistent nomenclature makes things simpler when you’re looking for the tests
    related to a particular file. [Listing 6-1](ch06.xhtml#ch6list1) shows the simplest
    unit test you can write.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的测试树中使用与模块树相同的层次结构，将使得测试更加易于管理。这意味着，涵盖 *mylib/foobar.py* 代码的测试应该保存在 *mylib/tests/test_foobar.py*
    中。统一的命名法使得查找与特定文件相关的测试变得更简单。[清单 6-1](ch06.xhtml#ch6list1) 显示了你可以编写的最简单的单元测试。
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 6-1: A really simple test in test_true.py*'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-1：在 test_true.py 中的一个非常简单的测试*'
- en: This will simply assert that the behavior of the program is what you expect.
    To run this test, you need to load the *test_true.py* file and run the `test_true()`
    function defined within.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这将简单地断言程序的行为是否符合预期。要运行此测试，你需要加载 *test_true.py* 文件并运行其中定义的 `test_true()` 函数。
- en: However, writing and running an individual test for each of your test files
    and functions would be a pain. For small projects with simple usage, the `pytest`
    package comes to the rescue—once installed via `pip`, pytest provides the `pytest`
    command, which loads every file whose name starts with *test_* and then executes
    all functions within that start with `test_`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为你的每个测试文件和函数编写和运行单独的测试会非常麻烦。对于使用简单的小型项目，`pytest` 包就能派上用场——通过 `pip` 安装后，pytest
    提供了 `pytest` 命令，它会加载所有文件名以 *test_* 开头的文件，并执行其中所有以 `test_` 开头的函数。
- en: 'With just the *test_true.py* file in our source tree, running `pytest` gives
    us the following output:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 只要我们的源代码树中有 *test_true.py* 文件，运行 `pytest` 就会给出如下输出：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `-v` option tells `pytest` to be verbose and print the name of each test
    run on a separate line. If a test fails, the output changes to indicate the failure,
    accompanied by the whole traceback.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`-v`选项告诉`pytest`以详细模式运行，并在单独的行上打印每个测试的名称。如果测试失败，输出会变更，显示失败信息，并伴随完整的回溯。'
- en: Let’s add a failing test this time, as shown in [Listing 6-2](ch06.xhtml#ch6list2).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们添加一个失败的测试，如[清单 6-2](ch06.xhtml#ch6list2)所示。
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 6-2: A failing test in test_true.py*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-2：test_true.py中的失败测试*'
- en: 'If we run the test file again, here’s what happens:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次运行测试文件，结果如下：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: A test fails as soon as an `AssertionError` exception is raised; our `assert`
    test will raise an `AssertionError` when its argument is evaluated to something
    false (`False`, `None`, 0, etc.). If any other exception is raised, the test also
    errors out.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦抛出`AssertionError`异常，测试就会失败；当`assert`测试的参数被评估为假值（`False`、`None`、0等）时，它会抛出`AssertionError`异常。如果抛出其他异常，测试也会报错。
- en: Simple, isn’t it? While simplistic, a lot of small projects use this approach
    and it works very well. Those projects require no tools or libraries other than
    pytest and thus can rely on simple `assert` tests.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 很简单，不是吗？虽然简单，但很多小项目都使用这种方法，而且效果非常好。这些项目除了`pytest`外不需要任何工具或库，因此可以依赖简单的`assert`测试。
- en: 'As you start to write more sophisticated tests, pytest will help you understand
    what’s wrong in your failing tests. Imagine the following test:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始编写更复杂的测试时，`pytest`将帮助你理解失败测试中的问题。想象一下以下测试：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When `pytest` is run, it gives the following output:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`pytest`时，它会显示如下输出：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This tells us that `a` and `b` are different and that this test does not pass.
    It also tells us exactly how they are different, making it easy to fix the test
    or code.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们`a`和`b`是不同的，并且该测试没有通过。它还告诉我们它们具体的不同之处，使得修复测试或代码变得容易。
- en: '***Skipping Tests***'
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***跳过测试***'
- en: If a test cannot be run, you will probably want to skip that test—for example,
    you may wish to run a test conditionally based on the presence or absence of a
    particular library. To that end, you can use the `pytest.skip()` function, which
    will mark the test as skipped and move on to the next one. The `pytest.mark.skip`
    decorator skips the decorated test function unconditionally, so you’ll use it
    when a test always needs to be skipped. [Listing 6-3](ch06.xhtml#ch6list3) shows
    how to skip a test using these methods.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个测试无法运行，你可能想要跳过该测试——例如，你可能希望根据某个特定库的存在与否来有条件地运行测试。为此，你可以使用`pytest.skip()`函数，它会将测试标记为跳过，并继续执行下一个测试。`pytest.mark.skip`装饰器会无条件跳过被装饰的测试函数，因此当某个测试始终需要跳过时，你会使用它。[清单
    6-3](ch06.xhtml#ch6list3)展示了如何使用这些方法跳过测试。
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 6-3: Skipping tests*'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-3：跳过测试*'
- en: 'When executed, this test file will output the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 执行时，这个测试文件将输出以下内容：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The output of the test run in [Listing 6-3](ch06.xhtml#ch6list3) indicates that,
    in this case, all the tests have been skipped. This information allows you to
    ensure you didn’t accidentally skip a test you expected to run.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单 6-3](ch06.xhtml#ch6list3)中的测试运行输出表明，在这种情况下，所有测试都被跳过了。这些信息让你可以确保没有意外跳过你期望运行的测试。
- en: '***Running Particular Tests***'
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行特定测试***'
- en: When using `pytest`, you often want to run only a particular subset of your
    tests. You can select which tests you want to run by passing their directory or
    files as an argument to the `pytest` command line. For example, calling `pytest
    test_one.py` will only run the *test_one.py* test. Pytest also accepts a directory
    as argument, and in that case, it will recursively scan the directory and run
    any file that matches the *test_*.py* pattern.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`pytest`时，你通常只想运行某一特定子集的测试。你可以通过将目录或文件作为参数传递给`pytest`命令行来选择运行的测试。例如，调用`pytest
    test_one.py`将只运行*test_one.py*测试。`pytest`也接受目录作为参数，在这种情况下，它会递归扫描该目录并运行任何匹配*test_*.py*模式的文件。
- en: You can also add a filter with the `-k` argument on the command line in order
    to execute only the test matching a name, as shown in [Listing 6-4](ch06.xhtml#ch6list4).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在命令行中使用`-k`参数添加筛选器，以便仅执行与某个名称匹配的测试，如[清单 6-4](ch06.xhtml#ch6list4)所示。
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 6-4: Filtering tests run by name*'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-4：按名称筛选运行的测试*'
- en: 'Names are not always the best way to filter which tests will run. Commonly,
    a developer would group tests by functionalities or types instead. Pytest provides
    a dynamic marking system that allows you to mark tests with a keyword that can
    be used as a filter. To mark tests in this way, use the `-m` option. If we set
    up a couple of tests like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 名称并不总是过滤将要运行的测试的最佳方式。通常，开发人员会根据功能或类型将测试分组。Pytest提供了一个动态标记系统，允许你使用关键字标记测试，并可以用作过滤器。要以这种方式标记测试，请使用`-m`选项。如果我们像这样设置几个测试：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'we can use the `-m` argument with `pytest` to run only one of those tests:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`-m`参数和`pytest`只运行其中一个测试：
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `-m` marker accepts more complex queries, so we can also run all tests
    that are *not* marked:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`-m`标记接受更复杂的查询，因此我们也可以运行所有*未*标记的测试：'
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here pytest executed every test that was not marked as `dicttest`—in this case,
    the `test_something_else` test, which failed. The remaining marked test, `test_something`,
    was not executed and so is listed as `deselected`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这里pytest执行了所有未标记为`dicttest`的测试——在这种情况下，`test_something_else`测试失败了。剩下的标记测试`test_something`没有执行，因此被列为`deselected`。
- en: Pytest accepts complex expressions composed of the `or`, `and`, and `not` keywords,
    allowing you to do more advanced filtering.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Pytest接受由`or`、`and`和`not`关键字组成的复杂表达式，允许你进行更高级的过滤。
- en: '***Running Tests in Parallel***'
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***并行运行测试***'
- en: Test suites can take a long time to run. It’s not uncommon for a full suite
    of unit tests to take tens of minutes to run in large software projects. By default,
    pytest runs all tests serially, in an undefined order. Since most computers have
    several CPUs, you can usually speed things up if you split the list of tests and
    run them on multiple CPUs.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 测试套件可能需要很长时间才能运行。在大型软件项目中，完整的单元测试套件通常需要几十分钟才能运行。默认情况下，pytest按顺序执行所有测试，顺序是未定义的。由于大多数计算机都有多个CPU，你通常可以通过将测试列表拆分并在多个CPU上运行它们来加速测试过程。
- en: To handle this approach, pytest provides the plugin `pytest-xdist`, which you
    can install with `pip`. This plugin extends the pytest command line with the `--numprocesses`
    argument (shortened as `-n`), which accepts as its argument the number of CPUs
    to use. Running `pytest -n 4` would run your test suite using four parallel processes,
    balancing the load across the available CPUs.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理这种方法，pytest提供了插件`pytest-xdist`，你可以通过`pip`安装此插件。此插件通过`--numprocesses`参数（缩写为`-n`）扩展了pytest命令行，该参数的值为要使用的CPU数量。运行`pytest
    -n 4`将使用四个并行进程运行你的测试套件，在可用的CPU之间平衡负载。
- en: Because the number of CPUs can change from one computer to another, the plugin
    also accepts the `auto` keyword as a value. In this case, it will probe the machine
    to retrieve the number of CPUs available and start this number of processes.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 因为CPU的数量可能因计算机而异，所以该插件还接受`auto`关键字作为值。在这种情况下，它会探测机器以获取可用的CPU数量，并启动相应数量的进程。
- en: '***Creating Objects Used in Tests with Fixtures***'
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用Fixtures创建用于测试的对象***'
- en: In unit testing, you’ll often need to execute a set of common instructions before
    and after running a test, and those instructions will use certain components.
    For example, you might need an object that represents the configuration state
    of your application, and you’ll likely want that object to be initialized before
    each test, then reset to its default values when the test is achieved. Similarly,
    if your test relies on the temporary creation of a file, the file must be created
    before the test starts and deleted once the test is done. These components, known
    as *fixtures*, are set up before a test and cleaned up after the test has finished.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在单元测试中，你通常需要在运行测试前后执行一组常见的指令，这些指令将使用某些组件。例如，你可能需要一个表示应用程序配置状态的对象，并且你可能希望在每个测试之前初始化该对象，然后在测试完成后将其重置为默认值。同样，如果你的测试依赖于临时创建一个文件，那么该文件必须在测试开始之前创建，并在测试完成后删除。这些组件被称为*fixtures*，在测试之前进行设置，并在测试完成后进行清理。
- en: With pytest, fixtures are defined as simple functions. The fixture function
    should return the desired object(s) so that a test using that fixture can use
    that object.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在pytest中，fixture被定义为简单的函数。fixture函数应返回所需的对象，以便使用该fixture的测试可以使用该对象。
- en: 'Here’s a simple fixture:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的fixture：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The database fixture is automatically used by any test that has `database` in
    its argument list. The `test_insert()` function will receive the result of the
    `database()` function as its first argument and use that result as it wants. When
    we use a fixture this way, we don’t need to repeat the database initialization
    code several times.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库fixture会自动被任何在其参数列表中包含`database`的测试使用。`test_insert()`函数将接收`database()`函数的结果作为第一个参数，并根据需要使用该结果。当我们以这种方式使用fixture时，我们不需要重复多次数据库初始化代码。
- en: Another common feature of code testing is tearing down after a test has used
    a fixture. For example, you may need to close a database connection. Implementing
    the fixture as a generator allows us to add teardown functionality, as shown in
    [Listing 6-5](ch06.xhtml#ch6list5).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 代码测试的另一个常见功能是，在测试使用完fixture后进行清理。例如，你可能需要关闭数据库连接。将fixture实现为生成器允许我们添加清理功能，如[示例6-5](ch06.xhtml#ch6list5)所示。
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 6-5: Teardown functionality*'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例6-5：清理功能*'
- en: Because we used the `yield` keyword and made `database` a generator, the code
    after the `yield` statement runs when the test is done. That code will close the
    database connection at the end of the test.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们使用了`yield`关键字并使`database`成为一个生成器，所以`yield`语句之后的代码将在测试完成后运行。该代码会在测试结束时关闭数据库连接。
- en: 'However, closing a database connection for each test might impose an unnecessary
    runtime cost, as tests may be able to reuse that same connection. In that case,
    you can pass the `scope` argument to the fixture decorator, specifying the scope
    of the fixture:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为每个测试关闭数据库连接可能会增加不必要的运行时开销，因为测试可能能够重用相同的连接。在这种情况下，你可以通过将`scope`参数传递给装饰器来指定fixture的作用范围：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: By specifying the `scope="module"` parameter, you initialize the fixture once
    for the whole module, and the same database connection will be passed to all test
    functions requesting a database connection.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 通过指定`scope="module"`参数，你可以在整个模块中初始化fixture一次，所有请求数据库连接的测试函数都会接收到相同的数据库连接。
- en: 'Finally, you can run some common code before and after your tests by marking
    fixtures as *automatically used* with the `autouse` keyword, rather than specifying
    them as an argument for each of the test functions. Specifying the `autouse=True`
    keyword argument to the `pytest.fixture()` function will make sure the fixture
    is called before running any test in the module or class it is defined in, as
    in this example:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以在测试前后运行一些公共代码，通过使用`autouse`关键字将fixtures标记为*自动使用*，而不是将其作为每个测试函数的参数来指定。向`pytest.fixture()`函数指定`autouse=True`关键字参数，可以确保在模块或类中定义的任何测试运行之前，都会调用该fixture，正如以下示例所示：
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Such automatically enabled features are handy, but make sure not to abuse fixtures:
    they are run before each and every test covered by their scope, so they can slow
    down a test run significantly.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这些自动启用的功能很方便，但要确保不要滥用fixtures：它们会在其作用范围内的每个测试之前运行，因此可能会显著减慢测试运行速度。
- en: '***Running Test Scenarios***'
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行测试场景***'
- en: When unit testing, you may want to run the same error-handling test with several
    different objects that trigger that error, or you may want to run an entire test
    suite against different drivers.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在单元测试时，你可能希望使用几个不同的对象来运行相同的错误处理测试，这些对象会触发该错误，或者你可能希望在不同的驱动程序上运行整个测试套件。
- en: We relied heavily on this latter approach when developing *Gnocchi*, a time
    series database. Gnocchi provides an abstract class that we call the *storage
    API*. Any Python class can implement this abstract base and register itself to
    become a driver. The software loads the configured storage driver when required
    and uses the implemented storage API to store or retrieve data. In this case,
    we need a class of unit tests that runs against each driver—thus running against
    each implementation of this storage API—to be sure all drivers conform to what
    the callers expect.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发*Gnocchi*（一个时间序列数据库）时，我们在很大程度上依赖了这种后者的方法。Gnocchi提供了一个我们称之为*存储API*的抽象类。任何Python类都可以实现这个抽象基类并注册自己成为一个驱动程序。软件在需要时加载配置的存储驱动程序，并使用实现的存储API来存储或检索数据。在这种情况下，我们需要一个单元测试类，它可以在每个驱动程序上运行——从而对每个存储API的实现进行测试——以确保所有驱动程序符合调用者的期望。
- en: 'An easy way to achieve this is by using *parameterized fixtures*, which will
    run all the tests that use them several times, once for each of the defined parameters.
    [Listing 6-6](ch06.xhtml#ch6list6) shows an example of using parameterized fixtures
    to run a single test twice with different parameters: once for `mysql` and once
    for `postgresql`.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一点的简单方法是使用 *参数化 fixtures*，这些 fixtures 会多次运行所有使用它们的测试，每次使用不同的定义参数。[清单 6-6](ch06.xhtml#ch6list6)
    展示了一个使用参数化 fixtures 的示例，用不同的参数运行单个测试两次：一次用于 `mysql`，一次用于 `postgresql`。
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 6-6: Running a test using parameterized fixtures*'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-6：使用参数化 fixtures 运行测试*'
- en: 'In [Listing 6-6](ch06.xhtml#ch6list6), the `driver` fixture is parameterized
    with two different values, each the name of a database driver that is supported
    by the application. When `test_insert` is run, it is actually run twice: once
    with a MySQL database connection and once with a PostgreSQL database connection.
    This allows us to easily reuse the same test with different scenarios, without
    adding many lines of code.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单 6-6](ch06.xhtml#ch6list6)中，`driver` fixture 使用了两个不同的值进行参数化，每个值都是应用程序支持的数据库驱动的名称。当运行
    `test_insert` 时，它实际上会运行两次：一次使用 MySQL 数据库连接，另一次使用 PostgreSQL 数据库连接。这使我们能够在不同的场景下轻松重用相同的测试，而无需添加许多代码行。
- en: '***Controlled Tests Using Mocking***'
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用模拟控制测试***'
- en: Mock objects are simulated objects that mimic the behavior of real application
    objects, but in particular and controlled ways. These are especially useful in
    creating environments that describe precisely the conditions for which you would
    like to test code. You can replace all objects but one with mock objects to isolate
    the behavior of your focus object and create an enviroment for testing your code.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟对象是模拟真实应用对象行为的对象，尤其是在特定和受控的方式下。这些对象在创建精确描述你希望测试代码的条件的环境时特别有用。你可以将所有对象替换为模拟对象，除了一个，用以隔离你关注对象的行为并为测试代码创建一个环境。
- en: One use case is in writing an HTTP client, since it is likely impossible (or
    at least extremely complicated) to spawn the HTTP server and test it through all
    scenarios to return every possible value. HTTP clients are especially difficult
    to test for all failure scenarios.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一个使用场景是在编写 HTTP 客户端时，因为可能不可能（或至少非常复杂）启动 HTTP 服务器并通过所有场景进行测试以返回每个可能的值。HTTP 客户端在所有故障场景下的测试尤其困难。
- en: 'The standard library for creating mock objects in Python is `mock`. Starting
    with Python 3.3, `mock` has been merged into the Python Standard Library as `unittest.mock`.
    You can, therefore, use a snippet like the following to maintain backward compatibility
    between Python 3.3 and earlier versions:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中用于创建模拟对象的标准库是 `mock`。从 Python 3.3 开始，`mock` 已经合并到 Python 标准库中，成为 `unittest.mock`。因此，你可以使用如下片段来保持
    Python 3.3 及更早版本之间的向后兼容性：
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `mock` library is pretty simple to use. Any attribute accessed on a `mock.Mock`
    object is dynamically created at runtime. Any value can be set to such an attribute.
    [Listing 6-7](ch06.xhtml#ch6list7) shows `mock` being used to create a fake object
    with a fake attribute.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`mock` 库使用起来相当简单。任何访问 `mock.Mock` 对象的属性都会在运行时动态创建。可以将任何值设置为这样的属性。[清单 6-7](ch06.xhtml#ch6list7)
    显示了如何使用 `mock` 创建一个带有假属性的假对象。'
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 6-7: Accessing the mock.Mock attribute*'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-7：访问 mock.Mock 属性*'
- en: You can also dynamically create a method on a malleable object, as in [Listing
    6-8](ch06.xhtml#ch6list8) where we create a fake method that always returns 42
    and accepts anything as an argument.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在一个可塑对象上动态创建方法，如[清单 6-8](ch06.xhtml#ch6list8)中所示，我们创建了一个始终返回 42 并接受任何参数的假方法。
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 6-8: Creating methods on a mock.Mock object*'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-8：在 mock.Mock 对象上创建方法*'
- en: In just a few lines, your `mock.Mock` object now has a `some_method()` method
    that returns 42\. It accepts any kind of argument, and there is no check on what
    the values are—yet.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 只需几行代码，你的 `mock.Mock` 对象现在就有了一个返回 42 的 `some_method()` 方法。它接受任何类型的参数，而且目前没有检查这些值是什么。
- en: Dynamically created methods can also have (intentional) side effects. Rather
    than being boilerplate methods that just return a value, they can be defined to
    execute useful code.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 动态创建的方法也可以具有（故意的）副作用。它们不仅仅是返回值的模板方法，而是可以定义执行有用代码的功能。
- en: '[Listing 6-9](ch06.xhtml#ch6list9) creates a fake method that has the side
    effect of printing the "`hello world`" string.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 6-9](ch06.xhtml#ch6list9) 创建了一个假的方法，该方法具有打印 "`hello world`" 字符串的副作用。'
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 6-9: Creating methods on a mock.Mock object with side effects*'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-9：在 mock.Mock 对象上创建带副作用的方法*'
- en: We assign an entire function to the `some_method` attribute ➊. This technique
    allows us to implement more complex scenarios in a test because we can plug any
    code needed for testing into a mock object. We then just need to pass this mock
    object to whichever function expects it.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将整个函数分配给 `some_method` 属性 ➊。这种技术使我们能够在测试中实现更复杂的场景，因为我们可以将任何需要的代码插入到模拟对象中进行测试。然后，只需将该模拟对象传递给需要它的函数。
- en: The `call_count` attribute ➋ is a simple way of checking the number of times
    a method has been called.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`call_count` 属性 ➋ 是检查方法被调用次数的简单方法。'
- en: 'The `mock` library uses the action/assertion pattern: this means that once
    your test has run, it’s up to you to check that the actions you are mocking were
    correctly executed. [Listing 6-10](ch06.xhtml#ch6list10) applies the `assert()`
    method to our mock objects to perform these checks.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`mock` 库采用了动作/断言模式：这意味着在测试运行完毕后，由你来检查你所模拟的动作是否被正确执行。[清单 6-10](ch06.xhtml#ch6list10)
    使用 `assert()` 方法对我们的模拟对象进行这些检查。'
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 6-10: Checking method calls*'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-10：检查方法调用*'
- en: We create a method with the arguments `foo` and `bar` to stand in as our tests
    by calling the method ➊. The usual way to check calls to a mock object is to use
    the `assert_called()` methods, such as `assert_called_once_with()` ➋. To these
    methods, you need to pass the values that you expect callers to use when calling
    your mock method. If the values passed are not the ones being used, then `mock`
    raises an `AssertionError`. If you don’t know what arguments may be passed, you
    can use `mock.ANY` as a value ➌; that will match any argument passed to your mock
    method.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个带有参数 `foo` 和 `bar` 的方法，通过调用该方法 ➊ 来作为我们的测试。检查对模拟对象的调用的常用方法是使用 `assert_called()`
    方法，如 `assert_called_once_with()` ➋。对于这些方法，需要传递你期望调用者在调用模拟方法时使用的值。如果传递的值与预期不符，`mock`
    会抛出 `AssertionError`。如果你不知道可能传递什么参数，可以使用 `mock.ANY` 作为值 ➌；这将匹配传递给模拟方法的任何参数。
- en: Th `mock` library can also be used to patch some function, method, or object
    from an external module. In [Listing 6-11](ch06.xhtml#ch6list11), we replace the
    `os.unlink()` function with a fake function we provide.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`mock` 库还可以用于修补外部模块中的某些函数、方法或对象。在 [清单 6-11](ch06.xhtml#ch6list11) 中，我们将 `os.unlink()`
    函数替换为我们提供的假函数。'
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 6-11: Using mock.patch*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-11：使用 mock.patch*'
- en: When used as a context manager, `mock.patch()` replaces the target function
    with the function we provide so the code executed inside the context uses that
    patched method. With the `mock.patch()` method, it’s possible to change any part
    of an external piece of code, making it behave in a way that lets you test all
    conditions in your application, as shown in [Listing 6-12](ch06.xhtml#ch6list12).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `mock.patch()` 作为上下文管理器使用时，它会将目标函数替换为我们提供的函数，因此在上下文中执行的代码将使用该修补方法。使用 `mock.patch()`
    方法，可以更改外部代码的任何部分，使其表现得符合你的测试需求，从而测试应用中的所有条件，如 [清单 6-12](ch06.xhtml#ch6list12)
    所示。
- en: '[PRE23]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 6-12: Using mock.patch() to test a set of behaviors*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-12：使用 mock.patch() 测试一组行为*'
- en: '[Listing 6-12](ch06.xhtml#ch6list12) implements a test suite that searches
    for all instances of the string “Python is a programming language” on the *[http://python.org/](http://python.org/)*
    web page ➊. There is no way to test negative scenarios (where this sentence is
    not on the web page) without modifying the page itself—something we’re not able
    to do, obviously. In this case, we’re using `mock` to cheat and change the behavior
    of the request so it returns a mocked reply with a fake page that doesn’t contain
    that string. This allows us to test the negative scenario in which *[http://python.org/](http://python.org/)*
    does not contain this sentence, making sure the program handles that case correctly.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 6-12](ch06.xhtml#ch6list12) 实现了一个测试套件，用于在 *[http://python.org/](http://python.org/)*
    网页中搜索所有出现的字符串“Python is a programming language” ➊。无法测试负面场景（即该句子不在网页上）——显然我们无法修改网页本身。在这种情况下，我们使用
    `mock` 来“作弊”并改变请求的行为，使其返回一个模拟的回复，其中没有该字符串。这使我们能够测试该负面场景，即 *[http://python.org/](http://python.org/)*
    网页中不包含该句子，从而确保程序能够正确处理这种情况。'
- en: This example uses the decorator version of `mock.patch()` ➋. Using the decorator
    does not change the mocking behavior, but it is simpler when you need to use mocking
    within the context of an entire test function.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子使用了 `mock.patch()` 的装饰器版本 ➋。使用装饰器不会改变模拟的行为，但当你需要在整个测试函数的上下文中使用模拟时，它更简单。
- en: Using mocking, we can simulate any problem, such as a web server returning a
    404 error, an I/O error, or a network latency issue. We can make sure code returns
    the correct values or raises the correct exception in every case, ensuring our
    code always behaves as expected.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模拟（mocking），我们可以模拟任何问题，比如Web服务器返回404错误、I/O错误或网络延迟问题。我们可以确保代码在每种情况下都返回正确的值或抛出正确的异常，确保我们的代码始终按预期行为运行。
- en: '***Revealing Untested Code with coverage***'
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***揭示未测试的代码与覆盖率***'
- en: A great complement to unit testing, the `coverage` tool identifies whether any
    of your code has been missed during testing. It uses code analysis tools and tracing
    hooks to determine which lines of your code have been executed; when used during
    a unit test run, it can show you which parts of your codebase have been crossed
    over and which parts have not. Writing tests is useful, but having a way to know
    what part of your code you may have missed during the testing process is the cherry
    on the cake.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`coverage`工具是单元测试的一个极好补充，它能识别出在测试过程中是否漏掉了某些代码。它使用代码分析工具和追踪钩子来确定哪些代码行已经执行；在单元测试运行时，它能显示出代码库的哪些部分已被覆盖，哪些部分没有。编写测试是有用的，但知道在测试过程中可能遗漏了哪些代码是锦上添花。'
- en: Install the `coverage` Python module on your system via `pip` to have access
    to the `coverage` program command from your shell.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`pip`安装`coverage` Python模块，即可在终端中访问`coverage`命令。
- en: '**NOTE**'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The command may also be named python-coverage, if you install coverage through
    your operating system installation software. This is the case on Debian, for example.*'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你通过操作系统的软件包管理工具安装`coverage`，该命令也可能被命名为python-coverage。例如，在Debian上就是如此。*'
- en: Using `coverage` in stand-alone mode is straightforward. It can show you parts
    of your programs that are never run and which code might be “dead code,” that
    is, code that could be removed without modifying the normal workflow of the program.
    All the test tools we’ve talked about so far in this chapter are integrated with
    `coverage`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`coverage`独立模式非常简单。它能显示程序中从未执行过的部分，以及哪些代码可能是“死代码”，即那些可以删除而不会影响程序正常工作流的代码。我们在本章讨论的所有测试工具都与`coverage`集成。
- en: When using `pytest`, just install the `pytest-cov` plugin via `pip install pytest-pycov`
    and add a few option switches to generate a detailed code coverage output, as
    shown in [Listing 6-13](ch06.xhtml#ch6list13).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`pytest`时，只需通过`pip install pytest-pycov`安装`pytest-cov`插件，并添加一些选项开关来生成详细的代码覆盖率输出，如[清单6-13](ch06.xhtml#ch6list13)所示。
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Listing 6-13: Using coverage with pytest*'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单6-13：在pytest中使用coverage*'
- en: The `--cov` option enables the coverage report at the end of the test run. You
    need to pass the package name as an argument for the plugin to filter the coverage
    report properly. The output includes the lines of code that were not run and therefore
    have no tests. All you need to do now is spawn your favorite text editor and start
    writing tests for that code.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`--cov`选项会在测试运行结束时启用覆盖率报告。你需要传递包名称作为参数，以便插件正确地过滤覆盖率报告。输出包括那些未执行的代码行，因此没有测试。现在你只需打开你最喜欢的文本编辑器，开始为那些代码编写测试。'
- en: However, `coverage` goes one better, allowing you to generate clear HTML reports.
    Simply add the `--cov-report=html` flag, and the *htmlcov* directory from which
    you ran the command will be populated with HTML pages. Each page will show you
    which parts of your source code were or were not run.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`coverage`更进一步，允许你生成清晰的HTML报告。只需添加`--cov-report=html`标志，然后运行该命令的*htmlcov*目录将会生成HTML页面。每个页面将显示你源代码中的哪些部分已被执行，哪些没有。
- en: If you want to be *that* person, you can use the option `--cover-fail-under=COVER_MIN_PERCENTAGE`,
    which will make the test suite fail if a minimum percentage of the code is not
    executed when the test suite is run. While having a good coverage percentage is
    a decent goal, and while the tool is useful to gain insight into the state of
    your test coverage, defining an arbitrary percentage value does not provide much
    insight. [Figure 6-1](ch06.xhtml#ch6fig1) shows an example of a coverage report
    with the percentage at the top.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想成为*那种*人，可以使用选项`--cover-fail-under=COVER_MIN_PERCENTAGE`，当测试套件运行时，如果代码的最低百分比未被执行，测试套件将失败。虽然有一个良好的覆盖率百分比是一个不错的目标，并且该工具有助于深入了解测试覆盖率的状态，但定义一个任意的百分比值并不能提供太多见解。[图6-1](ch06.xhtml#ch6fig1)展示了一个覆盖率报告的示例，顶部显示了百分比。
- en: For example, a code coverage score of 100 percent is a respectable goal, but
    it does not necessarily mean the code is entirely tested and you can rest. It
    only proves that your whole code path has been run; there is no indication that
    every possible condition has been tested.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，100% 的代码覆盖率是一个值得尊敬的目标，但这并不一定意味着代码已经完全测试过，你可以松一口气。它仅仅证明了你的整个代码路径已经运行过；并没有说明每一个可能的条件都已经被测试过。
- en: You should use coverage information to consolidate your test suite and add tests
    for any code that is currently not being run. This facilitates later project maintenance
    and increases your code’s overall quality.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该使用覆盖率信息来巩固你的测试套件，并为当前没有运行的代码添加测试。这有助于后续的项目维护，并提高代码的整体质量。
- en: '![image](../images/f06-01.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f06-01.jpg)'
- en: '*Figure 6-1: Coverage of ceilometer.publisher*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-1：ceilometer.publisher 的覆盖率*'
- en: '**Virtual Environments**'
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**虚拟环境**'
- en: 'Earlier we mentioned the danger that your tests may not capture the absence
    of dependencies. Any application of significant size inevitably depends on external
    libraries to provide features the application needs, but there are many ways external
    libraries might cause issues on your operating system. Here are a few:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到过一个风险，那就是你的测试可能无法捕捉到依赖缺失的问题。任何较大的应用程序不可避免地依赖于外部库来提供应用程序所需的功能，但外部库可能在你的操作系统上引发很多问题。以下是其中一些：
- en: Your system does not have the library you need packaged.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的系统没有打包你需要的库。
- en: Your system does not have the right *version* of the library you need packaged.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的系统没有打包你所需的正确 *版本* 的库。
- en: You need two different versions of the same library for two different applications.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要两个不同版本的相同库来支持两个不同的应用程序。
- en: These problems can happen when you first deploy your application or later on,
    while it’s running. Upgrading a Python library installed via your system manager
    might break your application in a snap without warning, for reasons as simple
    as an API change in the library being used by the application.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题可能发生在你首次部署应用程序时，或者稍后在应用程序运行过程中。通过系统管理器升级一个 Python 库，可能会在没有任何警告的情况下迅速破坏你的应用程序，原因可能只是库的
    API 发生了变化，而该库正被应用程序使用。
- en: The solution is for each application to use a library directory that contains
    all the application’s dependencies. This directory is then used to load the needed
    Python modules rather than the system-installed ones.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是让每个应用程序使用一个包含所有应用程序依赖项的库目录。然后，该目录用于加载所需的 Python 模块，而不是系统安装的模块。
- en: Such a directory is known as a *virtual environment*.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的目录被称为*虚拟环境*。
- en: '***Setting Up a Virtual Environment***'
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***设置虚拟环境***'
- en: The tool `virtualenv` handles virtual environments automatically for you. Until
    Python 3.2, you’ll find it in the `virtualenv` package that you can install using
    `pip install virtualenv`. If you use Python 3.3 or later, it’s available directly
    via Python under the `venv` name.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 工具 `virtualenv` 会为你自动处理虚拟环境。直到 Python 3.2，你可以通过安装 `virtualenv` 包来使用它，命令是 `pip
    install virtualenv`。如果你使用的是 Python 3.3 或更高版本，它可以通过 Python 的 `venv` 名称直接使用。
- en: 'To use the module, load it as the main program with a destination directory
    as its argument, like so:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用该模块，像这样将其作为主程序加载，并以目标目录作为参数：
- en: '[PRE25]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Once run, `venv` creates a *lib/pythonX.Y* directory and uses it to install
    `pip` into the virtual environment, which will be useful to install further Python
    packages.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦运行，`venv` 会创建一个 *lib/pythonX.Y* 目录，并使用它将 `pip` 安装到虚拟环境中，这对于安装后续的 Python 包非常有用。
- en: 'You can then activate the virtual environment by “sourcing” the `activate`
    command. Use the following on Posix systems:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以通过“激活” `activate` 命令来激活虚拟环境。在 Posix 系统上，使用以下命令：
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'On Windows systems, use this code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 系统上，使用以下代码：
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Once you do that, your shell prompt should appear prefixed by the name of your
    virtual environment. Executing `python` will call the version of Python that has
    been copied into the virtual environment. You can check that it’s working by reading
    the `sys.path` variable and checking that it has your virtual environment directory
    as its first component.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成，你的 shell 提示符应该会显示虚拟环境的名称。执行 `python` 将调用已经复制到虚拟环境中的 Python 版本。你可以通过查看 `sys.path`
    变量并确认它的第一个组件是虚拟环境目录来检查它是否正常工作。
- en: 'You can stop and leave the virtual environment at any time by calling the `deactivate`
    command:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以随时通过调用 `deactivate` 命令来停止并退出虚拟环境：
- en: '[PRE28]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'That’s it. Also note that you are not forced to run `activate` if you want
    to use the Python installed in your virtual environment just once. Calling the
    `python` binary will also work:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。还要注意，如果你只想使用虚拟环境中安装的 Python 一次，你并不一定需要运行`activate`。直接调用`python`二进制文件也能工作：
- en: '[PRE29]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, while we’re in our activated virtual environment, we do not have access
    to any of the modules installed and available on the main system. That is the
    point of using a virtual environment, but it does mean we probably need to install
    the packages we need. To do that, use the standard `pip` command to install each
    package, and the packages will install in the right place, without changing anything
    about your system:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们处于激活的虚拟环境中时，我们无法访问主系统中安装并可用的任何模块。这正是使用虚拟环境的意义所在，但这也意味着我们可能需要安装所需的包。为此，使用标准的`pip`命令安装每个包，这些包将安装到正确的位置，而不会改变系统中的任何内容：
- en: '[PRE30]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Voilà! We can install all the libraries we need and then run our application
    from this virtual environment, without breaking our system. It’s easy to see how
    we can script this to automate the installation of a virtual environment based
    on a list of dependencies, as in [Listing 6-14](ch06.xhtml#ch6list14).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Voilà！我们可以安装所需的所有库，然后从这个虚拟环境中运行我们的应用程序，而不会破坏系统。很容易看出，我们可以编写脚本来自动化安装虚拟环境，基于依赖项列表，就像在[清单
    6-14](ch06.xhtml#ch6list14)中所示。
- en: '[PRE31]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '*Listing 6-14: Automatic virtual environment creation*'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-14：自动虚拟环境创建*'
- en: It can still be useful to have access to your system-installed packages, so
    `virtualenv` allows you to enable them when creating your virtual environment
    by passing the `--system-site-packages` flag to the `virtualenv` command.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然通常不需要访问系统安装的包，但`virtualenv`允许你在创建虚拟环境时通过传递`--system-site-packages`标志启用它们。
- en: Inside `myvenv`, you will find a *pyvenv.cfg*, the configuration file for this
    environment. It doesn’t have a lot of configuration options by default. You should
    recognize `include-system-site-package`, whose purpose is the same as the `--system-site-packages`
    of `virtualenv` that we described earlier.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在`myvenv`中，你会找到一个*pyvenv.cfg*文件，这是该环境的配置文件。默认情况下，它没有很多配置选项。你应该能识别出`include-system-site-package`，其作用与我们之前描述的`virtualenv`中的`--system-site-packages`相同。
- en: As you might guess, virtual environments are incredibly useful for automated
    runs of unit test suites. Their use is so widespread that a particular tool has
    been built to address it.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能猜到的，虚拟环境对自动化运行单元测试套件非常有用。它们的使用如此广泛，以至于已经有一个专门的工具来解决这个问题。
- en: '***Using virtualenv with tox***'
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 virtualenv 配合 tox***'
- en: One of the central uses of virtual environments is to provide a clean environment
    for running unit tests. It would be detrimental if you were under the impression
    that your tests were working, when they were not, for example, respecting the
    dependency list.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟环境的主要用途之一是为运行单元测试提供一个干净的环境。如果你误以为测试正在正常工作，但它们没有遵守依赖项列表，那将是有害的。
- en: 'One way to ensure you’re accounting for all the dependencies would be to write
    a script to deploy a virtual environment, install `setuptools`, and then install
    all of the dependencies required for both your application/library runtime and
    unit tests. Luckily, this is such a popular use case that an application dedicated
    to this task has already been built: `tox`.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 确保考虑所有依赖项的一种方法是编写脚本来部署虚拟环境，安装`setuptools`，然后安装应用程序/库运行时和单元测试所需的所有依赖项。幸运的是，这是一个如此常见的用例，已经有一个专门用于此任务的应用程序：`tox`。
- en: The `tox` management tool aims to automate and standardize how tests are run
    in Python. To that end, it provides everything needed to run an entire test suite
    in a clean virtual environment, while also installing your application to check
    that the installation works.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`tox`管理工具旨在自动化和标准化 Python 中的测试运行方式。为此，它提供了运行整个测试套件所需的一切，同时也安装你的应用程序以检查安装是否成功。'
- en: 'Before using `tox`, you need to provide a configuration file named *tox.ini*
    that should be placed in the root directory of your project, beside your *setup.py*
    file:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`tox`之前，你需要提供一个名为*tox.ini*的配置文件，该文件应放置在项目的根目录中，与你的*setup.py*文件一起：
- en: '[PRE32]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You can then run `tox` successfully:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你可以成功地运行`tox`：
- en: '[PRE33]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In this instance, `tox` creates a virtual environment in *.tox/python* using
    the default Python version. It uses *setup.py* to create a distribution of your
    package, which it then installs inside this virtual environment. No commands are
    run, because we did not specify any in the configuration file. This alone is not
    particularly useful.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在此实例中，`tox` 使用默认的 Python 版本在 *.tox/python* 中创建一个虚拟环境。它使用 *setup.py* 创建包的分发文件，然后将其安装到这个虚拟环境中。没有运行任何命令，因为我们没有在配置文件中指定任何命令。单单这样做并没有太大用处。
- en: 'We can change this default behavior by adding a command to run inside our test
    environment. Edit *tox.ini* to include the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在测试环境中添加要运行的命令来改变这个默认行为。编辑 *tox.ini* 文件，添加以下内容：
- en: '[PRE34]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now `tox` runs the command `pytest`. However, since we do not have `pytest`
    installed in the virtual environment, this command will likely fail. We need to
    list `pytest` as a dependency to be installed:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `tox` 运行 `pytest` 命令。然而，由于我们在虚拟环境中没有安装 `pytest`，这个命令很可能会失败。我们需要将 `pytest`
    列为一个依赖项以便安装：
- en: '[PRE35]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: When run now, `tox` re-creates the environment, installs the new dependency,
    and runs the command `pytest`, which executes all of the unit tests. To add more
    dependencies, you can either list them in the `deps` configuration option, as
    is done here, or use the `-rfile` syntax to read from a file.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行时，`tox` 会重新创建环境，安装新的依赖项，并运行 `pytest` 命令，执行所有单元测试。要添加更多依赖项，你可以将它们列在 `deps`
    配置选项中，如这里所示，或者使用 `-rfile` 语法从文件中读取。
- en: '***Re-creating an Environment***'
  id: totrans-167
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***重新创建环境***'
- en: Sometimes you’ll need to re-create an environment to, for example, ensure things
    work as expected when a new developer clones the source code repository and runs
    `tox` for the first time. For this, `tox` accepts a `--recreate` option that will
    rebuild the virtual environment from scratch based on parameters you lay out.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你需要重新创建环境，例如，确保当一个新开发者克隆源代码仓库并首次运行 `tox` 时，所有东西能按预期工作。为此，`tox` 接受一个 `--recreate`
    选项，它将根据你设定的参数从头开始重建虚拟环境。
- en: 'You define the parameters for all virtual environments managed by `tox` in
    the `[testenv]` section of *tox.ini*. And, as mentioned, `tox` can manage multiple
    Python virtual environments—indeed, it is possible to run our tests under a Python
    version other than the default one by passing the `-e` flag to `tox`, like so:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 *tox.ini* 文件的 `[testenv]` 部分定义所有由 `tox` 管理的虚拟环境的参数。如前所述，`tox` 可以管理多个 Python
    虚拟环境——事实上，你可以通过向 `tox` 传递 `-e` 标志来运行非默认 Python 版本下的测试，方法如下：
- en: '[PRE36]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'By default, `tox` simulates any environment that matches an existing Python
    version: `py24`, `py25`, `py26`, `py27`, `py30`, `py31`, `py32`, `py33`, `py34`,
    `py35`, `py36`, `py37`, `jython`, and `pypy`! Furthermore, you can define your
    own environments. You just need to add another section named `[testenv:_envname_]`.
    If you want to run a particular command for just one of the environments, you
    can do so easily by listing the following in the *tox.ini* file:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`tox` 会模拟任何匹配现有 Python 版本的环境：`py24`、`py25`、`py26`、`py27`、`py30`、`py31`、`py32`、`py33`、`py34`、`py35`、`py36`、`py37`、`jython`
    和 `pypy`！此外，你还可以定义自己的环境。只需要添加一个名为 `[testenv:_envname_]` 的新部分。如果你只想为某个特定环境运行某个命令，可以通过在
    *tox.ini* 文件中列出以下内容来轻松实现：
- en: '[PRE37]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'By using `pytest --cov=myproject` under the `py36-coverage` section as shown
    here, you override the commands for the `py36-coverage` environment, meaning when
    you run `tox -e py36-coverage`, `pytest` is installed as part of the dependencies,
    but the command `pytest` is actually run instead with the coverage option. For
    that to work, the `pytest-cov` extension must be installed: to this end, we replace
    the `deps` value with the `deps` from `testenv` and add the `pytest-cov` dependency.
    Variable interpolation is also supported by `tox`, so you can refer to any other
    field from the *tox.ini* file and use it as a variable, the syntax being `{[env_name`]variable_name}.
    This allows us to avoid repeating the same things over and over again.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 `py36-coverage` 部分下使用 `pytest --cov=myproject`，如这里所示，你可以覆盖 `py36-coverage`
    环境的命令，这意味着当你运行 `tox -e py36-coverage` 时，`pytest` 会作为依赖项安装，但实际运行的命令是带有覆盖选项的 `pytest`。为了使这一点生效，必须安装
    `pytest-cov` 扩展：为此，我们将 `deps` 值替换为来自 `testenv` 的 `deps`，并添加 `pytest-cov` 依赖项。`tox`
    也支持变量插值，因此你可以引用 *tox.ini* 文件中的任何其他字段并将其作为变量使用，语法为 `{[env_name]variable_name}`。这样可以避免重复相同的内容。
- en: '***Using Different Python Versions***'
  id: totrans-174
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用不同的 Python 版本***'
- en: 'We can also create a new environment with an unsupported version of Python
    right away with the following in *tox.ini*:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过在 *tox.ini* 中添加以下内容，立即创建一个不受支持版本的 Python 环境：
- en: '[PRE38]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: When we run this, it will now (attempt to) use Python 2.1 to run the test suite—although
    since it is very unlikely you have this ancient Python version installed on your
    system, I doubt this would work for you!
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行它时，它现在会（尝试）使用 Python 2.1 来运行测试套件——尽管由于非常不可能你在系统上安装了这个古老的 Python 版本，我怀疑这对你来说会起作用！
- en: 'It’s likely that you’ll want to support multiple Python versions, in which
    case it would be useful to have `tox` run all the tests for all the Python versions
    you want to support by default. You can do this by specifying the environment
    list you want to use when `tox` is run without arguments:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望支持多个 Python 版本，在这种情况下，默认情况下让 `tox` 运行你想要支持的所有 Python 版本的所有测试会很有用。你可以通过在没有参数的情况下运行
    `tox` 时指定你想使用的环境列表来做到这一点：
- en: '[PRE39]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: When `tox` is launched without any further arguments, all four environments
    listed are created, populated with the dependencies and the application, and then
    run with the command `pytest`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `tox` 启动时没有其他参数，所有列出的四个环境都会被创建，填充依赖项和应用程序，然后用命令 `pytest` 运行它们。
- en: '***Integrating Other Tests***'
  id: totrans-181
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***集成其他测试***'
- en: 'We can also use `tox` to integrate tests like `flake8`, as discussed in [Chapter
    1](ch01.xhtml#ch01). The following *tox.ini* file provides a PEP 8 environment
    that will install `flake8` and run it:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 `tox` 集成像 `flake8` 这样的测试，如[第1章](ch01.xhtml#ch01)所讨论的。以下 *tox.ini* 文件提供了一个
    PEP 8 环境，将安装 `flake8` 并运行它：
- en: '[PRE40]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In this case, the `pep8` environment is run using the default version of Python,
    which is probably fine, though you can still specify the `basepython` option if
    you want to change that.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`pep8` 环境使用默认版本的 Python 运行，这可能没问题，尽管如果你想更改它，仍然可以指定 `basepython` 选项。
- en: When running `tox`, you’ll notice that all the environments are built and run
    sequentially. This can make the process very long, but since virtual environments
    are isolated, nothing prevents you from running `tox` commands in parallel. This
    is exactly what the `detox` package does, by providing a `detox` command that
    runs all of the default environments from *envlist* in parallel. You should `pip
    install` it!
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `tox` 时，你会注意到所有环境都是顺序构建并运行的。这可能会使过程非常漫长，但由于虚拟环境是隔离的，什么也不会阻止你并行运行 `tox` 命令。这正是
    `detox` 包所做的，它提供了一个 `detox` 命令，能够并行运行 *envlist* 中的所有默认环境。你应该 `pip install` 它！
- en: '**Testing Policy**'
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**测试政策**'
- en: 'Embedding testing code in your project is an excellent idea, but how that code
    is run is also extremely important. Too many projects have test code lying around
    that fails to run for some reason or other. This topic is not strictly limited
    to Python, but I consider it important enough to emphasize here: you should have
    a zero-tolerance policy regarding untested code. No code should be merged without
    a proper set of unit tests to cover it.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的项目中嵌入测试代码是一个极好的主意，但代码的执行方式同样至关重要。太多项目中有一些测试代码，因为某些原因没有运行。这个话题不仅限于 Python，但我认为它足够重要，值得在这里强调：你应该对未经测试的代码实行零容忍政策。没有适当的单元测试覆盖的代码不应被合并。
- en: The minimum you should aim for is that each of the commits you push passes all
    the tests. Automating this process is even better. For example, OpenStack relies
    on a specific workflow based on *Gerrit* (a web-based code review service) and
    *Zuul* (a continuous integration and delivery service). Each commit pushed goes
    through the code review system provided by Gerrit, and Zuul is in charge of running
    a set of testing jobs. Zuul runs the unit tests and various higher-level functional
    tests for each project. This code review, which is executed by a couple of developers,
    makes sure all code committed has associated unit tests.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该追求的最低目标是，你推送的每个提交都能通过所有测试。自动化这个过程会更好。例如，OpenStack 依赖于基于 *Gerrit*（一个基于 Web
    的代码审查服务）和 *Zuul*（一个持续集成和交付服务）的特定工作流。每个提交都会通过 Gerrit 提供的代码审查系统，Zuul 负责运行一系列测试任务。Zuul
    运行单元测试和各种高级功能测试。这些代码审查由几位开发人员执行，确保所有提交的代码都有相应的单元测试。
- en: If you’re using the popular GitHub hosting service, *Travis CI* is a tool that
    allows you to run tests after each push or merge or against pull requests that
    are submitted. While it is unfortunate that this testing is done post-push, it’s
    still a fantastic way to track regressions. Travis supports all significant Python
    versions out of the box, and it can be customized significantly. Once you’ve activated
    Travis on your project via the web interface at *[https://www.travis-ci.org/](https://www.travis-ci.org/)*,
    just add a *.travis.yml* file that will determine how the tests are run. [Listing
    6-15](ch06.xhtml#ch6list15) shows an example of a .*travis.yml* file.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用流行的 GitHub 托管服务，*Travis CI* 是一个可以在每次推送或合并后，或在提交的拉取请求上运行测试的工具。虽然遗憾的是这些测试是在推送后进行的，但它仍然是跟踪回归的一个绝佳方式。Travis
    开箱即支持所有主要的 Python 版本，并且可以进行显著的定制。一旦你通过 *[https://www.travis-ci.org/](https://www.travis-ci.org/)*
    的 web 界面激活了 Travis，只需添加一个 *.travis.yml* 文件来确定如何运行测试。[列表 6-15](ch06.xhtml#ch6list15)
    展示了一个 .*travis.yml* 文件的示例。
- en: '[PRE41]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '*Listing 6-15: A .travis.yml example file*'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-15：一个 .travis.yml 示例文件*'
- en: With this file in place in your code repository and Travis enabled, the latter
    will spawn a set of jobs to test your code with the associated unit tests. It’s
    easy to see how you can customize this by simply adding dependencies and tests.
    Travis is a paid service, but the good news is that for open source projects,
    it’s entirely free!
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码仓库中放置这个文件并启用 Travis 后，Travis 会启动一组作业，使用相关的单元测试来测试你的代码。你可以很容易地通过简单地添加依赖项和测试来定制它。Travis
    是一个付费服务，但好消息是，对于开源项目，它完全免费！
- en: The `tox-travis` package (*[https://pypi.python.org/pypi/tox-travis/](https://pypi.python.org/pypi/tox-travis/)*)
    is also worth looking into, as it will polish the integration between `tox` and
    Travis by running the correct `tox` target depending on the Travis environment
    being used. [Listing 6-16](ch06.xhtml#ch6list16) shows an example of a *.travis.yml*
    file that will install `tox-travis` before running `tox`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`tox-travis` 包 (*[https://pypi.python.org/pypi/tox-travis/](https://pypi.python.org/pypi/tox-travis/)*)
    也值得关注，因为它会通过根据所使用的 Travis 环境运行正确的 `tox` 目标，来优化 `tox` 和 Travis 之间的集成。[列表 6-16](ch06.xhtml#ch6list16)
    展示了一个 *.travis.yml* 文件示例，该文件会在运行 `tox` 之前安装 `tox-travis`。'
- en: '[PRE42]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '*Listing 6-16: A .travis.yml example file with tox-travis*'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-16：一个带有 tox-travis 的 .travis.yml 示例文件*'
- en: Using `tox-travis`, you can simply call `tox` as the script on Travis, and it
    will call `tox` with the environment you specify here in the *.travis.yml* file,
    building the necessary virtual environment, installing the dependency, and running
    the commands you specified in *tox.ini*. This makes it easy to use the same workflow
    both on your local development machine and on the Travis continuous integration
    platform.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `tox-travis`，你只需在 Travis 上调用 `tox` 作为脚本，它将根据 *.travis.yml* 文件中指定的环境调用 `tox`，构建必要的虚拟环境，安装依赖项，并运行你在
    *tox.ini* 中指定的命令。这使得在本地开发机器和 Travis 持续集成平台上使用相同的工作流程变得容易。
- en: These days, wherever your code is hosted, it is always possible to apply some
    automatic testing of your software and to make sure your project is moving forward,
    not being held back by the addition of bugs.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，无论你的代码托管在哪里，总是可以对软件进行一些自动化测试，确保你的项目在推进，而不是因为引入了 bug 而被拖慢进度。
- en: '**Robert Collins on Testing**'
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**罗伯特·柯林斯关于测试的观点**'
- en: Robert Collins is, among other things, the original author of the *Bazaar* distributed
    version control system. Today, he is a Distinguished Technologist at HP Cloud
    Services, where he works on OpenStack. Robert is also the author of many of the
    Python tools described in this book, such as fixtures, `testscenarios`, `testrepository`,
    and even `python-subunit`—you may have used one of his programs without knowing
    it!
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 罗伯特·柯林斯不仅是 *Bazaar* 分布式版本控制系统的原始作者之一，还是 HP Cloud Services 的杰出技术专家，目前致力于 OpenStack
    项目。罗伯特还是本书中描述的许多 Python 工具的作者，如 fixtures、`testscenarios`、`testrepository`，甚至是
    `python-subunit`——你可能在不知情的情况下使用过他的某些程序！
- en: '**What kind of testing policy would you advise using? Is it ever acceptable
    not to test code?**'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**你会建议使用什么样的测试策略？不进行代码测试是否可以接受？**'
- en: 'I think testing is an engineering trade-off: you must consider the likelihood
    of a failure slipping through to production undetected, the cost and size of an
    undetected failure, and cohesion of the team doing the work. Take OpenStack, which
    has 1,600 contributors: it’s difficult to work with a nuanced policy with so many
    people with their own opinions. Generally speaking, a project needs some automated
    testing to check that the code will do what it is intended to do, and that what
    it is intended to do is what is needed. Often that requires functional tests that
    might be in different codebases. Unit tests are excellent for speed and pinning
    down corner cases. I think it is okay to vary the balance between styles of testing,
    as long as there is testing.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为测试是一种工程折衷：你必须考虑失败未被发现而滑入生产环境的可能性、未发现的失败的成本和规模，以及执行工作的团队的凝聚力。以 OpenStack 为例，它有
    1600 名贡献者：如此多的人各自有自己的意见，难以制定细致的政策。一般来说，一个项目需要一些自动化测试，以检查代码是否按预期运行，并且它的功能是否符合需求。通常这需要一些功能性测试，可能存在不同的代码库中。单元测试在速度和定位边界情况方面非常优秀。我认为，在有测试的前提下，测试风格之间的平衡是可以有所不同的。
- en: 'Where the cost of testing is very high and the returns are very low, I think
    it’s fine to make an informed decision not to test, but that situation is relatively
    rare: most things can be tested reasonably cheaply, and the benefit of catching
    errors early is usually quite high.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试成本非常高且回报非常低的情况下，我认为做出不测试的明智决定是可以的，但这种情况相对较少：大多数事情可以以相对较低的成本进行测试，而及早发现错误的好处通常是相当高的。
- en: '**What are the best strategies when writing Python code to make testing manageable
    and improve the quality of the code?**'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**在编写 Python 代码时，哪些策略能够帮助管理测试并提高代码质量？**'
- en: Separate out concerns and don’t do multiple things in one place; this makes
    reuse natural, and that makes it easier to put test doubles in place. Take a purely
    functional approach when possible; for example, in a single method either calculate
    something or change some state, but avoid doing both. That way you can test all
    of the calculating behaviors without dealing with state changes, such as writing
    to a database or talking to an HTTP server. The benefit works the other way around
    too—you can replace the calculation logic for tests to provoke corner case behavior
    and use mocks and test doubles to check that the expected state propagation happens
    as desired. The most heinous things to test are deeply layered stacks with complex
    cross-layer behavioral dependencies. There you want to evolve the code so that
    the contract between layers is simple, predictable, and—most usefully for testing—replaceable.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 将关注点分离，不要在同一个地方做多个事情；这样可以自然地实现重用，也使得放置测试替代物更容易。在可能的情况下，采取纯粹的函数式方法；例如，在一个方法中要么计算某些内容，要么更改某些状态，但避免两者都做。这样，你可以测试所有的计算行为，而不需要处理状态的变化，比如写入数据库或与
    HTTP 服务器交互。这个好处也可以反向利用——你可以为测试替换计算逻辑，来引发边界情况的行为，并使用模拟和测试替代物来检查期望的状态传播是否按预期发生。最难测试的往往是深层次的堆栈，尤其是有复杂跨层行为依赖的情况。此时你需要让代码演变成层之间契约简单、可预测，并且——对测试最有用的是——可以替换的形式。
- en: '**What’s the best way to organize unit tests in source code?**'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '**如何在源代码中组织单元测试最为合适？**'
- en: Have a clear hierarchy, like *$ROOT/$PACKAGE/tests*. I tend to do just one hierarchy
    for a whole source tree, for example *$ROOT/$PACKAGE/$SUBPACKAGE/tests*.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有清晰的层次结构，例如 *`$ROOT/$PACKAGE/tests`*。我倾向于为整个源代码树做一个层次结构，例如 *`$ROOT/$PACKAGE/$SUBPACKAGE/tests`*。
- en: 'Within tests, I often mirror the structure of the rest of the source tree:
    *$ROOT/$PACKAGE/foo.py* would be tested in *$ROOT/$PACKAGE/tests/test_foo.py*.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试中，我通常会镜像源代码树的结构：*`$ROOT/$PACKAGE/foo.py`* 会在 *`$ROOT/$PACKAGE/tests/test_foo.py`*
    中进行测试。
- en: The rest of the tree should not import from the tests tree, except perhaps in
    the case of a `test_suite`/`load_tests` function in the top level `__init__`.
    This permits you to easily detach the tests for small-footprint installations.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 除非是顶层 `__init__` 中的 `test_suite`/`load_tests` 函数，否则其他树层不应导入测试树。这使得在小型安装环境下轻松分离测试成为可能。
- en: '**What do you see as the future of unit-testing libraries and frameworks in
    Python?**'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**你如何看待 Python 中单元测试库和框架的未来？**'
- en: 'The significant challenges I see are these:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我看到的主要挑战有：
- en: The continued expansion of parallel capabilities in new machines, like phones
    with four CPUs. Existing unit test internal APIs are not optimized for parallel
    workloads. My work on the StreamResult Java class is aimed directly at resolving
    this.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在新机器（例如装有四个CPU的手机）中，并行能力的持续扩展。现有的单元测试内部API并不针对并行工作负载进行优化。我在StreamResult Java类上的工作直接旨在解决这个问题。
- en: More complex scheduling support—a less ugly solution for the problems that class
    and module-scoped setup aim at.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更复杂的调度支持——为类和模块作用域设置所解决的问题提供一个不那么丑陋的解决方案。
- en: 'Finding some way to consolidate the vast variety of frameworks we have today:
    for integration testing, it would be great to be able to get a consolidated view
    across multiple projects that have different test runners in use.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找一种方法来整合当今我们拥有的各种框架：对于集成测试而言，能够跨多个使用不同测试运行程序的项目获得一个整合视图将会非常有益。
