- en: '**4'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**4'
- en: DECODING AMERICAN CIVIL WAR CIPHERS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 解码美国内战密码**
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: Cryptography is the science of secure communication through the use of *codes*
    and *ciphers*. A code replaces whole words with other words; a cipher scrambles
    or replaces the letters in words (so technically, Morse code is really Morse cipher).
    One goal of cryptography is to use a *key* to both *encrypt* readable *plaintext*
    into unreadable *ciphertext* and then *decrypt* it back to plaintext. The goal
    of *cryptanalysis* is to decode ciphers and codes without knowing their key or
    encryption algorithm.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 加密学是通过使用*密码*和*密文*进行安全通信的科学。密码是用其他词替代整个词语；而密文则是将单词中的字母进行打乱或替换（所以从技术上讲，摩尔斯电码实际上就是摩尔斯密文）。加密学的目标之一是使用*密钥*将可读的*明文*加密为不可读的*密文*，然后再将其*解密*回明文。*密码分析*的目标是在不知道密钥或加密算法的情况下解码密码和密码本。
- en: 'In this chapter, we’ll investigate two ciphers used in the American Civil War:
    the route cipher, used by the North, and the rail fence cipher, used by both sides.
    We’ll also look at what made one so successful and how we can use lessons learned
    from its application to better write programs for inexperienced users and those
    unfamiliar with your Python code.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究美国内战中使用的两种密码：北方使用的路线密码和双方都使用的铁轨密码。我们还将探讨是什么使其中一种密码如此成功，以及我们如何从其应用中汲取经验教训，以便为没有经验的用户和不熟悉你代码的
    Python 用户编写更好的程序。
- en: '**Project #8: The Route Cipher**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**项目#8：路线密码**'
- en: In the American Civil War, the Union had just about every advantage over the
    Confederacy, including the field of cryptography. The Union had better codes,
    better ciphers, and better-trained personnel. But perhaps its biggest advantage
    was in leadership and organization.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在美国内战中，联邦在加密学领域几乎在所有方面都优于南方联邦。联邦有更好的密码、更好的密文和更训练有素的人员。但也许它最大的优势在于领导力和组织结构。
- en: The head of the US Military Telegraph Department was Anson Stager ([Figure 4-1](ch04.xhtml#ch04fig1)).
    As the cofounder of Western Union, Stager knew from experience that telegraph
    operators made fewer mistakes when sending whole words, as opposed to the strings
    of random letters and numbers common to most ciphertext. He also knew that military
    dispatches only needed to stay secret long enough for orders to be carried out.
    His secure solution was a hybrid cryptosystem called the *route transposition
    cipher*, a combination of transposed real words and code words that became one
    of the most successful military ciphers of all time.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 美国军事电报部的负责人是安森·斯塔格（[图4-1](ch04.xhtml#ch04fig1)）。作为西联电报的共同创始人，斯塔格从经验中知道，当电报操作员发送完整单词时，他们犯错误的概率比发送随机字母和数字的密文低。他还知道，军事电报只需要保密足够长的时间，以便完成命令。他的安全解决方案是一种混合加密系统，称为*路线置换密码*，它结合了经过置换的真实单词和代码词，成为了历史上最成功的军事密码之一。
- en: '![image](../images/f0064-01.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0064-01.jpg)'
- en: '*Figure 4-1: General Anson Stager, US Telegraph Corps, 1865*'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-1：美国电报队的安森·斯塔格将军，1865年*'
- en: Transposition ciphers *scramble* the arrangement of letters or words, unlike
    substitution ciphers, which *replace* the letters in the plaintext with different
    characters or symbols. [Figure 4-2](ch04.xhtml#ch04fig2) shows an example of a
    route transposition cipher. The message is written left to right over a number
    of predetermined columns and rows, important plaintext words are replaced by code
    words, and the last row is filled with dummy placeholder words. The reader determines
    the order of the rearranged words by traversing up and down these columns, as
    shown. The starting word is *REST*, and then the encryption route is shown with
    arrows.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 置换密码*打乱*字母或单词的排列方式，不同于替代密码，后者是将明文中的字母用不同的字符或符号替代。[图4-2](ch04.xhtml#ch04fig2)展示了一个路线置换密码的例子。信息从左到右写在预定的若干列和行上，重要的明文词汇被代码词替代，最后一行填充了虚拟的占位符词。读者通过上下遍历这些列来确定重新排列的词语顺序，如图所示。起始词是*REST*，然后加密路线通过箭头显示出来。
- en: '![image](../images/f0065-01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0065-01.jpg)'
- en: '*Figure 4-2: A route cipher using actual Union code words*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-2：使用实际联邦代码词的路线密码*'
- en: To fully decode this message, you need to know both the starting point and route
    used to traverse the message and create the final ciphertext *and* the meaning
    of the code words.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要完全解码此消息，你需要知道起点和用于遍历消息并创建最终密文的路线*以及*代码词的含义。
- en: 'In the early 20th century, the distinguished military cryptanalyst William
    Friedman disparaged Stager’s route cipher. He considered it too unsophisticated
    and found it highly improbable that the Confederates never cracked it. But the
    fact remains that hundreds of thousands of route ciphers sent during the war were
    apparently never decoded, and not from lack of trying. In an early example of
    crowdsourcing, the Confederates published the coded messages in newspapers, hoping
    for some help with the decryption, but to no avail. While some historians speculate
    that this cipher was broken at times, Stager’s design teaches several important
    lessons:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在20世纪初，杰出的军事密码分析师威廉·弗里德曼（William Friedman）批评Stager的路由密码。他认为它过于简单，并且觉得南方联盟军队从未破解它的可能性非常小。但事实上，战争期间发送的数十万条路由密码显然从未被破解，而不是因为没有努力过。在一次早期的众包例子中，南方联盟军队将加密消息发布在报纸上，希望能获得解密的帮助，但没有成功。虽然一些历史学家推测这种密码曾在某些时候被破解，但Stager的设计教给我们几个重要的教训：
- en: '**Design for human error.** Military ciphers have to be simple, as hundreds
    might be sent in a day. The real words used in the route cipher made it much less
    likely to be garbled by telegraph operators. Stager knew his customer and designed
    for them. He recognized the limitations of his workforce and tailored his product
    accordingly. The Confederates, by contrast, had great difficulty deciphering their
    own complex messages, sometimes giving up and riding around enemy lines to talk
    face-to-face!'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**为人为错误设计。** 军事密码必须简单，因为每天可能会发送数百条。路由密码中使用的真实单词使其不太可能被电报操作员弄乱。Stager了解他的客户，并为他们设计。他认识到自己劳动力的局限性，并相应地调整了他的产品。相比之下，南方联盟军队在破译自己复杂的消息时遇到了巨大困难，有时甚至放弃，绕过敌军阵地去面对面交流！'
- en: '**Innovation trumps invention.** Sometimes you don’t need to invent something
    new; you just need to rediscover something old. The short word-transposition ciphers
    suitable for telegraph transmission were too weak to use on their own, but combined
    with code names and disruptive dummy words, they confounded the Confederates.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**创新胜过发明。** 有时候，你不需要发明新东西；你只需要重新发现旧事物。适用于电报传输的简短字词置换密码本身太弱，无法单独使用，但结合了代号和破坏性虚假词汇后，它们使得南方联盟军队陷入困境。'
- en: '**Share learning.** Because everyone in the Telegraph Corps used the same methodology,
    it was easy to build on existing techniques and share lessons learned. This allowed
    the route cipher to evolve over time with the introduction of slang and intentional
    misspellings, as well as a growing number of code words for places, people, and
    dates.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**分享学习。** 因为电报队的每个人都使用相同的方法，所以很容易在现有技术的基础上进行改进并分享经验教训。这使得路由密码随着时间的推移而不断发展，加入了俚语和故意拼写错误，同时增加了大量的地名、人物和日期的代号词。'
- en: Stager’s practical cipher may not have pleased later “purists,” but it was the
    perfect design for the time. The concepts behind it are timeless and easily transferable
    to modern-day applications.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Stager的实用密码可能并不讨后来的“纯粹主义者”喜欢，但它在当时是完美的设计。它背后的概念是永恒的，可以轻松转移到现代应用中。
- en: '**THE OBJECTIVE**'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标**'
- en: In Harry Turtledove’s award-winning 1992 novel *Guns of the South*, time travelers
    provide Confederate armies with modern weaponry, changing the course of history.
    Instead of AK-47s, let’s pretend you’ve traveled back to 1864 with your laptop,
    a few extra batteries, and Python to design an algorithm that will decrypt a route
    cipher based on an assumed encryption matrix and path. In the spirit of Stager,
    you’ll write a user-friendly program that will reduce human error.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在哈里·特特尔多夫（Harry Turtledove）获奖的1992年小说《*南方的枪火*》中，时间旅行者为南方联盟军队提供现代武器，改变了历史的进程。假设你没有携带AK-47步枪，而是带着你的笔记本电脑、几块额外的电池和Python，回到1864年，设计一个算法，解密基于假设的加密矩阵和路径的路由密码。在Stager的精神指导下，你将编写一个用户友好的程序，减少人为错误。
- en: '***The Strategy***'
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***策略***'
- en: When it comes to solving ciphers, it’s a lot easier if you know what type you’re
    dealing with. In this case, you know it’s a transposition cipher, because it’s
    composed of real words that are jumbled. You also know there are code words and
    null words present. Your job is to figure out ways to decrypt the *transposition*
    part of the route cipher and let someone else worry about code words while you
    go have a well-deserved mint julep.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到解决密码时，如果你知道你在处理哪种类型的密码，事情会变得容易很多。在这种情况下，你知道它是一个置换密码，因为它由被打乱的真实单词组成。你还知道存在代号词和虚假词。你的任务是找出解密路由密码中*置换*部分的方法，然后让别人去担心代号词，而你则去享受一杯应得的薄荷酒。
- en: '**Creating a Control Message**'
  id: totrans-23
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**创建控制消息**'
- en: 'To understand how to do this, create your own message and route cipher. Call
    this your *control message*:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解如何操作，创建你自己的消息和路由密码。将其称为你的*控制信息*：
- en: Number of columns = 4
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列数 = 4
- en: Number of rows = 5
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行数 = 5
- en: Start position = Bottom left
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 起始位置 = 左下角
- en: Route = Alternating up and down columns
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由 = 交替上下列
- en: Plaintext = 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 明文 = 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19
- en: Ciphertext = 16 12 8 4 0 1 5 9 13 17 18 14 10 6 2 3 7 11 15 19
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密文 = 16 12 8 4 0 1 5 9 13 17 18 14 10 6 2 3 7 11 15 19
- en: Key = –1 2 –3 4
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密钥 = –1 2 –3 4
- en: Using a numeric progression for the plaintext allows you to instantly tell whether
    you’ve gotten all or part of the decryption correct, at any place within the message.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数字序列作为明文，可以让你在消息的任何地方立即判断自己是否正确解密了全部或部分内容。
- en: The transposition matrix is shown in [Figure 4-3](ch04.xhtml#ch04fig3). The
    gray arrows indicate the encryption route.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 置换矩阵如 [图4-3](ch04.xhtml#ch04fig3) 所示，灰色箭头表示加密路径。
- en: '![image](../images/f0067-01.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0067-01.jpg)'
- en: '*Figure 4-3: The transposition matrix for the control message with the route
    cipher path and resulting ciphertext*'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-3：控制消息的置换矩阵，包含路由密码路径及生成的密文*'
- en: 'The key keeps track of both the *order* and *direction* of the route through
    the columns. The route doesn’t have to move through the columns in order. For
    instance, it can move down the first column, up the third, down the fourth, and
    finally up the second. Negative numbers mean you start at the bottom and read
    up a column; positive numbers mean the reverse. For the control message, the final
    key used in the program will be a list: [–1, 2, –3, 4]. This list will instruct
    the program to start reading up from the bottom of column 1, move to the top of
    column 2 and read down, move to the bottom of column 3 and read up, and move to
    the top of column 4 and read down.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 密钥跟踪了列中路由的*顺序*和*方向*。路由不必按顺序穿过列。例如，它可以先向下移动第一列，再向上移动第三列，接着向下移动第四列，最后向上移动第二列。负数表示从底部开始，向上读取一列；正数则表示相反的顺序。对于控制信息，程序中使用的最终密钥将是一个列表：[–1,
    2, –3, 4]。这个列表将指示程序从第一列的底部开始向上读取，移动到第二列的顶部并向下读取，接着移动到第三列的底部并向上读取，再移动到第四列的顶部并向下读取。
- en: Note that you shouldn’t use 0 in keys because the users, being human, prefer
    to start counting at 1\. Of course, Python prefers to start counting at 0, so
    you’ll need to subtract 1 from the key values behind the scenes. Everybody wins!
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你不应在密钥中使用0，因为用户是人类，习惯从1开始计数。当然，Python从0开始计数，所以你需要在背后从密钥值中减去1。这样，大家都能受益！
- en: 'Later, in “[Route Transposition Cipher: Brute-Force Attack](ch04.xhtml#lev111)”
    on [page 88](ch04.xhtml#page_88), you can use this compact key structure to brute-force
    your way through a route cipher, automatically trying hundreds of keys until the
    plaintext is restored.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在 “[路由置换密码：暴力破解攻击](ch04.xhtml#lev111)” 中的 [第88页](ch04.xhtml#page_88)，你可以使用这种紧凑的密钥结构通过暴力破解路由密码，自动尝试数百个密钥，直到明文被恢复。
- en: '**Designing, Populating, and Depopulating the Matrix**'
  id: totrans-39
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**设计、填充和清空矩阵**'
- en: 'You’ll input the ciphertext as a continuous string. For your program to unravel
    the route through this string, you’ll first need to build and populate a translation
    matrix. The ciphertext string is just the columns in the transposition matrix
    in [Figure 4-3](ch04.xhtml#ch04fig3) laid end to end, in the order they were read.
    And as there are five rows in the transposition matrix, every group of five elements
    in the ciphertext represents a separate column. You can represent this matrix
    with a list of lists:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你将输入密文作为一个连续的字符串。为了让程序解开该字符串中的路由，你首先需要构建并填充一个转换矩阵。密文字符串只是置换矩阵中的列，在 [图4-3](ch04.xhtml#ch04fig3)
    中按顺序连接在一起的结果。由于置换矩阵有五行，密文中的每五个元素表示一个单独的列。你可以使用一个列表的列表来表示这个矩阵：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The items in this new list now represent lists—with each list representing
    a column—and the five elements in each list represent the rows that comprise that
    column. This is a little hard to see, so let’s print each of these nested lists
    on a separate line:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新列表中的每一项现在代表一个列表——每个列表代表一列——而每个列表中的五个元素代表组成该列的行。这有点难理解，所以我们将在单独的行中打印每一个这些嵌套列表：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you read each list left to right, starting at the top, you follow the transposition
    route, which was up and down alternate columns (see [Figure 4-3](ch04.xhtml#ch04fig3)).
    From Python’s point of view, the first column read is `list-of-lists[0]`, and
    the starting point is `list-of-lists[0][0]`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从左到右读取每个列表，从顶部开始，你将沿着换位路径进行读取，该路径是上下交替的列（参见[图 4-3](ch04.xhtml#ch04fig3)）。从Python的角度来看，第一个读取的列是`list-of-lists[0]`，起始点是`list-of-lists[0][0]`。
- en: 'Now, normalize the route by reading all columns in the same direction as the
    starting column (up). This requires reversing the order of elements in every other
    list, as shown in bold here:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过按照与起始列相同的方向（向上）读取所有列来规范化路线。这需要反转每个其他列表中元素的顺序，如下所示，已加粗显示：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: A pattern emerges. If you start at the upper right and read down each column,
    ending at the lower left, the numbers are in numerical order; you’ve restored
    the plaintext!
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一个模式浮现出来。如果你从右上角开始，向下读取每一列，直到左下角，数字将按数字顺序排列；你已恢复明文！
- en: 'To replicate this, your script can loop through every nested list, removing
    the last item in that list and adding the item to a new string, until the translation
    matrix has been emptied. The script will know from the key which nested lists
    it needs to reverse and the order in which to depopulate the matrix. The output
    will be a string of the restored plaintext:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了复制这一点，你的脚本可以遍历每个嵌套列表，移除该列表中的最后一个项并将该项添加到一个新的字符串中，直到翻译矩阵被清空。脚本将通过密钥知道它需要反转哪些嵌套列表，并知道依次清空矩阵的顺序。输出将是一个恢复后的明文字符串：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You should now have a very general view of the strategy. Let’s get more descriptive
    and write the pseudocode next.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该对策略有了一个非常概括的理解。接下来，让我们更详细地描述，并编写伪代码。
- en: '***The Pseudocode***'
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***伪代码***'
- en: 'The script can be broken up into three major parts: user input, translation
    matrix population, and decryption to plaintext. You should be able to see these
    parts in the following pseudocode:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本可以分为三个主要部分：用户输入、翻译矩阵填充和解密为明文。你应该能够在下面的伪代码中看到这些部分：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Everything before the first loop is essentially just collecting and reformatting
    the cipher data. The first loop is responsible for building and populating the
    matrix, and the second loop creates a translation string from that matrix. Finally,
    the translation string is printed.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 循环前的所有内容基本上只是收集和重新格式化密码数据。第一个循环负责构建和填充矩阵，第二个循环从该矩阵中创建一个翻译字符串。最后，打印出翻译字符串。
- en: '***The Route Cipher Decryption Code***'
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***路线密码解密代码***'
- en: '[Listing 4-1](ch04.xhtml#ch04list1) takes a message encrypted with the route
    cipher, the number of columns and rows in the transposition matrix, and a key
    and then displays the translated plaintext. It will decrypt all “common” route
    ciphers, where the route starts at the top or bottom of a column and continues
    up and/or down columns.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 4-1](ch04.xhtml#ch04list1)接受一个使用路线密码加密的消息、换位矩阵中的列数和行数，以及一个密钥，然后显示翻译后的明文。它将解密所有“常见”的路线密码，其中路线从列的顶部或底部开始，并沿着列向上和/或向下继续。'
- en: This is the prototype version; once you’re sure it’s working, you’ll package
    it for others to use. You can download this code at *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这是原型版本；一旦你确认它可以正常工作，你可以将其打包供其他人使用。你可以在*[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*下载此代码。
- en: '*route_cipher_decrypt_prototype.py*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*route_cipher_decrypt_prototype.py*'
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 4-1: Code for* route_cipher_decrypt_prototype.py'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-1：* route_cipher_decrypt_prototype.py的代码'
- en: Start by loading the ciphertext ➊ as a string. You want to deal with words,
    not letters, so split the string apart based on empty spaces using the `split()`
    string method to create a new list named `cipherlist` ➋. The `split()` method
    is the inverse of the `join()` method, which you’ve seen before. You can split
    on any string; the method just defaults to runs of consecutive whitespace, deleting
    each whitespace before it moves to the next.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 从将密文➊作为字符串加载开始。你要处理的是单词而不是字母，因此根据空格使用`split()`字符串方法将字符串分开，创建一个名为`cipherlist`的新列表➋。`split()`方法是`join()`方法的反操作，你之前见过。你可以在任何字符串上进行分割；该方法默认为连续的空白字符运行，删除每个空白字符后才移至下一个。
- en: 'Now it’s time to input what you know about the cipher ➌: the columns and rows,
    which form the matrix, and the key, which contains the route. Initialize the column
    and row numbers as constants. Then make an empty list named `translation_matrix`
    to hold the contents of each column as a (nested) list. Assign placeholders by
    multiplying the value `None` by the number of columns. You can use the indexes
    of these empty items to put columns back in their correct order for keys that
    are not in numerical order.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候输入你对密码的了解了➌：列和行，这些构成了矩阵，还有包含路由的密钥。将列数和行数初始化为常量。然后创建一个名为`translation_matrix`的空列表，用来保存每列的内容作为（嵌套）列表。通过将值`None`乘以列数来分配占位符。你可以使用这些空项的索引将列按正确顺序放回原位，以应对密钥顺序不按数字排列的情况。
- en: An empty string named `plaintext` will hold the decrypted message. Next are
    some slicing parameters. Note that some of these are derived from the number of
    rows, which equates to the number of items in each column.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一个名为`plaintext`的空字符串将保存解密后的消息。接下来是一些切片参数。请注意，这些参数中的一些是根据行数推导出来的，行数等于每列中的项目数。
- en: Now, convert the key variable, which is a string, into a list of integers using
    *list comprehension*—a shorthand way of performing operations on lists ➍. You’ll
    use the numbers in the key as indexes later, so they need to be integers.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用*列表推导式*将密钥变量（一个字符串）转换为整数列表——这是一种对列表执行操作的简洁方式➍。你稍后会用密钥中的数字作为索引，因此它们需要是整数。
- en: The next block of code is a `for` loop that populates the `translation_matrix`,
    which is just a list of lists ➎. Since each column becomes a nested list and the
    length of the `key_int` list is equal to the number of columns, the range for
    the loop is the key, which also describes the route.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 下一段代码是一个`for`循环，它填充`translation_matrix`，它只是一个包含列表的列表➎。由于每列变成一个嵌套列表，并且`key_int`列表的长度等于列数，循环的范围就是密钥，它也描述了路由。
- en: Inside the loop, use a conditional to check whether the key is positive or negative
    ➏; if the key is positive, then the direction of the slice is reversed. Assign
    the slice to the correct position in `translation_matrix` based on the absolute
    key value and subtract 1 (since the keys don’t include 0, but the list indexes
    do). Finish the loop by advancing the slice endpoints by the number of rows and
    printing some useful information.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环内，使用条件判断密钥是正数还是负数➏；如果密钥是正数，那么切片的方向将被反转。根据绝对密钥值将切片分配到`translation_matrix`的正确位置，并减去
    1（因为密钥不包括 0，而列表索引是从 0 开始的）。通过将切片的端点按行数推进并打印一些有用的信息，完成循环。
- en: The final block ➐ loops through the number of rows—which is equivalent to the
    number of words in one of the nested lists—and through each nested list. The first
    two of these loops are shown in [Figure 4-4](ch04.xhtml#ch04fig4). As you stop
    in each nested list, you get to employ one of my favorite Python functions, the
    list `pop()` method ➑. The `pop()` method removes and returns the last item from
    a list, unless a specific index is provided. It destroys the nested list, but
    you’re done with it anyway.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一段代码➐遍历行数——这相当于嵌套列表中单词的数量——以及每个嵌套列表。这两次循环的前两次展示在[图 4-4](ch04.xhtml#ch04fig4)中。每当你停在每个嵌套列表时，就能使用我最喜欢的
    Python 函数之一——列表的`pop()`方法➑。`pop()`方法会移除并返回列表的最后一个项，除非提供了特定的索引。它销毁了嵌套列表，但反正你已经用完它了。
- en: '![image](../images/f0071-01.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0071-01.jpg)'
- en: '*Figure 4-4: First and second loop through the nested lists, removing and appending
    each end item to the translation string*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-4：第一次和第二次遍历嵌套列表，移除并将每个末尾项附加到翻译字符串*'
- en: 'As soon as you pop off a word, concatenate it to the `plaintext` string and
    add a space ➒. All that’s left to do is display the decrypted ciphertext. The
    output for the numeric test set looks like this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你弹出一个单词，就把它连接到`plaintext`字符串并加一个空格➒。剩下的就是显示解密后的密文。数字测试集的输出如下：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: That looks like success!
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 那看起来像是成功了！
- en: '***Hacking the Route Cipher***'
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***破解路由密码***'
- en: 'The preceding code assumes you know the route through the encryption matrix
    or have correctly guessed the key. If those assumptions aren’t true, your only
    recourse is to try every possible key and matrix arrangement. You’ll get a chance
    to automate the key selection process—for a given number of columns—in “[Route
    Transposition Cipher: Brute-Force Attack](ch04.xhtml#lev111)” on [page 88](ch04.xhtml#page_88).
    But, as you’ll see, the Union route cipher is well fortified against brute-force
    attacks. You can crack it, but you’ll end up with so much data, you’ll feel like
    the dog that chased a car and caught it.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码假设你已经知道加密矩阵的路径，或者已经正确猜测出密钥。如果这些假设不成立，你唯一的办法就是尝试每一个可能的密钥和矩阵排列。你可以在《[路由置换密码：暴力破解攻击](ch04.xhtml#lev111)》的第[88页](ch04.xhtml#page_88)中，自动化选择密钥的过程——对于特定列数。可是，正如你所看到的，联合路由密码对暴力破解攻击有很强的防护能力。你可以破解它，但你最终会获得大量数据，让你感觉就像那只追上了汽车并抓住它的狗。
- en: 'As messages get longer, the number of possible encryption paths in a transposition
    cipher becomes too large for a brute-force solution, even using modern computers.
    For example, if there are eight columns, and you allow the route to skip to any
    column, the number of ways to combine the columns is the factorial of eight: 8
    × 7 × 6 × 5 × 4 × 3 × 2 × 1 = 40,320\. That’s 40,320 paths *before* you start
    choosing alternative routes through the columns. If the route can change direction
    up or down a column, the number of combinations increases to 10,321,920\. And
    if you consider starting *anywhere* in a column—instead of at the very top or
    bottom—and allow *any* route through the matrix (such as spiraling), things will
    really start to get out of hand!'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 随着信息变长，置换密码中可能的加密路径数量变得过于庞大，甚至现代计算机也难以用暴力破解法解决。例如，如果有八列，并且允许路径跳过任何列，那么组合列的方式就是八的阶乘：8
    × 7 × 6 × 5 × 4 × 3 × 2 × 1 = 40,320。也就是说，40,320条路径*在*你开始选择不同的列路径之前。如果路径可以在列中上下变动，组合的数量就增加到10,321,920。若考虑到从列中的*任何*位置开始——而不是从顶部或底部——并允许*任何*矩阵路径（如螺旋状），那么情况就会变得更加复杂！
- en: For this reason, even short transposition ciphers can have thousands to millions
    of possible paths. Even if the number of paths is manageable for a computer and
    a brute-force attack may prevail, you’ll still need a way to sift through the
    myriad outcomes and either choose a winner computationally or select a small subset
    of candidates to visually examine.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个原因，即使是简单的置换密码，也可能拥有成千上万甚至数百万种可能的路径。即便路径数量对计算机来说是可管理的，且暴力破解攻击可能奏效，你仍然需要一种方法来筛选出无数的结果，并且无论是通过计算方式选出一个胜者，还是选择一小部分候选结果进行人工检查。
- en: For the more common *letter*-transposition ciphers, it’s easy to write a function
    that detects English by comparing each decryption attempt to a dictionary file.
    If the number of decrypted words belonging to a dictionary is greater than a certain
    threshold percentage, you’ve probably cracked the cipher. Likewise, if there’s
    a high frequency of common letter pairs (*digrams*)—like *er*, *th*, *on*, or
    *an*—you may have found the solution. Unfortunately, this approach won’t work
    for a *word*-transposition cipher like the one you’re using here.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更常见的*字母*置换密码，可以编写一个函数，通过将每次解密的尝试与字典文件进行比较，来检测是否为英语。如果解密出来的字典单词数量超过某个阈值百分比，那么你大概率破解了这个密码。同样，如果常见的字母对（*双字母组合*）出现频率较高，比如*er*、*th*、*on*或*an*，你可能已经找到了密码的解决方案。不幸的是，这种方法不适用于像你现在使用的*单词*置换密码。
- en: Dictionaries can’t help you figure out whether words have been arranged correctly.
    For word arrangement, you could try using approaches like grammatical rules and
    probabilistic language models, such as *n*-grams, combing through thousands of
    decryptions and picking candidate outcomes programmatically, but Stager’s wise
    use of code names and dummy words in his route cipher will greatly complicate
    the process.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 字典无法帮助你判断单词是否已经正确排列。对于单词排列，你可以尝试使用诸如语法规则和概率语言模型（例如*n*-gram）的方式，程序化地遍历数千个解密结果并挑选候选结果，但斯塔格在他的路由密码中巧妙地使用了代号和虚假单词，这将大大增加破解的难度。
- en: Cryptanalysts consider short, straight-up transposition ciphers to be fairly
    easy to crack without a computer, despite the issues just described. They look
    for common word or letter pairs that make sense, and use those to guess the number
    of rows in the transposition matrix.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 密码分析师认为，尽管存在上述问题，简单的、直白的置换密码在没有计算机的情况下还是相对容易破解的。他们会寻找有意义的常见单词或字母对，利用这些线索来猜测置换矩阵的行数。
- en: To illustrate, let’s use our control message composed of numbers. In [Figure
    4-5](ch04.xhtml#ch04fig5), you can see the ciphertext outcomes for a 4×5 matrix,
    each produced by starting at one of the four corners of the grid, and following
    an alternating, sequential route. All cases include repetition of adjacent numbers
    (shaded in [Figure 4-5](ch04.xhtml#ch04fig5)). These indicate where you’re moving
    laterally through the grid, and they provide clues to the design of the matrix
    and the route taken through it. You can immediately see that there were five rows,
    because the first of each common pair is a fifth word. Moreover, knowing there
    are 20 words in the message, you learn the number of columns was four (20 / 5
    = 4). Using the reasonable assumption that the plaintext message was written left
    to right, you can even guess the route. For example, if you start in the lower
    right, you go up to 3, then left to 2, then down to 18, then left to 17, then
    up to 1 and left to 0\. Of course, this would be more difficult with words, since
    the connection between words isn’t as explicit, but using numbers really makes
    the point.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，让我们使用由数字组成的控制信息。在[图4-5](ch04.xhtml#ch04fig5)中，你可以看到一个4×5矩阵的密文结果，每个结果都是从网格的四个角之一开始，按照交替的顺序路径进行的。所有情况都包含相邻数字的重复（在[图4-5](ch04.xhtml#ch04fig5)中用阴影标出）。这些重复表示你在网格中横向移动，并且提供了关于矩阵设计和所走路径的线索。你可以立即看到有五行，因为每对常见的数字对中的第一个是第五个单词。此外，知道消息中有20个单词，你可以推测列数为四（20
    / 5 = 4）。通过合理的假设，消息是从左到右写的，你甚至可以猜测路径。例如，如果你从右下角开始，你首先上移到3，然后左移到2，再下移到18，再左移到17，然后上移到1，最后左移到0。当然，使用单词时会更困难，因为单词之间的联系不如数字那样明确，但使用数字更能突显这一点。
- en: '![image](../images/f0073-01.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0073-01.jpg)'
- en: '*Figure 4-5: Characters or words in logical order (shaded) can be used to guess
    an encryption route.*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-5：按逻辑顺序排列的字符或单词（阴影部分）可以用于推测加密路径。*'
- en: Look at [Figure 4-6](ch04.xhtml#ch04fig6), based on the message in [Figure 4-2](ch04.xhtml#ch04fig2).
    End words and possible linked words, like “is just” or “heading to,” are shaded.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 看[图4-6](ch04.xhtml#ch04fig6)，这是基于[图4-2](ch04.xhtml#ch04fig2)中的消息。结束单词和可能的链接单词，如“is
    just”或“heading to”，被阴影标出。
- en: '![image](../images/f0073-02.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0073-02.jpg)'
- en: '*Figure 4-6: Human hacking of the route cipher in [Figure 4-2](ch04.xhtml#ch04fig2).
    A five-row matrix is indicated.*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-6：对[图4-2](ch04.xhtml#ch04fig2)中路线密码的人工破解。示出一个五行矩阵。*'
- en: There are 20 total words, for which there could be 4, 5, or 10 rows. It’s doubtful
    that a two-column matrix would be used, so we are realistically dealing with a
    4×5 or a 5×4 arrangement. If the route cipher path is like that in [Figure 4-5](ch04.xhtml#ch04fig5),
    then we’d expect to see two nonshaded words between shaded words for a four-row
    matrix and three nonshaded words for a five-row matrix. It’s harder to come up
    with sensical word pairs that honor the four-column pattern, regardless of which
    direction you read the ciphertext. So, we’re probably dealing with a five-column
    solution that starts on the left side of the matrix—since the linked words make
    sense read left to right.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 总共有20个单词，可以有4行、5行或10行。我们怀疑不会使用两列矩阵，因此我们实际处理的是4×5或5×4的排列。如果加密路径像[图4-5](ch04.xhtml#ch04fig5)所示，那么我们预期在四行矩阵中，每两个阴影单词之间会有两个非阴影单词，而在五行矩阵中会有三个非阴影单词。无论你从哪个方向阅读密文，按照四列模式来构思合理的单词对都更加困难。所以，我们可能在处理一个五列的解法，从矩阵的左侧开始——因为从左到右读取的链接单词是有意义的。
- en: 'Note how the shaded words in [Figure 4-6](ch04.xhtml#ch04fig6) fill out the
    top and bottom rows in the transposition matrix in [Figure 4-7](ch04.xhtml#ch04fig7).
    This is what we would expect, as the path is “turning around” at the top and bottom
    of every column. Graphical solutions: God’s gift to the innumerate!'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，[图4-6](ch04.xhtml#ch04fig6)中的阴影单词如何填充在[图4-7](ch04.xhtml#ch04fig7)中换位矩阵的顶部和底部行中。这是我们所期望的，因为路径在每一列的顶部和底部“转弯”了。图形化解决方案：上帝赐予不懂数学者的礼物！
- en: '![image](../images/f0074-01.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0074-01.jpg)'
- en: '*Figure 4-7: Shaded words in [Figure 4-6](ch04.xhtml#ch04fig6) placed in the
    transposition matrix*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-7：[图4-6](ch04.xhtml#ch04fig6)中的阴影单词放置在换位矩阵中*'
- en: This seemed easy, but then again, we know how a route cipher works. Confederate
    code breakers eventually discovered it too, but the use of code words denied them
    full entry into the system. To hack the codes, they needed a captured codebook
    or a large organization capable of acquiring and analyzing big data, which was
    beyond the reach of the Confederacy in the 19th century.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来很简单，但我们知道路由密码是如何工作的。联邦的破译员最终也发现了它，但密码词的使用让他们无法完全进入系统。要破解这些代码，他们需要一份捕获的密码本或一个能够获取并分析大数据的大型组织，而这在19世纪的南方联盟是无法实现的。
- en: '***Adding a User Interface***'
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***添加用户界面***'
- en: The second goal of this project is to write the code in such a way as to reduce
    human error, especially from those with less experience (including technicians,
    interns, peers, and telegraph clerks in 1864). Of course, the best way to make
    a program user-friendly is to include a *graphical user interface (GUI)*, but
    at times, this isn’t practical or possible. For example, code-cracking programs
    automatically loop through thousands of possible keys, and autogenerating these
    keys is easier than getting them directly from a user.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目的第二个目标是编写代码，减少人为错误，尤其是对于经验较少的人（包括技术人员、实习生、同事和1864年的电报员）。当然，使程序更具用户友好的最佳方法是包括一个*图形用户界面（GUI）*，但有时这并不实际或不可行。例如，破解代码程序会自动循环通过成千上万的可能密钥，自动生成这些密钥比直接从用户获取它们要容易。
- en: 'In this example, you’ll proceed with the assumption that the user will crack
    open the program file and enter some input or even make minor code changes. Here
    are some guidelines to follow:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你将假设用户会打开程序文件并输入一些内容，甚至做一些小的代码修改。以下是一些指南：
- en: Start with a useful docstring (see [Chapter 1](ch01.xhtml#ch01)).
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从有用的文档字符串开始（参见[第1章](ch01.xhtml#ch01)）。
- en: Place all required user input at the top.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有必需的用户输入放在最上面。
- en: Use comments to clarify input requirements.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用注释来澄清输入要求。
- en: Clearly separate user input from the remaining code.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清晰地将用户输入与其余代码分开。
- en: Encapsulate most processes in functions.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将大多数过程封装在函数中。
- en: Include functions to catch predictable user errors.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包括函数以捕捉可预测的用户错误。
- en: The nice thing about this approach is that no one’s intelligence gets insulted.
    If a user *wants* to scroll down and look at the code, or even change it, there’s
    nothing stopping them. If all they want to do is enter some values and get a black
    box solution, then they’re happy, too. And we’ve honored the spirit of Anson Stager
    by making things simple and reducing the chance for error.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的好处在于没有侮辱任何人的智商。如果用户*想*滚动查看代码，甚至修改代码，也没有任何障碍。如果他们只想输入一些值并获得一个黑盒解决方案，那么他们也会很高兴。而且，我们通过简化操作并减少出错的可能性，尊重了安森·斯塔格的精神。
- en: '**Instructing the User and Getting Input**'
  id: totrans-101
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**指导用户并获取输入**'
- en: '[Listing 4-2](ch04.xhtml#ch04list2) shows the prototype code repackaged for
    sharing with others. You can find this code at *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表4-2](ch04.xhtml#ch04list2)展示了重新打包后的原型代码，供与他人分享。你可以在* [https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*找到这段代码。'
- en: '*route_cipher_decrypt.py,* part 1'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*route_cipher_decrypt.py*，第1部分'
- en: '[PRE7]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 4-2: Docstring, imports, and user input for* route_cipher_decrypt.py'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表4-2：route_cipher_decrypt.py的文档字符串、导入和用户输入*'
- en: Start with a multiline docstring in triple quotes ➊. The docstring informs the
    user that the program only decrypts a typical route cipher—one that starts at
    either the top or bottom of a column—and how to enter the key information ➋. A
    diagram is included to help make the point.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个多行文档字符串开始 ➊。文档字符串告知用户该程序仅解密典型的路由密码——即从列的顶部或底部开始的密码——并告诉他们如何输入密钥信息 ➋。包含一个示意图以帮助说明。
- en: Next, import `sys` for access to system fonts and functions ➌. You’re going
    to check the user’s input for acceptance criteria, so you need to display messages
    in the shell in eye-catching red. Putting this `import` statement here is a catch-22\.
    Since the strategic goal is to hide the working code from the user, you really
    should apply this later in the program. But the Python convention of putting all
    `import` statements at the top is too strong to ignore.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，导入`sys`以访问系统字体和功能 ➌。你将检查用户输入是否符合接受标准，因此你需要在shell中以引人注目的红色显示消息。将这个`import`语句放在这里有些两难。由于战略目标是将工作代码隐藏起来，你应该在程序的后面应用它。但Python将所有`import`语句放在顶部的惯例太强大，无法忽视。
- en: Now for the input section. How often have you seen or dealt with code where
    inputs or changes have to be made *throughout* the program? This can be confusing
    for the author and even worse for another user. So, move all these important variables
    to the top for convenience, common courtesy, and error prevention.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是输入部分。你有多少次见过或处理过需要在程序中 *各处* 进行修改或输入的代码？这对作者来说可能很混乱，甚至对其他用户来说更加糟糕。因此，为了方便、礼貌和防止错误，将所有这些重要变量移到顶部。
- en: First, separate the input section with a line and then let the user know that
    they’re on deck with an all-caps comment ➍. The required inputs are clearly defined
    with comments. You can use triple quotes for the text input to better accommodate
    long snippets of text. Note that I’ve entered the string of numbers from [Figure
    4-3](ch04.xhtml#ch04fig3) ➎. Next, the user needs to add the number of columns
    and rows for the transposition matrix ➏, followed by the proposed (or known) key
    ➐.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，用一行分隔输入部分，然后通过全大写的注释提醒用户他们即将进行输入 ➍。必需的输入已经通过注释明确定义。你可以使用三重引号来处理文本输入，以便更好地容纳较长的文本片段。请注意，我已经输入了来自
    [图 4-3](ch04.xhtml#ch04fig3) 的数字串 ➎。接下来，用户需要添加转换矩阵的列数和行数 ➏，然后是提议的（或已知的）密钥 ➐。
- en: End the user input section with a declaration comment to that effect and a caution
    to not edit anything below the following line ➑. Then add some extra spaces to
    more clearly separate the input section from the rest of the program ➒.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户输入部分结束时，使用声明性注释标明，并提醒不要编辑以下行 ➑。然后添加一些额外的空格，以更清晰地将输入部分与程序的其余部分分开 ➒。
- en: '**Defining the main() Function**'
  id: totrans-111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**定义 main() 函数**'
- en: '[Listing 4-3](ch04.xhtml#ch04list3) defines the `main()` function, which runs
    the program and prints out the plaintext after the cipher is decoded. The `main()`
    function can be defined before or after the functions it calls, as long as it
    is the last function called.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 4-3](ch04.xhtml#ch04list3) 定义了 `main()` 函数，它运行程序并在解码后打印明文。`main()` 函数可以在它调用的函数之前或之后定义，只要它是最后被调用的函数。'
- en: '*route_cipher_decrypt.py,* part 2'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*route_cipher_decrypt.py，* 第二部分'
- en: '[PRE8]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 4-3: Defines the* main() *function*'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-3：定义了* main() *函数*'
- en: Start the `main()` function by printing the user input to the shell ➊. Then
    turn the ciphertext into a list by splitting on whitespace, as you did in the
    prototype code ➋.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 通过打印用户输入到 shell 来开始 `main()` 函数 ➊。然后，将密文按空格拆分成列表，正如你在原型代码中所做的那样 ➋。
- en: The next series of statements call functions you will define shortly. The first
    checks whether the input rows and columns are valid for the message length ➌.
    The second converts the `key` variable from a string to a list of integers ➍.
    The third builds the translation matrix ➎, and the fourth runs the decryption
    algorithm on the matrix and returns a plaintext string ➏. Finish `main()` by printing
    the plaintext ➐.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的系列语句调用了你将很快定义的函数。第一个函数检查输入的行和列是否适合消息长度 ➌。第二个函数将 `key` 变量从字符串转换为整数列表 ➍。第三个函数构建了转换矩阵
    ➎，第四个函数对矩阵运行解密算法并返回明文字符串 ➏。通过打印明文 ➐ 来完成 `main()` 函数。
- en: '**Verifying Data**'
  id: totrans-118
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**验证数据**'
- en: As you continue to package *route_cipher_decrypt.py* for the end user, you need
    to verify that the input is valid. [Listing 4-4](ch04.xhtml#ch04list4) anticipates
    common user errors and provides the user with helpful feedback and guidance.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当你继续为最终用户打包 *route_cipher_decrypt.py* 时，你需要验证输入是否有效。[清单 4-4](ch04.xhtml#ch04list4)
    预见了常见的用户错误，并为用户提供了有用的反馈和指导。
- en: '*route_cipher_decrypt.py,* part 3'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*route_cipher_decrypt.py，* 第三部分'
- en: '[PRE9]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 4-4: Defines functions for checking and prepping user input*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-4：定义了用于检查和准备用户输入的函数*'
- en: The `validate_col_row()` function checks that the input column and row numbers
    are appropriate for the length of the `cipherlist`, which you pass as an argument
    ➊. The transposition matrix is always the same size as the number of words in
    the message, so the number of columns and the number of rows have to be a factor
    of the message size. To determine all the permissible factors, first make an empty
    list to hold the factors and then get the length of the cipherlist. Use the *cipherlist*,
    rather than the input *ciphertext*, as the elements in the ciphertext are *letters*,
    not words.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`validate_col_row()` 函数检查输入的列数和行数是否适合 `cipherlist` 的长度，该长度作为参数传递 ➊。换位矩阵的大小始终与消息中的单词数量相同，因此列数和行数必须是消息大小的因子。要确定所有允许的因子，首先创建一个空列表来存储因子，然后获取
    `cipherlist` 的长度。使用 *cipherlist*，而不是输入的 *ciphertext*，因为密文中的元素是 *字母*，而不是单词。'
- en: Normally, to get the factors of a number, you would use a range of (`1,` number
    `+` `1`), but you don’t want these endpoints in the `factors` list, because a
    translation matrix with these dimensions would just be the plaintext. So exclude
    these values from the range ➋. Since a factor of a number divides evenly into
    that number, use the modulo operator (`%`) to find the factors and then append
    them to the `factors` list.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，若要获取一个数字的因子，你会使用范围（`1,` 数字`+` `1`），但你不希望这些端点出现在`factors`列表中，因为具有这些维度的翻译矩阵就是明文。所以将这些值从范围中排除
    ➋。由于一个数的因子可以整除该数，因此使用模运算符（`%`）来查找因子，并将它们添加到`factors`列表中。
- en: 'Next, display some useful information for the user: the length of the cipherlist
    and the acceptable choices for rows and columns ➌. Finally, multiply the user’s
    two choices together and compare the product to the length of the cipherlist.
    If they don’t match, print a red warning message in the shell (using our old `file=sys.stderr`
    trick) and terminate the program ➍. Use `sys.exit(1)`, as the `1` indicates an
    abnormal exit.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为用户显示一些有用的信息：密码列表的长度以及可接受的行列选择 ➌。最后，将用户的两个选择相乘，并将结果与密码列表的长度进行比较。如果它们不匹配，则在终端显示一个红色的警告消息（使用我们之前的`file=sys.stderr`技巧），并终止程序
    ➍。使用`sys.exit(1)`，其中`1`表示异常退出。
- en: Now define a function to check the key and convert it from a string to a list
    ➎. Pass it the `key` variable as an argument. Split out each item in `key` and
    convert it to an integer; name the list `key_int` to distinguish it from the user-entered
    `key` variable ➏. Next, determine the minimum and maximum values in the `key_int`
    list. Then use an `if` statement to make sure the list contains the same number
    of items as there are columns and none of the items in `key` is too large, too
    small, or equal to `0` ➐. Terminate the program with an error message if any of
    those criteria fail to pass ➑. Otherwise, return the `key_int` list ➒.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在定义一个函数来检查密钥，并将其从字符串转换为列表 ➎。将`key`变量作为参数传递给它。将`key`中的每一项分割出来并转换为整数；将该列表命名为`key_int`，以便与用户输入的`key`变量区分
    ➏。接下来，确定`key_int`列表中的最小值和最大值。然后使用`if`语句确保该列表包含的项数与列数相同，并且`key`中的项没有过大、过小或等于`0`
    ➐。如果任何条件不符合，程序将终止并显示错误消息 ➑。否则，返回`key_int`列表 ➒。
- en: '**Building and Decoding the Translation Matrix**'
  id: totrans-127
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**构建和解码翻译矩阵**'
- en: '[Listing 4-5](ch04.xhtml#ch04list5) defines two functions, one to build the
    translation matrix and one to decode it, and calls the `main()` function as a
    module or in stand-alone mode.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 4-5](ch04.xhtml#ch04list5)定义了两个函数，一个用于构建翻译矩阵，另一个用于解码翻译矩阵，并将`main()`函数作为模块或独立模式调用。'
- en: '*route_cipher_decrypt.py,* part 4'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*route_cipher_decrypt.py,* 第4部分'
- en: '[PRE10]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 4-5: Defines the functions for building and decoding the translation
    matrix*'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 4-5：定义了用于构建和解码翻译矩阵的函数*'
- en: These two functions represent encapsulation of code in the *route_cipher_decrypt_prototype.py*
    program. See [Listing 4-1](ch04.xhtml#ch04list1) for a detailed description.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数表示在*route_cipher_decrypt_prototype.py*程序中对代码的封装。详细描述请参见[列表 4-1](ch04.xhtml#ch04list1)。
- en: First, define a function to build the translation matrix; pass it the `key_int`
    and `cipherlist` variables as arguments ➊. Have the function return the list of
    lists.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，定义一个函数来构建翻译矩阵；将`key_int`和`cipherlist`变量作为参数传递给它 ➊。让该函数返回一个列表的列表。
- en: Next, bundle the decryption code, where you pop off the end of each nested list,
    as a function that uses the `translation_matrix` list as an argument ➋. Return
    the plaintext, which will be printed by the `main()` function.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将解密代码打包为一个函数，在这个函数中从每个嵌套列表的末尾弹出元素，并使用`translation_matrix`列表作为参数 ➋。返回明文，由`main()`函数打印出来。
- en: End with the conditional statement that lets the program run as a module or
    in stand-alone mode ➌.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 以条件语句结束，使得程序能够作为模块运行或独立运行 ➌。
- en: If you’re an occasional or one-time user of this code, you’ll appreciate how
    straightforward and approachable it is. If you plan to alter the code for your
    own purposes, you’ll also appreciate that the key variables are accessible and
    the major tasks are modularized. You won’t have to dig through the program to
    tease out what matters or understand the difference between arcane variables like
    `list1` and `list2`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只是偶尔或一次性使用这段代码，你会欣赏它的简单直观。如果你打算修改代码以便用于自己的目的，你也会欣赏到关键变量的可访问性以及主要任务的模块化。你不必深入程序中挖掘或理解像`list1`和`list2`这样难以理解的变量之间的区别。
- en: 'Here’s the output of the program, using the ciphertext from [Figure 4-3](ch04.xhtml#ch04fig3):'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是程序的输出，使用[图 4-3](ch04.xhtml#ch04fig3)中的密文：
- en: '[PRE11]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You should now be able to easily decrypt a route transposition cipher with
    a known key or test suspected routes by using the script’s clear and accessible
    interface to adjust the key. You’ll get a chance to truly crack one of these ciphers,
    by automatically trying every possible key, in “[Route Transposition Cipher: Brute-Force
    Attack](ch04.xhtml#lev111)” on [page 88](ch04.xhtml#page_88).'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该能够轻松地解密带有已知密钥的路线置换密码，或者使用脚本清晰且易于访问的界面调整密钥来测试怀疑的路线。你将有机会通过自动尝试每一个可能的密钥，真正破解这些密码，详见《[路线置换密码：暴力破解](ch04.xhtml#lev111)》，位于[第88页](ch04.xhtml#page_88)。
- en: '**Project #9: The Rail Fence Cipher**'
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**项目 #9：铁路栅栏密码**'
- en: Confederate officers and spies were pretty much on their own when it came to
    cryptography. This led to unsophisticated solutions, one of the favorites being
    the rail fence cipher, so named due to its resemblance to the zigzag pattern of
    a split-rail fence (shown in [Figure 4-8](ch04.xhtml#ch04fig8)).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 南方联邦的军官和间谍在密码学方面几乎是自给自足的。这导致了不太复杂的解决方案，其中之一就是铁路栅栏密码，由于其与分裂木栅栏的锯齿形状相似，因此得名（见[图
    4-8](ch04.xhtml#ch04fig8)）。
- en: '![image](../images/f0080-01.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0080-01.jpg)'
- en: '*Figure 4-8: A rail fence*'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-8：一座铁路栅栏*'
- en: The rail fence is a simple-to-use transposition cipher, like the Union’s route
    cipher, but differs from the route cipher in that it transposes letters rather
    than words, making it more error-prone. And since the number of possible keys
    is much more restrictive than the number of paths through a route cipher, the
    rail fence cipher is much easier to “tear down.”
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 铁路栅栏是一种简单易用的置换密码，像联邦的路线密码一样，但与路线密码不同的是，它是对字母进行置换而非单词，使其更容易出错。而且，由于可能的密钥数量远比路线密码中的路径数量有限，铁路栅栏密码也更容易被“破解”。
- en: Both the Union and Confederates used the rail fence as a field cipher, and the
    spies probably didn’t use code words very often. Codebooks needed to be tightly
    controlled, for obvious reasons, and were more likely to be secured in a military
    telegraph office than carried around by easily compromised undercover agents.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 联邦和南方都使用铁路栅栏作为场地密码，而间谍们可能并不经常使用密码词。密码本需要严格控制，显而易见的原因是它们更有可能保存在军事电报办公室，而不是随身携带，容易被渗透的卧底特工带走。
- en: 'Sometimes the Confederates used the more complex Vigenère cipher (see “[Project
    #12: Hiding a Vigenère Cipher](ch06.xhtml#lev130)” on [page 106](ch06.xhtml#page_106))
    for important messages—and some unimportant ones to mislead enemies—but it was
    tedious work to decipher and equally laborious to encrypt and not suitable for
    fast field communications.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '有时，南方联邦使用更复杂的维吉尼亚密码（见《[项目 #12：隐藏维吉尼亚密码](ch06.xhtml#lev130)》位于[第106页](ch06.xhtml#page_106)）用于重要消息——以及一些不重要的消息来误导敌人——但这是一项繁琐的解密工作，进行加密也同样费时，并不适合快速的现场通讯。'
- en: Despite their lack of training in the mechanics of cryptography, the Confederacy,
    and Southerners in general, were clever and innovative. Among their more impressive
    accomplishments in the art of secret messages was the use of microphotography,
    100 years before it was widely adopted during the Cold War.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管南方联邦及南方人普遍缺乏密码学方面的训练，但他们依然聪明且富有创新精神。他们在秘密消息艺术方面的成就之一，就是在冷战广泛采用之前100年，使用微型摄影。
- en: '**THE OBJECTIVE**'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标**'
- en: Write Python programs that will help a spy encrypt and decrypt a “two-rail”
    (two-row) rail fence cipher. You should write the programs in a way that will
    reduce potential errors by inexperienced users.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 编写 Python 程序，帮助间谍加密和解密“二轨”（两行）铁路栅栏密码。你应该以一种能够减少缺乏经验的用户操作错误的方式编写程序。
- en: '***The Strategy***'
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***策略***'
- en: To encrypt a message with the rail fence cipher, follow the steps in [Figure
    4-9](ch04.xhtml#ch04fig9).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用铁路栅栏密码加密信息，请按照[图 4-9](ch04.xhtml#ch04fig9)中的步骤操作。
- en: '![image](../images/f0081-01.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0081-01.jpg)'
- en: '*Figure 4-9: Encryption process for a “two-rail” rail fence cipher*'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-9：二轨铁路栅栏密码的加密过程*'
- en: After the plaintext is written, the spaces are removed, and all the letters
    are converted to uppercase (Step 2). Using uppercase is common convention in cryptography,
    as it obfuscates the presence of proper names and the beginning of sentences,
    giving a cryptanalyst fewer clues for deciphering the message.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 明文写完后，去掉空格，所有字母都转换为大写字母（步骤2）。使用大写字母是密码学中的常规做法，因为它掩盖了专有名词和句子的开头，从而给密码分析员提供了更少的线索来解密信息。
- en: The message is then written in stacked fashion, with every other letter below
    the previous letter and shifted over one space (Step 3). This is where the “rail
    fence” analogy becomes apparent.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将消息按堆叠的方式写出，每隔一个字母就将下一个字母写在前一个字母的下面，并且向右移动一个位置（步骤3）。这就是“铁丝栅栏”比喻的体现。
- en: The first row is then written, followed immediately by the second row on the
    same line (Step 4), and then the letters are broken into groups of five to create
    the illusion of distinct words and to further confuse the cryptanalyst (Step 5).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然后写出第一行，紧接着在同一行上写出第二行（步骤4），接着将字母分成五个一组，以制造出独立词的假象，并进一步迷惑密码分析师（步骤5）。
- en: To decrypt a rail fence cipher, reverse the process. Just remove the spaces,
    divide the message in half, stack the second half below the first, offset by one
    letter, and read the message using the zigzag pattern. If the ciphertext has an
    odd number of letters, put the extra letter in the first (upper) half.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要解密铁丝栅栏密码，逆向执行过程。只需去掉空格，将消息分为两半，将第二半放在第一半的下方，偏移一个字母，然后按之字形模式读取消息。如果密文的字母数是奇数，将多出的字母放在第一（上）半部分。
- en: To make things easy for people who want to use a rail fence cipher, follow the
    preceding steps to write two programs, one to encrypt and another to decrypt.
    [Figure 4-9](ch04.xhtml#ch04fig9) is essentially your pseudocode, so let’s get
    to it. And since you now know how to package the code for inexperienced users,
    take that approach from the start.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便希望使用铁丝栅栏密码的人，按照前面的步骤写两个程序，一个用来加密，另一个用来解密。[图4-9](ch04.xhtml#ch04fig9)本质上就是你的伪代码，接下来我们开始吧。既然你已经知道如何为缺乏经验的用户打包代码，从一开始就采用这种方法吧。
- en: '***The Rail Fence Cipher Encryption Code***'
  id: totrans-159
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***铁丝栅栏密码加密代码***'
- en: The code in this section allows a user to enter a plaintext message and have
    the encrypted results print in the interpreter window. This code is available
    for download with the book’s resources at *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的代码允许用户输入明文消息，并在解释器窗口中打印出加密结果。此代码可通过书本资源下载，网址为*[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*。
- en: '**Instructing the User and Getting Input**'
  id: totrans-161
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**指导用户并获取输入**'
- en: '[Listing 4-6](ch04.xhtml#ch04list6), at the top of *rail_fence_cipher_encrypt.py*,
    provides the program’s instructions and assigns the plaintext to a variable.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表4-6](ch04.xhtml#ch04list6)，位于*rail_fence_cipher_encrypt.py*的顶部，提供了程序的说明，并将明文赋值给一个变量。'
- en: '*rail_fence_cipher_encrypt.py,* part 1'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*rail_fence_cipher_encrypt.py,* 第一部分'
- en: '[PRE12]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 4-6: Docstring and user input section for* rail_fence_cipher_encrypt.py'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表4-6：rail_fence_cipher_encrypt.py的文档字符串和用户输入部分*'
- en: Start with a multiline docstring, placing an `r` (which stands for “raw”) prefix
    before the first set of triple quotes ➊. Without this prefix, Pylint will complain
    bitterly about the `\/\` slashes used further down. Fortunately, pydocstyle points
    this out so you can fix it (read [Chapter 1](ch01.xhtml#ch01) to learn all about
    Pylint and pydocstyle). If you want to know more about *raw strings*, see Section
    2.4.1 in the Python docs (*[https://docs.python.org/3.6/reference/lexical_analysis.html#string-and-bytes-literals](https://docs.python.org/3.6/reference/lexical_analysis.html#string-and-bytes-literals)*).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 从多行文档字符串开始，在第一组三重引号前加上`r`（表示“原始”）前缀 ➊。没有这个前缀，Pylint会对下文中的`\/\`斜杠报出严重警告。幸运的是，pydocstyle会指出这一点，你可以修复它（阅读[第1章](ch01.xhtml#ch01)了解更多关于Pylint和pydocstyle的信息）。如果你想了解更多关于*原始字符串*的内容，请参见Python文档中的第2.4.1节（*[https://docs.python.org/3.6/reference/lexical_analysis.html#string-and-bytes-literals](https://docs.python.org/3.6/reference/lexical_analysis.html#string-and-bytes-literals)*）。
- en: Next, separate the program’s docstring and `import` statements from the input
    section with a line and let the user know they’re on deck with an all-caps comment
    ➋. Clearly define the input requirement with comments and place the plaintext
    inside triple quotes to better accommodate long text strings ➌.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，用一行分隔程序的文档字符串和`import`语句与输入部分，并通过大写注释让用户知道他们要开始了 ➋。用注释清楚地定义输入要求，并将明文放入三重引号中，以更好地容纳长文本字符串
    ➌。
- en: Finally, end the user input section with a declaration to that effect and caution
    to not edit anything below the following line ➍.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，用声明结束用户输入部分，并提醒不要编辑以下内容 ➍。
- en: '**Encrypting a Message**'
  id: totrans-169
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**加密消息**'
- en: Add [Listing 4-7](ch04.xhtml#ch04list7) to *rail_fence_cipher_encrypt.py* in
    order to handle the encryption processes.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 将[列表4-7](ch04.xhtml#ch04list7)添加到*rail_fence_cipher_encrypt.py*中，以处理加密过程。
- en: '*rail_fence_cipher_encrypt.py,* part 2'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '*rail_fence_cipher_encrypt.py,* 第二部分'
- en: '[PRE13]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 4-7: Defines functions to encrypt the plaintext message*'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 4-7: 定义加密明文消息的函数*'
- en: 'To start, define a `main()` function to run the program ➊. Having a `main()`
    function gives you the flexibility to use this program as a module in another
    program later, should the need arise. This function calls three other functions:
    one to prepare the input plaintext, one to build the “rails” used by the cipher,
    and one to break the encrypted text into five-letter chunks.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，定义一个`main()`函数来运行程序 ➊。拥有一个`main()`函数可以让你在以后有需要时，将此程序作为模块在另一个程序中使用。这个函数调用了其他三个函数：一个用于准备输入的明文，一个用于构建加密所用的“rails”，以及一个用于将加密文本拆分成五个字母一组的块。
- en: Next, define a function to take the input string and prepare it for encryption
    ➋. This involves removing spaces ➌ and converting letters to uppercase (as in
    Step 2 in [Figure 4-9](ch04.xhtml#ch04fig9)) ➍. Then, after a newline, print the
    plaintext to the screen and return it.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，定义一个函数，用于处理输入字符串并为加密做准备 ➋。这个过程包括去除空格 ➌ 和将字母转换为大写（如[图4-9](ch04.xhtml#ch04fig9)的第2步所示）
    ➍。然后，换行后将明文打印到屏幕上并返回。
- en: Now, define a function to build two strings, as in Step 3 of [Figure 4-9](ch04.xhtml#ch04fig9),
    by slicing `message` for evens (starting at 0 and stepping by 2) and for odds
    (starting at 1 and stepping by 2) ➎. The two strings are then concatenated in
    a new string, named `rails` ➏, and returned.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，定义一个函数，按[图4-9](ch04.xhtml#ch04fig9)的第3步，将`message`字符串切片为偶数位置（从0开始，步长为2）和奇数位置（从1开始，步长为2）
    ➎。然后，将这两个字符串连接成一个新字符串，命名为`rails` ➏，并返回。
- en: Define an encryption function that takes the `rails` string as an argument ➐.
    Use list comprehension to split the ciphertext into chunks of five (as in Step
    5 of [Figure 4-9](ch04.xhtml#ch04fig9)) ➑. The encrypted text is then printed
    to the screen. Finish with the code to run the program as a module or in stand-alone
    mode ➒.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个加密函数，该函数以`rails`字符串作为参数 ➐。使用列表推导式将密文分成五个一组的块（如[图4-9](ch04.xhtml#ch04fig9)的第5步所示）
    ➑。然后，将加密文本打印到屏幕上。最后编写代码，以便在作为模块或独立模式下运行程序 ➒。
- en: 'Here is the output from this program:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是该程序的输出：
- en: '[PRE14]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '***The Rail Fence Cipher Decryption Code***'
  id: totrans-180
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Rail Fence Cipher 解密代码***'
- en: The code in this section allows a user to enter a message encrypted with the
    rail fence cipher and have the plaintext printed in the interpreter window. This
    code is available for download along with the rest of the book’s resources at
    *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分的代码允许用户输入使用rail fence cipher加密的消息，并在解释器窗口中显示明文。此代码可与本书的其他资源一起下载，网址为*[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*。
- en: '**Importing Modules, Instructing the User, and Getting Input**'
  id: totrans-182
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**导入模块，指示用户并获取输入**'
- en: '[Listing 4-8](ch04.xhtml#ch04list8) starts with instructions similar to those
    in the *rail_fence_cipher_encrypt.py* program ([Listing 4-6](ch04.xhtml#ch04list6)),
    imports two modules, and gets the user input.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 4-8](ch04.xhtml#ch04list8)开始的指令与*rail_fence_cipher_encrypt.py*程序中的指令类似（[Listing
    4-6](ch04.xhtml#ch04list6)），导入了两个模块，并获取了用户输入。'
- en: '*rail_fence_cipher_decrypt.py,* part 1'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '*rail_fence_cipher_decrypt.py*，第1部分'
- en: '[PRE15]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 4-8: Imports modules, instructs the user, and gets user input*'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 4-8: 导入模块，指示用户并获取用户输入*'
- en: One difference here is that you need to import the `math` and `itertools` modules
    ➊. You’ll use `math` for rounding. The `itertools` module is a group of functions
    in the Python Standard Library that create iterators for efficient looping. You’ll
    use `itertool`’s `zip_longest()` function during the decryption process.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的一个不同之处在于，你需要导入`math`和`itertools`模块 ➊。你将使用`math`进行四舍五入。`itertools`模块是Python标准库中的一组函数，能够创建用于高效循环的迭代器。你将在解密过程中使用`itertools`的`zip_longest()`函数。
- en: The only other change is that the user should enter ciphertext, rather than
    plaintext ➋.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的另一个变化是用户应该输入密文，而不是明文 ➋。
- en: '**Decrypting a Message**'
  id: totrans-189
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**解密消息**'
- en: '[Listing 4-9](ch04.xhtml#ch04list9) defines the functions for preparing and
    decoding the ciphertext and finishes off *rail_fence_cipher_decrypt.py*.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 4-9](ch04.xhtml#ch04list9)定义了用于准备和解码密文的函数，并完成了*rail_fence_cipher_decrypt.py*。'
- en: '*rail_fence_cipher_decrypt.py,* part 2'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '*rail_fence_cipher_decrypt.py*，第2部分'
- en: '[PRE16]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 4-9: Prepares, decodes, and prints the message*'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 4-9: 准备、解码并打印消息*'
- en: 'The `main()` function here ➊ is similar to the one used in the encryption program
    in [Listing 4-7](ch04.xhtml#ch04list7). Three functions are called: one to prepare
    the input string, one to “split the rails” in the rail fence cipher, and one to
    stitch the two rails back together into readable plaintext.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`main()`函数➊与[第4-7节](ch04.xhtml#ch04list7)中加密程序使用的函数相似。调用了三个函数：一个用于准备输入字符串，一个用于在栅栏密码中“分割轨道”，还有一个用于将两个轨道重新拼接成可读的明文。
- en: Start with a function that repeats the preprocessing steps used during encryption
    ➋. Remove the spaces between the five-letter chunks, as well as any other whitespace
    created during the pasting of the ciphertext, and print and return the ciphertext.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个函数开始，重复加密过程中使用的预处理步骤➋。移除五个字母块之间的空格，以及在粘贴密文时产生的其他空白字符，然后打印并返回密文。
- en: Next, you need to split the message back into two halves to reverse the encryption
    process ➌. As I mentioned in “[The Strategy](ch04.xhtml#lev97)” on [page 81](ch04.xhtml#page_81),
    the extra letter in a message with an odd number of characters is assigned to
    the top row. To address the odd-numbered case, use the `math.ceil()` method ➍.
    “Ceil” stands for “ceiling,” so when you divide by 2, the answer is always rounded
    up to the nearest integer. Assign this number to the `row_1_len` variable. Once
    you know the length of the first row, use that value and slicing to divide the
    `message` variable into two strings representing the rows ➎. End the function
    by returning the row variables.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要将消息分成两半，以逆转加密过程➌。正如我在[《策略》](ch04.xhtml#lev97)中提到的，[第81页](ch04.xhtml#page_81)上，字符数为奇数的消息中的额外字母被分配到顶部行。为了处理奇数情况，使用`math.ceil()`方法➍。“Ceil”代表“上限”，所以当你除以2时，答案总是向上舍入到最接近的整数。将这个数字赋值给`row_1_len`变量。知道了第一行的长度后，使用这个值和切片操作，将`message`变量分割成两个字符串，分别表示两行➎。最后，通过返回行变量来结束函数。
- en: Now it’s just a matter of choosing and joining every other letter from the rows
    to stitch the plaintext back together. Define a `decrypt()` function and pass
    it the strings for `row1` and `row2` ➏. Start the translation process by making
    an empty list to hold the results ➐. Next, you need an easy way to deal with cases
    where the ciphertext has an odd number of letters—resulting in two rows of different
    lengths—because Python prevents you from looping through two uneven sequences
    by raising an index-out-of-range error. This is why we’ve imported the `itertools`
    module—its functions help with looping to circumvent this problem.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，只需从两行中选择并连接每个其他字母，将明文拼接回来。定义一个`decrypt()`函数，并传入`row1`和`row2`字符串➏。通过创建一个空列表来存放结果，开始翻译过程➐。接下来，你需要一种简单的方法来处理密文字符数为奇数的情况——这样会导致两行长度不同——因为Python会通过抛出索引越界错误来阻止你遍历两个不等长的序列。这就是为什么我们导入了`itertools`模块——它的函数有助于循环遍历，绕过这个问题。
- en: The `itertools.zip_longest()` function accepts two strings as arguments and
    loops through them without complaint, appending a null value (`None`) to the `plaintext`
    list when it gets to the end of the shorter string ➑. You don’t want to print
    this null value, so if it’s there, remove it using the `pop()` method you applied
    in the route cipher code ➒. Complete the decryption process by printing the two
    rows (rails) to the screen, followed by the decrypted ciphertext.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`itertools.zip_longest()`函数接受两个字符串作为参数，并无怨无悔地循环遍历它们，在较短的字符串结束时向`plaintext`列表添加空值（`None`）➑。你不想打印这个空值，因此如果它存在，使用你在路线密码代码中应用的`pop()`方法将其移除➒。通过打印两个行（轨道）到屏幕上，接着是解密后的密文，完成解密过程。'
- en: 'End with the standard code for running the program as a module or in stand-alone
    mode ➓. The output from the program is as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 结束时使用标准代码，运行程序作为模块或独立模式➓。程序的输出如下：
- en: '[PRE17]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note that there will be no spaces between words, but that’s okay—you don’t want
    to leave the cryptanalyst feeling completely useless!
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，单词之间不会有空格，但没关系——你可不想让密码分析员完全无所作为！
- en: '**Summary**'
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: That completes our foray into Civil War ciphers. You wrote a program that helps
    a user decrypt a route cipher, and you gained valuable insights into how it works
    and how to hack it. You can implement an automated attack on the cipher in the
    following practice projects, but remember, with its many possible paths and use
    of code words, the Union route cipher is a tough nut to fully crack.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们对美国内战密码的探索。你编写了一个帮助用户解密路由密码的程序，并获得了关于密码如何工作及如何破解的宝贵见解。你可以在以下实践项目中实施对密码的自动化攻击，但请记住，凭借其众多可能的路径和使用代码词，联邦的路由密码仍然是一个难解的难题。
- en: Next, you wrote programs to encrypt and decrypt two-rail fence ciphers. Given
    how tedious and error-prone the manual encryption and decryption processes are,
    having an automated way to do most of the work would have been valuable to both
    sides in the war. And to further address these types of issues, you wrote your
    code to be user-friendly to the inexperienced cryptanalyst or spy.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你编写了程序来加密和解密二轨栅栏密码。考虑到手动加密和解密过程的繁琐和易出错，为战争中的双方提供一个自动化的方式来完成大部分工作将是非常有价值的。为了进一步解决这些问题，你编写的代码对没有经验的密码分析员或间谍来说也非常友好。
- en: '**Further Reading**'
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**进一步阅读**'
- en: More beginner-level Python programs for working with transposition ciphers are
    available in *Cracking Codes with Python* (No Starch Press, 2018) by Al Sweigart.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 更多适合初学者的 Python 程序，用于处理换位密码，可以在 Al Sweigart 的《用 Python 破解密码》（No Starch Press，2018年）一书中找到。
- en: 'Excellent and well-illustrated overviews of cryptography can be found in *Mysterious
    Messages: A History of Codes and Ciphers* (The Penguin Group, 2009) by Gary Blackwood
    and *The Code Book: The Science of Secrecy from Ancient Egypt to Quantum Cryptography*
    (Anchor, 2000) by Simon Singh.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Gary Blackwood 的《神秘信息：密码与密码学的历史》（企鹅出版社，2009年）和 Simon Singh 的《密码书：从古埃及到量子密码学的秘密科学》（Anchor出版社，2000年）提供了密码学的精彩和图文并茂的概述。
- en: The sites *[http://www.civilwarsignals.org/pages/crypto/crypto.html](http://www.civilwarsignals.org/pages/crypto/crypto.html)*
    and *[http://www.mathaware.org/mam/06/Sauerberg_route-essay.html](http://www.mathaware.org/mam/06/Sauerberg_route-essay.html)*
    include descriptions of Edward Porter Alexander’s attempt to solve a route cipher.
    Alexander was the father of the Confederate Army Signal Corps and a brilliant
    military innovator with many impressive accomplishments.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 网站 *[http://www.civilwarsignals.org/pages/crypto/crypto.html](http://www.civilwarsignals.org/pages/crypto/crypto.html)*
    和 *[http://www.mathaware.org/mam/06/Sauerberg_route-essay.html](http://www.mathaware.org/mam/06/Sauerberg_route-essay.html)*
    包含了 Edward Porter Alexander 尝试破解路由密码的描述。Alexander 是南方联邦军信号兵团的创始人，也是一个杰出的军事创新者，拥有许多令人印象深刻的成就。
- en: '**Practice Projects**'
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**实践项目**'
- en: Hone your cryptography skills with these projects. Solutions are available in
    the appendix and online.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些项目来提高你的密码学技能。解决方案可以在附录和在线找到。
- en: '***Hacking Lincoln***'
  id: totrans-211
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***破解林肯密码***'
- en: 'In his book, *Mysterious Messages: A History of Codes and Ciphers*, Gary Blackwood
    reproduces an actual message sent by Abraham Lincoln and encrypted with a route
    cipher:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在他的书《神秘信息：密码与密码学的历史》中，Gary Blackwood 复原了亚伯拉罕·林肯用路由密码加密并发送的实际信息：
- en: '**THIS OFF DETAINED ASCERTAIN WAYLAND CORRESPONDENTS OF AT WHY AND IF FILLS
    IT YOU GET THEY NEPTUNE THE TRIBUNE PLEASE ARE THEM CAN UP**'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**这个信息被滞留了，请确认为什么，若能填补，你会得到他们，海王星，公报，请与他们联系。**'
- en: Use the *route_cipher_decrypt.py* program to solve this cryptogram. The number
    of columns and rows must be factors of the message length, and the route starts
    in one of the corners, doesn’t skip columns, and alternates direction with every
    column change. The code word definitions and plaintext solution can be found in
    the appendix.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *route_cipher_decrypt.py* 程序来解密这个密码。列数和行数必须是消息长度的因数，路线从一个角落开始，不跳过列，并在每次更换列时改变方向。密码单词的定义和明文解答可以在附录中找到。
- en: '***Identifying Cipher Types***'
  id: totrans-215
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***识别密码类型***'
- en: The sooner you know what type of cipher you’re dealing with, the sooner you
    can break it. Word-transposition ciphers are easy to spot, but letter-transposition
    ciphers can look like letter-*substitution* ciphers. Fortunately, you can distinguish
    between the two by using the frequency of occurrence of letters in the ciphertext.
    Since the letters are just scrambled and not replaced in transposition ciphers,
    their frequency distribution will be the same as for the language in which the
    plaintext was written. An exception, however, is military messages, which use
    jargon and omit many common words. For these, you need a frequency table built
    from other military messages.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 你越早知道你正在处理的密码类型，就越早能够破解它。单词置换密码很容易识别，但字母置换密码可能看起来像字母的*替换*密码。幸运的是，你可以通过使用密文中字母出现的频率来区分这两者。由于字母仅被打乱而不是替换，在置换密码中，它们的频率分布将与明文所在语言的分布相同。然而，军事信息是一个例外，因为它们使用行话并省略了许多常见的单词。对于这些信息，你需要基于其他军事信息构建一个频率表。
- en: Write a Python program that takes a string of ciphertext as input and determines
    whether it is more likely to be a transposition cipher or a substitution cipher.
    Test it with the files *cipher_a.txt* and *cipher_b.txt*, downloadable from *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*.
    A solution can be found in the appendix and online at the book’s website in *identify_cipher_type_practice.py*.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个Python程序，接受一个密文字符串作为输入，并确定它更可能是置换密码还是替换密码。使用* cipher_a.txt *和* cipher_b.txt
    *文件进行测试，这些文件可以从*[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*下载。解决方案可以在附录中找到，也可以在本书网站的*identify_cipher_type_practice.py*中找到。
- en: '***Storing a Key as a Dictionary***'
  id: totrans-218
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***将密钥存储为字典***'
- en: 'Write a short script to break a route cipher key into two parts: one to record
    the column order and one to record the direction to read through the rows in the
    column (up or down). Store the column number as a dictionary key and the reading
    direction as the dictionary value. Have the program interactively request the
    key value for each column from the user. A solution can be found in the appendix
    and online in the file *key_dictionary_practice.py.*'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个简短的脚本，将路径密码的密钥拆分为两部分：一部分记录列的顺序，另一部分记录通过列中的行阅读的方向（向上或向下）。将列号作为字典的键，阅读方向作为字典的值。让程序交互式地请求用户为每一列输入密钥值。解决方案可以在附录中找到，并在线在*key_dictionary_practice.py*文件中提供。
- en: '***Automating Possible Keys***'
  id: totrans-220
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***自动化可能的密钥***'
- en: To attempt to decipher a route cipher using any combination of columns in its
    path, you need to know what those combinations are, so you can enter them as arguments
    in a decryption function. Write a Python program that accepts an integer (such
    as the number of columns) and returns a collection of tuples. Each tuple should
    contain a unique ordering of column numbers, like `(1, 2, 3, 4)`. Include negative
    values—for example, `(2, -3, 4, -1``)`—to capture encryption routes that go up
    columns versus down. A solution is provided in the appendix, with a downloadable
    version on the book’s website in *permutations_practice.py*.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试解密路径密码，使用路径中任何列的组合，你需要知道这些组合是什么，以便将它们作为参数输入解密函数。编写一个Python程序，接受一个整数（例如列数）并返回一个元组集合。每个元组应包含列号的唯一排列，如`(1,
    2, 3, 4)`。包括负值——例如`(2, -3, 4, -1)`——以捕捉向上或向下遍历列的加密路径。解决方案在附录中提供，并可以在本书网站的*permutations_practice.py*中下载。
- en: '***Route Transposition Cipher: Brute-Force Attack***'
  id: totrans-222
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***路径置换密码：暴力破解***'
- en: Copy and modify the *route_cipher_decrypt.py* program to hack the route cipher
    in [Figure 4-2](ch04.xhtml#ch04fig2). Rather than inputting a single key, loop
    through all possible keys—for an assumed number of columns—and print the results
    (use the earlier permutations code to generate the keys for this four-column cipher).
    The impact of switching the order of columns and allowing up-and-down paths through
    the transposition matrix is clearly illustrated in [Figure 4-10](ch04.xhtml#ch04fig10).
    The dashed line is the factorial of the number of columns; the solid line captures
    the effect of reading up columns as well as down (captured by the inclusion of
    negative values in the key). If you only needed to deal with the factorial of
    4, your job as a cryptanalyst would be easy. But as the cipher gets longer, the
    number of possible keys explodes. And some actual Union route ciphers had 10 or
    more columns!
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 复制并修改 *route_cipher_decrypt.py* 程序，破解[图4-2](ch04.xhtml#ch04fig2)中的路线密码。与其输入单一密钥，不如循环遍历所有可能的密钥—假设列数已知—并打印出结果（使用早期的排列代码生成这个四列密码的密钥）。列的顺序变换以及通过转置矩阵上下来回路径的影响在[图4-10](ch04.xhtml#ch04fig10)中有清晰展示。虚线代表列数的阶乘；实线显示了上下读取列的效果（由密钥中的负值体现）。如果你只需要处理4的阶乘，那么作为密码分析师，你的工作会很轻松。但随着密码长度的增加，可能的密钥数量会激增。而一些实际的联邦路线密码有10列或更多！
- en: '![image](../images/f0089-01.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0089-01.jpg)'
- en: '*Figure 4-10: Number of possible keys versus number of columns for a route
    cipher*'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-10：路线密码的可能密钥数与列数的关系*'
- en: 'Here are four translations out of the 384 produced for the ciphertext in [Figure
    4-2](ch04.xhtml#ch04fig2):'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是384种由[图4-2](ch04.xhtml#ch04fig2)加密文本生成的四个翻译：
- en: '[PRE18]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The correct answer is present, but you can appreciate how hard it would be to
    pick it out quickly, given the use of code words and dummy words. Still, you did
    your job. Go have that mint julep or some sweet tea.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 正确答案已经给出，但你可以理解，在使用了密码词和虚拟词的情况下，快速找出它有多么困难。不过，你做到了你的工作。去喝一杯薄荷酒或者一些甜茶吧。
- en: A solution to this project is provided in the appendix and at *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*
    in *route_cipher_hacker.py*. You will also need the *perms.py* program, which
    is based on the previous practice project.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目的解决方案在附录和 *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*
    中提供，文件名为 *route_cipher_hacker.py*。你还需要使用 *perms.py* 程序，它基于之前的实践项目。
- en: '**Challenge Projects**'
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**挑战项目**'
- en: No solutions are provided for challenge projects.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战项目没有提供解决方案。
- en: '***Route Cipher Encoder***'
  id: totrans-232
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***路线密码编码器***'
- en: A greenhorn Union telegraph clerk needs to encrypt the following message, complete
    with code words ([Table 4-1](ch04.xhtml#ch04tab1)). Help them out by writing a
    program that takes the message as input and automatically substitutes the code
    words, fills the bottom row with dummy words, and transposes the words using the
    key `[-1, 3, -2, 6, 5, -4]`. Use a 6×7 matrix and make up your own dummy words.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 一位初出茅庐的联邦电报员需要加密以下消息，并附上密码词（[表 4-1](ch04.xhtml#ch04tab1)）。通过编写一个程序来帮助他们，该程序将消息作为输入，自动替换密码词，使用虚拟词填充底行，并使用密钥`[-1,
    3, -2, 6, 5, -4]`转置这些词。使用一个6×7的矩阵，并自行编造虚拟词。
- en: We will run the batteries at Vicksburg the night of April 16 and proceed to
    Grand Gulf where we will reduce the forts. Be prepared to cross the river on April
    25 or 29\. Admiral Porter.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在4月16日晚上在维克斯堡执行炮火任务，然后前往大湾口，在那里我们将减少要塞。准备在4月25日或29日过河。波特海军上将。
- en: '**Table 4-1:** Code Words'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 4-1：** 密码词'
- en: '| Batteries | HOUNDS |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| 电池 | HOUNDS |'
- en: '| Vicksburg | ODOR |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| 维克斯堡 | ODOR |'
- en: '| April | CLAYTON |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| 四月 | CLAYTON |'
- en: '| 16 | SWEET |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| 16 | SWEET |'
- en: '| Grand | TREE |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| 大湾口 | TREE |'
- en: '| Gulf | OWL |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| 大湾口 | OWL |'
- en: '| Forts | BAILEY |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| 要塞 | BAILEY |'
- en: '| River | HICKORY |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| 河流 | HICKORY |'
- en: '| 25 | MULTIPLY |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| 25 | MULTIPLY |'
- en: '| 29 | ADD |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| 29 | ADD |'
- en: '| Admiral | HERMES |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| 海军上将 | HERMES |'
- en: '| Porter | LANGFORD |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| 波特 | LANGFORD |'
- en: Consider using a Python dictionary for the lexicon of code words in this table.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑使用Python字典来存储本表中的密码词词汇。
- en: '***Three-Rail Fence Cipher***'
  id: totrans-249
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***三轨篱笆密码***'
- en: Write a version of the rail fence cipher that uses three rails (rows) instead
    of two. You can find a hint at *[https://en.wikipedia.org/wiki/Rail_fence_cipher](https://en.wikipedia.org/wiki/Rail_fence_cipher)*.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 写一个版本的铁路篱笆密码，它使用三个轨道（行）而不是两个。你可以在 *[https://en.wikipedia.org/wiki/Rail_fence_cipher](https://en.wikipedia.org/wiki/Rail_fence_cipher)*
    上找到提示。
