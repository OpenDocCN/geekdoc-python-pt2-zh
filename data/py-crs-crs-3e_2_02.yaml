- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Testing Your Code
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 测试你的代码
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: When you write a function or a class, you can also write tests for that code.
    Testing proves that your code works as it’s supposed to in response to all the
    kinds of input it’s designed to receive. When you write tests, you can be confident
    that your code will work correctly as more people begin to use your programs.
    You’ll also be able to test new code as you add it, to make sure your changes
    don’t break your program’s existing behavior. Every programmer makes mistakes,
    so every programmer must test their code often, to catch problems before users
    encounter them.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写函数或类时，你还可以为这些代码编写测试。测试可以证明你的代码在响应它设计要接收的所有输入时能够按预期工作。当你编写测试时，你可以确信，随着越来越多的人开始使用你的程序，你的代码会正确运行。你还可以在添加新代码时进行测试，确保你的修改不会破坏程序原有的行为。每个程序员都会犯错，因此每个程序员都必须经常测试他们的代码，以便在用户遇到问题之前发现并解决问题。
- en: In this chapter, you’ll learn to test your code using `pytest`. The `pytest`
    library is a collection of tools that will help you write your first tests quickly
    and simply, while supporting your tests as they grow in complexity along with
    your projects. Python doesn’t include `pytest` by default, so you’ll learn to
    install external libraries. Knowing how to install external libraries will make
    a wide variety of well-designed code available to you. These libraries will expand
    the kinds of projects you can work on immensely.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何使用`pytest`来测试你的代码。`pytest`库是一套工具集，可以帮助你快速而简单地编写你的第一个测试，并在你的项目复杂性增加时，支持你的测试。Python
    默认不包括`pytest`，所以你将学习如何安装外部库。知道如何安装外部库将使你可以使用各种设计良好的代码。这些库将极大扩展你可以从事的项目类型。
- en: You’ll learn to build a series of tests and check that each set of inputs results
    in the output you want. You’ll see what a passing test looks like and what a failing
    test looks like, and you’ll learn how a failing test can help you improve your
    code. You’ll learn to test functions and classes, and you’ll start to understand
    how many tests to write for a project.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你将学习构建一系列测试，并检查每一组输入是否产生你想要的输出。你将看到通过的测试是什么样的，失败的测试是什么样的，你还将学习如何利用失败的测试来改进代码。你将学会测试函数和类，并开始理解为一个项目编写多少测试。
- en: Installing pytest with pip
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 pip 安装 pytest
- en: While Python includes a lot of functionality in the standard library, Python
    developers also depend heavily on third-party packages. A *third-party package*
    is a library that’s developed outside the core Python language. Some popular third-party
    libraries are eventually adopted into the standard library, and end up being included
    in most Python installations from that point forward. This happens most often
    with libraries that are unlikely to change much once they’ve had their initial
    bugs worked out. These kinds of libraries can evolve at the same pace as the overall
    language.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Python 在标准库中包含了很多功能，但 Python 开发者也非常依赖第三方包。*第三方包*是指在核心 Python 语言之外开发的库。一些流行的第三方库最终会被纳入标准库，并且从那时起将包含在大多数
    Python 安装中。这种情况通常发生在那些一旦修复了初始错误就不太可能发生重大变化的库上。这类库可以与整体语言的发展速度保持一致。
- en: Many packages, however, are kept out of the standard library so they can be
    developed on a timeline independent of the language itself. These packages tend
    to be updated more frequently than they would be if they were tied to Python’s
    development schedule. This is true of `pytest` and most of the libraries we’ll
    use in the second half of this book. You shouldn’t blindly trust every third-party
    package, but you also shouldn’t be put off by the fact that a lot of important
    functionality is implemented through such packages.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，许多软件包被排除在标准库之外，以便它们可以在独立于语言本身的时间表上进行开发。这些软件包的更新频率通常比如果它们与 Python 的开发进度挂钩时要高。这对于`pytest`以及我们将在本书后半部分使用的大多数库来说都是如此。你不应该盲目相信每一个第三方包，但也不应该因为很多重要功能是通过这些包来实现的而感到排斥。
- en: Updating pip
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新 pip
- en: Python includes a tool called pip that’s used to install third-party packages.
    Because pip helps install packages from external resources, it’s updated often
    to address potential security issues. So, we’ll start by updating pip.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Python 包含了一个叫做 pip 的工具，用于安装第三方包。由于 pip 帮助从外部资源安装包，它会经常更新，以解决潜在的安全问题。因此，我们首先会更新
    pip。
- en: 'Open a new terminal window and issue the following command:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个新的终端窗口，并执行以下命令：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first part of this command, `python -m pip`, tells Python to run the module
    `pip`. The second part, `install --upgrade`, tells pip to update a package that’s
    already been installed. The last part, `pip`, specifies which third-party package
    should be updated. The output shows that my current version of pip, version 22.0.4
    ❶, was replaced by the latest version at the time of this writing, 22.1.2 ❷.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令的第一部分 `python -m pip` 告诉 Python 运行 `pip` 模块。第二部分 `install --upgrade` 告诉
    pip 更新已经安装的包。最后一部分 `pip` 指定了要更新的第三方包。输出显示我的当前 pip 版本是 22.0.4 ❶，被替换为写作时的最新版本 22.1.2
    ❷。
- en: 'You can use this command to update any third-party package installed on your
    system:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这个命令来更新系统上安装的任何第三方包：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Installing pytest
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装 pytest
- en: 'Now that pip is up to date, we can install `pytest`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 既然 pip 已经是最新版本，我们可以安装 `pytest`：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We’re still using the core command `pip install`, without the `--upgrade` flag
    this time. Instead, we’re using the `--user` flag, which tells Python to install
    this package for the current user only. The output shows that the latest version
    of `pytest` was successfully installed, along with a number of other packages
    that `pytest` depends on.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然使用核心命令 `pip install`，这次没有 `--upgrade` 标志。相反，我们使用了 `--user` 标志，它告诉 Python
    只为当前用户安装这个包。输出显示 `pytest` 的最新版本已成功安装，并且安装了 `pytest` 依赖的其他一些包。
- en: 'You can use this command to install many third-party packages:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这个命令来安装许多第三方包：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Testing a Function
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试一个函数
- en: 'To learn about testing, we need code to test. Here’s a simple function that
    takes in a first and last name, and returns a neatly formatted full name:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解测试，我们需要一些代码来进行测试。这里有一个简单的函数，它接受名字和姓氏，并返回格式化的全名：
- en: '**name_function.py**'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**name_function.py**'
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The function `get_formatted_name()` combines the first and last name with a
    space in between to complete a full name, and then capitalizes and returns the
    full name. To check that `get_formatted_name()` works, let’s make a program that
    uses this function. The program *names.py* lets users enter a first and last name,
    and see a neatly formatted full name:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_formatted_name()` 函数将名字和姓氏结合，中间用空格隔开，完成全名的拼接，然后将全名首字母大写并返回。为了检查 `get_formatted_name()`
    是否正常工作，让我们编写一个使用此函数的程序。程序 *names.py* 让用户输入名字和姓氏，并显示格式化的全名：'
- en: '**names.py**'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**names.py**'
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This program imports `get_formatted_name()` from *name_function.py*. The user
    can enter a series of first and last names and see the formatted full names that
    are generated:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序从 *name_function.py* 导入 `get_formatted_name()`。用户可以输入一系列名字和姓氏，并查看生成的格式化全名：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We can see that the names generated here are correct. But say we want to modify
    `get_formatted_name()` so it can also handle middle names. As we do so, we want
    to make sure we don’t break the way the function handles names that have only
    a first and last name. We could test our code by running *names.py* and entering
    a name like `Janis Joplin` every time we modify `get_formatted_name()`, but that
    would become tedious. Fortunately, `pytest` provides an efficient way to automate
    the testing of a function’s output. If we automate the testing of `get_formatted_name()`,
    we can always be confident that the function will work when given the kinds of
    names we’ve written tests for.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到这里生成的名字是正确的。但是假设我们想修改 `get_formatted_name()` 以便它也能处理中间名。在我们做这项修改时，我们希望确保不会破坏函数对只有名字和姓氏的处理方式。我们可以通过运行
    *names.py* 并每次修改 `get_formatted_name()` 时输入一个名字，如 `Janis Joplin`，来测试我们的代码，但这样会变得很繁琐。幸运的是，`pytest`
    提供了一种有效的方法来自动化测试函数的输出。如果我们自动化测试 `get_formatted_name()`，我们就可以始终确保在输入我们已编写测试的名字时，函数能够正常工作。
- en: Unit Tests and Test Cases
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单元测试和测试用例
- en: There is a wide variety of approaches to testing software. One of the simplest
    kinds of test is a unit test. A *unit test* verifies that one specific aspect
    of a function’s behavior is correct. A *test case* is a collection of unit tests
    that together prove that a function behaves as it’s supposed to, within the full
    range of situations you expect it to handle.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 软件测试有许多种方法。最简单的测试之一就是单元测试。*单元测试* 验证函数行为的某一特定方面是否正确。*测试用例* 是一组单元测试，它们共同证明函数在你期望的所有情境下的行为是正确的。
- en: A good test case considers all the possible kinds of input a function could
    receive and includes tests to represent each of these situations. A test case
    with *full coverage* includes a full range of unit tests covering all the possible
    ways you can use a function. Achieving full coverage on a large project can be
    daunting. It’s often good enough to write tests for your code’s critical behaviors
    and then aim for full coverage only if the project starts to see widespread use.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的测试用例会考虑函数可能接收到的所有输入类型，并包括能够代表这些情况的测试。一个*完整覆盖*的测试用例包括对所有可能使用方式的单元测试。对于大型项目而言，达到完全覆盖可能是一个巨大的挑战。通常，只需编写针对代码关键行为的测试，只有当项目开始广泛使用时，才需要追求完全覆盖。
- en: A Passing Test
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过测试
- en: With `pytest`, writing your first unit test is pretty straightforward. We’ll
    write a single test function. The test function will call the function we’re testing,
    and we’ll make an assertion about the value that’s returned. If our assertion
    is correct, the test will pass; if the assertion is incorrect, the test will fail.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`pytest`，编写你的第一个单元测试是非常直接的。我们将编写一个简单的测试函数。测试函数将调用我们要测试的函数，然后我们会对返回的值进行断言。如果断言正确，测试将通过；如果断言错误，测试将失败。
- en: 'Here’s the first test of the function `get_formatted_name()`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`get_formatted_name()`函数的第一个测试：
- en: '**test_name_function.py**'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**test_name_function.py**'
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Before we run the test, let’s take a closer look at this function. The name
    of a test file is important; it must start with *test_*. When we ask `pytest`
    to run the tests we’ve written, it will look for any file that begins with *test_*,
    and run all of the tests it finds in that file.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们运行测试之前，让我们仔细看看这个函数。测试文件的名称很重要；它必须以*test_*开头。当我们请求`pytest`运行我们编写的测试时，它会查找任何以*test_*开头的文件，并运行该文件中的所有测试。
- en: 'In the test file, we first import the function that we want to test: `get_formatted_name()`.
    Then we define a test function: in this case, `test_first_last_name()` ❶. This
    is a longer function name than we’ve been using, for a good reason. First, test
    functions need to start with the word *test*, followed by an underscore. Any function
    that starts with `test_` will be *discovered* by `pytest`, and will be run as
    part of the testing process.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试文件中，我们首先导入我们要测试的函数：`get_formatted_name()`。然后我们定义一个测试函数：在这种情况下是`test_first_last_name()`
    ❶。这个函数名比我们之前使用的要长，原因是好的。首先，测试函数需要以*test*开头，后跟一个下划线。任何以`test_`开头的函数都将被`pytest`*发现*，并在测试过程中运行。
- en: Also, test names should be longer and more descriptive than a typical function
    name. You’ll never call the function yourself; `pytest` will find the function
    and run it for you. Test function names should be long enough that if you see
    the function name in a test report, you’ll have a good sense of what behavior
    was being tested.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，测试名称应该比常规函数名更长且更具描述性。你不会自己调用这个函数；`pytest`会找到并为你运行它。测试函数名应该足够长，以便当你在测试报告中看到函数名时，能够清楚地了解测试的行为。
- en: Next, we call the function we’re testing ❷. Here we call `get_formatted_name()`
    with the arguments `'janis'` and `'joplin'`, just like we used when we ran *names.py*.
    We assign the return value of this function to `formatted_name`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们调用我们正在测试的函数 ❷。在这里，我们用`'janis'`和`'joplin'`作为参数调用`get_formatted_name()`，就像我们运行*names.py*时使用的那样。我们将此函数的返回值赋给`formatted_name`。
- en: Finally, we make an assertion ❸. An *assertion* is a claim about a condition.
    Here we’re claiming that the value of `formatted_name` should be `'Janis Joplin'`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们进行一个断言 ❸。*断言*是对某个条件的声明。在这里，我们声明`formatted_name`的值应该是`'Janis Joplin'`。
- en: Running a Test
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行测试
- en: If you run the file *test_name_function.py* directly, you won’t get any output
    because we never called the test function. Instead, we’ll have `pytest` run the
    test file for us.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你直接运行文件*test_name_function.py*，不会得到任何输出，因为我们从未调用测试函数。相反，我们将让`pytest`为我们运行测试文件。
- en: 'To do this, open a terminal window and navigate to the folder that contains
    the test file. If you’re using VS Code, you can open the folder containing the
    test file and use the terminal that’s embedded in the editor window. In the terminal
    window, enter the command `pytest`. Here’s what you should see:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，打开一个终端窗口并导航到包含测试文件的文件夹。如果你使用的是 VS Code，你可以打开包含测试文件的文件夹，并使用编辑器窗口内嵌的终端。在终端窗口中，输入命令`pytest`。你应该会看到如下内容：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Let’s try to make sense of this output. First of all, we see some information
    about the system the test is running on ❶. I’m testing this on a macOS system,
    so you may see some different output here. Most importantly, we can see which
    versions of Python, `pytest`, and other packages are being used to run the test.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试着理解这个输出。首先，我们看到一些关于测试运行系统的信息❶。我是在macOS系统上进行测试的，所以你可能会看到不同的输出。最重要的是，我们可以看到用于运行测试的Python、`pytest`和其他包的版本。
- en: 'Next, we see the directory where the test is being run from ❷: in my case,
    *python_work/chapter_11*. We can see that `pytest` found one test to run ❸, and
    we can see the test file that’s being run ❹. The single dot after the name of
    the file tells us that a single test passed, and the `100%` makes it clear that
    all of the tests have been run. A large project can have hundreds or thousands
    of tests, and the dots and percentage-complete indicator can be helpful in monitoring
    the overall progress of the test run.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看到测试运行的目录❷：在我的情况下是*python_work/chapter_11*。我们可以看到`pytest`找到了一个测试来运行❸，并且可以看到正在运行的测试文件❹。文件名后面的单个点告诉我们有一个测试通过了，而`100%`则清楚地表示所有测试都已运行。一个大项目可能有数百个或数千个测试，点和完成百分比指示器可以帮助监控测试运行的整体进度。
- en: The last line tells us that one test passed, and it took less than 0.01 seconds
    to run the test.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行告诉我们有一个测试通过了，并且运行测试的时间不到0.01秒。
- en: This output indicates that the function `get_formatted_name()` will always work
    for names that have a first and last name, unless we modify the function. When
    we modify `get_formatted_name()`, we can run this test again. If the test passes,
    we know the function will still work for names like Janis Joplin.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出表示，`get_formatted_name()`函数对于包含名字和姓氏的姓名始终有效，除非我们修改该函数。当我们修改`get_formatted_name()`时，可以再次运行这个测试。如果测试通过，我们就知道该函数仍然适用于像Janis
    Joplin这样的名字。
- en: A Failing Test
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个失败的测试
- en: What does a failing test look like? Let’s modify `get_formatted_name()` so it
    can handle middle names, but let’s do so in a way that breaks the function for
    names with just a first and last name, like Janis Joplin.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 失败的测试是什么样子的？让我们修改`get_formatted_name()`，使其能够处理中间名，但我们将以一种破坏只包含名字和姓氏的人的功能的方式进行修改，就像Janis
    Joplin那样。
- en: 'Here’s a new version of `get_formatted_name()` that requires a middle name
    argument:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个新的`get_formatted_name()`版本，它需要一个中间名参数：
- en: '**name_function.py**'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**name_function.py**'
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This version should work for people with middle names, but when we test it,
    we see that we’ve broken the function for people with just a first and last name.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本应该适用于有中间名的人，但是当我们测试时，发现它已经破坏了只包含名字和姓氏的人的功能。
- en: 'This time, running `pytest` gives the following output:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，运行`pytest`会给出以下输出：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'There’s a lot of information here because there’s a lot you might need to know
    when a test fails. The first item of note in the output is a single `F` ❶, which
    tells us that one test failed. We then see a section that focuses on `FAILURES`
    ❷, because failed tests are usually the most important thing to focus on in a
    test run. Next, we see that `test_first_last_name()` was the test function that
    failed ❸. An angle bracket ❹ indicates the line of code that caused the test to
    fail. The `E` on the next line ❺ shows the actual error that caused the failure:
    a `TypeError` due to a missing required positional argument, `last`. The most
    important information is repeated in a shorter summary at the end, so when you’re
    running many tests, you can get a quick sense of which tests failed and why.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多信息，因为当测试失败时，你可能需要知道很多东西。输出中的第一个重点是一个单独的`F`❶，它告诉我们有一个测试失败。接着，我们看到一个专注于`FAILURES`❷的部分，因为失败的测试通常是测试运行中最重要的关注点。接下来，我们看到`test_first_last_name()`是失败的测试函数❸。一个尖括号❹指示了导致测试失败的代码行。下一行的`E`❺显示了导致失败的实际错误：由于缺少必需的位置参数`last`，出现了`TypeError`。最重要的信息在最后的简短总结中得到了重复，因此当你运行多个测试时，可以快速了解哪些测试失败以及原因。
- en: Responding to a Failed Test
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 响应失败的测试
- en: What do you do when a test fails? Assuming you’re checking the right conditions,
    a passing test means the function is behaving correctly and a failing test means
    there’s an error in the new code you wrote. So when a test fails, don’t change
    the test. If you do, your tests might pass, but any code that calls your function
    like the test does will suddenly stop working. Instead, fix the code that’s causing
    the test to fail. Examine the changes you just made to the function, and figure
    out how those changes broke the desired behavior.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试失败时，你该怎么办？假设你正在检查正确的条件，测试通过意味着函数行为正确，而测试失败意味着你写的新代码中有错误。所以，当测试失败时，不要改变测试。如果你这么做，测试可能会通过，但任何像测试一样调用你的函数的代码会突然停止工作。相反，应该修复导致测试失败的代码。检查你刚刚对函数所做的修改，弄清楚这些修改是如何破坏预期行为的。
- en: 'In this case, `get_formatted_name()` used to require only two parameters: a
    first name and a last name. Now it requires a first name, middle name, and last
    name. The addition of that mandatory middle name parameter broke the original
    behavior of `get_formatted_name()`. The best option here is to make the middle
    name optional. Once we do, our test for names like `Janis Joplin` should pass
    again, and we should be able to accept middle names as well. Let’s modify `get_formatted_name()`
    so middle names are optional and then run the test case again. If it passes, we’ll
    move on to making sure the function handles middle names properly.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`get_formatted_name()` 以前只需要两个参数：一个名和一个姓。现在它需要一个名、一个中间名和一个姓。增加了这个必需的中间名参数后，打破了
    `get_formatted_name()` 原来的行为。这里的最佳选择是让中间名变成可选项。一旦我们这么做，像 `Janis Joplin` 这样的姓名测试应该能重新通过，我们也应该能够接受中间名。让我们修改
    `get_formatted_name()`，使中间名成为可选项，然后再次运行测试用例。如果通过了，我们就可以继续确保该函数能够正确处理中间名。
- en: 'To make middle names optional, we move the parameter `middle` to the end of
    the parameter list in the function definition and give it an empty default value.
    We also add an `if` test that builds the full name properly, depending on whether
    a middle name is provided:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让中间名成为可选项，我们将参数 `middle` 移到函数定义的参数列表末尾，并赋予它一个空的默认值。我们还添加了一个 `if` 语句，根据是否提供中间名来正确构建全名：
- en: '**name_function.py**'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**name_function.py**'
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In this new version of `get_formatted_name()`, the middle name is optional.
    If a middle name is passed to the function, the full name will contain a first,
    middle, and last name. Otherwise, the full name will consist of just a first and
    last name. Now the function should work for both kinds of names. To find out if
    the function still works for names like `Janis Joplin`, let’s run the test again:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个新版本的 `get_formatted_name()` 中，中间名是可选的。如果传入了中间名，返回的全名将包含名、中间名和姓。否则，全名将仅包含名和姓。现在该函数应该能同时适用于两种类型的姓名。为了验证函数是否仍然适用于像
    `Janis Joplin` 这样的姓名，让我们再次运行测试：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The test passes now. This is ideal; it means the function works for names like
    `Janis Joplin` again, without us having to test the function manually. Fixing
    our function was easier because the failed test helped us identify how the new
    code broke existing behavior.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 测试现在通过了。这是理想的情况；意味着该函数又能处理像 `Janis Joplin` 这样的姓名，而不需要我们手动测试函数。修复我们的函数更容易，因为失败的测试帮助我们确定了新代码如何破坏了现有的行为。
- en: Adding New Tests
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加新测试
- en: 'Now that we know `get_formatted_name()` works for simple names again, let’s
    write a second test for people who include a middle name. We do this by adding
    another test function to the file *test_name_function.py*:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道 `get_formatted_name()` 又能处理简单姓名了，让我们为包含中间名的人编写第二个测试。我们通过在文件 *test_name_function.py*
    中添加另一个测试函数来做到这一点：
- en: '**test_name_function.py**'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**test_name_function.py**'
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We name this new function `test_first_last_middle_name()`. The function name
    must start with `test_` so the function runs automatically when we run `pytest`.
    We name the function to make it clear which behavior of `get_formatted_name()`
    we’re testing. As a result, if the test fails, we’ll know right away what kinds
    of names are affected.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个新函数命名为 `test_first_last_middle_name()`。函数名必须以 `test_` 开头，这样我们运行 `pytest`
    时它就会自动运行。我们为函数命名是为了明确指出我们正在测试 `get_formatted_name()` 的哪个行为。因此，如果测试失败，我们会立刻知道是哪些类型的姓名受到了影响。
- en: 'To test the function, we call `get_formatted_name()` with a first, last, and
    middle name ❶, and then we make an assertion ❷ that the returned full name matches
    the full name (first, middle, and last) that we expect. When we run `pytest` again,
    both tests pass:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试该函数，我们调用 `get_formatted_name()`，并传入一个名、一个姓和一个中间名 ❶，然后我们进行断言 ❷，验证返回的全名是否与我们预期的全名（名、中间名和姓）匹配。当我们再次运行
    `pytest` 时，两个测试都通过了：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The two dots ❶ indicate that two tests passed, which is also clear from the
    last line of output. This is great! We now know that the function still works
    for names like `Janis Joplin`, and we can be confident that it will work for names
    like `Wolfgang Amadeus Mozart` as well.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 两个点❶表示两个测试通过，这也从输出的最后一行可以看出。这很棒！我们现在知道这个函数对像 `Janis Joplin` 这样的名字依然有效，并且可以放心它同样适用于像
    `Wolfgang Amadeus Mozart` 这样的名字。
- en: Testing a Class
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试一个类
- en: In the first part of this chapter, you wrote tests for a single function. Now
    you’ll write tests for a class. You’ll use classes in many of your own programs,
    so it’s helpful to be able to prove that your classes work correctly. If you have
    passing tests for a class you’re working on, you can be confident that improvements
    you make to the class won’t accidentally break its current behavior.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的第一部分中，你为单个函数编写了测试。现在你将为一个类编写测试。你将在自己的许多程序中使用类，因此能够证明你的类正常工作是非常有帮助的。如果你为正在处理的类编写了通过的测试，你可以放心地做出改进而不会意外地破坏当前的行为。
- en: A Variety of Assertions
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 各种断言
- en: 'So far, you’ve seen just one kind of assertion: a claim that a string has a
    specific value. When writing a test, you can make any claim that can be expressed
    as a conditional statement. If the condition is `True` as expected, your assumption
    about how that part of your program behaves will be confirmed; you can be confident
    that no errors exist. If the condition you assume is `True` is actually `False`,
    the test will fail and you’ll know there’s an issue to resolve. [Table 11-1](#table11-1)
    shows some of the most useful kinds of assertions you can include in your initial
    tests.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你只见过一种类型的断言：声明一个字符串具有特定的值。在编写测试时，你可以做出任何可以表示为条件语句的声明。如果条件按预期为 `True`，则你关于程序某部分行为的假设将得到确认；你可以确信没有错误。如果你假设的条件是
    `True`，实际上为 `False`，则测试将失败，你会知道存在需要解决的问题。[表 11-1](#table11-1) 显示了你可以在初始测试中包含的一些最有用的断言类型。
- en: 'Table 11-1: Commonly Used Assertion Statements in Tests'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11-1：测试中常用的断言语句
- en: '| **Assertion** | **Claim** |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| **断言** | **声明** |'
- en: '| --- | --- |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `assert a == b` | Assert that two values are equal. |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `assert a == b` | 断言两个值相等。 |'
- en: '| `assert a != b` | Assert that two values are not equal. |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `assert a != b` | 断言两个值不相等。 |'
- en: '| `assert a` | Assert that `a` evaluates to `True`. |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `assert a` | 断言 `a` 的值为 `True`。 |'
- en: '| `assert not a` | Assert that `a` evaluates to `False`. |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `assert not a` | 断言 `a` 的值为 `False`。 |'
- en: '| `assert` `element` `in` `list` | Assert that an element is in a list. |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `assert` `element` `in` `list` | 断言一个元素在列表中。 |'
- en: '| `assert` `element` `not in` `list` | Assert that an element is not in a list.
    |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `assert` `element` `not in` `list` | 断言一个元素不在列表中。 |'
- en: These are just a few examples; anything that can be expressed as a conditional
    statement can be included in a test.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是一些例子；任何可以表示为条件语句的内容都可以包含在测试中。
- en: A Class to Test
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个用于测试的类
- en: 'Testing a class is similar to testing a function, because much of the work
    involves testing the behavior of the methods in the class. However, there are
    a few differences, so let’s write a class to test. Consider a class that helps
    administer anonymous surveys:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 测试一个类与测试一个函数类似，因为大部分工作都涉及测试类中方法的行为。然而，仍然存在一些差异，因此让我们编写一个类来进行测试。考虑一个帮助进行匿名调查的类：
- en: '**survey.py**'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**survey.py**'
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This class starts with a survey question that you provide ❶ and includes an
    empty list to store responses. The class has methods to print the survey question
    ❷, add a new response to the response list ❸, and print all the responses stored
    in the list ❹. To create an instance from this class, all you have to provide
    is a question. Once you have an instance representing a particular survey, you
    display the survey question with `show_question()`, store a response using `store_response()`,
    and show results with `show_results()`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类从你提供的调查问题❶开始，并包括一个空列表用于存储回应。这个类有方法来打印调查问题❷、将新的回应添加到回应列表❸，并打印存储在列表中的所有回应❹。要创建该类的实例，你只需要提供一个问题。一旦你有了表示特定调查的实例，你可以使用
    `show_question()` 显示调查问题，使用 `store_response()` 存储回应，并使用 `show_results()` 显示结果。
- en: 'To show that the `AnonymousSurvey` class works, let’s write a program that
    uses the class:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示 `AnonymousSurvey` 类的工作原理，让我们编写一个使用该类的程序：
- en: '**language_survey.py**'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**language_survey.py**'
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This program defines a question (`"What language did you first learn to speak?"`)
    and creates an `AnonymousSurvey` object with that question. The program calls
    `show_question()` to display the question and then prompts for responses. Each
    response is stored as it is received. When all responses have been entered (the
    user inputs `q` to quit), `show_results()` prints the survey results:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序定义了一个问题（`"你第一次学会说的是什么语言？"`），并创建了一个包含该问题的`AnonymousSurvey`对象。程序调用`show_question()`显示问题，然后提示输入回答。每个回答都会在收到时保存。当所有回答输入完成后（用户输入`q`退出），`show_results()`将打印调查结果：
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This class works for a simple anonymous survey, but say we want to improve `AnonymousSurvey`
    and the module it’s in, `survey`. We could allow each user to enter more than
    one response, we could write a method to list only unique responses and to report
    how many times each response was given, or we could even write another class to
    manage non-anonymous surveys.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类适用于一个简单的匿名调查，但假设我们想要改进`AnonymousSurvey`及其所在的模块`survey`。我们可以允许每个用户输入多个回答，编写一个方法仅列出唯一回答并报告每个回答出现的次数，甚至可以编写另一个类来管理非匿名调查。
- en: Implementing such changes would risk affecting the current behavior of the class
    `AnonymousSurvey`. For example, it’s possible that while trying to allow each
    user to enter multiple responses, we could accidentally change how single responses
    are handled. To ensure we don’t break existing behavior as we develop this module,
    we can write tests for the class.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这样的更改可能会影响当前`AnonymousSurvey`类的行为。例如，在尝试允许每个用户输入多个回答时，我们可能会不小心改变单个回答的处理方式。为了确保我们在开发该模块时不会破坏现有行为，我们可以为该类编写测试。
- en: Testing the AnonymousSurvey Class
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试`AnonymousSurvey`类
- en: 'Let’s write a test that verifies one aspect of the way `AnonymousSurvey` behaves.
    We’ll write a test to verify that a single response to the survey question is
    stored properly:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个测试，验证`AnonymousSurvey`行为的一个方面。我们将编写一个测试来验证单个回答是否能正确存储在调查中：
- en: '**test_survey.py**'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**test_survey.py**'
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We start by importing the class we want to test, `AnonymousSurvey`. The first
    test function will verify that when we store a response to the survey question,
    the response will end up in the survey’s list of responses. A good descriptive
    name for this function is `test_store_single_response()` ❶. If this test fails,
    we’ll know from the function name in the test summary that there was a problem
    storing a single response to the survey.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入要测试的类`AnonymousSurvey`。第一个测试函数将验证当我们存储一个调查问题的回答时，该回答是否会出现在调查的回答列表中。这个函数的一个好描述性名称是`test_store_single_response()`
    ❶。如果这个测试失败，我们可以从测试总结中的函数名称了解到存储单个回答时出现了问题。
- en: To test the behavior of a class, we need to make an instance of the class. We
    create an instance called `language_survey` ❷ with the question `"What language
    did you first learn to speak?"` We store a single response, `English`, using the
    `store_response()` method. Then we verify that the response was stored correctly
    by asserting that `English` is in the list `language_survey.responses` ❸.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试一个类的行为，我们需要创建该类的实例。我们创建一个名为`language_survey`的实例 ❷，并赋予问题`"你第一次学会说的是什么语言？"`。我们使用`store_response()`方法存储一个回答`English`。然后，我们通过断言`English`是否在`language_survey.responses`列表中来验证该回答是否已正确存储
    ❸。
- en: 'By default, running the command `pytest` with no arguments will run all the
    tests that `pytest` discovers in the current directory. To focus on the tests
    in one file, pass the name of the test file you want to run. Here we’ll run just
    the one test we wrote for `AnonymousSurvey`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，运行命令`pytest`且不带任何参数时，会运行`pytest`在当前目录中发现的所有测试。要集中测试某个文件中的测试，可以传入要运行的测试文件名。这里我们将仅运行我们为`AnonymousSurvey`编写的一个测试：
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This is a good start, but a survey is useful only if it generates more than
    one response. Let’s verify that three responses can be stored correctly. To do
    this, we add another method to `TestAnonymousSurvey`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的开始，但一个调查只有生成多个回答时才有意义。让我们验证是否可以正确存储三个回答。为此，我们向`TestAnonymousSurvey`添加另一个方法：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We call the new function `test_store_three_responses()`. We create a survey
    object just like we did in `test_store_single_response()`. We define a list containing
    three different responses ❶, and then we call `store_response()` for each of these
    responses. Once the responses have been stored, we write another loop and assert
    that each response is now in `language_survey.responses` ❷.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将新函数命名为`test_store_three_responses()`。我们像在`test_store_single_response()`中一样创建一个调查对象。我们定义了一个包含三个不同回答的列表❶，然后对每个回答调用`store_response()`。一旦回答被存储，我们再写一个循环，并断言每个回答现在都在`language_survey.responses`中❷。
- en: 'When we run the test file again, both tests (for a single response and for
    three responses) pass:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们再次运行测试文件时，两个测试（一个是单个回答，另一个是三个回答）都通过了：
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This works perfectly. However, these tests are a bit repetitive, so we’ll use
    another feature of `pytest` to make them more efficient.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这完美地工作。然而，这些测试有些重复，所以我们将使用`pytest`的另一个特性来使它们更高效。
- en: Using Fixtures
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Fixtures
- en: In *test_survey.py*, we created a new instance of `AnonymousSurvey` in each
    test function. This is fine in the short example we’re working with, but in a
    real-world project with tens or hundreds of tests, this would be problematic.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在*test_survey.py*中，我们在每个测试函数中都创建了一个新的`AnonymousSurvey`实例。这在我们处理的短小示例中没问题，但在一个有数十或数百个测试的实际项目中，这将成为一个问题。
- en: In testing, a *fixture* helps set up a test environment. Often, this means creating
    a resource that’s used by more than one test. We create a fixture in `pytest`
    by writing a function with the decorator `@pytest.fixture`. A *decorator* is a
    directive placed just before a function definition; Python applies this directive
    to the function before it runs, to alter how the function code behaves. Don’t
    worry if this sounds complicated; you can start to use decorators from third-party
    packages before learning to write them yourself.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试中，*fixture*帮助设置测试环境。通常，这意味着创建一个由多个测试使用的资源。我们通过写一个带有`@pytest.fixture`装饰器的函数来在`pytest`中创建一个fixture。*装饰器*是一个指令，位于函数定义之前；Python在运行函数之前应用这个指令，以改变函数代码的行为。如果这听起来很复杂，不用担心；你可以先使用第三方包的装饰器，而不必先学会自己写装饰器。
- en: 'Let’s use a fixture to create a single survey instance that can be used in
    both test functions in *test_survey.py*:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用一个fixture来创建一个可以在*test_survey.py*中的两个测试函数中使用的单一调查实例：
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We need to import `pytest` now, because we’re using a decorator that’s defined
    in `pytest`. We apply the `@pytest.fixture` decorator ❶ to the new function `language_survey()`
    ❷. This function builds an `AnonymousSurvey` object and returns the new survey.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要导入`pytest`，因为我们使用了一个在`pytest`中定义的装饰器。我们将`@pytest.fixture`装饰器❶应用到新的函数`language_survey()`❷上。这个函数构建了一个`AnonymousSurvey`对象，并返回新的调查。
- en: Notice that the definitions of both test functions have changed ❸ ❺; each test
    function now has a parameter called `language_survey`. When a parameter in a test
    function matches the name of a function with the `@pytest.fixture` decorator,
    the fixture will be run automatically and the return value will be passed to the
    test function. In this example, the function `language_survey()` supplies both
    `test_store_single_response()` and `test_store_three_responses()` with a `language_survey`
    instance.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，两个测试函数的定义发生了变化❸❺；每个测试函数现在都有一个名为`language_survey`的参数。当测试函数中的参数与带有`@pytest.fixture`装饰器的函数名称匹配时，fixture会自动运行，并将返回值传递给测试函数。在这个示例中，`language_survey()`函数为`test_store_single_response()`和`test_store_three_responses()`提供了一个`language_survey`实例。
- en: 'There’s no new code in either of the test functions, but notice that two lines
    have been removed from each function ❹ ❻: the line that defined a question and
    the line that created an `AnonymousSurvey` object.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 两个测试函数中没有新增代码，但请注意，每个函数中有两行代码被移除❹❻：定义问题的那一行和创建`AnonymousSurvey`对象的那一行。
- en: When we run the test file again, both tests still pass. These tests would be
    particularly useful when trying to expand `AnonymousSurvey` to handle multiple
    responses for each person. After modifying the code to accept multiple responses,
    you could run these tests and make sure you haven’t affected the ability to store
    a single response or a series of individual responses.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们再次运行测试文件时，两个测试仍然通过。这些测试在尝试扩展`AnonymousSurvey`以处理每个人的多个回答时尤其有用。在修改代码以接受多个回答后，您可以运行这些测试，确保没有影响存储单个回答或一系列个体回答的功能。
- en: The structure above will almost certainly look complicated; it contains some
    of the most abstract code you’ve seen so far. You don’t need to use fixtures right
    away; it’s better to write tests that have a lot of repetitive code than to write
    no tests at all. Just know that when you’ve written enough tests that the repetition
    is getting in the way, there’s a well-established way to deal with the repetition.
    Also, fixtures in simple examples like this one don’t really make the code any
    shorter or simpler to follow. But in projects with many tests, or in situations
    where it takes many lines to build a resource that’s used in multiple tests, fixtures
    can drastically improve your test code.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 上述结构看起来几乎肯定会很复杂；它包含了一些你到目前为止见过的最抽象的代码。你不需要立刻使用 fixtures；与其完全不写测试，不如写一些有很多重复代码的测试。只要记住，当你写了足够多的测试，重复的代码开始成为障碍时，有一种成熟的方法可以处理这些重复。而且像这种简单的例子中的
    fixture 并不会使代码更简洁或更容易理解。但在有许多测试的项目中，或者在需要多行代码来构建多个测试所用资源的情况下，fixtures 能显著提升你的测试代码质量。
- en: When you want to write a fixture, write a function that generates the resource
    that’s used by multiple test functions. Add the `@pytest.fixture` decorator to
    the new function, and add the name of this function as a parameter for each test
    function that uses this resource. Your tests will be shorter and easier to write
    and maintain from that point forward.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想编写一个 fixture 时，写一个生成多个测试函数所用资源的函数。在新函数上添加`@pytest.fixture`装饰器，并将该函数的名称作为参数添加到每个使用该资源的测试函数中。从那时起，你的测试会更简洁，更容易编写和维护。
- en: Summary
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned to write tests for functions and classes using
    tools in the `pytest` module. You learned to write test functions that verify
    specific behaviors your functions and classes should exhibit. You saw how fixtures
    can be used to efficiently create resources that can be used in multiple test
    functions in a test file.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了使用 `pytest` 模块中的工具为函数和类编写测试。你学会了编写测试函数来验证你的函数和类应该表现出的特定行为。你还了解了如何使用
    fixtures 高效地创建可以在测试文件中多个测试函数中使用的资源。
- en: Testing is an important topic that many newer programmers aren’t exposed to.
    You don’t have to write tests for all the simple projects you try as a new programmer.
    But as soon as you start to work on projects that involve significant development
    effort, you should test the critical behaviors of your functions and classes.
    You’ll be more confident that new work on your project won’t break the parts that
    work, and this will give you the freedom to make improvements to your code. If
    you accidentally break existing functionality, you’ll know right away, so you
    can still fix the problem easily. Responding to a failed test that you ran is
    much easier than responding to a bug report from an unhappy user.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是一个重要的主题，但许多新手程序员并未接触过。你不需要为所有简单的项目编写测试，尤其是作为新手程序员时。但一旦你开始从事涉及重大开发工作的项目，你应该测试函数和类的关键行为。这样你会更有信心，知道对项目进行的新工作不会破坏现有功能，并且这将让你有自由改进代码。如果你不小心破坏了现有功能，你会立刻发现，这样你仍然能轻松修复问题。响应一个失败的测试远比响应一个来自不满用户的
    bug 报告要容易得多。
- en: Other programmers will respect your projects more if you include some initial
    tests. They’ll feel more comfortable experimenting with your code and be more
    willing to work with you on projects. If you want to contribute to a project that
    other programmers are working on, you’ll be expected to show that your code passes
    existing tests and you’ll usually be expected to write tests for any new behavior
    you introduce to the project.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在项目中加入一些初始测试，其他程序员会更尊重你的项目。他们会更愿意实验你的代码，并且更愿意与你合作。如果你想为其他程序员正在进行的项目做贡献，你需要展示你的代码通过了现有的测试，并且通常需要为你引入的任何新行为编写测试。
- en: Play around with tests to become familiar with the process of testing your code.
    Write tests for the most critical behaviors of your functions and classes, but
    don’t aim for full coverage in early projects unless you have a specific reason
    to do so.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 玩转测试，熟悉测试代码的编写过程。为你的函数和类的关键行为编写测试，但在早期项目中，除非有特定的原因，不要追求完全覆盖。
