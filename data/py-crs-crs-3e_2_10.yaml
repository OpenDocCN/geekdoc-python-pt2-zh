- en: '18'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '18'
- en: Getting Started with Django
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 开始使用 Django
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: As the internet has evolved, the line between websites and mobile apps has blurred.
    Websites and apps both help users interact with data in a variety of ways. Fortunately,
    you can use Django to build a single project that serves a dynamic website as
    well as a set of mobile apps. *Django* is Python’s most popular *web framework*,
    a set of tools designed for building interactive web applications. In this chapter,
    you’ll learn how to use Django to build a project called Learning Log, an online
    journal system that lets you keep track of information you’ve learned about different
    topics.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 随着互联网的发展，网站和移动应用之间的界限逐渐模糊。网站和应用都帮助用户以多种方式与数据互动。幸运的是，你可以使用 Django 来构建一个既能提供动态网站，又能支持一套移动应用的项目。*Django*
    是 Python 最受欢迎的 *web 框架*，它是一个为构建互动式 web 应用而设计的一套工具。在本章中，你将学习如何使用 Django 构建一个名为
    Learning Log 的项目，这是一个在线日记系统，可以帮助你记录你所学到的不同主题的信息。
- en: We’ll write a specification for this project, and then define models for the
    data the app will work with. We’ll use Django’s admin system to enter some initial
    data, and then write views and templates so Django can build the site’s pages.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为这个项目编写一个规范，然后定义该应用将使用的数据模型。我们将使用 Django 的管理系统输入一些初始数据，然后编写视图和模板，以便 Django
    能构建网站的页面。
- en: Django can respond to page requests and make it easier to read and write to
    a database, manage users, and much more. In Chapters 19 and 20, you’ll refine
    the Learning Log project, and then deploy it to a live server so you (and everyone
    else in the world) can use it.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Django 可以响应页面请求，并使得读取和写入数据库、更好地管理用户等变得更加简便。在第 19 章和第 20 章中，你将完善 Learning Log
    项目，并将其部署到在线服务器，这样你（以及全世界的其他人）就可以使用它。
- en: Setting Up a Project
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置项目
- en: When starting work on something as significant as a web app, you first need
    to describe the project’s goals in a specification, or *spec*. Once you have a
    clear set of goals, you can start to identify manageable tasks to achieve those
    goals.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始一个像 web 应用这样重要的项目时，首先需要在规范（*spec*）中描述项目的目标。一旦你有了明确的目标，就可以开始识别可管理的任务来实现这些目标。
- en: In this section, we’ll write a spec for Learning Log and start working on the
    first phase of the project. This will involve setting up a virtual environment
    and building out the initial aspects of a Django project.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将为 Learning Log 编写一个规范，并开始着手项目的第一阶段。这将包括设置虚拟环境并构建 Django 项目的初步部分。
- en: Writing a Spec
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写规范
- en: 'A full spec details the project goals, describes the project’s functionality,
    and discusses its appearance and user interface. Like any good project or business
    plan, a spec should keep you focused and help keep your project on track. We won’t
    write a full project spec here, but we’ll lay out a few clear goals to keep the
    development process focused. Here’s the spec we’ll use:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的规范详细说明了项目目标，描述了项目的功能，并讨论了其外观和用户界面。像任何好的项目或商业计划一样，规范应帮助你保持专注，确保项目按计划推进。我们在这里不会编写完整的项目规范，但会列出一些清晰的目标，以确保开发过程有条不紊。以下是我们将使用的规范：
- en: We’ll write a web app called Learning Log that allows users to log the topics
    they’re interested in and make journal entries as they learn about each topic.
    The Learning Log home page will describe the site and invite users to either register
    or log in. Once logged in, a user can create new topics, add new entries, and
    read and edit existing entries.
  id: totrans-11
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们将编写一个名为 Learning Log 的 web 应用，它允许用户记录他们感兴趣的主题，并在学习每个主题时做日记记录。Learning Log
    的主页将描述该网站，并邀请用户注册或登录。一旦登录，用户可以创建新主题、添加新条目，并阅读和编辑现有条目。
- en: When you’re researching a new topic, maintaining a journal of what you’ve learned
    can help you keep track of new information and information you’ve already found.
    This is especially true when studying technical subjects. A good app, like the
    one we’ll be creating, can help make this process more efficient.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当你研究一个新主题时，保持学习日志可以帮助你跟踪新信息以及已经找到的信息。尤其在学习技术类内容时，这一点尤为重要。一个好的应用程序，像我们将要创建的这个应用，可以帮助你提高这一过程的效率。
- en: Creating a Virtual Environment
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建虚拟环境
- en: To work with Django, we’ll first set up a virtual environment. A *virtual environment*
    is a place on your system where you can install packages and isolate them from
    all other Python packages. Separating one project’s libraries from other projects
    is beneficial and will be necessary when we deploy Learning Log to a server in
    Chapter 20.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用 Django，我们首先设置一个虚拟环境。*虚拟环境* 是系统中可以安装包并将其与其他 Python 包隔离的地方。将一个项目的库与其他项目分开是有益的，并且在第
    20 章将 Learning Log 部署到服务器时是必要的。
- en: 'Create a new directory for your project called *learning_log*, switch to that
    directory in a terminal, and enter the following code to create a virtual environment:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为你的项目创建一个新的目录，命名为 *learning_log*，在终端中切换到该目录，并输入以下代码来创建虚拟环境：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here we’re running the `venv` virtual environment module and using it to create
    an environment named *ll_env* (note that this name starts with two lowercase *L*s,
    not two ones). If you use a command such as `python3` when running programs or
    installing packages, make sure to use that command here.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们运行 `venv` 虚拟环境模块，并使用它来创建名为 *ll_env* 的环境（请注意，这个名称以两个小写字母 *L* 开头，而不是两个数字
    1）。如果你在运行程序或安装包时使用像 `python3` 这样的命令，请确保在这里也使用相同的命令。
- en: Activating the Virtual Environment
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 激活虚拟环境
- en: 'Now we need to activate the virtual environment, using the following command:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要激活虚拟环境，使用以下命令：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This command runs the script *activate* in *ll_env/bin/*. When the environment
    is active, you’ll see the name of the environment in parentheses. This indicates
    that you can install new packages to the environment and use packages that have
    already been installed. Packages you install in *ll_env* will not be available
    when the environment is inactive.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令运行 *ll_env/bin/* 中的 *activate* 脚本。当虚拟环境激活时，你会看到环境名称显示在括号中。这表示你可以向环境中安装新的包并使用已经安装的包。在
    *ll_env* 中安装的包在环境不活跃时无法使用。
- en: 'To stop using a virtual environment, enter `deactivate`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要停止使用虚拟环境，输入 `deactivate`：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The environment will also become inactive when you close the terminal it’s running
    in.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当你关闭运行虚拟环境的终端时，环境也会变得不活跃。
- en: Installing Django
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装 Django
- en: 'With the virtual environment activated, enter the following to update pip and
    install Django:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚拟环境激活后，输入以下命令来更新 pip 并安装 Django：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Because it downloads resources from a variety of sources, pip is upgraded fairly
    often. It’s a good idea to upgrade pip whenever you make a new virtual environment.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 pip 会从多个来源下载资源，因此它会比较频繁地升级。每次创建新虚拟环境时，最好都升级 pip。
- en: We’re working in a virtual environment now, so the command to install Django
    is the same on all systems. There’s no need to use longer commands, such as `python
    -m pip install` `package_name`, or to include the `--user` flag. Keep in mind
    that Django will be available only when the *ll_env* environment is active.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在在虚拟环境中工作，所以安装 Django 的命令在所有系统中都是相同的。无需使用更长的命令，如 `python -m pip install`
    `package_name`，也不需要包括 `--user` 标志。请记住，Django 只有在 *ll_env* 环境激活时才可用。
- en: Creating a Project in Django
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Django 中创建项目
- en: 'Without leaving the active virtual environment (remember to look for *ll_env*
    in parentheses in the terminal prompt), enter the following commands to create
    a new project:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在不离开激活的虚拟环境（记得在终端提示符中查找括号里的 *ll_env*）的情况下，输入以下命令来创建一个新项目：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `startproject` command ❶ tells Django to set up a new project called *ll_project*.
    The dot (`.`) at the end of the command creates the new project with a directory
    structure that will make it easy to deploy the app to a server when we’re finished
    developing it.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`startproject` 命令❶ 告诉 Django 创建一个名为 *ll_project* 的新项目。命令末尾的点（`.`）会创建一个新的项目，并生成一个目录结构，这样在我们完成开发后，可以方便地将应用部署到服务器上。'
- en: Running the `ls` command (`dir` on Windows) ❷ shows that Django has created
    a new directory called *ll_project*. It also created a *manage.py* file, which
    is a short program that takes in commands and feeds them to the relevant part
    of Django. We’ll use these commands to manage tasks, such as working with databases
    and running servers.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `ls` 命令（Windows 上使用 `dir`）❷ 可以看到 Django 创建了一个名为 *ll_project* 的新目录。它还创建了一个
    *manage.py* 文件，这是一个简短的程序，用来接收命令并将其传递给 Django 的相关部分。我们将使用这些命令来管理任务，如操作数据库和运行服务器。
- en: The *ll_project* directory contains four files ❸; the most important are *settings.py*,
    *urls.py*, and *wsgi.py*. The *settings.py* file controls how Django interacts
    with your system and manages your project. We’ll modify a few of these settings
    and add some settings of our own as the project evolves. The *urls.py* file tells
    Django which pages to build in response to browser requests. The *wsgi.py* file
    helps Django serve the files it creates. The filename is an acronym for “web server
    gateway interface.”
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*ll_project*目录包含四个文件 ❸；其中最重要的是*settings.py*、*urls.py*和*wsgi.py*。*settings.py*文件控制Django如何与您的系统交互并管理您的项目。在项目发展过程中，我们会修改其中的一些设置并添加我们自己的设置。*urls.py*文件告诉Django在响应浏览器请求时构建哪些页面。*wsgi.py*文件帮助Django提供它所创建的文件。该文件名是“Web服务器网关接口”的缩写。'
- en: Creating the Database
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建数据库
- en: 'Django stores most of the information for a project in a database, so next
    we need to create a database that Django can work with. Enter the following command
    (still in an active environment):'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Django将项目的大部分信息存储在数据库中，因此接下来我们需要创建一个Django可以使用的数据库。输入以下命令（仍然在活动环境中）：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Anytime we modify a database, we say we’re *migrating* the database. Issuing
    the `migrate` command for the first time tells Django to make sure the database
    matches the current state of the project. The first time we run this command in
    a new project using SQLite (more about SQLite in a moment), Django will create
    a new database for us. Here, Django reports that it will prepare the database
    to store information it needs to handle administrative and authentication tasks
    ❶.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们修改数据库时，我们称之为*迁移*数据库。首次执行`migrate`命令会告诉Django确保数据库与项目的当前状态相匹配。第一次在使用SQLite的新项目中运行此命令时，Django会为我们创建一个新的数据库。在这里，Django报告它将准备数据库以存储处理管理和认证任务所需的信息
    ❶。
- en: Running the `ls` command shows that Django created another file called *db.sqlite3*
    ❷. *SQLite* is a database that runs off a single file; it’s ideal for writing
    simple apps because you won’t have to pay much attention to managing the database.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`ls`命令显示Django创建了另一个名为*db.sqlite3*的文件 ❷。*SQLite*是一个基于单个文件运行的数据库；它非常适合编写简单应用，因为您不需要过多关注数据库管理。
- en: Viewing the Project
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查看项目
- en: 'Let’s make sure that Django has set up the project properly. Enter the `runserver`
    command to view the project in its current state:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们确保Django已正确设置项目。输入`runserver`命令查看当前状态下的项目：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Django should start a server called the *development server*, so you can view
    the project on your system to see how well it works. When you request a page by
    entering a URL in a browser, the Django server responds to that request by building
    the appropriate page and sending it to the browser.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Django应该启动一个名为*开发服务器*的服务器，这样您就可以在系统上查看项目，看看它的运行效果。当您通过在浏览器中输入URL来请求页面时，Django服务器会响应该请求，构建相应的页面并将其发送到浏览器。
- en: Django first checks to make sure the project is set up properly ❶; it then reports
    the version of Django in use and the name of the settings file in use ❷. Finally,
    it reports the URL where the project is being served ❸. The URL *http://127.0.0.1:8000/*
    indicates that the project is listening for requests on port 8000 on your computer,
    which is called a localhost. The term *localhost* refers to a server that only
    processes requests on your system; it doesn’t allow anyone else to see the pages
    you’re developing.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Django首先检查确保项目已正确设置 ❶；然后报告正在使用的Django版本以及正在使用的设置文件的名称 ❷。最后，它报告项目正在服务的URL ❸。URL
    *http://127.0.0.1:8000/* 表示该项目正在监听计算机上端口8000的请求，这个地址被称为本地主机（localhost）。*localhost*指的是一个仅处理您系统上的请求的服务器；它不允许其他人查看您正在开发的页面。
- en: 'Open a web browser and enter the URL *http://localhost:8000/*, or *http://127.0.0.1:8000/*
    if the first one doesn’t work. You should see something like [Figure 18-1](#figure18-1):
    a page that Django creates to let you know everything is working properly so far.
    Keep the server running for now, but when you want to stop the server, press CTRL-C
    in the terminal where the `runserver` command was issued.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个网页浏览器并输入URL *http://localhost:8000/*，或者如果第一个无法使用，可以输入 *http://127.0.0.1:8000/*。您应该会看到类似于[图18-1](#figure18-1)的内容：Django创建的页面，用来告诉您到目前为止一切正常。暂时保持服务器运行，但当您想停止服务器时，可以在发出`runserver`命令的终端中按CTRL-C。
- en: '![](image_fi/502703c18/f18001.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502703c18/f18001.png)'
- en: 'Figure 18-1: Everything is working so far.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图18-1：到目前为止一切正常。
- en: Starting an App
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动一个应用
- en: A Django *project* is organized as a group of individual *apps* that work together
    to make the project work as a whole. For now, we’ll create one app to do most
    of our project’s work. We’ll add another app in Chapter 19 to manage user accounts.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Django *项目* 被组织为一组独立的 *应用*，这些应用共同工作，使项目作为一个整体运作。现在，我们将创建一个应用来完成我们项目的大部分工作。在第19章中，我们会添加另一个应用来管理用户账户。
- en: 'You should leave the development server running in the terminal window you
    opened earlier. Open a new terminal window (or tab) and navigate to the directory
    that contains *manage.py*. Activate the virtual environment, and then run the
    `startapp` command:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该保持之前打开的终端窗口中的开发服务器正在运行。打开一个新的终端窗口（或标签页），并导航到包含 *manage.py* 的目录。激活虚拟环境，然后运行
    `startapp` 命令：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The command `startapp` `appname` tells Django to create the infrastructure needed
    to build an app. When you look in the project directory now, you’ll see a new
    folder called *learning_logs* ❶. Use the `ls` command to see what Django has created
    ❷. The most important files are *models.py*, *admin.py*, and *views.py*. We’ll
    use *models.py* to define the data we want to manage in our app. We’ll look at
    *admin.py* and *views.py* a little later.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 命令 `startapp` `appname` 告诉 Django 创建构建应用所需的基础设施。当你现在查看项目目录时，你会看到一个名为 *learning_logs*
    ❶ 的新文件夹。使用 `ls` 命令查看 Django 创建了什么 ❷。最重要的文件是 *models.py*、*admin.py* 和 *views.py*。我们将使用
    *models.py* 来定义我们想要在应用中管理的数据。稍后我们会再看看 *admin.py* 和 *views.py*。
- en: Defining Models
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义模型
- en: Let’s think about our data for a moment. Each user will need to create a number
    of topics in their learning log. Each entry they make will be tied to a topic,
    and these entries will be displayed as text. We’ll also need to store the timestamp
    of each entry so we can show users when they made each one.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们思考一下我们的数据。每个用户需要在他们的学习日志中创建多个话题。每个条目都会与一个话题关联，并且这些条目将以文本的形式显示。我们还需要存储每个条目的时间戳，以便向用户展示他们何时创建了每个条目。
- en: 'Open the file *models.py* and look at its existing content:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 打开文件 *models.py* 并查看其现有内容：
- en: '**models.py**'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**models.py**'
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'A module called `models` is being imported, and we’re being invited to create
    models of our own. A *model* tells Django how to work with the data that will
    be stored in the app. A model is a class; it has attributes and methods, just
    like every class we’ve discussed. Here’s the model for the topics users will store:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一个名为 `models` 的模块正在被导入，我们被邀请创建我们自己的模型。*模型* 告诉 Django 如何处理将存储在应用中的数据。模型是一个类；它有属性和方法，就像我们讨论过的每个类一样。这里是用户将要存储的主题模型：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We’ve created a class called `Topic`, which inherits from `Model`—a parent
    class included in Django that defines a model’s basic functionality. We add two
    attributes to the `Topic` class: `text` and `date_added`.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为 `Topic` 的类，它继承自 `Model` —— 这是 Django 中定义模型基本功能的父类。我们在 `Topic` 类中添加了两个属性：`text`
    和 `date_added`。
- en: The `text` attribute is a `CharField`, a piece of data that’s made up of characters
    or text ❶. You use `CharField` when you want to store a small amount of text,
    such as a name, a title, or a city. When we define a `CharField` attribute, we
    have to tell Django how much space it should reserve in the database. Here we
    give it a `max_length` of `200` characters, which should be enough to hold most
    topic names.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`text` 属性是一个 `CharField`，它由字符或文本组成 ❶。当你想存储少量文本时，比如名称、标题或城市时，使用 `CharField`。在定义
    `CharField` 属性时，我们需要告诉 Django 在数据库中为它预留多少空间。这里我们给它设置了 `max_length` 为 `200` 个字符，这应该足够容纳大多数话题名称。'
- en: The `date_added` attribute is a `DateTimeField`, a piece of data that will record
    a date and time ❷. We pass the argument `auto_now_add=True`, which tells Django
    to automatically set this attribute to the current date and time whenever the
    user creates a new topic.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`date_added` 属性是一个 `DateTimeField`，用于记录日期和时间 ❷。我们传递参数 `auto_now_add=True`，告诉
    Django 每当用户创建一个新话题时，自动将此属性设置为当前日期和时间。'
- en: It’s a good idea to tell Django how you want it to represent an instance of
    a model. If a model has a `__str__()` method, Django calls that method whenever
    it needs to generate output referring to an instance of that model. Here we’ve
    written a `__str__()` method that returns the value assigned to the `text` attribute
    ❸.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 告诉 Django 你希望它如何表示模型的一个实例是个好主意。如果一个模型有 `__str__()` 方法，每当 Django 需要生成与该模型实例相关的输出时，它就会调用该方法。这里我们编写了一个
    `__str__()` 方法，它返回分配给 `text` 属性的值 ❸。
- en: To see the different kinds of fields you can use in a model, see the “Model
    Field Reference” page at [https://docs.djangoproject.com/en/4.1/ref/models/fields](https://docs.djangoproject.com/en/4.1/ref/models/fields).
    You won’t need all the information right now, but it will be extremely useful
    when you’re developing your own Django projects.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看你可以在模型中使用的不同字段类型，请参考“模型字段参考”页面：[https://docs.djangoproject.com/en/4.1/ref/models/fields](https://docs.djangoproject.com/en/4.1/ref/models/fields)。你现在可能不需要所有信息，但在你开发自己的
    Django 项目时，这些信息将非常有用。
- en: Activating Models
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 激活模型
- en: 'To use our models, we have to tell Django to include our app in the overall
    project. Open *settings.py* (in the *ll_project* directory); you’ll see a section
    that tells Django which apps are installed in the project:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用我们的模型，我们必须告诉 Django 将我们的应用包含在整体项目中。打开 *settings.py*（在 *ll_project* 目录下）；你会看到一个部分，告诉
    Django 哪些应用已安装在项目中：
- en: '**settings.py**'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**settings.py**'
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Add our app to this list by modifying `INSTALLED_APPS` so it looks like this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通过修改 `INSTALLED_APPS` 来将我们的应用添加到此列表，使其看起来像这样：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Grouping apps together in a project helps keep track of them as the project
    grows to include more apps. Here we start a section called `My apps`, which includes
    only `'learning_logs'` for now. It’s important to place your own apps before the
    default apps, in case you need to override any behavior of the default apps with
    your own custom behavior.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个项目中将应用分组有助于在项目增长并包含更多应用时进行追踪。这里我们开始一个名为 `My apps` 的部分，目前只包含 `'learning_logs'`。将自己的应用放在默认应用之前很重要，以防你需要用自定义行为覆盖默认应用的某些行为。
- en: 'Next, we need to tell Django to modify the database so it can store information
    related to the model `Topic`. From the terminal, run the following command:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要告诉 Django 修改数据库，以便它可以存储与模型 `Topic` 相关的信息。在终端中运行以下命令：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The command `makemigrations` tells Django to figure out how to modify the database
    so it can store the data associated with any new models we’ve defined. The output
    here shows that Django has created a migration file called *0001_initial.py*.
    This migration will create a table for the model `Topic` in the database.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 命令 `makemigrations` 告诉 Django 找出如何修改数据库，以便它可以存储与我们定义的任何新模型相关的数据。这里的输出显示 Django
    创建了一个名为 *0001_initial.py* 的迁移文件。这个迁移文件将在数据库中为模型 `Topic` 创建一个表。
- en: 'Now we’ll apply this migration and have Django modify the database for us:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将应用这个迁移，并让 Django 为我们修改数据库：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Most of the output from this command is identical to the output from the first
    time we issued the `migrate` command. We need to check the last line in this output,
    where Django confirms that the migration for `learning_logs` worked `OK`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令的输出大部分与第一次执行 `migrate` 命令时的输出相同。我们需要检查输出的最后一行，Django 会在这里确认 `learning_logs`
    的迁移是否成功 `OK`。
- en: 'Whenever we want to modify the data that Learning Log manages, we’ll follow
    these three steps: modify *models.py*, call `makemigrations` on `learning_logs`,
    and tell Django to `migrate` the project.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们想修改 Learning Log 管理的数据时，我们将遵循以下三个步骤：修改 *models.py*，在 `learning_logs` 上调用
    `makemigrations`，然后告诉 Django 执行 `migrate` 操作。
- en: The Django Admin Site
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Django 管理站点
- en: Django makes it easy to work with your models through its admin site. Django’s
    *admin site* is only meant to be used by the site’s administrators; it’s not meant
    for regular users. In this section, we’ll set up the admin site and use it to
    add some topics through the `Topic` model.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Django 通过其管理站点使得与模型的交互变得简单。Django 的 *管理站点* 仅供网站管理员使用；不适用于普通用户。在本节中，我们将设置管理站点，并通过
    `Topic` 模型使用它添加一些主题。
- en: Setting Up a Superuser
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置超级用户
- en: Django allows you to create a *superuser*, a user who has all privileges available
    on the site. A user’s *privileges* control the actions they can take. The most
    restrictive privilege settings allow a user to only read public information on
    the site. Registered users typically have the privilege of reading their own private
    data and some selected information available only to members. To effectively administer
    a project, the site owner usually needs access to all information stored on the
    site. A good administrator is careful with their users’ sensitive information,
    because users put a lot of trust into the apps they access.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Django 允许你创建一个 *超级用户*，一个拥有网站所有权限的用户。用户的 *权限* 控制他们可以执行的操作。最严格的权限设置允许用户仅能读取网站上的公共信息。注册用户通常有权限读取自己的私人数据以及一些仅限成员查看的信息。为了有效地管理一个项目，网站所有者通常需要访问网站上存储的所有信息。一个好的管理员会小心处理用户的敏感信息，因为用户对他们访问的应用程序寄予了很大信任。
- en: 'To create a superuser in Django, enter the following command and respond to
    the prompts:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Django 中创建超级用户，请输入以下命令并按照提示进行操作：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When you issue the command `createsuperuser`, Django prompts you to enter a
    username for the superuser ❶. Here I’m using `ll_admin`, but you can enter any
    username you want. You can enter an email address or just leave this field blank
    ❷. You’ll need to enter your password twice ❸.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当你执行 `createsuperuser` 命令时，Django 会提示你输入超级用户的用户名 ❶。这里我使用的是 `ll_admin`，但你可以输入任何你想要的用户名。你可以输入一个电子邮件地址，也可以将该字段留空
    ❷。你需要输入密码两次 ❸。
- en: Registering a Model with the Admin Site
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在管理员网站注册模型
- en: Django includes some models in the admin site automatically, such as `User`
    and `Group`, but the models we create need to be added manually.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Django 自动将一些模型包含在管理员网站中，例如 `User` 和 `Group`，但是我们创建的模型需要手动添加。
- en: 'When we started the `learning_logs` app, Django created an *admin.py* file
    in the same directory as *models.py*. Open the *admin.py* file:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们启动 `learning_logs` 应用时，Django 会在与 *models.py* 相同的目录中创建一个 *admin.py* 文件。打开
    *admin.py* 文件：
- en: '**admin.py**'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**admin.py**'
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To register `Topic` with the admin site, enter the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 `Topic` 注册到管理员网站，请输入以下内容：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This code first imports the model we want to register, `Topic`. The dot in front
    of `models` tells Django to look for *models.py* in the same directory as *admin.py*.
    The code `admin.site.register()` tells Django to manage our model through the
    admin site.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码首先导入我们要注册的模型 `Topic`。`models` 前面的点告诉 Django 在与 *admin.py* 相同的目录中查找 *models.py*
    文件。`admin.site.register()` 代码告诉 Django 通过管理员网站管理我们的模型。
- en: Now use the superuser account to access the admin site. Go to *http://localhost:8000/admin/*
    and enter the username and password for the superuser you just created. You should
    see a screen similar to the one shown in [Figure 18-2](#figure18-2). This page
    allows you to add new users and groups, and change existing ones. You can also
    work with data related to the `Topic` model that we just defined.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用超级用户账户访问管理员网站。访问 *http://localhost:8000/admin/*，并输入你刚刚创建的超级用户的用户名和密码。你应该会看到一个类似
    [图 18-2](#figure18-2) 的页面。这个页面允许你添加新用户和组，并修改现有的用户和组。你也可以操作与我们刚刚定义的 `Topic` 模型相关的数据。
- en: '![](image_fi/502703c18/f18002.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502703c18/f18002.png)'
- en: 'Figure 18-2: The admin site with `Topic` included'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18-2：包含 `Topic` 的管理员网站
- en: Adding Topics
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加主题
- en: Now that `Topic` has been registered with the admin site, let’s add our first
    topic. Click **Topics** to go to the Topics page, which is mostly empty, because
    we have no topics to manage yet. Click **Add Topic**, and a form for adding a
    new topic appears. Enter `Chess` in the first box and click **Save**. You’ll be
    sent back to the Topics admin page, and you’ll see the topic you just created.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `Topic` 已经在管理员网站注册，接下来让我们添加第一个主题。点击 **Topics** 进入主题页面，页面大部分为空，因为我们还没有需要管理的主题。点击
    **Add Topic**，会出现一个添加新主题的表单。在第一个框中输入 `Chess`，然后点击 **Save**。你将被带回主题管理员页面，你会看到刚刚创建的主题。
- en: Let’s create a second topic so we’ll have more data to work with. Click **Add
    Topic** again, and enter `Rock Climbing`. Click **Save**, and you’ll be sent back
    to the main Topics page again. Now you’ll see Chess and Rock Climbing listed.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建第二个主题，以便有更多的数据进行操作。再次点击 **Add Topic**，输入 `Rock Climbing`。点击 **Save**，你会再次被带回主主题页面。现在，你会看到
    Chess 和 Rock Climbing 列出在页面上。
- en: Defining the Entry Model
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义 Entry 模型
- en: For a user to record what they’ve been learning about chess and rock climbing,
    we need to define a model for the kinds of entries users can make in their learning
    logs. Each entry needs to be associated with a particular topic. This relationship
    is called a *many-to-one relationship*, meaning many entries can be associated
    with one topic.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让用户记录他们在棋类和攀岩方面的学习内容，我们需要定义一个模型，用于记录用户可以在学习日志中做的条目。每个条目都需要与一个特定的主题相关联。这种关系被称为
    *多对一关系*，意味着多个条目可以关联到一个主题。
- en: 'Here’s the code for the `Entry` model. Place it in your *models.py* file:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 `Entry` 模型的代码。将其放入你的 *models.py* 文件中：
- en: '**models.py**'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**models.py**'
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `Entry` class inherits from Django’s base `Model` class, just as `Topic`
    did ❶. The first attribute, `topic`, is a `ForeignKey` instance ❷. A *foreign
    key* is a database term; it’s a reference to another record in the database. This
    is the code that connects each entry to a specific topic. Each topic is assigned
    a *key*, or ID, when it’s created. When Django needs to establish a connection
    between two pieces of data, it uses the keys associated with each piece of information.
    We’ll use these connections shortly to retrieve all the entries associated with
    a certain topic. The `on_delete=models.CASCADE` argument tells Django that when
    a topic is deleted, all the entries associated with that topic should be deleted
    as well. This is known as a *cascading delete*.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`Entry` 类继承自 Django 的基础 `Model` 类，就像 `Topic` 类一样 ❶。第一个属性 `topic` 是一个 `ForeignKey`
    实例 ❷。*外键* 是一个数据库术语；它是指向数据库中另一个记录的引用。这段代码将每个条目与特定主题关联起来。每个主题在创建时都会分配一个*键*或 ID。当
    Django 需要在两条数据之间建立连接时，它会使用与每条数据相关联的键。稍后我们将使用这些连接来检索与某个特定主题相关的所有条目。`on_delete=models.CASCADE`
    参数告诉 Django，当删除一个主题时，与该主题关联的所有条目也应该被删除。这被称为 *级联删除*。'
- en: Next is an attribute called `text`, which is an instance of `TextField` ❸. This
    kind of field doesn’t need a size limit, because we don’t want to limit the size
    of individual entries. The `date_added` attribute allows us to present entries
    in the order they were created, and to place a timestamp next to each entry.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一个名为 `text` 的属性，它是 `TextField` 的一个实例 ❸。这种字段不需要大小限制，因为我们不希望限制单个条目的大小。`date_added`
    属性允许我们按创建顺序展示条目，并为每个条目旁边添加一个时间戳。
- en: The `Meta` class is nested inside the `Entry` class ❹. The `Meta` class holds
    extra information for managing a model; here, it lets us set a special attribute
    telling Django to use `Entries` when it needs to refer to more than one entry.
    Without this, Django would refer to multiple entries as `Entrys`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`Meta` 类嵌套在 `Entry` 类中 ❹。`Meta` 类包含管理模型的额外信息；在这里，它允许我们设置一个特殊的属性，告诉 Django 在需要引用多个条目时使用
    `Entries`。如果没有这个，Django 会将多个条目称为 `Entrys`。'
- en: The `__str__()` method tells Django which information to show when it refers
    to individual entries. Because an entry can be a long body of text, `__str__()`
    returns just the first `50` characters of `text` ❺. We also add an ellipsis to
    clarify that we’re not always displaying the entire entry.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`__str__()` 方法告诉 Django 在引用单个条目时显示哪些信息。因为一个条目可能包含大量文本，所以 `__str__()` 返回 `text`
    的前 `50` 个字符 ❺。我们还添加了省略号，以明确表示我们并非总是显示完整的条目。'
- en: Migrating the Entry Model
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 迁移条目模型
- en: 'Because we’ve added a new model, we need to migrate the database again. This
    process will become quite familiar: you modify *models.py*, run the command `python
    manage.py makemigrations` `app_name`, and then run the command `python manage.py
    migrate`.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们添加了一个新模型，所以我们需要再次迁移数据库。这个过程将变得非常熟悉：你修改 *models.py*，运行命令 `python manage.py
    makemigrations` `app_name`，然后运行命令 `python manage.py migrate`。
- en: 'Migrate the database and check the output by entering the following commands:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移数据库并通过输入以下命令来检查输出：
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: A new migration called *0002_entry.py* is generated, which tells Django how
    to modify the database to store information related to the model `Entry` ❶. When
    we issue the `migrate` command, we see that Django applied this migration and
    everything worked properly ❷.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 生成了一个新的迁移文件 *0002_entry.py*，它告诉 Django 如何修改数据库以存储与模型 `Entry` 相关的信息 ❶。当我们执行 `migrate`
    命令时，Django 会应用这个迁移，并且一切正常工作 ❷。
- en: Registering Entry with the Admin Site
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在管理员网站注册条目
- en: 'We also need to register the `Entry` model. Here’s what *admin.py* should look
    like now:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要注册 `Entry` 模型。现在 *admin.py* 应该是这样的：
- en: '**admin.py**'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**admin.py**'
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Go back to *http://localhost/admin/*, and you should see Entries listed under
    *Learning_Logs*. Click the **Add** link for Entries, or click **Entries** and
    then choose **Add entry**. You should see a drop-down list to select the topic
    you’re creating an entry for and a text box for adding an entry. Select **Chess**
    from the drop-down list, and add an entry. Here’s the first entry I made:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到 *http://localhost/admin/*，你应该看到在 *Learning_Logs* 下列出条目。点击**添加**链接来添加条目，或者点击**条目**，然后选择**添加条目**。你应该看到一个下拉列表，供你选择你要创建条目的主题，并且有一个文本框用来添加条目。选择下拉列表中的**国际象棋**，然后添加一个条目。这是我添加的第一个条目：
- en: The opening is the first part of the game, roughly the first ten moves or so.
    In the opening, it’s a good idea to do three things—bring out your bishops and
    knights, try to control the center of the board, and castle your king.
  id: totrans-120
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 开局是游戏的第一部分，大约是前十步左右。在开局阶段，做三件事是个好主意——调动主教和骑士，尽量控制棋盘的中心，并为国王城堡。
- en: ''
  id: totrans-121
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Of course, these are just guidelines. It will be important to learn when to
    follow these guidelines and when to disregard these suggestions.
  id: totrans-122
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当然，这些只是指导原则。了解何时遵循这些原则以及何时忽视这些建议非常重要。
- en: When you click **Save**, you’ll be brought back to the main admin page for entries.
    Here, you’ll see the benefit of using `text[:50]` as the string representation
    for each entry; it’s much easier to work with multiple entries in the admin interface
    if you see only the first part of an entry, rather than the entire text of each
    entry.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击**保存**时，页面会带你回到条目的主管理页面。在这里，你会看到使用`text[:50]`作为每个条目的字符串表示的好处；如果只显示条目的前部分而不是每个条目的完整内容，管理界面处理多个条目会更容易。
- en: 'Make a second entry for Chess and one entry for Rock Climbing so we have some
    initial data. Here’s a second entry for Chess:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为Chess创建第二个条目，并为Rock Climbing创建一个条目，以便我们有一些初始数据。以下是Chess的第二个条目：
- en: In the opening phase of the game, it’s important to bring out your bishops and
    knights. These pieces are powerful and maneuverable enough to play a significant
    role in the beginning moves of a game.
  id: totrans-125
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在游戏的开局阶段，重要的是要把你的主教和骑士调出来。这些棋子强大且灵活，足以在游戏的开始阶段发挥重要作用。
- en: 'And here’s a first entry for Rock Climbing:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Rock Climbing的第一个条目：
- en: One of the most important concepts in climbing is to keep your weight on your
    feet as much as possible. There’s a myth that climbers can hang all day on their
    arms. In reality, good climbers have practiced specific ways of keeping their
    weight over their feet whenever possible.
  id: totrans-127
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 攀岩中最重要的概念之一是尽可能将重心放在脚上。有人误以为攀岩者可以整天用手臂挂着。实际上，优秀的攀岩者已经练习过在可能的情况下将重心放在脚上。
- en: These three entries will give us something to work with as we continue to develop
    Learning Log.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个条目将为我们提供一些内容，帮助我们继续开发Learning Log。
- en: The Django Shell
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Django Shell
- en: 'Now that we’ve entered some data, we can examine it programmatically through
    an interactive terminal session. This interactive environment is called the Django
    *shell*, and it’s a great environment for testing and troubleshooting your project.
    Here’s an example of an interactive shell session:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经输入了一些数据，可以通过交互式终端会话以编程方式检查它。这个交互式环境叫做Django的*shell*，它是一个非常适合测试和排查项目问题的环境。以下是一个交互式shell会话的示例：
- en: '[PRE20]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The command `python manage.py shell`, run in an active virtual environment,
    launches a Python interpreter that you can use to explore the data stored in your
    project’s database. Here, we import the model `Topic` from the `learning_logs.models`
    module ❶. We then use the method `Topic.objects.all()` to get all instances of
    the model `Topic`; the list that’s returned is called a *queryset*.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在激活的虚拟环境中运行`python manage.py shell`命令，可以启动一个Python解释器，您可以用它来探索存储在项目数据库中的数据。在这里，我们从`learning_logs.models`模块导入`Topic`模型❶。然后，我们使用方法`Topic.objects.all()`来获取所有`Topic`模型的实例；返回的列表称为*queryset*。
- en: 'We can loop over a queryset just as we’d loop over a list. Here’s how you can
    see the ID that’s been assigned to each topic object:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像遍历列表一样遍历一个queryset。以下是您如何查看分配给每个主题对象的ID：
- en: '[PRE21]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We assign the queryset to `topics` and then print each topic’s `id` attribute
    and the string representation of each topic. We can see that `Chess` has an ID
    of `1` and `Rock Climbing` has an ID of `2`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将queryset分配给`topics`，然后打印每个主题的`id`属性以及每个主题的字符串表示。我们可以看到`Chess`的ID是`1`，`Rock
    Climbing`的ID是`2`。
- en: 'If you know the ID of a particular object, you can use the method `Topic.objects.get()`
    to retrieve that object and examine any attribute the object has. Let’s look at
    the `text` and `date_added` values for `Chess`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您知道某个特定对象的ID，可以使用方法`Topic.objects.get()`来检索该对象，并检查该对象的任何属性。让我们来看一下`Chess`的`text`和`date_added`值：
- en: '[PRE22]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can also look at the entries related to a certain topic. Earlier, we defined
    the `topic` attribute for the `Entry` model. This was a `ForeignKey`, a connection
    between each entry and a topic. Django can use this connection to get every entry
    related to a certain topic, like this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以查看与某个特定主题相关的条目。之前，我们为`Entry`模型定义了`topic`属性。这个属性是一个`ForeignKey`，它在每个条目和一个主题之间建立了连接。Django可以利用这个连接获取与某个特定主题相关的每个条目，像这样：
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: To get data through a foreign key relationship, you use the lowercase name of
    the related model followed by an underscore and the word `set` ❶. For example,
    say you have the models `Pizza` and `Topping`, and `Topping` is related to `Pizza`
    through a foreign key. If your object is called `my_pizza`, representing a single
    pizza, you can get all of the pizza’s toppings using the code `my_pizza.topping_set.all()`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过外键关系获取数据，你需要使用相关模型的小写名称，后跟下划线和单词`set` ❶。例如，假设你有 `Pizza` 和 `Topping` 两个模型，且
    `Topping` 通过外键与 `Pizza` 相关。如果你的对象叫做 `my_pizza`，代表一个披萨，你可以使用代码 `my_pizza.topping_set.all()`
    获取该披萨的所有配料。
- en: We’ll use this syntax when we begin to code the pages users can request. The
    shell is really useful for making sure your code retrieves the data you want it
    to. If your code works as you expect it to in the shell, it should also work properly
    in the files within your project. If your code generates errors or doesn’t retrieve
    the data you expect it to, it’s much easier to troubleshoot your code in the simple
    shell environment than within the files that generate web pages. We won’t refer
    to the shell much, but you should continue using it to practice working with Django’s
    syntax for accessing the data stored in the project.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始编写用户可以请求的页面代码时，我们将使用这个语法。shell 对于确保你的代码能正确获取你想要的数据非常有用。如果你的代码在 shell 中按预期工作，那么它也应该在项目中的文件中正确运行。如果你的代码产生错误或没有按预期获取数据，在简单的
    shell 环境中调试代码要比在生成网页的文件中调试要容易得多。我们不会经常提到 shell，但你应该继续使用它来练习 Django 语法，以便访问项目中存储的数据。
- en: Each time you modify your models, you’ll need to restart the shell to see the
    effects of those changes. To exit a shell session, press CTRL-D; on Windows, press
    CTRL-Z and then press ENTER.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 每次修改模型后，你需要重新启动 shell 才能看到这些更改的效果。要退出 shell 会话，请按 CTRL-D；在 Windows 上，按 CTRL-Z
    然后按 ENTER。
- en: 'Making Pages: The Learning Log Home Page'
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 制作页面：Learning Log 主页
- en: 'Making web pages with Django consists of three stages: defining URLs, writing
    views, and writing templates. You can do these in any order, but in this project
    we’ll always start by defining the URL pattern. A *URL pattern* describes the
    way the URL is laid out. It also tells Django what to look for when matching a
    browser request with a site URL, so it knows which page to return.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Django 制作网页分为三个阶段：定义 URL、编写视图和编写模板。你可以按任何顺序进行这些操作，但在这个项目中，我们将始终从定义 URL 模式开始。*URL
    模式*描述了 URL 的布局方式。它还告诉 Django 在匹配浏览器请求与网站 URL 时要查找什么，以便知道返回哪个页面。
- en: Each URL then maps to a particular view. The *view* function retrieves and processes
    the data needed for that page. The view function often renders the page using
    a *template*, which contains the overall structure of the page. To see how this
    works, let’s make the home page for Learning Log. We’ll define the URL for the
    home page, write its view function, and create a simple template.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 URL 都映射到一个特定的视图。*视图*函数获取并处理该页面所需的数据。视图函数通常会使用一个*模板*来渲染页面，模板包含页面的整体结构。为了了解这一过程，我们将制作
    Learning Log 的主页。我们将定义主页的 URL，编写它的视图函数，并创建一个简单的模板。
- en: Because we just want to ensure that Learning Log works as it’s supposed to,
    we’ll make a simple page for now. A functioning web app is fun to style when it’s
    complete; an app that looks good but doesn’t work well is pointless. For now,
    the home page will display only a title and a brief description.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们只想确保 Learning Log 按预期工作，所以我们现在将制作一个简单的页面。完成后，功能完整的 Web 应用更容易进行样式化；而一个看起来不错但运行不良的应用毫无意义。目前，主页只会显示一个标题和简短的描述。
- en: Mapping a URL
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 映射 URL
- en: 'Users request pages by entering URLs into a browser and clicking links, so
    we’ll need to decide what URLs are needed. The home page URL is first: it’s the
    base URL people use to access the project. At the moment, the base URL, *http://localhost:8000/*,
    returns the default Django site that lets us know the project was set up correctly.
    We’ll change this by mapping the base URL to Learning Log’s home page.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 用户通过在浏览器中输入 URL 并点击链接来请求页面，因此我们需要决定需要哪些 URL。首先是主页的 URL：它是用户访问项目时使用的基础 URL。目前，基础
    URL *http://localhost:8000/* 会返回默认的 Django 网站，这告诉我们项目已经正确设置。我们将通过将基础 URL 映射到 Learning
    Log 的主页来改变这一点。
- en: 'In the main *ll_project* folder, open the file *urls.py*. You should see the
    following code:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在主 *ll_project* 文件夹中，打开 *urls.py* 文件。你应该会看到以下代码：
- en: '**ll_project/urls.py**'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**ll_project/urls.py**'
- en: '[PRE24]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The first two lines import the `admin` module and a function to build URL paths
    ❶. The body of the file defines the `urlpatterns` variable ❷. In this *urls.py*
    file, which defines URLs for the project as a whole, the `urlpatterns` variable
    includes sets of URLs from the apps in the project. The list includes the module
    `admin.site.urls`, which defines all the URLs that can be requested from the admin
    site ❸.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 前两行导入了`admin`模块和一个用于构建URL路径的函数❶。文件的主体定义了`urlpatterns`变量❷。在这个*urls.py*文件中，它为整个项目定义了URLs，`urlpatterns`变量包含了项目中各个应用的URL集合。列表中包括了模块`admin.site.urls`，它定义了所有可以从管理站点请求的URLs❸。
- en: 'We need to include the URLs for `learning_logs`, so add the following:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要包含`learning_logs`的URLs，因此添加以下内容：
- en: '[PRE25]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We’ve imported the `include()` function, and we’ve also added a line to include
    the module `learning_logs.urls`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经导入了`include()`函数，并且还添加了一行来包含模块`learning_logs.urls`。
- en: 'The default *urls.py* is in the *ll_project* folder; now we need to make a
    second *urls.py* file in the *learning_logs* folder. Create a new Python file,
    save it as *urls.py* in *learning_logs*, and enter this code into it:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的*urls.py*文件在*ll_project*文件夹中；现在我们需要在*learning_logs*文件夹中创建一个第二个*urls.py*文件。创建一个新的Python文件，将其保存为*urls.py*在*learning_logs*文件夹中，并在其中输入以下代码：
- en: '**learning_logs/urls.py**'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**learning_logs/urls.py**'
- en: '[PRE26]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: To make it clear which *urls.py* we’re working in, we add a docstring at the
    beginning of the file ❶. We then import the `path` function, which is needed when
    mapping URLs to views ❷. We also import the `views` module ❸; the dot tells Python
    to import the *views.py* module from the same directory as the current *urls.py*
    module. The variable `app_name` helps Django distinguish this *urls.py* file from
    files of the same name in other apps within the project ❹. The variable `urlpatterns`
    in this module is a list of individual pages that can be requested from the `learning_logs`
    app ❺.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了明确我们正在处理哪个*urls.py*文件，我们在文件开头添加了文档字符串❶。然后我们导入了`path`函数，这是将URLs映射到视图时所需要的❷。我们还导入了`views`模块❸；点号告诉Python从与当前*urls.py*模块相同的目录导入*views.py*模块。变量`app_name`帮助Django区分这个*urls.py*文件与项目中其他应用中同名的文件❹。此模块中的`urlpatterns`变量是一个可以从`learning_logs`应用请求的单独页面的列表❺。
- en: The actual URL pattern is a call to the `path()` function, which takes three
    arguments ❻. The first argument is a string that helps Django route the current
    request properly. Django receives the requested URL and tries to route the request
    to a view. It does this by searching all the URL patterns we’ve defined to find
    one that matches the current request. Django ignores the base URL for the project
    (*http://localhost:8000/*), so the empty string (`''`) matches the base URL. Any
    other URL won’t match this pattern, and Django will return an error page if the
    URL requested doesn’t match any existing URL patterns.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的URL模式是对`path()`函数的调用，该函数接受三个参数❻。第一个参数是一个字符串，帮助Django正确地路由当前请求。Django接收到请求的URL后，会尝试将请求路由到一个视图。它通过搜索我们定义的所有URL模式，找到一个与当前请求匹配的模式来实现这一点。Django忽略项目的基本URL（*http://localhost:8000/*），所以空字符串（`''`）与基本URL匹配。任何其他URL都无法匹配此模式，如果请求的URL没有匹配任何现有的URL模式，Django将返回一个错误页面。
- en: The second argument in `path()` ❻ specifies which function to call in *views.py*.
    When a requested URL matches the pattern we’re defining, Django calls the `index()`
    function from *views.py*. (We’ll write this view function in the next section.)
    The third argument provides the name *index* for this URL pattern so we can refer
    to it more easily in other files throughout the project. Whenever we want to provide
    a link to the home page, we’ll use this name instead of writing out a URL.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`path()`中的第二个参数❻指定了要调用的函数，即*views.py*中的函数。当请求的URL与我们定义的模式匹配时，Django会调用*views.py*中的`index()`函数。（我们将在下一节编写这个视图函数。）第三个参数为这个URL模式提供了名称*index*，这样我们就可以在项目中的其他文件中更方便地引用它。每当我们想提供一个指向主页的链接时，我们会使用这个名称，而不是写出完整的URL。'
- en: Writing a View
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写视图
- en: A view function takes in information from a request, prepares the data needed
    to generate a page, and then sends the data back to the browser. It often does
    this by using a template that defines what the page will look like.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 视图函数接收来自请求的信息，准备生成页面所需的数据，然后将数据发送回浏览器。它通常通过使用一个模板来定义页面的外观，来完成这一过程。
- en: 'The file *views.py* in *learning_logs* was generated automatically when we
    ran the command `python manage.py startapp`. Here’s what’s in *views.py* right
    now:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行命令`python manage.py startapp`时，*learning_logs*中的*views.py*文件是自动生成的。目前，*views.py*中的内容如下：
- en: '**views.py**'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**views.py**'
- en: '[PRE27]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Currently, this file just imports the `render()` function, which renders the
    response based on the data provided by views. Open *views.py* and add the following
    code for the home page:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这个文件只导入了`render()`函数，该函数根据视图提供的数据渲染响应。打开*views.py*并添加以下代码来创建主页：
- en: '[PRE28]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'When a URL request matches the pattern we just defined, Django looks for a
    function called `index()` in the *views.py* file. Django then passes the `request`
    object to this view function. In this case, we don’t need to process any data
    for the page, so the only code in the function is a call to `render()`. The `render()`
    function here passes two arguments: the original `request` object and a template
    it can use to build the page. Let’s write this template.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个URL请求与我们刚刚定义的模式匹配时，Django会在*views.py*文件中寻找一个名为`index()`的函数。然后，Django将`request`对象传递给这个视图函数。在这种情况下，我们不需要处理页面的数据，所以函数中唯一的代码就是调用`render()`。这里的`render()`函数传递了两个参数：原始的`request`对象和一个可以用来构建页面的模板。让我们编写这个模板。
- en: Writing a Template
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写模板
- en: The template defines what the page should look like, and Django fills in the
    relevant data each time the page is requested. A template allows you to access
    any data provided by the view. Because our view for the home page provides no
    data, this template is fairly simple.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 模板定义了页面的外观，而Django则在每次请求页面时填充相关数据。模板允许你访问视图提供的任何数据。由于我们为主页提供的视图没有数据，因此这个模板相对简单。
- en: 'Inside the *learning_logs* folder, make a new folder called *templates*. Inside
    the *templates* folder, make another folder called *learning_logs*. This might
    seem a little redundant (we have a folder named *learning_logs* inside a folder
    named *templates* inside a folder named *learning_logs*), but it sets up a structure
    that Django can interpret unambiguously, even in the context of a large project
    containing many individual apps. Inside the inner *learning_logs* folder, make
    a new file called *index.xhtml*. The path to the file will be *ll_project/learning_logs/templates/learning_logs/index.xhtml*.
    Enter the following code into that file:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在*learning_logs*文件夹内，创建一个名为*templates*的新文件夹。在*templates*文件夹内，再创建一个名为*learning_logs*的文件夹。这可能看起来有些冗余（我们在一个名为*learning_logs*的文件夹中再放一个名为*templates*的文件夹，里面再放一个名为*learning_logs*的文件夹），但这样可以建立一个Django可以明确理解的结构，即使在一个包含多个独立应用的大型项目中也是如此。在内部的*learning_logs*文件夹中，创建一个名为*index.xhtml*的新文件。该文件的路径将是*ll_project/learning_logs/templates/learning_logs/index.xhtml*。在该文件中输入以下代码：
- en: '**index.xhtml**'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**index.xhtml**'
- en: '[PRE29]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This is a very simple file. If you’re not familiar with HTML, the `<p></p>`
    tags signify paragraphs. The `<p>` tag opens a paragraph, and the `</p>` tag closes
    a paragraph. We have two paragraphs: the first acts as a title, and the second
    describes what users can do with Learning Log.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的文件。如果你不熟悉HTML，`<p></p>`标签表示段落。`<p>`标签用于打开一个段落，`</p>`标签用于关闭一个段落。我们有两个段落：第一个作为标题，第二个描述用户可以在Learning
    Log中做什么。
- en: Now when you request the project’s base URL, *http://localhost:8000/*, you should
    see the page we just built instead of the default Django page. Django will take
    the requested URL, and that URL will match the pattern `''`; then Django will
    call the function `views.index()`, which will render the page using the template
    contained in *index.xhtml*. [Figure 18-3](#figure18-3) shows the resulting page.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你请求项目的基础URL，*http://localhost:8000/*时，你应该能看到我们刚刚创建的页面，而不是默认的Django页面。Django会获取请求的URL，并将其与模式`''`进行匹配；然后，Django将调用函数`views.index()`，该函数将使用*index.xhtml*中包含的模板来渲染页面。[图18-3](#figure18-3)显示了生成的页面。
- en: '![](image_fi/502703c18/f18003.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502703c18/f18003.png)'
- en: 'Figure 18-3: The home page for Learning Log'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图18-3：Learning Log的主页
- en: Although it might seem like a complicated process for creating one page, this
    separation between URLs, views, and templates works quite well. It allows you
    to think about each aspect of a project separately. In larger projects, it allows
    individuals working on the project to focus on the areas in which they’re strongest.
    For example, a database specialist can focus on the models, a programmer can focus
    on the view code, and a frontend specialist can focus on the templates.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然创建一个页面看起来像是一个复杂的过程，但URL、视图和模板之间的这种分离方式其实非常有效。它让你可以分别思考项目的每个方面。在更大的项目中，它使得参与项目的人可以专注于自己最擅长的领域。例如，数据库专家可以专注于模型，程序员可以专注于视图代码，前端专家则可以专注于模板。
- en: Building Additional Pages
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建附加页面
- en: 'Now that we’ve established a routine for building a page, we can start to build
    out the Learning Log project. We’ll build two pages that display data: a page
    that lists all topics and a page that shows all the entries for a particular topic.
    For each page, we’ll specify a URL pattern, write a view function, and write a
    template. But before we do this, we’ll create a base template that all templates
    in the project can inherit from.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经建立了构建页面的常规流程，接下来我们可以开始构建学习日志项目。我们将构建两个显示数据的页面：一个列出所有主题的页面和一个显示特定主题下所有条目的页面。对于每个页面，我们将指定一个
    URL 模式，编写一个视图函数，并编写一个模板。但在这之前，我们将创建一个所有模板都可以继承的基础模板。
- en: Template Inheritance
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模板继承
- en: When building a website, some elements will need to be repeated on each page.
    Rather than writing these elements directly into each page, you can write a base
    template containing the repeated elements and then have each page inherit from
    the base. This approach lets you focus on developing the unique aspects of each
    page, and makes it much easier to change the overall look and feel of the project.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建网站时，一些元素需要在每个页面上重复。与其在每个页面中直接编写这些元素，不如编写一个包含重复元素的基础模板，然后让每个页面继承自该基础模板。这种方法让你可以专注于开发每个页面的独特部分，并使得更改项目的整体外观和感觉变得更加容易。
- en: The Parent Template
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 父模板
- en: 'We’ll create a template called *base.xhtml* in the same directory as *index.xhtml*.
    This file will contain elements common to all pages; every other template will
    inherit from *base.xhtml*. The only element we want to repeat on each page right
    now is the title at the top. Because we’ll include this template on every page,
    let’s make the title a link to the home page:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在与*index.xhtml*相同的目录下创建一个名为*base.xhtml*的模板。这个文件将包含所有页面共享的元素；其他所有模板都将继承自*base.xhtml*。目前我们只希望在每个页面上重复的元素是顶部的标题。因为我们将在每个页面中包含这个模板，所以让我们把标题做成指向主页的链接：
- en: '**base.xhtml**'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**base.xhtml**'
- en: '[PRE30]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The first part of this file creates a paragraph containing the name of the project,
    which also acts as a home page link. To generate a link, we use a *template tag*,
    which is indicated by braces and percent signs (`{% %}`). A template tag generates
    information to be displayed on a page. The template tag `{% url 'learning_logs:index'
    %}` shown here generates a URL matching the URL pattern defined in *learning_logs/urls.py*
    with the name `'index'` ❶. In this example, `learning_logs` is the *namespace*
    and `index` is a uniquely named URL pattern in that namespace. The namespace comes
    from the value we assigned to `app_name` in the *learning_logs/urls.py* file.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件的第一部分创建了一个包含项目名称的段落，该名称还充当主页链接。为了生成链接，我们使用一个*模板标签*，它由大括号和百分号表示（`{% %}`）。模板标签生成将在页面上显示的信息。这里显示的模板标签`{%
    url 'learning_logs:index' %}`生成一个与*learning_logs/urls.py*中定义的URL模式匹配的 URL，模式的名称为`'index'`
    ❶。在这个例子中，`learning_logs`是*命名空间*，而`index`是该命名空间中独一无二的 URL 模式。命名空间来自我们在*learning_logs/urls.py*文件中赋值给`app_name`的值。
- en: 'In a simple HTML page, a link is surrounded by the *anchor* *tag* `<a>`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个简单的 HTML 页面中，链接被*锚点* *标签* `<a>` 包围：
- en: '[PRE31]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Having the template tag generate the URL for us makes it much easier to keep
    our links up to date. We only need to change the URL pattern in *urls.py*, and
    Django will automatically insert the updated URL the next time the page is requested.
    Every page in our project will inherit from *base.xhtml*, so from now on, every
    page will have a link back to the home page.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让模板标签为我们生成 URL 可以大大简化更新链接的过程。我们只需要在*urls.py*中更改 URL 模式，Django 会在下次请求页面时自动插入更新后的
    URL。我们项目中的每个页面都将继承自*base.xhtml*，因此从现在起，每个页面都会有一个指向主页的链接。
- en: On the last line, we insert a pair of `block` tags ❷. This block, named `content`,
    is a placeholder; the child template will define the kind of information that
    goes in the `content` block.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一行，我们插入了一对`block`标签 ❷。这个名为`content`的块是一个占位符；子模板将定义放入`content`块中的信息类型。
- en: A child template doesn’t have to define every block from its parent, so you
    can reserve space in parent templates for as many blocks as you like; the child
    template uses only as many as it needs.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 子模板不必定义父模板中的每个块，因此你可以在父模板中保留尽可能多的块空间；子模板只使用它需要的部分。
- en: The Child Template
  id: totrans-194
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 子模板
- en: 'Now we need to rewrite *index.xhtml* to inherit from *base.xhtml*. Add the
    following code to *index.xhtml*:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要重写*index.xhtml*，使其继承自*base.xhtml*。请将以下代码添加到*index.xhtml*：
- en: '**index.xhtml**'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '**index.xhtml**'
- en: '[PRE32]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If you compare this to the original *index.xhtml*, you can see that we’ve replaced
    the Learning Log title with the code for inheriting from a parent template ❶.
    A child template must have an `{% extends %}` tag on the first line to tell Django
    which parent template to inherit from. The file *base.xhtml* is part of `learning_logs`,
    so we include *learning_logs* in the path to the parent template. This line pulls
    in everything contained in the *base.xhtml* template and allows *index.xhtml*
    to define what goes in the space reserved by the `content` block.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将其与原始的*index.xhtml*进行对比，你会看到我们将学习日志的标题替换为了继承父模板的代码❶。子模板的第一行必须有`{% extends
    %}`标签，以告诉Django从哪个父模板继承。*base.xhtml*文件是`learning_logs`的一部分，因此我们在父模板的路径中包含了*learning_logs*。这一行引入了*base.xhtml*模板中的所有内容，并允许*index.xhtml*定义在`content`块中预留的空间中放置的内容。
- en: We define the content block by inserting a `{% block %}` tag with the name `content`
    ❷. Everything that we aren’t inheriting from the parent template goes inside the
    `content` block. Here, that’s the paragraph describing the Learning Log project.
    We indicate that we’re finished defining the content by using an `{% endblock
    content %}` tag ❸. The `{% endblock %}` tag doesn’t require a name, but if a template
    grows to contain multiple blocks, it can be helpful to know exactly which block
    is ending.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过插入一个名为`content`的`{% block %}`标签❷来定义内容块。所有没有从父模板继承的内容都放在`content`块内。这里，就是描述学习日志项目的段落。我们通过使用`{%
    endblock content %}`标签❸来表示内容定义的结束。`{% endblock %}`标签不需要指定名称，但如果模板中包含多个块，知道具体哪个块结束会很有帮助。
- en: 'You can start to see the benefit of template inheritance: in a child template,
    we only need to include content that’s unique to that page. This not only simplifies
    each template, but also makes it much easier to modify the site. To modify an
    element common to many pages, you only need to modify the parent template. Your
    changes are then carried over to every page that inherits from that template.
    In a project that includes tens or hundreds of pages, this structure can make
    it much easier and faster to improve your site.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以开始看到模板继承的好处：在子模板中，我们只需要包含该页面独特的内容。这不仅简化了每个模板的编写，还使得修改站点变得更加容易。要修改多个页面共享的元素，只需要修改父模板。然后，你的更改将应用于所有继承自该模板的页面。在一个包含数十或数百个页面的项目中，这种结构可以大大提高更新站点的效率和速度。
- en: In a large project, it’s common to have one parent template called *base.xhtml*
    for the entire site and parent templates for each major section of the site. All
    the section templates inherit from *base.xhtml*, and each page in the site inherits
    from a section template. This way you can easily modify the look and feel of the
    site as a whole, any section in the site, or any individual page. This configuration
    provides a very efficient way to work, and encourages you to steadily update your
    project over time.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个大型项目中，通常会有一个名为*base.xhtml*的父模板，涵盖整个站点，以及每个主要部分的父模板。所有的部分模板都继承自*base.xhtml*，站点中的每个页面都继承自一个部分模板。这样，你可以轻松地修改站点的整体外观、任何部分的外观，或者任何单独页面的外观。这种配置提供了一种非常高效的工作方式，并鼓励你随着时间的推移稳步更新你的项目。
- en: The Topics Page
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 主题页面
- en: 'Now that we have an efficient approach to building pages, we can focus on our
    next two pages: the general topics page and the page to display entries for a
    single topic. The topics page will show all topics that users have created, and
    it’s the first page that will involve working with data.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了高效的页面构建方法，可以专注于接下来的两个页面：一般主题页面和显示单个主题条目的页面。主题页面将展示用户创建的所有主题，这是第一个涉及数据处理的页面。
- en: The Topics URL Pattern
  id: totrans-204
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 主题 URL 模式
- en: 'First, we define the URL for the topics page. It’s common to choose a simple
    URL fragment that reflects the kind of information presented on the page. We’ll
    use the word *topics*, so the URL *http://localhost:8000/topics/* will return
    this page. Here’s how we modify *learning_logs/urls.py*:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义主题页面的 URL。通常会选择一个简单的 URL 片段，反映页面上呈现的信息类型。我们将使用*topics*这个词，因此 URL *http://localhost:8000/topics/*
    将返回该页面。以下是我们如何修改*learning_logs/urls.py*：
- en: '**learning_logs/urls.py**'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**learning_logs/urls.py**'
- en: '[PRE33]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The new URL pattern is the word *topics*, followed by a forward slash. When
    Django examines a requested URL, this pattern will match any URL that has the
    base URL followed by *topics*. You can include or omit a forward slash at the
    end, but there can’t be anything else after the word *topics*, or the pattern
    won’t match. Any request with a URL that matches this pattern will then be passed
    to the function `topics()` in *views.py*.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 URL 模式是单词 *topics*，后跟一个斜杠。当 Django 检查请求的 URL 时，这个模式将匹配任何以基本 URL 后跟 *topics*
    的 URL。你可以选择在末尾添加或省略斜杠，但在 *topics* 后面不能有其他内容，否则模式将无法匹配。任何与此模式匹配的 URL 请求将被传递给 *views.py*
    中的 `topics()` 函数。
- en: The Topics View
  id: totrans-209
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 主题视图
- en: 'The `topics()` function needs to retrieve some data from the database and send
    it to the template. Add the following to *views.py*:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`topics()` 函数需要从数据库中获取一些数据，并将其发送到模板。将以下内容添加到 *views.py*：'
- en: '**views.py**'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**views.py**'
- en: '[PRE34]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We first import the model associated with the data we need ❶. The `topics()`
    function needs one parameter: the `request` object Django received from the server
    ❷. We query the database by asking for the `Topic` objects, sorted by the `date_added`
    attribute ❸. We assign the resulting queryset to `topics`.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入与我们需要的数据相关的模型 ❶。`topics()` 函数需要一个参数：Django 从服务器接收到的 `request` 对象 ❷。我们通过请求
    `Topic` 对象并按 `date_added` 属性排序来查询数据库 ❸。我们将结果查询集分配给 `topics`。
- en: We then define a context that we’ll send to the template ❹. A *context* is a
    dictionary in which the keys are names we’ll use in the template to access the
    data we want, and the values are the data we need to send to the template. In
    this case, there’s one key-value pair, which contains the set of topics we’ll
    display on the page. When building a page that uses data, we call `render()` with
    the `request` object, the template we want to use, and the `context` dictionary
    ❺.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们定义一个上下文，将其传送到模板 ❹。*上下文* 是一个字典，其中键是我们在模板中用于访问所需数据的名称，值是我们需要传递给模板的数据。在这种情况下，有一对键值对，包含我们将在页面上显示的主题集合。在构建使用数据的页面时，我们调用
    `render()`，传入 `request` 对象、我们想要使用的模板和 `context` 字典 ❺。
- en: The Topics Template
  id: totrans-215
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 主题模板
- en: 'The template for the topics page receives the `context` dictionary, so the
    template can use the data that `topics()` provides. Make a file called *topics.xhtml*
    in the same directory as *index.xhtml*. Here’s how we can display the topics in
    the template:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 主题页面的模板接收 `context` 字典，因此模板可以使用 `topics()` 提供的数据。请在与 *index.xhtml* 相同的目录中创建一个名为
    *topics.xhtml* 的文件。以下是我们如何在模板中显示主题：
- en: '**topics.xhtml**'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '**topics.xhtml**'
- en: '[PRE35]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We use the `{% extends %}` tag to inherit from *base.xhtml*, just as we did
    on the home page, and then we open a `content` block. The body of this page contains
    a bulleted list of the topics that have been entered. In standard HTML, a bulleted
    list is called an *unordered list* and is indicated by the tags `<ul></ul>`. The
    opening tag `<ul>` begins the bulleted list of topics ❶.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `{% extends %}` 标签从 *base.xhtml* 继承，就像在主页中做的那样，然后打开一个 `content` 块。该页面的主体包含已输入主题的项目符号列表。在标准
    HTML 中，项目符号列表被称为 *无序列表*，并通过 `<ul></ul>` 标签表示。打开标签 `<ul>` 开始了主题的项目符号列表 ❶。
- en: 'Next we use a template tag that’s equivalent to a `for` loop, which loops through
    the list `topics` from the `context` dictionary ❷. The code used in templates
    differs from Python in some important ways. Python uses indentation to indicate
    which lines of a `for` statement are part of a loop. In a template, every `for`
    loop needs an explicit `{% endfor %}` tag indicating where the end of the loop
    occurs. So in a template, you’ll see loops written like this:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用一个等效于 `for` 循环的模板标签，它遍历 `context` 字典中的 `topics` 列表 ❷。模板中使用的代码在一些重要方面与
    Python 不同。Python 使用缩进来指示 `for` 语句中的哪些行属于循环。在模板中，每个 `for` 循环都需要一个明确的 `{% endfor
    %}` 标签，指示循环的结束。因此，在模板中，你会看到类似这样的循环：
- en: '[PRE36]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Inside the loop, we want to turn each topic into an item in the bulleted list.
    To print a variable in a template, wrap the variable name in double braces. The
    braces won’t appear on the page; they just indicate to Django that we’re using
    a template variable. So the code `{{ topic.text }}` ❸ will be replaced by the
    value of the current topic’s `text` attribute on each pass through the loop. The
    HTML tag `<li></li>` indicates a *list item*. Anything between these tags, inside
    a pair of `<ul></ul>` tags, will appear as a bulleted item in the list.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环内部，我们希望将每个话题转化为项目符号列表中的一个项目。要在模板中打印变量，请将变量名包裹在双大括号中。大括号不会出现在页面上，它们只是告诉Django我们正在使用模板变量。因此，代码`{{
    topic.text }}` ❸将在循环的每次迭代中被当前话题的`text`属性的值所替代。HTML标签`<li></li>`表示一个*列表项*。任何位于这两个标签之间、在`<ul></ul>`标签对中的内容，都将作为项目符号项目显示在列表中。
- en: We also use the `{% empty %}` template tag ❹, which tells Django what to do
    if there are no items in the list. In this case, we print a message informing
    the user that no topics have been added yet. The last two lines close out the
    `for` loop ❺ and then close out the bulleted list ❻.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用了`{% empty %}`模板标签 ❹，它告诉Django在列表中没有项目时该怎么办。在这种情况下，我们会打印一条消息，告知用户尚未添加任何话题。最后两行关闭`for`循环
    ❺，然后关闭项目符号列表 ❻。
- en: 'Now we need to modify the base template to include a link to the topics page.
    Add the following code to *base.xhtml*:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要修改基础模板，以便包含指向话题页面的链接。将以下代码添加到*base.xhtml*中：
- en: '**base.xhtml**'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '**base.xhtml**'
- en: '[PRE37]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We add a dash after the link to the home page ❶, and then add a link to the
    topics page using the `{% url %}` template tag again ❷. This line tells Django
    to generate a link matching the URL pattern with the name `'topics'` in *learning_logs/urls.py*.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在主页链接后添加一个破折号 ❶，然后再次使用`{% url %}`模板标签添加指向话题页面的链接 ❷。这一行告诉Django生成一个与*learning_logs/urls.py*中名为`'topics'`的URL模式匹配的链接。
- en: Now when you refresh the home page in your browser, you’ll see a Topics link.
    When you click the link, you’ll see a page that looks similar to [Figure 18-4](#figure18-4).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当您在浏览器中刷新主页时，您会看到一个话题链接。当您点击该链接时，您将看到一个类似于[图18-4](#figure18-4)的页面。
- en: '![](image_fi/502703c18/f18004.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502703c18/f18004.png)'
- en: 'Figure 18-4: The topics page'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图18-4：话题页面
- en: Individual Topic Pages
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单个话题页面
- en: Next, we need to create a page that can focus on a single topic, showing the
    topic name and all the entries for that topic. We’ll define a new URL pattern,
    write a view, and create a template. We’ll also modify the topics page so each
    item in the bulleted list links to its corresponding topic page.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个页面，专注于单个话题，显示该话题的名称以及所有相关条目。我们将定义一个新的URL模式，编写一个视图，并创建一个模板。我们还将修改话题页面，使项目符号列表中的每个项目都链接到其对应的话题页面。
- en: The Topic URL Pattern
  id: totrans-233
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 话题URL模式
- en: 'The URL pattern for the topic page is a little different from the prior URL
    patterns because it will use the topic’s `id` attribute to indicate which topic
    was requested. For example, if the user wants to see the detail page for the Chess
    topic (where the `id` is 1), the URL will be *http://localhost:8000/topics/1/*.
    Here’s a pattern to match this URL, which you should place in *learning_logs/urls.py*:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 话题页面的URL模式与之前的URL模式略有不同，因为它将使用话题的`id`属性来指示请求的具体话题。例如，如果用户想查看象棋话题的详细页面（其中`id`为1），则URL将是*http://localhost:8000/topics/1/*。以下是匹配此URL的模式，您应将其放置在*learning_logs/urls.py*中：
- en: '**learning_logs/urls.py**'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '**learning_logs/urls.py**'
- en: '[PRE38]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Let’s examine the string `'topics/<int:topic_id>/'` in this URL pattern. The
    first part of the string tells Django to look for URLs that have the word *topics*
    after the base URL. The second part of the string, `/<int:topic_id>/`, matches
    an integer between two forward slashes and assigns the integer value to an argument
    called `topic_id`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析这个URL模式中的字符串`'topics/<int:topic_id>/'`。字符串的第一部分告诉Django在基础URL后查找包含单词*topics*的URL。字符串的第二部分`/<int:topic_id>/`，匹配两个斜杠之间的整数，并将整数值分配给名为`topic_id`的参数。
- en: When Django finds a URL that matches this pattern, it calls the view function
    `topic()` with the value assigned to `topic_id` as an argument. We’ll use the
    value of `topic_id` to get the correct topic inside the function.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 当Django找到与此模式匹配的URL时，它会调用视图函数`topic()`，并将分配给`topic_id`的值作为参数传递。我们将在函数中使用`topic_id`的值来获取正确的话题。
- en: The Topic View
  id: totrans-239
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 话题视图
- en: 'The `topic()` function needs to get the topic and all associated entries from
    the database, much like what we did earlier in the Django shell:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`topic()`函数需要从数据库中获取话题及其所有相关条目，类似于我们之前在Django shell中所做的：'
- en: '**views.py**'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '**views.py**'
- en: '[PRE39]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This is the first view function that requires a parameter other than the `request`
    object. The function accepts the value captured by the expression `/<int:topic_id>/`
    and assigns it to `topic_id` ❶. Then we use `get()` to retrieve the topic, just
    as we did in the Django shell ❷. Next, we get all of the entries associated with
    this topic and order them according to `date_added` ❸. The minus sign in front
    of `date_added` sorts the results in reverse order, which will display the most
    recent entries first. We store the topic and entries in the `context` dictionary
    ❹ and call `render()` with the `request` object, the *topic.xhtml* template, and
    the `context` dictionary ❺.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第一个需要除了`request`对象外的其他参数的视图函数。该函数接受由表达式 `/<int:topic_id>/` 捕获的值，并将其分配给 `topic_id`
    ❶。然后我们使用 `get()` 来检索主题，就像我们在 Django shell 中做的那样 ❷。接下来，我们获取与此主题相关的所有条目，并按`date_added`
    ❸ 排序。`date_added` 前的负号将结果按逆序排列，从而使最新的条目首先显示。我们将主题和条目存储在 `context` 字典 ❹ 中，并使用 `render()`
    函数，将 `request` 对象、*topic.xhtml* 模板和 `context` 字典传递给它 ❺。
- en: The Topic Template
  id: totrans-244
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 主题模板
- en: The template needs to display the name of the topic and the entries. We also
    need to inform the user if no entries have been made yet for this topic.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 模板需要显示主题的名称和条目。如果该主题尚未创建任何条目，我们还需要通知用户。
- en: '**topic.xhtml**'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '**topic.xhtml**'
- en: '[PRE40]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We extend *base.xhtml*, as we’ll do for all pages in the project. Next, we show
    the `text` attribute of the topic that’s been requested ❶. The variable `topic`
    is available because it’s included in the `context` dictionary. We then start
    a bulleted list ❷ to show each of the entries and loop through them ❸, as we did
    with the topics earlier.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们扩展了 *base.xhtml*，正如我们将在项目中的所有页面中所做的那样。接下来，我们显示请求的主题的 `text` 属性 ❶。变量 `topic`
    可用，因为它已包含在 `context` 字典中。然后我们开始一个项目符号列表 ❷，显示每个条目，并像之前处理主题时那样循环遍历它们 ❸。
- en: 'Each bullet lists two pieces of information: the timestamp and the full text
    of each entry. For the timestamp ❹, we display the value of the attribute `date_added`.
    In Django templates, a vertical line (`|`) represents a template *filter*—a function
    that modifies the value in a template variable during the rendering process. The
    filter `date:''M d, Y H:i''` displays timestamps in the format *January 1, 2022
    23:00*. The next line displays the value of the current entry’s `text` attribute.
    The filter `linebreaks` ❺ ensures that long text entries include line breaks in
    a format understood by browsers, rather than showing a block of uninterrupted
    text. We again use the `{% empty %}` template tag ❻ to print a message informing
    the user that no entries have been made.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 每个项目列出两条信息：时间戳和每个条目的完整文本。对于时间戳 ❹，我们显示属性`date_added`的值。在 Django 模板中，竖线符号 (`|`)
    代表模板的*过滤器*—一种在渲染过程中修改模板变量值的函数。过滤器`date:'M d, Y H:i'`以 *2022年1月1日 23:00* 的格式显示时间戳。下一行显示当前条目的`text`属性值。过滤器`linebreaks`
    ❺ 确保长文本条目在浏览器中显示时会包含换行符，而不是一大段连续的文本。我们再次使用 `{% empty %}` 模板标签 ❻ 来打印一条消息，告知用户尚未创建任何条目。
- en: Links from the Topics Page
  id: totrans-250
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 来自主题页面的链接
- en: 'Before we look at the topic page in a browser, we need to modify the topics
    template so each topic links to the appropriate page. Here’s the change you need
    to make to *topics.xhtml*:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们浏览器中查看主题页面之前，我们需要修改主题模板，以便每个主题都链接到相应的页面。以下是你需要在*topics.xhtml*中做的修改：
- en: '**topics.xhtml**'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '**topics.xhtml**'
- en: '[PRE41]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We use the URL template tag to generate the proper link, based on the URL pattern
    in `learning_logs` with the name `'topic'`. This URL pattern requires a `topic_id`
    argument, so we add the attribute `topic.id` to the URL template tag. Now each
    topic in the list of topics is a link to a topic page, such as *http://localhost:8000/topics/1/*.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 URL 模板标签来生成适当的链接，基于`learning_logs`中名为`'topic'`的 URL 模式。该 URL 模式需要一个`topic_id`参数，因此我们将属性`topic.id`添加到
    URL 模板标签中。现在，主题列表中的每个主题都链接到相应的主题页面，例如 *http://localhost:8000/topics/1/*。
- en: When you refresh the topics page and click a topic, you should see a page that
    looks like [Figure 18-5](#figure18-5).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 当你刷新主题页面并点击一个主题时，你应该会看到像[图 18-5](#figure18-5)那样的页面。
- en: '![](image_fi/502703c18/f18005.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502703c18/f18005.png)'
- en: 'Figure 18-5: The detail page for a single topic, showing all entries for a
    topic'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18-5：单一主题的详细页面，展示该主题的所有条目
- en: Summary
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how to start building a simple web app using the
    Django framework. You saw a brief project specification, installed Django to a
    virtual environment, set up a project, and checked that the project was set up
    correctly. You set up an app and defined models to represent the data for your
    app. You learned about databases and how Django helps you migrate your database
    after you make a change to your models. You created a superuser for the admin
    site, and you used the admin site to enter some initial data.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何使用 Django 框架开始构建一个简单的 web 应用程序。你了解了一个简要的项目规范，安装了 Django 到虚拟环境中，设置了一个项目，并检查了项目是否正确设置。你设置了一个应用并定义了模型，以表示应用的数据。你了解了数据库以及
    Django 如何在你对模型进行更改后帮助你迁移数据库。你为管理站点创建了超级用户，并使用管理站点输入了一些初始数据。
- en: You also explored the Django shell, which allows you to work with your project’s
    data in a terminal session. You learned how to define URLs, create view functions,
    and write templates to make pages for your site. You also used template inheritance
    to simplify the structure of individual templates and make it easier to modify
    the site as the project evolves.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 你还探索了 Django shell，它允许你在终端会话中操作项目的数据。你学习了如何定义 URL、创建视图函数以及编写模板来制作你站点的页面。你还使用了模板继承来简化单个模板的结构，并在项目发展过程中使修改站点变得更加容易。
- en: In Chapter 19, you’ll make intuitive, user-friendly pages that allow users to
    add new topics and entries and edit existing entries without going through the
    admin site. You’ll also add a user registration system, allowing users to create
    an account and make their own learning log. This is the heart of a web app—the
    ability to create something that any number of users can interact with.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 19 章中，你将创建直观且用户友好的页面，允许用户添加新的主题和条目，并编辑现有条目，而无需通过管理站点。你还将添加用户注册系统，允许用户创建账户并制作自己的学习日志。这是
    web 应用的核心——创建一种任何数量的用户都可以互动的功能。
