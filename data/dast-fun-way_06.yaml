- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Tries and Adapting Data Structures
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 字典树与适应性数据结构
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: Binary search trees, while incredibly powerful, are only one way of using a
    tree structure to better organize data. Instead of splitting our data sets based
    on less-than or greater-than comparisons, we can optimize how the tree splits
    the data for the specific search problem at hand. In this chapter, for example,
    we tackle the problem of storing and searching strings in trees. Extending the
    binary search tree’s general branching approach to capture additional structure
    within the data enables us to search efficiently for target strings in a set of
    strings.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉搜索树虽然功能强大，但只是使用树形结构来更好组织数据的一种方式。我们可以通过根据特定搜索问题来优化树分割数据的方式，而不是依赖大小比较来划分数据集。例如，在本章中，我们解决了如何在树中存储和搜索字符串的问题。通过扩展二叉搜索树的通用分支方法，以捕捉数据中的额外结构，我们可以在字符串集合中高效地搜索目标字符串。
- en: 'We begin by discussing how binary search trees can be directly applied to string
    data but have greater cost than other datatypes. Taking the sequential nature
    of strings into account, we’ll then adapt our search trees to store strings more
    efficiently. The result is a branching structure that may one day motivate the
    world’s most gloriously excessive filing cabinet: the trie (pronounced “try”).'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先讨论如何将二叉搜索树直接应用于字符串数据，但其开销比其他数据类型更高。考虑到字符串的顺序特性，我们接着将调整我们的搜索树，以更高效地存储字符串。结果是一个分支结构，未来或许能激发出世界上最奢华的文件柜：字典树（发音为“try”）。
- en: Tries are data structures that branch on a *single* character of the string
    at each level. This splitting strategy greatly reduces the cost of comparisons
    at each node. Through this lens, we explore how foundational concepts of various
    algorithms and data structures can be adapted to a new type of problem.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 字典树是一种数据结构，在每一层上根据字符串的*单个*字符进行分支。这种拆分策略大大减少了每个节点比较的成本。通过这种视角，我们探讨了如何将各种算法和数据结构的基础概念适应于新的问题类型。
- en: Binary Search Trees of Strings
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串的二叉搜索树
- en: When considering whether we can improve an algorithm, we should first understand
    the limitations of our current approach—otherwise, there’s no reason to build
    a more complex data structure. Therefore, before we dive into string-specific
    data structures, we’ll examine where binary search trees fall short when used
    to store strings. First, let’s see how binary search trees can be used for this
    search.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑是否可以改进一个算法时，我们应该首先理解当前方法的局限性——否则就没有理由去构建一个更复杂的数据结构。因此，在深入探讨针对字符串的特定数据结构之前，我们将先了解在用二叉搜索树存储字符串时存在的不足之处。首先，让我们看看如何将二叉搜索树用于这种搜索。
- en: Strings in Trees
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 树中的字符串
- en: Binary search trees can store not just numbers but anything sortable, from shoes
    (sorted by size or smell) to zombie movies (sorted by box office revenue or scariness)
    to food items (sorted by price, spiciness, or likelihood to cause vomiting within
    the next 24 hours). Binary search trees are quite versatile that way. All we need
    is the ability to order the items.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉搜索树不仅可以存储数字，还可以存储任何可排序的东西，从鞋子（按大小或气味排序）到僵尸电影（按票房收入或恐怖程度排序）再到食物项（按价格、辣度或未来24小时内导致呕吐的可能性排序）。二叉搜索树在这方面非常灵活。我们所需要的只是能够对项进行排序的能力。
- en: To store strings in a binary search tree, we can sort elements in alphabetical
    order. For example, each node of the binary search tree in [Figure 6-1](#figure6-1)
    is a single string partitioning its subtree into strings that come before and
    after it in the dictionary. We reuse the greater than and less than notation from
    binary search trees, where X < Y indicates that string X comes before string Y
    in the alphabet.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在二叉搜索树中存储字符串，我们可以将元素按字母顺序排序。例如，图6-1中的每个二叉搜索树节点都是一个字符串，将其子树划分为字典中该字符串之前和之后的字符串。我们沿用了二叉搜索树中的大于和小于符号，X
    < Y 表示字符串 X 在字母表中排在字符串 Y 之前。
- en: '![The root node of this binary search tree is Laugh. Its left child is Feet,
    and its right child is Rock. Various subtrees are also organized alphabetically.
    ](image_fi/502604c06/f06001.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![该二叉搜索树的根节点是 Laugh。它的左子节点是 Feet，右子节点是 Rock。各种子树也按字母顺序组织。](image_fi/502604c06/f06001.png)'
- en: 'Figure 6-1: A binary search tree constructed with words'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-1：用单词构建的二叉搜索树
- en: 'We search binary search trees of strings just as we did for numbers. For example,
    to find the string LIGHT in [Figure 6-1](#figure6-1), we begin at the root node.
    We then compare the target value to the node’s value, using alphabetical ordering,
    and progress down either the left or right branch:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们像搜索数字一样搜索二叉搜索树中的字符串。例如，在[图6-1](#figure6-1)中查找字符串“LIGHT”，我们从根节点开始。然后，我们将目标值与节点的值进行比较，使用字母顺序，继续沿左分支或右分支前进：
- en: 'LIGHT > LAUGH: We proceed down the right branch.'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: LIGHT > LAUGH：我们沿着右分支继续前进。
- en: 'LIGHT < ROCK: We proceed down the left branch.'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: LIGHT < ROCK：我们沿着左分支继续前进。
- en: 'LIGHT < MAIN: We proceed down the left branch.'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: LIGHT < MAIN：我们沿着左分支继续前进。
- en: 'LIGHT == LIGHT: We have found the target value and can terminate the search.'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: LIGHT == LIGHT：我们已找到目标值，可以终止搜索。
- en: In [Figure 6-2](#figure6-2), the shaded ovals indicate the 4 out of 12 nodes
    explored during the search.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图6-2](#figure6-2)中，阴影区域的椭圆表示在搜索过程中探测到的12个节点中的4个。
- en: '![Diagram marking the path of a search for the string LIGHT. The search moves
    down the tree from LAUGH to ROCK to MAIN to LIGHT. The nodes containing these
    strings are grayed out. ](image_fi/502604c06/f06002.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![标记搜索字符串LIGHT路径的图示。搜索路径从LAUGH到ROCK再到MAIN最后到LIGHT，包含这些字符串的节点已被灰色标出。](image_fi/502604c06/f06002.png)'
- en: 'Figure 6-2: The path of traversal when searching a binary search tree of strings
    for the string LIGHT'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-2：在搜索二叉搜索树中的字符串“LIGHT”时的遍历路径
- en: At first glance, binary search trees seem to provide a simple, efficient mechanism
    for searching string data—no modification required. If our tree is balanced, the
    worst-case cost of the search will scale proportional to the logarithm of the
    number of entries. In [Figure 6-2](#figure6-2), we were able to limit our search
    to checking the target against only 4 out of 12 nodes.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，二叉搜索树似乎提供了一种简单、高效的机制来搜索字符串数据——无需修改。如果我们的树是平衡的，那么搜索的最坏情况下的代价将与条目的数量的对数成比例。在[图6-2](#figure6-2)中，我们能够将搜索范围限制为只检查12个节点中的4个。
- en: However, we are forgetting one critical factor—the cost of each comparison.
    As we saw in Chapter 1, comparing two strings is more expensive than comparing
    a pair of numbers. In fact, in the worst case, the cost of the string comparison
    operation scales with the length of the strings themselves. Now the cost of our
    tree search depends on both the number of strings and their lengths, meaning we’ve
    added a new dimension of complexity.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们忘记了一个关键因素——每次比较的代价。如第一章所述，比较两个字符串比比较一对数字要昂贵。事实上，在最坏的情况下，字符串比较操作的代价与字符串的长度成比例。现在，我们的树搜索的代价不仅取决于字符串的数量，还取决于它们的长度，这意味着我们增加了一个新的复杂度维度。
- en: 'To fix this problem and achieve even greater computational savings than provided
    by a binary search tree, we must take into account two important aspects of string
    data’s structure: the sequential ordering of strings and the limited number of
    letters or characters involved.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，并实现比二叉搜索树更高的计算节省，我们必须考虑字符串数据结构的两个重要方面：字符串的顺序排列和涉及的字母或字符的有限数量。
- en: The Cost of String Comparison
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串比较的代价
- en: So far, we have been ignoring two important pieces of information in our quest
    to search strings. The first is the sequential nature of string comparisons. To
    determine the alphabetical order of strings, we start at the first character in
    a string and sequentially compare characters until we find a difference. That
    one difference then determines the string’s relative order in the search tree—it
    doesn’t matter what the rest of the characters are.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在搜索字符串时忽略了两个重要的信息。第一个是字符串比较的顺序性。为了确定字符串的字母顺序，我们从字符串的第一个字符开始，逐个字符进行比较，直到发现不同之处。这个不同决定了该字符串在搜索树中的相对顺序——其余的字符无关紧要。
- en: 'In the example in [Figure 6-3](#figure6-3), ZOMBIE comes before ZOOM because
    of the characters in the third position: M comes before O. We don’t care about
    the relationship of remaining characters, BIE and M, and can ignore them.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图6-3](#figure6-3)中的例子中，ZOMBIE排在ZOOM之前，因为第三个位置的字符：M排在O之前。我们不关心剩余字符BIE和M的关系，可以忽略它们。
- en: '![A figure showing the comparison of the strings ZOOM and ZOMBIE. The first
    two characters are marked with an equal sign to show they are the same. The third
    is marked with a greater than sign to indicate that O comes after M. The final
    characters are grayed out to indicate they are ignored.](image_fi/502604c06/f06003.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![一张显示字符串 ZOOM 和 ZOMBIE 比较的图。前两个字符用等号标记，表示它们相同。第三个字符用大于号标记，表示 O 在 M 后面。最后的字符被灰色标出，表示它们被忽略。](image_fi/502604c06/f06003.png)'
- en: 'Figure 6-3: The comparison of two strings progresses character by character
    until the first nonmatching pair is found.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-3：两个字符串的比较按字符逐个进行，直到找到第一个不匹配的字符对。
- en: 'As we saw in Chapter 1, the sequential comparison required for strings in binary
    search trees is inherently more expensive than the comparison of two numbers.
    Even comparing the two relatively short strings in [Figure 6-3](#figure6-3) requires
    three separate comparisons: Z versus Z, O versus O, and O versus M. By the time
    we get to longer strings, such as our favorite movie quotes, the cost can become
    significant. The situation becomes even more dire when the strings have a high
    degree of overlap. Imagine a binary search tree that indexes our coffee collection
    by name. If we insert a few hundred coffees under the brand name “Jeremy’s Gourmet
    High Caffeine Experience,” we would need to compare quite a few characters to
    decide whether “Jeremy’s Gourmet High Caffeine Experience: Medium Roast” comes
    before or after “Jeremy’s Gourmet High Caffeine Experience: City Roast.” Our binary
    search tree algorithm pays that cost at each node.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '正如我们在第 1 章中所看到的，二叉搜索树中对字符串进行的逐个比较，天生比数字的比较更为昂贵。即使是比较 [图 6-3](#figure6-3) 中的这两个相对较短的字符串，也需要进行三次独立的比较：Z
    对 Z，O 对 O，以及 O 对 M。当我们比较更长的字符串时，比如我们最喜欢的电影台词，代价可能会变得相当显著。如果字符串有较高的重叠度，情况会更加严重。试想一个按照名字对我们的咖啡系列进行索引的二叉搜索树。如果我们插入几百个名字为“Jeremy’s
    Gourmet High Caffeine Experience”的咖啡，我们就需要比较大量的字符来决定“Jeremy’s Gourmet High Caffeine
    Experience: Medium Roast”应该排在“Jeremy’s Gourmet High Caffeine Experience: City
    Roast”之前还是之后。我们的二叉搜索树算法在每个节点都会支付这笔代价。'
- en: The second key piece of information we haven’t considered as we strive to improve
    search efficiency is that, in many languages, each position can only contain a
    small number of letters. English words use just 26 letters (ignoring capitalization).
    Even if we include numbers and other characters, the set of valid characters is
    limited in practice. This means that, at each position, we have a limited number
    of ways the string can proceed—a limited number of next steps. As we’ll see shortly,
    this insight allows us to define a partitioning function that creates multi-way
    splits over the next character in the string.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在努力提高搜索效率时，还没有考虑到的第二个关键信息是，在许多语言中，每个位置只能包含少量字母。英文单词只使用 26 个字母（忽略大小写）。即便我们包含数字和其他字符，实际中有效字符的集合仍然是有限的。这意味着在每个位置上，字符串可以继续的方式是有限的——即下一个字符的选择是有限的。正如我们将要看到的，这一见解使我们能够定义一个分区函数，从而在字符串的下一个字符上进行多重分割。
- en: We can combine these insights to build a data structure that operates similarly
    to comparing strings in the real world. The resulting data structure, a trie,
    is optimized to account for the additional structure in strings.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这些见解结合起来，构建一个与现实世界中比较字符串的方式类似的数据结构。由此产生的数据结构——字典树，经过优化，能够考虑到字符串中的附加结构。
- en: Tries
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字典树
- en: '*Tries* are tree-based data structures that partition strings along different
    branches based on their prefixes. Computer scientist René de la Briandais proposed
    the general approach behind tries as a method to improve file searching on computers
    with slow memory access, and Edward Fredkin, a computer scientist and physicist,
    proposed their name. Instead of partitioning the data into two sets at each node,
    we branch the tree based on the prefix so far (sequential comparisons). Further,
    we allow the tree to split into more than a measly two branches (limited number
    of characters). In fact, for English words, we can let the tree branch 26 ways
    at each node—one branch for each of the possible next letters. Each node in the
    trie thus represents a prefix so far.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典树*（Tries）是基于树的结构，通过字符串的前缀将其划分为不同的分支。计算机科学家 René de la Briandais 提出了字典树的基本方法，旨在改善在内存访问较慢的计算机上进行文件搜索的效率，而计算机科学家兼物理学家
    Edward Fredkin 则提出了这个名称。与每个节点将数据分成两个集合不同，我们根据目前的前缀将树进行分支（逐步比较）。此外，我们允许树在每个节点分裂成多于两个的分支（字符数限制）。事实上，对于英文单词，我们可以让树在每个节点分成
    26 条分支——每条分支对应可能的下一个字母。因此，字典树中的每个节点都代表当前的前缀。'
- en: Like binary search trees, the trie starts at a root node, in this case representing
    the empty prefix. Each branch then defines the next character in the string. Naturally,
    this means each node can have more than two children, as shown in [Figure 6-4](#figure6-4).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 就像二叉搜索树一样，字典树从根节点开始，在这种情况下表示空前缀。然后，每个分支定义了字符串中的下一个字符。自然，这意味着每个节点可以有超过两个子节点，如[图6-4](#figure6-4)所示。
- en: '![A trie node with branches to child node pointers for strings starting with
    A, B, C, and so forth.](image_fi/502604c06/f06004.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![一个字典树节点，包含指向以A、B、C等字符开头的字符串子节点的指针。](image_fi/502604c06/f06004.png)'
- en: 'Figure 6-4: A trie node branches out on each possible character in the current
    position.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-4：字典树节点在当前位置的每个可能字符上分支。
- en: We can implement the branches of each trie node as using an array of pointers,
    with one array bin for each character. In some cases, we may be able to use representations
    more memory-efficient than arrays within our data structure. After all, even for
    English words, most non-trivial prefixes will have significantly fewer than 26
    valid options for the next letter. For now, however, we will stick with an array
    implementation for simplicity’s sake. The discussions and example implementations
    in this chapter also focus primarily on English words (26 letters and a 26-element
    array of children), though the algorithms apply to other character sets as well.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用指针数组来实现每个字典树节点的分支，每个字符对应一个数组槽。在某些情况下，我们可能能够在数据结构中使用比数组更节省内存的表示方式。毕竟，即使是英语单词，大多数非平凡的前缀也会有明显少于26个有效选项来表示下一个字母。不过，为了简单起见，我们暂时会坚持使用数组实现。本章的讨论和示例实现也主要聚焦于英语单词（26个字母和26个元素的子节点数组），尽管这些算法也适用于其他字符集。
- en: Think of a trie’s branching structure as the registration table of a major event.
    Upon showing up at the world’s premier conference on Coffee Analogies for Computer
    Science, we visit the registration table to get our own personalized packet of
    information and free conference goodie (hopefully a coffee mug). With a huge number
    of participants, the organizers split up the packets into manageable groups so
    as to prevent a single line from snaking around the convention center. Instead
    of creating a series of pairwise splits (such as “Does your last name come before
    or after Smith?”), the organizers divide attendees into 26 different lines according
    to the first letter of their last name. In a single step, the crush of attendees
    shrinks to 26 more manageable lines. A trie performs that spectacular many-way
    branching at every node.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将字典树的分支结构比作一个大型事件的注册表。当我们参加世界顶级的“计算机科学中的咖啡类比”会议时，我们会去注册桌领取个人化的信息包和免费的会议纪念品（希望是咖啡杯）。由于参与人数众多，组织者将信息包分成可管理的小组，以防止队伍绕着会议中心排队。与其通过一系列二元拆分（比如“你的姓氏是在Smith之前还是之后？”），组织者根据姓氏的首字母将参与者分成26条不同的队伍。这样，一下子，众多与会者就被缩小成26条更易管理的队伍。字典树就在每个节点上执行这种壮观的多路分支。
- en: As with a binary search tree, we do not need to create nodes for empty branches
    of the tree. [Figure 6-5](#figure6-5) shows an example of this structure, where
    the shaded letters represent empty branches of the trie. We do not create child
    nodes for those branches. Using the same terminology as for binary search trees,
    we call nodes with at least one child *internal nodes* and nodes without any children
    *leaf node**s*. As a result, although we have the potential to branch 26 times
    at each node (when using only English letters), our trie will be relatively sparse.
    Later nodes may only branch a small number of times.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 与二叉搜索树类似，我们不需要为树的空分支创建节点。[图6-5](#figure6-5)展示了这种结构的一个例子，其中阴影字母代表字典树中的空分支。我们不会为这些分支创建子节点。使用与二叉搜索树相同的术语，我们将至少有一个子节点的节点称为*内部节点*，没有任何子节点的节点称为*叶节点*。因此，尽管每个节点在理论上有可能有最多26个分支（当仅使用英语字母时），我们的字典树将相对稀疏。后续节点可能只会有少数几个分支。
- en: '![The first three levels of a trie. Each node shows possible branches to children
    starting with A, B, or C. Certain characters are grayed out to indicate the absence
    of children in various branches.](image_fi/502604c06/f06005.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![一个字典树的前三个层级。每个节点展示了以A、B或C开始的可能分支。某些字符被灰色显示，表示在不同分支中没有子节点。](image_fi/502604c06/f06005.png)'
- en: 'Figure 6-5: Tries only create nodes for non-empty branches of the tree, allowing
    the data structure to avoid wasting space on unused branches.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-5：字典树只为非空分支创建节点，从而避免在未使用的分支上浪费空间。
- en: Unlike in binary search trees, not every node in a trie represents a valid entry.
    While every leaf node is a valid entry, some internal nodes might be prefixes
    along the route to a full string. For example, a trie containing the string COFFEE
    would include an intermediate node representing the prefix COFFE. Although this
    is the spelling the author often uses when he’s consumed too much coffee, it is
    not actually a valid word or entry. We don’t want our data structure to imply
    that COFFE is acceptable just because there is a node corresponding to that prefix.
    At other points, however, an internal node might be a completely valid entry.
    If a trie contains the strings CAT and CATALOG, the node for CAT will be internal,
    because it has at least one child that lies along the path to the node for CATALOG.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 与二叉搜索树不同，前缀树中的并非每个节点都代表有效条目。虽然每个叶子节点都是有效条目，但一些内部节点可能只是通往完整字符串的前缀。例如，一个包含字符串
    COFFEE 的前缀树将包含一个表示前缀 COFFE 的中间节点。尽管这是作者在喝了太多咖啡后常常使用的拼写方式，但它实际上不是一个有效的单词或条目。我们不希望我们的数据结构仅仅因为有一个对应该前缀的节点，就暗示
    COFFE 是有效的。然而，在某些情况下，内部节点可能是完全有效的条目。如果一个前缀树包含字符串 CAT 和 CATALOG，那么 CAT 的节点将是内部节点，因为它至少有一个子节点，位于到
    CATALOG 节点的路径上。
- en: 'To resolve this ambiguity, we store within the trie node an indicator of whether
    the current prefix represents a valid entry. This could be as simple as a Boolean
    `is_entry` that is `True` for any node corresponding to a valid entry and `False`
    otherwise:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个歧义，我们在前缀树节点中存储一个指示符，表示当前前缀是否代表有效条目。这可以简单地是一个布尔值 `is_entry`，如果对应有效条目的节点为
    `True`，否则为 `False`：
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this example, the node for COFFE would have `is_entry = False`, while the
    node for COFFEE would have `is_entry = True`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，COFFE 的节点会有 `is_entry = False`，而 COFFEE 的节点会有 `is_entry = True`。
- en: Alternately, we could store something more useful in the trie node, such as
    the count of how many times a given entry has been inserted. Or, if we are tracking
    auxiliary data for each entry, such as a word’s definition or a list of hysterical
    puns, we could use the existence of this data as an indicator itself. Prefixes
    that do not represent valid entries can point to `null` or empty data structures.
    It may seem harsh, but only real words qualify for our best puns.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以在前缀树节点中存储一些更有用的信息，例如某个条目被插入的次数。或者，如果我们正在跟踪每个条目的辅助数据，例如单词的定义或一系列滑稽的双关语，我们可以使用这些数据的存在作为一个指示符。那些不代表有效条目的前缀可以指向
    `null` 或空的数据结构。这看起来可能有些苛刻，但只有真正的单词才能成为我们最好的双关语。
- en: 'As with the binary search tree, we can clean up the trie’s interface by wrapping
    the root node in a trie object:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 和二叉搜索树一样，我们可以通过将根节点包装在一个前缀树对象中，来清理前缀树的接口：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Unlike the binary search tree, our trie always has a (non-null) root. We create
    this root at the same time we create the trie data structure itself. Even for
    completely empty tries, we allocate a root node (with `is_entry = False`) that
    indicates the start of the string. Not only will the `Trie` data structure wrap
    the root node into a convenient container, but it will allow us to hide some additional
    bookkeeping needed for various operations.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 与二叉搜索树不同，我们的前缀树总是有一个（非空的）根节点。我们在创建前缀树数据结构时同时创建这个根节点。即使是完全空的前缀树，我们也会分配一个根节点（`is_entry
    = False`），表示字符串的开始。`Trie` 数据结构不仅将根节点包装在一个方便的容器中，还允许我们隐藏一些操作中需要的额外记账信息。
- en: One useful physical analogy for tries is an ultimate real-world filing system.
    Imagine a building that acts as storage system for detailed files on every topic
    in the world—a monument to efficient filing schemes. We partition the topics based
    on their first letter, like books of an encyclopedia, so our building has 26 stories.
    We reserve each floor of the building for each first letter, so the floors provide
    our first-level split. We then pack each floor with 26 rooms, one for each second
    letter of the topic. Each room would contain 26 filing cabinets that split for
    the third letter; each cabinet has 26 drawers (fourth letter), and 26 sections
    per drawer (fifth letter), and so on. At each level we are grouping together entries
    by their common prefixes. As long as we have high-speed elevators, we can find
    any topic relatively easily.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有用的字典树类比是终极现实世界的文件系统。想象一个建筑，作为存储世界上每个话题详细文件的系统——高效文件存储方案的纪念碑。我们根据话题的第一个字母对其进行划分，就像百科全书的书籍一样，因此我们的建筑有26层楼。我们为每个字母保留一个楼层，这些楼层提供了我们第一层次的划分。然后，我们将每一层填充26个房间，每个房间代表话题的第二个字母。每个房间里会有26个文件柜，用来划分第三个字母；每个文件柜有26个抽屉（第四个字母），每个抽屉有26个分区（第五个字母），依此类推。在每一层，我们通过共同的前缀将条目分组。只要我们有高速电梯，就可以相对轻松地找到任何话题。
- en: Searching Tries
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 搜索字典树
- en: Searching tries is similar to searching binary search trees, in that we start
    at the top of the tree at the root node and progress downward, choosing branches
    that lead to the search target. In the case of a trie, however, we choose the
    branch that corresponds to the next letter in the string. We don’t need to compare
    full strings, or even the beginning of the prefix. That was done at previous nodes.
    We only need to consider the next character—a single comparison at each level.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索字典树类似于搜索二叉查找树，因为我们从树的顶部根节点开始，向下移动，选择通向搜索目标的分支。然而，在字典树的情况下，我们选择与字符串中下一个字母对应的分支。我们不需要比较完整的字符串，甚至不需要比较前缀的开始部分。这些都已经在之前的节点中完成。我们只需要考虑下一个字符——每一层只进行一次比较。
- en: Returning to the filing building analogy, imagine searching for information
    on your favorite author. After arriving at the floor K, you face 26 rooms labeled
    A through Z that represent the prefixes KA through KZ. Your next step depends
    only on the second letter of the author’s name. You do not need to waste time
    even considering the first letter again—that was already done on the elevator.
    Every room on this floor starts with K. You confidently head toward the room labeled
    U.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 回到文件建筑类比，假设你正在搜索你最喜欢的作者的信息。在到达K楼后，你会面对26个标有A到Z的房间，它们代表了从KA到KZ的前缀。你下一步的行动只取决于作者名字的第二个字母。你不需要再浪费时间考虑第一个字母——那已经在电梯里完成了。这个楼层上的每个房间都以K开头，你自信地走向标有U的房间。
- en: One complication with implementing this approach in code is that the comparisons
    we perform change at each level of the search. At the first level, we check the
    first character for a match—but at the second level, we need to check the second
    character. Our search no longer compares the entire target against the value at
    the node. We need additional information, the placement of the character that
    we are checking for at this level. We can track this additional state by passing
    the index to check into our recursive search function and incrementing it with
    each level of recursion.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法实现代码的一种复杂性是，我们在每一层的搜索中所做的比较都会发生变化。在第一层，我们检查第一个字符是否匹配——但在第二层，我们需要检查第二个字符。我们的搜索不再将整个目标与节点中的值进行比较。我们需要额外的信息，就是在这一层我们要检查的字符的位置。我们可以通过将要检查的索引传递给递归搜索函数，并在每次递归时递增它，来跟踪这个额外的状态。
- en: 'The trie wrapper allows us to hide both the reference to the root node and
    the initial counter required by the recursive function, simplifying the code seen
    by the trie’s users:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 字典树包装器使我们能够隐藏对根节点的引用和递归函数所需的初始计数器，从而简化字典树用户看到的代码：
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This wrapper guarantees that subsequent search function is called with a non-null
    node and the correct initial index.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这个包装器保证后续的搜索函数会在一个非空节点和正确的初始索引下被调用。
- en: 'The code for recursively searching a trie is a bit more complex than the code
    for searching a binary search tree, because we must deal with target values of
    different lengths:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 递归搜索字典树的代码比搜索二叉查找树的代码稍微复杂一些，因为我们必须处理不同长度的目标值：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This code starts by checking the length of the target string against the current
    depth in order to determine whether the target should be located at this level
    ❶. If the index is equal to the length of the string (and thus one *past* the
    last character in the string), the code then checks whether the current node is
    itself a valid entry. This check is particularly necessary when the search terminates
    at an internal node, since we need to confirm that this node represents a valid
    entry in its own right, not just the prefix of another entry.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码首先通过检查目标字符串的长度与当前深度，来确定目标是否应该位于此层级❶。如果索引等于字符串的长度（即超过字符串的最后一个字符），代码会检查当前节点是否是有效条目。这一步检查在搜索终止于内部节点时尤其必要，因为我们需要确认该节点本身是有效条目，而不仅仅是另一个条目的前缀。
- en: If the code has not reached the end of the target string, it continues the search
    by examining the next character in our target ❷. We can define a helper function
    to map the character to the correct index in the array ❸. The code then checks
    whether the corresponding child exists ❹. If there isn’t a corresponding child,
    the code returns `null`, confident that `target` is not in the trie. If there
    is a corresponding child, the code follows that branch.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码还没有到达目标字符串的末尾，它会通过检查目标❷中的下一个字符继续搜索。我们可以定义一个辅助函数，将字符映射到数组中的正确索引❸。然后，代码检查是否存在相应的子节点❹。如果没有对应的子节点，代码返回`null`，确定`target`不在字典树中。如果有对应的子节点，代码会沿着那个分支继续搜索。
- en: For an example of this search procedure, consider a trie of exclamations like
    YIKES and ZOUNDS from a recent episode of our favorite Saturday morning cartoon,
    as in [Figure 6-6](#figure6-6). We can record auxiliary data such as the frequency
    of the word and who said it, allowing us to correct people’s references at parties.
    After all, what’s the use of data structures if they don’t help us win pedantic
    arguments?
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以最近一集我们最喜欢的周六早晨动画片中的感叹词YIKES和ZOUNDS为例，如[图6-6](#figure6-6)所示，我们可以记录一些辅助数据，比如单词的出现频率和是谁说的，这样我们就可以在聚会上纠正人们的引用。毕竟，如果数据结构不能帮助我们在学究式的争论中获胜，那它还有什么用呢？
- en: '![A trie that includes the strings EGADS, YIKES, YIP, YIPPEE, ZONK, and ZOUNDS.](image_fi/502604c06/f06006.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![包含字符串EGADS、YIKES、YIP、YIPPEE、ZONK和ZOUNDS的字典树。](image_fi/502604c06/f06006.png)'
- en: 'Figure 6-6: A trie constructed from cartoon phrases'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-6：由漫画短语构建的字典树
- en: To check whether this week’s episode contained our all-time favorite cartoon
    word, ZONK, we can simply search the trie. We start at the top of the trie and
    take the corresponding branches for each character, as shown in [Figure 6-7](#figure6-7).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查本周的剧集是否包含我们最喜欢的漫画词汇ZONK，我们可以简单地搜索字典树。我们从字典树的顶部开始，并根据每个字符选择相应的分支，如[图6-7](#figure6-7)所示。
- en: '![The trie from Figure 6‐6 with the following nodes highlighted: root, Z, ZO,
    ZON, and ZONK. The highlighted nodes show the path from the root to the node containing
    ZONK.](image_fi/502604c06/f06007.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图6-6中的字典树，以下节点被高亮显示：根节点、Z、ZO、ZON和ZONK。高亮节点显示了从根节点到包含ZONK节点的路径。](image_fi/502604c06/f06007.png)'
- en: 'Figure 6-7: A search of the trie of cartoon phrases for ZONK. The shaded nodes
    indicate the path taken during the search.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-7：对漫画短语的字典树进行ZONK搜索。阴影节点表示搜索过程中经过的路径。
- en: Since tries include only nodes that have data, we can determine whether a string
    is not in the trie by watching for dead ends. For example, we know ZIPPY did not
    occur in the episode because we hit a dead end after the prefix Z. There is no
    branch for the prefix ZI. If some know-it-all proclaims that their favorite line
    contained the exclamation ZIPPY, we can prove them wrong with a simple search.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 由于字典树只包含具有数据的节点，我们可以通过观察死胡同来判断一个字符串是否不在字典树中。例如，我们知道ZIPPY没有出现在这集里，因为在前缀Z之后我们遇到了死胡同。前缀ZI没有分支。如果有些自以为是的人宣称他们最喜欢的台词包含了感叹词ZIPPY，我们可以通过简单的搜索来证明他们错了。
- en: At first glance, it may appear that adding a large number of internal nodes
    increases the cost of searching. However, this new structure actually improves
    our search enormously. At each character in our target string, we perform a single
    lookup in the current node, checking for an existing child for that character,
    then proceed to the appropriate child node; thus, the number of lookups and comparisons
    scales with the length of our target string. Unlike a binary search tree, the
    number of comparisons for a successful trie search is independent of the number
    of strings stored in the trie. We could fill the trie with an entire dictionary
    and still only need to visit six nodes to check for the string EGADS.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，似乎添加大量内部节点会增加搜索的成本。然而，这种新结构实际上大大提高了我们的搜索效率。在目标字符串的每个字符位置，我们在当前节点进行一次查找，检查该字符是否有现有的子节点，然后继续访问相应的子节点；因此，查找次数和比较次数随着目标字符串的长度增长。与二叉搜索树不同，成功的trie搜索所需的比较次数与trie中存储的字符串数量无关。即使我们将整个字典填充进trie，仍然只需要访问六个节点来检查字符串EGADS。
- en: Of course, as with everything in computer science, this efficiency does not
    come for free. We pay a significant cost in memory usage. Instead of storing one
    node for each string and pointers to two children, we now store one node for each
    character in the string and a large number of pointers to potential children.
    Overlapping prefixes help reduce the memory cost per string. If multiple entries
    share the same prefix, such as ZO for ZOUNDS and ZONK in [Figure 6-6](#figure6-6),
    those entries share nodes for those initial overlapping characters.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，像计算机科学中的一切一样，这种效率并非免费的。我们付出了显著的内存开销。我们不再为每个字符串存储一个节点及指向两个子节点的指针，而是为字符串中的每个字符存储一个节点，并存储大量指向潜在子节点的指针。重叠的前缀有助于降低每个字符串的内存开销。如果多个条目共享相同的前缀，例如ZO对于ZOUNDS和ZONK（见[图6-6](#figure6-6)），这些条目将共享这些初始重叠字符的节点。
- en: Adding and Removing Nodes
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加和删除节点
- en: Like binary search trees, tries are dynamic data structures that adapt as we
    add or remove nodes, allowing them to accurately represent the data as it changes.
    Adding a string to a trie works much like adding data to a binary search tree.
    We progress down the tree as though searching for the string. Once we hit a dead
    end, we can create a subtree below that node to capture the remaining characters
    in that string. Unlike insertions in binary search trees, we may add multiple
    new internal nodes while inserting a single entry.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 与二叉搜索树类似，trie是一种动态数据结构，当我们添加或删除节点时，它会根据数据的变化进行适应，从而准确地表示数据的变化。将一个字符串添加到trie的方式类似于将数据添加到二叉搜索树。我们沿着树往下走，就像是在搜索这个字符串一样。一旦我们遇到死胡同，就可以在该节点下创建一个子树，以捕捉该字符串中剩余的字符。与二叉搜索树的插入不同，在插入单个条目时，我们可能会添加多个新的内部节点。
- en: 'The top-level `Trie` function sets up the insertion by calling the recursive
    search function with the (non-null) root node and the correct initial depth:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 顶层的`Trie`函数通过调用递归的搜索函数，传入（非空）根节点和正确的初始深度来设置插入操作：
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We don’t need to treat the creation of the root node as a special case, as we
    allocate an initial root node during the creation of the trie itself.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要将根节点的创建当作特例来处理，因为在创建trie本身时我们会分配一个初始的根节点。
- en: 'The code for insertion is similar to that of the search function:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 插入的代码与搜索功能的代码类似：
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This code starts by checking the current position against the length of the
    inserted string ❶. When it has hit the end of the string, it marks the current
    node as a valid entry. Depending on the use case, the code might also need to
    update the node’s auxiliary data. Where the code has not yet hit the end of the
    string, it looks up the next character and checks whether the corresponding child
    exists ❷. If not, the code creates a new child node. Then it recursively proceeds
    to call `TrieNodeInsert` on the correct child node (❸ or ❹).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码首先通过检查当前的位置与插入字符串的长度进行比较 ❶。当到达字符串的末尾时，它会将当前节点标记为有效条目。根据使用情况，代码可能还需要更新节点的辅助数据。若代码还未到达字符串末尾，它会查找下一个字符并检查是否存在相应的子节点
    ❷。如果没有，代码将创建一个新的子节点。然后，它会递归调用`TrieNodeInsert`函数，传入正确的子节点（❸或❹）。
- en: 'For example, if we wanted to add the string EEK to our list of cartoon exclamations,
    we would add two nodes: an internal node for the prefix EE and a leaf node for
    the full string EEK. [Figure 6-8](#figure6-8) illustrates this addition, with
    shaded nodes indicating the trie nodes created during the insertion.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想将字符串 EEK 添加到我们的卡通感叹词列表中，我们将添加两个节点：一个表示前缀 EE 的内部节点，以及一个表示完整字符串 EEK 的叶子节点。[图6-8](#figure6-8)展示了这个添加过程，带阴影的节点表示在插入过程中创建的字典树节点。
- en: 'Removing nodes follows a similar process, but in reverse: starting at the node
    for the final character, we progress up the tree, deleting nodes that we no longer
    need. We stop deleting nodes once we hit an internal node that either has at least
    one non-empty child branch, thus representing a valid prefix for other strings
    in the trie, or is itself a string stored in the tree and thus represents a valid
    leaf node in its own right.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 删除节点遵循类似的过程，但相反：从最终字符的节点开始，我们向上遍历树，删除不再需要的节点。我们停止删除节点，直到遇到一个内部节点，该节点要么至少有一个非空的子分支，从而代表字典树中其他字符串的有效前缀，要么它本身是树中存储的字符串，因此代表一个有效的叶子节点。
- en: 'As with search and insertion, we start with the wrapper code that starts the
    deletion at the root node and with the correct index:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 与搜索和插入一样，我们从封装代码开始，首先从根节点开始删除操作，并使用正确的索引：
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The function does not return a value.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数不返回任何值。
- en: The code for removing nodes builds on the code for search and insertion, initially
    walking down the tree until it reaches the entry to delete. As it returns back
    up the trie, additional logic prunes empty branches. The code returns a Boolean
    value indicating whether or not the current node can safely be deleted, allowing
    the parent node to prune the branch.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 删除节点的代码基于搜索和插入的代码，最初沿着树向下遍历，直到找到要删除的入口。当代码返回到字典树时，附加逻辑会修剪空分支。代码返回一个布尔值，指示当前节点是否可以安全删除，从而允许父节点修剪该分支。
- en: '![The trie from Figure 6‐6 with nodes added to store the strings EE and EEK.
    The additional nodes are in a branch below the node for the prefix E.](image_fi/502604c06/f06008.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图6-6中的字典树，添加了节点来存储字符串 EE 和 EEK。新增的节点位于前缀 E 的节点下方的分支中。](image_fi/502604c06/f06008.png)'
- en: 'Figure 6-8: The addition of EEK to the trie of cartoon phrases. The new nodes
    are shaded.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-8：将EEK添加到卡通短语的字典树中。新的节点以阴影显示。
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This code starts by comparing the length of the deleted string to the current
    level and changing the value of `is_entry` if the current node is being removed
    ❶. Otherwise, the algorithm recursively progresses down the tree, using the same
    logic as both our search and insertion functions ❷. It looks up the next character,
    finds the corresponding node, checks whether the node exists, and, if so, recursively
    descends to that node. If the node doesn’t exist, the target string is not in
    the trie, and the code will not continue downward. The code then deletes empty
    branches from the parent node. Each `TrieNodeDelete` call returns a Boolean to
    indicate whether it is safe to delete the corresponding node. If `TrieNodeDelete`
    returns `True`, then the parent immediately deletes the child node ❸.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码首先比较被删除字符串的长度与当前层级，如果当前节点正在被删除，则改变`is_entry`的值 ❶。否则，算法将递归地沿着树向下遍历，使用与搜索和插入功能相同的逻辑
    ❷。它查找下一个字符，找到对应的节点，检查该节点是否存在，如果存在，则递归下降到该节点。如果节点不存在，目标字符串不在字典树中，代码将停止向下继续。然后，代码会从父节点删除空分支。每次调用`TrieNodeDelete`都会返回一个布尔值，表示是否可以安全地删除对应的节点。如果`TrieNodeDelete`返回`True`，父节点将立即删除子节点
    ❸。
- en: The function ends with logic to determine whether it is safe for the parent
    to delete the current node. It returns `False` if `is_entry == True` ❹, indicating
    a valid entry, or if the current node has at least one non-null child ❺. It performs
    this last check using a `FOR` loop to iterate through each child and check whether
    it is `null`. If any child is not `null`, the code immediately returns `False`
    because it is a necessary internal node. Note that the code returns `False` in
    cases where the target string is not in the trie, because the code never sets
    `is_entry` to `False` for any node and thus there are no new pruning opportunities.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数以逻辑判断是否允许父节点删除当前节点作为结束。如果`is_entry == True` ❹，即表示是有效的入口，或者当前节点至少有一个非空的子节点
    ❺，它将返回`False`。它通过`FOR`循环遍历每个子节点，并检查是否为`null`来进行最后的检查。如果任何一个子节点不是`null`，代码将立即返回`False`，因为该节点是一个必要的内部节点。需要注意的是，如果目标字符串不在字典树中，代码会返回`False`，因为代码从不将任何节点的`is_entry`设置为`False`，因此没有新的修剪机会。
- en: Consider removing the string YIPPEE from our example trie. If the trie also
    contains the word YIP as an entry, we’d delete all nodes following the one for
    YIP as shown in [Figure 6-9](#figure6-9). The node for YIPPEE itself is marked
    safe to delete because it is a leaf and `is_entry` was marked `False` as part
    of the deletion. When the function returns to the node for YIPPE, it immediately
    deletes its only child (branch E). The node for YIPPE is now a leaf with `is_entry
    == False` and can be deleted by its parent. The process continues up the tree
    until we hit the node for YIP, which has `is_entry == True`, because the string
    YIP is in the trie.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑从我们示例中的 trie 中删除字符串 YIPPEE。如果 trie 中也包含单词 YIP 作为条目，我们将删除从 YIP 节点开始的所有后续节点，如[图
    6-9](#figure6-9)所示。YIPPEE 节点本身被标记为可以删除，因为它是一个叶子节点，并且 `is_entry` 已标记为 `False` 作为删除的一部分。当函数返回到
    YIP 节点时，它立即删除其唯一的子节点（分支 E）。YIP 节点现在是一个叶子节点，`is_entry == False`，并可以被其父节点删除。这个过程继续向上树结构进行，直到遇到
    YIP 节点，该节点的 `is_entry == True`，因为字符串 YIP 存在于 trie 中。
- en: Since deletion requires making a round trip from the root to a single leaf,
    the cost is again proportional to the length of the target string. As with search
    and insertion, cost is independent of the overall numbers of strings stored in
    the trie.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 由于删除需要从根节点到达单个叶子节点的往返，成本再次与目标字符串的长度成正比。与搜索和插入一样，成本与 trie 中存储的字符串总数无关。
- en: '![The Trie from Figure 6‐8 with the nodes YIPP, YIPPE, and YIPPEE marked with
    grayed‐out, dashed lines to indicate their deletion.](image_fi/502604c06/f06009.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图 6-8 中的 Trie，节点 YIPP、YIPPE 和 YIPPEE 被灰色虚线标记，以表示它们将被删除。](image_fi/502604c06/f06009.png)'
- en: 'Figure 6-9: Deletion of the string YIPPEE from the trie of cartoon phrases
    that also contains the string YIP. The deleted nodes have dashed lines and are
    grayed out.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-9：从包含字符串 YIP 的卡通短语的 trie 中删除字符串 YIPPEE。被删除的节点有虚线标记并被灰色显示。
- en: Why This Matters
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么这很重要
- en: 'We can now see how tries solve the problem with binary search trees that we
    posed earlier on: the cost of their search depends on both the number and length
    of words. In the brief examples in this chapter, tries do not provide much of
    an advantage. In fact, the overhead from additional branches may make them less
    efficient than binary search trees or sorted lists. However, tries become more
    and more cost-effective as we add more and more strings and the number of strings
    with similar prefixes increases. There are two reasons for this: first, the cost
    of a lookup in a trie scales independent of the number of entries, and second,
    string comparisons themselves can be expensive. In a binary search tree, these
    two factors compound, as we pay the cost of comparing two strings at each of the
    nodes.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以看到 trie 如何解决我们之前提出的二叉搜索树的问题：它们的搜索成本取决于单词的数量和长度。在本章的简短示例中，trie 并没有提供太多的优势。实际上，额外的分支所带来的开销可能使它们比二叉搜索树或排序列表效率更低。然而，随着我们添加越来越多的字符串，并且具有相似前缀的字符串数量增加，trie
    的成本效益会越来越高。原因有两个：首先，trie 中的查找成本与条目的数量无关，第二，字符串比较本身可能是昂贵的。在二叉搜索树中，这两个因素是复合的，因为我们在每个节点上都需要进行字符串比较。
- en: In the real world, for example, we might use a trie inside a word processor
    to track the words in a dictionary. Auxiliary data at each node might include
    the definition or common misspellings. As the user types and edits, the program
    can efficiently check whether each word is in the dictionary and highlight it
    if otherwise. This program greatly benefits from the shared prefixes and limited
    number of characters in a natural language.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，例如，我们可能会在文字处理器中使用 trie 来跟踪字典中的单词。每个节点的辅助数据可能包括单词的定义或常见的拼写错误。当用户输入和编辑时，程序可以高效地检查每个单词是否在字典中，并在其不在字典时进行高亮显示。这个程序极大地受益于自然语言中共享的前缀和有限的字符数。
- en: If we are composing an in-depth essay on the history of encyclopedias, for example,
    we do not want to pay excessive cost comparing *encyclopedia* to the neighboring
    words *encyclopedias*, *encyclopedic*, *encyclopedist*, and so forth. Remember
    that, as shown in [Figure 6-10](#figure6-10), the algorithm to compare the alphabetical
    ordering of two strings consists of iterating over those strings, comparing each
    character. Although the program stops once it finds a differing character, the
    cost of comparing similar prefixes adds up. Within an active word processor document,
    we might need to modify the set of words constantly. Each insertion or edit will
    require a lookup in our data structure.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们正在撰写一篇关于百科全书历史的深入文章，我们不希望在比较*encyclopedia*与相邻词汇*encyclopedias*、*encyclopedic*、*encyclopedist*等时支付过高的成本。请记住，如[图
    6-10](#figure6-10)所示，比较两个字符串字母顺序的算法是通过遍历这两个字符串，比较每个字符。尽管程序在找到不同字符时会停止，但比较相似前缀的成本会累积。在一个活跃的文字处理器文档中，我们可能需要不断修改词汇集。每次插入或编辑都需要在我们的数据结构中进行查找。
- en: '![A string comparison between the words encyclopedic and encyclopedias. The
    first 11 characters are marked as equal.](image_fi/502604c06/f06010.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![词汇“encyclopedic”和“encyclopedias”之间的字符串比较。前11个字符标记为相等。](image_fi/502604c06/f06010.png)'
- en: 'Figure 6-10: An example of an expensive string comparison'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-10：一个昂贵的字符串比较示例
- en: An even better use for a trie might be a data structure that tracks structured
    labels—such as serial numbers, model numbers, or SKU codes—that are often formatted
    as short alphanumeric strings. For example, we could create a simple trie to store
    product registration information indexed by serial number. Even allowing for billions
    of products sold, the cost of all operations scales linearly with the length of
    the serial number. If our serial numbers contain structure, such as a prefix representing
    the device’s model, we can realize further savings by limiting the branching factor
    at initial nodes (since many strings will use the same prefix). Auxiliary data
    could include information about where or when the device was purchased.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对于trie的一个更好的用途，可能是跟踪结构化标签的数据结构——例如序列号、型号或SKU代码——这些通常格式化为简短的字母数字字符串。例如，我们可以创建一个简单的trie来存储按序列号索引的产品注册信息。即使销售了数十亿个产品，所有操作的成本也会随着序列号的长度线性增长。如果我们的序列号包含结构信息，例如代表设备型号的前缀，我们可以通过限制初始节点的分支因子来进一步节省开销（因为许多字符串将使用相同的前缀）。辅助数据可以包括关于设备购买地点或时间的信息。
- en: 'More importantly than any particular application, tries demonstrate how we
    can use further structure within the data to optimize the cost of operations.
    We adapted the branching structure of binary search trees to use the sequential
    nature of strings. This improvement once again illustrates a core theme of this
    book: we can often use the structure inherent in data to improve algorithmic efficiency.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 比任何具体应用更重要的是，tries演示了如何利用数据中的进一步结构来优化操作成本。我们将二叉搜索树的分支结构与字符串的顺序特性结合起来。这一改进再次展示了本书的核心主题：我们通常可以利用数据固有的结构来提高算法效率。
