- en: '**10'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**10'
- en: FLOW CONTROL**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 流程控制**
- en: '![image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common.jpg)'
- en: So far, we’ve been focusing on the components of programs, such as expressions,
    variables, and data types. We’ve strung a few of these together into simple executable
    instructions, but these have been mostly linear in nature; in other words, they
    were executed in the order in which they were written. More complex programs will
    include branching instructions that skip whole sections of code, jump back to
    the beginning, or decide among multiple options. To handle these situations, you’ll
    need a way to control the flow of your code.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在关注程序的组件，例如表达式、变量和数据类型。我们将这些组件组合成简单的可执行指令，但这些指令大多是线性的；换句话说，它们按编写的顺序依次执行。更复杂的程序会包括分支指令，这些指令可以跳过整个代码块，跳回到开头，或在多个选项中做出选择。为了处理这些情况，你需要一种控制代码流程的方法。
- en: The *flow of execution* refers to the order in which statements are run in a
    program. Execution starts at the top of the code, with the first statement, after
    which point the statements are read in order. But this order doesn’t have to be
    from top to bottom. In fact, the flow in most programs changes directions like
    cars in a busy intersection.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*执行流程* 指的是程序中语句执行的顺序。执行从代码的顶部开始，首先执行第一条语句，之后按照顺序依次执行剩余的语句。但这个顺序不一定是从上到下的。事实上，大多数程序的流程像繁忙交叉路口的车辆一样会改变方向。'
- en: '*Flow control statements* give Python the ability to make decisions about which
    instructions to execute next. You can think of these statements as the diamond
    shapes in flowcharts that indicate a decision is required to move forward ([Figure
    10-1](ch10.xhtml#ch010fig1)).'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*流程控制语句* 赋予 Python 做出决定的能力，以决定接下来执行哪些指令。你可以将这些语句看作流程图中的菱形，表示需要做出决策才能继续前进（见
    [图 10-1](ch10.xhtml#ch010fig1)）。'
- en: '![Image](../images/10fig01.jpg)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/10fig01.jpg)'
- en: '*Figure 10-1: The diamond shape represents a decision in a flowchart.*'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-1：菱形表示流程图中的决策。*'
- en: This flowchart evaluates whether the `number` variable is greater than or equal
    to `3`. The resulting decision causes the code to choose one path or another,
    a process called *branching*.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这个流程图评估 `number` 变量是否大于或等于 `3`。根据评估结果，代码会选择一条路径或另一条路径，这一过程称为 *分支*。
- en: In this chapter, we’ll discuss the `if`, `else`, `elif`, `while`, `for`, `break`,
    and `continue` flow control statements and clauses. We’ll also look at ways to
    monitor the execution of flow and handle any exceptions that might occur.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论 `if`、`else`、`elif`、`while`、`for`、`break` 和 `continue` 流程控制语句和子句。我们还将探讨如何监控流程的执行并处理可能发生的任何异常。
- en: '**The if Statement**'
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**if 语句**'
- en: The `if` statement is a conditional, or relational, statement. All control statements,
    including `if` statements, end with a colon (`:`) and are followed by an indented
    block of code. This indented clause executes only if the `if` statement’s condition
    is `True`. Otherwise, the clause is skipped.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`if` 语句是一种条件语句或关系语句。所有控制语句，包括 `if` 语句，都以冒号（`:`）结束，并紧随其后的是一个缩进的代码块。只有当 `if`
    语句的条件为 `True` 时，这个缩进的代码块才会执行。否则，该代码块会被跳过。'
- en: 'For example, this snippet checks whether 42 is less than 2\. Only if the condition
    tests `True` will it print a message:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这段代码检查 42 是否小于 2。只有当条件为 `True` 时，它才会打印消息：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: All `if` statements must express a *condition*, which is an expression that
    is either true or false. This example used a comparison operator (`<`) to express
    a condition. Another option is to use Boolean values (covered in [Chapter 8](ch08.xhtml)).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的 `if` 语句必须表达一个 *条件*，即一个结果为真或假的表达式。这个例子使用了比较运算符（`<`）来表达条件。另一个选项是使用布尔值（在 [第
    8 章](ch08.xhtml) 中讨论）。
- en: If you run this code, you should notice that nothing happens. This is because
    the statement evaluated to `False`. That’s okay, but in most cases, you’ll want
    to explicitly handle `False` outcomes, if only to make it clear that there’s no
    missing code.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这段代码，你应该会注意到没有任何变化。这是因为该语句的结果是 `False`。没关系，但在大多数情况下，你会希望显式地处理 `False` 的结果，至少为了明确表示没有遗漏的代码。
- en: 'You can do that by adding an `else` clause, which executes if the `if` statement
    does not. The diamond in [Figure 10-1](ch10.xhtml#ch010fig1) represents an `if-else`
    statement that works as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过添加 `else` 子句来实现这一点，它会在 `if` 语句未执行时执行。图 [10-1](ch10.xhtml#ch010fig1) 中的菱形表示一个
    `if-else` 语句，其工作原理如下：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `else` clause represents the `False` branch in [Figure 10-1](ch10.xhtml#ch010fig1).
    If the condition in the `if` statement is not met, it prints the string `′``Out
    of range.``′`
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`else`子句表示[图 10-1](ch10.xhtml#ch010fig1)中的`False`分支。如果`if`语句中的条件未满足，它将打印字符串`′``Out
    of range.``′`'
- en: '***Working with Code Blocks***'
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***处理代码块***'
- en: Lines of code immediately underneath `if` statements and `else` clauses are
    indented. Indenting code tells the Python interpreter that a group of statements
    belongs to a specific *block* of code. These blocks execute as a single unit and
    end when the indentation level decreases back to zero or to the same level as
    a containing block.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 紧接在`if`语句和`else`子句之后的代码行会进行缩进。缩进代码是为了告诉 Python 解释器，这一组语句属于特定的*代码块*。这些代码块作为一个单元执行，直到缩进级别减少回零或回到与包含块相同的级别时结束。
- en: Most programming languages make use of specific syntax to structure their code,
    such as braces (`{}`) for marking blocks, and semicolons (`;`) for ending lines.
    Python uses whitespace, because it is easier to understand visually, as demonstrated
    in [Figure 10-2](ch10.xhtml#ch010fig2), which diagrams the previous `if` statement.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程语言使用特定的语法来构造代码，例如使用大括号（`{}`）来标记代码块，使用分号（`;`）来结束语句行。Python 使用空白字符，因为这样在视觉上更容易理解，如[图
    10-2](ch10.xhtml#ch010fig2)所示，展示了前面提到的`if`语句。
- en: '![Image](../images/10fig02.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/10fig02.jpg)'
- en: '*Figure 10-2: Example code blocks*'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-2：示例代码块*'
- en: The colon at the end of the first line lets Python know that a new code block
    is coming up. Each line in this block must be indented by the same amount. In
    the figure, Block 1 is the code that runs if the `if` statement’s condition is
    `True`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行末尾的冒号告诉 Python 接下来会有一个新的代码块。此代码块中的每一行都必须进行相同的缩进。在该图中，代码块1是当`if`语句条件为`True`时执行的代码。
- en: The following `else` clause returns to the previous indentation level. The colon
    after `else` denotes the start of another block (the block that runs if the `if`
    statement’s condition is `False`, or Block 2), and this, too, must be indented.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以下的`else`子句返回到先前的缩进级别。`else`后面的冒号表示另一个代码块的开始（即`if`语句条件为`False`时执行的代码块，或称为代码块2），这个代码块也必须进行缩进。
- en: 'We’ve been dealing with a single level of indentation, but blocks can contain
    more deeply indented, or *nested*, blocks. In the following example, each input
    line after line `In [7]` represents a new block of code:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前处理的是单级缩进，但代码块中也可以包含更深层次的缩进，或者称为*嵌套*代码块。在下面的示例中，每个`In [7]`之后的输入行表示一个新的代码块：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you make a mistake indenting code, don’t worry, Python will let you know.
    Depending on where the mistake occurred (such as outside or inside a function),
    it will raise either a `SyntaxError` or an `IndentationError`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在缩进代码时犯了错误，不用担心，Python 会提示你。根据错误发生的位置（例如，在函数外部或内部），Python 会抛出`SyntaxError`或`IndentationError`。
- en: '**NOTE**'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*According to the PEP8 Style Guide ([https://pep8.org/#indentation/](https://pep8.org/#indentation/)),
    you should use four spaces per indentation level, and spaces are preferred to
    using tabs. By default, the Spyder text editor converts a tab into four spaces,
    so you can reduce your repetitive strain injury exposure. You can find this option
    under Tools *▸* Preferences *▸* Editor *▸* Source Code *▸* Indentation characters.*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*根据 PEP8 风格指南 ([https://pep8.org/#indentation/](https://pep8.org/#indentation/))，每个缩进级别应使用四个空格，并且推荐使用空格而非制表符。默认情况下，Spyder
    编辑器将制表符转换为四个空格，因此可以减少反复操作带来的肌肉劳损。你可以在工具 *▸* 首选项 *▸* 编辑器 *▸* 源代码 *▸* 缩进字符中找到此选项。*'
- en: '***Using the else and elif Clauses***'
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 else 和 elif 子句***'
- en: The `if` statement comes with another optional clause, called `elif` (short
    for “else-if”), which tests another condition when the `if` statement evaluates
    to `False`. The `elif` clause lets you check multiple expressions for `True` and
    execute a block of code as soon as one of the conditions evaluates to `True`.
    You then can use the `else` clause as a final “catch all” that runs if none of
    the previous conditions are met.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句有一个可选的子句，叫做`elif`（即“else-if”的缩写），当`if`语句的条件为`False`时，它会测试另一个条件。`elif`子句允许你检查多个表达式是否为`True`，并在其中一个条件为`True`时执行一个代码块。然后，你可以使用`else`子句作为最终的“捕捉”语句，当没有任何前面的条件满足时执行。'
- en: 'Let’s use `elif` and `else` to compare a single variable, representing the
    core temperature of a nuclear reactor in degrees Celsius, to several possible
    responses:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`elif`和`else`来比较一个变量，该变量表示核反应堆的核心温度（单位：摄氏度），并对几种可能的响应进行比较：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The code starts by assigning an optimum operating temperature of 300^° Celsius
    to the `core` variable. Next, an `if` statement tests whether the temperature
    is below 200^°. If so, the core should be shut down, so a message to that effect
    is printed. Next, a series of `elif` clauses look at other outcomes, such as a
    core temperature of exactly 300^°, and print appropriate responses. Finally, an
    `else` clause executes if all the proceeding conditions evaluate to `False`. This
    will catch a `core` value greater than or equal to `1800`. Closing an `if` statement
    block with an `else` clause ensures that at least one clause is executed, and
    you won’t be left with an empty response.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先为`core`变量分配一个300^°的最佳工作温度。接着，`if`语句测试温度是否低于200^°。如果是，核心应当关闭，因此会打印出相关的消息。然后，一系列`elif`语句检查其他结果，比如核心温度恰好为300^°，并打印出相应的响应。最后，如果所有前述条件的评估结果为`False`，`else`语句会执行。这将捕捉到`core`值大于或等于`1800`的情况。使用`else`语句结束`if`语句块，确保至少有一个语句被执行，你不会得到空的响应。
- en: 'When using an `else` clause, you’ll want to be very careful that your code
    properly handles the full range of possible values. For example, the following
    code prints the meltdown warning, even though the core temperature is only 200^°.
    See if you can figure out what went wrong:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`else`语句时，你需要特别小心，确保你的代码能够正确处理所有可能的值。例如，以下代码会打印出过热警告，尽管核心温度仅为200^°。试着找找哪里出了问题：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Because this code failed to explicitly handle a `core` value of exactly `200`,
    it was evaluated in the `else` clause, resulting in an incorrect message and a
    lot of unnecessary excitement.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这段代码没有明确处理`core`值恰好为`200`的情况，因此它被评估为`else`语句中的条件，导致错误的消息和许多不必要的激动。
- en: Also make sure that *only one* condition evaluates to `True`. An advantage of
    using `elif` is that if a condition evaluates to `True`, the program will execute
    its corresponding block and exit the statement immediately. This is efficient,
    but if more than one `elif` condition evaluates to `True`, only the block associated
    with the *first* `True` condition will execute.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，要确保*只有一个*条件评估为`True`。使用`elif`的一个优点是，如果某个条件评估为`True`，程序会立即执行对应的代码块并退出语句。这是高效的，但如果多个`elif`条件评估为`True`，只有与*第一个*`True`条件相关联的代码块会执行。
- en: 'To illustrate, here’s a poorly written piece of code that uses `elif` to increment
    multiple count variables whose conditions overlap:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例，展示了一段使用`elif`来递增多个计数变量的代码，且这些条件之间有重叠：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This code starts by assigning tuples of dog breeds, cat breeds, and combined
    popular breeds. It then assigns count variables for each category, after which
    a poodle breed is assigned to the `animal` variable.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码首先分配了狗品种、猫品种以及流行狗品种的元组。接着，它为每个类别分配了计数变量，之后将“poodle”品种赋值给`animal`变量。
- en: Next, a series of conditional statements evaluates the `animal` variable. If
    it’s in the `dogs` tuple, the `dog_count` variable is incremented by 1\. Otherwise,
    if it’s in the `cats` tuple, the `cat_count` variable is incremented, and then,
    if it’s only in the `popular_breeds` tuple, the `popular_breeds_count` is incremented.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，一系列条件语句评估`animal`变量。如果它在`dogs`元组中，`dog_count`变量加1。否则，如果它在`cats`元组中，`cat_count`变量加1，之后，如果它仅在`popular_breeds`元组中，`popular_breeds_count`会加1。
- en: When you run the code and check the counts, they’re incorrect. Despite “poodle”
    being present in both the `dogs` and `popular_breeds` tuples, only the `dog_count`
    variable was updated. Because the first `elif` clause evaluated to `True`, the
    `if` statement terminated immediately, and the popular breeds evaluation was never
    performed.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行代码并检查计数时，它们是错误的。尽管“poodle”同时出现在`dogs`和`popular_breeds`元组中，只有`dog_count`变量被更新。因为第一个`elif`语句评估为`True`，`if`语句立即终止，导致流行品种的评估从未执行。
- en: '***Using Ternary Expressions***'
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用三元表达式***'
- en: 'For convenience, Python lets you combine an `if-else` block into a single expression
    called a *ternary expression* whose syntax is as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便，Python允许将`if-else`语句块合并为一个称为*三元表达式*的单一表达式，其语法如下：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here’s an example:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Ternary expressions let you write pithy code at the cost of readability. They
    should be used with only simple and straightforward conditions and expressions.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 三元表达式让你可以写出简洁的代码，但代价是可读性降低。它们应该仅在条件和表达式简单直白的情况下使用。
- en: '***Using Boolean Operators***'
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用布尔运算符***'
- en: To further aid you in making comparisons, Python provides the `and`, `or`, and
    `not` operators. These three operators compare Boolean values and evaluate to
    a Boolean value.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你进行比较，Python 提供了 `and`、`or` 和 `not` 运算符。这三个运算符比较布尔值并计算出一个布尔值。
- en: The possible outcomes for Boolean operators can be shown in a truth table, which
    we present in [Table 10-1](ch10.xhtml#ch010tab1).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔运算符的可能结果可以通过真值表展示，我们在[表 10-1](ch10.xhtml#ch010tab1)中展示了该表。
- en: '**Table 10-1:** Truth Table for `and`/`or` Operators'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 10-1：** `and`/`or` 运算符的真值表'
- en: '| **Expression** | **Evaluation** |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| **表达式** | **求值** |'
- en: '| --- | --- |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| True `and` True | True |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| True `and` True | True |'
- en: '| True `and` False | False |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| True `and` False | False |'
- en: '| False `and` True | False |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| False `and` True | False |'
- en: '| False `and` False | False |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| False `and` False | False |'
- en: '| True `or` True | True |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| True `or` True | True |'
- en: '| True `or` False | True |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| True `or` False | True |'
- en: '| False `or` True | True |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| False `or` True | True |'
- en: '| False `or` False | False |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| False `or` False | False |'
- en: As you can see, the `and` operator evaluates an expression to `True` only if
    *both* Boolean values are `True`. The `or` operator evaluates to `True` if *either*
    of the Boolean values is `True`. For example, you could say you had “cereal” for
    breakfast if you had either corn flakes *or* raison bran, but you can’t say you
    had “bacon and eggs” unless you had both bacon *and* eggs.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`and` 运算符只有在*两个*布尔值都为 `True` 时才会求值为 `True`。`or` 运算符只要*任意一个*布尔值为 `True`，就会求值为
    `True`。例如，如果你早餐吃了玉米片*或*葡萄干麦片，那么你可以说自己吃了“麦片”，但如果你吃了培根*和*鸡蛋，你才能说自己吃了“培根和鸡蛋”。
- en: 'The `not` operator operates on only *one* expression or Boolean and evaluates
    to the *opposite* Boolean value. For example:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`not` 运算符仅作用于*一个*表达式或布尔值，并计算出*相反*的布尔值。例如：'
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'With `and`, `or`, and `not`, you can build more complex comparisons for directing
    your code’s flow of execution. Try out a few examples in the console:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `and`、`or` 和 `not`，你可以构建更复杂的比较来控制代码的执行流。尝试在控制台中执行几个例子：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Python will evaluate each expression, from left to right, until it has a single
    Boolean value. It then evaluates these Booleans down to a single value, either
    `True` or `False`. The order of operations is as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Python 会从左到右依次计算每个表达式，直到得到一个单一的布尔值。然后它会将这些布尔值计算为一个最终值，可能是 `True` 或 `False`。运算顺序如下：
- en: math operators → comparison operators → `not` operator → `and` operator → `or`
    operator
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 数学运算符 → 比较运算符 → `not` 运算符 → `and` 运算符 → `or` 运算符
- en: 'With Boolean operators, you can compare multiple variables within `if` statements.
    Here’s an example in which you discriminate animals using the number of legs and
    the sound produced:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用布尔运算符，你可以在 `if` 语句中比较多个变量。以下是一个例子，你可以通过动物的腿数和发出的声音来区分动物：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the previous example, both conditions had to be `True` for the `if` statement
    to execute. In the following example, only one of the conditions needs to be `True`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`if` 语句要执行，两个条件必须都是 `True`。在以下示例中，只需要其中一个条件为 `True`：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If `today` is either `Saturday` or `Sunday`, you’re in the weekend, and the
    `print()` function is called.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `today` 是 `Saturday` 或 `Sunday`，那么你就在周末，并且会调用 `print()` 函数。
- en: 'Note that it’s easy to slip-up when using `if` statement syntax. The following
    code looks logical, but it will evaluate to `True` no matter the value of the
    `today` variable:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在使用 `if` 语句语法时容易出错。以下代码看起来是合乎逻辑的，但无论 `today` 变量的值如何，结果都会求值为 `True`：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '**Loops**'
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**循环**'
- en: Loops permit the repetition of certain steps indented under a keyword. The repetition
    continues until some condition is met, making loops much like `if` statements,
    but they can run more than once.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 循环允许在关键字下缩进的某些步骤反复执行。直到满足某个条件，重复才会停止，这使得循环类似于 `if` 语句，但它们可以执行多次。
- en: Python uses the `while` and `for` keywords for loops. These correspond to *condition-controlled*
    loops and *collection-controlled* loops, respectively.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Python 使用 `while` 和 `for` 关键字来实现循环。这些分别对应于*条件控制*循环和*集合控制*循环。
- en: 'The `while` keyword, plus a condition, forms a `while` statement. These are
    used to execute a block of code repeatedly until the given condition evaluates
    to `False`. At this point, the line immediately after the loop in the program
    is executed. Here’s the syntax:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 关键字加上一个条件构成了一个 `while` 语句。这些语句用于反复执行一段代码，直到给定的条件求值为 `False`。此时，程序中紧接着循环的下一行代码会被执行。以下是语法：'
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `for` keyword is used to repeat a block of code a fixed number of times
    or to iterate over a sequence of items. Here’s the basic syntax:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 关键字用于重复执行一段固定次数的代码或对一组项进行迭代。以下是基本语法：'
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When the `for` loop runs out of items, its underlying condition becomes `False`,
    and the loop ends and returns control to the first line of code under the `for`
    loop’s block.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `for` 循环耗尽所有项目时，它的底层条件变为 `False`，循环结束并将控制权返回到 `for` 循环块下的第一行代码。
- en: '***The while Statement***'
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***while 语句***'
- en: The `while` statement tests a condition and executes the block over and over
    until the condition is `False` ([Figure 10-3](ch10.xhtml#ch010fig3)) or you explicitly
    end the loop with a `break` statement (more on these later). In fact, a `while`
    loop can go on forever.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 语句会测试一个条件，并不断执行代码块，直到条件变为 `False`（[图 10-3](ch10.xhtml#ch010fig3)），或者你显式地使用
    `break` 语句结束循环（后面会详细讲解）。事实上，`while` 循环可能会永远运行下去。'
- en: '![Image](../images/10fig03.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/10fig03.jpg)'
- en: '*Figure 10-3: Flowchart for a generic while loop*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-3：通用 `while` 循环的流程图*'
- en: A `while` loop is useful for performing some action until a target is reached.
    For instance, you can simulate the population growth of a herd of deer until the
    population reaches a target value, at which time the simulation loop could stop
    and log details, such as the time it took to reach the target or the average weight
    of an adult deer.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 循环用于在达到目标之前执行某个操作。例如，你可以模拟一群鹿的种群增长，直到种群达到目标值，这时模拟循环可以停止并记录相关细节，如达到目标所花费的时间或成年鹿的平均体重。'
- en: A much simpler example is testing for a password. In the code that follows,
    we give a user a set number of times to enter the correct value.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更简单的例子是测试密码。在下面的代码中，我们给用户设定了一个输入正确密码的次数限制。
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this example, we first create an empty `password` variable and set a `count`
    variable to `0`. We then start a loop using the `while` keyword ➊. If `password`
    does not equal “Python,” the indented `while` clause will prompt the user to enter
    a password. It then increments the `count` variable by `1` and uses an `if` statement
    to check if the number of allowable counts has been exceeded ➋. If this evaluates
    to `True`, the user is informed that they have exceeded the allowed number of
    attempts, and the `break` keyword ends the loop. If `count` is less than or equal
    to `3`, the loop will continue prompting the user for a password. If the user
    enters the correct password, the loop ends without fanfare.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们首先创建一个空的 `password` 变量，并将 `count` 变量设置为 `0`。然后我们使用 `while` 关键字开始一个循环
    ➊。如果 `password` 不等于“Python”，缩进的 `while` 子句将提示用户输入密码。接着它将 `count` 变量增加 `1`，并使用
    `if` 语句检查是否超过了允许的次数 ➋。如果这个条件为 `True`，用户将被告知已超出允许的尝试次数，并且 `break` 关键字将结束循环。如果 `count`
    小于或等于 `3`，循环将继续提示用户输入密码。如果用户输入正确密码，循环将在没有任何提示的情况下结束。
- en: '[Figure 10-4](ch10.xhtml#ch010fig4) documents this loop in a flowchart. Note
    how both the `while` and `if` conditions are marked by diamonds. This is because
    they represent decision points.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10-4](ch10.xhtml#ch010fig4) 用流程图记录了这个循环。注意 `while` 和 `if` 条件都被标记为菱形。这是因为它们代表了决策点。'
- en: '![Image](../images/10fig04.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/10fig04.jpg)'
- en: '*Figure 10-4: The flowchart for the password while loop*'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-4：密码 `while` 循环的流程图*'
- en: Each execution of a loop is called an *iteration*. The `while` loop can iterate
    *indefinitely* because the number of loops isn’t explicitly specified at the start.
    A `while` loop can run a million times or end after the first iteration depending
    on whether its condition is met.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 每次执行循环都称为一次 *迭代*。`while` 循环可以 *无限次* 迭代，因为循环的次数在开始时没有明确指定。`while` 循环可以执行一百万次，或者在第一次迭代后结束，这取决于其条件是否满足。
- en: '**NOTE**'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If your program is ever caught in an infinite loop, you can use CTRL-C to
    stop the program and escape.*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你的程序进入了无限循环，可以使用 CTRL-C 停止程序并退出。*'
- en: '**TEST YOUR KNOWLEDGE**'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试你的知识**'
- en: 1.  Each new code block should be indented _____ spaces.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 每个新的代码块应该缩进 _____ 个空格。
- en: '2.  True or false: The `or` operator evaluates an expression to `True` only
    if *both* Boolean values are `True`.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 判断对错：`or` 操作符仅在 *两个* 布尔值都为 `True` 时，才会使表达式的结果为 `True`。
- en: 3.  Write a `while` loop that never ends, and then stop it using CTRL-C.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 编写一个永不结束的 `while` 循环，然后使用 CTRL-C 停止它。
- en: 4.  Which values can be used to represent `False`?
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 哪些值可以用来表示 `False`？
- en: a.  `0`
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: a. `0`
- en: b.  0.0
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: b. `0.0`
- en: c.  F
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: c. F
- en: d.  All the above
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: d. 上述所有
- en: 5.  To form Pig Latin, one takes an English word that begins with a consonant,
    moves the consonant to the end, and adds “ay” after it. If the word begins with
    a vowel, one simply adds “way” to the end. Use the Spyder text editor to write
    a program that takes a word as input and uses indexing and slicing to return its
    Pig Latin equivalent. Keep the program running until the user decides to quit.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 5.  形成猪拉丁语的方法是：将一个以辅音开头的英语单词将辅音移到末尾，并在其后添加“ay”。如果单词以元音开头，则直接在末尾添加“way”。使用 Spyder
    文本编辑器编写一个程序，接受一个单词作为输入，利用索引和切片返回其对应的猪拉丁语形式。保持程序运行，直到用户决定退出。
- en: '***The for Statement***'
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***for 语句***'
- en: 'The `for` statement lets you execute a loop a set number of times. This number
    is often specified using the built-in `range()` function. This memory-efficient
    function returns a sequence of evenly spaced numbers starting from 0 (by default)
    and ending before a specified endpoint. Here’s what the `range()` function’s syntax
    looks like:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 语句让你能够执行固定次数的循环。这个次数通常通过内建的 `range()` 函数来指定。这个内存高效的函数返回一个从 0（默认值）开始，直到指定结束点之前的等距数字序列。以下是
    `range()` 函数的语法：'
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `start` and `step` parameters are optional. If omitted, the `start` parameter
    defaults to `0`, and the `step` defaults to `1`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`start` 和 `step` 参数是可选的。如果省略，`start` 参数默认值为 `0`，`step` 默认值为 `1`。'
- en: 'Here’s an example where a `for` loop uses `range()` to print five numbers:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例，演示了如何使用 `for` 循环和 `range()` 打印五个数字：
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note that `5` is not included in the output. This is because the function reads
    *up to* the stop value but doesn’t include it. The block beneath the `for` statement
    is indented, just as in a `while` loop.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`5` 没有包含在输出中。这是因为该函数读取*直到*停止值，但不包括它。`for` 语句下面的代码块是缩进的，就像在 `while` 循环中一样。
- en: 'Here’s an example using all three arguments (`start`, `stop`, `step`) in `range()`
    to print every other number from 1 to 6:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例，展示如何使用 `range()` 中的所有三个参数（`start`、`stop`、`step`），以打印从 1 到 6 之间的每个其他数字：
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note that the `i` in the previous code is used by convention when iterating
    over a range of numbers. Any legal variable name (such as `num` or `number`) will
    work. An underscore (`_`) is preferred if you’re using a linter to check your
    code; other names can sometimes trigger an `unused variable` warning.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在之前的代码中，`i` 是按照惯例在遍历数字范围时使用的变量名。任何合法的变量名（如 `num` 或 `number`）都可以使用。如果你使用
    linter 工具检查代码，建议使用下划线（`_`）；否则，其他变量名有时会触发“未使用的变量”警告。
- en: 'You can use `range()`in conjunction with the `len()` function to obtain the
    endpoint for an arbitrarily sized sequence. Here’s an example:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 `range()` 与 `len()` 函数结合使用，来获取任意大小序列的结束点。以下是一个示例：
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This code starts by assigning a list of letters to the `my_list` variable. In
    the following `if` statement, passing the `range()` function the length of this
    list, as determined by the `len()` function, sets the number of iterations. With
    each iteration, the current value of `i` is used as an index for the list, and
    the corresponding letter is printed.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码首先将字母列表赋值给 `my_list` 变量。在随后的 `if` 语句中，通过将 `range()` 函数与 `len()` 函数结合使用，设置了循环的迭代次数。每次迭代时，当前的
    `i` 值被用作列表的索引，并打印出相应的字母。
- en: 'Although it works, this code isn’t very Pythonic. Fortunately, you can use
    iterables directly in the `for` statement. Remember, iterables are objects that
    can return their items one at a time. These include sequence types like range,
    list, tuple, string, set, and more. As a result, you don’t need to keep track
    of the iterable’s size or use a running index. Here’s the previous snippet in
    this format:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它能工作，但这段代码并不算非常 Pythonic。幸运的是，你可以直接在 `for` 语句中使用可迭代对象。记住，可迭代对象是那些可以一次返回一个元素的对象，包括像
    `range`、`list`、`tuple`、`string`、`set` 等序列类型。因此，你不需要跟踪可迭代对象的大小或使用一个递增的索引值。以下是使用这种格式的之前代码片段：
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Notice how the code reads almost like English. You can’t get more Pythonic than
    that!
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意代码几乎像英语一样可读。没有比这更“Pythonic”的写法了！
- en: '**NOTE**'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Never add or delete items to a list while looping over it. If you want to
    change a list during a loop, append the changes to a new list.*'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*在遍历列表时，绝对不要添加或删除列表中的项。如果你想在循环过程中更改列表，应该将更改追加到一个新的列表中。*'
- en: 'You can even loop over a string and print its characters without using an intermediate
    variable to hold the string:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以遍历一个字符串并打印其字符，而无需使用中间变量来保存字符串：
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the event that you need an item’s index during looping, the best solution
    is to use the built-in `enumerate()` function. This function adds a counter to
    each item of an iterable object and returns an *enumerate* object, allowing you
    to loop over an iterable and keep track of the number of iterations. The first
    index value starts from 0 by default, but you can override that by specifying
    a starting index. The following example produces a numbered list of items (starting
    at 1) from a `list` datatype:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在循环过程中需要获取项的索引，最佳的解决方案是使用内置的`enumerate()`函数。该函数为可迭代对象中的每个项添加计数器，并返回一个*enumerate*对象，允许你在循环过程中追踪迭代次数。默认情况下，第一个索引值从0开始，但你可以通过指定起始索引来覆盖这一行为。下面的示例生成一个编号的项列表（从1开始），数据类型为`list`：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Some other uses for `enumerate()` include selecting every *n* items from a list,
    ending a loop after *n* items, and using the indexes for line weights or symbol
    sizes when plotting.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`enumerate()`的其他用法包括从列表中选择每隔*n*项，循环*n*项后结束循环，以及在绘图时使用索引作为线条权重或符号大小。'
- en: '***Loop Control Statements***'
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***循环控制语句***'
- en: '*Loop control statements* are used inside loops to change the normal sequence
    of execution. Earlier, you used a `break` statement to interrupt and end a `while`
    loop. Python also uses `continue` and `pass` statements to control loops.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*循环控制语句*用于循环内部，改变正常的执行顺序。之前，你使用了`break`语句来中断并结束`while`循环。Python还使用`continue`和`pass`语句来控制循环。'
- en: '**The break Statement**'
  id: totrans-136
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**break语句**'
- en: The `break` keyword lets you exit a loop’s code block at any time. A common
    usage is to set `while` to `True` (`while True:`) and then “manually” break out
    of the loop when a condition is met. Because `True` always evaluates to true,
    no condition can stop the loop, so you must force the issue using `break`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`break`关键字允许你随时退出循环的代码块。一种常见的用法是将`while`设置为`True`（`while True:`），然后在满足某个条件时“手动”退出循环。由于`True`始终为真，无法通过条件停止循环，因此必须使用`break`强制退出。'
- en: 'In nested loops, `break` terminates only the block it’s in, along with any
    inner blocks. Outer loops will continue to run. For example, the following example
    contains two nested loops:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在嵌套循环中，`break`只终止其所在的代码块及其中的任何内部代码块。外部循环将继续执行。例如，下面的示例包含了两个嵌套循环：
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Even though the `break` statement interrupted the inner `for` loop and prevented
    “Jamie” from printing, the outer loop ran to completion.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 即使`break`语句中断了内部的`for`循环并且阻止了“Jamie”的打印，外部循环仍然会继续执行直到完成。
- en: '**The continue Statement**'
  id: totrans-141
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**continue语句**'
- en: 'The `continue` keyword immediately returns control to the beginning of a loop,
    skipping any loop clauses beneath it. For instance, the following example uses
    a `while` loop to evaluate a user’s name and password. Enter the code in the Jupyter
    Qt console and then run it using SHIFT-ENTER:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`continue`关键字会立即将控制权返回到循环的起始位置，跳过其下方的任何循环语句。例如，下面的示例使用`while`循环来验证用户的用户名和密码。将代码输入到Jupyter
    Qt控制台中，然后按SHIFT-ENTER运行：'
- en: '[PRE24]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The first step, of course, is to get the correct username. If the condition
    for the first `if` statement evaluates to `True` (the name is *not* “Alice”),
    a `continue` statement interrupts the loop and restarts the sequence ➊. If the
    name passes the test, the `continue` statement is skipped, and the user is prompted
    for a password ➋. If they enter the correct value, a `break` statement ends the
    loop ➌. Otherwise, they’re alerted to the error, and the loop begins again.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，当然是获取正确的用户名。如果第一个`if`语句的条件为`True`（用户名*不是*“Alice”），则`continue`语句会中断循环并重新开始序列
    ➊。如果用户名通过测试，`continue`语句会被跳过，接下来会提示用户输入密码 ➋。如果输入正确，`break`语句会结束循环 ➌。否则，用户会收到错误提示，循环重新开始。
- en: '**The pass Statement**'
  id: totrans-145
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**pass语句**'
- en: 'You can use the `pass` keyword to build “empty” loops, or blocks that take
    no action. These keywords serve as placeholders for future code or flag places
    where you intentionally omitted something. Take this snippet, for example, in
    which we choose to not print the `h` in `Python`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`pass`关键字来构建“空”循环，或者不执行任何操作的代码块。这些关键字作为占位符，预留将来填写的代码，或者标记你故意省略某些内容的位置。例如，在这个片段中，我们选择不打印`Python`中的`h`：
- en: '[PRE25]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This code assigns “Python” to the `word` variable, and 0 to the `count` variable.
    While the `count` value is less than the length of `word`, the loop prints each
    character in `word` indexed at the current `count` value. If `count` is equal
    to `3`, however, it uses the `pass` keyword to continue the loop with no action.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将“Python”赋值给了`word`变量，并将0赋值给了`count`变量。当`count`值小于`word`的长度时，循环会打印出`word`中索引为当前`count`值的每个字符。但是，当`count`等于`3`时，它使用`pass`关键字跳过当前循环。
- en: You could have accomplished the same thing by only printing `count < 3` and
    `count > 3`, but this could be viewed in retrospect as an indexing mistake (see
    the earlier core temperature example at lines `In [10]-[11]`). By including the
    reference to `h` and using `pass` ➊, it’s clear that you knew what you were doing.
    You basically said, “I know there’s a letter at this index and I’m not printing
    it on purpose.”
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你本可以通过只打印`count < 3`和`count > 3`来完成相同的任务，但从回顾的角度看，这可能被视为一个索引错误（请参阅前面第`In [10]-[11]`行的核心温度示例）。通过包括对`h`的引用并使用`pass`
    ➊，可以明确看出你知道自己在做什么。你基本上是说，“我知道在这个索引处有一个字母，但我故意不打印它。”
- en: '***Replacing Loops with Comprehensions***'
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***用推导式替代循环***'
- en: In Python, a *comprehension* is a way to construct a new sequence such as a
    list, set, or dictionary from an existing sequence. For example, you might want
    to create a new list containing the logarithms of the numbers in another list.
    As a replacement for standard `for` loops, comprehensions are faster, more elegant,
    and more concise.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，*推导式*是一种通过现有序列构建新序列（如列表、集合或字典）的方法。例如，你可能想要创建一个新列表，其中包含另一个列表中数字的对数。作为标准`for`循环的替代，推导式更快、更优雅、也更简洁。
- en: 'A downside to comprehensions is that you can’t embed a `print()` function in
    the loop to help you track what’s happening. They can also be quite difficult
    to read when using complicated expressions, but for simple expressions, they can’t
    be beat. Python supports comprehensions for lists, dictionaries, sets, and something
    we’ll talk about in the next chapter: generators.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 推导式的一个缺点是，你不能在循环中嵌入`print()`函数来帮助你跟踪发生了什么。当使用复杂的表达式时，它们也可能变得难以阅读，但对于简单的表达式来说，它们无可替代。Python支持列表、字典、集合的推导式，还有我们将在下一章讨论的：生成器。
- en: '**List Comprehensions**'
  id: totrans-153
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**列表推导式**'
- en: 'To make a new list using *list comprehension*, encase the comprehension expression
    in square brackets. To use a condition to choose items from an existing iterable,
    use this syntax:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用*列表推导式*创建一个新列表，将推导式表达式放在方括号中。如果你想用条件从现有的可迭代对象中选择项目，可以使用以下语法：
- en: '[PRE26]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Use this syntax if you want to alter these items, or generate new items, before
    adding them to the new list:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在将这些项添加到新列表之前修改它们，或生成新的项，可以使用以下语法：
- en: '[PRE27]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'For instance, here’s an example that takes a string, loops through it, capitalizes
    each letter, and appends the capital letter to a new list:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这里有一个示例，它接受一个字符串，遍历字符串， 将每个字母大写，并将大写字母追加到一个新列表中：
- en: '[PRE28]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, we assigned a string to the `word` variable, and then we created the `letters`
    list using the list comprehension `[letter.upper() for letter in word]`. Notice
    how the syntax is a little backward, as the loop variable (`letter`) appears before
    it’s defined.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将一个字符串赋值给了`word`变量，然后使用列表推导式`[letter.upper() for letter in word]`创建了`letters`列表。注意语法略有不同，循环变量（`letter`）出现在定义之前。
- en: 'The following example extracts the capital “P” from “Python.” Notice how you
    can use an `if` statement within the comprehension:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例提取了“Python”中的大写字母“P”。注意你可以在推导式中使用`if`语句：
- en: '[PRE29]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The single-line list comprehension in line `In [57]` is equivalent to the following
    code using a standard `for` loop:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 行`In [57]`中的单行列表推导式等价于使用标准`for`循环的以下代码：
- en: '[PRE30]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In this case, list comprehension saved you three lines of code.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，列表推导式帮你节省了三行代码。
- en: 'You also can create list comprehensions using nested `for` loops, as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过嵌套的`for`循环创建列表推导式，如下所示：
- en: '[PRE31]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You can see more examples of list comprehensions at *[https://docs.python.org/3/tutorial/datastructures.html](https://docs.python.org/3/tutorial/datastructures.html)*.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 *[https://docs.python.org/3/tutorial/datastructures.html](https://docs.python.org/3/tutorial/datastructures.html)*
    中看到更多的列表推导式示例。
- en: '**Dictionary Comprehensions**'
  id: totrans-169
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**字典推导式**'
- en: '*Dictionary comprehensions* are like list comprehensions, except they use key-value
    (k, v) pairs in place of items, are enclosed in curly brackets, and return a dictionary
    rather than a list.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典推导式*类似于列表推导式，不同之处在于它使用键值对（k, v）代替了项，使用大括号包裹，并返回一个字典而不是列表。'
- en: 'You can use dictionary comprehensions on existing dictionaries, in which case
    you either choose key-value (k, v) pairs from the existing dictionary based on
    some condition, or you use an expression on the keys and/or values based on a
    condition. The general syntax is:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在现有的字典上使用字典推导式，在这种情况下，你要么基于某些条件从现有字典中选择键值对（k, v），要么基于条件对键和值应用表达式。一般语法如下：
- en: '[PRE32]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'or:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: '[PRE33]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'When using dictionary comprehension on another type of iterable, like a list,
    you choose and/or change existing items in the iterable to serve as key-value
    pairs in the new dictionary. The syntax is varied, but looks something like this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当在另一种可迭代对象（如列表）上使用字典推导式时，你可以选择并/或改变现有的项，以便将其作为新字典中的键值对。语法有多种变化，但大致如下所示：
- en: '[PRE34]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note that the expression can alter the item used for the key, for the value
    or for both.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，表达式可以改变用于键、值，或者两者的项。
- en: 'Here’s an example in which we extract even numbers from a list and map them
    to their square:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个例子，我们从列表中提取偶数，并将其映射到它们的平方：
- en: '[PRE35]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'And here we zip two tuples (the `mineral` and `hardness` variables) together
    to create part of Moh’s famous mineral hardness scale:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将两个元组（`mineral`和`hardness`变量）压缩在一起，创建摩氏著名的矿物硬度标度的一部分：
- en: '[PRE36]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Note that you also can generate the `mohs` dictionary by calling the built-in
    `dict()` function, as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你也可以通过调用内置的`dict()`函数来生成`mohs`字典，如下所示：
- en: '[PRE37]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '**Set Comprehensions**'
  id: totrans-184
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**集合推导式**'
- en: '*Set comprehensions* are enclosed in curly brackets and return unsorted sets.
    You can *choose* existing items from an iterable using the following syntax:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '*集合推导式* 用大括号括起来，并返回未排序的集合。你可以使用以下语法从可迭代对象中 *选择* 已有项：'
- en: '[PRE38]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Alternatively, you can alter the items or derive new items by applying a condition-based
    expression before adding the item to the new set:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以通过在将项添加到新集合之前应用基于条件的表达式，来改变项或派生新项：
- en: '[PRE39]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Here’s an example that returns all the unique characters in a string, given
    that sets don’t allow duplicate values (this is the same as the `set()` function):'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个例子，它返回字符串中的所有唯一字符，考虑到集合不允许重复值（这与`set()`函数相同）：
- en: '[PRE40]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'And here we use an expression to calculate word lengths:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们使用一个表达式来计算单词的长度：
- en: '[PRE41]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '**Handling Exceptions**'
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**处理异常**'
- en: An *exception* occurs when Python encounters an error during execution. This
    causes it to “raise an exception” and produce a Python object that represents
    an error. If not dealt with immediately, exceptions cause a program to terminate
    and display an error message.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Python 在执行过程中遇到错误时，会发生 *异常*。这会导致它“抛出异常”，并产生一个代表错误的 Python 对象。如果不立即处理，异常会导致程序终止并显示错误消息。
- en: Fortunately, exceptions can be “caught” and handled through flow control. This
    gives you the opportunity to fix the problem, try again, supply a more helpful
    error message, or suppress the error.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，异常可以通过流控制“捕获”并进行处理。这为你提供了修复问题、重新尝试、提供更有帮助的错误信息或抑制错误的机会。
- en: '***Using try and except***'
  id: totrans-196
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 try 和 except***'
- en: Python provides a `try` statement with an `except` clause to help you handle
    exceptions. The `try` statement lets you isolate code that could potentially contain
    an error and crash your program. If the code contains an error, the `except` clause
    will deal with it by providing code that executes only when an exception is raised.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Python 提供了一个`try`语句和一个`except`子句来帮助你处理异常。`try`语句允许你隔离可能包含错误并导致程序崩溃的代码。如果代码中包含错误，`except`子句将通过提供代码来处理它，这些代码只有在异常被抛出时才会执行。
- en: 'The simplest exception handling merely prevents your program from crashing
    unceremoniously. It presents an alert and (hopefully) a helpful message. Here
    is an example that’s designed to handle incorrect input from a user:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的异常处理仅仅是防止你的程序毫无预警地崩溃。它会呈现一个警告并（希望）给出有帮助的消息。以下是一个处理用户输入错误的例子：
- en: '[PRE42]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In this example, the `age` value is converted to an integer, as we want `age`
    to be a whole number in years. But the user entered letters instead (`Harry`),
    which raised a `ValueError` exception because letters can’t be converted into
    integers. You don’t see this error message, however, as we caught the exception
    using the `try` statement, which does just what it says. It tries the code in
    isolation, giving us the opportunity to do something before the program crashes.
    Here, we printed a message to the user so that the program ends somewhat gracefully.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`age`的值被转换为整数，因为我们希望`age`是一个完整的年份数字。但是用户输入了字母（`Harry`），这引发了一个`ValueError`异常，因为字母不能转换为整数。然而，你不会看到这个错误信息，因为我们使用`try`语句捕获了异常，`try`语句的作用正如其名，它会单独尝试这段代码，给我们机会在程序崩溃之前采取措施。在这里，我们向用户打印了一条信息，以便程序能够相对优雅地结束。
- en: In most cases, you want to specify the type of exception to handle rather than
    catch all of the built-in exceptions, as we did in the previous snippet. You can
    find a list of exception types on [Table 7-4](ch07.xhtml#ch07tab4) on [page 183](ch07.xhtml#ch07tab4).
    You can also create the error you’re looking for in the console and read off the
    exception name from the resulting `Traceback` message.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，你希望指定要处理的异常类型，而不是像我们在前一个代码片段中那样捕获所有内置异常。你可以在[第 183 页](ch07.xhtml#ch07tab4)的[表
    7-4](ch07.xhtml#ch07tab4)中找到异常类型的列表。你也可以在控制台中创建你需要的错误，并从结果的`Traceback`消息中读取异常名称。
- en: 'Let’s rewrite the previous snippet to catch a `ValueError`. Just place the
    proper exception name after `except`, as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们改写前面的代码片段来捕获`ValueError`。只需在`except`后面放上适当的异常名称，如下所示：
- en: '[PRE43]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You can also trap for multiple exception types by placing them after `except`
    as a tuple with parentheses:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过将多个异常类型放在`except`后面，作为一个元组（带有括号）来捕获多个异常类型：
- en: '[PRE44]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'If you want to use a different message or take a different action with each
    error type, simply use multiple stacked `except` clauses within a `try` statement,
    in this format:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望对每种错误类型使用不同的消息或采取不同的措施，只需在`try`语句中使用多个堆叠的`except`语句，格式如下：
- en: '[PRE45]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'You can also incorporate Python’s error messages into your own customized versions.
    Exceptions have *arguments*, which are official messages from Python describing
    what happened. You can use an argument by specifying a variable after the exception
    type, preceded by the keyword `as`. Here’s an example:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以将 Python 的错误消息集成到你自定义的版本中。异常有*参数*，它们是 Python 描述发生了什么的官方消息。你可以通过在异常类型后面指定一个变量，并用`as`关键字来使用这个参数。以下是一个例子：
- en: '[PRE46]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now you have the best of both worlds: Python’s precise but technical explanation
    combined with friendlier instructions for non-programmers.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你既能享受 Python 精确但技术性的解释，又能得到非程序员更友好的指示。
- en: 'Finally, you can add an `else` clause at the end of all the `except` clauses.
    This lets you do something, like confirm a successful operation, if no exceptions
    are raised elsewhere in the `try` block:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以在所有`except`语句的末尾添加一个`else`子句。如果在`try`块中没有引发异常，你可以做一些操作，例如确认操作成功：
- en: '[PRE47]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '***Forcing Exceptions with the raise Keyword***'
  id: totrans-213
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 raise 关键字强制抛出异常***'
- en: Python’s `raise` keyword allows you to force a specified exception if a condition
    occurs. You can use it to raise built-in error types or your own custom errors.
    It’s especially useful for validating inputs such as enforcing the use of maximum
    values, or handling the input of a negative number when you’re working with positive
    numbers.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的`raise`关键字允许你在发生某个条件时强制抛出指定的异常。你可以使用它来抛出内置的错误类型或你自己的自定义错误。它对于验证输入尤其有用，例如强制使用最大值，或者在处理正数时处理负数输入。
- en: 'To see how to create your own custom error, enter the following in Spyder’s
    text editor and save it with any name you please:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看如何创建你自己的自定义错误，请在 Spyder 的文本编辑器中输入以下内容并保存为任何你喜欢的文件名：
- en: '[PRE48]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Here, you accept a name from the user, convert it to lowercase, and compare
    it to “potter.” If the name doesn’t match, you use the `raise` keyword and call
    the `Exception` class, passing it a custom message.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你接受用户输入的名字，将其转换为小写，并与“potter”进行比较。如果名字不匹配，你使用`raise`关键字并调用`Exception`类，传递一个自定义消息。
- en: 'Now, run the file and input “Houdini” when prompted. You should see this general
    output in the console (truncated for brevity):'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行文件并在提示时输入“Houdini”。你应该在控制台看到类似的输出（为简洁起见，这里截断了一部分）：
- en: '[PRE49]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'To force Python to raise one of its built-in exceptions, substitute the name
    of the built-in exception class (see [Table 7-4](ch07.xhtml#ch07tab4)) for the
    `Exception` class you used previously. In this example, we raise Python’s built-in
    `TypeError` exception:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 要强制Python抛出一个内置异常，替换你之前使用的`Exception`类，使用内置异常类的名称（参见[表7-4](ch07.xhtml#ch07tab4)）。在这个例子中，我们抛出Python内置的`TypeError`异常：
- en: '[PRE50]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: You can read more about `raise` at *[https://docs.python.org/3/tutorial/errors.html](https://docs.python.org/3/tutorial/errors.html)*.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在*[https://docs.python.org/3/tutorial/errors.html](https://docs.python.org/3/tutorial/errors.html)*上阅读更多关于`raise`的内容。
- en: '***Ignoring Errors***'
  id: totrans-223
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***忽略错误***'
- en: 'What if you want to ignore errors while looping? For example, suppose that
    you’ve used Python’s `None` keyword to define missing or null sample values in
    your dataset (`data`):'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在循环时忽略错误该怎么办？例如，假设你使用Python的`None`关键字来定义数据集中缺失或空的样本值（`data`）：
- en: '[PRE51]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'You don’t want to strip this placeholder out of the dataset, because it contains
    valuable information. It lets you know that the dataset is incomplete as well
    as the location of the missing data. But if you try to iterate over the data and
    do something to it such as divide each value by 2, the `None` value will raise
    a `TypeError` and crash the program:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 你不希望从数据集中剔除这个占位符，因为它包含了有价值的信息。它能告诉你数据集是不完整的，以及缺失数据的位置。但是，如果你尝试遍历数据并对其进行某些操作，比如将每个值除以2，`None`值会抛出`TypeError`并导致程序崩溃：
- en: '[PRE52]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We can combine multiple flow control elements to handle this missing data.
    Here, we use a `try` statement with an `except` clause within the `for` loop:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以结合多个流程控制元素来处理这些缺失数据。在这里，我们在`for`循环内使用了`try`语句和`except`子句：
- en: '[PRE53]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Now, the loop runs to completion and flags where data is missing.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，循环已完成执行并标记了缺失数据的位置。
- en: 'However, what if you want to completely skip over the missing data? For example,
    you want to pass the output to some other mathematical operation where the “missing
    data” values would interfere? In this case, use the `continue` statement, as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你想完全跳过缺失数据呢？例如，你想将输出传递给其他数学运算，而“缺失数据”值会干扰这些运算？在这种情况下，使用`continue`语句，如下所示：
- en: '[PRE54]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The loop now treats the missing value as if it doesn’t exist because it continues
    the loop when it encounters the value. Remember, `continue` immediately returns
    control to the beginning of a loop.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，循环会将缺失值当作不存在的情况处理，因为它遇到该值时会继续循环。记住，`continue`会立即将控制权返回到循环的起始位置。
- en: '**Tracing Execution with Logging**'
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**通过日志追踪执行**'
- en: To control the flow of your program, you need to know what it’s returning at
    key locations. One way to keep track of this is to use the `print()` function.
    This lets you print the output, the data type of a variable, or some other useful
    information about an important step.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 为了控制程序的流程，你需要知道程序在关键位置返回了什么。跟踪这个信息的一种方式是使用`print()`函数。这可以让你打印输出、变量的数据类型或其他关于某个重要步骤的有用信息。
- en: The `print()` function works well for small programs, but if you’re using it
    only to quality-control your code, it can come with a price. To unclutter your
    code and output, you might need to go back later and either delete all the lines
    containing `print()` or comment them out (by placing a `#` at the start of the
    line) so that they don’t run.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`print()`函数对于小型程序来说效果很好，但如果你只是用它来进行代码的质量控制，它可能会带来一些问题。为了简化代码和输出，你可能需要稍后删除所有包含`print()`的行，或者将它们注释掉（在行首加上`#`），以避免它们被执行。'
- en: For large programs, a better choice is to use the `logging` module. This module
    is part of the standard library that ships with Python, and it can provide a customized
    report on what your program is doing at any location you choose. Five *logging
    levels* let you categorize messages by importance. These are listed in [Table
    10-3](ch10.xhtml#ch010tab3).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大型程序，更好的选择是使用`logging`模块。这个模块是Python标准库的一部分，可以提供自定义报告，记录程序在你选择的任何位置所做的事情。五个*日志级别*可以让你按重要性对消息进行分类。它们在[表10-3](ch10.xhtml#ch010tab3)中列出。
- en: '**Table 10-3:** Python’s Logging Levels'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '**表10-3：** Python的日志级别'
- en: '| **Level** | **Function** | **Description** |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| **级别** | **功能** | **描述** |'
- en: '| --- | --- | --- |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| DEBUG | `logging.debug()` | Detailed information for diagnosing problems
    |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| DEBUG | `logging.debug()` | 诊断问题的详细信息 |'
- en: '| INFO | `logging.info()` | Confirmation that things are working as expected
    |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| INFO | `logging.info()` | 确认一切按预期正常工作 |'
- en: '| WARNING | `logging.warning()` | Unexpected event or potential future problem
    in working code |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| WARNING | `logging.warning()` | 工作代码中的意外事件或潜在的未来问题 |'
- en: '| ERROR | `logging.error()` | An error prevented the code from functioning
    as intended |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| ERROR | `logging.error()` | 错误阻止代码按预期功能运行 |'
- en: '| CRITICAL | `logging.critical()` | A serious error that may halt the program
    |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| CRITICAL | `logging.critical()` | 一个可能会导致程序停止的严重错误 |'
- en: 'Large programs that require logged messages are difficult to write in a console,
    so enter the following example in Spyder’s text editor and save it with a name
    like *logging.py*. This code uses `logging` to check that a vowel-counting program
    is working correctly:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记录日志的大型程序在控制台中编写较为困难，因此请将以下示例输入到 Spyder 的文本编辑器中，并保存为类似 *logging.py* 的文件名。此代码使用
    `logging` 检查一个元音计数程序是否正确运行：
- en: '[PRE55]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Save the file and press F5 (or click the **Run** button) to execute the code.
    You should see this general output:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件并按 F5（或点击 **运行** 按钮）执行代码。你应该看到以下通用输出：
- en: '[PRE56]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Let’s look at what you did. After importing the module, you used the `basicConfig()`
    method to set up and format the debugging information you wanted to see ➊. The
    `DEBUG` level is the lowest level of information and is used for diagnosing details.
    Adding a timestamp (`%(asctime)s`) is not necessary here, but it can become important
    when debugging long-running programs.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来看看你做了什么。在导入模块后，你使用 `basicConfig()` 方法设置并格式化了你想看到的调试信息 ➊。`DEBUG` 级别是最低的级别，用于诊断细节。添加时间戳（`%(asctime)s`）在这里不是必需的，但在调试长时间运行的程序时，它可能变得非常重要。
- en: After setting up the word to count, a constant for vowels, and a count variable,
    you started a `for` loop through the letters in the word and compared each to
    the contents of `VOWELS`. If the letter matched, you incremented the `num_vowels`
    counter by `1`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好要计数的单词、元音常量和计数变量后，你启动了一个 `for` 循环，遍历单词中的字母并将每个字母与 `VOWELS` 的内容进行比较。如果字母匹配，则将
    `num_vowels` 计数器加 `1`。
- en: For each letter evaluated, you used `logging.debug()` to enter the custom text
    message to display along with the current count ➋. The `logging` output displayed
    in the console. You can see the timestamp, the logging level, and the cumulative
    vowel count, along with which letters changed the count. In this case, only vowels
    change the count, so the program appears to be working as intended.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个评估的字母，你使用 `logging.debug()` 输入自定义文本消息，并显示当前计数 ➋。`logging` 输出会显示在控制台中。你可以看到时间戳、日志级别以及累积的元音计数，还可以看到哪些字母更改了计数。在这种情况下，只有元音字母会更改计数，所以程序看起来运行正常。
- en: 'You can redirect the logged messages to a permanent *text file* rather than
    displaying them on the screen. Just use the `filename` keyword in the `logging.basicConfig()`
    function, as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将日志消息重定向到一个永久的*文本文件*中，而不是在屏幕上显示。只需在 `logging.basicConfig()` 函数中使用 `filename`
    关键字，示例如下：
- en: '[PRE57]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: As written, this code will save the log file to the same folder as your Python
    file. To save it elsewhere, you’ll need to specify a path.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如代码所示，这段代码会将日志文件保存在与你的 Python 文件相同的文件夹中。若要将其保存在其他地方，你需要指定路径。
- en: 'Both the `print()` function and `logging` can slow down your program. It’s
    easier to disable the `logging` messages, however. With the `logging.disable()`
    function, you can turn off all the messages for a certain level with one line
    of code, as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`print()` 函数和 `logging` 都可能减慢程序的运行。然而，禁用 `logging` 消息更为简便。通过使用 `logging.disable()`
    函数，你可以用一行代码关闭某一级别的所有消息，示例如下：'
- en: '[PRE58]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Placing `logging.disable()` near the top of the program, just below the import
    statement, allows you to find it easily and toggle messages on and off by commenting
    them out with a hash mark, as follows:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `logging.disable()` 放在程序顶部、导入语句下方，可以轻松找到它并通过注释掉哈希标记来切换消息的开启和关闭，示例如下：
- en: '[PRE59]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The `logging.disable()` method will suppress all messages at the designated
    level and lower. Because `CRITICAL` is the highest level, you can use it to disable
    messages at every level. This is much easier than finding and deleting (or commenting-out)
    multiple calls to `print()`.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`logging.disable()` 方法将压制所有指定级别及更低级别的消息。由于 `CRITICAL` 是最高级别，因此你可以使用它来禁用所有级别的消息。这比找到并删除（或注释掉）多个
    `print()` 调用要容易得多。'
- en: For more details on the `logging` module, check out the documentation at *[https://docs.python.org/3/library/logging.html](https://docs.python.org/3/library/logging.html)*.
    For a basic tutorial, visit *[https://docs.python.org/3/howto/logging.html](https://docs.python.org/3/howto/logging.html)*.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多有关 `logging` 模块的详细信息，请查看文档 *[https://docs.python.org/3/library/logging.html](https://docs.python.org/3/library/logging.html)*。若要获取基本教程，请访问
    *[https://docs.python.org/3/howto/logging.html](https://docs.python.org/3/howto/logging.html)*。
- en: '**TEST YOUR KNOWLEDGE**'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试你的知识**'
- en: 6.  Write a code snippet that asks a user for a username and password. If the
    username is incorrect, keep asking until the user gets it right. If only the password
    is incorrect, keep asking for the correct password but don’t repeat the username
    request.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个代码片段，要求用户输入用户名和密码。如果用户名不正确，继续提示直到输入正确。如果只有密码不正确，继续提示输入正确的密码，但不再重复请求用户名。
- en: 7.  The `for` loop is just a concise version of a `while` loop. Write a `while`
    loop that behaves like a `for` loop and prints the word “Python” five times.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 循环只是 `while` 循环的简洁版本。写一个 `while` 循环，模拟 `for` 循环的行为，并打印出“Python”五次。'
- en: 8.  Use list comprehension to make a list of all the *even* numbers between
    1 and 10.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 使用列表推导式生成 1 到 10 之间的所有*偶数*。
- en: 9.  Use a `for` loop with the `range()` function to print a NASA-style countdown
    from 10 to 0.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `for` 循环和 `range()` 函数打印一个类似 NASA 风格的倒计时，从 10 到 0。
- en: '10.  A secret message is hidden at the center of each of the following words:
    “age,” “moody,” “knock,” “adder,” “project,” “stoop,” “blubber.” Use a `for` loop
    to find and print the message.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 一个隐藏的秘密信息位于以下单词的中心：“age”，“moody”，“knock”，“adder”，“project”，“stoop”，“blubber”。使用
    `for` 循环找到并打印出这个信息。
- en: 11.  Use the text editor to write a “guess my number” game that randomly chooses
    an integer between 1 and 100 (using `random.randint()`) and tells the player whether
    their answer is too high or too low until they guess correctly. Inform the player
    when they win and show them how many tries it took.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 使用文本编辑器编写一个“猜数字”游戏，程序随机选择一个介于 1 到 100 之间的整数（使用 `random.randint()`），并告诉玩家他们的猜测是太高还是太低，直到猜对为止。告知玩家他们获胜，并告诉他们猜了多少次。
- en: '12.  Use the text editor to write a “fortune cookie” program that presents
    the user with a menu of three options: Quit, Open a Fortune Cookie, or Open a
    Misfortune Cookie. Make a list of positive fortunes and a list of funny “misfortunes”
    and use the `random` module’s `choice()` function to randomly choose from each
    list. Print the results to the screen.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 使用文本编辑器编写一个“幸运饼干”程序，给用户提供三个选项：退出、打开幸运饼干或打开不幸饼干。列出正面的幸运语和幽默的“不幸”语句，并使用 `random`
    模块的 `choice()` 函数从每个列表中随机选择。将结果打印到屏幕上。
- en: '**Summary**'
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: The magic of programming lies in the ability of programs to make decisions during
    execution. These decisions are facilitated by conditions that evaluate to `True`
    or `False`. Using comparison and Boolean operators with *conditional statements*
    like `if`, `elif`, and `else`, you can control what your code does and when it
    does it.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 编程的魔力在于程序在执行过程中能够做出决策。这些决策通过评估为 `True` 或 `False` 的条件来实现。通过使用比较和布尔运算符与*条件语句*（如
    `if`、`elif` 和 `else`），你可以控制代码执行的内容和时机。
- en: '*Indentation* (whitespace) is used to segregate code into functionally similar
    segments, called *blocks*. Indentation levels let Python know when blocks start
    and end. This, in turn, helps you control the flow of execution through a program.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '*缩进*（空白字符）用于将代码分隔成功能相似的片段，称为 *代码块*。缩进级别告诉 Python 何时开始和结束代码块。这有助于你控制程序执行的流程。'
- en: A `while` loop causes code to execute over and over until a certain condition
    is met. The `for` loop, on the other hand, runs for a designated number of times
    or until it exhausts the items in a container data type, such as a list. Both
    types of loops can be manually interrupted with the `break` statement or forced
    to jump back to the start using the `continue` statement.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 循环会使代码重复执行，直到满足某个条件。而 `for` 循环则会执行指定次数，或者直到它耗尽容器数据类型中的项，例如列表。两种类型的循环都可以通过
    `break` 语句手动中断，或者使用 `continue` 语句强制跳回开始。'
- en: A `for` loop can be simplified into a single line of code using *comprehensions*.
    You can use these with lists, sets, and dictionaries. For simple expressions,
    comprehensions are not only more concise than `for` loops, they’re faster, as
    well.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 循环可以通过*推导式*简化为一行代码。你可以在列表、集合和字典中使用推导式。对于简单的表达式，推导式不仅比 `for` 循环更加简洁，而且速度更快。'
- en: Because errors can affect the flow of your code, Python provides `try` statements
    with `except` clauses to help you handle errors by suppressing them, fixing them,
    creating customized error messages, or getting a user to try again. To help you
    find and debug errors and other issues, Python provides the `logging` module.
    Compared to the `print()` function, `logging` is a more sophisticated and manageable
    way to monitor the flow of execution of large programs.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 因为错误可能会影响代码的流程，Python 提供了带有 `except` 子句的 `try` 语句，帮助你通过抑制错误、修复错误、创建自定义错误信息或让用户重试来处理错误。为了帮助你找到和调试错误以及其他问题，Python
    提供了 `logging` 模块。与 `print()` 函数相比，`logging` 是一种更复杂且易于管理的方式，适用于监控大型程序的执行流程。
- en: Another way to control flow is to write functions. We’ll look at these important
    “mini-programs” in the next chapter.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 控制流程的另一种方式是编写函数。我们将在下一章中学习这些重要的“迷你程序”。
