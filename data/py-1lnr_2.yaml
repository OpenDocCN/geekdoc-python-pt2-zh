- en: '**2'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**2'
- en: PYTHON TRICKS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: PYTHON 技巧**
- en: '![Image](Images/comm-1.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/comm-1.jpg)'
- en: 'For our purposes, a *trick* is a way of accomplishing a task in a surprisingly
    fast or easy manner. In this book, you’ll learn a wide variety of tricks and techniques
    to make your code more concise, while boosting your speed of implementation. While
    all technical chapters in this book show you Python tricks, this chapter addresses
    the low-hanging fruit: tricks you can adopt quickly and effortlessly, but with
    great effect on your coding productivity.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们来说，*技巧*是一种出人意料地快速或简便地完成任务的方法。在本书中，你将学习多种技巧和技术，使代码更加简洁，并提高实现的速度。虽然本书的所有技术章节都展示了
    Python 技巧，但这一章关注的是“低垂的果实”：你可以迅速而轻松地采纳的技巧，但对提高编码生产力有极大帮助。
- en: This chapter also serves as a stepping-stone for the more advanced chapters
    that follow. You need to understand the skills introduced in these one-liners
    to understand those that follow. Notably, we’ll cover a range of basic Python
    functionality to help you write effective code, including list comprehension,
    file access, the `map()` function, the `lambda` function, the `reduce()` function,
    slicing, slice assignments, generator functions, and the `zip()` function.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章也为后面更高级的章节奠定基础。你需要理解这些单行代码中介绍的技能，才能理解后续的内容。特别地，我们将涵盖一系列基本的 Python 功能，帮助你编写高效的代码，包括列表推导式、文件访问、`map()`
    函数、`lambda` 函数、`reduce()` 函数、切片、切片赋值、生成器函数以及 `zip()` 函数。
- en: If you’re already an advanced programmer, you could skim over this chapter and
    decide which individual parts you want to study in more depth—and which ones you
    already understand well.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经是一个高级程序员，可以快速浏览这一章，并选择你想要深入研究的部分——以及你已经掌握得很好的一些部分。
- en: '**Using List Comprehension to Find Top Earners**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用列表推导式查找高收入者**'
- en: 'In this section, you’ll learn a beautiful, powerful, and highly efficient Python
    feature to create lists: list comprehension. You’ll use list comprehension in
    many of the one-liners to come.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，你将学习到一个既优美又强大、高效的 Python 特性——列表推导式。你将在接下来的许多单行代码中使用列表推导式。
- en: '***The Basics***'
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基础知识***'
- en: 'Say you work in the human resources department of a large company and need
    to find all staff members who earn at least $100,000 per year. Your desired output
    is a list of tuples, each consisting of two values: the employee name and the
    employee’s yearly salary. Here’s the code you develop:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你在一家大公司的 HR 部门工作，需要找出所有年收入至少为 10 万美元的员工。你期望的输出结果是一个元组列表，每个元组包含两个值：员工姓名和员工的年薪。你可以开发出以下代码：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: While the code is correct, there’s an easier and much more concise—and therefore
    more readable—way of accomplishing the same result. All things being equal, the
    solution with *fewer lines* allows the reader to grasp the meaning of code faster.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然代码是正确的，但有一种更简单、更加简洁——因此也更易读——的方法可以实现相同的结果。其他条件相同的情况下，*行数更少*的解决方案能让读者更快地理解代码的含义。
- en: 'Python offers a powerful way of creating new lists: *list comprehension*. The
    simple formula is as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Python 提供了一种强大的创建新列表的方法：*列表推导式*。其简单的公式如下：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The enclosing brackets indicate that the result is a new list. The *context*
    defines which list elements to select. The *expression* defines how to modify
    each list element before adding the result to the list. Here’s an example:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 包围的括号表示结果是一个新的列表。*上下文*定义了选择哪些列表元素。*表达式*定义了如何在将结果添加到列表之前修改每个列表元素。下面是一个示例：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The bold part of the equation, **for x in range(3)**, is the context and the
    remaining part `x * 2`, is the expression. Roughly speaking, the expression doubles
    the values 0, 1, 2 generated by the context. Thus, the list comprehension results
    in the following list:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 方程中的粗体部分，**for x in range(3)**，是上下文，剩余部分 `x * 2` 是表达式。大致来说，表达式将上下文生成的 0、1、2
    的值翻倍。因此，列表推导式的结果是如下列表：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Both the expression and the context can be arbitrarily complicated. The expression
    may be a function of any variable defined in the context and may perform any computation—it
    can even call outside functions. The goal of the expression is to modify each
    list element before adding it to the new list.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式和上下文都可以是任意复杂的。表达式可以是上下文中定义的任何变量的函数，并且可以执行任何计算——它甚至可以调用外部函数。表达式的目标是修改每个列表元素，然后将其添加到新列表中。
- en: The context can consist of one or many variables defined using one or many nested
    `for` loops. You can also restrict the context by using `if` statements. In this
    case, a new value will be added to the list only if the user-defined condition
    holds.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文可以由一个或多个变量组成，这些变量是通过一个或多个嵌套的 `for` 循环定义的。你也可以通过使用 `if` 语句来限制上下文。在这种情况下，只有在用户定义的条件成立时，新的值才会被添加到列表中。
- en: 'List comprehension is best explained by example. Study the following examples
    carefully and you’ll get a good sense of list comprehension:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导式最好通过示例来解释。仔细研究以下示例，你将能更好地理解列表推导式：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**Expression** ➊: Identity function (does not change the context variable `x`).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**表达式** ➊：恒等函数（不改变上下文变量 `x`）。'
- en: '**Context** ➋: Context variable `x` takes all values returned by the range
    function: `0, 1, 2, 3, 4`.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**上下文** ➋：上下文变量 `x` 获取由范围函数返回的所有值：`0, 1, 2, 3, 4`。'
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**Expression** ➊: Create a new tuple from the context variables `x` and `y`.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**表达式** ➊：从上下文变量 `x` 和 `y` 创建一个新的元组。'
- en: '**Context** ➋: The context variable `x` iterates over all values returned by
    the range function (`0`, `1`, `2`), while context variable `y` iterates over all
    values returned by the range function (`0`, `1`, `2`). The two `for` loops are
    nested, so the context variable `y` repeats its iteration procedure for every
    single value of the context variable `x`. Thus, there are 3 × 3 = 9 combinations
    of context variables.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**上下文** ➋：上下文变量 `x` 遍历范围函数返回的所有值 (`0`、`1`、`2`)，而上下文变量 `y` 遍历范围函数返回的所有值 (`0`、`1`、`2`)。这两个
    `for` 循环是嵌套的，因此上下文变量 `y` 会对上下文变量 `x` 的每个值重复其迭代过程。因此，总共有 3 × 3 = 9 种上下文变量组合。'
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**Expression** ➊: Square function on the context variable `x`.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**表达式** ➊：对上下文变量 `x` 应用平方函数。'
- en: '**Context** ➋: Context variable `x` iterates over all values returned by the
    range function—`0`, `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9`—but only if they
    are odd values; that is, `x % 2 > 0`.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**上下文** ➋：上下文变量 `x` 遍历范围函数返回的所有值——`0`、`1`、`2`、`3`、`4`、`5`、`6`、`7`、`8`、`9`——但仅当它们是奇数时，即
    `x % 2 > 0`。'
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '**Expression** ➊: String lowercase function on context variable `x`.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**表达式** ➊：对上下文变量 `x` 应用字符串小写函数。'
- en: '**Context** ➋: Context variable `x` iterates over all string values in the
    list: `''I'', ''AM'', ''NOT'', ''SHOUTING''`.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**上下文** ➋：上下文变量 `x` 遍历列表中的所有字符串值：`''I''`、`''AM''`、`''NOT''`、`''SHOUTING''`。'
- en: Now, you should be able to understand the following code snippet.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该能够理解以下的代码片段。
- en: '***The Code***'
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: 'Let’s consider the same employee salary problem introduced earlier: given a
    dictionary with string keys and integer values, create a new list of (key, value)
    tuples so that the value associated with the key is larger than or equal to 100,000\.
    [Listing 2-1](#list2-1) shows the code.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑之前提到的员工薪水问题：给定一个包含字符串键和整数值的字典，创建一个新的 (key, value) 元组列表，其中键对应的值大于或等于 100,000。
    [示例 2-1](#list2-1) 展示了相关代码。
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 2-1: One-liner solution for list comprehension*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表推导式的单行解决方案：示例 2-1*'
- en: What’s the output of this code snippet?
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的输出是什么？
- en: '***How It Works***'
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***它是如何工作的***'
- en: 'Let’s examine the one-liner:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来分析这个单行代码：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '**Expression** ➊: Creates a simple (key, value) tuple for context variables
    `k` and `v`.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**表达式** ➊：为上下文变量 `k` 和 `v` 创建一个简单的 (key, value) 元组。'
- en: '**Context** ➋: The dictionary method `dict.items()` ensures that context variable
    `k` iterates over all dictionary keys and that context variable `v` iterates over
    the associated values for context variable `k`—but only if the value of context
    variable `v` is larger than or equal to 100,000 as ensured by the `if` condition.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**上下文** ➋：字典方法 `dict.items()` 确保上下文变量 `k` 遍历字典中的所有键，同时上下文变量 `v` 遍历与上下文变量 `k`
    关联的值——但仅在上下文变量 `v` 的值大于或等于 100,000 时，这一点通过 `if` 条件得到确保。'
- en: 'The result of the one-liner is as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 单行代码的结果如下：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This simple one-liner program introduces the important concept of *list* *comprehension*.
    We use list comprehension in multiple instances in this book, so make sure that
    you understand the examples in this section before moving on.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的单行程序介绍了一个重要的概念——*列表推导式*。在本书的多个实例中，我们使用了列表推导式，因此在继续阅读之前，请确保理解本节中的示例。
- en: '**Using List Comprehension to Find Words with High Information Value**'
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用列表推导式查找高信息量的词语**'
- en: In this one-liner, you’ll dive even deeper into the powerful feature of list
    comprehension.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个单行代码中，你将更深入地探讨列表推导式的强大功能。
- en: '***The Basics***'
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基础概念***'
- en: Search engines rank textual information according to its relevance to a user
    query. To accomplish this, search engines analyze the content of the text to be
    searched. All text consists of words. Some words provide a lot of information
    about the content of the text—and others don’t. Examples for the former are words
    like *white*, *whale*, *Captain*, *Ahab* (Do you know the text?). Examples for
    the latter are words like *is*, *to*, *as*, *the*, *a*, or *how*, because most
    texts contain those words. Filtering out words that don’t contribute a lot of
    meaning is common practice when implementing search engines. A simple heuristic
    is to filter out all words with three characters or less.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索引擎根据文本信息与用户查询的相关性来对文本进行排名。为此，搜索引擎分析要搜索的文本内容。所有文本都由单词组成。某些单词能提供大量关于文本内容的信息，而其他单词则没有。例如，前者的单词包括*white*、*whale*、*Captain*、*Ahab*（你知道这段文本吗？）。后者的单词包括*is*、*to*、*as*、*the*、*a*或*how*，因为大多数文本都包含这些单词。过滤掉那些对意义贡献不大的单词是实现搜索引擎时的常见做法。一种简单的启发式方法是过滤掉所有字符数为三个或更少的单词。
- en: '***The Code***'
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: 'Our goal is to solve the following problem: given a multiline string, create
    a list of lists—each consisting of all the words in a line that have more than
    three characters. [Listing 2-2](#list2-2) provides the data and the solution.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是解决以下问题：给定一个多行字符串，创建一个由多个列表组成的列表——每个列表包含该行中所有字符数大于三的单词。[清单 2-2](#list2-2)提供了数据和解决方案。
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 2-2: One-liner solution to find words with high information value*'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-2：一行解决方案，用于查找具有高信息量的单词*'
- en: What’s the output of this code?
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的输出是什么？
- en: '***How It Works***'
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***工作原理***'
- en: 'The one-liner creates a list of lists by using two nested list comprehension
    expressions:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码通过使用两个嵌套的列表推导式，创建了一个由多个列表组成的列表：
- en: The inner list comprehension expression `[x for x in line.split() if len(x)>3]`
    uses the string `split()` function to divide a given line into a sequence of words.
    We iterate over all words `x` and add them to the list if they have more than
    three characters.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内层列表推导式`[x for x in line.split() if len(x)>3]`使用字符串的`split()`函数将给定行分割成一系列单词。我们遍历所有单词`x`，如果它们的字符数大于三，就将它们添加到列表中。
- en: The outer list comprehension expression creates the string `line` used in the
    previous statement. Again, it uses the `split()` function to divide the text on
    the newline characters `'\n'`.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外层列表推导式创建了之前语句中使用的字符串`line`。同样，它使用`split()`函数根据换行符`'\n'`将文本分割开来。
- en: Of course, you need to get used to thinking in terms of list comprehensions,
    so the meaning may not come naturally to you. But after reading this book, list
    comprehensions will be your bread and butter—and you’ll quickly read and write
    Pythonic code like this.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您需要习惯以列表推导式的方式思考，因此其含义可能对您来说并不直观。但是在读完本书后，列表推导式将成为您的基本工具——您会很快像这样阅读和编写符合
    Python 风格的代码。
- en: '**Reading a File**'
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**读取文件**'
- en: In this section, you’ll read a file and store the result as a list of strings
    (one string per line). You’ll also remove any leading and trailing whitespaces
    from the lines.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将读取一个文件并将结果存储为一个字符串列表（每行一个字符串）。您还将删除行首和行尾的空白字符。
- en: '***The Basics***'
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基础知识***'
- en: 'In Python, reading a file is straightforward but usually takes a few lines
    of code (and one or two Google searches) to accomplish. Here’s one standard way
    of reading a file in Python:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，读取文件非常简单，但通常需要几行代码（以及一两次 Google 搜索）才能完成。以下是 Python 中读取文件的一种标准方式：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The code assumes that you’ve stored this code snippet in a file named *readFileDefault.py*
    in a folder. The code then opens this file, creates an empty list, `lines`, and
    fills the list with strings by using the `append()` operation in the `for` loop
    body to iterate over all the lines in the file. You also use the string method
    `strip()` to remove any leading or trailing whitespace (otherwise, the newline
    character `'\n'` would appear in the strings).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 代码假设您已经将这段代码片段存储在名为*readFileDefault.py*的文件中，并且该文件位于某个文件夹中。代码接着打开该文件，创建一个空列表`lines`，并通过在`for`循环体中使用`append()`操作遍历文件中的所有行，将字符串添加到列表中。您还使用了字符串方法`strip()`来移除任何行首或行尾的空白字符（否则换行符`'\n'`将出现在字符串中）。
- en: 'To access files on your computer, you need to know how to open and close files.
    You can access a file’s data only after you’ve opened it. After closing the file,
    you can be sure that the data was written into the file. Python may create a buffer
    and wait for a while before it writes the whole buffer into the file ([Figure
    2-1](#ch02fig01)). The reason for this is simple: file access is slow. For efficiency
    reasons, Python avoids writing every single bit independently. Instead, it waits
    until the buffer has filled with enough bytes and then flushes the whole buffer
    at once into the file.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问你计算机上的文件，你需要知道如何打开和关闭文件。只有在打开文件后，你才能访问文件的数据。关闭文件后，你可以确定数据已经写入文件。Python 可能会创建一个缓冲区，并等待一段时间，才将整个缓冲区的数据写入文件中（[图
    2-1](#ch02fig01)）。原因很简单：文件访问速度较慢。为了提高效率，Python 避免每次单独写入每一个字节，而是等待直到缓冲区填充足够的字节，再一次性将整个缓冲区写入文件。
- en: '![images](Images/fig2-1.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![images](Images/fig2-1.jpg)'
- en: '*Figure 2-1: Opening and closing a file in Python*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-1：在 Python 中打开和关闭文件*'
- en: 'That’s why it’s good practice to close the file after reading it with the command
    `f.close()`, to ensure all the data is properly written into the file instead
    of residing in temporary memory. However, in a few exceptions, Python closes the
    file automatically: one of these exceptions occurs when the reference count drops
    to zero, as you’ll see in the following code.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么在读取文件后最好使用命令`f.close()`关闭文件，以确保所有数据正确写入文件，而不是停留在临时内存中。不过，Python 在一些特殊情况下会自动关闭文件：其中一个例外是当引用计数降为零时，正如你将在以下代码中看到的。
- en: '***The Code***'
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: Our goal is to open a file, read all lines, strip the leading and trailing whitespace
    characters, and store the result in a list. [Listing 2-3](#list2-3) provides the
    one-liner.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是打开一个文件，读取所有行，去除前后空格字符，并将结果存储在一个列表中。[清单 2-3](#list2-3) 提供了这行代码。
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 2-3: One-liner solution to read a file line by line.*'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-3：逐行读取文件的单行解决方案。*'
- en: Go ahead and guess the output of this code snippet before reading on.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续阅读之前，不妨先猜猜这个代码片段的输出是什么。
- en: '***How It Works***'
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***工作原理***'
- en: You use the `print()` statement to print the resulting list to the shell. You
    create the list by using list comprehension (see [“Using List Comprehension to
    Find Top Earners”](#lev-24) on [page 18](#page_18)). In the *expression* part
    of the list comprehension, you use the `strip()` method of string objects.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用 `print()` 语句将结果列表打印到命令行。你通过使用列表推导式来创建该列表（请参见 [“使用列表推导式查找收入最高的人”](#lev-24)
    在 [第 18 页](#page_18)）。在列表推导式的*表达式*部分，你使用字符串对象的 `strip()` 方法。
- en: The *context* part of the list comprehension iterates over all lines in the
    file.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导式的*上下文*部分会遍历文件中的所有行。
- en: 'The output of the one-liner is simply the one-liner itself (because it reads
    its Python source code file with the name *readFile.py*), wrapped into a string
    and filled into a list:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一行代码的输出就是这行代码本身（因为它读取了名为*readFile.py*的 Python 源代码文件），并将其包装成字符串，填入一个列表中：
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This section demonstrates that by making code shorter and more concise, you
    make it more readable without compromising efficiency.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 本节展示了通过让代码更简洁、精炼，可以在不牺牲效率的情况下提高可读性。
- en: '**Using Lambda and Map Functions**'
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用 Lambda 和 Map 函数**'
- en: 'This section introduces two important Python features: the `lambda` and `map()`
    functions. Both functions are valuable tools in your Python toolbox. You’ll use
    these functions to search a list of strings for occurrences of another string.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了两个重要的 Python 特性：`lambda` 和 `map()` 函数。这两个函数是你 Python 工具箱中的宝贵工具。你将使用这些函数在一个字符串列表中查找另一个字符串的出现。
- en: '***The Basics***'
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基础知识***'
- en: In [Chapter 1](ch01.xhtml#ch01), you learned how to define a new function with
    the expression `def` `x`, followed by the content of the function. However, this
    is not the only way of defining a function in Python. You can also use *lambda
    functions* to define a simple function *with a return value* (the return value
    can be any object, including tuples, lists, and sets). In other words, every lambda
    function returns an object value to its calling environment. Note that this poses
    a practical restriction to lambda functions, because unlike standard functions,
    they are not designed to execute code *without* returning an object value to the
    calling environment.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.xhtml#ch01)中，你学习了如何使用`def`关键字定义一个新函数，后跟函数的内容。然而，这并不是在Python中定义函数的唯一方式。你还可以使用*lambda函数*定义一个简单的*具有返回值*的函数（返回值可以是任何对象，包括元组、列表和集合）。换句话说，每个lambda函数都会向其调用环境返回一个对象值。需要注意的是，这给lambda函数带来了实际的限制，因为与标准函数不同，lambda函数并不设计用来执行*没有*返回对象值的代码。
- en: '**NOTE**'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*We already covered lambda functions in [Chapter 1](ch01.xhtml#ch01), but because
    it’s such an important concept used throughout this book, we’ll take a deeper
    look in this section.*'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们在[第1章](ch01.xhtml#ch01)中已经介绍了lambda函数，但由于它是本书中贯穿始终的重要概念，我们将在本节深入探讨。*'
- en: 'Lambda functions allow you to define a new function in a single line by using
    the keyword `lambda`. This is useful when you want to quickly create a function
    that you’ll use only once and can be garbage-collected immediately afterward.
    Let’s first study the exact syntax of lambda functions:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: lambda函数允许你通过使用关键字`lambda`在一行中定义一个新函数。这在你需要快速创建一个只会使用一次并且可以立即进行垃圾回收的函数时非常有用。我们首先来研究lambda函数的具体语法：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You start the function definition with the keyword `lambda`, followed by a
    sequence of function arguments. When calling the function, the caller must provide
    these arguments. You then include a colon (`:`) and the *return expression*, which
    calculates the return value based on the arguments of the lambda function. The
    return expression calculates the function output and can be any Python expression.
    Consider the following function definition as an example:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你以关键字`lambda`开始定义函数，后跟一系列函数参数。在调用该函数时，调用者必须提供这些参数。然后，你在函数定义中包含一个冒号（`:`）和*返回表达式*，该表达式根据lambda函数的参数计算返回值。返回表达式计算函数的输出，并且可以是任何Python表达式。以下是一个函数定义的示例：
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The lambda function has two arguments, `x` and `y`. The return value is simply
    the sum of both arguments, `x + y`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个lambda函数有两个参数，`x`和`y`。返回值就是这两个参数的和，`x + y`。
- en: You typically use a lambda function when you call the function only once and
    can easily define it in a single line of code. One common example is using lambda
    with the `map()` function that takes as input arguments a function object `f`
    and a sequence `s`. The `map()` function then applies the function `f` on each
    element in the sequence `s`. Of course, you *could* define a full-fledged named
    function to define the function argument `f`. But this is often inconvenient and
    reduces readability—especially if the function is short and you need it only once—so
    it’s usually best to use a lambda function here.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 通常在你只会调用一次函数，并且可以在一行代码中轻松定义它时，才会使用lambda函数。一个常见的例子是将lambda与`map()`函数一起使用，`map()`函数的输入参数是一个函数对象`f`和一个序列`s`。然后，`map()`函数将在序列`s`中的每个元素上应用函数`f`。当然，你*可以*定义一个完整的命名函数来定义函数参数`f`，但这样做通常不方便，并且会降低可读性——特别是当函数很短且只需要使用一次时——因此，通常最好在这里使用lambda函数。
- en: 'Before presenting the one-liner, I’ll quickly introduce another small Python
    trick that makes your life easier: checking whether string `x` contains substring
    `y` by using the expression `y in x`. This statement returns `True` if there exists
    at least one occurrence of the string `y` in the string `x`. For example, the
    expression `''42'' in ''The answer is 42''` evaluates to `True`, while the expression
    `''21'' in ''The answer is 42''` evaluates to `False`.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在展示单行代码之前，我将简要介绍另一个小的Python技巧，帮助你更轻松地处理问题：通过使用表达式`y in x`来检查字符串`x`是否包含子字符串`y`。如果字符串`x`中至少有一个`y`，该表达式将返回`True`。例如，表达式`'42'
    in 'The answer is 42'`的结果为`True`，而表达式`'21' in 'The answer is 42'`的结果为`False`。
- en: Now let’s look at our one-liner.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下我们的单行代码。
- en: '***The Code***'
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: When given a list of strings, our next one-liner ([Listing 2-4](#list2-4)) creates
    a new list of tuples, each consisting of a Boolean value and the original string.
    The Boolean value indicates whether the string `'anonymous'` appears in the original
    string! We call the resulting list `mark` because the Boolean values *mark* the
    string elements in the list that contain the string `'anonymous'`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个字符串列表，接下来的单行代码（[Listing 2-4](#list2-4)）将创建一个包含布尔值和原始字符串的元组的新列表。布尔值表示字符串
    `'anonymous'` 是否出现在原始字符串中！我们将结果列表命名为 `mark`，因为布尔值 *标记* 了列表中包含字符串 `'anonymous'`
    的元素。
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 2-4: One-liner solution to mark strings that contain the string `''anonymous''`*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 2-4：标记包含字符串 `''anonymous''` 的字符串的单行解决方案*'
- en: What’s the output of this code?
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的输出是什么？
- en: '***How It Works***'
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***工作原理***'
- en: The `map()` function adds a Boolean value to each string element in the original
    `txt` list. This Boolean value is `True` if the string element contains the word
    *anonymous*. The first argument is the anonymous lambda function, and the second
    is a list of strings you want to check for the desired string.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`map()` 函数将布尔值添加到原始 `txt` 列表中的每个字符串元素。如果字符串元素包含单词 *anonymous*，则布尔值为 `True`。第一个参数是匿名的
    lambda 函数，第二个参数是你想检查的字符串列表。'
- en: You use the lambda return expression `(True, s) if 'anonymous' in s else (False,
    s)` to search for the `'anonymous'` string. The value `s` is the input argument
    of the lambda function, which, in this example, is a string. If the string query
    `'anonymous'` exists in the string, the expression returns the tuple `(True, s)`.
    Otherwise, it returns the tuple `(False, s)`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用 lambda 返回表达式 `(True, s) if 'anonymous' in s else (False, s)` 来查找字符串 `'anonymous'`。值
    `s` 是 lambda 函数的输入参数，在此例中是一个字符串。如果查询的字符串 `'anonymous'` 存在于该字符串中，表达式将返回元组 `(True,
    s)`。否则，返回元组 `(False, s)`。
- en: 'The result of the one-liner is the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 单行代码的结果如下：
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The Boolean values indicate that only the first two strings in the list contain
    the substring `'anonymous'`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值表明列表中只有前两个字符串包含子字符串 `'anonymous'`。
- en: 'You’ll find lambdas incredibly useful in the upcoming one-liners. You’re also
    making consistent progress toward your goal: understanding every single line of
    Python code you’ll encounter in practice.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的单行代码中，你会发现 lambda 表达式非常有用。你也在不断向目标前进：理解你在实践中遇到的每一行 Python 代码。
- en: '**EXERCISE 2-1**'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 2-1**'
- en: Use list comprehension rather than the `map`() function to accomplish the same
    output. (You can find the solution at the end of this chapter.)
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 使用列表推导式而不是 `map()` 函数来实现相同的输出。（你可以在本章末尾找到解决方案。）
- en: '**Using Slicing to Extract Matching Substring Environments**'
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用切片提取匹配的子字符串环境**'
- en: This section teaches you the important basic concept of *slicing*—the process
    of carving out a subsequence from an original full sequence—to process simple
    text queries. We’ll search some text for a specific string, and then extract that
    string along with a handful of characters around it to give us context.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讲解了 *切片* 的重要基础概念——从原始完整序列中提取子序列的过程——用于处理简单的文本查询。我们将搜索文本中的特定字符串，然后提取该字符串及其周围的一些字符，以提供上下文。
- en: '***The Basics***'
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基础知识***'
- en: Slicing is integral to a vast number of Python concepts and skills, both advanced
    and basic, such as when using any of Python’s built-in data structures like lists,
    tuples, and strings. Slicing is also the basis of many advanced Python libraries
    such as NumPy, Pandas, TensorFlow, and scikit-learn. Studying slicing thoroughly
    will have a positive ripple effect throughout your career as a Python coder.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 切片是许多 Python 概念和技能的核心，无论是高级还是基础的，譬如在使用 Python 内置的数据结构（如列表、元组和字符串）时。切片也是许多高级
    Python 库（如 NumPy、Pandas、TensorFlow 和 scikit-learn）的基础。深入学习切片将对你作为 Python 编程人员的职业生涯产生积极的连锁反应。
- en: 'Slicing carves out subsequences of a sequence, such as a part of a string.
    The syntax is straightforward. Say you have a variable `x` that refers to a string,
    list, or tuple. You can carve out a subsequence by using the following notation:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 切片从序列中提取子序列，例如提取字符串的一部分。语法非常简单。假设你有一个变量 `x`，它引用了一个字符串、列表或元组。你可以使用以下符号来提取子序列：
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The resulting subsequence starts at index `start` (included) and ends at index
    `stop` (excluded). You can include an optional third `step` argument that determines
    which elements are carved out, so you could choose to include just every `step`-th
    element. For example, the slicing operation `x[1:4:1]` used on variable `x = 'hello
    world'` results in the string `'ell'`. Slicing operation `x[1:4:2]` on the same
    variable results in string `'el'` because only every other element is taken into
    the resulting slice. Recall from [Chapter 1](ch01.xhtml#ch01) that the first element
    of any sequence type, such as strings and lists, has index 0 in Python.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 结果子序列从索引 `start`（包含）开始，到索引 `stop`（不包含）结束。你可以包含一个可选的第三个 `step` 参数，用于确定提取哪些元素，因此你可以选择仅包括每隔
    `step` 个元素。例如，对变量 `x = 'hello world'` 使用切片操作 `x[1:4:1]`，结果为字符串 `'ell'`。对同一变量使用切片操作
    `x[1:4:2]`，结果为字符串 `'el'`，因为每隔一个元素才会被包含到结果切片中。回顾 [第 1 章](ch01.xhtml#ch01)，在 Python
    中，任何序列类型（如字符串和列表）的第一个元素的索引是 0。
- en: If you don’t include the `step` argument, Python assumes the default step size
    of one. For example, the slice call `x[1:4]` would result in the string `'ell'`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不包含 `step` 参数，Python 会假定步长默认为 1。例如，切片调用 `x[1:4]` 将返回字符串 `'ell'`。
- en: If you don’t include the beginning or ending arguments, Python assumes you want
    to start at the start, or end at the end. For example, the slice call `x[:4]`
    would result in the string `'hell'`, and the slice call `x[4:]` would result in
    the string `'o world'`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不包含起始或结束参数，Python 假定你希望从开始处切片，或从结束处切片。例如，切片调用 `x[:4]` 将返回字符串 `'hell'`，而切片调用
    `x[4:]` 将返回字符串 `'o world'`。
- en: Study the following examples to improve your intuitive understanding even further.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 研究以下示例，以进一步提升你的直观理解。
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'These variants of the basic `[start:stop:step]` pattern of Python slicing highlight
    the technique’s many interesting properties:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 Python 切片基本的 `[start:stop:step]` 模式的变种突出了该技巧的许多有趣属性：
- en: If `start` >= `stop` with a positive `step` size, the slice is empty ➊.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `start` >= `stop` 且 `step` 为正数，则切片为空 ➊。
- en: If the `stop` argument is larger than the sequence length, Python will slice
    all the way to and including the rightmost element ➋.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `stop` 参数大于序列长度，Python 将切片到并包含最右边的元素 ➋。
- en: If the `step` size is positive, the default start is the leftmost element, and
    the default stop is the rightmost element (included) ➌.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `step` 大小为正，默认的起始位置是最左边的元素，默认的结束位置是最右边的元素（包含） ➌。
- en: If the `step` size is negative (`step` < 0), the slice traverses the sequence
    in reverse order. With empty start and stop arguments, you slice from the rightmost
    element (included) to the leftmost element (included) ➍. Note that if the stop
    argument is given, the respective position is excluded from the slice.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `step` 大小为负（`step` < 0），切片将按反向顺序遍历序列。在没有指定起始和结束参数的情况下，你将从最右侧的元素（包含）切片到最左侧的元素（包含）➍。注意，如果给定了
    `stop` 参数，相应的位置将被排除在切片之外。
- en: Next, you’ll use slicing along with the `string.find(value)` method to find
    the index of string argument `value` in a given string.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将使用切片和 `string.find(value)` 方法来查找给定字符串中 `value` 的索引位置。
- en: '***The Code***'
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: Our goal is to find a particular text query within a multiline string. You want
    to find the query in the text and return its immediate environment, up to 18 positions
    around the found query. Extracting the environment as well as the query is useful
    for seeing the textual context of the found string—just as Google presents text
    snippets around a searched keyword. In [Listing 2-5](#list2-5), you’re looking
    for the string `'SQL'` in an Amazon letter to shareholders—with the immediate
    environment of up to 18 positions around the string `'SQL'`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是在一个多行字符串中查找特定的文本查询。你希望在文本中找到查询内容，并返回其即时环境，最多包括查询前后 18 个位置。提取环境以及查询本身有助于看到找到的字符串的文本上下文——就像
    Google 在搜索关键词时展示的文本片段。在 [示例 2-5](#list2-5) 中，你要在亚马逊致股东的信中查找字符串 `'SQL'`，并返回该字符串前后最多
    18 个字符的环境。
- en: '[PRE21]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 2-5: One-liner solution to find strings in a text and their direct
    environment*'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 2-5：在文本中查找字符串及其直接环境的单行解决方案*'
- en: Take a guess at the output of this code.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 猜一猜这段代码的输出。
- en: '***How It Works***'
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***工作原理***'
- en: 'You define a lambda function with two arguments: a string value `x`, and a
    query `q` to search for in the text. You assign the lambda function to the name
    `find`. The function `find(x, q)` finds the string query `q` in the string text
    `x`.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你定义了一个包含两个参数的lambda函数：一个字符串值`x`，和一个查询`q`，用于在文本中查找。你将lambda函数赋值给名称`find`。函数`find(x,
    q)`在字符串文本`x`中查找字符串查询`q`。
- en: 'If the query `q` does not appear in the string `x`, you directly return the
    result `-1`. Otherwise, you use slicing on the text string to carve out the first
    occurrence of the query, plus 18 characters to the left of the query and 18 characters
    to the right, to capture the query’s environment. You find that the index of the
    first occurrence of `q` in `x` is using the string function `x.find(q)`. You call
    the function twice: to help determine the start index and the stop index of the
    slice, but both function calls return the same value because both the query `q`
    and the string `x` do not change. Although this code works perfectly fine, the
    redundant function call causes unnecessary computations—a disadvantage that could
    easily be fixed by adding a helper variable to temporarily store the result of
    the first function call. You could then reuse the result from the first function
    call by accessing the value in the helper variable.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果查询`q`没有出现在字符串`x`中，你直接返回结果`-1`。否则，你使用切片操作在文本字符串上切出查询第一次出现的部分，并在查询左侧和右侧各加上18个字符，以捕捉查询的上下文。你发现`q`在`x`中的第一次出现的索引是通过字符串函数`x.find(q)`来找到的。你调用该函数两次：一次用于确定切片的起始索引，另一次用于确定结束索引，但这两次函数调用返回相同的值，因为查询`q`和字符串`x`都没有发生变化。虽然这段代码完全正常工作，但冗余的函数调用导致了不必要的计算——这是一个可以通过添加一个辅助变量来暂时存储第一次函数调用结果并重用的缺点。
- en: 'This discussion highlights an important trade-off: by restricting yourself
    to one line of code, you cannot define and reuse a helper variable to store the
    index of the first occurrence of the query. Instead, you must execute the same
    function `find` to compute the start index (and decrement the result by 18 index
    positions) and to compute the end index (and increment the result by 18 index
    positions). In [Chapter 5](ch05.xhtml#ch05), you’ll learn a more efficient way
    of searching patterns in strings (using regular expressions) that resolves this
    issue.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 本讨论突出了一个重要的折中：通过将自己限制为一行代码，你不能定义和重用一个辅助变量来存储查询的第一次出现的索引。相反，你必须执行相同的`find`函数来计算起始索引（并将结果减去18个索引位置），并计算结束索引（并将结果加上18个索引位置）。在[第5章](ch05.xhtml#ch05)，你将学习一种更高效的字符串模式搜索方法（使用正则表达式），解决这个问题。
- en: 'When searching for the query `''SQL''` in Amazon’s letter to shareholders,
    you find an occurrence of the query in the text:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在搜索亚马逊给股东的信中查询`'SQL'`时，你会在文本中找到查询的一个出现：
- en: '[PRE22]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As a result, you get the string and a few words around it to provide context
    for the find. Slicing is a crucial element of your basic Python education. Let’s
    deepen your understanding even more with another slicing one-liner.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 结果，你得到字符串及其周围的几个单词，以提供查找的上下文。切片是你基础Python学习中的一个关键元素。让我们通过另一个切片单行代码来进一步加深你的理解。
- en: '**Combining List Comprehension and Slicing**'
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**结合列表推导式和切片**'
- en: This section combines list comprehension and slicing to sample a two-dimensional
    data set. We aim to create a smaller but representative sample of data from a
    prohibitively large sample.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 本节结合了列表推导式和切片，用于从一个二维数据集中采样。我们的目标是从一个庞大的样本中创建一个更小但具有代表性的样本。
- en: '***The Basics***'
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基础知识***'
- en: Say you work as a financial analyst for a large bank and are training a new
    machine learning model for stock-price forecasting. You have a training data set
    of real-world stock prices. However, the data set is huge, and the model training
    seems to take forever on your computer. For example, it’s common in machine learning
    to test the prediction accuracy of your model for different sets of model parameters.
    In our application, say, you must wait for hours until the training program terminates
    (training highly complex models on large-scale data sets does in fact take hours).
    To speed things up, you reduce the data set by half by excluding every other stock-price
    data point. You don’t expect this modification to decrease the model’s accuracy
    significantly.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你在一家大银行担任金融分析师，并正在为股票价格预测训练一个新的机器学习模型。你拥有一个真实世界股票价格的训练数据集。然而，数据集非常庞大，模型训练在你的电脑上似乎永远也训练不完。例如，在机器学习中，通常需要测试不同模型参数集的预测准确度。在我们的应用中，假设你必须等上好几个小时，直到训练程序结束（在大规模数据集上训练高度复杂的模型实际上确实需要几个小时）。为了加快速度，你通过排除每隔一个的股票价格数据点将数据集减半。你并不期望这种修改会显著降低模型的准确性。
- en: 'In this section, you’ll use two Python features you learned about previously
    in this chapter: list comprehension and slicing. List comprehension allows you
    to iterate over each list element and modify it subsequently. Slicing allows you
    to select every other element from a given list quickly—and it lends itself naturally
    to simple filtering operations. Let’s have a detailed look at how these two features
    can be used in combination.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中，你将使用本章前面学习过的两个 Python 特性：列表推导式和切片。列表推导式允许你遍历每个列表元素并随后修改它。切片允许你快速选择给定列表中的每隔一个元素——它自然适用于简单的过滤操作。让我们详细看看这两个特性如何结合使用。
- en: '***The Code***'
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: Our goal is to create a new training data sample from our data—a list of lists,
    each consisting of six floats—by including only every other float value from the
    original data set. Take a look at [Listing 2-6](#list2-6).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是从数据中创建一个新的训练数据样本——一个由六个浮动值组成的列表的列表——只包括原始数据集中每隔一个的浮动值。请查看[清单 2-6](#list2-6)。
- en: '[PRE23]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 2-6: One-liner solution to sample data*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-6：单行代码解决方案来抽样数据*'
- en: As usual, see if you can guess the output.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，看看你能否猜出输出结果。
- en: '***How It Works***'
  id: totrans-149
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***它是如何工作的***'
- en: 'Our solution is a two-step approach. First, you use list comprehension to iterate
    over all lines of the original list, `price`. Second, you create a new list of
    floats by slicing each line; you use `line[start:stop:step]` with default start
    and stop parameters and step size `2`. The new list of floats consists of only
    three (instead of six) floats, resulting in the following array:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的解决方案是一个两步法。首先，你使用列表推导式遍历原始列表`price`的所有行。第二，你通过切片每一行来创建一个新的浮动值列表；你使用`line[start:stop:step]`，其中
    start 和 stop 使用默认参数，步长为`2`。新的浮动值列表仅包含三个（而不是六个）浮动值，结果是以下数组：
- en: '[PRE24]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This one-liner using built-in Python functionality is not complicated. However,
    you’ll learn about an even shorter version that uses the NumPy library for data
    science computations in [Chapter 3](ch03.xhtml#ch03).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这个使用内置 Python 功能的一行代码并不复杂。然而，你将在[第 3 章](ch03.xhtml#ch03)中了解一个更简短的版本，它使用 NumPy
    库进行数据科学计算。
- en: '**EXERCISE 2-2**'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 2-2**'
- en: 'Revisit this one-liner after studying [Chapter 3](ch03.xhtml#ch03) and come
    up with a more concise one-liner solution using the NumPy library. Hint: Use NumPy’s
    more powerful slicing capabilities.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习完[第 3 章](ch03.xhtml#ch03)后，重新审视这一行代码，并用 NumPy 库来提出一个更简洁的解决方案。一点提示：使用 NumPy
    更强大的切片功能。
- en: '**Using Slice Assignment to Correct Corrupted Lists**'
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用切片赋值来修正损坏的列表**'
- en: 'This section shows you a powerful slicing feature in Python: slice assignments.
    *Slice assignments* use slicing notation *on the left-hand side* of an assignment
    operation to modify a subsequence of the original sequence.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 本节向你展示了 Python 中一个强大的切片功能：切片赋值。*切片赋值*在赋值操作的*左侧*使用切片符号来修改原始序列的子序列。
- en: '***The Basics***'
  id: totrans-157
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基础知识***'
- en: Imagine you work at a small internet startup that keeps track of its users’
    web browsers (Google Chrome, Firefox, Safari). You store the data in a database.
    To analyze the data, you load the gathered browser data into a large list of strings,
    but because of a bug in your tracking algorithm, every second string is corrupted
    and needs to be replaced by the correct string.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您在一家小型互联网创业公司工作，负责追踪用户的Web浏览器（如谷歌Chrome、Firefox、Safari）。您将数据存储在数据库中。为了分析数据，您将收集到的浏览器数据加载到一个包含大量字符串的列表中，但由于跟踪算法中的一个bug，每隔一个字符串会被损坏，需要替换为正确的字符串。
- en: 'Assume that your web server always redirects the first web request of a user
    to another URL (this is a common practice in web development known under the HTML
    code 301: *moved permanently*). You conclude that the first browser value will
    be equal to the second one in most cases because the browser of a user stays the
    same while waiting for the redirection to occur. This means that you can easily
    reproduce the original data. Essentially, you want to duplicate every other string
    in the list: the list `[''Firefox'', ''corrupted'', ''Chrome'', ''corrupted'']`
    becomes `[''Firefox'', ''Firefox'', ''Chrome'', ''Chrome'']`.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您的Web服务器总是将用户的第一次Web请求重定向到另一个URL（这在Web开发中是一种常见做法，称为HTML代码301：*永久移动*）。您得出结论，在大多数情况下，第一个浏览器值将等于第二个浏览器值，因为用户的浏览器在等待重定向发生时保持不变。这意味着您可以轻松地重现原始数据。实质上，您想要将列表中的每隔一个字符串复制一次：列表
    `['Firefox', 'corrupted', 'Chrome', 'corrupted']` 变成 `['Firefox', 'Firefox', 'Chrome',
    'Chrome']`。
- en: How can you achieve this in a fast, readable, and efficient way (preferably
    in a single line of code)? Your first idea is to create a new list, iterate over
    the corrupted list, and add every noncorrupted browser twice to the new list.
    But you reject the idea because you’d then have to maintain two lists in your
    code—and each may have millions of entries. Also, this solution would require
    a few lines of code, which would hurt conciseness and readability of your source
    code.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如何以快速、易读且高效的方式（最好是一行代码）实现这一点？您的第一个想法是创建一个新的列表，遍历损坏的列表，并将每个未损坏的浏览器字符串添加到新列表中两次。但您放弃了这个想法，因为那样您就得在代码中维护两个列表——而且每个列表可能有数百万个条目。此外，这种解决方案需要几行代码，会影响代码的简洁性和可读性。
- en: 'Luckily, you’ve read about a beautiful Python feature: slice assignments. You’ll
    use slice assignments to select and replace a *sequence of elements* between indices
    `i` and `j` by using the slicing notation `lst[i:j] = [0 0 ...0]`. Because you
    are using slicing `lst[i:j]` on the *left-hand side* of the assignment operation
    (rather than on the right-hand side as done previously), the feature is denoted
    as slice *assignments*.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，您已经读过一个很棒的Python特性：切片赋值。您将使用切片赋值来选择并替换索引 `i` 和 `j` 之间的*元素序列*，通过使用切片符号 `lst[i:j]
    = [0 0 ...0]`。因为您在赋值操作的*左侧*使用了切片 `lst[i:j]`（而不是之前在右侧使用），这个特性被称为切片*赋值*。
- en: 'The idea of slice assignments is simple: replace all selected elements in the
    original sequence on the left with the elements on the right.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 切片赋值的思路很简单：将原始序列中左侧选定的所有元素替换为右侧的元素。
- en: '***The Code***'
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: Our goal is to replace every other string with the string immediately in front
    of it; see [Listing 2-7](#list2-7).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是用它前面的字符串替换每个字符串；请参见 [列表 2-7](#list2-7)。
- en: '[PRE25]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 2-7: One-liner solution to replace all corrupted strings*'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-7：替换所有损坏字符串的单行解决方案*'
- en: What’s the fixed sequence of browsers in this code?
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码中的固定浏览器序列是什么？
- en: '***How It Works***'
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***它是如何工作的***'
- en: 'The one-liner solution replaces the `''corrupted''` strings with the browser
    strings that precede them in the list. You use the slice assignment notation to
    access every corrupted element in the `visitors` list. I’ve highlighted the selected
    elements in the following code snippet:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 单行解决方案将 `'corrupted'` 字符串替换为它们前面的浏览器字符串。您使用切片赋值符号来访问 `visitors` 列表中每个被损坏的元素。我在以下代码片段中高亮显示了选定的元素：
- en: '[PRE26]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The code replaces these selected elements with the slice on the right of the
    assignment operation. These elements are highlighted in the following code snippet:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 代码通过赋值操作右侧的切片来替换这些选定的元素。这些元素在以下代码片段中被高亮显示：
- en: '[PRE27]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The former elements are replaced by the latter. Therefore, the resulting `visitors`
    list is the following (highlighting the replaced elements):'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的元素被后面的元素替换。因此，结果 `visitors` 列表如下所示（高亮显示了被替换的元素）：
- en: '[PRE28]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The result is the original list with each `'corrupted'` string replaced by its
    preceding browser string. This way, you clean the corrupted data set.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，原始列表中的每个 `'corrupted'` 字符串都被其前一个浏览器字符串替换。这样，你就清理了受损的数据集。
- en: 'Using slice assignments for this problem is the quickest and most effective
    way of accomplishing your small task. Note that the cleaned data has nonbiased
    browser usage statistics: a browser with 70 percent market share in the corrupted
    data will maintain its 70 percent market share in the cleaned data. The cleaned
    data can then be used for further analysis—for example, to find out whether Safari
    users are better customers (after all, they tend to spend more money on hardware).
    You’ve learned a simple and concise way of modifying a list programmatically and
    in place.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 使用切片赋值来解决这个问题是完成你小任务最快、最有效的方法。请注意，清洗后的数据具有非偏倚的浏览器使用统计信息：在受损数据中占有 70% 市场份额的浏览器，在清洗后的数据中仍将保持
    70% 的市场份额。清洗后的数据可以用于进一步分析——例如，找出是否 Safari 用户是更好的客户（毕竟，他们往往在硬件上花费更多）。你已经学会了一种简单且简洁的方式来编程修改列表并且在原地进行修改。
- en: '**Analyzing Cardiac Health Data with List Concatenation**'
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用列表连接分析心脏健康数据**'
- en: In this section, you’ll learn how to use list concatenation to repeatedly copy
    smaller lists and merge them into a larger list to generate cyclic data.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何使用列表连接操作来反复复制较小的列表，并将它们合并成一个较大的列表，从而生成循环数据。
- en: '***The Basics***'
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基础知识***'
- en: This time, you’re working on a small code project for a hospital. Your goal
    is to monitor and visualize the health statistics of patients by tracking their
    cardiac cycles. By plotting expected cardiac cycle data, you’ll enable patients
    and doctors to monitor any deviation from that cycle. For example, given a series
    of measurements stored in the list `[62, 60, 62, 64, 68, 77, 80, 76, 71, 66, 61,
    60, 62]` for a single cardiac cycle, you want to achieve the visualization in
    [Figure 2-2](#ch02fig02).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，你正在为一家医院开发一个小型代码项目。你的目标是通过跟踪患者的心脏周期来监控和可视化患者的健康统计数据。通过绘制预期的心脏周期数据，你将帮助患者和医生监控心脏周期的任何偏差。例如，给定一个包含单次心脏周期的测量数据列表
    `[62, 60, 62, 64, 68, 77, 80, 76, 71, 66, 61, 60, 62]`，你希望在 [图 2-2](#ch02fig02)
    中实现该可视化效果。
- en: '![images](Images/fig2-2.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![images](Images/fig2-2.jpg)'
- en: '*Figure 2-2: Visualizing expected cardiac cycles by copying* selected *values
    from the measured data*'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-2：通过复制* 选定的 *测量数据中的值* 来可视化预期的心脏周期'
- en: 'The problem is that the first and the last two data values in the list are
    redundant: `[62, 60, 62, 64, 68, 77, 80, 76, 71, 66, 61, 60, 62]`. This may have
    been useful when plotting only a single cardiac cycle to indicate that one full
    cycle has been visualized. However, we must get rid of this redundant data to
    ensure that our expected cardiac cycles do not look like the ones in [Figure 2-3](#ch02fig03)
    when copying the same cardiac cycle.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于列表中的第一个和最后两个数据值是冗余的：`[62, 60, 62, 64, 68, 77, 80, 76, 71, 66, 61, 60, 62]`。当仅绘制单个心脏周期时，这些冗余数据可能会有用，以表示一个完整的周期已被可视化。然而，我们必须去除这些冗余数据，以确保我们复制相同的心脏周期时，预期的心脏周期不会像
    [图 2-3](#ch02fig03) 中的那样。
- en: '![images](Images/fig2-3.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![images](Images/fig2-3.jpg)'
- en: '*Figure 2-3: Visualizing expected cardiac cycles by copying* all *values from
    the measured data (no filtering of redundant data)*'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-3：通过复制* 所有 *测量数据中的值（不过滤冗余数据）* 来可视化预期的心脏周期'
- en: 'Clearly, you need to *clean* the original list by removing the redundant first
    and the last two data values: `[62, 60, 62, 64, 68, 77, 80, 76, 71, 66, 61, 60,
    62]` becomes `[60, 62, 64, 68, 77, 80, 76, 71, 66, 61]`.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，你需要 *清理* 原始列表，去除第一个和最后两个冗余数据值：`[62, 60, 62, 64, 68, 77, 80, 76, 71, 66, 61,
    60, 62]` 变为 `[60, 62, 64, 68, 77, 80, 76, 71, 66, 61]`。
- en: 'You’ll combine slicing with the new Python feature *list concatenation*, which
    creates a new list by *concatenating* (that is, *joining*) existing lists. For
    example, the operation `[1, 2, 3] + [4, 5]` generates the new list `[1, 2, 3,
    4, 5]`, but doesn’t replace the original lists. You can use this with the `*`
    operator to concatenate the *same list* again and again to create large lists:
    for example, the operation `[1, 2, 3] * 3` generates the new list `[1, 2, 3, 1,
    2, 3, 1, 2, 3]`.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 你将结合切片操作与 Python 新特性 *列表连接*，该特性通过 *连接*（即 *合并*）现有的列表来创建一个新列表。例如，操作 `[1, 2, 3]
    + [4, 5]` 会生成新列表 `[1, 2, 3, 4, 5]`，但不会替换原始列表。你可以使用 `*` 运算符将 *同一列表* 一次次地连接起来，创建更大的列表：例如，操作
    `[1, 2, 3] * 3` 会生成新列表 `[1, 2, 3, 1, 2, 3, 1, 2, 3]`。
- en: In addition, you’ll use the `matplotlib.pyplot` module to plot the cardiac data
    you generate. The matplotlib function `plot(data)` expects an iterable argument
    `data`—an *iterable* is simply an object over which you can iterate, such as a
    list—and uses it as `y` values for subsequent data points in a two-dimensional
    plot. Let’s dive into the example.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您将使用`matplotlib.pyplot`模块来绘制您生成的心脏数据。matplotlib的`plot(data)`函数期望一个可迭代的参数`data`——*可迭代对象*就是指可以迭代的对象，例如列表——并将其作为后续数据点的`y`值，用于二维图形的绘制。我们来深入了解一下这个示例。
- en: '***The Code***'
  id: totrans-189
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: Given a list of integers that reflect the measured cardiac cycle, you first
    want to clean the data by removing the first and last two values from the list.
    Second, you create a new list with expected future heart rates by copying the
    cardiac cycle to future time instances. [Listing 2-8](#list2-8) shows the code.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个反映测量心脏周期的整数列表，您首先需要通过去除列表中的前两个和最后两个值来清理数据。其次，您通过将心脏周期数据复制到未来时间点来创建一个新的列表，预测未来的心率。[列表
    2-8](#list2-8)展示了代码。
- en: '[PRE29]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*Listing 2-8: One-liner solution to predict heart rates at different times*'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-8：预测不同时间心率的一行解决方案*'
- en: Next, you’ll learn about the result of this code snippet.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您将学习这个代码片段的结果。
- en: '***How It Works***'
  id: totrans-194
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***它是如何工作的***'
- en: This one-liner consists of two steps. First, you use slicing to clean the data
    by using the negative stop argument `-2` to slice all the way to the right but
    skip the last two redundant values. Second, you concatenate the resulting data
    values 10 times by using the replication operator `*`. The result is a list of
    10 × 10 = 100 integers made up of the concatenated cardiac cycle data. When you
    plot the result, you get the desired output shown previously in [Figure 2-2](#ch02fig02).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这个一行解决方案包含两个步骤。首先，您使用切片来清理数据，通过使用负的停止参数`-2`来切片，直到右边但跳过最后两个冗余的值。其次，您使用复制操作符`*`将结果数据值重复10次。最终结果是一个由10
    × 10 = 100个整数组成的列表，这些整数是通过连接的心脏周期数据。当您绘制结果时，您会看到先前在[图 2-2](#ch02fig02)中显示的期望输出。
- en: '**Using Generator Expressions to Find Companies That Pay Below Minimum Wage**'
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用生成器表达式查找支付低于最低工资的公司**'
- en: This section combines some of the Python basics you’ve already learned and introduces
    the useful function `any()`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 本节结合了您已经学过的一些Python基础知识，并介绍了有用的`any()`函数。
- en: '***The Basics***'
  id: totrans-198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基础知识***'
- en: You work in law enforcement for the US Department of Labor, finding companies
    that pay below minimum wage so you can initiate further investigations. Like hungry
    dogs on the back of a meat truck, your Fair Labor Standards Act (FLSA) officers
    are already waiting for the list of companies that violated the minimum wage law.
    Can you give it to them?
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 您在美国劳工部从事执法工作，负责找出支付低于最低工资的公司，以便进行进一步调查。就像饿狼盯着肉车一样，您的公平劳动标准法（FLSA）官员已经在等待那些违反最低工资法的公司名单。您能给他们吗？
- en: 'Here’s your weapon: Python’s `any()` function, which takes an iterable, such
    as a list, and returns `True` if at least one element of the iterable evaluates
    to `True`. For example, the expression `any([True, False, False, False])` evaluates
    to `True`, while the expression `any([2<1, 3+2>5+5, 3-2<0, 0])` evaluates to `False`.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您的武器：Python的`any()`函数，它接受一个可迭代对象（例如列表），并在至少一个元素的值为`True`时返回`True`。例如，表达式`any([True,
    False, False, False])`的结果为`True`，而表达式`any([2<1, 3+2>5+5, 3-2<0, 0])`的结果为`False`。
- en: '**NOTE**'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Python’s creator, Guido van Rossum, was a huge fan of the built-in function
    *`any()`* and even proposed to include it as a built-in function in Python 3\.
    See his 2005 blog post, “The Fate of *`reduce()`* in Python 3000” at [https://www.artima.com/weblogs/viewpost.jsp?thread=98196](https://www.artima.com/weblogs/viewpost.jsp?thread=98196)
    for more details.*'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '*Python的创造者Guido van Rossum非常喜欢内建函数*`any()`*，甚至提议将其作为Python 3的内建函数之一。请参阅他2005年的博客文章《Python
    3000中的*`reduce()`*命运》，详情请见[https://www.artima.com/weblogs/viewpost.jsp?thread=98196](https://www.artima.com/weblogs/viewpost.jsp?thread=98196)。*'
- en: 'An interesting Python extension is a generalization of list comprehension:
    generator expressions. *Generator expressions* work exactly like list comprehensions—but
    without creating an actual list in memory. The numbers are created on the fly,
    without storing them explicitly in a list. For example, instead of using list
    comprehension to calculate the squares of the first 20 numbers, `sum([x*x for
    x in range(20)])`, you can use a generator expression: `sum(x*x for x in range(20))`.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的Python扩展是列表推导式的概括：生成器表达式。*生成器表达式*的工作方式与列表推导式完全相同——但它不会在内存中创建一个实际的列表。这些数字是动态生成的，而不是显式存储在列表中。例如，代替使用列表推导式来计算前20个数字的平方，`sum([x*x
    for x in range(20)])`，你可以使用生成器表达式：`sum(x*x for x in range(20))`。
- en: '***The Code***'
  id: totrans-204
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: Our data is a dictionary of dictionaries storing the hourly wages of company
    employees. You want to extract a list of the companies paying below your state’s
    minimum wage (< $9) for at least one employee; see [Listing 2-9](#list2-9).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据是一个字典的字典，存储着公司员工的时薪。你希望提取出至少有一名员工的工资低于你所在州最低工资（< $9）的公司列表；见[列表 2-9](#list2-9)。
- en: '[PRE30]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*Listing 2-9: One-liner solution to find companies that pay below minimum wage*'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-9：找到低于最低工资的公司的一行解决方案*'
- en: Which companies must be further investigated?
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 哪些公司需要进一步调查？
- en: '***How It Works***'
  id: totrans-209
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***它是如何工作的***'
- en: You use two generator expressions in this one-liner.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这行代码中使用了两个生成器表达式。
- en: The first generator expression, `y<9 for y in companies[x].values()`, generates
    the input to the function `any()`. It checks each of the companies’ employees
    to see whether they are being paid below minimum wage, `y<9`. The result is an
    iterable of Booleans. You use the dictionary function `values()` to return the
    collection of values stored in the dictionary. For example, the expression `companies['CoolCompany'].values()`
    returns the collection of hourly wages `dict_values([33, 28, 29])`. If at least
    one of them is below minimum wage, the function `any()` would return `True`, and
    the company name `x` would be stored as a string in the resulting list `illegal`,
    as described next.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个生成器表达式`y<9 for y in companies[x].values()`生成了输入给`any()`函数的内容。它检查每个公司员工的薪水，查看是否低于最低工资`y<9`。结果是一个布尔值的可迭代对象。你使用字典函数`values()`返回字典中存储的所有值。例如，表达式`companies['CoolCompany'].values()`返回时薪的集合`dict_values([33,
    28, 29])`。如果其中至少有一个低于最低工资，`any()`函数将返回`True`，公司名称`x`将作为字符串存储在结果列表`illegal`中，如下所述。
- en: The second generator expression is the list comprehension `[x for x in companies
    if any(...)]` and it creates a list of company names for which the previous call
    of the function `any()` returns `True`. Those are the companies that pay below
    minimum wage. Note that the expression `for x in companies` visits all dictionary
    keys—the company names `'CoolCompany'`, `'CheapCompany'`, and `'SosoCompany'`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个生成器表达式是列表推导式`[x for x in companies if any(...)]`，它创建了一个公司名称的列表，其中先前调用的`any()`函数返回`True`。这些公司是那些支付低于最低工资的公司。注意，表达式`for
    x in companies`访问所有字典的键——公司名称`'CoolCompany'`、`'CheapCompany'`和`'SosoCompany'`。
- en: 'The result is therefore as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，结果如下：
- en: '[PRE31]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Two out of three companies must be investigated further because they pay too
    little money to at least one employee. Your officers can start to talk to Ann,
    Chrisi, and Cole!
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 三家公司中有两家需要进一步调查，因为它们至少有一名员工的薪资过低。你的工作人员可以开始与Ann、Chrisi和Cole交谈！
- en: '**Formatting Databases with the zip() Function**'
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用zip()函数格式化数据库**'
- en: In this section, you’ll learn how to apply database column names to a list of
    rows by using the `zip()` function.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何通过使用`zip()`函数将数据库列名应用到一系列行中。
- en: '***The Basics***'
  id: totrans-218
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基础知识***'
- en: 'The `zip()` function takes iterables `iter_1`, `iter_2`, `...`, `iter_n` and
    aggregates them into a single iterable by aligning the corresponding *i*-th values
    into a single tuple. The result is an *iterable* of tuples. For example, consider
    these two lists:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`zip()`函数接受可迭代对象`iter_1`、`iter_2`、`...`、`iter_n`，并通过将相应的*i*-th值对齐为一个元组，将它们聚合成一个单一的可迭代对象。结果是一个元组的*可迭代对象*。例如，考虑这两个列表：'
- en: '[PRE32]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If you zip them together—after a simple data type conversion, as you’ll see
    in a moment—you’ll get a new list:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将它们压缩在一起——经过一个简单的数据类型转换，正如你稍后会看到的——你将得到一个新的列表：
- en: '[PRE33]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Unzipping them back into the original tuples requires two steps. First, you
    remove the outer square bracket of the result to get the following three tuples:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 将它们解压回原始元组需要两个步骤。首先，你需要移除结果的外部方括号，得到以下三个元组：
- en: '[PRE34]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then when you zip those together, you get the new list:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当你将它们一起压缩时，你将得到新的列表：
- en: '[PRE35]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'So, you have your two original lists again! The following code snippet shows
    this process in full:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，你又得到了原来的两个列表！下面的代码片段展示了这一过程的完整实现：
- en: '[PRE36]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: You use the asterisk operator `*` to unpack ➊ all elements of the list. This
    operator removes the outer bracket of the list `zipped` so that the input to the
    `zip()` function consists of three iterables (the tuples `(1, 4), (2, 5), (3,
    6)`). If you zip those iterables together, you package the first three tuple values
    `1`, `2`, and `3` into a new tuple, and the second three tuple values `4`, `5`,
    and `6` into another new tuple. Together, you get the resulting iterables `(1,
    2, 3)` and `(4, 5, 6)`, which is the original (unzipped) data.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用星号操作符 `*` 来解包 ➊ 列表中的所有元素。此操作符去掉了列表 `zipped` 的外部括号，使得 `zip()` 函数的输入由三个可迭代对象组成（元组
    `(1, 4), (2, 5), (3, 6)`）。如果你将这些可迭代对象进行 zip 操作，你会将前三个元组值 `1`、`2` 和 `3` 打包成一个新元组，再将接下来的三个元组值
    `4`、`5` 和 `6` 打包成另一个新元组。最终，你得到的迭代对象是 `(1, 2, 3)` 和 `(4, 5, 6)`，这就是原始（未解压）数据。
- en: 'Now, imagine you work in the IT branch of the controlling department of your
    company. You maintain the database of all employees with the column names: `''name''`,
    `''salary''`, and `''job''`. However, your data is out of shape—it’s a collection
    of rows in the form `(''Bob'', 99000, ''mid-level manager'')`. You want to associate
    your column names to each data entry to bring it into the readable form `{''name'':
    ''Bob'', ''salary'': 99000, ''job'': ''mid-level` `manager''}`. How can you achieve
    that?'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，假设你在公司财务部门的 IT 分支工作。你负责维护所有员工的数据库，包含列名：`''name''`、`''salary''` 和 `''job''`。然而，你的数据格式不规范——它是以
    `(''Bob'', 99000, ''mid-level manager'')` 形式存储的多行数据。你想将列名与每条数据关联起来，使其变为可读的形式 `{''name'':
    ''Bob'', ''salary'': 99000, ''job'': ''mid-level manager''}`。你该如何实现？'
- en: '***The Code***'
  id: totrans-231
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: Your data consists of the column names and the employee data organized as list
    of tuples (rows). Assign the column names to the rows and, thus, create a list
    of dictionaries. Each dictionary assigns the column names to the respective data
    values ([Listing 2-10](#list2-10)).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 你的数据包含列名和组织为元组列表（行）的员工数据。将列名分配给每一行数据，进而创建一个字典列表。每个字典将列名分配给相应的数据值（[列出 2-10](#list2-10)）。
- en: '[PRE37]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '*Listing 2-10: One-liner solution to apply a database format to a list of tuples*'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '*列出 2-10：将数据库格式应用于元组列表的简洁解法*'
- en: What’s the printed format of the database `db`?
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，数据库 `db` 的打印格式是什么？
- en: '***How It Works***'
  id: totrans-236
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***它是如何工作的***'
- en: You create the list by using list comprehension (see “[Using List Comprehension
    to Find Top Earners](#lev-24)” on [page 18](#page_18) for more on expression *+*
    context). The context consists of a tuple of every row in the variable `db_rows`.
    The expression `zip(column_names, row)` zips together the schema and each row.
    For example, the first element created by the list comprehension would be `zip(['name',
    'salary', 'job'], ('Alice', 180000, 'data scientist'))`, which results in a zip
    object that, after conversion to a list, is in the form `[('name', 'Alice'), ('salary',
    180000), ('job', 'data scientist')]`. The elements are in `(`*`key`*`,` *`value`*`)`
    form so you can convert it into a dictionary by using the converter function `dict()`
    to arrive at the required database format.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过使用列表推导式创建列表（更多关于表达式 *+* 上下文的内容请参见 “[使用列表推导式查找高薪员工](#lev-24)” 以及 [第18页](#page_18)）。上下文由变量
    `db_rows` 中每一行的元组组成。表达式 `zip(column_names, row)` 将列名和每一行数据打包在一起。例如，列表推导式创建的第一个元素是
    `zip(['name', 'salary', 'job'], ('Alice', 180000, 'data scientist'))`，它生成一个 zip
    对象，转换成列表后格式为 `[('name', 'Alice'), ('salary', 180000), ('job', 'data scientist')]`。这些元素是
    `(*key*, *value*)` 形式，因此你可以通过使用转换函数 `dict()` 将其转换成字典，达到所需的数据库格式。
- en: '**NOTE**'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The *`zip()`* function doesn’t care that one input is a list and the other
    is a tuple. The function requires only that the input is an iterable (and both
    lists and tuples are iterables).*'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '*`zip()`* 函数不关心一个输入是列表而另一个是元组。该函数只要求输入是可迭代的（列表和元组都是可迭代的）。'
- en: 'Here’s the output of the one-liner code snippet:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这是单行代码片段的输出结果：
- en: '[PRE38]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Every data item is now associated with its name in a list of dictionaries. You’ve
    learned how to use the `zip()` function effectively.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 每个数据项现在都与其名称关联，形成了一个字典列表。你已经学会了如何有效地使用 `zip()` 函数。
- en: '**Summary**'
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter, you’ve mastered list comprehensions, file input, the functions
    `lambda`, `map()`, and `zip()`, the `all()` quantifier, slicing, and basic list
    arithmetic. You’ve also learned how to use and manipulate data structures to solve
    various day-to-day problems.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你已经掌握了列表推导式、文件输入、`lambda` 函数、`map()` 和 `zip()` 函数、`all()` 量词、切片和基本的列表运算。你还学会了如何使用和操作数据结构来解决各种日常问题。
- en: 'Converting data structures back and forth easily is a skill with a profound
    impact on your coding productivity. Rest assured that your programming productivity
    will soar as you increase your ability to quickly manipulate data. Small processing
    tasks like the ones you’ve seen in this chapter contribute significantly to the
    common “death by a thousand cuts”: the overwhelming harm that performing many
    small tasks has on your overall productivity. By using the Python tricks, functions,
    and features introduced in this chapter, you’ve obtained effective protection
    against those thousand cuts. Speaking metaphorically, the newly acquired tools
    help you recover from each cut much faster.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 数据结构的来回转换是一项对编程生产力有深远影响的技能。可以放心，当你提高快速操作数据的能力时，你的编程生产力将迅速提升。像本章中看到的小型处理任务，实际上会对常见的“千刀万剐”产生显著影响：频繁执行许多小任务对整体生产力的压迫性伤害。通过使用本章介绍的
    Python 技巧、函数和特性，你已经有效地抵御了这些千刀万剐的伤害。用比喻来说，新获得的工具帮助你在每次受伤后更快恢复。
- en: In the next chapter, you’ll improve your data science skills even further by
    diving into a new set of tools provided by the NumPy library for numerical computations
    in Python.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，你将通过深入学习 NumPy 库提供的一组工具来进一步提升你的数据科学技能，这些工具专为 Python 中的数值计算而设计。
- en: '**SOLUTION TO EXERCISE 2-1**'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 2-1 的解答**'
- en: Here’s how to use list comprehension instead of the `map`() function to achieve
    the same problem of filtering out all lines that contain the string `'anonymous'`.
    In this case, I even recommend using the faster and cleaner list comprehension
    feature.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何使用列表推导式替代 `map()` 函数，达到相同的效果，即过滤掉包含字符串 `'anonymous'` 的所有行。在这种情况下，我甚至推荐使用更快、更简洁的列表推导式特性。
- en: '[PRE39]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
