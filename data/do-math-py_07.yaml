- en: '**7**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**7**'
- en: '**Solving Calculus Problems**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**求解微积分问题**'
- en: '![image](images/common-01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/common-01.jpg)'
- en: In this final chapter, we’ll learn to solve calculus problems. We’ll first learn
    about mathematical functions, followed by a quick overview of the common mathematical
    functions available in Python’s standard library and SymPy. Then, we’ll learn
    how we can find the limits of functions and calculate derivatives and integrals—
    that is, the kinds of things you’d be doing in any calculus class. Let’s get started!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章最后，我们将学习如何求解微积分问题。我们将首先了解数学函数，然后快速回顾 Python 标准库和 SymPy 中常见的数学函数。接着，我们将学习如何找到函数的极限，并计算导数和积分——也就是你在任何微积分课上都会做的事情。让我们开始吧！
- en: '**What Is a Function?**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**什么是函数？**'
- en: Let’s start out with some basic definitions. A function is a *mapping* between
    an input set and an output set. The special condition of a function is that an
    element of the input set is related to *exactly one* element of the output set.
    For example, [Figure 7-1](ch07.html#ch7fig1) shows two sets such that an element
    of the output set is the square of an element that belongs to the input set.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一些基本定义开始。函数是输入集合和输出集合之间的*映射*。函数的特殊条件是输入集合中的一个元素与*恰好一个*输出集合中的元素相关联。例如，[图
    7-1](ch07.html#ch7fig1) 显示了两个集合，其中输出集合的一个元素是输入集合中某个元素的平方。
- en: '![image](images/f07-01.jpg)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f07-01.jpg)'
- en: '*Figure 7-1: A function describes a mapping between an input set and an output
    set. Here, an element of the output set is the square of an element from the input
    set.*'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-1：一个函数描述了输入集合与输出集合之间的映射。这里，输出集合中的一个元素是输入集合中某个元素的平方。*'
- en: Using the familiar function notation, we’d write this function as *f*(*x*) =
    *x*², where *x* is the independent variable quantity. So *f*(2) = 4, *f*(100)
    = 10000, and so on. We refer to *x* as the independent variable quantity because
    we’re free to assume a value for it as long as that value is within its domain
    (see the next section).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 使用常见的函数表示法，我们将这个函数写作 *f*(*x*) = *x*²，其中 *x* 是独立变量。比如 *f*(2) = 4，*f*(100) = 10000，等等。我们称
    *x* 为独立变量，因为我们可以自由地为它假设一个值，只要该值在它的定义域内（参见下一节）。
- en: Functions can also be defined in terms of multiple variables. For example, *f*(*x*,
    *y*) = *x*² + *y*² defines a function of two variables, *x* and *y*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 函数也可以用多个变量来定义。例如，*f*(*x*, *y*) = *x*² + *y*² 定义了一个包含两个变量 *x* 和 *y* 的函数。
- en: '***Domain and Range of a Function***'
  id: totrans-10
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***函数的定义域和值域***'
- en: The *domain* of a function is the set of input values that the independent variable
    can validly assume. The output set of a function is called the *range*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的*定义域*是独立变量可以有效取值的输入值集合。函数的输出集合称为*值域*。
- en: For example, the domain of the function *f*(*x*) = 1/*x* is all nonzero real
    and complex numbers because 1/0 isn’t defined. The range is formed by the set
    of values obtained by substituting each number in the domain into 1/*x*, so in
    this case it is also all nonzero real and complex numbers.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，函数 *f*(*x*) = 1/*x* 的定义域是所有非零的实数和复数，因为 1/0 是未定义的。值域是通过将定义域中的每个数代入 1/*x* 计算得到的值集，因此在这种情况下，值域也是所有非零的实数和复数。
- en: '**NOTE**'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The domain and range of a function can certainly be different. For example,
    for the function* x*², the domain is all positive and negative numbers, but the
    range is only the positive numbers.*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数的定义域和值域当然可以不同。例如，对于函数* x*²，定义域是所有正数和负数，但值域仅包括正数。*'
- en: '***An Overview of Common Mathematical Functions***'
  id: totrans-15
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***常见数学函数概述***'
- en: We’ve already used a number of common mathematical functions from the Python
    standard library’s math module. A couple of familiar examples are the sin() and
    cos() functions, which correspond to the trigonometric functions sine and cosine.
    Other trigonometric functions—tan() and the inverse equivalents of these functions,
    asin(), acos(), and atan()—are also defined.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用了 Python 标准库的 math 模块中的一些常见数学函数。几个熟悉的例子是 sin() 和 cos() 函数，它们分别对应三角函数中的正弦和余弦。其他三角函数——tan()
    以及这些函数的反函数，asin()、acos() 和 atan()——也已定义。
- en: The math module also includes functions that find the logarithm of a number—the
    natural logarithm function log(), the base-2 logarithm log2(), and the base-10
    logarithm log10()—as well as the function exp(), which finds the value of *e^x*,
    where *e* is Euler’s number (approximately 2.71828).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: math 模块还包括一些用来计算数值对数的函数——自然对数函数 log()、以 2 为底的对数 log2() 和以 10 为底的对数 log10()——以及函数
    exp()，该函数计算 *e^x* 的值，其中 *e* 是欧拉常数（大约等于 2.71828）。
- en: One drawback of all these functions is that they’re not suitable for working
    with symbolic expressions. If we want to manipulate a mathematical expression
    involving symbols, we have to start using the equivalent functions defined by
    SymPy.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些函数的一个缺点是，它们不适合处理符号表达式。如果我们想要处理包含符号的数学表达式，就必须开始使用SymPy定义的等效函数。
- en: 'Let’s see a quick example:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个简短的例子：
- en: '>>> import math'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> import math'
- en: '>>> math.sin(math.pi/2)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> math.sin(math.pi/2)'
- en: '1.0'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '1.0'
- en: Here, we find the sine of the angle *π*/2 using the sin() function defined by
    the standard library’s math module. Then, we can do the same using SymPy.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用标准库的math模块定义的sin()函数来求解角度*π*/2的正弦值。然后，我们可以使用SymPy做同样的事情。
- en: '>>> import sympy'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> import sympy'
- en: '>>> sympy.sin(math.pi/2)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> sympy.sin(math.pi/2)'
- en: '1.00000000000000'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '1.00000000000000'
- en: Similar to the standard library’s sin() function, SymPy’s sin() function expects
    the angle to be expressed in radians. Both functions return 1.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于标准库的sin()函数，SymPy的sin()函数也期望角度以弧度表示。两个函数都返回1。
- en: 'Now, let’s try to call each function with a symbol instead and see what happens:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试使用符号来调用每个函数，看看会发生什么：
- en: '>>> from sympy import Symbol'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> from sympy import Symbol'
- en: '>>> theta = Symbol(''theta'')'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> theta = Symbol(''theta'')'
- en: ➊ >>> math.sin(theta) + math.sin(theta)
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ >>> math.sin(theta) + math.sin(theta)
- en: 'Traceback (most recent call last):'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 回溯（最近的调用最后）：
- en: File "<pyshell#53>", line 1, in <module>
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 "<pyshell#53>"，第1行，位于 <module>
- en: math.sin(theta) + math.sin(theta)
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: math.sin(theta) + math.sin(theta)
- en: File "/usr/lib/python3.4/site-packages/sympy/core/expr.py", line 225, in
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 "/usr/lib/python3.4/site-packages/sympy/core/expr.py"，第225行，位于
- en: __float__
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: __float__
- en: raise TypeError("can't convert expression to float")
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 引发 TypeError("无法将表达式转换为浮动类型")
- en: TypeError: can't convert expression to float
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 'TypeError: 无法将表达式转换为浮动类型'
- en: ➋ >>> sympy.sin(theta) + sympy.sin(theta)
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ >>> sympy.sin(theta) + sympy.sin(theta)
- en: 2*sin(theta)
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 2*sin(theta)
- en: The standard library’s sin() function doesn’t know what to do when we call it
    with theta at ➊, so it raises an exception to indicate that it’s expecting a numerical
    value as an argument to the sin() function. On the other hand, SymPy is able to
    perform the same operation at ➋, and it returns the expression 2*sin(theta) as
    the result. This is hardly surprising to us now, but it illustrates the kinds
    of tasks where the standard library’s mathematical functions can fall short.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库的sin()函数在我们以➊的形式调用它时，不知道该怎么办，因此它引发一个异常，表示它期望sin()函数的参数是一个数值。另一方面，SymPy能够在➋执行相同的操作，并返回表达式2*sin(theta)作为结果。现在这对我们来说不算什么令人惊讶的事，但它说明了标准库的数学函数在某些任务中的不足之处。
- en: Let’s consider another example. Say we want to derive the expression for the
    time it takes for a body in projectile motion to reach the highest point if it’s
    thrown with initial velocity u at an angle theta (see “[Projectile Motion](ch02.html#ch02lev2sec08)”
    on [page 48](ch02.html#page_48)).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑另一个例子。假设我们想要推导出一个物体在抛射运动中到达最高点所需的时间表达式，如果它以初速度u在角度theta下被抛出（见[《抛体运动》](ch02.html#ch02lev2sec08)，第48页）。
- en: 'At the highest point, u*sin(theta)-g*t = 0, so to find t, we’ll use the solve()
    function we learned about in [Chapter 4](ch04.html#ch04):'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在最高点，u*sin(theta)-g*t = 0，因此为了求解t，我们将使用在[第4章](ch04.html#ch04)中学到的solve()函数：
- en: '>>> from sympy import sin, solve, Symbol'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> from sympy import sin, solve, Symbol'
- en: '>>> u = Symbol(''u'')'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> u = Symbol(''u'')'
- en: '>>> t = Symbol(''t'')'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> t = Symbol(''t'')'
- en: '>>> g = Symbol(''g'')'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> g = Symbol(''g'')'
- en: '>>> theta = Symbol(''theta'')'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> theta = Symbol(''theta'')'
- en: '>>> solve(u*sin(theta)-g*t, t)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> solve(u*sin(theta)-g*t, t)'
- en: '[u*sin(theta)/g]'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[u*sin(theta)/g]'
- en: The expression for t, as we learned earlier, turns out to be u*sin(theta)/g,
    and it illustrates how the solve() function can be used to find solutions to equations
    containing mathematical functions as well.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所学，t的表达式是u*sin(theta)/g，它展示了如何使用solve()函数来求解包含数学函数的方程。
- en: '**Assumptions in SymPy**'
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**SymPy中的假设**'
- en: 'In all our programs, we’ve created a Symbol object in SymPy, defining the variable
    like so: x = Symbol(''x''). Assume that as a result of an operation you asked
    SymPy to perform, SymPy needs to check whether the expression *x* + 5 is greater
    than 0\. Let’s see what would happen:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们所有的程序中，我们都创建了一个Symbol对象来定义变量，像这样：x = Symbol('x')。假设由于你要求SymPy执行的操作，SymPy需要检查表达式*x*
    + 5是否大于0。我们来看看会发生什么：
- en: '>>> from sympy import Symbol'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> from sympy import Symbol'
- en: '>>> x = Symbol(''x'')'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x = Symbol(''x'')'
- en: '>>> if (x+5) > 0:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 如果 (x+5) > 0：'
- en: print('Do Something')
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: print('做一些事情')
- en: 'else:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 否则：
- en: print('Do Something else')
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: print('做一些别的事情')
- en: 'Traceback (most recent call last):'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 回溯（最近的调用最后）：
- en: File "<pyshell#45>", line 1, in <module>
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 "<pyshell#45>"，第1行，位于 <module>
- en: 'if (x + 5) > 0:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 (x + 5) > 0：
- en: File "/usr/lib/python3.4/site-packages/sympy/core/relational.py", line 103,
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 "/usr/lib/python3.4/site-packages/sympy/core/relational.py"，第 103 行，
- en: in __nonzero__
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在 __nonzero__
- en: raise TypeError("cannot determine truth value of\n%s" % self)
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: raise TypeError("无法确定真假值\n%s" % self)
- en: TypeError: cannot determine truth value of
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: TypeError: 无法确定的真假值
- en: x + 5 > 0
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: x + 5 > 0
- en: Because SymPy doesn’t know anything about the sign of *x*, it can’t deduce whether
    *x* + 5 is greater than 0, so it displays an error. But basic math tells us that
    if *x* is positive, *x* + 5 will always be positive, and if *x* is negative, it
    will be positive only in certain cases.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 SymPy 无法知道 *x* 的符号，它无法推断 *x* + 5 是否大于 0，所以显示了一个错误。但基础数学告诉我们，如果 *x* 为正，*x*
    + 5 永远大于 0；如果 *x* 为负，它只有在某些情况下才大于 0。
- en: 'So if we create a Symbol object specifying positive=True, we tell SymPy to
    assume only positive values. Now it knows for sure that *x* + 5 is definitely
    greater than 0:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果我们创建一个指定 positive=True 的 Symbol 对象，我们告诉 SymPy 只假设正值。现在它可以确定 *x* + 5 肯定大于
    0：
- en: '>>> x = Symbol(''x'', positive=True)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x = Symbol(''x'', positive=True)'
- en: '>>> if (x+5) > 0:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> if (x+5) > 0:'
- en: print('Do Something')
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: print('做某事')
- en: 'else:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: print('Do Something else')
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: print('做其他事情')
- en: Do Something
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 做某事
- en: Note that if we’d instead specified negative=True, we could get the same error
    as in the first case. Just as we can declare a symbol as positive and negative,
    it’s also possible to specify it as real, integer, complex, imaginary, and so
    on. These declarations are referred to as *assumptions* in SymPy.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果我们改为指定 negative=True，我们可能会遇到与第一个例子相同的错误。正如我们可以声明一个符号为正或负一样，也可以将其指定为实数、整数、复数、虚数等。这些声明在
    SymPy 中被称为*假设*。
- en: '**Finding the Limit of Functions**'
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**寻找函数的极限**'
- en: A common task in calculus is finding the *limiting value* (or simply the *limit*)
    of the function, when the variable’s value is assumed to approach a certain value.
    Consider a function *f*(*x*) = 1/*x*, whose graph is shown in [Figure 7-2](ch07.html#ch7fig2).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 微积分中的一个常见任务是找到当变量的值趋近于某个特定值时，函数的*极限值*（或简称*极限*）。考虑一个函数 *f*(*x*) = 1/*x*，其图像如[图
    7-2](ch07.html#ch7fig2)所示。
- en: As the value of *x* increases, the value of *f*(*x*) approaches 0\. Using the
    limit notation, we’d write this as
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 *x* 的值增大，*f*(*x*) 的值接近 0。使用极限符号，我们可以写作：
- en: '![image](images/e0181-01.jpg)![image](images/f07-02.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/e0181-01.jpg)![image](images/f07-02.jpg)'
- en: '*Figure 7-2: A graph showing the function 1/*x *as the value of* x *increases*'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-2：显示函数 1/*x* 随着 *x* 增大而变化的图形*'
- en: 'We can find limits of functions in SymPy by creating objects of the Limit class
    as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过创建 Limit 类的对象来在 SymPy 中找到函数的极限，方法如下：
- en: ➊ >>> from sympy import Limit, Symbol, S
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ >>> from sympy import Limit, Symbol, S
- en: ➋ >>> x = Symbol('x')
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ >>> x = Symbol('x')
- en: ➌ >>> Limit(1/x, x, S.Infinity)
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ >>> Limit(1/x, x, S.Infinity)
- en: Limit(1/x, x, oo, dir='-')
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Limit(1/x, x, oo, dir='-')
- en: 'At ➊, we import the Limit and Symbol classes, as well as S, which is a special
    SymPy class that contains the definition of infinity (positive and negative) and
    other special values. Then at ➋ we create a symbol object, x, to represent *x*.
    We create the Limit object at ➌, passing it three arguments: 1/x, the variable
    x, and finally the value at which we want to calculate the function’s limit (infinity,
    given by S.Infinity).'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们导入 Limit 和 Symbol 类，以及 S，这是一个特殊的 SymPy 类，包含无穷大（正负）及其他特殊值的定义。然后在 ➋ 处，我们创建一个符号对象
    x 来表示 *x*。在 ➌ 处，我们创建 Limit 对象，传入三个参数：1/x、变量 x 和我们想要计算函数极限的值（无穷大，由 S.Infinity 给出）。
- en: The result is returned as an *unevaluated* object with the oo symbol denoting
    positive infinity and the dir='-' symbol specifying that we are approaching the
    limit from the negative side.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 结果以*未求值*的对象形式返回，oo 符号表示正无穷大，dir='-' 符号指定我们是从负方向接近极限。
- en: 'To find the value of the limit, we use the doit() method:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到极限值，我们使用 doit() 方法：
- en: '>>> l = Limit(1/x, x, S.Infinity)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> l = Limit(1/x, x, S.Infinity)'
- en: '>>> l.doit()'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> l.doit()'
- en: '0'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: 'By default, the limit is found from a positive direction, unless the value
    at which the limit is to be calculated is positive or negative infinity. In the
    case of positive infinity, the direction is negative, and vice versa. You can
    change the default direction as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，极限是从正方向求得，除非计算极限的值是正无穷大或负无穷大。在正无穷大的情况下，方向是负的，反之亦然。你可以通过以下方式更改默认方向：
- en: '>>> Limit(1/x, x, 0, dir=''-'').doit()'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> Limit(1/x, x, 0, dir=''-'').doit()'
- en: -oo
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: -oo
- en: Here, we calculate
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们计算
- en: '![image](images/e0182-01.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/e0182-01.jpg)'
- en: 'and as we approach 0 for *x* from the negative side, the value of the limit
    approaches negative infinity. On the other hand, if we approach 0 from the positive
    side, the value approaches positive infinity:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从负侧逼近 0 时，*x* 的极限值趋向负无穷。另一方面，如果我们从正侧逼近 0，极限值则趋向正无穷：
- en: '>>> Limit(1/x, x, 0, dir=''+'').doit()'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> Limit(1/x, x, 0, dir=''+'').doit()'
- en: oo
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: oo
- en: The Limit class also handles functions with limits of indeterminate forms,
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Limit 类也处理具有不定型极限的函数，
- en: '![image](images/e0182-02.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/e0182-02.jpg)'
- en: 'automatically:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 自动计算：
- en: '>>> from sympy import Symbol, sin'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 从 sympy 导入 Symbol, sin'
- en: '>>> Limit(sin(x)/x, x, 0).doit()'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> Limit(sin(x)/x, x, 0).doit()'
- en: '1'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: You have very likely used l’Hôpital’s rule to find such limits, but as we see
    here, the Limit class takes care of this for us.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你很可能已经使用了 l'Hôpital 法则来求解这样的极限，但正如我们在这里看到的，Limit 类会为我们处理这一问题。
- en: '***Continuous Compound Interest***'
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***连续复利***'
- en: Say you’ve deposited $1 in a bank. This deposit is the *principal*, which pays
    you *interest*—in this case, interest of 100 percent that compounds n times yearly
    for 1 year. The amount you’ll get at the end of 1 year is given by
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你在银行存入了 1 美元。这笔存款就是 *本金*，它会支付给你 *利息*——在这种情况下，利率为 100%，并且每年复利计算 n 次，持续 1 年。你在
    1 年结束时得到的金额由下式给出：
- en: '![image](images/e0183-01.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/e0183-01.jpg)'
- en: 'The prominent mathematician James Bernoulli discovered that as the value of
    *n* increases, the term (1 + 1/*n*)*^n* approaches the value of *e*—the constant
    that we can verify by finding the limit of the function:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 著名数学家詹姆斯·伯努利发现，当 *n* 的值增加时，(1 + 1/*n*)*^n* 这一项趋近于常数 *e*——我们可以通过计算该函数的极限来验证这一点：
- en: '>>> from sympy import Limit, Symbol, S'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 从 sympy 导入 Limit, Symbol, S'
- en: '>>> n = Symbol(''n'')'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> n = Symbol(''n'')'
- en: '>>> Limit((1+1/n)**n, n, S.Infinity).doit()'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> Limit((1+1/n)**n, n, S.Infinity).doit()'
- en: E
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: E
- en: For any principal amount *p*, any rate *r*, and any number of years *t*, the
    compound interest is calculated using the formula
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何本金 *p*、任何利率 *r* 和任何年数 *t*，复利可以通过以下公式计算：
- en: '![image](images/e0183-02.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/e0183-02.jpg)'
- en: 'Assuming continuous compounding interest, we can find the expression for *A*
    as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 假设是连续复利，我们可以按照以下方式找到 *A* 的表达式：
- en: '>>> from sympy import Symbol, Limit, S'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 从 sympy 导入 Symbol, Limit, S'
- en: '>>> p = Symbol(''p'', positive=True)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> p = Symbol(''p'', positive=True)'
- en: '>>> r = Symbol(''r'', positive=True)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> r = Symbol(''r'', positive=True)'
- en: '>>> t = Symbol(''t'', positive=True)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> t = Symbol(''t'', positive=True)'
- en: '>>> Limit(p*(1+r/n)**(n*t), n, S.Infinity).doit()'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> Limit(p*(1+r/n)**(n*t), n, S.Infinity).doit()'
- en: p*exp(r*t)
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: p*exp(r*t)
- en: We create three symbol objects, representing the principal amount, p, the rate
    of interest, r, and the number of years, t. We also tell SymPy that these symbols
    will assume positive values by passing the positive=True keyword argument while
    creating the Symbol objects. If we don’t specify, SymPy doesn’t know anything
    about the numerical values the symbol can assume and may not be able to evaluate
    the limit correctly. We then feed in the expression for the compound interest
    to create the Limit object and evaluate it using the doit() method. The limit
    turns out to be p*exp(r*t), which tells us that the compound interest grows exponentially
    with time for the fixed rate of interest.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建三个符号对象，分别表示本金 *p*，利率 *r* 和年数 *t*。我们还通过传递 `positive=True` 关键字参数告诉 SymPy 这些符号将假定为正值。如果不指定，SymPy
    将不知道这些符号可以假定的数值，因此可能无法正确计算极限。然后，我们将复利的表达式传入，创建 Limit 对象，并使用 `doit()` 方法进行求值。结果极限为
    *p*exp(*r*t*)，这告诉我们，在固定利率下，复利随时间呈指数增长。
- en: '***Instantaneous Rate of Change***'
  id: totrans-126
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***瞬时变化率***'
- en: Consider a car moving along a road. It accelerates uniformly such that the distance
    traveled, *S*, is given by the function
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一辆沿道路行驶的汽车。它匀加速运动，使得所行驶的距离 *S* 可以通过以下函数表示：
- en: '*S*(*t*) = 5*t*² + 2*t* + 8.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*S*(*t*) = 5*t*² + 2*t* + 8。'
- en: In this function, the independent variable is *t*, which represents the time
    elapsed since the car started moving.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在此函数中，自变量是 *t*，表示汽车开始运动后经过的时间。
- en: If we measure the distance traveled in time *t*[1] and time *t*[2] such that
    *t*[2] > *t*[1], then we can calculate the distance moved by the car in 1 unit
    of time using the expression
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在时间 *t*[1] 和时间 *t*[2]（其中 *t*[2] > *t*[1]）之间测量汽车行驶的距离，那么我们可以使用以下表达式计算汽车在
    1 单位时间内行驶的距离：
- en: '![image](images/e0184-01.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/e0184-01.jpg)'
- en: This is also referred to as the average rate of change of the function *S*(*t*)
    with respect to the variable *t*, or in other words, the average speed. If we
    write *t*[2] as *t*[1] + *δ[t]*—where *δ[t]* is the difference between *t*[2]
    and *t*[1] in units of time—we can rewrite the expression for the average speed
    as
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这也称为函数 *S*(*t*) 相对于变量 *t* 的平均变化率，或者换句话说，平均速度。如果我们将 *t*[2] 写成 *t*[1] + *δ[t]*——其中
    *δ[t]* 是 *t*[2] 和 *t*[1] 之间的时间差——我们可以将平均速度的表达式改写为：
- en: '![image](images/e0184-02.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/e0184-02.jpg)'
- en: This expression is also a function with *t*[1] as the variable. Now, if we further
    assume *δ[t]* to be really small, such that it approaches 0, we can use limit
    notation to write this as
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表达式也是一个以 *t*[1] 为变量的函数。现在，如果我们进一步假设 *δ[t]* 很小，趋近于 0，我们可以使用极限符号将其写作：
- en: '![image](images/e0184-03.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/e0184-03.jpg)'
- en: 'We will now evaluate the above limit. First, let’s create the various expression
    objects:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将计算上述的极限。首先，我们来创建各种表达式对象：
- en: '>>> from sympy import Symbol, Limit'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> from sympy import Symbol, Limit'
- en: '>>> t = Symbol(''t'')'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> t = Symbol(''t'')'
- en: ➊ >>> St = 5*t**2 + 2*t + 8
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ >>> St = 5*t**2 + 2*t + 8
- en: '>>> t1 = Symbol(''t1'')'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> t1 = Symbol(''t1'')'
- en: '>>> delta_t = Symbol(''delta_t'')'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> delta_t = Symbol(''delta_t'')'
- en: ➋ >>> St1 = St.subs({t: t1})
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '➋ >>> St1 = St.subs({t: t1})'
- en: ➌ >>> St1_delta = St.subs({t: t1 + delta_t})
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '➌ >>> St1_delta = St.subs({t: t1 + delta_t})'
- en: We first define the function *S*(*t*) at ➊. Then, we define two symbols, t1
    and delta_t, which correspond to *t*[1] and *δ[t]*. Using the subs() method, we
    then find *S*(*t*[1]) and *S*(*t*[1] + *δ[t]*) by substituting in the value of
    t for t1 and t1_delta_t at ➋ and ➌, respectively.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在 ➊ 定义了函数 *S*(*t*)。然后，我们定义了两个符号，t1 和 delta_t，它们分别对应于 *t*[1] 和 *δ[t]*。使用
    subs() 方法后，我们通过在 ➋ 和 ➌ 处将 t 替换为 t1 和 t1_delta_t 来找到 *S*(*t*[1]) 和 *S*(*t*[1] +
    *δ[t]*)。
- en: 'Now, let’s evaluate the limit:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们来计算这个极限：
- en: '>>> Limit((St1_delta-St1)/delta_t, delta_t, 0).doit()'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> Limit((St1_delta-St1)/delta_t, delta_t, 0).doit()'
- en: 10*t1 + 2
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 10*t1 + 2
- en: The limit turns out to be 10*t1 + 2, and it’s the rate of change of *S*(*t*)
    at time t1, or the instantaneous rate of change. This change is more commonly
    referred to as the *instantaneous speed* of the car at the time instant t1.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 极限结果为 10*t1 + 2，它是 *S*(*t*) 在时刻 t1 处的变化率，或者说是瞬时变化率。这个变化通常称为汽车在时刻 t1 的 *瞬时速度*。
- en: The limit we calculated here is referred to as the *derivative* of a function,
    and we can calculate it directly using SymPy’s Derivative class.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里计算的极限称为函数的 *导数*，我们可以直接使用 SymPy 的 Derivative 类来计算它。
- en: '**Finding the Derivative of Functions**'
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**求函数的导数**'
- en: 'The derivative of a function *y* = *f*(*x*) expresses the rate of change in
    the dependent variable, *y*, with respect to the independent variable, *x*. It’s
    denoted as either *f*′(*x*) or *dy*/*dx*. We can find the derivative of a function
    by creating an object of the Derivative class. Let’s use the previous function
    representing the motion of a car as an example:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 *y* = *f*(*x*) 的导数表示因变量 *y* 相对于自变量 *x* 的变化率。它通常表示为 *f*′(*x*) 或 *dy*/*dx*。我们可以通过创建
    Derivative 类的对象来求函数的导数。我们以之前表示汽车运动的函数为例：
- en: ➊ >>> from sympy import Symbol, Derivative
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ >>> from sympy import Symbol, Derivative
- en: '>>> t = Symbol(''t'')'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> t = Symbol(''t'')'
- en: '>>> St = 5*t**2 + 2*t + 8'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> St = 5*t**2 + 2*t + 8'
- en: ➋ >>> Derivative(St, t)
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ >>> Derivative(St, t)
- en: Derivative(5*t**2 + 2*t + 8, t)
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Derivative(5*t**2 + 2*t + 8, t)
- en: 'We import the Derivative class at ➊. At ➋, we create an object of the Derivative
    class. The two arguments passed while creating the object are the function St
    and the symbol t, which corresponds to the variable *t*. As with the Limit class,
    an object of the Derivative class is returned, and the derivative is not actually
    calculated. We call the doit() method on the unevaluated Derivative object to
    find the derivative:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 ➊ 导入了 Derivative 类。在 ➋，我们创建了 Derivative 类的一个对象。创建该对象时传入的两个参数是函数 St 和符号 t，t
    对应于变量 *t*。与 Limit 类一样，Derivatives 类的对象会被返回，导数并没有实际计算。我们调用未求值的 Derivative 对象的 doit()
    方法来计算导数：
- en: '>>> d = Derivative(St, t)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> d = Derivative(St, t)'
- en: '>>> d.doit()'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> d.doit()'
- en: 10*t + 2
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 10*t + 2
- en: 'The expression for the derivative turns out to be 10*t + 2. Now, if we want
    to calculate the value of the derivative at a particular value of *t*—say, *t*
    = *t*[1] or *t* = 1—we can use the subs() method:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 导数的表达式为 10*t + 2。如果我们想计算某个特定值 *t*（比如 *t* = *t*[1] 或 *t* = 1）处的导数值，可以使用 subs()
    方法：
- en: '>>> d.doit().subs({t:t1})'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> d.doit().subs({t:t1})'
- en: 10*t1 + 2
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 10*t1 + 2
- en: '>>> d.doit().subs({t:1})'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> d.doit().subs({t:1})'
- en: '12'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '12'
- en: 'Let’s try a complicated arbitrary function with *x* as the only variable: (*x*³
    + *x*² + *x*) × (*x*² + *x*).'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一个复杂的任意函数，以*x*为唯一变量：(*x*³ + *x*² + *x*) × (*x*² + *x*)。
- en: '>>> from sympy import Derivative, Symbol'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> from sympy import Derivative, Symbol'
- en: '>>> x = Symbol(''x'')'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x = Symbol(''x'')'
- en: '>>> f = (x**3 + x**2 + x)*(x**2+x)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> f = (x**3 + x**2 + x)*(x**2+x)'
- en: '>>> Derivative(f, x).doit()'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> Derivative(f, x).doit()'
- en: (2*x + 1)*(x**3 + x**2 + x) + (x**2 + x)*(3*x**2 + 2*x + 1)
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: (2*x + 1)*(x**3 + x**2 + x) + (x**2 + x)*(3*x**2 + 2*x + 1)
- en: You may consider this function the product of two independent functions, which
    means that, by hand, we’d need to make use of the *product rule* of differentiation
    to find the derivative. But we don’t need to worry about that here because we
    can just create an object of the Derivative class to do that for us.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将此函数视为两个独立函数的乘积，这意味着，我们手动计算时需要使用求导的*乘积法则*。但在这里，我们不需要担心这些，因为我们可以直接创建一个Derivative类的对象来为我们完成这项工作。
- en: Try out some other complicated expressions, such as expressions involving trigonometric
    functions.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试一些其他复杂的表达式，例如涉及三角函数的表达式。
- en: '***A Derivative Calculator***'
  id: totrans-174
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***一个求导计算器***'
- en: 'Now let’s write a derivative calculator program, which will take a function
    as input and then print the result of differentiating it with respect to the variable
    specified:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写一个求导计算器程序，该程序接受一个函数作为输入，然后打印出对指定变量求导后的结果：
- en: ''''''''
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: ''''''''
- en: Derivative calculator
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 求导计算器
- en: ''''''''
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: ''''''''
- en: from sympy import Symbol, Derivative, sympify, pprint
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: from sympy import Symbol, Derivative, sympify, pprint
- en: from sympy.core.sympify import SympifyError
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: from sympy.core.sympify import SympifyError
- en: 'def derivative(f, var):'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 'def derivative(f, var):'
- en: var = Symbol(var)
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: var = Symbol(var)
- en: d = Derivative(f, var).doit()
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: d = Derivative(f, var).doit()
- en: pprint(d)
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: pprint(d)
- en: 'if __name__==''__main__'':'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__==''__main__'':'
- en: ➊     f = input('Enter a function: ')
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ➊     f = input('输入一个函数: ')
- en: var = input('Enter the variable to differentiate with respect to: ')
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: var = input('输入要进行求导的变量: ')
- en: 'try:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 'try:'
- en: ➋         f = sympify(f)
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: ➋         f = sympify(f)
- en: 'except SympifyError:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 'except SympifyError:'
- en: print('Invalid input')
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: print('无效的输入')
- en: 'else:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: ➌         derivative(f, var)
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: ➌         derivative(f, var)
- en: At ➊, we ask the user to input a function for which the derivative is to be
    found, and then we ask for the variable with respect to which the function is
    to be differentiated. At ➋, we convert the input function into a SymPy object
    using the sympify() function. We call this function in a try...except block so
    that we can display an error message in case the user enters an invalid input.
    If the input expression is a valid expression, we call the derivative function
    at ➌, passing the converted expression and the variable with respect to which
    the function is to be differentiated as arguments.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们让用户输入一个需要求导的函数，然后让用户输入希望对其求导的变量。在➋处，我们使用sympify()函数将输入的函数转换为SymPy对象。我们在try...except块中调用该函数，以便在用户输入无效内容时显示错误信息。如果输入的表达式是有效的，我们会在➌处调用derivative函数，传入转换后的表达式和需要对其求导的变量作为参数。
- en: 'In the derivative() function, we first create a Symbol object that corresponds
    to the variable with respect to which the function is to be differentiated. We
    use the label var to refer to this variable. Next, we create a Derivative object
    that passes both the function to differentiate and the symbol object var. We immediately
    call the doit() method to evaluate the derivative, and we then use the pprint()
    function to print the result so that it appears close to its mathematical counterpart.
    A sample execution of the program follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在derivative()函数中，我们首先创建一个Symbol对象，表示需要对其进行求导的变量。我们使用标签var来引用这个变量。接下来，我们创建一个Derivative对象，并传入需要求导的函数和symbol对象var。然后，我们立即调用doit()方法来计算导数，最后使用pprint()函数打印结果，使其尽量与数学表达式相似。以下是程序的示例执行：
- en: Enter a function: 2*x**2 + 3*x + 1
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 输入一个函数: 2*x**2 + 3*x + 1
- en: Enter the variable to differentiate with respect to: x
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 输入要进行求导的变量: x
- en: 4·x + 3
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 4·x + 3
- en: 'Here’s a sample run when used with a function of two variables:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个针对双变量函数的示例运行：
- en: Enter a function: 2*x**2 + y**2
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 输入一个函数: 2*x**2 + y**2
- en: Enter the variable to differentiate with respect to: x
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 输入要进行求导的变量: x
- en: 4·x
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 4·x
- en: '***Calculating Partial Derivatives***'
  id: totrans-203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***计算偏导数***'
- en: In the previous program, we saw that it’s possible to calculate the derivative
    of a multivariable function with respect to any variable using the Derivative
    class. This calculation is usually referred to as *partial differentiation*, with
    *partial* indicating that we assume only one variable varies while the others
    are fixed.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的程序中，我们看到通过导数类可以计算多变量函数对任意变量的导数。这种计算通常被称为*偏微分*，其中*偏*表示我们假设只有一个变量发生变化，而其他变量保持不变。
- en: Let’s consider the function *f*(*x*, *y*) = 2*xy* + *xy*². The partial differentiation
    of *f*(*x*, *y*) with respect to *x* is
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑函数*f*（*x*，*y*）= 2*xy* + *xy*²。函数*f*（*x*，*y*）对*x*的偏微分为：
- en: '![image](images/e0187-01.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/e0187-01.jpg)'
- en: 'The preceding program is capable of finding the partial derivative because
    it’s just a matter of specifying the right variable:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的程序能够找到偏导数，因为它只需要指定正确的变量：
- en: Enter a function: 2*x*y + x*y**2
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 输入函数：2*x*y + x*y**2
- en: Enter the variable to differentiate with respect to: x
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 输入要计算导数的变量：x
- en: y² + 2·y
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: y² + 2·y
- en: '**NOTE**'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*A key assumption I’ve made in this chapter is that all the functions we’re
    calculating the derivative of are differentiable in their respective domains.*'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '*我在本章中做出的一个关键假设是，我们正在计算导数的所有函数在各自的定义域内都是可微的。*'
- en: '**Higher-Order Derivatives and Finding the Maxima and Minima**'
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**高阶导数和寻找极大值与极小值**'
- en: By default, creating the derivative object using the Derivative class finds
    the first-order derivative. To find higher-order derivatives, simply specify the
    order of the derivative to calculate as the third argument when you create the
    Derivative object. In this section I will show you how to use the first- and second-order
    derivative of the function to find its maxima and minima on an interval.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，使用导数类创建导数对象会找到一阶导数。要找到高阶导数，只需在创建导数对象时将计算导数的阶数作为第三个参数传递即可。在这一节中，我将向你展示如何使用一阶和二阶导数来找到函数在区间上的最大值和最小值。
- en: Consider the function *x*⁵ – 30*x*³ + 50*x*, defined on the domain [–5, 5].
    Note that I have used square brackets to indicate a closed domain, indicating
    that the variable *x* can assume any real value greater than or equal to –5 and
    less than or equal to 5 (see [Figure 7-3](ch07.html#ch7fig3)).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑函数*x*⁵ – 30*x*³ + 50*x*，定义在区间[–5, 5]上。注意，我使用方括号表示闭区间，这表示变量*x*可以取任意实数值，且该值大于或等于–5，小于或等于5（见[图
    7-3](ch07.html#ch7fig3)）。
- en: '![image](images/f07-03.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f07-03.jpg)'
- en: '*Figure 7-3: Plot of the function* x*⁵ – 30*x*³* + *50*x*, where –5* ≤ x ≤
    *5*'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-3: 函数*x*⁵ – 30*x*³* + *50*x*的图形，定义域为–5* ≤ x ≤ *5*'
- en: From the graph, we can see that the function attains its minimum value on the
    interval –2 ≤ *x* ≤ 0 at the point *B*. Similarly, it attains its maximum value
    on the interval 0 ≤ *x* ≤ 2 at the point *C*. On the other hand, the function
    attains its maximum and minimum values on the entire domain of *x* that we’ve
    considered here at the points *A* and *D*, respectively. Thus, when we consider
    the function on the whole interval [–5, 5], the points *B* and *C* are referred
    to as a *local minimum* and a *local maximum*, respectively, while the points
    *A* and *D* are the *global maximum* and the *global minimum*, respectively.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 从图形中我们可以看到，函数在区间–2 ≤ *x* ≤ 0上取得最小值，在点*B*处。同样，在区间0 ≤ *x* ≤ 2上，函数在点*C*处取得最大值。另一方面，函数在我们所考虑的整个*x*定义域内分别在点*A*和*D*处取得最大值和最小值。因此，当我们考虑函数在整个区间[–5,
    5]上的表现时，点*B*和*C*分别称为*局部最小值*和*局部最大值*，而点*A*和*D*分别是*全局最大值*和*全局最小值*。
- en: 'The term *extremum* (plural *extrema*) refers to the points where the function
    attains a local or global maximum or minimum. If *x* is an extremum of the function
    *f*(*x*), then the first-order derivative of *f* at *x*, denoted *f*′(*x*), must
    vanish. This property shows that a good way to find possible extrema is to try
    to solve the equation *f*′(*x*) = 0\. Such solutions are called *critical points*
    of the function. Let’s try this out:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '*极值*（复数形式*极值点*）是指函数取得局部或全局最大值或最小值的点。如果* x *是函数*f*（*x*）的极值点，那么函数在* x *处的一阶导数*f*′（*x*）必须为零。这个性质表明，寻找可能的极值点的一个有效方法是尝试解方程*f*′（*x*）
    = 0\. 这些解称为函数的*临界点*。我们来尝试一下：'
- en: '>>> from sympy import Symbol, solve, Derivative'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> from sympy import Symbol, solve, Derivative'
- en: '>>> x = Symbol(''x'')'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x = Symbol(''x'')'
- en: '>>> f = x**5 - 30*x**3 + 50*x'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> f = x**5 - 30*x**3 + 50*x'
- en: '>>> d1 = Derivative(f, x).doit()'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> d1 = Derivative(f, x).doit()'
- en: 'Now that we have calculated the first-order derivative, *f*′(*x*), we’ll solve
    *f*′(*x*) = 0 to find the critical points:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，我们已经计算了函数的第一阶导数*f*′(*x*)，接下来我们将解*f*′(*x*) = 0来找到临界点：  '
- en: '>>> critical_points = solve(d1)'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> critical_points = solve(d1)  '
- en: '>>> critical_points'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> critical_points  '
- en: '[-sqrt(-sqrt(71) + 9), sqrt(-sqrt(71) + 9), -sqrt(sqrt(71) + 9),'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '[-sqrt(-sqrt(71) + 9), sqrt(-sqrt(71) + 9), -sqrt(sqrt(71) + 9),  '
- en: sqrt(sqrt(71) + 9)]
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 'sqrt(sqrt(71) + 9)]  '
- en: 'The numbers in the list critical_points shown here correspond to the points
    *B*, *C*, *A*, and *D*, respectively. We will create labels to refer to these
    points, and then we can use the labels in our commands:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '列表critical_points中的数字对应于点*B*、*C*、*A*和*D*。我们将为这些点创建标签，然后可以在命令中使用这些标签：  '
- en: '>>> A = critical_points[2]'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> A = critical_points[2]  '
- en: '>>> B = critical_points[0]'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> B = critical_points[0]  '
- en: '>>> C = critical_points[1]'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> C = critical_points[1]  '
- en: '>>> D = critical_points[3]'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> D = critical_points[3]  '
- en: Because all the critical points for this function lie within the considered
    interval, they are all relevant for our search for the global maximum and minimum
    of *f*(*x*). We may now apply the so-called *second derivative test* to narrow
    down which critical points could be global maxima or minima.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '因为该函数的所有临界点都位于考虑的区间内，所以它们都与我们寻找*f*(*x*)的全局最大值和最小值相关。现在我们可以应用所谓的*二阶导数检验*来缩小哪些临界点可能是全局最大值或最小值。  '
- en: 'First, we calculate the second-order derivative for the function *f*(*x*).
    Note that to do so, we enter 2 as the third argument:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '首先，我们计算函数*f*(*x*)的二阶导数。请注意，为此，我们需要将2作为第三个参数输入：  '
- en: '>>> d2 = Derivative(f, x, 2).doit()'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> d2 = Derivative(f, x, 2).doit()  '
- en: Now, we find the value of the second derivative by substituting the value of
    each of the critical points one by one in place of *x*. If the resulting value
    is less than 0, the point is a local maximum; if the value is greater than 0,
    it’s a local minimum. If the resulting value is 0, then the test is inconclusive
    and we cannot deduce anything about whether the critical point *x* is a local
    minimum, maximum, or neither.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，我们通过将每个临界点的值逐一代入二阶导数中来找到二阶导数的值。如果结果小于0，则该点为局部最大值；如果结果大于0，则为局部最小值。如果结果为0，则检验不确定，我们无法推断该临界点*x*是局部最小值、最大值，还是既不是。  '
- en: '>>> d2.subs({x:B}).evalf()'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> d2.subs({x:B}).evalf()  '
- en: '127.661060789073'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '127.661060789073  '
- en: '>>> d2.subs({x:C}).evalf()'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> d2.subs({x:C}).evalf()  '
- en: '-127.661060789073'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '-127.661060789073  '
- en: '>>> d2.subs({x:A}).evalf()'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> d2.subs({x:A}).evalf()  '
- en: '-703.493179468151'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '-703.493179468151  '
- en: '>>> d2.subs({x:D}).evalf()'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> d2.subs({x:D}).evalf()  '
- en: '703.493179468151'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '703.493179468151  '
- en: Evaluating the second derivative test at the critical points tells us that the
    points *A* and *C* are local maxima and the points *B* and *D* are local minima.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '对临界点进行二阶导数检验的结果告诉我们，点*A*和*C*是局部最大值，点*B*和*D*是局部最小值。  '
- en: The global maximum and minimum of *f*(*x*) on the interval [–5, 5] is attained
    either at a critical point *x* or at one of the endpoints of the domain (*x* =
    –5 and *x* = 5). We have already found all of the critical points, which are the
    points *A*, *B*, *C*, and *D*. The function cannot attain its global minimum at
    either of the critical points *A* or *C* because they are local maximums. By similar
    logic, the function cannot attain its global maximum at *B* or *D*.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '函数*f*(*x*)在区间[–5, 5]上的全局最大值和最小值要么出现在临界点*x*处，要么出现在区间端点（*x* = –5和*x* = 5）。我们已经找到了所有的临界点，即点*A*、*B*、*C*和*D*。由于点*A*和*C*是局部最大值，因此函数不能在这两个临界点处取得全局最小值。通过类似的逻辑，函数也不能在点*B*和*D*处取得全局最大值。  '
- en: Thus, to find the global maximum, we must compute the value of *f*(*x*) at the
    points *A*, *C*, –5, and 5\. Among these points, the place where *f*(*x*) has
    the largest value must be the global maximum.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '因此，为了找到全局最大值，我们必须计算函数*f*(*x*)在点*A*、*C*、–5和5处的值。在这些点中，*f*(*x*)取得最大值的地方一定是全局最大值。  '
- en: 'We will create two labels, x_min and x_max, to refer to the domain boundaries
    and evaluate the function at the points A, C, x_min, and x_max:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建两个标签，x_min和x_max，用来表示区间的边界，并在点A、C、x_min和x_max处评估函数：
- en: '>>> x_min = -5'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x_min = -5  '
- en: '>>> x_max = 5'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x_max = 5  '
- en: '>>> f.subs({x:A}).evalf()'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> f.subs({x:A}).evalf()  '
- en: '705.959460380365'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '705.959460380365  '
- en: '>>> f.subs({x:C}).evalf()'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> f.subs({x:C}).evalf()  '
- en: '25.0846626340294'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '25.0846626340294  '
- en: '>>> f.subs({x:x_min}).evalf()'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> f.subs({x:x_min}).evalf()  '
- en: '375.000000000000'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '375.000000000000  '
- en: '>>> f.subs({x:x_max}).evalf()'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> f.subs({x:x_max}).evalf()  '
- en: '-375.000000000000'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '-375.000000000000  '
- en: By these calculations, as well as by examining the function value at all the
    critical points and the domain boundaries ([Figure 7-3](ch07.html#ch7fig3)), we
    see that the point *A* turns out be the global maximum.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些计算，以及检查所有临界点和定义域边界的函数值（[图7-3](ch07.html#ch7fig3)），我们可以看到，*A* 点是全局最大值。
- en: 'Similarly, to determine the global minimum, we must compute the values of *f*(*x*)
    at the points *B*, *D*, –5, and 5:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，为了确定全局最小值，我们必须计算 *f*(*x*) 在点 *B*、*D*、–5 和 5 处的值：
- en: '>>> f.subs({x:B}).evalf()'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> f.subs({x:B}).evalf()'
- en: '-25.0846626340294'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '-25.0846626340294'
- en: '>>> f.subs({x:D}).evalf()'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> f.subs({x:D}).evalf()'
- en: '-705.959460380365'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '-705.959460380365'
- en: '>>> f.subs({x:x_min}).evalf()'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> f.subs({x:x_min}).evalf()'
- en: '375.000000000000'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '375.000000000000'
- en: '>>> f.subs({x:x_max}).evalf()'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> f.subs({x:x_max}).evalf()'
- en: '-375.000000000000'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '-375.000000000000'
- en: The point where *f*(*x*) has the smallest value must be the global minimum for
    the function; this turns out to be point *D*.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 *f*(*x*) 的最小值点一定是该函数的全局最小值；这就是点 *D*。
- en: This method for finding the extrema of a function—by considering the function’s
    value at all of the critical points (after potentially discarding some via the
    second derivative test) and boundary values—will always work as long as the function
    is twice differentiable. That is, both the first and second derivative must exist
    everywhere in the domain.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这种通过考虑函数在所有临界点（可能通过二阶导数测试舍弃某些临界点）和边界值处的函数值来寻找极值的方法——只要函数是二阶可微的——总是有效的。也就是说，函数的一阶和二阶导数必须在定义域的每个点上都存在。
- en: 'For a function such as *e^x*, there might not be any critical points in the
    domain, but in this case the method works fine: it simply tells us that the extrema
    occur at the domain boundary.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像 *e^x* 这样的函数，可能在定义域内没有任何临界点，但在这种情况下，方法仍然有效：它只是告诉我们，极值发生在定义域的边界处。
- en: '**Finding the Global Maximum Using Gradient Ascent**'
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用梯度上升法找到全局最大值**'
- en: Sometimes we’re just interested in finding the global maximum for a function
    instead of all the local and global maxima and minima. For example, we might want
    to discover the angle of projection for which a ball will cover the maximum horizontal
    distance. We’re going to learn a new, more practical approach to solve such a
    problem. This approach makes use of the first derivative only, so it’s applicable
    only to functions for which the first derivative can be calculated.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们只关心找到函数的全局最大值，而不是所有的局部和全局最大值与最小值。例如，我们可能想知道一个球的投射角度，使得它能覆盖最大水平距离。我们将学习一种新的、更实用的方法来解决这样的问题。这种方法仅使用一阶导数，因此只适用于可以计算一阶导数的函数。
- en: This method is called the *gradient ascent method*, which is an iterative approach
    to finding the global maximum. Because the gradient ascent method involves lots
    of computation, it’s the perfect kind of thing to solve programmatically rather
    than by hand. Let’s try it out using the example problem of finding the angle
    of projection. In [Chapter 2](ch02.html#ch02), we derived the expression
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法叫做 *梯度上升法*，它是一种迭代求解全局最大值的方法。由于梯度上升法涉及大量计算，因此它是通过编程来解决的理想方法，而不是手工计算。让我们尝试使用找出投射角度的例子问题。在[第2章](ch02.html#ch02)中，我们推导了这个表达式：
- en: '![image](images/e0191-01.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/e0191-01.jpg)'
- en: to calculate the time of flight for a body in projectile motion that’s thrown
    with a velocity *u* at an angle *θ*. The *range* of a projectile, *R*, is the
    total horizontal distance traveled by the projectile and is given by the product
    of *u[x] × t*[flight]. Here, *u[x]* is the horizontal component of the initial
    velocity and is equal to *u* cos*θ*. Substituting the formulas for *u[x]* and
    *t*[flight], we get the expression
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 用于计算在投射运动中，物体以速度 *u* 和角度 *θ* 被抛出的飞行时间。一个抛体的*射程*，*R*，是抛体所走的总水平距离，由 *u[x] × t*[flight]
    的乘积给出。这里，*u[x]* 是初速度的水平分量，等于 *u* cos*θ*。将 *u[x]* 和 *t*[flight] 的公式代入，我们得到以下表达式：
- en: '![image](images/e0191-02.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/e0191-02.jpg)'
- en: The plot in [Figure 7-4](ch07.html#ch7fig4) shows values of *θ* between 0 and
    90 degrees and the corresponding range (distance traveled) for each angle. From
    the graph, we can see that the maximum range is obtained when the angle of projection
    is around 45 degrees. We’ll now learn to use the gradient ascent method to find
    this value of *θ* numerically.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '[图7-4](ch07.html#ch7fig4)中的图像显示了*θ*在0到90度之间的值及对应的范围（行进距离）。从图中可以看出，最大范围出现在投射角度约为45度时。接下来，我们将学习使用梯度上升法来数值求解这个*θ*值。'
- en: '![image](images/f07-04.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f07-04.jpg)'
- en: '*Figure 7-4: The range of a projectile thrown with an initial velocity of 25
    m/s with varying angles of projection*'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-4：以25 m/s的初速度投射的抛射物，在不同投射角度下的射程*'
- en: 'The gradient ascent method is an iterative method: we start with an initial
    value of *θ*—say, 0.001, or *θ*[old] = 0.001—and gradually get closer to the value
    of *θ* that corresponds to the maximum range ([Figure 7-5](ch07.html#ch7fig5)).
    The step that gets us closer is the equation'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 梯度上升法是一种迭代方法：我们从*θ*的初始值开始——例如，0.001，或者*θ*[old] = 0.001——并逐渐接近对应于最大范围的*θ*值（[图
    7-5](ch07.html#ch7fig5)）。使我们逐步接近的步骤是：
- en: '![image](images/e0192-01.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/e0192-01.jpg)'
- en: where *λ* is the *step size* and
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*λ*是*步长*，并且
- en: '![image](images/e0192-02.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/e0192-02.jpg)'
- en: 'is the derivative of *R* with respect to *θ*. Once we set *θ*[old] = 0.001,
    we do the following:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 是*R*对*θ*的导数。一旦我们设定*θ*[old] = 0.001，我们执行以下步骤：
- en: 1\. Calculate *θ*[new] using the preceding equation.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 使用上述方程计算*θ*[new]。
- en: 2\. If the absolute difference *θ*[new] – *θ*[old] is greater than a value,
    *ε*, we set *θ*[old] = *θ*[new] and return to step 1\. Otherwise, we go to step
    3.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 如果*θ*[new] – *θ*[old]的绝对差值大于某个值*ε*，我们设定*θ*[old] = *θ*[new]，然后返回第1步。否则，进入第3步。
- en: 3\. *θ*[new] is an approximate value of *θ* for which *R* has the maximum value.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. *θ*[new]是*θ*的一个近似值，使得*R*达到最大值。
- en: The value of *epsilon* (*ε*) determines when we decide to stop the iteration
    of the algorithm. It is discussed in “[The Role of the Step Size and Epsilon](ch07.html#ch07lev2sec09)”
    on [page 197](ch07.html#page_197).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '*epsilon*（*ε*）的值决定了我们何时停止算法的迭代。在“[步长和epsilon的作用](ch07.html#ch07lev2sec09)”中会有更详细的讨论，见[第197页](ch07.html#page_197)。'
- en: '![image](images/f07-05.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f07-05.jpg)'
- en: '*Figure 7-5: The gradient ascent method takes us iteratively toward the maximum
    point of the function.*'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：梯度上升法逐步逼近函数的最大点。*'
- en: The following grad_ascent() function implements the gradient ascent algorithm.
    The parameter x0 is the initial value of the variable at which to start the iteration,
    f1x is the derivative of the function whose maximum we want to find, and x is
    the Symbol object corresponding to the variable for the function.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 以下grad_ascent()函数实现了梯度上升算法。参数x0是开始迭代的变量初始值，f1x是我们要寻找最大值的函数的导数，x是与该函数变量对应的Symbol对象。
- en: ''''''''
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: ''''''''
- en: Use gradient ascent to find the angle at which the projectile
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 使用梯度上升法找到使抛射物
- en: has maximum range for a fixed velocity, 25 m/s
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 对于固定速度，25 m/s下，*R*具有最大射程
- en: ''''''''
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: ''''''''
- en: import math
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: import math
- en: from sympy import Derivative, Symbol, sin
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: from sympy import Derivative, Symbol, sin
- en: 'def grad_ascent(x0, f1x, x):'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 'def grad_ascent(x0, f1x, x):'
- en: ➊     epsilon = 1e-6
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: ➊     epsilon = 1e-6
- en: ➋     step_size = 1e-4
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: ➋     step_size = 1e-4
- en: ➌     x_old = x0
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: ➌     x_old = x0
- en: ➍     x_new = x_old + step_size*f1x.subs({x:x_old}).evalf()
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: ➍     x_new = x_old + step_size*f1x.subs({x:x_old}).evalf()
- en: '➎     while abs(x_old - x_new) > epsilon:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '➎     while abs(x_old - x_new) > epsilon:'
- en: x_old = x_new
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: x_old = x_new
- en: x_new = x_old + step_size*f1x.subs({x:x_old}).evalf()
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: x_new = x_old + step_size*f1x.subs({x:x_old}).evalf()
- en: return x_new
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: return x_new
- en: '➏ def find_max_theta(R, theta):'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '➏ def find_max_theta(R, theta):'
- en: '# Calculate the first derivative'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '# 计算一阶导数'
- en: R1theta = Derivative(R, theta).doit()
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: R1theta = Derivative(R, theta).doit()
- en: theta0 = 1e-3
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: theta0 = 1e-3
- en: theta_max = grad_ascent(theta0, R1theta, theta)
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: theta_max = grad_ascent(theta0, R1theta, theta)
- en: ➐     return theta_max
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: ➐     return theta_max
- en: 'if __name__ == ''__main__'':'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: g = 9.8
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: g = 9.8
- en: '# Assume initial velocity'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '# 假设初速度'
- en: u = 25
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: u = 25
- en: '# Expression for range'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '# 范围公式'
- en: theta = Symbol('theta')
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: theta = Symbol('theta')
- en: ➑     R = u**2*sin(2*theta)/g
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: ➑     R = u**2*sin(2*theta)/g
- en: ➒     theta_max = find_max_theta(R, theta)
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: ➒     theta_max = find_max_theta(R, theta)
- en: print('Theta: {0}'.format(math.degrees(theta_max)))
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 'print(''Theta: {0}''.format(math.degrees(theta_max)))'
- en: print('Maximum Range: {0}'.format(R.subs({theta:theta_max})))
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 'print(''最大射程: {0}''.format(R.subs({theta:theta_max})))'
- en: We set the epsilon value to 1e-6 and the step size to 1e-4 at ➊ and ➋, respectively.
    The epsilon value must always be a very small positive value close to 0, and the
    step size should be chosen such that the variable is incremented in small amounts
    at every iteration of the algorithm. The choice of the value of epsilon and step
    size is discussed in a bit more detail in “[The Role of the Step Size and Epsilon](ch07.html#ch07lev2sec09)”
    on [page 197](ch07.html#page_197).
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在➊和➋分别设定了epsilon值为1e-6，步长为1e-4。epsilon值必须始终是非常小的正数，接近0，步长应选择为使变量在每次迭代时增量较小。epsilon值和步长的选择将在“[步长和epsilon的作用](ch07.html#ch07lev2sec09)”中更详细讨论，见[第197页](ch07.html#page_197)。
- en: We set x_old to x0 at ➌ and calculate x_new for the first time at ➍. We use
    the subs() method to substitute the value of x_old in place of the variable and
    then use evalf() to calculate the numerical value. If the absolute difference
    abs(x_old – x_new) is greater than epsilon, the while loop at ➎ keeps executing,
    and we keep updating the value of x_old and x_new as per steps 1 and 2 of the
    gradient ascent algorithm. Once we’re out of the loop—that is, abs(x_old – x_new)
    > epsilon—we return x_new, the variable value corresponding to the maximum function
    value.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '我们在➌将x_old设为x0，并在➍第一次计算x_new。我们使用subs()方法将x_old的值代入变量中，然后使用evalf()计算数值。如果绝对差值abs(x_old
    – x_new)大于epsilon，while循环会在➎继续执行，我们会根据梯度上升算法的第1步和第2步更新x_old和x_new的值。一旦我们跳出循环——也就是abs(x_old
    – x_new)小于epsilon——我们返回x_new，即对应最大函数值的变量值。  '
- en: We begin to define the find_max_theta() function at ➏. In this function, we
    calculate the first-order derivative of R; create a label, theta0, and set it
    to 1e-3; and call the grad_ascent() function with these two values as arguments,
    as well as a third argument, the symbol object theta. Once we get the value of
    *θ* corresponding to the maximum function value (theta_max), we return it at ➐.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '我们在➏定义了find_max_theta()函数。在这个函数中，我们计算R的一阶导数；创建一个标签theta0，并将其设为1e-3；然后调用grad_ascent()函数，并将这两个值作为参数，同时传入第三个参数，即符号对象theta。一旦我们得到对应最大函数值的*θ*（theta_max），我们会在➐返回它。  '
- en: Finally, we create the expression representing the horizontal range at ➑, having
    set the initial velocity, u = 25, and the theta Symbol object corresponding to
    the angle *θ*. Then we call the find_max_theta() function with R and theta at
    ➒.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '最后，我们在➑创建了表示水平范围的表达式，初始速度u = 25，并设定了对应角度*θ*的符号对象theta。然后我们用R和theta调用find_max_theta()函数，在➒处。  '
- en: 'When you run this program, you should see the following output:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '当你运行这个程序时，你应该会看到以下输出：  '
- en: Theta: 44.99999978475661
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 'Theta: 44.99999978475661  '
- en: Maximum Range: 63.7755102040816
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '最大范围: 63.7755102040816  '
- en: The value of *θ* is printed in degrees and turns out to be close to 45 degrees,
    as expected. If you change the initial velocity to other values, you’ll see that
    the angle of projection at which the maximum range is reached is always close
    to 45 degrees.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '*θ*的值以度为单位打印，结果接近45度，符合预期。如果你改变初速度的值，你会发现达到最大范围的投射角始终接近45度。'
- en: '***A Generic Program for Gradient Ascent***'
  id: totrans-333
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***梯度上升的通用程序***  '
- en: 'We can modify the preceding program slightly to make a generic program for
    gradient ascent:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '我们可以稍微修改前面的程序，制作一个通用的梯度上升程序：  '
- en: ''''''''
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '''''''  '
- en: Use gradient ascent to find the maximum value of a
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '使用梯度上升法找到a的最大值  '
- en: single-variable function
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '单变量函数  '
- en: ''''''''
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '''''''  '
- en: from sympy import Derivative, Symbol, sympify
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 'from sympy import Derivative, Symbol, sympify  '
- en: 'def grad_ascent(x0, f1x, x):'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 'def grad_ascent(x0, f1x, x):  '
- en: epsilon = 1e-6
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 'epsilon = 1e-6  '
- en: step_size = 1e-4
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 'step_size = 1e-4  '
- en: x_old = x0
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 'x_old = x0  '
- en: x_new = x_old + step_size*f1x.subs({x:x_old}).evalf()
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 'x_new = x_old + step_size*f1x.subs({x:x_old}).evalf()  '
- en: 'while abs(x_old - x_new) > epsilon:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 'while abs(x_old - x_new) > epsilon:  '
- en: x_old = x_new
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 'x_old = x_new  '
- en: x_new = x_old + step_size*f1x.subs({x:x_old}).evalf()
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 'x_new = x_old + step_size*f1x.subs({x:x_old}).evalf()  '
- en: return x_new
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 'return x_new  '
- en: 'if __name__ == ''__main__'':'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':  '
- en: f = input('Enter a function in one variable: ')
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 'f = input(''请输入一个单变量函数：'')  '
- en: var = input('Enter the variable to differentiate with respect to: ')
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 'var = input(''请输入要进行微分的变量：'')  '
- en: var0 = float(input('Enter the initial value of the variable: '))
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 'var0 = float(input(''请输入变量的初始值：''))  '
- en: 'try:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 'try:  '
- en: f = sympify(f)
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 'f = sympify(f)  '
- en: 'except SympifyError:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 'except SympifyError:  '
- en: print('Invalid function entered')
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 'print(''无效的函数输入'')  '
- en: 'else:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:  '
- en: ➊         var = Symbol(var)
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '➊         var = Symbol(var)  '
- en: ➋         d = Derivative(f, var).doit()
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '➋         d = Derivative(f, var).doit()  '
- en: ➌         var_max = grad_ascent(var0, d, var)
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '➌         var_max = grad_ascent(var0, d, var)  '
- en: print('{0}: {1}'.format(var.name, var_max))
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 'print(''{0}: {1}''.format(var.name, var_max))  '
- en: print('Maximum value: {0}'.format(f.subs({var:var_max})))
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 'print(''最大值: {0}''.format(f.subs({var:var_max})))  '
- en: The function grad_ascent() remains the same here. Now, however, the program
    asks the user to input the function, the variable in the function, and the initial
    value of the variable, where gradient ascent will begin. Once we’re sure that
    SymPy can recognize the user’s input, we create a Symbol object corresponding
    to the variable at ➊, find the first derivative with respect to it at ➋, and call
    the grad_ascent() function with these three arguments. The maximum value is returned
    at ➌.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 函数grad_ascent()在这里保持不变。然而，现在程序要求用户输入函数、函数中的变量以及变量的初始值，梯度上升将从这个初始值开始。一旦我们确认SymPy能够识别用户的输入，我们创建一个与变量对应的Symbol对象（➊），求出关于该变量的一阶导数（➋），并使用这三个参数调用grad_ascent()函数。最大值在➌处返回。
- en: 'Here’s a sample run:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例运行：
- en: Enter a function in one variable: 25*25*sin(2*theta)/9.8
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 输入一个单变量函数：25*25*sin(2*theta)/9.8
- en: Enter the variable to differentiate with respect to: theta
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 输入要进行求导的变量：theta
- en: Enter the initial value of the variable: 0.001
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 输入变量的初始值：0.001
- en: theta: 0.785360029379083
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: theta：0.785360029379083
- en: Maximum value: 63.7755100185965
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 最大值：63.7755100185965
- en: The function input here is the same as in our first implementation of gradient
    ascent, and the value of *θ* is printed in radians.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 这里输入的函数与我们第一次实现梯度上升时相同，*θ*的值以弧度形式打印。
- en: 'Here’s another run of the program, which will find the maximum value for cos*y*:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 这是程序的另一次运行，它将找到cos*y*的最大值：
- en: Enter a function in one variable: cos(y)
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 输入一个单变量函数：cos(y)
- en: Enter the variable to differentiate with respect to: y
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 输入要进行求导的变量：y
- en: Enter the initial value of the variable: 0.01
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 输入变量的初始值：0.01
- en: y: 0.00999900001666658
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: y：0.00999900001666658
- en: Maximum value: 0.999950010415832
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 最大值：0.999950010415832
- en: 'The program also works correctly for a function such as cos(y) + k, where k
    is a constant:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序对像cos(y) + k这样的函数也能正常工作，其中k是一个常数：
- en: Enter a function in one variable: cos(y) + k
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 输入一个单变量函数：cos(y) + k
- en: Enter the variable to differentiate with respect to: y
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 输入要进行求导的变量：y
- en: Enter the initial value of the variable: 0.01
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 输入变量的初始值：0.01
- en: y: 0.00999900001666658
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: y：0.00999900001666658
- en: Maximum value: k + 0.999950010415832
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 最大值：k + 0.999950010415832
- en: However, a function such as cos(ky) won’t work because its first-order derivative,
    kcos(ky), still contains k, and SymPy doesn’t know anything about its value. Therefore,
    SymPy can’t perform a key step in the gradient ascent algorithm—namely, the comparison
    abs(x_old - x_new) > epsilon.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，像cos(ky)这样的函数不起作用，因为它的一阶导数kcos(ky)仍然包含k，而SymPy并不知道k的值。因此，SymPy无法执行梯度上升算法中的关键步骤——即比较abs(x_old
    - x_new) > epsilon。
- en: '***A Word of Warning About the Initial Value***'
  id: totrans-384
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***关于初始值的警告***'
- en: 'The initial value of the variable from which we start the iteration of the
    gradient ascent method plays a very important role in the algorithm. Consider
    the function *x*⁵ – 30*x*³ + 50*x*, which we used as an example in [Figure 7-3](ch07.html#ch7fig3).
    Let’s find the maximum using our generic gradient ascent program:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始梯度上升法迭代的变量初始值在算法中起着非常重要的作用。考虑函数*x*⁵ – 30*x*³ + 50*x*，我们在[图7-3](ch07.html#ch7fig3)中使用了这个例子。让我们使用通用的梯度上升程序来找到最大值：
- en: Enter a function in one variable: x**5 - 30*x**3 + 50*x
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 输入一个单变量函数：x**5 - 30*x**3 + 50*x
- en: Enter the variable to differentiate with respect to: x
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 输入要进行求导的变量：x
- en: Enter the initial value of the variable: -2
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 输入变量的初始值：-2
- en: x: -4.17445116397103
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: x：-4.17445116397103
- en: Maximum value: 705.959460322318
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 最大值：705.959460322318
- en: 'The gradient ascent algorithm stops when it finds the *closest peak*, which
    is not always the global maximum. In this example, when you start from the initial
    value of –2, it stops at the peak that also corresponds to the global maximum
    (approximately 706) in the considered domain. To verify this further, let’s try
    a different initial value:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 梯度上升算法在找到*最接近的峰值*时停止，这并不总是全局最大值。在这个例子中，当你从初始值-2开始时，它停在了对应于全局最大值（约706）的峰值上。为了进一步验证这一点，我们尝试使用不同的初始值：
- en: Enter a function in one variable: x**5 - 30*x**3 + 50*x
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 输入一个单变量函数：x**5 - 30*x**3 + 50*x
- en: Enter the variable to differentiate with respect to: x
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 输入要进行求导的变量：x
- en: Enter the initial value of the variable: 0.5
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 输入变量的初始值：0.5
- en: x: 0.757452532565767
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: x：0.757452532565767
- en: Maximum value: 25.0846622605419
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 最大值：25.0846622605419
- en: In this case, the closest peak at which the gradient ascent algorithm stops
    is not the true global maximum of the function. [Figure 7-6](ch07.html#ch7fig6)
    depicts the result of the gradient ascent algorithm for both of these scenarios.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，梯度上升算法停止的最近峰值并不是函数的真正全局最大值。[图 7-6](ch07.html#ch7fig6) 描述了这两种情况的梯度上升算法结果。
- en: '![image](images/f07-06.jpg)'
  id: totrans-398
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f07-06.jpg)'
- en: '*Figure 7-6: Results of the gradient ascent algorithm with different initial
    values. Gradient ascent always takes us to the closest peak.*'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：使用不同初始值的梯度上升算法结果。梯度上升总是将我们带到最近的峰值。*'
- en: Thus, when using this method, the initial value must be chosen carefully. Some
    variations of the algorithm try to address this limitation.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在使用此方法时，初始值必须谨慎选择。算法的一些变体试图解决这个限制。
- en: '***The Role of the Step Size and Epsilon***'
  id: totrans-401
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***步长和 Epsilon 的作用***'
- en: In the gradient ascent algorithm, the next value for the variable is calculated
    using the equation
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 在梯度上升算法中，下一步的变量值是通过以下方程计算的
- en: '![image](images/e0197-01.jpg)'
  id: totrans-403
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/e0197-01.jpg)'
- en: where *λ* is the *step size*. The step size determines the distance of the next
    step. It should be small to avoid going *over* a peak. That is, if the current
    value of *x* is close to the value that corresponds to the maximum value of the
    function, the next step shouldn’t be beyond the peak. The algorithm will then
    be unsuccessful. On the other hand, very small values will take longer to calculate.
    We’ve used a fixed step size of 10^(–3), but this may *not* be the most appropriate
    value for all functions.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *λ* 是 *步长*。步长决定了下一步的距离。它应该足够小，以避免“越过”一个峰值。也就是说，如果当前的 *x* 值接近于对应于函数最大值的 *x*
    值，那么下一步不应超过这个峰值，否则算法将失败。另一方面，过小的步长会导致计算时间更长。我们使用了固定的步长 10^(–3)，但这可能*不是*所有函数的最合适值。
- en: The value of epsilon (*ε*) that determines when we decide to stop the iteration
    of the algorithm should be a value that’s sufficiently small that we’re convinced
    the value of *x* is not changing. We expect the first derivative, *f*′(*x*), to
    be 0 at the maximum point, and ideally the absolute difference |*θ*[new] – *θ*[old]|
    is 0 (see step 2 of the gradient ascent algorithm on [page 192](ch07.html#page_192)).
    Due to numerical inaccuracies, however, we may not exactly get a difference of
    0; hence, the value of epsilon is chosen to be a value close to 0, which, for
    all practical purposes, would tell us that the value of *x* isn’t changing anymore.
    I have used 10^(–6) as the epsilon for all the functions. This value, although
    sufficiently small and suitable for the functions that have a solution for *f*′(*x*)
    = 0, such as sin(x), may not be the right value for other functions. Thus, it’s
    a good idea to verify the maximum value at the end to ensure its correctness and,
    if needed, to adjust the value for epsilon accordingly.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 决定何时停止算法迭代的 epsilon (*ε*) 值应该是一个足够小的值，以便我们可以确信 *x* 的值不再变化。我们期望在最大值点，*f*′(*x*)
    的导数为 0，理想情况下，绝对差值 |*θ*[new] – *θ*[old]| 应为 0（请参见 [第192页](ch07.html#page_192)的梯度上升算法的第二步）。然而，由于数值不准确，我们可能无法精确得到
    0 的差值；因此，选择一个接近 0 的 epsilon 值，这个值在实际应用中能够告诉我们 *x* 的值已经不再变化。我使用了 10^(–6) 作为所有函数的
    epsilon 值。这个值虽然足够小，并且适用于那些在 *f*′(*x*) = 0 下有解的函数，比如 sin(x)，但对于其他函数，这个值可能不是最合适的。因此，验证最终的最大值以确保其正确性是个好主意，并且如果需要，可以相应调整
    epsilon 的值。
- en: 'Step 2 of the gradient ascent algorithm also implies that for the algorithm
    to terminate, the equation *f*′(*x*) = 0 must have a solution, which isn’t the
    case for a function such as *e^x* or log(*x*). If you provide one of these functions
    as input to the preceding program, therefore, the program won’t give you a solution,
    and it will continue running. We can make the gradient ascent program more useful
    for such cases by incorporating a check for whether *f*′(*x*) = 0 has a solution.
    Here’s the modified program:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 梯度上升算法的第二步还意味着，为了使算法终止，方程 *f*′(*x*) = 0 必须有解，而像 *e^x* 或 log(*x*) 这样的函数则没有解。因此，如果你将这些函数之一作为输入提供给前面的程序，程序将无法给出解，并将继续运行。我们可以通过加入检查
    *f*′(*x*) = 0 是否有解来使梯度上升程序在这种情况下更加实用。以下是修改后的程序：
- en: ''''''''
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: ''''''''
- en: Use gradient ascent to find the maximum value of a
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 使用梯度上升法寻找 a 的最大值
- en: single-variable function. This also checks for the existence
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 单变量函数。这个过程也检查是否存在
- en: of a solution for the equation f'(x)=0.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 对于方程 f'(x)=0 的解
- en: ''''''''
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: ''''''''
- en: from sympy import Derivative, Symbol, sympify, solve
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: from sympy import Derivative, Symbol, sympify, solve
- en: 'def grad_ascent(x0, f1x, x):'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 'def grad_ascent(x0, f1x, x):'
- en: '# Check if f1x=0 has a solution'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '# 检查 f1x=0 是否有解'
- en: '➊     if not solve(f1x):'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '➊     如果 not solve(f1x):'
- en: print('Cannot continue, solution for {0}=0 does not exist'.format(f1x))
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: print('无法继续，{0}=0 的解不存在'.format(f1x))
- en: return
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: return
- en: epsilon = 1e-6
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: epsilon = 1e-6
- en: step_size = 1e-4
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: step_size = 1e-4
- en: x_old = x0
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: x_old = x0
- en: x_new = x_old + step_size*f1x.subs({x:x_old}).evalf()
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: x_new = x_old + step_size*f1x.subs({x:x_old}).evalf()
- en: 'while abs(x_old - x_new) > epsilon:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 'while abs(x_old - x_new) > epsilon:'
- en: x_old = x_new
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: x_old = x_new
- en: x_new = x_old + step_size*f1x.subs({x:x_old}).evalf()
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: x_new = x_old + step_size*f1x.subs({x:x_old}).evalf()
- en: return x_new
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: return x_new
- en: 'if __name__ == ''__main__'':'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: f = input('Enter a function in one variable: ')
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: f = input('请输入一个单变量函数：')
- en: var = input('Enter the variable to differentiate with respect to: ')
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: var = input('请输入需要对其求导的变量：')
- en: var0 = float(input('Enter the initial value of the variable: '))
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: var0 = float(input('请输入变量的初始值：'))
- en: 'try:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 'try:'
- en: f = sympify(f)
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: f = sympify(f)
- en: 'except SympifyError:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 'except SympifyError:'
- en: print('Invalid function entered')
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: print('输入的函数无效')
- en: 'else:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: var = Symbol(var)
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: var = Symbol(var)
- en: d = Derivative(f, var).doit()
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: d = 导数(f, var).doit()
- en: var_max = grad_ascent(var0, d, var)
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: var_max = grad_ascent(var0, d, var)
- en: '➋         if var_max:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '➋         如果 var_max:'
- en: print('{0}: {1}'.format(var.name, var_max))
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: print('{0}: {1}'.format(var.name, var_max))
- en: print('Maximum value: {0}'.format(f.subs({var:var_max})))
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: print('最大值：{0}'.format(f.subs({var:var_max})))
- en: In this modification of the grad_ascent() function, we call SymPy’s solve()
    function at ➊ to determine whether the equation *f*′(*x*) = 0, here f1x, has a
    solution. If not, we print a message and return. Another modification appears
    in the __main__ block at ➋. We check whether the grad_ascent() function successfully
    returned a result; if it did, then we proceed to print the maximum value of the
    function and the corresponding value of the variable.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 在 grad_ascent() 函数的这个修改中，我们在 ➊ 调用 SymPy 的 solve() 函数来判断方程 *f*′(*x*) = 0（这里是
    f1x）是否有解。如果没有解，我们打印一条信息并返回。另一个修改出现在 __main__ 块的 ➋。我们检查 grad_ascent() 函数是否成功返回结果；如果成功，则继续打印函数的最大值和相应的变量值。
- en: 'These changes let the program handle functions such as log(*x*) and *e^x*:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 这些改动使得程序能够处理诸如 log(*x*) 和 *e^x* 这样的函数：
- en: Enter a function in one variable: log(x)
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 输入一个单变量函数：log(x)
- en: Enter the variable to differentiate with respect to: x
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 输入需要对其求导的变量：x
- en: Enter the initial value of the variable: 0.1
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 输入变量的初始值：0.1
- en: Cannot continue, solution for 1/x=0 does not exist
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 无法继续，1/x=0 的解不存在
- en: You will see the same for *e^x*.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到相同的结果，*e^x*。
- en: '**GRADIENT DESCENT ALGORITHM**'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '**梯度下降算法**'
- en: 'The reverse algorithm of the gradient ascent algorithm is the gradient *descent*
    algorithm, which is a method to find the minimum value of a function. It is similar
    to the gradient ascent algorithm, but instead of “climbing up” along the function,
    we “climb down.” Challenge #2 on [page 205](ch07.html#page_205) discusses the
    difference between these two algorithms and gives you an opportunity to implement
    the reverse one.'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 梯度上升算法的逆算法是梯度*下降*算法，它是一种找到函数最小值的方法。它与梯度上升算法类似，不同之处在于，我们不是沿着函数“向上爬”，而是“向下爬”。[第205页](ch07.html#page_205)的挑战#2讨论了这两种算法的区别，并给你提供了实现逆算法的机会。
- en: '**Finding the Integrals of Functions**'
  id: totrans-450
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**寻找函数的积分**'
- en: The *indefinite integral*, or the *antiderivative*, of a function *f*(*x*) is
    another function *F*(*x*), such that *F*′(*x*) = *f*(*x*). That is, the integral
    of a function is another function whose derivative is the original function. Mathematically,
    it’s written as *F*(*x*) = ∫ *f*(*x*)*dx*. The *definite integral*, on the other
    hand, is the integral
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 *f*(*x*) 的*不定积分*，或称为*反导数*，是另一个函数 *F*(*x*)，使得 *F*′(*x*) = *f*(*x*)。也就是说，函数的积分是另一个函数，它的导数就是原函数。数学上表示为
    *F*(*x*) = ∫ *f*(*x*)*dx*。而*定积分*则是函数的积分，
- en: '![image](images/e0200-01.jpg)'
  id: totrans-452
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/e0200-01.jpg)'
- en: which is really *F*(*b*) – *F*(*a*), where *F*(*b*) and *F*(*a*) are the values
    of the anti-derivative of the function at *x* = *b* and at *x* = *a*, respectively.
    We can find both the integrals by creating an Integral object.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是 *F*(*b*) – *F*(*a*)，其中 *F*(*b*) 和 *F*(*a*) 是该函数在 *x* = *b* 和 *x* = *a*
    时的反导数值。我们可以通过创建一个积分对象来求解这两个积分。
- en: 'Here’s how we can find the integral ∫ *kxdx*, where *k* is a constant term:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何找到积分 ∫ *kxdx*，其中 *k* 是常数项：
- en: '>>> from sympy import Integral, Symbol'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> from sympy import Integral, Symbol'
- en: '>>> x = Symbol(''x'')'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x = Symbol(''x'')'
- en: '>>> k = Symbol(''k'')'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> k = Symbol(''k'')'
- en: '>>> Integral(k*x, x)'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 积分(k*x, x)'
- en: Integral(k*x, x)
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 积分(k*x, x)
- en: 'We import the Integral and Symbol classes and create two Symbol objects corresponding
    to k and x. Then, we create an Integral object with the function kx, specifying
    the variable to integrate with respect to x. Similar to Limit and Derivative classes,
    we can now evaluate the integral using the doit() method:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入Integral和Symbol类，并创建两个Symbol对象，分别对应于k和x。然后，我们使用函数kx创建一个积分对象，指定按x进行积分。类似于Limit和Derivative类，我们现在可以使用doit()方法计算积分：
- en: '>>> Integral(k*x, x).doit()'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> Integral(k*x, x).doit()'
- en: k*x**2/2
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: k*x**2/2
- en: The integral turns out to be *kx*²/2\. If you calculate the derivative of *kx*²/2,
    you’ll get back the original function, *kx*.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 积分的结果是*kx*²/2。如果你计算*kx*²/2的导数，你将得到原始函数*kx*。
- en: 'To find the *definite* integral, we simply specify the variable, the lower
    limit, and the upper limit as a tuple when we create the Integral object:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算*定积分*，我们只需在创建积分对象时指定变量、下限和上限作为一个元组：
- en: '>>> Integral(k*x, (x, 0, 2)).doit()'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> Integral(k*x, (x, 0, 2)).doit()'
- en: 2*k
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 2*k
- en: The result returned is the definite integral
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的结果是定积分
- en: '![image](images/e0200-02.jpg)'
  id: totrans-468
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/e0200-02.jpg)'
- en: It can be useful to visualize definite integrals by discussing them in a geometric
    context. Consider [Figure 7-7](ch07.html#ch7fig7), which shows the graph of the
    function *f*(*x*) = *x* between *x* = 0 and *x* = 5.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在几何上下文中讨论定积分，直观地理解它们是很有帮助的。考虑[图7-7](ch07.html#ch7fig7)，它展示了函数*f*(*x*) = *x*在*x*
    = 0和*x* = 5之间的图形。
- en: Now consider the region under the graph *ABDE*, which is bounded by the *x*-axis,
    between the points *x* = 2 and *x* = 4—points *A* and *B*, respectively. The area
    of the region can be found by adding the area of the square *ABCE* and the right-angled
    triangle *ECD*, which is 2 × 2 + (1/2) × 2 × 2 = 6.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑图形*ABDE*下的区域，该区域被*x*-轴以及点*x* = 2和*x* = 4——分别是点*A*和*B*——所界定。该区域的面积可以通过将平方区域*ABCE*的面积与直角三角形*ECD*的面积相加来计算，面积为2
    × 2 + (1/2) × 2 × 2 = 6。
- en: '![image](images/f07-07.jpg)'
  id: totrans-471
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f07-07.jpg)'
- en: '*Figure 7-7: The definite integral of a function between two points is the
    area enclosed by the graph of the function bounded by the* x-*axis.*'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-7：在两个点之间的定积分是由该函数的图形与*x*-轴围成的面积。*'
- en: 'Let’s now calculate the integral ![image](images/e0201-01.jpg):'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来计算积分！[image](images/e0201-01.jpg)：
- en: '>>> from sympy import Integral, Symbol'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> from sympy import Integral, Symbol'
- en: '>>> x = Symbol(''x'')'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x = Symbol(''x'')'
- en: '>>> Integral(x, (x, 2, 4)).doit()'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> Integral(x, (x, 2, 4)).doit()'
- en: '6'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: The value of the integral turns out to be the same as the area of the region
    *ABDE*. This isn’t a coincidence; you’ll find this is true for any function of
    *x* for which the integral can be determined.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 积分的值恰好等于区域*ABDE*的面积。这并非偶然；你会发现对于任何可以确定积分的函数*f*(*x*)，这一点都是成立的。
- en: Understanding that the definite integral is the area enclosed by the function
    between specified points on the *x*-axis is key for understanding probability
    calculations in random events that involve continuous random variables.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 理解定积分是由指定点之间的函数图形与*x*-轴围成的区域所组成的面积，这对于理解涉及连续随机变量的随机事件中的概率计算至关重要。
- en: '**Probability Density Functions**'
  id: totrans-480
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**概率密度函数**'
- en: Let’s consider a fictional class of students and their grades on a math quiz.
    Each student can earn a grade between 0 and 20, including fractional grades. If
    we treat the grade as a random event, the grade itself is a *continuous random
    variable* because it can have *any* value between 0 and 20\. If we want to calculate
    the probability of a student getting a grade between 11 and 12, we can’t apply
    the strategy we learned in [Chapter 5](ch05.html#ch05). To see why, let’s consider
    the formula, assuming uniform probability,
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个虚拟的学生班级及其数学测验成绩。每个学生可以获得0到20之间的成绩，包括分数。如果我们将成绩视为一个随机事件，则成绩本身是一个*连续随机变量*，因为它可以在0到20之间取*任何*值。如果我们想要计算一个学生获得11到12之间成绩的概率，我们不能应用在[第5章](ch05.html#ch05)中学到的策略。为了理解为什么，我们来看看公式，假设均匀概率，
- en: '![image](images/e0202-01.jpg)'
  id: totrans-482
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/e0202-01.jpg)'
- en: where *E* is the set of all grades possible between 11 and 12 and *S* is the
    set of all possible grades—that is, all real numbers between 1 and 20\. By our
    definition of the preceding problem, *n*(*E*) is infinite because it’s impossible
    to count all possible real numbers between 11 and 12; the same is true for *n*(*S*).
    Thus, we need a different approach to calculate the probability.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，*E*是11到12之间所有可能分数的集合，*S*是所有可能分数的集合——即1到20之间的所有实数。根据我们对前述问题的定义，*n*(*E*)是无限的，因为不可能数出11到12之间所有可能的实数；*n*(*S*)也同样如此。因此，我们需要采用不同的方法来计算概率。
- en: A *probability density function*, *P*(*x*), expresses the probability of the
    value of a random variable being *close* to *x*, an arbitrary value.[¹](footnote.html#fn05)
    It can also tell us the probability of *x* falling within an interval. That is,
    if we knew the probability density function representing the probability of grades
    in our fictional class, calculating *P*(11 < *x* < 12) would give us the probability
    that we’re looking for. But how do we calculate this? It turns out that this probability
    is the area enclosed by the graph of the probability density function and the
    *x*-axis between the points *x* = 11 and *x* = 12\. Assuming an arbitrary probability
    density function, [Figure 7-8](ch07.html#ch7fig8) demonstrates this.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *概率密度函数*，*P*(*x*)，表示随机变量的值接近 *x* 的概率，即某个任意值。[¹](footnote.html#fn05) 它还可以告诉我们
    *x* 落在某个区间内的概率。也就是说，如果我们知道表示我们虚构班级成绩概率的概率密度函数，计算 *P*(11 < *x* < 12) 就能给出我们所寻找的概率。那么，我们该如何计算呢？事实证明，这个概率就是概率密度函数图形与
    *x* 轴之间，在 *x* = 11 和 *x* = 12 之间的面积。假设一个任意的概率密度函数，[图 7-8](ch07.html#ch7fig8) 展示了这一点。
- en: '![image](images/f07-08.jpg)'
  id: totrans-485
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f07-08.jpg)'
- en: '*Figure 7-8: A probability density function for grades on a math quiz*'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-8：数学小测验成绩的概率密度函数*'
- en: We already know that this area is equal to the value of the integral,
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道，这个面积等于积分的值，
- en: '![image](images/e0203-01.jpg)'
  id: totrans-488
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/e0203-01.jpg)'
- en: thus, we have an easy way to find the probability of the grade lying between
    11 and 12\. With the math out of the way, we can now find out what the probability
    is. The probability density function we assumed earlier is the function
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有了一种简单的方法来计算成绩位于 11 和 12 之间的概率。计算完成后，我们可以得出所需的概率。我们之前假设的概率密度函数是
- en: '![image](images/e0203-02.jpg)'
  id: totrans-490
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/e0203-02.jpg)'
- en: where *x* is the grade obtained. This function has been chosen so that the probability
    of the grade being close to 10 (either greater or less than) is high but then
    decreases sharply.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *x* 是获得的成绩。这个函数的选择是为了使得成绩接近 10（无论是大于还是小于）的概率较高，但随后迅速下降。
- en: Now, let’s calculate the integral
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们计算积分
- en: '![image](images/e0203-03.jpg)'
  id: totrans-493
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/e0203-03.jpg)'
- en: 'with *p*(*x*) being the preceding function:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *p*(*x*) 是前面提到的函数：
- en: '>>> from sympy import Symbol, exp, sqrt, pi, Integral'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> from sympy import Symbol, exp, sqrt, pi, Integral'
- en: '>>> x = Symbol(''x'')'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x = Symbol(''x'')'
- en: '>>> p = exp(-(x - 10)**2/2)/sqrt(2*pi)'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> p = exp(-(x - 10)**2/2)/sqrt(2*pi)'
- en: '>>> Integral(p, (x, 11, 12)).doit().evalf()'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> Integral(p, (x, 11, 12)).doit().evalf()'
- en: '0.135905121983278'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: '0.135905121983278'
- en: We create the Integral object for the function, with p representing the probability
    density function that specifies that we want to calculate the definite integral
    between 11 and 12 on the *x*-axis. We evaluate the function using doit() and find
    the numerical value using evalf(). Thus, the probability that a grade lies between
    11 and 12 is close to 0.14.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为该函数创建了积分对象，其中 p 表示概率密度函数，指定我们要计算 *x* 轴上 11 到 12 之间的定积分。我们使用 doit() 评估该函数，并使用
    evalf() 找到数值结果。因此，成绩位于 11 和 12 之间的概率接近 0.14。
- en: '**THE PROBABILITY DENSITY FUNCTION: A CAVEAT**'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: '**概率密度函数：一个警告**'
- en: Strictly speaking, this density function assigns a nonzero probability to grades
    less than 0 or greater than 20\. However, as you can check using the ideas from
    this section, the probability of such an event is so small that it is negligible
    for our purposes.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，这个密度函数会对小于 0 或大于 20 的成绩分配一个非零的概率。然而，正如你可以通过本节的概念所验证的那样，这样的事件概率非常小，可以忽略不计。
- en: 'A probability density function has two special properties: (1) the function
    value for any *x* is always greater than 0, as probability can’t be less than
    0, and (2) the value of the definite integral'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 一个概率密度函数有两个特殊性质：（1）对于任何 *x*，函数值总是大于 0，因为概率不能小于 0；（2）定积分的值
- en: '![image](images/e0204-01.jpg)'
  id: totrans-504
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/e0204-01.jpg)'
- en: is equal to 1\. The second property merits some discussion. Because *p*(*x*)
    is a probability density function, the area enclosed by it, which is also the
    integral
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 等于 1。第二个性质值得讨论。因为 *p*(*x*) 是一个概率密度函数，它所围成的面积也是积分的值。
- en: '![image](images/e0204-02.jpg)'
  id: totrans-506
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/e0204-02.jpg)'
- en: 'between any two points, *x* = *a* and *x* = *b*, gives us the probability of
    *x* lying between *x* = *a* and *x* = *b*. This also means that no matter what
    the values of *a* and *b* are, the value of the integral must not exceed 1 because
    the probability can’t be greater than 1 by definition. Hence, even if *a* and
    *b* are very large values such that they tend to –∞ and ∞, respectively, the value
    of the integral will still be 1, as we can verify ourselves:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何两个点之间，*x* = *a* 和 *x* = *b*，给出了 *x* 在 *x* = *a* 和 *x* = *b* 之间的概率。这也意味着，无论
    *a* 和 *b* 的值是多少，积分的值都不能超过1，因为根据定义，概率不能大于1。因此，即使 *a* 和 *b* 是非常大的值，趋向于 –∞ 和 ∞，积分的值仍然是1，正如我们自己可以验证的那样：
- en: '>>> from sympy import Symbol, exp, sqrt, pi, Integral, S'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> from sympy import Symbol, exp, sqrt, pi, Integral, S'
- en: '>>> x = Symbol(''x'')'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x = Symbol(''x'')'
- en: '>>> p = exp(-(x – 10)**2/2)/sqrt(2*pi)'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> p = exp(-(x – 10)**2/2)/sqrt(2*pi)'
- en: '>>> Integral(p, (x, S.NegativeInfinity, S.Infinity)).doit().evalf()'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> Integral(p, (x, S.NegativeInfinity, S.Infinity)).doit().evalf()'
- en: '1.00000000000000'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '1.00000000000000'
- en: S.NegativeInfinity and S.Infinity denote the negative and positive infinity
    that we then specify as the lower and upper limits, respectively, while creating
    the Integral object.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: S.NegativeInfinity和S.Infinity分别表示我们在创建积分对象时指定的负无穷和正无穷的下限和上限。
- en: When we’re dealing with continuous random variables, a tricky situation can
    arise. In discrete probability, the probability of an event such as a fair six-sided
    die rolling a 7 is 0\. We call an event for which the probability is 0 an *impossible*
    event. In the case of continuous random variables, the probability of the variable
    assuming any exact value is 0, even though it may be a *possible* event. For example,
    the grade of a student being exactly 11.5 is possible, but due to the nature of
    continuous random variables, the probability is 0\. To see why, consider that
    the probability will be the value of the integral
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理连续随机变量时，可能会遇到一些棘手的情况。在离散概率中，像掷一个公平的六面骰子得到7这样的事件概率是0。我们称概率为0的事件为*不可能*事件。在连续随机变量的情况下，尽管某个特定值可能是*可能*的事件，但变量取得该值的概率是0。例如，学生成绩恰好为11.5是可能的，但由于连续随机变量的性质，概率为0。要理解为什么，考虑概率是积分的值
- en: '![image](images/e0204-03.jpg)'
  id: totrans-515
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/e0204-03.jpg)'
- en: Because this integral has the same lower and upper limits, its value is 0\.
    This is rather unintuitive and paradoxical, so let’s try to understand it.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这个积分的上下限相同，所以它的值是0。这是相当不直观和自相矛盾的，因此让我们试着理解它。
- en: Consider the range of grades we addressed earlier—0 to 20\. The grade a student
    can obtain can be any number in this interval, which means there is an infinite
    number of numbers. If each number were to have an equal probability of being selected,
    what would that probability be? According to the formula for discrete probability,
    this should be 1/∞, which means a very small number. In fact, this number is so
    small that for all practical purposes, it’s considered 0\. Hence, the probability
    of the grade being 11.5 is 0.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑我们之前讨论的成绩范围——0到20。学生可以获得的成绩是这个区间内的任意数字，这意味着有无限多个数字。如果每个数字的选择概率相等，那么这个概率是多少呢？根据离散概率公式，这应该是1/∞，也就是说，这是一个非常小的数字。事实上，这个数字小到在实际应用中可以视为0。因此，成绩为11.5的概率是0。
- en: '**What You Learned**'
  id: totrans-518
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to find the limits, derivatives, and integrals
    of functions. You learned about the gradient ascent method for finding the maximum
    value of a function and saw how you can apply integration principles to calculate
    the probability of continuous random variables. Next, you have a few tasks to
    attempt.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了如何找到函数的极限、导数和积分。你了解了用于寻找函数最大值的梯度上升法，并看到如何应用积分原理来计算连续随机变量的概率。接下来，你有几个任务可以尝试。
- en: '**Programming Challenges**'
  id: totrans-520
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**编程挑战**'
- en: The following challenges build on what you’ve learned in this chapter. You can
    find sample solutions at *[http://www.nostarch.com/doingmathwithpython/](http://www.nostarch.com/doingmathwithpython/)*.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 以下挑战基于你在本章中学到的内容。你可以在*[http://www.nostarch.com/doingmathwithpython/](http://www.nostarch.com/doingmathwithpython/)*找到示例解答。
- en: '***#1: Verify the Continuity of a Function at a Point***'
  id: totrans-522
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***#1：验证函数在某点的连续性***'
- en: A necessary, but not sufficient, condition for a function to be differentiable
    at a point is that it must be continuous at that point. That is, the function
    must be defined at that point and its left-hand limit and right-hand limit must
    exist and be equal to the value of the function at that point. If *f*(*x*) is
    the function and *x* = *a* is the point we are interested in evaluating, this
    is mathematically stated as
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 一个函数在某点可微的必要条件是它必须在该点连续。也就是说，函数必须在该点定义，并且其左极限和右极限必须存在且等于该点的函数值。如果 *f*(*x*) 是函数，且
    *x* = *a* 是我们感兴趣的评价点，那么可以数学地表示为
- en: '![image](images/e0205-01.jpg)'
  id: totrans-524
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/e0205-01.jpg)'
- en: Your challenge here is to write a program that will (1) accept a single-variable
    function and a value of that variable as inputs and (2) check whether the input
    function is continuous at the point where the variable assumes the value input.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 你的挑战是编写一个程序，该程序将（1）接受一个单变量函数和该变量的值作为输入，并（2）检查输入的函数在变量取值时是否连续。
- en: 'Here is a sample working of the completed solution:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 这是完成解法的一个示例：
- en: Enter a function in one variable: 1/x
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 输入一个单变量函数：1/x
- en: Enter the variable: x
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 输入变量：x
- en: Enter the point to check the continuity at: 1
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 输入要检查连续性的点：1
- en: 1/x is continuous at 1.0
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 1/x 在 1.0 处是连续的
- en: 'The function 1/*x* is discontinuous at 0, so let’s check that:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 1/*x* 在 0 处是间断的，所以我们来检查一下：
- en: Enter a function in one variable: 1/x
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 输入一个单变量函数：1/x
- en: Enter the variable: x
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 输入变量：x
- en: Enter the point to check the continuity at: 0
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 输入要检查连续性的点：0
- en: 1/x is not continuous at 0.0
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 1/x 在 0.0 处不是连续的
- en: '***#2: Implement the Gradient Descent***'
  id: totrans-536
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***#2：实现梯度下降***'
- en: 'The gradient descent method is used to find the minimum value of a function.
    Similar to the gradient ascent method, the gradient descent method is an iterative
    method: we start with an initial value of the variable and gradually get closer
    to the variable value that corresponds to the minimum value of the function. The
    step that gets us closer is the equation'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 梯度下降法用于寻找函数的最小值。与梯度上升法类似，梯度下降法是一种迭代方法：我们从变量的初始值开始，逐渐接近对应于函数最小值的变量值。让我们更接近的步骤是方程
- en: '![image](images/e0206-01.jpg)'
  id: totrans-538
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/e0206-01.jpg)'
- en: where *λ* is the step size and
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *λ* 是步长，且
- en: '![image](images/e0206-02.jpg)'
  id: totrans-540
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/e0206-02.jpg)'
- en: is the result of differentiating the function. Thus, the only difference from
    the gradient ascent method is how we obtain the value of x_new from x_old.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 是函数的导数结果。因此，与梯度上升法的唯一区别是如何通过 x_new 从 x_old 获取值。
- en: Your challenge is to implement a generic program using the gradient descent
    algorithm to find the minimum value of a single-variable function specified as
    input by the user. The program should also create a graph of the function and
    show all the intermediate values it found before finding the minimum. (You may
    want to refer to [Figure 7-5](ch07.html#ch7fig5) on [page 193](ch07.html#page_193).)
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 你的挑战是使用梯度下降算法实现一个通用程序，找到用户输入的单变量函数的最小值。程序还应该创建该函数的图形，并显示在找到最小值之前它找到的所有中间值。（你可能需要参考[图
    7-5](ch07.html#ch7fig5)，在[第 193 页](ch07.html#page_193)。）
- en: '***#3: Area Between Two Curves***'
  id: totrans-543
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***#3：两曲线之间的面积***'
- en: We learned that the integral
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学到，积分
- en: '![image](images/e0206-03.jpg)'
  id: totrans-545
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/e0206-03.jpg)'
- en: expresses the area enclosed by the function *f*(*x*), with the *x*-axis between
    *x* = *a* and *x* = *b*. The area between two curves is thus expressed as the
    integral
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 表示由函数 *f*(*x*) 和 *x* 轴围成的区域，在 *x* = *a* 和 *x* = *b* 之间。因此，两个曲线之间的面积表示为积分
- en: '![image](images/e0206-04.jpg)'
  id: totrans-547
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/e0206-04.jpg)'
- en: where *a* and *b* are the points of intersection of the two curves with *a*
    < *b*. The function *f*(*x*) is referred to as the *upper function* and *g*(*x*)
    as the *lower function*. [Figure 7-9](ch07.html#ch7fig9) illustrates this, assuming
    *f*(*x*) = *x* and *g*(*x*) = *x*², with *a* = 0 and *b* = 1.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *a* 和 *b* 是两条曲线的交点，且 *a* < *b*。函数 *f*(*x*) 称为 *上函数*，*g*(*x*) 称为 *下函数*。[图
    7-9](ch07.html#ch7fig9) 说明了这一点，假设 *f*(*x*) = *x* 且 *g*(*x*) = *x*²，且 *a* = 0 和
    *b* = 1。
- en: Your challenge here is to write a program that will allow the user to input
    any two single-variable functions of *x* and print the enclosed area between the
    two. The program should make it clear that the first function entered should be
    the upper function, and it should also ask for the values of *x* between which
    to find the area.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 你的挑战是编写一个程序，允许用户输入任何两个单变量的 *x* 函数，并打印出它们之间的包围面积。程序应该明确指出，首先输入的函数应该是上函数，并且还应询问
    *x* 的取值范围，来计算该区域的面积。
- en: '![image](images/f07-09.jpg)'
  id: totrans-550
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f07-09.jpg)'
- en: '*Figure 7-9: The functions* f*(*x*) =* x *and* g*(*x*) =* x*² enclose an area
    between* x = *0 and* x = *1.0.*'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-9：函数* f*(*x*) =* x 和* g*(*x*) =* x*² 在* x = *0 和* x = *1.0* 之间包围了一个区域。*'
- en: '***#4: Finding the Length of a Curve***'
  id: totrans-552
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***#4：求曲线长度***'
- en: Let’s say you just completed cycling along a road that looks roughly like [Figure
    7-10](ch07.html#ch7fig10). Because you didn’t have an odometer, you want to know
    whether there’s a mathematical way to determine the distance you cycled. First,
    we’ll need to find an equation—even an approximation will do— that describes this
    path.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你刚刚完成了沿着一条大致如[图 7-10](ch07.html#ch7fig10)所示的道路骑行。由于你没有里程表，你希望知道是否有一种数学方法来确定你骑行的距离。首先，我们需要找到一个方程——即使是一个近似的方程——来描述这条路径。
- en: '![image](images/f07-10.jpg)'
  id: totrans-554
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f07-10.jpg)'
- en: '*Figure 7-10: An approximation of the cycling path*'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-10：骑行路径的近似图*'
- en: Notice how it looks very similar to the quadratic functions we’ve discussed
    in the earlier chapters? In fact, for this challenge, let’s assume that the equation
    is *y* = *f*(*x*) = 2*x*² + 3*x* + 1 and that you cycled from point *A* (–5, 36)
    to point *B* (10, 231). To find the length of this arc—that is, the distance you
    cycled—we’ll need to calculate the integral
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 注意它看起来和我们在前面章节讨论的二次函数非常相似吗？实际上，对于这个挑战，我们假设方程是 *y* = *f*(*x*) = 2*x*² + 3*x*
    + 1，且你从点 *A* (–5, 36) 骑行到点 *B* (10, 231)。为了找到这个弧线的长度——也就是你骑行的距离——我们需要计算积分。
- en: '![image](images/e0208-01.jpg)'
  id: totrans-557
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/e0208-01.jpg)'
- en: where *y* describes the preceding function. Your challenge here is to write
    a program that will calculate the length of the arc, *AB*.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *y* 描述了前面的函数。你的挑战是编写一个程序来计算弧长 *AB*。
- en: You may also want to generalize your solution so that it allows you to find
    the length of the arc between any two points for any arbitrary function, *f*(*x*).
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 你也许还希望将你的解决方案推广，使其可以用来计算任意两个点之间任意函数 *f*(*x*) 的弧长。
