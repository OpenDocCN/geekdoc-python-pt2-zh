- en: '6'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '6'
- en: DESIGNING PROGRAMS WITH FUNCTIONS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*函数*设计程序
- en: '![image](Images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/common.jpg)'
- en: When writing large programs, it’s important to organize our code into smaller
    logical pieces, each of which contributes to the overall goal. That way, we’ll
    be able to think about each piece on its own, without worrying about what other
    pieces are doing. Then we’ll put the pieces together. These pieces are called
    *functions*.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写大型程序时，组织代码为更小的逻辑单元非常重要，每个单元都为实现整体目标做出贡献。这样，我们就能单独考虑每个单元，而不用担心其他单元在做什么。然后我们将这些单元组合在一起。这些单元被称为*函数*。
- en: 'In this chapter, we’ll use functions to break down and solve two problems:
    calculating the score in a two-player card game and determining whether boxes
    of action figures can be nicely organized.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用函数来分解并解决两个问题：计算双人卡牌游戏的得分以及判断动作人偶盒子是否能够合理组织。
- en: 'Problem #14: Card Game'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '问题 #14：卡牌游戏'
- en: In this problem, we’ll implement a two-player card game. As part of thinking
    through the problem, we’ll find that the same bit of logic crops up several times.
    We’ll learn how to bundle this code into a Python function to avoid code duplication
    and enhance code clarity.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个问题中，我们将实现一个双人卡牌游戏。在思考问题的过程中，我们会发现相同的逻辑会多次出现。我们将学习如何将这部分代码封装成一个 Python 函数，以避免代码重复并提高代码的清晰度。
- en: This is DMOJ problem `ccc99s1`.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 DMOJ 问题 `ccc99s1`。
- en: The Challenge
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战
- en: Two players, A and B, are playing a card game. (You don’t need to know about
    playing cards or card games to understand this problem.)
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 两名玩家，A 和 B，正在进行一场卡牌游戏。（你不需要了解扑克牌或卡牌游戏才能理解这个问题。）
- en: The game starts with a deck of 52 cards. Player A takes a card from the deck,
    then player B takes a card from the deck, then player A, then player B, until
    there are no cards left in the deck.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏开始时有一副 52 张牌。玩家 A 从牌堆中抽取一张牌，然后玩家 B 抽取一张牌，然后是玩家 A，再然后是玩家 B，直到牌堆中没有牌为止。
- en: 'There are 13 types of cards in the deck. These types are as follows: two, three,
    four, five, six, seven, eight, nine, ten, jack, queen, king, ace. There are four
    cards of each of these types in the deck. For example, there are four twos, four
    threes, and so on, all the way up to four aces. (That’s why there are 52 cards
    in the deck: 13 types times 4 cards per type.)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 牌堆中有 13 种类型的牌。这些类型如下：二、三、四、五、六、七、八、九、十、杰克、皇后、国王、王牌。每种类型的牌在牌堆中都有四张。例如，有四张二、四张三，以此类推，一直到四张王牌。（这就是为什么牌堆中有
    52 张牌：13 种类型乘以每种类型 4 张牌。）
- en: 'A *high card* is a card that is a jack, queen, king, or ace. When a player
    takes a high card, they may score some points. Here are the rules by which points
    are scored:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*高牌*是指杰克、皇后、国王或王牌。当玩家抽到一张高牌时，他们可能会得分。以下是得分规则：'
- en: If a player takes a jack, after which there is at least one card remaining in
    the deck, and the next card in the deck is not a high card, then the player scores
    1 point.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果玩家抽到一张杰克，且此时牌堆中至少还有一张牌，并且下一张牌不是高牌，那么该玩家得 1 分。
- en: If a player takes a queen, after which there are at least two cards remaining
    in the deck, and neither of the next two cards in the deck is a high card, then
    the player scores 2 points.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果玩家抽到一张皇后，且此时牌堆中至少还有两张牌，并且接下来的两张牌中没有高牌，那么该玩家得 2 分。
- en: If a player takes a king, after which there are at least three cards remaining
    in the deck, and none of the next three cards in the deck is a high card, then
    the player scores 3 points.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果玩家抽到一张国王，且此时牌堆中至少还有三张牌，并且接下来的三张牌中没有高牌，那么该玩家得 3 分。
- en: If a player takes an ace, after which there are at least four cards remaining
    in the deck, and none of the next four cards in the deck is a high card, then
    the player scores 4 points.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果玩家抽到一张王牌，且此时牌堆中至少还有四张牌，并且接下来的四张牌中没有高牌，那么该玩家得 4 分。
- en: We’re asked to output information each time a player scores, as well as the
    total score for each player at the end of the game.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在每次玩家得分时输出信息，并在游戏结束时输出每个玩家的总分。
- en: Input
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输入
- en: The input consists of 52 lines. Each line contains the type of a card in the
    deck. The lines are in the order that cards will be taken from the deck; that
    is, the first line is the first card taken from the deck, the second line is the
    second card taken, and so on.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 输入由 52 行组成。每一行包含一张牌的类型。这些行是从牌堆中抽取的顺序；也就是说，第一行是从牌堆中抽取的第一张牌，第二行是第二张牌，以此类推。
- en: Output
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输出
- en: 'Whenever a player scores, output the following line:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 每当玩家得分时，输出以下内容：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: where p is `A` for player A or `B` for player B, and q is the number of points
    that they just scored.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，p代表玩家A为`A`，玩家B为`B`，q代表他们刚得的分数。
- en: 'When the game ends, output the following two lines:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏结束时，输出以下两行：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: where m is the total score for player A and n is the total score for player
    B.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，m是玩家A的总分，n是玩家B的总分。
- en: Exploring a Test Case
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探索一个测试用例
- en: If you think through how to solve this problem, you might be left wondering
    whether we can just solve it, right now, without learning anything new. Indeed,
    we can! We’re in great shape. We can use a list to represent the deck of cards.
    We know how to use the list `append` method to add a card to the deck. We can
    access values in the list to look for high cards. We’ve even got f-strings to
    help us output the player and points information.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细考虑如何解决这个问题，你可能会想，是否可以在不学习任何新知识的情况下，直接解决它。事实上，我们可以！我们处于非常有利的状态。我们可以用列表表示牌堆。我们知道如何使用列表的`append`方法将一张牌添加到牌堆中。我们可以访问列表中的值来查找高牌。我们甚至可以使用f-strings来帮助我们输出玩家和分数的信息。
- en: Rather than dive in, though, let’s go through a small example. Doing so is going
    to highlight that we’re missing one crucial feature of Python that will make it
    easier to organize our solution and solve this problem.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，在深入探讨之前，我们先通过一个小例子来演示。这样做将突显出我们缺少一个Python中至关重要的特性，这个特性将使得我们更容易组织解决方案并解决这个问题。
- en: 'We’ll be here all year if we go through a 52-card example, so let’s use a smaller
    one with just 10 cards. This isn’t a complete test case, so the program we write
    won’t work on it, but it’s enough for us to understand the mechanics of the game
    and what our solution will have to do. Here’s the test case:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们用一副52张牌的例子来演示，那我们得忙到明年了。所以我们使用一个只有10张牌的小例子。这个例子不是一个完整的测试用例，所以我们写的程序无法在其上运行，但它足以帮助我们理解游戏的机制以及我们的解决方案需要做些什么。以下是测试用例：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Player A takes the first card, which is a queen. A queen is a high card, and
    player A might score 2 points here. First, we confirm that there are at least
    two cards remaining in the deck after this queen. Next, we have to check these
    next two cards, hoping there is no high card among them. The next two cards are
    not high cards—they are a three and a seven—so player A gets 2 points.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家A拿到了第一张牌，那是一个皇后牌。皇后牌是高牌，玩家A可能会得到2分。首先，我们确认这张皇后之后，牌堆中至少剩下两张牌。接着，我们需要检查这两张牌，希望其中没有高牌。这两张牌不是高牌——分别是三号牌和七号牌——所以玩家A得到了2分。
- en: Player B now takes the second card, which is a three. Three isn’t a high card,
    so no points for player B.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家B现在拿到第二张牌，那是三号牌。三号牌不是高牌，所以玩家B没有得分。
- en: Player A now takes the seven. No points.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家A现在拿到七号牌，没有得分。
- en: Player B now takes the king, so there’s a chance for 3 points for player B.
    There are at least three cards remaining in the deck after this king. We have
    to check these next three cards, hoping there is no high card among them. Sadly,
    there is a high card, a jack, among those three. No points for player B.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家B现在拿到国王牌，因此有机会得到3分。国王牌之后，牌堆中至少剩下三张牌。我们需要检查这三张牌，希望其中没有高牌。不幸的是，其中有一张高牌——杰克——所以玩家B没有得分。
- en: Player A now takes the nine. No points.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家A现在拿到九号牌，没有得分。
- en: 'Player B now takes the first jack. There is at least one card remaining in
    the deck after this jack. We have to check this next card, hoping it isn’t a high
    card. Good news: it’s not a high card—it’s an eight—so player B gets 1 point.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家B现在拿到第一张杰克牌。在这张杰克牌之后，牌堆中至少剩下一张牌。我们需要检查这张牌，希望它不是高牌。好消息：它不是高牌——是八号牌——所以玩家B得到了1分。
- en: There’s only one more point scored, and it’s by player A when they take the
    second-last card (the jack) from the deck.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 只剩下最后一分了，这一分由玩家A获得，当他们从牌堆中拿到倒数第二张牌（杰克）时。
- en: 'Therefore, this is the output for this test case:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这是这个测试用例的输出：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Notice that each time a player takes a high card, we need to check two things:
    that there are at least a certain number of cards remaining in the deck and that
    there is no high card among these cards. The first we should be able to manage
    by using a variable that tells us how many cards have been taken. The second is
    more difficult. We’d need some code to check a given number of cards for a high
    card. Worse, if we’re not careful, we’d end up duplicating very similar code four
    times: once to check the card after a jack, once to check the two cards after
    a queen, once to check the three cards after a king, and once to check the four
    cards after an ace. If we later found a flaw in our logic, we would have to fix
    it in up to four different places.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，每次玩家拿到一张高牌时，我们需要检查两件事：第一，剩余的牌堆中是否至少还有一定数量的牌；第二，剩下的牌中是否没有高牌。第一个问题我们可以通过一个变量来管理，它会告诉我们已经拿了多少张牌。第二个问题则更复杂。我们需要一些代码来检查给定数量的牌中是否有高牌。更糟糕的是，如果我们不小心，我们会重复写四次非常相似的代码：一次检查拿到一张杰克后的牌，一次检查拿到一张皇后的两张牌，一次检查拿到一张国王后的三张牌，最后一次检查拿到一张王牌后的四张牌。如果我们后来发现逻辑有问题，我们就必须在多达四个不同的地方进行修正。
- en: Is there a Python feature that lets us package that “no high cards here” logic,
    just once, and invoke it four times? There is. It’s called a *function*, and it’s
    just a named block of code that carries out a small task. Functions are essential
    to the organization and clarity of our code. All programmers use them. Without
    them, writing large software systems like games and word processors would be untenable.
    Let’s learn how to use functions.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 是否有 Python 特性可以让我们将这段“没有高牌”的逻辑仅封装一次，然后调用四次呢？有的。这就是所谓的*函数*，它是一个命名的代码块，用来执行一个小任务。函数对于我们代码的组织和清晰度至关重要。所有程序员都会使用它们。如果没有函数，编写像游戏和文字处理器这样的庞大软件系统将变得不可行。让我们学习如何使用函数。
- en: Defining and Calling Functions
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义和调用函数
- en: 'We’ve already learned how to call functions that come with Python. For example,
    we’ve used the `input` function to read input. Here’s a call of `input` with no
    arguments:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了如何调用 Python 自带的函数。例如，我们使用了`input`函数来读取输入。这里是没有参数的`input`函数调用：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We’ve also used Python’s `print` function to output text. Here’s a call of
    `print` with one argument:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用了 Python 的`print`函数来输出文本。这里是带有一个参数的`print`函数调用：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The built-in Python functions are general-purpose, designed to be used in a
    wide variety of settings. When we want a function to solve a problem-specific
    task, we’ll have to define it ourselves.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 内建的 Python 函数是通用的，旨在在各种不同的场景中使用。当我们需要一个函数来解决特定任务时，我们就得自己定义一个。
- en: Functions Without Arguments
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 没有参数的函数
- en: 'To *define*, or create, a function, we use Python’s `def` keyword. Here’s the
    definition of a function that outputs three lines:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要*定义*或创建一个函数，我们使用 Python 的`def`关键字。这里是一个输出三行的函数定义：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The structure of a function definition mirrors that of an `if` statement or
    loop. The name after `def` is the name of the function that we’re defining; here,
    we’re defining a function named `intro`. Following the name of the function, we
    have a pair of empty parentheses, `()`. We’ll see later that we can include information
    in these parentheses to pass arguments to functions. This `intro` function doesn’t
    take any arguments, which is why the parentheses are empty. Following the parentheses
    is a colon; as with `if` statements or loops, leaving out the colon is a syntax
    error. On the following lines, we provide an indented block of statements that
    will run each time the function is called.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 函数定义的结构类似于`if`语句或循环。`def`后面的名称是我们正在定义的函数名；在这里，我们定义了一个名为`intro`的函数。在函数名后面是一个空的圆括号`()`。稍后我们会看到，我们可以在这些括号中包含信息来传递参数给函数。这个`intro`函数没有接受任何参数，所以括号是空的。括号后面是一个冒号；就像`if`语句或循环一样，省略冒号会导致语法错误。在接下来的行中，我们提供了一段缩进的语句块，每次调用该函数时，这些语句将被执行。
- en: 'When you defined the `intro` function, you may have expected to see this as
    output:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当你定义`intro`函数时，你可能希望看到如下的输出：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'But no: so far we’ve only defined the function, not called it. Defining a function
    has no observable effect; it simply stores the function in the computer’s memory
    so we can call it later. We call our own functions just like we call any of Python’s
    built-in functions. Since this `intro` function doesn’t take any arguments, we
    use an empty set of parentheses in the call:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 但是不行：到目前为止我们只是定义了函数，并没有调用它。定义函数不会产生任何可见的效果；它只是将函数存储在计算机的内存中，以便我们稍后调用。我们调用自定义函数的方式就像调用Python的内置函数一样。由于这个`intro`函数不需要任何参数，我们在调用时使用一个空的括号：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can call this function as many times as you like. It’s there as often as
    we need it.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以根据需要多次调用这个函数。它会在我们需要时随时存在。
- en: Functions with Arguments
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 带参数的函数
- en: 'Our `intro` function isn’t very flexible, as it does the same thing each time
    it’s called. We can change the function so that we can pass arguments to it, and
    the arguments we pass can influence what the function does. Here’s a new version
    of the `intro` function that allows us to pass a single argument:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`intro`函数不够灵活，因为每次调用时它做的事情都是一样的。我们可以修改这个函数，使得我们可以传入参数，并且传入的参数可以影响函数的行为。这里是一个新的`intro`函数版本，它允许我们传入一个参数：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To call this function, we provide a string argument:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用这个函数，我们提供一个字符串参数：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can’t call this `intro2` function without an argument—if we try, we get
    an error:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能在没有参数的情况下调用`intro2`函数——如果尝试调用，将会报错：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The error reminds us that we have not provided an argument for `message`. The
    name `message` is known as a function *parameter*. When we call `intro2`, Python
    first makes `message` refer to whatever our argument refers to; that is, `message`
    becomes an alias for our argument.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 错误提醒我们没有为`message`提供参数。`message`是一个函数*参数*。当我们调用`intro2`时，Python首先让`message`指向我们传入的参数；也就是说，`message`成为了我们参数的别名。
- en: 'We can create functions with more than one parameter. Here’s a function that
    takes two parameters, a message to print and the number of times to print it:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建具有多个参数的函数。这里是一个需要两个参数的函数，一个是要打印的消息，另一个是打印的次数：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To call this one, we provide two arguments. Python works from left to right,
    assigning the first argument to the first parameter and the second argument to
    the second parameter. In the following call, `''high''` is assigned to the `message`
    parameter and `5` is assigned to the `num_times` parameter:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用这个函数，我们提供两个参数。Python从左到右工作，将第一个参数赋给第一个参数，第二个参数赋给第二个参数。在以下调用中，`'high'`被赋值给`message`参数，`5`被赋值给`num_times`参数：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Be sure to provide the correct number of arguments. For `intro3`, we need two
    arguments. Anything else is an error:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要提供正确数量的参数。对于`intro3`，我们需要两个参数。任何其他情况都会导致错误：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We also have to be sure to provide values of the proper types. Wrong types
    won’t stop us from calling the function, but they will cause an error within the
    function:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须确保提供正确类型的值。错误的类型不会阻止我们调用函数，但会导致函数内部出错：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This `TypeError` arises because `intro3` uses a range `for` loop on variable
    `num_times`. If the argument we provide for `num_times` is not an integer, the
    range `for` loop fails.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`TypeError`错误是由于`intro3`使用了`for`循环遍历`num_times`变量。如果我们为`num_times`提供的参数不是整数，`for`循环就会失败。
- en: Keyword Arguments
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 关键字参数
- en: 'It’s possible to override the left-to-right correspondence between arguments
    and parameters when calling a function. To do that, we use the names of parameters
    in whatever order we like. An argument that uses the name of a parameter is called
    a *keyword argument*. Here’s how it works:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用函数时，实际上可以覆盖参数和参数值从左到右的对应关系。为了做到这一点，我们可以按照任何顺序使用参数的名称。使用参数名称的参数被称为*关键字参数*。下面是它的工作方式：
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Each function call here uses two keyword arguments. A keyword argument is written
    as the name of a parameter, an equal sign, and its corresponding argument.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的每个函数调用都使用了两个关键字参数。关键字参数的写法是参数名、等号和对应的参数值。
- en: 'You can even start with regular arguments and finish with keyword arguments:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以先使用普通参数，然后再使用关键字参数：
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'But once you use a keyword argument, you can’t go back to regular ones:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 但是一旦你使用了关键字参数，就不能再回到普通参数了：
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In “Sorting a List” in [Chapter 5](ch05.xhtml#ch05) we used a `reverse` keyword
    argument when calling the `sort` method. The Python designers decided that `reverse`
    would be a keyword-only parameter, which means that it’s impossible to fill in
    its value without using a keyword argument. Python lets us do that with our functions,
    too, but we won’t need that level of control in this book.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](ch05.xhtml#ch05)的“排序列表”中，我们在调用`sort`方法时使用了`reverse`关键字参数。Python的设计者决定将`reverse`设置为仅限关键字的参数，这意味着在没有使用关键字参数的情况下，无法为它填充值。Python也允许我们在函数中使用这种方式，但在本书中我们不需要这种级别的控制。
- en: Local Variables
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 局部变量
- en: 'Names of parameters work like regular variables, but are *local* to the function
    in which they’re defined. That is, a function parameter doesn’t exist outside
    of its function:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 参数的名称就像普通变量一样工作，但它们是*局部*的，仅限于定义它们的函数。也就是说，函数参数在其函数外部是不存在的：
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'What about that `line_length` variable—is it local, too? It is:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 那个`line_length`变量怎么样，是局部变量吗？是的：
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'What happens if you have a variable and you call a function that uses a parameter
    or local variable of the same name? Is your value lost? Let’s see:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个变量，并且调用一个使用相同名称的参数或局部变量的函数，会发生什么？你的值会丢失吗？让我们来看一下：
- en: '[PRE21]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Phew—it’s still `999`, just as we left it. Local variables are created when
    a function is called and destroyed when the function terminates, all without affecting
    other variables with shared names.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 呼——它仍然是`999`，就像我们离开时一样。局部变量在函数被调用时创建，在函数结束时销毁，而不会影响其他具有相同名称的变量。
- en: A function can access a variable that was created outside of that function.
    It’s ill-advised to rely on that, though, because then that function isn’t self-contained,
    instead hoping that variables it expects to be there are actually there. In this
    book, we’ll write functions so that they only use local variables. All information
    that a function needs will be provided to the function through its parameters.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一个函数可以访问在函数外部创建的变量。然而，依赖于这种做法并不明智，因为这样会导致该函数不具备自我封装性，而是依赖于期望存在的变量是否真的存在。在本书中，我们将编写只使用局部变量的函数。函数所需的所有信息都会通过参数提供给它。
- en: Mutable Parameters
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 可变参数
- en: 'Since a parameter is an alias for its corresponding argument, it can be used
    to change a mutable value. Here’s a function that removes all occurrences of `value`
    from a list `lst`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 由于参数是对应参数的别名，它可以用来改变一个可变值。这里有一个函数，用来从列表`lst`中移除所有出现的`value`：
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Notice that we passed a list to `remove_all` by using a variable. This function
    won’t accomplish anything useful if you call it with a list value directly (rather
    than with a variable referring to a list):'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们通过使用变量传递了一个列表给`remove_all`。如果你直接传递一个列表值（而不是一个引用该列表的变量），这个函数将不会完成任何有用的操作：
- en: '[PRE23]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The function removed all the 5s from the list, but because we didn’t use a variable,
    we have no way to refer to that list ever again.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数移除了列表中的所有5，但由于我们没有使用一个变量，我们再也无法引用这个列表。
- en: '**CONCEPT CHECK**'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念检查**'
- en: What is the output of the following code?
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码的输出是什么？
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: A. `a [1]`
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: A. `a [1]`
- en: B. `a [1, 2]`
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: B. `a [1, 2]`
- en: C. `A [1]`
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: C. `A [1]`
- en: D. `A [1, 2]`
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: D. `A [1, 2]`
- en: 'Answer: A. When `mystery` is called, its `s` parameter is made to reference
    whatever the `s` argument refers to, which is the `''a''` string. Similarly, its
    `lst` parameter is made to reference whatever the `lst` argument refers to, which
    is the `[1]` list. Inside of `mystery`, `s` and `lst` are local variables.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：A. 当调用`mystery`时，它的`s`参数被赋值为`s`参数所指向的内容，也就是`'a'`字符串。类似地，它的`lst`参数被赋值为`lst`参数所指向的内容，也就是`[1]`列表。在`mystery`函数内部，`s`和`lst`是局部变量。
- en: Now let’s study the two statements of the function itself.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们研究一下该函数本身的两个语句。
- en: First, `s = s.upper()`. This makes the local variable `s` refer to `'A'` (uppercase).
    But it hasn’t changed what `s` refers to outside of the function. That still refers
    to `'a'` (lowercase).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`s = s.upper()`。这将使局部变量`s`指向`'A'`（大写）。但它并没有改变函数外部`s`所指向的内容。外部的`s`仍然指向`'a'`（小写）。
- en: 'Second, `lst = lst + [2]`. Using `+` with lists creates a new list (it doesn’t
    change an existing list!), so this makes the local variable `lst` refer to the
    new list: `[1, 2]`. But, again, it hasn’t changed what `lst` refers to outside
    of the function; it’s still `[1]`.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，`lst = lst + [2]`。使用`+`运算符和列表会创建一个新列表（它不会改变现有的列表！），所以这会让局部变量`lst`指向新的列表：[1,
    2]。但同样，它并没有改变函数外部`lst`所指向的内容；它仍然是`[1]`。
- en: 'What gives—didn’t I tell you previously that functions can change a mutable
    parameter? I did; but to make that happen, you really do need to change the value
    itself, not what a local variable refers to. Compare the previous program with
    the next one, whose output is different:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 怎么回事——我之前不是告诉过你函数可以改变可变参数吗？我说过；但是为了实现这一点，你真的需要改变值本身，而不是改变局部变量指向的内容。比较一下前一个程序和下一个程序，后者的输出是不同的：
- en: '[PRE25]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Return Values
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 返回值
- en: 'Let’s come back to our Card Game problem. Our goal is to define a function
    that tells us whether there are no high cards in a list of cards. We’ll name that
    function `no_high`. We haven’t written `no_high` yet, but we can still specify
    what we hope to accomplish. Here’s what we’re after:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到卡牌游戏问题。我们的目标是定义一个函数，告诉我们列表中是否没有高牌。我们将这个函数命名为`no_high`。我们还没有编写`no_high`，但我们仍然可以指定我们希望实现的目标。我们想要的是：
- en: '[PRE26]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We want the first two calls to return `True`, because there are no high cards
    in those lists of cards. And we want the third and fourth calls to return `False`,
    because there’s at least one high card in those lists of cards.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望前两个调用返回`True`，因为在这些牌列表中没有高牌。而我们希望第三个和第四个调用返回`False`，因为这些牌列表中至少有一张高牌。
- en: How can we define a function that returns these `True` and `False` values? That’s
    the final piece of the function puzzle.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何定义一个返回这些`True`和`False`值的函数？那是函数谜题的最后一块拼图。
- en: To return a value from a function, we use Python’s `return` keyword. As soon
    as a `return` is reached, execution of the function terminates, and the specified
    value is returned to the caller.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从函数返回一个值，我们使用 Python 的 `return` 关键字。一旦遇到`return`，函数的执行就会终止，并将指定的值返回给调用者。
- en: 'Here’s how we can write the `no_high` function:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们如何编写`no_high`函数：
- en: '[PRE27]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We first check whether there are any `'jack'` cards in the list. If there are,
    then we know that the list contains one or more high cards, so we immediately
    return `False`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查列表中是否有任何`'jack'`卡牌。如果有，那么我们知道列表中包含一张或多张高牌，因此我们立即返回`False`。
- en: If we’re still here, then we know that there are no jacks. But there could be
    other high cards, so we need to check for them. The rest of the `if` statements
    check for queens, kings, and aces, respectively, returning `False` if any of them
    is in the list.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们还在这里，那就说明没有任何杰克牌。但可能会有其他高牌，所以我们需要检查它们。剩下的`if`语句分别检查皇后、国王和王牌，如果列表中包含任何一张，则返回`False`。
- en: If we don’t hit any of those four `return` statements, then there are no high
    cards in the list. In that case, we return `True`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有命中任何四个`return`语句，那么列表中就没有高牌。在这种情况下，我们返回`True`。
- en: A `return` by itself, with no value given, returns the value `None`. That’s
    useful if you’re writing a function that doesn’t return anything useful and you
    need to terminate the function before reaching the bottom of its code.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一个单独的`return`，没有给定值时，返回`None`。如果你写的函数不返回任何有用的东西，并且需要在到达代码底部之前终止函数，这是非常有用的。
- en: 'If a `return` is encountered inside a loop, the function still terminates immediately,
    regardless of how deeply nested it is. Here’s an example showing a `return` getting
    us out of a nested loop:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在循环中遇到`return`，函数仍然会立即终止，不管它有多深嵌套。下面是一个示例，展示了`return`如何让我们跳出嵌套的循环：
- en: '[PRE28]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'A `return` is like a super-`break`! Some people don’t like using `return` from
    within a loop for the same reason that they don’t like `break`: it can obscure
    the purpose and logic of a loop. I’ll use `return` within a loop when convenient.
    Unlike `break`, which can show up anywhere, a `return` is restricted to showing
    up within a function, separated from other code. If we keep our functions small,
    then using a `return` within a loop can help us write clear code without interfering
    with the code around it.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`return`就像是一个超级`break`！有些人不喜欢在循环中使用`return`，原因与不喜欢使用`break`相同：它可能会模糊循环的目的和逻辑。当方便时，我会在循环中使用`return`。与`break`可以出现在任何地方不同，`return`仅限于出现在函数内部，且与其他代码分开。如果我们保持函数小巧，那么在循环中使用`return`可以帮助我们编写清晰的代码，而不干扰周围的代码。'
- en: '**CONCEPT CHECK**'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念检查**'
- en: Is the following version of `no_high` correct? That is, does it return `True`
    if there is at least one high card in the list, and `False` otherwise?
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以下版本的`no_high`是否正确？也就是说，如果列表中至少有一张高牌，它是否返回`True`，否则返回`False`？
- en: '[PRE29]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: A. Yes
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: A. 对
- en: B. No; for example, it returns the wrong value for `['two', 'three']`
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: B. 不对；例如，对于`['two', 'three']`，它返回了错误的值。
- en: C. No; for example, it returns the wrong value for `['jack']`
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: C. 不对；例如，对于`['jack']`，它返回了错误的值。
- en: D. No; for example, it returns the wrong value for `['jack', 'two']`
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: D. 不；例如，它返回了错误的值 `['jack', 'two']`
- en: E. No; for example, it returns the wrong value for `['two', 'jack']`
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: E. 不；例如，它返回了错误的值 `['two', 'jack']`
- en: 'Answer: E. The `if-else` statement causes the loop to always terminate on its
    first iteration. If the first card is a high card, the function terminates and
    returns `False`; if the first card is not a high card, the function terminates
    and returns `True`. It doesn’t look at any of the other cards! And that’s why
    it fails on `[''two'', ''jack'']`: the first card is not a high card, so the function
    returns `True`. Returning `True` tells us that there are no high cards in the
    list. But that’s wrong: there’s a jack in there! The function did the wrong thing.
    It should have returned `False`.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：E. `if-else`语句导致循环在第一次迭代时总是终止。如果第一张卡片是高牌，函数终止并返回`False`；如果第一张卡片不是高牌，函数终止并返回`True`。它不会查看其他卡片！这就是为什么它在`['two',
    'jack']`上失败的原因：第一张卡片不是高牌，所以函数返回`True`。返回`True`意味着列表中没有高牌。但这错了：里面有一张杰克！函数做错了，它应该返回`False`。
- en: Function Documentation
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数文档
- en: It’s clear to us right now what our `no_high` function does and how we should
    call it. But what about in a few months, when the purpose of our old code doesn’t
    come readily to mind? And what about once we’ve amassed a large collection of
    our own functions, making it difficult to remember what each one does?
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以清楚地知道`no_high`函数的作用以及如何调用它。但几个月后，当我们不再立即记得旧代码的目的时会怎么样呢？如果我们积累了大量自己的函数，难以记住每个函数的作用，又该怎么办呢？
- en: 'For each function we write, we’ll add documentation that specifies the meaning
    of each parameter and what the function returns. Such documentation is called
    a *docstring*, for “documentation string.” The docstring should be written starting
    at the first line of the function’s block. Here’s the `no_high` function, this
    time with documentation:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们编写的每个函数，我们会添加文档说明，指定每个参数的含义以及函数返回的内容。这种文档称为*文档字符串*，即“documentation string”的缩写。文档字符串应从函数块的第一行开始编写。以下是`no_high`函数，这次带有文档说明：
- en: '[PRE30]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The docstring begins and ends with three double quotes (`"""`). Like a single
    quote (`'`) or double quote (`"`), three double quotes can be used to start and
    end any string. A string created with three quotes is called a *triple-quoted
    string*. (Three single quotes work as well, but Python convention is to use three
    double quotes.) They have the bonus of letting us add multiple lines of text to
    the string by just pressing ENTER after each line; strings created with `'` or
    `"` can’t span lines like that. We use triple-quoted strings for docstrings so
    that we can include as many lines as we like.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 文档字符串以三个双引号（`"""`）开头和结束。像单引号（`'`）或双引号（`"`）一样，三个双引号也可以用来开始和结束任何字符串。用三个引号创建的字符串称为*三引号字符串*。（三个单引号也可以使用，但
    Python 的惯例是使用三个双引号。）它们的优点是，允许我们通过在每一行后按下 ENTER 键来添加多行文本；用`'`或`"`创建的字符串则不能像这样跨越多行。我们使用三引号字符串作为文档字符串，这样我们就可以包含任意多的行。
- en: 'The docstring here tells us what `lst` is: it’s a list of strings representing
    cards. It also tells us that the function returns a `True` or `False` value and
    what each return value means. This is sufficient information to enable someone
    to call the function without having to look at its code. As long as someone knows
    what a function does, they can just use it. We’ve been using Python functions
    all along without ever having looked at their code. How does `print` work? How
    does `input` work? We don’t know! But it doesn’t matter: we know what the functions
    do, so we can just focus on calling them.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的文档字符串告诉我们`lst`是什么：它是一个表示卡片的字符串列表。它还告诉我们，函数返回一个`True`或`False`值，并说明每个返回值的含义。这些信息足以让任何人调用此函数，而不必查看其代码。只要有人知道一个函数的作用，他们就可以直接使用它。我们一直在使用
    Python 函数，而从未查看过它们的代码。`print`是如何工作的？`input`是如何工作的？我们不知道！但这并不重要：我们知道这些函数的作用，因此可以专注于调用它们。
- en: 'For functions with multiple parameters, the docstring should name each one
    and give its expected type. Here’s `remove_all`, from “Mutable Parameters” in
    this chapter, with a suitable docstring:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有多个参数的函数，文档字符串应列出每个参数并给出预期的类型。以下是本章《可变参数》中的`remove_all`函数，并附上了合适的文档字符串：
- en: '[PRE31]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Notice that this docstring doesn’t talk about returning anything. That’s because
    this function doesn’t return anything useful! It removes from `lst`, which is
    what the docstring says it does.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个文档字符串没有提到返回任何内容。这是因为这个函数不返回任何有用的东西！它从`lst`中移除内容，文档字符串就是这么说的。
- en: Solving the Problem
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决问题
- en: We’ve just learned the fundamentals of defining and calling functions. For the
    rest of the book, whenever we’re faced with a large problem to solve, we’ll be
    able to break down its solution into smaller tasks, each of which will be solved
    by a function.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚学习了定义和调用函数的基础知识。在本书接下来的部分，每当我们面临一个大问题时，我们将能够将问题的解决方案拆分为更小的任务，每个任务将由一个函数来解决。
- en: Let’s use our `no_high` function in a solution to Card Game. The code is in
    [Listing 6-1](ch06.xhtml#ch06ex01).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在卡牌游戏的解决方案中使用我们的`no_high`函数。代码见[清单6-1](ch06.xhtml#ch06ex01)。
- en: '[PRE32]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '*Listing 6-1: Solving Card Game*'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单6-1：解决卡牌游戏问题*'
- en: I’ve introduced the constant `NUM_CARDS` to refer to `52` ❶. We’ll use it a
    couple of times in the code, and it’s easier to remember what `NUM_CARDS` means
    than what `52` means.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我引入了常量`NUM_CARDS`来表示`52`❶。我们将在代码中多次使用它，记住`NUM_CARDS`的含义比记住`52`的含义更容易。
- en: Next we define the `no_high` function, including docstring, that we’ve discussed
    in depth ❷. We’ll always put our functions near the top of our programs. This
    way, the functions are available to be called by any code that follows them.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们定义`no_high`函数，包括我们已深入讨论过的文档字符串❷。我们总是把函数放在程序的顶部。这样，函数可以被后续的代码调用。
- en: The main part of the program starts with creating a list that will hold the
    cards in the deck ❸. We then read the cards from the input ❹, appending each to
    the deck. You’ll notice that cards are never literally removed or taken from the
    deck (the deck remains as is throughout program execution). We could have done
    it that way. Instead, I’ve chosen to track where we are in the deck so that we
    know which card would be removed next.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的主要部分从创建一个列表开始，这个列表将包含牌堆中的卡片❸。然后我们从输入中读取卡片❹，并将每张卡片添加到牌堆中。你会注意到，卡片从未被字面上移除或取出（整个程序执行过程中，牌堆保持不变）。我们本可以那样做，但我选择了跟踪我们在牌堆中的位置，这样我们就知道下一张卡片会被移除。
- en: 'There are three other crucial variables that we maintain: `score_a`, the current
    total score for player A; `score_b`, the current total score for player B; and
    `player`, the name of the current player.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 还有三个其他关键变量我们需要维护：`score_a`，玩家A当前的总分；`score_b`，玩家B当前的总分；以及`player`，当前玩家的名字。
- en: 'Our next task is to look at each card in the deck to give points to the players.
    A regular `for` loop would let us look at the current card. But that’s not enough:
    if the current card is a high card, then we have to be able to look at later cards
    as well. To facilitate that, we use a range `for` loop ❺.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的任务是查看牌堆中的每一张卡片，以便为玩家打分。一个普通的`for`循环可以让我们查看当前的卡片。但这还不够：如果当前卡片是高牌，那么我们还必须能够查看后面的卡片。为此，我们使用了一个范围`for`循环❺。
- en: On each iteration of this loop, we determine the number of points awarded to
    the current player based on the card that they take from the deck. Each rule for
    getting points depends on the deck having some number of remaining cards. The
    `remaining` variable ❻ tells us the number of remaining cards. When `i` is `0`,
    the number of remaining cards is `51`, because we’ve just taken the first card.
    When `i` is `1`, the number of remaining cards is `50`, because we’ve just taken
    the second card. In general, the expression for the number of remaining cards
    is the total number of cards, minus `i`, minus `1`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次循环迭代中，我们根据当前玩家从牌堆中拿到的卡片来确定该玩家获得的积分。每个得分规则都依赖于牌堆中剩余卡片的数量。`remaining`变量❻告诉我们剩余卡片的数量。当`i`为`0`时，剩余卡片的数量是`51`，因为我们刚刚拿了第一张卡片。当`i`为`1`时，剩余卡片的数量是`50`，因为我们刚刚拿了第二张卡片。一般来说，剩余卡片的数量可以通过总卡片数减去`i`再减去`1`来表示。
- en: And now we have four tests, one for each way to score points ❼. Each one checks
    the current card and the number of cards remaining. If both of those conditions
    are `True`, then a call is made to our `no_high` function with a slice of the
    deck containing the appropriate number of cards. For example, if the current card
    is a `'jack'` and there is at least `1` card remaining, then we pass a list of
    length `1` to `no_high` ❼. If `no_high` returns `True`, then there are no high
    cards in the slice of the list, so the current player gets points. The `points`
    variable determines the number of points that will be awarded; it starts at `0`
    on each iteration of the loop and is set to `1`, `2`, `3`, or `4` as appropriate.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了四个测试，每个测试对应一种得分方式❼。每个测试检查当前卡牌和剩余的卡牌数量。如果这两个条件都为`True`，则调用我们的`no_high`函数，并传入包含适当数量卡牌的卡组切片。例如，如果当前卡牌是‘jack’，并且至少剩余`1`张卡牌，则我们将长度为`1`的列表传递给`no_high`❼。如果`no_high`返回`True`，则说明切片中没有高卡，当前玩家得分。`points`变量决定将要获得的得分；它在每次循环迭代时从`0`开始，并根据需要设置为`1`、`2`、`3`或`4`。
- en: If the player scored points ❽, then we output a message indicating the player
    who scored points and the number of points they scored.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家得分❽，那么我们将输出一条消息，指明得分的玩家以及他们所获得的分数。
- en: All that’s left for the current iteration is to add the points to the current
    player’s score and make it the other player’s turn. We accomplish both of these
    tasks with an `if-else` statement ❾. (If `points` is `0` on this iteration, then
    a harmless `0` is added to a player’s score. There’s no reason to explicitly test
    for and avoid that.)
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当前迭代剩下的任务就是将得分加到当前玩家的分数上，并轮到另一个玩家。我们通过`if-else`语句❾来完成这两个任务。（如果当前迭代中的`points`为`0`，则会向玩家的分数中添加一个无害的`0`，不需要专门测试和避免这种情况。）
- en: The final two `print` calls output the total points for each player.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的两个`print`语句输出每个玩家的总得分。
- en: 'There we go: a solution to the problem that uses a function to organize our
    code and make it easier to read. Feel free to submit our code to the judge, and
    you should see that all test cases pass.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样：我们使用一个函数解决了这个问题，组织了我们的代码，使其更易于阅读。可以自由将我们的代码提交给裁判，你会看到所有测试用例都通过了。
- en: 'Problem #15: Action Figures'
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '问题 #15：动作人物模型'
- en: To solve Card Game, we first went through an example, and that example highlighted
    where a function might be useful. Now, we’ll solve another problem using functions,
    but we’ll discover the needed functions using a more systematic approach.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决卡牌游戏问题，我们首先通过一个例子来理解，这个例子突出了函数可能有用的地方。现在，我们将使用函数解决另一个问题，但我们会通过更系统化的方法来发现所需的函数。
- en: This is Timus problem `2144`. This is the only problem in the book from the
    Timus judge. To find the problem, go to *[https://acm.timus.ru/](https://acm.timus.ru/)*,
    click **Problem set**, click **Volume 12**, and find problem 2144 (it’s called
    Cleaning the Room on the judge).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Timus的第`2144`号问题。这是书中唯一来自Timus裁判的题目。要找到这个问题，请访问*[https://acm.timus.ru/](https://acm.timus.ru/)*，点击**Problem
    set**，点击**Volume 12**，然后找到2144号问题（在裁判系统中叫做Cleaning the Room）。
- en: The Challenge
  id: totrans-164
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战
- en: Lena has *n* unopened boxes of action figures. The boxes cannot be opened (otherwise
    the action figures lose their value), so the order of action figures in a box
    cannot be changed. Further, a box cannot be rotated (otherwise the action figures
    will be facing the wrong way).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Lena有*n*个未开封的动作人物模型盒子。盒子不能打开（否则动作人物模型的价值会降低），因此盒子中的人物模型顺序不能更改。此外，盒子不能旋转（否则人物模型会朝向错误的方向）。
- en: Each action figure is specified by its height. For example, one of the boxes
    might have three action figures, from left to right, of heights 4, 5, and 7\.
    When I talk about a box of action figures, I’ll always list the heights from left
    to right.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 每个动作人物模型都由其高度来表示。例如，一个盒子可能有三个人物模型，分别是高度4、5和7。从左到右排列。当我提到动作人物模型盒子时，我总是会从左到右列出人物模型的高度。
- en: Lena wants to *organize the boxes*, which means to arrange the boxes so that
    heights of action figures increase or stay the same from left to right.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Lena想要*整理这些盒子*，即将盒子排列成从左到右人物模型的高度逐渐增加或保持不变。
- en: Whether she can organize the boxes or not depends on the heights of action figures
    in the boxes. For example, if a first box has action figures of heights 4, 5,
    and 7, and a second box has action figures of heights 1 and 2, then she can organize
    these boxes by putting the second box first. But if we keep the first box as is
    and change the second box to have action figures of heights 6 and 8, then there’s
    no way to organize these boxes.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 是否可以整理这些盒子取决于盒子中人物模型的高度。例如，如果第一个盒子的高度是 4、5 和 7，第二个盒子的高度是 1 和 2，那么她可以通过先放第二个盒子来整理这些盒子。但如果我们保持第一个盒子不变，第二个盒子的高度改为
    6 和 8，那么就无法整理这两个盒子。
- en: Determine whether it’s possible for Lena to organize the boxes.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 判断 Lena 是否可以整理这些盒子。
- en: Input
  id: totrans-170
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输入
- en: 'The input consists of the following lines:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 输入包括以下几行：
- en: A line containing integer *n*, the number of boxes. *n* is between 1 and 100.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一行包含整数 *n*，即盒子的数量。*n* 的范围是 1 到 100。
- en: '*n* lines, one for each box. Each of these lines begins with integer *k*, indicating
    the number of action figures in this box. *k* is between 1 and 100\. (Since *k*
    is at least 1, we don’t have to worry about empty boxes.) Following *k*, there
    are *k* integers giving the heights of the action figures from left to right in
    this box. Each height is an integer between 1 and 10,000\. There is a space between
    each pair of integers on the line.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*n* 行，每行对应一个盒子。每行的开头是整数 *k*，表示这个盒子中的人物模型数量。*k* 的范围在 1 到 100 之间。（因为 *k* 至少为
    1，所以我们不需要担心空盒子。）紧接着 *k* 后面，是 *k* 个整数，表示这个盒子中人物模型的高度，从左到右排列。每个高度是一个介于 1 到 10,000
    之间的整数。每对整数之间有一个空格。'
- en: Output
  id: totrans-174
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输出
- en: If Lena can organize the boxes, output `YES`; otherwise, output `NO`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Lena 可以整理这些盒子，输出 `YES`；否则，输出 `NO`。
- en: Representing the Boxes
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代表盒子
- en: This problem consists of several smaller problems, each of which we can solve
    by writing a function. Let’s first see how to represent the boxes in Python, and
    then we’ll design the functions that we need.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题由几个较小的问题组成，我们可以通过编写函数来解决每个问题。首先，让我们看看如何在 Python 中表示这些盒子，然后我们将设计我们需要的函数。
- en: 'In [Chapter 5](ch05.xhtml#ch05), when we solved Baker Bonus, we learned that
    lists can have other lists as their values. This allows us to nest lists inside
    of lists. We can use such an arrangement to represent the boxes of action figures.
    For example, here’s a list that represents two boxes:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 5 章](ch05.xhtml#ch05)中，当我们解决贝克奖金问题时，我们学到了列表可以将其他列表作为其值。这使得我们可以将列表嵌套在列表中。我们可以使用这种结构来表示人物模型的盒子。例如，这里有一个列表，表示两个盒子：
- en: '[PRE33]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The first box has three action figures, and the second has two. We can access
    each box individually:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个盒子里有三个人物模型，第二个盒子里有两个。我们可以单独访问每个盒子：
- en: '[PRE34]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We’ll read the contents of the boxes from the input and put that information
    into a nested list, like the one I’ve shown. Then we’ll use that nested list to
    determine whether the boxes can be organized.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从输入中读取盒子的内容，并将这些信息放入一个嵌套列表，就像我所展示的那样。然后我们将使用这个嵌套列表来判断这些盒子是否能够整理。
- en: Top-Down Design
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自顶向下设计
- en: We’ll solve this problem using a program design approach called *top-down design*.
    Top-down design breaks a large problem into several smaller problems. That’s useful
    because each of the smaller problems will be easier to solve. We can then assemble
    those subproblem solutions to solve the original problem.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一种程序设计方法来解决这个问题，称为 *自顶向下设计*。自顶向下设计将一个大问题分解为多个较小的问题。这很有用，因为每个较小的问题都更容易解决。然后，我们可以将这些子问题的解决方案组合起来，解决原始问题。
- en: Doing Top-Down Design
  id: totrans-185
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 做自顶向下设计
- en: Here’s how top-down design works. We start by writing an incomplete Python program
    that captures the main tasks in a solution. Some of these tasks won’t require
    much code, so we can proceed to solve them directly. Other tasks will require
    more from us, and we’ll turn each of those into a function that we’ll call. We
    might also solve a task by writing a little code *and* calling a function. However,
    those functions won’t exist yet. We’ll have to write them!
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是自顶向下设计的工作方式。我们从编写一个不完整的 Python 程序开始，它捕捉了问题解决方案中的主要任务。其中一些任务不需要太多代码，所以我们可以直接解决它们。其他任务则需要更多代码，我们会将每个任务转换成一个函数来调用。我们也可能通过编写一些代码
    *并且* 调用函数来解决某些任务。不过，这些函数现在还不存在，我们必须编写它们！
- en: To write a needed function, we repeat this same process for that function’s
    task. That is, we start by writing down the tasks for that function. If we can
    write code for a task outright, then we do it; otherwise, we call another function
    (that we’ll write later) to handle that task.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 要写一个所需的函数，我们对该函数的任务重复这个相同的过程。也就是说，我们首先写下该函数的任务。如果我们能直接为某个任务编写代码，那就直接编写；否则，我们调用另一个函数（我们稍后会编写）来处理该任务。
- en: We keep doing this until we have no more functions to write. At that point,
    we’ll have a solution to our problem.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不断重复这个过程，直到没有更多的函数需要编写。到那时，我们就能得出问题的解决方案。
- en: It’s called top-down design because we start at the top, or highest, level of
    the problem and make our way downward, through the guts of the problem, until
    each task has been completely written in code. We’ll now use this to solve Action
    Figures.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是所谓的自顶向下设计，因为我们从问题的最顶层或最高层开始，逐步向下，深入问题的核心，直到每个任务都被完全编写成代码。我们现在将使用这种方法来解决动作人物问题。
- en: The Top Level
  id: totrans-190
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 顶层
- en: To begin our design, we focus on the main tasks that we’ll need to solve.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始设计之前，我们专注于我们需要解决的主要任务。
- en: We’ll certainly have to read the input, so that’s our first task.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们肯定需要读取输入，因此这将是我们的第一个任务。
- en: Now, assume that we’ve read the input. What should we do to determine whether
    the boxes can be organized? One important thing to do is check each box on its
    own to make sure that its action figures have their heights in order. For example,
    suppose that we had the box `[18, 20, 4]`. This box, with heights out of order,
    means that we have no chance of organizing all of the boxes. We can’t even organize
    this one!
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们已经读取了输入。我们应该做什么来确定箱子是否可以组织起来？一个重要的步骤是检查每个箱子，确保它的动作人物的身高是按顺序排列的。例如，假设我们有一个箱子`[18,
    20, 4]`。这个箱子的身高乱序，意味着我们没有机会整理所有箱子。我们甚至不能整理这个箱子！
- en: 'So, that’s our second task: determine whether each box, on its own, has its
    action figures in order. If any of these boxes has its action figures out of order,
    then we know that the boxes can’t be organized. If all boxes are OK, then we have
    more to check.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这就是我们的第二个任务：确定每个箱子本身是否有序。如果任何一个箱子的动作人物顺序错乱，那么我们知道这些箱子无法组织。如果所有的箱子都没问题，那么我们还有更多的检查。
- en: If each box on its own is OK, the next question is whether we can organize all
    of the boxes. One important observation we can make here is that the only action
    figures we care about from now on are the ones at the left and right sides of
    each box. The action figures between these don’t matter anymore.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果每个箱子本身都没有问题，接下来的问题是我们是否能够组织所有的箱子。我们在这里可以做出一个重要的观察：从现在开始，我们关心的唯一动作人物是每个箱子左右两侧的动作人物。箱子中间的动作人物不再重要。
- en: 'Consider this example where we have three boxes:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子，我们有三个箱子：
- en: '[PRE35]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The first box starts with an action figure of height 9 and ends with an action
    figure of height 25\. Action figures placed to the left of this box must all have
    height 9 or less; for example, we can place the third box to the left of this
    box. Action figures placed to the right of this box must all have height 25 or
    more; for example, we can place the second box to the right of this box. The action
    figures of heights 13, 14, and 17 change nothing; they may as well not be there.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个箱子以身高9的动作人物开始，以身高25的动作人物结束。放在这个箱子左边的动作人物的身高必须都不超过9；例如，我们可以将第三个箱子放在这个箱子左边。放在这个箱子右边的动作人物的身高必须都不低于25；例如，我们可以将第二个箱子放在这个箱子右边。身高为13、14和17的动作人物没有任何影响；它们可以不存在。
- en: 'That’s our third task then: ignore all action figures except those on the ends
    of boxes.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，第三个任务就是：忽略所有动作人物，除了那些在箱子两端的动作人物。
- en: 'Following that third task, we’ll have a list that looks like this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三个任务之后，我们会得到如下的任务列表：
- en: '[PRE36]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'It’s a lot easier to tell whether we can organize these boxes if we first sort
    them, like this:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们先对这些箱子进行排序，那么判断它们是否可以组织起来就容易多了，就像这样：
- en: '[PRE37]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now it’s easy to see what the neighboring boxes of a box must be. (We used a
    similar approach when solving Village Neighborhood in [Chapter 5](ch05.xhtml#ch05).)
    So, our fourth task is to sort the boxes.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在很容易看出一个箱子的邻近箱子是什么样子的。（我们在解决[第5章](ch05.xhtml#ch05)的村庄邻里问题时也使用了类似的方法。）所以，我们的第四个任务是对箱子进行排序。
- en: 'Our fifth and final task is to determine whether these sorted boxes are organized.
    They are organized if the heights of action figures are sorted from left to right.
    The action figures of heights 1, 6, 9, 25, 32, and 36 are appropriately sorted,
    so the previous boxes can be organized. But consider this example:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第五个也是最后一个任务是判断这些排序后的盒子是否已经被整理好。只有当动作人物的高度从左到右是有序时，盒子才算整理好。高度为1、6、9、25、32和36的动作人物已经按正确的顺序排列，因此前面的盒子可以被整理好。但考虑下面这个例子：
- en: '[PRE38]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: These boxes can’t be organized because of that huge action figure in the second
    box. That second box takes up heights 9 to 50; the third box can’t go on the right
    of the second box because its heights are too small.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这些盒子无法排序，因为第二个盒子里有个巨大的动作人物。第二个盒子占据了9到50的高度；第三个盒子不能放在第二个盒子的右边，因为它的高度太小。
- en: 'We’ve now finished working through the problem and have decided on five main
    tasks:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了问题的设计，并决定了五个主要任务：
- en: Read input.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取输入。
- en: Check whether all boxes are OK.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查所有盒子是否正常。
- en: Obtain a new list of boxes with only the left and right action figure heights
    from each box.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从每个盒子中获取一个新的盒子列表，只包含左右动作人物的高度。
- en: Sort these new boxes.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对这些新盒子进行排序。
- en: Determine whether these sorted boxes are organized.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 判断这些排序后的盒子是否已被整理好。
- en: You might wonder why we have a “Read input” task but not a “Write output” task.
    For this problem, writing output involves just outputting `YES` or `NO` as needed;
    there won’t be much to it. In addition, we’ll output `YES` or `NO` as soon as
    we know the answer, so output will be interleaved with other tasks. For those
    reasons, I’ve decided not to include it as a main task. When working through top-down
    design on your own, don’t worry if you later realize that you’ve left out a task.
    You can just add it and continue with your design.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会好奇，为什么我们有一个“读取输入”的任务，但没有“写入输出”的任务。对于这个问题，写输出仅仅是根据需要输出`YES`或`NO`；不会有太多复杂的操作。此外，我们会在知道答案的第一时间就输出`YES`或`NO`，所以输出会与其他任务交替进行。基于这些原因，我决定不把它作为一个主要任务。在进行自上而下的设计时，不用担心如果后来发现漏掉了任务，可以随时添加并继续设计。
- en: 'Here’s how we can capture our required tasks in code:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何在代码中捕捉所需任务的方式：
- en: '[PRE39]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: I’m calling this the main program ❶. Any functions we write should be included
    in the program before this comment.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我将这个称为主程序❶。我们写的任何函数都应该包含在这个注释之前。
- en: Each task is written as just a comment for now. The `TODO` markings are there
    to highlight that these are tasks for us to convert from English to Python. Once
    we finish a task, we’ll remove its `TODO`. That way, we’ll be able to track which
    tasks we’ve completed and which we haven’t. Let’s do this!
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 每个任务目前仅作为注释书写。`TODO`标记用来突出这些任务是我们需要从英语转换为Python的任务。每当我们完成一个任务时，我们会移除它的`TODO`。这样，我们就能追踪哪些任务已经完成，哪些还没完成。让我们开始吧！
- en: 'Task 1: Read Input'
  id: totrans-219
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 任务1：读取输入
- en: 'We need to read the line containing *n* (the number of boxes) and then read
    the boxes. Reading an integer is something we can do in a single line, so let’s
    read *n* directly. Reading the boxes, on the other hand, is a well-defined task
    that will take a few lines of code, so let’s solve that one with a function; we’ll
    call it `read_boxes`. Here’s where that leaves us in our main program:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要读取包含*n*（盒子数量）的那一行，然后读取盒子。读取整数是一行代码就能完成的任务，所以我们直接读取*n*。而读取盒子则是一个定义良好的任务，需要几行代码来解决，因此我们将通过一个函数来完成；我们称之为`read_boxes`。在主程序中，这就是我们当前的进度：
- en: '[PRE40]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: I’ve removed the `TODO` from the comment ❶, since from the perspective of the
    main program, we’ve solved that task. We do need to write the `read_boxes` function,
    of course, so let’s do that now.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我已从注释❶中移除了`TODO`，因为从主程序的角度来看，我们已经解决了这个任务。当然，我们还需要编写`read_boxes`函数，接下来我们就来做这个。
- en: 'The `read_boxes` function takes an integer `n` as a parameter and reads and
    returns `n` boxes. Here’s the code:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`read_boxes`函数接受一个整数`n`作为参数，读取并返回`n`个盒子。以下是代码：'
- en: '[PRE41]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We’re asked to read `n` boxes, so we loop `n` times ❶. On each iteration of
    this loop, we read the current line and split it into its individual action figure
    heights. The line starts with an integer indicating the number of heights in the
    line, so we remove that value from the list (it’s at index `0`) before continuing
    ❷. Then we convert each height to an integer and add the current box to the list
    of boxes. Finally, we return the list of boxes.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要读取`n`个盒子，因此我们循环`n`次❶。在每次循环中，我们读取当前行并将其拆分成单独的动作人物高度。行的开头是一个整数，表示这一行的高度数量，所以我们在继续之前会将该值从列表中移除（它在索引`0`）。然后，我们将每个高度转换为整数，并将当前盒子添加到盒子列表中。最后，我们返回盒子列表。
- en: We didn’t defer any part of `read_boxes` to some as-yet-written function, so
    we’re done with this task! We’ll include this function, along with other functions
    we write, before the `# Main Program` comment.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有将`read_boxes`的任何部分推迟到一个尚未编写的函数中，所以我们完成了这个任务！我们会将这个函数与其他编写的函数一起放在`# 主程序`注释之前。
- en: 'Task 2: Check Whether All Boxes Are OK'
  id: totrans-227
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 任务 2：检查所有盒子是否合格
- en: 'Does each box, on its own, have the action figures going from shortest to tallest?
    Good question, and not one we know how to answer in just a line or two of code.
    Let’s rely on a new function, `all_boxes_ok`, to tell us. If that function returns
    `False`, then at least one box has its heights messed up, so we won’t be able
    to organize the boxes. In that case, we should output `NO`. If `all_boxes_ok`
    returns `True`, then we should carry out our remaining tasks to determine whether
    the boxes can be organized. Let’s add this bit of `if-else` logic to our program,
    too. Here’s what we’ve got:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 每个盒子是否从最短的动作人物到最高的动作人物依次排列？好问题，这不是我们能在一两行代码中回答的。我们依赖一个新的函数`all_boxes_ok`来告诉我们。如果该函数返回`False`，说明至少有一个盒子的高度有问题，我们无法整理这些盒子。在这种情况下，我们应该输出`NO`。如果`all_boxes_ok`返回`True`，那么我们应该继续执行剩余任务，判断这些盒子是否能够整理。让我们也将这个`if-else`逻辑添加到我们的程序中。以下是我们得到的：
- en: '[PRE42]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Now we need to write the `all_boxes_ok` function that we’re calling ❶. We can
    check each box to determine whether it’s in order. If it isn’t, we return `False`
    right away. If it is in order, then we check the next box. If we check every box
    and they’re all in order, then we return `True`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要编写我们调用的`all_boxes_ok`函数 ❶。我们可以检查每个盒子是否按顺序排列。如果没有，我们立即返回`False`。如果按顺序排列，我们检查下一个盒子。如果检查每个盒子且它们都按顺序排列，我们就返回`True`。
- en: Aha, so we need to be able to check an individual box! Sounds like another function
    to me. Let’s call that one `box_ok`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 啊哈，所以我们需要能够检查一个单独的盒子！听起来像是另一个函数。我们叫它`box_ok`。
- en: 'Here’s what we have for `all_boxes_ok`:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们为`all_boxes_ok`写的：
- en: '[PRE43]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: I’ve used the word `nondecreasing` in the comment, rather than `increasing`,
    because heights of action figures are allowed to be equal. For example, the box
    `[4, 4, 4]` is just fine; claiming that this box is “increasing” would be incorrect.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我在注释中使用了`nondecreasing`这个词，而不是`increasing`，因为动作人物的高度可以相等。例如，盒子`[4, 4, 4]`是完全可以的；如果说这个盒子是“递增”的，那就是不正确的。
- en: 'We’ve pushed part of the `all_boxes_ok` task into `box_ok`, so let’s write
    that function next. Here goes:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`all_boxes_ok`任务的一部分推到`box_ok`函数中，所以接下来我们来编写这个函数。开始吧：
- en: '[PRE44]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: If any height is greater than the height to its right, we return `False` since
    the heights are not in order. If we get past the `for` loop, then there are no
    height violations, so we return `True`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果某个高度大于它右边的高度，我们返回`False`，因为高度顺序不对。如果通过了`for`循环，那么就没有高度违规，返回`True`。
- en: 'One nice side effect of using top-down design is that we get little chunks
    of code, wrapped up as functions, that we can test in isolation. For example,
    enter the code for `box_ok` into the Python shell. Then we can test it:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自顶向下设计的一个好处是，我们得到了一小块块的代码，以函数的形式封装起来，可以单独测试。例如，将`box_ok`的代码输入到Python shell中。然后我们可以测试它：
- en: '[PRE45]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We’re hoping for `True` to be returned here, because the box is in order from
    small heights to big heights. We certainly weren’t hoping for what we actually
    get:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望这里返回`True`，因为盒子的高度是从小到大排列的。我们当然不希望得到我们实际得到的结果：
- en: '[PRE46]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Errors are never fun, and they’re even less fun when we have to trawl through
    pages and pages of code to find them. But here, we know that the error is localized
    to this little function, so our work to find it is reduced considerably. The problem
    here is that we’ll eventually compare the rightmost height to the height to its
    right—and of course the latter doesn’t exist! So we need to stop one iteration
    earlier, comparing the second-to-last height to the last height. Here’s the updated
    code:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 错误从来都不好玩，当我们需要翻遍页面的代码才能找到它们时，更加令人沮丧。但在这里，我们知道错误局限于这个小函数，因此我们找出它的工作量大大减少。问题在于，我们最终会将最右边的高度与右边的高度进行比较——当然，右边的高度是不存在的！所以我们需要提前一轮停止，比较倒数第二个高度和最后一个高度。以下是更新后的代码：
- en: '[PRE47]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The only change is in the call to `range` ❶. If you test this version of the
    function, you’ll see that it works as required. We’re done with Task 2!
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的变化是在对`range` ❶的调用。如果你测试这个版本的函数，你会看到它按要求工作。任务 2 完成！
- en: 'Task 3: Obtain a New List of Boxes with Only Left and Right Heights'
  id: totrans-245
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 任务 3：获得只有左右高度的新盒子列表
- en: Now we’re getting the hang of top-down design. In this task, we need a way to
    go from boxes with all of their action figures to boxes only with their leftmost
    and rightmost action figures. I’ll refer to the leftmost and rightmost action
    figures as box *endpoints*.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了自上而下的设计方法。在这个任务中，我们需要一种方法，将包含所有动作人物的盒子，转变为只包含最左侧和最右侧动作人物的盒子。我将把最左侧和最右侧的动作人物称为盒子的*端点*。
- en: One approach is to create a new list of boxes with only the endpoints, and that’s
    what I’ll do here. You could also think about actually removing heights from the
    original boxes, though that’s a little trickier.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是创建一个新的仅包含端点的盒子列表，这也是我在这里要做的。你也可以考虑从原始盒子中实际删除高度，虽然这稍微复杂一些。
- en: 'I’ve called the function for this task `boxes_endpoints`. Here’s the main part
    of the program, updated with a call to that function:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经为这个任务将函数命名为`boxes_endpoints`。这是程序的主要部分，已经更新为调用该函数：
- en: '[PRE48]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'When we call `boxes_endpoints` with a list of boxes ❶, we expect to get back
    a new list with only the box endpoints. Here’s the `boxes_endpoints` code that
    satisfies this description:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们用包含盒子的列表❶调用`boxes_endpoints`时，我们期望返回一个仅包含盒子端点的新列表。这是满足此描述的`boxes_endpoints`代码：
- en: '[PRE49]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We create a new list ❶ that will hold the endpoints of each box. Then we loop
    through the boxes. For each box, we use indexing to find the leftmost and rightmost
    heights in the box and append them to our endpoints list ❷. Finally, we return
    the endpoints list.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个新的列表❶，用来存放每个盒子的端点。然后我们遍历盒子。对于每个盒子，我们使用索引来找到盒子中的最左侧和最右侧的高度，并将它们添加到我们的端点列表❷中。最后，我们返回端点列表。
- en: 'Wait a sec: what happens if there’s a box with just one action figure in it?
    What will our `boxes_endpoints` function do with it? According to its docstring,
    it will give us back a list of two values for any valid box. So that had better
    happen here; otherwise, the function isn’t doing what it promises. Let’s test
    it. Enter the `boxes_endpoints` function into the Python shell, and try it with
    a list of one box with one action figure:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 等一下：如果一个盒子里只有一个动作人物会怎么样？我们的`boxes_endpoints`函数会怎么处理它？根据它的文档字符串，它会为任何有效的盒子返回一个包含两个值的列表。所以这里最好也发生这种情况，否则函数就没有做到它承诺的功能。我们来测试一下。将`boxes_endpoints`函数输入到Python终端，并尝试使用一个只包含一个动作人物的盒子的列表：
- en: '[PRE50]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Success! The leftmost height is `2`, and the rightmost height is `2`, so we
    get a list with two occurrences of `2`. Our function works correctly in this case
    because `box[0]` and `box[-1]` both refer to the same value when `box` has only
    one value. (Don’t worry about the possibility of empty boxes. The problem description
    prohibits them.)
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 成功了！最左侧的高度是`2`，最右侧的高度是`2`，所以我们得到了一个包含两个`2`的列表。我们的函数在这个案例中工作正常，因为当`box`只有一个值时，`box[0]`和`box[-1]`都指向相同的值。（不必担心空盒子的情况，问题描述禁止了空盒子。）
- en: 'Task 4: Sort Boxes'
  id: totrans-256
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 任务 4：排序盒子
- en: 'At this point, we have a list of endpoints—something like this:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 到了这个时候，我们有了一个端点列表——大概是这样的：
- en: '[PRE51]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We want to sort them. Do we need another function for this? Some sort of `sort_endpoints`
    function?
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想对它们进行排序。我们需要另一个函数吗？比如`sort_endpoints`函数？
- en: 'Not this time! The list `sort` method does exactly what we need:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这次不是！`sort`方法正是我们需要的：
- en: '[PRE52]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: When called on a list of two-value lists, `sort` sorts using the first value.
    (If there’s a tie, then it further sorts using the second value.)
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 当对包含两个值的列表调用`sort`时，它会使用第一个值进行排序。（如果有并列情况，它会进一步使用第二个值进行排序。）
- en: 'We can immediately update the main part of our program with a call to `sort`
    and knock off one more `TODO`. Here’s the updated code:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以立即通过调用`sort`来更新程序的主要部分，再解决一个`TODO`。这是更新后的代码：
- en: '[PRE53]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We’re nearly there. Just one `TODO` to go.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们快完成了。只剩下一个`TODO`。
- en: 'Task 5: Determine Whether Boxes Are Organized'
  id: totrans-266
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 任务 5：确定盒子是否有序
- en: 'Our final task is to check the endpoints. They might be in order, like this:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最终任务是检查端点。它们可能是有序的，像这样：
- en: '[PRE54]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Or they might not be, like this:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 或者它们也可能不是有序的，像这样：
- en: '[PRE55]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'In the former case, we should print `YES`; in the latter, we should print `NO`.
    We need a function to tell us whether the endpoints are in order. Updating the
    main part of the program for the final time, we end up with this:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一种情况下，我们应该打印`YES`；在后一种情况下，我们应该打印`NO`。我们需要一个函数来告诉我们端点是否有序。最后一次更新程序的主要部分，结果是这样的：
- en: '[PRE56]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: All that stands between us and a complete solution to the problem is that `all_endpoints_ok`
    function that we’re calling ❶. It takes a list where each value is a list of endpoints
    and returns `True` if the endpoints are in order and `False` otherwise.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们和问题的完整解决方案之间只差一个 `all_endpoints_ok` 函数❶。它接收一个列表，每个值都是一个端点列表，如果端点顺序正确，返回 `True`，否则返回
    `False`。
- en: 'Let’s get a feel for how we can implement this function by working through
    an example. Here’s the list of endpoints we’ll use:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例来理解如何实现这个函数。以下是我们将使用的端点列表：
- en: '[PRE57]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The first box has a right endpoint of height 6\. So, the second box better have
    a left endpoint of height 6 or more. If it doesn’t, then we return `False` indicating
    that the endpoints are not in order. But we’re good here, because the second box
    has a left endpoint of height 9.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个盒子的右端点高度是 6。因此，第二个盒子的左端点高度必须至少是 6。如果不是，我们就返回 `False`，表示端点没有按照顺序排列。但在这里没问题，因为第二个盒子的左端点高度是
    9。
- en: Now we repeat that check using 25, the right endpoint of the second box. The
    left endpoint of the third box is 32, so we’re good again because 32 is at least
    25.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们使用第二个盒子的右端点 25 重复检查。第三个盒子的左端点是 32，所以没问题，因为 32 至少是 25。
- en: In general, if the left endpoint of a box is ever less than the right endpoint
    of the previous box, we return `False`. Otherwise, if all of these checks pass,
    we return `True`.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，如果一个盒子的左端点小于前一个盒子的右端点，我们就返回 `False`。否则，如果所有检查都通过，我们返回 `True`。
- en: 'Here’s the code:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是代码：
- en: '[PRE58]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: I’ve added some information to the docstring reminding us what the function
    requires when it’s called ❶. Specifically, we must remember to have the endpoints
    sorted before calling this function. Otherwise, the function could return the
    wrong value.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我在文档字符串中添加了一些信息，提醒我们在调用此函数时需要注意的事项❶。特别是，我们必须记住在调用此函数之前，端点应该是排序好的。否则，函数可能会返回错误的值。
- en: 'Each value of `endpoints` is a list with two values: index `0` is the leftmost
    (minimum) height, and index `1` is the rightmost (maximum) height. The code uses
    the `maximum` variable to track the maximum height of a box. Prior to the `for`
    loop, it refers to the maximum height in the first box ❷. The `for` loop compares
    the minimum of the next box to that maximum. If the minimum of the next box is
    too small, we return `False`, because these two boxes cannot be organized correctly.
    The last thing to do in each iteration is update `maximum` so that it refers to
    the maximum of the next box ❸.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`endpoints` 的每个值是一个包含两个值的列表：索引 `0` 是最左边（最小）的高度，索引 `1` 是最右边（最大）的高度。代码使用 `maximum`
    变量来追踪盒子的最大高度。在 `for` 循环之前，它引用第一个盒子的最大高度❷。`for` 循环比较下一个盒子的最小值与最大值。如果下一个盒子的最小值太小，我们返回
    `False`，因为这两个盒子无法正确组织。在每次迭代的最后，我们更新 `maximum`，使其引用下一个盒子的最大值❸。'
- en: Putting It All Together
  id: totrans-283
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将所有部分整合在一起
- en: Having written code for all tasks, including the functions that sprang up as
    part of the design, we’re ready to put it all together into a complete solution.
    It’s up to you whether to keep the comments in the main part of the program. I’ve
    left them in, but in practice this may be a case of over-documenting the code,
    since the function names on their own are chosen to convey what the code is doing.
    See [Listing 6-2](ch06.xhtml#ch06ex02) for the complete code.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经编写了所有任务的代码，包括作为设计一部分出现的函数，现在我们准备将它们整合成一个完整的解决方案。是否保留程序主部分的注释由你决定。我保留了它们，但实际上这可能会是过度文档化的做法，因为函数名称本身已经足够说明代码在做什么。完整代码请参见
    [清单 6-2](ch06.xhtml#ch06ex02)。
- en: '[PRE59]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '*Listing 6-2: Solving Action Figures*'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-2：解决动作人物问题*'
- en: 'This is the largest program that we’ve written to this point in the book. But
    look how tidy and minimal the main part of the program is: it’s mostly calls to
    functions, with a little bit of `if-else` logic to glue them together.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们目前为止在本书中编写的最大程序。但看看程序的主部分是多么简洁和最小化：它主要是函数调用，只有少量的 `if-else` 逻辑将它们连接起来。
- en: We’re calling each function only once here. Compare that to the `no_high` Card
    Game function that we called four times. Even if a function is called only once,
    it still contributes to organized, readable code.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这里只调用了每个函数一次。与我们四次调用的 `no_high` 卡牌游戏函数相比，即使一个函数只调用一次，它仍然能帮助代码更有组织且易于阅读。
- en: Time to submit to the Timus judge. You should see that all test cases pass.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候提交给 Timus 判定器了。你应该看到所有测试用例都通过了。
- en: '**CONCEPT CHECK**'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念检查**'
- en: In Task 2, we wrote function `box_ok` for determining whether a single box has
    its heights in order. It uses a range `for` loop. Is the following `while` loop
    version of `box_ok` correct?
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在任务2中，我们编写了函数`box_ok`来判断单个盒子中的高度是否按顺序排列。它使用了一个`for`循环。以下是`box_ok`的`while`循环版本，它是否正确？
- en: '[PRE60]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: A. Yes
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: A. 是的
- en: B. No; it can cause an `IndexError`
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: B. 否；它可能导致`IndexError`错误
- en: C. No; it doesn’t cause any errors, but it can return the wrong value
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: C. 否；它不会引发任何错误，但可能返回错误的值
- en: 'Answer: A. This is equivalent to our earlier version using the range `for`
    loop. The `ok` variable starts off as `True`, meaning that all heights we have
    checked are fine (because we haven’t checked any yet!). The `while` loop continues
    as long'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：A。这与我们之前使用`for`循环的范围版本等价。`ok`变量初始为`True`，意味着我们已经检查过的所有高度都是合格的（因为我们还没有检查过任何高度！）。`while`循环会继续执行，只要
- en: as there are more boxes to check and there are no height violations. If an action
    figure is out of order, `ok` is set to `False`, which terminates the loop. If
    all action figures are in order, then the value of `ok` never changes from `True`
    to `False`. Therefore, when we `return ok` at the bottom of the function, we return
    `True` if all action figures are in order and `False` if not.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 因为有更多的盒子需要检查，并且没有高度违规的情况。如果一个动作人物的顺序不正确，`ok`将被设置为`False`，这会终止循环。如果所有动作人物都按顺序排列，那么`ok`的值将从`True`保持到`False`。因此，当我们在函数的底部执行`return
    ok`时，如果所有动作人物都按顺序排列，我们将返回`True`，否则返回`False`。
- en: Summary
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned about functions. A function is a self-contained
    block of code that solves a small part of a larger problem. We learned how to
    pass information to a function (through arguments) and get information back (through
    a return value).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们学习了函数。函数是一个自包含的代码块，解决了一个较大问题的一个小部分。我们学会了如何将信息传递给函数（通过参数）并获取返回值（通过返回值）。
- en: To determine which functions to write in the first place, we can use top-down
    design. Top-down design helps us break a solution to a large problem into a number
    of smaller tasks; for each task, we solve it directly if we can or write a function
    for it if we can’t. If a given task is too unwieldy, we can perform further top-down
    design on it.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定首先要编写哪些函数，我们可以使用自顶向下设计方法。自顶向下设计帮助我们将一个大问题的解决方案拆解为多个较小的任务；对于每个任务，如果可以直接解决，就直接解决；如果无法直接解决，就为其编写函数。如果某个任务过于繁琐，我们可以进一步对其进行自顶向下设计。
- en: In the next chapter, we’ll learn how to work with files of our choosing, rather
    than using standard input and standard output. As we continue to push the boundaries
    of what we know, we’ll find many uses for functions in that chapter and the rest
    of the book. Practice with some of the following exercises to increase your confidence
    using functions.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用我们选择的文件，而不是使用标准输入和标准输出。随着我们不断拓展所知的边界，我们将在下一章及本书的其余部分找到很多函数的应用。通过一些以下的练习来增加你使用函数的信心。
- en: Chapter Exercises
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 章节练习
- en: Here are some exercises for you to try. For each, use top-down design to identify
    one or more functions that help you organize your code. Include a docstring in
    each function!
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些练习供你尝试。对于每个练习，使用自顶向下设计方法来识别一个或多个函数，以帮助你组织代码。每个函数中都要包含文档字符串！
- en: DMOJ problem `ccc13s1`, From 1987 to 2013
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ问题`ccc13s1`，从1987到2013
- en: DMOJ problem `ccc18j3`, Are we there yet?
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ问题`ccc18j3`，我们到了吗？
- en: DMOJ problem `ecoo12r1p2`, Decoding DNA
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ问题`ecoo12r1p2`，解码DNA
- en: DMOJ problem `crci07p1`, Platforme
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ问题`crci07p1`，Platforme
- en: DMOJ problem `coci13c2p2`, Misa
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ问题`coci13c2p2`，Misa
- en: Revisit some of the exercises from [Chapter 5](ch05.xhtml#ch05) and improve
    your solutions by using functions. I particularly suggest revisiting DMOJ problem
    `coci18c2p1` (Preokret) and DMOJ problem `ccc00s2` (Babbling Brooks).
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回顾一下[第5章](ch05.xhtml#ch05)中的一些练习，并通过使用函数来改进你的解法。我特别建议你回顾一下DMOJ问题`coci18c2p1`（Preokret）和DMOJ问题`ccc00s2`（Babbling
    Brooks）。
- en: Notes
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: Card Game is originally from the 1999 Canadian Computing Competition. Action
    Figures is originally from the 2019 Ural School Programming Contest.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 纸牌游戏最初来源于1999年加拿大计算机竞赛。动作人物最初来源于2019年乌拉尔学校编程竞赛。
- en: Many modern programming languages, Python included, support two distinct programming
    paradigms. One is based on functions; that’s what we studied in this chapter.
    The other is based on *objects* and leads to a paradigm known as *object-oriented
    programming (OOP)*. OOP involves defining new types and writing methods for those
    types. We use Python types (such as integers and strings) throughout the book,
    but we won’t otherwise discuss OOP. For an introduction to OOP, and case studies
    of OOP in practice, I recommend *Python Crash Course*, 2nd edition by Eric Matthes
    (No Starch Press, 2019).
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 许多现代编程语言，包括 Python，支持两种不同的编程范式。一种是基于函数的；这就是我们在本章中学习的内容。另一种是基于*对象*的，导致了一种被称为*面向对象编程（OOP）*的范式。OOP
    涉及定义新类型并为这些类型编写方法。我们在全书中使用 Python 类型（如整数和字符串），但不会进一步讨论 OOP。关于 OOP 的入门以及 OOP 实践案例，我推荐由
    Eric Matthes 编写的《*Python Crash Course*》第二版（No Starch Press，2019）。
