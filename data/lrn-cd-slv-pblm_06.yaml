- en: '6'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '6'
- en: DESIGNING PROGRAMS WITH FUNCTIONS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用函数设计程序
- en: '![image](Images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/common.jpg)'
- en: When writing large programs, it’s important to organize our code into smaller
    logical pieces, each of which contributes to the overall goal. That way, we’ll
    be able to think about each piece on its own, without worrying about what other
    pieces are doing. Then we’ll put the pieces together. These pieces are called
    *functions*.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写大型程序时，组织我们的代码成更小的逻辑单元是很重要的，每个单元都为整体目标做出贡献。这样，我们就可以独立思考每个单元，而不必担心其他单元在做什么。然后，我们再将这些单元组合在一起。这些单元被称为*函数*。
- en: 'In this chapter, we’ll use functions to break down and solve two problems:
    calculating the score in a two-player card game and determining whether boxes
    of action figures can be nicely organized.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用函数来分解并解决两个问题：计算两人纸牌游戏的得分和判断动作人物的盒子是否可以整齐地组织。
- en: 'Problem #14: Card Game'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '问题 #14：纸牌游戏'
- en: In this problem, we’ll implement a two-player card game. As part of thinking
    through the problem, we’ll find that the same bit of logic crops up several times.
    We’ll learn how to bundle this code into a Python function to avoid code duplication
    and enhance code clarity.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个问题中，我们将实现一个两人纸牌游戏。作为思考问题的一部分，我们会发现相同的逻辑片段会多次出现。我们将学习如何将这些代码打包成Python函数，以避免代码重复并增强代码的清晰性。
- en: This is DMOJ problem ccc99s1.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这是DMOJ问题ccc99s1。
- en: The Challenge
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战
- en: Two players, A and B, are playing a card game. (You don’t need to know about
    playing cards or card games to understand this problem.)
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 两个玩家，A和B，正在进行一场纸牌游戏。（你不需要了解纸牌或纸牌游戏即可理解这个问题。）
- en: The game starts with a deck of 52 cards. Player A takes a card from the deck,
    then player B takes a card from the deck, then player A, then player B, until
    there are no cards left in the deck.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏从一副52张的纸牌开始。玩家A从牌堆中拿一张卡片，然后玩家B拿一张卡片，然后是玩家A，再是玩家B，直到牌堆中没有卡片为止。
- en: 'There are 13 types of cards in the deck. These types are as follows: two, three,
    four, five, six, seven, eight, nine, ten, jack, queen, king, ace. There are four
    cards of each of these types in the deck. For example, there are four twos, four
    threes, and so on, all the way up to four aces. (That’s why there are 52 cards
    in the deck: 13 types times 4 cards per type.)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 牌堆中有13种类型的卡片。这些类型如下：二、三、四、五、六、七、八、九、十、杰克、皇后、国王、王牌。每种类型的卡片都有四张。例如，牌堆中有四张二，四张三，以此类推，一直到四张王牌。（这就是为什么牌堆中有52张卡片的原因：13种类型乘以每种类型的4张卡片。）
- en: 'A *high card* is a card that is a jack, queen, king, or ace. When a player
    takes a high card, they may score some points. Here are the rules by which points
    are scored:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*高牌*是指杰克、皇后、国王或王牌。当玩家拿到高牌时，他们可能会得分。以下是得分的规则：
- en: If a player takes a jack, after which there is at least one card remaining in
    the deck, and the next card in the deck is not a high card, then the player scores
    1 point.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果玩家拿到一张杰克，并且此后牌堆中至少还剩下一张卡片，而接下来的一张卡片不是高牌，那么该玩家得1分。
- en: If a player takes a queen, after which there are at least two cards remaining
    in the deck, and neither of the next two cards in the deck is a high card, then
    the player scores 2 points.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果玩家拿到一张皇后，并且此后牌堆中至少还剩两张卡片，而接下来的两张卡片都不是高牌，那么该玩家得2分。
- en: If a player takes a king, after which there are at least three cards remaining
    in the deck, and none of the next three cards in the deck is a high card, then
    the player scores 3 points.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果玩家拿到一张国王，并且此后牌堆中至少还剩三张卡片，而接下来的三张卡片都不是高牌，那么该玩家得3分。
- en: If a player takes an ace, after which there are at least four cards remaining
    in the deck, and none of the next four cards in the deck is a high card, then
    the player scores 4 points.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果玩家拿到一张王牌，并且此后牌堆中至少剩下四张卡片，而接下来的四张卡片都不是高牌，那么该玩家得4分。
- en: We’re asked to output information each time a player scores, as well as the
    total score for each player at the end of the game.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在每次玩家得分时输出信息，并且在游戏结束时输出每个玩家的总得分。
- en: Input
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输入
- en: The input consists of 52 lines. Each line contains the type of a card in the
    deck. The lines are in the order that cards will be taken from the deck; that
    is, the first line is the first card taken from the deck, the second line is the
    second card taken, and so on.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 输入由52行组成。每行包含牌堆中一张卡片的类型。这些行的顺序与卡片从牌堆中被拿出的顺序一致；也就是说，第一行是从牌堆中拿出的第一张卡片，第二行是第二张卡片，依此类推。
- en: Output
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输出
- en: 'Whenever a player scores, output the following line:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 每当玩家得分时，输出以下内容：
- en: Player p scores q point(s).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家p得分q 分。
- en: where p is A for player A or B for player B, and q is the number of points that
    they just scored.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 其中p是玩家A或B，q是他们刚刚得分的分数。
- en: 'When the game ends, output the following two lines:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当游戏结束时，输出以下两行：
- en: 'Player A: m point(s).'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家A：m 分。
- en: 'Player B: n point(s).'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家B：n 分。
- en: where m is the total score for player A and n is the total score for player
    B.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 其中m是玩家A的总得分，n是玩家B的总得分。
- en: Exploring a Test Case
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探索一个测试用例
- en: If you think through how to solve this problem, you might be left wondering
    whether we can just solve it, right now, without learning anything new. Indeed,
    we can! We’re in great shape. We can use a list to represent the deck of cards.
    We know how to use the list append method to add a card to the deck. We can access
    values in the list to look for high cards. We’ve even got f-strings to help us
    output the player and points information.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细思考如何解决这个问题，你可能会想是否现在就可以解决它，而不需要学任何新的东西。事实上，我们可以！我们状态很好。我们可以使用列表来表示牌堆。我们知道如何使用列表的append方法向牌堆中添加一张牌。我们可以访问列表中的值来查找高牌。我们甚至有f-strings来帮助我们输出玩家和得分信息。
- en: Rather than dive in, though, let’s go through a small example. Doing so is going
    to highlight that we’re missing one crucial feature of Python that will make it
    easier to organize our solution and solve this problem.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，在深入讨论之前，我们先看一个小例子。这样做将突出我们缺少Python中的一个关键特性，这个特性将使得我们更容易组织解决方案并解决这个问题。
- en: 'We’ll be here all year if we go through a 52-card example, so let’s use a smaller
    one with just 10 cards. This isn’t a complete test case, so the program we write
    won’t work on it, but it’s enough for us to understand the mechanics of the game
    and what our solution will have to do. Here’s the test case:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们用一副52张牌来做例子，可能会花费整年时间，因此我们使用一个包含10张牌的较小例子。这个例子不是完整的测试用例，因此我们写的程序不能在它上面工作，但足够让我们理解游戏的机制以及我们解决方案需要做什么。以下是测试用例：
- en: queen
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 皇后
- en: three
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 三
- en: seven
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 七
- en: king
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 国王
- en: nine
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 九
- en: jack
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 杰克
- en: eight
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 八
- en: king
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 国王
- en: jack
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 杰克
- en: four
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 四
- en: Player A takes the first card, which is a queen. A queen is a high card, and
    player A might score 2 points here. First, we confirm that there are at least
    two cards remaining in the deck after this queen. Next, we have to check these
    next two cards, hoping there is no high card among them. The next two cards are
    not high cards—they are a three and a seven—so player A gets 2 points.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家A拿到了第一张牌，这是一张皇后牌。皇后是高牌，玩家A在这里可能得2分。首先，我们确认皇后之后，牌堆中至少还有两张牌。接下来，我们需要检查这两张牌，希望它们之间没有高牌。接下来的两张牌不是高牌——它们是三和七——因此玩家A得了2分。
- en: Player B now takes the second card, which is a three. Three isn’t a high card,
    so no points for player B.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家B现在拿到第二张牌，这是一张三。三不是高牌，因此玩家B没有得分。
- en: Player A now takes the seven. No points.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家A现在拿到了七。没有得分。
- en: Player B now takes the king, so there’s a chance for 3 points for player B.
    There are at least three cards remaining in the deck after this king. We have
    to check these next three cards, hoping there is no high card among them. Sadly,
    there is a high card, a jack, among those three. No points for player B.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家B现在拿到国王，因此玩家B有可能得3分。国王之后牌堆中至少还有三张牌。我们需要检查这三张牌，希望它们之间没有高牌。遗憾的是，这三张牌中有一张高牌——杰克——因此玩家B没有得分。
- en: Player A now takes the nine. No points.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家A现在拿到了九。没有得分。
- en: 'Player B now takes the first jack. There is at least one card remaining in
    the deck after this jack. We have to check this next card, hoping it isn’t a high
    card. Good news: it’s not a high card—it’s an eight—so player B gets 1 point.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家B现在拿到第一张杰克牌。杰克之后牌堆中至少还有一张牌。我们需要检查这张牌，希望它不是高牌。好消息是：它不是高牌——它是一张八——因此玩家B得1分。
- en: There’s only one more point scored, and it’s by player A when they take the
    second-last card (the jack) from the deck.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 只剩下最后一分，由玩家A在他们从牌堆中拿到倒数第二张牌（杰克）时得到。
- en: 'Therefore, this is the output for this test case:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这是该测试用例的输出：
- en: Player A scores 2 point(s).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家A得分 2 分。
- en: Player B scores 1 point(s).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家B得分 1 分。
- en: Player A scores 1 point(s).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家A得分 1 分。
- en: 'Player A: 3 point(s).'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家A：3 分。
- en: 'Player B: 1 point(s).'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家B：1 分。
- en: 'Notice that each time a player takes a high card, we need to check two things:
    that there are at least a certain number of cards remaining in the deck and that
    there is no high card among these cards. The first we should be able to manage
    by using a variable that tells us how many cards have been taken. The second is
    more difficult. We’d need some code to check a given number of cards for a high
    card. Worse, if we’re not careful, we’d end up duplicating very similar code four
    times: once to check the card after a jack, once to check the two cards after
    a queen, once to check the three cards after a king, and once to check the four
    cards after an ace. If we later found a flaw in our logic, we would have to fix
    it in up to four different places.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，每次玩家拿到一张高牌时，我们需要检查两件事：第一，牌堆中剩余的牌数量是否足够；第二，这些牌中是否没有高牌。我们可以通过使用一个变量来跟踪已取出的牌的数量，来解决第一个问题。第二个问题则更为复杂。我们需要一些代码来检查一组牌中是否有高牌。更糟糕的是，如果不小心，我们可能会把非常相似的代码重复四次：一次检查杰克后的牌，一次检查皇后后的两张牌，一次检查国王后的三张牌，最后一次检查王牌后的四张牌。如果我们稍后发现逻辑上的问题，我们必须在最多四个不同的地方修复它。
- en: Is there a Python feature that lets us package that “no high cards here” logic,
    just once, and invoke it four times? There is. It’s called a *function*, and it’s
    just a named block of code that carries out a small task. Functions are essential
    to the organization and clarity of our code. All programmers use them. Without
    them, writing large software systems like games and word processors would be untenable.
    Let’s learn how to use functions.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 是否有一种 Python 特性，可以让我们只写一次“没有高牌”的逻辑，并调用四次？有的。它叫做*函数*，它就是一个执行小任务的命名代码块。函数对于我们代码的组织和清晰性至关重要。所有程序员都在使用函数。没有它们，编写像游戏和文字处理器这样的庞大软件系统将变得不可行。让我们学习如何使用函数。
- en: Defining and Calling Functions
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义和调用函数
- en: 'We’ve already learned how to call functions that come with Python. For example,
    we’ve used the input function to read input. Here’s a call of input with no arguments:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学会了如何调用 Python 提供的内置函数。例如，我们曾使用过 input 函数来读取输入。下面是一个没有参数的 input 函数调用：
- en: '>>> s = input()'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s = input()'
- en: hello
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你好
- en: '>>> s'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s'
- en: '''hello'''
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '''你好'''
- en: 'We’ve also used Python’s print function to output text. Here’s a call of print
    with one argument:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用了 Python 的 print 函数来输出文本。以下是带有一个参数的 print 函数调用：
- en: '>>> print(''well, well'')'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> print(''well, well'')'
- en: well, well
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: well, well
- en: The built-in Python functions are general-purpose, designed to be used in a
    wide variety of settings. When we want a function to solve a problem-specific
    task, we’ll have to define it ourselves.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Python 内置的函数是通用的，设计用于在各种场景下使用。当我们希望一个函数来解决特定问题时，我们必须自己定义它。
- en: Functions Without Arguments
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 无参数的函数
- en: 'To *define*, or create, a function, we use Python’s def keyword. Here’s the
    definition of a function that outputs three lines:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要*定义*或创建一个函数，我们使用 Python 的 def 关键字。以下是一个输出三行的函数定义：
- en: '>>> def intro():'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> def intro():'
- en: '...     print(''*********'')'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '...     print(''*********'')'
- en: '...     print(''*WELCOME*'')'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '...     print(''*欢迎*'')'
- en: '...     print(''*********'')'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '...     print(''*********'')'
- en: '...'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: The structure of a function definition mirrors that of an if statement or loop.
    The name after def is the name of the function that we’re defining; here, we’re
    defining a function named intro. Following the name of the function, we have a
    pair of empty parentheses, (). We’ll see later that we can include information
    in these parentheses to pass arguments to functions. This intro function doesn’t
    take any arguments, which is why the parentheses are empty. Following the parentheses
    is a colon; as with if statements or loops, leaving out the colon is a syntax
    error. On the following lines, we provide an indented block of statements that
    will run each time the function is called.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 函数定义的结构类似于 if 语句或循环。def 后面的名字是我们正在定义的函数的名称；在这里，我们定义了一个名为 intro 的函数。函数名称后面跟着一对空括号
    ()。稍后我们会看到，我们可以在括号中传递信息，以将参数传递给函数。这个 intro 函数不接受任何参数，所以括号是空的。括号后面是一个冒号；就像 if 语句或循环一样，缺少冒号会导致语法错误。在接下来的几行中，我们提供了一段缩进的代码块，每次调用该函数时都会执行。
- en: 'When you defined the intro function, you may have expected to see this as output:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当你定义 intro 函数时，你可能会期待看到以下输出：
- en: '*********'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*********'
- en: '*WELCOME*'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*欢迎*'
- en: '*********'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*********'
- en: 'But no: so far we’ve only defined the function, not called it. Defining a function
    has no observable effect; it simply stores the function in the computer’s memory
    so we can call it later. We call our own functions just like we call any of Python’s
    built-in functions. Since this intro function doesn’t take any arguments, we use
    an empty set of parentheses in the call:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 但是不行：到目前为止，我们只是定义了函数，还没有调用它。定义函数没有可观察的效果；它只是将函数存储在计算机的内存中，以便我们稍后可以调用它。我们像调用任何
    Python 内建函数一样调用我们自己的函数。由于这个 intro 函数不接受任何参数，我们在调用时使用一对空括号：
- en: '>>> intro()'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> intro()'
- en: '*********'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*********'
- en: '*WELCOME*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*WELCOME*'
- en: '*********'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*********'
- en: You can call this function as many times as you like. It’s there as often as
    we need it.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以根据需要调用这个函数任意多次。它会在我们需要时提供。
- en: Functions with Arguments
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 带有参数的函数
- en: 'Our intro function isn’t very flexible, as it does the same thing each time
    it’s called. We can change the function so that we can pass arguments to it, and
    the arguments we pass can influence what the function does. Here’s a new version
    of the intro function that allows us to pass a single argument:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 intro 函数并不灵活，因为每次调用它时都做相同的事情。我们可以修改函数，以便能够传递参数，而我们传递的参数可以影响函数的行为。这里是一个新的
    intro 函数版本，它允许我们传递一个参数：
- en: '>>> def intro2(message):'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> def intro2(message):'
- en: '...     line_length = len(message) + 2'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '...     line_length = len(message) + 2'
- en: '...     print(''*'' * line_length)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '...     print(''*'' * line_length)'
- en: '...     print(f''*{message}*'')'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '...     print(f''*{message}*'')'
- en: '...     print(''*'' * line_length)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '...     print(''*'' * line_length)'
- en: '...'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: 'To call this function, we provide a string argument:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用此函数，我们提供一个字符串参数：
- en: '>>> intro2(''HELLO'')'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> intro2(''HELLO'')'
- en: '*******'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*******'
- en: '*HELLO*'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*HELLO*'
- en: '*******'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*******'
- en: '>>> intro2(''WIN'')'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> intro2(''WIN'')'
- en: '*****'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*****'
- en: '*WIN*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*WIN*'
- en: '*****'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*****'
- en: 'We can’t call this intro2 function without an argument—if we try, we get an
    error:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能在没有参数的情况下调用这个 intro2 函数——如果我们尝试，系统会报错：
- en: '>>> intro2()'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> intro2()'
- en: 'Traceback (most recent call last):'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 回溯（最近的调用最后）：
- en: File "<stdin>", line 1, in <module>
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 "<stdin>"，第 1 行，在 <module> 中
- en: 'TypeError: intro2() missing 1 required positional argument: ''message'''
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 'TypeError: intro2() 缺少 1 个必需的位置参数：''message'''
- en: The error reminds us that we have not provided an argument for message. The
    name message is known as a function *parameter*. When we call intro2, Python first
    makes message refer to whatever our argument refers to; that is, message becomes
    an alias for our argument.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 错误提醒我们没有为 message 提供参数。message 是一个函数的*参数*。当我们调用 intro2 时，Python 首先让 message
    引用我们的参数所引用的内容；也就是说，message 成为我们参数的别名。
- en: 'We can create functions with more than one parameter. Here’s a function that
    takes two parameters, a message to print and the number of times to print it:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建具有多个参数的函数。这里有一个函数，接受两个参数：一个是要打印的消息，另一个是打印的次数：
- en: '>>> def intro3(message, num_times):'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> def intro3(message, num_times):'
- en: '...     for i in range(num_times):'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '...     for i in range(num_times):'
- en: '...         print(message)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '...         print(message)'
- en: '...'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: 'To call this one, we provide two arguments. Python works from left to right,
    assigning the first argument to the first parameter and the second argument to
    the second parameter. In the following call, ''high'' is assigned to the message
    parameter and 5 is assigned to the num_times parameter:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用这个函数，我们提供两个参数。Python 从左到右工作，将第一个参数赋给第一个参数位置，将第二个参数赋给第二个参数位置。在以下调用中，'high'
    被赋值给 message 参数，5 被赋值给 num_times 参数：
- en: '>>> intro3(''high'', 5)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> intro3(''high'', 5)'
- en: high
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: high
- en: high
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: high
- en: high
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: high
- en: high
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: high
- en: high
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: high
- en: 'Be sure to provide the correct number of arguments. For intro3, we need two
    arguments. Anything else is an error:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保提供正确数量的参数。对于 intro3，我们需要两个参数。其他任何情况都会报错：
- en: '>>> intro3()'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> intro3()'
- en: 'Traceback (most recent call last):'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 回溯（最近的调用最后）：
- en: File "<stdin>", line 1, in <module>
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 "<stdin>"，第 1 行，在 <module> 中
- en: 'TypeError: intro3() missing 2 required positional arguments: ''message'''
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 'TypeError: intro3() 缺少 2 个必需的位置参数：''message'''
- en: and 'num_times'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 和 'num_times'
- en: '>>> intro3(''high'')'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> intro3(''high'')'
- en: 'Traceback (most recent call last):'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 回溯（最近的调用最后）：
- en: File "<stdin>", line 1, in <module>
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 "<stdin>"，第 1 行，在 <module> 中
- en: 'TypeError: intro3() missing 1 required positional argument: ''num_times'''
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 'TypeError: intro3() 缺少 1 个必需的位置参数：''num_times'''
- en: 'We also have to be sure to provide values of the proper types. Wrong types
    won’t stop us from calling the function, but they will cause an error within the
    function:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须确保提供正确类型的值。错误的类型不会阻止我们调用函数，但它们会在函数内部引发错误：
- en: '>>> intro3(''high'', ''low'')'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> intro3(''high'', ''low'')'
- en: 'Traceback (most recent call last):'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 回溯（最近的调用最后）：
- en: File "<stdin>", line 1, in <module>
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 "<stdin>"，第 1 行，在 <module> 中
- en: File "<stdin>", line 2, in intro3
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 "<stdin>"，第 2 行，在 intro3 中
- en: 'TypeError: ''str'' object cannot be interpreted as an integer'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 'TypeError: ''str'' 对象不能作为整数解释'
- en: This TypeError arises because intro3 uses a range for loop on variable num_times.
    If the argument we provide for num_times is not an integer, the range for loop
    fails.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 TypeError 错误发生是因为 intro3 使用了针对 num_times 变量的 range 循环。如果我们为 num_times 提供的参数不是整数，那么
    range 循环会失败。
- en: Keyword Arguments
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 关键字参数
- en: 'It’s possible to override the left-to-right correspondence between arguments
    and parameters when calling a function. To do that, we use the names of parameters
    in whatever order we like. An argument that uses the name of a parameter is called
    a *keyword argument*. Here’s how it works:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 调用函数时，可以覆盖参数与参数值之间的左到右对应关系。为了实现这一点，我们可以随意使用参数的名称顺序。使用参数名称的参数被称为*关键字参数*。这就是它的工作原理：
- en: '>>> def intro3(message, num_times):'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> def intro3(message, num_times):'
- en: '...     for i in range(num_times):'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '...     对于 i 在 range(num_times) 中:'
- en: '...         print(message)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '...         打印(message)'
- en: '...'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '>>> intro3(message=''high'', num_times=3)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> intro3(message=''high'', num_times=3)'
- en: high
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: high
- en: high
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: high
- en: high
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: high
- en: '>>> intro3(num_times=3, message=''high'')'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> intro3(num_times=3, message=''high'')'
- en: high
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: high
- en: high
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: high
- en: high
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: high
- en: Each function call here uses two keyword arguments. A keyword argument is written
    as the name of a parameter, an equal sign, and its corresponding argument.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 每次函数调用使用两个关键字参数。关键字参数写作参数名、等号及其对应的参数值。
- en: 'You can even start with regular arguments and finish with keyword arguments:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以先使用常规参数，再使用关键字参数：
- en: '>>> intro3(''high'', num_times=3)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> intro3(''high'', num_times=3)'
- en: high
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: high
- en: high
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: high
- en: high
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: high
- en: 'But once you use a keyword argument, you can’t go back to regular ones:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 但是一旦你使用了关键字参数，就不能再回到常规参数了：
- en: '>>> intro3(message=''high'', 3)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> intro3(message=''high'', 3)'
- en: File "<stdin>", line 1
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 "<stdin>"，第 1 行
- en: 'SyntaxError: positional argument follows keyword argument'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 'SyntaxError: 位置参数位于关键字参数后面'
- en: In “Sorting a List” in [Chapter 5](ch05.xhtml#ch05) we used a reverse keyword
    argument when calling the sort method. The Python designers decided that reverse
    would be a keyword-only parameter, which means that it’s impossible to fill in
    its value without using a keyword argument. Python lets us do that with our functions,
    too, but we won’t need that level of control in this book.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在《[第 5 章](ch05.xhtml#ch05) 排序一个列表》中，我们在调用 sort 方法时使用了一个 reverse 关键字参数。Python
    设计者决定 reverse 只能作为关键字参数使用，这意味着无法在不使用关键字参数的情况下填充它的值。Python 也允许我们对函数使用这种方式，但本书中不需要这种控制。
- en: Local Variables
  id: totrans-162
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 局部变量
- en: 'Names of parameters work like regular variables, but are *local* to the function
    in which they’re defined. That is, a function parameter doesn’t exist outside
    of its function:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 参数名称像常规变量一样工作，但它们是*局部的*，仅在定义它们的函数中存在。也就是说，函数参数在函数外部不存在：
- en: '>>> def intro2(message):'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> def intro2(message):'
- en: '...     line_length = len(message) + 2'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '...     line_length = len(message) + 2'
- en: '...     print(''*'' * line_length)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '...     打印(''*'' * line_length)'
- en: '...     print(f''*{message}*'')'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '...     打印(f''*{message}*'')'
- en: '...     print(''*'' * line_length)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '...     打印(''*'' * line_length)'
- en: '...'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '>>> intro2(''hello'')'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> intro2(''hello'')'
- en: '*******'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '*******'
- en: '*hello*'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*hello*'
- en: '*******'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '*******'
- en: '>>> message'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> message'
- en: 'Traceback (most recent call last):'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 错误追踪（最近的调用最后）：
- en: File "<stdin>", line 1, in <module>
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 "<stdin>"，第 1 行，在 <module> 中
- en: 'NameError: name ''message'' is not defined'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 'NameError: 未定义名称 ''message'''
- en: 'What about that line_length variable—is it local, too? It is:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 那么那个 line_length 变量呢——它也是局部的吗？它是的：
- en: '>>> line_length'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> line_length'
- en: 'Traceback (most recent call last):'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 错误追踪（最近的调用最后）：
- en: File "<stdin>", line 1, in <module>
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 "<stdin>"，第 1 行，在 <module> 中
- en: 'NameError: name ''line_length'' is not defined'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 'NameError: 未定义名称 ''line_length'''
- en: 'What happens if you have a variable and you call a function that uses a parameter
    or local variable of the same name? Is your value lost? Let’s see:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个变量，并且调用了一个使用相同名称参数或局部变量的函数，会发生什么？你的值会丢失吗？我们来看一下：
- en: '>>> line_length = 999'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> line_length = 999'
- en: '>>> intro2(''hello'')'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> intro2(''hello'')'
- en: '*******'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '*******'
- en: '*hello*'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '*hello*'
- en: '*******'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '*******'
- en: '>>> line_length'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> line_length'
- en: '999'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '999'
- en: Phew—it’s still 999, just as we left it. Local variables are created when a
    function is called and destroyed when the function terminates, all without affecting
    other variables with shared names.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 呼——它仍然是 999，就像我们离开时一样。局部变量在函数调用时创建，并在函数终止时销毁，且不会影响其他具有相同名称的变量。
- en: A function can access a variable that was created outside of that function.
    It’s ill-advised to rely on that, though, because then that function isn’t self-contained,
    instead hoping that variables it expects to be there are actually there. In this
    book, we’ll write functions so that they only use local variables. All information
    that a function needs will be provided to the function through its parameters.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 一个函数可以访问函数外部创建的变量。然而，不建议依赖这种做法，因为这样函数就不是自包含的，而是期望某些变量已经存在。在本书中，我们将编写只使用局部变量的函数。所有函数需要的信息都会通过参数传递给函数。
- en: Mutable Parameters
  id: totrans-193
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 可变参数
- en: 'Since a parameter is an alias for its corresponding argument, it can be used
    to change a mutable value. Here’s a function that removes all occurrences of value
    from a list lst:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 由于参数是其对应实参的别名，它可以用来改变可变值。这里是一个函数，用于从列表 lst 中移除所有出现的某个值：
- en: '>>> def remove_all(lst, value):'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> def remove_all(lst, value):'
- en: '...     while value in lst:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '...         while value in lst:'
- en: '...         lst.remove(value)'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '...         lst.remove(value)'
- en: '...'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '>>> lst = [5, 10, 20, 5, 45, 5, 9]'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> lst = [5, 10, 20, 5, 45, 5, 9]'
- en: '>>> remove_all(lst, 5)'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> remove_all(lst, 5)'
- en: '>>> lst'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> lst'
- en: '[10, 20, 45, 9]'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '[10, 20, 45, 9]'
- en: 'Notice that we passed a list to remove_all by using a variable. This function
    won’t accomplish anything useful if you call it with a list value directly (rather
    than with a variable referring to a list):'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们通过使用变量将列表传递给 remove_all。如果你直接用列表值（而不是引用列表的变量）调用这个函数，它将不会完成任何有用的操作：
- en: '>>> remove_all([5, 10, 20, 5, 45, 5, 9], 5)'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> remove_all([5, 10, 20, 5, 45, 5, 9], 5)'
- en: The function removed all the 5s from the list, but because we didn’t use a variable,
    we have no way to refer to that list ever again.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数移除了列表中的所有5，但由于我们没有使用变量，我们再也无法引用这个列表。
- en: '**CONCEPT CHECK**'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念检查**'
- en: What is the output of the following code?
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码的输出是什么？
- en: 'def mystery(s, lst):'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 'def mystery(s, lst):'
- en: s = s.upper()
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: s = s.upper()
- en: lst = lst + [2]
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: lst = lst + [2]
- en: s = 'a'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: s = 'a'
- en: lst = [1]
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: lst = [1]
- en: mystery(s, lst)
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: mystery(s, lst)
- en: print(s, lst)
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: print(s, lst)
- en: A. a [1]
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: A. a [1]
- en: B. a [1, 2]
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: B. a [1, 2]
- en: C. A [1]
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: C. A [1]
- en: D. A [1, 2]
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: D. A [1, 2]
- en: 'Answer: A. When mystery is called, its s parameter is made to reference whatever
    the s argument refers to, which is the ''a'' string. Similarly, its lst parameter
    is made to reference whatever the lst argument refers to, which is the [1] list.
    Inside of mystery, s and lst are local variables.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：A。当调用 mystery 函数时，它的 s 参数会指向 s 实参指向的内容，即 'a' 字符串。同样，它的 lst 参数会指向 lst 实参指向的内容，即
    [1] 列表。在 mystery 函数内部，s 和 lst 是局部变量。
- en: Now let’s study the two statements of the function itself.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来研究一下函数本身的两个语句。
- en: First, s = s.upper(). This makes the local variable s refer to 'A' (uppercase).
    But it hasn’t changed what s refers to outside of the function. That still refers
    to 'a' (lowercase).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，s = s.upper()。这使得局部变量 s 指向 'A'（大写）。但它没有改变函数外部的 s 指向的内容，外部的 s 仍然指向 'a'（小写）。
- en: 'Second, lst = lst + [2]. Using + with lists creates a new list (it doesn’t
    change an existing list!), so this makes the local variable lst refer to the new
    list: [1, 2]. But, again, it hasn’t changed what lst refers to outside of the
    function; it’s still [1].'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，lst = lst + [2]。使用 + 运算符与列表操作会创建一个新列表（它不会改变现有的列表！），因此这使得局部变量 lst 指向新的列表：[1,
    2]。但同样，它并没有改变外部 lst 指向的内容，它仍然是 [1]。
- en: 'What gives—didn’t I tell you previously that functions can change a mutable
    parameter? I did; but to make that happen, you really do need to change the value
    itself, not what a local variable refers to. Compare the previous program with
    the next one, whose output is different:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 怎么回事——不是说过函数可以改变一个可变参数吗？是的，但为了让这种情况发生，你确实需要改变值本身，而不是局部变量指向的内容。比较之前的程序和下面的程序，后者的输出不同：
- en: 'def mystery(s, lst):'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 'def mystery(s, lst):'
- en: s.upper()  # upper creates a new string
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 's.upper()  # upper 创建一个新字符串'
- en: lst.append(2)  # append changes the list
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 'lst.append(2)  # append 改变了列表'
- en: s = 'a'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: s = 'a'
- en: lst = [1]
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: lst = [1]
- en: mystery(s, lst)
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: mystery(s, lst)
- en: print(s, lst)
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: print(s, lst)
- en: Return Values
  id: totrans-231
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 返回值
- en: 'Let’s come back to our Card Game problem. Our goal is to define a function
    that tells us whether there are no high cards in a list of cards. We’ll name that
    function no_high. We haven’t written no_high yet, but we can still specify what
    we hope to accomplish. Here’s what we’re after:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到卡牌游戏问题。我们的目标是定义一个函数，告诉我们在一副牌中是否没有高牌。我们将这个函数命名为 no_high。虽然我们还没有编写 no_high
    函数，但我们可以先说明我们希望实现的目标。以下是我们的目标：
- en: '>>> no_high([''two'', ''six''])'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> no_high([''two'', ''six''])'
- en: 'True'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 'True'
- en: '>>> no_high([''eight''])'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> no_high([''eight''])'
- en: 'True'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 'True'
- en: '>>> no_high([''two'', ''jack'', ''four''])'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> no_high([''two'', ''jack'', ''four''])'
- en: 'False'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 'False'
- en: '>>> no_high([''queen'', ''king'', ''three'', ''queen''])'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> no_high([''queen'', ''king'', ''three'', ''queen''])'
- en: 'False'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 'False'
- en: We want the first two calls to return True, because there are no high cards
    in those lists of cards. And we want the third and fourth calls to return False,
    because there’s at least one high card in those lists of cards.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望前两次调用返回 True，因为在那些卡片列表中没有高牌。而我们希望第三次和第四次调用返回 False，因为在那些卡片列表中至少有一张高牌。
- en: How can we define a function that returns these True and False values? That’s
    the final piece of the function puzzle.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何定义一个函数，返回这些 True 和 False 值呢？这就是函数谜题的最后一块拼图。
- en: To return a value from a function, we use Python’s return keyword. As soon as
    a return is reached, execution of the function terminates, and the specified value
    is returned to the caller.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 要从函数返回一个值，我们使用 Python 的 return 关键字。一旦执行到 return，函数执行就会立即终止，并且指定的值会返回给调用者。
- en: 'Here’s how we can write the no_high function:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何编写 no_high 函数的方式：
- en: '>>> def no_high(lst):'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> def no_high(lst):'
- en: '...     if ''jack'' in lst:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '...     if ''jack'' in lst:'
- en: '...         return False'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '...         return False'
- en: '...     if ''queen'' in lst:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '...     if ''queen'' in lst:'
- en: '...         return False'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '...         return False'
- en: '...     if ''king'' in lst:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '...     if ''king'' in lst:'
- en: '...         return False'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '...         return False'
- en: '...     if ''ace'' in lst:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '...     if ''ace'' in lst:'
- en: '...         return False'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '...         return False'
- en: '...     return True'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '...     return True'
- en: '...'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: We first check whether there are any 'jack' cards in the list. If there are,
    then we know that the list contains one or more high cards, so we immediately
    return False.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查列表中是否有任何 'jack' 卡片。如果有，那么我们知道列表中包含一个或多个高牌，因此我们立即返回 False。
- en: If we’re still here, then we know that there are no jacks. But there could be
    other high cards, so we need to check for them. The rest of the if statements
    check for queens, kings, and aces, respectively, returning False if any of them
    is in the list.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们还在这里，那么我们知道没有 jack。但仍可能有其他高牌，所以我们需要检查它们。其余的 if 语句分别检查 queen、king 和 ace，如果它们中的任何一个存在于列表中，则返回
    False。
- en: If we don’t hit any of those four return statements, then there are no high
    cards in the list. In that case, we return True.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有遇到这四个 return 语句，那么列表中就没有高牌。在这种情况下，我们返回 True。
- en: A return by itself, with no value given, returns the value None. That’s useful
    if you’re writing a function that doesn’t return anything useful and you need
    to terminate the function before reaching the bottom of its code.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: A. 没有给定值的 return 本身会返回 None。这个特性在你编写一个没有返回有用结果的函数时非常有用，可以让你在到达函数代码的底部之前终止函数。
- en: 'If a return is encountered inside a loop, the function still terminates immediately,
    regardless of how deeply nested it is. Here’s an example showing a return getting
    us out of a nested loop:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在循环中遇到 return，函数仍会立即终止，不论它嵌套得多深。下面是一个例子，展示了 return 如何让我们跳出一个嵌套循环：
- en: '>>> def func():'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> def func():'
- en: '...     for i in range(10):'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '...     for i in range(10):'
- en: '...         for j in range(10):'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '...         for j in range(10):'
- en: '...             print(i, j)'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '...             print(i, j)'
- en: '...             if j == 4:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '...             if j == 4:'
- en: '...                 return'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '...                 return'
- en: '...'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '>>> func()'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> func()'
- en: 0 0
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 0 0
- en: 0 1
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 0 1
- en: 0 2
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 0 2
- en: 0 3
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 0 3
- en: 0 4
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 0 4
- en: 'A return is like a super-break! Some people don’t like using return from within
    a loop for the same reason that they don’t like break: it can obscure the purpose
    and logic of a loop. I’ll use return within a loop when convenient. Unlike break,
    which can show up anywhere, a return is restricted to showing up within a function,
    separated from other code. If we keep our functions small, then using a return
    within a loop can help us write clear code without interfering with the code around
    it.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: return 就像是超级 break！有些人不喜欢在循环中使用 return，原因和他们不喜欢 break 是一样的：它可能会掩盖循环的目的和逻辑。我在循环中使用
    return 是为了方便。与可以随处出现的 break 不同，return 只能在函数内部使用，并且与其他代码分开。如果我们保持函数的简洁，那么在循环中使用
    return 可以帮助我们编写清晰的代码，而不会干扰周围的代码。
- en: '**CONCEPT CHECK**'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念检查**'
- en: Is the following version of no_high correct? That is, does it return True if
    there is at least one high card in the list, and False otherwise?
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 以下版本的 no_high 函数是否正确？也就是说，它是否在列表中至少有一张高牌时返回 True，否则返回 False？
- en: 'def no_high(lst):'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 'def no_high(lst):'
- en: 'for card in lst:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 'for card in lst:'
- en: 'if card in [''jack'', ''queen'', ''king'', ''ace'']:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 'if card in [''jack'', ''queen'', ''king'', ''ace'']:'
- en: return False
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: return False
- en: 'else:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: return True
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: return True
- en: A. Yes
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: A. 是的
- en: B. No; for example, it returns the wrong value for ['two', 'three']
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: B. 不是；例如，它返回错误的值，对于 ['two', 'three'] 来说就是如此。
- en: C. No; for example, it returns the wrong value for ['jack']
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: C. 不是；例如，它返回错误的值，对于 ['jack'] 来说就是如此。
- en: D. No; for example, it returns the wrong value for ['jack', 'two']
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: D. 不是；例如，它返回错误的值，对于 ['jack', 'two'] 来说就是如此。
- en: E. No; for example, it returns the wrong value for ['two', 'jack']
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: E. 不对；例如，它对 ['two', 'jack'] 返回错误的值
- en: 'Answer: E. The if-else statement causes the loop to always terminate on its
    first iteration. If the first card is a high card, the function terminates and
    returns False; if the first card is not a high card, the function terminates and
    returns True. It doesn’t look at any of the other cards! And that’s why it fails
    on [''two'', ''jack'']: the first card is not a high card, so the function returns
    True. Returning True tells us that there are no high cards in the list. But that’s
    wrong: there’s a jack in there! The function did the wrong thing. It should have
    returned False.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：E. if-else 语句使得循环总是在第一次迭代时终止。如果第一张牌是高牌，函数就终止并返回 False；如果第一张牌不是高牌，函数就终止并返回
    True。它不会检查其他任何牌！这就是它在 ['two', 'jack'] 上失败的原因：第一张牌不是高牌，因此函数返回 True。返回 True 告诉我们列表中没有高牌。但这错了：里面有一张杰克！函数做错了，应该返回
    False。
- en: Function Documentation
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数文档
- en: It’s clear to us right now what our no_high function does and how we should
    call it. But what about in a few months, when the purpose of our old code doesn’t
    come readily to mind? And what about once we’ve amassed a large collection of
    our own functions, making it difficult to remember what each one does?
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们很清楚 no_high 函数的作用，以及如何调用它。但如果几个月后，旧代码的目的不容易记起来怎么办？如果我们积累了大量自己的函数，导致很难记住每个函数的作用又该怎么办？
- en: 'For each function we write, we’ll add documentation that specifies the meaning
    of each parameter and what the function returns. Such documentation is called
    a *docstring*, for “documentation string.” The docstring should be written starting
    at the first line of the function’s block. Here’s the no_high function, this time
    with documentation:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们编写的每个函数，我们都会添加文档，说明每个参数的含义以及函数返回的内容。这种文档叫做*文档字符串*，即“documentation string”。文档字符串应该从函数代码块的第一行开始编写。下面是
    no_high 函数，带有文档字符串：
- en: '>>> def no_high(lst):'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> def no_high(lst):'
- en: '...     """'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '...     """'
- en: '...     lst is a list of strings representing cards.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '...     lst 是一个字符串列表，表示扑克牌。'
- en: '...'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '...     Return True if there are no high cards in lst, False otherwise.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '...     如果 lst 中没有高牌，则返回 True，否则返回 False。'
- en: '...     """'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '...     """'
- en: '...     if ''jack'' in lst:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '...     如果 ''jack'' 在 lst 中：'
- en: '...         return False'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '...         return False'
- en: '...     if ''queen'' in lst:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '...     如果 ''queen'' 在 lst 中：'
- en: '...         return False'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '...         return False'
- en: '...     if ''king'' in lst:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '...     如果 ''king'' 在 lst 中：'
- en: '...         return False'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '...         return False'
- en: '...     if ''ace'' in lst:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '...     如果 ''ace'' 在 lst 中：'
- en: '...         return False'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '...         return False'
- en: '...     return True'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '...     return True'
- en: '...'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: The docstring begins and ends with three double quotes ("""). Like a single
    quote (') or double quote ("), three double quotes can be used to start and end
    any string. A string created with three quotes is called a *triple-quoted string*.
    (Three single quotes work as well, but Python convention is to use three double
    quotes.) They have the bonus of letting us add multiple lines of text to the string
    by just pressing ENTER after each line; strings created with ' or " can’t span
    lines like that. We use triple-quoted strings for docstrings so that we can include
    as many lines as we like.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 文档字符串以三个双引号（"""）开始和结束。像单引号（'）或双引号（"）一样，三个双引号可以用来开始和结束任何字符串。使用三个引号创建的字符串叫做*三引号字符串*。（三单引号也可以，但
    Python 的约定是使用三个双引号。）它们的优势是允许我们通过在每行后按下 ENTER 键来添加多行文本；而使用 ' 或 " 创建的字符串不能像这样跨越多行。我们使用三引号字符串作为文档字符串，以便可以包括任意数量的行。
- en: 'The docstring here tells us what lst is: it’s a list of strings representing
    cards. It also tells us that the function returns a True or False value and what
    each return value means. This is sufficient information to enable someone to call
    the function without having to look at its code. As long as someone knows what
    a function does, they can just use it. We’ve been using Python functions all along
    without ever having looked at their code. How does print work? How does input
    work? We don’t know! But it doesn’t matter: we know what the functions do, so
    we can just focus on calling them.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的文档字符串告诉我们 lst 是什么：它是一个表示扑克牌的字符串列表。它还告诉我们函数返回 True 或 False 值，并说明每个返回值的含义。这些信息足够让别人可以调用函数，而无需查看它的代码。只要有人知道一个函数的作用，他们就可以直接使用它。我们一直在使用
    Python 函数，甚至从来没有看过它们的代码。print 是如何工作的？input 是如何工作的？我们不知道！但这并不重要：我们知道这些函数做什么，所以我们只需专注于调用它们。
- en: 'For functions with multiple parameters, the docstring should name each one
    and give its expected type. Here’s remove_all, from “Mutable Parameters” in this
    chapter, with a suitable docstring:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有多个参数的函数，文档字符串应命名每个参数并给出其预期类型。以下是remove_all函数，来自本章“可变参数”部分，具有合适的文档字符串：
- en: '>>> def remove_all(lst, value):'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> def remove_all(lst, value):'
- en: '...     """'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '...     """'
- en: '...     lst is a list.'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '...     lst是一个列表。'
- en: '...     value is a value.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '...     value是一个值。'
- en: '...'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '...     Remove all occurrences of value from lst.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '...     移除lst中所有的value出现的地方。'
- en: '...     """'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '...     """'
- en: '...     while value in lst:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '...     while value in lst:'
- en: '...         lst.remove(value)'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '...         lst.remove(value)'
- en: '...'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: Notice that this docstring doesn’t talk about returning anything. That’s because
    this function doesn’t return anything useful! It removes from lst, which is what
    the docstring says it does.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个文档字符串没有谈论返回任何内容。这是因为这个函数不返回任何有用的东西！它从lst中移除元素，这正是文档字符串所描述的。
- en: Solving the Problem
  id: totrans-322
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决问题
- en: We’ve just learned the fundamentals of defining and calling functions. For the
    rest of the book, whenever we’re faced with a large problem to solve, we’ll be
    able to break down its solution into smaller tasks, each of which will be solved
    by a function.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚学习了定义和调用函数的基础知识。在本书的剩余部分，每当我们面临一个大问题时，我们就能够将其解决方案分解为更小的任务，每个任务将由一个函数解决。
- en: Let’s use our no_high function in a solution to Card Game. The code is in [Listing
    6-1](ch06.xhtml#ch06ex01).
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在Card Game的解决方案中使用我们的no_high函数。代码在[Listing 6-1](ch06.xhtml#ch06ex01)中。
- en: ❶ NUM_CARDS = 52
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ NUM_CARDS = 52
- en: '❷ def no_high(lst):'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 定义no_high(lst)：
- en: '"""'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: lst is a list of strings representing cards.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: lst是一个字符串列表，表示牌。
- en: Return True if there are no high cards in lst, False otherwise.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 如果lst中没有高牌，返回True，否则返回False。
- en: '"""'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: 'if ''jack'' in lst:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 如果'lst'中有'jack'：
- en: return False
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 返回False
- en: 'if ''queen'' in lst:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 如果'lst'中有'queen'：
- en: return False
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 返回False
- en: 'if ''king'' in lst:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 如果'lst'中有'king'：
- en: return False
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 返回False
- en: 'if ''ace'' in lst:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 如果'lst'中有'ace'：
- en: return False
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 返回False
- en: return True
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 返回True
- en: ❸ deck = []
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ deck = []
- en: '❹ for i in range(NUM_CARDS):'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 对i在range(NUM_CARDS)中：
- en: deck.append(input())
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: deck.append(input())
- en: score_a = 0
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: score_a = 0
- en: score_b = 0
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: score_b = 0
- en: player = 'A'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: player = 'A'
- en: '❺ for i in range(NUM_CARDS):'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 对i在range(NUM_CARDS)中：
- en: card = deck[i]
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: card = deck[i]
- en: points = 0
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: points = 0
- en: ❻ remaining = NUM_CARDS - i - 1
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ remaining = NUM_CARDS - i - 1
- en: '❼ if card == ''jack'' and remaining >= 1 and no_high(deck[i+1:i+2]):'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '❼ 如果card == ''jack'' and remaining >= 1 and no_high(deck[i+1:i+2]):'
- en: points = 1
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: points = 1
- en: 'elif card == ''queen'' and remaining >= 2 and no_high(deck[i+1:i+3]):'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif card == ''queen'' and remaining >= 2 and no_high(deck[i+1:i+3]):'
- en: points = 2
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: points = 2
- en: 'elif card == ''king'' and remaining >= 3 and no_high(deck[i+1:i+4]):'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif card == ''king'' and remaining >= 3 and no_high(deck[i+1:i+4]):'
- en: points = 3
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: points = 3
- en: 'elif card == ''ace'' and remaining >= 4 and no_high(deck[i+1:i+5]):'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif card == ''ace'' and remaining >= 4 and no_high(deck[i+1:i+5]):'
- en: points = 4
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: points = 4
- en: '❽ if points > 0:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 如果points > 0：
- en: print(f'Player {player} scores {points} point(s).')
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: print(f'玩家{player}得分 {points} 分。')
- en: '❾ if player == ''A'':'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 如果player == 'A'：
- en: score_a = score_a + points
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: score_a = score_a + points
- en: player = 'B'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: player = 'B'
- en: 'else:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 否则：
- en: score_b = score_b + points
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: score_b = score_b + points
- en: player = 'A'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: player = 'A'
- en: 'print(f''Player A: {score_a} point(s).'')'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 'print(f''玩家A: {score_a} 分。'')'
- en: 'print(f''Player B: {score_b} point(s).'')'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 'print(f''玩家B: {score_b} 分。'')'
- en: '*Listing 6-1: Solving Card Game*'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 6-1: 解决Card Game*'
- en: I’ve introduced the constant NUM_CARDS to refer to 52 ❶. We’ll use it a couple
    of times in the code, and it’s easier to remember what NUM_CARDS means than what
    52 means.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 我引入了常量NUM_CARDS来表示52 ❶。我们将在代码中多次使用它，记住NUM_CARDS的含义比记住52的含义要容易。
- en: Next we define the no_high function, including docstring, that we’ve discussed
    in depth ❷. We’ll always put our functions near the top of our programs. This
    way, the functions are available to be called by any code that follows them.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们定义no_high函数，包括文档字符串，这是我们已经深入讨论过的 ❷。我们通常将函数放在程序的顶部，这样函数就可以被后续的代码调用。
- en: The main part of the program starts with creating a list that will hold the
    cards in the deck ❸. We then read the cards from the input ❹, appending each to
    the deck. You’ll notice that cards are never literally removed or taken from the
    deck (the deck remains as is throughout program execution). We could have done
    it that way. Instead, I’ve chosen to track where we are in the deck so that we
    know which card would be removed next.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的主要部分从创建一个列表开始，该列表将保存牌组中的牌 ❸。然后我们从输入中读取牌，将每张牌附加到牌组中。你会注意到，牌从未被字面上移除或从牌组中取出（牌组在整个程序执行过程中保持不变）。我们本可以那样做，但我选择跟踪我们在牌组中的位置，这样我们就知道下一张被移除的牌是哪张。
- en: 'There are three other crucial variables that we maintain: score_a, the current
    total score for player A; score_b, the current total score for player B; and player,
    the name of the current player.'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 还有三个其他关键变量需要维护：`score_a`，玩家 A 当前的总得分；`score_b`，玩家 B 当前的总得分；以及 `player`，当前玩家的名字。
- en: 'Our next task is to look at each card in the deck to give points to the players.
    A regular for loop would let us look at the current card. But that’s not enough:
    if the current card is a high card, then we have to be able to look at later cards
    as well. To facilitate that, we use a range for loop ❺.'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一步任务是查看牌组中的每张卡片并给予玩家得分。常规的 for 循环允许我们查看当前卡片。但这还不够：如果当前卡片是高牌，我们还需要查看后面的卡片。为了实现这一点，我们使用了
    range for 循环 ❺。
- en: On each iteration of this loop, we determine the number of points awarded to
    the current player based on the card that they take from the deck. Each rule for
    getting points depends on the deck having some number of remaining cards. The
    remaining variable ❻ tells us the number of remaining cards. When i is 0, the
    number of remaining cards is 51, because we’ve just taken the first card. When
    i is 1, the number of remaining cards is 50, because we’ve just taken the second
    card. In general, the expression for the number of remaining cards is the total
    number of cards, minus i, minus 1.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次循环迭代中，我们会根据玩家从牌组中抽取的卡片来确定他们获得的得分。每条得分规则依赖于牌组中剩余卡片的数量。`remaining` 变量 ❻ 告诉我们剩余卡片的数量。当
    i 为 0 时，剩余卡片的数量是 51，因为我们刚刚抽取了第一张卡片。当 i 为 1 时，剩余卡片的数量是 50，因为我们刚刚抽取了第二张卡片。一般来说，剩余卡片数量的表达式是总卡片数减去
    i 再减去 1。
- en: And now we have four tests, one for each way to score points ❼. Each one checks
    the current card and the number of cards remaining. If both of those conditions
    are True, then a call is made to our no_high function with a slice of the deck
    containing the appropriate number of cards. For example, if the current card is
    a 'jack' and there is at least 1 card remaining, then we pass a list of length
    1 to no_high ❼. If no_high returns True, then there are no high cards in the slice
    of the list, so the current player gets points. The points variable determines
    the number of points that will be awarded; it starts at 0 on each iteration of
    the loop and is set to 1, 2, 3, or 4 as appropriate.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有四个测试，每个测试对应一种得分方式❼。每个测试都会检查当前卡片和剩余卡片的数量。如果这两个条件都为真，就会调用我们的 `no_high` 函数，并传递包含适当数量卡片的牌组切片。例如，如果当前卡片是“杰克”并且至少剩下
    1 张卡片，我们就会将长度为 1 的列表传递给 `no_high` ❼。如果 `no_high` 返回 True，那么该切片中就没有高牌，因此当前玩家会得分。`points`
    变量决定将要奖励的得分；它在每次循环迭代时从 0 开始，根据情况设置为 1、2、3 或 4。
- en: If the player scored points ❽, then we output a message indicating the player
    who scored points and the number of points they scored.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家得分了 ❽，我们会输出一条消息，指示得分的玩家及他们得的分数。
- en: All that’s left for the current iteration is to add the points to the current
    player’s score and make it the other player’s turn. We accomplish both of these
    tasks with an if-else statement ❾. (If points is 0 on this iteration, then a harmless
    0 is added to a player’s score. There’s no reason to explicitly test for and avoid
    that.)
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 当前迭代中剩下的任务是将得分加到当前玩家的得分中，并轮到另一个玩家。我们通过一个 if-else 语句 ❾ 来完成这两个任务。（如果本次迭代的 `points`
    是 0，那么就会把一个无害的 0 加到玩家的得分中。没有必要明确测试和避免这种情况。）
- en: The final two print calls output the total points for each player.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的两个 `print` 调用会输出每个玩家的总得分。
- en: 'There we go: a solution to the problem that uses a function to organize our
    code and make it easier to read. Feel free to submit our code to the judge, and
    you should see that all test cases pass.'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样：通过使用函数来组织我们的代码并使其更易于阅读，我们解决了这个问题。可以随意将我们的代码提交给评审，你应该能看到所有测试用例都通过了。
- en: 'Problem #15: Action Figures'
  id: totrans-380
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '问题 #15：动作人物'
- en: To solve Card Game, we first went through an example, and that example highlighted
    where a function might be useful. Now, we’ll solve another problem using functions,
    but we’ll discover the needed functions using a more systematic approach.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决纸牌游戏问题，我们首先通过一个示例，并且这个示例突出了在哪些地方使用函数可能是有用的。现在，我们将使用函数来解决另一个问题，但我们会通过更系统的方法来发现所需的函数。
- en: This is Timus problem 2144. This is the only problem in the book from the Timus
    judge. To find the problem, go to *[https://acm.timus.ru/](https://acm.timus.ru/)*,
    click **Problem set**, click **Volume 12**, and find problem 2144 (it’s called
    Cleaning the Room on the judge).
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Timus 问题 2144。这是书中唯一来自 Timus 评测系统的问题。要找到该问题，请访问 *[https://acm.timus.ru/](https://acm.timus.ru/)*，点击
    **Problem set**，点击 **Volume 12**，然后找到问题 2144（在评测系统中称为 Cleaning the Room）。
- en: The Challenge
  id: totrans-383
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战
- en: Lena has *n* unopened boxes of action figures. The boxes cannot be opened (otherwise
    the action figures lose their value), so the order of action figures in a box
    cannot be changed. Further, a box cannot be rotated (otherwise the action figures
    will be facing the wrong way).
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: Lena 有 *n* 个未打开的动作人物盒子。这些盒子不能被打开（否则动作人物的价值会丧失），因此盒子中的动作人物顺序不能改变。此外，盒子也不能旋转（否则动作人物会朝错的方向）。
- en: Each action figure is specified by its height. For example, one of the boxes
    might have three action figures, from left to right, of heights 4, 5, and 7\.
    When I talk about a box of action figures, I’ll always list the heights from left
    to right.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 每个动作人物都有一个高度。例如，其中一个盒子可能包含三个动作人物，按从左到右的顺序，它们的高度分别是 4、5 和 7。当我提到动作人物盒子时，我总是按从左到右的顺序列出它们的高度。
- en: Lena wants to *organize the boxes*, which means to arrange the boxes so that
    heights of action figures increase or stay the same from left to right.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: Lena 想要 *整理盒子*，这意味着要将盒子排列，使得盒子中的动作人物高度从左到右逐渐增加或保持不变。
- en: Whether she can organize the boxes or not depends on the heights of action figures
    in the boxes. For example, if a first box has action figures of heights 4, 5,
    and 7, and a second box has action figures of heights 1 and 2, then she can organize
    these boxes by putting the second box first. But if we keep the first box as is
    and change the second box to have action figures of heights 6 and 8, then there’s
    no way to organize these boxes.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 是否能够整理这些盒子取决于盒子中动作人物的高度。例如，如果第一个盒子有高度分别为 4、5 和 7 的动作人物，而第二个盒子有高度分别为 1 和 2 的动作人物，那么她可以通过将第二个盒子放在前面来整理这些盒子。但如果我们保持第一个盒子的顺序不变，并将第二个盒子的动作人物高度改为
    6 和 8，那么就无法整理这些盒子。
- en: Determine whether it’s possible for Lena to organize the boxes.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 判断 Lena 是否能整理这些盒子。
- en: Input
  id: totrans-389
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输入
- en: 'The input consists of the following lines:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 输入包含以下几行：
- en: A line containing integer *n*, the number of boxes. *n* is between 1 and 100.
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一行包含整数 *n*，表示盒子的数量。*n* 的值在 1 到 100 之间。
- en: '*n* lines, one for each box. Each of these lines begins with integer *k*, indicating
    the number of action figures in this box. *k* is between 1 and 100\. (Since *k*
    is at least 1, we don’t have to worry about empty boxes.) Following *k*, there
    are *k* integers giving the heights of the action figures from left to right in
    this box. Each height is an integer between 1 and 10,000\. There is a space between
    each pair of integers on the line.'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*n* 行，每行代表一个盒子。每行开始是一个整数 *k*，表示该盒子中的动作人物数量。*k* 的值在 1 到 100 之间。（因为 *k* 至少为 1，所以我们不需要担心空盒子的情况。）接下来是
    *k* 个整数，表示该盒子中动作人物的高度，按从左到右的顺序排列。每对整数之间有一个空格。'
- en: Output
  id: totrans-393
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输出
- en: If Lena can organize the boxes, output YES; otherwise, output NO.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Lena 能够整理这些盒子，则输出 YES；否则，输出 NO。
- en: Representing the Boxes
  id: totrans-395
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 盒子的表示
- en: This problem consists of several smaller problems, each of which we can solve
    by writing a function. Let’s first see how to represent the boxes in Python, and
    then we’ll design the functions that we need.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题由多个小问题组成，每个问题我们可以通过编写一个函数来解决。首先让我们看看如何在 Python 中表示这些盒子，然后我们将设计所需的函数。
- en: 'In [Chapter 5](ch05.xhtml#ch05), when we solved Baker Bonus, we learned that
    lists can have other lists as their values. This allows us to nest lists inside
    of lists. We can use such an arrangement to represent the boxes of action figures.
    For example, here’s a list that represents two boxes:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 5 章](ch05.xhtml#ch05)中，当我们解决 Baker Bonus 问题时，我们学到了列表可以包含其他列表作为其值。这使得我们可以将列表嵌套在其他列表中。我们可以使用这种结构来表示动作人物的盒子。例如，这里有一个表示两个盒子的列表：
- en: '>>> boxes = [[4, 5, 7], [1, 2]]'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> boxes = [[4, 5, 7], [1, 2]]'
- en: 'The first box has three action figures, and the second has two. We can access
    each box individually:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个盒子有三个动作人物，第二个盒子有两个。我们可以单独访问每个盒子：
- en: '>>> boxes[0]'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> boxes[0]'
- en: '[4, 5, 7]'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '[4, 5, 7]'
- en: '>>> boxes[1]'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> boxes[1]'
- en: '[1, 2]'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '[1, 2]'
- en: We’ll read the contents of the boxes from the input and put that information
    into a nested list, like the one I’ve shown. Then we’ll use that nested list to
    determine whether the boxes can be organized.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从输入中读取框的内容，并将这些信息放入一个嵌套列表，就像我展示的那样。然后，我们将使用这个嵌套列表来判断这些框是否能够被组织。
- en: Top-Down Design
  id: totrans-405
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自顶向下设计
- en: We’ll solve this problem using a program design approach called *top-down design*.
    Top-down design breaks a large problem into several smaller problems. That’s useful
    because each of the smaller problems will be easier to solve. We can then assemble
    those subproblem solutions to solve the original problem.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一种称为 *自顶向下设计* 的程序设计方法来解决这个问题。自顶向下设计将一个大问题分解为几个较小的问题。这样做很有用，因为每个较小的问题都更容易解决。然后，我们可以将这些子问题的解决方案组合起来，解决原始问题。
- en: Doing Top-Down Design
  id: totrans-407
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 执行自顶向下设计
- en: Here’s how top-down design works. We start by writing an incomplete Python program
    that captures the main tasks in a solution. Some of these tasks won’t require
    much code, so we can proceed to solve them directly. Other tasks will require
    more from us, and we’ll turn each of those into a function that we’ll call. We
    might also solve a task by writing a little code *and* calling a function. However,
    those functions won’t exist yet. We’ll have to write them!
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是自顶向下设计的工作原理。我们首先编写一个不完整的 Python 程序，捕捉解决方案中的主要任务。其中一些任务不需要很多代码，因此我们可以直接解决它们。其他任务则需要更多的工作，我们会将每个任务转化为一个函数，并在需要时调用它。我们也可能通过编写一点代码
    *并* 调用一个函数来解决某个任务。然而，这些函数还不存在，我们必须先编写它们！
- en: To write a needed function, we repeat this same process for that function’s
    task. That is, we start by writing down the tasks for that function. If we can
    write code for a task outright, then we do it; otherwise, we call another function
    (that we’ll write later) to handle that task.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写所需的函数，我们对该函数的任务重复执行相同的过程。也就是说，我们首先写下该函数的任务。如果我们可以直接为某个任务编写代码，就立即写；否则，我们调用另一个函数（稍后编写）来处理这个任务。
- en: We keep doing this until we have no more functions to write. At that point,
    we’ll have a solution to our problem.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直这样做，直到不再需要编写任何函数。到那时，我们就有了问题的解决方案。
- en: It’s called top-down design because we start at the top, or highest, level of
    the problem and make our way downward, through the guts of the problem, until
    each task has been completely written in code. We’ll now use this to solve Action
    Figures.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 它被称为自顶向下设计，因为我们从问题的顶层或最高层开始，逐步向下穿过问题的核心，直到每个任务都已完全用代码实现。接下来我们将使用这种方法来解决动作人物的问题。
- en: The Top Level
  id: totrans-412
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 顶层
- en: To begin our design, we focus on the main tasks that we’ll need to solve.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始设计之前，我们专注于需要解决的主要任务。
- en: We’ll certainly have to read the input, so that’s our first task.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 我们肯定需要读取输入数据，所以这是我们的第一个任务。
- en: Now, assume that we’ve read the input. What should we do to determine whether
    the boxes can be organized? One important thing to do is check each box on its
    own to make sure that its action figures have their heights in order. For example,
    suppose that we had the box [18, 20, 4]. This box, with heights out of order,
    means that we have no chance of organizing all of the boxes. We can’t even organize
    this one!
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们已经读取了输入数据。我们应该做什么来判断这些框是否可以被组织起来？一个重要的步骤是检查每个框本身，确保其中的动作人物高度是有序的。例如，假设我们有一个框
    [18, 20, 4]。这个框的高度顺序错乱，意味着我们没有机会组织所有的框。我们甚至不能组织这个框！
- en: 'So, that’s our second task: determine whether each box, on its own, has its
    action figures in order. If any of these boxes has its action figures out of order,
    then we know that the boxes can’t be organized. If all boxes are OK, then we have
    more to check.'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这是我们的第二个任务：判断每个框本身是否将动作人物按顺序排列。如果任何一个框的动作人物顺序不对，那我们就知道这些框不能组织。如果所有框都没有问题，那么我们就有更多的检查任务。
- en: If each box on its own is OK, the next question is whether we can organize all
    of the boxes. One important observation we can make here is that the only action
    figures we care about from now on are the ones at the left and right sides of
    each box. The action figures between these don’t matter anymore.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 如果每个框本身都没问题，接下来的问题是我们是否能组织所有的框。这里一个重要的观察是，从现在起，我们只关心每个框左右两侧的动作人物。框内这些动作人物之间的顺序已经不再重要。
- en: 'Consider this example where we have three boxes:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个例子，我们有三个框：
- en: '[[9, 13, 14, 17, 25],'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '[[9, 13, 14, 17, 25],'
- en: '[32, 33, 34, 36],'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '[32, 33, 34, 36],'
- en: '[1, 6]]'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '[1, 6]]'
- en: The first box starts with an action figure of height 9 and ends with an action
    figure of height 25\. Action figures placed to the left of this box must all have
    height 9 or less; for example, we can place the third box to the left of this
    box. Action figures placed to the right of this box must all have height 25 or
    more; for example, we can place the second box to the right of this box. The action
    figures of heights 13, 14, and 17 change nothing; they may as well not be there.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个盒子以一个高度为9的人物模型开始，以一个高度为25的人物模型结束。放置在此盒子左侧的人物模型必须高度为9或更小；例如，我们可以将第三个盒子放置在此盒子左侧。放置在此盒子右侧的人物模型必须高度为25或更大；例如，我们可以将第二个盒子放置在此盒子右侧。高度为13、14和17的人物模型并不会改变任何事情；它们可以不在这里。
- en: 'That’s our third task then: ignore all action figures except those on the ends
    of boxes.'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 那么这是我们的第三个任务：忽略除了盒子两端的人物模型之外的所有人物模型。
- en: 'Following that third task, we’ll have a list that looks like this:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 紧接着第三个任务，我们将得到一个看起来像这样的列表：
- en: '[[9, 25],'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '[[9, 25]，'
- en: '[32, 36],'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '[32, 36]，'
- en: '[1, 6]]'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '[1, 6]]'
- en: 'It’s a lot easier to tell whether we can organize these boxes if we first sort
    them, like this:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们首先对这些盒子进行排序，就更容易判断我们是否能整理这些盒子，像这样：
- en: '[[1, 6],'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '[[1, 6]，'
- en: '[9, 25],'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '[9, 25]，'
- en: '[32, 36]]'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '[32, 36]]'
- en: Now it’s easy to see what the neighboring boxes of a box must be. (We used a
    similar approach when solving Village Neighborhood in [Chapter 5](ch05.xhtml#ch05).)
    So, our fourth task is to sort the boxes.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，清楚地看到一个盒子的邻近盒子应该是什么样子。（我们在解决[第5章](ch05.xhtml#ch05)中的村庄邻里问题时采用了类似的方法。）因此，我们的第四个任务是排序这些盒子。
- en: 'Our fifth and final task is to determine whether these sorted boxes are organized.
    They are organized if the heights of action figures are sorted from left to right.
    The action figures of heights 1, 6, 9, 25, 32, and 36 are appropriately sorted,
    so the previous boxes can be organized. But consider this example:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第五个也是最后一个任务是确定这些已排序的盒子是否已整理好。如果人物模型的高度从左到右排序，那么这些盒子就是整理好的。高度为1、6、9、25、32和36的人物模型已按适当顺序排序，因此前面的盒子可以整理好。但考虑这个例子：
- en: '[[1, 6],'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '[[1, 6]，'
- en: '[9, 50],'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '[9, 50]，'
- en: '[32, 36]]'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '[32, 36]]'
- en: These boxes can’t be organized because of that huge action figure in the second
    box. That second box takes up heights 9 to 50; the third box can’t go on the right
    of the second box because its heights are too small.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 由于第二个盒子里的那个巨大人物模型，这些盒子无法被整理。第二个盒子占用了高度9到50；第三个盒子不能放在第二个盒子的右边，因为它的高度太小。
- en: 'We’ve now finished working through the problem and have decided on five main
    tasks:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了问题的处理，并决定了五个主要任务：
- en: Read input.
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取输入。
- en: Check whether all boxes are OK.
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查所有盒子是否正常。
- en: Obtain a new list of boxes with only the left and right action figure heights
    from each box.
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取一个仅包含每个盒子左侧和右侧人物模型高度的新盒子列表。
- en: Sort these new boxes.
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对这些新盒子进行排序。
- en: Determine whether these sorted boxes are organized.
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定这些已排序的盒子是否已整理好。
- en: You might wonder why we have a “Read input” task but not a “Write output” task.
    For this problem, writing output involves just outputting YES or NO as needed;
    there won’t be much to it. In addition, we’ll output YES or NO as soon as we know
    the answer, so output will be interleaved with other tasks. For those reasons,
    I’ve decided not to include it as a main task. When working through top-down design
    on your own, don’t worry if you later realize that you’ve left out a task. You
    can just add it and continue with your design.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么我们有“读取输入”任务，却没有“写入输出”任务。对于这个问题，写入输出仅涉及按需输出YES或NO；没有什么复杂的。因此，我们会在知道答案的第一时间输出YES或NO，所以输出会与其他任务交替进行。基于这些原因，我决定不将其作为主要任务。在你独立进行自顶向下设计时，如果你后来意识到漏掉了一个任务，不必担心。你只需要添加它并继续设计即可。
- en: 'Here’s how we can capture our required tasks in code:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们可以在代码中捕捉所需任务的方式：
- en: '❶ # Main Program'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '❶ # 主程序'
- en: '# TODO: Read input'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '# TODO: 读取输入'
- en: '# TODO: Check whether all boxes are OK'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '# TODO: 检查所有盒子是否正常'
- en: '# TODO: Obtain a new list of boxes with only left and right heights'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '# TODO: 获取一个仅包含左侧和右侧高度的新盒子列表'
- en: '# TODO: Sort boxes'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '# TODO: 排序盒子'
- en: '# TODO: Determine whether boxes are organized'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '# TODO: 确定盒子是否已整理好'
- en: I’m calling this the main program ❶. Any functions we write should be included
    in the program before this comment.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 我将其称为主程序❶。我们编写的任何函数都应包含在此注释之前。
- en: Each task is written as just a comment for now. The TODO markings are there
    to highlight that these are tasks for us to convert from English to Python. Once
    we finish a task, we’ll remove its TODO. That way, we’ll be able to track which
    tasks we’ve completed and which we haven’t. Let’s do this!
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 每个任务目前都仅作为注释书写。TODO 标记用于突出显示这些任务，我们需要将其从英语转换为 Python。一旦完成某个任务，我们会移除其 TODO。这样，我们就能追踪哪些任务已完成，哪些还没有。让我们开始吧！
- en: 'Task 1: Read Input'
  id: totrans-454
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '任务 1: 读取输入'
- en: 'We need to read the line containing *n* (the number of boxes) and then read
    the boxes. Reading an integer is something we can do in a single line, so let’s
    read *n* directly. Reading the boxes, on the other hand, is a well-defined task
    that will take a few lines of code, so let’s solve that one with a function; we’ll
    call it read_boxes. Here’s where that leaves us in our main program:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要读取包含 *n*（盒子数量）的那一行，然后读取盒子。读取一个整数可以在一行中完成，所以我们直接读取 *n*。而读取盒子则是一个定义良好的任务，需几行代码来解决，因此我们通过一个函数来实现这个任务；我们将其命名为
    read_boxes。以下是主程序的当前状态：
- en: '# Main Program'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '# 主程序'
- en: '❶ # Read input'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '❶ # 读取输入'
- en: n = int(input())
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: n = int(input())
- en: boxes = read_boxes(n)
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: boxes = read_boxes(n)
- en: '# TODO: Check whether all boxes are OK'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '# TODO: 检查所有盒子是否合格'
- en: '# TODO: Obtain a new list of boxes with only left and right heights'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '# TODO: 获取一个仅包含左右高度的新盒子列表'
- en: '# TODO: Sort boxes'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '# TODO: 对盒子进行排序'
- en: '# TODO: Determine whether boxes are organized'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '# TODO: 确定盒子是否已经组织好'
- en: I’ve removed the TODO from the comment ❶, since from the perspective of the
    main program, we’ve solved that task. We do need to write the read_boxes function,
    of course, so let’s do that now.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 我已从注释 ❶ 中移除了 TODO，因为从主程序的角度来看，我们已经解决了这个任务。当然，我们仍然需要编写 read_boxes 函数，接下来就写这个函数吧。
- en: 'The read_boxes function takes an integer n as a parameter and reads and returns
    n boxes. Here’s the code:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: read_boxes 函数接受一个整数 n 作为参数，并读取并返回 n 个盒子。以下是代码：
- en: 'def read_boxes(n):'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 'def read_boxes(n):'
- en: '"""'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: n is the number of boxes to read.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: n 是要读取的盒子数量。
- en: Read the boxes from the input, and return them as a
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 从输入中读取盒子，并将其作为返回值
- en: list of boxes; each box is a list of action figure heights.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 盒子列表；每个盒子是一个动作人物高度的列表。
- en: '"""'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: boxes = []
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: boxes = []
- en: '❶ for i in range(n):'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '❶ for i in range(n):'
- en: box = input().split()
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: box = input().split()
- en: ❷ box.pop(0)
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ box.pop(0)
- en: 'for i in range(len(box)):'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(len(box)):'
- en: box[i] = int(box[i])
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: box[i] = int(box[i])
- en: boxes.append(box)
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: boxes.append(box)
- en: return boxes
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: return boxes
- en: We’re asked to read n boxes, so we loop n times ❶. On each iteration of this
    loop, we read the current line and split it into its individual action figure
    heights. The line starts with an integer indicating the number of heights in the
    line, so we remove that value from the list (it’s at index 0) before continuing
    ❷. Then we convert each height to an integer and add the current box to the list
    of boxes. Finally, we return the list of boxes.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要读取 n 个盒子，因此我们循环 n 次 ❶。每次循环时，我们读取当前行并将其拆分为各个动作人物的高度。该行以一个整数开始，表示该行中高度的数量，因此在继续之前，我们将该值从列表中删除（它位于索引
    0） ❷。然后，我们将每个高度转换为整数，并将当前盒子添加到盒子列表中。最后，我们返回盒子列表。
- en: 'We didn’t defer any part of read_boxes to some as-yet-written function, so
    we’re done with this task! We’ll include this function, along with other functions
    we write, before the # Main Program comment.'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '我们没有将 read_boxes 的任何部分推迟到尚未编写的函数，因此这个任务完成了！我们会在 # 主程序 注释之前，包括这个函数和我们编写的其他函数。'
- en: 'Task 2: Check Whether All Boxes Are OK'
  id: totrans-482
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '任务 2: 检查所有盒子是否合格'
- en: 'Does each box, on its own, have the action figures going from shortest to tallest?
    Good question, and not one we know how to answer in just a line or two of code.
    Let’s rely on a new function, all_boxes_ok, to tell us. If that function returns
    False, then at least one box has its heights messed up, so we won’t be able to
    organize the boxes. In that case, we should output NO. If all_boxes_ok returns
    True, then we should carry out our remaining tasks to determine whether the boxes
    can be organized. Let’s add this bit of if-else logic to our program, too. Here’s
    what we’ve got:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 每个盒子是否都按从最矮到最高的顺序排列？这是一个好问题，但我们不能通过一两行代码来回答。我们将依赖一个新函数 all_boxes_ok 来告诉我们。如果该函数返回
    False，则至少有一个盒子的高度不正确，因此我们无法组织这些盒子。在这种情况下，我们应该输出 NO。如果 all_boxes_ok 返回 True，则我们应继续进行剩下的任务，以确定这些盒子是否可以组织。让我们在程序中也加入这一段
    if-else 逻辑。以下是我们得到的结果：
- en: '# Main Program'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '# 主程序'
- en: '# Read input'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '# 读取输入'
- en: n = int(input())
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: n = int(input())
- en: boxes = read_boxes(n)
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: boxes = read_boxes(n)
- en: '# Check whether all boxes are OK'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '# 检查所有盒子是否合格'
- en: '❶ if not all_boxes_ok(boxes):'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '❶ if not all_boxes_ok(boxes):'
- en: print('NO')
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: print('NO')
- en: 'else:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: '# TODO: Obtain a new list of boxes with only left and right heights'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: '# TODO: 获取一个只包含左侧和右侧高度的新盒子列表'
- en: '# TODO: Sort boxes'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '# TODO: 对盒子进行排序'
- en: '# TODO: Determine whether boxes are organized'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: '# TODO: 确定盒子是否已排序'
- en: Now we need to write the all_boxes_ok function that we’re calling ❶. We can
    check each box to determine whether it’s in order. If it isn’t, we return False
    right away. If it is in order, then we check the next box. If we check every box
    and they’re all in order, then we return True.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要编写我们正在调用的all_boxes_ok函数❶。我们可以检查每个盒子，判断它是否有序。如果不是，我们立即返回False。如果是有序的，则检查下一个盒子。如果我们检查了每个盒子，它们都按顺序排列，那么返回True。
- en: Aha, so we need to be able to check an individual box! Sounds like another function
    to me. Let’s call that one box_ok.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 啊哈，所以我们需要能够检查一个单独的盒子！听起来像是另一个函数。我们叫它box_ok。
- en: 'Here’s what we have for all_boxes_ok:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们对all_boxes_ok的实现：
- en: 'def all_boxes_ok(boxes):'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 'def all_boxes_ok(boxes):'
- en: '"""'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: boxes is a list of boxes; each box is a list of action figure heights.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: boxes是一个盒子的列表；每个盒子是一个动作人物高度的列表。
- en: Return True if each box in boxes has its action figures in
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 如果boxes中的每个盒子都有按顺序排列的动作人物，则返回True
- en: nondecreasing order of height, False otherwise.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 如果高度是非递减的顺序，返回True，否则返回False。
- en: '"""'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: 'for box in boxes:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 'for box in boxes:'
- en: 'if not box_ok(box):'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 'if not box_ok(box):'
- en: return False
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: return False
- en: return True
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: return True
- en: I’ve used the word nondecreasing in the comment, rather than increasing, because
    heights of action figures are allowed to be equal. For example, the box [4, 4,
    4] is just fine; claiming that this box is “increasing” would be incorrect.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 我在注释中使用了“非递减”而不是“递增”这个词，因为动作人物的高度是允许相等的。例如，盒子[4, 4, 4]是完全可以的；如果声称这个盒子是“递增的”，那就是不正确的。
- en: 'We’ve pushed part of the all_boxes_ok task into box_ok, so let’s write that
    function next. Here goes:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将部分all_boxes_ok任务推给了box_ok，所以接下来编写这个函数。开始：
- en: 'def box_ok(box):'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 'def box_ok(box):'
- en: '"""'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: box is the list of action figure heights in a given box.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: box是给定盒子中动作人物的高度列表。
- en: Return True if the heights in box are in nondecreasing order,
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 如果盒子中的高度是非递减顺序，则返回True，
- en: False otherwise.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 否则返回False。
- en: '"""'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: 'for i in range(len(box)):'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(len(box)):'
- en: 'if box[i] > box[i + 1]:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 'if box[i] > box[i + 1]:'
- en: return False
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: return False
- en: return True
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: return True
- en: If any height is greater than the height to its right, we return False since
    the heights are not in order. If we get past the for loop, then there are no height
    violations, so we return True.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何一个高度大于其右边的高度，我们返回False，因为这些高度不是按顺序排列的。如果通过了for循环，那就说明没有高度违规，返回True。
- en: 'One nice side effect of using top-down design is that we get little chunks
    of code, wrapped up as functions, that we can test in isolation. For example,
    enter the code for box_ok into the Python shell. Then we can test it:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自顶向下设计的一个好处是，我们可以将代码分解成小块，封装成函数，然后可以单独进行测试。例如，输入box_ok的代码到Python shell中。然后我们可以进行测试：
- en: '>>> box_ok([4, 5, 6])'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> box_ok([4, 5, 6])'
- en: 'We’re hoping for True to be returned here, because the box is in order from
    small heights to big heights. We certainly weren’t hoping for what we actually
    get:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望这里返回True，因为盒子从小到大的高度是有序的。我们肯定不希望得到的是我们实际得到的结果：
- en: 'Traceback (most recent call last):'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 'Traceback (most recent call last):'
- en: File "<stdin>", line 1, in <module>
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: File "<stdin>", line 1, in <module>
- en: File "<stdin>", line 9, in box_ok
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: File "<stdin>", line 9, in box_ok
- en: 'IndexError: list index out of range'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 'IndexError: 列表索引超出范围'
- en: 'Errors are never fun, and they’re even less fun when we have to trawl through
    pages and pages of code to find them. But here, we know that the error is localized
    to this little function, so our work to find it is reduced considerably. The problem
    here is that we’ll eventually compare the rightmost height to the height to its
    right—and of course the latter doesn’t exist! So we need to stop one iteration
    earlier, comparing the second-to-last height to the last height. Here’s the updated
    code:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 错误从来不有趣，而且当我们不得不在一页又一页的代码中翻找时，它们就更加不有趣了。但在这里，我们知道错误仅限于这个小函数，所以我们找错误的工作量大大减少。问题在于，我们最终会将最右边的高度与它右边的高度进行比较——当然，后者是不存在的！所以我们需要提前一轮停止，比较倒数第二个高度和最后一个高度。下面是更新后的代码：
- en: 'def box_ok(box):'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 'def box_ok(box):'
- en: '"""'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: box is the list of action figure heights in a given box.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: box是给定盒子中动作人物的高度列表。
- en: Return True if the heights in box are in nondecreasing order,
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 如果盒子中的高度是非递减顺序，则返回True，
- en: False otherwise.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 否则返回False。
- en: '"""'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: '❶ for i in range(len(box) - 1):'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: '❶ for i in range(len(box) - 1):'
- en: 'if box[i] > box[i + 1]:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 'if box[i] > box[i + 1]:'
- en: return False
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: return False
- en: return True
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: return True
- en: The only change is in the call to range ❶. If you test this version of the function,
    you’ll see that it works as required. We’re done with Task 2!
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的变化是在调用 range ❶ 处。如果你测试这个版本的函数，你会看到它按要求工作。任务 2 完成！
- en: 'Task 3: Obtain a New List of Boxes with Only Left and Right Heights'
  id: totrans-540
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 任务 3：获取一个只包含左边和右边高度的新盒子列表
- en: Now we’re getting the hang of top-down design. In this task, we need a way to
    go from boxes with all of their action figures to boxes only with their leftmost
    and rightmost action figures. I’ll refer to the leftmost and rightmost action
    figures as box *endpoints*.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了自顶向下设计的方法。在这个任务中，我们需要一种方法，从包含所有动作人偶的盒子转换成只包含最左边和最右边动作人偶的盒子。我将最左边和最右边的动作人偶称为盒子的
    *端点*。
- en: One approach is to create a new list of boxes with only the endpoints, and that’s
    what I’ll do here. You could also think about actually removing heights from the
    original boxes, though that’s a little trickier.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是创建一个只包含端点的新盒子列表，这也是我这里要做的。你也可以考虑从原始盒子中实际移除高度，尽管那样稍微复杂一些。
- en: 'I’ve called the function for this task boxes_endpoints. Here’s the main part
    of the program, updated with a call to that function:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 我将这个任务的函数命名为 boxes_endpoints。以下是主程序的核心部分，更新后调用了该函数：
- en: Main Program
  id: totrans-544
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主程序
- en: Read input
  id: totrans-545
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取输入
- en: n = int(input())
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: n = int(input())
- en: boxes = read_boxes(n)
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: boxes = read_boxes(n)
- en: Check whether all boxes are OK
  id: totrans-548
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查所有盒子是否都正常
- en: 'if not all_boxes_ok(boxes):'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: '如果所有盒子都没问题（boxes）:'
- en: print('NO')
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: print('NO')
- en: 'else:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 否则：
- en: '# Obtain a new list of boxes with only left and right heights'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: '# 获取一个新的盒子列表，只有左边和右边的高度'
- en: ❶ endpoints = boxes_endpoints(boxes)
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ endpoints = boxes_endpoints(boxes)
- en: '# TODO: Sort boxes'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: '# TODO：排序盒子'
- en: '# TODO: Determine whether boxes are organized'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: '# TODO：确定盒子是否已经组织好'
- en: 'When we call boxes_endpoints with a list of boxes ❶, we expect to get back
    a new list with only the box endpoints. Here’s the boxes_endpoints code that satisfies
    this description:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们用一个盒子列表 ❶ 调用 boxes_endpoints 时，我们期望得到一个只包含盒子端点的新列表。这是满足该描述的 boxes_endpoints
    代码：
- en: 'def boxes_endpoints(boxes):'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: '定义 boxes_endpoints(boxes):'
- en: '"""'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: boxes is a list of boxes; each box is a list of action figure heights.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: boxes 是一个盒子列表；每个盒子是一个动作人偶高度的列表。
- en: 'Return a list, where each value is a list of two values:'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个列表，其中每个值都是一个包含两个值的列表：
- en: the heights of the leftmost and rightmost action figures in a box.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 盒子中最左边和最右边动作人偶的高度。
- en: '"""'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: ❶ endpoints = []
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ endpoints = []
- en: 'for box in boxes:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个 box 在 boxes 中：
- en: ❷ endpoints.append([box[0], box[-1]])
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ endpoints.append([box[0], box[-1]])
- en: return endpoints
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 endpoints
- en: We create a new list ❶ that will hold the endpoints of each box. Then we loop
    through the boxes. For each box, we use indexing to find the leftmost and rightmost
    heights in the box and append them to our endpoints list ❷. Finally, we return
    the endpoints list.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个新列表 ❶，用于存储每个盒子的端点。然后我们遍历这些盒子。对于每个盒子，我们使用索引来查找盒子中的最左边和最右边的高度，并将它们添加到端点列表
    ❷ 中。最后，我们返回端点列表。
- en: 'Wait a sec: what happens if there’s a box with just one action figure in it?
    What will our boxes_endpoints function do with it? According to its docstring,
    it will give us back a list of two values for any valid box. So that had better
    happen here; otherwise, the function isn’t doing what it promises. Let’s test
    it. Enter the boxes_endpoints function into the Python shell, and try it with
    a list of one box with one action figure:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 等一下：如果有一个盒子里面只有一个动作人偶，会发生什么？我们的 boxes_endpoints 函数会怎么处理它？根据它的文档字符串，它会返回一个包含两个值的列表。因此，这里最好也能发生这种情况；否则，函数就没有履行它的承诺。让我们测试一下。输入
    boxes_endpoints 函数到 Python shell，并尝试用一个包含一个动作人偶的盒子列表来测试：
- en: '>>> boxes_endpoints([[2]])'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> boxes_endpoints([[2]])'
- en: '[[2, 2]]'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: '[[2, 2]]'
- en: Success! The leftmost height is 2, and the rightmost height is 2, so we get
    a list with two occurrences of 2. Our function works correctly in this case because
    box[0] and box[-1] both refer to the same value when box has only one value. (Don’t
    worry about the possibility of empty boxes. The problem description prohibits
    them.)
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 成功！最左边的高度是 2，最右边的高度是 2，因此我们得到了一个包含两个 2 的列表。在这种情况下，我们的函数工作正常，因为当盒子只有一个值时，box[0]
    和 box[-1] 都指向相同的值。（不用担心空盒子的可能性，问题描述中已禁止空盒子。）
- en: 'Task 4: Sort Boxes'
  id: totrans-572
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 任务 4：排序盒子
- en: 'At this point, we have a list of endpoints—something like this:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 到此，我们已经有了一个端点列表——类似于这样：
- en: '>>> endpoints = [[9, 25], [32, 36], [1, 6]]'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> endpoints = [[9, 25], [32, 36], [1, 6]]'
- en: '>>> endpoints'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> endpoints'
- en: '[[9, 25], [32, 36], [1, 6]]'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: '[[9, 25], [32, 36], [1, 6]]'
- en: We want to sort them. Do we need another function for this? Some sort of sort_endpoints
    function?
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要对它们进行排序。我们需要另一个函数吗？比如说 sort_endpoints 函数？
- en: 'Not this time! The list sort method does exactly what we need:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 这次不行！列表的排序方法正好符合我们的需求：
- en: '>>> endpoints.sort()'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> endpoints.sort()'
- en: '>>> endpoints'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> endpoints'
- en: '[[1, 6], [9, 25], [32, 36]]'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: '[[1, 6], [9, 25], [32, 36]]'
- en: When called on a list of two-value lists, sort sorts using the first value.
    (If there’s a tie, then it further sorts using the second value.)
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 当对一个包含两个值的列表调用排序时，排序是根据第一个值进行的。（如果第一个值相等，则根据第二个值进一步排序。）
- en: 'We can immediately update the main part of our program with a call to sort
    and knock off one more TODO. Here’s the updated code:'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以立即通过调用排序来更新程序的主程序，解决另一个TODO。更新后的代码如下：
- en: Main Program
  id: totrans-584
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主程序
- en: Read input
  id: totrans-585
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取输入
- en: n = int(input())
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: n = int(input())
- en: boxes = read_boxes(n)
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: boxes = read_boxes(n)
- en: Check whether all boxes are OK
  id: totrans-588
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查所有盒子是否正常
- en: 'if not all_boxes_ok(boxes):'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 not all_boxes_ok(boxes):'
- en: print('NO')
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: print('NO')
- en: 'else:'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 否则：
- en: '# Obtain a new list of boxes with only left and right heights'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: '# 获取一个只包含左侧和右侧高度的新盒子列表'
- en: endpoints = boxes_endpoints(boxes)
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: endpoints = boxes_endpoints(boxes)
- en: '# Sort boxes'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: '# 排序盒子'
- en: endpoints.sort()
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: endpoints.sort()
- en: '# TODO: Determine whether boxes are organized'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: '# TODO: 判断盒子是否有序'
- en: We’re nearly there. Just one TODO to go.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 我们快完成了，只剩下一个TODO。
- en: 'Task 5: Determine Whether Boxes Are Organized'
  id: totrans-598
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 任务 5：判断盒子是否有序
- en: 'Our final task is to check the endpoints. They might be in order, like this:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最终任务是检查端点。它们可能已经有序，如下所示：
- en: '[[1, 6],'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: '[[1, 6],'
- en: '[9, 25],'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: '[9, 25],'
- en: '[32, 36]]'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: '[32, 36]]'
- en: 'Or they might not be, like this:'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 或者它们可能没有按顺序排列，如下所示：
- en: '[[1, 6],'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: '[[1, 6],'
- en: '[9, 50],'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: '[9, 50],'
- en: '[32, 36]]'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: '[32, 36]]'
- en: 'In the former case, we should print YES; in the latter, we should print NO.
    We need a function to tell us whether the endpoints are in order. Updating the
    main part of the program for the final time, we end up with this:'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一种情况下，我们应该打印YES；在后一种情况下，我们应该打印NO。我们需要一个函数来判断端点是否有序。更新程序的主程序部分，最终我们得到如下代码：
- en: Main Program
  id: totrans-608
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主程序
- en: Read input
  id: totrans-609
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取输入
- en: n = int(input())
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: n = int(input())
- en: boxes = read_boxes(n)
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: boxes = read_boxes(n)
- en: Check whether all boxes are OK
  id: totrans-612
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查所有盒子是否正常
- en: 'if not all_boxes_ok(boxes):'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 not all_boxes_ok(boxes):'
- en: print('NO')
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: print('NO')
- en: 'else:'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 否则：
- en: '# Obtain a new list of boxes with only left and right heights'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: '# 获取一个只包含左侧和右侧高度的新盒子列表'
- en: endpoints = boxes_endpoints(boxes)
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: endpoints = boxes_endpoints(boxes)
- en: '# Sort boxes'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: '# 排序盒子'
- en: endpoints.sort()
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: endpoints.sort()
- en: '# Determine whether boxes are organized'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: '# 判断盒子是否有序'
- en: '❶ if all_endpoints_ok(endpoints):'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: '❶ 如果 all_endpoints_ok(endpoints):'
- en: print('YES')
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: print('YES')
- en: 'else:'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 否则：
- en: print('NO')
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: print('NO')
- en: All that stands between us and a complete solution to the problem is that all_endpoints_ok
    function that we’re calling ❶. It takes a list where each value is a list of endpoints
    and returns True if the endpoints are in order and False otherwise.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们和问题的完整解决方案之间，只有一个 `all_endpoints_ok` 函数。它接受一个列表，每个值是一个端点的列表，并且如果端点有序则返回True，否则返回False。
- en: 'Let’s get a feel for how we can implement this function by working through
    an example. Here’s the list of endpoints we’ll use:'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来了解如何实现这个函数。这里是我们将使用的端点列表：
- en: '[[1, 6],'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: '[[1, 6],'
- en: '[9, 25],'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: '[9, 25],'
- en: '[32, 36]]'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: '[32, 36]]'
- en: The first box has a right endpoint of height 6\. So, the second box better have
    a left endpoint of height 6 or more. If it doesn’t, then we return False indicating
    that the endpoints are not in order. But we’re good here, because the second box
    has a left endpoint of height 9.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个盒子的右端点是高度6。那么第二个盒子必须具有高度为6或更高的左端点。如果没有，我们就返回False，表示端点没有按顺序排列。但是这里是没问题的，因为第二个盒子的左端点是高度9。
- en: Now we repeat that check using 25, the right endpoint of the second box. The
    left endpoint of the third box is 32, so we’re good again because 32 is at least
    25.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们用25这个值来重复检查，它是第二个盒子的右端点。第三个盒子的左端点是32，所以我们又可以继续，因为32至少是25。
- en: In general, if the left endpoint of a box is ever less than the right endpoint
    of the previous box, we return False. Otherwise, if all of these checks pass,
    we return True.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，如果某个盒子的左端点小于上一个盒子的右端点，我们就返回False。否则，如果所有的检查都通过，我们就返回True。
- en: 'Here’s the code:'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 这是代码：
- en: 'def all_endpoints_ok(endpoints):'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 'def all_endpoints_ok(endpoints):'
- en: '"""'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: 'endpoints is a list, where each value is a list of two values:'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: endpoints 是一个列表，每个值都是一个包含两个值的列表：
- en: the heights of the leftmost and rightmost action figures in a box.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 盒子中最左边和最右边动作人物的高度。
- en: '❶ Requires: endpoints is sorted by action figure heights.'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 需要：端点按动作人物高度排序。
- en: Return True if the endpoints came from boxes that can be
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 如果端点来自可以
- en: put in order, False otherwise.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 按顺序排列，若未按顺序排列，则返回False。
- en: '"""'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: ❷ maximum = endpoints[0][1]
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ maximum = endpoints[0][1]
- en: 'for i in range(1, len(endpoints)):'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(1, len(endpoints)):'
- en: 'if endpoints[i][0] < maximum:'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 endpoints[i][0] < maximum:'
- en: return False
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 False
- en: ❸ maximum = endpoints[i][1]
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ maximum = endpoints[i][1]
- en: return True
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 True
- en: I’ve added some information to the docstring reminding us what the function
    requires when it’s called ❶. Specifically, we must remember to have the endpoints
    sorted before calling this function. Otherwise, the function could return the
    wrong value.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 我在文档字符串中添加了一些信息，提醒我们调用该函数时需要什么❶。特别是，我们必须记得在调用该函数之前先对 endpoints 进行排序。否则，函数可能返回错误的值。
- en: 'Each value of endpoints is a list with two values: index 0 is the leftmost
    (minimum) height, and index 1 is the rightmost (maximum) height. The code uses
    the maximum variable to track the maximum height of a box. Prior to the for loop,
    it refers to the maximum height in the first box ❷. The for loop compares the
    minimum of the next box to that maximum. If the minimum of the next box is too
    small, we return False, because these two boxes cannot be organized correctly.
    The last thing to do in each iteration is update maximum so that it refers to
    the maximum of the next box ❸.'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: endpoints 的每个值是一个包含两个值的列表：索引 0 是最左边（最小）的身高，索引 1 是最右边（最大）的身高。代码使用 maximum 变量来跟踪盒子的最大身高。在
    for 循环之前，它引用的是第一个盒子的最大身高❷。该循环将下一个盒子的最小身高与最大身高进行比较。如果下一个盒子的最小值过小，则返回 False，因为这两个盒子无法正确排列。每次迭代的最后一步是更新
    maximum，使其引用下一个盒子的最大身高❸。
- en: Putting It All Together
  id: totrans-650
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 综合全部
- en: Having written code for all tasks, including the functions that sprang up as
    part of the design, we’re ready to put it all together into a complete solution.
    It’s up to you whether to keep the comments in the main part of the program. I’ve
    left them in, but in practice this may be a case of over-documenting the code,
    since the function names on their own are chosen to convey what the code is doing.
    See [Listing 6-2](ch06.xhtml#ch06ex02) for the complete code.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成了所有任务的代码编写后，包括作为设计的一部分产生的函数，我们准备将其全部汇总成完整的解决方案。是否保留主程序中的注释由你决定。我保留了它们，但实际上这可能会是过度注释代码的情况，因为函数名本身已经足够传达代码的功能。完整代码请参考
    [Listing 6-2](ch06.xhtml#ch06ex02)。
- en: 'def read_boxes(n):'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 'def read_boxes(n):'
- en: '"""'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: n is the number of boxes to read.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: n 是要读取的盒子数量。
- en: Read the boxes from the input, and return them as a
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 从输入中读取盒子，并以列表的形式返回它们。
- en: list of boxes; each box is a list of action figure heights.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 盒子列表；每个盒子是一个动作人物身高的列表。
- en: '"""'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: boxes = []
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: boxes = []
- en: 'for i in range(n):'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: '对于 i 从 0 到 n - 1:'
- en: box = input().split()
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: box = input().split()
- en: box.pop(0)
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: box.pop(0)
- en: 'for i in range(len(box)):'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: '对于 i 从 0 到 len(box) - 1:'
- en: box[i] = int(box[i])
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: box[i] = int(box[i])
- en: boxes.append(box)
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: boxes.append(box)
- en: return boxes
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 boxes
- en: 'def box_ok(box):'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 'def box_ok(box):'
- en: '"""'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: box is the list of action figure heights in a given box.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: box 是给定盒子中的动作人物身高列表。
- en: Return True if the heights in box are in nondecreasing order,
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 box 中的身高是非递减顺序，则返回 True，
- en: False otherwise.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 否则返回 False。
- en: '"""'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: 'for i in range(len(box) - 1):'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: '对于 i 从 0 到 len(box) - 2:'
- en: 'if box[i] > box[i + 1]:'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 box[i] > box[i + 1]:'
- en: return False
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 False
- en: return True
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 True
- en: 'def all_boxes_ok(boxes):'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 'def all_boxes_ok(boxes):'
- en: '"""'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: boxes is a list of boxes; each box is a list of action figure heights.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: boxes 是一个盒子列表；每个盒子是一个动作人物身高的列表。
- en: Return True if each box in boxes has its action figures in
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 如果每个箱子中的动作人物身高都是按非递减顺序排列的，返回 True。
- en: nondecreasing order of height, False otherwise.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 如果身高按非递减顺序排列，则返回 True，否则返回 False。
- en: '"""'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: 'for box in boxes:'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个箱子中的盒子：
- en: 'if not box_ok(box):'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 box_ok(box) 为 False：
- en: return False
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 False
- en: return True
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 True
- en: 'def boxes_endpoints(boxes):'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 'def boxes_endpoints(boxes):'
- en: '"""'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: boxes is a list of boxes; each box is a list of action figure heights.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: boxes 是一个盒子列表；每个盒子是一个动作人物身高的列表。
- en: 'Return a list, where each value is a list of two values:'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个列表，每个值都是一个包含两个值的列表：
- en: the heights of the leftmost and rightmost action figures in a box.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 盒子中的最左边和最右边的动作人物身高。
- en: '"""'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: endpoints = []
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: endpoints = []
- en: 'for box in boxes:'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个盒子中的盒子：
- en: endpoints.append([box[0], box[-1]])
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: endpoints.append([box[0], box[-1]])
- en: return endpoints
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 endpoints
- en: 'def all_endpoints_ok(endpoints):'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 'def all_endpoints_ok(endpoints):'
- en: '"""'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: 'endpoints is a list, where each value is a list of two values:'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: endpoints 是一个列表，每个值都是一个包含两个值的列表：
- en: the heights of the leftmost and rightmost action figures in a box.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 盒子中的最左边和最右边的动作人物身高。
- en: 'Requires: endpoints is sorted by action figure heights.'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 要求：endpoints 按动作人物身高排序。
- en: Return True if the endpoints came from boxes that can be
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 endpoints 中的每个值来自可以按顺序排列的盒子，返回 True。
- en: put in order, False otherwise.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 排序后返回 True，否则返回 False。
- en: '"""'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: maximum = endpoints[0][1]
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: maximum = endpoints[0][1]
- en: 'for i in range(1, len(endpoints)):'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: '对于 i 从 1 到 len(endpoints) - 1:'
- en: 'if endpoints[i][0] < maximum:'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 endpoints[i][0] < maximum:'
- en: return False
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 False
- en: maximum = endpoints[i][1]
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: maximum = endpoints[i][1]
- en: return True
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 True
- en: Main Program
  id: totrans-710
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主程序
- en: Read input
  id: totrans-711
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取输入
- en: n = int(input())
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: n = int(input())
- en: boxes = read_boxes(n)
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: boxes = read_boxes(n)
- en: Check whether all boxes are OK
  id: totrans-714
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查所有盒子是否都 OK
- en: 'if not all_boxes_ok(boxes):'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 not all_boxes_ok(boxes):'
- en: print('NO')
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 打印('NO')
- en: 'else:'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 否则：
- en: '# Obtain a new list of boxes with only left and right heights'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: '# 获取一个新的只包含左右高度的盒子列表'
- en: endpoints = boxes_endpoints(boxes)
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: endpoints = boxes_endpoints(boxes)
- en: '# Sort boxes'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: '# 对盒子进行排序'
- en: endpoints.sort()
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: endpoints.sort()
- en: '# Determine whether boxes are organized'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: '# 判断盒子是否已整理好'
- en: 'if all_endpoints_ok(endpoints):'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 all_endpoints_ok(endpoints)：
- en: print('YES')
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 打印('YES')
- en: 'else:'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 否则：
- en: print('NO')
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 打印('NO')
- en: '*Listing 6-2: Solving Action Figures*'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-2：解决动作人物问题*'
- en: 'This is the largest program that we’ve written to this point in the book. But
    look how tidy and minimal the main part of the program is: it’s mostly calls to
    functions, with a little bit of if-else logic to glue them together.'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 这是到目前为止我们在书中编写的最大程序。但看看程序的主体是多么简洁：它主要是函数调用，只有少量的 if-else 逻辑将它们串联起来。
- en: We’re calling each function only once here. Compare that to the no_high Card
    Game function that we called four times. Even if a function is called only once,
    it still contributes to organized, readable code.
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这里每个函数只调用了一次。对比一下我们在 no_high Card Game 函数中调用了四次的情况。即使一个函数只调用一次，它依然有助于使代码更具组织性和可读性。
- en: Time to submit to the Timus judge. You should see that all test cases pass.
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 该提交是时候提交给 Timus 评测系统了。你应该能看到所有的测试用例都通过了。
- en: '**CONCEPT CHECK**'
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念检查**'
- en: In Task 2, we wrote function box_ok for determining whether a single box has
    its heights in order. It uses a range for loop. Is the following while loop version
    of box_ok correct?
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 在任务 2 中，我们编写了函数 box_ok 来判断一个盒子的高度是否按顺序排列。它使用了 range for 循环。以下的 while 循环版本的 box_ok
    正确吗？
- en: 'def box_ok(box):'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 'def box_ok(box):'
- en: '"""'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: box is the list of action figure heights in a given box.
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: box 是一个包含给定盒子中动作人物高度的列表。
- en: Return True if the heights in box are in nondecreasing order,
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 box 中的高度是非递减顺序，则返回 True，
- en: False otherwise.
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 否则返回 False。
- en: '"""'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: ok = True
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: ok = True
- en: i = 0
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: i = 0
- en: 'while i < len(box) - 1 and ok:'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 当 i < len(box) - 1 且 ok 为真时：
- en: 'if box[i] > box[i + 1]:'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 box[i] > box[i + 1]：
- en: ok = False
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: ok = False
- en: i = i + 1
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: i = i + 1
- en: return ok
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 ok
- en: A. Yes
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: A. 是的
- en: B. No; it can cause an IndexError
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: B. 否；它可能会导致 IndexError
- en: C. No; it doesn’t cause any errors, but it can return the wrong value
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: C. 否；它不会引发错误，但可能返回错误的值
- en: 'Answer: A. This is equivalent to our earlier version using the range for loop.
    The ok variable starts off as True, meaning that all heights we have checked are
    fine (because we haven’t checked any yet!). The while loop continues as long'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：A。这与我们之前使用 range for 循环的版本等价。ok 变量最开始为 True，意味着我们检查过的所有高度都是正常的（因为我们还没有检查任何一个！）。只要符合条件，while
    循环就会继续进行。
- en: as there are more boxes to check and there are no height violations. If an action
    figure is out of order, ok is set to False, which terminates the loop. If all
    action figures are in order, then the value of ok never changes from True to False.
    Therefore, when we return ok at the bottom of the function, we return True if
    all action figures are in order and False if not.
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 因为有更多的盒子需要检查，并且没有高度违反规则。如果某个动作人物的高度不符合顺序，则 ok 被设置为 False，从而终止循环。如果所有动作人物的高度都符合顺序，那么
    ok 的值从不会从 True 改变为 False。因此，当我们在函数底部返回 ok 时，如果所有动作人物的高度都符合顺序，就返回 True，否则返回 False。
- en: Summary
  id: totrans-751
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned about functions. A function is a self-contained
    block of code that solves a small part of a larger problem. We learned how to
    pass information to a function (through arguments) and get information back (through
    a return value).
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了函数的概念。函数是一个自包含的代码块，用来解决更大问题中的一个小部分。我们学习了如何向函数传递信息（通过参数）并获取信息（通过返回值）。
- en: To determine which functions to write in the first place, we can use top-down
    design. Top-down design helps us break a solution to a large problem into a number
    of smaller tasks; for each task, we solve it directly if we can or write a function
    for it if we can’t. If a given task is too unwieldy, we can perform further top-down
    design on it.
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定首先需要编写哪些函数，我们可以使用自顶向下设计。自顶向下设计帮助我们将一个大问题的解决方案分解为多个小任务；对于每个任务，如果能直接解决就直接解决，如果不能，则为其编写函数。如果一个任务太复杂，我们可以对其进行进一步的自顶向下设计。
- en: In the next chapter, we’ll learn how to work with files of our choosing, rather
    than using standard input and standard output. As we continue to push the boundaries
    of what we know, we’ll find many uses for functions in that chapter and the rest
    of the book. Practice with some of the following exercises to increase your confidence
    using functions.
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用我们选择的文件，而不是使用标准输入和标准输出。随着我们不断拓宽知识的边界，我们将在那一章和本书的其余部分发现许多函数的应用。通过练习以下一些习题，来增强你使用函数的信心。
- en: Chapter Exercises
  id: totrans-755
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 章节练习
- en: Here are some exercises for you to try. For each, use top-down design to identify
    one or more functions that help you organize your code. Include a docstring in
    each function!
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些习题供你尝试。对于每个习题，使用自顶向下设计来识别一个或多个函数，帮助你组织代码。每个函数都要包括一个文档字符串！
- en: DMOJ problem ccc13s1, From 1987 to 2013
  id: totrans-757
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ 问题 ccc13s1，从1987年到2013年
- en: DMOJ problem ccc18j3, Are we there yet?
  id: totrans-758
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ 问题 ccc18j3，我们到了吗？
- en: DMOJ problem ecoo12r1p2, Decoding DNA
  id: totrans-759
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ 问题 ecoo12r1p2，解码 DNA
- en: DMOJ problem crci07p1, Platforme
  id: totrans-760
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ 问题 crci07p1，平台
- en: DMOJ problem coci13c2p2, Misa
  id: totrans-761
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ 问题 coci13c2p2，Misa
- en: Revisit some of the exercises from [Chapter 5](ch05.xhtml#ch05) and improve
    your solutions by using functions. I particularly suggest revisiting DMOJ problem
    coci18c2p1 (Preokret) and DMOJ problem ccc00s2 (Babbling Brooks).
  id: totrans-762
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新访问[第5章](ch05.xhtml#ch05)的一些习题，并通过使用函数来改进你的解决方案。我特别建议重新访问 DMOJ 问题 coci18c2p1（Preokret）和
    DMOJ 问题 ccc00s2（喋喋不休的小溪）。
- en: Notes
  id: totrans-763
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释
- en: Card Game is originally from the 1999 Canadian Computing Competition. Action
    Figures is originally from the 2019 Ural School Programming Contest.
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 卡片游戏最初来源于1999年加拿大计算机竞赛。动作人物最初来源于2019年乌拉尔学校编程竞赛。
- en: Many modern programming languages, Python included, support two distinct programming
    paradigms. One is based on functions; that’s what we studied in this chapter.
    The other is based on *objects* and leads to a paradigm known as *object-oriented
    programming (OOP)*. OOP involves defining new types and writing methods for those
    types. We use Python types (such as integers and strings) throughout the book,
    but we won’t otherwise discuss OOP. For an introduction to OOP, and case studies
    of OOP in practice, I recommend *Python Crash Course*, 2nd edition by Eric Matthes
    (No Starch Press, 2019).
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 许多现代编程语言，包括 Python，都支持两种不同的编程范式。一种是基于函数的；这就是我们在本章中学习的内容。另一种是基于*对象*的，并且引出了一个叫做*面向对象编程（OOP）*的范式。OOP
    涉及定义新类型并为这些类型编写方法。在本书中，我们将使用 Python 类型（例如整数和字符串），但不会进一步讨论 OOP。若想了解 OOP 的入门知识以及
    OOP 在实践中的案例研究，我推荐 Eric Matthes 编写的《*Python Crash Course*》第二版（No Starch Press,
    2019）。
