- en: '7'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '7'
- en: READING AND WRITING FILES
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 读取和写入文件
- en: '![image](Images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/common.jpg)'
- en: To this point, we’ve read all input using the `input` function and written all
    output using the `print` function. These functions read from standard input (defaulting
    to the keyboard) and write to standard output (defaulting to the screen), respectively.
    While we can change these defaults using input and output redirection, sometimes
    a program needs more control over its files. For example, your word processor
    allows you to open whichever document file you like and save a file with whatever
    name you like, without you messing around with standard input and standard output.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用`input`函数读取所有输入，并使用`print`函数输出所有结果。这些函数分别从标准输入（默认为键盘）读取，并将结果写入标准输出（默认为屏幕）。尽管我们可以通过输入和输出重定向改变这些默认值，但有时程序需要更好地控制文件。例如，你的文字处理器允许你打开任何文档文件并保存任何你喜欢的文件，而无需处理标准输入和标准输出。
- en: 'In this chapter, we’ll learn how to write programs that manipulate text files.
    We’ll solve two problems using files: correctly formatting an essay and seeding
    a farm to feed cows.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将学习如何编写处理文本文件的程序。我们将通过文件解决两个问题：正确格式化文章和播种农场以喂养奶牛。
- en: 'Problem #16: Essay Formatting'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '问题 #16：文章格式化'
- en: 'There’s one important difference between this problem and all the problems
    we’ve solved to this point: this one requires us to read from and write to specific
    files! Look out for this as you read the problem description.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本问题与我们之前解决的所有问题有一个重要区别：这个问题要求我们从特定的文件中读取并写入数据！在阅读问题描述时要特别注意这一点。
- en: This is USACO 2020 January Bronze Contest problem Word Processor. This is the
    first problem in the book from the USACO (USA Computing Olympiad) judge. To find
    the problem, go to *[http://usaco.org/](http://usaco.org/)*, click **Contests**,
    click **2020 January Contest Results**, and then click **View problem** under
    Word Processor.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这是USACO 2020年1月青铜组比赛问题《文字处理器》。这是USACO（美国计算机奥林匹克）评委书中的第一个问题。要查看该问题，请访问*[http://usaco.org/](http://usaco.org/)*，点击**Contests**，点击**2020
    January Contest Results**，然后点击**View problem**下的《文字处理器》。
- en: The Challenge
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战
- en: 'Bessie the cow is writing an essay. Each word in the essay contains only lowercase
    or uppercase characters. Her teacher has specified the maximum number of characters,
    not counting spaces, that can occur per line. To satisfy this requirement, Bessie
    writes down the words of the essay using the following rules:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 贝西（Bessie）奶牛正在写一篇文章。文章中的每个单词仅包含小写字母或大写字母。她的老师规定了每行的最大字符数（不包括空格）。为了满足这一要求，贝西使用以下规则写下文章中的单词：
- en: If the next word fits on the current line, add it to the current line. Include
    a space between each pair of words on the line.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果下一个单词适合当前行，则将其添加到当前行。在每对单词之间包括一个空格。
- en: Otherwise, put this word on a new line; this line becomes the new current line.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，将该单词放到新的一行；这一行成为新的当前行。
- en: Output the essay with the correct words on each line.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 输出文章，并确保每行包含正确的单词。
- en: Input
  id: totrans-13
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输入
- en: Read input from the file named *word.in*.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 从名为*word.in*的文件中读取输入。
- en: The input consists of two lines.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 输入由两行组成。
- en: The first line contains two integers separated by a space. The first integer
    is *n*, the number of words in the essay; it’s between 1 and 100\. The second
    integer is *k*, the maximum number of characters (not counting spaces) that can
    occur per line; it’s between 1 and 80.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一行包含两个由空格分隔的整数。第一个整数是*n*，文章中的单词数；它介于1和100之间。第二个整数是*k*，每行允许的最大字符数（不包括空格）；它介于1和80之间。
- en: The second line contains *n* words, with a space between each pair of words.
    Each word has at most *k* characters.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二行包含*n*个单词，每对单词之间有一个空格。每个单词最多有*k*个字符。
- en: Output
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输出
- en: Write output to the file named *word.out*.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 将输出写入名为*word.out*的文件中。
- en: Output the properly formatted essay.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 输出格式化正确的文章。
- en: Working with Files
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与文件打交道
- en: The Essay Formatting problem requires that we read from file *word.in* and write
    to file *word.out*. Before we can do those things, though, we need to learn how
    to open files in our programs.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 《文章格式化》问题要求我们从文件*word.in*中读取，并写入文件*word.out*。但是，在进行这些操作之前，我们需要学习如何在程序中打开文件。
- en: Opening a File
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 打开文件
- en: Using your text editor, create a new file called *word.in*. Put that file in
    the same directory that you’ve been using for your *.py* Python programs.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你的文本编辑器创建一个名为*word.in*的新文件。将该文件放在与*.py* Python程序相同的目录中。
- en: This is the first time that we’re creating a file that doesn’t end with *.py*.
    Instead, it ends with *.in*. Be sure to name the file *word.in*, not *word.py*.
    The *in* is short for input; you’ll see it used often for files that contain input
    for a program.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们第一次创建一个不以*.py*结尾的文件。相反，它以*.in*结尾。确保将文件命名为*word.in*，而不是*word.py*。*in*是“输入”的缩写，你将经常看到它用于包含程序输入的文件。
- en: 'In that file, let’s place valid input for the Essay Formatting problem. Enter
    the following into the file:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，让我们为“论文格式化”问题放入有效的输入。将以下内容输入文件中：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Save the file.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件。
- en: 'To open the file in Python, we use the `open` function. We pass two arguments:
    the first is the filename, and the second is the mode in which to open the file.
    The mode determines how we can interact with the file.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Python中打开文件，我们使用`open`函数。我们传递两个参数：第一个是文件名，第二个是打开文件的模式。模式决定了我们如何与文件进行交互。
- en: 'Here’s how we can open *word.in*:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们如何打开*word.in*：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this function call, we’ve provided a mode of `'r'`. The `r` stands for “read”
    and opens the file so that we can read from it. The mode happens to be an optional
    parameter whose default is `'r'`, so we can leave it out if we like. But I’ll
    explicitly include the `'r'` throughout the book for consistency.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数调用中，我们提供了一个模式`'r'`。`r`代表“读取”，并以此模式打开文件，供我们从中读取。模式是一个可选的参数，其默认值为`'r'`，所以我们可以选择省略它。但为了保持一致性，我将在全书中明确地包括`'r'`。
- en: When we use `open`, Python gives us some information about how the file was
    opened ❶. For example, it confirms the filename and mode. The bit about `encoding`
    indicates how the file was decoded from its state on disk into a form that we
    can read. Files can be encoded using a variety of encodings, but we don’t need
    to worry about encodings in this book.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`open`时，Python会给我们一些关于文件如何打开的信息❶。例如，它会确认文件名和模式。关于`encoding`的部分表示文件是如何从磁盘上的状态解码成我们可以读取的形式。文件可以使用多种编码方式进行编码，但在本书中我们不需要担心编码问题。
- en: 'If we try to open a file for reading that doesn’t exist, we get an error:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试打开一个不存在的文件进行读取，就会出现错误：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you’re getting this error when opening *word.in*, double-check that the file
    is named correctly and in the directory from which you started Python.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在打开*word.in*时遇到此错误，请仔细检查文件是否正确命名，并且位于你启动Python时的目录中。
- en: In addition to mode `'r'` for reading, there’s mode `'w'` for writing. If we
    use `'w'`, then we’re opening a file so that we can put text in it.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 除了用于读取的模式`'r'`，还有用于写入的模式`'w'`。如果我们使用`'w'`，那么我们就是在打开一个文件以便往其中写入文本。
- en: Be careful with mode `'w'`. If you use `'w'` with a file that already exists,
    the contents of that file will be deleted. I just accidentally did that with my
    *word.in* file. No big deal, because it was easy to re-create. But no one would
    be happy if we accidentally overwrote an important file.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 小心使用模式`'w'`。如果你用`'w'`打开一个已经存在的文件，该文件的内容将被删除。我刚刚不小心在我的*word.in*文件上做了这件事。没关系，因为重新创建它很容易。但如果我们不小心覆盖了一个重要文件，没人会开心。
- en: If you use `'w'` with a filename that doesn’t exist, it creates an empty file.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用`'w'`打开一个不存在的文件，它会创建一个空文件。
- en: 'Let’s use mode `''w''` to create an empty file called *blah.in*:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用模式`'w'`来创建一个名为*blah.in*的空文件：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now that *blah.in* exists, we can open it for reading without getting an error:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在*blah.in*已存在，我们可以打开它进行读取而不会出错：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'What’s that `_io.TextIOWrapper` that we keep seeing? That’s the type of the
    value that `open` returns:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 那个我们一直看到的`_io.TextIOWrapper`是什么？那是`open`返回的值的类型：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Think of this type as a file type. Its values represent open files, and you’ll
    see shortly that it has methods that we can call.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 把这个类型想象成文件类型。它的值表示打开的文件，而且你很快就会看到它有我们可以调用的方法。
- en: As with any function, if we don’t assign what `open` returns to a variable,
    then its return value is lost. The way we’ve been calling `open` so far doesn’t
    give us any way to refer to the file that we’ve opened!
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 和任何函数一样，如果我们不将`open`返回的内容赋值给一个变量，那么它的返回值就会丢失。到目前为止，我们调用`open`的方式并没有提供任何方式来引用我们打开的文件！
- en: 'Here’s how we can make a variable refer to an open file:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们如何让一个变量指向一个已打开的文件：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We’ll be able to use `input_file` to read from `'word.in'`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将能够使用`input_file`从`'word.in'`中读取数据。
- en: 'When solving Essay Formatting, we’ll also need a way to write to file `''word.out''`.
    Here’s a variable that will help us do that:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决论文格式化问题时，我们还需要一种方法来写入文件`'word.out'`。下面是一个有助于我们做到这一点的变量：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Reading from a File
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从文件中读取
- en: To read a line from an open file, we use the file’s `readline` method. That
    method returns a string containing the contents of the next line of the file.
    In that way, it’s similar to the `input` function. Unlike `input`, however, `readline`
    reads from a file rather than from standard input.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要从打开的文件中读取一行，我们使用文件的`readline`方法。该方法返回一个包含文件下一行内容的字符串。这样，它类似于`input`函数。然而，与`input`不同的是，`readline`是从文件中读取，而不是从标准输入中读取。
- en: 'Let’s open *word.in* and read its two lines:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开*word.in*并读取其中的两行：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'What’s unexpected here is the `\n` at the end of each string. We certainly
    didn’t see that when using `input` to read a line. The `\` symbol in a string
    is an *escape character*. It escapes from the standard interpretation of characters
    and changes their meaning. We don’t treat `\n` as the two separate characters
    `\` and `n`. Instead, `\n` is just one character: a newline character. All lines
    in a file, perhaps except for the last, end with a newline character. If they
    didn’t, then everything would be on a single line! The `readline` method is literally
    giving us the entire line, including its terminating newline character.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的意外之处在于每个字符串末尾的`\n`。当我们使用`input`读取一行时，显然没有看到这个符号。字符串中的`\`符号是一个*转义字符*。它从字符的标准解释中跳脱出来，改变它们的含义。我们并不将`\n`视为两个独立的字符`\`和`n`。相反，`\n`是一个字符：换行符。文件中的所有行（可能除了最后一行）都以换行符结尾。如果没有换行符，那么所有内容都会显示在同一行！`readline`方法实际上返回了整个行，包括它的结束换行符。
- en: 'Here’s how we can embed newlines in our own strings:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何在自己的字符串中嵌入换行符：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The Python shell doesn’t process the effects of escape characters, but `print`
    does.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Python shell 不处理转义字符的效果，但`print`会处理。
- en: 'The `\n` sequence is useful in strings because it helps us add multiple lines.
    But we rarely want those newlines in the lines that we read from files. To get
    rid of them, we can use the string `rstrip` method. This method is like `strip`
    except that it removes whitespace only from the right of a string (not the left).
    As far as it’s concerned, newlines are whitespace just like spaces:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`\n`序列在字符串中很有用，因为它帮助我们添加多行。但我们很少希望在从文件读取的行中出现这些换行符。为了去除它们，我们可以使用字符串的`rstrip`方法。这个方法类似于`strip`，不过它只删除字符串右侧的空白字符（而不是左侧）。在它看来，换行符就像空格一样，都是空白字符：'
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let’s try reading from the file again, this time stripping out the newlines:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再试着从文件中读取，这次去掉换行符：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: At this point, we’ve read the two lines, so there’s nothing left to read from
    the file. The `readline` method signals this by returning an empty string.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我们已经读取了两行，所以文件中没有剩余的内容可读。`readline`方法通过返回一个空字符串来表示这一点。
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The empty string means that we’ve reached the end of the file. If we want to
    read the lines again, we must reopen the file to start at its beginning.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 空字符串意味着我们已经到达了文件末尾。如果我们想再次读取这些行，我们必须重新打开文件，从头开始。
- en: 'Let’s do that, this time saving each line using variables:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们这么做，这次使用变量保存每一行：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If we need to read all of the lines from a file, no matter how many there are,
    we can use a `for` loop. Files in Python act as sequences of lines, so we can
    loop over them just like we loop over strings and lists:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要读取文件中的所有行，不论有多少行，我们可以使用`for`循环。Python中的文件就像行的序列，因此我们可以像遍历字符串和列表一样遍历文件：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Unlike a string or loop, though, we can’t loop over the file a second time,
    because the first one takes us to its end. If we try, we get nothing:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与字符串或循环不同的是，我们不能第二次循环读取文件，因为第一次循环已经把文件读取到了末尾。如果我们尝试这样做，就什么也得不到：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '**CONCEPT CHECK**'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念检查**'
- en: We want to use a `while` loop to output each line of the open file `input_file`.
    (The file could be any file; I’m not assuming that it’s related to Essay Formatting.)
    Which of the following pieces of code correctly does this?
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要使用`while`循环输出打开的文件`input_file`中的每一行。（该文件可以是任何文件；我并不假设它与论文格式化有关。）下面哪段代码正确地完成了这项任务？
- en: A.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: A.
- en: 'while input_file.readline() != '''':'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 'while input_file.readline() != '''':'
- en: print(input_file.readline().rstrip())
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: print(input_file.readline().rstrip())
- en: B.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: B.
- en: line = 'x'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: line = 'x'
- en: 'while line != '''':'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 'while line != '''':'
- en: line = input_file.readline()
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: line = input_file.readline()
- en: print(line.rstrip())
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: print(line.rstrip())
- en: C.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: C.
- en: line = input_file.readline()
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: line = input_file.readline()
- en: 'while line != '''':'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 'while line != '''':'
- en: line = input_file.readline()
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: line = input_file.readline()
- en: print(line.rstrip())
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: print(line.rstrip())
- en: D. All of the above
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: D. 以上所有
- en: E. None of the above
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: E. 以上都不是
- en: Before looking at the answer, I encourage you to create a file with four or
    five lines in it and try each piece of code on the file. You might also consider
    adding a character like `*` to the beginning of each line that’s output so that
    you can see any otherwise blank lines.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看答案之前，我建议你创建一个包含四五行文本的文件，并在文件上尝试每一段代码。你还可以考虑在每一行输出的开头添加一个字符，比如`*`，这样你就能看到任何原本为空的行。
- en: 'Answer: E. Each piece of code has a subtle error.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：E。每一段代码都有一个微妙的错误。
- en: Code A outputs only every other line of the file. For example, the `while` loop’s
    Boolean expression causes the first line to be read . . . and lost, because it
    isn’t assigned to a variable. The first iteration of the loop therefore outputs
    the second line of the file.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 代码A只输出文件中的每隔一行。例如，`while`循环的布尔表达式导致第一行被读取……并丢失，因为它没有被赋值给变量。因此，循环的第一次迭代输出的是文件的第二行。
- en: Code B comes very close to doing the right thing. It outputs all the lines of
    the file, but also outputs an extraneous blank line at the end.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 代码B非常接近正确的做法。它输出了文件的所有行，但在末尾多输出了一个空白行。
- en: Code C fails to print the first line of the file. That’s because the first line
    is read before the loop, but then the loop reads the second line without having
    printed the first. It also produces an extraneous blank line at the end, just
    like code B.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 代码C未能打印文件的第一行。这是因为第一行在循环前就已被读取，但之后循环读取了第二行，且没有打印第一行。它同样在末尾产生了多余的空白行，就像代码B一样。
- en: 'Here’s correct code to read and print each line:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这是正确的代码，用来读取并打印每一行：
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Writing to a File
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 写入文件
- en: To write a line to an open file, we use the file’s `write` method. We pass it
    a string, and that string is added to the end of the file.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要向一个打开的文件写入一行，我们使用文件的`write`方法。我们传递给它一个字符串，这个字符串会被添加到文件的末尾。
- en: 'To solve Essay Formatting, we’ll write to *word.out*. We’re not ready to solve
    that problem yet, so let’s instead write to *blah.out*. Here’s how we can write
    one line to that file:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决作文格式化问题，我们将写入*word.out*。但我们还没有准备好解决这个问题，所以我们暂时写入*blah.out*。以下是我们如何向该文件写入一行：
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: What’s that `5` doing there? The `write` method returns the number of characters
    written. It’s good confirmation that we’ve written the quantity of text that we
    expected to write.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 那个`5`在那里干什么？`write`方法返回的是写入的字符数。这是一个很好的确认，表示我们已经写入了预期的文本数量。
- en: If you open *blah.out* in your text editor, you should see the text `hello`
    in there.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在文本编辑器中打开*blah.out*，你应该看到文件中有`hello`这个文本。
- en: 'Let’s try writing three lines to the file. Here goes:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试向文件写入三行。开始吧：
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Based on what I’ve told you so far, you might expect *blah.out* to look like
    this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我到目前为止告诉你的内容，你可能会期望*blah.out*看起来像这样：
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'But if you open *blah.out* in your text editor, you should instead see the
    following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果你在文本编辑器中打开*blah.out*，你应该看到如下内容：
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The characters are on a single line like that because `write` doesn’t add newlines
    for us! If we want separate lines, we need to be explicit, like this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 字符之所以显示在同一行，是因为`write`方法不会为我们自动添加换行符！如果我们想要单独的行，我们需要明确指定，就像这样：
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Notice in each case that `write` writes three characters, not two. The newline
    counts as a character. Now if you open *blah.out* in your text editor, you should
    see the text spread across three lines:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在每种情况下，`write`方法写入的是三个字符，而不是两个。换行符也算作一个字符。现在，如果你在文本编辑器中打开*blah.out*，你应该看到文本分布在三行中：
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Unlike `print`, `write` works only if you call it with a string. To write a
    number to a file, convert it to a string first:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 与`print`不同，`write`只有在你用字符串调用它时才有效。要向文件写入数字，首先需要将其转换为字符串：
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Closing Files
  id: totrans-116
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 关闭文件
- en: It’s good practice to close a file once you’re done with it. It signals to readers
    of your code that the file is no longer being used.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成文件操作后关闭文件是一个好习惯。这向阅读你代码的人表明，文件不再被使用。
- en: Closing files also helps your operating system manage your computer’s resources.
    When you use the `write` method, what you write may not end up in the file immediately.
    Rather, Python or your operating system might wait until it has a bunch of `write`
    requests and then write them all at once. Closing a file that you wrote to guarantees
    that what you wrote to the file is safely stored in the file.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭文件还可以帮助操作系统管理计算机的资源。当你使用`write`方法时，你写入的内容可能不会立即写入文件。相反，Python或者操作系统可能会等到有多个`write`请求时，再将它们一次性写入。关闭你写入的文件可以确保你写入的内容已安全地存储在文件中。
- en: 'To close a file, call its `close` method. Here’s an example of opening a file,
    reading a line, and closing it:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要关闭文件，调用其`close`方法。以下是打开文件、读取一行并关闭文件的示例：
- en: '[PRE24]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Once you’ve closed a file, you can no longer read from or write to the file:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你关闭了文件，就不能再从该文件读取或写入：
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Solving the Problem
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决问题
- en: Back to Essay Formatting. Now we know how to read from *word.in* and write to
    *word.out*. That takes care of the input and output requirements. It’s time to
    tackle the problem itself.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 回到文章格式化问题。现在我们知道如何从*word.in*读取并写入到*word.out*。这样就完成了输入输出要求。接下来是解决问题本身。
- en: Let’s start by exploring a test case to make sure we know how to solve this
    problem. Then we’ll see the code.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先通过探索一个测试用例来确保我们知道如何解决这个问题。然后我们会看到代码。
- en: Exploring a Test Case
  id: totrans-126
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 探索一个测试用例
- en: 'Here’s the *word.in* file I’ve been using:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我一直在使用的*word.in*文件：
- en: '[PRE26]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: There are 12 words, and the maximum number of characters on a line (not counting
    spaces) is 13\. We should add words to the current line as long as they fit; once
    a word doesn’t fit, we’ll start a new line with that word.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 共有12个单词，每行最大字符数（不包括空格）是13个。只要单词能放下，我们就将它添加到当前行；一旦单词放不下，我们就用这个单词开始新的一行。
- en: The word `perhaps` contains seven characters, so it fits on the first line.
    The word `better` contains six characters. We can put that on the first line,
    too; with `perhaps` already there, we’re at a total of 13 characters (not including
    the space between the two words).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 单词`perhaps`包含七个字符，因此可以放在第一行。单词`better`包含六个字符。我们也可以把它放在第一行；由于`perhaps`已经在那，两个单词加起来总共有13个字符（不包括单词间的空格）。
- en: The word `poetry` can’t go on the first line, so we start a new line with `poetry`
    as its first word. The word `will` fits next to `poetry` on the second line. Similarly,
    `be` fits next to `will`. We’re at 12 nonspace characters so far. Now we have
    the word `written`, and with only one character of room on line 2, we’re forced
    to start the next line with `written` as its first word.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 单词`poetry`不能放在第一行，所以我们以`poetry`作为第一单词开始新的一行。接着，单词`will`适合放在第二行与`poetry`并排。类似地，`be`可以放在`will`后面。到目前为止，我们已经有了12个非空格字符。现在我们有了单词`written`，由于第二行只剩下一个字符的空间，我们只能在新的一行开始时把`written`作为第一个单词。
- en: 'Following this process to the end, the full essay that we need to write to
    *word.out* is this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 按照这个过程继续直到结束，我们需要写入*word.out*的完整文章是：
- en: '[PRE27]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The Code
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 代码
- en: Our solution is in [Listing 7-1](ch07.xhtml#ch07ex01).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的解决方案在[清单 7-1](ch07.xhtml#ch07ex01)中。
- en: '[PRE28]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*Listing 7-1: Solving Essay Formatting*'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-1: 解决文章格式化问题*'
- en: 'To begin, we open the input file ❶ and output file ❷. Notice the modes: we
    open the input file with mode `''r''` (for reading) and open the output file with
    mode `''w''` (for writing). We could have opened the output file a little later,
    right before we use it, but I’ve chosen to open both files here to simplify the
    organization of the program. Similarly, we could close a file as soon as we no
    longer need it, but in this book, I’ve chosen to close all files together at the
    end of the program. For long-running programs that manipulate many files, you
    likely want to keep files open only when needed.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们打开输入文件❶和输出文件❷。注意文件模式：我们用模式`'r'`（读取模式）打开输入文件，用模式`'w'`（写入模式）打开输出文件。我们本可以稍后再打开输出文件，在需要使用它之前，但为了简化程序结构，我选择在这里同时打开两个文件。同样，我们本可以在不再需要文件时立刻关闭它，但在本书中，我选择在程序的最后一起关闭所有文件。对于操作多个文件的长时间运行程序，你可能希望只在需要时才保持文件打开。
- en: 'Next, we read the first line of the input file ❸. This line contains two space-separated
    integers: `n`, the number of words, and `k`, the maximum number of allowed characters
    (not counting spaces) per line. As always with space-separated values, we use
    `split` to separate them. We then read the second line, which contains the essay
    words. Again we use `split`, this time to split the string of words into a list
    of words. That takes care of the input.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们读取输入文件的第一行❸。这一行包含两个用空格分隔的整数：`n`，单词的数量，以及`k`，每行允许的最大字符数（不包括空格）。像处理空格分隔的值一样，我们使用`split`来分割它们。然后我们读取第二行，它包含文章的单词。我们同样使用`split`，这次将单词字符串分割成一个单词列表。这样就处理好了输入。
- en: 'Two variables drive the main portion of the program: `line` and `chars_on_line`.
    The `line` variable refers to the current line; we start out with it referring
    to the empty string ❹. The `chars_on_line` variable refers to the number of characters,
    not counting spaces, on the current line.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 两个变量驱动程序的主要部分：`line`和`chars_on_line`。`line`变量表示当前行；我们一开始将它设置为空字符串❹。`chars_on_line`变量表示当前行上字符的数量，不包括空格。
- en: You may wonder why I’m maintaining `chars_on_line` at all. Couldn’t we just
    use `len(line)` instead? Well, if we did that, we’d be including spaces in our
    count, and spaces don’t count toward the number of characters allowed per line.
    We could fix that by subtracting the count of spaces, and I encourage you to try
    that on your own if you find it more intuitive than keeping the `chars_on_line`
    variable in there.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，为什么我要维持`chars_on_line`变量呢？我们不能直接使用`len(line)`吗？如果我们这么做，会把空格也算入总数，而空格不算在每行允许的字符数内。如果你觉得用`len(line)`会更直观，我鼓励你自己尝试一下，通过减去空格的数量来解决这个问题。
- en: Now it’s time to loop through all of the words. For each word, we have to determine
    whether it goes on the current line or next line.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候遍历所有单词了。对于每个单词，我们需要确定它是放在当前行还是下一行。
- en: If the number of nonspace characters on the current line plus the number of
    characters in the current word is at most `k`, then the current word fits on the
    current line ❺. In that case, we add the word plus a space to the current line
    and update the number of nonspace characters on the line.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果当前行上的非空字符数加上当前单词的字符数不超过`k`，则当前单词适合当前行❺。在这种情况下，我们将单词和一个空格添加到当前行，并更新当前行上的非空字符数。
- en: Otherwise, the current word doesn’t fit on the current line. The current line
    is done! We therefore write the line to the output file ❻ and update the `line`
    and `chars_on_line` variables to reflect that this is the only word on the now-current
    line.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，当前单词不适合当前行。当前行已结束！因此，我们将当前行写入输出文件❻，并更新`line`和`chars_on_line`变量，以反映当前行只有这个单词。
- en: 'There are two things to note about the `write` call ❻. First, the `[:-1]` slice
    is in there to prevent us from outputting the space that follows the last word
    on the line. Second, you may have expected me to use an f-string here, like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`write`调用❻有两点需要注意。首先，`[:-1]`切片的存在是为了防止我们输出行末单词后的空格。其次，你可能会期待我在这里使用f-string，像这样：
- en: '[PRE29]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: However, at the time of writing, the USACO judge is running an older version
    of Python that doesn’t support f-strings.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在写作时，USACO评测系统正在运行一个较旧版本的Python，该版本不支持f-strings。
- en: Why are we outputting `line` after the loop ends ❼? The reason is that each
    iteration of the `for` loop is guaranteed to leave `line` with one or more words
    that we have not output yet. Consider what happens with each word that we process.
    If the current word fits on the current line, we don’t output anything. If the
    current word doesn’t fit on the current line, then we output the current line,
    but not the word on the next line. We therefore need to write `line` to the output
    file *after* the loop ❼; otherwise, the last line in the essay will be lost.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们在循环结束后❼要输出`line`？原因是每次迭代的`for`循环都会确保`line`中包含一个或多个我们尚未输出的单词。考虑一下我们处理每个单词时发生的情况。如果当前单词适合当前行，我们就不输出任何内容。如果当前单词不适合当前行，我们就输出当前行，但不输出下一行的单词。因此，我们需要在循环结束后❼将`line`写入输出文件；否则，文章的最后一行将会丢失。
- en: The final thing we do is close both files.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们做的事情是关闭两个文件。
- en: One annoying aspect of writing to a file rather than the screen is that we aren’t
    shown the output when we run the program. To see the output, we have to open the
    output file in our text editor.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 写入文件而不是屏幕的一个令人烦恼的方面是，当我们运行程序时，看不到输出。为了查看输出，我们必须在文本编辑器中打开输出文件。
- en: 'Here’s a tip: develop the program using `print` calls rather than `write` calls
    so that all output goes to the screen. That should make it easier to find errors
    in your program and avoid having to switch back and forth between your code and
    the output file. Once you’re happy with the code, you can change the `print` calls
    back to `write` calls. Then be sure to do a little more testing, just to make
    sure that everything ends up in the file as it should.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个小技巧：在开发程序时，使用`print`调用而不是`write`调用，这样所有的输出都将显示在屏幕上。这样可以更容易地找到程序中的错误，并避免在代码和输出文件之间来回切换。一旦你对代码满意了，可以将`print`调用改回`write`调用。然后一定要再做一些测试，以确保所有内容都按照预期写入了文件。
- en: We’re ready to submit to the USACO judge. Send it our code! All test cases should
    pass.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们准备好提交给USACO评测了。把我们的代码发过去吧！所有测试用例都应该通过。
- en: 'Problem #17: Farm Seeding'
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '问题 #17：农场播种'
- en: We can use a loop to read a specified number of lines from a file. We’ll do
    that in this problem, and we’ll see that it’s similar to using a loop with `input`
    to read from standard input.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用循环从文件中读取指定数量的行。我们将在这个问题中做到这一点，并且会发现它与使用`input`从标准输入读取数据非常相似。
- en: In [Chapter 6](ch06.xhtml#ch06), when we solved Action Figures, we learned about
    top-down design using functions. It’s an important skill, composing multiple functions
    to solve a problem. And since there isn’t much more to say about files, I’ve chosen
    a problem that doubles as a site for top-down design.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](ch06.xhtml#ch06)中，当我们解决《动作人物》问题时，我们学习了使用函数的自上而下设计。这是一个重要的技能，能够通过组合多个函数来解决一个问题。由于关于文件没有更多要说的内容，我选择了一个既能作为解决问题的场景，又能作为自上而下设计的练习问题。
- en: This is a challenging problem. We’ll first need to understand exactly what we’re
    being asked to do. After that, we’ll need to develop a way to solve the problem
    and think carefully about why our solution is correct.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个具有挑战性的问题。我们首先需要准确理解我们被要求做的事情。之后，我们需要制定解决问题的方法，并仔细思考为什么我们的解决方案是正确的。
- en: This is USACO 2019 February Bronze Contest problem The Great Revegetation.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这是USACO 2019年2月青铜级竞赛问题——《大规模重新植草》。
- en: The Challenge
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战
- en: Farmer John has *n* pastures, all of which he would like to seed with grass.
    The pastures are numbered 1, 2, . . ., *n*.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 农夫约翰有*n*个牧场，他想要为这些牧场播种草。牧场编号为1、2、...、*n*。
- en: Farmer John has four different types of grass seed, numbered 1, 2, 3, and 4\.
    He’ll choose one of these grass types for each pasture.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 农夫约翰有四种不同的草种子，编号为1、2、3和4。他将为每个牧场选择其中一种草种类型。
- en: Farmer John also has *m* cows. Each cow has two favorite pastures in which it
    eats grass. Each cow cares only about its two favorite pastures, no others. For
    a healthy diet, each cow requires that its two pastures have different types of
    grass. For example, for some given cow, it would be okay if one of its pastures
    had grass type 1 and the other had grass type 4\. But it would not be okay if
    both of its pastures had grass type 1.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 农夫约翰还有*m*只牛。每只牛有两个最喜欢的牧场，它在这些牧场中吃草。每只牛只关心它的两个最喜欢的牧场，其他牧场无关紧要。为了保持健康饮食，每只牛要求它的两个牧场有不同的草种类型。例如，对于某只给定的牛，如果一个牧场是草种类型1，另一个是草种类型4，那么是可以接受的。但如果两个牧场都是草种类型1，那就不行。
- en: A pasture might be the favorite of more than one cow. But it’s guaranteed that
    a pasture is the favorite of no more than three cows.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 一个牧场可能是多个牛的最喜欢牧场，但保证每个牧场最多只会是三只牛的最喜欢牧场。
- en: Determine the grass type to use in each pasture. Each pasture is required to
    use a grass type between 1 and 4, and each cow’s two favorite pastures must have
    different grass types.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 确定每个牧场使用的草种类型。每个牧场必须使用1到4之间的草种类型，并且每只牛的两个最喜欢的牧场必须有不同的草种类型。
- en: Input
  id: totrans-164
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输入
- en: Read input from the file named *revegetate.in*.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 从名为*revegetate.in*的文件中读取输入。
- en: 'The input consists of the following lines:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 输入包括以下几行：
- en: A line containing two integers separated by a space. The first integer is *n*,
    the number of pastures; it’s between 2 and 100\. The second integer is *m*, the
    number of cows; it’s between 1 and 150.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一行包含两个由空格分隔的整数。第一个整数是*n*，即牧场的数量；它介于2和100之间。第二个整数是*m*，即牛的数量；它介于1和150之间。
- en: '*m* lines, each of which gives the two favorite pasture numbers for a cow.
    These pasture numbers are integers between 1 and *n* and are separated by a space.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*m*行，每行给出一只牛的两个最喜欢的牧场编号。这些牧场编号是1到*n*之间的整数，且用空格分隔。'
- en: Output
  id: totrans-169
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输出
- en: Write output to the file named *revegetate.out*.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 将输出写入名为*revegetate.out*的文件。
- en: Output a valid way to seed the pastures. The output is a line of *n* characters,
    each of which is a `'1'`, `'2'`, `'3'`, or `'4'`. The first character is the grass
    type for pasture 1, the second is the grass type for pasture 2, and so on.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 输出一种有效的牧场播种方式。输出是一行*n*个字符，每个字符为`'1'`、`'2'`、`'3'`或`'4'`。第一个字符是牧场1的草种类型，第二个字符是牧场2的草种类型，依此类推。
- en: We can interpret these *n* characters as an integer with *n* digits. For example,
    if we have the five grass types `'11123'`, then we can interpret this as the integer
    `11123`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这*n*个字符解释为一个整数，包含*n*个数字。例如，如果我们有五个草种类型`'11123'`，那么我们可以将其解释为整数`11123`。
- en: This integer interpretation comes into play when we have a choice of what to
    output. If there are multiple valid ways to seed the pastures, we must output
    the one that’s smallest when interpreted as an integer. For example, if both `'11123'`
    and `'22123'` are valid, we output the string `'11123'` because `11123` is less
    than `22123`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有多种输出选择时，这种整数解释法就派上用场了。如果有多种有效的播种方法，我们必须输出解释为整数时最小的那一种。例如，如果 `'11123'` 和
    `'22123'` 都是有效的，我们输出字符串 `'11123'`，因为 `11123` 小于 `22123`。
- en: Exploring a Test Case
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探索测试用例
- en: We’re going to use top-down design to arrive at a solution for this problem.
    Working through a test case will help us sift the tasks.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用自上而下的设计方法来找到这个问题的解决方案。通过处理一个测试用例，我们可以帮助自己梳理任务。
- en: 'Here’s the test case:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是测试用例：
- en: '[PRE30]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The first line of the test case tells us that we have eight pastures. They’re
    numbered from 1 to 8\. The first line also tells us that we have six cows. The
    problem doesn’t specify a numbering for the cows, so I’ll just number them starting
    at 0\. The two favorite pastures of each cow are in [Table 7-1](ch07.xhtml#ch07tab01)
    for easy reference.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 测试用例的第一行告诉我们有八个牧场，它们从 1 到 8 编号。第一行还告诉我们有六头牛。问题并没有指定牛的编号，所以我从 0 开始给它们编号。每头牛最喜欢的两个牧场在[表
    7-1](ch07.xhtml#ch07tab01)中可以方便查看。
- en: '**Table 7-1:** Farm Seeding Example, Cows'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 7-1：** 农场播种示例，牛'
- en: '| **Cow** | **Pasture 1** | **Pasture 2** |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| **牛** | **牧场 1** | **牧场 2** |'
- en: '| --- | --- | --- |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0 | 5 | 4 |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 5 | 4 |'
- en: '| 1 | 2 | 4 |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 2 | 4 |'
- en: '| 2 | 3 | 5 |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 3 | 5 |'
- en: '| 3 | 4 | 1 |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 4 | 1 |'
- en: '| 4 | 2 | 1 |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 2 | 1 |'
- en: '| 5 | 5 | 2 |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 5 | 2 |'
- en: In this problem, we’re being asked to make *n* decisions. What grass type should
    we use for pasture 1? What grass type should we use for pasture 2? Pasture 3?
    Pasture 4? And so on, all the way up to pasture *n*. One strategy for these kinds
    of problems is to make one decision at a time, without making a mistake on any
    of them. If we manage to finish with decision *n* and haven’t made any mistakes
    along the way, then our solution must be correct.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个问题中，我们需要做出 *n* 个决策。我们应该为牧场 1 选择什么草种？牧场 2 呢？牧场 3 呢？牧场 4 呢？依此类推，一直到牧场 *n*。解决这类问题的一种策略是一次做一个决策，不犯任何错误。如果我们能够完成第
    *n* 个决策，并且途中没有犯错，那么我们的解决方案必定是正确的。
- en: Let’s go through the pastures from 1 to 8 and see if we can assign a grass type
    to each of them. We need to prioritize choosing small-numbered grass types so
    that we end with the smallest grass types when interpreted as a number.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从牧场 1 到牧场 8 依次查看，看看能否为每个牧场分配一个草种。我们需要优先选择编号较小的草种，以便最终得到解释为数字时最小的草种。
- en: What grass type should we choose for pasture 1? The only cows that care about
    pasture 1 are cows 3 and 4, so we focus only on those two. If we had already chosen
    grass types for some of these cows’ pastures, then we’d have to be careful with
    our choice for pasture 1\. We wouldn’t want to give some cow two pastures with
    the same grass type, because that would break the rules! We haven’t chosen any
    grass types yet, so nothing can go wrong no matter what we choose for pasture
    1\. Since we want the smallest grass types, though, we’ll choose grass type 1.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该为牧场 1 选择什么草种呢？唯一关心牧场 1 的牛是牛 3 和牛 4，所以我们只需要关注这两头牛。如果我们已经为某些牛的牧场选择了草种，那么我们就需要小心选择牧场
    1 的草种。我们不希望给同一头牛安排两个草种相同的牧场，因为那样会违反规则！由于我们还没有选择任何草种，所以不管选择什么草种，都不会出错。不过，由于我们希望选择最小的草种，因此我们会选择草种
    1。
- en: 'I’ll collect our grass-type decisions in tables. Here’s the decision we just
    made, grass type 1 for pasture 1:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我将把我们的草种决策记录在表格中。以下是我们刚刚做出的决策，为牧场 1 选择草种 1：
- en: '| **Pasture** | **Grass type** |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| **牧场** | **草种** |'
- en: '| --- | --- |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 1 | 1 |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 |'
- en: 'Let’s move on. What grass type should we choose for pasture 2? The cows that
    care about pasture 2 are cows 1, 4, and 5, so we focus on those. One of cow 4’s
    pastures is pasture 1, and we chose grass type 1 for that pasture, so grass type
    1 is eliminated as a grass type for pasture 2\. If we used grass type 1 for pasture
    2, then we’d be giving cow 4 two pastures with the same grass type, and that would
    break the rules. Cows 1 and 5, however, don’t eliminate any other grass types,
    because we haven’t chosen grass types for their pastures yet. We therefore choose
    grass type 2, the smallest-numbered grass type that’s available. Here’s where
    we stand:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续前进。我们应该为牧场 2 选择什么草种呢？关心牧场 2 的牛是牛 1、4 和 5，所以我们集中在这些牛上。牛 4 的一个牧场是牧场 1，我们为那个牧场选择了草种
    1，所以草种 1 被排除为牧场 2 的草种。如果我们为牧场 2 选择草种 1，那么我们就会给牛 4 两个牧场分配相同的草种，这违反了规则。然而，牛 1 和牛
    5 并不会排除其他草种，因为我们还没有为它们的牧场选择草种。因此，我们选择草种 2，最小的可用草种。现在的情况如下：
- en: '| **Pasture** | **Grass type** |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| **牧场** | **草种** |'
- en: '| --- | --- |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 1 | 1 |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 |'
- en: '| 2 | 2 |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 2 |'
- en: 'What grass type should we choose for pasture 3? The only cow that cares about
    pasture 3 is cow 2\. Cow 2’s pastures are pastures 3 and 5\. That cow doesn’t
    eliminate any grass types, however, because we haven’t assigned a grass type to
    pasture 5! To get the smallest number, we’ll use grass type 1 for pasture 3\.
    Here’s our next snapshot:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该为牧场 3 选择什么草种呢？关心牧场 3 的唯一牛是牛 2。牛 2 的牧场是牧场 3 和 5。然而，这头牛不会排除任何草种，因为我们还没有为牧场
    5 分配草种！为了选择最小的数字，我们将为牧场 3 选择草种 1。现在我们的进展如下：
- en: '| **Pasture** | **Grass type** |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| **牧场** | **草种** |'
- en: '| --- | --- |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 1 | 1 |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 |'
- en: '| 2 | 2 |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 2 |'
- en: '| 3 | 1 |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 1 |'
- en: I can see three tasks in our top-down design crystallizing here. First, we need
    to obtain the cows that care about the current pasture. Second, we need to determine
    which grass types those cows eliminate from consideration. Third, we need to choose
    the smallest-numbered grass type that wasn’t eliminated. Each of those is a prime
    candidate for a function.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我能看到我们从自顶向下设计中逐步清晰化的三项任务。首先，我们需要获取关心当前牧场的牛。其次，我们需要确定这些牛排除的草种。第三，我们需要选择未被排除的最小编号草种。每一项任务都是函数的理想候选。
- en: 'Let’s keep going. We have three cows that care about pasture 4: cows 0, 1,
    and 3\. Cow 0 doesn’t eliminate any grass types, because we haven’t assigned grass
    types to its pastures yet. Cow 1 eliminates grass type 2 because we assigned grass
    type 2 to pasture 2 (its other pasture). And cow 3 eliminates grass type 1 because
    we assigned grass type 1 to pasture 1 (its other pasture). The smallest available
    grass type, then, is 3, so that’s what we use for pasture 4:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 继续前进。我们有三头牛关心牧场 4：牛 0、1 和 3。牛 0 不会排除任何草种，因为我们还没有为它的牧场分配草种。牛 1 排除了草种 2，因为我们将草种
    2 分配给了牧场 2（它的另一个牧场）。牛 3 排除了草种 1，因为我们将草种 1 分配给了牧场 1（它的另一个牧场）。因此，最小的可用草种是 3，所以我们为牧场
    4 选择了这个草种：
- en: '| **Pasture** | **Grass type** |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| **牧场** | **草种** |'
- en: '| --- | --- |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 1 | 1 |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 |'
- en: '| 2 | 2 |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 2 |'
- en: '| 3 | 1 |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 1 |'
- en: '| 4 | 3 |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 3 |'
- en: On to pasture 5\. The cows that care about pasture 5 are cows 0, 2, and 5\.
    Cow 0 eliminates grass type 3; cow 2 eliminates grass type 1; and cow 5 eliminates
    grass type 2\. So grass types 1, 2, and 3 are out. Our only choice is grass type
    4.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是牧场 5。关心牧场 5 的牛是牛 0、2 和 5。牛 0 排除了草种 3；牛 2 排除了草种 1；牛 5 排除了草种 2。所以草种 1、2 和
    3 都被排除了。我们唯一的选择是草种 4。
- en: That was close! We almost ran out of grass types there. Lucky for us, there
    was no other cow that cared about pasture 5 and eliminated grass type 4.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 那真是险些出事！我们差点就用完草种了。幸好，没有其他牛关心牧场 5 并排除了草种 4。
- en: 'Or, wait. This wasn’t luck at all, because of this bit from the problem description:
    “It’s guaranteed that a pasture is the favorite of no more than three cows.” This
    means that at most three grass types can be eliminated for each pasture. We’ll
    never be stuck! And we don’t even have to worry about the ramifications of past
    choices on our next decision. No matter what we did in the past, we’ll always
    have at least one available grass type.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 等等。其实这并不是运气，因为问题描述中有这么一句：“保证每个牧场最多只会是三头牛的最爱。”这意味着每个牧场最多只能排除三种草种。我们永远不会陷入困境！我们甚至不需要担心过去的选择对下一次决策的影响。无论我们之前做了什么，至少总会有一种可用的草种。
- en: 'Let’s add pasture 5 to our table:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把牧场 5 添加到表格中：
- en: '| **Pasture** | **Grass type** |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| **牧场** | **草种** |'
- en: '| --- | --- |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 1 | 1 |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 |'
- en: '| 2 | 2 |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 2 |'
- en: '| 3 | 1 |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 1 |'
- en: '| 4 | 3 |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 3 |'
- en: '| 5 | 4 |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 4 |'
- en: 'There are three pastures to go. But no cow cares about any of them, so we can
    just use grass type 1 in each case. That gives us this:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个草场要处理。但没有牛关心它们，所以我们可以在每种情况下使用草种类型 1。这样我们得到的是：
- en: '| **Pasture** | **Grass type** |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| **草场** | **草种类型** |'
- en: '| --- | --- |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 1 | 1 |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 |'
- en: '| 2 | 2 |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 2 |'
- en: '| 3 | 1 |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 1 |'
- en: '| 4 | 3 |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 3 |'
- en: '| 5 | 4 |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 4 |'
- en: '| 6 | 1 |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 1 |'
- en: '| 7 | 1 |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 1 |'
- en: '| 8 | 1 |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 1 |'
- en: 'We can read the grass types from top to bottom to obtain the correct output
    for this example. The output is as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从上到下读取草种类型，得到这个示例的正确输出。输出如下：
- en: '[PRE31]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Top-Down Design
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自上而下设计
- en: With a good understanding of the tasks that we’ll need to complete, we’ll turn
    to a top-down design of this problem.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 通过充分理解我们需要完成的任务，我们将转向问题的自上而下设计。
- en: The Top Level
  id: totrans-240
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 顶层设计
- en: We discovered three tasks in the previous section as we worked through a test
    case. Before our program can solve any of those tasks, we need to read the input,
    so that’s a fourth task. We also need to write the output. That will take some
    thought and a few lines of code, so let’s call that our fifth task.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一节通过测试用例发现了三个任务。在我们的程序能够解决任何这些任务之前，我们需要先读取输入，因此这是第四个任务。我们还需要写输出。这将需要一些思考和几行代码，所以我们将其定为第五个任务。
- en: 'Here are our five main tasks:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的五个主要任务：
- en: Read input.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取输入。
- en: Identify cows that care about current pasture.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定关心当前草场的牛。
- en: Eliminate grass types for current pasture.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 去除当前草场的草种类型。
- en: Choose smallest-numbered grass type for current pasture.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择当前草场的最小编号草种类型。
- en: Write output.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写输出。
- en: As we did when solving Action Figures in [Chapter 6](ch06.xhtml#ch06), we’ll
    start with a framework of `TODO` comments and remove each `TODO` as we solve it.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在解决《行动人物》时在 [第六章](ch06.xhtml#ch06) 所做的那样，我们将从一个包含 `TODO` 注释的框架开始，并在解决每个问题时去掉对应的
    `TODO`。
- en: We begin with mostly comments. Since we’ll need to open the files at the start
    and close them at the end, I’ve also added that code.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始时主要是注释。由于我们在开始时需要打开文件，在结束时需要关闭文件，我还添加了相关代码。
- en: 'Here’s where we begin:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们开始的地方：
- en: '[PRE32]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Task 1: Read Input'
  id: totrans-252
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 任务 1：读取输入
- en: 'Reading the first line of input, with the integers *n* and *m*, is something
    we know how to do. It’s straightforward enough that I don’t think we need a function
    for it, so let’s do it directly. Next we need to read the pasture information
    for the *m* cows, and here a function seems warranted. Let’s remove the `TODO`
    in the `Read input` comment, handle the first line of input, and call the `read_cows`
    function, which we’ll write shortly:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 读取输入的第一行，其中包含整数 *n* 和 *m*，是我们已经知道如何做的事情。它足够直接，我认为我们不需要为此编写一个函数，所以我们直接处理它。接下来，我们需要读取
    *m* 头牛的草场信息，在这里一个函数似乎是必要的。让我们去掉 `TODO` 注释中的内容，处理第一行输入，并调用 `read_cows` 函数，我们稍后会编写这个函数：
- en: '[PRE33]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `read_cows` function that we’re calling ❶ will take a file that’s already
    open for reading, and read the two favorite pastures for each cow. It’ll return
    a list of lists, where each inner list contains the two pasture numbers for a
    given cow. Here’s the code:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在调用的 `read_cows` 函数 ❶ 将接受一个已经打开的文件并读取每头牛的两个最爱草场。它将返回一个列表的列表，每个内部列表包含一头牛的两个草场编号。以下是代码：
- en: '[PRE34]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This function accumulates the cows’ favorite pastures into the `favorites` list.
    It does that using a range `for` loop that loops `num_cows` times, once for each
    cow. We need the loop because the number of lines to read depends on the number
    of cows in the file.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将牛的最爱草场收集到 `favorites` 列表中。它使用一个范围 `for` 循环来循环 `num_cows` 次，每次处理一头牛。我们需要这个循环，因为要读取的行数取决于文件中牛的数量。
- en: On each iteration of the loop, we read the next line and split it into its two
    components ❶. We then use `int` to convert the components from strings to integers.
    When we append this list to `favorites` ❷, we’re therefore appending a list of
    two integers.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次循环中，我们读取下一行并将其拆分成两个部分 ❶。然后，我们使用 `int` 将这些部分从字符串转换为整数。当我们将这个列表添加到 `favorites`
    ❷ 时，我们实际上是将一个包含两个整数的列表添加进去了。
- en: The last thing we do is return the list of favorite pastures.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做的最后一件事是返回最爱的草场列表。
- en: Before we continue, let’s make sure that we know how to call this function.
    We’ll practice calling it on its own, independent from the larger program that
    we’re building. It’s useful to test functions like this so that we can fix any
    errors that we might find along the way.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们确保我们知道如何调用这个函数。我们将单独练习调用它，而不依赖于我们正在构建的更大程序。测试这样的函数非常有用，因为我们可以在过程中修复任何发现的错误。
- en: 'Use your text editor to create a file named *revegetate.in* with the following
    contents (the same as the test case we studied earlier):'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你的文本编辑器创建一个名为*revegetate.in*的文件，内容如下（与我们之前学习的测试用例相同）：
- en: '[PRE35]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now, in the Python shell, enter the code for our `read_cows` function.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在Python shell中输入我们`read_cows`函数的代码。
- en: 'Here’s what we do to call `read_cows`:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们调用`read_cows`的方法：
- en: '[PRE36]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `read_cows` function reads only the information for the cows. Since we’re
    testing this function in isolation, outside of our program, we need to read the
    first line of the file ourselves before we call it ❶. When we then call `read_cows`,
    we get back a list giving the favorite pastures for each cow. Also notice that
    we’re calling `read_cows` with an open file, *not* a filename ❷.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`read_cows`函数只读取奶牛的信息。由于我们在程序外单独测试这个函数，因此我们需要在调用它之前自己读取文件的第一行❶。当我们调用`read_cows`时，它会返回一个列表，给出每只奶牛的最爱牧场。还要注意，我们在调用`read_cows`时传入的是打开的文件，而不是文件名❷。'
- en: Be sure to include our `read_cows` function, along with the functions we’ll
    write for other tasks, before our `# Main Program` comment. Then we can move on
    to Task 2.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保在`# Main Program`注释之前包含我们的`read_cows`函数，以及我们为其他任务编写的函数。然后我们可以继续进行任务2。
- en: 'Task 2: Identify Cows'
  id: totrans-268
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 任务2：识别奶牛
- en: Our overall strategy for solving this problem is to consider each pasture in
    turn, deciding which grass type to use. We’ll organize this work inside a loop,
    with each iteration of the loop responsible for seeding one pasture. For each
    pasture, we need to identify the cows that care about the pasture, eliminate the
    used grass types, and choose the smallest-numbered available grass type. These
    three tasks must run for each pasture, so we’ll indent them inside the loop.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们解决这个问题的总体策略是逐个考虑每个牧场，决定使用哪种草类型。我们将在一个循环中组织这项工作，每次循环的迭代负责播种一个牧场。对于每个牧场，我们需要识别关心该牧场的奶牛，排除已使用的草类型，并选择编号最小的可用草类型。这三项任务必须对每个牧场执行，因此我们将它们缩进到循环内部。
- en: We’ll write a function called `cows_with_favorite` that tells us the cows who
    care about the current pasture.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个名为`cows_with_favorite`的函数，用于告诉我们哪些奶牛关心当前的牧场。
- en: 'Here’s what we’ve got now for our main program:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们当前的主程序：
- en: '[PRE37]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `cows_with_favorite` function that we’re calling ❶ takes a list of the
    cows’ favorite pastures and a pasture number and returns the cows that care about
    that pasture. Here’s the code:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在调用的`cows_with_favorite`函数❶接收一个奶牛最喜欢的牧场列表和一个牧场编号，并返回关心该牧场的奶牛。以下是代码：
- en: '[PRE38]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The function loops through `favorites`, looking for cows that care about pasture
    number `pasture`. Each cow that cares about the pasture is added to the `cows`
    list that is ultimately returned.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数遍历`favorites`，查找关心牧场编号`pasture`的奶牛。每一只关心该牧场的奶牛都会被添加到`cows`列表中，最后该列表会被返回。
- en: 'Let’s do a little test. Enter our `cows_with_favorite` function into the Python
    shell. Here’s the call that we’ll try:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们做一个小测试。在Python shell中输入我们的`cows_with_favorite`函数。这里是我们将尝试的调用：
- en: '[PRE39]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We have three cows here, and we’re asking which ones care about pasture `5`.
    The cows at indices `0` and `2` care about pasture `5`, and that’s exactly what
    the function tells us:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有三只奶牛，我们要找出哪些奶牛关心牧场`5`。位于索引`0`和`2`的奶牛关心牧场`5`，这正是该函数告诉我们的内容：
- en: '[PRE40]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Task 3: Eliminate Grass Types'
  id: totrans-280
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 任务3：排除草类型
- en: Now we know the cows that care about the current pasture. Our next step is to
    figure out which grass types these cows eliminate from consideration for the current
    pasture. We eliminate the grass types that are used in a pasture associated with
    one or more of these cows. We’ll write a function called `types_used` that tells
    us the grass types that have already been used (and are therefore eliminated for
    the current pasture).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了哪些奶牛关心当前的牧场。我们的下一步是弄清楚这些奶牛会排除哪些草类型，无法用于当前牧场。我们将排除与这些奶牛相关的牧场中已经使用的草类型。我们将编写一个名为`types_used`的函数，告诉我们哪些草类型已经被使用（因此不能用于当前牧场）。
- en: 'Here is our main program, updated with a call to this function:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们更新后的主程序，包含了对这个函数的调用：
- en: '[PRE41]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In addition to calling the `types_used` function ❷, I’ve also added a variable
    called `pasture_types` ❶. The list referred to by this variable will keep track
    of the grass type for each pasture.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 除了调用`types_used`函数❷，我还添加了一个名为`pasture_types`的变量❶。该变量所引用的列表将跟踪每个牧场的草类型。
- en: Recall that the pastures are numbered starting from 1\. Python lists, on the
    other hand, are indexed starting from 0\. I don’t like this discrepancy; if we
    simply started adding grass types to `pasture_types`, then the grass type for
    pasture 1 would be at index 0, the grass type for pasture 2 would be at index
    1, and so on, always off by one. That’s why I added a bogus `0` at the beginning
    of the list ❶; when we later add the grass type for pasture 1, it’ll be placed
    at index 1 to match.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，牧场的编号是从1开始的，而Python的列表是从0开始索引的。我不喜欢这种差异；如果我们只是简单地开始将草种添加到`pasture_types`中，那么牧场1的草种会在索引0的位置，牧场2的草种会在索引1的位置，以此类推，始终相差一个位置。这就是为什么我在列表开头添加了一个虚假的`0`
    ❶；当我们后续为牧场1添加草种时，它会被放置在索引1的位置，以便与之匹配。
- en: 'Suppose we’ve figured out the grass types for the first four pastures. Here’s
    how `pasture_types` might look at that point:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经弄清楚了前四个牧场的草种。这时`pasture_types`可能看起来是这样的：
- en: '[PRE42]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: If we want the grass type for pasture 1, we look at index 1; if we want the
    grass type for pasture 2, we look at index 2; and so on. If we want the grass
    type for pasture 5? Well, no, we can’t have that, because we haven’t figured it
    out yet. If the length of `pasture_types` is `5`, it means that we’ve figured
    out the grass types for only the first four pastures. In general, the number of
    grass types that we’ve figured out is one less than the list’s length.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要牧场1的草种，我们查看索引1；如果我们想要牧场2的草种，我们查看索引2；以此类推。如果我们想要牧场5的草种？嗯，不行，因为我们还没有弄清楚。如果`pasture_types`的长度是`5`，这意味着我们只弄清楚了前四个牧场的草种。一般来说，我们弄清楚的草种数量比列表的长度少一个。
- en: 'Now we’re ready for the `types_used` function. It takes three parameters: the
    list of favorite pastures for each cow, the cows that care about the current pasture,
    and the grass types chosen for pastures so far. It returns the list of grass types
    that are already used and therefore eliminated for the current pasture. Here goes:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备使用`types_used`函数了。它接受三个参数：每头牛最喜欢的牧场列表、关心当前牧场的牛、以及目前已选定的牧场草种。它返回当前牧场已经使用并因此被排除的草种列表。接下来是：
- en: '[PRE43]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Each cow has two favorite pastures, which I refer to by `pasture_a` and `pasture_b`.
    For each of these pastures, we check whether a grass type has already been chosen
    for it at ❶ and ❷. A grass type has already been chosen if that pasture is already
    an index in `pasture_types`. These grass types are all added to the `used` list,
    which the function returns after looping through all of the relevant cows.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 每头牛有两个最喜欢的牧场，我称之为`pasture_a`和`pasture_b`。对于这些牧场，我们检查在❶和❷的位置，是否已经为其选择了草种。如果该牧场已经是`pasture_types`中的一个索引，那么草种就已经被选择。这些草种都被添加到`used`列表中，函数将在遍历所有相关牛后返回该列表。
- en: What if more than one cow uses the same pasture—what does our code do then?
    Let’s come up with a simple test case to answer that question.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如果多头牛使用同一片牧场——我们的代码会怎么处理呢？让我们提出一个简单的测试用例来回答这个问题。
- en: 'Enter our `types_used` function into the Python shell. Here’s a call of that
    function; let’s predict what it returns:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python shell中输入我们的`types_used`函数。以下是对该函数的调用；我们来预测它的返回值：
- en: '[PRE44]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Let’s be careful so we don’t get lost. The first argument gives the favorite
    pastures for three cows. The second argument gives the cows that care about a
    particular pasture; these are cows `0` and `1`. And the third argument gives the
    grass types that we’ve decided on so far.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要小心，以免迷失。第一个参数给出了三头牛的最喜欢的牧场。第二个参数给出了关心某个特定牧场的牛，这些是牛`0`和牛`1`。第三个参数给出了我们目前为止决定的草种。
- en: Now, what are the grass types already used, and therefore eliminated, by cows
    `0` and `1`? Cow `0` cares about pasture `4`, and pasture `4` uses grass type
    `3`, so grass type `3` is eliminated. Cow `1` cares about pasture `2`, and pasture
    `2` uses grass type `2`, so grass type `2` is eliminated. Cow `1` also cares about
    pasture `4`—but we already know, from cow `0`, that pasture `4`’s grass type `3`
    is eliminated.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，牛`0`和牛`1`已经使用并因此被排除的草种有哪些呢？牛`0`关心牧场`4`，而牧场`4`使用草种`3`，所以草种`3`被排除。牛`1`关心牧场`2`，而牧场`2`使用草种`2`，因此草种`2`被排除。牛`1`还关心牧场`4`——但我们已经从牛`0`那里知道，牧场`4`的草种`3`已经被排除。
- en: 'The return value of our function is this:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们函数的返回值是这样的：
- en: '[PRE45]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Two `3`s in there, one coming from cow `0` and the other from cow `1`.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个`3`，一个来自牛`0`，另一个来自牛`1`。
- en: It may seem tidier to have just one `3` in there, but what we have—with the
    duplicate—is just fine. If a grass type is in that list, then it’s eliminated,
    no matter whether it’s in there once, twice, or three times.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 或许只有一个`3`看起来更整洁，但现在这种带重复值的方式其实也没问题。如果某个草类型出现在列表中，那它就被排除，无论它出现了一次、两次，还是三次。
- en: 'Task 4: Choose Smallest-Numbered Grass Type'
  id: totrans-301
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 任务 4：选择最小编号的草类型
- en: 'Having obtained the grass types that are eliminated, we can move onto our next
    task: choosing the smallest-numbered available grass type for the current pasture.
    To solve this one, we’ll call a new function, `smallest_available`. It will return
    the grass type that we should use for the current pasture.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在得到已经被排除的草类型后，我们可以进行下一个任务：选择当前牧场的最小编号可用草类型。为了解决这个问题，我们将调用一个新的函数`smallest_available`。它将返回我们应该为当前牧场使用的草类型。
- en: 'Here’s the main program, updated with a call to the `smallest_available` function:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是主程序，更新后调用了`smallest_available`函数：
- en: '[PRE46]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Once we obtain the smallest-numbered grass type for the current pasture ❶, we
    add it to our list of chosen grass types ❷.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们获得了当前牧场的最小编号草类型❶，我们将其添加到已选择的草类型列表中❷。
- en: 'Here’s the `smallest_available` function itself:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`smallest_available`函数本身：
- en: '[PRE47]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The function begins with grass type `1`. It then loops until it finds a grass
    type that isn’t already used, increasing the grass type by one on each iteration.
    Once a free grass type is found, the function returns it. And remember, there
    are at most three grass types that have been used out of the four available, so
    this function is guaranteed to be successful.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数从草类型`1`开始。然后它循环，直到找到一个未被使用的草类型，每次循环时将草类型加1。一旦找到一个空闲的草类型，函数就返回它。请记住，最多只有四种草类型，其中已经使用了最多三种，因此该函数一定能成功。
- en: 'Task 5: Write Output'
  id: totrans-309
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 任务 5：写入输出
- en: 'We’ve got our answer, right there in `pasture_types`! Now all we have to do
    is output it. Here’s the main program a final time:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经得到了答案，就在`pasture_types`中！现在我们只需输出它。以下是最终的主程序：
- en: '[PRE48]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Before writing the output, we remove the bogus `0` at the beginning of `pasture_types`
    ❶. We don’t want to output that `0`, as it isn’t a real grass type. Then, we call
    `write_pastures` to actually write the output ❷.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在写入输出之前，我们首先去除`pasture_types`开头的无效`0`❶。我们不想输出那个`0`，因为它并不是真正的草类型。然后，我们调用`write_pastures`函数，实际上写入输出❷。
- en: 'All we need now is the `write_pastures` function. It takes a file open for
    writing, and a list of grass types, and outputs the grass types to the file. Here’s
    the code:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们所需要的就是`write_pastures`函数。它接受一个打开用于写入的文件和一个草类型列表，并将草类型输出到文件中。以下是代码：
- en: '[PRE49]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Right now, `pasture_types` is a list of integers. As we’ll see in a second,
    it’s more convenient to work with a list of strings here, so I create a new list
    with each integer as a string ❶. I don’t modify the `pasture_types` list itself,
    because that could shock the caller of this function. The caller calls this function
    expecting only that output gets written to `output_file`, not that its `pasture_types`
    list is modified. The function has no business modifying its list parameter.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`pasture_types`是一个整数列表。正如我们稍后会看到的，在这里使用字符串列表会更加方便，因此我创建了一个新的列表，将每个整数转换为字符串❶。我没有修改`pasture_types`列表本身，因为那样会影响到调用此函数的代码。调用者调用此函数时，只期望输出结果写入`output_file`，并不希望`pasture_types`列表被修改。函数没有理由修改它的列表参数。
- en: To produce the output, we need to call `write` with a string, not a list. And
    we need to output the strings from the list with no spaces between them. The string
    `join` method works wonderfully here. As we learned in “Joining a List into a
    String” in [Chapter 5](ch05.xhtml#ch05), the string that we call `join` on serves
    as the separator that’s placed between values in the list. Since we don’t want
    any separator between the values, we use an empty string as the separator ❷. The
    `join` method works only on a list of strings, not a list of integers, which is
    why I converted the list of integers to a list of strings at the start of this
    function ❶.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 为了输出结果，我们需要使用`write`函数传入一个字符串，而不是一个列表。而且我们需要将列表中的字符串输出，且它们之间不能有空格。`join`方法在这里非常有效。正如我们在[第5章](ch05.xhtml#ch05)的“将列表连接成字符串”部分所学，调用`join`的字符串作为分隔符，插入到列表中的值之间。由于我们不想在值之间加任何分隔符，因此我们使用空字符串作为分隔符❷。`join`方法只能作用于字符串列表，而不能作用于整数列表，这就是为什么我在这个函数开始时将整数列表转换为字符串列表❶。
- en: With the output as a single string, we can write it to the file ❸.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，输出已经是一个单一的字符串，我们可以将其写入文件❸。
- en: Putting It All Together
  id: totrans-318
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将所有内容整合起来
- en: The complete program is in [Listing 7-2](ch07.xhtml#ch07ex02).
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的程序在[清单 7-2](ch07.xhtml#ch07ex02)中。
- en: '[PRE50]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '*Listing 7-2: Solving Farm Seeding*'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-2：解决农场播种问题*'
- en: We did it! An intimidating problem, made more manageable by the application
    of top-down design. Feel free to submit our work to the USACO judge.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做到了！一个让人望而生畏的问题，通过自顶向下的设计变得更容易处理。可以放心地将我们的工作提交给USACO评审。
- en: It’s easy to be overwhelmed by a problem when you first read it. But remember
    that you don’t need to tackle it in one huge step. Break it down, solve each task
    that you can solve, and you’ll be well on your way to a solution for the overall
    problem. You’ve made huge strides in the amount of Python that you know and your
    ability to design programs and solve problems. Solving these problems is within
    your grasp!
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 初次阅读一个问题时，可能会感到不知所措。但记住，你不需要一次性完成所有的步骤。把问题分解开，解决你能解决的每个小任务，你就能为解决整体问题迈出重要的一步。你在Python知识和程序设计与问题解决能力方面已经取得了巨大的进展。解决这些问题触手可及！
- en: '**CONCEPT CHECK**'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念检查**'
- en: Let’s think about a new version of Farm Seeding where there’s no restriction
    on the number of cows that care about a pasture. A pasture might be the favorite
    of four cows, five cows, or even more. We’re still not allowed to give a cow two
    pastures with the same grass type.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个新的农场播种版本，在这个版本中，牧场不再有限制，允许多只奶牛关心一个牧场。一个牧场可能是四只奶牛、五只奶牛甚至更多的最爱。我们仍然不能给同一只奶牛分配两块草类型相同的牧场。
- en: Suppose that we’re solving this new version of the problem and have a test case
    where a pasture is the favorite of more than three cows. Which of the following
    is true of that test case?
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在解决这个新版本的问题，并且有一个测试用例，其中一个牧场是超过三只奶牛最喜欢的。在这个测试用例中，以下哪项是正确的？
- en: A. It’s *guaranteed* that there’s *no way* to solve it with only four grass
    types.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: A。*可以保证*仅使用四种草类型是*无法*解决这个问题的。
- en: B. There might be a way to solve it. If there is, it’s *possible* that our original
    solution ([Listing 7-2](ch07.xhtml#ch07ex02)) *will* do so.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: B。可能有一种解决方法。如果有的话，*可能*我们的原始解决方案（[清单 7-2](ch07.xhtml#ch07ex02)）*会*做到这一点。
- en: C. There might be a way to solve it. If there is, it’s *guaranteed* that our
    original solution ([Listing 7-2](ch07.xhtml#ch07ex02)) *will* do so.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: C。可能有一种解决方法。如果有的话，*可以保证*我们的原始解决方案（[清单 7-2](ch07.xhtml#ch07ex02)）*会*做到这一点。
- en: D. There might be a way to solve it. If there is, it’s *guaranteed* that our
    original solution ([Listing 7-2](ch07.xhtml#ch07ex02)) *won’t* do so.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: D。可能有一种解决方法。如果有的话，*可以保证*我们的原始解决方案（[清单 7-2](ch07.xhtml#ch07ex02)）*无法*做到这一点。
- en: 'Answer: B. We can find a test case that is correctly solved by our program,
    and we can find a test case that can be solved but not by our program. The former
    eliminates A and D as correct responses; the latter eliminates C as the correct
    response.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：B。我们可以找到一个能被我们的程序正确解决的测试用例，也可以找到一个能被解决但无法通过我们程序解决的测试用例。前者排除了A和D为正确答案；后者排除了C为正确答案。
- en: 'Here’s a test case that is correctly solved by our program:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个能被我们程序正确解决的测试用例：
- en: '[PRE51]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Each pasture is the favorite of four cows. Nevertheless, we can solve this test
    case using only two grass types. Try our program, and you should see that it correctly
    solves this test case.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 每个牧场都有四只奶牛最喜欢。尽管如此，我们可以仅使用两种草的类型来解决这个测试用例。试试我们的程序，你应该会看到它能够正确解决这个测试用例。
- en: 'Now here’s a test case that can be solved, but not by our program:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这里有一个能解决的问题，但不是通过我们的程序：
- en: '[PRE52]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The mistake that our program makes is to use grass type 1 for pasture 1\. In
    so doing, it’s forced to use grass type 5—which isn’t allowed!—for pasture 6\.
    Our program fails, but don’t conclude that there isn’t a way to solve this test
    case. In particular, use grass type 2 for pasture 1, and you should be able to
    find a way to solve this test case using only four grass types. It’s possible
    to solve these kinds of test cases with a more sophisticated program, and I encourage
    you to think about this on your own if you’re interested.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 我们程序的错误在于将草类型1分配给了牧场1。这样，它被迫将草类型5——这是不允许的！——分配给牧场6。我们的程序失败了，但不要因此得出没有办法解决这个测试用例的结论。特别是，可以将草类型2分配给牧场1，你应该能够找到只使用四种草类型来解决这个测试用例的方法。通过更复杂的程序来解决这类问题是可行的，如果你感兴趣，鼓励你自己思考一下。
- en: Summary
  id: totrans-338
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned how to open, read from, write to, and close files.
    Files are useful whenever you need to store information and use it as input later.
    They’re also useful for communicating information to your users. We also learned
    that we process files similarly to how we process standard input and standard
    output.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何打开、读取、写入和关闭文件。文件在你需要存储信息并稍后作为输入使用时非常有用。它们也在向用户传递信息时非常有用。我们还学到了如何像处理标准输入和标准输出一样处理文件。
- en: In the next chapter, we’ll learn how to store a collection of values in a Python
    set or dictionary. Storing a collection of values—that sounds like what a list
    does. We’ll see, though, that sets and dictionaries can make it easier for us
    to solve some kinds of problems.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何在Python集合或字典中存储一组值。存储一组值——听起来像是列表的功能。不过我们会发现，集合和字典可以帮助我们更轻松地解决某些问题。
- en: Chapter Exercises
  id: totrans-341
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 章节练习
- en: Here are some exercises for you to try. All of them are from the USACO judge
    and require reading and writing files. They’ll also require you to dust the cobwebs
    off material from previous chapters.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些练习，供你尝试。它们都是来自USACO的评审，要求你读取和写入文件。它们还会要求你复习前面章节中的一些知识点。
- en: USACO 2018 December Bronze Contest problem Mixing Milk
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: USACO 2018年12月铜奖竞赛问题 混合牛奶
- en: USACO 2017 February Bronze Contest problem Why Did the Cow Cross the Road
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: USACO 2017年2月铜奖竞赛问题 为什么牛要过马路
- en: USACO 2017 US Open Bronze Contest problem The Lost Cow
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: USACO 2017年美国公开赛铜奖竞赛问题 失踪的牛
- en: USACO 2019 December Bronze Contest problem Cow Gymnastics
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: USACO 2019年12月铜奖竞赛问题 牛体操
- en: USACO 2017 US Open Bronze Contest problem Bovine Genomics
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: USACO 2017年美国公开赛铜奖竞赛问题 牛基因组学
- en: USACO 2018 US Open Bronze Contest problem Team Tic Tac Toe
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: USACO 2018年美国公开赛铜奖竞赛问题 团队井字棋
- en: USACO 2019 February Bronze Contest problem Sleepy Cow Herding
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: USACO 2019年2月铜奖竞赛问题 昏昏欲睡的牛群
- en: Notes
  id: totrans-350
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释
- en: Essay Formatting is originally from the USACO 2020 January Bronze Contest. Farm
    Seeding is originally from the USACO 2019 February Bronze Contest.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 文章格式化最初来自USACO 2020年1月的铜奖竞赛。农场播种最初来自USACO 2019年2月的铜奖竞赛。
- en: There are many types of files besides text files. You might like to work with
    HTML files, Excel spreadsheets, PDF files, Word documents, or image files. Python
    can help! See *Automate the Boring Stuff with Python*, 2nd edition by Al Sweigart
    (No Starch Press, 2019) for much more information.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 除了文本文件，还有许多其他类型的文件。你可能想处理HTML文件、Excel电子表格、PDF文件、Word文档或图像文件。Python可以帮忙！欲了解更多信息，请参阅*《用Python自动化无聊的事》*，第二版，作者：Al
    Sweigart（No Starch Press出版社，2019年）。
- en: 'The “perhaps better poetry” line is from J. C. R. Licklider, as quoted in *Computers
    and the World of the Future*, edited by Martin Greenberger (MIT Press, 1962):'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 这句“或许更好的诗歌”出自J. C. R. Licklider的名言，引用自*《计算机与未来的世界》*，由马丁·格林伯格（Martin Greenberger）编辑（MIT出版社，1962年）：
- en: But some people write poetry in the language we speak. Perhaps better poetry
    will be written in the language of digital computers of the future than has ever
    been written in English.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 但有些人用我们说的语言写诗。或许将来用数字计算机的语言写出的诗，比用英语写的更好。
