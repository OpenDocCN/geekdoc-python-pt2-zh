- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Geometry
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 几何学
- en: '![](Images/circleart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/circleart.png)'
- en: We humans have a deep, intuitive grasp of geometry. Every time we maneuver a
    couch through a hallway, draw a picture in *Pictionary*, or judge how far away
    another car on the highway is, we’re engaging in some kind of geometric reasoning,
    often depending on algorithms that we’ve unconsciously mastered. By now, you won’t
    be surprised to learn that advanced geometry is a natural fit for algorithmic
    reasoning.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们人类对几何学有着深刻的直觉理解。每当我们在走廊中搬动沙发、玩*Pictionary*时，或者判断高速公路上另一辆车的距离时，我们都在进行某种几何推理，通常依赖于我们潜意识中掌握的算法。到目前为止，你可能不会惊讶地发现，进阶的几何学与算法推理自然契合。
- en: In this chapter, we’ll use a geometric algorithm to solve the postmaster problem.
    We’ll begin with a description of the problem and see how we can solve it using
    Voronoi diagrams. The rest of the chapter explains how to algorithmically generate
    this solution.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将使用几何算法来解决邮局问题。我们将从问题描述开始，看看如何使用 Voronoi 图来解决它。接下来的内容将解释如何通过算法生成这一解决方案。
- en: The Postmaster Problem
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 邮局问题
- en: Imagine that you are Benjamin Franklin, and you have been appointed the first
    postmaster general of a new nation. The existing independent post offices had
    been built haphazardly as the nation grew, and your job is to turn these chaotic
    parts into a well-functioning whole. Suppose that in one town, four post offices
    are placed among the homes, as in [Figure 7-1](#figure7-1).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你是本杰明·富兰克林，并且你被任命为一个新国家的首任邮政总局长。随着国家的发展，原有的独立邮局是随意建立的，你的工作是将这些混乱的部分整合成一个高效运作的整体。假设在一个城镇中，四个邮局分布在各个住宅区，如同[图
    7-1](#figure7-1)所示。
- en: '![figure_7_1](Images/figure_7-1.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![figure_7_1](Images/figure_7-1.png)'
- en: '[Figure 7-1:](#figureanchor7-1) A town and its post offices'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-1：](#figureanchor7-1) 一个城镇及其邮局'
- en: Since there has never been a postmaster in your new nation, there has been no
    oversight to optimize the post offices’ deliveries. It could be that post office
    4 is assigned to deliver to a home that’s closer to post offices 2 and 3, and
    at the same time post office 2 is assigned to deliver to a home that’s closer
    to post office 4, as in [Figure 7-2](#figure7-2).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在你的新国家从未有过邮政总局长，因此没有人监督优化邮局的送达工作。可能是邮局 4 被分配给一个距离邮局 2 和 3 更近的家庭，而与此同时，邮局 2
    却被分配给了一个离邮局 4 更近的家庭，如同[图 7-2](#figure7-2)所示。
- en: '![figure_7_2](Images/figure_7-2.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![figure_7_2](Images/figure_7-2.png)'
- en: '[Figure 7-2:](#figureanchor7-2) Post offices 2 and 4 have inefficient assignments.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-2：](#figureanchor7-2) 邮局 2 和 4 的分配效率低。'
- en: 'You can rearrange the delivery assignments so that each home receives deliveries
    from the ideal post office. The ideal post office for a delivery assignment could
    be the one with the most free staff, the one that possesses suitable equipment
    for traversing an area, or the one with the institutional knowledge to find all
    the addresses in an area. But probably, the ideal post office for a delivery assignment
    is simply the closest one. You may notice that this is similar to the traveling
    salesman problem (TSP), at least in the sense that we are moving objects around
    a map and want to decrease the distance we have to travel. However, the TSP is
    the problem of one traveler optimizing the order of a set route, while here you
    have the problem of many travelers (letter carriers) optimizing the assignment
    of many routes. In fact, this problem and the TSP can be solved consecutively
    for maximum gain: after you make the assignments of which post office should deliver
    to which homes, the individual letter carriers can use the TSP to decide the order
    in which to visit those homes.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以重新安排送达任务，使得每个家庭都能从理想的邮局接收邮件。一个送达任务的理想邮局可能是员工最多的邮局、拥有适合穿越某区域的设备的邮局，或者是拥有能够找到该区域内所有地址的机构知识的邮局。但最可能的是，送达任务的理想邮局只是最靠近的那个。你可能会注意到，这与旅行商问题（TSP）类似，至少在我们需要在地图上移动物体并希望减少旅行距离的方面。然而，TSP
    是一个优化路线顺序的旅行者问题，而在这里，你面临的是多个旅行者（投递员）优化多个路线分配的问题。实际上，这个问题和 TSP 可以连续解决，以获得最大的收益：在你完成哪些邮局应送达哪些家庭的任务分配后，个别的投递员可以使用
    TSP 来决定访问这些家庭的顺序。
- en: The simplest approach to this problem, which we might call the *postmaster problem*,
    is to consider each house in turn, calculating the distance between the house
    and each of the four post offices, and assigning the closest post office to deliver
    to the house in question.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的最简单方法，我们可以称之为*邮递员问题*，是依次考虑每座房子，计算房子与四个邮局之间的距离，并将最近的邮局分配给该房子。
- en: This approach has a few weaknesses. First, it does not provide an easy way to
    make assignments when new houses are built; every newly built house has to go
    through the same laborious process of comparison with every existing post office.
    Second, doing calculations at the individual house level does not allow us to
    learn about a region as a whole. For example, maybe an entire neighborhood lies
    within the shadow of one post office but lies many miles away from all other post
    offices. It would be best to conclude in one step that the whole neighborhood
    should be served by the same close post office. Unfortunately, our method requires
    us to repeat the calculation for every house in the neighborhood, only to get
    the same result each time.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有一些弱点。首先，它没有提供一种简单的方式来分配新建房屋；每一座新建的房子必须通过与每个现有邮局的比较，经历同样繁琐的过程。其次，在单独为每个房子做计算时，我们无法了解整个区域的情况。例如，也许某个社区的整个区域都处在某个邮局的覆盖范围内，但却远离其他邮局。最好在一步中得出结论，认为整个社区应该由同一个邻近的邮局提供服务。不幸的是，我们的方法要求我们对社区内的每座房子重复计算，最后得到相同的结果。
- en: By calculating distances for each house individually, we’re repeating work that
    we wouldn’t have to do if we could somehow make generalizations about entire neighborhoods
    or regions. And that work will add up. In megacities of tens of millions of inhabitants,
    with many post offices and quick construction rates like we see today around the
    world, this approach would be unnecessarily slow and computing-resource-heavy.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 通过为每座房子单独计算距离，我们在重复做一些不必要的工作，如果我们能对整个社区或区域做出一些概括的话，就不需要做这些工作。而且这些工作会逐渐累积。在拥有数千万居民的超级城市中，考虑到如今世界各地许多邮局以及快速的建筑速度，这种方法会显得不必要地慢且消耗大量计算资源。
- en: A more elegant approach would be to consider the map as a whole and separate
    it into distinct regions, each of which represents one post office’s assigned
    service area. By drawing just two straight lines, we can accomplish that with
    our hypothetical town ([Figure 7-3](#figure7-3)).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 更优雅的方法是将地图整体考虑，并将其划分为不同的区域，每个区域代表一个邮局的服务区域。通过仅绘制两条直线，我们就可以完成这一任务，就像我们假设的小镇（[图
    7-3](#figure7-3)）一样。
- en: The regions we have drawn indicate areas of closest proximity, meaning that
    for every single house, point, and pixel, the closest post office is the one that
    shares its region. Now that the entire map is subdivided, we can easily assign
    any new construction to its closest post office simply by checking which region
    it’s in.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们绘制的区域表示最近邻的区域，这意味着对于每一座房子、每一个点和每一个像素，最近的邮局就是与它共享同一区域的邮局。现在，整个地图已被细分，我们可以通过简单地检查某个区域来轻松地将任何新的建筑分配到它最近的邮局。
- en: A diagram that subdivides a map into regions of closest proximity, as ours does,
    is called a *Voronoi diagram*. Voronoi diagrams have a long history going all
    the way back to René Descartes. They were used to analyze water pump placement
    in London to provide evidence for how cholera was spread, and they’re still used
    in physics and materials science to represent crystal structures. This chapter
    will introduce an algorithm for generating a Voronoi diagram for any set of points,
    thereby solving the postmaster problem.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 将地图细分为最近邻区域的图形，正如我们所做的那样，叫做*Voronoi 图*。Voronoi 图有着悠久的历史，早在勒内·笛卡尔时期就已出现。它们曾被用来分析伦敦水泵的布置，为霍乱传播的方式提供证据，至今仍广泛应用于物理学和材料科学中，用于表示晶体结构。本章将介绍一种为任意一组点生成
    Voronoi 图的算法，从而解决邮递员问题。
- en: '![figure_7_3](Images/figure_7-3.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![figure_7_3](Images/figure_7-3.png)'
- en: '[Figure 7-3:](#figureanchor7-3) Voronoi diagram separating our town into optimal
    postal delivery regions'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-3：](#figureanchor7-3) Voronoi 图将我们的城市划分为最佳邮政配送区域'
- en: Triangles 101
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 三角形基础 101
- en: 'Let’s back up and start with the simplest elements of the algorithms we’ll
    explore. We’re working in geometry, in which the simplest element of analysis
    is the point. We’ll represent points as lists with two elements: an x-coordinate
    and a y-coordinate, like the following example:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回过头来，从我们将要探索的算法的最简单元素开始。我们正在研究几何学，其中最简单的分析元素是点。我们将点表示为具有两个元素的列表：一个x坐标和一个y坐标，如以下示例所示：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'At the next level of complexity, we combine points to form triangles. We’ll
    represent a triangle as a list of three points:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个复杂度级别，我们将点组合成三角形。我们将三角形表示为由三个点组成的列表：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let’s also define a helper function that can convert a set of three disparate
    points into a triangle. All this little function does is collect three points
    into a list and return the list:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以定义一个辅助函数，将三个不相干的点转换为一个三角形。这个小函数所做的只是将三个点收集到一个列表中，并返回该列表：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'It will be helpful to be able to visualize the triangles we’re working with.
    Let’s create a simple function that will take any triangle and plot it. First,
    we’ll use the `genlines()` function that we defined in Chapter 6\. Remember that
    this function takes a collection of points and converts them into lines. Again,
    it’s a very simple function, just appending points to a list called `lines`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 能够可视化我们正在处理的三角形会很有帮助。让我们创建一个简单的函数，它可以接收任何三角形并将其绘制出来。首先，我们将使用在第6章中定义的`genlines()`函数。记住，这个函数接收一组点并将它们转换为直线。再一次，这是一个非常简单的函数，只是将点附加到一个名为`lines`的列表中：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Next, we’ll create our simple plotting function. It will take a triangle we
    pass to it, split it into its *x* and *y* values, call `genlines()` to create
    a collection of lines based on those values, plot the points and lines, and finally
    save the figure to a .*png* file. It uses the `pylab` module for plotting and
    code from the `matplotlib` module to create the line collection. [Listing 7-1](#listing7-1)
    shows this function.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个简单的绘图函数。它将接收我们传递给它的三角形，拆分其* x *和* y *值，调用`genlines()`来根据这些值创建一组直线，绘制点和直线，最后将图像保存为.*png*文件。它使用`pylab`模块进行绘图，并使用`matplotlib`模块中的代码来创建直线集合。[列表
    7-1](#listing7-1)展示了这个函数。
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[Listing 7-1:](#listinganchor7-1) A function for plotting triangles'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 7-1:](#listinganchor7-1) 绘制三角形的函数'
- en: 'Now, we can select three points, convert them to a triangle, and plot the triangle,
    all in one line:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以选择三个点，将它们转换为三角形，并在一行代码中绘制该三角形：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[Figure 7-4](#figure7-4) shows the output.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-4](#figure7-4)展示了输出结果。'
- en: '![figure_7-4](Images/figure_7-4.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![figure_7-4](Images/figure_7-4.png)'
- en: '[Figure 7-4:](#figureanchor7-4) A humble triangle'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-4:](#figureanchor7-4) 一个简朴的三角形'
- en: 'It will also come in handy to have a function that allows us to calculate the
    distance between any two points using the Pythagorean theorem:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，拥有一个函数来计算任何两个点之间的距离也会很有用，使用的是勾股定理：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, a reminder of the meaning of some common terms in geometry:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，提醒一下几种常见几何术语的含义：
- en: '**Bisect** To divide a line into two equal segments. Bisecting a line finds
    its midpoint.'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**平分** 将一条线分成两个相等的部分。平分一条线找到它的中点。'
- en: '**Equilateral** Meaning “equal sides.” We use this term to describe a shape
    in all which all sides have equal length.'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**等边** 意思是“边长相等”。我们用这个术语来描述所有边长相等的形状。'
- en: '**Perpendicular** The way we describe two lines that form a 90-degree angle.'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**垂直** 我们描述两条形成90度角的直线的方式。'
- en: '**Vertex** The point at which two edges of a shape meet.'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**顶点** 形状中两条边相交的点。'
- en: Advanced Graduate-Level Triangle Studies
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级研究生级别的三角形研究
- en: The scientist and philosopher Gottfried Wilhelm Leibniz thought that our world
    was the best of all possible worlds because it was the “simplest in hypotheses
    and richest in phenomena.” He thought that the laws of science could be boiled
    down to a few simple rules but that those rules led to the complex variety and
    beauty of the world we observe. This may not be true for the universe, but it
    is certainly true for triangles. Starting with something that is extremely simple
    in hypothesis (the idea of a shape with three sides), we enter a world that is
    extremely rich in phenomena.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 科学家和哲学家戈特弗里德·威廉·莱布尼茨认为，我们的世界是所有可能世界中最好的，因为它是“假设最简单、现象最丰富的”。他认为，科学的规律可以归结为几条简单的规则，而这些规则却能引发我们所观察到的世界的复杂多样性和美丽。虽然这可能不适用于整个宇宙，但对于三角形来说却完全正确。从一个假设极为简单的东西开始（即具有三条边的形状的概念），我们进入了一个现象极其丰富的世界。
- en: Finding the Circumcenter
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 寻找外接圆心
- en: 'To begin to see the richness of the phenomena of the world of triangles, consider
    the following simple algorithm, which you can try with any triangle:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始看到三角形世界现象的丰富性，考虑以下简单的算法，你可以用任何三角形来尝试：
- en: Find the midpoint of each side of the triangle.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找出三角形每条边的中点。
- en: Draw a line from each vertex of the triangle to the midpoint of the vertex’s
    opposite side.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从三角形的每个顶点画一条线，连接到该顶点对面的边的中点。
- en: After you follow this algorithm, you will see something like [Figure 7-5](#figure7-5).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在你遵循这个算法后，你会看到类似[图 7-5](#figure7-5)的情况。
- en: '![figure_7_5](Images/figure_7-5.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![figure_7_5](Images/figure_7-5.png)'
- en: '[Figure 7-5:](#figureanchor7-5) Triangle centroid (source Wikimedia Commons)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-5:](#figureanchor7-5) 三角形重心（来源：Wikimedia Commons）'
- en: Remarkably, all the lines you drew meet in a single point that looks something
    like the “center” of the triangle. All three lines will meet at a single point
    no matter what triangle you start with. The point where they meet is commonly
    called the *centroid* of the triangle, and it’s always on the inside in a place
    that looks like it could be called the triangle’s center.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，你画的所有线条都汇聚在一个点上，这个点看起来像是三角形的“中心”。无论你从哪个三角形开始，这三条线都会汇聚到一个点。它们汇聚的点通常被称为三角形的*重心*，并且总是位于三角形的内部，像是可以被称为三角形中心的地方。
- en: 'Some shapes, like circles, always have one point that can unambiguously be
    called the shape’s center. But triangles aren’t like this: the centroid is one
    center-ish point, but there are other points that could also be considered centers.
    Consider this new algorithm for any triangle:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 有些形状，如圆形，总是有一个明确的点可以称为形状的中心。但三角形不是这样的：重心是一个可以称为三角形中心的点，但也有其他点也可以被视为中心。考虑这个新的算法，适用于任何三角形：
- en: Bisect each side of the triangle.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将三角形的每条边平分。
- en: Draw a line perpendicular to each side through the side’s midpoint.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 画一条垂直于每条边的线，穿过该边的中点。
- en: In this case, the lines do not typically go through the vertices like they did
    when we drew a centroid. Compare [Figure 7-5](#figure7-5) with [Figure 7-6](#figure7-6).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，这些线条通常不像我们绘制重心时那样穿过顶点。比较[图 7-5](#figure7-5)与[图 7-6](#figure7-6)。
- en: '![figure_7_6](Images/figure_7-6.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![figure_7_6](Images/figure_7-6.png)'
- en: '[Figure 7-6:](#figureanchor7-6) Triangle circumcenter (source: Wikimedia Commons)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-6:](#figureanchor7-6) 三角形外接圆心（来源：Wikimedia Commons）'
- en: 'Notice that the lines do all meet, again in a point that is not the centroid,
    but is often inside the triangle. This point has another interesting property:
    it’s the center of the unique circle that goes through all three vertices of our
    triangle. Here is another of the rich phenomena related to triangles: every triangle
    has one unique circle that goes through all three of its points. This circle is
    called the *circumcircle* because it is the circle that circumscribes the triangle.
    The algorithm we just outlined finds the center of that circumcircle. For this
    reason, the point where all three of these lines meet is called the *circumcenter*.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这些线确实会汇聚，再次汇聚到一个点，这个点不是重心，但通常在三角形内部。这个点有另一个有趣的性质：它是通过三角形所有三个顶点的唯一圆的圆心。这里是与三角形相关的另一个丰富现象：每个三角形都有一个唯一的圆，经过它的所有三个点。这个圆被称为*外接圆*，因为它是包围三角形的圆。我们刚才概述的算法找到了那个外接圆的圆心。正因为如此，这三条线的交点被称为*外接圆心*。
- en: Like the centroid, the circumcenter is a point that could be called the center
    of a triangle, but they are not the only candidates—an encyclopedia at *https://faculty.evansville.edu/ck6/encyclopedia/ETC.html*
    contains a list of 40,000 (so far) points that could be called triangle centers
    for one reason or another. As the encyclopedia itself says, the definition of
    a triangle center is one that “is satisfied by infinitely many objects, of which
    only finitely many will ever be published.” Remarkably, starting with three simple
    points and three straight sides, we get a potentially infinite encyclopedia of
    unique centers—Leibniz would be so pleased.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 像重心一样，外接圆心是一个可以称为三角形中心的点，但它们并不是唯一的候选点——一本名为*https://faculty.evansville.edu/ck6/encyclopedia/ETC.html*的百科全书列出了40,000个（迄今为止）因各种原因可以称为三角形中心的点。正如百科全书本身所说，三角形中心的定义是“满足无穷多对象的条件，其中只有有限的对象会被发布。”令人惊讶的是，从三个简单的点和三条直线开始，我们得到了一个可能无限的独特中心百科全书——莱布尼茨一定会非常高兴。
- en: 'We can write a function that finds the circumcenter and *circumradius* (the
    radius of the circumcircle) for any given triangle. This function relies on conversion
    to complex numbers. It takes a triangle as its input and returns a center and
    a radius as its output:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写一个函数，找到任意给定三角形的外心和*外接半径*（外接圆的半径）。该函数依赖于转换为复数。它以一个三角形作为输入，并返回一个中心和半径作为输出：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The specific details of how this function calculates the center and radius are
    complex. We won’t dwell on it here, but I encourage you to walk through the code
    on your own, if you’d like.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数计算中心和半径的具体细节比较复杂。我们在这里不深入讨论，但如果你愿意，可以自己逐步查看代码。
- en: Increasing Our Plotting Capabilities
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 增强我们的绘图功能
- en: Now that we can find a circumcenter and a circumradius for every triangle, let’s
    improve our `plot_triangle()` function so it can plot everything. [Listing 7-2](#listing7-2)
    shows the new function.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经可以为每个三角形找到外心和外接半径了，让我们改进 `plot_triangle()` 函数，使其能够绘制所有内容。[清单 7-2](#listing7-2)
    显示了新函数。
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[Listing 7-2:](#listinganchor7-2) Our improved `plot_triangle()` function,
    which plots the circumcenter and cicrumcircle'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 7-2:](#listinganchor7-2) 我们改进后的 `plot_triangle()` 函数，绘制外心和外接圆'
- en: 'We start by adding two new arguments: a `centers` variable that’s a list of
    the respective circumcenters of all triangles, and a `radii` variable that’s a
    list of the radius of every triangle’s circumcircle. Note that we take arguments
    that consist of lists, since this function is meant to draw multiple triangles
    instead of just one triangle. We’ll use `pylab`’s circle-drawing capabilities
    to draw the circles. Later, we’ll be working with multiple triangles at the same
    time. It will be useful to have a plotting function that can plot multiple triangles
    instead of just one. We’ll put a loop in our plotting function that will loop
    through every triangle and center and plot each of them successively.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从添加两个新的参数开始：一个 `centers` 变量，它是所有三角形外心的列表，另一个 `radii` 变量，它是每个三角形外接圆半径的列表。请注意，我们传入的是由列表组成的参数，因为这个函数是为了绘制多个三角形，而不仅仅是一个三角形。我们将使用
    `pylab` 的圆形绘制功能来绘制这些圆。以后，我们将同时处理多个三角形。为了能够绘制多个三角形而不是一个，我们将在绘图函数中加入一个循环，遍历每个三角形及其外心，并依次绘制它们。
- en: 'We can call this function with a list of triangles that we define:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用我们定义的三角形列表调用这个函数：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Our output is shown in [Figure 7-7](#figure7-7).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的输出如[图 7-7](#figure7-7)所示。
- en: '![figure_7-7](Images/figure_7-7.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![figure_7-7](Images/figure_7-7.png)'
- en: '[Figure 7-7:](#figureanchor7-7) Two triangles with circumcenter and circumcircles'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-7:](#figureanchor7-7) 两个带有外心和外接圆的三角形'
- en: Notice that our first triangle is close to equilateral. Its circumcircle is
    small and its circumcenter lies within it. Our second triangle is a narrow, sliver
    triangle. Its circumcircle is large and its circumcenter is far outside the plot
    boundaries. Every triangle has a unique circumcircle, and different triangle shapes
    lead to different kinds of circumcircles. It could be worthwhile to explore different
    triangle shapes and the circumcircles they lead to on your own. Later, the differences
    between these triangles’ circumcircles will be important.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们的第一个三角形接近等边三角形。它的外接圆很小，外心位于外接圆内。我们的第二个三角形是一个狭长的三角形。它的外接圆很大，外心远离图形边界。每个三角形都有一个独特的外接圆，不同的三角形形状会导致不同类型的外接圆。你可能会发现自己可以独立探索不同的三角形形状及其相应的外接圆。稍后，这些三角形外接圆之间的差异将变得很重要。
- en: Delaunay Triangulation
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 德劳内三角剖分
- en: We’re ready for the first major algorithm of this chapter. It takes a set of
    points as its input and returns a set of triangles as its output. In this context,
    turning a set of points into a set of triangles is called *triangulation*.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们准备好进入本章的第一个主要算法了。它接受一组点作为输入，并返回一组三角形作为输出。在这个上下文中，将一组点转化为一组三角形被称为*三角剖分*。
- en: 'The `points_to_triangle()` function we defined near the beginning of the chapter
    is the simplest possible triangulation algorithm. However, it’s quite limited
    because it works only if we give it exactly three input points. If we want to
    triangulate three points, there’s only one possible way to do so: output a triangle
    consisting of exactly those three points. If we want to triangulate more than
    three points, there will inevitably be more than one way to triangulate. For example,
    consider the two distinct ways to triangulate the same seven points shown in [Figure
    7-8](#figure7-8).'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章开始时定义的`points_to_triangle()`函数是最简单的三角剖分算法。然而，它非常有限，因为它仅在我们输入恰好三个点时才有效。如果我们要对三个点进行三角剖分，只有一种可能的方式：输出一个由这三点构成的三角形。如果我们要对超过三个点进行三角剖分，必然会有多种方法。例如，考虑[图
    7-8](#figure7-8)中展示的对相同七个点的两种不同的三角剖分方式。
- en: '![figure_7_8](Images/figure_7-8.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![figure_7_8](Images/figure_7-8.png)'
- en: '[Figure 7-8:](#figureanchor7-8) Two different ways to triangulate seven points
    (Wikimedia Commons)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-8:](#figureanchor7-8) 两种不同的七点三角剖分方式（来自维基共享资源）'
- en: In fact, there are 42 possible ways to triangulate this regular heptagon [Figure
    7-9](#figure7-9)).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，有42种可能的方式来对这个规则的七边形进行三角剖分，[图 7-9](#figure7-9)展示了这些方式。
- en: '![figure_7_9](Images/figure_7-9.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![figure_7_9](Images/figure_7-9.png)'
- en: '[Figure 7-9:](#figureanchor7-9) All 42 possible ways to triangulate seven points
    (source: Wikipedia)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-9:](#figureanchor7-9) 所有42种可能的七点三角剖分方式（来源：维基百科）'
- en: If you have more than seven points and they are irregularly placed, the number
    of possible triangulations can rise to staggering magnitudes.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有超过七个点，并且它们的位置不规则，可能的三角剖分数量会达到惊人的数量级。
- en: We can accomplish triangulation manually by getting pen and paper and connecting
    dots. Unsurprisingly, we can do it better and faster by using an algorithm.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过拿起笔和纸手动进行三角剖分。毫不奇怪，我们通过使用算法可以做得更好更快。
- en: There are a several different triangulation algorithms. Some are meant to have
    a quick runtime, others are meant to be simple, and still others are meant to
    yield triangulations that have specific desirable properties. What we’ll cover
    here is called the *Bowyer-Watson algorithm*, and it’s designed to take a set
    of points as its input and output a Delaunay triangulation.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种不同的三角剖分算法。有些算法旨在快速运行，有些则注重简单性，还有一些旨在得到具有特定优良性质的三角剖分。我们将在这里讨论的是*Bowyer-Watson算法*，它的设计目的是接受一组点作为输入并输出德劳内三角剖分。
- en: 'A *Delaunay triangulation (DT)* aims to avoid narrow, sliver triangles. It
    tends to output triangles that are somewhere close to equilateral. Remember that
    equilateral triangles have relatively small circumcircles and sliver triangles
    have relatively large circumcircles. With that in mind, consider the technical
    definition of a DT: for a set of points, it is the set of triangles connecting
    all the points in which no point is inside the circumcircle of any of the triangles.
    The large circumcircles of sliver triangles would be very likely to encompass
    one or more of the other points in the set, so a rule stating that no point can
    be inside any circumcircle leads to relatively few sliver triangles. If this is
    unclear, don’t fret—you’ll see it visualized in the next section.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*德劳内三角剖分（DT）*旨在避免狭长的细三角形。它倾向于输出接近等边三角形的三角形。记住，等边三角形的外接圆相对较小，而细长三角形的外接圆相对较大。考虑德劳内三角剖分的技术定义：对于一组点，它是连接所有点的三角形集，其中没有任何点位于任何三角形的外接圆内。细长三角形的大外接圆很可能会包含集合中的一个或多个其他点，因此规定没有点可以位于任何外接圆内，导致了相对较少的细长三角形。如果这一点不清楚，不要担心——你将在下一节看到可视化的解释。'
- en: Incrementally Generating Delaunay Triangulations
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 增量生成德劳内三角剖分
- en: 'Our eventual goal is to write a function that will take any set of points and
    output a full Delaunay triangulation. But let’s start with something simple: we’ll
    write a function that takes an existing DT of *n* points and also one point that
    we want to add to it, and outputs a DT of *n* + 1 points. This “Delaunay expanding”
    function will get us very close to being able to write a full DT function.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终的目标是编写一个函数，接受任何一组点并输出完整的德劳内三角剖分。但让我们从简单的开始：我们将编写一个函数，接受一个已有的*n*点的DT，以及一个我们想要添加进去的点，并输出一个*n*
    + 1点的DT。这个“德劳内扩展”函数将使我们非常接近能够编写完整的DT函数。
- en: First, suppose that we already have the DT of nine points shown in [Figure 7-10](#figure7-10).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，假设我们已经得到了[图 7-10](#figure7-10)中展示的九个点的DT。
- en: Now suppose we want to add a 10th point to our DT ([Figure 7-11](#figure7-11)).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'A DT has only one rule: no point can lie within a circumcircle of any of its
    triangles. So we check the circumcircle of every circle in our existing DT, to
    determine whether point 10 lies within any of them. We find that point 10 lies
    within the circumcircles of three triangles ([Figure 7-12](#figure7-12)).'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '![figure_7-10](Images/figure_7-10.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
- en: '[Figure 7-10:](#figureanchor7-10) A DT with nine points'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '![figure_7-11](Images/figure_7-11.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
- en: '[Figure 7-11:](#figureanchor7-11) A 9-point DT with the 10th point we want
    to add'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '![figure_7-12](Images/figure_7-12.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
- en: '[Figure 7-12:](#figureanchor7-12) Three triangles in the DT have circumcircles
    containing point 10.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: These triangles are no longer allowed to be in our DT, so we will remove them,
    yielding [Figure 7-13](#figure7-13).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '![figure_7-13](Images/figure_7-13.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
- en: '[Figure 7-13:](#figureanchor7-13) We have removed the invalid triangles.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'We haven’t finished yet. We need to fill in the hole that we’ve created and
    make sure that point 10 is properly connected to the other points. If we don’t,
    then we won’t have a collection of triangles, we’ll just have points and lines.
    The way we connect point 10 can be described simply: add an edge connecting point
    10 to every vertex of the largest empty polygon that point 10 lies within ([Figure
    7-14](#figure7-14)).'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '![figure_7-14](Images/figure_7-14.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
- en: '[Figure 7-14:](#figureanchor7-14) Completing the 10-point DT by reconnecting
    valid triangles'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Voilà! We started with a 9-point DT, added a new point, and now have a 10-point
    DT. This process may seem straightforward. Unfortunately, as is often the case
    with geometric algorithms, what seems clear and intuitive to the human eye can
    be tricky to write code for. But let’s not allow this to deter us, brave adventurers.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Delaunay Triangulations
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s start by assuming that we already have a DT, which we’ll call `delaunay`.
    It will be nothing more than a list of triangles. We can even start with one triangle
    alone:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, we’ll define a point that we want to add to it, called `point_to_add`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We first need to determine which, if any, triangles in the existing DT are
    now invalid because their circumcircle contains the `point_to_add`. We’ll do the
    following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Use a loop to iterate over every triangle in the existing DT.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each triangle, find the circumcenter and radius of its circumcircle.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the distance between the `point_to_add` and this circumcenter.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If this distance is less than the circumradius, then the new point is inside
    the triangle’s circumcircle. We can then conclude this triangle is invalid and
    needs to be removed from the DT.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can accomplish these steps with the following code snippet:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This snippet creates an empty list called `invalid_triangles`, loops through
    every triangle in our existing DT, and checks whether a particular triangle is
    invalid. It does this by checking whether the distance between the `point_to_add`
    and the circumcenter is less than the circumcircle’s radius. If a triangle is
    invalid, we append it to the `invalid_triangles` list.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码片段创建了一个名为 `invalid_triangles` 的空列表，遍历我们现有 DT 中的每个三角形，并检查某个三角形是否无效。它通过检查
    `point_to_add` 与外接圆心的距离是否小于外接圆的半径来判断。如果某个三角形无效，我们就将它添加到 `invalid_triangles` 列表中。
- en: Now we have a list of invalid triangles. Since they are invalid, we want to
    remove them. Eventually, we’ll also need to add new triangles to our DT. To do
    that, it will help to have a list of every point that is in one of the invalid
    triangles, as those points will be in our new, valid triangles.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一份无效三角形的列表。由于它们无效，我们想要移除它们。最终，我们还需要向 DT 中添加新的三角形。为了做到这一点，拥有一个包含所有无效三角形中点的列表将非常有帮助，因为这些点将出现在我们的新有效三角形中。
- en: Our next code snippet removes all invalid triangles from our DT, and we also
    get a collection of the points that make them up.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的代码片段将从我们的 DT 中移除所有无效的三角形，同时还会获取构成它们的点的集合。
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We first create an empty list called `points_in_invalid`. Then, we loop through
    `invalid_triangles`, using Python’s `remove()` method to take each invalid triangle
    out of the existing DT. We then loop through every point in the triangle to add
    it to the `points_in_invalid` list. Finally, since we may have added some duplicate
    points to the `points_in_invalid` list, we’ll use a list comprehension 1 to re-create
    `points_in_invalid` with only unique values.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个空列表，名为 `points_in_invalid`。然后，我们遍历 `invalid_triangles`，使用 Python 的 `remove()`
    方法将每个无效的三角形从现有的 DT 中删除。接着，我们遍历每个三角形中的点，并将它们添加到 `points_in_invalid` 列表中。最后，由于我们可能已将一些重复的点添加到
    `points_in_invalid` 列表中，我们将使用列表推导式 1 来重新创建 `points_in_invalid`，确保只包含唯一的值。
- en: The final step in our algorithm is the trickiest one. We have to add new triangles
    to replace the invalid ones. Each new triangle will have the `point_to_add` as
    one of its points, and and two points from the existing DT as its other points.
    However, we can’t add every possible combination of `point_to_add` and two existing
    points.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们算法的最后一步是最棘手的一步。我们必须添加新的三角形来替换无效的三角形。每个新三角形将包含 `point_to_add` 作为其中一个点，并且另外两个点来自现有的
    DT。然而，我们不能添加 `point_to_add` 和两个现有点的每一种可能组合。
- en: In Figures [7-13](#figure7-13) and [7-14](#figure7-14), notice that the new
    triangles we needed to add were all triangles with point 10 as one of their points,
    and with edges selected from the empty polygon that contained point 10\. This
    may seem simple enough after a visual check, but it’s not straightforward to write
    code for it.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在图 [7-13](#figure7-13) 和 [7-14](#figure7-14) 中，请注意我们需要添加的新三角形都是以点 10 作为其中一个顶点，并且边是从包含点
    10 的空多边形中选择的。经过视觉检查后，这看起来很简单，但要为其编写代码并不直接。
- en: We need to find a simple geometric rule that can be easily explained in Python’s
    hyper-literal style of interpretation. Think of the rules that could be used to
    generate the new triangles in [Figure 7-14](#figure7-14). As is common in mathematical
    situations, we could find multiple equivalent sets of rules. We could have rules
    related to points, since one definition of a triangle is a set of three points.
    We could have other rules related to lines, since another, equivalent definition
    of triangles is a set of three line segments. We could use any set of rules; we
    just want the one that will be the simplest to understand and implement in our
    code. One possible rule is that we should consider every possible combination
    of points in the invalid triangles with the `point_to_add`, but we should add
    one of those triangles only if the edge not containing the `point_to_add` occurs
    exactly once in the list of invalid triangles. This rule works because the edges
    that occur exactly once will be the edges of the outer polygon surrounding the
    new point (in [Figure 7-13](#figure7-13), the edges in question are the edges
    of the polygon connecting points 1, 4, 8, 7, and 3).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code implements this rule:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here we loop through every point in `points_in_invalid`. For each one, we loop
    through every following point in `points_in_invalid`. This double loop enables
    us to consider every combination of two points that was in an invalid triangle.
    For each combination, we loop through all the invalid triangles and count how
    many times those two points are together in an invalid triangle. If they are together
    in exactly one invalid triangle, then we conclude that they should be together
    in one of our new triangles, and we add a new triangle to our DT that consists
    of those two points together with our new point.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'We have completed the steps that are required to add a new point to an existing
    DT. So we can take a DT that has *n* points, add a new point, and end up with
    a DT that has *n* + 1 points. Now, we need to learn to use this capability to
    take a set of *n* points and build a DT from scratch, from zero points all the
    way to *n* points. After we get the DT started, it’s really quite simple: we just
    need to loop through the process that goes from *n* points to *n* + 1 points over
    and over until we have added all of our points.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'There is just one more complication. For reasons that we’ll discuss later,
    we want to add three more points to the collection of points whose DT we’re generating.
    These points will lie far outside our chosen points, which we can ensure by finding
    the uppermost and leftmost points, adding a new point that is higher and farther
    left than either of those, and doing similarly for the lowermost and rightmost
    points and the lowermost and leftmost points. We’ll se these points together as
    the first triangle of our DT. We’ll start with a DT that connects three points:
    the three points in the new triangle just mentioned. Then, we’ll follow the logic
    that we’ve already seen to turn a three-point DT into a four-point DT, then into
    a five-point DT, and so on until we’ve added all of our points.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 7-3](#listing7-3), we can combine the code we wrote earlier to create
    a function called `gen_delaunay()`, which takes a set of points as its input and
    outputs a full DT.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[Listing 7-3:](#listinganchor7-3) A function that takes a set of points and
    returns a Delaunay triangulation'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'The full DT generation function starts by adding the new outside triangle mentioned
    earlier. It then loops through every point in our collection of points 1. For
    every point, it creates a list of invalid triangles: every triangle that’s in
    the DT whose circumcircle includes the point we’re currently looking at 2. It
    removes those invalid triangles from the DT and creates a collection of points
    using each point that was in those invalid triangles 3. Then, using those points,
    it adds new triangles that follow the rules of Delaunay triangulations 4. It accomplishes
    this incrementally, using exactly the code that we have already introduced. Finally,
    it returns `delaunay`, a list containing the collection of triangles that constitutes
    our DT.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'We can easily call this function to generate a DT for any collection of points.
    In the following code, we specify a number for `N` and generate `N` random points
    (*x* and *y* values). Then, we zip the *x* and *y* values, put them together into
    a list, pass them to our `gen_delaunay()` function, and get back a full, valid
    DT that we store in a variable called `the_delaunay`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We’ll use `the_delaunay` in the next section to generate a Voronoi diagram.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: From Delaunay to Voronoi
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we’ve completed our DT generation algorithm, the Voronoi diagram generation
    algorithm is within our grasp. We can turn a set of points into a Voronoi diagram
    by following this algorithm:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Find the DT of a set of points.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take the circumcenter of every triangle in the DT.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Draw lines connecting the circumcenters of all triangles in the DT that share
    an edge.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We already know how to do step 1 (we did it in the previous section), and we
    can accomplish step 2 withthe `triangle_to_circumcenter()` function. So the only
    thing we need is a code snippet that can accomplish step 3.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: The code we write for step 3 will live in our plotting function. Remember that
    we pass a set of triangles and circumcenters to that function as its inputs. Our
    code will need to create a collection of lines connecting circumcenters. But it
    will not connect all of the circumcenters, only those from triangles that share
    an edge.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re storing our triangles as collections of points, not edges. But it’s still
    easy to check whether two of our triangles share an edge; we just check whether
    they share exactly two points. If they share only one point, then they have vertices
    that meet but no common edge. If they share three points, they are the same triangle
    and so will have the same circumcenter. Our code will loop through every triangle,
    and for each triangle, it will loop through every triangle again, and check the
    number of points that the two triangles share. If the number of common points
    is exactly two, then it will add a line between the circumcenters of the triangles
    in question. The lines between the circumcenters will be the boundaries of our
    Voronoi diagram. The following code snippet shows how we’ll loop through triangles,
    but it’s part of a larger plotting function, so don’t run it yet:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This code will be added to our plotting function, since our final goal is a
    plotted Voronoi diagram.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'While we’re at it, we can make several other useful additions to our plotting
    function. The new plotting function is shown in [Listing 7-4](#listing7-4), with
    the changes in bold:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[Listing 7-4:](#listinganchor7-4) A function that plots triangles, circumcenters,
    circumcircles, Voronoi points, and Voronoi boundaries'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: First, we add new arguments that specify exactly what we want to plot. Remember
    that in this chapter we have worked with points, edges, triangles, circumcircles,
    circumcenters, DTs, and Voronoi boundaries. It could be overwhelming to the eye
    to plot all of these together, so we will add `plotcircles` to specify whether
    we want to plot our circumcircles, `plotpoints` to specify whether we want to
    plot our collection of points, `plottriangles` to specify whether we want to plot
    our DT, `plotvoronoi` to specify whether we want to plot our Voronoi diagram edges,
    and `plotvpoints` which to specify whether we want to plot our circumcenters (which
    are the vertices of the Voronoi diagram edges). The new additions are shown in
    bold. One addition plots the Voronoi vertices (circumcenters), if we have specified
    in our arguments that we want to plot them 1. The longer addition plots the Voronoi
    edges 2. We’ve also specified a few `if` statements that allow us to plot, or
    not plot, triangles, vertices, and circumcircles, as we prefer.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re almost ready to call this plotting function and see our final Voronoi
    diagram. However, first we need to get the circumcenters of every triangle in
    our DT. Luckily, this is very easy. We can create an empty list called `circumcenters`
    and append the circumcenter of every triangle in our DT to that list, as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, we’ll call our plotting function, specifying that we want it to draw
    the Voronoi boundaries:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[Figure 7-15](#figure7-15) shows our output.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '![figure_7-15](Images/figure_7-15.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
- en: '[Figure 7-15:](#figureanchor7-15) A Voronoi diagram. Phew!'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: We’ve transformed a set of points into a Voronoi diagram in mere seconds. You
    can see that the boundaries in this Voronoi diagram run right up to the edge of
    the plot. If we increased the size of the plot, the Voronoi edges would continue
    even farther. Remember that Voronoi edges connect the centers of circumcircles
    of triangles in our DT. But our DT could be connecting very few points that are
    close together in the center of our plot, so all the circumcenters could lie within
    a small area in the middle of our plot. If that happened, the edges of our Voronoi
    diagram wouldn’t extend to the edges of the plot space. This is why we added the
    new outer triangle in the first line of our `gen_delaunay()` function; by having
    a triangle whose points are far outside our plot area, we can be confident that
    there will always be Voronoi edges that run to the edge of our map, so that (for
    example) we will know which post office to assign to deliver to new suburbs built
    on or outside the edge of the city.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you might enjoy playing with our plotting function. For example, if
    you set all of its input arguments to `True`, you can generate a messy but beautiful
    plot of all the elements we have discussed in this chapter:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Our output is shown in [Figure 7-16](#figure7-16).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '![figure_7-16](Images/figure_7-16.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
- en: '[Figure 7-16:](#figureanchor7-16) Magic eye'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: You can use this image to convince your roommates and family members that you
    are doing top-secret particle collision analysis work for CERN, or maybe you could
    use it to apply for an art fellowship as a spiritual successor to Piet Mondrian.
    As you look at this Voronoi diagram with its DT and circumcircles, you could imagine
    post offices, water pumps, crystal structures, or any other possible application
    of Voronoi diagrams. Or you could just imagine points, triangles, and lines and
    revel in the pure joys of geometry.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter introduced methods for writing code to do geometric reasoning.
    We started by drawing simple points, lines, and triangles. We proceeded to discuss
    different ways to find the center of a triangle, and how this enables us to generate
    a Delaunay triangulation for any set of points. Finally, we went over simple steps
    for using a Delaunay triangulation to generate a Voronoi diagram, which can be
    used to solve the postmaster problem or to contribute to any of a variety of other
    applications. They are complex in some ways, but in the end they boil down to
    elementary manipulations of points, lines, and triangles.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we discuss algorithms that can be used to work with languages.
    In particular, we’ll talk about how an algorithm can correct text that’s missing
    spaces and how to write a program that can predict what word should come next
    in a natural phrase.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
