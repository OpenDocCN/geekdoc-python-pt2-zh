<html><head></head><body>
<div id="sbo-rt-content"><section aria-labelledby="header0101" class="chapter" epub:type="chapter" id="ch01" role="doc-chapter">
<header id="header0101">
<h1 class="cn"><span aria-label=" Page 2. " class="page" epub:type="pagebreak" id="p2" role="doc-pagebreak"/><span aria-label=" Page 3. " class="page" epub:type="pagebreak" id="p3" role="doc-pagebreak"/><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rch01">1</a></h1>
<h1 class="ct">The Koch Snowflake</h1>
</header>
<figure class="figure">
<p class="fig"><img alt="" height="100" src="images/nsp-venkitachalam503045-circle-image.jpg" width="100"/></p>
</figure>
<p class="pf">We’ll start our Python adventures by figuring out how to draw an interesting shape called the <span class="idx" data-term="Koch snowflake"/><i>Koch snowflake</i>, invented by Swedish mathematician Helge von Koch in 1904. The Koch snowflake is a <i><span class="idx" data-level1="fractal" data-term="Koch snowflake"/>fractal</i>—a type of figure that repeats itself as you zoom in to it.</p>
<p>Fractals derive their repeating nature from <i><span class="idx" data-level1="recursion" data-term="Koch snowflake"/>recursion</i>, a technique where something is defined in terms of itself. In particular, you draw a fractal using a <span class="idx" data-level1="recursive algorithm" data-term="Koch snowflake"/><i>recursive algorithm</i>, a repeating process where one repetition’s output becomes the input of the next repetition.</p>
<p>As you work through this chapter, you’ll learn:</p>
<ul style="list-style-type:none">
<li class="blf">• The basics of recursive algorithms and functions</li>
<li class="bl">• How to create graphics using the <code>turtle</code> module</li>
<li class="bl">• A recursive algorithm to draw the Koch snowflake</li>
<li class="bl">• Some linear algebra</li>
</ul>
<section>
<h2 class="ah" id="ah0301"><span aria-label=" Page 4. " class="page" epub:type="pagebreak" id="p4" role="doc-pagebreak"/><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah0301">How It Works</a></h2>
<p class="paft"><a class="xref" href="nsp-venkitachalam503045-0012.xhtml#fig1-1">Figure 1-1</a> shows what the Koch snowflake looks like. Notice how the large branch in the middle is repeated on a smaller scale by branches on the left and right. Similarly, the large branch in the middle is itself made up of smaller branches that echo the larger shape. This is the repeating, self-similar nature of a fractal.</p>
<figure class="figure" id="fig1-1">
<p class="fig"><img alt="" height="118" src="images/nsp-venkitachalam503045-f01001.jpg" width="402"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 1-1:</span> The Koch snowflake</p>
</figcaption>
</figure>
<p>If you know how to calculate the points that form the basic shape making up the snowflake, you can develop an algorithm to perform the same calculations recursively. This way, you’ll draw smaller and smaller versions of that shape, building up the fractal. In this section, we’ll look generally at how recursion works. Then we’ll consider how to apply recursion, along with some linear algebra and Python’s <code>turtle</code> module, to draw the Koch snowflake.</p>
<section>
<h3 class="bh" id="bh0301"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh0301">Using Recursion</a></h3>
<p class="paft">To get a feel for how recursion works, let’s take a look at a simple recursive algorithm: computing the factorial of a number. The factorial of a number can be defined by a function, as shown here:</p>
<div class="equation">
<p class="eq"><i>f</i>(<i>N</i>) = 1 × 2 × 3 × . . . × (<i>N</i> − 1) × <i>N</i></p>
</div>
<p>In other words, the <span class="idx" data-term="factorial"/>factorial of <i>N</i> is just the product of the numbers 1 through <i>N</i>. You can rewrite this as:</p>
<div class="equation">
<p class="eq"><i>f</i>(<i>N</i>) = <i>N</i> × (<i>N</i> − 1) × . . . × 3 × 2 × 1</p>
</div>
<p class="pcon">which can again be rewritten as:</p>
<div class="equation">
<p class="eq"><i>f</i>(<i>N</i>) = <i>N</i> × <i>f</i>(<i>N</i> − 1)</p>
</div>
<p>Wait, what did you just do? You defined <i>f</i> in terms of itself! That’s recursion. Calling <i>f</i>(<i>N</i>) will end up calling <i>f</i>(<i>N</i> − 1), which will end up calling <i>f</i>(<i>N</i> − 2), and so on. But how do you know when to stop? Well, you have to define <i>f</i>(1) as 1, and that will be the deepest step of the recursion.</p>
<p><span aria-label=" Page 5. " class="page" epub:type="pagebreak" id="p5" role="doc-pagebreak"/>Here’s how to implement the recursive factorial function in Python:</p>
<div class="codeline">
<p class="clf">def factorial(N):</p>
<p class="cl">  <!--<ccust1>1</ccust1>-->❶ if N == 1:</p>
<p class="cl">        return 1</p>
<p class="cl">    else:</p>
<p class="cll">      <!--<ccust1>2</ccust1>-->❷ return N * factorial(N-1)</p>
</div>
<p>You handle the case where <i>N</i> is equal to 1 by simply returning <code>1</code> <!--<ccust1>1</ccust1>-->❶, and you implement the recursive call by calling <code>factorial()</code> again <!--<ccust1>2</ccust1>-->❷, this time passing in <code>N-1</code>. The function will keep calling itself until <i>N</i> equals 1. The net effect is that when the function returns, it will have computed the product of all numbers 1 through <i>N</i>.</p>
<p>In general, when you’re trying to implement an algorithm using recursion, follow these steps:</p>
<ol style="list-style-type:none">
<li class="nlf">1. Define a <span class="idx" data-level1="recursion" data-level2="base case" data-term="Koch snowflake"/>base case where the recursion ends. In our factorial example, you did this by defining <i>f</i>(1) as 1.</li>
<li class="nll">2. Define the <span class="idx" data-level1="recursion" data-level2="recursive step" data-term="Koch snowflake"/>recursive step. For this you need to think about how to express the algorithm as a recursive process. In some algorithms, there can be multiple recursive calls from a function—as you’ll see soon.</li>
</ol>
<p>Recursion is a helpful tool for problems that can be naturally partitioned into smaller versions of themselves. The factorial algorithm is a perfect example of this partitioning, and as you’ll soon see, so is drawing the Koch snowflake. That said, recursion isn’t always the most efficient way to solve a problem. In some cases, it would make sense to re-implement the recursive algorithm in terms of loops. But the fact remains that recursive algorithms are often more compact and elegant compared to their loopy counterparts.</p>
</section>
<section>
<h3 class="bh" id="bh0302"><span class="idx" data-level1="computing" data-term="Koch snowflake"/>Computing the Snowflake</h3>
<p class="paft">Now let’s look at how to construct the Koch snowflake. <a class="xref" href="nsp-venkitachalam503045-0012.xhtml#fig1-2">Figure 1-2</a> shows the basic pattern for drawing the snowflake. I’ll call this pattern a <i>flake</i>. The basis of the figure is the line segment <img alt="" height="25" src="images/nsp-venkitachalam503045-m01001.jpg" width="39"/> of length <i>d</i>. The segment is split into three equal parts, <img alt="" height="34" src="images/nsp-venkitachalam503045-m01002.jpg" width="47"/>, <img alt="" height="36" src="images/nsp-venkitachalam503045-m01003.jpg" width="54"/>, and <img alt="" height="36" src="images/nsp-venkitachalam503045-m01004.jpg" width="47"/>, each of which has a length <i>r</i>. Instead of directly connecting points <i>P</i><sub>1</sub> and <i>P</i><sub>3</sub>, these points are connected through <i>P</i><sub>2</sub>, which is chosen such that <i>P</i><sub>1</sub>, <i>P</i><sub>2</sub>, and <i>P</i><sub>3</sub> form an equilateral triangle of side length <i>r</i> and height <i>h</i>. Point <i>C</i>, the midpoint of <i>P</i><sub>1</sub> and <i>P</i><sub>3</sub> (and by extension of <i>A</i> and <i>B</i>), falls directly beneath <i>P</i><sub>2</sub>, such that <img alt="" height="25" src="images/nsp-venkitachalam503045-m01005.jpg" width="39"/> and <img alt="" height="37" src="images/nsp-venkitachalam503045-m01006.jpg" width="48"/> are perpendicular.</p>
<figure class="figure" id="fig1-2">
<p class="fig"><span aria-label=" Page 6. " class="page" epub:type="pagebreak" id="p6" role="doc-pagebreak"/><img alt="" height="772" src="images/nsp-venkitachalam503045-f01002.jpg" style="width:95%; height:auto;" width="1200"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 1-2:</span> The basic pattern for drawing a Koch snowflake</p>
</figcaption>
</figure>
<p>Once you understand how to calculate the points shown in <a class="xref" href="nsp-venkitachalam503045-0012.xhtml#fig1-2">Figure 1-2</a>, you’ll be able to recursively draw smaller and smaller flakes to reproduce the Koch snowflake. Essentially, your goal is this: given points <i>A</i> and <i>B</i>, you want to compute the points <i>P</i><sub>1</sub>, <i>P</i><sub>2</sub>, and <i>P</i><sub>3</sub> and join them up as shown in the figure. To calculate those points, you’ll need to use some linear algebra, a mathematical discipline that lets you compute distances and figure out coordinates of points based on <i>vectors</i>, quantities that have both magnitude and direction.</p>
<p>Here’s a simple formula from <span class="idx" data-term="linear algebra"/>linear algebra that you’ll be using. Say you have a point <i>A</i> in 3D space and a unit vector <img alt="" height="23" src="images/nsp-venkitachalam503045-m01007.jpg" width="15"/> (a <i>unit vector</i> is a vector with a length of 1 unit). Point <i>B</i> at a distance <i>d</i> along this unit vector is given by:</p>
<div class="equation">
<p class="eq"><i>B</i> = <i>A</i> + <i>d</i> × <img alt="" height="23" src="images/nsp-venkitachalam503045-m01007.jpg" width="15"/></p>
</div>
<p>You can easily verify this with an example. Take the case where <i>A</i> = (5, 0, 0) and <img alt="" height="23" src="images/nsp-venkitachalam503045-m01007.jpg" width="15"/> = (0, 1, 0). What are the coordinates for a point <i>B</i> that’s 10 units away from <i>A</i> along <img alt="" height="23" src="images/nsp-venkitachalam503045-m01007.jpg" width="15"/>? Using the previous formula, you get:</p>
<div class="equation">
<p class="eq"><i>B</i> = (5, 0, 0) + 10 × (0, 1, 0) = (5, 10, 0)</p>
</div>
<p class="pcon">In other words, to get from <i>A</i> to <i>B</i>, you move 10 units along the positive y-axis.</p>
<p>Here’s another result you’ll use—let’s call it the <i>perpendicular vector trick</i>. Say you have a vector <img alt="" height="28" src="images/nsp-venkitachalam503045-m01008.jpg" width="19"/> = (<i>a</i>, <i>b</i>). If you have another vector <img alt="" height="28" src="images/nsp-venkitachalam503045-m01009.jpg" width="18"/> that’s perpendicular to <img alt="" height="28" src="images/nsp-venkitachalam503045-m01008.jpg" width="19"/>, it can be expressed as <img alt="" height="28" src="images/nsp-venkitachalam503045-m01009.jpg" width="18"/> = (−<i>b</i>, <i>a</i>). You can verify that this trick works by taking the dot product of <img alt="" height="28" src="images/nsp-venkitachalam503045-m01008.jpg" width="19"/> and <img alt="" height="28" src="images/nsp-venkitachalam503045-m01009.jpg" width="18"/>. To take the dot product of a pair of two-dimensional vectors, multiply the first components from each vector, then multiply the second components from each vector, and finally add the results together. In this case, the dot product of <img alt="" height="28" src="images/nsp-venkitachalam503045-m01008.jpg" width="19"/> and <img alt="" height="28" src="images/nsp-venkitachalam503045-m01009.jpg" width="18"/> is:</p>
<div class="equation">
<p class="eq"><img alt="" height="28" src="images/nsp-venkitachalam503045-m01010.jpg" width="53"/> = (<i>a</i> × −<i>b</i>) + (<i>b</i> × <i>a</i>) = −<i>ab</i> + <i>ab</i> = 0</p>
</div>
<p class="pcon"><span aria-label=" Page 7. " class="page" epub:type="pagebreak" id="p7" role="doc-pagebreak"/>The dot product of two perpendicular vectors will always be zero, so <img alt="" height="28" src="images/nsp-venkitachalam503045-m01009.jpg" width="18"/> is indeed perpendicular to <img alt="" height="28" src="images/nsp-venkitachalam503045-m01008.jpg" width="19"/>.</p>
<p>With this in mind, let’s return to the flake in <a class="xref" href="nsp-venkitachalam503045-0012.xhtml#fig1-2">Figure 1-2</a>. How can you calculate the position of <i>P</i><sub>2</sub>, given the coordinates for points <i>A</i> and <i>B</i>? You know that <i>P</i><sub>2</sub> falls <i>h</i> distance away from point <i>C</i> along unit vector <img alt="" height="23" src="images/nsp-venkitachalam503045-m01007.jpg" width="15"/>. Your first linear algebra formula tells you:</p>
<div class="equation">
<p class="eq"><i>P</i><sub>2</sub> = <i>C</i> + <i>h</i> × <img alt="" height="23" src="images/nsp-venkitachalam503045-m01007.jpg" width="15"/></p>
</div>
<p>Now let’s put those variables in terms that you know. First, <i>C</i> is the midpoint of line <img alt="" height="25" src="images/nsp-venkitachalam503045-m01011.jpg" width="39"/>, so <i>C</i> = (<i>A</i> + <i>B</i>) / 2. Next, <i>h</i> is the height of an equilateral triangle with side length <i>r</i>. The Pythagorean theorem tells you:</p>
<div class="equation">
<p class="eq"><img alt="" height="69" src="images/nsp-venkitachalam503045-m01012.jpg" width="108"/></p>
</div>
<p class="pcon">In this case, <i>r</i> is simply a third of the distance from <i>A</i> to <i>B</i>. If <i>A</i> has coordinates (<i>x</i><sub>1</sub>, <i>y</i><sub>1</sub>) and <i>B</i> has coordinates (<i>x</i><sub>2</sub>, <i>y</i><sub>2</sub>), you can calculate the distance between them as:</p>
<div class="equation">
<p class="eq"><img alt="" height="41" src="images/nsp-venkitachalam503045-m01013.jpg" width="318"/></p>
</div>
<p class="pcon">Then simply divide <i>d</i> by 3 to get <i>r</i>.</p>
<p>Finally, you need a way to express <img alt="" height="23" src="images/nsp-venkitachalam503045-m01007.jpg" width="15"/>. You know that <img alt="" height="23" src="images/nsp-venkitachalam503045-m01007.jpg" width="15"/> is perpendicular to vector <img alt="" height="28" src="images/nsp-venkitachalam503045-m01014.jpg" width="38"/>, and you can express <img alt="" height="28" src="images/nsp-venkitachalam503045-m01014.jpg" width="38"/> by subtracting point <i>A</i>’s coordinates from point <i>B</i>’s:</p>
<div class="equation">
<p class="eq"><img alt="" height="28" src="images/nsp-venkitachalam503045-m01014.jpg" width="38"/> = (<i>x</i><sub>2</sub> − <i>x</i><sub>1</sub>, <i>y</i><sub>2</sub> − <i>y</i><sub>1</sub>)</p>
</div>
<p class="pcon">The magnitude of <img alt="" height="28" src="images/nsp-venkitachalam503045-m01014.jpg" width="38"/> is given by <i>d</i> = <img alt="" height="28" src="images/nsp-venkitachalam503045-m01015.jpg" width="48"/>. You can now use the perpendicular vector trick to express <img alt="" height="23" src="images/nsp-venkitachalam503045-m01007.jpg" width="15"/> in terms of <i>A</i> and <i>B</i>:</p>
<div class="equation">
<p class="eq"><img alt="" height="74" src="images/nsp-venkitachalam503045-m01016.jpg" width="555"/></p>
</div>
<p>Next you need to compute <i>P</i><sub>1</sub> and <i>P</i><sub>3</sub>. For this you’re going to use another result from linear algebra. Let’s say you have a line <img alt="" height="25" src="images/nsp-venkitachalam503045-m01011.jpg" width="39"/> and a point <i>C</i> on the line. Let <i>a</i> be the distance of <i>C</i> from <i>A</i> and <i>b</i> be the distance of <i>C</i> from <i>B</i>. The point <i>C</i> is given by:</p>
<div class="equation">
<p class="eq"><img alt="" height="73" src="images/nsp-venkitachalam503045-m01017.jpg" width="267"/></p>
</div>
<p>To understand this formula, think about what happens if <i>C</i> is the midpoint of <i>A</i> and <i>B</i>, meaning <i>a</i> and <i>b</i> would be the same. In this case, you can intuit that <i>C</i> ought to equal (<i>A</i> + <i>B</i>) / 2. Substitute all the <i>b</i>s for <i>a</i>s in the previous equation. You’ll get:</p>
<div class="equation">
<p class="eq"><img alt="" height="66" src="images/nsp-venkitachalam503045-m01018.jpg" width="382"/></p>
</div>
<p>With this new formula in mind, you can now compute <i>P</i><sub>1</sub> and <i>P</i><sub>3</sub>. These points divide line <img alt="" height="25" src="images/nsp-venkitachalam503045-m01011.jpg" width="39"/> into thirds, meaning the distance from <i>P</i><sub>1</sub> to <i>B</i> is twice <span aria-label=" Page 8. " class="page" epub:type="pagebreak" id="p8" role="doc-pagebreak"/>the distance from <i>P</i><sub>1</sub> to <i>A</i> (<i>b</i> = 2<i>a</i>), and the distance from <i>P</i><sub>3</sub> to <i>A</i> is twice the distance from <i>P</i><sub>3</sub> to <i>B</i> (<i>a</i> = 2<i>b</i>). Feeding this into the formula, you can therefore calculate the points as:</p>
<div class="equation">
<p class="eq"><img alt="" height="63" src="images/nsp-venkitachalam503045-m01019.jpg" width="190"/> and <img alt="" height="63" src="images/nsp-venkitachalam503045-m01020.jpg" width="190"/></p>
</div>
<p>Now you have everything you need to draw the first level of the snowflake fractal. Once you decide on <i>A</i> and <i>B</i>, you know how to compute the points <i>P</i><sub>1</sub>, <i>P</i><sub>2</sub>, and <i>P</i><sub>3</sub>. But what happens at the second level of the fractal? You take each individual line segment from the flake at the first level (<a class="xref" href="nsp-venkitachalam503045-0012.xhtml#fig1-2">Figure 1-2</a>) and replace it with a smaller flake. The result is shown in <a class="xref" href="nsp-venkitachalam503045-0012.xhtml#fig1-3">Figure 1-3</a>.</p>
<figure class="figure" id="fig1-3">
<p class="fig"><img alt="" height="581" src="images/nsp-venkitachalam503045-f01003.jpg" style="width:95%; height:auto;" width="1200"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 1-3:</span> The second step of Koch snowflake construction</p>
</figcaption>
</figure>
<p>Notice how each of the four line segments from <a class="xref" href="nsp-venkitachalam503045-0012.xhtml#fig1-2">Figure 1-2</a>, <img alt="" height="35" src="images/nsp-venkitachalam503045-m01021.jpg" width="47"/>, <img alt="" height="35" src="images/nsp-venkitachalam503045-m01022.jpg" width="55"/>, <img alt="" height="35" src="images/nsp-venkitachalam503045-m01023.jpg" width="55"/>, and <img alt="" height="35" src="images/nsp-venkitachalam503045-m01024.jpg" width="46"/>, has become the basis for a new flake. In the Koch snowflake program, you’ll be able to use the endpoints of each line segment, for example, <i>A</i> and <i>P</i><sub>1</sub>, as new values for <i>A</i> and <i>B</i> and recursively perform the same calculations used to arrive at the points in <a class="xref" href="nsp-venkitachalam503045-0012.xhtml#fig1-2">Figure 1-2</a>.</p>
<p>At each level of the fractal, you’ll subdivide the snowflake again, drawing smaller and smaller self-similar figures. This is the <span class="idx" data-level1="recursion" data-level2="recursive step" data-term="Koch snowflake"/><i>recursive step</i> of the algorithm, which you’ll repeat until you reach a <span class="idx" data-level1="recursion" data-level2="base case" data-term="Koch snowflake"/><i>base case</i>. This should happen when <img alt="" height="25" src="images/nsp-venkitachalam503045-m01011.jpg" width="39"/> is smaller than a certain threshold—say, 10 pixels. When you hit that threshold, just draw the line segments and stop recursing.</p>
<p>To make the final output a bit fancy, you can draw three linked flakes as the first level of the fractal. This will give you the hexagonal symmetry of an actual snowflake. <a class="xref" href="nsp-venkitachalam503045-0012.xhtml#fig1-4">Figure 1-4</a> shows what the starting drawing will look like.</p>
<figure class="figure" id="fig1-4">
<p class="fig"><span aria-label=" Page 9. " class="page" epub:type="pagebreak" id="p9" role="doc-pagebreak"/><img alt="" height="1200" src="images/nsp-venkitachalam503045-f01004.jpg" style="width:95%; height:auto;" width="947"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 1-4:</span> <span class="idx" data-level1="combining" data-term="Koch snowflake"/>Combining three snowflakes</p>
</figcaption>
</figure>
<p>Now that you know how to calculate the coordinates for making the snowflake, let’s see how to use those coordinates in Python to actually draw an image.</p>
</section>
<section>
<h3 class="bh" id="bh0303">Drawing with <span class="idx" data-term="turtle graphics "/>turtle Graphics</h3>
<p class="paft">In this chapter, you’ll use Python’s <code><span class="idx" data-level1="turtle module" data-term="turtle graphics"/>turtle</code> module to draw the snowflake; it’s a simple drawing program modeled after the idea of a turtle dragging its tail through the sand, creating patterns. The <code>turtle</code> module includes methods you can use to set the position and color of the pen (the turtle’s tail) and many other useful functions for drawing.</p>
<p><span aria-label=" Page 10. " class="page" epub:type="pagebreak" id="p10" role="doc-pagebreak"/>As you’ll see, all you need is a handful of graphics functions to draw the Koch snowflake. In fact, from the standpoint of <code>turtle</code>, drawing the snowflake is almost as easy as drawing a triangle. To prove it, and to give you a feel for how <code>turtle</code> works, the following program uses <code>turtle</code> to draw said triangle. Enter the code, save it as <i>test_turtle.py</i>, and run it in Python:</p>
<div class="codeline">
<p class="cl2f"><!--<ccust1>1</ccust1>-->❶ import turtle</p>
<p class="clf">def draw_triangle(x1, y1, x2, y2, x3, y3, t):</p>
<p class="cl">    # go to start of triangle</p>
<p class="cl">  <!--<ccust1>2</ccust1>-->❷ t.up()</p>
<p class="cl">  <!--<ccust1>3</ccust1>-->❸ t.setpos(x1, y1)</p>
<p class="cl">  <!--<ccust1>4</ccust1>-->❹ t.down()</p>
<p class="cl">    t.setpos(x2, y2)</p>
<p class="cl">    t.setpos(x3, y3)</p>
<p class="cl">    t.setpos(x1, y1)</p>
<p class="cl">    t.up()</p>
<p class="clf">def main():</p>
<p class="cl">    print('testing turtle graphics...')</p>
<p class="clf">  <!--<ccust1>5</ccust1>-->❺ t = turtle.Turtle()</p>
<p class="cl">  <!--<ccust1>6</ccust1>-->❻ t.hideturtle()</p>
<p class="clf">  <!--<ccust1>7</ccust1>-->❼ draw_triangle(-100, 0, 0, -173.2, 100, 0, t)</p>
<p class="clf">  <!--<ccust1>8</ccust1>-->❽ turtle.mainloop()</p>
<p class="clf"># call main</p>
<p class="cl">if __name__ == '__main__':</p>
<p class="cll">    main()</p>
</div>
<p>You start by importing the <code>turtle</code> module <!--<ccust1>1</ccust1>-->❶. Next, you define the <code>draw_triangle()</code> method, whose parameters are three pairs of x-coordinates and y-coordinates (the three corners of a triangle), as well as <code>t</code>, a <code>turtle</code> object. The method starts by calling <span class="idx" data-level1="up" data-term="turtle graphics"/><code>up()</code> <!--<ccust1>2</ccust1>-->❷. This tells Python to move the pen up; in other words, take the pen off the virtual paper so that it won’t draw as you move the turtle. You want to position the turtle before you start drawing. The <span class="idx" data-level1="setpos" data-term="turtle graphics"/><code>setpos()</code> call <!--<ccust1>3</ccust1>-->❸ sets the position of the turtle to the first pair of x- and y-coordinates. Calling <span class="idx" data-level1="down" data-term="turtle graphics"/><code>down()</code> <!--<ccust1>4</ccust1>-->❹ sets the pen down, and for each of the subsequent <code>setpos()</code> calls, a line is drawn as the turtle moves to the next set of coordinates. The net result is a triangle drawing.</p>
<p>Next you declare a <code>main()</code> function to actually do the drawing. In it, you create the <code>turtle</code> object for drawing <!--<ccust1>5</ccust1>-->❺ and hide the turtle <!--<ccust1>6</ccust1>-->❻. Without this command, you’d see a small shape representing the turtle at the front of the line being drawn. You then call <code>draw_triangle()</code> to draw the triangle <!--<ccust1>7</ccust1>-->❼, passing in the desired coordinates as arguments. The call to <span class="idx" data-level1="mainloop" data-term="turtle graphics"/><code>mainloop()</code> <!--<ccust1>8</ccust1>-->❽ keeps the <code><span class="idx" data-level1="tkinter" data-term="turtle graphics"/>tkinter</code> window open after the triangle has been drawn. (<span class="idx" data-term="tkinter module"/><code>tkinter</code> is Python’s default GUI library.)</p>
<p><span aria-label=" Page 11. " class="page" epub:type="pagebreak" id="p11" role="doc-pagebreak"/><a class="xref" href="nsp-venkitachalam503045-0012.xhtml#fig1-5">Figure 1-5</a> shows the output of this simple program.</p>
<figure class="figure" id="fig1-5">
<p class="fig"><img alt="" height="1168" src="images/nsp-venkitachalam503045-f01005.jpg" style="width:95%; height:auto;" width="1200"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 1-5:</span> The output of a simple <code class="i">turtle</code> program</p>
</figcaption>
</figure>
<p>You now have everything you need for the project. Let’s draw some flakes!</p>
</section>
</section>
<section>
<h2 class="ah" id="ah0302"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah0302">Requirements</a></h2>
<p class="paft">In this project, you’ll use the Python <code>turtle</code> module to draw the snowflake.</p>
</section>
<section>
<h2 class="ah" id="ah0303"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah0303">The Code</a></h2>
<p class="paft">To <span class="idx" data-level1="drawing" data-level2="startRange" data-term="Koch snowflake"/>draw the Koch snowflake, define a recursive function, <code>drawKochSF()</code>. This function computes <i>P</i><sub>1</sub>, <i>P</i><sub>2</sub>, and <i>P</i><sub>3</sub> in terms of <i>A</i> and <i>B</i> from <a class="xref" href="nsp-venkitachalam503045-0012.xhtml#fig1-2">Figure 1-2</a> and then recursively calls itself to perform the same calculation for smaller and smaller line segments until it reaches the smallest base case. Then it draws the flakes using <code>turtle</code>. For the full project code, skip ahead to <a class="xref" href="nsp-venkitachalam503045-0012.xhtml#ah0307">“The Complete Code”</a> on <a class="xref" href="nsp-venkitachalam503045-0012.xhtml#p16">page 16</a>. The code is also available in the book’s <span class="idx" data-level1="GitHub code" data-term="Koch snowflake"/>GitHub repository at <a class="url-i" href="https://github.com/mkvenkit/pp2e/blob/main/koch/koch.py">https://github.com/mkvenkit/pp2e/blob/main/koch/koch.py</a>.</p>
<section>
<h3 class="bh" id="bh0304">Calculating the Points</h3>
<p class="paft">Begin the <code>drawKochSF()</code> function by calculating the coordinates for all the points needed to draw the basic flake pattern shown in <a class="xref" href="nsp-venkitachalam503045-0012.xhtml#fig1-2">Figure 1-2</a>.</p>
<div class="codeline">
<p class="clf"><span aria-label=" Page 12. " class="page" epub:type="pagebreak" id="p12" role="doc-pagebreak"/>def drawKochSF(x1, y1, x2, y2, t):</p>
<p class="cl">    d = math.sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2))</p>
<p class="cl">    r = d/3.0</p>
<p class="cl">    h = r*math.sqrt(3)/2.0</p>
<p class="cl">    p3 = ((x1 + 2*x2)/3.0, (y1 + 2*y2)/3.0)</p>
<p class="cl">    p1 = ((2*x1 + x2)/3.0, (2*y1 + y2)/3.0)</p>
<p class="cl">    c = (0.5*(x1+x2), 0.5*(y1+y2))</p>
<p class="cl">    n = ((y1-y2)/d, (x2-x1)/d)</p>
<p class="cll">    p2 = (c[0]+h*n[0], c[1]+h*n[1])</p>
</div>
<p>You define <code>drawKochSF()</code>, passing in the x- and y-coordinates for the endpoints of a line segment <img alt="" height="25" src="images/nsp-venkitachalam503045-m01011.jpg" width="39"/>, which forms the basis for one of the sides of the snowflake, as shown in <a class="xref" href="nsp-venkitachalam503045-0012.xhtml#fig1-4">Figure 1-4</a>. You also pass in the <code>turtle</code> object <code>t</code>, which you use for the actual drawing. Then you compute all the parameters shown in <a class="xref" href="nsp-venkitachalam503045-0012.xhtml#fig1-2">Figure 1-2</a>, as discussed in the <a class="xref" href="nsp-venkitachalam503045-0012.xhtml#bh0302">“Computing the Snowflake”</a> section, starting with <code>d</code>, the distance from <i>A</i> to <i>B</i>. Dividing <code>d</code> by 3 gives you <code>r</code>, the length of each of the four line segments that makes up a flake. You use <code>r</code> to find <code>h</code>, the height of the “cone” at the heart of the flake.</p>
<p>You calculate the rest of the parameters as tuples containing an x- and a y-coordinate. The <code>p3</code> and <code>p1</code> tuples describe the two points at the base of the cone portion of the flake. Point <code>c</code> is the midpoint of <code>p1</code> and <code>p3</code>, and <code>n</code> is the unit vector perpendicular to line <img alt="" height="25" src="images/nsp-venkitachalam503045-m01011.jpg" width="39"/>. Along with <code>h</code>, they help you calculate <code>p2</code>, the apex of the flake’s cone.</p>
</section>
<section>
<h3 class="bh" id="bh0305">Recursing</h3>
<p class="paft">The next part of the <code>drawKochSF()</code> function uses recursion to break down the first-level flake into smaller and smaller versions of itself.</p>
<div class="codeline">
<p class="clf">  <!--<ccust1>1</ccust1>-->❶ if d &gt; 10:</p>
<p class="cl">        # flake #1</p>
<p class="cl">      <!--<ccust1>2</ccust1>-->❷ drawKochSF(x1, y1, p1[0], p1[1], t)</p>
<p class="cl">        # flake #2</p>
<p class="cl">        drawKochSF(p1[0], p1[1], p2[0], p2[1], t)</p>
<p class="cl">        # flake #3</p>
<p class="cl">        drawKochSF(p2[0], p2[1], p3[0], p3[1], t)</p>
<p class="cl">        # flake #4</p>
<p class="cll">        drawKochSF(p3[0], p3[1], x2, y2, t)</p>
</div>
<p>First you check for the recursion-stopping criteria <!--<ccust1>1</ccust1>-->❶. If <code>d</code>, the length of segment <img alt="" height="25" src="images/nsp-venkitachalam503045-m01011.jpg" width="39"/>, is greater than 10 pixels, you continue the recursion. You do this by calling the <code>drawKochSF()</code> function again—four times! With each call, you pass in a different set of arguments corresponding to the coordinates for one of the four line segments that make up a flake, which you calculated at the start of the function. At <!--<ccust1>2</ccust1>-->❷, for example, you call <code>drawKochSF()</code> for the segment <img alt="" height="35" src="images/nsp-venkitachalam503045-m01021.jpg" width="47"/>. The other function calls are for segments <img alt="" height="35" src="images/nsp-venkitachalam503045-m01022.jpg" width="55"/>, <img alt="" height="35" src="images/nsp-venkitachalam503045-m01023.jpg" width="55"/>, and <img alt="" height="35" src="images/nsp-venkitachalam503045-m01024.jpg" width="46"/>. Within each of these recursive calls, you’ll perform a new set of calculations based on the new values for points <i>A</i> and <i>B</i>, and if <code>d</code> is still greater than 10 pixels, you’ll make another four recursive calls to <code>drawKochSF()</code>, and so on.</p>
</section>
<section>
<h3 class="bh" id="bh0306"><span aria-label=" Page 13. " class="page" epub:type="pagebreak" id="p13" role="doc-pagebreak"/>Drawing a Flake</h3>
<p class="paft">Now let’s look at what happens if segment <img alt="" height="25" src="images/nsp-venkitachalam503045-m01011.jpg" width="39"/> is less than 10 pixels. This is the base case for the recursive algorithm. Since you’re below the threshold, you aren’t going to recurse. Instead, you actually draw the four line segments that make up a single flake pattern and return from the function. You use the <code>up()</code>, <code>down()</code>, and <code>setpos()</code> methods from the <code>turtle</code> module, which you learned about in the <a class="xref">“Drawing with <code>turtle</code> Graphics”</a> section.</p>
<div class="codeline">
<p class="clf">    else:</p>
<p class="cl">        # draw cone</p>
<p class="cl">        t.up()</p>
<p class="cl">      <!--<ccust1>1</ccust1>-->❶ t.setpos(p1[0], p1[1])</p>
<p class="cl">        t.down()</p>
<p class="cl">        t.setpos(p2[0], p2[1])</p>
<p class="cl">        t.setpos(p3[0], p3[1])</p>
<p class="cl">        # draw sides</p>
<p class="cl">        t.up()</p>
<p class="cl">      <!--<ccust1>2</ccust1>-->❷ t.setpos(x1, y1)</p>
<p class="cl">        t.down()</p>
<p class="cl">        t.setpos(p1[0], p1[1])</p>
<p class="cl">        t.up()</p>
<p class="cl">      <!--<ccust1>3</ccust1>-->❸ t.setpos(p3[0], p3[1])</p>
<p class="cl">        t.down()</p>
<p class="cll">        t.setpos(x2, y2)</p>
</div>
<p>First you draw the cone formed by points <code>p1</code>, <code>p2</code>, and <code>p3</code> <!--<ccust1>1</ccust1>-->❶. Then you draw lines <img alt="" height="35" src="images/nsp-venkitachalam503045-m01021.jpg" width="47"/> <!--<ccust1>2</ccust1>-->❷ and <img alt="" height="35" src="images/nsp-venkitachalam503045-m01024.jpg" width="46"/> <!--<ccust1>3</ccust1>-->❸. Since you already performed all the required calculations at the start of the function, drawing is simply a matter of passing the appropriate coordinates to the <code>setpos()</code> method.</p>
</section>
<section>
<h3 class="bh" id="bh0307"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh0307">Writing the main() Function</a></h3>
<p class="paft">The <code>main()</code> function sets up a <code>turtle</code> object and calls <code>drawKochSF()</code>.</p>
<div class="codeline">
<p class="clf">def main():</p>
<p class="cl">    print('Drawing the Koch Snowflake...')</p>
<p class="clf">    t = turtle.Turtle()</p>
<p class="cl">    t.hideturtle()</p>
<p class="clf">    # draw</p>
<p class="cl">    try:</p>
<p class="cl">      <!--<ccust1>1</ccust1>-->❶ drawKochSF(-100, 0, 100, 0, t)</p>
<p class="cl">      <!--<ccust1>2</ccust1>-->❷ drawKochSF(0, -173.2, -100, 0, t)</p>
<p class="cl">      <!--<ccust1>3</ccust1>-->❸ drawKochSF(100, 0, 0, -173.2, t)</p>
<p class="cl">  <!--<ccust1>4</ccust1>-->❹ except:</p>
<p class="cl">         print("Exception, exiting.")</p>
<p class="cl">         exit(0)</p>
<p class="clf">    # wait for user to click on screen to exit</p>
<p class="cll">  <!--<ccust1>5</ccust1>-->❺ turtle.Screen().exitonclick()</p>
</div>
<p><span aria-label=" Page 14. " class="page" epub:type="pagebreak" id="p14" role="doc-pagebreak"/>In <a class="xref" href="nsp-venkitachalam503045-0012.xhtml#fig1-4">Figure 1-4</a>, you saw how you were going to draw three of the snowflakes to get a hexagonally symmetric image as the final output. You do this by making three calls to <code>drawKochSF()</code>. The coordinates used for points <i>A</i> and <i>B</i> are <code>(-100, 0), (100, 0)</code> for the first snowflake <!--<ccust1>1</ccust1>-->❶, <code>(0, -173.2), (-100, 0)</code> for the second <!--<ccust1>2</ccust1>-->❷, and <code>(100, 0), (0, -173.2)</code> for the third <!--<ccust1>3</ccust1>-->❸. Notice that these are the same coordinates you used earlier to draw a triangle in your <i>test_turtle.py</i> program. Try to work out the coordinates for yourself. (Hint: <img alt="" height="31" src="images/nsp-venkitachalam503045-m01025.jpg" width="205"/>.)</p>
<p>The <code>drawKochSF()</code> calls are enclosed in a Python <code>try</code> block to catch any exceptions that happen during drawing. For example, if you close the window while the drawing is still in process, an exception is thrown. You catch it in the <code>except</code> block <!--<ccust1>4</ccust1>-->❹, where you print a message and exit the program. If you allow the drawing to complete, you’ll get to <code>turtle.Screen().exitonclick()</code> <!--<ccust1>5</ccust1>-->❺, which will wait until you close the window by clicking anywhere inside <span class="idx" data-level1="drawing" data-level2="endRange" data-term="Koch snowflake"/>it.</p>
</section>
</section>
<section>
<h2 class="ah" id="ah0304"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah0304"><span class="idx" data-level1="running the code" data-term="Koch snowflake"/>Running the Snowflake Code</a></h2>
<p class="paft">Run the code in a terminal as follows. <a class="xref" href="nsp-venkitachalam503045-0012.xhtml#fig1-6">Figure 1-6</a> shows the output.</p>
<div class="codeline">
<p class="cls">$ <code class="b">python koch.py</code></p>
</div>
<figure class="figure" id="fig1-6">
<p class="fig"><img alt="" height="1164" src="images/nsp-venkitachalam503045-f01006.jpg" style="width:95%; height:auto;" width="1200"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 1-6:</span> The Koch snowflake output</p>
</figcaption>
</figure>
<p>There’s your beautiful snowflake!</p>
</section>
<section>
<h2 class="ah" id="ah0305"><span aria-label=" Page 15. " class="page" epub:type="pagebreak" id="p15" role="doc-pagebreak"/><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah0305">Summary</a></h2>
<p class="paft">In this chapter, you learned the basics of recursive functions and algorithms. You also learned how to draw simple graphics with Python’s <code>turtle</code> module. You put these concepts together to create a nice drawing of an interesting fractal called the Koch snowflake.</p>
</section>
<section>
<h2 class="ah" id="ah0306"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah0306">Experiments!</a></h2>
<p class="paft">Now that you have completed one <span class="idx" data-term="fractal"/>fractal drawing, let’s look at another interesting one called the <span class="idx" data-term="Sierpiński triangle"/><i>Sierpi</i><span class="dcrit-i">ń</span><i>ski triangle</i>, named after the Polish mathematician Wacław Sierpi<span class="dcrit">ń</span>ski. <a class="xref" href="nsp-venkitachalam503045-0012.xhtml#fig1-7">Figure 1-7</a> shows what it looks like.</p>
<figure class="figure" id="fig1-7">
<p class="fig"><img alt="" height="936" src="images/nsp-venkitachalam503045-f01007.jpg" style="width:95%; height:auto;" width="957"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 1-7:</span> The Sierpi<span class="dcrit">ń</span>ski triangle</p>
</figcaption>
</figure>
<p>Try drawing the Sierpi<span class="dcrit">ń</span>ski triangle with <code>turtle</code> graphics. You can use a recursive algorithm like you did to draw the Koch snowflake. If you look at <a class="xref" href="nsp-venkitachalam503045-0012.xhtml#fig1-7">Figure 1-7</a>, you’ll see that the large triangle is divided into three smaller triangles, with an upside-down triangular hole in the middle. Each of the three smaller triangles is itself divided into another three triangles plus a hole in the middle, and so on. That gives you a hint on how to split up your recursion.</p>
<p>(The solution to this problem is in the GitHub repository for the book <a class="url-i" href="https://github.com/mkvenkit/pp2e/blob/main/koch/koch.py">https://github.com/mkvenkit/pp2e/blob/main/koch/koch.py</a>)</p>
</section>
<section>
<h2 class="ah" id="ah0307"><span aria-label=" Page 16. " class="page" epub:type="pagebreak" id="p16" role="doc-pagebreak"/><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah0307"><span class="idx" data-level1="complete code listing" data-term="Koch snowflake"/>The Complete Code</a></h2>
<p class="paft">Here’s the complete code listing for this project:</p>
<div class="codeline">
<p class="clf">"""</p>
<p class="cl">koch.py</p>
<p class="clf">A program that draws the Koch snowflake.</p>
<p class="clf">Author: Mahesh Venkitachalam</p>
<p class="cl">"""</p>
<p class="clf">import turtle</p>
<p class="cl">import math</p>
<p class="clf"># draw the recursive Koch snowflake</p>
<p class="cl">def drawKochSF(x1, y1, x2, y2, t):</p>
<p class="cl">    d = math.sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2))</p>
<p class="cl">    r = d/3.0</p>
<p class="cl">    h = r*math.sqrt(3)/2.0</p>
<p class="cl">    p3 = ((x1 + 2*x2)/3.0, (y1 + 2*y2)/3.0)</p>
<p class="cl">    p1 = ((2*x1 + x2)/3.0, (2*y1 + y2)/3.0)</p>
<p class="cl">    c = (0.5*(x1+x2), 0.5*(y1+y2))</p>
<p class="cl">    n = ((y1-y2)/d, (x2-x1)/d)</p>
<p class="cl">    p2 = (c[0]+h*n[0], c[1]+h*n[1])</p>
<p class="cl">    if d &gt; 10:</p>
<p class="cl">        # flake #1</p>
<p class="cl">        drawKochSF(x1, y1, p1[0], p1[1], t)</p>
<p class="cl">        # flake #2</p>
<p class="cl">        drawKochSF(p1[0], p1[1], p2[0], p2[1], t)</p>
<p class="cl">        # flake #3</p>
<p class="cl">        drawKochSF(p2[0], p2[1], p3[0], p3[1], t)</p>
<p class="cl">        # flake #4</p>
<p class="cl">        drawKochSF(p3[0], p3[1], x2, y2, t)</p>
<p class="cl">    else:</p>
<p class="cl">        # draw cone</p>
<p class="cl">        t.up()</p>
<p class="cl">        t.setpos(p1[0], p1[1])</p>
<p class="cl">        t.down()</p>
<p class="cl">        t.setpos(p2[0], p2[1])</p>
<p class="cl">        t.setpos(p3[0], p3[1])</p>
<p class="cl">        # draw sides</p>
<p class="cl">        t.up()</p>
<p class="cl">        t.setpos(x1, y1)</p>
<p class="cl">        t.down()</p>
<p class="cl">        t.setpos(p1[0], p1[1])</p>
<p class="cl">        t.up()</p>
<p class="cl">        t.setpos(p3[0], p3[1])</p>
<p class="cl">        t.down()</p>
<p class="cl">        t.setpos(x2, y2)</p>
<p class="clf"># main() function</p>
<p class="cl">def main():</p>
<p class="cl">    print('Drawing the Koch Snowflake...')</p>
<p class="clf"><span aria-label=" Page 17. " class="page" epub:type="pagebreak" id="p17" role="doc-pagebreak"/>    t = turtle.Turtle()</p>
<p class="cl">    t.hideturtle()</p>
<p class="clf">    # draw</p>
<p class="cl">    try:</p>
<p class="cl">        drawKochSF(-100, 0, 100, 0, t)</p>
<p class="cl">        drawKochSF(0, -173.2, -100, 0, t)</p>
<p class="cl">        drawKochSF(100, 0, 0, -173.2, t)</p>
<p class="cl">    except:</p>
<p class="cl">        print("Exception, exiting.")</p>
<p class="cl">        exit(0)</p>
<p class="clf">    # wait for user to click on screen to exit</p>
<p class="cl">    turtle.Screen().exitonclick()</p>
<p class="clf"># call main</p>
<p class="cl">if __name__ == '__main__':</p>
<p class="cl">    main()</p>
</div>
</section>
</section>
</div></body></html>