["```py\nimport numpy as np\nrandom_seed = 1729\nnp.random.seed(random_seed)\nN = 40\nx = np.random.rand(N)\ny = np.random.rand(N)\n```", "```py\npoints = zip(x,y)\ncities = list(points)\n```", "```py\nitinerary = list(range(0,N))\n```", "```py\nitinerary = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29, \\30,31,32,33,34,35,36,37,38,39]\n```", "```py\nlines = []\n```", "```py\nfor j in range(0,len(itinerary) - 1):\n    lines.append([cities[itinerary[j]],cities[itinerary[j + 1]]])\n```", "```py\n[(0.21215859519373315, 0.1421890509660515), (0.25901824052776146, 0.4415438502354807)]\n```", "```py\ndef genlines(cities,itinerary):\n    lines = []\n    for j in range(0,len(itinerary) - 1):\n        lines.append([cities[itinerary[j]],cities[itinerary[j + 1]]])\n    return(lines)\n```", "```py\nimport math\ndef howfar(lines):\n    distance = 0\n    for j in range(0,len(lines)):\n        distance += math.sqrt(abs(lines[j][1][0] - lines[j][0][0])**2 + \\\n        abs(lines[j][1][1] - lines[j][0][1])**2)\n    return(distance)\n```", "```py\ntotaldistance = howfar(genlines(cities,itinerary))\nprint(totaldistance)\n```", "```py\nimport matplotlib.collections as mc\nimport matplotlib.pylab as pl\ndef plotitinerary(cities,itin,plottitle,thename):\n    lc = mc.LineCollection(genlines(cities,itin), linewidths=2)\n    fig, ax = pl.subplots()\n    ax.add_collection(lc)\n    ax.autoscale()\n    ax.margins(0.1)\n    pl.scatter(x, y)\n    pl.title(plottitle)\n    pl.xlabel('X Coordinate')\n    pl.ylabel('Y Coordinate')\n    pl.savefig(str(thename) + '.png')\n    pl.close()\n```", "```py\npoint = [0.5,0.5]\nj = 10\ndistance = math.sqrt((point[0] - cities[j][0])**2 + (point[1] - cities[j][1])**2)\n```", "```py\ndef findnearest(cities,idx,nnitinerary):\n    point = cities[idx]\n    mindistance = float('inf')\n    minidx = - 1\n    for j in range(0,len(cities)):\n        distance = math.sqrt((point[0] - cities[j][0])**2 + (point[1] - cities[j][1])**2)\n        if distance < mindistance and distance > 0 and j not in nnitinerary:\n            mindistance = distance\n            minidx = j\n    return(minidx)\n```", "```py\nnnitinerary = [0]\n```", "```py\ndef donn(cities,N):\n    nnitinerary = [0]\n    for j in range(0,N - 1):\n        next = findnearest(cities,nnitinerary[len(nnitinerary) - 1],nnitinerary)\n        nnitinerary.append(next)\n    return(nnitinerary)\n```", "```py\nplotitinerary(cities,donn(cities,N),'TSP - Nearest Neighbor','figure3')\n```", "```py\nprint(howfar(genlines(cities,donn(cities,N))))\n```", "```py\ninitial_itinerary = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26, \\27,28,29,30,31,32,33,34,35,36,37,38,39]\n```", "```py\nnew_itinerary = [0,1,2,3,4,5**,30,**7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27, \\28,29**,6,**31,32,33,34,35,36,37,38,39]\n```", "```py\nprint(howfar(genlines(cities,initial_itinerary)))\nprint(howfar(genlines(cities,new_itinerary)))\n```", "```py\ndef perturb(cities,itinerary):\n    neighborids1 = math.floor(np.random.rand() * (len(itinerary)))\n    neighborids2 = math.floor(np.random.rand() * (len(itinerary)))\n\n    itinerary2 = itinerary.copy()\n\n    itinerary2[neighborids1] = itinerary[neighborids2]\n    itinerary2[neighborids2] = itinerary[neighborids1]\n\n    distance1 = howfar(genlines(cities,itinerary))\n    distance2 = howfar(genlines(cities,itinerary2))\n\n    itinerarytoreturn = itinerary.copy()\n\n    if(distance1 > distance2):\n        itinerarytoreturn = itinerary2.copy()\n\n    return(itinerarytoreturn.copy())\n```", "```py\nitinerary = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29, \\30,31,32,33,34,35,36,37,38,39]\n\nnp.random.seed(random_seed)\nitinerary_ps = itinerary.copy()\nfor n in range(0,len(itinerary) * 50000):\n    itinerary_ps = perturb(cities,itinerary_ps)\n\nprint(howfar(genlines(cities,itinerary_ps)))\n```", "```py\ntemperature = lambda t: 1/(t + 1)\n```", "```py\nimport matplotlib.pyplot as plt\nts = list(range(0,100))\nplt.plot(ts, [temperature(t) for t in ts])\nplt.title('The Temperature Function')\nplt.xlabel('Time')\nplt.ylabel('Temperature')\nplt.show()\n```", "```py\ndef perturb_sa1(cities,itinerary**,time**):\n    neighborids1 = math.floor(np.random.rand() * (len(itinerary)))\n    neighborids2 = math.floor(np.random.rand() * (len(itinerary)))\n\n    itinerary2 = itinerary.copy()\n\n    itinerary2[neighborids1] = itinerary[neighborids2]\n    itinerary2[neighborids2] = itinerary[neighborids1]\n\n    distance1 = howfar(genlines(cities,itinerary))\n    distance2 = howfar(genlines(cities,itinerary2))\n\n    itinerarytoreturn = itinerary.copy()\n\n    **randomdraw = np.random.rand()**\n **temperature = 1/((time/1000) + 1)**\n\n   ** if((distance2 > distance1 and (randomdraw) < (temperature)) or (distance1 > distance2)):**\n        itinerarytoreturn=itinerary2.copy()\n\n    return(itinerarytoreturn.copy())\n```", "```py\nitinerary = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29, \\30,31,32,33,34,35,36,37,38,39]\nnp.random.seed(random_seed)\n\nitinerary_sa = itinerary.copy()\nfor n in range(0,len(itinerary) * 50000):\n    itinerary_sa = perturb_sa1(cities,itinerary_sa,n)\n\nprint(howfar(genlines(cities,itinerary))) #random itinerary\nprint(howfar(genlines(cities,itinerary_ps))) #perturb search\nprint(howfar(genlines(cities,itinerary_sa))) #simulated annealing\nprint(howfar(genlines(cities,donn(cities,N)))) #nearest neighbor\n```", "```py\nsmall = 10\nbig = 20\nitinerary = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29, \\30,31,32,33,34,35,36,37,38,39]\nitinerary[small:big] = itinerary[small:big][::-1]\nprint(itinerary)\n```", "```py\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, **19, 18, 17, 16, 15, 14, 13, 12, 11, 10**, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39]\n```", "```py\nitinerary = [0,1,2,3,4,5,6,7,8,9]\n```", "```py\nitinerary = [0,5,6,7,8,1,2,3,4,9]\n```", "```py\nsmall = 1\nbig = 5\nitinerary = [0,1,2,3,4,5,6,7,8,9]\ntempitin = itinerary[small:big]\ndel(itinerary[small:big])\nnp.random.seed(random_seed + 1)\nneighborids3 = math.floor(np.random.rand() * (len(itinerary)))\nfor j in range(0,len(tempitin)):\n    itinerary.insert(neighborids3 + j,tempitin[j])\n```", "```py\ndef perturb_sa2(cities,itinerary,time):\n    neighborids1 = math.floor(np.random.rand() * (len(itinerary)))\n    neighborids2 = math.floor(np.random.rand() * (len(itinerary)))\n\n    itinerary2 = itinerary.copy()\n\n **randomdraw2 = np.random.rand()**\n **small = min(neighborids1,neighborids2)**\n **big = max(neighborids1,neighborids2)**\n **if(randomdraw2 >= 0.55):**\n **itinerary2[small:big] = itinerary2[small:big][:: - 1]**\n **elif(randomdraw2 < 0.45):**\n **tempitin = itinerary[small:big]**\n **del(itinerary2[small:big])**\n **neighborids3 = math.floor(np.random.rand() * (len(itinerary)))**\n **for j in range(0,len(tempitin)):**\n **itinerary2.insert(neighborids3 + j,tempitin[j])**\n **else:**\n        itinerary2[neighborids1] = itinerary[neighborids2]\n        itinerary2[neighborids2] = itinerary[neighborids1]\n\n    distance1 = howfar(genlines(cities,itinerary))\n    distance2 = howfar(genlines(cities,itinerary2))\n\n    itinerarytoreturn = itinerary.copy()\n\n    randomdraw = np.random.rand()\n    temperature = 1/((time/1000) + 1)  \n\n    if((distance2 > distance1 and (randomdraw) < (temperature)) or (distance1 > distance2)):\n        itinerarytoreturn = itinerary2.copy()\n\n    return(itinerarytoreturn.copy())\n```", "```py\nif((distance2 > distance1 and randomdraw < temperature) or (distance1 > distance2)):\n```", "```py\nscale = 3.5\nif((distance2 > distance1 and (randomdraw) < (math.exp(scale*(distance1-distance2)) * temperature)) or (distance1 > distance2)):\n```", "```py\n`--snip--`\n# beginning of perturb function goes here\n\n    scale = 3.5\n    if((distance2 > distance1 and (randomdraw) < (math.exp(scale * (distance1 - distance2)) * temperature)) or (distance1 > distance2)):\n        itinerarytoreturn = itinerary2.copy()\n\n    return(itinerarytoreturn.copy())\n```", "```py\ndef perturb_sa3(cities,itinerary,time**,maxitin**):\n    neighborids1 = math.floor(np.random.rand() * (len(itinerary)))\n    neighborids2 = math.floor(np.random.rand() * (len(itinerary)))\n **global mindistance**\n **global minitinerary**\n **global minidx**\n    itinerary2 = itinerary.copy()\n    randomdraw = np.random.rand()\n\n    randomdraw2 = np.random.rand()\n    small = min(neighborids1,neighborids2)\n    big = max(neighborids1,neighborids2)\n    if(randomdraw2>=0.55):\n        itinerary2[small:big] = itinerary2[small:big][::- 1 ]\n    elif(randomdraw2 < 0.45):\n        tempitin = itinerary[small:big]\n        del(itinerary2[small:big])\n        neighborids3 = math.floor(np.random.rand() * (len(itinerary)))\n        for j in range(0,len(tempitin)):\n            itinerary2.insert(neighborids3 + j,tempitin[j])\n else:\n        itinerary2[neighborids1] = itinerary[neighborids2]\n        itinerary2[neighborids2] = itinerary[neighborids1]\n\n    temperature=1/(time/(maxitin/10)+1)\n\n    distance1 = howfar(genlines(cities,itinerary))\n    distance2 = howfar(genlines(cities,itinerary2))\n\n    itinerarytoreturn = itinerary.copy()\n\n    scale = 3.5\n    if((distance2 > distance1 and (randomdraw) < (math.exp(scale*(distance1 - distance2)) * \\temperature)) or (distance1 > distance2)):\n        itinerarytoreturn = itinerary2.copy()\n\n **reset = True**\n **resetthresh = 0.04**\n **if(reset and (time - minidx) > (maxitin * resetthresh)):**\n **itinerarytoreturn = minitinerary**\n **minidx = time**\n ****if(howfar(genlines(cities,itinerarytoreturn)) < mindistance):**\n **mindistance = howfar(genlines(cities,itinerary2))**\n **minitinerary = itinerarytoreturn**\n **minidx = time**\n\n    if(abs(time - maxitin) <= 1):\n        itinerarytoreturn = minitinerary.copy()\n\n    return(itinerarytoreturn.copy())**\n```", "```py\ndef siman(itinerary,cities):\n    newitinerary = itinerary.copy()\n    global mindistance\n    global minitinerary\n    global minidx\n    mindistance = howfar(genlines(cities,itinerary))\n    minitinerary = itinerary\n    minidx = 0\n\n    maxitin = len(itinerary) * 50000\n    for t in range(0,maxitin):\n        newitinerary = perturb_sa3(cities,newitinerary,t,maxitin)\n\n    return(newitinerary.copy())\n```", "```py\nnp.random.seed(random_seed)\nitinerary = list(range(N))\nnnitin = donn(cities,N)\nnnresult = howfar(genlines(cities,nnitin))\nsimanitinerary = siman(itinerary,cities)\nsimanresult = howfar(genlines(cities,simanitinerary))\nprint(nnresult)\nprint(simanresult)\nprint(simanresult/nnresult)\n```"]