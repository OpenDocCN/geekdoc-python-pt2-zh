# 12

B 树

![](img/chapterart.png)

第十一章展示了内存访问成本如何在不同介质之间变化。在本章中，我们将讨论这个问题如何从访问单个值扩展到访问新数据块的成本，并介绍一种新的数据结构来处理这一情况。

计算机科学中有许多例子表明，访问块内的数据成本较低，但检索新块的数据相对昂贵。例如，计算机可能会从硬盘中读取整块信息，称为 *页面*，并将其存储到内存中。在软盘视频游戏时代，你可能会看到一个提示，要求你“插入第 5 张磁盘中的第 7 张”，或者在游戏加载下一块数据时等待类似的提示。类似地，在线应用程序可能会从服务器通过互联网下载一致的数据块，让你在下载完整视频之前就能开始观看。

本章介绍了 *B 树*，这是一种自平衡的基于树的数据结构，由计算机科学家鲁道夫·拜尔（Rudolf Bayer）和爱德华·麦克雷特（Edward McCreight）设计，用来考虑检索新数据块的成本。B 树将多个数据存储在单个节点中，使我们可以一次性支付昂贵的检索费用以提取所有这些值。一旦节点被加载到本地内存中，我们就可以快速访问其中的值。其折衷是处理节点时的额外复杂性。

在计算领域，我们可能会遇到这个问题，尤其是在尝试索引庞大数据集时。考虑一个字面上天文数字大小的数据集的索引，其中包含指向每颗恒星、星系、星云、彗星、小行星以及其他天体图像的指针。该数据集仍然大于索引本身，但索引可能需要跨越许多较慢存储块。B 树提供了一种创新的方式，将索引和键结合起来，同时最小化检索成本。

B 树也是如何定义树的操作，确保它们不会变得极度不平衡的一个例子。正如我们在本章后面将看到的，B 树始终保持完美的平衡，所有叶节点的深度完全相同。

## B 树结构

B 树采用我们在字典树（tries）或四叉树（quadtrees）中看到的多路分支结构来存储单个键。实际上，这意味着它们允许内部节点拥有超过两个分支，因此它们几乎充满了指针。它们还需要在每个节点中存储多个键。B 树节点包含多个键，这不仅可以追踪多路分区，而且更重要的是，最大化我们通过提取单个节点所能检索到的数据量。

我们可以在日常在线配送的场景中看到将多个项目打包到一个节点中的好处。每个盒子都有运费，我们运送很多小盒子时，这些费用可能会迅速增加。这相当于从昂贵的存储中检索许多小的树节点。如果我们将几个项目放在同一个盒子里，我们就可以通过一起运输来降低费用。同样，B 树通过一起检索一个块中的多个键来减少检索的成本。

从形式上讲，我们用一个大小参数 *k* 来定义 B 树节点的大小，该参数提供了非根节点可以存储的元素数量的界限。所有非根节点存储排序后的 *k* 到 2*k* 个键。根节点更加灵活，允许包含 0 到 2*k* 个键。像二叉搜索树一样，内部节点使用这些键的值来定义分支的范围。内部节点为每个可能的分裂点存储指针，在节点中的每个键之前和之后，都可以有 *k* + 1 到 2*k* + 1 个子节点，除了根节点，它可以有 0 到 2*k* + 1 个子节点。这些分裂点在概念上与二叉搜索树中的分裂点相同——它们将空间划分为分裂点之前的键和分裂点之后的键。

图 12-1 展示了该结构的一个示例。包含键 12、31 和 45 的节点定义了四个独立的分区：小于 12 的键、介于 12 和 31 之间的键、介于 31 和 45 之间的键，以及大于 45 的键。包含 13、17 和 26 的子树通过父节点中的两个分裂点定义。该节点中的所有键必须大于 12，因为它们的子指针指向键 12 的右侧。同样，所有键必须小于 31，因为它们的指针指向键 31 的左侧。

![示例 B 树有 3 层。顶部节点有一个键（51）和指向 2 个子节点的指针。左侧子节点有键 12、31 和 45，并指向 4 个子节点，其中一个是包含 13、17、26 的子树。](img/f12001.png)

图 12-1：一个示例 B 树

将这个结构放在“综合趣味与信息收藏博物馆”庞大藏品的索引情境中来考虑。在允许动态更新藏品的尝试下，我们将每个项目的索引条目存储在一张小纸卡上，卡上写有项目名称、简短描述和在我们庞大收藏仓库中的位置。每个文件夹可以容纳九百张卡片，因此对于我们一亿个项目的收藏，我们需要超过十万个文件夹来存储整个索引。

尽管我们希望将整个索引存储在本地，但我们办公室的空间实在不足。一旦我们请求并取回包含索引部分的文件夹，我们就可以相对容易地浏览其中的条目。然而，每次请求新卷都需要前往档案室并填写请求表。

在这个组织方案中，每张索引卡对应 B 树中的一个条目，其中名称字符串是键。绑定器对应 B 树节点，每个节点有 900 个插槽，因此最多可以容纳 900 个键。绑定器中的条目是排序好的，这使得我们可以通过线性扫描或二分查找来搜索键。此外，我们在每个绑定器的插槽中还保存一个数据，即指向包含当前索引卡的键和前一张索引卡的键之间条目的绑定器指针。如图 12-2 所示，如果我们要查找目标“Caffeine Unlimited Coffee Mug”，我们会首先扫描“Caffeine Ten Coffee Mug”，它在字母顺序上排在目标之前，然后扫描“Jeremy’s Gourmet High-Caffeine Experience”，它排在目标之后。此时，我们已经越过了目标键的潜在位置，知道需要在当前条目之前的绑定器中进行搜索。

![我们的收藏品索引中的三项条目：Caffeine Ten 咖啡杯、Jeremy’s Gourmet High‐Caffeine Experience 咖啡杯和 Morning Zap 品牌咖啡杯。每个条目都有两个指针，一个是物品指针，一个是绑定指针。Jeremy’s Gourmet High‐Caffeine Experience 咖啡杯的绑定指针显示为一个箭头。](img/f12002.png)

图 12-2：我们索引卡中的绑定指针指示继续搜索时要使用哪个绑定器。

我们在绑定器的最末尾存储一个额外的指针，该指针指向另一个绑定器，包含所有在当前绑定器中最后一个键之后的键。总之，我们的绑定器最多可以包含 900 个键（以及指向相关收藏品的指针）和 901 个指向其他绑定器的指针。

与其他基于树的数据结构一样，我们使用顶层复合数据结构和节点特定数据结构来定义 B 树结构：

```py
BTree {
    BTreeNode: root
    Integer: k
}

BTreeNode {
    Integer: k
    Integer: size
    Boolean: is_leaf
    Array of Type: keys
    Array of BTreeNodes: children
}
```

在这个数据结构和下面的示例中，我们存储和检索单个键，以保持代码简单。与我们介绍的其他数据结构一样，在大多数情况下，存储一个复合数据结构，其中既包含键又包含指向键数据的指针会更有用，就像图 12-2 中的物品指针一样。

B 树结构的一个复杂性在于我们将键和子节点存储在两个不同大小的数组中。这意味着我们需要定义键在索引*i*时如何映射到其相邻的子节点指针。对于任何给定的索引*i*，我们可以访问*keys*[*i*]中的键，但我们还需要能够访问该键之前和之后的节点指针。我们定义指针的方式是，*children*[*i*]中的所有键值都小于*keys*[*i*]，并且大于*keys*[*i* − 1]（如果*i* > 0），如图 12-3 所示。

![键数组包含 12、31 和 45。子数组有 4 个指针：小于 12 的键，小于 31 且大于 12 的键，小于 45 且大于 31 的键，以及大于 45 的键。](img/f12003.png)

图 12-3：将键数组中的条目映射到子数组中相应的元素

根据定义，B 树是平衡的数据结构。每个叶子节点与根节点的深度相同。在后面的章节中，我们将展示如何通过插入和删除新键来更新节点，从而保持这种结构。

## 搜索 B 树

我们使用相同的通用程序来搜索 B 树，正如我们对所有基于树的数据结构所采用的做法：我们从树的顶部开始，逐层向下，直到找到我们感兴趣的键。B 树与二叉搜索树的主要区别在于，我们可能需要检查每个节点中的多个键。我们沿着每个节点中的键扫描，直到找到目标键或发现某个键值大于目标值。在后一种情况下，如果我们在内部节点上，我们会下移到适当的子节点，并继续搜索，如下所示：

```py
BTreeSearch(BTree: tree, Type: target):
    return BTreeNodeSearch(tree.root, target)

BTreeNodeSearch(BTreeNode: node, Type: target):
    # Search the node's key list for the target.
    Integer: i = 0
  ❶ WHILE i < node.size AND target >= node.keys[i]:
      ❷ IF target == node.keys[i]:
            return node.keys[i]
        i = i + 1

    # Descend to the correct child.
  ❸ IF node.is_leaf:
        return null
  ❹ return BTreeNodeSearch(node.children[i], target)
```

该搜索的代码通过使用`WHILE`循环 ❶扫描当前节点中存储的键开始。该循环一直持续，直到它到达键列表的末尾（`i == node.size`）或遇到一个比目标值大的键（`target < node.keys[i]`）。代码检查是否在当前节点中找到匹配的键，如果找到，则返回该键 ❷。虽然示例代码为了简化演示使用了线性扫描来搜索节点，但我们也可以使用二分搜索来提高效率。

如果代码在当前节点中没有找到匹配项且当前节点是叶子节点，则表示树中没有匹配项，代码返回`null` ❸。否则，代码会递归地探索正确的子节点。它可以直接通过循环迭代器 `i` ❹访问正确的子节点，因为当 `i` 表示最后一个子节点或 `key[i] > target` 时，循环会停止。

考虑在图 12-1 中展示的 B 树中搜索键 17 的例子。在根节点中，我们检查第一个键（51），并发现它大于 17，因此我们通过第一个子指针下移一级。在下一级，我们检查两个键：12 小于目标值，因此我们跳过它；31 大于目标值，因此我们通过第二个子指针下移到一个子节点，该子节点的键值小于 31。这个过程一直持续到叶子节点。图 12-4 展示了这一搜索过程，图中用灰色标出了我们访问和比较的数组区间。

![B 树的搜索访问了顶级节点中的键 51、第二级子节点中的键 12 和 31，以及第三级子节点中的键 13 和 17。](img/f12004.png)

图 12-4：B 树的一个搜索示例。阴影单元格是算法检查过的单元。

我们应该考虑在节点内搜索键值对运行时的影响：与单次比较后直接进入下一级不同，现在可能需要在每个节点上执行多个比较。这是一个可以接受的权衡，原因有二。首先，记住 B 树是经过优化的，目的是减少访问的节点数量。相比之下，节点内部的数据访问预期是相对廉价的，因为它们发生在本地内存中，并不需要我们从昂贵的存储中获取另一个数据块。其次，同样重要的是，B 树的分支结构仍然提供了大量的剪枝机会。每次比较依然可以排除整个子树。而且，像当前节点一样，每个被跳过的节点最多可能包含 2*k*个键值和 2*k* + 1 个子节点。

回到我们的收藏品示例，考虑搜索某个特定的收藏品。我们从根文件夹开始。由于键值是按字母顺序存储的，我们可以迅速浏览行，直到找到我们想要的键值，或者经过它应在的位置。如果我们没有看到目标键值，我们就知道它不在这个文件夹中。我们会抱怨一番有限存储空间的不公平，并注意到我们遇到的第一个比目标键值大的键值，它的项目指针指向“文件夹#300”。我们会继续抱怨几句，然后向档案管理员索要文件夹#300。

让我们将这种存储方式与将所有索引卡片按排序顺序存储的情况进行对比。文件夹#1 包含从*Aa*到*Ab*的第一组卡片，文件夹#2 包含*Ac*到*Ad*，依此类推。这对于静态数据集来说可能效果不错。我们可以对文件夹进行二分查找，每次请求当前范围内的中间文件夹，并将请求次数限制在对数级别。然而，随着卡片的增删，这种方式开始崩溃。文件夹变得过满，要求我们将卡片从一个文件夹移动到另一个文件夹。更新集合时可能需要级联更新多个文件夹，因为卡片必须被移位。在最坏的情况下，如果我们将文件夹装得满满的，我们可能需要访问索引中的每个文件夹。正如我们接下来所看到的，B 树结构有助于数据集的动态变化。

## 添加键值

向 B 树添加键值比我们之前考虑的基于树的其他数据结构要复杂。在这种情况下，我们需要保持结构平衡，并限制每个节点中存储的键值数量（介于*k*和 2*k*之间）。处理满节点有两种方法。第一，我们可以在树的过程中分裂，确保我们永远不会在满节点上执行插入操作。第二，我们可以暂时将键值插入到满节点中（允许其超载），然后在返回的过程中进行分裂。我们将探讨后一种方法，它导致了一个两阶段的算法来插入新键值。

为了执行插入操作，我们首先沿着树向下搜索，寻找插入新键的位置。然后，我们返回到树的上方，拆分已经溢出的节点。每一次拆分都会增加节点的分支因子，但不一定增加树的高度。事实上，只有在拆分根节点时，我们才会增加树的高度。因为我们只是通过拆分根节点来增加树的高度（同时为每个叶子节点增加一个深度），我们可以保证树始终保持平衡。

### 添加算法

在算法的第一阶段，我们递归地向下遍历树，寻找插入新键的正确位置。如果在过程中找到匹配的键，我们可以更新该键的数据。否则，我们继续向下到达叶节点，在那里我们将键插入到数组中。

我们首先定义一个简单的辅助函数`BTreeNodeAddKey`，用于将一个键插入到一个非满的节点中。为了方便起见，我们还传递一个指向子节点的指针（表示新键*之后*的子节点），这样我们可以在拆分节点时重用这个函数。如果我们位于一个叶节点，该节点不存储指向子节点的指针，那么`next_child`指针将被忽略。

```py
BTreeNodeAddKey(BTreeNode: node, Type: key, 
                BTreeNode: next_child):
  ❶ Integer: i = node.size - 1
    WHILE i >= 0 AND key < node.keys[i]:
        node.keys[i+1] = node.keys[i]
        IF NOT node.is_leaf:
            node.children[i+2] = node.children[i+1]
        i = i - 1

 # Insert both the key and the pointer to the child node.
  ❷ node.keys[i+1] = key
    IF NOT node.is_leaf:
        node.children[i+2] = next_child
  ❸ node.size = node.size + 1
```

代码从`keys`数组的*末尾*（索引`node.size – 1`）开始，并通过`WHILE`循环 ❶向索引 0 方向推进。在每一步中，代码会检查新键是否应该插入当前位置，如果不应该，就将`keys`和`children`数组中的当前元素向后移动一个位置。循环在超过正确位置一步时终止，这个位置可能是数组的起始位置。一旦找到新键的正确插入位置，已经移动了新键和后续元素的位置。我们可以直接插入新键和子节点 ❷。代码最后通过调整节点的大小来考虑插入 ❸。

在这里，我们可能会对在数组中线性地移动项以腾出位置来插入新元素的成本感到惊讶，如图 12-5 所示。这正是我们在第三章中提到的所有问题。但请记住，我们正在权衡这些（有限的）线性成本，以尽量减少对节点的访问。我们愿意忍受将卡片移到活页夹中的麻烦，以最小化未来对其他活页夹的需求。

![一个包含四个位置的数组。键 26 被插入到数组的第二个位置，随后两个键 31 和 45 分别向后移一个位置。](img/f12005.png)

图 12-5：在`BTreeNodeAddKey`中将元素移位以插入 26

我们需要一些额外的辅助函数来处理节点填满的情况。请记住，我们每个节点最多只能包含 2*k*个元素——超过这个数量就需要拆分节点。首先，我们从一个简单的访问器函数`BTreeNodeIsOverFull`开始，该函数返回一个布尔值，表示节点是否包含超过 2*k*个元素：

```py
BTreeNodeIsOverFull(BTreeNode: node):
    return node.size == (2 * node.k + 1)
```

这相当于检查我们是否已经用完了活页夹中的所有口袋。

我们还添加了第二个辅助函数 `BTreeNodeSplit`，它接收一个节点和一个子节点的索引，并拆分该子节点。该索引之前的内容保留在原子节点中，索引之后的内容从子节点中清除，并添加到新创建的兄弟节点中。位于该索引处的关键字会从子节点中清除并添加到当前（父）节点中。

```py
BTreeNodeSplit(BTreeNode: node, Integer: child_index): 
  ❶ BTreeNode: old_child = node.children[child_index]
    BTreeNode: new_child = BTreeNode(node.k)
    new_child.is_leaf = old_child.is_leaf

    # Get the index and key used for the split.
  ❷ Integer: split_index = Floor(old_child.size / 2.0)
    Type: split_key = old_child.keys[split_index]    

    # Copy the larger half of the keys (and their children) to 
    # new_child and erase them from old_child.
    Integer: new_index = 0
    Integer: old_index = split_index + 1
  ❸ WHILE old_index < old_child.size:
        new_child.keys[new_index] = old_child.keys[old_index]
        old_child.keys[old_index] = null

        IF NOT old_child.is_leaf:
            new_child.children[new_index] = old_child.children[old_index]
            old_child.children[old_index] = null
        new_index = new_index + 1
        old_index = old_index + 1

    # Copy the remaining child (after the last key).
  ❹ IF NOT old_child.is_leaf:
        new_child.children[new_index] = old_child.children[old_child.size]
        old_child.children[old_child.size] = null

    # Remove the key at index and add it to the current node.
  ❺ old_child.keys[split_index] = null
  ❻ BTreeNodeAddKey(node, split_key, new_child)

    # Update the sizes of the nodes.
  ❼ new_child.size = old_child.size - split_index - 1
    old_child.size = split_index
```

`BTreeNodeSplit`的代码首先查找要拆分的节点（`old_child`）并创建一个新的（空的）兄弟节点（`new_child`）❶。该节点将与要拆分的子节点处于同一级别，因此我们将 `is_leaf` 的值复制过去。接下来，代码确定用于拆分点的索引和关键字❷。然后，代码使用 `WHILE` 循环将 `old_child` 中 `split_index` 之后的内容从 `keys` 和 `children` 数组复制到 `new_child` 中的相应数组❸。代码使用一对索引来捕获旧位置的索引（`old_index`）和相应的新位置（`new_index`）。同时，代码通过将条目设置为 `null` 来从 `old_child` 的数组中删除元素。由于 `children` 数组多了一个元素，我们需要单独复制最后一个元素❹。最后，我们删除 `split_index` 处的关键字❺，将 `split_key` 和新的子节点指针添加到当前节点❻，并设置两个子节点的大小❼。

让我们在我们的收藏品存储索引的上下文中查看这个操作，如图 12-6 所示。当文件夹达到容量时，我们将其内容重新划分为两个文件夹。首先，我们购买一个新的空文件夹。这个兄弟文件夹将存储大约一半的超满文件夹内容。其次，我们小心地将超满文件夹后半部分的内容迁移到新文件夹中，并保持排序顺序。第三，我们移除唯一的索引卡片，该卡片的关键字位于两个文件夹的关键字之间，并将其插入到父文件夹中，以指示两个子文件夹之间的分割。之前超满的子文件夹将包含关键字在此分割之前的卡片，而新文件夹将包含关键字在此分割之后的卡片。

![一排有三个条目的商品：Caffeine Ten 咖啡杯、Jeremy’s Gourmet 高咖啡因体验咖啡杯和 Morning Zap 品牌咖啡杯。箭头指示左边的卡片（以及所有之前的卡片）保留在文件夹中。第二个箭头指示中间的卡片进入父文件夹。第三个箭头指示右边的卡片和所有后续卡片进入新的文件夹。](img/f12006.png)

图 12-6：我们通过在中间卡片的关键字上拆分来重新划分文件夹。

给定这些辅助函数，我们现在可以定义一个插入函数，该函数执行递归查找和随后的添加操作。我们在叶节点进行添加。当递归返回到树的上层时，我们检查最近访问的子节点是否已满，因此需要进行拆分。

```py
BTreeNodeInsert(BTreeNode: node, Type: key):
    Integer: i = 0
  ❶ WHILE i < node.size AND key >= node.keys[i]:
      ❷ IF key == node.keys[i]:
            Update data.
            return
        i = i + 1

    IF node.is_leaf:
      ❸ BTreeNodeAddKey(node, key, null)
    ELSE:
      ❹ BTreeNodeInsert(node.children[i], key)
      ❺ IF BTreeNodeIsOverFull(node.children[i]):
          ❻ BTreeNodeSplit(node, i)
```

代码首先找到`key`在`keys`数组中的正确位置 ❶。`WHILE` 循环会遍历数组，直到它到达键列表的末尾（`i == node.size`）或遇到一个大于目标的键（`key < node.keys[i]`）。如果代码找到了完全匹配，它会更新该键的任何数据并返回 ❷。否则，它需要插入新数据。

如果键被插入到叶节点中，代码会使用`BTreeNodeAddKey`函数 ❸，该函数将数组元素移位并将新键插入正确的位置。如果键被插入到内部节点中，索引`i`提供了正确子节点的指针用于插入。代码会递归地插入到该子节点 ❹，然后检查插入后是否破坏了 B 树的属性（特别是节点大小应在 *k* 和 2*k* 之间） ❺。

如果代码将太多元素插入到一个节点中，它会破坏 B 树的属性。我们可以使用辅助函数`BTreeNodeIsOverFull`来检查最近修改的节点是否包含太多元素。代码从父节点进行此检查，因此我们可以保持修复 B 树的逻辑简单。它使用`BTreeNodeSplit`将过满的子节点拆分为两个节点 ❻。在这个插入过程中，当插入新的分隔键时，我们可能会破坏当前节点，但没关系；当我们回到这个节点的父节点时，我们会处理它。

我们使用了一些额外的存储空间来简化代码。代码允许节点暂时过满，在等待父节点调用`BTreeNodeSplit`时，存储 2*k* + 1 个键和 2*k* + 2 个子节点。我们可以通过简单地为键和子节点分配足够大的数组来创建这个缓冲区。

我们可以将代码的第一阶段看作是为我们的收藏添加一个新的咖啡杯。我们为这个咖啡杯创建一个索引卡，并将其插入到我们的索引文件夹中。我们从根文件夹开始，寻找放置卡片的位置。在搜索过程中，我们按照相应的指针进入子文件夹。一旦我们到达一个叶文件夹，没有在索引卡上指示任何子项，我们就将新卡片放在那里。我们检查该文件夹是否现在（过）满，如果是，就开始重新分配它的内容。然后，我们按照请求它们的反向顺序将文件夹归还到存储中。如果我们刚刚拆分了一个文件夹并因此将新卡片转移到其父文件夹，我们也会检查是否需要拆分父文件夹。这个过程会一直持续，直到我们回到根文件夹。

我们需要为根节点定义一个额外的特殊情况。记住，拆分根节点是唯一允许我们增加树的高度的方式。我们需要定义一个包装函数来完成这项操作。幸运的是，我们可以重用之前的辅助函数：

```py
BTreeInsert(BTree: tree, Type: key): 
  ❶ BTreeNodeInsert(tree.root, key)

  ❷ IF BTreeNodeIsOverFull(tree.root):
      ❸ BTreeNode: new_root = BTreeNode(tree.k)
        new_root.is_leaf = False
        new_root.size = 0

      ❹ new_root.children[0] = tree.root
      ❺ BTreeNodeSplit(new_root, 0)
      ❻ tree.root = new_root
```

代码从使用`BTreeNodeInsert` ❶将`key`插入根节点开始。这个函数递归地向下遍历树，找到正确的位置插入新键，并通过各个层级返回，修复除了根节点外的所有 B 树属性。接着，代码通过对根节点使用`BTreeNodeIsOverFull` ❷检查根节点是否有太多元素。如果根节点有太多元素，代码通过创建一个新的空根节点来向树中添加一个新层级 ❸，将旧根节点指定为新根节点的第一个子节点 ❹，拆分这个（过满的）子节点 ❺，并更新树的根节点 ❻。在拆分之后，新的根节点将包含一个键和两个子节点。

在插入一个键的过程中，我们完成了从根节点到叶节点再返回的单次往返。我们需要访问（并修改）的节点数因此与树的深度成正比。由于我们的 B 树始终保持平衡，所有叶节点处于相同的深度，并且所有非根内部节点的分支因子至少为*k* + 1，因此节点检索的规模在*N*上按对数增长。总的工作量还包括节点内的线性操作，比如复制或移动键值，因此所需的总工作量与*k* × log*k*成正比。

### 添加键的示例

让我们考虑一些例子，以更好地理解我们刚刚介绍的功能。首先，考虑最简单的情况，如图 12-7 所示，即向一个不会过满的叶节点添加键。假设*k* = 2，在这种情况下，我们的非根节点可以包含 2 到 2*k* = 4 个元素。如果我们将键 30 添加到图 12-7(a)中的子树，我们只需向下遍历到叶节点，并使用`BTreeNodeAddKey`辅助函数将新键添加到数组的正确位置。由于叶节点已有四个元素，我们不需要拆分它。我们得到的子树如图 12-7(b)所示。

![图 A 显示一个包含一个内部节点和四个叶节点的子树。第二个叶节点包含键 13、17 和 26。图 B 显示相同的树，但在第二个子节点的末尾添加了键 30。该节点现在包含键 13、17、26 和 30。](img/f12007.png)

图 12-7：向一个未满的 B 树叶节点插入键 30（a）后，得到一个包含四个元素的叶节点（b）。

随着节点的填充，逻辑变得更加复杂。考虑在图 12-8(a)中向同一棵树添加键 29 的示例。在图 12-8(b)中插入新键后，叶节点已满。我们通过识别过满节点的分割点（键=26）并将其提升到父节点来处理此问题。然后，我们使用辅助函数`BTreeNodeSplit`将叶节点分成两个兄弟节点，如图 12-8(c)所示。如果提升中间元素导致内部节点已满，我们还需要对其进行拆分。

![图 A 显示了一个包含一个内部节点和四个叶子节点的子树。第二个叶子节点包含键 13、17、26 和 30。在图 B 中，键 29 已被添加到第二个子节点，导致该节点存储的键值过多，包含键 13、17、26、29 和 30。在图 C 中，第二个子节点被拆分成两个节点（13、17）和（29、30），并且键 26 被提升到其父节点。](img/f12008.png)

图 12-8：将键 29 插入到已满的叶子节点中（a）会使该叶子节点包含过多的元素（b）。我们必须拆分过满的叶子节点，以恢复 B 树的条件（c）。

最后，考虑一下如果我们的拆分一直传播到根节点会发生什么。假设在插入操作后，根节点本身变得过满，如图 12-9(a) 所示。我们在 图 12-9(b) 中通过拆分根节点并为树创建一个新的层级来解决这个问题。新的根节点仅包含一个元素，即之前根节点的中间键。请注意，与所有其他节点不同，根节点可以少于 *k* 个元素。事实上，每次我们拆分根节点时，都会创建一个仅包含一个元素的新根节点。

正如本节中的示例所示，B 树的修改仅限于在最初查找插入位置时访问的那些节点。由于我们不需要更新或修复其他分支，修改的节点数量仅受树的深度限制，因此按比例与 log*k* 成正比。

![图 A 显示了一个根节点过满的 B 树，根节点包含键 12、31、51、61 和 86。根节点有五个子节点，所有子节点都是叶子节点。图 B 显示了拆分后的树，新的根节点包含键 51，并有两个子节点。根节点的左子节点包含键 12 和 31。根节点的右子节点包含键 61 和 86。树的五个叶子节点保持不变。](img/f12009.png)

图 12-9：当 B 树的根节点变得过满时（a），我们将其拆分成两个兄弟节点，并将中间元素提升为新的根节点（b）。

## 删除键

删除键遵循类似于添加键的方法。我们需要再次保持结构平衡，并限制每个节点中存储的键的数量（在 *k* 和 2*k* 之间）。这导致删除键的算法是一个多阶段过程。首先，我们沿树向下搜索，就像在寻找键一样。一旦找到该键，我们将其删除。最后，我们返回树的上方，检查并修复那些键数量过少的节点。由于我们从不删除除空根节点之外的任何节点（减少所有叶子节点的深度），我们再次保证树始终保持平衡。

### 修复过少的节点

当我们从 B 树中删除键时，我们面临节点键数低于 *k* 个的风险。我们可以通过一个简单的辅助函数来检查这个条件：

```py
BTreeNodeIsUnderFull(BTreeNode: node):
    return node.size < node.k
```

根据 B 树的结构，我们可能需要使用两种不同的方法来修复一个节点不足的情况，下面我将讨论这两种方法。每种方法都依赖于通过相邻兄弟节点的关键字来扩展当前节点的关键字。在第一种情况下，我们直接将两个小的兄弟节点合并为一个节点。在第二种情况下，我们将一个较大兄弟节点的关键字转移到不足的节点中。我们使用哪个功能取决于这两个兄弟节点的关键字总数。两种辅助函数都通过父节点调用，父节点会传递分隔相邻兄弟节点的关键字的索引。

合并操作需要两个相邻的兄弟节点以及将它们分隔开的关键字，并将它们合并为一个大的子节点。因此，要求两个兄弟节点中关键字的总数*小于*2*k*，以确保新子节点是有效的。图 12-10 展示了这一过程，其中图 12-10(a) 描述了合并操作前的子树，图中间的子节点只有一个关键字。图 12-10(b) 展示了合并后的同一子树。

![图 A 显示了一个包含三个叶子节点和一个内部节点的节点。内部节点的关键字是 26 和 31。中间的叶子节点只有一个关键字 29，最右边的叶子节点有两个关键字 32 和 42。图 B 显示了一个包含两个叶子节点的节点。内部节点现在只有一个关键字 26。最右边的节点现在有关键字 29、31、32 和 42。](img/f12010.png)

图 12-10：B 树节点的合并操作

列表 12-1 显示了合并两个相邻兄弟节点的代码。

```py
BTreeNodeMerge(BTreeNode: node, Integer: index):
  ❶ BTreeNode: childL = node.children[index]
    BTreeNode: childR = node.children[index + 1]

    # Copy over the parent's key and the right child's first child pointer.
  ❷ Integer: loc = childL.size
    childL.keys[loc] = node.keys[index]
    IF NOT childL.is_leaf:
        childL.children[loc + 1] = childR.children[0]
    loc = loc + 1

  ❸ # Copy over the right child's keys and children.
    Integer: i = 0
    WHILE i < childR.size:
        childL.keys[loc + i] = childR.keys[i]
        IF NOT childL.is_leaf:
            childL.children[loc + i + 1] = childR.children[i + 1]
        i = i + 1
    childL.size = childL.size + childR.size + 1

    # Remove the key from the current node.
    i = index
  ❹ WHILE i < node.size - 1:
        node.keys[i] = node.keys[i + 1]
        node.children[i + 1] = node.children[i + 2]
        i = i + 1
    node.keys[i] = null
    node.children[i + 1] = null
    node.size = node.size – 1
```

列表 12-1：合并两个子节点的代码

代码将右子节点的关键字和父节点的分隔关键字附加到左子节点上。它首先检索两个子节点，我们分别称其为`childL`（左子节点）和`childR`（右子节点）❶。根据定义，`childL`中的任何关键字都小于分隔关键字，而`childR`中的任何关键字都大于分隔关键字。接下来，代码将父节点的分隔关键字和右子节点的第一个子指针附加到左子节点的末尾❷。它使用`WHILE`循环从右子节点复制剩余的关键字和指针❸。同时，它更新左子节点的大小。此时，已经成功将两个子节点合并为一个新节点。合并后的子节点指针存储在`node.children[index]`中。

代码的最后部分通过清理父节点来完成❹。它通过移动后续的关键字和指针，删除之前的分隔关键字和指向右子节点的指针，将最终的单元设置为`null`，并更新当前节点的大小。

在合并两个节点的过程中，我们从它们的父节点获取一个关键字。这可能会导致父节点的关键字数量少于*k*，因此我们需要在树的更高层级继续进行修复。

这一过程直接类似于我们在存储索引示例中合并绑定器的操作。如果一个索引绑定器包含的键太少，那么它就浪费空间和请求时间。我们不希望请求一个只有一张索引卡的绑定器。合并绑定器的过程是将一个子绑定器中的卡片连同父绑定器中的分隔卡片一起，按照正确的顺序放入另一个子绑定器中。由于我们已经请求了父绑定器和一个子绑定器（因此它们已经在本地内存中），我们可以通过一次额外的请求快速完成这个合并操作。

修复不足节点的第二种方法是将一个键（以及可能的子节点）从其相邻兄弟节点中转移过来。这种方法仅在兄弟节点能够承受丢失一个键时有效，因此适用于兄弟节点的键的总数必须至少为 2*k*的情况。虽然我们可以合并并优化地重新分割相邻的兄弟节点，但为了说明问题，我们使用了一种更简单的方法，只转移一个键。由于我们在删除或合并操作期间仅从一个节点中删除一个键，转移一个键就足以修复我们的不足节点。

然而，如图 12-11 所示，我们不能仅仅从一个子节点中取出一个键并把它交给另一个子节点。父节点中的分隔键强制执行分裂的边界。因此，我们进行两阶段转移。首先，我们将当前的分隔键从父节点转移到不足节点。其次，我们用另一个兄弟节点的键替换父节点中的分隔键。

![图 A 显示了一个包含三个叶子节点和一个内部节点的节点。内部节点有键 26 和 31。中间叶子节点只有一个键 29，最右边的叶子节点有三个键 32、42 和 45。图 B 显示了相同的子树。内部节点现在有键 26 和 32。中间叶子节点现在有两个键 29 和 31，而最右边的节点有两个键 42 和 45。](img/f12011.png)

图 12-11：B 树节点上的转移左操作

如清单 12-2 所示，我们将代码分成了两个辅助函数，一个用于将键从右子节点转移到左子节点，另一个则是反方向的转移。将键从右子节点转移到左子节点的代码会转移两个键：一个从右子节点到父节点，另一个从父节点到左子节点。

```py
BTreeNodeTransferLeft(BTreeNode: node, Integer: index):
  ❶ BTreeNode: childL = node.children[index]
    BTreeNode: childR = node.children[index + 1]
    Type: middle_key = node.keys[index]

  ❷ node.keys[index] = childR.keys[0]
  ❸ childL.keys[childL.size] = middle_key
    IF NOT childR.is_leaf:
        childL.children[childL.size + 1] = childR.children[0]
    childL.size = childL.size + 1

  ❹ Integer: i = 0
    WHILE i < childR.size - 1:
        childR.keys[i] = childR.keys[i + 1]
        IF NOT childR.is_leaf:
            childR.children[i] = childR.children[i + 1]
        i = i + 1

  ❺ childR.keys[i] = null
    IF NOT childR.is_leaf:
        childR.children[i] = childR.children[i + 1]
        childR.children[i + 1] = null
  ❻ childR.size = childR.size – 1
```

清单 12-2：将一个键和子指针从右侧兄弟节点转移到不足节点的代码

代码首先通过获取两个相邻的兄弟节点和分隔键 ❶ 开始。它将右侧子节点中的第一个键移动到替换之前的分隔键 ❷。然后，它将来自父节点的前一个分隔键（`middle_key`）和右侧子节点的第一个子指针追加到左侧子节点数组的末尾 ❸。现在，左侧子节点和父节点都已更新。接着，代码清理右侧子节点。它使用 `WHILE` 循环移动剩余的元素 ❹，将现在空的位置标记为 `null` ❺，并调整大小 ❻。

从左侧子节点转移键到右侧子节点的代码与示例 12-3 中展示的代码类似。双键转移则是相反的方向：一张从左侧子节点到父节点，另一张从父节点到右侧子节点。

```py
BTreeNodeTransferRight(BTreeNode: node, Integer: index):
  ❶ BTreeNode: childL = node.children[index]
    BTreeNode: childR = node.children[index + 1]
    Type: middle_key = node.keys[index]

    # Make space in childR for the new key and pointer.
  ❷ Integer: i = childR.size - 1
    WHILE i >= 0:
        childR.keys[i+1] = childR.keys[i]
 IF NOT childR.is_leaf:
            childR.children[i+2] = childR.children[i+1]
        i = i – 1
    IF NOT childR.is_leaf:
        childR.children[1] = childR.children[0]

  ❸ childR.keys[0] = middle_key
    IF NOT childR.is_leaf:
        childR.children[0] = childL.children[childL.size]
    childR.size = childR.size + 1

  ❹ node.keys[index] = childL.keys[childL.size – 1]

  ❺ childL.keys[childL.size - 1] = null
    IF NOT childL.is_leaf:
        childL.children[childL.size] = null
    childL.size = childL.size – 1
```

示例 12-3：从左侧兄弟节点向欠充实节点转移键和子指针的代码

代码首先通过获取两个相邻的兄弟节点和分隔键 ❶ 开始。接着，代码将右侧节点中的键和值移动，为新的元素腾出空间 ❷。它将来自父节点的前一个分隔键（`middle_key`）和左侧子节点的最后一个子指针追加到右侧节点的*开头* ❸，使其大小增加 1。然后，代码将左侧子节点中的最后一个键移动到父节点中的分隔键位置 ❹。最后，代码通过将现在空的条目标记为 `null` 并更新大小来清理左侧子节点 ❺。

与合并操作不同，任何转移操作都不会减少父节点中的键的数量。因此，我们不需要在树的更高层级进行修复。这些转移操作的物理对应是请求一个兄弟存储绑定器，并在两个子节点和父节点之间移动两张索引卡。我们从父节点取出位于两个绑定器之间的中间卡片，并将其添加到较不充实的子节点绑定器中。然后，我们用子节点中卡片更多的那张卡片替换父节点中的这张卡片。

我们可以将这三种修复功能以及选择它们的逻辑封装到一个帮助函数中，该函数接受当前节点和欠充实子节点的索引：

```py
BTreeNodeRepairUnderFull(BTreeNode: node, Integer: child):
  ❶ IF child == node.size:
        child = child - 1
  ❷ Integer: total = (node.children[child].size + 
                      node.children[child + 1].size)

    IF total < 2 * node.k:
      ❸ BTreeNodeMerge(node, child)
        return

 ❹ IF node.children[child].size < node.children[child + 1].size:
        BTreeNodeTransferLeft(node, child)
    ELSE:
        BTreeNodeTransferRight(node, child)
```

为了确定使用哪种修复策略，代码需要找到一个相邻的兄弟节点，并检查这两个子节点的键的总数。在这里，为了便于说明，我们使用一种简单的策略，即除非我们正在修复数组中的最后一个子节点❶，否则总是使用下一个子节点（`child + 1`）作为兄弟节点。如果我们正在修复数组中的最后一个子节点，我们则使用前一个子节点作为兄弟节点。代码检查这两个子节点的总键数❷。如果键的数量足够少（少于 2*k*），则使用`BTreeNodeMerge`函数合并这两个节点❸。否则，如果节点的键数达到 2*k*或更多，代码将使用`BTreeNodeTransferLeft`或`BTreeNodeTransferRight`将一个键移动到较小的节点❹。

### 查找最小值键

我们在删除操作中使用了另一个辅助函数——用于查找并返回给定节点下方或本身的最小键的代码。这个代码在 Listing 12-4 中，也可以单独用于计算 B 树中键的边界。

```py
BTreeNodeFindMin(BTreeNode: node):
  ❶ IF node.size == 0:
        return null
  ❷ IF node.is_leaf:
        return node.keys[0]
    ELSE:
      ❸ return BTreeNodeFindMin(node.children[0])
```

Listing 12-4：用于查找给定节点下方或本身的最小键的代码

代码包含三种可能的情况。如果节点为空，代码返回`null`以表示该节点中没有最小键❶。这种情况应该仅出现在空的根节点中，因为所有其他节点至少会有*k*个键。如果节点是非空叶子节点，代码返回该节点数组中的第一个（即最小）键❷。最后，如果节点是内部节点，代码会递归检查第一个子节点❸。

### 删除算法

我们从描述删除算法的顶层封装函数开始。这个函数相对简单，它调用递归删除函数，传入树的根节点。

```py
BTreeDelete(BTree: tree, Type: key):
    BTreeNodeDelete(tree.root, key)

    IF tree.root.size == 0 AND NOT tree.root.is_leaf:
        tree.root = tree.root.children[0]
```

正如我们在分割节点时仅增加了一层一样，只有当根节点变为空时，我们才从树中移除一层。如果 B 树并非完全空，空的根节点仍会在数组位置 0 中有一个有效的子节点。我们使用这个子节点来替换原来的根节点。

核心删除算法递归地遍历树，查找要删除的键。由于我们可能会将键的数量减少到低于所需的*k*，因此我们需要检查修改后的子节点是否现在变得过少，如果是，需进行修复。

```py
BTreeNodeDelete(BTreeNode: node, Type: key):
  ❶ Integer: i = 0
    WHILE i < node.size AND key > node.keys[i]:
        i = i + 1

    # Deletion from a leaf node.
    IF node.is_leaf:
        IF i < node.size AND key == node.keys[i]:
          ❷ WHILE i < node.size - 1:
                node.keys[i] = node.keys[i + 1]
                i = i + 1
            node.keys[i] = null
            node.size = node.size - 1
        return

    # Deletion at an internal node.
    IF i < node.size AND key == node.keys[i]:
      ❸ Type: min_key = BTreeNodeFindMin(node.children[i+1])
        node.keys[i] = min_key

      ❹ BTreeNodeDelete(node.children[i+1], min_key)
        IF BTreeNodeIsUnderFull(node.children[i+1]):
            BTreeNodeRepairUnderFull(node, i+1)
    ELSE:
      ❺ BTreeNodeDelete(node.children[i], key)
        IF BTreeNodeIsUnderFull(node.children[i]):
            BTreeNodeRepairUnderFull(node, i)
```

代码通过扫描键数组❶来查找当前节点中要删除的键。如果在该节点中找到匹配的键，`WHILE`循环结束，`i`是与键匹配的索引。

代码接着考虑叶子节点的情况。如果节点是叶子节点并且找到了键，代码通过将键向左移动来删除它❷。代码还会将最后一个元素设置为`null`并更新大小。由于叶子节点没有设置子指针，所以代码无需更改子指针。如果节点是叶子节点但没有找到键，代码则简单地返回。

代码接下来处理内部节点的情况。需要考虑两种情况：键在节点中，或者不在。如果代码在内部节点中找到了该键，它会用排序顺序中紧跟目标键的下一个键来替换该键 ❸。代码通过调用清单 12-4 中的 `BTreeNodeFindMin` 函数，从目标键后面的子节点中找到该下一个键。然后，代码通过调用 `BTreeNodeDelete` ❹ 删除子树中的该键。接着，代码检查该子节点是否不足，如果是，则进行修复。

如果目标键不在内部节点中，则代码会递归地调用 `BTreeNodeDelete` 来处理相应的子节点 ❺。同样，它需要检查该子节点是否已经变得不足，如果是，则进行修复。

与插入操作一样，我们的目标是限制在此操作过程中访问的节点数量。删除操作最多只需要从根节点到叶子节点进行一次遍历。即使我们从内部节点进行删除，随后的替换和删除操作仍然仅会继续到一个单一的叶子节点。如果我们修复一个节点以获取该节点的兄弟节点，我们需要额外一次的请求。

### 删除键的示例

让我们看几个刚才讨论过的删除操作的示例。首先，考虑最简单的情况，如图 12-12 所示，从一个包含超过 *k* + 1 个键的叶子节点中删除一个键。假设 *k* = 2，那么我们的非根节点可以包含 2 到 2*k* = 4 个元素。如果我们从图 12-12(a)中的子树删除键值 5，我们只需要沿着路径进入叶子节点，并从数组中删除该键。由于结果叶子节点包含三个元素，因此我们不需要进行修复。我们得到的子树如图 12-12(b)所示。

![图 A 显示了一个子树，包含一个内部节点和五个叶子节点。第一个叶子节点包含键值 1、3、5 和 6。图 B 显示了与图 A 相同的树，其中从第一个叶子节点的中间删除了键值 5。此时，该节点包含键值 1、3 和 6。](img/f12012.png)

图 12-12：从 B 树的叶子节点删除键值 5 (a) 结果是一个包含三个元素的叶子节点 (b)。

接下来，我们考虑从一个不需要修复的内部节点中删除键的情况，如图 12-13 所示。如果我们从图 12-13(a)中的子树删除键值 45，我们发现该键位于一个内部节点中。为了删除它，我们用下一个按顺序排列的键替换它，即 47。由于结果节点中所有的键数都至少为两个，因此我们不需要进行任何修复。我们得到的子树如图 12-13(b)所示。

![图 A 显示一个包含一个内部节点和五个叶子节点的子树。内部节点包含键 12、26、31 和 45。第五个（最右边）叶子包含键 47、48 和 49。图 B 显示了与图 A 相同的树，内部节点中的键 45 被删除。之前位于图 A 中最右边节点中的键 47，替代了键 45。第五个叶子节点包含键 48 和 49。](img/f12013.png)

图 12-13：从内部 B 树节点中删除键 45 (a) 会导致从其子节点之一取出键 (b)。

最后，我们考虑不同的情况，在这些情况下，删除键需要我们修复一个不足的节点。图 12-14 显示了一个我们可以合并两个节点的情况。我们从删除图 12-14(a)中的键 32 开始。图 12-14(b)显示了我们用于合并操作的键：不足的节点中的键、它右侧相邻兄弟节点中的键，以及分隔这两个节点的父节点中的键。图 12-14(c)显示了修复后的树。新的子节点有四个键，之前的父节点有三个。

![图 A 显示一个包含一个内部节点和五个叶子节点的子树。内部节点包含键 12、26、31 和 45。第四个叶子包含键 32 和 42。第五个叶子包含键 47 和 48。在图 A 中，键 32 从叶子节点中删除，剩下一个键 42。图 B 显示了右侧最远的两个子节点和分隔键 45 的虚线。图 C 显示了合并后的最终树。内部节点现在有四个子节点，包含键 12、26 和 31。最右边的叶子节点包含键 42、45、47 和 48。](img/f12014.png)

图 12-14：从几乎为空的节点中删除键 32 (a) 会导致叶子节点元素过少 (b)。我们必须与相邻的兄弟节点合并，以恢复 B 树的条件 (c)。

图 12-15 显示了一个我们可以从较大的兄弟节点转移键的情况。我们从删除图 12-15(a)中的键 32 开始。图 12-15(b)显示了我们用来恢复平衡的键：不足的节点中的键、它右侧相邻兄弟节点中的键，以及分隔这两个节点的父节点中的键。图 12-15(c)展示了哪些键会移动以及它们的去向。修复后的树在图 12-15(d)中显示。

![图 A 显示了一个子树，包含一个内部节点和五个叶节点。内部节点包含键 12、26、31 和 45。第四个叶节点包含键 32 和 42。第五个叶节点包含键 47、48 和 49。在图 A 中，键 32 从叶节点中移除，剩下一个键 42。图 B 显示了一个虚线框住了最右侧的两个子节点和分隔键 45。图 C 包括箭头，表示最右侧的子节点中的键 47 将移动到父节点中，父节点中的键 45 将移动到该叶节点中。最终的树结构显示在图 D 中，内部节点有四个子节点，包含键 12、26、31 和 47。第四个叶节点包含键 42 和 45，第五个叶节点包含键 48 和 49。](img/f12015.png)

图 12-15：从几乎为空的节点中删除键 32（a）会导致叶节点的元素不足（b）。我们可以通过从相邻的兄弟节点中取一个键（c）来修复这个问题，以恢复 B 树的条件（d）。

最后，图 12-16 显示了一个通过合并根节点下唯一的两个子节点来移除树的一层的情况。图 12-16(b) 显示合并后，根节点为空，唯一的键已经移到合并后的节点。我们在图 12-16(c) 中通过移除旧根节点，并将该节点的唯一子节点提升为新根节点来修复这个问题。

与添加操作不同，删除操作可能会修改其他分支的节点。在删除过程中，合并节点和转移键会使用同一层次的兄弟节点。然而，修改的节点总数仍然受到树的深度限制。最多，我们每一层只能访问一个兄弟节点，访问的节点数量会随 *N* 的对数增长。

![图 A 中，根节点的键是 51，左子节点包含键 12 和 31，右子节点包含键 61。图 B 显示了合并操作后的结果，根节点为空，只有一个子节点，包含键 12、31、51 和 61。图 C 显示了最终的树结构，旧根节点已被移除，新的根节点是包含键 12、31、51 和 61 的节点。](img/f12016.png)

图 12-16：合并根节点下唯一的两个子节点（a）会导致根节点为空（b）。我们通过提升根节点的唯一子节点为新根节点（c）来修复这一问题。

## 为什么这很重要

B 树展示了一些重要的概念。首先，它们展示了如何调整先前数据结构的行为，以处理节点之间的内存访问比节点内部访问更昂贵的情况。B 树通过将索引和存储结合在一起，尽量减少我们所需的访问次数。这对于可能将信息存储在磁盘或外部服务器上的大数据集至关重要。通过对每个非根节点强制至少有 *k* 个键，我们确保每个节点的分支因子至少为 *k* + 1，从而扁平化整个数据结构。这有助于限制树的整体深度，从而减少搜索、插入或删除所需的检索次数。我们还确保每个非根节点始终保持至少半满，这意味着我们不会浪费时间去检索只有少量元素的节点（可能除了根节点）。

将 B 树的方法与我们收藏品的更专业化索引方案进行对比是很有帮助的。我们可以开发一个数据结构，最初根据类别进行拆分。顶级索引将收藏品的类别（如与咖啡相关的收藏品）映射到该特定类别的文件夹。每个类别的文件夹然后映射到所有子类别，如咖啡杯或咖啡海报。以此类推。这也是一种有效的方法，基于我们在本书中看到的分支结构。权衡在于通用性与效率之间。在许多情况下，我们可以进一步优化数据结构以适应当前任务，但可能失去将其应用于其他问题的能力。在某些情况下，这种权衡可能是值得的，而在其他情况下，则可能不是。与聚焦于类别的索引方案相比，B 树提供了一种更通用的方法，适用于任何可排序的键集。

B 树所展示的第二个概念是数据结构本身的第二级动态性。B 树不断调整其结构，以适应它所存储的数据分布，从而保持平衡。正如我们在第五章中看到的，如果我们的树变得极度不平衡，我们就会失去基于树的结构的优势。B 树通过在每个节点中对键数量的范围限制（*k* 到 2*k*）和保证所有叶子节点具有相同深度的方式，程序化地避免了这种情况。它们通过重新平衡来适应“糟糕”的输入数据分布——修复节点中过多或过少的项。尽管有许多其他的树平衡策略，B 树提供了一个简单且清晰的例子，展示了如何利用额外的结构（在这种情况下是每个节点多个键）来避免最坏的情况。
