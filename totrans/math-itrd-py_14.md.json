["```py\n*cellular Automata.pyde*\ndef setup():\n    size(600,600)\n\ndef draw():\n    for x in range(10):\n for y in range(10):\n            rect(20*x,20*y,20,20)\n```", "```py\n*cellular Automata.pyde*\nGRID_W = 15\nGRID_H = 15\n\n#size of cell\nSZ = 18\ndef setup():\n    size(600,600)\n\ndef draw():\n    for c in range(GRID_W): #the columns\n        for r in range(GRID_H): #the rows\n            rect(SZ*c,SZ*r,SZ,SZ)\n```", "```py\n*cellular Automata.pyde*\n#size of cell\nSZ = 18\n\nclass Cell:\n    def __init__(self,c,r,state=0):\n        self.c = c\n        self.r = r\n        self.state = state\n\n    def display(self):\n        if self.state == 1:\n            fill(0) #black\n        else:\n            fill(255) #white\n        rect(SZ*self.r,SZ*self.c,SZ,SZ)\n```", "```py\n*cellular Automata.pyde*\ndef createCellList():\n    '''Creates a big list of off cells with\n    one on Cell in the center'''\n ➊ newList=[]#empty list for cells\n    #populate the initial cell list\n    for j in range(GRID_H):\n     ➋ newList.append([]) #add empty row\n        for i in range(GRID_W):\n         ➌ newList [j].append(Cell(i,j,0)) #add off Cells or zeroes\n    #center cell is set to on\n ➍ newList [GRID_H//2][GRID_W//2].state = 1\n    return newList\n```", "```py\ndef setup():\n    global cellList\n    size(600,600)\n    cellList = createCellList()\n\ndef draw():\n    for row in cellList:\n        for cell in row:\n            cell.display()\n```", "```py\n*cellular Automata.pyde*\ndef setup():\n    global SZ,cellList\n    size(600,600)\n    SZ = width // GRID_W + 1\n    cellList = createCellList()\n```", "```py\n    def checkNeighbors(self):\n        if self.state == 1: return 1 #on Cells stay on\n        neighbs = 0\n        #check the neighbor above\n        if cellList[self.r-1][self.c].state == 1:\n            neighbs += 1\n```", "```py\ncellList[self.r - 1][self.c + 0] #above\ncellList[self.r + 1][self.c + 0] #below\ncellList[self.r + 0][self.c - 1] #left\ncellList[self.r + 0][self.c + 1] #right\n```", "```py\n*cellular Automata.pyde*\ndef checkNeighbors(self):\n    if self.state == 1: return 1 #on Cells stay on\n    neighbs = 0 #check the neighbors\n    for dr,dc in [[-1,0],[1,0],[0,-1],[0,1]]:\n        if cellList[self.r + dr][self.c + dc].state == 1:\n            neighbs += 1\n    if neighbs in [1,4]:\n        return 1\n    else:\n        return 0\n```", "```py\ndef draw():\n    for row in cellList:\n        for cell in row:\n         ➊ cell.state = cell.checkNeighbors()\n            cell.display()\n```", "```py\nIndexError: index out of range: 15\n```", "```py\n    *cellular Automata.pyde*\n    def checkNeighbors(self,cellList):\n        if self.state == 1: return 1 #on Cells stay on\n        neighbs = 0\n        #check the neighbors\n        for dr,dc in [[-1,0],[1,0],[0,-1],[0,1]]:\n         ➊ try:\n                if cellList[self.r + dr][self.c + dc].state == 1:\n                    neighbs += 1\n         ➋ except IndexError:\n                continue\n        if neighbs in [1,4]:\n            return 1\n        else:\n            return 0\n```", "```py\ncellList = newList  #?\n```", "```py\n>>> a = [1,2,3]\n>>> b = a\n>>> b\n[1, 2, 3]\n >>> a.append(4)\n>>> a\n[1, 2, 3, 4]\n>>> b\n[1, 2, 3, 4]\n```", "```py\n>>> a = [1,2,3]\n>>> b = a[::]\n>>> b\n[1, 2, 3]\n>>> a.append(4)\n>>> a\n[1, 2, 3, 4]\n>>> b\n[1, 2, 3]\n```", "```py\ngeneration = 0\n```", "```py\n*cellular Automata.pyde*\ndef setup():\n    global SZ, cellList\n    size(600,600)\n    SZ = width // GRID_W + 1\n    cellList = createCellList()\n\ndef draw():\n    global generation,cellList\n    cellList = update(cellList)\n    for row in cellList:\n        for cell in row:\n            cell.display()\n generation += 1\n    if generation == 3:\n        noLoop()\n\ndef update(cellList):\n    newList = []\n    for r,row in enumerate(cellList):\n        newList.append([])\n        for c,cell in enumerate(row):\n            newList[r].append(Cell(c,r,cell.checkNeighbors()))\n    return newList[::]\n```", "```py\nGRID_W = 41\nGRID_H = 41\n```", "```py\n    noStroke()\n```", "```py\n*cellular Automata.pyde*\ndef draw():\n    global generation,cellList\n ➊ frameRate(10)\n    cellList = update(cellList)\n    for row in cellList:\n        for cell in row:\n            cell.display()\n    generation += 1\n ➋ if generation == 30:\n        generation = 1\n        cellList = createCellList()\n```", "```py\n    *GameOfLife.pyde*\n    def checkNeighbors(self):\n        neighbs = 0  #check the neighbors\n     ➊ for dr,dc in [[-1,-1],[-1,0],[-1,1],[1,0],[1,-1],[1,1],[0,-1],[0,1]]:\n            try:\n                if cellList[self.r + dr][self.c + dc].state == 1:\n                    neighbs += 1\n            except IndexError:\n                continue\n     ➋ if self.state == 1:\n            if neighbs in [2,3]:\n                return 1\n            return 0\n        if neighbs == 3:\n            return 1\n        return 0\n```", "```py\nfrom random import choice\n```", "```py\nnewList [j].append(Cell(i,j,choice([0,1])))\n```", "```py\ndef draw():\n    global cellList\n    frameRate(10)\n    cellList = update(cellList)\n    for row in cellList:\n        for cell in row:\n            cell.display()\n```", "```py\n   *elementaryCA.pyde*\n➊ #CA variables\n   w = 50\n   rows = 1\n   cols = 11\n\n   def setup():\n       global cells\n       size(600,600)\n       #first row:\n    ➋ cells = []\n       for r in range(rows):\n           cells.append([])\n           for c in range(cols):\n               cells[r].append(0)\n    ➌ cells[0][cols//2] = 1\n\n   def draw():\n       background(255) #white\n       #draw the CA\n       for i, cell in enumerate(cells): #rows\n         for j, v in enumerate(cell): #columns\n          ➍ if v == 1:\n                 fill(0)\n            else: fill(255)\n          ➎ rect(j*w-(cols*w-width)/2,w*i,w,w)\n```", "```py\nif left == 1 and me == 1 and right == 1:\n```", "```py\nruleset = [0,0,0,1,1,1,1,0]\n```", "```py\n   *elementaryCA.pyde*\n   #CA variables\n   w = 50\n➊ rows = 10\n   cols = 100\n   --snip--\n   ruleset = [0,0,0,1,1,1,1,0] #rule 30\n\n➋ def rules(a,b,c):\n       return ruleset[7 - (4*a + 2*b + c)]\n\n   def generate():\n       for i, row in enumerate(cells): #look at first row\n           for j in range(1,len(row)-1):\n               left = row[j-1]\n               me = row[j]\n               right = row[j+1]\n               if i < len(cells) - 1:\n                    cells[i+1][j] = rules(left,me,right)\n       return cells\n```", "```py\ncells = generate()\n```"]