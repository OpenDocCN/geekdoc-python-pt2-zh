# 14

跳表

![](img/chapterart.png)

本章介绍了*跳表*，一种带有多个指针的排序链表，允许我们在搜索、插入或删除等操作中偶尔跳到链表中更远的元素。这种跳跃的潜力解决了链表的一个主要问题——我们不得不扫描所有元素才能找到一个目标。跳过一些元素能够节省宝贵的时间。

为了理解跳表的工作原理，可以考虑我每次丢失书中位置时采用的策略。为了避免剧透，我不会使用二分查找，因为二分查找可能跳到我尚未阅读的文本部分。相反，我从书的开头开始，每次跳过多页——跳跃的范围足够大，以至于我不需要扫描每一页，但又不至于大到如果跳得过远会破坏故事情节。我在搜索开始时使用较大的跳跃，但随着我接近上次读到的位置，逐渐改用越来越小的跳跃。跳表采用了类似的方法，显著改变了链表的行为，使其能够解决以前我们只会用基于树的数据结构来解决的问题。

跳表是由计算机科学家威廉·皮尤（William Pugh）提出的概率数据结构，它使得插入、删除和搜索等操作在*平均*情况下变得更加高效。跳表不是存储一个单一的链表，而是有效地创建了一层层链表，每一层只包含下一层节点的一个子集。这意味着我们从跳表的高层开始搜索，那里节点较少，并且可以跨越多个节点进行*跳跃*，避免不必要的节点。随着我们接近目标并精细化搜索，我们会在多级层次结构中逐渐下降。如果我们类比搜索一本书中的位置，这就相当于随着接近目标位置，我们逐渐减少跳跃的步幅。

我在本书中包含了跳表，主要有两个原因。首先，和几乎所有其他在本书中呈现的数据结构一样，跳表展示了如何通过额外的信息或结构提供显著的算法优势。在这种情况下，多个层次的链接降低了搜索的成本。其次，更令人兴奋的是，跳表是一种随机化的数据结构。与布隆过滤器（Bloom filters）不同，布隆过滤器根据数据是确定性的，跳表则将随机性的使用推向了一个新高度：它们的结构本身就是通过概率确定的，以平衡*平均*情况下的性能。我们使用随机数生成器来选择每个节点的层级，从而决定它允许我们跳跃的远近。

## 随机化与确定性结构

从确定性生成的数据结构到随机化结构的转变，既带来了复杂性，也带来了好处。我们迄今为止所研究的每种数据结构，其结构完全由我们插入的数据决定。例如，如果我们将相同的数据按相同的顺序插入二叉搜索树，我们将始终得到相同的结构。堆、字典树、网格、四叉树等也是如此。即便是两个哈希表或布隆过滤器，如果我们使用相同的哈希函数并插入相同的项，它们也将是相同的。

这种确定性在面对最坏情况数据时可能会引发问题。正如我们在第五章所见，如果我们从一个空的二叉搜索树开始，并按有序顺序插入元素，我们的树实际上会变成一个有序链表。每个节点将只有一个子节点，且都指向相同的方向。缓解这个问题的一种潜在方法是随机插入数据。虽然我们可能会偶然选择一个糟糕的顺序，但发生这种情况的概率要低得多。

我们可以通过在每次插入时随机选择参数，将这种随机化方法扩展到构建数据结构本身。我们不再改变数据的顺序，而是改变如何将这些数据链接到结构中。

一开始，随机化方法可能看起来不太直观。如果我们不了解输入分布，我们很容易为该分布做出错误的结构选择。我们可能担心总是选择最坏的参数。然而，如果我们使用良好的随机化策略，这种失败的情况将变得非常罕见。另一方面，随机化设计能防止我们做出持续的次优选择。虽然它可能无法导致最优解，但通常能提供一个合理的解。随机性可以带来较好的平均情况表现。同时，随机性也有助于平滑处理那些数据以极端坏顺序到达的情况。

## 引入跳表

正如我们在第三章看到的，链表上的某些操作由于链表的结构本身而存在固有的限制。我们无法高效地搜索链表，因为无法随机访问元素。这会带来严重的后果；即使我们知道节点是有序的，我们也无法使用二分查找。我们只能沿着指针从一个节点遍历到另一个节点，直到找到目标节点。这种令人沮丧的限制让许多新计算机科学家抓狂，咕哝着不太友善的话语。

跳表通过提供跳跃多个节点的能力，帮助缓解了这种低效问题。从本质上讲，跳表只是一个带有多层节点的有序链表：

```py
SkipList {
    Integer: top_level
    Integer: max_level
    SkipListNode: front
}
```

字段`top_level`表示当前使用的最高层级，而字段`max_level`表示最高允许的层级。为了简化，我们独立指定`max_level`，以便在列表开始时预分配一组指针数组。

跳表的复杂性以及它的强大之处，源自于节点内部的指针结构。每个节点不只是存储指向下一个节点的单一指针，而是具有一个预定义的层级或*高度*，在这个高度上存储指向下一个节点的指针。高度为 *L* 的节点维护 *L* + 1 个不同的前向指针，分别对应每个层级 [0, *L*]。关键是，*L* 层级的指针将当前节点与下一个同层级的节点相连，这意味着 `next` 中的指针通常会指向不同的跳表节点。

```py
SkipListNode {
    Type: key
    Type: value
    Integer: height
    Array of SkipListNodes: next
}
```

由于跳表的较高层级包含的节点比下面的层级要少，这些较高层级的节点可以链接得更远，超出了低层级所能做到的范围。这使得算法在较高层级可以跨越多个节点，跳过许多中间节点。随着层级逐渐升高，节点的数量减少，这些链接的跳跃距离也变得越来越远。

想象一下搜索跳表的过程，就像通过手电筒在建筑物之间传递信息。你能够传递信息的距离取决于你所在的楼层以及路径中建筑物的高度。如果你卡在第一层，你只能将信息传递给相邻的建筑物。任何超出这个范围的建筑都会被相邻的建筑物挡住。然而，如果你运气好，正好在一栋高楼里，你可以越过较矮的建筑物，将信息传递得更远，就像在图 14-1 中所示。或者，如果你只需要将信息传递给邻近的人，你可以简单地下到最低一层。

![五栋不同高度的建筑物。建筑物 2 是最高的，建筑物 5 是次高的。箭头显示，从第二栋建筑的楼层可以越过中间两栋建筑的顶部，向最后一栋建筑传递信息。](img/f14001.png)

图 14-1：在跳表中节点之间的移动就像在城市的建筑物之间用手电筒传递信息。

跳表通过概率方式创建这些链接。程序为每个节点分配一个随机高度，与节点中存储的键值无关，并将新节点插入到它对应层级的列表中。因此，一个高度为 0 的节点只会出现在最底层的列表中，而一个高度为 2 的节点将出现在层级 0、1 和 2 的列表中。图 14-2 展示了这个示例。在上面的传递信息的例子中，这相当于一栋只有一层的建筑与一栋有三层的建筑。三层的建筑能够在三个不同的高度传递信息，可能接入最多三个邻居。

![跳表包含键值 0、1、8、9、12 和 17。每个节点的高度在 0 到 2 之间。节点 1 指向高度为 0 的节点 8、高度为 1 的节点 12 和高度为 2 的节点 17。](img/f14002.png)

图 14-2：一个示例跳表

由于较高层次的节点可以跳过更低层次的节点，因此理想情况下我们希望稀疏地使用这些节点，并将它们分布在整个列表中。在消息传递的示例中，我们不希望我们的城市景观只包含相同高度的建筑物。我们希望有很多单层建筑，一些中层建筑以及少数较高的建筑物，这些建筑物能够让我们的消息快速传递到街道的另一端。通过选择具有正确概率分布的高度，我们可以在平均情况下平衡每一层的密度。*L* + 1 层的节点比*L*层的节点要少。这有助于确保良好的平均性能，并避免其他数据结构中可能出现的最坏情况。

如图 14-2 所示，这个跳表实现使用了一个虚拟节点`front`来存储每一层前端的指针。节点`front`是一个`SkipListNode`，但不包含键值或数据。将列表的前端跟踪到一个`SkipListNode`中，使得插入和删除的代码大大简化，正如我们在本章稍后将看到的那样。

### 跳表搜索

为了搜索跳表，我们从最顶层的前端开始，遍历列表节点。根据图 14-2 中的插图更通俗地说，我们从左上角开始，向下和向右移动。在每次迭代中，我们检查是否还有下一个节点在该层，如果有，我们还需要检查该节点的键值是否小于我们的目标。如果这两个条件都满足，我们就移动到该层的下一个节点。如果其中任何一个条件不满足（我们已经到达该层的末尾，或者遇到一个键值大于或等于目标的节点），我们就会降到下一层继续搜索。我们的搜索会在尝试下降到底层时终止。

```py
SkipListSearch(SkipList: list, Type: target):
    Integer: level = list.top_level
  ❶ SkipListNode: current = list.front

  ❷ WHILE level >= 0:
        WHILE (current.next[level] != null AND
               current.next[level].key < target):
           current = current.next[level]
        level = level - 1

  ❸ SkipListNode: result = current.next[0]
  ❹ IF result != null AND result.key == target:
        return result.value
    ELSE:
        return null
```

跳表搜索的代码从`current`节点开始，该节点位于最顶层列表的前端 ❶。两个嵌套的`WHILE`循环负责遍历。内层循环遍历当前的链表，直到到达列表的末尾（`current.next[level] == null`）或者遇到一个键值大于或等于目标的节点（`current.next[level].key >= target`）。外层循环则每次迭代向下移动一层，直到到达列表底部 ❷。如果目标存在于列表中，它将位于下一个节点 ❸。但是，我们必须检查该节点是否存在并且具有正确的键值 ❹。当搜索循环终止时，我们可以确保我们已经到达了列表中最后一个键值小于目标的节点。目标要么是下一个节点，要么不存在。

假设我们在图 14-3 中展示的列表中搜索目标 14。从 3 层的前端开始。该层的第一个节点的键是 13，小于我们的目标，因此我们向该节点前进。此时，我们已经到达了 3 层列表的末端。我们无法在此高度继续向前，下一节点的指针为 null。

搜索然后下降到 2 层并继续在该层进行。在这里我们发现列表中的下一个键（14）*不*小于我们的目标，因此我们继续下降到 1 层。1 层和 0 层的情况相同——列表中的下一个键不小于我们的目标。我们的搜索在完成 0 层后终止。此时，我们当前节点（键=13）的`next`指针指向目标节点。

![搜索 14 从前端开始，沿着指针到达高度为 3 的节点 13，然后继续在该节点的层级向下遍历。](img/f14003.png)

图 14-3：在跳跃列表中搜索目标 14。阴影部分的条目和虚线指针表示在搜索过程中遍历的部分。

请注意，虽然我们在多个迭代中指向了目标节点（在 2、1 和 0 层），但我们仍然继续搜索，直到越过了最底层。这是由于我们代码中的终止条件。我们可以添加额外的逻辑来提前停止搜索，但为了简化，我们在这里保持与后续插入操作相同的逻辑。

相比之下，如果我们搜索相同的列表以寻找目标 12，如图 14-4 所示，我们将在搜索中明显更早下降到最底层，并沿着底层继续前进。

![搜索 12 从前端开始，沿着指针到达高度为 2 的节点 2，继续向下遍历该节点直到高度为 0，再沿着指针到达高度为 0 的节点 9。](img/f14004.png)

图 14-4：在跳跃列表中搜索目标 12。阴影部分的条目和虚线指针表示在搜索过程中遍历的部分。

我们可以将这种遍历过程想象成松鼠在树木行列中的导航。松鼠享受从更高的树枝上俯瞰的景色，跳跃从一棵树到另一棵，直到没有更多同样高度的树在它的目的地之前。每当可能时，它会在高大的老橡树之间跳跃，飞越它们之间的较矮小树苗。由于较高的树木比较稀少，因此它们之间的距离也较远，松鼠每次跳跃的距离也较长。从一棵高大树的宽树枝跳到其高大邻居的树枝所需的跳跃次数比穿越其中所有的小树苗要少。

然而，松鼠不愿意浪费时间回头，因此它永远不会超过目标。最终，松鼠会到达一个地方，如果它跳到这个层级的下一个树上，它将超过目标。或者可能已经没有这个高度的树了。不管怎样，松鼠叹了口气，勉强降到较低的树枝层级，然后继续前进。它在下一个层级上继续进展，尽可能大跳跃并享受风景，直到它再次遇到需要降级的地方。

### 添加节点

用于选择新节点高度的分布可能会对跳表的结构和性能产生重大影响。如果所有节点都处于相同的层级，无论是最小层级还是最大层级，跳表就会退化为一个排序的链表，只是附加了额外的内存开销。更糟糕的是，如果我们将所有高度都设置为最大值，就会创建多个平行列表，但没有任何搜索效率的提升。理想情况下，我们希望每一层的高节点较少，而下面每层的节点数量逐渐增加。

William Pugh 提出的选择节点高度的原始方法是不断使用一个常数概率*p*来增加一个新的层级。所有节点从 0 层开始。我们不断抛一个加权硬币——从 0 到 1 随机选择一个数字，并检查它是否小于*p*——直到我们得到一个大于*p*的数字，或者达到了最大允许的高度。我们统计小于*p*的抛掷次数，并将其作为新的层级。例如，我们可以选择*p* = 0.5，在这种情况下，我们预计大约有一半的节点会从层级*L*晋升到层级*L* + 1。我们可以通过调整*p*的值来平衡搜索效率和内存使用。较小的*p*值意味着较少的高层节点，从而每个节点的指针也较少。我们将节点的高度限制为`max_level`，以与`front`节点中的预分配数组保持一致。

你可以通过不一致的父母回应孩子要求更多糖果的请求来形象化这种方法。当孩子得到糖果时，他们总是得到一块，然后总是想要更多。每次孩子要求糖果时，父母会随机地（以概率*p*）决定是否满足请求。如果满足，就给孩子再一块。这对应于将节点的高度增加一层。自然，孩子看到自己的胜利后，立即再问一次。这个过程一直持续，直到父母最终变得恼火，以概率(1 − *p*)喊出明确的“没有更多糖果！”类似地，我们继续增加节点的高度，直到我们的随机数生成器或最大阈值告诉我们应该完全停止。

向跳表中添加节点遵循与查找目标节点相同的流程：我们向下并向右推进，寻找插入新节点的位置。实际上，我们可以重用查找的基本结构来进行插入。我们只需要跟踪一个额外的数据：每个级别上可能指向新节点的最后一个节点。

```py
SkipListInsert(SkipList: list, Type: key, Type: value):
    Integer: level = list.top_level
  ❶ SkipListNode: current = list.front
  ❷ Array: last = a size list.max_level + 1 array of SkipListNode pointers 
                  initially set to list.front for all levels.

  ❸ WHILE level >= 0:
      ❹ WHILE (current.next[level] != null AND
               current.next[level].key < key):
           current = current.next[level]
      ❺ last[level] = current
        level = level - 1

    SkipListNode: result = current.next[0]
  ❻ IF result != null AND result.key == key:
       result.value = value
       return

  ❼ Integer: new_level = pick a random level
  ❽ IF new_level > list.top_level:
        list.top_level = new_level
    SkipListNode: new_node = SkipListNode(key, value, new_level)

    Integer: j = 0
  ❾ WHILE j <= new_level:
         new_node.next[j] = last[j].next[j]
         last[j].next[j] = new_node
         j = j + 1
```

我们从列表的左上角开始（`list.front`的`list.top_level`）❶。通过一对嵌套的`WHILE`循环，我们向下并向右推进，寻找正确的插入位置。外层`WHILE`循环❸遍历列表的各个层级，每一层都保存最后一个看到的节点，然后下降到下一层。内层`WHILE`循环❹遍历跳表，每当该层的下一个节点的键小于我们的目标时，就向前移动。

数组`last`中的每个条目一开始都指向`list.front`，表示该节点被插入到列表的前端❷。每次从该级别下降时，我们都会更新`last`❺，因为我们已经看到该级别下一个节点的键大于或等于要插入的键（或者下一个节点为`null`），因此我们需要在该节点之前插入。如果在遍历跳表时碰巧找到了匹配的键，我们只需更新该键的数据❻。这意味着，像我们的其他数据结构一样，我们的跳表实现将每个键视为唯一。

当我们找到插入新节点的正确位置时，我们为这个节点随机选择一个高度❼。正如我们之前讨论的，我们用来选择这个高度的概率分布会对跳表的结构和性能产生重要影响。由于我们限制新高度小于`list.max_level`，因此避免了对`last`数组的无效访问。我们检查选定的高度是否代表列表的新顶层，如果是，则更新`list.top_level`❽。

最后，代码通过使用`WHILE`循环插入新元素，更新指针，使新节点指向正确的下一个节点❾。然后，它更新`last`中列出的每个节点，使它们指向我们的新节点。这里我们可以看到使用虚拟节点`front`（具有最大高度）来存储指向列表开头的指针的好处。我们可以像处理其他节点一样跟踪并更新这个“列表前端”位置。这大大简化了代码。

图 14-5 显示了我们如何将键 10 插入到一个示例跳表中。阴影部分的节点表示我们在查找过程中遍历的条目。

![数组 last 在高度 3 指向 front，在高度 2 指向节点 1，在高度 1 指向节点 1，在高度 0 指向节点 9。](img/f14005.png)

图 14-5：将键 10 插入跳表中。数组`last`跟踪插入节点前的节点。

通过跟踪每个层级中位于目标节点*之前*的最后一个节点，我们实际上是在跟踪哪个节点需要指向新的节点。随着我们遍历列表，我们记下需要插入新链接的位置。在每个层级，我们会遇到一个节点，其键值大于或等于我们的新键，这时我们可以大声说：“我看到了插入新节点的位置，就在这个节点之后！”然后我们下降到下一层，继续我们的工作。当搜索阶段到达最底层时，我们已经有了一个完整的节点列表，记录了我们需要调整前向指针的位置。

### 删除节点

从跳表中删除节点的算法几乎与插入节点的算法相同。我们首先在跳表中搜索删除目标，同时跟踪每个层级中位于目标节点*之前*的最后一个节点。一旦搜索阶段完成，我们更新这些前驱节点列表，以删除我们要删除的节点。

```py
SkipListDelete(SkipList: list, Type: target):
    Integer: level = list.top_level
  ❶ SkipListNode: current = list.front
    Array: last = a size list.max_level + 1 array of SkipListNode pointers 
                  initially set to list.front for all levels.

  ❷ WHILE level >= 0:
        WHILE (current.next[level] != null AND
 current.next[level].key < target):
           current = current.next[level]
        last[level] = current
        level = level - 1

  ❸ SkipListNode: result = current.next[0]
    IF result == null OR result.key != target:
        return

    level = result.height
    Integer: j = 0
  ❹ WHILE j <= level:
         last[j].next[j] = result.next[j]
         result.next[j] = null
         j = j + 1

  ❺ IF level == list.top_level:
        Integer: top = list.top_level
        WHILE top > 0 AND list.front.next[top] == null:
             top = top - 1
        list.top_level = top
```

删除代码的初始块与插入的代码完全相同。我们从列表的左上角开始 ❶。一对嵌套的`WHILE`循环 ❷在每个层级中搜索，直到遇到一个键值大于或等于`target`的节点，或遇到列表的末尾（`null`）。此时，我们记录下最后访问的节点，并降到下一层继续搜索。在搜索结束时，我们检查是否找到了一个`key`与`target`匹配的节点 ❸。如果没有找到匹配的节点，则跳表中没有要删除的节点。

为了删除已标识的节点，我们使用`WHILE`循环 ❹，简单地将跳表中每个节点的`last`的`next`指针指向当前节点之后的节点：`last[j].next[j] = result.next[j]`，适用于所有层级`j`。这样我们就把节点从列表中剪切出来了。我们还将`result.next[j]`设置为`null`，因为`result`不再在列表中。

最后，我们需要检查跳表的顶层是否仍然有效 ❺。如果我们删除了唯一一个高度为`top_level`的节点，那么`top_level`应该减少，以反映当前的最大高度。我们可以通过沿着`front`节点向下并检查`next`指针，直到找到一个非`null`的节点来更新`top_level`。在我们的删除函数中的最后一段代码会根据需要更新列表的顶层。如果列表为空，我们会默认将顶层设置为零。

再次，我们可以通过如何查看下一个节点并维护需要更新的节点列表来可视化删除所需的初始搜索。在每一层，我们在当前节点之前的节点上找到要删除的节点（如果它存在）。下一个节点的键大于或等于我们需要删除的键。我们停顿：“我最好标记下当前节点，因为我需要改变它的指针，跳过被删除的节点。”我们将当前节点的指针记录在 `last` 中，然后继续前进到下一层。在我们旅程的终点，我们已经收集了需要更新指针的节点的完整列表。

## 运行时间

搜索、插入和删除操作的成本都将依赖于节点的位置和高度的分布。在理想情况下，*L* 层的节点将包括 *L* − 1 层的每个其他节点。我们在每一层减少一半的节点，并将它们均匀间隔开来。在这种情况下，跳表的行为类似于二分查找。通过查看顶层的单个节点，我们可以修剪掉一半的搜索空间。然后我们降到下一层，再次将空间一分为二。因此，在最好的情况下，我们的性能将是对数级别的，取决于条目的数量。

跳表的最坏情况性能相当于标准链表的性能——它与节点数量成线性关系。如果链表中的每个节点都是相同高度，那么我们的跳表无非就是一个排序的链表。我们被迫顺序扫描每个节点，以找到给定的目标。

假设我们使用一种良好的高度概率分布，例如先前描述的 Pugh 原始技术（*p* = 0.5），那么插入、删除和搜索的*预期*成本都将随着条目数量呈对数增长。与最坏情况成本不同，预期成本提供了对数据结构平均性能的估计。这使得跳表的平均性能与二叉搜索树相当。

## 为什么这很重要

跳表旨在作为平衡搜索树的一种更简单的替代方案，是另一种支持高效搜索的动态数据结构。然而，与我们应用于此任务的其他算法（包括排序数组和二叉搜索树）不同，跳表依赖于随机化结构来提供良好的性能。我们常见操作的*预期*计算成本——搜索、插入和删除——是列表大小的对数级别。

这自然引出了一个问题：为什么我们要将算法的性能寄托于随机行为？我们可能会遇到高节点聚集的情况，或者高度分布过于平坦的情况。然而，二叉搜索树也面临同样的问题。如果我们以不理想的顺序插入和删除节点，最终可能会得到一条树节点的链表。虽然可以使用更复杂的二叉搜索树扩展来避免这种最坏情况，但跳表依赖于随机化来避免糟糕的行为。作为交换，它们使用了更简单的代码。因此，跳表展示了随机化如何在数据结构的实现中提供既能有效抵御坏数据又能保持简单性的优势。
