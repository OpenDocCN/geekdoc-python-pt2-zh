- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Python Philosophy
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: I believe the best place to start learning Python is not with the language itself,
    but with the guiding philosophy driving it. To write good Python code, you must
    first understand what Python is. That’s what this chapter will focus on.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: What Is Python, Exactly?
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python is a programming language developed in 1991 by Dutch programmer Guido
    van Rossum. The name refers not to the snake often used as a mascot, but to *Monty
    Python’s Flying Circus* (that fact alone should tell you a lot about the mindset
    behind the language). What began as a hobby project over Christmas break turned
    into one of the most perennially popular computer languages today.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: From a technical perspective, Python is considered a high-level, general-purpose
    language, with full support for the procedural, object-oriented, and functional
    programming paradigms, among others.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: 'Fans of Python are quick to point out its famous readability and simplicity,
    which lend to an initial feeling that the language is “magic.” This has also given
    rise to a less-than-useful bit of advice for newcomers: “Python is easy; it’s
    just pseudocode!”'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: 'That isn’t strictly true. Don’t let the natural readability fool you: Python
    is beautifully unique and influenced by many other languages, but it often bears
    little resemblance to any of them. To truly master it, one must take it by itself,
    not in strong comparison to other languages. That is exactly what this book will
    do.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Most importantly, however, Python is an idea. It’s the collective creation of
    a diverse group of nerds, united by nothing more than an audacious desire to build
    an awesome programming language. When you truly understand Python, it alters your
    entire perspective. You’re a part of something larger; something that has taken
    on a life of its own.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 'As Guido van Rossum explained in his famous King’s Day speech:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: I believe the most important idea is that Python is developed on the Internet,
    entirely in the open, by a community of volunteers (but not amateurs!) who feel
    passion and ownership.
  id: totrans-11
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Myths: What Python Isn’t'
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a lot of myths about Python, many of which lead to people shunning
    the language for certain applications, if not altogether.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 'Myth #1: Python Is Merely a Scripting Language'
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'I consider “scripting language” to be one of the most insidious terms used
    in discussing programming languages. It implies that the language is somehow unsuited
    for writing “real” software (see Myth #5).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Python is *turing-complete*, which means that you could implement any programming
    language in Python and then be able to execute any program written in that language.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: To put that another way, anything another programming language can do, Python
    can do. Whether it’s easy, or even advisable, depends on what you’re attempting.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'Myth #2: Python Is Slow'
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s easy to assume that high-level or interpreted languages like Python are
    naturally slower than compiled or low-level languages like C. In truth, it depends
    on the implementation of the language and how it’s used. In this book, we’ll cover
    several concepts related to improving the performance of Python code.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: The default implementation of the Python language interpreter, CPython, is written
    in C, and it is indeed slower than native machine code. However, there are various
    libraries and techniques—as well as other implementations of the language, including
    PyPy—which have much better performance overall (see Chapter 21) and even approach
    the speed of native machine code.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: With all that said, you should understand how performance actually factors into
    your project. In most situations, Python is plenty fast enough to be a good choice
    for application development, data analysis, scientific computing, game development,
    web development, and the list goes on. The performance drawbacks inherent in CPython
    usually only become problematic when you are dealing with very specific scenarios
    demanding extraordinarily high performance. Even then, there are ways around the
    bottlenecks. For the majority of projects, Python’s baseline performance is more
    than sufficient.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'Myth #3: Python Cannot Be Compiled'
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python is an *interpreted language*, meaning the code is read, interpreted,
    and executed at runtime by the language’s *interpreter*. An end user running a
    project written in Python will typically have to have the Python interpreter installed.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: This contrasts with what I like to call *assembled languages*, like C, C++,
    or FORTRAN. In these languages, the final result of compilation is machine code,
    which can be executed directly on any compatible computer without needing an additional
    program on that machine (or somehow bundled with the code).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Many developers take this to mean that Python cannot be compiled (assembled)
    to machine code, which seems like the obvious corollary. In fact, it is possible
    to compile Python to machine code, although this is rarely necessary and seldom
    done.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: If you want to go this route, there are a few options. On UNIX, the built-in
    *Freeze* tool transpiles to C arrays of Python bytecode, and then it assembles
    this C code to machine code. This doesn’t result in truly assembled Python code,
    however, because the Python interpreter must still be invoked behind the scenes.
    Freeze only works on UNIX systems. The *cx_Freeze* tool, as well as *py2exe* on
    Windows, does much the same thing as Freeze.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: To truly compile Python to machine code, you must use an intermediary language.
    *Nuitka* can be used to transpile Python code C and C++, which can then be assembled
    to machine code. You can also transpile Python to Java with *VOC*. *Cython* also
    allows transpiling a specialized form of Python to C, although it’s primarily
    geared toward writing Python extensions in C.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'Myth #4: Python Gets Compiled Behind the Scenes'
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Python interpreter converts code to *bytecode*, which is then executed.
    The interpreter includes a *virtual machine*, which executes the Python bytecode
    similarly to how a CPU executes machine code. Sometimes, the interpreter will
    do the conversion to bytecode in advance, for performance reasons, generating
    *.pyc* files containing bytecode. While this is “compiling” in one sense of the
    term, there is a key difference between compiling to bytecode and compiling to
    machine code: bytecode is still run through the interpreter, whereas machine code
    executes directly, without needing an additional program. (Technically, “compiling”
    to machine code is called *assembling*, although this distinction is often neglected
    or overlooked.)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: In practice, the majority of Python projects ship as source code, or at least
    Python bytecode, which is run in the Python interpreter installed on the user’s
    machine. There are occasions when a standard executable is preferable, such as
    for ease of installation on end-user computers or in closed-source projects. For
    those situations, tools such as *PyInstaller* and *cx_Freeze* exist. These don’t
    compile the code, but rather bundle the Python source code or bytecode with the
    interpreter so it can be executed by itself (see Chapter 18).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'Myth #5: Python Is Unsuitable for Large Projects'
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I’ve heard some developers say, “Python is only useful if the whole project
    fits in one file.” This adage is partially based on the misconception that Python
    projects with multiple files are confusingly structured. This indeed tends to
    be the trend, but only because so few developers know how to correctly structure
    a Python project.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: In reality, project structure in Python is far simpler than in C++ and Java.
    Once the developer understands the concepts of packages, modules, and the import
    system (see Chapter 4), working with multiple code files becomes trivial.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Another reason for this myth has to do with the fact that Python is dynamically
    typed, rather than statically typed like Java or C++, which some believe makes
    refactoring harder. This doesn’t have to be the case, once the developer knows
    how to work with Python’s type system, instead of against it (see Chapter 5).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Python 2 vs. Python 3
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For many years, there existed two major versions of Python. Starting in 2001,
    *Python 2* was the standard, meaning most books and articles about Python were
    written for this version. The last release was Python 2.7.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: The current version is *Python 3*, known during its development as *Python 3000*
    or *Py3k*. From its release in 2008 until 2019, we were in a sort of limbo between
    the two versions; a lot of existing code and packages were written in Python 2,
    while Python 3 was increasingly recommended for new projects that didn’t require
    legacy support. Many techniques and tools existed for writing code that could
    run in either version, which eased the transition for many existing projects.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: In more recent years, especially since the release of Python 3.5, we’ve begun
    moving away from Python 2 altogether. Most major libraries officially supported
    Python 3, and legacy support became less of a priority.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: As of January 1, 2020, Python 2 has been officially retired, and Python 3 is
    the definitive standard. Since Python 4 is still nothing more than a vague wisp
    of a rumor at this point, it’s safe to say that Python 3 will be with us for years
    to come.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, many software development teams have been slow (sometimes unavoidably)
    about porting their code bases from Python 2 to Python 3\. This has left a lot
    of projects in limbo. If you use Python in a professional capacity, there is a
    good chance you’ll have to help transition some code to Python 3\. Python’s standard
    library includes a tool called *2to3*, which helps automate this process. Running
    the code through this tool is a good first step, but you will still need to manually
    update the code to use some of the newer patterns and tools Python 3 has to offer.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Defining “Pythonic” Code
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Among Python developers, you’ll hear a lot of talk about *Pythonic* code and
    what it constitutes, precisely. In a general sense, idiomatic code that makes
    good use of the language’s features is considered Pythonic.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, this is very much open to interpretation. As a result, the topic
    of best practices in Python is a regular source of heated debate in the community.
    Don’t be alarmed by this. By regularly grappling with our own conventions and
    standards, we continually improve them and our own understanding along the way.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Our tendency to debate best practices in Python is rooted in our philosophy
    of *There’s Only One Way To Do It (TOOWTDI)*, a phrase coined by PythonLabs in
    2000 as a tongue-in-cheek response to the Perl community’s own adage of *There’s
    More Than One Way To Do It (TMTOWTDI)*. Despite the historic rivalry between these
    communities, these philosophies aren’t strictly opposing.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Python developers rightly assume there is some single, quantifiably “best” solution
    to any specific problem. Our task is to figure out what that solution is, but
    we also know we will often fall far short of the goal. Through continual discussion,
    debate, and experimentation, we refine our approaches in pursuit of the theoretical
    Best Solution.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: In the same way, the Perl community understands that it is often impossible
    to definitively arrive at that Best Solution, so they emphasize experimentation
    instead of compliance with strict standards, in an effort to discover better and
    better solutions.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'In the end, the goal is the same: to ultimately define the best possible solution
    to a problem. Only the emphasis differs.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: In this book, I’ll focus a lot on the generally accepted Pythonic ways of writing
    code. However, I don’t claim to be the final authority. My colleagues in the Python
    community will always have plenty to add to these discussions. I never fail to
    learn something new from them!
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: The Zen of Python
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In 1999, a discussion started on the official Python mailing list about the
    need to write down some sort of formal guiding principles for the language. Tim
    Peters, a prominent member of the community, jokingly laid out a poetic summary
    of 19 principles to serve as an outline, leaving the 20th spot open for Guido
    van Rossum to complete (which he never did).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Other community members quickly seized on this summary as a fantastic overview
    of Python’s philosophy, ultimately adopting it wholesale as *The Zen of Python*.
    The entire text is published by Python as PEP 20.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Beautiful is better than ugly.
  id: totrans-52
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-53
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Explicit is better than implicit.
  id: totrans-54
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Simple is better than complex.
  id: totrans-56
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Complex is better than complicated.
  id: totrans-58
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Flat is better than nested.
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Sparse is better than dense.
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Readability counts.
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Special cases aren’t special enough to break the rules.
  id: totrans-66
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-67
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Although practicality beats purity.
  id: totrans-68
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Errors should never pass silently.
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-71
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Unless explicitly silenced.
  id: totrans-72
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the face of ambiguity, refuse the temptation to guess.
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: There should be one—and preferably only one—obvious way to do it.
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-77
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Although that way may not be obvious at first unless you’re Dutch.
  id: totrans-78
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-79
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Now is better than never.
  id: totrans-80
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-81
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Although never is often better than *right* now.
  id: totrans-82
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-83
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If the implementation is hard to explain, it’s a bad idea.
  id: totrans-84
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-85
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If the implementation is easy to explain, it may be a good idea.
  id: totrans-86
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-87
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Namespaces are one honking great idea—let’s do more of those!
  id: totrans-88
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This, too, is open to interpretation, and some argue that Tim Peters was kidding
    when he wrote The Zen of Python. However, if there’s one thing I’ve learned about
    Python developers, it’s that the line between “kidding” and “serious” is fine
    as spider silk.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: In any case, The Zen of Python is a great place to start when talking about
    best practices in Python. Many developers, including myself, often refer back
    to it. I’ll refer to it frequently throughout this book.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Documentation, PEPs, and You
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Dead Simple Python* is intended as a beginning, not an ending, to your learning
    journey. Once you are well acquainted with the Python language, you can turn to
    the language’s extensive official documentation to learn more about any particular
    features or tools. These docs are found online at [https://docs.python.org/](https://docs.python.org/).'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Any new feature in Python begins its life as a *Python Enhancement Proposal*
    (PEP). Each is assigned a unique number and published to the official PEP index
    at [https://python.org/dev/peps/](https://python.org/dev/peps/). Once proposed,
    a PEP will be considered, discussed, and ultimately accepted or rejected.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Accepted PEPs are effectively extensions of the documentation, as they are the
    most cohesive and authoritative descriptions of the feature(s) they define. Additionally,
    there are several Meta-PEPs and Informational PEPs that provide the backbone for
    the Python community and language.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: As such, the official documentation and PEP index should be the first place
    you go if you have any questions about Python. I’ll refer to these frequently
    throughout this book.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Who Calls the Shots?
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To understand how and why the language evolves, it is important to know who’s
    in charge. When a PEP is proposed, who gets to decide if it’s accepted or rejected?
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Python is an open source project officially owned by the nonprofit Python Software
    Foundation. Unlike many other popular languages, no formal associations exist
    between Python and any for-profit organization.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: As an open source project, Python is supported by an active and vibrant community.
    At its heart is the core team, the trusted volunteers who maintain the language
    and keep the community running smoothly.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Language creator Guido van Rossum served as the Benevolent Dictator for Life
    (BDFL), making the final decisions on all PEPs and overseeing ongoing development
    of the language. In 2018, he made the decision to step down from the role.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: A few months after his resignation, PEP 13 was created to establish a new system
    of governance. Now the language is governed by a five-person steering committee,
    elected by the core team. Every time a new release of the language comes out,
    a new steering committee is elected.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: The Python Community
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Python community is a vast and diverse group of individuals from all over
    the world, united by their passion for this unique language. Ever since I stumbled
    upon the community many years ago as an utter novice, I have gained immeasurable
    help, guidance, and inspiration from it and its people. I’ve been privileged to
    offer the same to others in return. This book would not have ever happened without
    the continual feedback of my Python friends!
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python community is moderated by the core team and governed by the Python
    Code of Conduct. In short, it emphasizes open, considerate, and respectful behavior,
    summarizing itself as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Overall, we’re good to each other. We contribute to this community, not because
    we have to, but because we want to. If we remember that, these guidelines will
    come naturally.
  id: totrans-105
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: I strongly encourage any developer who uses Python to plug into this vibrant
    community. One of the best ways to participate is through the Libera.Chat IRC
    `#python` chatroom. You can find guides to getting onto IRC at [https://python.org/community/](https://python.org/community/).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: If you have any questions about Python, including while you read through this
    book, I recommend asking for help in the IRC channel. Chances are, you’ll find
    me and most of my technical editors there.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: In Chapter 21, I’ll discuss the many facets of the Python community.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: The Pursuit of the One Obvious Way
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Python mantra “There’s Only One Way to Do It” can be quite confusing at
    first. There are many possible ways to solve any one problem. Are Pythonistas
    just too enamored with their own ideas?
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, no. This mantra means something much more encouraging, and it’s
    something every Python developer should understand.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'Some insight comes from The Zen of Python, which includes this rather cryptic
    quip:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: There should be one—and preferably only one—obvious way to do it.
  id: totrans-113
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-114
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Although that way may not be obvious at first unless you’re Dutch.
  id: totrans-115
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Tim Peters was, of course, referring to language creator Guido van Rossum, a
    Dutch national. As the creator of the language, Guido could usually cut right
    to the “most obvious way” of solving problems in Python, especially in the early
    days of the language.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: This *obvious way* is Python’s term for “the best solution”—a marriage of good
    practice, clean style, and reasonable efficiency, resulting in elegant code that
    is comprehensible to even the greenest novice.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'The details of the problem being solved will usually inform this “obvious way”:
    one situation may call for a loop, another for recursion, and yet another for
    a list comprehension. Contrary to the usual implications of the word *obvious*,
    the solution is often anything but simple to work out. The best solution is only
    obvious *once you know it*; arriving at it is where things get tricky. Most of
    us aren’t Guido.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: However, the *pursuit* of the “one obvious way” is a defining facet of the Python
    community, and it has had a profound impact on *Dead Simple Python*. A lot of
    the insights in this book were born out of sometimes intense debate between myself
    and my fellow Pythonistas. For this reason, I hand-selected my panel of technical
    editors from those colleagues who are commonly in opposition to me, and often
    each other, on pedantic technical points.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Anything ultimately adopted as the “right way” to solve a problem is usually
    accepted as such because of its technical merit, rather than because of some like-minded
    bias among Python developers, who are among the most exacting folks I’ve had the
    privilege of working with. This approach to logic overflows into every other conversation
    we have (which leads to some rather amazing and enlightening academic debates).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: New situations present themselves regularly. There will never come a point in
    any Python developer’s career when coding becomes truly “easy.” Situations will
    arise in every project that demand careful consideration, and often, debate. Developers
    must attempt to solve problems in the way that seems most obvious to them, then
    submit the solution to the critique of peers.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: The approaches in this book are, in many cases, the most obvious according to
    my view. Most have been seconded by my colleagues, yet I dare not assert that
    I am altogether “Dutch” in the Python sense. If you find yourself debating techniques
    in the Python community, please do not wave this book in anyone’s face as evidence
    that your solution is best! Skill in finding an obvious solution is not something
    that can be taught; rather it is only learned through practice.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping Up
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Despite the many myths that have been tossed around over the years, Python is
    a versatile and technically sound language, capable of handling just about any
    problem you can throw at it. It’s a solid choice, whether you are writing automation,
    crunching massive datasets, building native user applications, implementing machine
    learning, or crafting web applications and APIs. Most importantly, Python is backed
    by a vibrant, diverse, and helpful community.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管多年来有许多关于它的误解，Python是一种多功能且技术上扎实的编程语言，能够处理几乎任何你能抛给它的问题。无论是编写自动化脚本、处理海量数据集、构建本地用户应用、实现机器学习，还是开发Web应用和API，它都是一个可靠的选择。最重要的是，Python得到了一个充满活力、多样化且乐于助人的社区的支持。
- en: The key to success, then, is writing Python code that makes the most of the
    strengths and features of the language. The goal is not simply to write code that
    works, but to write code that both looks and behaves elegantly. The rest of this
    book will teach you how to do exactly that.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的关键在于编写充分发挥语言优点和特性的Python代码。目标不仅仅是编写能工作的代码，而是编写既美观又高效的代码。本书的其余部分将教你如何做到这一点。
