["```py\nArrayDouble(Array: old_array):\n    Integer: length = length of old_array\n    Array: new_array = empty array of size length * 2\n\n    Integer: j = 0\n    WHILE j < length:\n        new_array[j] = old_array[j]\n        j = j + 1\n    return new_array\n```", "```py\nLinkedListNode {\n    Type: value\n    LinkedListNode: next\n}\n```", "```py\nLinkedListLookUp(LinkedListNode: head, Integer: element_number):\n  ❶ LinkedListNode: current = head\n    Integer: count = 0\n\n  ❷ WHILE count < element_number AND current != null:\n        current = current.next\n        count = count + 1\n    return current\n```", "```py\nLinkedListInsertAfter(LinkedListNode: previous,\n                      LinkedListNode: new_node):\n    new_node.next = previous.next\n    previous.next = new_node\n```", "```py\nLinkedListInsert(LinkedListNode: head, Integer: index,\n                 Type: value):\n    # Special case inserting a new head node.\n  ❶ IF index == 0:\n        LinkedListNode: new_head = LinkedListNode(value)\n        new_head.next = head\n        return new_head\n\n    LinkedListNode: current = head\n    LinkedListNode: previous = null\n    Integer: count = 0\n  ❷ WHILE count < index AND current != null:\n        previous = current\n        current = current.next\n        count = count + 1\n\n    # Check if we've run off the end of the list before\n    # getting to the necessary index.\n  ❸ IF count < index:\n        Produce an invalid index error.\n\n  ❹ LinkedListNode: new_node = LinkedListNode(value)\n    new_node.next = previous.next\n    previous.next = new_node\n\n  ❺ return head\n```", "```py\nLinkedListDelete(LinkedListNode: head, Integer: index):\n  ❶ IF head == null:\n        return null\n\n  ❷ IF index == 0:\n        new_head = head.next\n        head.next = null\n        return new_head\n\n    LinkedListNode: current = head\n    LinkedListNode: previous = null\n    Integer: count = 0\n  ❸ WHILE count < index AND current != null:\n        previous = current\n        current = current.next\n        count = count + 1\n\n  ❹ IF current != null:\n      ❺ previous.next = current.next\n      ❻ current.next = null\n    ELSE:\n        Produce an invalid index error.\n  ❼ return head\n```", "```py\n WHILE current != null AND current.value != value:\n```", "```py`The strength of linked lists is that they allow us to insert or remove elements without shifting those elements around in the computer’s memory. We can leave the nodes where they are and just update the pointers to indicate their movement.    ## Doubly Linked Lists    There are many additional ways we can add structure with pointers, many of which we’ll examine in later chapters. For now, we’ll discuss just one simple extension of the linked list: the *doubly linked list*, which includes backward as well as forward pointers, as shown in [Figure 3-13](#figure3-13).  ![The list from Figure 3‐5, now with right‐pointing and left‐pointing arrows between each node. ](image_fi/502604c03/f03013.png)    Figure 3-13: A doubly linked list contains pointers to both the next and previous entries.      For algorithms that need to iterate lists in both directions, or just for adventurous programmers looking to expand the number of pointers in their data structures, it is easy to adapt a linked list to a doubly linked one:    ```", "```py    The code for operating on doubly linked lists is similar to the code for singly linked lists. Lookups, insertions, and deletions often require traversing the list to find the correct element. Updating the appropriate nodes’ `previous` pointers in addition to their `next` pointers requires additional logic. Yet this small amount of additional information can enable shortcuts to some of the operations. Given the pointer to any node in a doubly linked list, we can also access the node before it without having to traverse the entire list from the beginning, as we would have to do for a singly linked list.    ## Arrays and Linked Lists of Items    So far, we have primarily used arrays to store individual (numeric) values. We might be storing a list of top scores, a list of reminder times for a smart alarm clock, or a log of how much coffee we consume each day. This is useful in a variety of applications but is only the most basic way to use an array. We can use the concept of pointers to store more complex and differently sized items.    Suppose you’re planning a party. We will make the generous assumption that, unlike many parties thrown by the author, your gathering is popular enough to require an RSVP list. As you begin to receive responses to your invitations, you write a new program using an array to keep track of the guests. You’d like to store at least a single string in each entry, indicating the name of the person who has responded. However, you immediately run into the problem that strings might not be fixed size, so you can’t guarantee they will fit in the array’s fixed-size bin. You could expand the bin size to fit all possible strings. But how much is enough? Can you reliably say all your invitees will have fewer than 1,000 characters in their name? And if we allow for 1,000 characters, what about the waste? If we are reserving space for 1,000 characters per invitee, then entries for “John Smith” are using only a tiny fraction of their bins. What if we want to include even more dynamic data with each record, such as a list of each guest’s music preferences or nicknames?    The natural solution is to combine arrays and pointers, as shown in [Figure 3-14](#figure3-14). Each bin in the array stores a single pointer to the data of interest. In this case, each bin stores a pointer to a string located somewhere else in memory. This allows the data for each entry to vary in size. We can allocate as much space as we need for each string and point to those strings from the array. We could even create a detailed composite data structure for our RSVP records and link those from the array.  ![Array in which each value points to an ellipse (three dots) outside of the array, indicating that the values link to larger data structures. ](image_fi/502604c03/f03014.png)    Figure 3-14: Arrays can store a series of pointers, allowing them to link to larger data structures.      The RSVP records don’t need to fit into the array bins, because their data lives somewhere else in memory. The array bins only hold (fixed-size) pointers. Similarly, a linked list’s nodes can contain pointers to other data. Unlike the `next` pointers in a linked list, which are pointing to other nodes, these pointers can point to arbitrary other blocks of data.    The rest of the book includes many cases where individual “values” are actually pointers to complex and even dynamic data structures.    ## Why This Matters    Linked lists and arrays are only the simplest example of how we can trade off among complexity, efficiency, and flexibility in our data structures. By using a pointer, a variable that stores addresses in memory, we can link across blocks of memory. A single fixed-size array bin can point to complex data records or strings of different lengths. Further, we can use pointers to create dynamically linked structures through the computer’s memory. By changing a pointer’s value to point to a new address, we can change this structure as needed at any time.    Over the remaining chapters, we will see numerous examples of how dynamic data structures can be used to both improve organization of the data and make certain computations more efficient. However, it is important to keep the relative tradeoffs in mind. As we saw with arrays and linked lists, each data structure comes with its own advantages and disadvantages in terms of flexibility, space requirements, efficiency of operations, and complexity. In the next chapter, we will show how can build on these fundamental concepts to create two data structures, stacks and queues, that enable different behavior.```"]