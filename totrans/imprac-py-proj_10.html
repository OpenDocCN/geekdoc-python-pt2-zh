<html><head></head><body>
<h2 class="h2" id="ch10"><span epub:type="pagebreak" id="page_187"/><strong><span class="big">10</span><br/>ARE WE ALONE? EXPLORING THE FERMI PARADOX</strong></h2>
<div class="image1"><img src="../images/common01.jpg" alt="image"/></div>
<p class="noindent">Scientists use the <em>Drake equation</em> to estimate the possible number of civilizations in the galaxy currently producing electromagnetic emissions, such as radio waves. In 2017, the equation was updated to account for new exoplanet discoveries by NASA’s Kepler satellite. The result, published in the scientific journal <em>Astrobiology</em>, was astonishing. For humanity to be the first and only technologically advanced species, the probability of an advanced civilization developing on a habitable alien planet would have to be less than 1 in 10 billion trillion! And yet, as Nobel Prize–winning physicist Enrico Fermi famously observed, “Where is everybody?”</p>
<p class="indent">Fermi was more skeptical about interstellar travel than the existence of extraterrestrials, but his question became known as <em>Fermi’s paradox</em>, and it morphed into the conjecture “If they were out there, they’d be here.” According to the SETI Institute, even with modest rocket technology, an <span epub:type="pagebreak" id="page_188"/>eager civilization could explore the entire galaxy, if not colonize it, within 10 million years. That may sound like a long time, but it’s only 1/1,000 the age of the Milky Way! As a result, some have come to accept Fermi’s paradox as proof we are alone in the cosmos. Others find holes in the argument.</p>
<p class="indent">In this chapter, you’ll investigate the absence of alien radio transmissions by calculating the probability of one civilization detecting another based on the volume of their transmissions and output from the Drake equation. You’ll also use Python’s de facto standard GUI package, <span class="literal">tkinter</span>, to quickly and easily create a graphical model of the Milky Way.</p>
<h3 class="h3a" id="lev221"><strong>Project #17: Modeling the Milky Way</strong></h3>
<p class="noindent">Our galaxy, the Milky Way, is a fairly common spiral galaxy, like the one shown in <a href="ch10.xhtml#ch10fig1">Figure 10-1</a>.</p>
<div class="image"><a id="ch10fig1"/><img src="../images/f0188-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 10-1: Spiral galaxy NGC 6744, “Big Brother” to the Milky Way</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_189"/>In cross-sectional view, the Milky Way is a flattened disc with a central bulge that most likely contains a supermassive black hole at its core. Four “spiral arms”—comprising relatively densely packed gas, dust, and stars—radiate from this central mass. The dimensions of the Milky Way are shown in <a href="ch10.xhtml#ch10fig2">Figure 10-2</a>.</p>
<div class="image"><a id="ch10fig2"/><img src="../images/f0189-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 10-2: Schematic profile (edge view) of the Milky Way galaxy (LY = Light-Years) and a simplified model</em></p>
<p class="indent">The center of the galaxy is considered fairly inhospitable to life due to high levels of radiation associated with the more closely packed stars. So, for this project, you can treat the galaxy as a simple disc to discount some of the volume associated with the bulge but still leave room for some advanced civilizations near the core (see the Galactic Model in <a href="ch10.xhtml#ch10fig2">Figure 10-2</a>).</p>
<div class="sidebar">
<p class="sidebart"><strong>THE OBJECTIVE</strong></p>
<p class="spara">For a given number of advanced galactic civilizations and an average radio bubble size, estimate the probability of <em>any</em> civilization detecting the radio transmissions of <em>any other</em> civilization. For perspective, post the size of Earth’s current radio bubble on a 2D graphical representation of the Milky Way.</p>
</div>
<h3 class="h3" id="lev222"><strong>The Strategy</strong></h3>
<p class="noindent">Here are the steps needed to complete this project:</p>
<ol>
<li class="noindent">Estimate the number of transmitting civilizations using the Drake equation.</li>
<li class="noindent">Choose a size range for their radio bubbles.</li>
<li class="noindent">Generate a formula for estimating the probability of one civilization detecting another.</li>
<li class="noindent">Build a graphical model of the galaxy and post Earth’s radio emissions bubble.</li>
</ol>
<p class="indent"><span epub:type="pagebreak" id="page_190"/>In order to keep the description close to the code, each of these tasks will be described in detail in its own section. Note that the first two steps don’t require the use of Python.</p>
<h3 class="h3" id="lev223"><strong>Estimating the Number of Civilizations</strong></h3>
<p class="noindent">You can manually estimate the number of advanced civilizations using the Drake equation:</p>
<p class="center"><em>N</em> = <em>R<sup>*</sup></em> · <em>f</em><sub>p</sub> · <em>n</em><sub>e</sub> · <em>f</em><sub>l</sub> · <em>f</em><sub>i</sub> · <em>f</em><sub>c</sub> · <em>L</em></p>
<p class="noindent">where:</p>
<p class="hang"><em>N</em> = The number of civilizations in our galaxy whose electromagnetic emissions are detectable</p>
<p class="hang"><em>R</em><sup>*</sup> = The average rate of star formation in the galaxy (new stars per year)</p>
<p class="hang"><em>f</em><sup>p</sup> = The fraction of stars with planets</p>
<p class="hang"><em>n</em><sup>e</sup> = For stars with planets, the average number of planets with an environment suitable for life</p>
<p class="hang"><em>f</em><sup>l</sup> = The fraction of planets that develop life</p>
<p class="hang"><em>f</em><sup>i</sup> = The fraction of life-bearing planets with intelligent, civilized life</p>
<p class="hang"><em>f</em><sup>c</sup> = The fraction of civilizations that release detectable signs of their existence into space</p>
<p class="hang"><em>L</em> = The length of time—in years—over which the civilizations release the detectable signals</p>
<p class="indentt">Thanks to recent advances in the detection of exoplanets, the first three components (<em>R</em><sup>*</sup>, <em>f</em><sup>p</sup>, <em>n</em><sup>e</sup>) are becoming increasingly constrained. For <em>n</em><sup>e</sup>, recent studies suggest that 10 to 40 percent of all planets may be suitable for <em>some form</em> of life.</p>
<p class="indent">For the remaining components, Earth is the only example. In the Earth’s 4.5-billion-year history, <em>Homo sapiens</em> has existed for only 200,000 years, civilization for only 6,000 years, and radio transmissions for only 112 years. With respect to <em>L</em>, wars, plagues, ice ages, asteroid impacts, super-volcanoes, supernovas, and coronal mass ejections can disrupt a civilization’s ability to transmit radio signals. And the shorter the time of transmission, the less likely it is for civilizations to coexist.</p>
<p class="indent">According to the Wikipedia article on the Drake equation (<em><a href="https://en.wikipedia.org/wiki/Drake_equation">https://en.wikipedia.org/wiki/Drake_equation</a></em>), in 1961, Drake and his colleagues estimated the number of communicating civilizations in the galaxy to be between 1,000 and 100,000,000. More recent updates have set the range from 1 (just us) to 15,600,000 (<a href="ch10.xhtml#ch10tab1">Table 10-1</a>).</p>
<p class="tabcap" id="ch10tab1"><span epub:type="pagebreak" id="page_191"/><strong>Table 10-1:</strong> Some Drake Equation Inputs and Results</p>
<table class="topbot-d">
<thead>
<tr>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Parameter</strong></p></td>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Drake 1961**</strong></p></td>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Drake 2017</strong></p></td>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Your choices</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><em>R</em><sup>*</sup></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">1</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">3</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba"> </p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><em>f</em><sub>p</sub></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">0.35</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">1</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba"> </p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><em>n</em><sup>e</sup></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">3</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">0.2</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba"> </p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><em>f</em><sub>l</sub></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">1</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">0.13</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba"> </p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><em>f</em><sub>i</sub></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">1</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">1</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba"> </p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><em>f</em><sub>c</sub></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">0.15</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">0.2</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba"> </p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><em>L</em></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">50 × 10<sup>6</sup></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">1 × 10<sup>9</sup></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba"> </p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-ba"><p class="taba"><em>N</em></p></td>
<td style="vertical-align: top;" class="table-ba"><p class="taba">7.9 × 10<sup>6</sup></p></td>
<td style="vertical-align: top;" class="table-ba"><p class="taba">15.6 × 10<sup>6</sup></p></td>
<td style="vertical-align: top;" class="table-ba"><p class="taba"> </p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b" colspan="4"><p class="taba">**midpoint of ranges shown</p></td>
</tr>
</tbody>
</table>
<p class="indent">For input to your program, you can use the estimates in the table, those you find online, or those you calculate yourself (in the final column of the table).</p>
<h3 class="h3" id="lev224"><strong>Selecting Radio Bubble Dimensions</strong></h3>
<p class="noindent">Radio waves that aren’t focused into a beam for targeted transmission are incidental. Think of these as “planet leakage.” Because we choose not to broadcast our presence to aliens who might come and eat us, almost all of our transmissions are incidental. These transmissions currently form an expanding sphere around Earth with a diameter of around 225 light-years (LY).</p>
<p class="indent">A 225 LY bubble sounds impressive, but it is the <em>detectable</em> size that really matters. A radio wave front is subject to the <em>inverse square law</em>, which means it continuously loses power density as it expands. Additional power loss can result from absorption or scattering. At some point, the signal becomes too weak to separate from background noise. Even with our best technology—the radio telescopes of the <em>Breakthrough Listen</em> program—we could detect our own radio bubble only out to about 16 LY.</p>
<p class="indent">Since we’re really investigating why <em>we</em> haven’t detected aliens, you should assume, for this project, that other civilizations have technology similar to our own. Another assumption should be that, like us, all aliens have a paranoid planetary consciousness and aren’t broadcasting “here we are” signals that would announce their presence. Investigating incidental bubble sizes ranging from a little smaller than those currently detectable to those a little larger than our own transmissions should be a reasonable place to start. This would suggest a diameter range of 30 to 250 LY. Although we can’t detect a 250 LY bubble, it will be interesting to see what the odds would be if we could.</p>
<h3 class="h3" id="lev225"><span epub:type="pagebreak" id="page_192"/><strong>Generating a Formula for the Probability of Detection</strong></h3>
<p class="noindent">As the number of advanced civilizations in the galaxy increases, the probability that one will detect another also increases. This is intuitive, but how do you assign the actual probabilities?</p>
<p class="indent">The nice thing about computers is that they allow us to brute-force our way to solutions that may or may not be intuitive. One approach here would be to make a 3D model of the Milky Way disc, randomly distribute civilizations throughout, and measure the distances between them using one of Python’s many tools for calculating Euclidian distance. But with potentially hundreds of millions of civilizations to analyze, this method would be computationally expensive.</p>
<p class="indent">Since we’re dealing with huge unknowns, there’s no need to be super-accurate or precise. We just want to be in the ballpark, so an easy simplification is to compartmentalize the galaxy into a series of radio bubble “equivalent volumes” by dividing the volume of the galactic disc by the volume of a radio bubble (see <a href="ch10.xhtml#ch10fig3">Figure 10-3</a>).</p>
<div class="image"><a id="ch10fig3"/><img src="../images/f0192-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 10-3: Modeling the galaxy using cubes with volumes equivalent to a 200 LY radio bubble</em></p>
<p class="indent">You can find the volumes using the following equations, where <em>R</em> is the radius of the galactic disc and <em>r</em> is the radius of a radio bubble:</p>
<p class="bqc">disc volume = π × <em>R</em><sup>2</sup> × disc height<br/>radio bubble volume = 4/3 × π × <em>r</em><sup>3</sup><br/>scaled disc volume = disc volume / radio bubble volume</p>
<p class="indent">The scaled disc volume is the number of equivalent volumes that “fit” in the galaxy. Think of these as boxes numbered from 1 to the maximum number of volumes.</p>
<p class="indent"><span epub:type="pagebreak" id="page_193"/>To place civilizations, you simply choose a box number at random. Duplicate picks indicate multiple civilizations within the same box. Assume civilizations in the same box can detect each other. This isn’t strictly true (see <a href="ch10.xhtml#ch10fig4">Figure 10-4</a>), but because you’ll be using large numbers of civilizations, the discrepancies will tend to cancel each other out, just as when you sum a lot of rounded numbers.</p>
<div class="image"><a id="ch10fig4"/><img src="../images/f0193-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 10-4: Detection problems at the individual equivalent volume level</em></p>
<p class="indent">To avoid having to repeat this exercise every time you change the number of civilizations and/or radio bubble dimensions, you can capture the results as a formula—a <em>polynomial equation</em>—that can be used to generate all future probability estimates. A <em>polynomial</em> is the sum or difference of a collection of algebraic terms. The famous <em>quadratic equation</em> we all learned in school is a polynomial equation of the second degree (meaning that the exponents of the variables are no greater than 2):</p>
<p class="center"><em>ax</em><sup>2</sup> + <em>bx</em> + <em>c</em> = 0</p>
<p class="indent">Polynomials make nice curves, so they’re tailor-made for this problem. But for the formula to work with variable numbers of civilizations and bubble sizes, you’ll need to use the <em>ratio</em> of the number of civilizations to the total volume. The total volume is represented by the scaled disc volume, which is the same as the total number of equivalent volumes.</p>
<p class="indent">In <a href="ch10.xhtml#ch10fig5">Figure 10-5</a>, each dot represents the probability of detection for the ratio below it. The equation shown in the figure is the polynomial expression, which generates the line connecting the dots. With this formula, you can predict the probability for any ratio of civilizations per volume, up to a value of 5 (above this, we’ll just assume the probability is 1.0).</p>
<div class="image"><span epub:type="pagebreak" id="page_194"/><a id="ch10fig5"/><img src="../images/f0194-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 10-5: Probability of detection versus ratio of number of civilizations to scaled galactic volume</em></p>
<p class="indent">In <a href="ch10.xhtml#ch10fig5">Figure 10-5</a>, the civilizations-to-volume ratios are posted on the x-axis. A ratio of 0.5, for example, means that there are half as many civilizations as available radio bubble equivalent volumes, a ratio of 2 means there are twice as many civilizations as volumes, and so on. The y-axis is the probability that an equivalent volume contains more than one civilization.</p>
<p class="indent">Another thing to note from <a href="ch10.xhtml#ch10fig5">Figure 10-5</a> is that it takes a lot of civilizations to ensure that they all have a roommate. Imagine that 999,999 out of 1,000,000 equivalent volumes contain at least two civilizations and you use your God-like powers to randomly place one new civilization. The odds are one in a million that this new civilization will end up in the remaining volume with a single occupant. That last equivalent volume is the proverbial needle in the haystack!</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>An axiom of computer modeling is to start simple and add complexity. The simplest “base case” assumption is that advanced civilizations are randomly distributed throughout the galaxy. In “<a href="ch10.xhtml#lev246">Challenge Projects</a>” on <a href="ch10.xhtml#page_214">page 214</a>, you’ll get a chance to challenge this assumption using the concept of galactic habitable zones.</em></p>
</div>
<h3 class="h3" id="lev226"><strong>The Probability-of-Detection Code</strong></h3>
<p class="noindent">The probability-of-detection code randomly chooses locations (radio bubble equivalent volumes) for a set number of locations and civilizations, counts how many locations occur only once (that is, contain only one civilization), and repeats the experiment multiple times to converge on a probability estimate. The process is then repeated for a new number of civilizations. The output is presented as probability versus the <em>ratio</em> of civilizations per volume, <span epub:type="pagebreak" id="page_195"/>rather than the actual number of civilizations, and turned into a polynomial expression so that the results are easily portable. This means this program only needs to be run once.</p>
<p class="indent">To generate the polynomial equation and check that it fits the data, you’ll use <span class="literal">NumPy</span> and <span class="literal">matplotlib</span>. The <span class="literal">NumPy</span> library adds support for large, multidimensional arrays and matrices, and it includes many mathematical functions that operate on them. The <span class="literal">matplotlib</span> library supports 2D plotting and rudimentary 3D plotting, and <span class="literal">NumPy</span> represents its numerical mathematics extension.</p>
<p class="indent">There are several ways to install these scientific Python distributions. One way is to use <span class="literal">SciPy</span>, an open source Python library used for scientific and technical computing (see <em><a href="https://scipy.org/index.html">https://scipy.org/index.html</a></em>). If you’re going to do a lot of data analysis and plotting, you may want to download and use a free package like Anaconda or Enthought Canopy, which works with Windows, Linux, and macOS. These packages spare you the task of finding and installing all the required data science libraries in the correct version. A listing of these types of packages, along with links to their websites, can be found at <em><a href="https://scipy.org/install.html">https://scipy.org/install.html</a></em>.</p>
<p class="indent">Alternatively, you may want to download the products directly, using pip. I did this using the instructions at <em><a href="https://scipy.org/install.html">https://scipy.org/install.html</a></em>. Because <span class="literal">matplotlib</span> requires a large number of dependencies, these need to be installed at the same time. For Windows, I ran the following Python 3–specific command from the PowerShell, launched from within my <em>Python35</em> folder (you can leave off the <em>3</em> in <em>python3</em> unless you have multiple versions installed):</p>
<p class="programs">$ <span class="codestrong1">python3 -m pip install --user numpy scipy matplotlib ipython jupyter pandas sympy nose</span></p>
<p class="indent">All the other modules you’ll need come bundled with Python. As for the code in <a href="ch10.xhtml#ch10list1">Listings 10-1</a> and <a href="ch10.xhtml#ch10list2">10-2</a>, you can type it in or download a copy from <em><a href="https://www.nostarch.com/impracticalpython/">https://www.nostarch.com/impracticalpython/</a></em>.</p>
<h4 class="h4" id="lev227"><strong><em>Calculating Probability of Detection for a Range of Civilizations</em></strong></h4>
<p class="noindent"><a href="ch10.xhtml#ch10list1">Listing 10-1</a> imports modules and does all the work just described except for fitting the polynomial and displaying the <span class="literal">matplotlib</span> quality check.</p>
<p class="margin"><em>probability_of_detection.py,</em> part 1</p>
<p class="programs"><span class="ent">➊</span> from random import randint<br/>   from collections import Counter<br/>   import numpy as np<br/>   import matplotlib.pyplot as plt<br/><br/><span class="ent">➋</span> NUM_EQUIV_VOLUMES = 1000  # number of locations in which to place civilizations<br/>   MAX_CIVS = 5000  # maximum number of advanced civilizations<br/>   TRIALS = 1000  # number of times to model a given number of civilizations<br/>   CIV_STEP_SIZE = 100  # civilizations count step size<br/><br/><span epub:type="pagebreak" id="page_196"/><span class="ent">➌</span> x = []  # x values for polynomial fit<br/>   y = []  # y values for polynomial fit<br/><br/><span class="ent">➍</span> for num_civs in range(2, MAX_CIVS + 2, CIV_STEP_SIZE):<br/>       civs_per_vol = num_civs / NUM_EQUIV_VOLUMES<br/>       num_single_civs = 0<br/>    <span class="ent">➎</span> for trial in range(TRIALS):<br/>           locations = []  # equivalent volumes containing a civilization<br/>        <span class="ent">➏</span> while len(locations) &lt; num_civs:<br/>               location = randint(1, NUM_EQUIV_VOLUMES)<br/>               locations.append(location)<br/>        <span class="ent">➐</span> overlap_count = Counter(locations)<br/>           overlap_rollup = Counter(overlap_count.values())<br/>           num_single_civs += overlap_rollup[1]<br/><br/>    <span class="ent">➑</span> prob = 1 - (num_single_civs / (num_civs * TRIALS))<br/><br/>       # print ratio of civs-per-volume vs. probability of 2+ civs per location<br/>    <span class="ent">➒</span> print("{:.4f}  {:.4f}".format(civs_per_vol, prob))<br/>    <span class="ent">➓</span> x.append(civs_per_vol)<br/>       y.append(prob)</p>
<p class="listing" id="ch10list1"><em>Listing 10-1: Imports modules, randomly chooses radio-bubble-equivalent-volume locations, and calculates the probability of multiple civilizations per location</em></p>
<p class="indent">Import the familiar <span class="literal">random</span> module and <span class="literal">Counter</span>, for counting the number of civilizations at each location (designated by how many times a location has been chosen) <span class="ent">➊</span>. How <span class="literal">Counter</span> works will be explained in a moment. You’ll use the <span class="literal">NumPy</span> and <span class="literal">matplotlib</span> imports to fit and display the polynomial.</p>
<p class="indent">Assign some constants that represent user input for the number of equivalent volumes, the maximum number of civilizations, the number of trials—that is, how many times to repeat the experiment for a given number of civilizations—and a step size for the count <span class="ent">➋</span>. Because the results are predictable, you can use a large step value of 100 without compromising accuracy. Note that you’ll get very similar results whether the number of equivalent volumes is 100 or 100,000+.</p>
<p class="indent">You’ll need a series of paired (<em>x</em>, <em>y</em>) values for the polynomial expression, so start two lists to hold these <span class="ent">➌</span>. The x-value will be the ratio of civilizations per volume, and the y-value will be the corresponding probability of detection.</p>
<p class="indent">Start a series of nested loops, with the highest loop representing the number of civilizations to model <span class="ent">➍</span>. You need at least two civilizations for one to detect the other, and set the maximum to <span class="literal">MAX_CIVS</span> plus 2, to overshoot when calculating the polynomial. Use the <span class="literal">CIV_STEP_SIZE</span> constant for the step value.</p>
<p class="indent">Next, calculate the overall <span class="literal">civs_per_vol</span> ratio and start a counter named <span class="literal">num_single_civs</span> to keep track of the number of locations containing a single civilization.</p>
<p class="indent">You’ve chosen how many civilizations to distribute, so now use a <span class="literal">for</span> loop to go through the number of trials <span class="ent">➎</span>. For each trial, you distribute the same <span epub:type="pagebreak" id="page_197"/>number of civilizations. Assign an empty list to the variable <span class="literal">locations</span> and then, for each civilization <span class="ent">➏</span>, pick a location number at random and append it to the list. Duplicate values in the list will represent locations containing multiple civilizations.</p>
<p class="indent">Run <span class="literal">Counter</span> on this list <span class="ent">➐</span> and get the values. End the loop by getting the number of locations that occur only once and add them to the <span class="literal">num_single_civs</span> counter. Here’s an example of how these three statements work:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">from collections import Counter</span><br/>&gt;&gt;&gt; <span class="codestrong1">alist = [124, 452, 838, 124, 301]</span><br/>&gt;&gt;&gt; <span class="codestrong1">count = Counter(alist)</span><br/>&gt;&gt;&gt; <span class="codestrong1">count</span><br/>Counter({124: 2, 452: 1, 301: 1, 838: 1})<br/>&gt;&gt;&gt; <span class="codestrong1">value_count = Counter(count.values())</span><br/>&gt;&gt;&gt; <span class="codestrong1">value_count</span><br/>Counter({1: 3, 2: 1})<br/>&gt;&gt;&gt; <span class="codestrong1">value_count[1]</span><br/>3</p>
<p class="indent">The <span class="literal">alist</span> list contains five numbers, with one (124) duplicated. Running <span class="literal">Counter</span> on this list produces a dictionary with the numbers as the keys and the number of times they occur as the values. Passing <span class="literal">Counter</span> the values in <span class="literal">count</span>—with the <span class="literal">values()</span> method—creates another dictionary with the previous values as keys and the number of times they occur as the new values. You want to know how many numbers occur only once, so use the dictionary method <span class="literal">value_count[1]</span> to return the number of nonduplicated numbers. These, of course, would represent radio-bubble-equivalent volumes containing a single civilization.</p>
<p class="indent">Now use the results from <span class="literal">Counter</span> to calculate the probability of multiple civilizations per location for the current number of civilizations being distributed <span class="ent">➑</span>. This is 1 minus the number of single-occupancy locations divided by the number of civilizations in each trial times the number of trials.</p>
<p class="indent">Follow this by printing the ratio of civilizations to volume and the probability that multiple civilizations share a location <span class="ent">➒</span>. The first few lines of this output are as follows:</p>
<p class="programs">0.0020  0.0020<br/>0.1020  0.0970<br/>0.2020  0.1832<br/>0.3020  0.2607<br/>0.4020  0.3305<br/>0.5020  0.3951<br/>0.6020  0.4516<br/>0.7020  0.5041</p>
<p class="indent">This printout serves as an initial QC step and is optional; comment it out if you want to speed up the runtime. Finish by appending the values to the <span class="literal">x</span> and <span class="literal">y</span> lists <span class="ent">➓</span>.</p>
<h4 class="h4" id="lev228"><span epub:type="pagebreak" id="page_198"/><strong><em>Generating a Predictive Formula and Checking the Results</em></strong></h4>
<p class="noindent"><a href="ch10.xhtml#ch10list2">Listing 10-2</a> uses <span class="literal">NumPy</span> to perform polynomial regression on the probability of detection versus the ratio of civilizations per volume calculated in <a href="ch10.xhtml#ch10list1">Listing 10-1</a>. You’ll use this polynomial equation in the next program to obtain probability estimates. To check that the resulting curve fits the data points, <span class="literal">matplotlib</span> displays the actual and predicted values.</p>
<p class="margin"><em>probability_of_detection.py,</em> part 2</p>
<p class="programs"><span class="ent">➊</span> coefficients = np.polyfit(x, y, 4)  # 4th order polynomial fit<br/><span class="ent">➋</span> p = np.poly1d(coefficients)<br/>   print("\n{}".format(p))<br/><span class="ent">➌</span> xp = np.linspace(0, 5)<br/><span class="ent">➍</span> _ = plt.plot(x, y, '.', xp, p(xp), '-')<br/><span class="ent">➎</span> plt.ylim(-0.5, 1.5)<br/><span class="ent">➏</span> plt.show()</p>
<p class="listing" id="ch10list2"><em>Listing 10-2: Performs polynomial regression and displays a QC plot</em></p>
<p class="indent">Start by assigning a variable, <span class="literal">coefficients</span>, to the output from the <span class="literal">NumPy</span> <span class="literal">polyfit()</span> method <span class="ent">➊</span>. This method takes as arguments the <span class="literal">x</span> and <span class="literal">y</span> lists and an integer representing the degree of the fitting polynomial. It returns a vector of coefficients, <span class="literal">p</span>, that minimizes the squared error.</p>
<p class="indent">If you print the <span class="literal">coefficients</span> variable, you get the following output:</p>
<p class="programs">[-0.00475677  0.066811   -0.3605069   0.92146096  0.0082604 ]</p>
<p class="indent">To get the full expression, pass the <span class="literal">coefficients</span> variable to <span class="literal">poly1d</span> and assign the results to a new variable <span class="ent">➋</span>. Print this variable, and you’ll see a similar equation to that shown in <a href="ch10.xhtml#ch10fig5">Figure 10-5</a>:</p>
<p class="programs">           4           3          2<br/>-0.004757 x + 0.06681 x - 0.3605 x + 0.9215 x + 0.00826</p>
<p class="indent">To check that the polynomial adequately reproduces the input, you’ll want to plot the ratio of civilizations to volume on the x-axis, with probability on the y-axis. To get the x-axis values, you can use the <span class="literal">NumPy</span> <span class="literal">linspace()</span> method, which returns evenly spaced numbers over a specified interval. Use a range of <span class="literal">(0, 5)</span>, as this will cover almost the full probability range.</p>
<p class="indent">To post symbols for the calculated and predicted values, first pass the <span class="literal">plot()</span> method the <span class="literal">x</span> and <span class="literal">y</span> lists, plotting them using a period (dot), which is equivalent to the dots in <a href="ch10.xhtml#ch10fig5">Figure 10-5</a> <span class="ent">➍</span>. Then pass the predicted x-axis values (<span class="literal">xp</span>) and, to get the predicted y-axis probability, pass <span class="literal">p</span> the same variable, plotting the results using a dash.</p>
<p class="indent">Finish by limiting the y-axis to values of <span class="literal">–0.5</span> and <span class="literal">1.5</span> <span class="ent">➎</span> and use the <span class="literal">show()</span> method to actually display the graph (<a href="ch10.xhtml#ch10fig6">Figure 10-6</a>) <span class="ent">➏</span>. The resultant plot is simple and sparse, as its only purpose is to confirm that the polynomial regression is working as intended. You can alter the polynomial fit by increasing or decreasing the third argument in step <span class="ent">➊</span>.</p>
<div class="image"><span epub:type="pagebreak" id="page_199"/><a id="ch10fig6"/><img src="../images/f0199-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 10-6: Calculated results (dots) versus results predicted by the polynomial (line)</em></p>
<p class="indent">Armed with these results, you can now estimate the probability of detection for any number of civilizations in the blink of an eye. All Python needs to do is solve a polynomial equation.</p>
<h3 class="h3" id="lev229"><strong>Building the Graphical Model</strong></h3>
<p class="noindent">The graphical model will be a 2D, top-down view of the galactic disc. Plotting the size of Earth’s present emissions bubble on this display will put in perspective both the size of the galaxy and our diminutive place within it.</p>
<p class="indent">Modeling the Milky Way is all about modeling the spiral arms. Each spiral arm represents a <em>logarithmic spiral</em>, a geometric feature so common in nature it has been dubbed <em>spira mirabilis</em>—“miraculous spiral.” If you compare <a href="ch10.xhtml#ch10fig7">Figure 10-7</a> to <a href="ch10.xhtml#ch10fig1">Figure 10-1</a>, you can see how closely the structure of a hurricane resembles that of a galaxy. The eye of the hurricane can even be thought of as a supermassive black hole, with the eyewall representing the event horizon!</p>
<div class="image"><a id="ch10fig7"/><img src="../images/f0199-02.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 10-7: Hurricane Igor</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_200"/>Because spirals radiate out from a central point, or <em>pole</em>, you’ll more easily graph them with <em>polar coordinates</em> (<a href="ch10.xhtml#ch10fig8">Figure 10-8</a>). With polar coordinates, the (<em>x</em>, <em>y</em>) coordinates used in the more familiar Cartesian coordinate system are replaced by (<em>r</em>, θ), where <em>r</em> is the distance from the center and θ is the angle made by <em>r</em> and the x-axis. The coordinates for the pole are (0, 0).</p>
<div class="image"><a id="ch10fig8"/><img src="../images/f0200-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 10-8: Example polar coordinate system</em></p>
<p class="indent">The polar equation for a logarithmic spiral is:</p>
<p class="center"><em>r</em> = <em>ae</em><sup>bθ</sup></p>
<p class="noindent">where <em>r</em> is the distance from the origin, θ is the angle from the x-axis, <em>e</em> is the base of natural logarithms, and <em>a</em> and <em>b</em> are arbitrary constants.</p>
<p class="indent">You can use this formula to draw a single spiral; then, rotate and redraw the spiral three times to produce the four arms of the Milky Way. You’ll build the spirals out of circles of various sizes, which will represent stars. <a href="ch10.xhtml#ch10fig9">Figure 10-9</a> is an example of one realization of the graphical model. Because the simulations are stochastic, each will be slightly different, and there are multiple variables you can tweak to change the appearance.</p>
<div class="image"><a id="ch10fig9"/><img src="../images/f0200-02.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 10-9: The Milky Way, modeled using logarithmic spirals</em></p>
<p class="indent">I generated the image in <a href="ch10.xhtml#ch10fig9">Figure 10-9</a> with <span class="literal">tkinter</span> (pronounced “tee-kay-inter”), the default GUI library for developing desktop applications in Python. Although primarily designed for GUI elements such as windows, buttons, scroll bars, and so on, <span class="literal">tkinter</span> can also generate graphs, charts, screensavers, simple games, and more. Among its advantages is that, as part of the standard Python distribution, it’s portable across all operating systems and there’s no need to install external libraries. It’s also well documented and easy to use.</p>
<p class="indent"><span epub:type="pagebreak" id="page_201"/>Most Windows, macOS, and Linux machines come with <span class="literal">tkinter</span> already installed. If you don’t have it or need the latest version, you can download and install it from <em><a href="https://www.activestate.com/">https://www.activestate.com/</a></em>. As always, if the module is already installed, you should be able to import it in the interpreter window with no errors:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">import tkinter</span><br/>&gt;&gt;&gt;</p>
<p class="indent">Introductory Python books sometimes include overviews of <span class="literal">tkinter</span>, and you can find the official online documentation at <em><a href="https://docs.python.org/3/library/tk.html">https://docs.python.org/3/library/tk.html</a></em>. Some other references on <span class="literal">tkinter</span> are included in “<a href="ch10.xhtml#lev241">Further Reading</a>” on <a href="ch10.xhtml#page_212">page 212</a>.</p>
<h4 class="h4" id="lev230"><strong><em>Scaling the Graphical Model</em></strong></h4>
<p class="noindent">The scale of the graphical model is in light-years per pixel, and the width of each pixel will equate to the diameter of a radio bubble. As a result, when the radio bubble being investigated changes diameter, the scale units will change, and the graphical model will need to be rebuilt. The following equation will scale the model to the bubble:</p>
<p class="center">scaled disc radius = disc radius / bubble diameter</p>
<p class="noindent">where the disc radius is 50,000 and the length unit is light-years.</p>
<p class="indent">When the selected radio bubble is small, the graphical model “zooms in,” and when it is large, it “zooms out” (<a href="ch10.xhtml#ch10fig10">Figure 10-10</a>).</p>
<div class="image"><a id="ch10fig10"/><img src="../images/f0201-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 10-10: Impact of radio bubble diameter on the appearance of the galactic model</em></p>
<h4 class="h4" id="lev231"><span epub:type="pagebreak" id="page_202"/><strong><em>The Galaxy Simulator Code</em></strong></h4>
<p class="noindent">The galaxy simulator code will calculate the probability of detection for any number of civilizations and radio bubble sizes, and then generate a graphical model of the galaxy. When a bubble the size of our current emissions bubble is used, it will post and annotate our bubble in red, in the approximate location of our solar system. You can download the code from <em><a href="https://www.nostarch.com/impracticalpython/">https://www.nostarch.com/impracticalpython/</a></em>.</p>
<h5 class="h5" id="lev232"><strong>Entering Inputs and Key Parameters</strong></h5>
<p class="noindent"><a href="ch10.xhtml#ch10list3">Listing 10-3</a> starts <em>galaxy_simulator.py</em> by importing modules and putting the frequently accessed user input near the top.</p>
<p class="margin"><em>galaxy_simulator.py,</em> part 1</p>
<p class="programs"><span class="ent">➊</span> import tkinter as tk<br/>   from random import randint, uniform, random<br/>   import math<br/><br/>   #=============================================================================<br/><span class="ent">➋</span> # MAIN INPUT<br/><br/>   # scale (radio bubble diameter) in light-years:<br/><span class="ent">➌</span> SCALE = 225  # enter 225 to see Earth's radio bubble<br/><br/>   # number of advanced civilizations from the Drake equation:<br/><span class="ent">➍</span> NUM_CIVS = 15600000<br/>   #=============================================================================</p>
<p class="listing" id="ch10list3"><em>Listing 10-3: Imports modules and assigns constants</em></p>
<p class="indent">Import <span class="literal">tkinter</span> as <span class="literal">tk</span>, so you don’t have to type the full name when calling <span class="literal">tkinter</span> classes <span class="ent">➊</span>. If you’re using Python 2, use <span class="literal">Tkinter</span>—with an uppercase <em>T</em>. You’ll also need the <span class="literal">random</span> and <span class="literal">math</span> modules.</p>
<p class="indent">Use a comment to highlight the main user-input section <span class="ent">➋</span> and assign the two inputs. Use <span class="literal">SCALE</span> for the diameter, in light-years, of the detectable electromagnetic bubble around each civilization <span class="ent">➌</span>; <span class="literal">NUM_CIVS</span> is the number of civilizations to model, which you can determine using anything from the Drake equation to a total guess <span class="ent">➍</span>.</p>
<h5 class="h5" id="lev233"><strong>Setting Up the tkinter Canvas and Assigning Constants</strong></h5>
<p class="noindent">The code in <a href="ch10.xhtml#ch10list4">Listing 10-4</a> instantiates a <span class="literal">tkinter</span> window object with a canvas on which you can draw things. This is where the galaxy map, or graphical model, will appear. It also assigns constants related to the dimensions of the Milky Way.</p>
<p class="margin"><em>galaxy_simulator.py,</em> part 2</p>
<p class="programs">   # set up display canvas<br/><span class="ent">➊</span> root = tk.Tk()<br/>   root.title("Milky Way galaxy")<br/><span class="ent">➋</span> c = tk.Canvas(root, width=1000, height=800, bg='black')<br/><span epub:type="pagebreak" id="page_203"/><span class="ent">➌</span> c.grid()<br/><span class="ent">➍</span> c.configure(scrollregion=(-500, -400, 500, 400))<br/><br/>   # actual Milky Way dimensions (light-years)<br/><span class="ent">➎</span> DISC_RADIUS = 50000<br/>   DISC_HEIGHT = 1000<br/><span class="ent">➏</span> DISC_VOL = math.pi * DISC_RADIUS**2 * DISC_HEIGHT</p>
<p class="listing" id="ch10list4"><em>Listing 10-4: Sets up</em> <span class="codeitalic">tkinter</span> <em>window and canvas and assigns constants</em></p>
<p class="indent">Start by creating a window with the conventional name <span class="literal">root</span> <span class="ent">➊</span>. This is a <em>top-level</em> window that will hold everything else. In the next line, give the window a title—“Milky Way galaxy”—which will appear in the upper left of the window frame (see <a href="ch10.xhtml#ch10fig9">Figure 10-9</a> for an example).</p>
<p class="indent">Next, add a component, known as a <em>widget</em>, to the root window. <em>Widget</em> stands for “Windows gadget.” There are 21 core widgets in <span class="literal">tkinter</span>, including labels, frames, radio buttons, and scroll bars. Assign a <span class="literal">Canvas</span> widget to contain all the drawing objects <span class="ent">➋</span>. This is a general-purpose widget intended for graphics and other complex layouts. Specify the parent window, the screen width and height, and the background color. Name the canvas <span class="literal">c</span>, for <em>canvas</em>.</p>
<p class="indent">You can divide the <span class="literal">Canvas</span> widget into rows and columns, like a table or spreadsheet. Each cell in this grid can hold a different widget, and these widgets can span multiple cells. Within a cell, you can align a widget using the <span class="literal">STICKY</span> option. To manage each widget in a window, you’ll need to use the <span class="literal">grid</span> geometry manager. Since you’re using only one widget in this project, you don’t need to pass the manager anything <span class="ent">➌</span>.</p>
<p class="indent">Finish by configuring the <span class="literal">canvas</span> to use a <span class="literal">scrollregion</span> <span class="ent">➍</span>. This sets the origin coordinates <span class="literal">(0, 0)</span> to the center of the <span class="literal">canvas</span>. You need this to draw the galaxy’s spiral arms with polar coordinates. Without it, the default origin would be the top-left corner of the <span class="literal">canvas</span>.</p>
<p class="indent">The arguments passed to <span class="literal">configure</span> set the limits of the <span class="literal">canvas</span>. These should be half of the <span class="literal">canvas</span> width and height; for example, scroll limits of <span class="literal">600, 500</span> will require <span class="literal">canvas</span> dimensions of <span class="literal">1200, 1000</span>. The values shown here work well on a small laptop, but feel free to alter them later if you find you need a larger window.</p>
<p class="indent">Follow the input section with dimensional constants for the galaxy <span class="ent">➎</span>. You could assign some of these variables within functions, but having them in the global space allows for a more logical flow to the code explanation. The first two are the radius and height of the galactic disc from <a href="ch10.xhtml#ch10fig2">Figure 10-2</a>. The final constant represents the disc volume <span class="ent">➏</span>.</p>
<h5 class="h5" id="lev234"><strong>Scaling the Galaxy and Calculating the Probability of Detection</strong></h5>
<p class="noindent"><a href="ch10.xhtml#ch10list5">Listing 10-5</a> defines functions to scale the galaxy dimensions based on the diameter of the radio bubble in use and to calculate the probability of one civilization detecting another. The latter function is where you apply the polynomial equation built with the <em>probability_of_detection.py</em> program described previously.</p>
<p class="margin"><span epub:type="pagebreak" id="page_204"/><em>galaxy_simulator.py,</em> part 3</p>
<p class="programs"><span class="ent">➊</span> def scale_galaxy():<br/>       """Scale galaxy dimensions based on radio bubble size (scale)."""<br/>       disc_radius_scaled = round(DISC_RADIUS / SCALE)<br/>    <span class="ent">➋</span> bubble_vol = 4/3 * math.pi * (SCALE / 2)**3<br/>    <span class="ent">➌</span> disc_vol_scaled = DISC_VOL/bubble_vol<br/>    <span class="ent">➍</span> return disc_radius_scaled, disc_vol_scaled<br/><br/><span class="ent">➎</span> def detect_prob(disc_vol_scaled):<br/>       """Calculate probability of galactic civilizations detecting each other."""<br/>    <span class="ent">➏</span> ratio = NUM_CIVS / disc_vol_scaled  # ratio of civs to scaled galaxy volume<br/>    <span class="ent">➐</span> if ratio &lt; 0.002:  # set very low ratios to probability of 0<br/>           detection_prob = 0<br/>       elif ratio &gt;= 5:  # set high ratios to probability of 1<br/>           detection_prob = 1<br/>    <span class="ent">➑</span> else:<br/>           detection_prob = -0.004757 * ratio**4 + 0.06681 * ratio**3 - 0.3605 * \<br/>                            ratio**2 + 0.9215 * ratio + 0.00826<br/>    <span class="ent">➒</span> return round(detection_prob, 3)</p>
<p class="listing" id="ch10list5"><em>Listing 10-5: Scales galactic dimensions and calculates detection probability</em></p>
<p class="indent">Define a function called <span class="literal">scale_galaxy()</span> to scale the galactic dimensions to the radio bubble size <span class="ent">➊</span>. It will use the constants from the global space, so there is no need to pass it any arguments. Calculate the scaled disc radius and then the radio bubble volume, using the equation for the volume of a sphere, and assign the results to <span class="literal">bubble_vol</span> <span class="ent">➋</span>.</p>
<p class="indent">Next, divide the actual disc volume by <span class="literal">bubble_vol</span> to get the scaled disc volume <span class="ent">➌</span>. This is the number of radio bubble “equivalent volumes” that can fit in the galaxy. Each bubble constitutes a possible location for a civilization.</p>
<p class="indent">End the function by returning the <span class="literal">disc_radius_scaled</span> and <span class="literal">disc_vol_scaled</span> variables <span class="ent">➍</span>.</p>
<p class="indent">Now, define a function called <span class="literal">detect_prob()</span> to calculate the probability of detection, which takes the scaled disc volume as an argument <span class="ent">➎</span>. For the <span class="literal">x</span> term in the polynomial, calculate the ratio of the number of civilizations to the scaled disc volume <span class="ent">➏</span>. Since the polynomial regression can have problems at the endpoints, use conditionals to set very small ratios to <span class="literal">0</span> and large ratios to <span class="literal">1</span> <span class="ent">➐</span>. Otherwise, apply the polynomial expression generated by the <em>probability_of_detection.py</em> code <span class="ent">➑</span>, then return the probability rounded to three decimal places <span class="ent">➒</span>.</p>
<h5 class="h5" id="lev235"><strong>Using Polar Coordinates</strong></h5>
<p class="noindent"><a href="ch10.xhtml#ch10list6">Listing 10-6</a> defines a function to select random (<em>x</em>, <em>y</em>) locations using polar coordinates. This function will choose the locations of some of the stars posted in the graphical model. Because the display is 2D, there’s no need to choose a <em>z</em> location.</p>
<p class="margin"><em>galaxy_simulator.py,</em> part 4</p>
<p class="programs"><span class="ent">➊</span> def random_polar_coordinates(disc_radius_scaled):<br/>       """Generate uniform random (x, y) point within a disc for 2D display."""<br/>    <span class="ent">➋</span> r = random()<br/>    <span class="ent">➌</span> theta = uniform(0, 2 * math.pi)<br/><span epub:type="pagebreak" id="page_205"/>    <span class="ent">➍</span> x = round(math.sqrt(r) * math.cos(theta) * disc_radius_scaled)<br/>       y = round(math.sqrt(r) * math.sin(theta) * disc_radius_scaled)<br/>    <span class="ent">➎</span> return x, y</p>
<p class="listing" id="ch10list6"><em>Listing 10-6: Defines a function to randomly pick an (</em>x, y<em>) pair with polar coordinates</em></p>
<p class="indent">The function takes the scaled disc radius as an argument <span class="ent">➊</span>. Use the <span class="literal">random()</span> function to choose a float value between 0.0 and 1.0 and assign it to the variable <span class="literal">r</span> <span class="ent">➋</span>. Next, randomly choose <span class="literal">theta</span> from a uniform distribution between 0 and 360 degrees (2π is the radian equivalent of 360 degrees) <span class="ent">➌</span>.</p>
<p class="indent">The transformation to generate points <em>evenly</em> over a <em>unit</em> disc is:</p>
<div class="imagec"><img src="../images/f0205-01.jpg" alt="image"/></div>
<p class="indent">The equations yield (<em>x</em>, <em>y</em>) values between -1 and 1. To scale the results to the galactic disc, multiply by the scaled disc radius <span class="ent">➍</span>. End the function by returning <span class="literal">x</span> and <span class="literal">y</span> <span class="ent">➎</span>.</p>
<h5 class="h5" id="lev236"><strong>Building Spiral Arms</strong></h5>
<p class="noindent"><a href="ch10.xhtml#ch10list7">Listing 10-7</a> defines a function that builds the spiral arms using the logarithmic spiral equation. This spiral may be miraculous, but a large part of the magic is tinkering with the initial bare-bones spiral to flesh out the arm. You’ll accomplish this by varying the size of stars, randomly altering their positions a tiny amount, and duplicating the spiral for each arm in order to shift it slightly backward and dim its stars.</p>
<p class="margin"><em>galaxy_simulator.py,</em> part 5</p>
<p class="programs"><span class="ent">➊</span> def spirals(b, r, rot_fac, fuz_fac, arm):<br/>       """Build spiral arms for tkinter display using logarithmic spiral formula.<br/><br/>       b = arbitrary constant in logarithmic spiral equation<br/>       r = scaled galactic disc radius<br/>       rot_fac = rotation factor<br/>       fuz_fac = random shift in star position in arm, applied to 'fuzz' variable<br/>       arm = spiral arm (0 = main arm, 1 = trailing stars)<br/>       """<br/>    <span class="ent">➋</span> spiral_stars = []<br/>    <span class="ent">➌</span> fuzz = int(0.030 * abs(r)) # randomly shift star locations<br/>       theta_max_degrees = 520<br/>    <span class="ent">➍</span> for i in range(theta_max_degrees):  # range(0, 600, 2) for no black hole<br/>           theta = math.radians(i)<br/>           x = r * math.exp(b * theta) * math.cos(theta + math.pi * rot_fac)\<br/>               + randint(-fuzz, fuzz) * fuz_fac<br/>           y = r * math.exp(b * theta) * math.sin(theta + math.pi * rot_fac)\<br/>               + randint(-fuzz, fuzz) * fuz_fac<br/>           spiral_stars.append((x, y))<br/>    <span class="ent">➎</span> for x, y in spiral_stars:<br/>        <span class="ent">➏</span> if arm == 0 and int(x % 2) == 0:<br/>               c.create_oval(x-2, y-2, x+2, y+2, fill='white', outline='')<br/>           elif arm == 0 and int(x % 2) != 0:<br/>               c.create_oval(x-1, y-1, x+1, y+1, fill='white', outline='')<br/><span epub:type="pagebreak" id="page_206"/>        <span class="ent">➐</span> elif arm == 1:<br/>               c.create_oval(x, y, x, y, fill='white', outline='')</p>
<p class="listing" id="ch10list7"><em>Listing 10-7: Defines the</em> <span class="codeitalic">spirals()</span> <em>function</em></p>
<p class="indent">Define a function called <span class="literal">spirals()</span> <span class="ent">➊</span>. Its parameters are listed in the function docstring. The first two parameters, <span class="literal">b</span> and <span class="literal">r</span>, are from the logarithmic spiral equation. The next, <span class="literal">rot_fac</span>, is the rotation factor that lets you move the spiral around the center point so you can produce a new spiral arm. The fuzz factor, <span class="literal">fuz_fac</span>, lets you tweak how far you move stars away from the center of the spiraling line. Finally, the <span class="literal">arm</span> parameter lets you specify either the leading arm or the trailing arm of faint stars. The trailing arm will be shifted—that is, plotted a little behind the leading arm—and its stars will be smaller.</p>
<p class="indent">Initialize an empty list to hold the locations of the stars that will make up the spiral <span class="ent">➋</span>. Assign a <span class="literal">fuzz</span> variable, where you multiply an arbitrary constant by the absolute value of the scaled disc radius <span class="ent">➌</span>. The spiral equation alone produces stars that are lined up (see the left two panels in <a href="ch10.xhtml#ch10fig11">Figure 10-11</a>). Fuzzing will move stars in the spiral back and forth a little, to either side of the spiral line. You can see the effect on the bright stars in the rightmost panel in <a href="ch10.xhtml#ch10fig11">Figure 10-11</a>. I determined these values through trial and error; feel free to play with them if you like.</p>
<div class="image"><a id="ch10fig11"/><img src="../images/f0206-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 10-11: Filling out the spiral arms by shifting spirals and randomly changing star positions</em></p>
<p class="indent">Now it’s time to build the spiral lines. First, use a range of values to represent θ in the logarithmic spiral equation <span class="ent">➍</span>. A range of about <span class="literal">520</span> will produce the galaxy in <a href="ch10.xhtml#ch10fig9">Figure 10-9</a>, which has a central “black hole.” Otherwise, use a range of <span class="literal">(0, 600, 2)</span>—or similar—to produce a bright central core fully packed with stars (<a href="ch10.xhtml#ch10fig12">Figure 10-12</a>). You can tinker with these values until you get your preferred result. Loop through the values in <span class="literal">theta</span> and apply the logarithmic spiral equation, using cosine for the x-value and sine for the y-value. Note that you add the <span class="literal">fuzz</span> value, multiplied by the fuzz factor, to the result. Append each (<em>x</em>, <em>y</em>) pair to the <span class="literal">spiral_stars</span> list.</p>
<div class="image"><span epub:type="pagebreak" id="page_207"/><a id="ch10fig12"/><img src="../images/f0207-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 10-12: Graphical model without the central black hole (compare to <a href="ch10.xhtml#ch10fig9">Figure 10-9</a>)</em></p>
<p class="indent">Later, in the <span class="literal">main()</span> function, you’ll specify the <span class="literal">rot_fac</span> variable, which will move the spiral around the center. After the program builds the four main arms, it will use <span class="literal">rot_fac</span> to build four new arms, slightly offset from the first four, to produce the band of dim, trailing stars seen to the left of each arc of bright stars in <a href="ch10.xhtml#ch10fig11">Figure 10-11</a>.</p>
<p class="indent">Now that you have the list of star locations, start a <span class="literal">for</span> loop through the (<em>x</em>, <em>y</em>) coordinates <span class="ent">➎</span>. Then use a conditional statement to choose the main, leading arm and locations for which <span class="literal">x</span> is even <span class="ent">➏</span>. For these, use the <span class="literal">canvas</span> widget’s <span class="literal">create_oval()</span> method to create a star object to post. This method’s first four arguments define a bounding box into which the oval fits. The larger the number after <span class="literal">x</span> and <span class="literal">y</span>, the larger the oval. Make the fill white and don’t use an outline; the default outline is a thin black line.</p>
<p class="indent">If the x-value is odd, make the star a step smaller. And if the <span class="literal">arm</span> value is <span class="literal">1</span>, the star is in the shifted arm, so make it as small as possible <span class="ent">➐</span>.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>The star objects are for visual impact only. Neither their size nor number is to scale. To be realistic, they would be much, much smaller and much more numerous (over 100 billion!).</em></p>
</div>
<h5 class="h5" id="lev237"><strong>Scattering Star Haze</strong></h5>
<p class="noindent">The space between the spiral arms isn’t devoid of stars, so the next function (<a href="ch10.xhtml#ch10list8">Listing 10-8</a>) randomly casts points across the galactic model, with no regard for spiral arms. Think of this as the glow you see in photographs of distant galaxies.</p>
<p class="margin"><span epub:type="pagebreak" id="page_208"/><em>galaxy_simulator.py,</em> part 6</p>
<p class="programs"><span class="ent">➊</span> def star_haze(disc_radius_scaled, density):<br/>       """Randomly distribute faint tkinter stars in galactic disc.<br/><br/>       disc_radius_scaled = galactic disc radius scaled to radio bubble diameter<br/>       density = multiplier to vary number of stars posted<br/>       """<br/>    <span class="ent">➋</span> for i in range(0, disc_radius_scaled * density):<br/>        <span class="ent">➌</span> x, y = random_polar_coordinates(disc_radius_scaled)<br/>        <span class="ent">➍</span> c.create_text(x, y, fill='white', font=('Helvetica', '7'), text='.')</p>
<p class="listing" id="ch10list8"><em>Listing 10-8: Defines the</em> <span class="codeitalic">star_haze()</span> <em>function</em></p>
<p class="indent">Define the <span class="literal">star_haze()</span> function and pass it two arguments: the scaled disc radius and an integer multiplier that the function will use to increase the base number of random stars <span class="ent">➊</span>. So, if you prefer a thick fog rather than a light haze, increase the value of the density value when you call the function in <span class="literal">main()</span>.</p>
<p class="indent">Start a <span class="literal">for</span> loop where the maximum range value is equal to the scaled disc radius multiplied by <span class="literal">density</span> <span class="ent">➋</span>. By using the radius value, you scale the number of stars to the size of the disc being displayed. Then call the <span class="literal">random_polar_coordinates()</span> function to get an (<em>x</em>, <em>y</em>) pair <span class="ent">➌</span>.</p>
<p class="indent">End by creating a display object for the canvas using the (<em>x</em>, <em>y</em>) pair <span class="ent">➍</span>. Since you’ve already used the smallest oval size for the stars along and around the spiral, use the <span class="literal">create_text()</span> method instead of <span class="literal">create_oval()</span>. With this method, you can use a period to represent a star. The font size parameter will allow you to scale the haze stars until you find something aesthetically pleasing.</p>
<p class="indent"><a href="ch10.xhtml#ch10fig13">Figure 10-13</a> is a comparison between the galactic model without the star haze (left) and with the star haze (right).</p>
<div class="image"><a id="ch10fig13"/><img src="../images/f0208-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 10-13: Galactic model without star haze (left) versus with star haze (right)</em></p>
<p class="indent">You can be creative with the haze. For example, you can make the stars more numerous and color them gray, or use a loop to vary both their size and color. Don’t use green, however, as there are no green stars in the universe!</p>
<h5 class="h5" id="lev238"><span epub:type="pagebreak" id="page_209"/><strong>Defining the main() Function</strong></h5>
<p class="noindent"><a href="ch10.xhtml#ch10list9">Listing 10-9</a> defines the <span class="literal">main()</span> function in <em>galaxy_simulator.py</em>. It will make the calls to scale the galaxy, calculate the probability of detection, build the galaxy display, and post statistics. It will also run the <span class="literal">tkinter</span> main loop.</p>
<p class="margin"><em>galaxy_simulator.py,</em> part 8</p>
<p class="programs">def main():<br/>       """Calculate detection probability &amp; post galaxy display &amp; statistics."""<br/>    <span class="ent">➊</span> disc_radius_scaled, disc_vol_scaled = scale_galaxy()<br/>       detection_prob = detect_prob(disc_vol_scaled)<br/><br/>       # build 4 main spiral arms &amp; 4 trailing arms<br/>    <span class="ent">➋</span> spirals(b=-0.3, r=disc_radius_scaled, rot_fac=2, fuz_fac=1.5, arm=0)<br/>       spirals(b=-0.3, r=disc_radius_scaled, rot_fac=1.91, fuz_fac=1.5, arm=1)<br/>       spirals(b=-0.3, r=-disc_radius_scaled, rot_fac=2, fuz_fac=1.5, arm=0)<br/>       spirals(b=-0.3, r=-disc_radius_scaled, rot_fac=-2.09, fuz_fac=1.5, arm=1)<br/>       spirals(b=-0.3, r=-disc_radius_scaled, rot_fac=0.5, fuz_fac=1.5, arm=0)<br/>       spirals(b=-0.3, r=-disc_radius_scaled, rot_fac=0.4, fuz_fac=1.5, arm=1)<br/>       spirals(b=-0.3, r=-disc_radius_scaled, rot_fac=-0.5, fuz_fac=1.5, arm=0)<br/>       spirals(b=-0.3, r=-disc_radius_scaled, rot_fac=-0.6, fuz_fac=1.5, arm=1)<br/>       star_haze(disc_radius_scaled, density=8)<br/><br/>       # display legend<br/>    <span class="ent">➌</span> c.create_text(-455, -360, fill='white', anchor='w',<br/>                     text='One Pixel = {} LY'.format(SCALE))<br/>       c.create_text(-455, -330, fill='white', anchor='w',<br/>                     text='Radio Bubble Diameter = {} LY'.format(SCALE))<br/>       c.create_text(-455, -300, fill='white', anchor='w',<br/>                     text='Probability of detection for {:,} civilizations = {}'.<br/>                     format(NUM_CIVS, detection_prob))<br/><br/>       # post Earth's 225 LY diameter bubble and annotate<br/>    <span class="ent">➍</span> if SCALE == 225:<br/>        <span class="ent">➎</span> c.create_rectangle(115, 75, 116, 76, fill='red', outline='')<br/>           c.create_text(118, 72, fill='red', anchor='w',<br/>                         text="&lt;---------- Earth's Radio Bubble")<br/><br/>       # run tkinter loop<br/>    <span class="ent">➏</span> root.mainloop()<br/><span class="ent">➐</span> if __name__ == '__main__':<br/>       main()</p>
<p class="listing" id="ch10list9"><em>Listing 10-9: Defines and calls the</em> <span class="codeitalic">main()</span> <em>function</em></p>
<p class="indent">Start <span class="literal">main()</span> by calling the <span class="literal">scale_galaxy()</span> function to get the scaled disc volume and radius <span class="ent">➊</span>. Then call the <span class="literal">detect_prob()</span> function and pass it the <span class="literal">disc_vol_scaled</span> variable. Assign the results to a variable named <span class="literal">detection_prob</span>.</p>
<p class="indent">Now build the galaxy display (graphical model) <span class="ent">➋</span>. This calls the <span class="literal">spirals()</span> function multiple times, with small changes to each call. The <span class="literal">arm</span> parameter designates the bright main arms and the faint trailing arms. The <span class="literal">rot_fac</span> (rotation factor) variable determines where the spiral plots. The slight change in rotation factor between arms 0 and 1 (for example, <span class="literal">2</span> to <span class="literal">1.91</span>) is <span epub:type="pagebreak" id="page_210"/>what causes the faint arm to plot slightly offset from the bright arm. Finish the display by calling the <span class="literal">star_haze()</span> function. Again, feel free to experiment with any of these parameters.</p>
<p class="indent">Next, display a legend and statistics. Start with the scale <span class="ent">➌</span> and radio bubble diameter followed by the probability of detection for the given number of civilizations. Arguments include the x and y coordinates, a fill (text) color, a justification anchor—with left represented by <span class="literal">w</span> for “west”—and the text. Note the use of <span class="literal">{:,}</span> to insert a comma as a thousand separator. This is part of the newer <em>string format method</em>. You can read more about it at <em><a href="https://docs.python.org/3/library/string.html#string-formatting">https://docs.python.org/3/library/string.html#string-formatting</a></em>.</p>
<p class="indent">If the user has selected a radio bubble diameter of <span class="literal">225</span> LY <span class="ent">➍</span>, then the display is at the same scale as our own emissions bubble, so post a red pixel at the approximate location of our solar system and annotate it <span class="ent">➎</span>. There are a number of ways to display a single pixel using <span class="literal">tkinter</span>. Here, you use the <span class="literal">create_rectangle()</span> method, but you can also make a line that is one pixel long with the following statement:</p>
<p class="programs">c.create_line(115, 75, 116, 75, fill='red')</p>
<p class="indent">With the <span class="literal">create_rectangle()</span> method, the first two arguments are points (<span class="literal">x0</span>, <span class="literal">y0</span>), which correspond to the top-left corner, and (<span class="literal">x1</span>, <span class="literal">y1</span>), the location of the pixel just outside of the bottom-right corner. With the <span class="literal">create_line()</span> method, the arguments are for the starting and ending points. The default line width is one pixel.</p>
<p class="indent">End the <span class="literal">main()</span> function by executing the <span class="literal">tkinter</span> <span class="literal">mainloop()</span> function, also known as the <em>event loop</em> <span class="ent">➏</span>. This keeps the <span class="literal">root</span> window open until you close it.</p>
<p class="indent">Back in the global space, end the program by allowing it to be run stand-alone or called as a module in another program <span class="ent">➐</span>.</p>
<p class="indent">The final display will look like <a href="ch10.xhtml#ch10fig14">Figure 10-14</a>, shown with the Earth’s radio bubble and a central black hole.</p>
<div class="image"><a id="ch10fig14"/><img src="../images/f0210-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 10-14: The final display, with Earth’s 225 LY diameter radio bubble posted on the galactic map</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_211"/>Note that, despite the fact that our radio bubble is no bigger than a pinprick at this scale, if civilizations had a detection range of 112.5 light-years, and if there were as many of these civilizations as predicted by current high-side parameters for the Drake equation, the probability of detection is 1!</p>
<h3 class="h3" id="lev239"><strong>Results</strong></h3>
<p class="noindent">Given the enormous uncertainty in the inputs and the use of simplifying assumptions, you’re not looking for accuracy here. What you’re looking for is <em>directionality</em>. Should we (or anyone like us) expect to detect another civilization that isn’t actively trying to contact us? Based on <a href="ch10.xhtml#ch10fig15">Figure 10-15</a>, probably not.</p>
<div class="image"><a id="ch10fig15"/><img src="../images/f0211-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 10-15: Probability of one civilization detecting another for different radio bubble diameters and different numbers of civilizations in the galaxy</em></p>
<p class="indent">With our current technology, we could detect emissions from a civilization as far away as 16 LY, which equates to a 32 LY diameter radio bubble. Even if the galaxy is filled with 15.6 million advanced civilizations, as predicted by the updated Drake equation in the Wikipedia article, the chance of detecting 32 LY radio bubbles is less than 4 percent!</p>
<p class="indent">Take another look at <a href="ch10.xhtml#ch10fig14">Figure 10-14</a>, and you can begin to appreciate the sheer enormity and emptiness of our galaxy. Astronomers even have a word for this: <em>Laniakea</em>, Hawaiian for “immeasurable heaven.”</p>
<p class="indent">Earth is, as Carl Sagan described it, just a “mote of dust, suspended in a sunbeam.” And recent studies suggest that the window of opportunity for detecting civilizations with radio waves is much smaller than we thought. If other civilizations follow our lead and switch to digital signals and satellite communications, then their incidental radio leakage will drop by at least a factor of four. We all become unintentionally stealthy, blooming for a hundred years or so, then fading away.</p>
<p class="indent">Given these facts, it’s not surprising that the government no longer funds the search for extraterrestrial intelligence using radio telescopes. <span epub:type="pagebreak" id="page_212"/>These days, efforts are shifting to optical methods that look for signature gases in the atmospheres of exoplanets, such as the waste products of life and industrial activity.</p>
<h3 class="h3" id="lev240"><strong>Summary</strong></h3>
<p class="noindent">In this chapter, you gained experience using <span class="literal">tkinter</span>, <span class="literal">matplotlib</span>, and <span class="literal">NumPy</span>. You generated a polynomial expression for making reasonable estimates of the likelihood of detecting incidental alien radio transmissions, and you used the always-available <span class="literal">tkinter</span> module to add a cool visual component to the analysis.</p>
<h3 class="h3" id="lev241"><strong>Further Reading</strong></h3>
<p class="noindent"><em>Are We Alone? Philosophical Implications of the Discovery of Extraterrestrial Life</em> (BasicBooks, 1995) by Paul Davies is a thoughtful look at the search for alien life, told by an eminent scientist and award-winning science writer.</p>
<p class="indent">“A New Formula Describing the Scaffold Structure of Spiral Galaxies” (<em>Monthly Notices of the Royal Astronomical Society</em>, July 21, 2009) by Harry I. Ringermacher and Lawrence R. Mead (<em><a href="https://arxiv.org/abs/0908.0892v1">https://arxiv.org/abs/0908.0892v1</a></em>) provides formulas for modeling the shapes of spiral galaxies observed by the Hubble telescope.</p>
<p class="indent">“Tkinter 8.5 Reference: A GUI for Python” (New Mexico Tech Computer Center, 2013) by John W. Shipman is a useful supplement to the official <span class="literal">tkinter</span> docs. It can be found at <em><a href="http://infohost.nmt.edu/tcc/help/pubs/tkinter/tkinter.pdf">http://infohost.nmt.edu/tcc/help/pubs/tkinter/tkinter.pdf</a></em>.</p>
<p class="indent">Another useful online <span class="literal">tkinter</span> resource is <em><a href="https://wiki.python.org/moin/TkInter/">https://wiki.python.org/moin/TkInter/</a></em>.</p>
<p class="indent"><em>Tkinter GUI Application Development HOTSHOT</em> (Packt Publishing, 2013) by Bhaskar Chaudhary uses a project-based approach to teach <span class="literal">tkinter</span>.</p>
<h3 class="h3" id="lev242"><strong>Practice Projects</strong></h3>
<p class="noindent">Try these three spin-off projects. You can find them in the appendix or download them from <em><a href="https://www.nostarch.com/impracticalpython/">https://www.nostarch.com/impracticalpython/</a></em>.</p>
<h4 class="h4" id="lev243"><strong><em>A Galaxy Far, Far Away</em></strong></h4>
<p class="noindent">Tired of living in the Milky Way galaxy? Heck, who isn’t? Fortunately, there’s more in heaven and earth than just logarithmic spirals. Use Python and <span class="literal">tkinter</span> to build us a new home—but not necessarily a realistic home. For inspiration, visit online articles like Alexandre Devert’s post on his Marmakoide’s Blog, “Spreading Points on a Disc and on a Sphere” (<em><a href="http://blog.marmakoide.org/">http://blog.marmakoide.org/</a></em>). The example shown in <a href="ch10.xhtml#ch10fig16">Figure 10-16</a> was built with <em>galaxy_practice.py</em>.</p>
<div class="image"><span epub:type="pagebreak" id="page_213"/><a id="ch10fig16"/><img src="../images/f0213-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 10-16: Galaxy produced by the</em> galaxy_practice.py <em>program</em></p>
<h4 class="h4" id="lev244"><strong><em>Building a Galactic Empire</em></strong></h4>
<p class="noindent">Pick a location in the galaxy, an average travel speed of 5 to 10 percent of the speed of light, and a time step of 500,000 years. Then model the expansion of a space-faring empire. At each time step, calculate the size of the expanding <em>colonization bubble</em> and update the galaxy map. Check your results by placing the home-world location at the center of the galaxy, setting the speed to <span class="literal">1</span>, and confirming that it takes 50,000 years to reach the edge of the galaxy.</p>
<p class="indent">When you have the program up and running, you can perform interesting experiments. For example, you can test how fast we would need to go to explore the galaxy in 10 million years, as mentioned in the introduction to this chapter (see <a href="ch10.xhtml#ch10fig17">Figure 10-17</a>).</p>
<div class="image"><a id="ch10fig17"/><img src="../images/f0213-02.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 10-17: A core-located empire’s expansion using travel below light speed over 10 million years</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_214"/>You could also estimate how much of the galaxy the <em>Star Trek</em> Federation could have explored in its first 100 years, assuming they averaged 100x light speed at warp 4 (<a href="ch10.xhtml#ch10fig18">Figure 10-18</a>).</p>
<div class="image"><a id="ch10fig18"/><img src="../images/f0214-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 10-18: Expansion of the</em> Star Trek <em>Federation in first 100 years under warp factor 4</em></p>
<p class="indent">These figures were built with the <em>empire_practice.py</em> program.</p>
<h4 class="h4" id="lev245"><strong><em>A Roundabout Way to Predict Detectability</em></strong></h4>
<p class="noindent">Another way to predict the probability of detection is to use polar coordinates to distribute civilizations—as xyz points—in the galactic disc and then round the points to the nearest radio bubble <em>radius</em>. Points that share the same location represent civilizations that could detect each other. But be careful—this method rounds using cubes rather than spheres, so you’ll need to convert the radius to the side of a cube that produces the same volume.</p>
<p class="indent">Write the program so that it predicts the probability of detecting 16 LY <em>radius</em> bubbles (the limit of our current technology) given 15,600,000 transmitting civilizations randomly distributed throughout the galaxy (updated Drake equation output from Wikipedia). Use the full 50,000 LY radius and 1,000 LY height of the galactic model when distributing the civilizations.</p>
<p class="indent">For a solution, see <em>rounded_detection_practice.py</em>. Note that the program will take several minutes to run.</p>
<h3 class="h3" id="lev246"><strong>Challenge Projects</strong></h3>
<p class="noindent">Here are a few follow-up projects to try on your own. Remember that I don’t provide solutions to challenge projects.</p>
<h4 class="h4" id="lev247"><strong><em>Creating a Barred-Spiral Galaxy</em></strong></h4>
<p class="noindent">Our understanding of the Milky Way evolves as we obtain and analyze new astronomical data. Scientists now believe that the core of the galaxy is <span epub:type="pagebreak" id="page_215"/>elongated and bar shaped. Use the equations provided in the Ringermacher and Mead paper, cited in “<a href="ch10.xhtml#lev241">Further Reading</a>” on <a href="ch10.xhtml#page_212">page 212</a>, to create a new <span class="literal">tkinter</span> visual model of the galaxy that honors the barred-spiral concept.</p>
<h4 class="h4" id="lev248"><strong><em>Adding Habitable Zones to Your Galaxy</em></strong></h4>
<p class="noindent">Solar systems have <em>Goldilocks zones</em> that are favorable for the development of life. Planets orbiting in these zones stay warm enough for at least some of their water to remain in liquid state.</p>
<p class="indent">There is also a theory that galaxies, like solar systems, have <em>habitable zones</em> in which life is more likely to develop. One definition of the habitable zone for the Milky Way places its inner boundary about 13,000 LY from the galactic center and its outer boundary about 33,000 LY from the center (<a href="ch10.xhtml#ch10fig19">Figure 10-19</a>). The core is excluded due to the high levels of radiation, large number of supernovas, and complex orbit-disrupting gravitational fields resulting from all the closely spaced stars. The rim areas are condemned due to low metallicity, which is crucial to the development of planets.</p>
<div class="image"><a id="ch10fig19"/><img src="../images/f0215-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 10-19: Approximate galactic habitable zone (shaded) superimposed on the Milky Way model</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_216"/>A refinement of the habitable zone model excludes spiral arms, for reasons similar to those applied to the core. Our own existence doesn’t contradict this. Earth is located in the Orion “spur,” a relatively small feature between the Sagittarius and Perseus arms.</p>
<p class="indent">Edit the <em>galaxy_simulation.py</em> program so that it uses only the volume in the galactic habitable zone, however you define it. You should research what these volumes may be and what effect they’ll have on the number of civilizations (<em>N</em>) that the Drake equation calculates. Consider using <em>regions</em>, such as the core, spirals, outer rim, and so on, within which <em>N</em> is different but civilizations are still randomly distributed. Highlight these regions on the galactic map and post their probability-of-detection estimates.</p>
</body></html>