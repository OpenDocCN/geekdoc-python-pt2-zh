["```py\ndef function_name(parameters):\n    <function body>\n```", "```py\ndef make_vector_between(p, q):\n    u = q['x'] - p['x']\n    v = q['y'] - p['y']\n\n    return {'u': u, 'v': v}\n```", "```py\nlast_point = {'x': 10, 'y': 20}\n\ndef make_vector(q):\n    u = q['x'] - last_point['x']\n    v = q['y'] - last_point['y']\n    new_vector = {'u': u, 'v': v}\n    last_point = q\n\n    return new_vector\n```", "```py\npoint = {'x': 5, 'y': 2}\nvector = {'u': 10, 'v': 20}\n```", "```py\ndef displaced_point(point, vector):\n    x = point['x'] + vector['u']\n    y = point['y'] + vector['v']\n\n    return {'x': x, 'y': y}\n```", "```py\n>>> displaced_point(point, vector)\n{'x': 15, 'y': 22}\n\n# let's check the state of point (shouldn't have been mutated)\n>>> point\n{'x': 5, 'y': 2}\n```", "```py\ndef displace_point_in_place(point, vector):\n    point['x'] += vector['u']\n    point['y'] += vector['v']\n```", "```py\n>>> displace_point_in_place(point, vector)\n# nothing gets returned from the function, so let's check the point\n\n>>> point\n{'x': 15, 'y': 22}\n# the original point has been mutated!\n```", "```py\n    lambda <arg1>, <arg2>, ...: <expression body>\n```", "```py\n>>> sum = lambda x, y: x + y\n>>> sum(1, 2)\n3\n```", "```py\n>>> def sum(x, y):\n...     return x + y\n...\n>>> sum(1, 2)\n3\n```", "```py\n>>> def repeat_fn(fn, times):\n...     for _ in range(times):\n...         fn()\n...\n\n>>> def say_hi():\n...     print('Hi there!')\n...\n\n>>> repeat_fn(say_hi, 5)\nHi there!\nHi there!\nHi there!\nHi there!\nHi there!\n```", "```py\n>>> def repeat_fn(fn, times):\n...     for _ in range(times):\n...         fn()\n...\n\n>>> repeat_fn(lambda: print(\"Hello!\"), 5)\nHello!\nHello!\nHello!\nHello!\nHello!\n```", "```py\n>>> def make_contains_validator(sequence):\n...     return lambda string: sequence in string\n```", "```py\n>>> validate_contains_at = make_contains_validator('@')\n```", "```py\n>>> validate_contains_at('foo@bar.com')\nTrue\n>>> validate_contains_at('not this one')\nFalse\n```", "```py\ndef outer_fn(a, b):\n    c = a + b\n\n    def inner_fn():\n        # we have access to a, b and c here\n        print(a, b, c)\n\n    inner_fn()\n```", "```py\ndef public_fn():\n    # this function can be imported\n\ndef __private_fn():\n    # this function should only be accessed from inside the module\n```", "```py\n    filter(<predicate_fn>, <collection>)\n```", "```py\nlambda n: n % 2 == 0\n```", "```py\n>>> numbers = [1, 2, 3, 4, 5, 6, 7, 8]\n>>> evens = filter(lambda n: n % 2 == 0, numbers)\n>>> list(evens)\n[2, 4, 6, 8]\n```", "```py\n>>> for number in evens:\n...     print(number)\n...\n2\n4\n6\n8\n```", "```py\n    map(<mapping_fn>, <collection>)\n```", "```py\n>>> names = ['Angel', 'Alvaro', 'Mery', 'Paul', 'Isabel']\n>>> lengths = map(lambda name: len(name), names)\n>>> list(lengths)\n[5, 6, 4, 4, 6]\n```", "```py\n    reducer_fn(<accumulated_result>, <item>)\n```", "```py\n    reduce(<reducer_fn>, <collection>)\n```", "```py\n>>> from functools import reduce\n\n>>> letters = ['A', 'B', 'C', 'D']\n\n>>> reduce(lambda result, letter: result + letter, letters)\n'ABCD'\n```", "```py\n    reduce(<reducer_fn>, <collection>, <start_result>)\n```", "```py\n>>> reduce(lambda total_length, name: total_length + len(name), names)\nTraceback (most recent call last):\n  File \"<input>\", line 1, in <module>\n  File \"<input>\", line 1, in <lambda>\nTypeError: can only concatenate str (not \"int\") to str\n```", "```py\n>>> reduce(lambda total_length, name: total_length + len(name), names, 0)\n25\n```", "```py\n>>> from functools import reduce\n\n>>> names = ['Angel', 'Alvaro', 'Mery', 'Paul', 'Isabel']\n>>> lengths = map(lambda name: len(name), names)\n>>> reduce(lambda total_length, length: total_length + length, lengths)\n25\n```", "```py\n>>> from functools import reduce\n>>> import operator\n\n>>> names = ['Angel', 'Alvaro', 'Mery', 'Paul', 'Isabel']\n>>> lengths = map(lambda name: len(name), names)\n>>> reduce(operator.add, lengths)\n25\n```", "```py\ndef add(a, b):\n    \"Same as a + b.\"\n    return a + b\n```", "```py\n['Angel', 'Angel-Alvaro', 'Angel-Alvaro-Mery', ...]\n```", "```py\n>>> from functools import reduce\n\n>>> names = ['Angel', 'Alvaro', 'Mery', 'Paul', 'Isabel']\n>>> def compute_next_name(names, name):\n...     if len(names) < 1:\n...         return name\n...     return names[-1] + '-' + name\n...\n>>> reduce(\n...    lambda result, name: result + [compute_next_name(result, name)],\n...    names,\n...    [])\n['Angel', 'Angel-Alvaro', 'Angel-Alvaro-Mery', 'Angel-Alvaro-Mery-Paul', ...]\n```", "```py\n    [<expression> for <item> in <list>]\n```", "```py\n>>> names = ['Angel', 'Alvaro', 'Mery', 'Paul', 'Isabel']\n>>> [len(name) for name in names]\n[5, 6, 4, 4, 6]\n```", "```py\n    [<expression> for <item> in <list> if <condition>]\n```", "```py\n>>> [name for name in names if name.startswith('A')]\n['Angel', 'Alvaro']\n```", "```py\n>>> [(name, len(name)) for name in names if len(name) < 6]\n[('Angel', 5), ('Mery', 4), ('Paul', 4)]\n```", "```py\n>>> names_with_length = map(lambda name: (name, len(name)), names)\n>>> result = filter(lambda name_length: name_length[1] < 6, names_with_length)\n>>> list(result)\n[('Angel', 5), ('Mery', 4), ('Paul', 4)]\n```", "```py\nclass CoffeeMachine:\n    def __init__(self):\n        self.__coffees_brewed = 0\n```", "```py\n>>> machine = CoffeeMachine()\n```", "```py\ndef __init__(self):\n    self.__coffees_brewed = 0\n```", "```py\n# Don't do this!\n>>> machine.__coffees_brewed\n0\n```", "```py\n# Don't do this!\n>>> machine.__coffees_brewed = 5469\n>>> machine.__coffees_brewed\n5469\n```", "```py\n>>> machine = CoffeeMachine()\n```", "```py\ndef brew_coffee(self):\n    # we need 'self' here to access the class' __coffees_brewed count\n    self.__coffees_brewed += 1\n```", "```py\nclass CoffeeMachine:\n    def __init__(self):\n        self.__coffees_brewed = 0\n\n    @property\n    def coffees_brewed(self):\n        return self.__coffees_brewed\n```", "```py\n>>> machine = CoffeeMachine()\n>>> machine.coffees_brewed\n0\n```", "```py\n@property\ndef coffees_brewed(self):\n    return self.__coffees_brewed\n```", "```py\nclass CoffeeMachine:\n    def __init__(self):\n        self.__coffees_brewed\n\n    @property\n    def has_brewed(self):\n        return self.__coffees_brewed > 0\n\n    --snip--\n```", "```py\n>>> machine.has_brewed\nFalse\n```", "```py\nclass CoffeeMachine:\n    def __init__(self):\n        self.__coffees_brewed = 0\n\n    @property\n    def coffees_brewed(self):\n        return self.__coffees_brewed\n\n    @property\n    def has_brewed(self):\n        return self.__coffees_brewed > 0\n\n    def brew_coffee(self):\n        self.__coffees_brewed += 1\n```", "```py\n>>> machine = CoffeeMachine()\n>>> machine.brew_coffee()\n```", "```py\n>>> machine.coffees_brewed\n1\n>>> machine.has_brewed\nTrue\n```", "```py\na_function()\n```", "```py\nmachine.brew_coffee()\n```", "```py\n>>> machine.brew_tea()\nTraceback (most recent call last):\n  File \"<input>\", line 1, in <module>\nAttributeError: 'CoffeeMachine' object has no attribute 'brew_tea'\n```", "```py\nclass CoffeeMachine:\n\n    def __init__(self):\n        self.__coffees_brewed = 0\n        self.__liters_of_water = 0\n\n    def fill_water_tank(self, liters):\n        self.__liters_of_water += liters\n```", "```py\n>>> machine = CoffeeMachine()\n>>> machine.fill_water_tank(5)\n```", "```py\nclass CoffeeHipster:\n    def __init__(self, skill_level):\n        self.__skill_level = skill_level\n\n    def brew_coffee(self):\n        # depending on the __skill_level, this method\n        # may take a long time to complete.\n        # But apparently the result will be worth it?\n        --snip--\n```", "```py\ndef keep_programmer_awake(programmer, coffee_producer):\n    while programmer.wants_to_sleep:\n        # give the coder some wakey juice\n        coffee_producer.brew_coffee()\n        --snip--\n```", "```py\n>>> machine = CoffeeMachine()\n>>> hipster = CoffeeHipster()\n>>> programmer = SleepyProgrammer('Angel')\n\n# works!\n>>> keep_programmer_awake(programmer, machine)\n\n# also works!\n>>> keep_programmer_awake(programmer, hipster)\n```", "```py\nclass ComplexNum:\n    def __init__(self, re, im):\n        self.__re = re\n        self.__im = im\n\n    @property\n    def real(self):\n        return self.__re\n\n    @property\n    def imaginary(self):\n        return self.__im\n```", "```py\nclass ComplexNum:\n\n    --snip--\n\n    def plus(self, addend):\n        return ComplexNum(\n            self.__re + addend.__re,\n            self.__im + addend.__im\n        )\n```", "```py\n>>> c1 = ComplexNum(2, 3)\n>>> c2 = ComplexNum(5, 7)\n\n>>> c1.plus(c2)\n# the result is: 7 + 10i\n```", "```py\n>>> c1 + c2\n```", "```py\nclass ComplexNum:\n\n    --snip--\n\n    def __add__(self, addend):\n        return ComplexNum(\n            self.__re + addend.__re,\n            self.__im + addend.__im\n        )\n```", "```py\nclass ComplexNum:\n\n    --snip--\n\n    def __sub__(self, subtrahend):\n        return ComplexNum(\n            self.__re - subtrahend.__re,\n            self.__im - subtrahend.__im\n        )\n```", "```py\n>>> c1 - c2\n# yields: -3 - 4i\n```", "```py\nclass ComplexNum:\n\n    --snip--\n\n    def __eq__(self, other):\n        return (self.__re == other.__re) and (self.__im == other.__im)\n```", "```py\n>>> c1 == c2\nFalse\n```", "```py\nclass ComplexNum:\n\n    def __init__(self, re, im):\n        self.__re = re\n        self.__im = im\n\n    @property\n    def real(self):\n        return self.__re\n\n    @property\n    def imaginary(self):\n        return self.__im\n```", "```py\ndef defrangulate(complex):\n    --snip--\n    im = complex.imaginry\n```", "```py\ndef defrangulate(complex: ComplexNum):\n    --snip--\n    im = complex.imaginry\n    -------------^-------\n    'ComplexNum' object has no attribute 'imaginry'\n```", "```py\nclass ComplexNum:\n    def __init__(self, re: float, im: float):\n        self.__re = re\n        self.__im = im\n```", "```py\ni = ComplexNumber('one', 'two')\n------------------^------------\nExpected type 'float', got 'str' instead.\n```"]