- en: '8'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '8'
- en: ORGANIZING VALUES USING SETS AND DICTIONARIES
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用集合和字典组织值
- en: '![image](Images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/common.jpg)'
- en: A Python list is useful whenever we need to store a sequence of values, such
    as the heights of action figures or the words in an essay. Lists make it easy
    for us to keep values in order and access a value given its index. As we’ll see
    in this chapter, though, there are operations that lists are not optimized for,
    including identifying whether a specific value is in a collection and making associations
    between pairs of values.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要存储一系列值时，比如动作人物的身高或文章中的单词，Python 列表非常有用。列表使我们能够轻松地保持值的顺序，并根据索引访问某个值。然而，正如我们在本章中将看到的，列表并不适合一些操作，包括检查某个特定值是否在集合中以及在值对之间建立关联。
- en: In this chapter, we’ll learn about Python sets and dictionaries, two alternatives
    to lists for storing collections of values. We’ll see that a set can be the tool
    of choice when we need to search for specific values and don’t care about their
    order and that a dictionary can be the tool of choice whenever we need to work
    with pairs of values.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习 Python 集合和字典，这两种存储值集合的替代方式。我们将看到，当我们需要查找特定值且不关心它们的顺序时，集合是首选工具；而当我们需要处理值对时，字典则是最佳选择。
- en: 'We’ll solve three problems using these new collections: determining the number
    of unique email addresses, finding common words in a list of words, and determining
    the number of special pairs of cities and states.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过这三种新的集合解决问题：确定唯一电子邮件地址的数量、查找一组单词中共同的单词，以及确定特殊的城市和州的配对数量。
- en: 'Problem #18: Email Addresses'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '问题 #18：电子邮件地址'
- en: In this problem, we’ll store a collection of email addresses. We won’t care
    about the number of times that each email address shows up, and we won’t care
    about maintaining the order of the email addresses. These lax storage requirements
    mean that we can forgo a list for a set—a Python type whose speed leaves lists
    in the dust. We’re going to learn all about sets.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个问题中，我们将存储一组电子邮件地址。我们不关心每个电子邮件地址出现的次数，也不关心电子邮件地址的顺序。这些宽松的存储要求意味着我们可以用集合代替列表——集合是
    Python 中一种比列表更高效的类型。我们将学习关于集合的所有内容。
- en: This is DMOJ problem ecoo19r2p1.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 DMOJ 问题 ecoo19r2p1。
- en: The Challenge
  id: totrans-9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战
- en: Did you know that there are many ways to write someone’s Gmail email address?
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道吗，写某人的 Gmail 地址有很多种方式？
- en: We can take someone’s Gmail address and add a plus (+) symbol and a string before
    the @ symbol, and they’ll get any email we send to that new address. That is,
    as far as Gmail addresses are concerned, all characters from a + symbol to just
    before the @ symbol are ignored. For example, I tell people that my Gmail address
    is *[daniel.zingaro@gmail.com](mailto:daniel.zingaro@gmail.com)*, but that’s only
    one way to write it. If you send email to *[daniel.zingaro+book@gmail.com](mailto:daniel.zingaro+book@gmail.com)*
    or *[daniel.zingaro+hi.there@gmail.com](mailto:daniel.zingaro+hi.there@gmail.com)*,
    I’ll get it. (Choose your favorite. Say hi!)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在某人的 Gmail 地址中加入一个加号（+）符号和一个字符串，在@符号前，这样他们就会收到我们发送到新地址的任何邮件。也就是说，就 Gmail
    地址而言，所有从加号（+）符号开始到@符号前的字符都会被忽略。例如，我告诉大家我的 Gmail 地址是* [daniel.zingaro@gmail.com](mailto:daniel.zingaro@gmail.com)*，但这只是其中一种写法。如果你发送邮件到*
    [daniel.zingaro+book@gmail.com](mailto:daniel.zingaro+book@gmail.com)* 或* [daniel.zingaro+hi.there@gmail.com](mailto:daniel.zingaro+hi.there@gmail.com)*，我也会收到。（选一个你喜欢的。打个招呼吧！）
- en: Dots before the @ symbol are also ignored in Gmail addresses. For example, if
    you send email to *[danielzingaro@gmail.com](mailto:danielzingaro@gmail.com)*
    (no dot at all), *[daniel..zingaro@gmail.com](mailto:daniel..zingaro@gmail.com)*
    (two dots in a row), *[da.nielz.in.gar.o..@gmail.com](mailto:da.nielz.in.gar.o..@gmail.com)*
    (chaotic dots), *[daniel.zin.garo+blah@gmail.com](mailto:daniel.zin.garo+blah@gmail.com)*,
    and so on, I’ll get it.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Gmail 地址中，@符号前的点也会被忽略。例如，如果你将邮件发送到* [danielzingaro@gmail.com](mailto:danielzingaro@gmail.com)*（没有点），*
    [daniel..zingaro@gmail.com](mailto:daniel..zingaro@gmail.com)*（两个点连在一起），* [da.nielz.in.gar.o..@gmail.com](mailto:da.nielz.in.gar.o..@gmail.com)*（混乱的点），*
    [daniel.zin.garo+blah@gmail.com](mailto:daniel.zin.garo+blah@gmail.com)*，等等，我都会收到。
- en: 'Last thing: uppercase and lowercase differences throughout the address are
    ignored. I hope you’re not firing a flurry at me by this point, but I’d get anything
    you send to *[Daniel.Zingaro@gmail.com](mailto:Daniel.Zingaro@gmail.com)*, *[DAnIELZIngARO+Flurry@gmAIL.COM](mailto:DAnIELZIngARO+Flurry@gmAIL.COM)*,
    and so on.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点：地址中的大小写差异会被忽略。我希望你此时不会朝我发射一阵子弹，但我会收到任何你发到* [Daniel.Zingaro@gmail.com](mailto:Daniel.Zingaro@gmail.com)*、*[DAnIELZIngARO+Flurry@gmAIL.COM](mailto:DAnIELZIngARO+Flurry@gmAIL.COM)*等地址的邮件。
- en: 'In this problem, we’re provided with email addresses, and we’re asked to determine
    the number of them that are unique. The rules for email addresses in this problem
    are the same as those discussed for Gmail: characters from a + symbol to just
    before the @ symbol are ignored, dots before the @ symbol are ignored, and case
    throughout the entire address is ignored.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个问题中，我们提供了电子邮件地址，我们需要确定其中有多少个是唯一的。这个问题中电子邮件地址的规则与 Gmail 中讨论的规则相同：从 + 符号到 @
    符号前的字符会被忽略，@ 符号前的点会被忽略，整个地址的大小写会被忽略。
- en: Input
  id: totrans-15
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输入
- en: 'The input consists of 10 test cases. Each test case contains the following
    lines:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 输入包含 10 个测试用例。每个测试用例包含以下几行：
- en: A line containing integer *n*, the number of email addresses. *n* is between
    1 and 100,000.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一行包含整数 *n*，表示电子邮件地址的数量。*n* 介于 1 和 100,000 之间。
- en: '*n* lines, each of which gives an email address. Each email address consists
    of at least one character before the @ symbol, followed by the @ symbol itself,
    followed by at least one character after the @ symbol. Characters before the @
    symbol consist of letters, numbers, dots, and pluses. Characters after the @ symbol
    consist of letters, numbers, and dots.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*n* 行，每行包含一个电子邮件地址。每个电子邮件地址至少包含一个 @ 符号前的字符，后跟 @ 符号本身，再后面是至少一个 @ 符号后的字符。@ 符号前的字符可以是字母、数字、点和加号。@
    符号后的字符可以是字母、数字和点。'
- en: Output
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输出
- en: For each test case, output the number of unique email addresses.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个测试用例，输出唯一电子邮件地址的数量。
- en: The time limit for solving the test cases is 30 seconds.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 解决测试用例的时间限制为 30 秒。
- en: Using a List
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用列表
- en: You’ve worked through seven chapters of this book. In each one, I posed a problem
    and then taught you new Python features so that you could solve that problem.
    You might therefore expect me to teach you some new Python before solving Email
    Addresses.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经完成了本书的七章内容。在每一章中，我都提出了一个问题，然后教你新的 Python 特性，以便你能够解决这个问题。因此，你可能会期望我在解决电子邮件地址问题之前，教你一些新的
    Python 知识。
- en: 'And you might object to that: don’t we already have what we need? After all,
    we can write a function to take an email address and return a clean version, with
    no + stuff, no dots before the @ symbol, and all in lowercase. We can also maintain
    a list of clean email addresses. For each email address that we see, we can clean
    it up and check whether it’s in the list of clean email addresses. If it isn’t,
    then we can add it; if it is, then we do nothing (since it’s already being counted).
    Once we’ve gone through all of the email addresses, the length of the list will
    give us the number of unique email addresses.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会对此提出异议：难道我们已经拥有了所需的内容吗？毕竟，我们可以编写一个函数来接受电子邮件地址并返回清理后的版本，没有 + 相关内容，没有 @ 符号前的点，且全部小写。我们还可以维护一个清理后的电子邮件地址列表。对于我们看到的每个电子邮件地址，我们可以清理它并检查它是否已经在清理后的电子邮件地址列表中。如果没有，我们就添加它；如果有，我们就什么也不做（因为它已经被计数了）。一旦我们遍历了所有电子邮件地址，列表的长度将给出唯一电子邮件地址的数量。
- en: Yes. We may already have what we need. Let’s try solving this thing.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 是的。我们可能已经拥有了所需的内容。让我们尝试解决这个问题。
- en: Cleaning an Email Address
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 清理电子邮件地址
- en: Consider the email address *[DAnIELZIngARO+Flurry@gmAIL.COM](mailto:DAnIELZIngARO+Flurry@gmAIL.COM)*.
    We’re going to clean this email address so that it becomes *[danielzingaro@gmail.com](mailto:danielzingaro@gmail.com)*.
    No +Flurry, no dots before the @ symbol, and all lowercase. We can think of the
    clean version as the true email address. Any other email address that represents
    the same true email address will also match *[danielzingaro@gmail.com](mailto:danielzingaro@gmail.com)*
    once it’s been cleaned.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑电子邮件地址 *[DAnIELZIngARO+Flurry@gmAIL.COM](mailto:DAnIELZIngARO+Flurry@gmAIL.COM)*。我们将清理这个电子邮件地址，使其变为
    *[danielzingaro@gmail.com](mailto:danielzingaro@gmail.com)*。没有 +Flurry，没有 @ 符号前的点，而且全部小写。我们可以将清理后的版本视为真实的电子邮件地址。任何表示相同真实电子邮件地址的其他电子邮件地址，在清理后也会匹配
    *[danielzingaro@gmail.com](mailto:danielzingaro@gmail.com)*。
- en: 'Cleaning an email address is a small, self-contained task, so let’s write a
    function for it. This clean function will take a string representing an email
    address, clean it up, and return the cleaned email address. We’ll carry out three
    cleaning steps: removing characters from a + symbol to just before the @ symbol,
    removing dots before the @ symbol, and converting to lowercase. The code for this
    function is in [Listing 8-1](ch08.xhtml#ch08ex01).'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 清理电子邮件地址是一个小而独立的任务，因此让我们为此编写一个函数。这个清理函数将接受一个代表电子邮件地址的字符串，清理它，并返回清理后的电子邮件地址。我们将执行三个清理步骤：从
    + 符号到 @ 符号前的字符需要删除，@ 符号前的点需要删除，以及将字符转换为小写。这个函数的代码在[清单 8-1](ch08.xhtml#ch08ex01)中。
- en: 'def clean(address):'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 'def clean(address):'
- en: '"""'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: address is a string email address.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: address是一个字符串，表示电子邮件地址。
- en: Return cleaned address.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 返回清理后的地址。
- en: '"""'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: '# Remove from ''+'' up to but not including ''@'''
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '# 去除从''+''到@符号前的所有内容'
- en: ❶ plus_index = address.find('+')
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ plus_index = address.find('+')
- en: 'if plus_index != -1:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 'if plus_index != -1:'
- en: ❷ at_index = address.find('@')
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ at_index = address.find('@')
- en: address = address[:plus_index] + address[at_index:]
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: address = address[:plus_index] + address[at_index:]
- en: '# Remove dots before @ symbol'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '# 去除@符号前的点'
- en: at_index = address.find('@')
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: at_index = address.find('@')
- en: before_at = ''
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: before_at = ''
- en: i = 0
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: i = 0
- en: 'while i < at_index:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 'while i < at_index:'
- en: '❸ if address[i] != ''.'':'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '❸ if address[i] != ''.'':'
- en: before_at = before_at + address[i]
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: before_at = before_at + address[i]
- en: i = i + 1
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: i = i + 1
- en: ❹ cleaned = before_at + address[at_index:]
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ cleaned = before_at + address[at_index:]
- en: '# Convert to lowercase'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '# 转换为小写'
- en: ❺ cleaned = cleaned.lower()
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ cleaned = cleaned.lower()
- en: return cleaned
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: return cleaned
- en: '*Listing 8-1: Cleaning an email address*'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单8-1：清理电子邮件地址*'
- en: 'The first step is to remove characters from a + symbol to just before the @
    symbol. The string find method is useful here. It returns the index of the leftmost
    occurrence of its argument, or -1 if the argument isn’t found:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是去除从+符号到@符号之前的所有字符。字符串的find方法在这里非常有用。它返回参数最左边出现的位置索引，如果找不到则返回-1：
- en: '>>> ''abc+def''.find(''+'')'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> ''abc+def''.find(''+'')'
- en: '3'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: '>>> ''abcdef''.find(''+'')'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> ''abcdef''.find(''+'')'
- en: '-1'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '-1'
- en: I use find to determine the index of the leftmost + symbol ❶. If there is no
    + symbol at all, then there’s nothing to do for this step. If there is one, however,
    then we find the index of the @ symbol ❷ and remove characters from the + symbol
    up to but not including the @ symbol.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用find方法来确定最左边的+符号的索引 ❶。如果没有+符号，那么这一操作就不需要做了。但是，如果有的话，我们会找到@符号的索引 ❷，并去掉从+符号到@符号之前的所有字符。
- en: The second step is to remove any dots before the @ symbol. To do that, I use
    a new string, before_at, to accumulate the part of the address before the @ symbol.
    Each character before the @ symbol that is not a . is added to before_at ❸.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步是去掉@符号前面的任何点。为此，我使用一个新的字符串before_at，用来累积@符号前的部分。每个@符号前不是点的字符都会被添加到before_at中
    ❸。
- en: The before_at string doesn’t include the @ symbol or any characters following
    it. We don’t want to lose that part of the email address, so I use a new variable,
    cleaned, to refer to the whole email address ❹.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: before_at字符串不包括@符号或其后的任何字符。我们不想丢失电子邮件地址的这部分，所以我使用一个新变量cleaned，来表示整个电子邮件地址 ❹。
- en: The third step is to convert the entire email address to lowercase ❺. After
    that, the email address is clean, so we can return it.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 第三步是将整个电子邮件地址转换为小写 ❺。完成后，电子邮件地址就被清理好了，可以返回它。
- en: 'Let’s test this a little. Enter the code for our clean function into the Python
    shell. Here’s the function cleaning a few email addresses:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微测试一下。将我们的clean函数代码输入到Python Shell中。这里是该函数清理几个电子邮件地址的例子：
- en: '>>> clean(''daniel.zingaro+book@gmail.com'')'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> clean(''daniel.zingaro+book@gmail.com'')'
- en: '''danielzingaro@gmail.com'''
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '''danielzingaro@gmail.com'''
- en: '>>> clean(''da.nielz.in.gar.o..@gmail.com'')'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> clean(''da.nielz.in.gar.o..@gmail.com'')'
- en: '''danielzingaro@gmail.com'''
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '''danielzingaro@gmail.com'''
- en: '>>> clean(''DAnIELZIngARO+Flurry@gmAIL.COM'')'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> clean(''DAnIELZIngARO+Flurry@gmAIL.COM'')'
- en: '''danielzingaro@gmail.com'''
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '''danielzingaro@gmail.com'''
- en: '>>> clean(''a.b.c@d.e.f'')'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> clean(''a.b.c@d.e.f'')'
- en: '''abc@d.e.f'''
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '''abc@d.e.f'''
- en: 'If the email address is already clean, clean returns it as is:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果电子邮件地址已经是干净的，clean函数会直接返回它：
- en: '>>> clean(''danielzingaro@gmail.com'')'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> clean(''danielzingaro@gmail.com'')'
- en: '''danielzingaro@gmail.com'''
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '''danielzingaro@gmail.com'''
- en: The Main Program
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 主程序
- en: We can use our clean function to clean any email address. The strategy now is
    to maintain a list of clean email addresses. We will add a cleaned email address
    to this list only if it hasn’t been added already. In that way, we’ll avoid adding
    duplicates of the same clean email address.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用我们的clean函数来清理任何电子邮件地址。现在的策略是维护一个清理过的电子邮件地址列表。只有在该清理后的电子邮件地址尚未添加时，我们才会将其加入此列表。通过这种方式，我们可以避免添加重复的清理过的电子邮件地址。
- en: The main part of our program is in [Listing 8-2](ch08.xhtml#ch08ex02). Be sure
    to enter our clean function ([Listing 8-1](ch08.xhtml#ch08ex01)) before this code
    for a complete solution to the problem.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们程序的主要部分在[清单8-2](ch08.xhtml#ch08ex02)中。请确保在这段代码之前输入我们的clean函数代码（[清单8-1](ch08.xhtml#ch08ex01)），这样可以完整解决问题。
- en: Main Program
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主程序
- en: 'for dataset in range(10):'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 'for dataset in range(10):'
- en: n = int(input())
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: n = int(input())
- en: ❶ addresses = []
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ addresses = []
- en: 'for i in range(n):'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(n):'
- en: address = input()
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: address = input()
- en: address = clean(address)
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: address = clean(address)
- en: '❷ if not address in addresses:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '❷ if not address in addresses:'
- en: addresses.append(address)
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: addresses.append(address)
- en: ❸ print(len(addresses))
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ print(len(addresses))
- en: '*Listing 8-2: Main program, using a list*'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单8-2：主程序，使用列表*'
- en: We have 10 test cases to process, so we surround the rest of the program with
    a range for loop that loops 10 times.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有10个测试用例需要处理，因此我们将程序的其余部分用一个循环包围，循环执行10次。
- en: For each test case, we read the number of email addresses and start with an
    empty list of clean email addresses ❶.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个测试用例，我们读取电子邮件地址的数量，并从一个空的干净电子邮件地址列表开始❶。
- en: We then use an inner range for loop to loop through each email address. We read
    each email address and clean it. Then, if we haven’t seen this clean email address
    before ❷, we add it to our list of clean email addresses.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用一个内部的循环遍历每个电子邮件地址。我们读取每个电子邮件地址并进行清理。然后，如果我们之前没有见过这个干净的电子邮件地址❷，我们就将它添加到我们的干净电子邮件地址列表中。
- en: When the inner loop finishes, we’ll have built up a list of all clean email
    addresses. There are no duplicates in that list. The number of unique email addresses,
    then, is the length of this list, so that’s what we output ❸.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当内部循环结束时，我们将构建出一个包含所有干净电子邮件地址的列表。该列表中没有重复项。那么，唯一电子邮件地址的数量就是该列表的长度，因此我们将输出这个结果❸。
- en: Not bad, eh? Almost like we could have solved this problem after we learned
    functions in [Chapter 6](ch06.xhtml#ch06). Or, really, after we learned lists
    in [Chapter 5](ch05.xhtml#ch05).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 不错吧？几乎就像我们在学习了[第6章](ch06.xhtml#ch06)的函数后就可以解决这个问题。或者，实际上，在我们学习了[第5章](ch05.xhtml#ch05)的列表后也能解决。
- en: Almost, but not quite. Because if you submit to the judge, you should notice
    that things don’t go according to plan.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 差一点，但还是不完全对。因为如果你提交给评测系统，你应该会注意到事情并没有按计划进行。
- en: The first sign of trouble is that the judge takes a while to show us our results.
    For example, I just waited one minute here for my results to show up. Compare
    that to the other problems we solved earlier, where we received feedback very
    quickly.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 问题的第一个迹象是，评测系统显示结果需要一些时间。例如，我在这里等待了1分钟才看到我的结果。对比我们之前解决的其他问题，反馈速度非常快。
- en: The second sign of trouble is that when our results do show up, we’re not awarded
    full points for this problem! I’m being given 3.25 points out of 5\. You may receive
    a little more or a little less, but you shouldn’t receive the full 5 points.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 问题的第二个迹象是，当结果显示出来时，我们并没有获得该问题的满分！我得到了5分中的3.25分。你可能会得到稍多或稍少的分数，但不应该得到满分5分。
- en: The reason we’re losing points is not because our program is wrong. Our program
    is fine. No matter the test case, it will output the correct number of unique
    email addresses.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们失去分数的原因不是因为程序有错误。我们的程序是正确的。无论测试用例如何，它都会输出正确的唯一电子邮件地址数量。
- en: So if our program is correct, what’s the problem?
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果我们的程序是正确的，问题出在哪里呢？
- en: The problem is that our program is too slow. The judge lets us know this by
    putting TLE at the start of each test case. TLE stands for time limit exceeded.
    For this problem, the judge has allocated 30 seconds to each batch of 10 test
    cases. If our program takes longer than 30 seconds, the judge terminates our program,
    and the remaining test cases in the batch are not allowed to run.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是我们的程序太慢了。评测系统通过在每个测试用例前标记TLE来告诉我们这一点。TLE代表“超时”（Time Limit Exceeded）。对于这个问题，评测系统为每批10个测试用例分配了30秒时间。如果我们的程序花费的时间超过30秒，评测系统会终止程序，并且该批次中剩余的测试用例将不再运行。
- en: This may be the first time limit exceeded error you’ve received, though it’s
    possible you’ve seen them as you completed exercises from previous chapters.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是你收到的第一次超时错误，尽管你可能在完成前面的章节练习时也曾遇到过。
- en: The first thing to check when you receive this error is whether your program
    is getting stuck in an infinite loop. If it is, then it’ll never finish, no matter
    the time limit. The judge terminates the program when the allotted time expires.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 收到这个错误时，首先要检查的是你的程序是否陷入了无限循环。如果是的话，程序将永远不会结束，不管时间限制如何。当分配的时间到期时，评测系统会终止程序。
- en: If there’s no infinite loop, then the likely culprit is the *efficiency* of
    our program itself. When programmers talk about efficiency, they’re referring
    to how long it takes the program to run. A program that runs faster (takes less
    time) is more efficient than a program that runs slower (takes more time). To
    solve the test cases within the time limit, we’re going to make our program more
    efficient.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有无限循环，那么问题的可能原因就是我们程序的*效率*。当程序员谈论效率时，他们指的是程序运行的时间。运行更快（花费更少时间）的程序比运行更慢（花费更多时间）的程序更高效。为了在时间限制内解决测试用例，我们需要提高程序的效率。
- en: Efficiency of Searching a List
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 搜索列表的效率
- en: Appending to a Python list is extremely fast. It doesn’t matter whether the
    list has only a few values or many thousands; appending takes the same small amount
    of time.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 向 Python 列表中添加元素非常快速。无论列表中只有几个值，还是有成千上万个值，追加操作所花费的时间几乎是一样的。
- en: Using the in operator, however, is a different story. Our program uses the in
    operator to determine whether a clean email address is already in our list of
    clean email addresses. A test case might have as many as 100,000 email addresses.
    In the worst case, then, our program could use in 100,000 times. It turns out
    that in is very slow when used on a list with many values, and this ends up hurting
    our program’s efficiency. To determine whether a value is in the list, in searches
    the list from beginning to end, list value by list value. It does that until it
    finds the value it’s looking for, or it runs out of list values to check. The
    more values that in has to look through, the slower it is.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用 `in` 操作符是另一回事。我们的程序使用 `in` 操作符来判断一个干净的电子邮件地址是否已经在我们清洁的电子邮件地址列表中。一个测试用例可能有多达
    100,000 个电子邮件地址。那么，在最坏的情况下，我们的程序可能会使用 `in` 操作符查找 100,000 次。事实证明，当在一个包含大量值的列表上使用
    `in` 时，它非常慢，这最终会影响程序的效率。为了确定一个值是否在列表中，`in` 会从头到尾逐个检查列表中的每个值。它会一直这样查找，直到找到所需的值，或者没有值可以继续检查。`in`
    需要查找的值越多，它的速度就越慢。
- en: Let’s get a feel for the way that in slows down as the length of a list increases.
    We’ll use a function that takes a list and a value and uses in to search the list
    for the value. It searches for the value 50,000 times; if we searched only once,
    it would be too fast for us to be able to see what’s going on.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们感受一下随着列表长度增加，`in` 操作符的速度是如何变慢的。我们将使用一个函数，该函数接受一个列表和一个值，并使用 `in` 操作符在列表中查找该值。它会查找
    50,000 次；如果我们只查找一次，那就太快了，我们无法看到发生了什么。
- en: The function is in [Listing 8-3](ch08.xhtml#ch08ex03). Enter its code into the
    Python shell.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数位于 [列表 8-3](ch08.xhtml#ch08ex03)。将它的代码输入到 Python shell 中。
- en: 'def search(collection, value):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 'def search(collection, value):'
- en: '"""'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: search many times for value in collection.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在集合中多次搜索值。
- en: '"""'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: 'for i in range(50000):'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(50000):'
- en: found = value in collection
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: found = value in collection
- en: '*Listing 8-3: Searching a collection many times*'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-3：多次搜索集合中的值*'
- en: Let’s create a list of the integers from 1 to 5,000 and search for 5000. By
    searching for the rightmost value in the list, we make in take as much time as
    possible on that list. Don’t worry that we’re exploring this using a list of integers
    rather than a list of email addresses. The efficiency will be similar, and numbers
    are so much easier to generate than email addresses!
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个包含 1 到 5,000 的整数列表，并搜索 5000。通过搜索列表中的最右侧值，我们让 `in` 操作符在这个列表上尽可能花费时间。不要担心我们用整数列表而不是电子邮件地址列表来探索这个问题。效率是类似的，而且数字比电子邮件地址要容易生成得多！
- en: 'Here goes:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 开始：
- en: '>>> search(list(range(1, 5001)), 5000)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> search(list(range(1, 5001)), 5000)'
- en: On my laptop, this takes about three seconds to run. We don’t need precise timing
    here; we’re just looking for a general picture of what happens as we increase
    the length of the list.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的笔记本上，这大约需要 3 秒钟。我们不需要精确的时间，只是想大致了解随着列表长度增加，发生了什么。
- en: 'Now let’s create a list of the integers from 1 to 10,000 and search for 10000:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个包含 1 到 10,000 的整数列表，并搜索 10000：
- en: '>>> search(list(range(1, 10001)), 10000)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> search(list(range(1, 10001)), 10000)'
- en: On my laptop, that takes about six seconds. As a summary so far, for a list
    of length 5000, it takes three seconds; double the list length to 10000, and the
    time doubles, too, to six seconds.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的笔记本上，这大约花了 6 秒。到目前为止的总结是，对于一个长度为 5000 的列表，花费了 3 秒钟；将列表长度加倍到 10000，所花时间也加倍，变成了
    6 秒。
- en: 'A list of length 20000? Give it a try:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 长度为 20000 的列表？试试看：
- en: '>>> search(list(range(1, 20001)), 20000)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> search(list(range(1, 20001)), 20000)'
- en: This takes about 12 seconds on my laptop.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这在我的笔记本上大约花了 12 秒。
- en: 'The time has doubled again. Try it on a list of length 50000. You’ll be waiting
    a while. I just ran this on my laptop:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 时间再次翻倍了。试试在一个长度为 50,000 的列表上。你会等上一段时间。我刚刚在我的笔记本上运行了这个：
- en: '>>> search(list(range(1, 50001)), 50000)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> search(list(range(1, 50001)), 50000)'
- en: It took just over 30 seconds. Remember that our search function is searching
    the list 50,000 times. So, it’s taking 30 seconds to search a list of length 50000
    a total of 50,000 times.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这花了 30 多秒。记住，我们的搜索函数会查找列表 50,000 次。所以，它花了 30 秒钟在一个长度为 50,000 的列表上总共查找 50,000
    次。
- en: We could have a test case that requires this much searching. For example, suppose
    we add 100,000 unique email addresses to our list, one at a time. Halfway through,
    we’ll have a list of 50,000 values; from then on, the remaining 50,000 uses of
    in will be on a list of at least 50,000 values.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能有一个需要如此多查找的测试案例。例如，假设我们每次都向列表中添加 100,000 个唯一的电子邮件地址。如果我们添加到一半，列表就会有 50,000
    个值；从那时起，剩下的 50,000 次查找都会发生在至少包含 50,000 个值的列表中。
- en: And that’s only for one of the 10 test cases! We need to get through all 10
    test cases within a total of 30 seconds. If one test case can take about 30 seconds
    on its own, we have no chance.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这仅仅是 10 个测试案例中的一个！我们需要在 30 秒内完成所有 10 个测试案例。如果一个测试案例就需要大约 30 秒，我们就没有机会了。
- en: Searching a list is just too slow. The Python list is the wrong type to use.
    We need a type better suited to the job. We need a Python set. You’re not going
    to believe how fast it is to search a set.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 查找列表的速度实在是太慢了。Python 列表类型不适合用来做这个。我们需要一个更适合此任务的类型。我们需要 Python 集合。你简直不敢相信，查找集合是多么迅速。
- en: Sets
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集合
- en: A *set* is a Python type that stores a collection of values, where repeated
    values are not allowed. We use opening and closing curly brackets to delimit the
    set.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*集合* 是 Python 中一种存储值集合的类型，其中不允许有重复值。我们使用开闭大括号来定义集合。'
- en: 'Unlike a list, a set might not maintain the values in the order you specify.
    Here’s a set of integers:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 与列表不同，集合可能不会保持你指定的值的顺序。以下是一个整数集合：
- en: '>>> {13, 15, 30, 45, 61}'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> {13, 15, 30, 45, 61}'
- en: '{45, 13, 15, 61, 30}'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '{45, 13, 15, 61, 30}'
- en: Notice that Python jumbled the order of the values. You may see the values in
    a different order on your computer. The important point is that you cannot rely
    on any particular order of the values. If order matters to you, a set is not the
    type to use.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 Python 打乱了值的顺序。你可能在你的电脑上看到不同的顺序。关键点是，你不能依赖于任何特定的顺序。如果顺序对你很重要，集合就不是你该使用的类型。
- en: 'If we try to include multiple occurrences of a value, only one occurrence is
    retained:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试包含多个相同的值，只有一个会被保留：
- en: '>>> {1, 1, 3, 2, 3, 1, 3, 3, 3}'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> {1, 1, 3, 2, 3, 1, 3, 3, 3}'
- en: '{1, 2, 3}'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '{1, 2, 3}'
- en: 'Sets are equal if they contain exactly the same values, even if we write them
    in different orders:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个集合包含完全相同的值，即使我们以不同的顺序写它们，它们也是相等的：
- en: '>>> {1, 2, 3} == {1, 2, 3}'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> {1, 2, 3} == {1, 2, 3}'
- en: 'True'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 'True'
- en: '>>> {1, 1, 3, 2, 3, 1, 3, 3, 3} == {1, 2, 3}'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> {1, 1, 3, 2, 3, 1, 3, 3, 3} == {1, 2, 3}'
- en: 'True'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 'True'
- en: '>>> {1, 2} == {1, 2, 3}'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> {1, 2} == {1, 2, 3}'
- en: 'False'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 'False'
- en: 'We can create a set of strings, like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这样创建一个字符串集合：
- en: '>>> {''abc@d.e.f'', ''danielzingaro@gmail.com''}'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> {''abc@d.e.f'', ''danielzingaro@gmail.com''}'
- en: '{''abc@d.e.f'', ''danielzingaro@gmail.com''}'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '{''abc@d.e.f'', ''danielzingaro@gmail.com''}'
- en: 'We cannot create a set of lists:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能创建一个包含列表的集合：
- en: '>>> {[1, 2], [3, 4]}'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> {[1, 2], [3, 4]}'
- en: 'Traceback (most recent call last):'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 回溯（最近的调用最后）：
- en: File "<stdin>", line 1, in <module>
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 "<stdin>"，第 1 行，在 <module> 中
- en: 'TypeError: unhashable type: ''list'''
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 'TypeError: 无法哈希的类型: ''list'''
- en: Values in a set must be immutable, which explains why we can’t put lists inside
    a set. The restriction has to do with how Python searches a set for a value. When
    Python adds a value to a set, it uses the value itself to determine where exactly
    it gets stored. Later, Python can find this value by looking in the place where
    it should be located. If a value in the set could change, then Python might look
    in the wrong place, failing to find the value.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 集合中的值必须是不可变的，这解释了为什么我们不能将列表放入集合中。这个限制与 Python 如何在集合中查找值有关。当 Python 向集合添加一个值时，它会使用该值本身来确定存储的位置。之后，Python
    可以通过查看该值应该存放的位置来找到这个值。如果集合中的值可能会改变，那么 Python 可能会在错误的位置查找，导致找不到这个值。
- en: 'While we can’t create a set of lists, there’s no problem with a list of sets:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们不能创建一个包含列表的集合，但创建一个包含集合的列表是没有问题的：
- en: '>>> lst = [{1, 2, 3}, {4, 5, 6}]'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> lst = [{1, 2, 3}, {4, 5, 6}]'
- en: '>>> lst'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> lst'
- en: '[{1, 2, 3}, {4, 5, 6}]'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '[{1, 2, 3}, {4, 5, 6}]'
- en: '>>> len(lst)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> len(lst)'
- en: '2'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '>>> lst[0]'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> lst[0]'
- en: '{1, 2, 3}'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '{1, 2, 3}'
- en: 'You can use the len function to determine the number of values in a set:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 len 函数来确定集合中值的数量：
- en: '>>> len({2, 4, 6, 8})'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> len({2, 4, 6, 8})'
- en: '4'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: 'You can also loop over the values in a set:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以遍历集合中的值：
- en: '>>> for value in {2, 4, 6, 8}:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> for value in {2, 4, 6, 8}:'
- en: '...     print(''I found'', value)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '...     print(''I found'', value)'
- en: '...'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: I found 8
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我找到了 8
- en: I found 2
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我找到了 2
- en: I found 4
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我找到了 4
- en: I found 6
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我找到了 6
- en: You can’t index or slice a set, though. Values in a set don’t have indices.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，你不能对集合进行索引或切片操作。集合中的值没有索引。
- en: 'To create an empty set, you might expect to use an empty pair of curly brackets,
    {}. In an inconsistency of Python syntax, that doesn’t work:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个空集合，你可能会想使用一对空的大括号，即 {}。但由于 Python 语法的不一致性，这样做不起作用：
- en: '>>> type({2, 4, 6, 8})'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> type({2, 4, 6, 8})'
- en: <class 'set'>
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: <class 'set'>
- en: '>>> {}'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> {}'
- en: '{}'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '{}'
- en: '>>> type({})'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> type({})'
- en: <class 'dict'>
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: <class 'dict'>
- en: 'Using {} gives us the wrong type: a dict (dictionary) instead of a set. We’ll
    talk about dictionaries later in this chapter.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 {} 给我们带来了错误的类型：字典（dict），而不是集合。我们稍后将在本章讨论字典。
- en: 'To make an empty set, we use set(), like this:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个空集合，我们使用 set()，像这样：
- en: '>>> set()'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> set()'
- en: set()
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: set()
- en: '>>> type(set())'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> type(set())'
- en: <class 'set'>
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: <class 'set'>
- en: Set Methods
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集合方法
- en: Sets are mutable, so we can add and remove values. We can perform these tasks
    by using methods.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是可变的，因此我们可以添加和移除值。我们可以使用方法执行这些任务。
- en: You can get a list of set methods by using dir(set()). And you can get help
    on a specific set method by using help, similar to how we use help to learn about
    string or list methods. For example, to learn about the add method, type help(set().add).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 dir(set()) 获取集合方法的列表。你还可以通过使用 help 获取关于特定集合方法的帮助，方法类似于我们获取字符串或列表方法帮助的方式。例如，要了解
    add 方法，可以输入 help(set().add)。
- en: 'The add method is what we use to add a value to a set. It’s the analog of append
    on lists:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: add 方法是用来向集合中添加一个值的。它类似于列表中的 append：
- en: '>>> s = set()'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s = set()'
- en: '>>> s'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s'
- en: set()
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: set()
- en: '>>> s.add(2)'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s.add(2)'
- en: '>>> s'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s'
- en: '{2}'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '{2}'
- en: '>>> s.add(4)'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s.add(4)'
- en: '>>> s'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s'
- en: '{2, 4}'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '{2, 4}'
- en: '>>> s.add(6)'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s.add(6)'
- en: '>>> s'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s'
- en: '{2, 4, 6}'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '{2, 4, 6}'
- en: '>>> s.add(8)'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s.add(8)'
- en: '>>> s'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s'
- en: '{8, 2, 4, 6}'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '{8, 2, 4, 6}'
- en: '>>> s.add(8)'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s.add(8)'
- en: '>>> s'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s'
- en: '{8, 2, 4, 6}'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '{8, 2, 4, 6}'
- en: 'To remove a value, we use the remove method:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 要移除一个值，我们使用 remove 方法：
- en: '>>> s.remove(4)'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s.remove(4)'
- en: '>>> s'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s'
- en: '{8, 2, 6}'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '{8, 2, 6}'
- en: '>>> s.remove(8)'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s.remove(8)'
- en: '>>> s'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s'
- en: '{2, 6}'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '{2, 6}'
- en: '>>> s = {2, 6}'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s = {2, 6}'
- en: '>>> s.remove(8)'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s.remove(8)'
- en: 'Traceback (most recent call last):'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 'Traceback (most recent call last):'
- en: File "<stdin>", line 1, in <module>
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 "<stdin>"，第 1 行，在 <module>
- en: 'KeyError: 8'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 'KeyError: 8'
- en: '**CONCEPT CHECK**'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念检查**'
- en: Use help to learn about the set update and intersection methods.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 help 来了解集合的 update 和 intersection 方法。
- en: What is output by the call of print in the following code?
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码的 print 调用会输出什么？
- en: s1 = {1, 3, 5, 7, 9}
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: s1 = {1, 3, 5, 7, 9}
- en: s2 = {1, 2, 4, 6, 8, 10}
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: s2 = {1, 2, 4, 6, 8, 10}
- en: s3 = {1, 4, 9, 16, 25}
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: s3 = {1, 4, 9, 16, 25}
- en: s1.update(s2)
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: s1.update(s2)
- en: s1.intersection(s3)
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: s1.intersection(s3)
- en: print(s1)
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: print(s1)
- en: A. {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: A. {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
- en: B. {1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: B. {1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
- en: C. {1, 4, 9}
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: C. {1, 4, 9}
- en: D. {1, 4, 9, 16, 25}
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: D. {1, 4, 9, 16, 25}
- en: E. {1}
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: E. {1}
- en: 'Answer: A. The update method adds whatever is in set s2 but is missing from
    set s1 to set s1. After the call of update, s1 is the set {1, 2, 3, 4, 5, 6, 7,
    8, 9, 10}.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：A。update 方法将集合 s2 中缺失的内容添加到集合 s1 中。调用 update 后，s1 就变成了集合 {1, 2, 3, 4, 5,
    6, 7, 8, 9, 10}。
- en: Now for the call of intersection. The intersection of two sets is the set consisting
    of the values that are in both sets. Here, the intersection of s1 and s3 is {1,
    4, 9}. However, the intersection method *does not* modify a set; rather, it produces
    a new set! For that reason, it has no effect on s1.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来看交集的调用。两个集合的交集是由两个集合中都包含的值组成的集合。这里，s1 和 s3 的交集是 {1, 4, 9}。然而，交集方法*不会*修改集合；它会生成一个新的集合！因此，它对
    s1 没有影响。
- en: Efficiency of Searching a Set
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 搜索集合的效率
- en: Back to solving Email Addresses.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 回到解决电子邮件地址的问题。
- en: Do we care about the order of our cleaned email addresses? No! All we care about
    is whether an email address is already in there or not.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在清理后的电子邮件地址中关心顺序吗？不！我们关心的只是电子邮件地址是否已经存在。
- en: Do we need to allow duplicates in our cleaned email addresses? No again! In
    fact, we want to explicitly avoid storing duplicate email addresses.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是否需要在清理后的电子邮件地址中允许重复项？再次不需要！事实上，我们希望明确避免存储重复的电子邮件地址。
- en: Order doesn’t matter, and duplicates are not allowed. These are the two ingredients
    that suggest that a set may be the right type to use.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 顺序不重要，且不允许重复项。这是建议使用集合作为合适类型的两个要素。
- en: We were foiled in our attempt to use a list because searching a list is too
    slow. A set is going to be an improvement for us because we can search a set faster
    than we can search a list.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在尝试使用列表时遇到障碍，因为搜索列表的速度太慢。使用集合会对我们有所改善，因为我们可以比搜索列表更快地搜索集合。
- en: We’ve already used the search function in [Listing 8-3](ch08.xhtml#ch08ex03)
    to search a list. But that function doesn’t do anything that specifically requires
    a list! It uses the in operator, and in works on both lists and sets. So we can
    use that function, unchanged, to search a set, too.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用 [Listing 8-3](ch08.xhtml#ch08ex03) 中的搜索函数搜索过列表。但这个函数并不特定需要列表！它使用 in 运算符，而
    in 运算符可以在列表和集合中使用。所以我们可以直接使用这个函数来搜索集合。
- en: 'Enter the search function from [Listing 8-3](ch08.xhtml#ch08ex03) into the
    Python shell. Follow along on your computer to get a sense of the difference between
    searching a long list and a big set:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 从[列表8-3](ch08.xhtml#ch08ex03)中的搜索功能进入Python shell。在你的电脑上跟着做，体验一下在长列表和大集合中搜索的区别：
- en: '>>> search(list(range(1, 50001)), 50000)'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> search(list(range(1, 50001)), 50000)'
- en: ❶ >>> search(set(range(1, 50001)), 50000)
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ >>> search(set(range(1, 50001)), 50000)
- en: At ❶, I’ve used set to produce a set, not a list, of the integers from the range.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在❶处，我使用set来生成一个整数集合，而不是列表。
- en: On my laptop, searching the list takes about 30 seconds. Searching the set,
    by comparison, is bullet fast, almost instantaneous.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的笔记本电脑上，搜索列表大约需要30秒。而搜索集合则非常快速，几乎是瞬间完成。
- en: 'Sets are unstoppable. Don’t try this on a list, but here we go, searching for
    something in a set of 500,000 values:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是不可阻挡的。不要在列表上尝试这个，但我们来试试，在一个50万个元素的集合中搜索：
- en: '>>> search(set(range(1, 500001)), 500000)'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> search(set(range(1, 500001)), 500000)'
- en: Boom! Piece of cake.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！轻松搞定。
- en: 'Python manages a list in such a way as to allow us to use any index at any
    time. Python has no flexibility to mess around with the order of values: the first
    value has to be at index 0, the second at index 1, and so on. But for a set, Python
    can store it in whatever way it wants, because it makes no promises of keeping
    things in order for us. And it’s that increased latitude that allows Python to
    optimize searches in a set for speed.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: Python管理列表的方式使我们可以随时使用任何索引。Python不能随意改变值的顺序：第一个值必须在索引0，第二个值在索引1，以此类推。但是对于集合，Python可以以它想要的任何方式存储它，因为它不承诺为我们保持顺序。而正是这种增加的灵活性使得Python能够在集合中优化搜索的速度。
- en: 'For similar reasons, there are other operations that are extremely slow on
    large lists but extremely fast on large sets. For example, removing a value from
    a list is very slow, because Python must decrease the index of each value that’s
    to the right of that value. By contrast, removing a value from a set is very fast:
    there are no indices to update!'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 出于类似的原因，一些在大列表上非常慢的操作，在大集合上却非常快。例如，从列表中删除一个值非常慢，因为Python必须调整该值右边每个值的索引。相比之下，从集合中删除一个值非常快：因为没有需要更新的索引！
- en: Solving the Problem
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决问题
- en: We already have a function to clean an email address ([Listing 8-1](ch08.xhtml#ch08ex01)),
    and we’ll use it in our set-based solution. As for the main program, [Listing
    8-2](ch08.xhtml#ch08ex02) gets us most of the way there. We just need to use a
    set instead of a list.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有一个函数来清理电子邮件地址（[列表8-1](ch08.xhtml#ch08ex01)），我们将在集合解决方案中使用它。至于主程序，[列表8-2](ch08.xhtml#ch08ex02)已经为我们提供了大部分解决方案。我们只需要用集合代替列表。
- en: The new main program is in [Listing 8-4](ch08.xhtml#ch08ex04). Include [Listing
    8-1](ch08.xhtml#ch08ex01) before this code for a complete solution to the problem.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 新的主程序在[列表8-4](ch08.xhtml#ch08ex04)中。要完整解决这个问题，请在这段代码前包含[列表8-1](ch08.xhtml#ch08ex01)。
- en: Main Program
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主程序
- en: 'for dataset in range(10):'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 'for dataset in range(10):'
- en: n = int(input())
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: n = int(input())
- en: ❶ addresses = set()
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ addresses = set()
- en: 'for i in range(n):'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(n):'
- en: address = input()
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: address = input()
- en: address = clean(address)
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: address = clean(address)
- en: ❷ addresses.add(address)
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ addresses.add(address)
- en: print(len(addresses))
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: print(len(addresses))
- en: '*Listing 8-4: Main program, using a set*'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表8-4：主程序，使用集合*'
- en: Notice that we’re now using a set ❶ of email addresses rather than a list. After
    cleaning each email address, we add it to the set using the set add method ❷.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们现在使用的是一个电子邮件地址的集合❶，而不是列表。清理每个电子邮件地址后，我们通过集合的add方法❷将其添加到集合中。
- en: In [Listing 8-2](ch08.xhtml#ch08ex02), we used the in operator to check whether
    an email address is already in the list so that we didn’t add duplicates. There’s
    no corresponding in check in our set-based solution. Where did it go? It seems
    that we’re adding each email address to the set without even making sure that
    it’s not already there.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表8-2](ch08.xhtml#ch08ex02)中，我们使用了in操作符来检查一个电子邮件地址是否已经在列表中，以防止添加重复项。在我们的集合解决方案中，没有相应的in检查。那它去哪儿了？似乎我们在将每个电子邮件地址添加到集合时，并没有确保它还不在集合中。
- en: We can get away without the in check when using a set because a set never contains
    duplicates. The add method handles the in check for us, ensuring that a duplicate
    doesn’t get added. You can think of add carrying out its own in check. There’s
    no timing concern there, because searching a set is so fast.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 使用集合时，我们可以省略in检查，因为集合永远不会包含重复项。add方法会为我们处理in检查，确保不会添加重复项。你可以认为add方法在执行自己的in检查。这里没有时间上的顾虑，因为搜索集合非常快速。
- en: If you submit this solution to the judge, you should pass all of the test cases
    well within the time limit.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将这个解法提交给评审，你应该能在时间限制内顺利通过所有测试用例。
- en: As you’ve seen here, choosing the appropriate Python type can mean the difference
    between an unsatisfactory solution and a satisfactory one. Before you start writing
    code, ask yourself which operations you’ll be frequently performing and which
    Python type is ideally suited to those operations.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在这里看到的，选择合适的 Python 类型可能意味着解决方案是满意的，还是不满意的。在你开始写代码之前，问问自己哪些操作你会频繁执行，哪些 Python
    类型最适合这些操作。
- en: Before continuing, you might like to try solving exercises 1 and 2 from “Chapter
    Exercises” on [page 236](ch08.xhtml#ch08lev1sec19).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，你可能想尝试解决“章节练习”中的第 1 题和第 2 题，详情见 [第 236 页](ch08.xhtml#ch08lev1sec19)。
- en: 'Problem #19: Common Words'
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '问题 #19: 常见单词'
- en: In this problem, we’ll need to associate words with their number of occurrences.
    This is beyond what we can do with sets, so we won’t use sets here. Instead, we’ll
    learn about and use Python dictionaries.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个问题中，我们需要将单词与它们出现的次数关联起来。由于集合无法完成这一任务，所以我们不使用集合。相反，我们将学习并使用 Python 字典。
- en: This is DMOJ problem cco99p2.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 DMOJ 问题 cco99p2。
- en: The Challenge
  id: totrans-276
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战
- en: We are given *m* words. The words are not necessarily distinct; for example,
    the word brook could appear multiple times. We are also given an integer *k*.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们给定 *m* 个单词。这些单词不一定是不同的；例如，单词 brook 可能出现多次。我们还给定一个整数 *k*。
- en: Our task is to find the *k*th most common words. A word *w* is a *k*th most
    common word if exactly *k* – 1 distinct words occur more often than does *w*.
    Depending on the dataset, the *k*th most common words could be no words, one word,
    or more than one word.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的任务是找出 *k*th 最常见的单词。一个单词 *w* 是 *k*th 最常见单词，当且仅当有恰好 *k* – 1 个不同的单词出现得比 *w*
    更频繁。根据数据集，*k*th 最常见的单词可能是没有单词、一个单词或多个单词。
- en: Let’s make sure we’re clear on this definition of the *k*th most common words.
    If *k* = 1, then we’re being asked for the words for which exactly 0 words occur
    more often; that is, we’re being asked for the words that occur most often. If
    *k* = 2, then we’re being asked for the words for which exactly 1 word occurs
    more often. If *k* = 3, then we’re being asked for the words for which exactly
    two distinct words occur more often, and so on.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们明确一下*k*th 最常见单词的定义。如果*k* = 1，那么我们要求的是恰好有 0 个单词出现得更频繁的单词，也就是说，我们要求的是出现最频繁的单词。如果*k*
    = 2，那么我们要求的是恰好有 1 个单词出现得更频繁的单词。如果*k* = 3，那么我们要求的是恰好有两个不同单词出现得更频繁的单词，以此类推。
- en: Input
  id: totrans-280
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输入
- en: 'The input contains a line giving the number of test cases, followed by the
    lines of the test cases themselves. Each test case contains the following lines:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 输入包含一行，给出测试用例的数量，后面是每个测试用例的行。每个测试用例包含以下几行：
- en: A line containing the integers *m* (the number of words in the test case) and
    *k* separated by a space. *m* is between 0 and 1,000; *k* is at least 1.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一行包含整数 *m*（测试用例中的单词数）和 *k*（查询的常见单词顺序），二者由空格分隔。*m* 的范围是 0 到 1000，*k* 至少为 1。
- en: '*m* lines, each of which gives a word. Each word consists of at most 20 characters,
    and all characters are lowercase.'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*m* 行，每行给出一个单词。每个单词最多由 20 个字符组成，且所有字符均为小写字母。'
- en: Output
  id: totrans-284
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输出
- en: 'For each test case, output the following lines:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个测试用例，输出以下内容：
- en: 'A line containing the following:'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一行包含以下内容：
- en: 'p most common word(s):'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第 p 个最常见单词：
- en: where p is 1st if *k* is 1, 2nd if *k* is 2, 3rd if *k* is 3, 4th if *k* is
    4, and so on.
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其中 p 是第 1 个，如果 *k* 是 1；第 2 个，如果 *k* 是 2；第 3 个，如果 *k* 是 3；第 4 个，如果 *k* 是 4，依此类推。
- en: One line for each of the *k*th most common words. If there are no such words,
    there are no lines of output here.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个 *k*th 最常见单词一行。如果没有这样的单词，则没有输出行。
- en: A blank line.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一行空白行。
- en: The time limit for solving the test cases is one second.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 解决测试用例的时间限制是 1 秒。
- en: Exploring a Test Case
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探索一个测试用例
- en: Let’s start by exploring a test case. It’ll boost our understanding of the problem
    and motivate the use of a new Python type.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个测试用例来开始。这将帮助我们更好地理解问题，并激励我们使用一种新的 Python 类型。
- en: 'Suppose that we’re interested in the most common words of all. This means that
    *k* is 1\. Here’s the test case:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们对所有单词中最常见的单词感兴趣。这意味着 *k* 是 1。这里是测试用例：
- en: '1'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: 14 1
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 14 1
- en: storm
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: storm
- en: cut
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: cut
- en: magma
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: magma
- en: cut
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: cut
- en: brook
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: brook
- en: gully
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: gully
- en: gully
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: gully
- en: storm
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: storm
- en: cliff
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: cliff
- en: cut
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: cut
- en: blast
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: blast
- en: brook
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: brook
- en: cut
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: cut
- en: gully
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: gully
- en: 'The word that shows up most often is cut. There are four occurrences of cut,
    and no other word has that many occurrences. The correct output is therefore:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 最常出现的单词是 cut。cut 出现了四次，没有其他单词出现这么多次。因此，正确的输出是：
- en: '1st most common word(s):'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个最常见的词：
- en: cut
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: cut
- en: ❶
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: ❶
- en: Notice the required blank line at the end ❶.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 注意末尾需要有一个空行 ❶。
- en: Now, what do we do if *k* were 2? We could answer this by scanning through the
    words again and counting occurrences, but there’s a different way to organize
    the words that would make our task considerably easier. Rather than a list of
    words, let’s look at each word associated with its number of occurrences. See
    [Table 8-1](ch08.xhtml#ch08tab01).
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果 *k* 为 2，我们该怎么办？我们可以通过再次扫描单词并统计出现次数来回答这个问题，但还有一种不同的方式来组织单词，这会让我们的任务变得更加轻松。与其列出单词，不如将每个单词与其出现次数关联起来。请参见[表
    8-1](ch08.xhtml#ch08tab01)。
- en: '**Table 8-1:** Words and Number of Occurrences'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 8-1：** 单词和出现次数'
- en: '| **Word** | **Number of occurrences** |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| **单词** | **出现次数** |'
- en: '| --- | --- |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| cut | 4 |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| cut | 4 |'
- en: '| gully | 3 |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| gully | 3 |'
- en: '| storm | 2 |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '| storm | 2 |'
- en: '| brook | 2 |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '| brook | 2 |'
- en: '| magma | 1 |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '| magma | 1 |'
- en: '| cliff | 1 |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
  zh: '| cliff | 1 |'
- en: '| blast | 1 |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '| blast | 1 |'
- en: I’ve sorted the words based on their number of occurrences. Looking at the top
    row, we can reaffirm that cut is the word to output for *k* = 1\. Looking at the
    second row, we see that gully is the word to output for *k* = 2\. The word gully
    is the only word that has exactly one word with more occurrences.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经根据单词的出现次数对它们进行了排序。查看第一行，我们可以确认 cut 是 *k* = 1 时要输出的单词。查看第二行，我们看到 gully 是 *k*
    = 2 时要输出的单词。gully 是唯一一个恰好有一个出现次数更多的单词。
- en: Now for *k* = 3\. This time, there are *two* words to output, storm and brook,
    because they both have the same number of occurrences. Each of these words has
    exactly two words with more occurrences. This shows that we sometimes need to
    output more than one word.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑 *k* = 3。这次，有 *两个* 单词需要输出，storm 和 brook，因为它们的出现次数相同。每个单词恰好有两个出现次数更多的单词。这表明我们有时需要输出多个单词。
- en: It’s also possible that we need to output zero words! For example, consider
    *k* = 4\. There are *no* words that have exactly three words with more occurrences.
    Looking down the table, you might wonder why we don’t output magma for *k* = 4\.
    We don’t output magma, because magma has exactly four words (not exactly three
    words) with more occurrences.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 也有可能我们需要输出零个单词！例如，考虑 *k* = 4。在这种情况下，没有单词的出现次数恰好有三个比它更多的单词。看一下表格，你可能会问为什么我们不输出
    magma 当 *k* = 4。我们不输出 magma，因为 magma 恰好有四个单词（而不是三个单词）出现次数更多。
- en: 'When *k* = 5, we have three words to output: magma, cliff, and blast. Before
    continuing, verify for yourself that there are no words to output for any other
    value of *k*—no words for *k* = 6, *k* = 7, *k* = 8, *k* = 9, *k* = 100, and so
    on.'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 当 *k* = 5 时，我们有三个单词需要输出：magma、cliff 和 blast。在继续之前，请自行验证，对于其他任何 *k* 的值，都没有单词需要输出——对于
    *k* = 6，*k* = 7，*k* = 8，*k* = 9，*k* = 100 等等，都没有单词。
- en: '[Table 8-1](ch08.xhtml#ch08tab01) simplifies the problem quite a bit for us.
    We’re now going to learn how to organize information like this in Python.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 8-1](ch08.xhtml#ch08tab01) 为我们简化了问题。接下来，我们将学习如何在 Python 中组织这样的信息。'
- en: Dictionaries
  id: totrans-332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字典
- en: A *dictionary* is a Python type that stores a mapping from one group of elements,
    called *keys*, to another group of elements, called *values*.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典* 是一种 Python 类型，用于存储从一组元素（称为 *键*）到另一组元素（称为 *值*）的映射。'
- en: We use opening and closing curly brackets to delimit the dictionary. Those are
    the same symbols that we use for a set, but Python can tell the difference between
    a set and a dictionary because of what we put inside the curly brackets. For a
    set, we list values; for a dictionary, we list key:value pairs.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用开括号和闭括号来限定字典。这些符号与我们用来表示集合的符号相同，但 Python 能够通过大括号中的内容区分集合和字典。对于集合，我们列出的是值；对于字典，我们列出的是键:值对。
- en: 'Here’s a dictionary mapping some strings to numbers:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个将一些字符串映射到数字的字典：
- en: '>>> {''cut'':4, ''gully'':3}'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> {''cut'':4, ''gully'':3}'
- en: '{''cut'': 4, ''gully'': 3}'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '{''cut'': 4, ''gully'': 3}'
- en: In this dictionary, the keys are 'cut' and 'gully', and the values are 4 and
    3. The key 'cut' is mapped to the value 4, and the key 'gully' is mapped to the
    value 3.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，键是 'cut' 和 'gully'，值分别是 4 和 3。键 'cut' 映射到值 4，键 'gully' 映射到值 3。
- en: 'Based on our encounters with sets, you might wonder whether dictionaries maintain
    the pairs in the order we enter them. For example, you might wonder whether this
    could happen:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 基于我们对集合的了解，你可能会想知道字典是否会按照我们输入的顺序来保持这些键值对。例如，你可能会想知道是否会发生以下情况：
- en: '>>> {''cut'':4, ''gully'':3}'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> {''cut'':4, ''gully'':3}'
- en: '{''gully'': 3, ''cut'': 4}'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '{''gully'': 3, ''cut'': 4}'
- en: 'As of Python 3.7, the answer is no: dictionaries retain the order in which
    you added pairs. In earlier versions of Python, dictionaries did not maintain
    this order, so you could add pairs in one order but get them back in another.
    It’s still a good idea to write code that doesn’t rely on the Python 3.7 behavior,
    though, because older versions of Python are likely to be in use for the foreseeable
    future.'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 从Python 3.7开始，答案是“否”：字典会保持你添加键值对的顺序。在Python的早期版本中，字典并不保留顺序，因此你可以按某种顺序添加键值对，但取出来时可能是另一个顺序。不过，编写不依赖于Python
    3.7行为的代码仍然是个好主意，因为未来仍有可能使用较旧版本的Python。
- en: 'Dictionaries are equal if they contain the same key:value pairs, even if we
    write them in different orders:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 字典如果包含相同的键值对，无论我们以何种顺序书写，都是相等的：
- en: '>>> {''cut'':4, ''gully'':3} == {''cut'':4, ''gully'':3}'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> {''cut'':4, ''gully'':3} == {''cut'':4, ''gully'':3}'
- en: 'True'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 真
- en: '>>> {''cut'':4, ''gully'':3} == {''gully'': 3, ''cut'': 4}'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> {''cut'':4, ''gully'':3} == {''gully'': 3, ''cut'': 4}'
- en: 'True'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 真
- en: '>>> {''cut'':4, ''gully'':3} == {''gully'': 3, ''cut'': 10}'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> {''cut'':4, ''gully'':3} == {''gully'': 3, ''cut'': 10}'
- en: 'False'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 假
- en: '>>> {''cut'':4, ''gully'':3} == {''cut'': 4}'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> {''cut'':4, ''gully'':3} == {''cut'': 4}'
- en: 'False'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 假
- en: 'Dictionary keys must be unique. If you try to include the same key multiple
    times, only one pair involving that key is retained:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 字典的键必须是唯一的。如果你尝试多次包含相同的键，那么只会保留一个涉及该键的键值对：
- en: '>>> {''storm'': 1, ''storm'': 2}'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> {''风暴'': 1, ''风暴'': 2}'
- en: '{''storm'': 2}'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '{''风暴'': 2}'
- en: 'Repeated values, by contrast, are fine:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，重复的值是可以的：
- en: '>>> {''storm'': 2, ''brook'': 2}'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> {''风暴'': 2, ''小溪'': 2}'
- en: '{''storm'': 2, ''brook'': 2}'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '{''风暴'': 2, ''小溪'': 2}'
- en: 'Keys are required to be immutable values, such as numbers and strings. Values
    can be immutable or mutable. This means that we can’t use a list as a key, but
    we can use a list as a value:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是不可变值，如数字和字符串。值可以是不可变的或可变的。这意味着我们不能使用列表作为键，但可以将列表作为值：
- en: '>>> {[''storm'', ''brook'']: 2}'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> {[''风暴'', ''小溪'']: 2}'
- en: 'Traceback (most recent call last):'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 回溯（最近一次调用最先发生）：
- en: File "<stdin>", line 1, in <module>
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 "<stdin>"，第1行，模块内：
- en: 'TypeError: unhashable type: ''list'''
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 'TypeError: 不可哈希的类型：''列表'''
- en: '>>> {2: [''storm'', ''brook'']}'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> {2: [''风暴'', ''小溪'']}'
- en: '{2: [''storm'', ''brook'']}'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '{2: [''风暴'', ''小溪'']}'
- en: 'The len function gives us the number of key:value pairs in a dictionary:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: len函数返回字典中键值对的数量：
- en: '>>> len({''cut'':4, ''gully'':3})'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> len({''cut'':4, ''gully'':3})'
- en: '2'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '>>> len({2: [''storm'', ''brook'']})'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> len({2: [''风暴'', ''小溪'']})'
- en: '1'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: 'To create an empty dictionary, we use {}. That’s why we’re stuck with that
    second-rate set() syntax to create a set—dictionaries got the nice syntax:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个空字典，我们使用{}。这也是为什么我们不得不使用那种二流的set()语法来创建集合——字典拥有更漂亮的语法：
- en: '>>> {}'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> {}'
- en: '{}'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '{}'
- en: '>>> type({})'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> type({})'
- en: <class 'dict'>
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: <class 'dict'>
- en: The type is called dict, not dictionary.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 类型叫做dict，而不是字典。
- en: You’ll see “dictionary” and “dict” used interchangeably in Python resources
    and code, but I’ll stick with “dictionary” in this book.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python的资源和代码中，你会看到“字典”和“dict”可以互换使用，但在本书中，我会坚持使用“字典”这个术语。
- en: '**CONCEPT CHECK**'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念检查**'
- en: Which of the following is best suited for a dictionary rather than a list or
    set?
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 以下哪项最适合用字典而不是列表或集合？
- en: A. The order in which people finish a race
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: A. 人们完成比赛的顺序
- en: B. The ingredients necessary for a recipe
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: B. 食谱所需的配料
- en: C. The names of countries and their capital cities
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: C. 各国及其首都的名称
- en: D. 50 random integers
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: D. 50个随机整数
- en: 'Answer: C. This is the only option that includes a mapping between keys and
    values. Here, the keys could be the countries, and the values could be their capital
    cities.'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：C。这是唯一一个包含键值映射的选项。这里，键可以是国家，值可以是它们的首都。
- en: '**CONCEPT CHECK**'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念检查**'
- en: What is the type of the values (ignoring the keys) in the following dictionary?
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 以下字典中，忽略键后，值的类型是什么？
- en: '{''MLB'': {''Bluejays'': [1992, 1993],'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '{''MLB'': {''蓝鸟'': [1992, 1993],'
- en: '''Orioles'': [1966, 1970, 1983]},'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '''金莺'': [1966, 1970, 1983]},'
- en: '''NFL'': {''Patriots'': [''too many'']}}'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '''NFL'': {''爱国者'': [''太多'']}}'
- en: A. Integer
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: A. 整数
- en: B. String
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: B. 字符串
- en: C. List
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: C. 列表
- en: D. Dictionary
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: D. 字典
- en: E. More than one of the above
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: E. 上述多个选项
- en: 'Answer: D. The value for each key in the dictionary is itself a dictionary.
    For example, the key ''MLB'' is mapped to a dictionary; that dictionary has two
    key:value pairs of its own.'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：D。字典中每个键的值本身就是一个字典。例如，键'MLB'映射到一个字典；该字典有两个键值对。
- en: Indexing Dictionaries
  id: totrans-395
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 索引字典
- en: 'We can use square brackets to look up the value that a key maps to. It’s similar
    to how we index a list, but with the keys serving as the valid “indices”:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用方括号查找一个键映射到的值。这类似于如何索引列表，不过是用键作为有效的“索引”：
- en: '>>> d = {''cut'':4, ''gully'':3}'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> d = {''cut'':4, ''gully'':3}'
- en: '>>> d'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> d'
- en: '{''cut'': 4, ''gully'': 3}'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '{''cut'': 4, ''gully'': 3}'
- en: '>>> d[''cut'']'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> d[''cut'']'
- en: '4'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: '>>> d[''gully'']'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> d[''gully'']'
- en: '3'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: 'It’s an error to use a key that doesn’t exist:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不存在的键是错误的：
- en: '>>> d[''storm'']'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> d[''storm'']'
- en: 'Traceback (most recent call last):'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 'Traceback (most recent call last):'
- en: File "<stdin>", line 1, in <module>
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: File "<stdin>", line 1, in <module>
- en: 'KeyError: ''storm'''
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 'KeyError: ''storm'''
- en: 'We can protect against that error by first using in to check whether a key
    is in the dictionary. When used on a dictionary, the in operator checks only the
    keys, not the values. Here’s how we can check that a key exists before trying
    to find its value:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过先使用 in 检查一个键是否在字典中来防止这个错误。当在字典上使用 in 操作符时，它只检查键，而不检查值。以下是如何在尝试查找键的值之前检查一个键是否存在：
- en: '>>> if ''cut'' in d:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> if ''cut'' in d:'
- en: '...     print(d[''cut''])'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '...     print(d[''cut''])'
- en: '...'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '4'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: '>>> if ''storm'' in d:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> if ''storm'' in d:'
- en: '...     print(d[''storm''])'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '...     print(d[''storm''])'
- en: '...'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: Indexing and using in on a dictionary are extremely fast operations. They don’t
    require searching any kind of list, no matter how many keys are in the dictionary.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 索引和使用 in 操作符对字典进行操作都是非常快速的操作。无论字典中有多少键，都不需要搜索任何列表。
- en: 'It’s sometimes more convenient to use the get method rather than indexing to
    look up the value for a key. The get method never produces an error, even if the
    key doesn’t exist:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 有时使用 get 方法比通过索引查找键的值更方便。即使键不存在，get 方法也永远不会产生错误：
- en: '>>> print(d.get(''cut''))'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> print(d.get(''cut''))'
- en: '4'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: '>>> print(d.get(''storm''))'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> print(d.get(''storm''))'
- en: None
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: None
- en: If the key exists, get returns its value. Otherwise, it returns None to signify
    that the key does not exist.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 如果键存在，get 会返回其值。否则，它返回 None，表示该键不存在。
- en: 'In addition to looking up the value for a key, we can use square brackets to
    add keys to a dictionary or change the value that a key maps to. Here’s some code
    that shows how to do each of these, starting with an empty dictionary:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 除了查找键的值，我们还可以使用方括号向字典添加键，或更改键所映射的值。以下是一些代码，展示如何做到这一点，从一个空字典开始：
- en: '>>> d = {}'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> d = {}'
- en: '>>> d[''gully''] = 1'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> d[''gully''] = 1'
- en: '>>> d'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> d'
- en: '{''gully'': 1}'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '{''gully'': 1}'
- en: '>>> d[''cut''] = 1'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> d[''cut''] = 1'
- en: '>>> d'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> d'
- en: '{''gully'': 1, ''cut'': 1}'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '{''gully'': 1, ''cut'': 1}'
- en: '>>> d[''cut''] = 4'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> d[''cut''] = 4'
- en: '>>> d'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> d'
- en: '{''gully'': 1, ''cut'': 4}'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '{''gully'': 1, ''cut'': 4}'
- en: '>>> d[''gully''] = d[''gully''] + 1'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> d[''gully''] = d[''gully''] + 1'
- en: '>>> d'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> d'
- en: '{''gully'': 2, ''cut'': 4}'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '{''gully'': 2, ''cut'': 4}'
- en: '>>> d[''gully''] = d[''gully''] + 1'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> d[''gully''] = d[''gully''] + 1'
- en: '>>> d'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> d'
- en: '{''gully'': 3, ''cut'': 4}'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '{''gully'': 3, ''cut'': 4}'
- en: '**CONCEPT CHECK**'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念检查**'
- en: Use help({}.get) to learn more about the dictionary get method.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 help({}.get) 来了解字典的 get 方法。
- en: What is the output of the following code?
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码的输出是什么？
- en: 'd = {3: 4}'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 'd = {3: 4}'
- en: d[5] = d.get(4, 8)
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: d[5] = d.get(4, 8)
- en: d[4] = d.get(3, 9)
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: d[4] = d.get(3, 9)
- en: print(d)
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: print(d)
- en: 'A. {3: 4, 5: 8, 4: 9}'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 'A. {3: 4, 5: 8, 4: 9}'
- en: 'B. {3: 4, 5: 8, 4: 4}'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 'B. {3: 4, 5: 8, 4: 4}'
- en: 'C. {3: 4, 5: 4, 4: 3}'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 'C. {3: 4, 5: 4, 4: 3}'
- en: D. Error caused by get
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: D. 由 get 引起的错误
- en: 'Answer: B. The first call of get returns 8, because key 4 does not exist in
    the dictionary. That line therefore adds key 5 with value 8.'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：B. 第一次调用 get 返回 8，因为键 4 在字典中不存在。该行因此添加了键 5 和值 8。
- en: 'The second call of get returns 4: key 3 is in the dictionary already, so the
    second parameter, 9, is ignored. That line therefore adds key 4 with value 4.'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次调用 get 返回 4：键 3 已经在字典中，因此第二个参数 9 被忽略。该行因此添加了键 4 和值 4。
- en: Looping Through Dictionaries
  id: totrans-454
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遍历字典
- en: 'If we use a for loop on a dictionary, we get the dictionary’s keys:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对字典使用 for 循环，得到的是字典的键：
- en: '>>> d = {''cut'': 4, ''gully'': 3, ''storm'': 2, ''brook'': 2}'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> d = {''cut'': 4, ''gully'': 3, ''storm'': 2, ''brook'': 2}'
- en: '>>> for word in d:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> for word in d:'
- en: '...     print(''a key is'', word)'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '...     print(''a key is'', word)'
- en: '...'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: a key is cut
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 一个键被切割
- en: a key is gully
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 一个键是 gully
- en: a key is storm
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 一个键是 storm
- en: a key is brook
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 一个键是 brook
- en: 'We might also want to access the value associated with each key, and we can
    do that by using each key as an index in the dictionary. Here’s a loop that accesses
    both the key and its value:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可能希望访问与每个键相关联的值，我们可以通过使用每个键作为字典中的索引来做到这一点。以下是一个循环，访问键及其值：
- en: '>>> for word in d:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> for word in d:'
- en: '...     print(''key'', word, ''has value'', d[word])'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '...     print(''key'', word, ''has value'', d[word])'
- en: '...'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: key cut has value 4
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: key cut 的值为 4
- en: key gully has value 3
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: key gully 的值为 3
- en: key storm has value 2
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: key storm 的值为 2
- en: key brook has value 2
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: key brook 的值为 2
- en: Dictionaries have methods that let us access the keys, values, or both.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 字典有方法可以让我们访问键、值或两者。
- en: 'The keys method gives us the keys, and the values method gives us the values:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: keys 方法给我们键，values 方法给我们值：
- en: '>>> d.keys()'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> d.keys()'
- en: dict_keys(['cut', 'gully', 'storm', 'brook'])
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: dict_keys(['cut', 'gully', 'storm', 'brook'])
- en: '>>> d.values()'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> d.values()'
- en: dict_values([4, 3, 2, 2])
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: dict_values([4, 3, 2, 2])
- en: 'These aren’t lists, but we can pass them to list to convert them:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 这些不是列表，但我们可以将它们传递给 list 来进行转换：
- en: '>>> keys = list(d.keys())'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> keys = list(d.keys())'
- en: '>>> keys'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> keys'
- en: '[''cut'', ''gully'', ''storm'', ''brook'']'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '[''cut'', ''gully'', ''storm'', ''brook'']'
- en: '>>> values = list(d.values())'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> values = list(d.values())'
- en: '>>> values'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> values'
- en: '[4, 3, 2, 2]'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '[4, 3, 2, 2]'
- en: 'With the keys available as a list, we can sort the keys and then loop through
    them in sorted order:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 使用列表形式的键，我们可以对键进行排序，然后按排序顺序遍历它们：
- en: '>>> keys.sort()'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> keys.sort()'
- en: '>>> keys'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> keys'
- en: '[''brook'', ''cut'', ''gully'', ''storm'']'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '[''brook'', ''cut'', ''gully'', ''storm'']'
- en: '>>> for word in keys:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> for word in keys:'
- en: '...     print(''key'', word, ''has value'', d[word])'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '...     print(''key'', word, ''has value'', d[word])'
- en: '...'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: key brook has value 2
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: key brook 的值是 2
- en: key cut has value 4
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: key cut 的值是 4
- en: key gully has value 3
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: key gully 的值是 3
- en: key storm has value 2
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: key storm 的值是 2
- en: 'We can also loop through the values:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以遍历值：
- en: '>>> for num in d.values():'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> for num in d.values():'
- en: '...     print(''number'', num)'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '...     print(''number'', num)'
- en: '...'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: number 4
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 数字 4
- en: number 3
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 数字 3
- en: number 2
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 数字 2
- en: number 2
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 数字 2
- en: Looping through keys is often preferred over looping through values. It’s easy
    to go from a key to its value. As we’ll see in the next subsection, though, it’s
    not as easy to go from a value back to its key.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历键通常比遍历值更受欢迎。因为从键到值很容易。但正如我们在下一个小节中将看到的，从值回到键则没有那么简单。
- en: 'One final method that’s relevant here is items. It gives us access to both
    the keys and values:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个相关的最终方法是 items。它让我们可以同时访问键和值：
- en: '>>> pairs = list(d.items())'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> pairs = list(d.items())'
- en: '>>> pairs'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> pairs'
- en: '[(''cut'', 4), (''gully'', 3), (''storm'', 2), (''brook'', 2)]'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: '[(''cut'', 4), (''gully'', 3), (''storm'', 2), (''brook'', 2)]'
- en: 'This gives us another way to loop through the key:value pairs of a dictionary:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了另一种遍历字典键:值对的方式：
- en: '>>> for pair in pairs:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> for pair in pairs:'
- en: '...     print(''key'', pair[0], ''has value'', pair[1])'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '...     print(''key'', pair[0], ''has value'', pair[1])'
- en: '...'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: key cut has value 4
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: key cut 的值是 4
- en: key gully has value 3
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: key gully 的值是 3
- en: key storm has value 2
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: key storm 的值是 2
- en: key brook has value 2
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: key brook 的值是 2
- en: 'Look carefully at the pairs value:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细查看 pairs 的值：
- en: '>>> pairs'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> pairs'
- en: '[(''cut'', 4), (''gully'', 3), (''storm'', 2), (''brook'', 2)]'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: '[(''cut'', 4), (''gully'', 3), (''storm'', 2), (''brook'', 2)]'
- en: 'There’s something fishy here: there are parentheses around each inner value,
    not square brackets. It turns out that this is *not* a list of lists, but a list
    of *tuples*:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有点问题：每个内部值周围都是括号，而不是方括号。事实证明，这*不是*一个列表的列表，而是一个元组的列表：
- en: '>>> type(pairs[0])'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> type(pairs[0])'
- en: <class 'tuple'>
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: <class 'tuple'>
- en: 'Tuples are similar to lists in that they store a sequence of values. The most
    important difference between tuples and lists is that tuples are immutable. You
    can loop over them, index them, and slice them, but you can’t modify them. If
    you try to modify a tuple, you get an error:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 元组与列表类似，它们存储一个值的序列。元组和列表之间最重要的区别是，元组是不可变的。你可以遍历它们、索引它们和切片它们，但不能修改它们。如果你试图修改元组，就会报错：
- en: '>>> pairs[0][0] = ''river'''
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> pairs[0][0] = ''river'''
- en: 'Traceback (most recent call last):'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 'Traceback (most recent call last):'
- en: File "<stdin>", line 1, in <module>
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: File "<stdin>", line 1, in <module>
- en: 'TypeError: ''tuple'' object does not support item assignment'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 'TypeError: ''tuple'' 对象不支持项赋值'
- en: 'You can create your own tuples using parentheses. For a tuple with a single
    value, we need a trailing comma. For a tuple with multiple values, we don’t:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用括号创建自己的元组。对于一个只有单个值的元组，我们需要一个结尾的逗号。对于多个值的元组，则不需要：
- en: '>>> (4,)'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> (4,)'
- en: (4,)
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: (4,)
- en: '>>> (4, 5)'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> (4, 5)'
- en: (4, 5)
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: (4, 5)
- en: '>>> (4, 5, 6)'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> (4, 5, 6)'
- en: (4, 5, 6)
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: (4, 5, 6)
- en: Tuples have methods—but only a few, because methods that would change a tuple
    are not allowed. I encourage you to learn more about tuples if you’re interested,
    but we won’t use tuples any further in this book.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 元组有方法——但只有少数几个，因为不允许改变元组的那些方法。如果你感兴趣，我鼓励你了解更多关于元组的内容，但在本书中我们不会再使用元组了。
- en: Inverting a Dictionary
  id: totrans-536
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 反转字典
- en: We’re close to being able to solve Common Words using dictionaries. Here’s the
    plan. We maintain a dictionary that maps from words to their number of occurrences.
    Whenever we process a word, we check whether that word is already in the dictionary.
    If it isn’t, then we add it with a value of 1\. If it is, then we increase its
    value by 1.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接近于能够使用字典解决常见单词问题了。计划如下：我们维护一个字典，将单词映射到它们出现的次数。每当处理一个单词时，我们检查该单词是否已经在字典中。如果不在，我们就以
    1 为值将其加入字典。如果已经在字典中，我们则将其值加 1。
- en: 'Here’s an example of adding two words, one that we have seen before and one
    that we haven’t:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子，展示如何添加两个单词，一个是我们之前见过的，另一个是我们没见过的：
- en: '>>> d = {''storm'': 1, ''cut'': 1, ''magma'': 1}'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> d = {''storm'': 1, ''cut'': 1, ''magma'': 1}'
- en: '>>> word = ''cut''  # ''cut'' is already in the dictionary'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> word = ''cut''  # ''cut'' 已经在字典中'
- en: '>>> if not word in d:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> if not word in d:'
- en: '...     d[word] = 1'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: '...     d[word] = 1'
- en: '... else:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: '... else:'
- en: '...     d[word] = d[word] + 1'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '...     d[word] = d[word] + 1'
- en: '...'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '>>> d'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> d'
- en: '{''storm'': 1, ''cut'': 2, ''magma'': 1}'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: '{''storm'': 1, ''cut'': 2, ''magma'': 1}'
- en: '>>> word = ''brook''  # ''brook'' is not in the dictionary'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> word = ''brook''  # ''brook'' 不在字典中'
- en: '>>> if not word in d:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> if not word in d:'
- en: '...     d[word] = 1'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: '...     d[word] = 1'
- en: '... else:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: '... else:'
- en: '...     d[word] = d[word] + 1'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: '...     d[word] = d[word] + 1'
- en: '...'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '>>> d'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> d'
- en: '{''storm'': 1, ''cut'': 2, ''magma'': 1, ''brook'': 1}'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: '{''storm'': 1, ''cut'': 2, ''magma'': 1, ''brook'': 1}'
- en: 'Dictionaries make it easy to go from a key to a value. For example, given the
    key ''brook'', we can easily look up the value 1:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 字典使得从键到值的映射变得容易。例如，给定键 'brook'，我们可以轻松查找值 1：
- en: '>>> d[''brook'']'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> d[''brook'']'
- en: '1'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: Referring to [Table 8-1](ch08.xhtml#ch08tab01), that’s like going from a word
    in the left column to its number of occurrences in the right column. That doesn’t
    directly tell us the words that have a specified number of occurrences, though.
    What we really need to be able to do is go from the right column to the left,
    from number of occurrences to words. Then we’ll be able to sort the numbers of
    occurrences from most to least to find the words we need.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 参照[表 8-1](ch08.xhtml#ch08tab01)，这就像从左列的单词到右列的出现次数。但是，这并不能直接告诉我们有多少个单词具有特定的出现次数。我们真正需要做的是从右列到左列转换，从出现次数到单词。这样我们就能按照出现次数从多到少排序，找到我们需要的单词。
- en: 'That is, we need to go from this kind of dictionary:'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，我们需要将这种字典转换为：
- en: '{''storm'': 2, ''cut'': 4, ''magma'': 1, ''brook'': 2,'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: '{''storm'': 2, ''cut'': 4, ''magma'': 1, ''brook'': 2,'
- en: '''gully'': 3, ''cliff'': 1, ''blast'': 1}'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: '''gully'': 3, ''cliff'': 1, ''blast'': 1}'
- en: 'to this kind, the *inverted dictionary*:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 转换为这种形式，即*倒转字典*：
- en: '{2: [''storm'', ''brook''], 4: [''cut''], 1: [''magma'', ''cliff'', ''blast''],'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: '{2: [''storm'', ''brook''], 4: [''cut''], 1: [''magma'', ''cliff'', ''blast''],'
- en: '3: [''gully'']}'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: '3: [''gully'']}'
- en: 'The original dictionary maps from strings to numbers. The inverted dictionary
    maps from numbers to strings. Well, not quite: the inverted dictionary maps from
    numbers to *lists* of strings. Remember that each key is allowed only once in
    a dictionary. In the inverted dictionary, we need to map each key to multiple
    values, so we store all of those values in a list.'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 原始字典将字符串映射到数字。倒转的字典将数字映射到字符串。嗯，不完全是：倒转的字典将数字映射到*字符串列表*。记住，在字典中，每个键只能出现一次。在倒转的字典中，我们需要将每个键映射到多个值，因此我们将所有这些值存储在一个列表中。
- en: To invert a dictionary, each key becomes a value, and each value becomes a key.
    If a key doesn’t exist yet in the inverted dictionary, we create a list for its
    value. If a key is already in the inverted dictionary, then we add its value to
    its list.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 要倒转一个字典，每个键变成一个值，每个值变成一个键。如果一个键还没有出现在倒转字典中，我们为它的值创建一个列表。如果该键已经存在于倒转字典中，那么我们将它的值添加到该列表中。
- en: We can now write a function to return the inverted version of a dictionary.
    See [Listing 8-5](ch08.xhtml#ch08ex05) for the code.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以编写一个函数来返回字典的倒转版本。请参见[示例 8-5](ch08.xhtml#ch08ex05)获取代码。
- en: 'def invert_dictionary(d):'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 'def invert_dictionary(d):'
- en: '"""'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: d is a dictionary mapping strings to numbers.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: d 是一个将字符串映射到数字的字典。
- en: Return the inverted dictionary of d.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 d 的倒转字典。
- en: '"""'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: inverted = {}
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: inverted = {}
- en: '❶ for key in d:'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: '❶ for key in d:'
- en: ❷ num = d[key]
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ num = d[key]
- en: 'if not num in inverted:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 'if not num in inverted:'
- en: ❸ inverted[num] = [key]
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ inverted[num] = [key]
- en: 'else:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: ❹ inverted[num].append(key)
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ inverted[num].append(key)
- en: return inverted
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: return inverted
- en: '*Listing 8-5: Inverting a dictionary*'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 8-5：倒转字典*'
- en: We’re using a for loop over the dictionary d ❶, which gives us each key. We
    index d to obtain the value mapped to by this key ❷. Then we add this key:value
    pair to the inverted dictionary. If num is not yet a key in the inverted dictionary,
    then we add it and make it map to the associated key in d ❸. If num is already
    a key in the inverted dictionary, then its value is already a list. We can therefore
    use append to add the key from d as another value ❹.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个 for 循环遍历字典 d ❶，它为我们提供每个键。我们索引 d 来获取这个键映射到的值 ❷。然后我们将这个键值对添加到倒转字典中。如果 num
    还不是倒转字典中的键，那么我们添加它并将其映射到 d 中的关联键 ❸。如果 num 已经是倒转字典中的键，那么它的值已经是一个列表。因此，我们可以使用 append
    方法将 d 中的键作为另一个值添加到列表中 ❹。
- en: 'Enter the code for our invert_dictionary function into the Python shell. Let’s
    give it a try:'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的 `invert_dictionary` 函数的代码输入到 Python shell 中。让我们试试看：
- en: '>>> d = {''a'': 1, ''b'': 1, ''c'': 1}'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> d = {''a'': 1, ''b'': 1, ''c'': 1}'
- en: '>>> invert_dictionary(d)'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> invert_dictionary(d)'
- en: '{1: [''a'', ''b'', ''c'']}'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: '{1: [''a'', ''b'', ''c'']}'
- en: '>>> d = {''storm'': 2, ''cut'': 4, ''magma'': 1, ''brook'': 2,'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> d = {''storm'': 2, ''cut'': 4, ''magma'': 1, ''brook'': 2,'
- en: '...      ''gully'': 3, ''cliff'': 1, ''blast'': 1}'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: '...      ''gully'': 3, ''cliff'': 1, ''blast'': 1}'
- en: '>>> invert_dictionary(d)'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> invert_dictionary(d)'
- en: '{2: [''storm'', ''brook''], 4: [''cut''], 1: [''magma'', ''cliff'', ''blast''],'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: '{2: [''storm'', ''brook''], 4: [''cut''], 1: [''magma'', ''cliff'', ''blast''],'
- en: '3: [''gully'']}'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: '3: [''gully'']}'
- en: Now we’re ready to solve Common Words with an inverted dictionary.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备通过反转字典来解决常见单词问题。
- en: Solving the Problem
  id: totrans-594
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决问题
- en: If you’d like more practice with top-down design, you might like to solve the
    problem on your own before continuing. In the interest of space, I won’t follow
    the steps of top-down design here. Rather, I’ll present the solution in its entirety,
    and then we’ll discuss each function and how it is used.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想通过自顶向下的设计来多做一些练习，可以在继续之前尝试独立解决这个问题。为了节省空间，我在这里不逐步跟进自顶向下的设计，而是直接给出完整的解决方案，然后我们再讨论每个函数及其用途。
- en: The Code
  id: totrans-596
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 代码
- en: The solution is in [Listing 8-6](ch08.xhtml#ch08ex06).
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案见 [Listing 8-6](ch08.xhtml#ch08ex06)。
- en: 'def invert_dictionary(d):'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 'def invert_dictionary(d):'
- en: '"""'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: d is a dictionary mapping strings to numbers.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: d 是一个将字符串映射到数字的字典。
- en: Return the inverted dictionary of d.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 返回反转后的字典 d。
- en: '"""'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: inverted = {}
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: inverted = {}
- en: 'for key in d:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 'for key in d:'
- en: num = d[key]
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: num = d[key]
- en: 'if not num in inverted:'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 num 不在 inverted 中：
- en: inverted[num] = [key]
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: inverted[num] = [key]
- en: 'else:'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: inverted[num].append(key)
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: inverted[num].append(key)
- en: return inverted
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: return inverted
- en: '❶ def with_suffix(num):'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: '❶ def with_suffix(num):'
- en: '"""'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: num is an integer >= 1.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: num 是一个大于或等于 1 的整数。
- en: Return a string of num with its suffix added; e.g. '5th'.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 返回带有后缀的数字字符串；例如 '5th'。
- en: '"""'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: ❷ s = str(num)
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ s = str(num)
- en: '❸ if s[-1] == ''1'' and s[-2:] != ''11'':'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: '❸ 如果 s[-1] == ''1'' 且 s[-2:] != ''11'':'
- en: return s + 'st'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: return s + 'st'
- en: 'elif s[-1] == ''2'' and s[-2:] != ''12'':'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif s[-1] == ''2'' 且 s[-2:] != ''12'':'
- en: return s + 'nd'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: return s + 'nd'
- en: 'elif s[-1] == ''3'' and s[-2:] != ''13'':'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif s[-1] == ''3'' 且 s[-2:] != ''13'':'
- en: return s + 'rd'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: return s + 'rd'
- en: 'else:'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: return s + 'th'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: return s + 'th'
- en: '❹ def most_common_words(num_to_words, k):'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: '❹ def most_common_words(num_to_words, k):'
- en: '"""'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: num_to_words is a dictionary mapping number of occurrences to
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: num_to_words 是一个将出现次数映射到单词的字典。
- en: lists of words.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 单词列表。
- en: k is an integer >= 1.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: k 是一个大于或等于 1 的整数。
- en: Return a list of the kth most-common words in num_to_words.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 num_to_words 中第 k 个最常见的单词的列表。
- en: '"""'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: nums = list(num_to_words.keys())
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: nums = list(num_to_words.keys())
- en: nums.sort(reverse=True)
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: nums.sort(reverse=True)
- en: total = 0
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: total = 0
- en: i = 0
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: i = 0
- en: done = False
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: done = False
- en: '❺ while i < len(nums) and not done:'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ while i < len(nums) 且 done 为假：
- en: num = nums[i]
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: num = nums[i]
- en: '❻ if total + len(num_to_words[num]) >= k:'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: '❻ 如果 total + len(num_to_words[num]) >= k:'
- en: done = True
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: done = True
- en: 'else:'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: total = total + len(num_to_words[num])
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: total = total + len(num_to_words[num])
- en: i = i + 1
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: i = i + 1
- en: '❼ if total == k - 1 and i < len(nums):'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: '❼ 如果 total == k - 1 且 i < len(nums):'
- en: return num_to_words[nums[i]]
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: return num_to_words[nums[i]]
- en: 'else:'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: return []
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: return []
- en: ❽ n = int(input())
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ n = int(input())
- en: 'for dataset in range(n):'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 'for dataset in range(n):'
- en: lst = input().split()
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: lst = input().split()
- en: m = int(lst[0])
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: m = int(lst[0])
- en: k = int(lst[1])
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: k = int(lst[1])
- en: word_to_num = {}
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: word_to_num = {}
- en: 'for i in range(m):'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(m):'
- en: word = input()
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: word = input()
- en: 'if not word in word_to_num:'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 word 不在 word_to_num 中：
- en: word_to_num[word] = 1
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: word_to_num[word] = 1
- en: 'else:'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: word_to_num[word] = word_to_num[word] + 1
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: word_to_num[word] = word_to_num[word] + 1
- en: ❾ num_to_words = invert_dictionary(word_to_num)
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ num_to_words = invert_dictionary(word_to_num)
- en: ordinal = with_suffix(k)
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: ordinal = with_suffix(k)
- en: words = most_common_words(num_to_words, k)
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: words = most_common_words(num_to_words, k)
- en: print(f'{ordinal} most common word(s):')
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: print(f'{ordinal} most common word(s):')
- en: 'for word in words:'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 'for word in words:'
- en: print(word)
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: print(word)
- en: print()
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: print()
- en: '*Listing 8-6: Solving Common Words*'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 8-6: 解决常见单词问题*'
- en: The first function is invert_dictionary. We’ve already discussed that, in “Inverting
    a Dictionary” earlier in this chapter. We’ll now go through each other piece of
    the program.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数是 invert_dictionary。我们在本章“反转字典”部分已经讨论过它。接下来我们将逐一讲解程序中的其他部分。
- en: Adding the Suffix
  id: totrans-669
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加后缀
- en: 'The with_suffix function ❶ takes a number and returns a string with the correct
    suffix added to the number. We need this function because of the pesky requirement
    to output *k* with a suffix. For example, if *k* = 1, then we’ll have to produce
    this line as part of the output:'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: with_suffix 函数 ❶ 接收一个数字，并返回一个带有正确后缀的字符串。我们需要这个函数，因为有个麻烦的要求需要将 *k* 与后缀一起输出。例如，如果
    *k* = 1，那么我们就必须在输出中生成这一行：
- en: '1st most common word(s):'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 1st 最常见的单词：
- en: 'If *k* = 2, we’ll have to produce this line as part of the output:'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *k* = 2，我们必须在输出中生成这一行：
- en: '2nd most common word(s):'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 2nd 最常见的单词：
- en: and so on. Our with_suffix function makes sure that we add the correct suffix
    to the number. We first convert the number to a string ❷ so that we can easily
    access its digits. Then we use a series of tests to determine whether the suffix
    is st, nd, rd, or th. For example, if the last digit is a 1 but the last two digits
    aren’t 11 ❸, then the correct suffix is st. That gives us 1st, 21st, and 31st,
    but not 11st (which would be incorrect).
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 依此类推。我们的`with_suffix`函数确保我们为数字添加正确的后缀。我们首先将数字转换为字符串❷，以便我们可以轻松访问它的每一位数字。然后我们使用一系列的测试来确定后缀是st、nd、rd还是th。例如，如果最后一位数字是1，但最后两位数字不是11❸，那么正确的后缀是st。这样我们就得到了1st、21st和31st，但不是11st（那将是错误的）。
- en: Finding the kth Most Common Words
  id: totrans-675
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 查找第k个最常见的单词
- en: The most_common_words function ❹ is the function that actually finds the words
    that we need. It takes an inverted dictionary (which maps numbers of occurrences
    to lists of words) and an integer k and returns a list of the kth most common
    words.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: '`most_common_words`函数❹就是实际查找我们需要的单词的函数。它接受一个反转字典（将出现次数映射到单词列表）和一个整数k，并返回一个包含第k个最常见单词的列表。'
- en: 'To see how it works, let’s look at a sample inverted dictionary. I’ve organized
    its keys in order from most occurrences to fewest occurrences, as that’s the order
    that most_common_words goes through the keys. Here’s the dictionary:'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看它是如何工作的，让我们看看一个示例反转字典。我已经按从最多到最少出现次数的顺序整理了它的键，因为这是`most_common_words`函数遍历键的顺序。以下是字典：
- en: '{4: [''cut''],'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: '{4: [''cut''],'
- en: '3: [''gully''],'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: '3: [''gully''],'
- en: '2: [''storm'', ''brook''],'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: '2: [''storm'', ''brook''],'
- en: '1: [''magma'', ''cliff'', ''blast'']}'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: '1: [''magma'', ''cliff'', ''blast'']}'
- en: Suppose that k is 3. Therefore, exactly two words must be more common than the
    words that we return. The words we need are not provided by the first dictionary
    key. That key gives us only one word (cut), so it can’t be the third most common
    word. Similarly, the words we need are not provided by the second dictionary key.
    That key gives us one more word (gully). We’ve processed a total of two words
    now but haven’t found the third most common words yet. The words we need, however,
    *are* provided by the third dictionary key. That key gives us two more words;
    each of these words (storm and brook) has exactly two words with more occurrences,
    so these are the words for when k is 3.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 假设k是3。因此，恰好有两个单词必须比我们返回的单词更常见。我们需要的单词并没有由第一个字典键提供。这个键只给了我们一个单词（cut），所以它不能是第三个最常见的单词。同样，第二个字典键也没有提供我们需要的单词。这个键给了我们另外一个单词（gully）。到现在为止，我们已经处理了两个单词，但仍未找到第三个最常见的单词。然而，第三个字典键提供了我们需要的单词。该键给了我们两个单词；这两个单词（storm
    和 brook）都有恰好两个比它们出现次数更多的单词，因此这些就是k为3时的单词。
- en: What if k were 4? This time, exactly three words must be more common than the
    words that we return. The candidate words are still those from the third key (storm
    and brook), but there are only two words that occur more often than each of these
    words. There are therefore *no* words for when k = 4.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 如果k是4会怎么样呢？这时，必须有恰好三个词比我们返回的词更常见。候选词仍然是来自第三个键（storm 和 brook），但是只有两个词比这两个词更常见。因此，当k=4时，*没有*可以返回的词。
- en: In summary, we need to total up the words we see when going through the keys
    until we find the key that might contain the words we need. If exactly k - 1 words
    occur more often, then we have words for k; otherwise, we don’t, and there are
    no words to output.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们需要累计当遍历键时看到的单词，直到找到可能包含我们所需单词的键。如果恰好有k - 1个单词更常见，那么我们就找到了第k个最常见的单词；否则，我们没有找到，因此没有单词可以输出。
- en: Now let’s walk through the code itself. We begin by obtaining a list of the
    dictionary’s keys and sorting them from biggest to smallest. We then loop through
    the keys in that reverse-sorted order ❺. The done variable tells us whether we’ve
    looked at k or more words yet. As soon as we have ❻, we exit the loop.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们一起看一下代码本身。我们首先获取字典的键并按从大到小排序。然后我们按这个倒排序的顺序遍历键❺。done变量告诉我们是否已经查看了k个或更多的单词。一旦我们查看了❻个单词，我们就退出循环。
- en: When the loop is done, we check whether there are any words for k. If there
    are exactly k - 1 words that occur more often, and we haven’t gone past the end
    of our keys ❼, then we indeed have words to return. Otherwise, there are no words
    to return, so we return the empty list.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 当循环结束后，我们检查是否有第k个单词。如果恰好有k - 1个单词出现得更频繁，并且我们没有遍历到键的末尾❼，那么我们确实有单词可以返回。否则，没有单词可以返回，所以我们返回空列表。
- en: The Main Program
  id: totrans-687
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 主程序
- en: 'Now we arrive at the main part of the program ❽. We build dictionary word_to_num,
    which maps each word to its number of occurrences. We then build the inverted
    dictionary num_to_words ❾, which maps each number of occurrences to the associated
    list of words. Notice how the names of these dictionaries convey the direction
    of mapping: word_to_num goes from words to numbers, and num_to_words goes from
    numbers to words.'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们进入程序的主要部分❽。我们构建了字典word_to_num，它将每个单词映射到其出现次数。接着我们构建了反向字典num_to_words❾，它将每个出现次数映射到相关的单词列表。请注意，这些字典的名称传达了映射的方向：word_to_num是从单词到数字，num_to_words是从数字到单词。
- en: The rest of the code calls our other helper functions and outputs the appropriate
    words.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的代码调用了其他辅助函数，并输出适当的单词。
- en: 'With that, you’re ready to submit to the judge. Well done: that’s the first
    problem that you’ve solved with dictionaries. Whenever you need to map between
    two types of values, think about whether you can organize the information using
    a dictionary. If you can, it’s likely that you’ll be well on your way to an efficient
    solution!'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你就准备好提交给评测系统了。做得好：这是你用字典解决的第一个问题。每当你需要在两种类型的值之间映射时，想一想是否可以使用字典来组织这些信息。如果可以，这通常意味着你已经走在了高效解决方案的道路上！
- en: 'Problem #20: Cities and States'
  id: totrans-691
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '问题 #20：城市与州'
- en: Here’s another problem where we’ll be able to use a dictionary. As you read
    the problem description, think about what we could use as the keys and what we
    could use as the values.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个我们能够使用字典的问题。在阅读问题描述时，思考我们可以将什么作为键，什么可以作为值。
- en: This is USACO 2016 December Silver Contest problem Cities and States.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 这是USACO 2016年12月银奖竞赛问题“城市与州”。
- en: The Challenge
  id: totrans-694
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战
- en: The United States is divided into geographical regions called *states*, each
    of which contains one or more cities. Each state has been given a two-character
    abbreviation. For example, the abbreviation for Pennsylvania is PA, and the abbreviation
    for South Carolina is SC. We’ll write city names and state abbreviations in all
    uppercase.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 美国被划分为称为*州*的地理区域，每个州包含一个或多个城市。每个州都有一个由两个字符组成的缩写。例如，宾夕法尼亚州的缩写是PA，南卡罗来纳州的缩写是SC。我们将所有城市名和州缩写写成大写。
- en: Consider the pair of cities SCRANTON PA and PARKER SC. This pair of cities is
    *special* because the first two characters of each city give the abbreviation
    for the other city’s state. That is, the first two characters of SCRANTON give
    us SC (PARKER’s state), and the first two characters of PARKER give us PA (SCRANTON’s
    state).
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑城市对SCRANTON PA和PARKER SC。这个城市对是*特殊的*，因为每个城市的前两个字符给出了另一个城市所在州的缩写。也就是说，SCRANTON的前两个字符给出了SC（PARKER的州），而PARKER的前两个字符给出了PA（SCRANTON的州）。
- en: A pair of cities is *special* if they meet this property and are not in the
    same state.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一对城市满足以下条件，并且不在同一个州，则该对城市是*特殊的*。
- en: Determine the number of special pairs of cities in the provided input.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 确定提供输入中的特殊城市对的数量。
- en: Input
  id: totrans-699
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输入
- en: Read input from the file named *citystate.in*.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 从名为*citystate.in*的文件中读取输入。
- en: 'The input consists of the following lines:'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 输入由以下几行组成：
- en: A line containing *n*, the number of cities. *n* is between 1 and 200,000.
  id: totrans-702
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一行包含*n*，表示城市的数量。*n*的范围是1到200,000之间。
- en: '*n* lines, one per city. Each line gives the name of a city in uppercase, a
    space, and its state’s abbreviation in uppercase. The name of each city is between
    2 and 10 characters; the abbreviation for each state is exactly two characters.
    The same city name can exist in multiple states but will not appear more than
    once in the same state. The name of a city or state in this problem is any string
    that meets these requirements; it might not be the name of an actual US city or
    state.'
  id: totrans-703
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*n*行，每行对应一个城市。每行包含一个城市名（大写），一个空格，以及该城市所在州的缩写（大写）。每个城市的名称长度在2到10个字符之间；每个州的缩写恰好由两个字符组成。同一城市名可以出现在多个州，但不会在同一个州中出现两次。本问题中的城市名或州名是符合这些要求的任何字符串；它们可能不是实际的美国城市或州名。'
- en: Output
  id: totrans-704
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输出
- en: Write output to the file named *citystate.out*.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 将输出写入名为*citystate.out*的文件。
- en: Output the number of special pairs of cities.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 输出特殊城市对的数量。
- en: The time limit for solving each test case is four seconds.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 每个测试案例的时间限制是四秒。
- en: Exploring a Test Case
  id: totrans-708
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探索测试案例
- en: Perhaps you’re thinking that you could solve this problem with a list. That’s
    a good thought to have! If you’re interested, I suggest giving that a try before
    continuing. The strategy would be to use two nested loops to consider each pair
    of cities and check whether each pair is special. It’s possible to come up with
    a correct solution using this approach.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你在想，你可以用列表来解决这个问题。这是一个不错的思路！如果你感兴趣，我建议你在继续之前先尝试一下。策略是使用两个嵌套的循环来考虑每一对城市，并检查每一对是否特殊。使用这种方法也是可能得出正确解的。
- en: A correct solution, yes, but also a slow one. The list of cities can be huge—up
    to a maximum of 200,000—and any solution involving searching a list for matching
    cities is doomed to be too slow. Let’s explore a test case and work out how a
    dictionary can help.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 一个正确的解决方案，没错，但也是一个缓慢的解决方案。城市的列表可能非常庞大——最多可达 200,000 个——任何涉及搜索列表以匹配城市的方案注定会太慢。让我们通过一个测试案例来探讨一下字典如何能提供帮助。
- en: 'Here’s our test case:'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的测试案例：
- en: '12'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: '12'
- en: SCRANTON PA
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: SCRANTON PA
- en: MANISTEE MI
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 曼尼斯蒂 MI
- en: NASHUA NH
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 纳舒厄 NH
- en: PARKER SC
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 帕克 SC
- en: LAFAYETTE CO
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 拉斐特 CO
- en: WASHOUGAL WA
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 瓦绍格尔 WA
- en: MIDDLEBOROUGH MA
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 米德尔伯勒 MA
- en: MADISON MI
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 麦迪逊 MI
- en: MILFORD MA
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 米尔福德 MA
- en: MIDDLETON MA
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 中托 MA
- en: COVINGTON LA
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 科温顿 LA
- en: LAKEWOOD CO
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 莱克伍德 CO
- en: The first city is SCRANTON PA. To find special pairs involving this city, we
    need to find other cities whose name starts with PA and whose state is SC. The
    only other city that meets this description is PARKER SC.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个城市是 SCRANTON PA。为了找到涉及该城市的特殊城市对，我们需要找到其他名称以 PA 开头且州为 SC 的城市。唯一符合这个描述的城市是帕克
    SC。
- en: Notice that all we care about for SCRANTON PA is that its name starts with SC
    and that its state is PA. It could have been called SCMERWIN PA or SCSHOCK PA
    or SCHRUTE PA; it would still be a special pair with PARKER SC.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，SCRANTON PA 只有一个条件我们需要关心，那就是它的名字以 SC 开头，且它的州是 PA。它本可以叫做 SCMERWIN PA，SCSHOCK
    PA 或者 SCHRUTE PA，依然会与帕克 SC 形成特殊对。
- en: Let’s refer to the first two characters of a city name followed by the city’s
    state as a *combo*. For example, the combo for SCRANTON PA is SCPA, and the combo
    for PARKER SC is PASC.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把城市名称的前两个字符加上城市所在的州称为*组合*。例如，SCRANTON PA 的组合是 SCPA，帕克 SC 的组合是 PASC。
- en: Rather than searching for special pairs of cities, we can now look at special
    pairs of combos. Let’s try this.
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 与其寻找特殊的城市对，我们现在可以看看特殊的组合对。让我们尝试一下。
- en: There are two cities with the combo MAMI. They happen to be MANISTEE MI and
    MADISON MI, but all we care about is that there are two of them. The MAMI cities
    start with MA and are in state MI. To count up the special pairs involving MAMI
    cities, we need to know the cities that start with MI and have state MA. That
    is, we need to know the number of MIMA cities. There are three MIMA cities. They
    happen to be MIDDLEBOROUGH MA, MILFORD MA, and MIDDLETON MA, but all we care about
    is that there are three of them. Okay—so we have two MAMI cities and three MIMA
    cities. The total special pairs for these combos is therefore 2 * 3 = 6, because
    for each of the two MAMI cities, we have a choice of three MIMA cities.
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个城市属于 MAMI 组合。它们恰好是曼尼斯蒂 MI 和麦迪逊 MI，但我们关心的是它们的数量是两个。MAMI 城市以 MA 开头，且位于 MI 州。为了计算涉及
    MAMI 城市的特殊城市对，我们需要知道那些以 MI 开头并且位于 MA 州的城市数量。也就是说，我们需要知道 MIMA 城市的数量。共有三个 MIMA 城市。它们恰好是米德尔伯勒
    MA、米尔福德 MA 和中托 MA，但我们关心的是它们的数量是三个。那么——我们有两个 MAMI 城市和三个 MIMA 城市。因此，这些组合的总特殊城市对数量是
    2 * 3 = 6，因为对于每一个 MAMI 城市，我们都有三个 MIMA 城市的选择。
- en: 'If you’re not convinced, here are the six special pairs for these combos:'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还不相信，这里是这几个组合的六个特殊城市对：
- en: MANISTEE MI and MIDDLEBOROUGH MA
  id: totrans-731
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 曼尼斯蒂 MI 和米德尔伯勒 MA
- en: MANISTEE MI and MILFORD MA
  id: totrans-732
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 曼尼斯蒂 MI 和米尔福德 MA
- en: MANISTEE MI and MIDDLETON MA
  id: totrans-733
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 曼尼斯蒂 MI 和中托 MA
- en: MADISON MI and MIDDLEBOROUGH MA
  id: totrans-734
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 麦迪逊 MI 和米德尔伯勒 MA
- en: MADISON MI and MILFORD MA
  id: totrans-735
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 麦迪逊 MI 和米尔福德 MA
- en: MADISON MI and MIDDLETON MA
  id: totrans-736
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 麦迪逊 MI 和中托 MA
- en: If we could map combos—SCPA, PASC, MAMI, MIMA, and so on—to the number of occurrences,
    we could loop through the combos to find the number of special pairs of cities.
    A dictionary is the perfect tool to store this mapping.
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能将组合——SCPA, PASC, MAMI, MIMA 等——映射到出现次数，我们就可以循环这些组合来找出特殊城市对的数量。字典是存储这种映射的完美工具。
- en: 'Here’s the dictionary that we’d like to create for our test case:'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们希望为测试案例创建的字典：
- en: '{''SCPA'': 1, ''MAMI'': 2, ''NANH'': 1, ''PASC'': 1, ''LACO'': 2,'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: '{''SCPA'': 1, ''MAMI'': 2, ''NANH'': 1, ''PASC'': 1, ''LACO'': 2,'
- en: '''MIMA'': 3, ''COLA'': 1}'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: '''MIMA'': 3, ''COLA'': 1}'
- en: With this dictionary, we can figure out the number of special pairs of cities.
    Let’s work through the process.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个字典，我们可以计算出特殊城市对的数量。让我们一步步地看一下这个过程。
- en: The first key is 'SCPA'; its value is 1. To find special pairs of cities involving
    'SCPA', we need to look up the value for 'PASC'. That value is also 1. We multiply
    the two values together, yielding 1 * 1 = 1 special pair of cities involving these
    combos. We need to carry out this same procedure for each other key in the dictionary.
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个关键字是 'SCPA'，它的值是 1。要找到涉及 'SCPA' 的特殊城市对，我们需要查找 'PASC' 的值。这个值也是 1。我们将两个值相乘，得到
    1 * 1 = 1 对涉及这些组合的特殊城市对。我们需要对字典中每个其他的关键字执行相同的操作。
- en: The next key is 'MAMI'; its value is 2. To find special pairs of cities involving
    'MAMI', we need to look up the value for 'MIMA'. That value is 3. We multiply
    the two values together, yielding 2 * 3 = 6 special pairs of cities involving
    these combos. With the 1 we found previously, we now have a total of 7.
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个关键字是 'MAMI'，它的值是 2。要找到涉及 'MAMI' 的特殊城市对，我们需要查找 'MIMA' 的值。这个值是 3。我们将两个值相乘，得到
    2 * 3 = 6 对涉及这些组合的特殊城市对。加上之前找到的 1 对，现在总共有 7 对。
- en: The next key is 'NANH'; its value is 1. To find special pairs of cities involving
    'NANH', we need to look up the value for 'NHNA'. But 'NHNA' isn’t a key in the
    dictionary! There are no special pairs of cities involving these combos. We still
    have a total of 7.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个关键字是 'NANH'，它的值是 1。要找到涉及 'NANH' 的特殊城市对，我们需要查找 'NHNA' 的值。但 'NHNA' 不是字典中的一个关键字！因此没有涉及这些组合的特殊城市对。我们仍然有总共
    7 对。
- en: 'Pay close attention to this next one. The next key is ''PASC''; its value is
    1. To find special pairs of cities involving ''PASC'', we need to look up the
    value for ''SCPA''. That value is also 1. We multiply the two values together,
    yielding 1 * 1 = 1 special pair of cities involving these combos. But wait: we
    already accounted for this pair when we processed the key ''SCPA''. If we add
    1 here, then we’ll end up double-counting this pair. In fact, by processing each
    key we will double-count *every* special pair of cities. Not to worry, though:
    we’ll make an adjustment later when we’re ready to print the final answer. Let’s
    add this 1 in there. With the 7 we found previously, we now have a total of 8.'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 请特别注意接下来的这一条。下一个关键字是 'PASC'，它的值是 1。要找到涉及 'PASC' 的特殊城市对，我们需要查找 'SCPA' 的值。这个值也是
    1。我们将两个值相乘，得到 1 * 1 = 1 对涉及这些组合的特殊城市对。但是等等：我们已经在处理 'SCPA' 关键字时考虑过了这一对。如果我们在这里加
    1，就会导致重复计算这一对。事实上，通过处理每个关键字，我们会重复计算 *每一* 对特殊城市对。不过不用担心：当我们准备打印最终答案时，我们会做出调整。让我们把这
    1 加进去。加上之前找到的 7 对，现在总共有 8 对。
- en: The next key is 'LACO'; its value is 2. The value for 'COLA' is 1, giving 2
    * 1 = 2 special pairs of cities involving these combos. With the 8 we found previously,
    we now have a total of 10.
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个关键字是 'LACO'，它的值是 2。'COLA' 的值是 1，乘积 2 * 1 = 2，表示涉及这些组合的特殊城市对有 2 对。加上之前找到的
    8 对，现在总共有 10 对。
- en: There are two keys to go, 'MIMA' and 'COLA'. The first leads us to add 6 to
    our total; the second leads us to add 2\. With the 10 we found previously, we
    now have a total of 18.
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 还有两个关键字需要处理，'MIMA' 和 'COLA'。第一个让我们将 6 加到总数中；第二个让我们将 2 加上。加上之前找到的 10 对，现在总共有
    18 对。
- en: Remember that we’ve double-counted every special pair of cities. We don’t have
    18 unique special pairs of cities, then. We have only 18 / 2 = 9 special pairs
    of cities. All we need to do is divide by 2 to undo the double counting.
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们已经重复计算了每一对特殊城市对。因此，我们并没有 18 对独特的特殊城市对。实际上，我们只有 18 / 2 = 9 对特殊城市对。我们只需要除以
    2，就能消除重复计数。
- en: If you compare the dictionary we just went through to the cities in the test
    case, you’ll notice that something is missing from the dictionary. It’s that city
    WASHOUGAL WA! Its combo is WAWA, but there’s no 'WAWA' key in our dictionary.
    We’re not accounting for this city, and we need to understand why.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将我们刚才讲解的字典与测试用例中的城市进行比较，你会注意到字典中缺少了一个城市——WASHOUGAL WA！它的组合是 WAWA，但字典中没有 'WAWA'
    这个关键字。我们没有考虑到这个城市，我们需要理解为什么。
- en: The first two characters of WASHOUGAL WA are WA. This means that the only way
    for WASHOUGAL WA to be part of a special pair of cities is to find another city
    whose state is WA. Notice that WASHOUGAL WA is in state WA, too. However, the
    problem specifies that the two cities in a special pair of cities must come from
    different states. There’s therefore no way to find a special pair of cities involving
    WASHOUGAL WA. To make sure we don’t accidentally count fake special pairs, we
    don’t even include WASHOUGAL WA in the dictionary.
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: WASHOUGAL WA 的前两个字符是 WA。这意味着 WASHOUGAL WA 成为特殊城市对的一部分的唯一方式是找到另一个州为 WA 的城市。请注意，WASHOUGAL
    WA 也位于 WA 州。然而，问题指定特殊城市对中的两个城市必须来自不同的州。因此，无法找到包含 WASHOUGAL WA 的特殊城市对。为了确保我们不会意外地计数虚假的特殊城市对，我们甚至不将
    WASHOUGAL WA 包含在字典中。
- en: Solving the Problem
  id: totrans-751
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决问题
- en: We’re ready to go! We can use a dictionary for a concise, rocket-fast solution
    to Cities and States. The code is in [Listing 8-7](ch08.xhtml#ch08ex07).
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 我们准备好了！我们可以使用字典为城市和州问题提供简洁、快速的解决方案。代码在 [清单 8-7](ch08.xhtml#ch08ex07) 中。
- en: input_file = open('citystate.in', 'r')
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: input_file = open('citystate.in', 'r')
- en: output_file = open('citystate.out', 'w')
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: output_file = open('citystate.out', 'w')
- en: n = int(input_file.readline())
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: n = int(input_file.readline())
- en: ❶ combo_to_num = {}
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ combo_to_num = {}
- en: 'for i in range(n):'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(n):'
- en: lst = input_file.readline().split()
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: lst = input_file.readline().split()
- en: ❷ city = lst[0][:2]
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ city = lst[0][:2]
- en: state = lst[1]
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: state = lst[1]
- en: '❸ if city != state:'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: '❸ if city != state:'
- en: combo = city + state
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: combo = city + state
- en: 'if not combo in combo_to_num:'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 'if not combo in combo_to_num:'
- en: combo_to_num[combo] = 1
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: combo_to_num[combo] = 1
- en: 'else:'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: combo_to_num[combo] = combo_to_num[combo] + 1
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: combo_to_num[combo] = combo_to_num[combo] + 1
- en: total = 0
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: total = 0
- en: '❹ for combo in combo_to_num:'
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: '❹ for combo in combo_to_num:'
- en: ❺ other_combo = combo[2:] + combo[:2]
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ other_combo = combo[2:] + combo[:2]
- en: 'if other_combo in combo_to_num:'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 'if other_combo in combo_to_num:'
- en: ❻ total = total + combo_to_num[combo] * combo_to_num[other_combo]
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ total = total + combo_to_num[combo] * combo_to_num[other_combo]
- en: ❼ output_file.write(str(total // 2) + '\n')
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ output_file.write(str(total // 2) + '\n')
- en: input_file.close()
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: input_file.close()
- en: output_file.close()
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: output_file.close()
- en: '*Listing 8-7: Solving Cities and States*'
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-7：解决城市和州的问题*'
- en: This is a USACO problem where we need to use files rather than standard input
    and standard output.
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 USACO 问题，我们需要使用文件而不是标准输入和标准输出。
- en: The dictionary that we’ll build is called combo_to_num ❶. It maps from four-character
    combos, like 'SCPA', to the number of cities with that combo.
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建的字典叫做 combo_to_num ❶。它将四个字符的组合（例如 'SCPA'）映射到具有该组合的城市数量。
- en: For each city from the input, we use variables to refer to the first two characters
    of the name of the city ❷ and its state. Then, if these values are not the same
    ❸, we combine them and add the combo to the dictionary. If the combo wasn’t already
    in the dictionary, we add it with a value of 1; if it was already there, we increase
    its value by 1.
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 对于输入中的每个城市，我们使用变量来表示城市名称的前两个字符 ❷ 和其州名。然后，如果这些值不相同 ❸，我们将它们组合并将组合添加到字典中。如果该组合尚未在字典中，我们将其添加，值为
    1；如果已经存在，我们将其值增加 1。
- en: The dictionary is now built. We loop through its keys ❹. For each key, we construct
    the other combo that we need to look up to find special pairs of cities involving
    this key. If the key is 'SCPA', for example, then we want the other combo to be
    'PASC'. To do that, we take the rightmost two characters of the key and follow
    those by the leftmost two characters ❺. If that other combo is also in the dictionary,
    then we multiply the two key’s values and add that to our total ❻.
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 字典现在已经构建完成。我们遍历其键 ❹。对于每个键，我们构造需要查找的另一个组合，以便找到包含此键的特殊城市对。如果键是 'SCPA'，例如，那么我们希望另一个组合是
    'PASC'。为此，我们取键的最右边两个字符，再跟上最左边的两个字符 ❺。如果另一个组合也在字典中，那么我们将两个键的值相乘，并将结果加到总数中 ❻。
- en: All we need to do now is output the total number of special pairs of cities
    to the output file. As explained in the previous section, we need to divide our
    total by 2 ❼ to undo the double-counting that results from processing each key
    in the dictionary.
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要做的就是将特殊城市对的总数输出到输出文件。如前一节所述，我们需要将总数除以 2 ❼ 来消除因处理字典中的每个键而导致的重复计数。
- en: 'There we have it: another example of solving a problem with a suitable deployment
    of a dictionary. Feel free to submit our code!'
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样：这是一个使用字典适当部署来解决问题的例子。随时可以提交我们的代码！
- en: Summary
  id: totrans-782
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about Python sets and dictionaries. A set is a collection
    of values with no order and no duplicates. A dictionary is a collection of key:value
    pairs. As we saw in this chapter’s problems, sometimes these collections are more
    appropriate than lists. For example, determining whether a value is in a set is
    ridiculously fast compared to the same operation on a list. If we don’t care about
    the order of values or want to eliminate duplicates, we should seriously consider
    using a set.
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们学习了 Python 的集合和字典。集合是一种没有顺序且没有重复元素的值集合。字典是一种由键：值对组成的集合。正如我们在本章的题目中看到的，有时候这些集合比列表更合适。例如，相比于在列表上执行相同的操作，判断某个值是否存在于集合中要快得多。如果我们不关心值的顺序，或者希望消除重复项，那么我们应该认真考虑使用集合。
- en: Similarly, a dictionary makes it easy to determine the value mapped to by a
    key. If we’re maintaining a mapping from keys to values, then we should seriously
    consider using a dictionary.
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，字典使得通过键来查找对应的值变得容易。如果我们需要维持一个从键到值的映射，那么我们应该认真考虑使用字典。
- en: With sets and dictionaries in the mix, you now have more flexibility for how
    to store your values. This flexibility, however, means that you need to make a
    choice. Don’t default to using a list anymore! The difference between using one
    type or another might be the difference between solving the problem or not.
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 通过引入集合和字典，你现在有更多的灵活性来存储你的值。然而，这种灵活性意味着你需要做出选择。不要再默认使用列表了！使用不同类型的数据结构之间的差异，可能会决定你能否解决问题。
- en: We’ve reached an important milestone, as we’ve now covered most of the Python
    that I’ll be teaching you in this book. This doesn’t mean that your Python journey
    is complete. There’s a lot more to know about Python beyond what I’ve included
    in the book. This does mean, though, that we’ve reached a point where we can solve
    a wide variety of problems—in competitive programming or otherwise—with our Python
    skills.
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经达到了一个重要的里程碑，因为我们已经涵盖了本书中我要教授的绝大部分 Python 内容。这并不意味着你的 Python 学习之旅就此完成。Python
    还有很多知识点是本书中没有涉及的。然而，这意味着我们已经达到了一个阶段，我们可以利用我们的 Python 技能解决各种各样的问题——无论是在竞争性编程中，还是其他方面。
- en: 'In the next chapter of the book, we shift gears: from learning new Python features
    to sharpening our problem-solving ability. We’ll focus on one particular type
    of problem that we can solve by searching through all candidate solutions.'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的下一章中，我们将转变方向：从学习新的 Python 特性转向提升我们的问题解决能力。我们将专注于一种特定类型的问题，解决这些问题的方式是通过搜索所有候选解来完成。
- en: Chapter Exercises
  id: totrans-788
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 章节练习
- en: Here are some exercises for you to try. For each, use a set or dictionary. Sometimes,
    a set or dictionary will help you write code that runs faster; other times, it
    will help you write code that’s more organized and easier to read.
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些你可以尝试的练习。对于每个练习，使用集合或字典。有时候，集合或字典可以帮助你写出更快速的代码；有时候，它们也能帮助你写出更有组织且更易读的代码。
- en: DMOJ problem crci06p1, Bard
  id: totrans-790
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ 问题 crci06p1，Bard
- en: DMOJ problem dmopc19c5p1, Conspicuous Cryptic Checklist
  id: totrans-791
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ 问题 dmopc19c5p1，显眼的神秘清单
- en: DMOJ problem coci15c2p1, Marko
  id: totrans-792
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ 问题 coci15c2p1，Marko
- en: DMOJ problem ccc06s2, Attack of the CipherTexts
  id: totrans-793
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ 问题 ccc06s2，加密文本的攻击
- en: DMOJ problem dmopc19c3p1, Mode Finding
  id: totrans-794
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ 问题 dmopc19c3p1，众数查找
- en: 'DMOJ problem coci14c2p2, Utrka (Try solving this one in three different ways:
    using a dictionary, using a set, and using lists!)'
  id: totrans-795
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ 问题 coci14c2p2，Utrka（试着用三种不同的方式来解决这个问题：使用字典、使用集合和使用列表！）
- en: 'DMOJ problem coci17c2p2, ZigZag (Hint: maintain two dictionaries. The first
    maps each starting letter to its list of words; the second maps each starting
    letter to the index of its next word that will be output. That way, we can cycle
    through the words for each letter without having to explicitly update numbers
    of occurrences or modify lists.)'
  id: totrans-796
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ 问题 coci17c2p2，ZigZag（提示：维护两个字典。第一个将每个起始字母映射到其单词列表；第二个将每个起始字母映射到下一个将要输出的单词的索引。通过这种方式，我们可以循环遍历每个字母的单词，而不需要显式更新出现次数或修改列表。）
- en: Notes
  id: totrans-797
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: Email Addresses is originally from the 2019 Educational Computing Organization
    of Ontario Programming Contest, Round 2\. Common Words is originally from the
    1999 Canadian Computing Olympiad. Cities and States is originally from the USACO
    2016 December Silver Contest.
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: Email Addresses 最初来自 2019 年安大略省教育计算组织编程竞赛第 2 轮。Common Words 最初来自 1999 年加拿大计算奥林匹克竞赛。Cities
    and States 最初来自 2016 年美国计算奥林匹克银奖竞赛。
- en: If you’d like to learn more about Python, I recommend *Python Crash Course*,
    2nd edition by Eric Matthes (No Starch Press, 2019). When you’re ready to take
    it to the next level, you might like to read *Effective Python*, 2nd edition by
    Brett Slatkin (Addison-Wesley Professional, 2020), which offers a collection of
    tips to help you write better Python code.
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想深入了解Python，我推荐由Eric Matthes所著的*Python Crash Course*（第二版，No Starch Press，2019）。当你准备好提升自己的技能时，你可能会喜欢阅读由Brett
    Slatkin所著的*Effective Python*（第二版，Addison-Wesley Professional，2020），它提供了一系列技巧，帮助你编写更好的Python代码。
