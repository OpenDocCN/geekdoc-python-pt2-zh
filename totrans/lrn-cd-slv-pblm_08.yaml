- en: '8'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '8'
- en: ORGANIZING VALUES USING SETS AND DICTIONARIES
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用集合和字典组织值
- en: '![image](Images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/common.jpg)'
- en: A Python list is useful whenever we need to store a sequence of values, such
    as the heights of action figures or the words in an essay. Lists make it easy
    for us to keep values in order and access a value given its index. As we’ll see
    in this chapter, though, there are operations that lists are not optimized for,
    including identifying whether a specific value is in a collection and making associations
    between pairs of values.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要存储一系列值时，例如动作人物的高度或文章中的单词时，Python 列表是非常有用的。列表使我们能够轻松保持值的顺序，并根据索引访问某个值。然而，正如我们将在本章中看到的那样，列表并不适合执行一些操作，包括确定一个特定的值是否在集合中以及在一对值之间建立关联。
- en: In this chapter, we’ll learn about Python sets and dictionaries, two alternatives
    to lists for storing collections of values. We’ll see that a set can be the tool
    of choice when we need to search for specific values and don’t care about their
    order and that a dictionary can be the tool of choice whenever we need to work
    with pairs of values.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习 Python 集合和字典，它们是存储值集合的两种替代方案。我们将看到，当我们需要查找特定的值并且不关心它们的顺序时，集合是首选工具；而当我们需要处理一对值时，字典是首选工具。
- en: 'We’ll solve three problems using these new collections: determining the number
    of unique email addresses, finding common words in a list of words, and determining
    the number of special pairs of cities and states.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这些新的集合解决三个问题：确定唯一电子邮件地址的数量、在一组单词中找到公共单词，以及确定一对城市和州的特殊组合数量。
- en: 'Problem #18: Email Addresses'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '问题 #18：电子邮件地址'
- en: In this problem, we’ll store a collection of email addresses. We won’t care
    about the number of times that each email address shows up, and we won’t care
    about maintaining the order of the email addresses. These lax storage requirements
    mean that we can forgo a list for a set—a Python type whose speed leaves lists
    in the dust. We’re going to learn all about sets.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个问题中，我们将存储一组电子邮件地址。我们不关心每个电子邮件地址出现的次数，也不关心电子邮件地址的顺序。这些宽松的存储要求意味着我们可以用集合来替代列表——集合是一种
    Python 类型，它的速度远远超过列表。我们将学习有关集合的一切。
- en: This is DMOJ problem `ecoo19r2p1`.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 DMOJ 问题 `ecoo19r2p1`。
- en: The Challenge
  id: totrans-9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战
- en: Did you know that there are many ways to write someone’s Gmail email address?
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道有很多种方式可以写一个人的 Gmail 地址吗？
- en: We can take someone’s Gmail address and add a plus (`+`) symbol and a string
    before the `@` symbol, and they’ll get any email we send to that new address.
    That is, as far as Gmail addresses are concerned, all characters from a `+` symbol
    to just before the `@` symbol are ignored. For example, I tell people that my
    Gmail address is *[daniel.zingaro@gmail.com](mailto:daniel.zingaro@gmail.com)*,
    but that’s only one way to write it. If you send email to *[daniel.zingaro+book@gmail.com](mailto:daniel.zingaro+book@gmail.com)*
    or *[daniel.zingaro+hi.there@gmail.com](mailto:daniel.zingaro+hi.there@gmail.com)*,
    I’ll get it. (Choose your favorite. Say hi!)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在某人的 Gmail 地址中，在 `@` 符号前加上一个加号（`+`）符号和一个字符串，这样他们就能收到我们发送到那个新地址的任何邮件。也就是说，针对
    Gmail 地址，所有从 `+` 符号到 `@` 符号之前的字符都会被忽略。例如，我告诉别人我的 Gmail 地址是 *[daniel.zingaro@gmail.com](mailto:daniel.zingaro@gmail.com)*，但这只是写法之一。如果你发送邮件到
    *[daniel.zingaro+book@gmail.com](mailto:daniel.zingaro+book@gmail.com)* 或 *[daniel.zingaro+hi.there@gmail.com](mailto:daniel.zingaro+hi.there@gmail.com)*，我也会收到。（选择你喜欢的方式，打个招呼！）
- en: Dots before the `@` symbol are also ignored in Gmail addresses. For example,
    if you send email to *[danielzingaro@gmail.com](mailto:danielzingaro@gmail.com)*
    (no dot at all), *[daniel..zingaro@gmail.com](mailto:daniel..zingaro@gmail.com)*
    (two dots in a row), *[da.nielz.in.gar.o..@gmail.com](mailto:da.nielz.in.gar.o..@gmail.com)*
    (chaotic dots), *[daniel.zin.garo+blah@gmail.com](mailto:daniel.zin.garo+blah@gmail.com)*,
    and so on, I’ll get it.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Gmail 地址中，`@` 符号前的点也会被忽略。例如，如果你发送邮件到 *[danielzingaro@gmail.com](mailto:danielzingaro@gmail.com)*（没有点），*[daniel..zingaro@gmail.com](mailto:daniel..zingaro@gmail.com)*（两个点连在一起），*[da.nielz.in.gar.o..@gmail.com](mailto:da.nielz.in.gar.o..@gmail.com)*（混乱的点），*[daniel.zin.garo+blah@gmail.com](mailto:daniel.zin.garo+blah@gmail.com)*
    等等，我都会收到。
- en: 'Last thing: uppercase and lowercase differences throughout the address are
    ignored. I hope you’re not firing a flurry at me by this point, but I’d get anything
    you send to *[Daniel.Zingaro@gmail.com](mailto:Daniel.Zingaro@gmail.com)*, *[DAnIELZIngARO+Flurry@gmAIL.COM](mailto:DAnIELZIngARO+Flurry@gmAIL.COM)*,
    and so on.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一件事：地址中的大小写差异会被忽略。我希望到此时你没有对我发起一阵攻击，但无论如何，任何发到 *[Daniel.Zingaro@gmail.com](mailto:Daniel.Zingaro@gmail.com)*、
    *[DAnIELZIngARO+Flurry@gmAIL.COM](mailto:DAnIELZIngARO+Flurry@gmAIL.COM)* 等的邮件，我都会收到。
- en: 'In this problem, we’re provided with email addresses, and we’re asked to determine
    the number of them that are unique. The rules for email addresses in this problem
    are the same as those discussed for Gmail: characters from a `+` symbol to just
    before the `@` symbol are ignored, dots before the `@` symbol are ignored, and
    case throughout the entire address is ignored.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个问题中，我们被提供了电子邮件地址，并要求我们确定其中有多少是唯一的。这个问题中电子邮件地址的规则与 Gmail 中讨论的规则相同：从 `+` 符号到
    `@` 符号前的字符会被忽略，`@` 符号前的点会被忽略，整个地址中的大小写会被忽略。
- en: Input
  id: totrans-15
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输入
- en: 'The input consists of 10 test cases. Each test case contains the following
    lines:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 输入包含 10 个测试用例。每个测试用例包含以下行：
- en: A line containing integer *n*, the number of email addresses. *n* is between
    1 and 100,000.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一行包含整数 *n*，表示电子邮件地址的数量。*n* 在 1 和 100,000 之间。
- en: '*n* lines, each of which gives an email address. Each email address consists
    of at least one character before the `@` symbol, followed by the `@` symbol itself,
    followed by at least one character after the `@` symbol. Characters before the
    `@` symbol consist of letters, numbers, dots, and pluses. Characters after the
    `@` symbol consist of letters, numbers, and dots.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*n* 行，每行给出一个电子邮件地址。每个电子邮件地址由 `@` 符号前至少一个字符和 `@` 符号本身，以及 `@` 符号后至少一个字符组成。`@`
    符号前的字符可以是字母、数字、点和加号。`@` 符号后的字符可以是字母、数字和点。'
- en: Output
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输出
- en: For each test case, output the number of unique email addresses.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个测试用例，输出唯一电子邮件地址的数量。
- en: The time limit for solving the test cases is 30 seconds.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 解决测试用例的时间限制是 30 秒。
- en: Using a List
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用列表
- en: You’ve worked through seven chapters of this book. In each one, I posed a problem
    and then taught you new Python features so that you could solve that problem.
    You might therefore expect me to teach you some new Python before solving Email
    Addresses.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学习了本书的七个章节。在每一章中，我提出了一个问题，并教你一些新的 Python 特性，以便你能解决这个问题。因此，你可能会期待我在解决电子邮件地址问题之前，先教你一些新的
    Python 知识。
- en: 'And you might object to that: don’t we already have what we need? After all,
    we can write a function to take an email address and return a clean version, with
    no `+` stuff, no dots before the `@` symbol, and all in lowercase. We can also
    maintain a list of clean email addresses. For each email address that we see,
    we can clean it up and check whether it’s in the list of clean email addresses.
    If it isn’t, then we can add it; if it is, then we do nothing (since it’s already
    being counted). Once we’ve gone through all of the email addresses, the length
    of the list will give us the number of unique email addresses.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会反对这一点：我们难道已经拥有我们需要的东西了吗？毕竟，我们可以写一个函数，接收一个电子邮件地址并返回清理后的版本，去掉 `+` 部分，去掉 `@`
    符号前的点，并且全部小写。我们还可以维护一个清理后的电子邮件地址列表。对于我们看到的每个电子邮件地址，我们可以将其清理并检查它是否已经在清理后的电子邮件地址列表中。如果没有，我们可以将其添加进去；如果已经有了，则什么也不做（因为它已经被计数）。一旦我们处理完所有电子邮件地址，列表的长度将给我们唯一电子邮件地址的数量。
- en: Yes. We may already have what we need. Let’s try solving this thing.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 是的。我们可能已经拥有我们需要的东西。让我们试着解决这个问题。
- en: Cleaning an Email Address
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 清理电子邮件地址
- en: Consider the email address *[DAnIELZIngARO+Flurry@gmAIL.COM](mailto:DAnIELZIngARO+Flurry@gmAIL.COM)*.
    We’re going to clean this email address so that it becomes *[danielzingaro@gmail.com](mailto:danielzingaro@gmail.com)*.
    No +Flurry, no dots before the @ symbol, and all lowercase. We can think of the
    clean version as the true email address. Any other email address that represents
    the same true email address will also match *[danielzingaro@gmail.com](mailto:danielzingaro@gmail.com)*
    once it’s been cleaned.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑电子邮件地址 *[DAnIELZIngARO+Flurry@gmAIL.COM](mailto:DAnIELZIngARO+Flurry@gmAIL.COM)*。我们将清理这个电子邮件地址，使其变成
    *[danielzingaro@gmail.com](mailto:danielzingaro@gmail.com)*。去掉 +Flurry，去掉 @ 符号前的点，并且全部转为小写。我们可以将清理后的版本视为真实的电子邮件地址。任何其他表示相同真实电子邮件地址的邮件地址，在清理后也会匹配
    *[danielzingaro@gmail.com](mailto:danielzingaro@gmail.com)*。
- en: 'Cleaning an email address is a small, self-contained task, so let’s write a
    function for it. This `clean` function will take a string representing an email
    address, clean it up, and return the cleaned email address. We’ll carry out three
    cleaning steps: removing characters from a `+` symbol to just before the `@` symbol,
    removing dots before the `@` symbol, and converting to lowercase. The code for
    this function is in [Listing 8-1](ch08.xhtml#ch08ex01).'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 清理邮箱地址是一个小而独立的任务，所以我们来为此写一个函数。这个 `clean` 函数将接受一个表示邮箱地址的字符串，清理它并返回清理后的邮箱地址。我们将执行三个清理步骤：移除从
    `+` 符号到 `@` 符号之前的字符、去掉 `@` 符号前的点（`.`），以及转换为小写。这个函数的代码在 [Listing 8-1](ch08.xhtml#ch08ex01)
    中。
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 8-1: Cleaning an email address*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 8-1：清理邮箱地址*'
- en: 'The first step is to remove characters from a `+` symbol to just before the
    `@` symbol. The string `find` method is useful here. It returns the index of the
    leftmost occurrence of its argument, or `-1` if the argument isn’t found:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是移除从 `+` 符号到 `@` 符号前的字符。`find` 字符串方法在这里很有用。它返回其参数在字符串中最左侧出现的索引，如果找不到该参数，则返回
    `-1`：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: I use `find` to determine the index of the leftmost `+` symbol ❶. If there is
    no `+` symbol at all, then there’s nothing to do for this step. If there is one,
    however, then we find the index of the `@` symbol ❷ and remove characters from
    the `+` symbol up to but not including the `@` symbol.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用 `find` 方法来确定最左侧的 `+` 符号的索引 ❶。如果没有 `+` 符号，就不需要做这一步。如果有，则我们再查找 `@` 符号的索引 ❷，并从
    `+` 符号到 `@` 符号之间的字符进行删除。
- en: The second step is to remove any dots before the `@` symbol. To do that, I use
    a new string, `before_at`, to accumulate the part of the address before the `@`
    symbol. Each character before the `@` symbol that is not a `.` is added to `before_at`
    ❸.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步是去掉 `@` 符号前的点（`.`）。为此，我使用一个新字符串 `before_at` 来积累 `@` 符号前的部分地址。每个在 `@` 符号前且不是
    `.` 的字符都会被添加到 `before_at` ❸。
- en: The `before_at` string doesn’t include the `@` symbol or any characters following
    it. We don’t want to lose that part of the email address, so I use a new variable,
    `cleaned`, to refer to the whole email address ❹.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`before_at` 字符串不包含 `@` 符号或其后的任何字符。我们不想丢失邮箱地址的这一部分，所以我使用一个新变量 `cleaned` 来表示整个邮箱地址
    ❹。'
- en: The third step is to convert the entire email address to lowercase ❺. After
    that, the email address is clean, so we can return it.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 第三步是将整个邮箱地址转换为小写 ❺。完成后，邮箱地址就被清理干净了，因此我们可以返回它。
- en: 'Let’s test this a little. Enter the code for our `clean` function into the
    Python shell. Here’s the function cleaning a few email addresses:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微测试一下。将 `clean` 函数的代码输入到 Python shell 中。下面是该函数清理几个邮箱地址的过程：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If the email address is already clean, `clean` returns it as is:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果邮箱地址已经是干净的，`clean` 函数就直接返回它：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The Main Program
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 主程序
- en: We can use our `clean` function to clean any email address. The strategy now
    is to maintain a list of clean email addresses. We will add a cleaned email address
    to this list only if it hasn’t been added already. In that way, we’ll avoid adding
    duplicates of the same clean email address.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `clean` 函数清理任何邮箱地址。现在的策略是保持一个清理后的邮箱地址列表。只有当某个清理后的邮箱地址还没有被添加到列表中时，我们才会将其加入。这样，我们就能避免添加重复的邮箱地址。
- en: The main part of our program is in [Listing 8-2](ch08.xhtml#ch08ex02). Be sure
    to enter our `clean` function ([Listing 8-1](ch08.xhtml#ch08ex01)) before this
    code for a complete solution to the problem.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的主要部分在 [Listing 8-2](ch08.xhtml#ch08ex02) 中。在这个代码之前，请确保输入我们的 `clean` 函数代码（[Listing
    8-1](ch08.xhtml#ch08ex01)），以完整解决问题。
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 8-2: Main program, using a list*'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 8-2：主程序，使用列表*'
- en: We have 10 test cases to process, so we surround the rest of the program with
    a range `for` loop that loops 10 times.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有 10 个测试用例需要处理，因此将程序的其余部分放入一个循环中，循环 10 次。
- en: For each test case, we read the number of email addresses and start with an
    empty list of clean email addresses ❶.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个测试用例，我们读取邮箱地址的数量，并从一个空的清理邮箱地址列表开始 ❶。
- en: We then use an inner range `for` loop to loop through each email address. We
    read each email address and clean it. Then, if we haven’t seen this clean email
    address before ❷, we add it to our list of clean email addresses.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用一个内部的 `for` 循环来遍历每个邮箱地址。我们读取每个邮箱地址并清理它。如果这个清理后的邮箱地址之前没有出现过 ❷，我们就把它添加到清理过的邮箱地址列表中。
- en: When the inner loop finishes, we’ll have built up a list of all clean email
    addresses. There are no duplicates in that list. The number of unique email addresses,
    then, is the length of this list, so that’s what we output ❸.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当内层循环结束时，我们将建立一个所有干净电子邮件地址的列表。这个列表中没有重复项。因此，唯一的电子邮件地址数量就是这个列表的长度，这就是我们输出的内容
    ❸。
- en: Not bad, eh? Almost like we could have solved this problem after we learned
    functions in [Chapter 6](ch06.xhtml#ch06). Or, really, after we learned lists
    in [Chapter 5](ch05.xhtml#ch05).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 不错吧？几乎就像我们在[第 6 章](ch06.xhtml#ch06)学到函数后就能解决这个问题。或者，实际上，在我们学习[第 5 章](ch05.xhtml#ch05)的列表后就能解决。
- en: Almost, but not quite. Because if you submit to the judge, you should notice
    that things don’t go according to plan.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 差不多，但还差一点。因为如果你提交给裁判，你应该会注意到事情并没有按计划进行。
- en: The first sign of trouble is that the judge takes a while to show us our results.
    For example, I just waited one minute here for my results to show up. Compare
    that to the other problems we solved earlier, where we received feedback very
    quickly.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 麻烦的第一个迹象是裁判花了一些时间才显示我们的结果。例如，我刚才在这里等待了一分钟，才看到我的结果。相比之前我们解决的其他问题，那里反馈速度非常快。
- en: The second sign of trouble is that when our results do show up, we’re not awarded
    full points for this problem! I’m being given 3.25 points out of 5\. You may receive
    a little more or a little less, but you shouldn’t receive the full 5 points.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 麻烦的第二个迹象是，当我们的结果显示出来时，我们没有为这个问题获得满分！我得到了 3.25 分（满分 5 分）。你可能得到更多或更少的分数，但你不应该得到满分
    5 分。
- en: The reason we’re losing points is not because our program is wrong. Our program
    is fine. No matter the test case, it will output the correct number of unique
    email addresses.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们丢分的原因不是因为程序有错误。我们的程序是正确的。无论测试用例是什么，它都会输出正确的唯一电子邮件地址数量。
- en: So if our program is correct, what’s the problem?
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果我们的程序是正确的，问题出在哪里呢？
- en: The problem is that our program is too slow. The judge lets us know this by
    putting `TLE` at the start of each test case. TLE stands for time limit exceeded.
    For this problem, the judge has allocated 30 seconds to each batch of 10 test
    cases. If our program takes longer than 30 seconds, the judge terminates our program,
    and the remaining test cases in the batch are not allowed to run.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于我们的程序太慢了。裁判通过在每个测试用例前面加上 `TLE` 来告诉我们这一点。TLE 代表超出时间限制。对于这个问题，裁判为每批 10 个测试用例分配了
    30 秒的时间。如果我们的程序超过 30 秒没有完成，裁判会终止程序，剩下的测试用例将无法继续执行。
- en: This may be the first time limit exceeded error you’ve received, though it’s
    possible you’ve seen them as you completed exercises from previous chapters.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是你第一次遇到超出时间限制的错误，尽管在完成之前章节的练习时，你可能也遇到过类似的错误。
- en: The first thing to check when you receive this error is whether your program
    is getting stuck in an infinite loop. If it is, then it’ll never finish, no matter
    the time limit. The judge terminates the program when the allotted time expires.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当你收到这个错误时，首先要检查的是程序是否陷入了无限循环。如果是的话，不管时间限制是多少，它都永远不会结束。裁判会在分配的时间到期时终止程序。
- en: If there’s no infinite loop, then the likely culprit is the *efficiency* of
    our program itself. When programmers talk about efficiency, they’re referring
    to how long it takes the program to run. A program that runs faster (takes less
    time) is more efficient than a program that runs slower (takes more time). To
    solve the test cases within the time limit, we’re going to make our program more
    efficient.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有无限循环，那么可能的罪魁祸首就是我们程序本身的*效率*。当程序员谈论效率时，他们指的是程序运行所需的时间。一个运行得更快（耗时更少）的程序比一个运行得更慢（耗时更多）的程序更高效。为了在时间限制内解决测试用例，我们将使程序更加高效。
- en: Efficiency of Searching a List
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列表搜索的效率
- en: Appending to a Python list is extremely fast. It doesn’t matter whether the
    list has only a few values or many thousands; appending takes the same small amount
    of time.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 向 Python 列表添加元素是非常快的。无论列表中只有几个值还是成千上万个值，添加元素所花的时间都差不多。
- en: Using the `in` operator, however, is a different story. Our program uses the
    `in` operator to determine whether a clean email address is already in our list
    of clean email addresses. A test case might have as many as 100,000 email addresses.
    In the worst case, then, our program could use `in` 100,000 times. It turns out
    that `in` is very slow when used on a list with many values, and this ends up
    hurting our program’s efficiency. To determine whether a value is in the list,
    `in` searches the list from beginning to end, list value by list value. It does
    that until it finds the value it’s looking for, or it runs out of list values
    to check. The more values that `in` has to look through, the slower it is.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用`in`操作符则是另一回事。我们的程序使用`in`操作符来判断一个清洁的电子邮件地址是否已经存在于我们的清洁电子邮件地址列表中。一个测试用例可能包含多达100,000个电子邮件地址。在最坏的情况下，我们的程序可能需要使用`in`操作100,000次。事实证明，当在一个包含许多值的列表上使用`in`时，它非常慢，这最终会影响我们程序的效率。为了判断一个值是否在列表中，`in`会从头到尾逐个值地搜索列表。它会一直搜索，直到找到它正在寻找的值，或者没有更多的列表值可供检查。`in`需要查看的值越多，它的速度就越慢。
- en: Let’s get a feel for the way that `in` slows down as the length of a list increases.
    We’ll use a function that takes a list and a value and uses `in` to search the
    list for the value. It searches for the value 50,000 times; if we searched only
    once, it would be too fast for us to be able to see what’s going on.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解一下随着列表长度增加，`in`操作如何变慢。我们将使用一个函数，该函数接受一个列表和一个值，并使用`in`来搜索列表中的该值。它会搜索50,000次；如果我们只搜索一次，那会太快，我们根本无法看到发生了什么。
- en: The function is in [Listing 8-3](ch08.xhtml#ch08ex03). Enter its code into the
    Python shell.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数位于[清单8-3](ch08.xhtml#ch08ex03)中。将其代码输入到Python shell中。
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 8-3: Searching a collection many times*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单8-3：多次搜索一个集合*'
- en: Let’s create a list of the integers from 1 to 5,000 and search for `5000`. By
    searching for the rightmost value in the list, we make `in` take as much time
    as possible on that list. Don’t worry that we’re exploring this using a list of
    integers rather than a list of email addresses. The efficiency will be similar,
    and numbers are so much easier to generate than email addresses!
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个从1到5,000的整数列表，并搜索`5000`。通过搜索列表中的最右边的值，我们使得`in`在该列表上花费尽可能多的时间。别担心我们用整数列表而不是电子邮件地址列表来进行探索。效率会类似，而且数字比电子邮件地址要容易生成得多！
- en: 'Here goes:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 开始吧：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: On my laptop, this takes about three seconds to run. We don’t need precise timing
    here; we’re just looking for a general picture of what happens as we increase
    the length of the list.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的笔记本上，这大约需要三秒钟来运行。我们不需要精确的计时；我们只是想了解随着列表长度增加，发生了什么情况。
- en: 'Now let’s create a list of the integers from 1 to 10,000 and search for `10000`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个从1到10,000的整数列表，并搜索`10000`：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: On my laptop, that takes about six seconds. As a summary so far, for a list
    of length `5000`, it takes three seconds; double the list length to `10000`, and
    the time doubles, too, to six seconds.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的笔记本上，这大约需要六秒钟。到目前为止的总结是，对于一个长度为`5000`的列表，耗时三秒；将列表长度加倍到`10000`，时间也翻倍，达到了六秒。
- en: 'A list of length `20000`? Give it a try:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一个长度为`20000`的列表？试试看：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This takes about 12 seconds on my laptop.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的笔记本上，这大约需要12秒。
- en: 'The time has doubled again. Try it on a list of length `50000`. You’ll be waiting
    a while. I just ran this on my laptop:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 时间再次翻倍。试试一个长度为`50000`的列表。你需要等一会儿。我刚在我的笔记本上运行了这个：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It took just over 30 seconds. Remember that our `search` function is searching
    the list 50,000 times. So, it’s taking 30 seconds to search a list of length `50000`
    a total of 50,000 times.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 它花了超过30秒。记住，我们的`search`函数正在搜索50,000次列表。所以，它花了30秒来总共搜索一个长度为`50000`的列表50,000次。
- en: We could have a test case that requires this much searching. For example, suppose
    we add 100,000 unique email addresses to our list, one at a time. Halfway through,
    we’ll have a list of 50,000 values; from then on, the remaining 50,000 uses of
    `in` will be on a list of at least 50,000 values.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会有一个需要进行如此多次搜索的测试用例。例如，假设我们将100,000个独特的电子邮件地址一个个添加到我们的列表中。在一半的过程中，我们将有一个包含50,000个值的列表；从那时起，剩下的50,000次`in`操作将会作用于一个至少包含50,000个值的列表。
- en: And that’s only for one of the 10 test cases! We need to get through all 10
    test cases within a total of 30 seconds. If one test case can take about 30 seconds
    on its own, we have no chance.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这仅仅是10个测试用例中的一个！我们需要在30秒内完成所有10个测试用例。如果一个测试用例单独就能花费大约30秒，那我们就没有机会了。
- en: Searching a list is just too slow. The Python list is the wrong type to use.
    We need a type better suited to the job. We need a Python set. You’re not going
    to believe how fast it is to search a set.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 查找列表实在是太慢了。Python 列表并不是适合这个工作的类型。我们需要一个更适合的类型。我们需要一个 Python 集合。你简直不敢相信查找集合是多么的快速。
- en: Sets
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集合
- en: A *set* is a Python type that stores a collection of values, where repeated
    values are not allowed. We use opening and closing curly brackets to delimit the
    set.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*集合*是一个 Python 类型，它存储一组值，其中不允许重复的值。我们使用大括号来限定集合。
- en: 'Unlike a list, a set might not maintain the values in the order you specify.
    Here’s a set of integers:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 与列表不同，集合可能不会保持你指定的顺序。这是一个整数集合：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Notice that Python jumbled the order of the values. You may see the values in
    a different order on your computer. The important point is that you cannot rely
    on any particular order of the values. If order matters to you, a set is not the
    type to use.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 Python 打乱了值的顺序。你可能在你的计算机上看到不同的顺序。关键点是你不能依赖值的任何特定顺序。如果顺序对你很重要，集合就不是合适的类型。
- en: 'If we try to include multiple occurrences of a value, only one occurrence is
    retained:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试包含一个值的多个出现，只有一个会被保留：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Sets are equal if they contain exactly the same values, even if we write them
    in different orders:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是相等的，如果它们包含完全相同的值，即使我们以不同的顺序书写它们：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can create a set of strings, like this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个字符串集合，像这样：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We cannot create a set of lists:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能创建一个包含列表的集合：
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Values in a set must be immutable, which explains why we can’t put lists inside
    a set. The restriction has to do with how Python searches a set for a value. When
    Python adds a value to a set, it uses the value itself to determine where exactly
    it gets stored. Later, Python can find this value by looking in the place where
    it should be located. If a value in the set could change, then Python might look
    in the wrong place, failing to find the value.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 集合中的值必须是不可变的，这解释了为什么我们不能将列表放入集合中。这个限制与 Python 如何在集合中查找值有关。当 Python 向集合中添加一个值时，它使用该值本身来确定它应该存储的位置。后来，Python
    可以通过查看应该存放值的位置来找到它。如果集合中的值可能会改变，Python 可能会在错误的位置查找，导致找不到该值。
- en: 'While we can’t create a set of lists, there’s no problem with a list of sets:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们不能创建一个包含列表的集合，但创建一个包含集合的列表没有问题：
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can use the `len` function to determine the number of values in a set:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `len` 函数来确定集合中值的数量：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You can also loop over the values in a set:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以遍历集合中的值：
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You can’t index or slice a set, though. Values in a set don’t have indices.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你不能对集合进行索引或切片。集合中的值没有索引。
- en: 'To create an empty set, you might expect to use an empty pair of curly brackets,
    `{}`. In an inconsistency of Python syntax, that doesn’t work:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个空集合，你可能会期待使用一个空的大括号`{}`。但在 Python 语法的不一致性中，这样是行不通的：
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Using `{}` gives us the wrong type: a `dict` (dictionary) instead of a `set`.
    We’ll talk about dictionaries later in this chapter.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `{}` 会给我们错误的类型：一个 `dict`（字典），而不是一个 `set`（集合）。我们将在本章稍后讨论字典。
- en: 'To make an empty set, we use `set()`, like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个空集合，我们使用 `set()`，像这样：
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Set Methods
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集合方法
- en: Sets are mutable, so we can add and remove values. We can perform these tasks
    by using methods.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是可变的，因此我们可以添加和删除值。我们可以通过使用方法来执行这些任务。
- en: You can get a list of set methods by using `dir(set())`. And you can get help
    on a specific set method by using `help`, similar to how we use `help` to learn
    about string or list methods. For example, to learn about the `add` method, type
    `help(set().add)`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用 `dir(set())` 获取集合方法的列表。你也可以使用 `help` 获取某个特定集合方法的帮助，类似于我们用 `help` 学习字符串或列表方法。例如，要了解
    `add` 方法，可以输入 `help(set().add)`。
- en: 'The `add` method is what we use to add a value to a set. It’s the analog of
    `append` on lists:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`add` 方法是用来向集合添加一个值的。它类似于列表的 `append` 方法：'
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To remove a value, we use the `remove` method:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除一个值，我们使用 `remove` 方法：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '**CONCEPT CHECK**'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念检查**'
- en: Use `help` to learn about the set `update` and `intersection` methods.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `help` 来了解集合的 `update` 和 `intersection` 方法。
- en: What is output by the call of `print` in the following code?
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码中 `print` 的输出是什么？
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: A. `{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}`
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: A. `{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}`
- en: B. `{1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}`
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: B. `{1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}`
- en: C. `{1, 4, 9}`
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: C. `{1, 4, 9}`
- en: D. `{1, 4, 9, 16, 25}`
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: D. `{1, 4, 9, 16, 25}`
- en: E. `{1}`
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: E. `{1}`
- en: 'Answer: A. The `update` method adds whatever is in set `s2` but is missing
    from set `s1` to set `s1`. After the call of `update`, `s1` is the set `{1, 2,
    3, 4, 5, 6, 7, 8, 9, 10}`.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：A. `update` 方法将集合 `s2` 中存在但 `s1` 中缺少的元素添加到集合 `s1`。在调用 `update` 后，`s1` 就是集合
    `{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}`。
- en: Now for the call of `intersection`. The intersection of two sets is the set
    consisting of the values that are in both sets. Here, the intersection of `s1`
    and `s3` is `{1, 4, 9}`. However, the `intersection` method *does not* modify
    a set; rather, it produces a new set! For that reason, it has no effect on `s1`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来看看 `intersection` 的调用。两个集合的交集是一个包含同时存在于两个集合中的值的新集合。在这里，`s1` 和 `s3` 的交集是 `{1,
    4, 9}`。然而，`intersection` 方法*不会*修改集合；它会生成一个新集合！因此，它对 `s1` 没有影响。
- en: Efficiency of Searching a Set
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 搜索集合的效率
- en: Back to solving Email Addresses.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 回到解决电子邮件地址的问题。
- en: Do we care about the order of our cleaned email addresses? No! All we care about
    is whether an email address is already in there or not.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们关心清理后的电子邮件地址的顺序吗？不关心！我们只关心一个电子邮件地址是否已经存在于其中。
- en: Do we need to allow duplicates in our cleaned email addresses? No again! In
    fact, we want to explicitly avoid storing duplicate email addresses.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在清理后的电子邮件地址中允许重复吗？当然不需要！实际上，我们明确地希望避免存储重复的电子邮件地址。
- en: Order doesn’t matter, and duplicates are not allowed. These are the two ingredients
    that suggest that a set may be the right type to use.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 顺序不重要，且不允许重复。这两点表明集合可能是合适的类型。
- en: We were foiled in our attempt to use a list because searching a list is too
    slow. A set is going to be an improvement for us because we can search a set faster
    than we can search a list.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在尝试使用列表时遇到了困难，因为列表的搜索太慢了。集合将是我们改进的方案，因为我们可以比搜索列表更快地搜索集合。
- en: We’ve already used the `search` function in [Listing 8-3](ch08.xhtml#ch08ex03)
    to search a list. But that function doesn’t do anything that specifically requires
    a list! It uses the `in` operator, and `in` works on both lists and sets. So we
    can use that function, unchanged, to search a set, too.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在 [清单 8-3](ch08.xhtml#ch08ex03) 中使用了 `search` 函数来搜索一个列表。但这个函数并没有做任何特别需要列表的操作！它使用了
    `in` 操作符，而 `in` 同样适用于列表和集合。所以我们可以不做任何修改地将这个函数用来搜索集合。
- en: 'Enter the `search` function from [Listing 8-3](ch08.xhtml#ch08ex03) into the
    Python shell. Follow along on your computer to get a sense of the difference between
    searching a long list and a big set:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python shell 中输入来自 [清单 8-3](ch08.xhtml#ch08ex03) 的 `search` 函数。跟着你的电脑操作，感受一下在长列表和大集合中搜索的区别：
- en: '[PRE23]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: At ❶, I’ve used `set` to produce a set, not a list, of the integers from the
    range.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ❶ 处，我使用 `set` 生成了一个整数集合，而不是列表。
- en: On my laptop, searching the list takes about 30 seconds. Searching the set,
    by comparison, is bullet fast, almost instantaneous.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的笔记本上，搜索列表大约需要30秒。相比之下，搜索集合速度飞快，几乎是瞬间完成。
- en: 'Sets are unstoppable. Don’t try this on a list, but here we go, searching for
    something in a set of 500,000 values:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是不可阻挡的。不要在列表上尝试这种操作，但我们来试试，在一个包含50万个值的集合中搜索某个值：
- en: '[PRE24]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Boom! Piece of cake.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 哗啦！小菜一碟。
- en: 'Python manages a list in such a way as to allow us to use any index at any
    time. Python has no flexibility to mess around with the order of values: the first
    value has to be at index 0, the second at index 1, and so on. But for a set, Python
    can store it in whatever way it wants, because it makes no promises of keeping
    things in order for us. And it’s that increased latitude that allows Python to
    optimize searches in a set for speed.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Python 以某种方式管理列表，允许我们在任何时候使用任何索引。Python 在值的顺序上没有灵活性：第一个值必须在索引0，第二个值在索引1，依此类推。但对于集合，Python
    可以以任何方式存储它，因为它没有承诺保持顺序。这种增加的灵活性使得 Python 能够优化集合中的搜索速度。
- en: 'For similar reasons, there are other operations that are extremely slow on
    large lists but extremely fast on large sets. For example, removing a value from
    a list is very slow, because Python must decrease the index of each value that’s
    to the right of that value. By contrast, removing a value from a set is very fast:
    there are no indices to update!'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 出于类似的原因，某些操作在大列表上非常慢，但在大集合上非常快。例如，从列表中移除一个值非常慢，因为 Python 必须更新该值右侧所有值的索引。相比之下，从集合中移除一个值非常快：因为没有索引需要更新！
- en: Solving the Problem
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决问题
- en: We already have a function to clean an email address ([Listing 8-1](ch08.xhtml#ch08ex01)),
    and we’ll use it in our set-based solution. As for the main program, [Listing
    8-2](ch08.xhtml#ch08ex02) gets us most of the way there. We just need to use a
    set instead of a list.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了一个清理电子邮件地址的函数（[清单 8-1](ch08.xhtml#ch08ex01)），并将在基于集合的解决方案中使用它。至于主程序，[清单
    8-2](ch08.xhtml#ch08ex02)基本上解决了大部分问题。我们只需要用集合替换列表。
- en: The new main program is in [Listing 8-4](ch08.xhtml#ch08ex04). Include [Listing
    8-1](ch08.xhtml#ch08ex01) before this code for a complete solution to the problem.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 新的主程序在 [Listing 8-4](ch08.xhtml#ch08ex04) 中。要完整解决此问题，请在此代码之前包含 [Listing 8-1](ch08.xhtml#ch08ex01)。
- en: '[PRE25]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 8-4: Main program, using a set*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 8-4：主程序，使用集合*'
- en: Notice that we’re now using a set ❶ of email addresses rather than a list. After
    cleaning each email address, we add it to the set using the set `add` method ❷.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们现在使用的是一组电子邮件地址 ❶，而不是列表。在清理每个电子邮件地址后，我们使用集合的 `add` 方法 ❷ 将其添加到集合中。
- en: In [Listing 8-2](ch08.xhtml#ch08ex02), we used the `in` operator to check whether
    an email address is already in the list so that we didn’t add duplicates. There’s
    no corresponding `in` check in our set-based solution. Where did it go? It seems
    that we’re adding each email address to the set without even making sure that
    it’s not already there.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [Listing 8-2](ch08.xhtml#ch08ex02) 中，我们使用 `in` 操作符检查电子邮件地址是否已经存在于列表中，以避免添加重复项。在我们的基于集合的解决方案中，没有相应的
    `in` 检查。它去哪儿了？似乎我们正在将每个电子邮件地址直接添加到集合中，而没有确保它已经存在。
- en: We can get away without the `in` check when using a set because a set never
    contains duplicates. The `add` method handles the `in` check for us, ensuring
    that a duplicate doesn’t get added. You can think of `add` carrying out its own
    `in` check. There’s no timing concern there, because searching a set is so fast.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用集合时，我们可以省略 `in` 检查，因为集合从不包含重复元素。`add` 方法会为我们处理 `in` 检查，确保不会添加重复元素。你可以认为 `add`
    已经执行了自己的 `in` 检查。这里没有时间问题，因为查找集合中的元素非常快。
- en: If you submit this solution to the judge, you should pass all of the test cases
    well within the time limit.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将此解决方案提交给评审员，你应该能够在时间限制内顺利通过所有测试用例。
- en: As you’ve seen here, choosing the appropriate Python type can mean the difference
    between an unsatisfactory solution and a satisfactory one. Before you start writing
    code, ask yourself which operations you’ll be frequently performing and which
    Python type is ideally suited to those operations.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在这里看到的，选择合适的 Python 类型可以决定一个不令人满意的解决方案和一个令人满意的解决方案之间的差异。在开始编写代码之前，问问自己将频繁执行哪些操作，哪些
    Python 类型最适合这些操作。
- en: Before continuing, you might like to try solving exercises 1 and 2 from “Chapter
    Exercises” on [page 236](ch08.xhtml#ch08lev1sec19).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，你可能想尝试解决《章节练习》中的第 1 和第 2 题，见 [第 236 页](ch08.xhtml#ch08lev1sec19)。
- en: 'Problem #19: Common Words'
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '问题 #19：常见单词'
- en: In this problem, we’ll need to associate words with their number of occurrences.
    This is beyond what we can do with sets, so we won’t use sets here. Instead, we’ll
    learn about and use Python dictionaries.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个问题中，我们需要将单词与其出现次数关联起来。这超出了集合所能做到的范围，因此我们不会在这里使用集合。相反，我们将学习并使用 Python 字典。
- en: This is DMOJ problem `cco99p2`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 DMOJ 问题 `cco99p2`。
- en: The Challenge
  id: totrans-157
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战
- en: We are given *m* words. The words are not necessarily distinct; for example,
    the word `brook` could appear multiple times. We are also given an integer *k*.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们给定了 *m* 个单词。这些单词不一定是唯一的；例如，单词 `brook` 可能会出现多次。我们还给定了一个整数 *k*。
- en: Our task is to find the *k*th most common words. A word *w* is a *k*th most
    common word if exactly *k* – 1 distinct words occur more often than does *w*.
    Depending on the dataset, the *k*th most common words could be no words, one word,
    or more than one word.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的任务是找到 *k* 最常见的单词。如果一个单词 *w* 是第 *k* 最常见的单词，则恰好有 *k* - 1 个不同的单词比 *w* 出现得更频繁。根据数据集的不同，*k*
    最常见的单词可能没有单词，可能有一个单词，也可能有多个单词。
- en: Let’s make sure we’re clear on this definition of the *k*th most common words.
    If *k* = 1, then we’re being asked for the words for which exactly 0 words occur
    more often; that is, we’re being asked for the words that occur most often. If
    *k* = 2, then we’re being asked for the words for which exactly 1 word occurs
    more often. If *k* = 3, then we’re being asked for the words for which exactly
    two distinct words occur more often, and so on.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们确保对 *k* 最常见单词的定义有清晰的理解。如果 *k* = 1，那么我们被要求找出那些没有比它出现次数更多的单词；也就是说，我们要找出最常见的单词。如果
    *k* = 2，那么我们被要求找出那些恰好有一个单词比它出现次数更多的单词。如果 *k* = 3，那么我们被要求找出那些恰好有两个不同单词比它出现次数更多的单词，以此类推。
- en: Input
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输入
- en: 'The input contains a line giving the number of test cases, followed by the
    lines of the test cases themselves. Each test case contains the following lines:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 输入包含一行，给出测试用例的数量，接着是测试用例本身的各行。每个测试用例包含以下几行：
- en: A line containing the integers *m* (the number of words in the test case) and
    *k* separated by a space. *m* is between 0 and 1,000; *k* is at least 1.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*m* lines, each of which gives a word. Each word consists of at most 20 characters,
    and all characters are lowercase.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For each test case, output the following lines:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'A line containing the following:'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: where p is `1st` if *k* is 1, `2nd` if *k* is 2, `3rd` if *k* is 3, `4th` if
    *k* is 4, and so on.
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: One line for each of the *k*th most common words. If there are no such words,
    there are no lines of output here.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A blank line.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The time limit for solving the test cases is one second.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Exploring a Test Case
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s start by exploring a test case. It’ll boost our understanding of the problem
    and motivate the use of a new Python type.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that we’re interested in the most common words of all. This means that
    *k* is 1\. Here’s the test case:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The word that shows up most often is `cut`. There are four occurrences of `cut`,
    and no other word has that many occurrences. The correct output is therefore:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Notice the required blank line at the end ❶.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Now, what do we do if *k* were 2? We could answer this by scanning through the
    words again and counting occurrences, but there’s a different way to organize
    the words that would make our task considerably easier. Rather than a list of
    words, let’s look at each word associated with its number of occurrences. See
    [Table 8-1](ch08.xhtml#ch08tab01).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 8-1:** Words and Number of Occurrences'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '| **Word** | **Number of occurrences** |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
- en: '| cut | 4 |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
- en: '| gully | 3 |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
- en: '| storm | 2 |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
- en: '| brook | 2 |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
- en: '| magma | 1 |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
- en: '| cliff | 1 |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
- en: '| blast | 1 |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
- en: I’ve sorted the words based on their number of occurrences. Looking at the top
    row, we can reaffirm that `cut` is the word to output for *k* = 1\. Looking at
    the second row, we see that `gully` is the word to output for *k* = 2\. The word
    `gully` is the only word that has exactly one word with more occurrences.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Now for *k* = 3\. This time, there are *two* words to output, `storm` and `brook`,
    because they both have the same number of occurrences. Each of these words has
    exactly two words with more occurrences. This shows that we sometimes need to
    output more than one word.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: It’s also possible that we need to output zero words! For example, consider
    *k* = 4\. There are *no* words that have exactly three words with more occurrences.
    Looking down the table, you might wonder why we don’t output `magma` for *k* =
    4\. We don’t output `magma`, because `magma` has exactly four words (not exactly
    three words) with more occurrences.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'When *k* = 5, we have three words to output: `magma`, `cliff`, and `blast`.
    Before continuing, verify for yourself that there are no words to output for any
    other value of *k*—no words for *k* = 6, *k* = 7, *k* = 8, *k* = 9, *k* = 100,
    and so on.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 8-1](ch08.xhtml#ch08tab01) simplifies the problem quite a bit for us.
    We’re now going to learn how to organize information like this in Python.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Dictionaries
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *dictionary* is a Python type that stores a mapping from one group of elements,
    called *keys*, to another group of elements, called *values*.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: We use opening and closing curly brackets to delimit the dictionary. Those are
    the same symbols that we use for a set, but Python can tell the difference between
    a set and a dictionary because of what we put inside the curly brackets. For a
    set, we list values; for a dictionary, we list `key:value` pairs.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a dictionary mapping some strings to numbers:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this dictionary, the keys are `'cut'` and `'gully'`, and the values are `4`
    and `3`. The key `'cut'` is mapped to the value `4`, and the key `'gully'` is
    mapped to the value `3`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on our encounters with sets, you might wonder whether dictionaries maintain
    the pairs in the order we enter them. For example, you might wonder whether this
    could happen:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'As of Python 3.7, the answer is no: dictionaries retain the order in which
    you added pairs. In earlier versions of Python, dictionaries did not maintain
    this order, so you could add pairs in one order but get them back in another.
    It’s still a good idea to write code that doesn’t rely on the Python 3.7 behavior,
    though, because older versions of Python are likely to be in use for the foreseeable
    future.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'Dictionaries are equal if they contain the same `key:value` pairs, even if
    we write them in different orders:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Dictionary keys must be unique. If you try to include the same key multiple
    times, only one pair involving that key is retained:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Repeated values, by contrast, are fine:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Keys are required to be immutable values, such as numbers and strings. Values
    can be immutable or mutable. This means that we can’t use a list as a key, but
    we can use a list as a value:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `len` function gives us the number of `key:value` pairs in a dictionary:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To create an empty dictionary, we use `{}`. That’s why we’re stuck with that
    second-rate `set()` syntax to create a set—dictionaries got the nice syntax:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The type is called `dict`, not `dictionary`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: You’ll see “dictionary” and “dict” used interchangeably in Python resources
    and code, but I’ll stick with “dictionary” in this book.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '**CONCEPT CHECK**'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Which of the following is best suited for a dictionary rather than a list or
    set?
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: A. The order in which people finish a race
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: B. The ingredients necessary for a recipe
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: C. The names of countries and their capital cities
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: D. 50 random integers
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer: C. This is the only option that includes a mapping between keys and
    values. Here, the keys could be the countries, and the values could be their capital
    cities.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '**CONCEPT CHECK**'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: What is the type of the values (ignoring the keys) in the following dictionary?
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: A. Integer
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: B. String
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: C. List
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: D. Dictionary
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: E. More than one of the above
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer: D. The value for each key in the dictionary is itself a dictionary.
    For example, the key `''MLB''` is mapped to a dictionary; that dictionary has
    two `key:value` pairs of its own.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Indexing Dictionaries
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can use square brackets to look up the value that a key maps to. It’s similar
    to how we index a list, but with the keys serving as the valid “indices”:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'It’s an error to use a key that doesn’t exist:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We can protect against that error by first using `in` to check whether a key
    is in the dictionary. When used on a dictionary, the `in` operator checks only
    the keys, not the values. Here’s how we can check that a key exists before trying
    to find its value:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Indexing and using `in` on a dictionary are extremely fast operations. They
    don’t require searching any kind of list, no matter how many keys are in the dictionary.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s sometimes more convenient to use the `get` method rather than indexing
    to look up the value for a key. The `get` method never produces an error, even
    if the key doesn’t exist:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: If the key exists, `get` returns its value. Otherwise, it returns `None` to
    signify that the key does not exist.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to looking up the value for a key, we can use square brackets to
    add keys to a dictionary or change the value that a key maps to. Here’s some code
    that shows how to do each of these, starting with an empty dictionary:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '**CONCEPT CHECK**'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Use `help({}.get)` to learn more about the dictionary `get` method.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: What is the output of the following code?
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'A. `{3: 4, 5: 8, 4: 9}`'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'B. `{3: 4, 5: 8, 4: 4}`'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'C. `{3: 4, 5: 4, 4: 3}`'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: D. Error caused by `get`
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer: B. The first call of `get` returns `8`, because key `4` does not exist
    in the dictionary. That line therefore adds key `5` with value `8`.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'The second call of `get` returns `4`: key `3` is in the dictionary already,
    so the second parameter, `9`, is ignored. That line therefore adds key `4` with
    value `4`.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Looping Through Dictionaries
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we use a `for` loop on a dictionary, we get the dictionary’s keys:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We might also want to access the value associated with each key, and we can
    do that by using each key as an index in the dictionary. Here’s a loop that accesses
    both the key and its value:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Dictionaries have methods that let us access the keys, values, or both.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: 'The `keys` method gives us the keys, and the `values` method gives us the values:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'These aren’t lists, but we can pass them to `list` to convert them:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'With the keys available as a list, we can sort the keys and then loop through
    them in sorted order:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We can also loop through the values:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Looping through keys is often preferred over looping through values. It’s easy
    to go from a key to its value. As we’ll see in the next subsection, though, it’s
    not as easy to go from a value back to its key.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: 'One final method that’s relevant here is `items`. It gives us access to both
    the keys and values:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This gives us another way to loop through the `key:value` pairs of a dictionary:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Look carefully at the `pairs` value:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'There’s something fishy here: there are parentheses around each inner value,
    not square brackets. It turns out that this is *not* a list of lists, but a list
    of *tuples*:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Tuples are similar to lists in that they store a sequence of values. The most
    important difference between tuples and lists is that tuples are immutable. You
    can loop over them, index them, and slice them, but you can’t modify them. If
    you try to modify a tuple, you get an error:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'You can create your own tuples using parentheses. For a tuple with a single
    value, we need a trailing comma. For a tuple with multiple values, we don’t:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Tuples have methods—but only a few, because methods that would change a tuple
    are not allowed. I encourage you to learn more about tuples if you’re interested,
    but we won’t use tuples any further in this book.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Inverting a Dictionary
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re close to being able to solve Common Words using dictionaries. Here’s the
    plan. We maintain a dictionary that maps from words to their number of occurrences.
    Whenever we process a word, we check whether that word is already in the dictionary.
    If it isn’t, then we add it with a value of 1\. If it is, then we increase its
    value by 1.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of adding two words, one that we have seen before and one
    that we haven’t:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Dictionaries make it easy to go from a key to a value. For example, given the
    key `''brook''`, we can easily look up the value `1`:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Referring to [Table 8-1](ch08.xhtml#ch08tab01), that’s like going from a word
    in the left column to its number of occurrences in the right column. That doesn’t
    directly tell us the words that have a specified number of occurrences, though.
    What we really need to be able to do is go from the right column to the left,
    from number of occurrences to words. Then we’ll be able to sort the numbers of
    occurrences from most to least to find the words we need.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: 'That is, we need to go from this kind of dictionary:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'to this kind, the *inverted dictionary*:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The original dictionary maps from strings to numbers. The inverted dictionary
    maps from numbers to strings. Well, not quite: the inverted dictionary maps from
    numbers to *lists* of strings. Remember that each key is allowed only once in
    a dictionary. In the inverted dictionary, we need to map each key to multiple
    values, so we store all of those values in a list.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: To invert a dictionary, each key becomes a value, and each value becomes a key.
    If a key doesn’t exist yet in the inverted dictionary, we create a list for its
    value. If a key is already in the inverted dictionary, then we add its value to
    its list.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: We can now write a function to return the inverted version of a dictionary.
    See [Listing 8-5](ch08.xhtml#ch08ex05) for the code.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '*Listing 8-5: Inverting a dictionary*'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: We’re using a `for` loop over the dictionary `d` ❶, which gives us each key.
    We index `d` to obtain the value mapped to by this key ❷. Then we add this `key:value`
    pair to the inverted dictionary. If `num` is not yet a key in the inverted dictionary,
    then we add it and make it map to the associated key in `d` ❸. If `num` is already
    a key in the inverted dictionary, then its value is already a list. We can therefore
    use `append` to add the key from `d` as another value ❹.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the code for our `invert_dictionary` function into the Python shell.
    Let’s give it a try:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Now we’re ready to solve Common Words with an inverted dictionary.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: Solving the Problem
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you’d like more practice with top-down design, you might like to solve the
    problem on your own before continuing. In the interest of space, I won’t follow
    the steps of top-down design here. Rather, I’ll present the solution in its entirety,
    and then we’ll discuss each function and how it is used.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  id: totrans-308
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution is in [Listing 8-6](ch08.xhtml#ch08ex06).
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '*Listing 8-6: Solving Common Words*'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: The first function is `invert_dictionary`. We’ve already discussed that, in
    “Inverting a Dictionary” earlier in this chapter. We’ll now go through each other
    piece of the program.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Suffix
  id: totrans-313
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `with_suffix` function ❶ takes a number and returns a string with the correct
    suffix added to the number. We need this function because of the pesky requirement
    to output *k* with a suffix. For example, if *k* = 1, then we’ll have to produce
    this line as part of the output:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'If *k* = 2, we’ll have to produce this line as part of the output:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: and so on. Our `with_suffix` function makes sure that we add the correct suffix
    to the number. We first convert the number to a string ❷ so that we can easily
    access its digits. Then we use a series of tests to determine whether the suffix
    is `st`, `nd`, `rd`, or `th`. For example, if the last digit is a `1` but the
    last two digits aren’t `11` ❸, then the correct suffix is `st`. That gives us
    `1st`, `21st`, and `31st`, but not `11st` (which would be incorrect).
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: Finding the kth Most Common Words
  id: totrans-319
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `most_common_words` function ❹ is the function that actually finds the words
    that we need. It takes an inverted dictionary (which maps numbers of occurrences
    to lists of words) and an integer `k` and returns a list of the `k`th most common
    words.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how it works, let’s look at a sample inverted dictionary. I’ve organized
    its keys in order from most occurrences to fewest occurrences, as that’s the order
    that `most_common_words` goes through the keys. Here’s the dictionary:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Suppose that `k` is `3`. Therefore, exactly two words must be more common than
    the words that we return. The words we need are not provided by the first dictionary
    key. That key gives us only one word (`cut`), so it can’t be the third most common
    word. Similarly, the words we need are not provided by the second dictionary key.
    That key gives us one more word (`gully`). We’ve processed a total of two words
    now but haven’t found the third most common words yet. The words we need, however,
    *are* provided by the third dictionary key. That key gives us two more words;
    each of these words (`storm` and `brook`) has exactly two words with more occurrences,
    so these are the words for when `k` is `3`.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: What if `k` were `4`? This time, exactly three words must be more common than
    the words that we return. The candidate words are still those from the third key
    (`storm` and `brook`), but there are only two words that occur more often than
    each of these words. There are therefore *no* words for when `k = 4`.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: In summary, we need to total up the words we see when going through the keys
    until we find the key that might contain the words we need. If exactly `k - 1`
    words occur more often, then we have words for `k`; otherwise, we don’t, and there
    are no words to output.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s walk through the code itself. We begin by obtaining a list of the
    dictionary’s keys and sorting them from biggest to smallest. We then loop through
    the keys in that reverse-sorted order ❺. The `done` variable tells us whether
    we’ve looked at `k` or more words yet. As soon as we have ❻, we exit the loop.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: When the loop is done, we check whether there are any words for `k`. If there
    are exactly `k - 1` words that occur more often, and we haven’t gone past the
    end of our keys ❼, then we indeed have words to return. Otherwise, there are no
    words to return, so we return the empty list.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: The Main Program
  id: totrans-328
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now we arrive at the main part of the program ❽. We build dictionary `word_to_num`,
    which maps each word to its number of occurrences. We then build the inverted
    dictionary `num_to_words` ❾, which maps each number of occurrences to the associated
    list of words. Notice how the names of these dictionaries convey the direction
    of mapping: `word_to_num` goes from words to numbers, and `num_to_words` goes
    from numbers to words.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the code calls our other helper functions and outputs the appropriate
    words.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: 'With that, you’re ready to submit to the judge. Well done: that’s the first
    problem that you’ve solved with dictionaries. Whenever you need to map between
    two types of values, think about whether you can organize the information using
    a dictionary. If you can, it’s likely that you’ll be well on your way to an efficient
    solution!'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem #20: Cities and States'
  id: totrans-332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here’s another problem where we’ll be able to use a dictionary. As you read
    the problem description, think about what we could use as the keys and what we
    could use as the values.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: This is USACO 2016 December Silver Contest problem Cities and States.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: The Challenge
  id: totrans-335
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The United States is divided into geographical regions called *states*, each
    of which contains one or more cities. Each state has been given a two-character
    abbreviation. For example, the abbreviation for Pennsylvania is PA, and the abbreviation
    for South Carolina is SC. We’ll write city names and state abbreviations in all
    uppercase.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: Consider the pair of cities `SCRANTON PA` and `PARKER SC`. This pair of cities
    is *special* because the first two characters of each city give the abbreviation
    for the other city’s state. That is, the first two characters of SCRANTON give
    us SC (PARKER’s state), and the first two characters of PARKER give us PA (SCRANTON’s
    state).
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: A pair of cities is *special* if they meet this property and are not in the
    same state.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: Determine the number of special pairs of cities in the provided input.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: Input
  id: totrans-340
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Read input from the file named *citystate.in*.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: 'The input consists of the following lines:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: A line containing *n*, the number of cities. *n* is between 1 and 200,000.
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*n* lines, one per city. Each line gives the name of a city in uppercase, a
    space, and its state’s abbreviation in uppercase. The name of each city is between
    2 and 10 characters; the abbreviation for each state is exactly two characters.
    The same city name can exist in multiple states but will not appear more than
    once in the same state. The name of a city or state in this problem is any string
    that meets these requirements; it might not be the name of an actual US city or
    state.'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output
  id: totrans-345
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write output to the file named *citystate.out*.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: Output the number of special pairs of cities.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: The time limit for solving each test case is four seconds.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: Exploring a Test Case
  id: totrans-349
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Perhaps you’re thinking that you could solve this problem with a list. That’s
    a good thought to have! If you’re interested, I suggest giving that a try before
    continuing. The strategy would be to use two nested loops to consider each pair
    of cities and check whether each pair is special. It’s possible to come up with
    a correct solution using this approach.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: A correct solution, yes, but also a slow one. The list of cities can be huge—up
    to a maximum of 200,000—and any solution involving searching a list for matching
    cities is doomed to be too slow. Let’s explore a test case and work out how a
    dictionary can help.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s our test case:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The first city is `SCRANTON PA`. To find special pairs involving this city,
    we need to find other cities whose name starts with `PA` and whose state is `SC`.
    The only other city that meets this description is `PARKER SC`.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: Notice that all we care about for `SCRANTON PA` is that its name starts with
    `SC` and that its state is `PA`. It could have been called `SCMERWIN PA` or `SCSHOCK
    PA` or `SCHRUTE PA`; it would still be a special pair with `PARKER SC`.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: Let’s refer to the first two characters of a city name followed by the city’s
    state as a *combo*. For example, the combo for `SCRANTON PA` is `SCPA`, and the
    combo for `PARKER SC` is `PASC`.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: Rather than searching for special pairs of cities, we can now look at special
    pairs of combos. Let’s try this.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: There are two cities with the combo `MAMI`. They happen to be `MANISTEE MI`
    and `MADISON MI`, but all we care about is that there are two of them. The `MAMI`
    cities start with `MA` and are in state `MI`. To count up the special pairs involving
    `MAMI` cities, we need to know the cities that start with `MI` and have state
    `MA`. That is, we need to know the number of `MIMA` cities. There are three `MIMA`
    cities. They happen to be `MIDDLEBOROUGH MA`, `MILFORD MA`, and `MIDDLETON MA`,
    but all we care about is that there are three of them. Okay—so we have two `MAMI`
    cities and three `MIMA` cities. The total special pairs for these combos is therefore
    2 * 3 = 6, because for each of the two `MAMI` cities, we have a choice of three
    `MIMA` cities.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re not convinced, here are the six special pairs for these combos:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '`MANISTEE MI` and `MIDDLEBOROUGH MA`'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MANISTEE MI` and `MILFORD MA`'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MANISTEE MI` and `MIDDLETON MA`'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MADISON MI` and `MIDDLEBOROUGH MA`'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MADISON MI` and `MILFORD MA`'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MADISON MI` and `MIDDLETON MA`'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we could map combos—`SCPA`, `PASC`, `MAMI`, `MIMA`, and so on—to the number
    of occurrences, we could loop through the combos to find the number of special
    pairs of cities. A dictionary is the perfect tool to store this mapping.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the dictionary that we’d like to create for our test case:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: With this dictionary, we can figure out the number of special pairs of cities.
    Let’s work through the process.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: The first key is `'SCPA'`; its value is `1`. To find special pairs of cities
    involving `'SCPA'`, we need to look up the value for `'PASC'`. That value is also
    `1`. We multiply the two values together, yielding 1 * 1 = 1 special pair of cities
    involving these combos. We need to carry out this same procedure for each other
    key in the dictionary.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: The next key is `'MAMI'`; its value is `2`. To find special pairs of cities
    involving `'MAMI'`, we need to look up the value for `'MIMA'`. That value is `3`.
    We multiply the two values together, yielding 2 * 3 = 6 special pairs of cities
    involving these combos. With the 1 we found previously, we now have a total of
    7.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: The next key is `'NANH'`; its value is `1`. To find special pairs of cities
    involving `'NANH'`, we need to look up the value for `'NHNA'`. But `'NHNA'` isn’t
    a key in the dictionary! There are no special pairs of cities involving these
    combos. We still have a total of 7.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to this next one. The next key is `''PASC''`; its value
    is `1`. To find special pairs of cities involving `''PASC''`, we need to look
    up the value for `''SCPA''`. That value is also `1`. We multiply the two values
    together, yielding 1 * 1 = 1 special pair of cities involving these combos. But
    wait: we already accounted for this pair when we processed the key `''SCPA''`.
    If we add 1 here, then we’ll end up double-counting this pair. In fact, by processing
    each key we will double-count *every* special pair of cities. Not to worry, though:
    we’ll make an adjustment later when we’re ready to print the final answer. Let’s
    add this 1 in there. With the 7 we found previously, we now have a total of 8.'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: The next key is `'LACO'`; its value is `2`. The value for `'COLA'` is `1`, giving
    2 * 1 = 2 special pairs of cities involving these combos. With the 8 we found
    previously, we now have a total of 10.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: There are two keys to go, `'MIMA'` and `'COLA'`. The first leads us to add 6
    to our total; the second leads us to add 2\. With the 10 we found previously,
    we now have a total of 18.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: Remember that we’ve double-counted every special pair of cities. We don’t have
    18 unique special pairs of cities, then. We have only 18 / 2 = 9 special pairs
    of cities. All we need to do is divide by 2 to undo the double counting.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: If you compare the dictionary we just went through to the cities in the test
    case, you’ll notice that something is missing from the dictionary. It’s that city
    `WASHOUGAL WA`! Its combo is `WAWA`, but there’s no `'WAWA'` key in our dictionary.
    We’re not accounting for this city, and we need to understand why.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: The first two characters of `WASHOUGAL WA` are `WA`. This means that the only
    way for `WASHOUGAL WA` to be part of a special pair of cities is to find another
    city whose state is `WA`. Notice that `WASHOUGAL WA` is in state `WA`, too. However,
    the problem specifies that the two cities in a special pair of cities must come
    from different states. There’s therefore no way to find a special pair of cities
    involving `WASHOUGAL WA`. To make sure we don’t accidentally count fake special
    pairs, we don’t even include `WASHOUGAL WA` in the dictionary.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: Solving the Problem
  id: totrans-379
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re ready to go! We can use a dictionary for a concise, rocket-fast solution
    to Cities and States. The code is in [Listing 8-7](ch08.xhtml#ch08ex07).
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '*Listing 8-7: Solving Cities and States*'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: This is a USACO problem where we need to use files rather than standard input
    and standard output.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: The dictionary that we’ll build is called `combo_to_num` ❶. It maps from four-character
    combos, like `'SCPA'`, to the number of cities with that combo.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: For each city from the input, we use variables to refer to the first two characters
    of the name of the city ❷ and its state. Then, if these values are not the same
    ❸, we combine them and add the combo to the dictionary. If the combo wasn’t already
    in the dictionary, we add it with a value of 1; if it was already there, we increase
    its value by 1.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: The dictionary is now built. We loop through its keys ❹. For each key, we construct
    the other combo that we need to look up to find special pairs of cities involving
    this key. If the key is `'SCPA'`, for example, then we want the other combo to
    be `'PASC'`. To do that, we take the rightmost two characters of the key and follow
    those by the leftmost two characters ❺. If that other combo is also in the dictionary,
    then we multiply the two key’s values and add that to our total ❻.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: All we need to do now is output the total number of special pairs of cities
    to the output file. As explained in the previous section, we need to divide our
    total by 2 ❼ to undo the double-counting that results from processing each key
    in the dictionary.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: 'There we have it: another example of solving a problem with a suitable deployment
    of a dictionary. Feel free to submit our code!'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-389
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we learned about Python sets and dictionaries. A set is a collection
    of values with no order and no duplicates. A dictionary is a collection of `key:value`
    pairs. As we saw in this chapter’s problems, sometimes these collections are more
    appropriate than lists. For example, determining whether a value is in a set is
    ridiculously fast compared to the same operation on a list. If we don’t care about
    the order of values or want to eliminate duplicates, we should seriously consider
    using a set.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, a dictionary makes it easy to determine the value mapped to by a
    key. If we’re maintaining a mapping from keys to values, then we should seriously
    consider using a dictionary.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: With sets and dictionaries in the mix, you now have more flexibility for how
    to store your values. This flexibility, however, means that you need to make a
    choice. Don’t default to using a list anymore! The difference between using one
    type or another might be the difference between solving the problem or not.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: We’ve reached an important milestone, as we’ve now covered most of the Python
    that I’ll be teaching you in this book. This doesn’t mean that your Python journey
    is complete. There’s a lot more to know about Python beyond what I’ve included
    in the book. This does mean, though, that we’ve reached a point where we can solve
    a wide variety of problems—in competitive programming or otherwise—with our Python
    skills.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter of the book, we shift gears: from learning new Python features
    to sharpening our problem-solving ability. We’ll focus on one particular type
    of problem that we can solve by searching through all candidate solutions.'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: Chapter Exercises
  id: totrans-395
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here are some exercises for you to try. For each, use a set or dictionary. Sometimes,
    a set or dictionary will help you write code that runs faster; other times, it
    will help you write code that’s more organized and easier to read.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: DMOJ problem `crci06p1`, Bard
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DMOJ problem `dmopc19c5p1`, Conspicuous Cryptic Checklist
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DMOJ problem `coci15c2p1`, Marko
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DMOJ problem `ccc06s2`, Attack of the CipherTexts
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DMOJ problem `dmopc19c3p1`, Mode Finding
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'DMOJ problem `coci14c2p2`, Utrka (Try solving this one in three different ways:
    using a dictionary, using a set, and using lists!)'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'DMOJ problem `coci17c2p2`, ZigZag (Hint: maintain two dictionaries. The first
    maps each starting letter to its list of words; the second maps each starting
    letter to the index of its next word that will be output. That way, we can cycle
    through the words for each letter without having to explicitly update numbers
    of occurrences or modify lists.)'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notes
  id: totrans-404
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Email Addresses is originally from the 2019 Educational Computing Organization
    of Ontario Programming Contest, Round 2\. Common Words is originally from the
    1999 Canadian Computing Olympiad. Cities and States is originally from the USACO
    2016 December Silver Contest.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: If you’d like to learn more about Python, I recommend *Python Crash Course*,
    2nd edition by Eric Matthes (No Starch Press, 2019). When you’re ready to take
    it to the next level, you might like to read *Effective Python*, 2nd edition by
    Brett Slatkin (Addison-Wesley Professional, 2020), which offers a collection of
    tips to help you write better Python code.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
