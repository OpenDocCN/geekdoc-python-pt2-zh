- en: '8'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ORGANIZING VALUES USING SETS AND DICTIONARIES
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A Python list is useful whenever we need to store a sequence of values, such
    as the heights of action figures or the words in an essay. Lists make it easy
    for us to keep values in order and access a value given its index. As we’ll see
    in this chapter, though, there are operations that lists are not optimized for,
    including identifying whether a specific value is in a collection and making associations
    between pairs of values.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll learn about Python sets and dictionaries, two alternatives
    to lists for storing collections of values. We’ll see that a set can be the tool
    of choice when we need to search for specific values and don’t care about their
    order and that a dictionary can be the tool of choice whenever we need to work
    with pairs of values.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll solve three problems using these new collections: determining the number
    of unique email addresses, finding common words in a list of words, and determining
    the number of special pairs of cities and states.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem #18: Email Addresses'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this problem, we’ll store a collection of email addresses. We won’t care
    about the number of times that each email address shows up, and we won’t care
    about maintaining the order of the email addresses. These lax storage requirements
    mean that we can forgo a list for a set—a Python type whose speed leaves lists
    in the dust. We’re going to learn all about sets.
  prefs: []
  type: TYPE_NORMAL
- en: This is DMOJ problem ecoo19r2p1.
  prefs: []
  type: TYPE_NORMAL
- en: The Challenge
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Did you know that there are many ways to write someone’s Gmail email address?
  prefs: []
  type: TYPE_NORMAL
- en: We can take someone’s Gmail address and add a plus (+) symbol and a string before
    the @ symbol, and they’ll get any email we send to that new address. That is,
    as far as Gmail addresses are concerned, all characters from a + symbol to just
    before the @ symbol are ignored. For example, I tell people that my Gmail address
    is *[daniel.zingaro@gmail.com](mailto:daniel.zingaro@gmail.com)*, but that’s only
    one way to write it. If you send email to *[daniel.zingaro+book@gmail.com](mailto:daniel.zingaro+book@gmail.com)*
    or *[daniel.zingaro+hi.there@gmail.com](mailto:daniel.zingaro+hi.there@gmail.com)*,
    I’ll get it. (Choose your favorite. Say hi!)
  prefs: []
  type: TYPE_NORMAL
- en: Dots before the @ symbol are also ignored in Gmail addresses. For example, if
    you send email to *[danielzingaro@gmail.com](mailto:danielzingaro@gmail.com)*
    (no dot at all), *[daniel..zingaro@gmail.com](mailto:daniel..zingaro@gmail.com)*
    (two dots in a row), *[da.nielz.in.gar.o..@gmail.com](mailto:da.nielz.in.gar.o..@gmail.com)*
    (chaotic dots), *[daniel.zin.garo+blah@gmail.com](mailto:daniel.zin.garo+blah@gmail.com)*,
    and so on, I’ll get it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Last thing: uppercase and lowercase differences throughout the address are
    ignored. I hope you’re not firing a flurry at me by this point, but I’d get anything
    you send to *[Daniel.Zingaro@gmail.com](mailto:Daniel.Zingaro@gmail.com)*, *[DAnIELZIngARO+Flurry@gmAIL.COM](mailto:DAnIELZIngARO+Flurry@gmAIL.COM)*,
    and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this problem, we’re provided with email addresses, and we’re asked to determine
    the number of them that are unique. The rules for email addresses in this problem
    are the same as those discussed for Gmail: characters from a + symbol to just
    before the @ symbol are ignored, dots before the @ symbol are ignored, and case
    throughout the entire address is ignored.'
  prefs: []
  type: TYPE_NORMAL
- en: Input
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The input consists of 10 test cases. Each test case contains the following
    lines:'
  prefs: []
  type: TYPE_NORMAL
- en: A line containing integer *n*, the number of email addresses. *n* is between
    1 and 100,000.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*n* lines, each of which gives an email address. Each email address consists
    of at least one character before the @ symbol, followed by the @ symbol itself,
    followed by at least one character after the @ symbol. Characters before the @
    symbol consist of letters, numbers, dots, and pluses. Characters after the @ symbol
    consist of letters, numbers, and dots.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For each test case, output the number of unique email addresses.
  prefs: []
  type: TYPE_NORMAL
- en: The time limit for solving the test cases is 30 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Using a List
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ve worked through seven chapters of this book. In each one, I posed a problem
    and then taught you new Python features so that you could solve that problem.
    You might therefore expect me to teach you some new Python before solving Email
    Addresses.
  prefs: []
  type: TYPE_NORMAL
- en: 'And you might object to that: don’t we already have what we need? After all,
    we can write a function to take an email address and return a clean version, with
    no + stuff, no dots before the @ symbol, and all in lowercase. We can also maintain
    a list of clean email addresses. For each email address that we see, we can clean
    it up and check whether it’s in the list of clean email addresses. If it isn’t,
    then we can add it; if it is, then we do nothing (since it’s already being counted).
    Once we’ve gone through all of the email addresses, the length of the list will
    give us the number of unique email addresses.'
  prefs: []
  type: TYPE_NORMAL
- en: Yes. We may already have what we need. Let’s try solving this thing.
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning an Email Address
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Consider the email address *[DAnIELZIngARO+Flurry@gmAIL.COM](mailto:DAnIELZIngARO+Flurry@gmAIL.COM)*.
    We’re going to clean this email address so that it becomes *[danielzingaro@gmail.com](mailto:danielzingaro@gmail.com)*.
    No +Flurry, no dots before the @ symbol, and all lowercase. We can think of the
    clean version as the true email address. Any other email address that represents
    the same true email address will also match *[danielzingaro@gmail.com](mailto:danielzingaro@gmail.com)*
    once it’s been cleaned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Cleaning an email address is a small, self-contained task, so let’s write a
    function for it. This clean function will take a string representing an email
    address, clean it up, and return the cleaned email address. We’ll carry out three
    cleaning steps: removing characters from a + symbol to just before the @ symbol,
    removing dots before the @ symbol, and converting to lowercase. The code for this
    function is in [Listing 8-1](ch08.xhtml#ch08ex01).'
  prefs: []
  type: TYPE_NORMAL
- en: 'def clean(address):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: address is a string email address.
  prefs: []
  type: TYPE_NORMAL
- en: Return cleaned address.
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: '# Remove from ''+'' up to but not including ''@'''
  prefs: []
  type: TYPE_NORMAL
- en: ❶ plus_index = address.find('+')
  prefs: []
  type: TYPE_NORMAL
- en: 'if plus_index != -1:'
  prefs: []
  type: TYPE_NORMAL
- en: ❷ at_index = address.find('@')
  prefs: []
  type: TYPE_NORMAL
- en: address = address[:plus_index] + address[at_index:]
  prefs: []
  type: TYPE_NORMAL
- en: '# Remove dots before @ symbol'
  prefs: []
  type: TYPE_NORMAL
- en: at_index = address.find('@')
  prefs: []
  type: TYPE_NORMAL
- en: before_at = ''
  prefs: []
  type: TYPE_NORMAL
- en: i = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'while i < at_index:'
  prefs: []
  type: TYPE_NORMAL
- en: '❸ if address[i] != ''.'':'
  prefs: []
  type: TYPE_NORMAL
- en: before_at = before_at + address[i]
  prefs: []
  type: TYPE_NORMAL
- en: i = i + 1
  prefs: []
  type: TYPE_NORMAL
- en: ❹ cleaned = before_at + address[at_index:]
  prefs: []
  type: TYPE_NORMAL
- en: '# Convert to lowercase'
  prefs: []
  type: TYPE_NORMAL
- en: ❺ cleaned = cleaned.lower()
  prefs: []
  type: TYPE_NORMAL
- en: return cleaned
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 8-1: Cleaning an email address*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to remove characters from a + symbol to just before the @
    symbol. The string find method is useful here. It returns the index of the leftmost
    occurrence of its argument, or -1 if the argument isn’t found:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> ''abc+def''.find(''+'')'
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> ''abcdef''.find(''+'')'
  prefs: []
  type: TYPE_NORMAL
- en: '-1'
  prefs: []
  type: TYPE_NORMAL
- en: I use find to determine the index of the leftmost + symbol ❶. If there is no
    + symbol at all, then there’s nothing to do for this step. If there is one, however,
    then we find the index of the @ symbol ❷ and remove characters from the + symbol
    up to but not including the @ symbol.
  prefs: []
  type: TYPE_NORMAL
- en: The second step is to remove any dots before the @ symbol. To do that, I use
    a new string, before_at, to accumulate the part of the address before the @ symbol.
    Each character before the @ symbol that is not a . is added to before_at ❸.
  prefs: []
  type: TYPE_NORMAL
- en: The before_at string doesn’t include the @ symbol or any characters following
    it. We don’t want to lose that part of the email address, so I use a new variable,
    cleaned, to refer to the whole email address ❹.
  prefs: []
  type: TYPE_NORMAL
- en: The third step is to convert the entire email address to lowercase ❺. After
    that, the email address is clean, so we can return it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s test this a little. Enter the code for our clean function into the Python
    shell. Here’s the function cleaning a few email addresses:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> clean(''daniel.zingaro+book@gmail.com'')'
  prefs: []
  type: TYPE_NORMAL
- en: '''danielzingaro@gmail.com'''
  prefs: []
  type: TYPE_NORMAL
- en: '>>> clean(''da.nielz.in.gar.o..@gmail.com'')'
  prefs: []
  type: TYPE_NORMAL
- en: '''danielzingaro@gmail.com'''
  prefs: []
  type: TYPE_NORMAL
- en: '>>> clean(''DAnIELZIngARO+Flurry@gmAIL.COM'')'
  prefs: []
  type: TYPE_NORMAL
- en: '''danielzingaro@gmail.com'''
  prefs: []
  type: TYPE_NORMAL
- en: '>>> clean(''a.b.c@d.e.f'')'
  prefs: []
  type: TYPE_NORMAL
- en: '''abc@d.e.f'''
  prefs: []
  type: TYPE_NORMAL
- en: 'If the email address is already clean, clean returns it as is:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> clean(''danielzingaro@gmail.com'')'
  prefs: []
  type: TYPE_NORMAL
- en: '''danielzingaro@gmail.com'''
  prefs: []
  type: TYPE_NORMAL
- en: The Main Program
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We can use our clean function to clean any email address. The strategy now is
    to maintain a list of clean email addresses. We will add a cleaned email address
    to this list only if it hasn’t been added already. In that way, we’ll avoid adding
    duplicates of the same clean email address.
  prefs: []
  type: TYPE_NORMAL
- en: The main part of our program is in [Listing 8-2](ch08.xhtml#ch08ex02). Be sure
    to enter our clean function ([Listing 8-1](ch08.xhtml#ch08ex01)) before this code
    for a complete solution to the problem.
  prefs: []
  type: TYPE_NORMAL
- en: Main Program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'for dataset in range(10):'
  prefs: []
  type: TYPE_NORMAL
- en: n = int(input())
  prefs: []
  type: TYPE_NORMAL
- en: ❶ addresses = []
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(n):'
  prefs: []
  type: TYPE_NORMAL
- en: address = input()
  prefs: []
  type: TYPE_NORMAL
- en: address = clean(address)
  prefs: []
  type: TYPE_NORMAL
- en: '❷ if not address in addresses:'
  prefs: []
  type: TYPE_NORMAL
- en: addresses.append(address)
  prefs: []
  type: TYPE_NORMAL
- en: ❸ print(len(addresses))
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 8-2: Main program, using a list*'
  prefs: []
  type: TYPE_NORMAL
- en: We have 10 test cases to process, so we surround the rest of the program with
    a range for loop that loops 10 times.
  prefs: []
  type: TYPE_NORMAL
- en: For each test case, we read the number of email addresses and start with an
    empty list of clean email addresses ❶.
  prefs: []
  type: TYPE_NORMAL
- en: We then use an inner range for loop to loop through each email address. We read
    each email address and clean it. Then, if we haven’t seen this clean email address
    before ❷, we add it to our list of clean email addresses.
  prefs: []
  type: TYPE_NORMAL
- en: When the inner loop finishes, we’ll have built up a list of all clean email
    addresses. There are no duplicates in that list. The number of unique email addresses,
    then, is the length of this list, so that’s what we output ❸.
  prefs: []
  type: TYPE_NORMAL
- en: Not bad, eh? Almost like we could have solved this problem after we learned
    functions in [Chapter 6](ch06.xhtml#ch06). Or, really, after we learned lists
    in [Chapter 5](ch05.xhtml#ch05).
  prefs: []
  type: TYPE_NORMAL
- en: Almost, but not quite. Because if you submit to the judge, you should notice
    that things don’t go according to plan.
  prefs: []
  type: TYPE_NORMAL
- en: The first sign of trouble is that the judge takes a while to show us our results.
    For example, I just waited one minute here for my results to show up. Compare
    that to the other problems we solved earlier, where we received feedback very
    quickly.
  prefs: []
  type: TYPE_NORMAL
- en: The second sign of trouble is that when our results do show up, we’re not awarded
    full points for this problem! I’m being given 3.25 points out of 5\. You may receive
    a little more or a little less, but you shouldn’t receive the full 5 points.
  prefs: []
  type: TYPE_NORMAL
- en: The reason we’re losing points is not because our program is wrong. Our program
    is fine. No matter the test case, it will output the correct number of unique
    email addresses.
  prefs: []
  type: TYPE_NORMAL
- en: So if our program is correct, what’s the problem?
  prefs: []
  type: TYPE_NORMAL
- en: The problem is that our program is too slow. The judge lets us know this by
    putting TLE at the start of each test case. TLE stands for time limit exceeded.
    For this problem, the judge has allocated 30 seconds to each batch of 10 test
    cases. If our program takes longer than 30 seconds, the judge terminates our program,
    and the remaining test cases in the batch are not allowed to run.
  prefs: []
  type: TYPE_NORMAL
- en: This may be the first time limit exceeded error you’ve received, though it’s
    possible you’ve seen them as you completed exercises from previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing to check when you receive this error is whether your program
    is getting stuck in an infinite loop. If it is, then it’ll never finish, no matter
    the time limit. The judge terminates the program when the allotted time expires.
  prefs: []
  type: TYPE_NORMAL
- en: If there’s no infinite loop, then the likely culprit is the *efficiency* of
    our program itself. When programmers talk about efficiency, they’re referring
    to how long it takes the program to run. A program that runs faster (takes less
    time) is more efficient than a program that runs slower (takes more time). To
    solve the test cases within the time limit, we’re going to make our program more
    efficient.
  prefs: []
  type: TYPE_NORMAL
- en: Efficiency of Searching a List
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Appending to a Python list is extremely fast. It doesn’t matter whether the
    list has only a few values or many thousands; appending takes the same small amount
    of time.
  prefs: []
  type: TYPE_NORMAL
- en: Using the in operator, however, is a different story. Our program uses the in
    operator to determine whether a clean email address is already in our list of
    clean email addresses. A test case might have as many as 100,000 email addresses.
    In the worst case, then, our program could use in 100,000 times. It turns out
    that in is very slow when used on a list with many values, and this ends up hurting
    our program’s efficiency. To determine whether a value is in the list, in searches
    the list from beginning to end, list value by list value. It does that until it
    finds the value it’s looking for, or it runs out of list values to check. The
    more values that in has to look through, the slower it is.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s get a feel for the way that in slows down as the length of a list increases.
    We’ll use a function that takes a list and a value and uses in to search the list
    for the value. It searches for the value 50,000 times; if we searched only once,
    it would be too fast for us to be able to see what’s going on.
  prefs: []
  type: TYPE_NORMAL
- en: The function is in [Listing 8-3](ch08.xhtml#ch08ex03). Enter its code into the
    Python shell.
  prefs: []
  type: TYPE_NORMAL
- en: 'def search(collection, value):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: search many times for value in collection.
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(50000):'
  prefs: []
  type: TYPE_NORMAL
- en: found = value in collection
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 8-3: Searching a collection many times*'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create a list of the integers from 1 to 5,000 and search for 5000. By
    searching for the rightmost value in the list, we make in take as much time as
    possible on that list. Don’t worry that we’re exploring this using a list of integers
    rather than a list of email addresses. The efficiency will be similar, and numbers
    are so much easier to generate than email addresses!
  prefs: []
  type: TYPE_NORMAL
- en: 'Here goes:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> search(list(range(1, 5001)), 5000)'
  prefs: []
  type: TYPE_NORMAL
- en: On my laptop, this takes about three seconds to run. We don’t need precise timing
    here; we’re just looking for a general picture of what happens as we increase
    the length of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s create a list of the integers from 1 to 10,000 and search for 10000:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> search(list(range(1, 10001)), 10000)'
  prefs: []
  type: TYPE_NORMAL
- en: On my laptop, that takes about six seconds. As a summary so far, for a list
    of length 5000, it takes three seconds; double the list length to 10000, and the
    time doubles, too, to six seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'A list of length 20000? Give it a try:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> search(list(range(1, 20001)), 20000)'
  prefs: []
  type: TYPE_NORMAL
- en: This takes about 12 seconds on my laptop.
  prefs: []
  type: TYPE_NORMAL
- en: 'The time has doubled again. Try it on a list of length 50000. You’ll be waiting
    a while. I just ran this on my laptop:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> search(list(range(1, 50001)), 50000)'
  prefs: []
  type: TYPE_NORMAL
- en: It took just over 30 seconds. Remember that our search function is searching
    the list 50,000 times. So, it’s taking 30 seconds to search a list of length 50000
    a total of 50,000 times.
  prefs: []
  type: TYPE_NORMAL
- en: We could have a test case that requires this much searching. For example, suppose
    we add 100,000 unique email addresses to our list, one at a time. Halfway through,
    we’ll have a list of 50,000 values; from then on, the remaining 50,000 uses of
    in will be on a list of at least 50,000 values.
  prefs: []
  type: TYPE_NORMAL
- en: And that’s only for one of the 10 test cases! We need to get through all 10
    test cases within a total of 30 seconds. If one test case can take about 30 seconds
    on its own, we have no chance.
  prefs: []
  type: TYPE_NORMAL
- en: Searching a list is just too slow. The Python list is the wrong type to use.
    We need a type better suited to the job. We need a Python set. You’re not going
    to believe how fast it is to search a set.
  prefs: []
  type: TYPE_NORMAL
- en: Sets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *set* is a Python type that stores a collection of values, where repeated
    values are not allowed. We use opening and closing curly brackets to delimit the
    set.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike a list, a set might not maintain the values in the order you specify.
    Here’s a set of integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> {13, 15, 30, 45, 61}'
  prefs: []
  type: TYPE_NORMAL
- en: '{45, 13, 15, 61, 30}'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that Python jumbled the order of the values. You may see the values in
    a different order on your computer. The important point is that you cannot rely
    on any particular order of the values. If order matters to you, a set is not the
    type to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we try to include multiple occurrences of a value, only one occurrence is
    retained:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> {1, 1, 3, 2, 3, 1, 3, 3, 3}'
  prefs: []
  type: TYPE_NORMAL
- en: '{1, 2, 3}'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sets are equal if they contain exactly the same values, even if we write them
    in different orders:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> {1, 2, 3} == {1, 2, 3}'
  prefs: []
  type: TYPE_NORMAL
- en: 'True'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> {1, 1, 3, 2, 3, 1, 3, 3, 3} == {1, 2, 3}'
  prefs: []
  type: TYPE_NORMAL
- en: 'True'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> {1, 2} == {1, 2, 3}'
  prefs: []
  type: TYPE_NORMAL
- en: 'False'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a set of strings, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> {''abc@d.e.f'', ''danielzingaro@gmail.com''}'
  prefs: []
  type: TYPE_NORMAL
- en: '{''abc@d.e.f'', ''danielzingaro@gmail.com''}'
  prefs: []
  type: TYPE_NORMAL
- en: 'We cannot create a set of lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> {[1, 2], [3, 4]}'
  prefs: []
  type: TYPE_NORMAL
- en: 'Traceback (most recent call last):'
  prefs: []
  type: TYPE_NORMAL
- en: File "<stdin>", line 1, in <module>
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeError: unhashable type: ''list'''
  prefs: []
  type: TYPE_NORMAL
- en: Values in a set must be immutable, which explains why we can’t put lists inside
    a set. The restriction has to do with how Python searches a set for a value. When
    Python adds a value to a set, it uses the value itself to determine where exactly
    it gets stored. Later, Python can find this value by looking in the place where
    it should be located. If a value in the set could change, then Python might look
    in the wrong place, failing to find the value.
  prefs: []
  type: TYPE_NORMAL
- en: 'While we can’t create a set of lists, there’s no problem with a list of sets:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> lst = [{1, 2, 3}, {4, 5, 6}]'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> lst'
  prefs: []
  type: TYPE_NORMAL
- en: '[{1, 2, 3}, {4, 5, 6}]'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> len(lst)'
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> lst[0]'
  prefs: []
  type: TYPE_NORMAL
- en: '{1, 2, 3}'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the len function to determine the number of values in a set:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> len({2, 4, 6, 8})'
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also loop over the values in a set:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> for value in {2, 4, 6, 8}:'
  prefs: []
  type: TYPE_NORMAL
- en: '...     print(''I found'', value)'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: I found 8
  prefs: []
  type: TYPE_NORMAL
- en: I found 2
  prefs: []
  type: TYPE_NORMAL
- en: I found 4
  prefs: []
  type: TYPE_NORMAL
- en: I found 6
  prefs: []
  type: TYPE_NORMAL
- en: You can’t index or slice a set, though. Values in a set don’t have indices.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an empty set, you might expect to use an empty pair of curly brackets,
    {}. In an inconsistency of Python syntax, that doesn’t work:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> type({2, 4, 6, 8})'
  prefs: []
  type: TYPE_NORMAL
- en: <class 'set'>
  prefs: []
  type: TYPE_NORMAL
- en: '>>> {}'
  prefs: []
  type: TYPE_NORMAL
- en: '{}'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> type({})'
  prefs: []
  type: TYPE_NORMAL
- en: <class 'dict'>
  prefs: []
  type: TYPE_NORMAL
- en: 'Using {} gives us the wrong type: a dict (dictionary) instead of a set. We’ll
    talk about dictionaries later in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To make an empty set, we use set(), like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> set()'
  prefs: []
  type: TYPE_NORMAL
- en: set()
  prefs: []
  type: TYPE_NORMAL
- en: '>>> type(set())'
  prefs: []
  type: TYPE_NORMAL
- en: <class 'set'>
  prefs: []
  type: TYPE_NORMAL
- en: Set Methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sets are mutable, so we can add and remove values. We can perform these tasks
    by using methods.
  prefs: []
  type: TYPE_NORMAL
- en: You can get a list of set methods by using dir(set()). And you can get help
    on a specific set method by using help, similar to how we use help to learn about
    string or list methods. For example, to learn about the add method, type help(set().add).
  prefs: []
  type: TYPE_NORMAL
- en: 'The add method is what we use to add a value to a set. It’s the analog of append
    on lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> s = set()'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> s'
  prefs: []
  type: TYPE_NORMAL
- en: set()
  prefs: []
  type: TYPE_NORMAL
- en: '>>> s.add(2)'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> s'
  prefs: []
  type: TYPE_NORMAL
- en: '{2}'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> s.add(4)'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> s'
  prefs: []
  type: TYPE_NORMAL
- en: '{2, 4}'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> s.add(6)'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> s'
  prefs: []
  type: TYPE_NORMAL
- en: '{2, 4, 6}'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> s.add(8)'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> s'
  prefs: []
  type: TYPE_NORMAL
- en: '{8, 2, 4, 6}'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> s.add(8)'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> s'
  prefs: []
  type: TYPE_NORMAL
- en: '{8, 2, 4, 6}'
  prefs: []
  type: TYPE_NORMAL
- en: 'To remove a value, we use the remove method:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> s.remove(4)'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> s'
  prefs: []
  type: TYPE_NORMAL
- en: '{8, 2, 6}'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> s.remove(8)'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> s'
  prefs: []
  type: TYPE_NORMAL
- en: '{2, 6}'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> s = {2, 6}'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> s.remove(8)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Traceback (most recent call last):'
  prefs: []
  type: TYPE_NORMAL
- en: File "<stdin>", line 1, in <module>
  prefs: []
  type: TYPE_NORMAL
- en: 'KeyError: 8'
  prefs: []
  type: TYPE_NORMAL
- en: '**CONCEPT CHECK**'
  prefs: []
  type: TYPE_NORMAL
- en: Use help to learn about the set update and intersection methods.
  prefs: []
  type: TYPE_NORMAL
- en: What is output by the call of print in the following code?
  prefs: []
  type: TYPE_NORMAL
- en: s1 = {1, 3, 5, 7, 9}
  prefs: []
  type: TYPE_NORMAL
- en: s2 = {1, 2, 4, 6, 8, 10}
  prefs: []
  type: TYPE_NORMAL
- en: s3 = {1, 4, 9, 16, 25}
  prefs: []
  type: TYPE_NORMAL
- en: s1.update(s2)
  prefs: []
  type: TYPE_NORMAL
- en: s1.intersection(s3)
  prefs: []
  type: TYPE_NORMAL
- en: print(s1)
  prefs: []
  type: TYPE_NORMAL
- en: A. {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
  prefs: []
  type: TYPE_NORMAL
- en: B. {1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
  prefs: []
  type: TYPE_NORMAL
- en: C. {1, 4, 9}
  prefs: []
  type: TYPE_NORMAL
- en: D. {1, 4, 9, 16, 25}
  prefs: []
  type: TYPE_NORMAL
- en: E. {1}
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer: A. The update method adds whatever is in set s2 but is missing from
    set s1 to set s1. After the call of update, s1 is the set {1, 2, 3, 4, 5, 6, 7,
    8, 9, 10}.'
  prefs: []
  type: TYPE_NORMAL
- en: Now for the call of intersection. The intersection of two sets is the set consisting
    of the values that are in both sets. Here, the intersection of s1 and s3 is {1,
    4, 9}. However, the intersection method *does not* modify a set; rather, it produces
    a new set! For that reason, it has no effect on s1.
  prefs: []
  type: TYPE_NORMAL
- en: Efficiency of Searching a Set
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Back to solving Email Addresses.
  prefs: []
  type: TYPE_NORMAL
- en: Do we care about the order of our cleaned email addresses? No! All we care about
    is whether an email address is already in there or not.
  prefs: []
  type: TYPE_NORMAL
- en: Do we need to allow duplicates in our cleaned email addresses? No again! In
    fact, we want to explicitly avoid storing duplicate email addresses.
  prefs: []
  type: TYPE_NORMAL
- en: Order doesn’t matter, and duplicates are not allowed. These are the two ingredients
    that suggest that a set may be the right type to use.
  prefs: []
  type: TYPE_NORMAL
- en: We were foiled in our attempt to use a list because searching a list is too
    slow. A set is going to be an improvement for us because we can search a set faster
    than we can search a list.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve already used the search function in [Listing 8-3](ch08.xhtml#ch08ex03)
    to search a list. But that function doesn’t do anything that specifically requires
    a list! It uses the in operator, and in works on both lists and sets. So we can
    use that function, unchanged, to search a set, too.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the search function from [Listing 8-3](ch08.xhtml#ch08ex03) into the
    Python shell. Follow along on your computer to get a sense of the difference between
    searching a long list and a big set:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> search(list(range(1, 50001)), 50000)'
  prefs: []
  type: TYPE_NORMAL
- en: ❶ >>> search(set(range(1, 50001)), 50000)
  prefs: []
  type: TYPE_NORMAL
- en: At ❶, I’ve used set to produce a set, not a list, of the integers from the range.
  prefs: []
  type: TYPE_NORMAL
- en: On my laptop, searching the list takes about 30 seconds. Searching the set,
    by comparison, is bullet fast, almost instantaneous.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sets are unstoppable. Don’t try this on a list, but here we go, searching for
    something in a set of 500,000 values:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> search(set(range(1, 500001)), 500000)'
  prefs: []
  type: TYPE_NORMAL
- en: Boom! Piece of cake.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python manages a list in such a way as to allow us to use any index at any
    time. Python has no flexibility to mess around with the order of values: the first
    value has to be at index 0, the second at index 1, and so on. But for a set, Python
    can store it in whatever way it wants, because it makes no promises of keeping
    things in order for us. And it’s that increased latitude that allows Python to
    optimize searches in a set for speed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For similar reasons, there are other operations that are extremely slow on
    large lists but extremely fast on large sets. For example, removing a value from
    a list is very slow, because Python must decrease the index of each value that’s
    to the right of that value. By contrast, removing a value from a set is very fast:
    there are no indices to update!'
  prefs: []
  type: TYPE_NORMAL
- en: Solving the Problem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We already have a function to clean an email address ([Listing 8-1](ch08.xhtml#ch08ex01)),
    and we’ll use it in our set-based solution. As for the main program, [Listing
    8-2](ch08.xhtml#ch08ex02) gets us most of the way there. We just need to use a
    set instead of a list.
  prefs: []
  type: TYPE_NORMAL
- en: The new main program is in [Listing 8-4](ch08.xhtml#ch08ex04). Include [Listing
    8-1](ch08.xhtml#ch08ex01) before this code for a complete solution to the problem.
  prefs: []
  type: TYPE_NORMAL
- en: Main Program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'for dataset in range(10):'
  prefs: []
  type: TYPE_NORMAL
- en: n = int(input())
  prefs: []
  type: TYPE_NORMAL
- en: ❶ addresses = set()
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(n):'
  prefs: []
  type: TYPE_NORMAL
- en: address = input()
  prefs: []
  type: TYPE_NORMAL
- en: address = clean(address)
  prefs: []
  type: TYPE_NORMAL
- en: ❷ addresses.add(address)
  prefs: []
  type: TYPE_NORMAL
- en: print(len(addresses))
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 8-4: Main program, using a set*'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’re now using a set ❶ of email addresses rather than a list. After
    cleaning each email address, we add it to the set using the set add method ❷.
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 8-2](ch08.xhtml#ch08ex02), we used the in operator to check whether
    an email address is already in the list so that we didn’t add duplicates. There’s
    no corresponding in check in our set-based solution. Where did it go? It seems
    that we’re adding each email address to the set without even making sure that
    it’s not already there.
  prefs: []
  type: TYPE_NORMAL
- en: We can get away without the in check when using a set because a set never contains
    duplicates. The add method handles the in check for us, ensuring that a duplicate
    doesn’t get added. You can think of add carrying out its own in check. There’s
    no timing concern there, because searching a set is so fast.
  prefs: []
  type: TYPE_NORMAL
- en: If you submit this solution to the judge, you should pass all of the test cases
    well within the time limit.
  prefs: []
  type: TYPE_NORMAL
- en: As you’ve seen here, choosing the appropriate Python type can mean the difference
    between an unsatisfactory solution and a satisfactory one. Before you start writing
    code, ask yourself which operations you’ll be frequently performing and which
    Python type is ideally suited to those operations.
  prefs: []
  type: TYPE_NORMAL
- en: Before continuing, you might like to try solving exercises 1 and 2 from “Chapter
    Exercises” on [page 236](ch08.xhtml#ch08lev1sec19).
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem #19: Common Words'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this problem, we’ll need to associate words with their number of occurrences.
    This is beyond what we can do with sets, so we won’t use sets here. Instead, we’ll
    learn about and use Python dictionaries.
  prefs: []
  type: TYPE_NORMAL
- en: This is DMOJ problem cco99p2.
  prefs: []
  type: TYPE_NORMAL
- en: The Challenge
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We are given *m* words. The words are not necessarily distinct; for example,
    the word brook could appear multiple times. We are also given an integer *k*.
  prefs: []
  type: TYPE_NORMAL
- en: Our task is to find the *k*th most common words. A word *w* is a *k*th most
    common word if exactly *k* – 1 distinct words occur more often than does *w*.
    Depending on the dataset, the *k*th most common words could be no words, one word,
    or more than one word.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s make sure we’re clear on this definition of the *k*th most common words.
    If *k* = 1, then we’re being asked for the words for which exactly 0 words occur
    more often; that is, we’re being asked for the words that occur most often. If
    *k* = 2, then we’re being asked for the words for which exactly 1 word occurs
    more often. If *k* = 3, then we’re being asked for the words for which exactly
    two distinct words occur more often, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Input
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The input contains a line giving the number of test cases, followed by the
    lines of the test cases themselves. Each test case contains the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: A line containing the integers *m* (the number of words in the test case) and
    *k* separated by a space. *m* is between 0 and 1,000; *k* is at least 1.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*m* lines, each of which gives a word. Each word consists of at most 20 characters,
    and all characters are lowercase.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For each test case, output the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A line containing the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'p most common word(s):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: where p is 1st if *k* is 1, 2nd if *k* is 2, 3rd if *k* is 3, 4th if *k* is
    4, and so on.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: One line for each of the *k*th most common words. If there are no such words,
    there are no lines of output here.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A blank line.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The time limit for solving the test cases is one second.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring a Test Case
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s start by exploring a test case. It’ll boost our understanding of the problem
    and motivate the use of a new Python type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that we’re interested in the most common words of all. This means that
    *k* is 1\. Here’s the test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: 14 1
  prefs: []
  type: TYPE_NORMAL
- en: storm
  prefs: []
  type: TYPE_NORMAL
- en: cut
  prefs: []
  type: TYPE_NORMAL
- en: magma
  prefs: []
  type: TYPE_NORMAL
- en: cut
  prefs: []
  type: TYPE_NORMAL
- en: brook
  prefs: []
  type: TYPE_NORMAL
- en: gully
  prefs: []
  type: TYPE_NORMAL
- en: gully
  prefs: []
  type: TYPE_NORMAL
- en: storm
  prefs: []
  type: TYPE_NORMAL
- en: cliff
  prefs: []
  type: TYPE_NORMAL
- en: cut
  prefs: []
  type: TYPE_NORMAL
- en: blast
  prefs: []
  type: TYPE_NORMAL
- en: brook
  prefs: []
  type: TYPE_NORMAL
- en: cut
  prefs: []
  type: TYPE_NORMAL
- en: gully
  prefs: []
  type: TYPE_NORMAL
- en: 'The word that shows up most often is cut. There are four occurrences of cut,
    and no other word has that many occurrences. The correct output is therefore:'
  prefs: []
  type: TYPE_NORMAL
- en: '1st most common word(s):'
  prefs: []
  type: TYPE_NORMAL
- en: cut
  prefs: []
  type: TYPE_NORMAL
- en: ❶
  prefs: []
  type: TYPE_NORMAL
- en: Notice the required blank line at the end ❶.
  prefs: []
  type: TYPE_NORMAL
- en: Now, what do we do if *k* were 2? We could answer this by scanning through the
    words again and counting occurrences, but there’s a different way to organize
    the words that would make our task considerably easier. Rather than a list of
    words, let’s look at each word associated with its number of occurrences. See
    [Table 8-1](ch08.xhtml#ch08tab01).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 8-1:** Words and Number of Occurrences'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Word** | **Number of occurrences** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| cut | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| gully | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| storm | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| brook | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| magma | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| cliff | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| blast | 1 |'
  prefs: []
  type: TYPE_TB
- en: I’ve sorted the words based on their number of occurrences. Looking at the top
    row, we can reaffirm that cut is the word to output for *k* = 1\. Looking at the
    second row, we see that gully is the word to output for *k* = 2\. The word gully
    is the only word that has exactly one word with more occurrences.
  prefs: []
  type: TYPE_NORMAL
- en: Now for *k* = 3\. This time, there are *two* words to output, storm and brook,
    because they both have the same number of occurrences. Each of these words has
    exactly two words with more occurrences. This shows that we sometimes need to
    output more than one word.
  prefs: []
  type: TYPE_NORMAL
- en: It’s also possible that we need to output zero words! For example, consider
    *k* = 4\. There are *no* words that have exactly three words with more occurrences.
    Looking down the table, you might wonder why we don’t output magma for *k* = 4\.
    We don’t output magma, because magma has exactly four words (not exactly three
    words) with more occurrences.
  prefs: []
  type: TYPE_NORMAL
- en: 'When *k* = 5, we have three words to output: magma, cliff, and blast. Before
    continuing, verify for yourself that there are no words to output for any other
    value of *k*—no words for *k* = 6, *k* = 7, *k* = 8, *k* = 9, *k* = 100, and so
    on.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 8-1](ch08.xhtml#ch08tab01) simplifies the problem quite a bit for us.
    We’re now going to learn how to organize information like this in Python.'
  prefs: []
  type: TYPE_NORMAL
- en: Dictionaries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *dictionary* is a Python type that stores a mapping from one group of elements,
    called *keys*, to another group of elements, called *values*.
  prefs: []
  type: TYPE_NORMAL
- en: We use opening and closing curly brackets to delimit the dictionary. Those are
    the same symbols that we use for a set, but Python can tell the difference between
    a set and a dictionary because of what we put inside the curly brackets. For a
    set, we list values; for a dictionary, we list key:value pairs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a dictionary mapping some strings to numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> {''cut'':4, ''gully'':3}'
  prefs: []
  type: TYPE_NORMAL
- en: '{''cut'': 4, ''gully'': 3}'
  prefs: []
  type: TYPE_NORMAL
- en: In this dictionary, the keys are 'cut' and 'gully', and the values are 4 and
    3. The key 'cut' is mapped to the value 4, and the key 'gully' is mapped to the
    value 3.
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on our encounters with sets, you might wonder whether dictionaries maintain
    the pairs in the order we enter them. For example, you might wonder whether this
    could happen:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> {''cut'':4, ''gully'':3}'
  prefs: []
  type: TYPE_NORMAL
- en: '{''gully'': 3, ''cut'': 4}'
  prefs: []
  type: TYPE_NORMAL
- en: 'As of Python 3.7, the answer is no: dictionaries retain the order in which
    you added pairs. In earlier versions of Python, dictionaries did not maintain
    this order, so you could add pairs in one order but get them back in another.
    It’s still a good idea to write code that doesn’t rely on the Python 3.7 behavior,
    though, because older versions of Python are likely to be in use for the foreseeable
    future.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Dictionaries are equal if they contain the same key:value pairs, even if we
    write them in different orders:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> {''cut'':4, ''gully'':3} == {''cut'':4, ''gully'':3}'
  prefs: []
  type: TYPE_NORMAL
- en: 'True'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> {''cut'':4, ''gully'':3} == {''gully'': 3, ''cut'': 4}'
  prefs: []
  type: TYPE_NORMAL
- en: 'True'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> {''cut'':4, ''gully'':3} == {''gully'': 3, ''cut'': 10}'
  prefs: []
  type: TYPE_NORMAL
- en: 'False'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> {''cut'':4, ''gully'':3} == {''cut'': 4}'
  prefs: []
  type: TYPE_NORMAL
- en: 'False'
  prefs: []
  type: TYPE_NORMAL
- en: 'Dictionary keys must be unique. If you try to include the same key multiple
    times, only one pair involving that key is retained:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> {''storm'': 1, ''storm'': 2}'
  prefs: []
  type: TYPE_NORMAL
- en: '{''storm'': 2}'
  prefs: []
  type: TYPE_NORMAL
- en: 'Repeated values, by contrast, are fine:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> {''storm'': 2, ''brook'': 2}'
  prefs: []
  type: TYPE_NORMAL
- en: '{''storm'': 2, ''brook'': 2}'
  prefs: []
  type: TYPE_NORMAL
- en: 'Keys are required to be immutable values, such as numbers and strings. Values
    can be immutable or mutable. This means that we can’t use a list as a key, but
    we can use a list as a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> {[''storm'', ''brook'']: 2}'
  prefs: []
  type: TYPE_NORMAL
- en: 'Traceback (most recent call last):'
  prefs: []
  type: TYPE_NORMAL
- en: File "<stdin>", line 1, in <module>
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeError: unhashable type: ''list'''
  prefs: []
  type: TYPE_NORMAL
- en: '>>> {2: [''storm'', ''brook'']}'
  prefs: []
  type: TYPE_NORMAL
- en: '{2: [''storm'', ''brook'']}'
  prefs: []
  type: TYPE_NORMAL
- en: 'The len function gives us the number of key:value pairs in a dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> len({''cut'':4, ''gully'':3})'
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> len({2: [''storm'', ''brook'']})'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an empty dictionary, we use {}. That’s why we’re stuck with that
    second-rate set() syntax to create a set—dictionaries got the nice syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> {}'
  prefs: []
  type: TYPE_NORMAL
- en: '{}'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> type({})'
  prefs: []
  type: TYPE_NORMAL
- en: <class 'dict'>
  prefs: []
  type: TYPE_NORMAL
- en: The type is called dict, not dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll see “dictionary” and “dict” used interchangeably in Python resources
    and code, but I’ll stick with “dictionary” in this book.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONCEPT CHECK**'
  prefs: []
  type: TYPE_NORMAL
- en: Which of the following is best suited for a dictionary rather than a list or
    set?
  prefs: []
  type: TYPE_NORMAL
- en: A. The order in which people finish a race
  prefs: []
  type: TYPE_NORMAL
- en: B. The ingredients necessary for a recipe
  prefs: []
  type: TYPE_NORMAL
- en: C. The names of countries and their capital cities
  prefs: []
  type: TYPE_NORMAL
- en: D. 50 random integers
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer: C. This is the only option that includes a mapping between keys and
    values. Here, the keys could be the countries, and the values could be their capital
    cities.'
  prefs: []
  type: TYPE_NORMAL
- en: '**CONCEPT CHECK**'
  prefs: []
  type: TYPE_NORMAL
- en: What is the type of the values (ignoring the keys) in the following dictionary?
  prefs: []
  type: TYPE_NORMAL
- en: '{''MLB'': {''Bluejays'': [1992, 1993],'
  prefs: []
  type: TYPE_NORMAL
- en: '''Orioles'': [1966, 1970, 1983]},'
  prefs: []
  type: TYPE_NORMAL
- en: '''NFL'': {''Patriots'': [''too many'']}}'
  prefs: []
  type: TYPE_NORMAL
- en: A. Integer
  prefs: []
  type: TYPE_NORMAL
- en: B. String
  prefs: []
  type: TYPE_NORMAL
- en: C. List
  prefs: []
  type: TYPE_NORMAL
- en: D. Dictionary
  prefs: []
  type: TYPE_NORMAL
- en: E. More than one of the above
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer: D. The value for each key in the dictionary is itself a dictionary.
    For example, the key ''MLB'' is mapped to a dictionary; that dictionary has two
    key:value pairs of its own.'
  prefs: []
  type: TYPE_NORMAL
- en: Indexing Dictionaries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can use square brackets to look up the value that a key maps to. It’s similar
    to how we index a list, but with the keys serving as the valid “indices”:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> d = {''cut'':4, ''gully'':3}'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> d'
  prefs: []
  type: TYPE_NORMAL
- en: '{''cut'': 4, ''gully'': 3}'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> d[''cut'']'
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> d[''gully'']'
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s an error to use a key that doesn’t exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> d[''storm'']'
  prefs: []
  type: TYPE_NORMAL
- en: 'Traceback (most recent call last):'
  prefs: []
  type: TYPE_NORMAL
- en: File "<stdin>", line 1, in <module>
  prefs: []
  type: TYPE_NORMAL
- en: 'KeyError: ''storm'''
  prefs: []
  type: TYPE_NORMAL
- en: 'We can protect against that error by first using in to check whether a key
    is in the dictionary. When used on a dictionary, the in operator checks only the
    keys, not the values. Here’s how we can check that a key exists before trying
    to find its value:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> if ''cut'' in d:'
  prefs: []
  type: TYPE_NORMAL
- en: '...     print(d[''cut''])'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> if ''storm'' in d:'
  prefs: []
  type: TYPE_NORMAL
- en: '...     print(d[''storm''])'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: Indexing and using in on a dictionary are extremely fast operations. They don’t
    require searching any kind of list, no matter how many keys are in the dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s sometimes more convenient to use the get method rather than indexing to
    look up the value for a key. The get method never produces an error, even if the
    key doesn’t exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> print(d.get(''cut''))'
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> print(d.get(''storm''))'
  prefs: []
  type: TYPE_NORMAL
- en: None
  prefs: []
  type: TYPE_NORMAL
- en: If the key exists, get returns its value. Otherwise, it returns None to signify
    that the key does not exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to looking up the value for a key, we can use square brackets to
    add keys to a dictionary or change the value that a key maps to. Here’s some code
    that shows how to do each of these, starting with an empty dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> d = {}'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> d[''gully''] = 1'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> d'
  prefs: []
  type: TYPE_NORMAL
- en: '{''gully'': 1}'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> d[''cut''] = 1'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> d'
  prefs: []
  type: TYPE_NORMAL
- en: '{''gully'': 1, ''cut'': 1}'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> d[''cut''] = 4'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> d'
  prefs: []
  type: TYPE_NORMAL
- en: '{''gully'': 1, ''cut'': 4}'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> d[''gully''] = d[''gully''] + 1'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> d'
  prefs: []
  type: TYPE_NORMAL
- en: '{''gully'': 2, ''cut'': 4}'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> d[''gully''] = d[''gully''] + 1'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> d'
  prefs: []
  type: TYPE_NORMAL
- en: '{''gully'': 3, ''cut'': 4}'
  prefs: []
  type: TYPE_NORMAL
- en: '**CONCEPT CHECK**'
  prefs: []
  type: TYPE_NORMAL
- en: Use help({}.get) to learn more about the dictionary get method.
  prefs: []
  type: TYPE_NORMAL
- en: What is the output of the following code?
  prefs: []
  type: TYPE_NORMAL
- en: 'd = {3: 4}'
  prefs: []
  type: TYPE_NORMAL
- en: d[5] = d.get(4, 8)
  prefs: []
  type: TYPE_NORMAL
- en: d[4] = d.get(3, 9)
  prefs: []
  type: TYPE_NORMAL
- en: print(d)
  prefs: []
  type: TYPE_NORMAL
- en: 'A. {3: 4, 5: 8, 4: 9}'
  prefs: []
  type: TYPE_NORMAL
- en: 'B. {3: 4, 5: 8, 4: 4}'
  prefs: []
  type: TYPE_NORMAL
- en: 'C. {3: 4, 5: 4, 4: 3}'
  prefs: []
  type: TYPE_NORMAL
- en: D. Error caused by get
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer: B. The first call of get returns 8, because key 4 does not exist in
    the dictionary. That line therefore adds key 5 with value 8.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The second call of get returns 4: key 3 is in the dictionary already, so the
    second parameter, 9, is ignored. That line therefore adds key 4 with value 4.'
  prefs: []
  type: TYPE_NORMAL
- en: Looping Through Dictionaries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we use a for loop on a dictionary, we get the dictionary’s keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> d = {''cut'': 4, ''gully'': 3, ''storm'': 2, ''brook'': 2}'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> for word in d:'
  prefs: []
  type: TYPE_NORMAL
- en: '...     print(''a key is'', word)'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: a key is cut
  prefs: []
  type: TYPE_NORMAL
- en: a key is gully
  prefs: []
  type: TYPE_NORMAL
- en: a key is storm
  prefs: []
  type: TYPE_NORMAL
- en: a key is brook
  prefs: []
  type: TYPE_NORMAL
- en: 'We might also want to access the value associated with each key, and we can
    do that by using each key as an index in the dictionary. Here’s a loop that accesses
    both the key and its value:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> for word in d:'
  prefs: []
  type: TYPE_NORMAL
- en: '...     print(''key'', word, ''has value'', d[word])'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: key cut has value 4
  prefs: []
  type: TYPE_NORMAL
- en: key gully has value 3
  prefs: []
  type: TYPE_NORMAL
- en: key storm has value 2
  prefs: []
  type: TYPE_NORMAL
- en: key brook has value 2
  prefs: []
  type: TYPE_NORMAL
- en: Dictionaries have methods that let us access the keys, values, or both.
  prefs: []
  type: TYPE_NORMAL
- en: 'The keys method gives us the keys, and the values method gives us the values:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> d.keys()'
  prefs: []
  type: TYPE_NORMAL
- en: dict_keys(['cut', 'gully', 'storm', 'brook'])
  prefs: []
  type: TYPE_NORMAL
- en: '>>> d.values()'
  prefs: []
  type: TYPE_NORMAL
- en: dict_values([4, 3, 2, 2])
  prefs: []
  type: TYPE_NORMAL
- en: 'These aren’t lists, but we can pass them to list to convert them:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> keys = list(d.keys())'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> keys'
  prefs: []
  type: TYPE_NORMAL
- en: '[''cut'', ''gully'', ''storm'', ''brook'']'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> values = list(d.values())'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> values'
  prefs: []
  type: TYPE_NORMAL
- en: '[4, 3, 2, 2]'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the keys available as a list, we can sort the keys and then loop through
    them in sorted order:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> keys.sort()'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> keys'
  prefs: []
  type: TYPE_NORMAL
- en: '[''brook'', ''cut'', ''gully'', ''storm'']'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> for word in keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '...     print(''key'', word, ''has value'', d[word])'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: key brook has value 2
  prefs: []
  type: TYPE_NORMAL
- en: key cut has value 4
  prefs: []
  type: TYPE_NORMAL
- en: key gully has value 3
  prefs: []
  type: TYPE_NORMAL
- en: key storm has value 2
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also loop through the values:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> for num in d.values():'
  prefs: []
  type: TYPE_NORMAL
- en: '...     print(''number'', num)'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: number 4
  prefs: []
  type: TYPE_NORMAL
- en: number 3
  prefs: []
  type: TYPE_NORMAL
- en: number 2
  prefs: []
  type: TYPE_NORMAL
- en: number 2
  prefs: []
  type: TYPE_NORMAL
- en: Looping through keys is often preferred over looping through values. It’s easy
    to go from a key to its value. As we’ll see in the next subsection, though, it’s
    not as easy to go from a value back to its key.
  prefs: []
  type: TYPE_NORMAL
- en: 'One final method that’s relevant here is items. It gives us access to both
    the keys and values:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> pairs = list(d.items())'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> pairs'
  prefs: []
  type: TYPE_NORMAL
- en: '[(''cut'', 4), (''gully'', 3), (''storm'', 2), (''brook'', 2)]'
  prefs: []
  type: TYPE_NORMAL
- en: 'This gives us another way to loop through the key:value pairs of a dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> for pair in pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '...     print(''key'', pair[0], ''has value'', pair[1])'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: key cut has value 4
  prefs: []
  type: TYPE_NORMAL
- en: key gully has value 3
  prefs: []
  type: TYPE_NORMAL
- en: key storm has value 2
  prefs: []
  type: TYPE_NORMAL
- en: key brook has value 2
  prefs: []
  type: TYPE_NORMAL
- en: 'Look carefully at the pairs value:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> pairs'
  prefs: []
  type: TYPE_NORMAL
- en: '[(''cut'', 4), (''gully'', 3), (''storm'', 2), (''brook'', 2)]'
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s something fishy here: there are parentheses around each inner value,
    not square brackets. It turns out that this is *not* a list of lists, but a list
    of *tuples*:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> type(pairs[0])'
  prefs: []
  type: TYPE_NORMAL
- en: <class 'tuple'>
  prefs: []
  type: TYPE_NORMAL
- en: 'Tuples are similar to lists in that they store a sequence of values. The most
    important difference between tuples and lists is that tuples are immutable. You
    can loop over them, index them, and slice them, but you can’t modify them. If
    you try to modify a tuple, you get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> pairs[0][0] = ''river'''
  prefs: []
  type: TYPE_NORMAL
- en: 'Traceback (most recent call last):'
  prefs: []
  type: TYPE_NORMAL
- en: File "<stdin>", line 1, in <module>
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeError: ''tuple'' object does not support item assignment'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create your own tuples using parentheses. For a tuple with a single
    value, we need a trailing comma. For a tuple with multiple values, we don’t:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> (4,)'
  prefs: []
  type: TYPE_NORMAL
- en: (4,)
  prefs: []
  type: TYPE_NORMAL
- en: '>>> (4, 5)'
  prefs: []
  type: TYPE_NORMAL
- en: (4, 5)
  prefs: []
  type: TYPE_NORMAL
- en: '>>> (4, 5, 6)'
  prefs: []
  type: TYPE_NORMAL
- en: (4, 5, 6)
  prefs: []
  type: TYPE_NORMAL
- en: Tuples have methods—but only a few, because methods that would change a tuple
    are not allowed. I encourage you to learn more about tuples if you’re interested,
    but we won’t use tuples any further in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Inverting a Dictionary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re close to being able to solve Common Words using dictionaries. Here’s the
    plan. We maintain a dictionary that maps from words to their number of occurrences.
    Whenever we process a word, we check whether that word is already in the dictionary.
    If it isn’t, then we add it with a value of 1\. If it is, then we increase its
    value by 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of adding two words, one that we have seen before and one
    that we haven’t:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> d = {''storm'': 1, ''cut'': 1, ''magma'': 1}'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> word = ''cut''  # ''cut'' is already in the dictionary'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> if not word in d:'
  prefs: []
  type: TYPE_NORMAL
- en: '...     d[word] = 1'
  prefs: []
  type: TYPE_NORMAL
- en: '... else:'
  prefs: []
  type: TYPE_NORMAL
- en: '...     d[word] = d[word] + 1'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> d'
  prefs: []
  type: TYPE_NORMAL
- en: '{''storm'': 1, ''cut'': 2, ''magma'': 1}'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> word = ''brook''  # ''brook'' is not in the dictionary'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> if not word in d:'
  prefs: []
  type: TYPE_NORMAL
- en: '...     d[word] = 1'
  prefs: []
  type: TYPE_NORMAL
- en: '... else:'
  prefs: []
  type: TYPE_NORMAL
- en: '...     d[word] = d[word] + 1'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> d'
  prefs: []
  type: TYPE_NORMAL
- en: '{''storm'': 1, ''cut'': 2, ''magma'': 1, ''brook'': 1}'
  prefs: []
  type: TYPE_NORMAL
- en: 'Dictionaries make it easy to go from a key to a value. For example, given the
    key ''brook'', we can easily look up the value 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> d[''brook'']'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: Referring to [Table 8-1](ch08.xhtml#ch08tab01), that’s like going from a word
    in the left column to its number of occurrences in the right column. That doesn’t
    directly tell us the words that have a specified number of occurrences, though.
    What we really need to be able to do is go from the right column to the left,
    from number of occurrences to words. Then we’ll be able to sort the numbers of
    occurrences from most to least to find the words we need.
  prefs: []
  type: TYPE_NORMAL
- en: 'That is, we need to go from this kind of dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '{''storm'': 2, ''cut'': 4, ''magma'': 1, ''brook'': 2,'
  prefs: []
  type: TYPE_NORMAL
- en: '''gully'': 3, ''cliff'': 1, ''blast'': 1}'
  prefs: []
  type: TYPE_NORMAL
- en: 'to this kind, the *inverted dictionary*:'
  prefs: []
  type: TYPE_NORMAL
- en: '{2: [''storm'', ''brook''], 4: [''cut''], 1: [''magma'', ''cliff'', ''blast''],'
  prefs: []
  type: TYPE_NORMAL
- en: '3: [''gully'']}'
  prefs: []
  type: TYPE_NORMAL
- en: 'The original dictionary maps from strings to numbers. The inverted dictionary
    maps from numbers to strings. Well, not quite: the inverted dictionary maps from
    numbers to *lists* of strings. Remember that each key is allowed only once in
    a dictionary. In the inverted dictionary, we need to map each key to multiple
    values, so we store all of those values in a list.'
  prefs: []
  type: TYPE_NORMAL
- en: To invert a dictionary, each key becomes a value, and each value becomes a key.
    If a key doesn’t exist yet in the inverted dictionary, we create a list for its
    value. If a key is already in the inverted dictionary, then we add its value to
    its list.
  prefs: []
  type: TYPE_NORMAL
- en: We can now write a function to return the inverted version of a dictionary.
    See [Listing 8-5](ch08.xhtml#ch08ex05) for the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'def invert_dictionary(d):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: d is a dictionary mapping strings to numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Return the inverted dictionary of d.
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: inverted = {}
  prefs: []
  type: TYPE_NORMAL
- en: '❶ for key in d:'
  prefs: []
  type: TYPE_NORMAL
- en: ❷ num = d[key]
  prefs: []
  type: TYPE_NORMAL
- en: 'if not num in inverted:'
  prefs: []
  type: TYPE_NORMAL
- en: ❸ inverted[num] = [key]
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: ❹ inverted[num].append(key)
  prefs: []
  type: TYPE_NORMAL
- en: return inverted
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 8-5: Inverting a dictionary*'
  prefs: []
  type: TYPE_NORMAL
- en: We’re using a for loop over the dictionary d ❶, which gives us each key. We
    index d to obtain the value mapped to by this key ❷. Then we add this key:value
    pair to the inverted dictionary. If num is not yet a key in the inverted dictionary,
    then we add it and make it map to the associated key in d ❸. If num is already
    a key in the inverted dictionary, then its value is already a list. We can therefore
    use append to add the key from d as another value ❹.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the code for our invert_dictionary function into the Python shell. Let’s
    give it a try:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> d = {''a'': 1, ''b'': 1, ''c'': 1}'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> invert_dictionary(d)'
  prefs: []
  type: TYPE_NORMAL
- en: '{1: [''a'', ''b'', ''c'']}'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> d = {''storm'': 2, ''cut'': 4, ''magma'': 1, ''brook'': 2,'
  prefs: []
  type: TYPE_NORMAL
- en: '...      ''gully'': 3, ''cliff'': 1, ''blast'': 1}'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> invert_dictionary(d)'
  prefs: []
  type: TYPE_NORMAL
- en: '{2: [''storm'', ''brook''], 4: [''cut''], 1: [''magma'', ''cliff'', ''blast''],'
  prefs: []
  type: TYPE_NORMAL
- en: '3: [''gully'']}'
  prefs: []
  type: TYPE_NORMAL
- en: Now we’re ready to solve Common Words with an inverted dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: Solving the Problem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you’d like more practice with top-down design, you might like to solve the
    problem on your own before continuing. In the interest of space, I won’t follow
    the steps of top-down design here. Rather, I’ll present the solution in its entirety,
    and then we’ll discuss each function and how it is used.
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution is in [Listing 8-6](ch08.xhtml#ch08ex06).
  prefs: []
  type: TYPE_NORMAL
- en: 'def invert_dictionary(d):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: d is a dictionary mapping strings to numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Return the inverted dictionary of d.
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: inverted = {}
  prefs: []
  type: TYPE_NORMAL
- en: 'for key in d:'
  prefs: []
  type: TYPE_NORMAL
- en: num = d[key]
  prefs: []
  type: TYPE_NORMAL
- en: 'if not num in inverted:'
  prefs: []
  type: TYPE_NORMAL
- en: inverted[num] = [key]
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: inverted[num].append(key)
  prefs: []
  type: TYPE_NORMAL
- en: return inverted
  prefs: []
  type: TYPE_NORMAL
- en: '❶ def with_suffix(num):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: num is an integer >= 1.
  prefs: []
  type: TYPE_NORMAL
- en: Return a string of num with its suffix added; e.g. '5th'.
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: ❷ s = str(num)
  prefs: []
  type: TYPE_NORMAL
- en: '❸ if s[-1] == ''1'' and s[-2:] != ''11'':'
  prefs: []
  type: TYPE_NORMAL
- en: return s + 'st'
  prefs: []
  type: TYPE_NORMAL
- en: 'elif s[-1] == ''2'' and s[-2:] != ''12'':'
  prefs: []
  type: TYPE_NORMAL
- en: return s + 'nd'
  prefs: []
  type: TYPE_NORMAL
- en: 'elif s[-1] == ''3'' and s[-2:] != ''13'':'
  prefs: []
  type: TYPE_NORMAL
- en: return s + 'rd'
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: return s + 'th'
  prefs: []
  type: TYPE_NORMAL
- en: '❹ def most_common_words(num_to_words, k):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: num_to_words is a dictionary mapping number of occurrences to
  prefs: []
  type: TYPE_NORMAL
- en: lists of words.
  prefs: []
  type: TYPE_NORMAL
- en: k is an integer >= 1.
  prefs: []
  type: TYPE_NORMAL
- en: Return a list of the kth most-common words in num_to_words.
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: nums = list(num_to_words.keys())
  prefs: []
  type: TYPE_NORMAL
- en: nums.sort(reverse=True)
  prefs: []
  type: TYPE_NORMAL
- en: total = 0
  prefs: []
  type: TYPE_NORMAL
- en: i = 0
  prefs: []
  type: TYPE_NORMAL
- en: done = False
  prefs: []
  type: TYPE_NORMAL
- en: '❺ while i < len(nums) and not done:'
  prefs: []
  type: TYPE_NORMAL
- en: num = nums[i]
  prefs: []
  type: TYPE_NORMAL
- en: '❻ if total + len(num_to_words[num]) >= k:'
  prefs: []
  type: TYPE_NORMAL
- en: done = True
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: total = total + len(num_to_words[num])
  prefs: []
  type: TYPE_NORMAL
- en: i = i + 1
  prefs: []
  type: TYPE_NORMAL
- en: '❼ if total == k - 1 and i < len(nums):'
  prefs: []
  type: TYPE_NORMAL
- en: return num_to_words[nums[i]]
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: return []
  prefs: []
  type: TYPE_NORMAL
- en: ❽ n = int(input())
  prefs: []
  type: TYPE_NORMAL
- en: 'for dataset in range(n):'
  prefs: []
  type: TYPE_NORMAL
- en: lst = input().split()
  prefs: []
  type: TYPE_NORMAL
- en: m = int(lst[0])
  prefs: []
  type: TYPE_NORMAL
- en: k = int(lst[1])
  prefs: []
  type: TYPE_NORMAL
- en: word_to_num = {}
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(m):'
  prefs: []
  type: TYPE_NORMAL
- en: word = input()
  prefs: []
  type: TYPE_NORMAL
- en: 'if not word in word_to_num:'
  prefs: []
  type: TYPE_NORMAL
- en: word_to_num[word] = 1
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: word_to_num[word] = word_to_num[word] + 1
  prefs: []
  type: TYPE_NORMAL
- en: ❾ num_to_words = invert_dictionary(word_to_num)
  prefs: []
  type: TYPE_NORMAL
- en: ordinal = with_suffix(k)
  prefs: []
  type: TYPE_NORMAL
- en: words = most_common_words(num_to_words, k)
  prefs: []
  type: TYPE_NORMAL
- en: print(f'{ordinal} most common word(s):')
  prefs: []
  type: TYPE_NORMAL
- en: 'for word in words:'
  prefs: []
  type: TYPE_NORMAL
- en: print(word)
  prefs: []
  type: TYPE_NORMAL
- en: print()
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 8-6: Solving Common Words*'
  prefs: []
  type: TYPE_NORMAL
- en: The first function is invert_dictionary. We’ve already discussed that, in “Inverting
    a Dictionary” earlier in this chapter. We’ll now go through each other piece of
    the program.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Suffix
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The with_suffix function ❶ takes a number and returns a string with the correct
    suffix added to the number. We need this function because of the pesky requirement
    to output *k* with a suffix. For example, if *k* = 1, then we’ll have to produce
    this line as part of the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '1st most common word(s):'
  prefs: []
  type: TYPE_NORMAL
- en: 'If *k* = 2, we’ll have to produce this line as part of the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '2nd most common word(s):'
  prefs: []
  type: TYPE_NORMAL
- en: and so on. Our with_suffix function makes sure that we add the correct suffix
    to the number. We first convert the number to a string ❷ so that we can easily
    access its digits. Then we use a series of tests to determine whether the suffix
    is st, nd, rd, or th. For example, if the last digit is a 1 but the last two digits
    aren’t 11 ❸, then the correct suffix is st. That gives us 1st, 21st, and 31st,
    but not 11st (which would be incorrect).
  prefs: []
  type: TYPE_NORMAL
- en: Finding the kth Most Common Words
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The most_common_words function ❹ is the function that actually finds the words
    that we need. It takes an inverted dictionary (which maps numbers of occurrences
    to lists of words) and an integer k and returns a list of the kth most common
    words.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how it works, let’s look at a sample inverted dictionary. I’ve organized
    its keys in order from most occurrences to fewest occurrences, as that’s the order
    that most_common_words goes through the keys. Here’s the dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '{4: [''cut''],'
  prefs: []
  type: TYPE_NORMAL
- en: '3: [''gully''],'
  prefs: []
  type: TYPE_NORMAL
- en: '2: [''storm'', ''brook''],'
  prefs: []
  type: TYPE_NORMAL
- en: '1: [''magma'', ''cliff'', ''blast'']}'
  prefs: []
  type: TYPE_NORMAL
- en: Suppose that k is 3. Therefore, exactly two words must be more common than the
    words that we return. The words we need are not provided by the first dictionary
    key. That key gives us only one word (cut), so it can’t be the third most common
    word. Similarly, the words we need are not provided by the second dictionary key.
    That key gives us one more word (gully). We’ve processed a total of two words
    now but haven’t found the third most common words yet. The words we need, however,
    *are* provided by the third dictionary key. That key gives us two more words;
    each of these words (storm and brook) has exactly two words with more occurrences,
    so these are the words for when k is 3.
  prefs: []
  type: TYPE_NORMAL
- en: What if k were 4? This time, exactly three words must be more common than the
    words that we return. The candidate words are still those from the third key (storm
    and brook), but there are only two words that occur more often than each of these
    words. There are therefore *no* words for when k = 4.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, we need to total up the words we see when going through the keys
    until we find the key that might contain the words we need. If exactly k - 1 words
    occur more often, then we have words for k; otherwise, we don’t, and there are
    no words to output.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s walk through the code itself. We begin by obtaining a list of the
    dictionary’s keys and sorting them from biggest to smallest. We then loop through
    the keys in that reverse-sorted order ❺. The done variable tells us whether we’ve
    looked at k or more words yet. As soon as we have ❻, we exit the loop.
  prefs: []
  type: TYPE_NORMAL
- en: When the loop is done, we check whether there are any words for k. If there
    are exactly k - 1 words that occur more often, and we haven’t gone past the end
    of our keys ❼, then we indeed have words to return. Otherwise, there are no words
    to return, so we return the empty list.
  prefs: []
  type: TYPE_NORMAL
- en: The Main Program
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now we arrive at the main part of the program ❽. We build dictionary word_to_num,
    which maps each word to its number of occurrences. We then build the inverted
    dictionary num_to_words ❾, which maps each number of occurrences to the associated
    list of words. Notice how the names of these dictionaries convey the direction
    of mapping: word_to_num goes from words to numbers, and num_to_words goes from
    numbers to words.'
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the code calls our other helper functions and outputs the appropriate
    words.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that, you’re ready to submit to the judge. Well done: that’s the first
    problem that you’ve solved with dictionaries. Whenever you need to map between
    two types of values, think about whether you can organize the information using
    a dictionary. If you can, it’s likely that you’ll be well on your way to an efficient
    solution!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem #20: Cities and States'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here’s another problem where we’ll be able to use a dictionary. As you read
    the problem description, think about what we could use as the keys and what we
    could use as the values.
  prefs: []
  type: TYPE_NORMAL
- en: This is USACO 2016 December Silver Contest problem Cities and States.
  prefs: []
  type: TYPE_NORMAL
- en: The Challenge
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The United States is divided into geographical regions called *states*, each
    of which contains one or more cities. Each state has been given a two-character
    abbreviation. For example, the abbreviation for Pennsylvania is PA, and the abbreviation
    for South Carolina is SC. We’ll write city names and state abbreviations in all
    uppercase.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the pair of cities SCRANTON PA and PARKER SC. This pair of cities is
    *special* because the first two characters of each city give the abbreviation
    for the other city’s state. That is, the first two characters of SCRANTON give
    us SC (PARKER’s state), and the first two characters of PARKER give us PA (SCRANTON’s
    state).
  prefs: []
  type: TYPE_NORMAL
- en: A pair of cities is *special* if they meet this property and are not in the
    same state.
  prefs: []
  type: TYPE_NORMAL
- en: Determine the number of special pairs of cities in the provided input.
  prefs: []
  type: TYPE_NORMAL
- en: Input
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Read input from the file named *citystate.in*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The input consists of the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: A line containing *n*, the number of cities. *n* is between 1 and 200,000.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*n* lines, one per city. Each line gives the name of a city in uppercase, a
    space, and its state’s abbreviation in uppercase. The name of each city is between
    2 and 10 characters; the abbreviation for each state is exactly two characters.
    The same city name can exist in multiple states but will not appear more than
    once in the same state. The name of a city or state in this problem is any string
    that meets these requirements; it might not be the name of an actual US city or
    state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write output to the file named *citystate.out*.
  prefs: []
  type: TYPE_NORMAL
- en: Output the number of special pairs of cities.
  prefs: []
  type: TYPE_NORMAL
- en: The time limit for solving each test case is four seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring a Test Case
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Perhaps you’re thinking that you could solve this problem with a list. That’s
    a good thought to have! If you’re interested, I suggest giving that a try before
    continuing. The strategy would be to use two nested loops to consider each pair
    of cities and check whether each pair is special. It’s possible to come up with
    a correct solution using this approach.
  prefs: []
  type: TYPE_NORMAL
- en: A correct solution, yes, but also a slow one. The list of cities can be huge—up
    to a maximum of 200,000—and any solution involving searching a list for matching
    cities is doomed to be too slow. Let’s explore a test case and work out how a
    dictionary can help.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s our test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '12'
  prefs: []
  type: TYPE_NORMAL
- en: SCRANTON PA
  prefs: []
  type: TYPE_NORMAL
- en: MANISTEE MI
  prefs: []
  type: TYPE_NORMAL
- en: NASHUA NH
  prefs: []
  type: TYPE_NORMAL
- en: PARKER SC
  prefs: []
  type: TYPE_NORMAL
- en: LAFAYETTE CO
  prefs: []
  type: TYPE_NORMAL
- en: WASHOUGAL WA
  prefs: []
  type: TYPE_NORMAL
- en: MIDDLEBOROUGH MA
  prefs: []
  type: TYPE_NORMAL
- en: MADISON MI
  prefs: []
  type: TYPE_NORMAL
- en: MILFORD MA
  prefs: []
  type: TYPE_NORMAL
- en: MIDDLETON MA
  prefs: []
  type: TYPE_NORMAL
- en: COVINGTON LA
  prefs: []
  type: TYPE_NORMAL
- en: LAKEWOOD CO
  prefs: []
  type: TYPE_NORMAL
- en: The first city is SCRANTON PA. To find special pairs involving this city, we
    need to find other cities whose name starts with PA and whose state is SC. The
    only other city that meets this description is PARKER SC.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that all we care about for SCRANTON PA is that its name starts with SC
    and that its state is PA. It could have been called SCMERWIN PA or SCSHOCK PA
    or SCHRUTE PA; it would still be a special pair with PARKER SC.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s refer to the first two characters of a city name followed by the city’s
    state as a *combo*. For example, the combo for SCRANTON PA is SCPA, and the combo
    for PARKER SC is PASC.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than searching for special pairs of cities, we can now look at special
    pairs of combos. Let’s try this.
  prefs: []
  type: TYPE_NORMAL
- en: There are two cities with the combo MAMI. They happen to be MANISTEE MI and
    MADISON MI, but all we care about is that there are two of them. The MAMI cities
    start with MA and are in state MI. To count up the special pairs involving MAMI
    cities, we need to know the cities that start with MI and have state MA. That
    is, we need to know the number of MIMA cities. There are three MIMA cities. They
    happen to be MIDDLEBOROUGH MA, MILFORD MA, and MIDDLETON MA, but all we care about
    is that there are three of them. Okay—so we have two MAMI cities and three MIMA
    cities. The total special pairs for these combos is therefore 2 * 3 = 6, because
    for each of the two MAMI cities, we have a choice of three MIMA cities.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re not convinced, here are the six special pairs for these combos:'
  prefs: []
  type: TYPE_NORMAL
- en: MANISTEE MI and MIDDLEBOROUGH MA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MANISTEE MI and MILFORD MA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MANISTEE MI and MIDDLETON MA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MADISON MI and MIDDLEBOROUGH MA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MADISON MI and MILFORD MA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MADISON MI and MIDDLETON MA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we could map combos—SCPA, PASC, MAMI, MIMA, and so on—to the number of occurrences,
    we could loop through the combos to find the number of special pairs of cities.
    A dictionary is the perfect tool to store this mapping.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the dictionary that we’d like to create for our test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '{''SCPA'': 1, ''MAMI'': 2, ''NANH'': 1, ''PASC'': 1, ''LACO'': 2,'
  prefs: []
  type: TYPE_NORMAL
- en: '''MIMA'': 3, ''COLA'': 1}'
  prefs: []
  type: TYPE_NORMAL
- en: With this dictionary, we can figure out the number of special pairs of cities.
    Let’s work through the process.
  prefs: []
  type: TYPE_NORMAL
- en: The first key is 'SCPA'; its value is 1. To find special pairs of cities involving
    'SCPA', we need to look up the value for 'PASC'. That value is also 1. We multiply
    the two values together, yielding 1 * 1 = 1 special pair of cities involving these
    combos. We need to carry out this same procedure for each other key in the dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: The next key is 'MAMI'; its value is 2. To find special pairs of cities involving
    'MAMI', we need to look up the value for 'MIMA'. That value is 3. We multiply
    the two values together, yielding 2 * 3 = 6 special pairs of cities involving
    these combos. With the 1 we found previously, we now have a total of 7.
  prefs: []
  type: TYPE_NORMAL
- en: The next key is 'NANH'; its value is 1. To find special pairs of cities involving
    'NANH', we need to look up the value for 'NHNA'. But 'NHNA' isn’t a key in the
    dictionary! There are no special pairs of cities involving these combos. We still
    have a total of 7.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to this next one. The next key is ''PASC''; its value is
    1. To find special pairs of cities involving ''PASC'', we need to look up the
    value for ''SCPA''. That value is also 1. We multiply the two values together,
    yielding 1 * 1 = 1 special pair of cities involving these combos. But wait: we
    already accounted for this pair when we processed the key ''SCPA''. If we add
    1 here, then we’ll end up double-counting this pair. In fact, by processing each
    key we will double-count *every* special pair of cities. Not to worry, though:
    we’ll make an adjustment later when we’re ready to print the final answer. Let’s
    add this 1 in there. With the 7 we found previously, we now have a total of 8.'
  prefs: []
  type: TYPE_NORMAL
- en: The next key is 'LACO'; its value is 2. The value for 'COLA' is 1, giving 2
    * 1 = 2 special pairs of cities involving these combos. With the 8 we found previously,
    we now have a total of 10.
  prefs: []
  type: TYPE_NORMAL
- en: There are two keys to go, 'MIMA' and 'COLA'. The first leads us to add 6 to
    our total; the second leads us to add 2\. With the 10 we found previously, we
    now have a total of 18.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that we’ve double-counted every special pair of cities. We don’t have
    18 unique special pairs of cities, then. We have only 18 / 2 = 9 special pairs
    of cities. All we need to do is divide by 2 to undo the double counting.
  prefs: []
  type: TYPE_NORMAL
- en: If you compare the dictionary we just went through to the cities in the test
    case, you’ll notice that something is missing from the dictionary. It’s that city
    WASHOUGAL WA! Its combo is WAWA, but there’s no 'WAWA' key in our dictionary.
    We’re not accounting for this city, and we need to understand why.
  prefs: []
  type: TYPE_NORMAL
- en: The first two characters of WASHOUGAL WA are WA. This means that the only way
    for WASHOUGAL WA to be part of a special pair of cities is to find another city
    whose state is WA. Notice that WASHOUGAL WA is in state WA, too. However, the
    problem specifies that the two cities in a special pair of cities must come from
    different states. There’s therefore no way to find a special pair of cities involving
    WASHOUGAL WA. To make sure we don’t accidentally count fake special pairs, we
    don’t even include WASHOUGAL WA in the dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: Solving the Problem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re ready to go! We can use a dictionary for a concise, rocket-fast solution
    to Cities and States. The code is in [Listing 8-7](ch08.xhtml#ch08ex07).
  prefs: []
  type: TYPE_NORMAL
- en: input_file = open('citystate.in', 'r')
  prefs: []
  type: TYPE_NORMAL
- en: output_file = open('citystate.out', 'w')
  prefs: []
  type: TYPE_NORMAL
- en: n = int(input_file.readline())
  prefs: []
  type: TYPE_NORMAL
- en: ❶ combo_to_num = {}
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(n):'
  prefs: []
  type: TYPE_NORMAL
- en: lst = input_file.readline().split()
  prefs: []
  type: TYPE_NORMAL
- en: ❷ city = lst[0][:2]
  prefs: []
  type: TYPE_NORMAL
- en: state = lst[1]
  prefs: []
  type: TYPE_NORMAL
- en: '❸ if city != state:'
  prefs: []
  type: TYPE_NORMAL
- en: combo = city + state
  prefs: []
  type: TYPE_NORMAL
- en: 'if not combo in combo_to_num:'
  prefs: []
  type: TYPE_NORMAL
- en: combo_to_num[combo] = 1
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: combo_to_num[combo] = combo_to_num[combo] + 1
  prefs: []
  type: TYPE_NORMAL
- en: total = 0
  prefs: []
  type: TYPE_NORMAL
- en: '❹ for combo in combo_to_num:'
  prefs: []
  type: TYPE_NORMAL
- en: ❺ other_combo = combo[2:] + combo[:2]
  prefs: []
  type: TYPE_NORMAL
- en: 'if other_combo in combo_to_num:'
  prefs: []
  type: TYPE_NORMAL
- en: ❻ total = total + combo_to_num[combo] * combo_to_num[other_combo]
  prefs: []
  type: TYPE_NORMAL
- en: ❼ output_file.write(str(total // 2) + '\n')
  prefs: []
  type: TYPE_NORMAL
- en: input_file.close()
  prefs: []
  type: TYPE_NORMAL
- en: output_file.close()
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 8-7: Solving Cities and States*'
  prefs: []
  type: TYPE_NORMAL
- en: This is a USACO problem where we need to use files rather than standard input
    and standard output.
  prefs: []
  type: TYPE_NORMAL
- en: The dictionary that we’ll build is called combo_to_num ❶. It maps from four-character
    combos, like 'SCPA', to the number of cities with that combo.
  prefs: []
  type: TYPE_NORMAL
- en: For each city from the input, we use variables to refer to the first two characters
    of the name of the city ❷ and its state. Then, if these values are not the same
    ❸, we combine them and add the combo to the dictionary. If the combo wasn’t already
    in the dictionary, we add it with a value of 1; if it was already there, we increase
    its value by 1.
  prefs: []
  type: TYPE_NORMAL
- en: The dictionary is now built. We loop through its keys ❹. For each key, we construct
    the other combo that we need to look up to find special pairs of cities involving
    this key. If the key is 'SCPA', for example, then we want the other combo to be
    'PASC'. To do that, we take the rightmost two characters of the key and follow
    those by the leftmost two characters ❺. If that other combo is also in the dictionary,
    then we multiply the two key’s values and add that to our total ❻.
  prefs: []
  type: TYPE_NORMAL
- en: All we need to do now is output the total number of special pairs of cities
    to the output file. As explained in the previous section, we need to divide our
    total by 2 ❼ to undo the double-counting that results from processing each key
    in the dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'There we have it: another example of solving a problem with a suitable deployment
    of a dictionary. Feel free to submit our code!'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we learned about Python sets and dictionaries. A set is a collection
    of values with no order and no duplicates. A dictionary is a collection of key:value
    pairs. As we saw in this chapter’s problems, sometimes these collections are more
    appropriate than lists. For example, determining whether a value is in a set is
    ridiculously fast compared to the same operation on a list. If we don’t care about
    the order of values or want to eliminate duplicates, we should seriously consider
    using a set.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, a dictionary makes it easy to determine the value mapped to by a
    key. If we’re maintaining a mapping from keys to values, then we should seriously
    consider using a dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: With sets and dictionaries in the mix, you now have more flexibility for how
    to store your values. This flexibility, however, means that you need to make a
    choice. Don’t default to using a list anymore! The difference between using one
    type or another might be the difference between solving the problem or not.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve reached an important milestone, as we’ve now covered most of the Python
    that I’ll be teaching you in this book. This doesn’t mean that your Python journey
    is complete. There’s a lot more to know about Python beyond what I’ve included
    in the book. This does mean, though, that we’ve reached a point where we can solve
    a wide variety of problems—in competitive programming or otherwise—with our Python
    skills.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter of the book, we shift gears: from learning new Python features
    to sharpening our problem-solving ability. We’ll focus on one particular type
    of problem that we can solve by searching through all candidate solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here are some exercises for you to try. For each, use a set or dictionary. Sometimes,
    a set or dictionary will help you write code that runs faster; other times, it
    will help you write code that’s more organized and easier to read.
  prefs: []
  type: TYPE_NORMAL
- en: DMOJ problem crci06p1, Bard
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DMOJ problem dmopc19c5p1, Conspicuous Cryptic Checklist
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DMOJ problem coci15c2p1, Marko
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DMOJ problem ccc06s2, Attack of the CipherTexts
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DMOJ problem dmopc19c3p1, Mode Finding
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'DMOJ problem coci14c2p2, Utrka (Try solving this one in three different ways:
    using a dictionary, using a set, and using lists!)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'DMOJ problem coci17c2p2, ZigZag (Hint: maintain two dictionaries. The first
    maps each starting letter to its list of words; the second maps each starting
    letter to the index of its next word that will be output. That way, we can cycle
    through the words for each letter without having to explicitly update numbers
    of occurrences or modify lists.)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Email Addresses is originally from the 2019 Educational Computing Organization
    of Ontario Programming Contest, Round 2\. Common Words is originally from the
    1999 Canadian Computing Olympiad. Cities and States is originally from the USACO
    2016 December Silver Contest.
  prefs: []
  type: TYPE_NORMAL
- en: If you’d like to learn more about Python, I recommend *Python Crash Course*,
    2nd edition by Eric Matthes (No Starch Press, 2019). When you’re ready to take
    it to the next level, you might like to read *Effective Python*, 2nd edition by
    Brett Slatkin (Addison-Wesley Professional, 2020), which offers a collection of
    tips to help you write better Python code.
  prefs: []
  type: TYPE_NORMAL
