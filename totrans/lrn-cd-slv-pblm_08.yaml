- en: '8'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '8'
- en: ORGANIZING VALUES USING SETS AND DICTIONARIES
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用集合和字典组织值
- en: '![image](Images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/common.jpg)'
- en: A Python list is useful whenever we need to store a sequence of values, such
    as the heights of action figures or the words in an essay. Lists make it easy
    for us to keep values in order and access a value given its index. As we’ll see
    in this chapter, though, there are operations that lists are not optimized for,
    including identifying whether a specific value is in a collection and making associations
    between pairs of values.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要存储一系列值时，例如动作人物的高度或文章中的单词时，Python 列表是非常有用的。列表使我们能够轻松保持值的顺序，并根据索引访问某个值。然而，正如我们将在本章中看到的那样，列表并不适合执行一些操作，包括确定一个特定的值是否在集合中以及在一对值之间建立关联。
- en: In this chapter, we’ll learn about Python sets and dictionaries, two alternatives
    to lists for storing collections of values. We’ll see that a set can be the tool
    of choice when we need to search for specific values and don’t care about their
    order and that a dictionary can be the tool of choice whenever we need to work
    with pairs of values.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习 Python 集合和字典，它们是存储值集合的两种替代方案。我们将看到，当我们需要查找特定的值并且不关心它们的顺序时，集合是首选工具；而当我们需要处理一对值时，字典是首选工具。
- en: 'We’ll solve three problems using these new collections: determining the number
    of unique email addresses, finding common words in a list of words, and determining
    the number of special pairs of cities and states.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这些新的集合解决三个问题：确定唯一电子邮件地址的数量、在一组单词中找到公共单词，以及确定一对城市和州的特殊组合数量。
- en: 'Problem #18: Email Addresses'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '问题 #18：电子邮件地址'
- en: In this problem, we’ll store a collection of email addresses. We won’t care
    about the number of times that each email address shows up, and we won’t care
    about maintaining the order of the email addresses. These lax storage requirements
    mean that we can forgo a list for a set—a Python type whose speed leaves lists
    in the dust. We’re going to learn all about sets.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个问题中，我们将存储一组电子邮件地址。我们不关心每个电子邮件地址出现的次数，也不关心电子邮件地址的顺序。这些宽松的存储要求意味着我们可以用集合来替代列表——集合是一种
    Python 类型，它的速度远远超过列表。我们将学习有关集合的一切。
- en: This is DMOJ problem `ecoo19r2p1`.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 DMOJ 问题 `ecoo19r2p1`。
- en: The Challenge
  id: totrans-9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战
- en: Did you know that there are many ways to write someone’s Gmail email address?
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道有很多种方式可以写一个人的 Gmail 地址吗？
- en: We can take someone’s Gmail address and add a plus (`+`) symbol and a string
    before the `@` symbol, and they’ll get any email we send to that new address.
    That is, as far as Gmail addresses are concerned, all characters from a `+` symbol
    to just before the `@` symbol are ignored. For example, I tell people that my
    Gmail address is *[daniel.zingaro@gmail.com](mailto:daniel.zingaro@gmail.com)*,
    but that’s only one way to write it. If you send email to *[daniel.zingaro+book@gmail.com](mailto:daniel.zingaro+book@gmail.com)*
    or *[daniel.zingaro+hi.there@gmail.com](mailto:daniel.zingaro+hi.there@gmail.com)*,
    I’ll get it. (Choose your favorite. Say hi!)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在某人的 Gmail 地址中，在 `@` 符号前加上一个加号（`+`）符号和一个字符串，这样他们就能收到我们发送到那个新地址的任何邮件。也就是说，针对
    Gmail 地址，所有从 `+` 符号到 `@` 符号之前的字符都会被忽略。例如，我告诉别人我的 Gmail 地址是 *[daniel.zingaro@gmail.com](mailto:daniel.zingaro@gmail.com)*，但这只是写法之一。如果你发送邮件到
    *[daniel.zingaro+book@gmail.com](mailto:daniel.zingaro+book@gmail.com)* 或 *[daniel.zingaro+hi.there@gmail.com](mailto:daniel.zingaro+hi.there@gmail.com)*，我也会收到。（选择你喜欢的方式，打个招呼！）
- en: Dots before the `@` symbol are also ignored in Gmail addresses. For example,
    if you send email to *[danielzingaro@gmail.com](mailto:danielzingaro@gmail.com)*
    (no dot at all), *[daniel..zingaro@gmail.com](mailto:daniel..zingaro@gmail.com)*
    (two dots in a row), *[da.nielz.in.gar.o..@gmail.com](mailto:da.nielz.in.gar.o..@gmail.com)*
    (chaotic dots), *[daniel.zin.garo+blah@gmail.com](mailto:daniel.zin.garo+blah@gmail.com)*,
    and so on, I’ll get it.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Gmail 地址中，`@` 符号前的点也会被忽略。例如，如果你发送邮件到 *[danielzingaro@gmail.com](mailto:danielzingaro@gmail.com)*（没有点），*[daniel..zingaro@gmail.com](mailto:daniel..zingaro@gmail.com)*（两个点连在一起），*[da.nielz.in.gar.o..@gmail.com](mailto:da.nielz.in.gar.o..@gmail.com)*（混乱的点），*[daniel.zin.garo+blah@gmail.com](mailto:daniel.zin.garo+blah@gmail.com)*
    等等，我都会收到。
- en: 'Last thing: uppercase and lowercase differences throughout the address are
    ignored. I hope you’re not firing a flurry at me by this point, but I’d get anything
    you send to *[Daniel.Zingaro@gmail.com](mailto:Daniel.Zingaro@gmail.com)*, *[DAnIELZIngARO+Flurry@gmAIL.COM](mailto:DAnIELZIngARO+Flurry@gmAIL.COM)*,
    and so on.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一件事：地址中的大小写差异会被忽略。我希望到此时你没有对我发起一阵攻击，但无论如何，任何发到 *[Daniel.Zingaro@gmail.com](mailto:Daniel.Zingaro@gmail.com)*、
    *[DAnIELZIngARO+Flurry@gmAIL.COM](mailto:DAnIELZIngARO+Flurry@gmAIL.COM)* 等的邮件，我都会收到。
- en: 'In this problem, we’re provided with email addresses, and we’re asked to determine
    the number of them that are unique. The rules for email addresses in this problem
    are the same as those discussed for Gmail: characters from a `+` symbol to just
    before the `@` symbol are ignored, dots before the `@` symbol are ignored, and
    case throughout the entire address is ignored.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个问题中，我们被提供了电子邮件地址，并要求我们确定其中有多少是唯一的。这个问题中电子邮件地址的规则与 Gmail 中讨论的规则相同：从 `+` 符号到
    `@` 符号前的字符会被忽略，`@` 符号前的点会被忽略，整个地址中的大小写会被忽略。
- en: Input
  id: totrans-15
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输入
- en: 'The input consists of 10 test cases. Each test case contains the following
    lines:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 输入包含 10 个测试用例。每个测试用例包含以下行：
- en: A line containing integer *n*, the number of email addresses. *n* is between
    1 and 100,000.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一行包含整数 *n*，表示电子邮件地址的数量。*n* 在 1 和 100,000 之间。
- en: '*n* lines, each of which gives an email address. Each email address consists
    of at least one character before the `@` symbol, followed by the `@` symbol itself,
    followed by at least one character after the `@` symbol. Characters before the
    `@` symbol consist of letters, numbers, dots, and pluses. Characters after the
    `@` symbol consist of letters, numbers, and dots.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*n* 行，每行给出一个电子邮件地址。每个电子邮件地址由 `@` 符号前至少一个字符和 `@` 符号本身，以及 `@` 符号后至少一个字符组成。`@`
    符号前的字符可以是字母、数字、点和加号。`@` 符号后的字符可以是字母、数字和点。'
- en: Output
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输出
- en: For each test case, output the number of unique email addresses.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个测试用例，输出唯一电子邮件地址的数量。
- en: The time limit for solving the test cases is 30 seconds.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 解决测试用例的时间限制是 30 秒。
- en: Using a List
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用列表
- en: You’ve worked through seven chapters of this book. In each one, I posed a problem
    and then taught you new Python features so that you could solve that problem.
    You might therefore expect me to teach you some new Python before solving Email
    Addresses.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学习了本书的七个章节。在每一章中，我提出了一个问题，并教你一些新的 Python 特性，以便你能解决这个问题。因此，你可能会期待我在解决电子邮件地址问题之前，先教你一些新的
    Python 知识。
- en: 'And you might object to that: don’t we already have what we need? After all,
    we can write a function to take an email address and return a clean version, with
    no `+` stuff, no dots before the `@` symbol, and all in lowercase. We can also
    maintain a list of clean email addresses. For each email address that we see,
    we can clean it up and check whether it’s in the list of clean email addresses.
    If it isn’t, then we can add it; if it is, then we do nothing (since it’s already
    being counted). Once we’ve gone through all of the email addresses, the length
    of the list will give us the number of unique email addresses.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会反对这一点：我们难道已经拥有我们需要的东西了吗？毕竟，我们可以写一个函数，接收一个电子邮件地址并返回清理后的版本，去掉 `+` 部分，去掉 `@`
    符号前的点，并且全部小写。我们还可以维护一个清理后的电子邮件地址列表。对于我们看到的每个电子邮件地址，我们可以将其清理并检查它是否已经在清理后的电子邮件地址列表中。如果没有，我们可以将其添加进去；如果已经有了，则什么也不做（因为它已经被计数）。一旦我们处理完所有电子邮件地址，列表的长度将给我们唯一电子邮件地址的数量。
- en: Yes. We may already have what we need. Let’s try solving this thing.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 是的。我们可能已经拥有我们需要的东西。让我们试着解决这个问题。
- en: Cleaning an Email Address
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 清理电子邮件地址
- en: Consider the email address *[DAnIELZIngARO+Flurry@gmAIL.COM](mailto:DAnIELZIngARO+Flurry@gmAIL.COM)*.
    We’re going to clean this email address so that it becomes *[danielzingaro@gmail.com](mailto:danielzingaro@gmail.com)*.
    No +Flurry, no dots before the @ symbol, and all lowercase. We can think of the
    clean version as the true email address. Any other email address that represents
    the same true email address will also match *[danielzingaro@gmail.com](mailto:danielzingaro@gmail.com)*
    once it’s been cleaned.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑电子邮件地址 *[DAnIELZIngARO+Flurry@gmAIL.COM](mailto:DAnIELZIngARO+Flurry@gmAIL.COM)*。我们将清理这个电子邮件地址，使其变成
    *[danielzingaro@gmail.com](mailto:danielzingaro@gmail.com)*。去掉 +Flurry，去掉 @ 符号前的点，并且全部转为小写。我们可以将清理后的版本视为真实的电子邮件地址。任何其他表示相同真实电子邮件地址的邮件地址，在清理后也会匹配
    *[danielzingaro@gmail.com](mailto:danielzingaro@gmail.com)*。
- en: 'Cleaning an email address is a small, self-contained task, so let’s write a
    function for it. This `clean` function will take a string representing an email
    address, clean it up, and return the cleaned email address. We’ll carry out three
    cleaning steps: removing characters from a `+` symbol to just before the `@` symbol,
    removing dots before the `@` symbol, and converting to lowercase. The code for
    this function is in [Listing 8-1](ch08.xhtml#ch08ex01).'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 清理邮箱地址是一个小而独立的任务，所以我们来为此写一个函数。这个 `clean` 函数将接受一个表示邮箱地址的字符串，清理它并返回清理后的邮箱地址。我们将执行三个清理步骤：移除从
    `+` 符号到 `@` 符号之前的字符、去掉 `@` 符号前的点（`.`），以及转换为小写。这个函数的代码在 [Listing 8-1](ch08.xhtml#ch08ex01)
    中。
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 8-1: Cleaning an email address*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 8-1：清理邮箱地址*'
- en: 'The first step is to remove characters from a `+` symbol to just before the
    `@` symbol. The string `find` method is useful here. It returns the index of the
    leftmost occurrence of its argument, or `-1` if the argument isn’t found:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是移除从 `+` 符号到 `@` 符号前的字符。`find` 字符串方法在这里很有用。它返回其参数在字符串中最左侧出现的索引，如果找不到该参数，则返回
    `-1`：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: I use `find` to determine the index of the leftmost `+` symbol ❶. If there is
    no `+` symbol at all, then there’s nothing to do for this step. If there is one,
    however, then we find the index of the `@` symbol ❷ and remove characters from
    the `+` symbol up to but not including the `@` symbol.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用 `find` 方法来确定最左侧的 `+` 符号的索引 ❶。如果没有 `+` 符号，就不需要做这一步。如果有，则我们再查找 `@` 符号的索引 ❷，并从
    `+` 符号到 `@` 符号之间的字符进行删除。
- en: The second step is to remove any dots before the `@` symbol. To do that, I use
    a new string, `before_at`, to accumulate the part of the address before the `@`
    symbol. Each character before the `@` symbol that is not a `.` is added to `before_at`
    ❸.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步是去掉 `@` 符号前的点（`.`）。为此，我使用一个新字符串 `before_at` 来积累 `@` 符号前的部分地址。每个在 `@` 符号前且不是
    `.` 的字符都会被添加到 `before_at` ❸。
- en: The `before_at` string doesn’t include the `@` symbol or any characters following
    it. We don’t want to lose that part of the email address, so I use a new variable,
    `cleaned`, to refer to the whole email address ❹.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`before_at` 字符串不包含 `@` 符号或其后的任何字符。我们不想丢失邮箱地址的这一部分，所以我使用一个新变量 `cleaned` 来表示整个邮箱地址
    ❹。'
- en: The third step is to convert the entire email address to lowercase ❺. After
    that, the email address is clean, so we can return it.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 第三步是将整个邮箱地址转换为小写 ❺。完成后，邮箱地址就被清理干净了，因此我们可以返回它。
- en: 'Let’s test this a little. Enter the code for our `clean` function into the
    Python shell. Here’s the function cleaning a few email addresses:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微测试一下。将 `clean` 函数的代码输入到 Python shell 中。下面是该函数清理几个邮箱地址的过程：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If the email address is already clean, `clean` returns it as is:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果邮箱地址已经是干净的，`clean` 函数就直接返回它：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The Main Program
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 主程序
- en: We can use our `clean` function to clean any email address. The strategy now
    is to maintain a list of clean email addresses. We will add a cleaned email address
    to this list only if it hasn’t been added already. In that way, we’ll avoid adding
    duplicates of the same clean email address.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `clean` 函数清理任何邮箱地址。现在的策略是保持一个清理后的邮箱地址列表。只有当某个清理后的邮箱地址还没有被添加到列表中时，我们才会将其加入。这样，我们就能避免添加重复的邮箱地址。
- en: The main part of our program is in [Listing 8-2](ch08.xhtml#ch08ex02). Be sure
    to enter our `clean` function ([Listing 8-1](ch08.xhtml#ch08ex01)) before this
    code for a complete solution to the problem.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的主要部分在 [Listing 8-2](ch08.xhtml#ch08ex02) 中。在这个代码之前，请确保输入我们的 `clean` 函数代码（[Listing
    8-1](ch08.xhtml#ch08ex01)），以完整解决问题。
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 8-2: Main program, using a list*'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 8-2：主程序，使用列表*'
- en: We have 10 test cases to process, so we surround the rest of the program with
    a range `for` loop that loops 10 times.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有 10 个测试用例需要处理，因此将程序的其余部分放入一个循环中，循环 10 次。
- en: For each test case, we read the number of email addresses and start with an
    empty list of clean email addresses ❶.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个测试用例，我们读取邮箱地址的数量，并从一个空的清理邮箱地址列表开始 ❶。
- en: We then use an inner range `for` loop to loop through each email address. We
    read each email address and clean it. Then, if we haven’t seen this clean email
    address before ❷, we add it to our list of clean email addresses.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用一个内部的 `for` 循环来遍历每个邮箱地址。我们读取每个邮箱地址并清理它。如果这个清理后的邮箱地址之前没有出现过 ❷，我们就把它添加到清理过的邮箱地址列表中。
- en: When the inner loop finishes, we’ll have built up a list of all clean email
    addresses. There are no duplicates in that list. The number of unique email addresses,
    then, is the length of this list, so that’s what we output ❸.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当内层循环结束时，我们将建立一个所有干净电子邮件地址的列表。这个列表中没有重复项。因此，唯一的电子邮件地址数量就是这个列表的长度，这就是我们输出的内容
    ❸。
- en: Not bad, eh? Almost like we could have solved this problem after we learned
    functions in [Chapter 6](ch06.xhtml#ch06). Or, really, after we learned lists
    in [Chapter 5](ch05.xhtml#ch05).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 不错吧？几乎就像我们在[第 6 章](ch06.xhtml#ch06)学到函数后就能解决这个问题。或者，实际上，在我们学习[第 5 章](ch05.xhtml#ch05)的列表后就能解决。
- en: Almost, but not quite. Because if you submit to the judge, you should notice
    that things don’t go according to plan.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 差不多，但还差一点。因为如果你提交给裁判，你应该会注意到事情并没有按计划进行。
- en: The first sign of trouble is that the judge takes a while to show us our results.
    For example, I just waited one minute here for my results to show up. Compare
    that to the other problems we solved earlier, where we received feedback very
    quickly.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 麻烦的第一个迹象是裁判花了一些时间才显示我们的结果。例如，我刚才在这里等待了一分钟，才看到我的结果。相比之前我们解决的其他问题，那里反馈速度非常快。
- en: The second sign of trouble is that when our results do show up, we’re not awarded
    full points for this problem! I’m being given 3.25 points out of 5\. You may receive
    a little more or a little less, but you shouldn’t receive the full 5 points.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 麻烦的第二个迹象是，当我们的结果显示出来时，我们没有为这个问题获得满分！我得到了 3.25 分（满分 5 分）。你可能得到更多或更少的分数，但你不应该得到满分
    5 分。
- en: The reason we’re losing points is not because our program is wrong. Our program
    is fine. No matter the test case, it will output the correct number of unique
    email addresses.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们丢分的原因不是因为程序有错误。我们的程序是正确的。无论测试用例是什么，它都会输出正确的唯一电子邮件地址数量。
- en: So if our program is correct, what’s the problem?
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果我们的程序是正确的，问题出在哪里呢？
- en: The problem is that our program is too slow. The judge lets us know this by
    putting `TLE` at the start of each test case. TLE stands for time limit exceeded.
    For this problem, the judge has allocated 30 seconds to each batch of 10 test
    cases. If our program takes longer than 30 seconds, the judge terminates our program,
    and the remaining test cases in the batch are not allowed to run.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于我们的程序太慢了。裁判通过在每个测试用例前面加上 `TLE` 来告诉我们这一点。TLE 代表超出时间限制。对于这个问题，裁判为每批 10 个测试用例分配了
    30 秒的时间。如果我们的程序超过 30 秒没有完成，裁判会终止程序，剩下的测试用例将无法继续执行。
- en: This may be the first time limit exceeded error you’ve received, though it’s
    possible you’ve seen them as you completed exercises from previous chapters.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是你第一次遇到超出时间限制的错误，尽管在完成之前章节的练习时，你可能也遇到过类似的错误。
- en: The first thing to check when you receive this error is whether your program
    is getting stuck in an infinite loop. If it is, then it’ll never finish, no matter
    the time limit. The judge terminates the program when the allotted time expires.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当你收到这个错误时，首先要检查的是程序是否陷入了无限循环。如果是的话，不管时间限制是多少，它都永远不会结束。裁判会在分配的时间到期时终止程序。
- en: If there’s no infinite loop, then the likely culprit is the *efficiency* of
    our program itself. When programmers talk about efficiency, they’re referring
    to how long it takes the program to run. A program that runs faster (takes less
    time) is more efficient than a program that runs slower (takes more time). To
    solve the test cases within the time limit, we’re going to make our program more
    efficient.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有无限循环，那么可能的罪魁祸首就是我们程序本身的*效率*。当程序员谈论效率时，他们指的是程序运行所需的时间。一个运行得更快（耗时更少）的程序比一个运行得更慢（耗时更多）的程序更高效。为了在时间限制内解决测试用例，我们将使程序更加高效。
- en: Efficiency of Searching a List
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列表搜索的效率
- en: Appending to a Python list is extremely fast. It doesn’t matter whether the
    list has only a few values or many thousands; appending takes the same small amount
    of time.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 向 Python 列表添加元素是非常快的。无论列表中只有几个值还是成千上万个值，添加元素所花的时间都差不多。
- en: Using the `in` operator, however, is a different story. Our program uses the
    `in` operator to determine whether a clean email address is already in our list
    of clean email addresses. A test case might have as many as 100,000 email addresses.
    In the worst case, then, our program could use `in` 100,000 times. It turns out
    that `in` is very slow when used on a list with many values, and this ends up
    hurting our program’s efficiency. To determine whether a value is in the list,
    `in` searches the list from beginning to end, list value by list value. It does
    that until it finds the value it’s looking for, or it runs out of list values
    to check. The more values that `in` has to look through, the slower it is.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用`in`操作符则是另一回事。我们的程序使用`in`操作符来判断一个清洁的电子邮件地址是否已经存在于我们的清洁电子邮件地址列表中。一个测试用例可能包含多达100,000个电子邮件地址。在最坏的情况下，我们的程序可能需要使用`in`操作100,000次。事实证明，当在一个包含许多值的列表上使用`in`时，它非常慢，这最终会影响我们程序的效率。为了判断一个值是否在列表中，`in`会从头到尾逐个值地搜索列表。它会一直搜索，直到找到它正在寻找的值，或者没有更多的列表值可供检查。`in`需要查看的值越多，它的速度就越慢。
- en: Let’s get a feel for the way that `in` slows down as the length of a list increases.
    We’ll use a function that takes a list and a value and uses `in` to search the
    list for the value. It searches for the value 50,000 times; if we searched only
    once, it would be too fast for us to be able to see what’s going on.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解一下随着列表长度增加，`in`操作如何变慢。我们将使用一个函数，该函数接受一个列表和一个值，并使用`in`来搜索列表中的该值。它会搜索50,000次；如果我们只搜索一次，那会太快，我们根本无法看到发生了什么。
- en: The function is in [Listing 8-3](ch08.xhtml#ch08ex03). Enter its code into the
    Python shell.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数位于[清单8-3](ch08.xhtml#ch08ex03)中。将其代码输入到Python shell中。
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 8-3: Searching a collection many times*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单8-3：多次搜索一个集合*'
- en: Let’s create a list of the integers from 1 to 5,000 and search for `5000`. By
    searching for the rightmost value in the list, we make `in` take as much time
    as possible on that list. Don’t worry that we’re exploring this using a list of
    integers rather than a list of email addresses. The efficiency will be similar,
    and numbers are so much easier to generate than email addresses!
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个从1到5,000的整数列表，并搜索`5000`。通过搜索列表中的最右边的值，我们使得`in`在该列表上花费尽可能多的时间。别担心我们用整数列表而不是电子邮件地址列表来进行探索。效率会类似，而且数字比电子邮件地址要容易生成得多！
- en: 'Here goes:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 开始吧：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: On my laptop, this takes about three seconds to run. We don’t need precise timing
    here; we’re just looking for a general picture of what happens as we increase
    the length of the list.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的笔记本上，这大约需要三秒钟来运行。我们不需要精确的计时；我们只是想了解随着列表长度增加，发生了什么情况。
- en: 'Now let’s create a list of the integers from 1 to 10,000 and search for `10000`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个从1到10,000的整数列表，并搜索`10000`：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: On my laptop, that takes about six seconds. As a summary so far, for a list
    of length `5000`, it takes three seconds; double the list length to `10000`, and
    the time doubles, too, to six seconds.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的笔记本上，这大约需要六秒钟。到目前为止的总结是，对于一个长度为`5000`的列表，耗时三秒；将列表长度加倍到`10000`，时间也翻倍，达到了六秒。
- en: 'A list of length `20000`? Give it a try:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一个长度为`20000`的列表？试试看：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This takes about 12 seconds on my laptop.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的笔记本上，这大约需要12秒。
- en: 'The time has doubled again. Try it on a list of length `50000`. You’ll be waiting
    a while. I just ran this on my laptop:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 时间再次翻倍。试试一个长度为`50000`的列表。你需要等一会儿。我刚在我的笔记本上运行了这个：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It took just over 30 seconds. Remember that our `search` function is searching
    the list 50,000 times. So, it’s taking 30 seconds to search a list of length `50000`
    a total of 50,000 times.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 它花了超过30秒。记住，我们的`search`函数正在搜索50,000次列表。所以，它花了30秒来总共搜索一个长度为`50000`的列表50,000次。
- en: We could have a test case that requires this much searching. For example, suppose
    we add 100,000 unique email addresses to our list, one at a time. Halfway through,
    we’ll have a list of 50,000 values; from then on, the remaining 50,000 uses of
    `in` will be on a list of at least 50,000 values.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会有一个需要进行如此多次搜索的测试用例。例如，假设我们将100,000个独特的电子邮件地址一个个添加到我们的列表中。在一半的过程中，我们将有一个包含50,000个值的列表；从那时起，剩下的50,000次`in`操作将会作用于一个至少包含50,000个值的列表。
- en: And that’s only for one of the 10 test cases! We need to get through all 10
    test cases within a total of 30 seconds. If one test case can take about 30 seconds
    on its own, we have no chance.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这仅仅是10个测试用例中的一个！我们需要在30秒内完成所有10个测试用例。如果一个测试用例单独就能花费大约30秒，那我们就没有机会了。
- en: Searching a list is just too slow. The Python list is the wrong type to use.
    We need a type better suited to the job. We need a Python set. You’re not going
    to believe how fast it is to search a set.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 查找列表实在是太慢了。Python 列表并不是适合这个工作的类型。我们需要一个更适合的类型。我们需要一个 Python 集合。你简直不敢相信查找集合是多么的快速。
- en: Sets
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集合
- en: A *set* is a Python type that stores a collection of values, where repeated
    values are not allowed. We use opening and closing curly brackets to delimit the
    set.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*集合*是一个 Python 类型，它存储一组值，其中不允许重复的值。我们使用大括号来限定集合。
- en: 'Unlike a list, a set might not maintain the values in the order you specify.
    Here’s a set of integers:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 与列表不同，集合可能不会保持你指定的顺序。这是一个整数集合：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Notice that Python jumbled the order of the values. You may see the values in
    a different order on your computer. The important point is that you cannot rely
    on any particular order of the values. If order matters to you, a set is not the
    type to use.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 Python 打乱了值的顺序。你可能在你的计算机上看到不同的顺序。关键点是你不能依赖值的任何特定顺序。如果顺序对你很重要，集合就不是合适的类型。
- en: 'If we try to include multiple occurrences of a value, only one occurrence is
    retained:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试包含一个值的多个出现，只有一个会被保留：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Sets are equal if they contain exactly the same values, even if we write them
    in different orders:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是相等的，如果它们包含完全相同的值，即使我们以不同的顺序书写它们：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can create a set of strings, like this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个字符串集合，像这样：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We cannot create a set of lists:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能创建一个包含列表的集合：
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Values in a set must be immutable, which explains why we can’t put lists inside
    a set. The restriction has to do with how Python searches a set for a value. When
    Python adds a value to a set, it uses the value itself to determine where exactly
    it gets stored. Later, Python can find this value by looking in the place where
    it should be located. If a value in the set could change, then Python might look
    in the wrong place, failing to find the value.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 集合中的值必须是不可变的，这解释了为什么我们不能将列表放入集合中。这个限制与 Python 如何在集合中查找值有关。当 Python 向集合中添加一个值时，它使用该值本身来确定它应该存储的位置。后来，Python
    可以通过查看应该存放值的位置来找到它。如果集合中的值可能会改变，Python 可能会在错误的位置查找，导致找不到该值。
- en: 'While we can’t create a set of lists, there’s no problem with a list of sets:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们不能创建一个包含列表的集合，但创建一个包含集合的列表没有问题：
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can use the `len` function to determine the number of values in a set:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `len` 函数来确定集合中值的数量：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You can also loop over the values in a set:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以遍历集合中的值：
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You can’t index or slice a set, though. Values in a set don’t have indices.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你不能对集合进行索引或切片。集合中的值没有索引。
- en: 'To create an empty set, you might expect to use an empty pair of curly brackets,
    `{}`. In an inconsistency of Python syntax, that doesn’t work:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个空集合，你可能会期待使用一个空的大括号`{}`。但在 Python 语法的不一致性中，这样是行不通的：
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Using `{}` gives us the wrong type: a `dict` (dictionary) instead of a `set`.
    We’ll talk about dictionaries later in this chapter.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `{}` 会给我们错误的类型：一个 `dict`（字典），而不是一个 `set`（集合）。我们将在本章稍后讨论字典。
- en: 'To make an empty set, we use `set()`, like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个空集合，我们使用 `set()`，像这样：
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Set Methods
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集合方法
- en: Sets are mutable, so we can add and remove values. We can perform these tasks
    by using methods.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是可变的，因此我们可以添加和删除值。我们可以通过使用方法来执行这些任务。
- en: You can get a list of set methods by using `dir(set())`. And you can get help
    on a specific set method by using `help`, similar to how we use `help` to learn
    about string or list methods. For example, to learn about the `add` method, type
    `help(set().add)`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用 `dir(set())` 获取集合方法的列表。你也可以使用 `help` 获取某个特定集合方法的帮助，类似于我们用 `help` 学习字符串或列表方法。例如，要了解
    `add` 方法，可以输入 `help(set().add)`。
- en: 'The `add` method is what we use to add a value to a set. It’s the analog of
    `append` on lists:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`add` 方法是用来向集合添加一个值的。它类似于列表的 `append` 方法：'
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To remove a value, we use the `remove` method:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除一个值，我们使用 `remove` 方法：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '**CONCEPT CHECK**'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念检查**'
- en: Use `help` to learn about the set `update` and `intersection` methods.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `help` 来了解集合的 `update` 和 `intersection` 方法。
- en: What is output by the call of `print` in the following code?
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码中 `print` 的输出是什么？
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: A. `{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}`
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: A. `{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}`
- en: B. `{1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}`
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: B. `{1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}`
- en: C. `{1, 4, 9}`
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: C. `{1, 4, 9}`
- en: D. `{1, 4, 9, 16, 25}`
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: D. `{1, 4, 9, 16, 25}`
- en: E. `{1}`
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: E. `{1}`
- en: 'Answer: A. The `update` method adds whatever is in set `s2` but is missing
    from set `s1` to set `s1`. After the call of `update`, `s1` is the set `{1, 2,
    3, 4, 5, 6, 7, 8, 9, 10}`.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：A. `update` 方法将集合 `s2` 中存在但 `s1` 中缺少的元素添加到集合 `s1`。在调用 `update` 后，`s1` 就是集合
    `{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}`。
- en: Now for the call of `intersection`. The intersection of two sets is the set
    consisting of the values that are in both sets. Here, the intersection of `s1`
    and `s3` is `{1, 4, 9}`. However, the `intersection` method *does not* modify
    a set; rather, it produces a new set! For that reason, it has no effect on `s1`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来看看 `intersection` 的调用。两个集合的交集是一个包含同时存在于两个集合中的值的新集合。在这里，`s1` 和 `s3` 的交集是 `{1,
    4, 9}`。然而，`intersection` 方法*不会*修改集合；它会生成一个新集合！因此，它对 `s1` 没有影响。
- en: Efficiency of Searching a Set
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 搜索集合的效率
- en: Back to solving Email Addresses.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 回到解决电子邮件地址的问题。
- en: Do we care about the order of our cleaned email addresses? No! All we care about
    is whether an email address is already in there or not.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们关心清理后的电子邮件地址的顺序吗？不关心！我们只关心一个电子邮件地址是否已经存在于其中。
- en: Do we need to allow duplicates in our cleaned email addresses? No again! In
    fact, we want to explicitly avoid storing duplicate email addresses.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在清理后的电子邮件地址中允许重复吗？当然不需要！实际上，我们明确地希望避免存储重复的电子邮件地址。
- en: Order doesn’t matter, and duplicates are not allowed. These are the two ingredients
    that suggest that a set may be the right type to use.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 顺序不重要，且不允许重复。这两点表明集合可能是合适的类型。
- en: We were foiled in our attempt to use a list because searching a list is too
    slow. A set is going to be an improvement for us because we can search a set faster
    than we can search a list.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在尝试使用列表时遇到了困难，因为列表的搜索太慢了。集合将是我们改进的方案，因为我们可以比搜索列表更快地搜索集合。
- en: We’ve already used the `search` function in [Listing 8-3](ch08.xhtml#ch08ex03)
    to search a list. But that function doesn’t do anything that specifically requires
    a list! It uses the `in` operator, and `in` works on both lists and sets. So we
    can use that function, unchanged, to search a set, too.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在 [清单 8-3](ch08.xhtml#ch08ex03) 中使用了 `search` 函数来搜索一个列表。但这个函数并没有做任何特别需要列表的操作！它使用了
    `in` 操作符，而 `in` 同样适用于列表和集合。所以我们可以不做任何修改地将这个函数用来搜索集合。
- en: 'Enter the `search` function from [Listing 8-3](ch08.xhtml#ch08ex03) into the
    Python shell. Follow along on your computer to get a sense of the difference between
    searching a long list and a big set:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python shell 中输入来自 [清单 8-3](ch08.xhtml#ch08ex03) 的 `search` 函数。跟着你的电脑操作，感受一下在长列表和大集合中搜索的区别：
- en: '[PRE23]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: At ❶, I’ve used `set` to produce a set, not a list, of the integers from the
    range.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ❶ 处，我使用 `set` 生成了一个整数集合，而不是列表。
- en: On my laptop, searching the list takes about 30 seconds. Searching the set,
    by comparison, is bullet fast, almost instantaneous.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的笔记本上，搜索列表大约需要30秒。相比之下，搜索集合速度飞快，几乎是瞬间完成。
- en: 'Sets are unstoppable. Don’t try this on a list, but here we go, searching for
    something in a set of 500,000 values:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是不可阻挡的。不要在列表上尝试这种操作，但我们来试试，在一个包含50万个值的集合中搜索某个值：
- en: '[PRE24]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Boom! Piece of cake.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 哗啦！小菜一碟。
- en: 'Python manages a list in such a way as to allow us to use any index at any
    time. Python has no flexibility to mess around with the order of values: the first
    value has to be at index 0, the second at index 1, and so on. But for a set, Python
    can store it in whatever way it wants, because it makes no promises of keeping
    things in order for us. And it’s that increased latitude that allows Python to
    optimize searches in a set for speed.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Python 以某种方式管理列表，允许我们在任何时候使用任何索引。Python 在值的顺序上没有灵活性：第一个值必须在索引0，第二个值在索引1，依此类推。但对于集合，Python
    可以以任何方式存储它，因为它没有承诺保持顺序。这种增加的灵活性使得 Python 能够优化集合中的搜索速度。
- en: 'For similar reasons, there are other operations that are extremely slow on
    large lists but extremely fast on large sets. For example, removing a value from
    a list is very slow, because Python must decrease the index of each value that’s
    to the right of that value. By contrast, removing a value from a set is very fast:
    there are no indices to update!'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 出于类似的原因，某些操作在大列表上非常慢，但在大集合上非常快。例如，从列表中移除一个值非常慢，因为 Python 必须更新该值右侧所有值的索引。相比之下，从集合中移除一个值非常快：因为没有索引需要更新！
- en: Solving the Problem
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决问题
- en: We already have a function to clean an email address ([Listing 8-1](ch08.xhtml#ch08ex01)),
    and we’ll use it in our set-based solution. As for the main program, [Listing
    8-2](ch08.xhtml#ch08ex02) gets us most of the way there. We just need to use a
    set instead of a list.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了一个清理电子邮件地址的函数（[清单 8-1](ch08.xhtml#ch08ex01)），并将在基于集合的解决方案中使用它。至于主程序，[清单
    8-2](ch08.xhtml#ch08ex02)基本上解决了大部分问题。我们只需要用集合替换列表。
- en: The new main program is in [Listing 8-4](ch08.xhtml#ch08ex04). Include [Listing
    8-1](ch08.xhtml#ch08ex01) before this code for a complete solution to the problem.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 新的主程序在 [Listing 8-4](ch08.xhtml#ch08ex04) 中。要完整解决此问题，请在此代码之前包含 [Listing 8-1](ch08.xhtml#ch08ex01)。
- en: '[PRE25]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 8-4: Main program, using a set*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 8-4：主程序，使用集合*'
- en: Notice that we’re now using a set ❶ of email addresses rather than a list. After
    cleaning each email address, we add it to the set using the set `add` method ❷.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们现在使用的是一组电子邮件地址 ❶，而不是列表。在清理每个电子邮件地址后，我们使用集合的 `add` 方法 ❷ 将其添加到集合中。
- en: In [Listing 8-2](ch08.xhtml#ch08ex02), we used the `in` operator to check whether
    an email address is already in the list so that we didn’t add duplicates. There’s
    no corresponding `in` check in our set-based solution. Where did it go? It seems
    that we’re adding each email address to the set without even making sure that
    it’s not already there.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [Listing 8-2](ch08.xhtml#ch08ex02) 中，我们使用 `in` 操作符检查电子邮件地址是否已经存在于列表中，以避免添加重复项。在我们的基于集合的解决方案中，没有相应的
    `in` 检查。它去哪儿了？似乎我们正在将每个电子邮件地址直接添加到集合中，而没有确保它已经存在。
- en: We can get away without the `in` check when using a set because a set never
    contains duplicates. The `add` method handles the `in` check for us, ensuring
    that a duplicate doesn’t get added. You can think of `add` carrying out its own
    `in` check. There’s no timing concern there, because searching a set is so fast.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用集合时，我们可以省略 `in` 检查，因为集合从不包含重复元素。`add` 方法会为我们处理 `in` 检查，确保不会添加重复元素。你可以认为 `add`
    已经执行了自己的 `in` 检查。这里没有时间问题，因为查找集合中的元素非常快。
- en: If you submit this solution to the judge, you should pass all of the test cases
    well within the time limit.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将此解决方案提交给评审员，你应该能够在时间限制内顺利通过所有测试用例。
- en: As you’ve seen here, choosing the appropriate Python type can mean the difference
    between an unsatisfactory solution and a satisfactory one. Before you start writing
    code, ask yourself which operations you’ll be frequently performing and which
    Python type is ideally suited to those operations.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在这里看到的，选择合适的 Python 类型可以决定一个不令人满意的解决方案和一个令人满意的解决方案之间的差异。在开始编写代码之前，问问自己将频繁执行哪些操作，哪些
    Python 类型最适合这些操作。
- en: Before continuing, you might like to try solving exercises 1 and 2 from “Chapter
    Exercises” on [page 236](ch08.xhtml#ch08lev1sec19).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，你可能想尝试解决《章节练习》中的第 1 和第 2 题，见 [第 236 页](ch08.xhtml#ch08lev1sec19)。
- en: 'Problem #19: Common Words'
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '问题 #19：常见单词'
- en: In this problem, we’ll need to associate words with their number of occurrences.
    This is beyond what we can do with sets, so we won’t use sets here. Instead, we’ll
    learn about and use Python dictionaries.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个问题中，我们需要将单词与其出现次数关联起来。这超出了集合所能做到的范围，因此我们不会在这里使用集合。相反，我们将学习并使用 Python 字典。
- en: This is DMOJ problem `cco99p2`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 DMOJ 问题 `cco99p2`。
- en: The Challenge
  id: totrans-157
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战
- en: We are given *m* words. The words are not necessarily distinct; for example,
    the word `brook` could appear multiple times. We are also given an integer *k*.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们给定了 *m* 个单词。这些单词不一定是唯一的；例如，单词 `brook` 可能会出现多次。我们还给定了一个整数 *k*。
- en: Our task is to find the *k*th most common words. A word *w* is a *k*th most
    common word if exactly *k* – 1 distinct words occur more often than does *w*.
    Depending on the dataset, the *k*th most common words could be no words, one word,
    or more than one word.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的任务是找到 *k* 最常见的单词。如果一个单词 *w* 是第 *k* 最常见的单词，则恰好有 *k* - 1 个不同的单词比 *w* 出现得更频繁。根据数据集的不同，*k*
    最常见的单词可能没有单词，可能有一个单词，也可能有多个单词。
- en: Let’s make sure we’re clear on this definition of the *k*th most common words.
    If *k* = 1, then we’re being asked for the words for which exactly 0 words occur
    more often; that is, we’re being asked for the words that occur most often. If
    *k* = 2, then we’re being asked for the words for which exactly 1 word occurs
    more often. If *k* = 3, then we’re being asked for the words for which exactly
    two distinct words occur more often, and so on.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们确保对 *k* 最常见单词的定义有清晰的理解。如果 *k* = 1，那么我们被要求找出那些没有比它出现次数更多的单词；也就是说，我们要找出最常见的单词。如果
    *k* = 2，那么我们被要求找出那些恰好有一个单词比它出现次数更多的单词。如果 *k* = 3，那么我们被要求找出那些恰好有两个不同单词比它出现次数更多的单词，以此类推。
- en: Input
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输入
- en: 'The input contains a line giving the number of test cases, followed by the
    lines of the test cases themselves. Each test case contains the following lines:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 输入包含一行，给出测试用例的数量，接着是测试用例本身的各行。每个测试用例包含以下几行：
- en: A line containing the integers *m* (the number of words in the test case) and
    *k* separated by a space. *m* is between 0 and 1,000; *k* is at least 1.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一行包含整数*m*（测试用例中的单词数）和*k*，中间用空格隔开。*m*在0到1,000之间；*k*至少为1。
- en: '*m* lines, each of which gives a word. Each word consists of at most 20 characters,
    and all characters are lowercase.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*m*行，每行给出一个单词。每个单词最多包含20个字符，并且所有字符都是小写字母。'
- en: Output
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输出
- en: 'For each test case, output the following lines:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个测试用例，输出以下行：
- en: 'A line containing the following:'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一行包含以下内容：
- en: '[PRE26]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: where p is `1st` if *k* is 1, `2nd` if *k* is 2, `3rd` if *k* is 3, `4th` if
    *k* is 4, and so on.
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当*p*是`1st`时，如果*k*是1；`2nd`时，如果*k*是2；`3rd`时，如果*k*是3；`4th`时，如果*k*是4，以此类推。
- en: One line for each of the *k*th most common words. If there are no such words,
    there are no lines of output here.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个*k*最常见单词的一行。如果没有这样的单词，就没有输出行。
- en: A blank line.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空行。
- en: The time limit for solving the test cases is one second.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 解决测试用例的时间限制为1秒。
- en: Exploring a Test Case
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探索一个测试用例
- en: Let’s start by exploring a test case. It’ll boost our understanding of the problem
    and motivate the use of a new Python type.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从探索一个测试用例开始。这将有助于我们更好地理解问题，并促使我们使用新的Python类型。
- en: 'Suppose that we’re interested in the most common words of all. This means that
    *k* is 1\. Here’s the test case:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们对所有单词中最常见的单词感兴趣。这意味着*k*是1。以下是测试用例：
- en: '[PRE27]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The word that shows up most often is `cut`. There are four occurrences of `cut`,
    and no other word has that many occurrences. The correct output is therefore:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 出现次数最多的单词是`cut`。`cut`出现了四次，其他单词的出现次数没有这么多。因此，正确的输出是：
- en: '[PRE28]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Notice the required blank line at the end ❶.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 注意末尾需要空行 ❶。
- en: Now, what do we do if *k* were 2? We could answer this by scanning through the
    words again and counting occurrences, but there’s a different way to organize
    the words that would make our task considerably easier. Rather than a list of
    words, let’s look at each word associated with its number of occurrences. See
    [Table 8-1](ch08.xhtml#ch08tab01).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果*k*是2，我们该怎么做呢？我们可以通过再次扫描单词并计算出现次数来回答这个问题，但还有一种不同的方式来组织单词，这将使我们的任务变得更容易。与其查看单词列表，不如查看每个单词及其出现次数。见[表8-1](ch08.xhtml#ch08tab01)。
- en: '**Table 8-1:** Words and Number of Occurrences'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**表8-1：** 单词及其出现次数'
- en: '| **Word** | **Number of occurrences** |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| **单词** | **出现次数** |'
- en: '| --- | --- |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| cut | 4 |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| cut | 4 |'
- en: '| gully | 3 |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| gully | 3 |'
- en: '| storm | 2 |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| storm | 2 |'
- en: '| brook | 2 |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| brook | 2 |'
- en: '| magma | 1 |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| magma | 1 |'
- en: '| cliff | 1 |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| cliff | 1 |'
- en: '| blast | 1 |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| blast | 1 |'
- en: I’ve sorted the words based on their number of occurrences. Looking at the top
    row, we can reaffirm that `cut` is the word to output for *k* = 1\. Looking at
    the second row, we see that `gully` is the word to output for *k* = 2\. The word
    `gully` is the only word that has exactly one word with more occurrences.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我已根据单词的出现次数对它们进行了排序。从第一行看，我们可以确认`cut`是*k* = 1时的输出单词。从第二行看，我们看到`gully`是*k* =
    2时的输出单词。单词`gully`是唯一一个有一个单词出现次数更多的单词。
- en: Now for *k* = 3\. This time, there are *two* words to output, `storm` and `brook`,
    because they both have the same number of occurrences. Each of these words has
    exactly two words with more occurrences. This shows that we sometimes need to
    output more than one word.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于*k* = 3。此时，有*两个*单词需要输出，`storm`和`brook`，因为它们都有相同的出现次数。每个单词都有恰好两个出现次数更多的单词。这表明有时我们需要输出多个单词。
- en: It’s also possible that we need to output zero words! For example, consider
    *k* = 4\. There are *no* words that have exactly three words with more occurrences.
    Looking down the table, you might wonder why we don’t output `magma` for *k* =
    4\. We don’t output `magma`, because `magma` has exactly four words (not exactly
    three words) with more occurrences.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 也有可能我们需要输出零个单词！例如，考虑*k* = 4时。没有单词恰好有三个单词出现次数更多。从表格中往下看，你可能会想，为什么我们不在*k* = 4时输出`magma`？我们不输出`magma`，因为`magma`有恰好四个单词（而不是恰好三个单词）出现次数更多。
- en: 'When *k* = 5, we have three words to output: `magma`, `cliff`, and `blast`.
    Before continuing, verify for yourself that there are no words to output for any
    other value of *k*—no words for *k* = 6, *k* = 7, *k* = 8, *k* = 9, *k* = 100,
    and so on.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当*k* = 5时，我们有三个单词需要输出：`magma`、`cliff`和`blast`。在继续之前，请自行验证对于其他任何*k*的值（如*k* =
    6，*k* = 7，*k* = 8，*k* = 9，*k* = 100等）没有要输出的单词。
- en: '[Table 8-1](ch08.xhtml#ch08tab01) simplifies the problem quite a bit for us.
    We’re now going to learn how to organize information like this in Python.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '[表8-1](ch08.xhtml#ch08tab01)简化了我们的任务。接下来，我们将学习如何在Python中组织这种信息。'
- en: Dictionaries
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字典
- en: A *dictionary* is a Python type that stores a mapping from one group of elements,
    called *keys*, to another group of elements, called *values*.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典* 是一种 Python 类型，用于存储从一组元素（称为 *键*）到另一组元素（称为 *值*）的映射。'
- en: We use opening and closing curly brackets to delimit the dictionary. Those are
    the same symbols that we use for a set, but Python can tell the difference between
    a set and a dictionary because of what we put inside the curly brackets. For a
    set, we list values; for a dictionary, we list `key:value` pairs.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用开括号和闭括号来界定字典。这些符号与集合的符号相同，但 Python 可以通过括号内的内容来区分集合和字典。对于集合，我们列出值；对于字典，我们列出
    `key:value` 键值对。
- en: 'Here’s a dictionary mapping some strings to numbers:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个将一些字符串映射到数字的字典：
- en: '[PRE29]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this dictionary, the keys are `'cut'` and `'gully'`, and the values are `4`
    and `3`. The key `'cut'` is mapped to the value `4`, and the key `'gully'` is
    mapped to the value `3`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，键是 `'cut'` 和 `'gully'`，值分别是 `4` 和 `3`。键 `'cut'` 映射到值 `4`，键 `'gully'`
    映射到值 `3`。
- en: 'Based on our encounters with sets, you might wonder whether dictionaries maintain
    the pairs in the order we enter them. For example, you might wonder whether this
    could happen:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们对集合的了解，你可能会想知道字典是否会按我们输入的顺序保留键值对。例如，你可能会想知道是否会发生以下情况：
- en: '[PRE30]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'As of Python 3.7, the answer is no: dictionaries retain the order in which
    you added pairs. In earlier versions of Python, dictionaries did not maintain
    this order, so you could add pairs in one order but get them back in another.
    It’s still a good idea to write code that doesn’t rely on the Python 3.7 behavior,
    though, because older versions of Python are likely to be in use for the foreseeable
    future.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Python 3.7 开始，答案是否定的：字典会保留你添加键值对的顺序。在早期版本的 Python 中，字典并不保持顺序，因此你可以按某种顺序添加键值对，但返回时却是另一种顺序。不过，还是建议编写不依赖于
    Python 3.7 行为的代码，因为旧版本的 Python 可能会在可预见的未来继续使用。
- en: 'Dictionaries are equal if they contain the same `key:value` pairs, even if
    we write them in different orders:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字典包含相同的 `key:value` 键值对，即使顺序不同，它们也是相等的：
- en: '[PRE31]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Dictionary keys must be unique. If you try to include the same key multiple
    times, only one pair involving that key is retained:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 字典的键必须是唯一的。如果你尝试多次包含相同的键，那么只有与该键相关的一个键值对会被保留：
- en: '[PRE32]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Repeated values, by contrast, are fine:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，重复的值是可以的：
- en: '[PRE33]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Keys are required to be immutable values, such as numbers and strings. Values
    can be immutable or mutable. This means that we can’t use a list as a key, but
    we can use a list as a value:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是不可变的值，如数字和字符串。值可以是不可变或可变的。这意味着我们不能使用列表作为键，但可以使用列表作为值：
- en: '[PRE34]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `len` function gives us the number of `key:value` pairs in a dictionary:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`len` 函数返回字典中 `key:value` 键值对的数量：'
- en: '[PRE35]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To create an empty dictionary, we use `{}`. That’s why we’re stuck with that
    second-rate `set()` syntax to create a set—dictionaries got the nice syntax:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个空字典，我们使用 `{}`。这也是为什么我们只能使用那个二流的 `set()` 语法来创建集合——字典获得了更漂亮的语法：
- en: '[PRE36]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The type is called `dict`, not `dictionary`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 该类型被称为 `dict`，而不是 `dictionary`。
- en: You’ll see “dictionary” and “dict” used interchangeably in Python resources
    and code, but I’ll stick with “dictionary” in this book.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 资源和代码中，你会看到“字典”和“dict”交替使用，但在本书中我将坚持使用“字典”。
- en: '**CONCEPT CHECK**'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念检查**'
- en: Which of the following is best suited for a dictionary rather than a list or
    set?
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 以下哪个更适合用字典而不是列表或集合？
- en: A. The order in which people finish a race
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: A. 人们完成比赛的顺序
- en: B. The ingredients necessary for a recipe
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: B. 一个食谱所需的食材
- en: C. The names of countries and their capital cities
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: C. 国家名称及其首都城市
- en: D. 50 random integers
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: D. 50 个随机整数
- en: 'Answer: C. This is the only option that includes a mapping between keys and
    values. Here, the keys could be the countries, and the values could be their capital
    cities.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：C。这是唯一一个包含键值对映射的选项。这里，键可以是国家名，值可以是它们的首都城市。
- en: '**CONCEPT CHECK**'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念检查**'
- en: What is the type of the values (ignoring the keys) in the following dictionary?
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 以下字典中，忽略键后，值的类型是什么？
- en: '[PRE37]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: A. Integer
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: A. 整数
- en: B. String
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: B. 字符串
- en: C. List
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: C. 列表
- en: D. Dictionary
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: D. 字典
- en: E. More than one of the above
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: E. 以上多个选项
- en: 'Answer: D. The value for each key in the dictionary is itself a dictionary.
    For example, the key `''MLB''` is mapped to a dictionary; that dictionary has
    two `key:value` pairs of its own.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：D。字典中每个键的值本身就是一个字典。例如，键 `'MLB'` 映射到一个字典；该字典有两个 `key:value` 键值对。
- en: Indexing Dictionaries
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 索引字典
- en: 'We can use square brackets to look up the value that a key maps to. It’s similar
    to how we index a list, but with the keys serving as the valid “indices”:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用方括号查找一个键对应的值。这与我们索引列表的方式类似，只不过键作为有效的“索引”：
- en: '[PRE38]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'It’s an error to use a key that doesn’t exist:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不存在的键是一个错误：
- en: '[PRE39]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We can protect against that error by first using `in` to check whether a key
    is in the dictionary. When used on a dictionary, the `in` operator checks only
    the keys, not the values. Here’s how we can check that a key exists before trying
    to find its value:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过首先使用`in`来检查一个键是否存在于字典中，从而防止出现错误。当`in`用于字典时，它只检查键，而不检查值。以下是我们如何在尝试查找其值之前检查键是否存在：
- en: '[PRE40]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Indexing and using `in` on a dictionary are extremely fast operations. They
    don’t require searching any kind of list, no matter how many keys are in the dictionary.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 索引和在字典上使用`in`是非常快速的操作。它们不需要搜索任何类型的列表，无论字典中有多少个键。
- en: 'It’s sometimes more convenient to use the `get` method rather than indexing
    to look up the value for a key. The `get` method never produces an error, even
    if the key doesn’t exist:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 有时使用`get`方法而不是索引来查找键的值会更方便。即使键不存在，`get`方法也永远不会产生错误：
- en: '[PRE41]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: If the key exists, `get` returns its value. Otherwise, it returns `None` to
    signify that the key does not exist.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果键存在，`get`返回其值。否则，它返回`None`，表示该键不存在。
- en: 'In addition to looking up the value for a key, we can use square brackets to
    add keys to a dictionary or change the value that a key maps to. Here’s some code
    that shows how to do each of these, starting with an empty dictionary:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 除了查找键的值，我们还可以使用方括号向字典添加键或更改键所对应的值。以下是一些代码，展示了如何做到这一点，从一个空字典开始：
- en: '[PRE42]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '**CONCEPT CHECK**'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念检查**'
- en: Use `help({}.get)` to learn more about the dictionary `get` method.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`help({}.get)`了解更多关于字典`get`方法的信息。
- en: What is the output of the following code?
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码的输出是什么？
- en: '[PRE43]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'A. `{3: 4, 5: 8, 4: 9}`'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 'A. `{3: 4, 5: 8, 4: 9}`'
- en: 'B. `{3: 4, 5: 8, 4: 4}`'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 'B. `{3: 4, 5: 8, 4: 4}`'
- en: 'C. `{3: 4, 5: 4, 4: 3}`'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 'C. `{3: 4, 5: 4, 4: 3}`'
- en: D. Error caused by `get`
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: D. `get`引起的错误
- en: 'Answer: B. The first call of `get` returns `8`, because key `4` does not exist
    in the dictionary. That line therefore adds key `5` with value `8`.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：B。第一次调用`get`返回`8`，因为键`4`在字典中不存在。因此，这一行会添加键`5`，值为`8`。
- en: 'The second call of `get` returns `4`: key `3` is in the dictionary already,
    so the second parameter, `9`, is ignored. That line therefore adds key `4` with
    value `4`.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次调用`get`返回`4`：键`3`已经存在于字典中，因此第二个参数`9`被忽略。因此，这一行会添加键`4`，值为`4`。
- en: Looping Through Dictionaries
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遍历字典
- en: 'If we use a `for` loop on a dictionary, we get the dictionary’s keys:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在字典上使用`for`循环，我们将得到字典的键：
- en: '[PRE44]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We might also want to access the value associated with each key, and we can
    do that by using each key as an index in the dictionary. Here’s a loop that accesses
    both the key and its value:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能还希望访问与每个键相关联的值，我们可以通过使用每个键作为字典中的索引来做到这一点。下面是一个既访问键又访问其值的循环：
- en: '[PRE45]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Dictionaries have methods that let us access the keys, values, or both.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 字典有一些方法，可以让我们访问键、值或两者。
- en: 'The `keys` method gives us the keys, and the `values` method gives us the values:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`keys`方法给我们提供键，而`values`方法给我们提供值：'
- en: '[PRE46]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'These aren’t lists, but we can pass them to `list` to convert them:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这些不是列表，但我们可以将它们传递给`list`以进行转换：
- en: '[PRE47]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'With the keys available as a list, we can sort the keys and then loop through
    them in sorted order:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 有了作为列表的键，我们可以对这些键进行排序，然后按排序顺序遍历它们：
- en: '[PRE48]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We can also loop through the values:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以遍历值：
- en: '[PRE49]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Looping through keys is often preferred over looping through values. It’s easy
    to go from a key to its value. As we’ll see in the next subsection, though, it’s
    not as easy to go from a value back to its key.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历键通常比遍历值更受欢迎。因为从键到值很容易。然而，正如我们在下一小节中将看到的，从值回到键就没有那么容易了。
- en: 'One final method that’s relevant here is `items`. It gives us access to both
    the keys and values:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个相关的方法是`items`。它让我们可以访问键和值：
- en: '[PRE50]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This gives us another way to loop through the `key:value` pairs of a dictionary:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了另一种遍历字典`key:value`对的方法：
- en: '[PRE51]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Look carefully at the `pairs` value:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细查看`pairs`的值：
- en: '[PRE52]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'There’s something fishy here: there are parentheses around each inner value,
    not square brackets. It turns out that this is *not* a list of lists, but a list
    of *tuples*:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有些可疑：每个内部值周围是圆括号，而不是方括号。事实证明，这不是一个列表的列表，而是一个元组的列表：
- en: '[PRE53]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Tuples are similar to lists in that they store a sequence of values. The most
    important difference between tuples and lists is that tuples are immutable. You
    can loop over them, index them, and slice them, but you can’t modify them. If
    you try to modify a tuple, you get an error:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 元组与列表相似，它们存储一系列的值。元组和列表之间最重要的区别在于，元组是不可变的。你可以遍历元组、索引它、切片它，但你不能修改它。如果你试图修改元组，会发生错误：
- en: '[PRE54]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'You can create your own tuples using parentheses. For a tuple with a single
    value, we need a trailing comma. For a tuple with multiple values, we don’t:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用圆括号创建自己的元组。对于一个只有一个值的元组，我们需要一个尾随的逗号。对于多个值的元组，则不需要：
- en: '[PRE55]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Tuples have methods—but only a few, because methods that would change a tuple
    are not allowed. I encourage you to learn more about tuples if you’re interested,
    but we won’t use tuples any further in this book.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 元组有一些方法——但只有少数几个，因为不允许改变元组的操作。如果你感兴趣，我鼓励你了解更多关于元组的知识，但在本书中我们不再使用元组。
- en: Inverting a Dictionary
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 反转字典
- en: We’re close to being able to solve Common Words using dictionaries. Here’s the
    plan. We maintain a dictionary that maps from words to their number of occurrences.
    Whenever we process a word, we check whether that word is already in the dictionary.
    If it isn’t, then we add it with a value of 1\. If it is, then we increase its
    value by 1.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经接近使用字典解决常见单词问题了。计划如下：我们维护一个字典，将单词映射到它们的出现次数。每次处理一个单词时，我们检查该单词是否已经存在于字典中。如果不存在，我们将它加入字典，并赋值为
    1。如果存在，则将其值加 1。
- en: 'Here’s an example of adding two words, one that we have seen before and one
    that we haven’t:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个例子，展示了如何添加两个单词，一个我们之前见过，另一个我们没见过：
- en: '[PRE56]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Dictionaries make it easy to go from a key to a value. For example, given the
    key `''brook''`, we can easily look up the value `1`:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 字典使得从键到值的查找变得容易。例如，给定键 `'brook'`，我们可以轻松查找其值 `1`：
- en: '[PRE57]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Referring to [Table 8-1](ch08.xhtml#ch08tab01), that’s like going from a word
    in the left column to its number of occurrences in the right column. That doesn’t
    directly tell us the words that have a specified number of occurrences, though.
    What we really need to be able to do is go from the right column to the left,
    from number of occurrences to words. Then we’ll be able to sort the numbers of
    occurrences from most to least to find the words we need.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 参考[表格 8-1](ch08.xhtml#ch08tab01)，这就像是从左列的单词到右列中它们的出现次数。这并不能直接告诉我们出现次数为特定数字的单词，然而。我们真正需要的是能够从右列反向查找，从出现次数到单词。这样我们就可以按出现次数从多到少排序，找到我们需要的单词。
- en: 'That is, we need to go from this kind of dictionary:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，我们需要从这种类型的字典开始：
- en: '[PRE58]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'to this kind, the *inverted dictionary*:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种类型，*反转字典*：
- en: '[PRE59]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The original dictionary maps from strings to numbers. The inverted dictionary
    maps from numbers to strings. Well, not quite: the inverted dictionary maps from
    numbers to *lists* of strings. Remember that each key is allowed only once in
    a dictionary. In the inverted dictionary, we need to map each key to multiple
    values, so we store all of those values in a list.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 原始字典是从字符串映射到数字。反转后的字典则是从数字映射到字符串。嗯，其实不完全是：反转字典是从数字映射到*字符串的列表*。记住，字典中的每个键只允许出现一次。在反转字典中，我们需要将每个键映射到多个值，因此我们将所有这些值存储在一个列表中。
- en: To invert a dictionary, each key becomes a value, and each value becomes a key.
    If a key doesn’t exist yet in the inverted dictionary, we create a list for its
    value. If a key is already in the inverted dictionary, then we add its value to
    its list.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 要反转字典，每个键变成一个值，每个值变成一个键。如果一个键在反转字典中尚不存在，我们就为其值创建一个列表。如果键已经存在于反转字典中，那么我们将其值添加到该键的列表中。
- en: We can now write a function to return the inverted version of a dictionary.
    See [Listing 8-5](ch08.xhtml#ch08ex05) for the code.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以编写一个函数，返回一个字典的反转版本。查看[列表 8-5](ch08.xhtml#ch08ex05)中的代码。
- en: '[PRE60]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '*Listing 8-5: Inverting a dictionary*'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-5：反转字典*'
- en: We’re using a `for` loop over the dictionary `d` ❶, which gives us each key.
    We index `d` to obtain the value mapped to by this key ❷. Then we add this `key:value`
    pair to the inverted dictionary. If `num` is not yet a key in the inverted dictionary,
    then we add it and make it map to the associated key in `d` ❸. If `num` is already
    a key in the inverted dictionary, then its value is already a list. We can therefore
    use `append` to add the key from `d` as another value ❹.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`for`循环遍历字典`d`❶，这会给我们每个键。我们索引`d`以获取该键对应的值❷。然后，我们将这个`key:value`对添加到反转字典中。如果`num`还不是反转字典中的一个键，那么我们就添加它，并将其映射到`d`中的相应键❸。如果`num`已经是反转字典中的一个键，那么它的值已经是一个列表。因此，我们可以使用`append`将`d`中的键作为另一个值添加❹。
- en: 'Enter the code for our `invert_dictionary` function into the Python shell.
    Let’s give it a try:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的`invert_dictionary`函数代码输入Python shell中，试试看：
- en: '[PRE61]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Now we’re ready to solve Common Words with an inverted dictionary.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备通过反转字典来解决常见词问题。
- en: Solving the Problem
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决问题
- en: If you’d like more practice with top-down design, you might like to solve the
    problem on your own before continuing. In the interest of space, I won’t follow
    the steps of top-down design here. Rather, I’ll present the solution in its entirety,
    and then we’ll discuss each function and how it is used.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想更多地练习自顶向下设计，或许可以在继续之前自行尝试解决这个问题。为了节省篇幅，我在这里不会遵循自顶向下设计的步骤，而是直接展示完整的解决方案，然后我们再讨论每个函数及其使用方法。
- en: The Code
  id: totrans-308
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 代码
- en: The solution is in [Listing 8-6](ch08.xhtml#ch08ex06).
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案见[清单 8-6](ch08.xhtml#ch08ex06)。
- en: '[PRE62]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '*Listing 8-6: Solving Common Words*'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-6: 解决常见词问题*'
- en: The first function is `invert_dictionary`. We’ve already discussed that, in
    “Inverting a Dictionary” earlier in this chapter. We’ll now go through each other
    piece of the program.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数是`invert_dictionary`。我们在本章“反转字典”部分已经讨论过它。接下来我们将逐一讲解程序中的其他部分。
- en: Adding the Suffix
  id: totrans-313
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加后缀
- en: 'The `with_suffix` function ❶ takes a number and returns a string with the correct
    suffix added to the number. We need this function because of the pesky requirement
    to output *k* with a suffix. For example, if *k* = 1, then we’ll have to produce
    this line as part of the output:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '`with_suffix`函数❶接受一个数字并返回添加了正确后缀的字符串。我们需要这个函数，是因为有一个恼人的要求：输出*k*时需要带上后缀。例如，如果*k*
    = 1，那么我们就必须生成这一行作为输出的一部分：'
- en: '[PRE63]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'If *k* = 2, we’ll have to produce this line as part of the output:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*k* = 2，我们将需要生成这行作为输出的一部分：
- en: '[PRE64]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: and so on. Our `with_suffix` function makes sure that we add the correct suffix
    to the number. We first convert the number to a string ❷ so that we can easily
    access its digits. Then we use a series of tests to determine whether the suffix
    is `st`, `nd`, `rd`, or `th`. For example, if the last digit is a `1` but the
    last two digits aren’t `11` ❸, then the correct suffix is `st`. That gives us
    `1st`, `21st`, and `31st`, but not `11st` (which would be incorrect).
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 依此类推。我们的`with_suffix`函数确保我们为数字添加正确的后缀。我们首先将数字转换为字符串❷，以便可以轻松访问其各个数字。然后，我们使用一系列测试来判断后缀是`st`、`nd`、`rd`还是`th`。例如，如果最后一位数字是`1`，但最后两位数字不是`11`❸，那么正确的后缀是`st`。这会给我们`1st`、`21st`和`31st`，但不会是`11st`（这是错误的）。
- en: Finding the kth Most Common Words
  id: totrans-319
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 查找第k个最常见的单词
- en: The `most_common_words` function ❹ is the function that actually finds the words
    that we need. It takes an inverted dictionary (which maps numbers of occurrences
    to lists of words) and an integer `k` and returns a list of the `k`th most common
    words.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '`most_common_words`函数❹是实际找到我们需要的单词的函数。它接受一个反转字典（该字典将出现次数映射到单词列表）和一个整数`k`，并返回出现次数第`k`多的单词列表。'
- en: 'To see how it works, let’s look at a sample inverted dictionary. I’ve organized
    its keys in order from most occurrences to fewest occurrences, as that’s the order
    that `most_common_words` goes through the keys. Here’s the dictionary:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看它是如何工作的，让我们看一个反转字典的示例。我已经将它的键按出现次数从多到少排序，因为`most_common_words`就是按照这个顺序遍历键的。以下是字典：
- en: '[PRE65]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Suppose that `k` is `3`. Therefore, exactly two words must be more common than
    the words that we return. The words we need are not provided by the first dictionary
    key. That key gives us only one word (`cut`), so it can’t be the third most common
    word. Similarly, the words we need are not provided by the second dictionary key.
    That key gives us one more word (`gully`). We’ve processed a total of two words
    now but haven’t found the third most common words yet. The words we need, however,
    *are* provided by the third dictionary key. That key gives us two more words;
    each of these words (`storm` and `brook`) has exactly two words with more occurrences,
    so these are the words for when `k` is `3`.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`k`是`3`。因此，恰好必须有两个单词比我们返回的单词更常见。我们需要的单词并没有由第一个字典键提供。那个键只给我们一个单词（`cut`），所以它不能是第三常见的单词。同样，我们需要的单词也没有由第二个字典键提供。那个键给我们另一个单词（`gully`）。到目前为止，我们已经处理了两个单词，但还没有找到第三常见的单词。然而，我们需要的单词*确实*由第三个字典键提供。那个键给我们两个更多的单词；每个单词（`storm`和`brook`）都有恰好两个比它们更常见的单词，因此这些就是当`k`为`3`时的单词。
- en: What if `k` were `4`? This time, exactly three words must be more common than
    the words that we return. The candidate words are still those from the third key
    (`storm` and `brook`), but there are only two words that occur more often than
    each of these words. There are therefore *no* words for when `k = 4`.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`k`是`4`呢？这次，恰好必须有三个单词比我们返回的单词更常见。候选单词仍然是来自第三个键（`storm`和`brook`），但是只有两个单词比这两个单词出现得更频繁。因此，当`k
    = 4`时，*没有*单词。
- en: In summary, we need to total up the words we see when going through the keys
    until we find the key that might contain the words we need. If exactly `k - 1`
    words occur more often, then we have words for `k`; otherwise, we don’t, and there
    are no words to output.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们需要在遍历键时统计我们看到的单词，直到找到可能包含我们需要的单词的键。如果恰好有`k - 1`个单词出现得更频繁，那么我们就有`k`的单词；否则，我们没有要输出的单词。
- en: Now let’s walk through the code itself. We begin by obtaining a list of the
    dictionary’s keys and sorting them from biggest to smallest. We then loop through
    the keys in that reverse-sorted order ❺. The `done` variable tells us whether
    we’ve looked at `k` or more words yet. As soon as we have ❻, we exit the loop.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看代码本身。我们首先获取字典的键的列表，并按从大到小的顺序对它们进行排序。然后我们以该倒排顺序❺遍历这些键。`done`变量告诉我们是否已经查看过`k`个或更多的单词。一旦我们有了❻，我们就退出循环。
- en: When the loop is done, we check whether there are any words for `k`. If there
    are exactly `k - 1` words that occur more often, and we haven’t gone past the
    end of our keys ❼, then we indeed have words to return. Otherwise, there are no
    words to return, so we return the empty list.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 当循环完成时，我们检查是否有任何单词满足`k`。如果恰好有`k - 1`个单词出现得更频繁，并且我们没有超过键的末尾❼，那么我们确实有要返回的单词。否则，没有单词可以返回，所以我们返回空列表。
- en: The Main Program
  id: totrans-328
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 主程序
- en: 'Now we arrive at the main part of the program ❽. We build dictionary `word_to_num`,
    which maps each word to its number of occurrences. We then build the inverted
    dictionary `num_to_words` ❾, which maps each number of occurrences to the associated
    list of words. Notice how the names of these dictionaries convey the direction
    of mapping: `word_to_num` goes from words to numbers, and `num_to_words` goes
    from numbers to words.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来到了程序的主要部分❽。我们构建了字典`word_to_num`，它将每个单词映射到它的出现次数。接着我们构建了反向字典`num_to_words`❾，它将每个出现次数映射到相应的单词列表。注意这些字典的名称如何传达映射的方向：`word_to_num`从单词到数字，`num_to_words`从数字到单词。
- en: The rest of the code calls our other helper functions and outputs the appropriate
    words.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的代码调用了我们其他的辅助函数，并输出了相应的单词。
- en: 'With that, you’re ready to submit to the judge. Well done: that’s the first
    problem that you’ve solved with dictionaries. Whenever you need to map between
    two types of values, think about whether you can organize the information using
    a dictionary. If you can, it’s likely that you’ll be well on your way to an efficient
    solution!'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，你就准备好提交给评审了。干得好：这是你用字典解决的第一个问题。每当你需要在两种类型的值之间进行映射时，思考一下是否可以使用字典来组织信息。如果可以，很可能你已经走上了高效解决方案的道路！
- en: 'Problem #20: Cities and States'
  id: totrans-332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '问题 #20：城市与州'
- en: Here’s another problem where we’ll be able to use a dictionary. As you read
    the problem description, think about what we could use as the keys and what we
    could use as the values.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个我们能够使用字典的问题。当你阅读问题描述时，思考一下我们可以用什么作为键，什么可以作为值。
- en: This is USACO 2016 December Silver Contest problem Cities and States.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 这是USACO 2016年12月银奖比赛的题目——城市与州。
- en: The Challenge
  id: totrans-335
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战
- en: The United States is divided into geographical regions called *states*, each
    of which contains one or more cities. Each state has been given a two-character
    abbreviation. For example, the abbreviation for Pennsylvania is PA, and the abbreviation
    for South Carolina is SC. We’ll write city names and state abbreviations in all
    uppercase.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 美国被划分为称为*州*的地理区域，每个州包含一个或多个城市。每个州都有一个两字符的缩写。例如，宾夕法尼亚州的缩写是PA，南卡罗来纳州的缩写是SC。我们将以全大写字母书写城市名称和州的缩写。
- en: Consider the pair of cities `SCRANTON PA` and `PARKER SC`. This pair of cities
    is *special* because the first two characters of each city give the abbreviation
    for the other city’s state. That is, the first two characters of SCRANTON give
    us SC (PARKER’s state), and the first two characters of PARKER give us PA (SCRANTON’s
    state).
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑城市对`SCRANTON PA`和`PARKER SC`。这对城市是*特殊的*，因为每个城市的前两个字符代表另一个城市的州的缩写。也就是说，`SCRANTON`的前两个字符给我们提供了SC（`PARKER`的州），而`PARKER`的前两个字符给我们提供了PA（`SCRANTON`的州）。
- en: A pair of cities is *special* if they meet this property and are not in the
    same state.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一对城市满足这个条件且不在同一州，则该对城市为*特殊的*。
- en: Determine the number of special pairs of cities in the provided input.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 确定提供的输入中有多少个特殊的城市对。
- en: Input
  id: totrans-340
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输入
- en: Read input from the file named *citystate.in*.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 从名为*citystate.in*的文件中读取输入。
- en: 'The input consists of the following lines:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 输入包含以下几行：
- en: A line containing *n*, the number of cities. *n* is between 1 and 200,000.
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一行包含*n*，表示城市的数量。*n*的范围是1到200,000之间。
- en: '*n* lines, one per city. Each line gives the name of a city in uppercase, a
    space, and its state’s abbreviation in uppercase. The name of each city is between
    2 and 10 characters; the abbreviation for each state is exactly two characters.
    The same city name can exist in multiple states but will not appear more than
    once in the same state. The name of a city or state in this problem is any string
    that meets these requirements; it might not be the name of an actual US city or
    state.'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*n*行，每行一个城市。每行给出一个城市的名称（全大写），一个空格，及其州的缩写（全大写）。每个城市的名称长度在2到10个字符之间；每个州的缩写恰好为两个字符。相同的城市名称可以出现在多个州中，但在同一州中不会重复出现。该问题中城市或州的名称可以是符合这些要求的任何字符串；它可能不是一个实际存在的美国城市或州的名称。'
- en: Output
  id: totrans-345
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输出
- en: Write output to the file named *citystate.out*.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 将输出写入名为*citystate.out*的文件中。
- en: Output the number of special pairs of cities.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 输出特殊城市对的数量。
- en: The time limit for solving each test case is four seconds.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 每个测试用例的时间限制为四秒。
- en: Exploring a Test Case
  id: totrans-349
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探索一个测试用例
- en: Perhaps you’re thinking that you could solve this problem with a list. That’s
    a good thought to have! If you’re interested, I suggest giving that a try before
    continuing. The strategy would be to use two nested loops to consider each pair
    of cities and check whether each pair is special. It’s possible to come up with
    a correct solution using this approach.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你认为可以用一个列表来解决这个问题。这是一个不错的想法！如果你有兴趣，在继续之前我建议先尝试这个方法。策略是使用两个嵌套循环来考虑每一对城市，并检查每一对是否特殊。使用这种方法是有可能得到正确解决方案的。
- en: A correct solution, yes, but also a slow one. The list of cities can be huge—up
    to a maximum of 200,000—and any solution involving searching a list for matching
    cities is doomed to be too slow. Let’s explore a test case and work out how a
    dictionary can help.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 一个正确的解决方案，没错，但它也很慢。城市的列表可能非常庞大——最多可达200,000个——任何涉及在列表中查找匹配城市的解决方案注定会太慢。让我们探索一个测试用例，看看字典如何帮助解决这个问题。
- en: 'Here’s our test case:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的测试用例：
- en: '[PRE66]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The first city is `SCRANTON PA`. To find special pairs involving this city,
    we need to find other cities whose name starts with `PA` and whose state is `SC`.
    The only other city that meets this description is `PARKER SC`.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个城市是`SCRANTON PA`。要找到与这个城市相关的特殊城市对，我们需要找到其他以`PA`开头且州为`SC`的城市。符合此描述的唯一其他城市是`PARKER
    SC`。
- en: Notice that all we care about for `SCRANTON PA` is that its name starts with
    `SC` and that its state is `PA`. It could have been called `SCMERWIN PA` or `SCSHOCK
    PA` or `SCHRUTE PA`; it would still be a special pair with `PARKER SC`.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对于`SCRANTON PA`，我们关心的是它的名称以`SC`开头，且其州为`PA`。它也可以被称为`SCMERWIN PA`、`SCSHOCK
    PA`或`SCHRUTE PA`，但它仍然会与`PARKER SC`形成特殊对。
- en: Let’s refer to the first two characters of a city name followed by the city’s
    state as a *combo*. For example, the combo for `SCRANTON PA` is `SCPA`, and the
    combo for `PARKER SC` is `PASC`.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将城市名称的前两个字符与城市所在州的简称组合称为*组合*（combo）。例如，`SCRANTON PA`的组合是`SCPA`，而`PARKER SC`的组合是`PASC`。
- en: Rather than searching for special pairs of cities, we can now look at special
    pairs of combos. Let’s try this.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以不再搜索特殊城市对，而是寻找特殊组合对。让我们试试看。
- en: There are two cities with the combo `MAMI`. They happen to be `MANISTEE MI`
    and `MADISON MI`, but all we care about is that there are two of them. The `MAMI`
    cities start with `MA` and are in state `MI`. To count up the special pairs involving
    `MAMI` cities, we need to know the cities that start with `MI` and have state
    `MA`. That is, we need to know the number of `MIMA` cities. There are three `MIMA`
    cities. They happen to be `MIDDLEBOROUGH MA`, `MILFORD MA`, and `MIDDLETON MA`,
    but all we care about is that there are three of them. Okay—so we have two `MAMI`
    cities and three `MIMA` cities. The total special pairs for these combos is therefore
    2 * 3 = 6, because for each of the two `MAMI` cities, we have a choice of three
    `MIMA` cities.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个城市的组合是`MAMI`。它们分别是`MANISTEE MI`和`MADISON MI`，但我们关心的是它们的数量是两个。`MAMI`城市以`MA`开头，且位于`MI`州。为了统计涉及`MAMI`城市的特殊城市对，我们需要知道那些以`MI`开头、且位于`MA`州的城市。也就是说，我们需要知道`MIMA`城市的数量。共有三个`MIMA`城市。它们分别是`MIDDLEBOROUGH
    MA`，`MILFORD MA`，和`MIDDLETON MA`，但我们关心的是它们的数量是三个。好——所以我们有两个`MAMI`城市和三个`MIMA`城市。因而，这些组合的总特殊城市对为2
    * 3 = 6，因为对于每一个`MAMI`城市，我们都有三种选择的`MIMA`城市。
- en: 'If you’re not convinced, here are the six special pairs for these combos:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还不信服，以下是这些组合的六对特殊城市：
- en: '`MANISTEE MI` and `MIDDLEBOROUGH MA`'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MANISTEE MI` 和 `MIDDLEBOROUGH MA`'
- en: '`MANISTEE MI` and `MILFORD MA`'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MANISTEE MI` 和 `MILFORD MA`'
- en: '`MANISTEE MI` and `MIDDLETON MA`'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MANISTEE MI` 和 `MIDDLETON MA`'
- en: '`MADISON MI` and `MIDDLEBOROUGH MA`'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MADISON MI` 和 `MIDDLEBOROUGH MA`'
- en: '`MADISON MI` and `MILFORD MA`'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MADISON MI` 和 `MILFORD MA`'
- en: '`MADISON MI` and `MIDDLETON MA`'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MADISON MI` 和 `MIDDLETON MA`'
- en: If we could map combos—`SCPA`, `PASC`, `MAMI`, `MIMA`, and so on—to the number
    of occurrences, we could loop through the combos to find the number of special
    pairs of cities. A dictionary is the perfect tool to store this mapping.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能够将组合——`SCPA`，`PASC`，`MAMI`，`MIMA`等——映射到出现次数，我们就可以遍历这些组合来找出特殊城市对的数量。字典是存储这种映射的完美工具。
- en: 'Here’s the dictionary that we’d like to create for our test case:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们希望为测试用例创建的字典：
- en: '[PRE67]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: With this dictionary, we can figure out the number of special pairs of cities.
    Let’s work through the process.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个字典，我们可以计算出特殊城市对的数量。让我们一步步做这个过程。
- en: The first key is `'SCPA'`; its value is `1`. To find special pairs of cities
    involving `'SCPA'`, we need to look up the value for `'PASC'`. That value is also
    `1`. We multiply the two values together, yielding 1 * 1 = 1 special pair of cities
    involving these combos. We need to carry out this same procedure for each other
    key in the dictionary.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个键是`'SCPA'`；它的值是`1`。为了查找涉及`'SCPA'`的特殊城市对，我们需要查找`'PASC'`的值。该值也是`1`。我们将这两个值相乘，得到
    1 * 1 = 1 对涉及这些组合的特殊城市。我们需要对字典中的其他每个键执行相同的操作。
- en: The next key is `'MAMI'`; its value is `2`. To find special pairs of cities
    involving `'MAMI'`, we need to look up the value for `'MIMA'`. That value is `3`.
    We multiply the two values together, yielding 2 * 3 = 6 special pairs of cities
    involving these combos. With the 1 we found previously, we now have a total of
    7.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个键是`'MAMI'`；它的值是`2`。为了查找涉及`'MAMI'`的特殊城市对，我们需要查找`'MIMA'`的值。该值是`3`。我们将这两个值相乘，得到
    2 * 3 = 6 对涉及这些组合的特殊城市。加上之前找到的1，我们现在一共有7对。
- en: The next key is `'NANH'`; its value is `1`. To find special pairs of cities
    involving `'NANH'`, we need to look up the value for `'NHNA'`. But `'NHNA'` isn’t
    a key in the dictionary! There are no special pairs of cities involving these
    combos. We still have a total of 7.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个键是`'NANH'`；它的值是`1`。为了查找涉及`'NANH'`的特殊城市对，我们需要查找`'NHNA'`的值。但是`'NHNA'`不是字典中的键！因此没有涉及这些组合的特殊城市对。我们仍然总共有7对。
- en: 'Pay close attention to this next one. The next key is `''PASC''`; its value
    is `1`. To find special pairs of cities involving `''PASC''`, we need to look
    up the value for `''SCPA''`. That value is also `1`. We multiply the two values
    together, yielding 1 * 1 = 1 special pair of cities involving these combos. But
    wait: we already accounted for this pair when we processed the key `''SCPA''`.
    If we add 1 here, then we’ll end up double-counting this pair. In fact, by processing
    each key we will double-count *every* special pair of cities. Not to worry, though:
    we’ll make an adjustment later when we’re ready to print the final answer. Let’s
    add this 1 in there. With the 7 we found previously, we now have a total of 8.'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意接下来的这一点。下一个关键字是 `'PASC'`；它的值是 `1`。要找到涉及 `'PASC'` 的特殊城市配对，我们需要查找 `'SCPA'`
    的值。它的值也是 `1`。我们将这两个值相乘，得到 1 * 1 = 1 对涉及这些组合的特殊城市配对。但是等一下：我们在处理 `'SCPA'` 关键字时已经计算过这对配对。如果我们再加
    1，那么我们会重复计算这对配对。事实上，通过处理每个关键字，我们将重复计算*每一对*特殊城市配对。别担心：当我们准备输出最终答案时，我们会做调整。我们就先把这个
    1 加进去。再加上之前找到的 7 个，我们现在总共有 8 个。
- en: The next key is `'LACO'`; its value is `2`. The value for `'COLA'` is `1`, giving
    2 * 1 = 2 special pairs of cities involving these combos. With the 8 we found
    previously, we now have a total of 10.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个关键字是 `'LACO'`；它的值是 `2`。`'COLA'` 的值是 `1`，因此这两个组合涉及的城市特殊配对数量为 2 * 1 = 2。再加上我们之前找到的
    8 个，现在总共有 10 个。
- en: There are two keys to go, `'MIMA'` and `'COLA'`. The first leads us to add 6
    to our total; the second leads us to add 2\. With the 10 we found previously,
    we now have a total of 18.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 还有两个关键字，`'MIMA'` 和 `'COLA'`。第一个让我们在总数上加上 6，第二个让我们加上 2。加上之前找到的 10，现在总共有 18 个。
- en: Remember that we’ve double-counted every special pair of cities. We don’t have
    18 unique special pairs of cities, then. We have only 18 / 2 = 9 special pairs
    of cities. All we need to do is divide by 2 to undo the double counting.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们已经重复计算了每一对特殊城市配对。因此，我们并不拥有 18 对独特的特殊城市配对。我们只有 18 / 2 = 9 对特殊城市配对。我们只需要除以
    2 来消除重复计算的结果。
- en: If you compare the dictionary we just went through to the cities in the test
    case, you’ll notice that something is missing from the dictionary. It’s that city
    `WASHOUGAL WA`! Its combo is `WAWA`, but there’s no `'WAWA'` key in our dictionary.
    We’re not accounting for this city, and we need to understand why.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将我们刚才分析的字典与测试用例中的城市进行比较，你会发现字典中缺少了一些内容。那就是城市 `WASHOUGAL WA`！它的组合是 `WAWA`，但在我们的字典中并没有
    `'WAWA'` 这个关键字。我们没有考虑到这个城市，需要弄清楚为什么。
- en: The first two characters of `WASHOUGAL WA` are `WA`. This means that the only
    way for `WASHOUGAL WA` to be part of a special pair of cities is to find another
    city whose state is `WA`. Notice that `WASHOUGAL WA` is in state `WA`, too. However,
    the problem specifies that the two cities in a special pair of cities must come
    from different states. There’s therefore no way to find a special pair of cities
    involving `WASHOUGAL WA`. To make sure we don’t accidentally count fake special
    pairs, we don’t even include `WASHOUGAL WA` in the dictionary.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '`WASHOUGAL WA` 的前两个字符是 `WA`。这意味着 `WASHOUGAL WA` 要成为特殊配对城市的一部分，唯一的方法是找到另一个州为
    `WA` 的城市。请注意，`WASHOUGAL WA` 也位于 `WA` 州。然而，问题规定，特殊配对城市的两个城市必须来自不同的州。因此，无法找到涉及 `WASHOUGAL
    WA` 的特殊配对城市。为了确保我们不会错误地计算伪特殊配对，我们甚至不会将 `WASHOUGAL WA` 包含在字典中。'
- en: Solving the Problem
  id: totrans-379
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决问题
- en: We’re ready to go! We can use a dictionary for a concise, rocket-fast solution
    to Cities and States. The code is in [Listing 8-7](ch08.xhtml#ch08ex07).
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 我们准备好了！我们可以使用字典来快速且简洁地解决城市和州问题。代码见 [清单 8-7](ch08.xhtml#ch08ex07)。
- en: '[PRE68]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '*Listing 8-7: Solving Cities and States*'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-7：解决城市和州问题*'
- en: This is a USACO problem where we need to use files rather than standard input
    and standard output.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 USACO 问题，需要使用文件而不是标准输入和标准输出。
- en: The dictionary that we’ll build is called `combo_to_num` ❶. It maps from four-character
    combos, like `'SCPA'`, to the number of cities with that combo.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建的字典叫做 `combo_to_num` ❶。它将四个字符的组合，如 `'SCPA'`，映射到具有该组合的城市数量。
- en: For each city from the input, we use variables to refer to the first two characters
    of the name of the city ❷ and its state. Then, if these values are not the same
    ❸, we combine them and add the combo to the dictionary. If the combo wasn’t already
    in the dictionary, we add it with a value of 1; if it was already there, we increase
    its value by 1.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 对于输入中的每个城市，我们使用变量来表示城市名称的前两个字符 ❷ 以及它的州。然后，如果这些值不同 ❸，我们将它们组合并将组合添加到字典中。如果该组合尚不存在于字典中，我们将其添加并赋值为
    1；如果已存在，则将其值加 1。
- en: The dictionary is now built. We loop through its keys ❹. For each key, we construct
    the other combo that we need to look up to find special pairs of cities involving
    this key. If the key is `'SCPA'`, for example, then we want the other combo to
    be `'PASC'`. To do that, we take the rightmost two characters of the key and follow
    those by the leftmost two characters ❺. If that other combo is also in the dictionary,
    then we multiply the two key’s values and add that to our total ❻.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 字典现在已经建立。我们遍历它的键 ❹。对于每个键，我们构造需要查找的另一组，以找到涉及该键的特殊城市对。例如，如果键是`'SCPA'`，那么我们希望另一组是`'PASC'`。为此，我们取键的最右两个字符，然后跟随左侧两个字符
    ❺。如果另一组也在字典中，那么我们将两个键的值相乘并添加到我们的总数 ❻。
- en: All we need to do now is output the total number of special pairs of cities
    to the output file. As explained in the previous section, we need to divide our
    total by 2 ❼ to undo the double-counting that results from processing each key
    in the dictionary.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需将特殊城市对的总数输出到输出文件中。如前一节所述，我们需要将总数除以2 ❼，以消除处理字典中每个键时导致的重复计数。
- en: 'There we have it: another example of solving a problem with a suitable deployment
    of a dictionary. Feel free to submit our code!'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样：用适当的字典部署解决问题的另一个例子。随时提交我们的代码！
- en: Summary
  id: totrans-389
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about Python sets and dictionaries. A set is a collection
    of values with no order and no duplicates. A dictionary is a collection of `key:value`
    pairs. As we saw in this chapter’s problems, sometimes these collections are more
    appropriate than lists. For example, determining whether a value is in a set is
    ridiculously fast compared to the same operation on a list. If we don’t care about
    the order of values or want to eliminate duplicates, we should seriously consider
    using a set.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了Python集合和字典。集合是一组没有顺序且没有重复值的数据。字典是一组`键:值`对。正如我们在本章的问题中看到的那样，有时这些集合比列表更合适。例如，确定值是否在集合中的操作比在列表上进行同样的操作要快得多。如果我们不关心值的顺序或想要消除重复值，我们应该认真考虑使用集合。
- en: Similarly, a dictionary makes it easy to determine the value mapped to by a
    key. If we’re maintaining a mapping from keys to values, then we should seriously
    consider using a dictionary.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，字典使得确定由键映射到的值变得容易。如果我们在维护从键到值的映射，那么我们应该认真考虑使用字典。
- en: With sets and dictionaries in the mix, you now have more flexibility for how
    to store your values. This flexibility, however, means that you need to make a
    choice. Don’t default to using a list anymore! The difference between using one
    type or another might be the difference between solving the problem or not.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在集合和字典混合使用的情况下，你现在有更多的灵活性来存储你的值。然而，这种灵活性意味着你需要做出选择。不要再默认使用列表！使用一种类型还是另一种类型可能是解决问题与否的关键。
- en: We’ve reached an important milestone, as we’ve now covered most of the Python
    that I’ll be teaching you in this book. This doesn’t mean that your Python journey
    is complete. There’s a lot more to know about Python beyond what I’ve included
    in the book. This does mean, though, that we’ve reached a point where we can solve
    a wide variety of problems—in competitive programming or otherwise—with our Python
    skills.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经达到了一个重要的里程碑，因为我们现在已经涵盖了本书中我将教给你的大部分Python知识。这并不意味着你的Python之旅结束了。关于Python，书中未包含的内容还有很多。不过，这意味着我们已经达到了一个可以用我们的Python技能解决各种问题的地步，无论是在竞技编程中还是其他方面。
- en: 'In the next chapter of the book, we shift gears: from learning new Python features
    to sharpening our problem-solving ability. We’ll focus on one particular type
    of problem that we can solve by searching through all candidate solutions.'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 在书的下一章中，我们将换个角度：从学习新的Python特性转向提升我们的问题解决能力。我们将专注于通过搜索所有候选解决方案来解决一类特定的问题。
- en: Chapter Exercises
  id: totrans-395
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 章节练习
- en: Here are some exercises for you to try. For each, use a set or dictionary. Sometimes,
    a set or dictionary will help you write code that runs faster; other times, it
    will help you write code that’s more organized and easier to read.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些练习供你尝试。对于每个练习，使用一个集合或字典。有时，使用集合或字典可以帮助你编写运行更快的代码；其他时候，它可以帮助你编写更有组织、更易于阅读的代码。
- en: DMOJ problem `crci06p1`, Bard
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ问题 `crci06p1`，巴德
- en: DMOJ problem `dmopc19c5p1`, Conspicuous Cryptic Checklist
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ问题 `dmopc19c5p1`，显眼的神秘清单
- en: DMOJ problem `coci15c2p1`, Marko
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ问题 `coci15c2p1`，Marko
- en: DMOJ problem `ccc06s2`, Attack of the CipherTexts
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ问题 `ccc06s2`，密文攻击
- en: DMOJ problem `dmopc19c3p1`, Mode Finding
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ问题 `dmopc19c3p1`，找众数
- en: 'DMOJ problem `coci14c2p2`, Utrka (Try solving this one in three different ways:
    using a dictionary, using a set, and using lists!)'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ 问题 `coci14c2p2`，Utrka（尝试通过三种不同方式解决此问题：使用字典、使用集合和使用列表！）
- en: 'DMOJ problem `coci17c2p2`, ZigZag (Hint: maintain two dictionaries. The first
    maps each starting letter to its list of words; the second maps each starting
    letter to the index of its next word that will be output. That way, we can cycle
    through the words for each letter without having to explicitly update numbers
    of occurrences or modify lists.)'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ 问题 `coci17c2p2`，ZigZag（提示：维护两个字典。第一个字典将每个起始字母映射到其单词列表；第二个字典将每个起始字母映射到其下一个将要输出的单词的索引。这样，我们可以循环遍历每个字母的单词，而无需显式更新出现次数或修改列表。）
- en: Notes
  id: totrans-404
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: Email Addresses is originally from the 2019 Educational Computing Organization
    of Ontario Programming Contest, Round 2\. Common Words is originally from the
    1999 Canadian Computing Olympiad. Cities and States is originally from the USACO
    2016 December Silver Contest.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: Email Addresses 最初来自 2019 年安大略省教育计算组织编程竞赛第二轮。Common Words 最初来自 1999 年加拿大计算奥林匹克竞赛。Cities
    and States 最初来自 2016 年美国计算机奥林匹克银奖竞赛。
- en: If you’d like to learn more about Python, I recommend *Python Crash Course*,
    2nd edition by Eric Matthes (No Starch Press, 2019). When you’re ready to take
    it to the next level, you might like to read *Effective Python*, 2nd edition by
    Brett Slatkin (Addison-Wesley Professional, 2020), which offers a collection of
    tips to help you write better Python code.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想深入了解 Python，我推荐*Python Crash Course*，第二版，由 Eric Matthes 编写（No Starch Press，2019）。当你准备好提升到下一个层次时，你可能会喜欢阅读*Effective
    Python*，第二版，由 Brett Slatkin 编写（Addison-Wesley Professional，2020），它提供了一些技巧，帮助你编写更好的
    Python 代码。
