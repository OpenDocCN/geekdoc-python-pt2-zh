- en: '6'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '6'
- en: CREATING OSCILLATIONS WITH TRIGONOMETRY
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用三角学创建振荡
- en: '*I’ve got an oscillating fan at my house. The fan goes back and forth. It looks
    like the fan is saying “No.” So I like to ask it questions that a fan would say
    “No” to. “Do you keep my hair in place? Do you keep my documents in order? Do
    you have three settings? Liar!” My fan lied to me.—Mitch Hedberg*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*我家有一台振荡风扇。风扇来回摆动。它看起来像是在说“不”。所以我喜欢问它一些风扇会说“不”的问题。“你能保持我的头发整齐吗？你能保持我的文件整齐吗？你有三个档位吗？骗子！”我的风扇骗了我。——米奇·赫德伯格*'
- en: '![image](../images/fintro-01.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fintro-01.jpg)'
- en: '*Trigonometry* literally means the study of triangles. Specifically, it is
    the study of right triangles and the special ratios that exist between their sides.
    Judging from what’s taught in a traditional trigonometry class, though, you’d
    think that’s where it ends. [Figure 6-1](ch06.xhtml#ch06fig1) shows just one part
    of a typical trigonometry homework assignment.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*三角学*字面意思是研究三角形。具体来说，它是研究直角三角形以及它们的边之间存在的特殊比率。然而，从传统三角学课程中所教授的内容来看，你可能会认为就到此为止。[图6-1](ch06.xhtml#ch06fig1)展示了典型三角学家庭作业的一部分。'
- en: '![image](../images/f104-01.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f104-01.jpg)'
- en: '*Figure 6-1: Question after question in traditional trig class on unknown sides
    in triangles*'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-1：传统三角学课堂中关于三角形未知边的一个个问题*'
- en: 'This is the kind of task most people remember from their trigonometry class,
    where solving for unknown sides in a triangle is a common assignment. *But this
    is seldom how trig functions are used in reality*. The more common uses of trig
    functions such as sine and cosine are for oscillating motion, like water, light,
    and sound waves. Suppose you take your graphing code from *grid.pyde* in [Chapter
    4](ch04.xhtml#ch04) and change the function to the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是大多数人记得的三角学课程任务，解未知三角形边长是常见的作业。*但实际上，三角函数很少是这样使用的*。正弦和余弦等三角函数更常见的用途是用于振荡运动，比如水波、光波和声波。假设你把[第4章](ch04.xhtml#ch04)中*grid.pyde*的绘图代码拿来，并将函数改成如下：
- en: 'def f(x):'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 'def f(x):'
- en: return sin(x)
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: return sin(x)
- en: In this case, you’d get this output shown in [Figure 6-2](ch06.xhtml#ch06fig2).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你将得到[图6-2](ch06.xhtml#ch06fig2)中所示的输出。
- en: '![image](../images/f104-02.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f104-02.jpg)'
- en: '*Figure 6-2: A sine wave*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-2：正弦波*'
- en: The values on the x-axis are the radians, the input of the sine function. The
    y-axis is the output. If you put sin(1) into your calculator or the Python shell,
    you’ll get out a long decimal starting with 0.84. . . . That’s the height of the
    curve when x = 1\. It’s almost at the top of the curve in [Figure 6-2](ch06.xhtml#ch06fig2).
    Put sin(3) into the calculator and you’ll get 0.14. . . . On the curve, you can
    see it’s almost on the x-axis when x = 3\. Enter any other values for x, and the
    output should follow this up-and-down pattern, *oscillating* between 1 and –1\.
    The wave takes just over six units to make a complete wave, or one *wavelength*,
    which we also call the *period* of the function. The period of the sine function
    is 2π, or 6.28 radians in Processing and Python. In school, you won’t go any further
    than drawing lots of waves like this. But in this chapter, you’ll use sine, cosine,
    and tangent to simulate oscillating motion in real time. You’ll also use trigonometry
    to make some interesting, dynamic, interactive sketches in Processing. The main
    trig functions are shown in [Figure 6-3](ch06.xhtml#ch06fig3).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: x轴上的数值是弧度，表示正弦函数的输入。y轴是输出。如果你在计算器或Python终端中输入sin(1)，你会得到一个以0.84开始的长小数。……这就是当x
    = 1时曲线的高度。它几乎位于[图6-2](ch06.xhtml#ch06fig2)中曲线的顶部。输入sin(3)到计算器中，你会得到0.14……在曲线上，你可以看到当x
    = 3时，它几乎在x轴上。输入其他任何x值，输出应该遵循这种上下波动的模式，*在1和-1之间振荡*。该波形需要超过六个单位才能完成一个完整的波形，或者一个*波长*，我们也称之为该函数的*周期*。正弦函数的周期是2π，或者在Processing和Python中为6.28弧度。在学校，你不会再做更多的事情，除了像这样画很多波形。但在本章中，你将使用正弦、余弦和正切来模拟实时的振荡运动。你还将使用三角学在Processing中制作一些有趣的动态交互式草图。[图6-3](ch06.xhtml#ch06fig3)展示了主要的三角函数。
- en: '![image](../images/f105-01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f105-01.jpg)'
- en: '*Figure 6-3: The ratios of the sides of a right triangle*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-3：直角三角形的边比*'
- en: We’ll use trig functions to generate polygons of any number of sides as well
    as stars with any (odd) number of prongs. After that, you’ll create a sine wave
    from a point rotating around a circle. You’ll draw Spirograph- and harmonograph-type
    designs, which require trig functions. You’ll also oscillate a wave of colorful
    points in and out of a circle!
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用三角函数生成任意边数的多边形以及具有任意（奇数）齿数的星形。之后，你将创建一个从围绕圆旋转的点生成的正弦波。你将绘制Spirograph和harmonograph类型的设计，这些设计需要使用三角函数。你还将让一波五颜六色的点在圆圈内外振荡！
- en: Let’s start by discussing how using trig functions is going to make transforming,
    rotating, and oscillating shapes much easier than before.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先讨论一下，如何使用三角函数使得变换、旋转和振荡形状比以前更加容易。
- en: USING TRIGONOMETRY FOR ROTATIONS AND OSCILLATIONS
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用三角学进行旋转和振荡
- en: 'First of all, sines and cosines make rotations a cinch. In [Figure 6-3](ch06.xhtml#ch06fig3),
    sin A is expressed as the opposite side divided by the hypotenuse, or side a divided
    by side c:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，正弦和余弦使得旋转变得非常简单。在[图6-3](ch06.xhtml#ch06fig3)中，sin A被表示为对边除以斜边，或者说是a边除以c边：
- en: '![image](../images/e105-01.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e105-01.jpg)'
- en: 'Solve this for side a, and you get the hypotenuse times the sine of A:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 解这个方程，得到斜边乘以角A的正弦：
- en: a = c Sin A
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: a = c Sin A
- en: Therefore, the y-coordinate of a point can be expressed as the distance from
    the origin times the sine of the angle the point makes with the horizontal. Imagine
    a circle with radius r, the hypotenuse of the triangle, rotating around the point
    at (0,0), as shown in [Figure 6-4](ch06.xhtml#ch06fig4).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个点的y坐标可以表示为从原点到该点的距离乘以该点与水平线的夹角的正弦。想象一个半径为r的圆，它是三角形的斜边，围绕(0,0)点旋转，如[图6-4](ch06.xhtml#ch06fig4)所示。
- en: '![image](../images/f106-01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f106-01.jpg)'
- en: '*Figure 6-4: Polar form of coordinates of a point*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-4：点的极坐标形式*'
- en: To rotate a point, we’re going to keep the radius of the circle constant and
    simply vary theta, the angle. The computer is going to do the hard part of recalculating
    all the positions of the point by multiplying the radius r by the cosine or sine
    of the angle theta! We also need to remember that sine and cosine expect radian
    input, not degrees. Fortunately, you’ve already learned how easy it is to use
    Processing’s built-in radians() and degrees() functions to convert to whatever
    units we want.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要旋转一个点，我们将保持圆的半径不变，只改变θ角度。计算机会通过将半径r与角度θ的余弦或正弦相乘，来重新计算点的所有位置！我们还需要记住，正弦和余弦期望的是弧度输入，而不是角度。幸运的是，你已经学会了如何轻松使用Processing的内置函数radians()和degrees()来进行单位转换。
- en: WRITING FUNCTIONS TO DRAW POLYGONS
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写函数绘制多边形
- en: Thinking about vertices as points that rotate around a center makes creating
    polygons very easy. Recall that a polygon is a many-sided figure; a *regular polygon*
    is made by connecting a certain number of points equally spaced around a circle.
    Remember how much geometry we needed to know to draw an equilateral triangle in
    [Chapter 5](ch05.xhtml#ch05)? With trigonometry functions helping us with rotations,
    all we have to do to draw polygons is use [Figure 6-4](ch06.xhtml#ch06fig4) to
    create a polygon function.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 将顶点视为绕中心旋转的点，使得创建多边形变得非常简单。回想一下，多边形是一个多边形状；一个*正多边形*是通过连接一定数量均匀分布在圆周上的点来构成的。记得在[第5章](ch05.xhtml#ch05)中，我们需要多少几何知识来绘制一个等边三角形吗？有了三角函数帮助我们旋转，我们绘制多边形所需要做的就是使用[图6-4](ch06.xhtml#ch06fig4)来创建一个多边形函数。
- en: Open a new sketch in Processing and save it as *polygon.pyde*. Then enter the
    code in [Listing 6-1](ch06.xhtml#ch06list1) to make a polygon using by the vertex()
    function.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在Processing中打开一个新的草图并将其保存为*polygon.pyde*。然后输入[清单6-1](ch06.xhtml#ch06list1)中的代码，使用vertex()函数绘制一个多边形。
- en: '*polygon.pyde*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*polygon.pyde*'
- en: 'def setup():'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 'def setup():'
- en: size(600,600)
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: size(600,600)
- en: 'def draw():'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 'def draw():'
- en: beginShape()
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: beginShape()
- en: vertex(100,100)
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: vertex(100,100)
- en: vertex(100,200)
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: vertex(100,200)
- en: vertex(200,200)
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: vertex(200,200)
- en: vertex(200,100)
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: vertex(200,100)
- en: vertex(150,50)
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: vertex(150,50)
- en: endShape(CLOSE)
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: endShape(CLOSE)
- en: '*Listing 6-1: Drawing a polygon using vertex()*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单6-1：使用vertex()绘制多边形*'
- en: We could always draw polygons using line(), but once we connect all the lines,
    we couldn’t fill in the shape with color. The Processing functions beginShape()
    and endShape() define any shape we want by using the vertex() function to say
    where the points of the shape should be. This lets us create as many vertices
    as we want.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们总是可以使用line()函数绘制多边形，但一旦我们连接了所有的线条，就无法用颜色填充形状。Processing函数beginShape()和endShape()通过使用vertex()函数定义我们想要的任何形状，告诉程序形状的点应该在哪里。这使得我们可以创建任意数量的顶点。
- en: We always start the shape with beginShape(), list all the points on the shape
    by sending them to the vertex() function, and finally end the shape with endShape().
    If we put CLOSE inside the endShape() function, the program will connect the last
    vertex with the first vertex.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们总是从 beginShape() 开始绘制形状，通过将所有的点发送到 vertex() 函数来列出形状上的所有点，最后用 endShape() 结束形状。如果我们在
    endShape() 函数中添加 CLOSE，程序将把最后一个顶点与第一个顶点连接起来。
- en: When you run this code, you should see something like [Figure 6-5](ch06.xhtml#ch06fig5).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这段代码时，应该会看到类似[图 6-5](ch06.xhtml#ch06fig5)的内容。
- en: '![image](../images/f107-01.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f107-01.jpg)'
- en: '*Figure 6-5: A house-shaped polygon made from vertices*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-5：由顶点构成的房子形状多边形*'
- en: However, it’s laborious to enter more than four or five points manually. It
    would be great if we could just rotate a single point around another point using
    a loop. Let’s try that next.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，手动输入超过四个或五个点非常繁琐。如果我们能通过循环将一个点围绕另一个点旋转，那就太好了。接下来我们就来尝试这个方法。
- en: DRAWING A HEXAGON WITH LOOPS
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用循环绘制六边形
- en: Let’s use a for loop to create six vertices of a hexagon using the code in [Listing
    6-2](ch06.xhtml#ch06list2).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 for 循环来创建六个顶点的六边形，代码见[清单 6-2](ch06.xhtml#ch06list2)。
- en: '*polygon.pyde*'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*polygon.pyde*'
- en: 'def draw():'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 'def draw():'
- en: translate(width/2,height/2)
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: translate(width/2,height/2)
- en: beginShape()
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: beginShape()
- en: 'for i in range(6):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(6):'
- en: vertex(100,100)
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: vertex(100,100)
- en: rotate(radians(60))
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: rotate(radians(60))
- en: endShape(CLOSE)
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: endShape(CLOSE)
- en: '*Listing 6-2: Trying to use rotate() inside a for loop*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-2：尝试在 for 循环中使用 rotate()*'
- en: However, you’ll find out that if you run this code, you get a blank screen!
    You can’t use the rotate() function inside a shape because this function spins
    the entire coordinate system. This is *precisely* why we need the sine and cosine
    notation you saw in [Figure 6-4](ch06.xhtml#ch06fig4) to rotate the vertices!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你会发现如果运行这段代码，你将看到一个空白屏幕！你不能在形状内使用 rotate() 函数，因为该函数会旋转整个坐标系。这正是我们需要你在[图 6-4](ch06.xhtml#ch06fig4)中看到的正弦和余弦表示法来旋转顶点的原因！
- en: '[Figure 6-6](ch06.xhtml#ch06fig6) shows how the expression (r*cos(60*i),r*sin(60*i))
    creates each vertex of a hexagon. When i = 0, the angle in the parentheses will
    be 0 degrees; when i = 1, the angle will be 60 degrees; and so on.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-6](ch06.xhtml#ch06fig6)展示了表达式 (r*cos(60*i),r*sin(60*i)) 如何生成六边形的每个顶点。当
    i = 0 时，括号中的角度为 0 度；当 i = 1 时，角度为 60 度；依此类推。'
- en: '![image](../images/f108-01.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f108-01.jpg)'
- en: '*Figure 6-6: Using sines and cosines to rotate a point around the center*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用正弦和余弦将点旋转到中心周围*'
- en: 'To re-create this hexagon in code, we have to create a variable, r, that represents
    the distance from the center of rotation to each vertex, which won’t change. The
    only thing we need to change is the number of degrees in the sin() and cos() functions,
    which are all multiples of 60\. Generally, it can be written like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在代码中重新创建这个六边形，我们需要创建一个变量 r，表示从旋转中心到每个顶点的距离，这个值不会变化。我们唯一需要更改的是 sin() 和 cos()
    函数中的角度，这些角度都是 60 的倍数。通常可以这样写：
- en: 'for i in range(6):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(6):'
- en: vertex(r*cos(60*i),r*sin(60*i))
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: vertex(r*cos(60*i),r*sin(60*i))
- en: First, we make i go from 0 to 5 so that every vertex will be a multiple of 60
    (0, 60, 120, and so on), as shown in [Figure 6-7](ch06.xhtml#ch06fig7). Let’s
    change r to 100 and convert the degree numbers to radians so the code looks like
    [Listing 6-3](ch06.xhtml#ch06list3).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们让 i 从 0 到 5，这样每个顶点都会是 60 的倍数（0, 60, 120 等），如[图 6-7](ch06.xhtml#ch06fig7)所示。让我们将
    r 改为 100，并将角度数转换为弧度，这样代码就像[清单 6-3](ch06.xhtml#ch06list3)所示。
- en: '*polygon.pyde*'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*polygon.pyde*'
- en: 'def setup():'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 'def setup():'
- en: size(600,600)
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: size(600,600)
- en: 'def draw():'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 'def draw():'
- en: translate(width/2,height/2)
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: translate(width/2,height/2)
- en: beginShape()
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: beginShape()
- en: 'for i in range(6):'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(6):'
- en: vertex(100*cos(radians(60*i)),
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: vertex(100*cos(radians(60*i)),
- en: 100*sin(radians(60*i)))
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 100*sin(radians(60*i)))
- en: endShape(CLOSE)
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: endShape(CLOSE)
- en: '*Listing 6-3: Drawing a hexagon*'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-3：绘制六边形*'
- en: '![image](../images/f108-02.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f108-02.jpg)'
- en: '*Figure 6-7: A hexagon built with a vertex() function and a for loop*'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-7：使用 vertex() 函数和 for 循环构建的六边形*'
- en: Now that we’ve set r equal to 100 and converted the degrees to radians, when
    we run this code, we should see a hexagon like in [Figure 6-7](ch06.xhtml#ch06fig7).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将 r 设置为 100，并将角度转换为弧度，当我们运行这段代码时，应该会看到一个像[图 6-7](ch06.xhtml#ch06fig7)中的六边形。
- en: In fact, we could create a function to make *any* polygon this way!
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们可以创建一个函数来用这种方式绘制*任何*多边形！
- en: '#### DRAWING AN EQUILATERAL TRIANGLE'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 绘制一个等边三角形'
- en: Now let’s make an equilateral triangle using this function. [Listing 6-4](ch06.xhtml#ch06list4)
    shows a simpler way to make an equilateral triangle using looping instead of using
    square roots like we did in [Chapter 5](ch05.xhtml#ch05).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用这个函数绘制一个等边三角形。[列表 6-4](ch06.xhtml#ch06list4) 展示了一个更简单的方法，通过循环而不是像在 [第
    5 章](ch05.xhtml#ch05) 中那样使用平方根来绘制等边三角形。
- en: '*polygon.pyde*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*polygon.pyde*'
- en: 'def setup():'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 'def setup():'
- en: size(600,600)
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: size(600,600)
- en: 'def draw():'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 'def draw():'
- en: translate(width/2,height/2)
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: translate(width/2,height/2)
- en: 'polygon(3,100) #3 sides, vertices 100 units from the center'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 'polygon(3,100) #3 个边，顶点距中心 100 单位'
- en: 'def polygon(sides,sz):'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 'def polygon(sides,sz):'
- en: '''''''draws a polygon given the number'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '''''''根据边数绘制一个多边形'
- en: of sides and length from the center'''
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 边数和从中心到顶点的长度'''
- en: beginShape()
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: beginShape()
- en: 'for i in range(sides):'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(sides):'
- en: step = radians(360/sides)
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: step = radians(360/sides)
- en: vertex(sz*cos(i * step),
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: vertex(sz*cos(i * step),
- en: sz*sin(i * step))
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: sz*sin(i * step))
- en: endShape(CLOSE)
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: endShape(CLOSE)
- en: '*Listing 6-4: Drawing an equilateral triangle*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-4: 绘制一个等边三角形*'
- en: 'In this example, we create a polygon() function that draws a polygon given
    the number of sides (sides) and the size of the polygon (sz). The rotation for
    each vertex is 360 divided by sides. For our hexagon, we rotate by 60 degrees
    because there are six sides to a hexagon (360 / 6 = 60). The line polygon(3,100)
    calls the polygon function and passes two inputs: 3 for the number of sides and
    100 for the distance from the center to the vertices.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个 polygon() 函数，给定边数（sides）和多边形的大小（sz），即可绘制一个多边形。每个顶点的旋转角度是 360
    除以边数。对于我们的六边形，旋转角度是 60 度，因为六边形有六个边（360 / 6 = 60）。polygon(3,100) 这行代码调用了 polygon
    函数，并传入两个输入：3 代表边数，100 代表从中心到顶点的距离。
- en: Run this code and you should get what’s shown in [Figure 6-8](ch06.xhtml#ch06fig8).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这段代码，你应该能看到 [图 6-8](ch06.xhtml#ch06fig8) 中展示的内容。
- en: '![image](../images/f109-01.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f109-01.jpg)'
- en: '*Figure 6-8: An equilateral triangle!*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-8: 等边三角形！*'
- en: Now making regular polygons of any number of sides should be a breeze. No square
    roots necessary! [Figure 6-9](ch06.xhtml#ch06fig9) shows some sample polygons
    you can make using the polygon() function.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，制作任意边数的正多边形应该轻松得多。不再需要使用平方根！[图 6-9](ch06.xhtml#ch06fig9)展示了你可以使用 polygon()
    函数绘制的一些示例多边形。
- en: '![image](../images/f110-01.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f110-01.jpg)'
- en: '*Figure 6-9: All the polygons you want!*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-9: 所有你想要的多边形！*'
- en: Try updating the numbers in polygon(3,100) to see how the polygons change shape!
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试更新 polygon(3,100) 中的数字，看看多边形的形状如何变化！
- en: MAKING SINE WAVES
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 制作正弦波
- en: Like Mitch Hedberg’s fan at the beginning of the chapter, sines and cosines
    are for rotating and oscillating. Sine and cosine functions make waves when the
    height of a point on a circle is measured over time. To make this more concrete,
    let’s create a circle to visualize making sine waves by putting a point (shown
    as a red ellipse) on the circumference of the circle. As this point travels around
    the circle, its height over time will draw out a sine wave.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 就像本章开头提到的 Mitch Hedberg 的风扇一样，正弦和余弦用于旋转和振荡。当测量圆上某一点的高度随时间变化时，正弦和余弦函数会形成波动。为了让这一点更加具体，我们可以创建一个圆，来可视化通过将一个点（显示为红色椭圆）放置在圆的周长上而生成正弦波。当这个点沿圆周运动时，其高度随时间变化会绘制出正弦波。
- en: Start a new Processing sketch and save it as *CircleSineWave.pyde*. Create a
    big circle on the left side of the screen, like in [Figure 6-10](ch06.xhtml#ch06fig10).
    Try it yourself before looking at the code.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 开始一个新的 Processing 草图并保存为 *CircleSineWave.pyde*。在屏幕的左侧创建一个大圆，像 [图 6-10](ch06.xhtml#ch06fig10)
    中那样。在查看代码之前，先自己尝试一下。
- en: '![image](../images/f110-02.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f110-02.jpg)'
- en: '*Figure 6-10: The start of the sine wave sketch*'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-10: 正弦波草图的开始*'
- en: Listing 6-5 shows the code to make the sketch of a red point on the circumference
    of a big circle.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6-5 显示了绘制一个红点在大圆周长上的代码。
- en: '*CircleSineWave.pyde*'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*CircleSineWave.pyde*'
- en: 'r1 = 100 #radius of big circle'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 'r1 = 100 #大圆的半径'
- en: r2 = 10  #radius of small circle
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 'r2 = 10  #小圆的半径'
- en: 't = 0 #time variable'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 't = 0 #时间变量'
- en: 'def setup():'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 'def setup():'
- en: size(600,600)
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: size(600,600)
- en: 'def draw():'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 'def draw():'
- en: background(200)
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: background(200)
- en: '#move to left-center of screen'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '#移动到屏幕的左中心'
- en: translate(width/4,height/2)
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: translate(width/4,height/2)
- en: 'noFill() #don''t color in the circle'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 'noFill() #不填充圆'
- en: 'stroke(0) #black outline'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 'stroke(0) #黑色轮廓'
- en: ellipse(0,0,2*r1,2*r1)
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: ellipse(0,0,2*r1,2*r1)
- en: '#circling ellipse:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '#环绕椭圆：'
- en: 'fill(255,0,0) #red'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 'fill(255,0,0) #红色'
- en: y = r1*sin(t)
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: y = r1*sin(t)
- en: x = r1*cos(t)
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: x = r1*cos(t)
- en: ellipse(x,y,r2,r2)
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ellipse(x,y,r2,r2)
- en: '*Listing 6-5: Our circle and the point*'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-5: 我们的圆和点*'
- en: First, we declare variables for the radii of the circles, and we use t to represent
    the time it takes to make the point move. In draw(), we set the background to
    gray(200), translated to the center of the screen, and draw the big circle with
    radius r1. Next, we draw the circling ellipse by using our polar coordinates for
    x and y.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们声明了圆的半径变量，并使用t来表示使点移动所需的时间。在draw()中，我们将背景设置为灰色（200），并将原点移到屏幕的中心，然后绘制大圆。接下来，我们通过使用极坐标计算x和y来绘制旋转的椭圆。
- en: 'To make the ellipse rotate around the circle, all we have to do is vary the
    number inside the trig functions (in this case, t). At the end of the draw() function,
    we simply make the time variable go up by a little bit, like this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让椭圆绕圆旋转，我们只需要改变三角函数中的数字（在本例中是t）。在draw()函数的末尾，我们只需要让时间变量增加一点点，像这样：
- en: t += 0.05
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: t += 0.05
- en: 'If you try to run this code right now, you’ll get an error message about local
    variable ''t'' referenced before assignment. Python functions have local variables,
    but we want the draw() function to use the global time variable t. Therefore,
    we have to add the following line to the beginning of the draw() function:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在尝试运行这段代码，你会收到一个关于局部变量‘t’在赋值前被引用的错误信息。Python函数有局部变量，但我们希望draw()函数使用全局时间变量t。因此，我们必须在draw()函数的开始添加以下这一行：
- en: global t
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: global t
- en: Now you’ll see a red ellipse traveling along the circumference of the circle,
    as in [Figure 6-11](ch06.xhtml#ch06fig11).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你会看到一个红色椭圆沿圆的周长移动，就像[图 6-11](ch06.xhtml#ch06fig11)中所示。
- en: '![image](../images/f112-01.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f112-01.jpg)'
- en: '*Figure 6-11: The red ellipse travels along the circumference of the big circle*.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-11：红色椭圆沿大圆的周长移动*。'
- en: Now we need to choose a place over to the right of the screen to start drawing
    the wave. We’ll extend a green line from the red ellipse to, say, x = 200\. Add
    these lines to your draw() function right before t += 0.05. The full code for
    drawing the sine wave should look like [Listing 6-6](ch06.xhtml#ch06list6).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要在屏幕的右侧选择一个位置来开始绘制波形。我们将从红色椭圆延伸一条绿色线段，假设x = 200。将这些代码添加到draw()函数中，放在t +=
    0.05之前。绘制正弦波的完整代码应该像[Listing 6-6](ch06.xhtml#ch06list6)这样。
- en: '*CircleSineWave.pyde*'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*CircleSineWave.pyde*'
- en: 'r1 = 100 #radius of big circle'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 'r1 = 100 #大圆的半径'
- en: r2 = 10  #radius of small circle
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 'r2 = 10  #小圆的半径'
- en: 't = 0 #time variable'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 't = 0 #时间变量'
- en: 'def setup():'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 'def setup():'
- en: size(600,600)
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: size(600,600)
- en: 'def draw():'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 'def draw():'
- en: global t
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: global t
- en: background(200)
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: background(200)
- en: '#move to left-center of screen'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '#移动到屏幕的左侧中央'
- en: translate(width/4,height/2)
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: translate(width/4,height/2)
- en: 'noFill() #don''t color in the circle'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 'noFill() #不填充圆形'
- en: 'stroke(0) #black outline'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 'stroke(0) #黑色轮廓'
- en: ellipse(0,0,2*r1,2*r1)
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ellipse(0,0,2*r1,2*r1)
- en: '#circling ellipse:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '# 绕圈旋转的椭圆：'
- en: 'fill(255,0,0) #red'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 'fill(255,0,0) #红色'
- en: y = r1*sin(t)
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: y = r1*sin(t)
- en: x = r1*cos(t)
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: x = r1*cos(t)
- en: ellipse(x,y,r2,r2)
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ellipse(x,y,r2,r2)
- en: 'stroke(0,255,0) #green for the line'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 'stroke(0,255,0) #绿色线条'
- en: line(x,y,200,y)
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: line(x,y,200,y)
- en: 'fill(0,255,0) #green for the ellipse'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 'fill(0,255,0) #绿色用于椭圆'
- en: ellipse(200,y,10,10)
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ellipse(200,y,10,10)
- en: t += 0.05
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: t += 0.05
- en: '*Listing 6-6: Adding a line to draw the wave*'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 6-6: 添加一条线来绘制波形*'
- en: Here, we draw a green line on the same height (y-value) as the rotating red
    ellipse. This green line stays parallel to the horizontal, so as the red ellipse
    goes up and down, the green ellipse will be at the same height. When you run your
    program, you’ll see something like [Figure 6-12](ch06.xhtml#ch06fig12).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在与旋转红色椭圆相同的高度（y值）绘制了一条绿色线。这条绿色线保持与水平平行，因此当红色椭圆上下移动时，绿色椭圆将保持在同一高度。运行程序时，你将看到类似[图
    6-12](ch06.xhtml#ch06fig12)的效果。
- en: '![image](../images/f113-01.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f113-01.jpg)'
- en: '*Figure 6-12: Getting ready to draw the wave!*'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-12：准备绘制波形！*'
- en: You can see that we’ve added a green ellipse that only measures how far up and
    down the red ellipse moves, nothing else.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，我们添加了一个绿色椭圆，它仅用来测量红色椭圆上下移动的距离，其他没有任何作用。
- en: LEAVING A TRAIL
  id: totrans-171
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 留下轨迹
- en: 'Now we want the green ellipse to leave a trail to show its height over time.
    Leaving a trail really means that we save all the heights and display them—every
    loop. To save a bunch of things, like numbers, letters, words, points, and so
    on, we need a *list*. Add this line to the variables we declared at the beginning
    of the program, before the setup() function:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们希望绿色椭圆留下轨迹，显示它随时间变化的高度。留下轨迹实际上意味着我们保存所有的高度并显示它们——每次循环都这样做。为了保存很多东西，比如数字、字母、单词、点等等，我们需要一个*列表*。将这行代码添加到程序开始时声明的变量中，放在setup()函数之前：
- en: circleList = []
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: circleList = []
- en: 'This creates an empty list in which we’ll save the locations of the green ellipse.
    Add the circleList variable to the global line in the draw() function:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了一个空列表，我们将把绿色椭圆的位置保存在其中。将`circleList`变量添加到`draw()`函数中的全局行：
- en: global t, circleList
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: global t, circleList
- en: 'After we calculate x and y in the draw() function, we need to add the y-coordinate
    to the circleList, but there are a couple of different ways to do this. You already
    know the append() function, but this adds the point at the end of the list. We
    could use Python’s insert() function to put the new points at the beginning of
    the list, like so:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们计算了x和y值之后，接下来需要将y坐标添加到`circleList`中，但有几种不同的方法可以做到这一点。你已经知道了`append()`函数，但它会将点添加到列表的末尾。我们可以使用Python的`insert()`函数将新点放到列表的开头，像这样：
- en: circleList.insert(0,y)
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: circleList.insert(0,y)
- en: However, the list is going to get bigger every loop. We could limit its length
    to 250 by adding the new value to the first 249 items already in the list, as
    shown in [Listing 6-7](ch06.xhtml#ch06list7).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，列表会在每次循环时变大。我们可以通过将新值添加到前249个已有的项中来限制它的长度为250，具体方法见[Listing 6-7](ch06.xhtml#ch06list7)。
- en: y = r1*sin(t)
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: y = r1*sin(t)
- en: x = r1*cos(t)
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: x = r1*cos(t)
- en: '#add point to list:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '#将点添加到列表：'
- en: circleList = [y] + circleList[:249]
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: circleList = [y] + circleList[:249]
- en: '*Listing 6-7: Adding a point to a list and limiting the list to 250 points*'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 6-7：向列表中添加一个点并将列表限制为250个点*'
- en: The new line of code concatenates the list containing the y-value we just calculated
    and the first 249 items in the circleList. That 250-point list now becomes the
    new circleList.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 新的一行代码将包含我们刚刚计算出的y值和`circleList`中前249个项目的列表连接起来。这个包含250个点的列表现在就成了新的`circleList`。
- en: At the end of the draw() function (before incrementing t), we’ll put in a loop
    that iterates over all the elements of the circleList and draws a new ellipse,
    to look like the green ellipse is leaving a trail. This is shown in [Listing 6-8](ch06.xhtml#ch06list8).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在`draw()`函数的末尾（在递增`t`之前），我们会加入一个循环，遍历`circleList`的所有元素并绘制一个新的椭圆，使绿色椭圆看起来像是在留下轨迹。具体见[Listing
    6-8](ch06.xhtml#ch06list8)。
- en: '#loop over circleList to leave a trail:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '#遍历circleList以留下轨迹：'
- en: 'for i in range(len(circleList)):'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(len(circleList)):'
- en: '#small circle for trail:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '#轨迹的小圆：'
- en: ellipse(200+i,circleList[i],5,5)
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: ellipse(200+i,circleList[i],5,5)
- en: '*Listing 6-8: Looping over the circle list and drawing an ellipse at each point
    in the list*'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 6-8：遍历圆形列表并在每个点绘制一个椭圆*'
- en: This code uses a loop, with i going up from 0 to the length of the circleList
    and drawing an ellipse for each point in the list. The x-value starts at 200 and
    is incremented by whatever value i is. The y-value of the ellipse is the y-value
    we saved to the circleList.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使用了一个循环，`i`从0增加到`circleList`的长度，并在列表中的每个点上绘制一个椭圆。椭圆的x值从200开始，并根据`i`的值递增。椭圆的y值是我们保存到`circleList`中的y值。
- en: When you run this, you’ll see something like [Figure 6-13](ch06.xhtml#ch06fig13).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个时，你会看到类似[图6-13](ch06.xhtml#ch06fig13)的效果。
- en: '![image](../images/f114-01.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f114-01.jpg)'
- en: '*Figure 6-13: A sine wave!*'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-13：正弦波！*'
- en: You can see the wave being drawn out, leaving a green trail.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到波形被绘制出来，留下了绿色的轨迹。
- en: USING PYTHON’S BUILT-IN ENUMERATE() FUNCTION
  id: totrans-196
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用Python的内置`enumerate()`函数
- en: You can also draw an ellipse at each point in the list using Python’s built-in
    enumerate() function. It’s a handy and more “Pythonic” way of keeping track of
    the index and value of the items in a list. To see this in action, open a new
    file in IDLE and enter the code in [Listing 6-9](ch06.xhtml#ch06list9).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用Python的内置`enumerate()`函数，在列表中的每个点上绘制一个椭圆。这是一种方便且更“Pythonic”的方式，用来跟踪列表中项的索引和值。要看到这个的实际效果，打开IDLE中的新文件，并输入[Listing
    6-9](ch06.xhtml#ch06list9)中的代码。
- en: '>>> myList = ["I","love","using","Python"]'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> myList = ["I","love","using","Python"]'
- en: '>>> for index, value in enumerate(myList):'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> for index, value in enumerate(myList):'
- en: print(index,value)
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: print(index,value)
- en: 0 I
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 0 I
- en: 1 love
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 1 love
- en: 2 using
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 2 using
- en: 3 Python
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 3 Python
- en: '*Listing 6-9: Learning to use Python’s enumerate() function*'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 6-9：学习使用Python的`enumerate()`函数*'
- en: You’ll notice there are two variables (index and value) instead of just one
    (i). To use the enumerate() function in your circle list, you can use two variables
    to keep track of the iterator (i, the index) and the circle (c, the value), like
    in [Listing 6-10](ch06.xhtml#ch06list10).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到有两个变量（index和value），而不仅仅是一个（i）。要在`circleList`中使用`enumerate()`函数，你可以使用两个变量来跟踪迭代器（i，索引）和圆形（c，值），就像在[Listing
    6-10](ch06.xhtml#ch06list10)中那样。
- en: '#loop over circleList to leave a trail:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '#遍历circleList以留下轨迹：'
- en: 'for i,c in enumerate(circleList):'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i,c in enumerate(circleList):'
- en: '#small circle for trail:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '#轨迹的小圆：'
- en: ellipse(200+i,c,5,5)
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: ellipse(200+i,c,5,5)
- en: '*Listing 6-10: Using enumerate() to get the index and the value of every item
    in a list*'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: The final code should look like what you see in [Listing 6-11](ch06.xhtml#ch06list11).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '*CircleSineWave.pyde*'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'r1 = 100 #radius of big circle'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: r2 = 10  #radius of small circle
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 't = 0 #time variable'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: circleList = []
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'def setup():'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: size(600,600)
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'def draw():'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: global t, circleList
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: background(200)
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '#move to left-center of screen'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: translate(width/4,height/2)
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'noFill() #don''t color in the circle'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'stroke(0) #black outline'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: ellipse(0,0,2*r1,2*r1)
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '#circling ellipse:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 'fill(255,0,0) #red'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: y = r1*sin(t)
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: x = r1*cos(t)
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '#add point to list:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: circleList = [y] + circleList[:245]
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: ellipse(x,y,r2,r2)
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'stroke(0,255,0) #green for the line'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: line(x,y,200,y)
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'fill(0,255,0) #green for the ellipse'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: ellipse(200,y,10,10)
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '#loop over circleList to leave a trail:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'for i,c in enumerate(circleList):'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '#small circle for trail:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: ellipse(200+i,c,5,5)
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: t += 0.05
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 6-11: The final code for the* CircleSineWave.pyde *sketch*'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: This is the animation that’s usually shown to beginning trig students, and you’ve
    made your own version!
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: CREATING A SPIROGRAPH PROGRAM
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you know how to rotate circles and leave trails, let’s make a Spirograph-type
    model! *Spirograph* is a toy that’s made up of two overlapping circular gears
    that slide against each other. The gears have holes you can put pens and pencils
    through to draw cool, curvy designs. Many people played with Spirograph as kids,
    drawing the designs by hand. But we can make Spirograph-type designs using a computer
    and the sine and cosine code you just learned.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: First, start a new sketch in Processing called *spirograph.pyde*. Then add the
    code in [Listing 6-12](ch06.xhtml#ch06list12).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '*spirograph.pyde*'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 'r1 = 300.0 #radius of big circle'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'r2 = 175.0 #radius of circle 2'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: r3 = 5.0   #radius of drawing "dot"
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '#location of big circle:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: x1 = 0
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: y1 = 0
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 't = 0 #time variable'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'points = [] #empty list to put points in'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: 'def setup():'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: size(600,600)
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'def draw():'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: global r1,r2,x1,y1,t
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: translate(width/2,height/2)
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: background(255)
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: noFill()
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '#big circle'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: stroke(0)
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: ellipse(x1,y1,2*r1,2*r1)
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 6-12: Getting our big circle on the screen*'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: We first put a big circle in the middle of the screen and create variables for
    the big circle, and then we put a smaller circle on its circumference, like the
    discs in a Spirograph set.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: DRAWING THE SMALLER CIRCLE
  id: totrans-270
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s place the smaller circle on the circumference of the big circle, as in
    [Figure 6-14](ch06.xhtml#ch06fig14).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f117-01.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-14: The two circles*'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll make the smaller circle rotate around “inside” the bigger circle,
    just like a Spirograph gear. Update the code in [Listing 6-12](ch06.xhtml#ch06list12)
    with the code in [Listing 6-13](ch06.xhtml#ch06list13) to draw the second circle.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '#big circle'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: stroke(0)
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: ellipse(x1,y1,2*r1,2*r1)
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '#circle 2'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: x2 = (r1 - r2)
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: y2 = 0
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: ellipse(x2,y2,2*r2,2*r2)
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 6-13: Adding the smaller circle*'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: To make the smaller circle rotate around inside the bigger circle, we need to
    add the sine and cosine parts to the location of “circle 2” so it’ll oscillate.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: ROTATING THE SMALLER CIRCLE
  id: totrans-284
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Finally, at the very end of the draw() function, we have to increment our time
    variable, t, as in [Listing 6-14](ch06.xhtml#ch06list14).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '#big circle'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: stroke(0)
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: ellipse(x1,y1,2*r1,2*r1)
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '#circle 2'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: x2 = (r1 - r2)*cos(t)
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: y2 = (r1 - r2)*sin(t)
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: ellipse(x2,y2,2*r2,2*r2)
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: t += 0.05
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 6-14: The code to make the circle rotate*'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: This means circle 2 will oscillate up and down, and left and right, in a circular
    path inside the big circle. Run the code, and you should see circle 2 spinning
    nicely! But how about that hole on the gear where the pen sits and draws the trail?
    We’ll create a third ellipse to represent that point. Its location will be the
    second circle’s center plus the difference of the radii. The code for the “drawing
    dot” is shown in [Listing 6-15](ch06.xhtml#ch06list15).
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '#drawing dot'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: x3 = x2+(r2 - r3)*cos(t)
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: y3 = y2+(r2 - r3)*sin(t)
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: fill(255,0,0)
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: ellipse(x3,y3,2*r3,2*r3)
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 6-15: Adding the drawing dot*'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: When you run this code, you’ll see the drawing dot right on the edge of circle
    2, rotating as if circle 2 were sliding along circle 1’s circumference. Circle
    3 (the drawing dot) has to be a certain proportion between the center of circle
    2 and its circumference, so we need to introduce a proportion variable (prop)
    before the setup() function. Be sure to declare it as a global variable at the
    beginning of the draw() function, as you see in [Listing 6-16](ch06.xhtml#ch06list16).
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: prop = 0.9
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '*--snip--*'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: global r1,r2,x1,y1,t,prop
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '*--snip--*'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: x3 = x2+prop*(r2 - r3)*cos(t)
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: y3 = y2+prop*(r2 - r3)*sin(t)
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 6-16: Adding the proportion variable*'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have to figure out how fast the drawing dot rotates. It only takes a
    little algebra to prove its angular velocity (how fast it spins around) is the
    ratio of the size of the big circle to the little circle. Note that the negative
    sign means the dot spins in the opposite direction. Change the x3 and y3 lines
    in the draw() function to this:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: x3 = x2+prop*(r2 - r3)*cos(-((r1-r2)/r2)*t)
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: y3 = y2+prop*(r2 - r3)*sin(-((r1-r2)/r2)*t)
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: 'All that’s left is to save the dot (x3,y3) to a points list and draw lines
    between the points, just like we did in the wave sketch. Add the points list to the
    global line:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: global r1,r2,x1,y1,t,prop,points
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: After drawing the third ellipse, put the points into a list. This is the same
    procedure we used in *CircleSineWave.pyde* earlier in the chapter. Finally, go
    through the list and draw lines between the points, as in [Listing 6-17](ch06.xhtml#ch06list17).
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: fill(255,0,0)
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: ellipse(x3,y3,2*r3,2*r3)
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '#add points to list'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: points = [[x3, y3]] + points[:2000]
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: 'for i,p in enumerate(points): #go through the points list'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: 'if i < len(points)-1: #up to the next to last point'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: 'stroke(255,0,0) #draw red lines between the points'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: line(p[0],p[1],points[i+1][0],points[i+1][1])
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: t += 0.05
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 6-17: Graphing the points in the Spirograph*'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-17：绘制Spirograph中的点*'
- en: We used a similar trick for adding the points to the list in the circular wave
    example. We concatenated a list with the current point in it to a list with 2000
    of the items in the circleList. This automatically limits the number of points
    we’re saving to the points list. Run this code and watch the program draw a Spirograph,
    as shown in [Figure 6-15](ch06.xhtml#ch06fig15).
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在圆形波例子中使用了类似的方法将点添加到列表中。我们将包含当前点的列表与包含2000个圆形列表项的列表连接在一起。这会自动限制我们保存到点列表中的点的数量。运行这段代码并观察程序绘制Spirograph图形，如[图
    6-15](ch06.xhtml#ch06fig15)所示。
- en: '![image](../images/f119-01.jpg)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f119-01.jpg)'
- en: '*Figure 6-15: Drawing the Spirograph*'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-15：绘制Spirograph图形*'
- en: You can change the size of the second circle (r2) and the position of the drawing
    dot (prop) to draw different designs. For example, the Spirograph in [Figure 6-16](ch06.xhtml#ch06fig16)
    has r2 equal to 105 and prop equal to 0.8.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以改变第二个圆的大小（r2）和绘图点的位置（prop），以绘制不同的图形。例如，[图 6-16](ch06.xhtml#ch06fig16)中的Spirograph图形，r2为105，prop为0.8。
- en: '![image](../images/f120-01.jpg)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f120-01.jpg)'
- en: '*Figure 6-16: Another Spirograph design, created by changing r2 and prop*'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-16：通过改变r2和prop创建的另一种Spirograph设计*'
- en: So far, we’ve been making shapes oscillate up and down, or left and right, using
    sine and cosine, but what about making shapes oscillate in two different directions?
    We’ll try that next.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用正弦和余弦让形状上下或左右振荡，但如果要让形状在两个不同方向上振荡呢？接下来我们就尝试一下。
- en: MAKING HARMONOGRAPHS
  id: totrans-333
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建谐振图形
- en: In the 1800s, there was an invention called the *harmonograph* that was a table
    connected to two pendulums. When the pendulums swung, the attached pen would draw
    on a piece of paper. As the pendulums swung back and forth and died down (*decayed*),
    the patterns would change in interesting ways, as illustrated in [Figure 6-17](ch06.xhtml#ch06fig17).
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在19世纪，曾经有一种叫做*谐振图形*的发明，它是一个与两个摆锤连接的桌子。当摆锤摆动时，附着的笔会在纸上绘图。当摆锤来回摆动并逐渐停下（*衰减*）时，图案会以有趣的方式发生变化，如[图
    6-17](ch06.xhtml#ch06fig17)所示。
- en: '![image](../images/f120-02.jpg)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f120-02.jpg)'
- en: '*Figure 6-17: Harmonograph machine and design*'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-17：谐振图形机器与设计*'
- en: Using programming and a few equations, we can model how a harmonograph draws
    its patterns. The equations to model the oscillation of one pendulum are
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编程和几个方程式，我们可以模拟谐振图形绘制其图案的过程。模拟单个摆锤振荡的方程式如下：
- en: '![image](../images/e121-01.jpg)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e121-01.jpg)'
- en: 'In these equations, *x* and *y* represent the horizontal and vertical displacement
    left/right and up/down distance) of the pen, respectively. Variable *a* is the
    amplitude (size) of the motion, *f* is the frequency of the pendulum, *t* is the
    elapsed time, *p* is the phase shift, e is the base of the natural logarithms
    (it’s a constant, around 2.7), and *d* is the decay factor (how fast the pendulum
    slows down). The time variable, *t*, will of course be the same in both of these
    equations, but all the other variables can be different: the left/right frequency
    can be different from the up/down frequency, for example.'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些方程中，*x*和*y*分别表示笔的水平和垂直位移（左右和上下的距离）。变量*a*表示运动的振幅（大小），*f*是摆锤的频率，*t*是经过的时间，*p*是相位移，e是自然对数的底数（大约为2.7），*d*是衰减因子（摆锤减速的速度）。时间变量*t*在这两个方程中当然是相同的，但其他所有变量都可以不同：例如，左右方向的频率可以不同于上下方向的频率。
- en: WRITING THE HARMONOGRAPH PROGRAM
  id: totrans-340
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编写谐振图形程序
- en: Let’s create a Python-Processing sketch that models the movement of a pendulum.
    Create a new Processing sketch and call it *harmonograph.pyde*. The initial code
    is shown in [Listing 6-18](ch06.xhtml#ch06list18).
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来创建一个Python-Processing草图，用于模拟摆锤的运动。创建一个新的Processing草图，并将其命名为*harmonograph.pyde*。初始代码显示在[清单
    6-18](ch06.xhtml#ch06list18)中。
- en: '*harmonograph.pyde*'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '*harmonograph.pyde*'
- en: t = 0
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: t = 0
- en: 'def setup():'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 'def setup():'
- en: size(600,600)
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: size(600,600)
- en: noStroke()
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: noStroke()
- en: 'def draw():'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 'def draw():'
- en: global t
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: global t
- en: '➊ a1,a2 = 100,200 #amplitudes'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ a1,a2 = 100,200 #振幅'
- en: 'f1,f2 = 1,2 #frequencies'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 'f1,f2 = 1,2 #频率'
- en: 'p1,p2 = 0,PI/2 #phase shifts'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 'p1,p2 = 0,PI/2 #相位移'
- en: 'd1,d2 = 0.02,0.02 #decay constants'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 'd1,d2 = 0.02,0.02 #衰减常数'
- en: background(255)
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: background(255)
- en: translate(width/2,height/2)
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: translate(width/2,height/2)
- en: ➋ x = a1*cos(f1*t + p1)*exp(-d1*t)
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ x = a1*cos(f1*t + p1)*exp(-d1*t)
- en: y = a2*cos(f2*t + p2)*exp(-d2*t)
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: y = a2*cos(f2*t + p2)*exp(-d2*t)
- en: 'fill(0) #black'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 'fill(0) #黑色'
- en: ellipse(x,y,5,5)
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: ellipse(x,y,5,5)
- en: t += .1
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: t += .1
- en: '*Listing 6-18: The initial code for the harmonograph sketch*'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-18：谐振图形草图的初始代码*'
- en: This is just the usual setup() and draw() functions with a time variable (t)
    and values for the amplitude (a1,a2), frequency (f1,f2), phase shift (p1,p2),
    and decay constants (d1,d2).
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: Then, starting at ➊, we define a bunch of variables to plug into the two formulas
    for the location of the harmonograph drawing pen. The x = and y = lines ➋ use
    those variables and calculate the coordinates for the ellipse.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: Now run this code, and you should see the circle moving, but what is it drawing?
    We need to put the points in a list and then graph all the points in the list.
    Right after declaring the t variable, create a list called points. The code so
    far is shown in [Listing 6-19](ch06.xhtml#ch06list19).
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '*harmonograph.pyde*'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: t = 0
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: points = []
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: 'def setup():'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: size(600,600)
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: noStroke()
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: 'def draw():'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: global t,points
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: a1,a2 = 100,200
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: f1,f2 = 1,2
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: p1,p2 = 0,PI/2
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: d1,d2 = 0.02,0.02
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: background(255)
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: translate(width/2,height/2)
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: x = a1*cos(f1*t + p1)*exp(-d1*t)
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: y = a2*cos(f2*t + p2)*exp(-d2*t)
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: '#save location to points List'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: points.append([x,y])
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: '#go through points list and draw lines between them'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: 'for i,p in enumerate(points):'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: 'stroke(0) #black'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: 'if i < len(points) - 1:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: line(p[0],p[1],points[i+1][0],points[i+1][1])
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: t += .1
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 6-19: The code to draw a harmonograph using lines between points*'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f122-01.jpg)'
  id: totrans-389
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-18: The harmonograph*'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: We start by defining the points list at the top of the file and adding points
    to the global variables in the draw() function. After calculating where x and
    y are, we add the line to add the point [x,y] to the points list. Finally, we
    go through the points list and draw a line from each point to the next one. Then
    we use Python’s enumerate() function and stop one point before the last one. This
    is so we don’t get an error message telling us the index is out of range when
    it tries to draw a line from the last point to the next one. Now when we run the
    code, we see the dot leave a trail behind it, as in [Figure 6-18](ch06.xhtml#ch06fig18).
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice if you comment out the decay part of the formulas, like this, the program
    will simply draw over the same lines:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: x = a1*cos(f1*t + p1)#*exp(-d1*t)
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: y = a2*cos(f2*t + p2)#*exp(-d2*t)
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: The decay models the gradual decrease in a pendulum’s maximum amplitude, and
    it’s what creates the “scalloped” effect of so many harmonograph images. The first
    few times it’s cool to watch the code draw the design, but it takes a while. What
    if we could fill the points list all at once?
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: FILLING THE LIST INSTANTLY
  id: totrans-396
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Instead of drawing the whole list at every frame, let’s come up with a way to
    fill the list instantly. We can cut the whole harmonograph code out of the draw()
    function and paste it into its own function, like in [Listing 6-20](ch06.xhtml#ch06list20).
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: 'def harmonograph(t):'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: a1,a2 = 100,200
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: f1,f2 = 1,2
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: p1,p2 = PI/6,PI/2
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: d1,d2 = 0.02,0.02
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: x = a1*cos(f1*t + p1)*exp(-d1*t)
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: y = a2*cos(f2*t + p2)*exp(-d2*t)
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: return [x,y]
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 6-20: Separating out the harmonograph() function*'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: Now in the draw() function, you just need a loop where you add a bunch of points
    for values of t, as in [Listing 6-21](ch06.xhtml#ch06list21).
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: 'def draw():'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: background(255)
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: translate(width/2,height/2)
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: points = []
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: t = 0
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: 'while t < 1000:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: points.append(harmonograph(t))
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: t += 0.01
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: '#go through points list and draw lines between them'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: 'for i,p in enumerate(points):'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: 'stroke(0) #black'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: 'if i < len(points) - 1:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: line(p[0],p[1],points[i+1][0],points[i+1][1])
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 6-21: The new draw() function, which calls the harmonograph() function*'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: Run this code and you’ll instantly see a complete harmonograph! Because we changed
    the size of the ellipses and the phase shifts, this one looks different, as you
    can see in [Figure 6-19](ch06.xhtml#ch06fig19). Change each of the values yourself
    and see how this changes the design!
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f124-01.jpg)'
  id: totrans-423
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-19: Using a different formula to make the harmonograph*'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: TWO PENDULUMS ARE BETTER THAN ONE
  id: totrans-425
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can add another pendulum to make more complicated designs by adding another
    term to each formula, like this:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: x = a1*cos(f1*t + p1)*exp(-d1*t) + a3*cos(f3*t + p3)*exp(-d3*t)
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: y = a2*sin(f2*t + p2)*exp(-d2*t) + a4*sin(f4*t + p4)*exp(-d4*t)
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: All this does is add identical code to each line, with a few numbers changed,
    to simulate more than one pendulum in each direction. Of course, you have to create
    more variables and give them values. In [Listing 6-22](ch06.xhtml#ch06list22)
    are my suggestions for copying one of the designs I found at *[http://www.walkingrandomly.com/?p=151](http://www.walkingrandomly.com/?p=151)*.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: 'def harmonograph(t):'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: a1=a2=a3=a4 = 100
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: f1,f2,f3,f4 = 2.01,3,3,2
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: p1,p2,p3,p4 = -PI/2,0,-PI/16,0
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: d1,d2,d3,d4 = 0.00085,0.0065,0,0
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: x = a1*cos(f1*t + p1)*exp(-d1*t) + a3*cos(f3*t + p3)*exp(-d3*t)
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: y = a2*sin(f2*t + p2)*exp(-d2*t) + a4*sin(f4*t + p4)*exp(-d4*t)
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: return [x,y]
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 6-22: The harmonograph code for the design in [Figure 6-20](ch06.xhtml#ch06fig20)*'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 6-22](ch06.xhtml#ch06list22), all we changed were the constants
    for a, f, p, and d to make a completely different design. If you add stroke(255,0,0)
    to the code before drawing the lines, you’ll make the lines red, as shown in [Figure
    6-20](ch06.xhtml#ch06fig20).
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f125-01.jpg)'
  id: totrans-440
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-20: A complete harmonograph!*'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6-23 shows the final code for *harmonograph.pyde*.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: '*harmonograph.pyde*'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: t = 0
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: points = []
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: 'def setup():'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: size(600,600)
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: noStroke()
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: 'def draw():'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: background(255)
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: translate(width/2,height/2)
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: points = []
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: t = 0
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: 'while t < 1000:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: points.append(harmonograph(t))
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: t += 0.01
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: '#go through points list and draw lines between them'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: 'for i,p in enumerate(points):'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: 'stroke(255,0,0) #red'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: 'if i < len(points) - 1:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: line(p[0],p[1],points[i+1][0],points[i+1][1])
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: 'def harmonograph(t):'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: a1=a2=a3=a4 = 100
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: f1,f2,f3,f4 = 2.01,3,3,2
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: p1,p2,p3,p4 = -PI/2,0,-PI/16,0
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: d1,d2,d3,d4 = 0.00085,0.0065,0,0
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: x = a1*cos(f1*t + p1)*exp(-d1*t) + a3*cos(f3*t + p3)*exp(-d3*t)
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: y = a2*sin(f2*t + p2)*exp(-d2*t) + a4*sin(f4*t + p4)*exp(-d4*t)
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: return [x,y]
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 6-23: The final code for the harmonograph sketch*'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-23：和谐图草图的最终代码*'
- en: '### SUMMARY'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '### 总结'
- en: Students in trigonometry class have to solve for unknown side lengths or angle
    measurements in triangles. But now you know the *real* use of sines and cosines
    is to rotate and transform points and shapes to make Spirograph and harmonograph
    designs! In this chapter, you saw how useful it is to save points to a list and
    then loop through the list to draw lines between the points. We also revisited
    some Python tools like enumerate() and vertex().
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 三角学课上的学生需要解出三角形中的未知边长或角度。但现在你知道了，*正弦*和*余弦*的真正用途是旋转和变换点和形状，以制作螺旋图和和谐图设计！在这一章中，你看到了将点保存到列表中并通过循环遍历列表在点之间画线是多么有用。我们还回顾了一些Python工具，如`enumerate()`和`vertex()`。
- en: In the next chapter, we’ll use sines and cosines and the rotation ideas you
    learned in this chapter to invent a whole new kind of number! We’ll also rotate
    and transform grids using these new numbers, and we’ll create complex (pun intended)
    works of art using the locations of pixels!
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用你在这一章中学到的正弦和余弦以及旋转的概念，发明一种全新的数字！我们还将使用这些新数字旋转和变换网格，并利用像素的位置创作复杂（字面和双关的意思）艺术作品！
