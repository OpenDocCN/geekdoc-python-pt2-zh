- en: '6'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '6'
- en: CREATING OSCILLATIONS WITH TRIGONOMETRY
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 用三角函数创建振荡
- en: '*I’ve got an oscillating fan at my house. The fan goes back and forth. It looks
    like the fan is saying “No.” So I like to ask it questions that a fan would say
    “No” to. “Do you keep my hair in place? Do you keep my documents in order? Do
    you have three settings? Liar!” My fan lied to me.—Mitch Hedberg*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*我家里有一个振荡风扇。风扇来回摆动，看起来风扇在说“不要”。所以我喜欢问它一些风扇会说“不”的问题。“你能保持我的头发整齐吗？你能整理我的文件吗？你有三个档位吗？骗子！”我的风扇骗了我。—米奇·赫德伯格*'
- en: '![image](../images/fintro-01.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fintro-01.jpg)'
- en: '*Trigonometry* literally means the study of triangles. Specifically, it is
    the study of right triangles and the special ratios that exist between their sides.
    Judging from what’s taught in a traditional trigonometry class, though, you’d
    think that’s where it ends. [Figure 6-1](ch06.xhtml#ch06fig1) shows just one part
    of a typical trigonometry homework assignment.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*三角学*字面意思是三角形的研究。具体来说，它是对直角三角形及其各边之间特殊比率的研究。然而，从传统三角学课堂上教授的内容来看，你可能会认为这就是三角学的全部。[图
    6-1](ch06.xhtml#ch06fig1)显示的是典型三角学作业的一部分。'
- en: '![image](../images/f104-01.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f104-01.jpg)'
- en: '*Figure 6-1: Question after question in traditional trig class on unknown sides
    in triangles*'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-1：传统三角学课堂上关于三角形未知边的一个个问题*'
- en: 'This is the kind of task most people remember from their trigonometry class,
    where solving for unknown sides in a triangle is a common assignment. *But this
    is seldom how trig functions are used in reality*. The more common uses of trig
    functions such as sine and cosine are for oscillating motion, like water, light,
    and sound waves. Suppose you take your graphing code from *grid.pyde* in [Chapter
    4](ch04.xhtml#ch04) and change the function to the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这是大多数人从三角学课上记得的任务，解决三角形中未知边长是一个常见的作业。*但这并不是三角函数在现实中的常见用途*。三角函数，如正弦和余弦，更多的应用于振荡运动，比如水波、光波和声波。假设你拿出你在[第
    4 章](ch04.xhtml#ch04)中使用的图形代码 *grid.pyde*，并将函数修改为以下内容：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this case, you’d get this output shown in [Figure 6-2](ch06.xhtml#ch06fig2).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你会得到[图 6-2](ch06.xhtml#ch06fig2)中显示的输出。
- en: '![image](../images/f104-02.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f104-02.jpg)'
- en: '*Figure 6-2: A sine wave*'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-2：正弦波*'
- en: The values on the x-axis are the radians, the input of the sine function. The
    y-axis is the output. If you put `sin(1)` into your calculator or the Python shell,
    you’ll get out a long decimal starting with 0.84. . . . That’s the height of the
    curve when x = 1\. It’s almost at the top of the curve in [Figure 6-2](ch06.xhtml#ch06fig2).
    Put `sin(3)` into the calculator and you’ll get 0.14. . . . On the curve, you
    can see it’s almost on the x-axis when x = 3\. Enter any other values for x, and
    the output should follow this up-and-down pattern, *oscillating* between 1 and
    –1\. The wave takes just over six units to make a complete wave, or one *wavelength*,
    which we also call the *period* of the function. The period of the sine function
    is 2π, or 6.28 radians in Processing and Python. In school, you won’t go any further
    than drawing lots of waves like this. But in this chapter, you’ll use sine, cosine,
    and tangent to simulate oscillating motion in real time. You’ll also use trigonometry
    to make some interesting, dynamic, interactive sketches in Processing. The main
    trig functions are shown in [Figure 6-3](ch06.xhtml#ch06fig3).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: x 轴上的数值是弧度，是正弦函数的输入值。y 轴是输出值。如果你在计算器或 Python shell 中输入 `sin(1)`，你会得到一个以 0.84
    开头的长小数……这就是当 x = 1 时曲线的高度。它几乎处于曲线的顶部，在[图 6-2](ch06.xhtml#ch06fig2)中可以看到。输入 `sin(3)`
    到计算器中，你会得到 0.14……在曲线上，你会看到当 x = 3 时它几乎在 x 轴上。输入其他任何 x 值，输出都会遵循这种上下波动的模式，*在 1 和
    -1 之间振荡*。一个完整的波形大约需要六个单位的时间，或者一个 *波长*，我们也称之为该函数的 *周期*。正弦函数的周期是 2π，或在 Processing
    和 Python 中为 6.28 弧度。在学校里，你不会做比画出这样的波形更多的事情。但在本章中，你将使用正弦、余弦和正切函数来实时模拟振荡运动。你还将使用三角学在
    Processing 中创建一些有趣的动态交互式草图。主要的三角函数见[图 6-3](ch06.xhtml#ch06fig3)。
- en: '![image](../images/f105-01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f105-01.jpg)'
- en: '*Figure 6-3: The ratios of the sides of a right triangle*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-3：直角三角形各边的比率*'
- en: We’ll use trig functions to generate polygons of any number of sides as well
    as stars with any (odd) number of prongs. After that, you’ll create a sine wave
    from a point rotating around a circle. You’ll draw Spirograph- and harmonograph-type
    designs, which require trig functions. You’ll also oscillate a wave of colorful
    points in and out of a circle!
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用三角函数生成任意边数的多边形，以及任何（奇数）角度的星形。之后，你将创建一个从点沿圆周旋转的正弦波。你将绘制类似Spirograph和harmonograph的图形，这些都需要三角函数。你还将使五颜六色的点在圆内外振荡！
- en: Let’s start by discussing how using trig functions is going to make transforming,
    rotating, and oscillating shapes much easier than before.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先讨论一下，使用三角函数将如何使变换、旋转和振荡形状变得比以前更容易。
- en: USING TRIGONOMETRY FOR ROTATIONS AND OSCILLATIONS
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用三角学进行旋转和振荡
- en: 'First of all, sines and cosines make rotations a cinch. In [Figure 6-3](ch06.xhtml#ch06fig3),
    sin A is expressed as the opposite side divided by the hypotenuse, or side a divided
    by side c:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，正弦和余弦使旋转变得非常简单。在[图6-3](ch06.xhtml#ch06fig3)中，sin A 表示为对边除以斜边，或者边a除以边c：
- en: '![image](../images/e105-01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e105-01.jpg)'
- en: 'Solve this for side a, and you get the hypotenuse times the sine of A:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 解这个方程来求边a，你会得到斜边乘以角A的正弦值：
- en: a = c Sin A
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: a = c Sin A
- en: Therefore, the y-coordinate of a point can be expressed as the distance from
    the origin times the sine of the angle the point makes with the horizontal. Imagine
    a circle with radius r, the hypotenuse of the triangle, rotating around the point
    at (0,0), as shown in [Figure 6-4](ch06.xhtml#ch06fig4).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，点的y坐标可以表示为原点到该点的距离乘以该点与水平线之间的角度的正弦值。想象一个半径为r的圆，斜边是三角形的斜边，围绕点(0,0)旋转，如[图6-4](ch06.xhtml#ch06fig4)所示。
- en: '![image](../images/f106-01.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f106-01.jpg)'
- en: '*Figure 6-4: Polar form of coordinates of a point*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-4：点的极坐标形式*'
- en: To rotate a point, we’re going to keep the radius of the circle constant and
    simply vary theta, the angle. The computer is going to do the hard part of recalculating
    all the positions of the point by multiplying the radius r by the cosine or sine
    of the angle theta! We also need to remember that sine and cosine expect radian
    input, not degrees. Fortunately, you’ve already learned how easy it is to use
    Processing’s built-in `radians()` and `degrees()` functions to convert to whatever
    units we want.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要旋转一个点，我们将保持圆的半径不变，简单地改变角度theta。计算机会通过将半径r乘以角度theta的余弦或正弦值来重新计算所有点的位置！我们还需要记住，正弦和余弦函数期望的是弧度输入，而不是度数。幸运的是，你已经学会了使用Processing内建的`radians()`和`degrees()`函数，轻松地将单位转换为我们想要的任何形式。
- en: WRITING FUNCTIONS TO DRAW POLYGONS
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写绘制多边形的函数
- en: Thinking about vertices as points that rotate around a center makes creating
    polygons very easy. Recall that a polygon is a many-sided figure; a *regular polygon*
    is made by connecting a certain number of points equally spaced around a circle.
    Remember how much geometry we needed to know to draw an equilateral triangle in
    [Chapter 5](ch05.xhtml#ch05)? With trigonometry functions helping us with rotations,
    all we have to do to draw polygons is use [Figure 6-4](ch06.xhtml#ch06fig4) to
    create a polygon function.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 将顶点看作围绕中心旋转的点，使得创建多边形变得非常容易。回想一下，多边形是一个多边形状；*规则多边形*是通过将一定数量的点等间距地连接在圆周上形成的。还记得我们在[第5章](ch05.xhtml#ch05)中需要多少几何知识才能绘制一个等边三角形吗？有了三角函数帮助旋转后，我们只需要使用[图6-4](ch06.xhtml#ch06fig4)来创建一个多边形函数，就能绘制多边形。
- en: Open a new sketch in Processing and save it as *polygon.pyde*. Then enter the
    code in [Listing 6-1](ch06.xhtml#ch06list1) to make a polygon using by the `vertex()`
    function.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在Processing中打开一个新草图并将其保存为*polygon.pyde*。然后输入[清单6-1](ch06.xhtml#ch06list1)中的代码，通过`vertex()`函数绘制一个多边形。
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 6-1: Drawing a polygon using `vertex()`*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-1：使用`vertex()`绘制多边形*'
- en: We could always draw polygons using `line()`, but once we connect all the lines,
    we couldn’t fill in the shape with color. The Processing functions `beginShape()`
    and `endShape()` define any shape we want by using the `vertex()` function to
    say where the points of the shape should be. This lets us create as many vertices
    as we want.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当然可以使用`line()`来绘制多边形，但一旦我们连接了所有的线条，就无法用颜色填充形状了。Processing函数`beginShape()`和`endShape()`通过使用`vertex()`函数来定义我们想要的任何形状，指定形状的各个点位置。这让我们能够创建任意数量的顶点。
- en: We always start the shape with `beginShape()`, list all the points on the shape
    by sending them to the `vertex()` function, and finally end the shape with `endShape()`.
    If we put `CLOSE` inside the `endShape()` function, the program will connect the
    last vertex with the first vertex.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们总是从`beginShape()`开始形状，列出形状的所有顶点并通过`vertex()`函数传递它们，最后通过`endShape()`结束形状。如果我们在`endShape()`函数中放入`CLOSE`，程序将连接最后一个顶点和第一个顶点。
- en: When you run this code, you should see something like [Figure 6-5](ch06.xhtml#ch06fig5).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这段代码时，你应该看到类似于[图6-5](ch06.xhtml#ch06fig5)的图形。
- en: '![image](../images/f107-01.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f107-01.jpg)'
- en: '*Figure 6-5: A house-shaped polygon made from vertices*'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-5：由顶点组成的房屋形状多边形*'
- en: However, it’s laborious to enter more than four or five points manually. It
    would be great if we could just rotate a single point around another point using
    a loop. Let’s try that next.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，手动输入四五个以上的点是很麻烦的。如果我们能够通过循环将一个点围绕另一个点旋转就好了。接下来我们试试看。
- en: DRAWING A HEXAGON WITH LOOPS
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用循环绘制六边形
- en: Let’s use a `for` loop to create six vertices of a hexagon using the code in
    [Listing 6-2](ch06.xhtml#ch06list2).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`for`循环来创建六个六边形的顶点，代码见[清单6-2](ch06.xhtml#ch06list2)。
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 6-2: Trying to use `rotate()` inside a `for` loop*'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单6-2：尝试在`for`循环中使用`rotate()`*'
- en: However, you’ll find out that if you run this code, you get a blank screen!
    You can’t use the `rotate()` function inside a shape because this function spins
    the entire coordinate system. This is *precisely* why we need the sine and cosine
    notation you saw in [Figure 6-4](ch06.xhtml#ch06fig4) to rotate the vertices!
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你会发现，如果你运行这段代码，你会看到一片空白屏幕！你不能在形状内部使用`rotate()`函数，因为这个函数会旋转整个坐标系统。这就是为什么我们需要你在[图6-4](ch06.xhtml#ch06fig4)中看到的正弦和余弦表示法来旋转顶点！这*正是*我们需要的原因！
- en: '[Figure 6-6](ch06.xhtml#ch06fig6) shows how the expression `(r*cos(60*i),r*sin(60*i))`
    creates each vertex of a hexagon. When i = 0, the angle in the parentheses will
    be 0 degrees; when i = 1, the angle will be 60 degrees; and so on.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-6](ch06.xhtml#ch06fig6)展示了如何通过表达式`(r*cos(60*i), r*sin(60*i))`来创建六边形的每个顶点。当i
    = 0时，括号中的角度为0度；当i = 1时，角度为60度；以此类推。'
- en: '![image](../images/f108-01.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f108-01.jpg)'
- en: '*Figure 6-6: Using sines and cosines to rotate a point around the center*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-6：使用正弦和余弦旋转点绕中心*'
- en: 'To re-create this hexagon in code, we have to create a variable, `r`, that
    represents the distance from the center of rotation to each vertex, which won’t
    change. The only thing we need to change is the number of degrees in the `sin()`
    and `cos()` functions, which are all multiples of 60\. Generally, it can be written
    like this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要在代码中重新创建这个六边形，我们需要创建一个变量`r`，它表示从旋转中心到每个顶点的距离，而这个距离不会改变。我们唯一需要改变的是`sin()`和`cos()`函数中的角度，它们都是60的倍数。一般情况下，它可以写成这样：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: First, we make `i` go from 0 to 5 so that every vertex will be a multiple of
    60 (0, 60, 120, and so on), as shown in [Figure 6-7](ch06.xhtml#ch06fig7). Let’s
    change `r` to 100 and convert the degree numbers to radians so the code looks
    like [Listing 6-3](ch06.xhtml#ch06list3).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们让`i`从0到5，这样每个顶点的角度将是60的倍数（0、60、120等等），如[图6-7](ch06.xhtml#ch06fig7)所示。接着，我们将`r`更改为100并将角度转换为弧度，这样代码就像[清单6-3](ch06.xhtml#ch06list3)一样。
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 6-3: Drawing a hexagon*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单6-3：绘制六边形*'
- en: '![image](../images/f108-02.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f108-02.jpg)'
- en: '*Figure 6-7: A hexagon built with a `vertex()` function and a `for` loop*'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-7：使用`vertex()`函数和`for`循环绘制的六边形*'
- en: Now that we’ve set `r` equal to 100 and converted the degrees to radians, when
    we run this code, we should see a hexagon like in [Figure 6-7](ch06.xhtml#ch06fig7).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将`r`设置为100并将角度转换为弧度，当我们运行这段代码时，我们应该看到一个类似于[图6-7](ch06.xhtml#ch06fig7)的六边形。
- en: In fact, we could create a function to make *any* polygon this way!
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我们可以创建一个函数，通过这种方式绘制*任何*多边形！
- en: '#### DRAWING AN EQUILATERAL TRIANGLE'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 绘制等边三角形'
- en: Now let’s make an equilateral triangle using this function. [Listing 6-4](ch06.xhtml#ch06list4)
    shows a simpler way to make an equilateral triangle using looping instead of using
    square roots like we did in [Chapter 5](ch05.xhtml#ch05).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们用这个函数创建一个等边三角形。[清单6-4](ch06.xhtml#ch06list4)展示了一种更简单的方法，通过循环来创建等边三角形，而不是像我们在[第5章](ch05.xhtml#ch05)中那样使用平方根。
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 6-4: Drawing an equilateral triangle*'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单6-4：绘制等边三角形*'
- en: 'In this example, we create a `polygon()` function that draws a polygon given
    the number of sides (`sides`) and the size of the polygon (`sz`). The rotation
    for each vertex is 360 divided by `sides`. For our hexagon, we rotate by 60 degrees
    because there are six sides to a hexagon (360 / 6 = 60). The line `polygon(3,100)`
    calls the polygon function and passes two inputs: 3 for the number of sides and
    100 for the distance from the center to the vertices.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们创建了一个`polygon()`函数，根据边数(`sides`)和多边形的大小(`sz`)来绘制多边形。每个顶点的旋转角度是360度除以边数。在我们的六边形中，我们旋转60度，因为六边形有六个边（360
    / 6 = 60）。`polygon(3,100)`这一行调用了多边形函数，并传入了两个参数：边数为3，中心到顶点的距离为100。
- en: Run this code and you should get what’s shown in [Figure 6-8](ch06.xhtml#ch06fig8).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这段代码，你应该会看到[图6-8](ch06.xhtml#ch06fig8)所展示的效果。
- en: '![image](../images/f109-01.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f109-01.jpg)'
- en: '*Figure 6-8: An equilateral triangle!*'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-8：一个等边三角形！*'
- en: Now making regular polygons of any number of sides should be a breeze. No square
    roots necessary! [Figure 6-9](ch06.xhtml#ch06fig9) shows some sample polygons
    you can make using the `polygon()` function.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，绘制任意边数的规则多边形应该非常简单。无需平方根！[图6-9](ch06.xhtml#ch06fig9)展示了一些可以使用`polygon()`函数绘制的样本多边形。
- en: '![image](../images/f110-01.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f110-01.jpg)'
- en: '*Figure 6-9: All the polygons you want!*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-9：你想要的所有多边形！*'
- en: Try updating the numbers in `polygon(3,100)` to see how the polygons change
    shape!
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试更新`polygon(3,100)`中的数字，看看多边形如何改变形状！
- en: MAKING SINE WAVES
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 制作正弦波
- en: Like Mitch Hedberg’s fan at the beginning of the chapter, sines and cosines
    are for rotating and oscillating. Sine and cosine functions make waves when the
    height of a point on a circle is measured over time. To make this more concrete,
    let’s create a circle to visualize making sine waves by putting a point (shown
    as a red ellipse) on the circumference of the circle. As this point travels around
    the circle, its height over time will draw out a sine wave.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 就像章节开头提到的Mitch Hedberg的风扇一样，正弦和余弦用于旋转和振荡。当测量圆上的一个点随时间变化的高度时，正弦和余弦函数会形成波浪。为了让这一点更具体，我们可以画一个圆来可视化正弦波的生成，在圆的圆周上放置一个点（用红色椭圆表示）。当这个点沿着圆周移动时，它的高度随时间变化将画出一条正弦波。
- en: Start a new Processing sketch and save it as *CircleSineWave.pyde*. Create a
    big circle on the left side of the screen, like in [Figure 6-10](ch06.xhtml#ch06fig10).
    Try it yourself before looking at the code.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 启动一个新的Processing草图并将其保存为*CircleSineWave.pyde*。在屏幕左侧创建一个大圆，如[图6-10](ch06.xhtml#ch06fig10)所示。在查看代码之前，自己尝试一下。
- en: '![image](../images/f110-02.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f110-02.jpg)'
- en: '*Figure 6-10: The start of the sine wave sketch*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-10：正弦波草图的开始*'
- en: Listing 6-5 shows the code to make the sketch of a red point on the circumference
    of a big circle.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 清单6-5展示了绘制一个红点在大圆圆周上的草图代码。
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 6-5: Our circle and the point*'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-5：我们的圆形和点*'
- en: First, we declare variables for the radii of the circles, and we use `t` to
    represent the time it takes to make the point move. In `draw()`, we set the background
    to `gray(200)`, translated to the center of the screen, and draw the big circle
    with radius `r1`. Next, we draw the circling ellipse by using our polar coordinates
    for x and y.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们声明圆的半径变量，并使用`t`表示使点移动所需的时间。在`draw()`中，我们将背景设置为`gray(200)`，将画布移到屏幕的中心，并绘制半径为`r1`的大圆。接着，我们使用极坐标绘制围绕圆旋转的椭圆，分别为x和y坐标。
- en: 'To make the ellipse rotate around the circle, all we have to do is vary the
    number inside the trig functions (in this case, `t`). At the end of the `draw()`
    function, we simply make the time variable go up by a little bit, like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让椭圆绕着圆旋转，我们只需要改变三角函数中的数字（在这种情况下是`t`）。在`draw()`函数的末尾，我们只需让时间变量稍微增加一点，如下所示：
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If you try to run this code right now, you’ll get an error message about `local
    variable ''t'' referenced before assignment`. Python functions have local variables,
    but we want the `draw()` function to use the global time variable `t`. Therefore,
    we have to add the following line to the beginning of the `draw()` function:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行这段代码，你会看到一个关于`local variable 't' referenced before assignment`的错误信息。Python函数有局部变量，但我们希望`draw()`函数使用全局时间变量`t`。因此，我们需要在`draw()`函数的开始部分添加以下代码：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now you’ll see a red ellipse traveling along the circumference of the circle,
    as in [Figure 6-11](ch06.xhtml#ch06fig11).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你会看到一个红色椭圆沿着圆周移动，如[图6-11](ch06.xhtml#ch06fig11)所示。
- en: '![image](../images/f112-01.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f112-01.jpg)'
- en: '*Figure 6-11: The red ellipse travels along the circumference of the big circle*.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-11：红色椭圆沿着大圆的圆周运动*。'
- en: Now we need to choose a place over to the right of the screen to start drawing
    the wave. We’ll extend a green line from the red ellipse to, say, x = 200\. Add
    these lines to your `draw()` function right before `t += 0.05`. The full code
    for drawing the sine wave should look like [Listing 6-6](ch06.xhtml#ch06list6).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要选择屏幕右侧的一个位置来开始绘制波形。我们将在红色椭圆的基础上延伸一条绿色的线，假设是x = 200。将这些行添加到你的`draw()`函数中，在`t
    += 0.05`之前。绘制正弦波的完整代码应如下所示，[清单6-6](ch06.xhtml#ch06list6)。
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 6-6: Adding a line to draw the wave*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单6-6：添加一行来绘制波形*'
- en: Here, we draw a green line on the same height (y-value) as the rotating red
    ellipse. This green line stays parallel to the horizontal, so as the red ellipse
    goes up and down, the green ellipse will be at the same height. When you run your
    program, you’ll see something like [Figure 6-12](ch06.xhtml#ch06fig12).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们绘制了一条与旋转的红色椭圆保持相同高度（y值）的绿色线。这条绿色线始终与水平线平行，因此当红色椭圆上下移动时，绿色椭圆会保持在相同的高度。当你运行程序时，你会看到类似[图6-12](ch06.xhtml#ch06fig12)的效果。
- en: '![image](../images/f113-01.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f113-01.jpg)'
- en: '*Figure 6-12: Getting ready to draw the wave!*'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-12：准备绘制波形！*'
- en: You can see that we’ve added a green ellipse that only measures how far up and
    down the red ellipse moves, nothing else.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，我们添加了一个绿色椭圆，它只衡量红色椭圆上下移动的距离，别的什么都不做。
- en: LEAVING A TRAIL
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 留下轨迹
- en: 'Now we want the green ellipse to leave a trail to show its height over time.
    Leaving a trail really means that we save all the heights and display them—every
    loop. To save a bunch of things, like numbers, letters, words, points, and so
    on, we need a *list*. Add this line to the variables we declared at the beginning
    of the program, before the `setup()` function:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们希望绿色椭圆留下一个轨迹，以显示它随时间的高度变化。留下轨迹实际上意味着我们保存所有的高度并在每次循环时显示它们。为了保存许多东西，比如数字、字母、单词、点等，我们需要一个*列表*。在程序开始时声明的变量中，在`setup()`函数之前，添加这一行：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This creates an empty list in which we’ll save the locations of the green ellipse.
    Add the `circleList` variable to the `global` line in the `draw()` function:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这会创建一个空列表，我们将在其中保存绿色椭圆的位置。将`circleList`变量添加到`draw()`函数中的`global`行：
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'After we calculate x and y in the `draw()` function, we need to add the y-coordinate
    to the `circleList`, but there are a couple of different ways to do this. You
    already know the `append()` function, but this adds the point at the end of the
    list. We could use Python’s `insert()` function to put the new points at the beginning
    of the list, like so:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在`draw()`函数中计算x和y之后，我们需要将y坐标添加到`circleList`中，但有几种不同的方法可以做到这一点。你已经知道`append()`函数，它会将点添加到列表的末尾。我们可以使用Python的`insert()`函数将新点放到列表的开头，像这样：
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: However, the list is going to get bigger every loop. We could limit its length
    to 250 by adding the new value to the first 249 items already in the list, as
    shown in [Listing 6-7](ch06.xhtml#ch06list7).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，列表会在每次循环时变大。我们可以通过将新值添加到前249个已有项中，将其长度限制为250，如[清单6-7](ch06.xhtml#ch06list7)所示。
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 6-7: Adding a point to a list and limiting the list to 250 points*'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单6-7：向列表中添加一个点并将列表限制为250个点*'
- en: The new line of code concatenates the list containing the y-value we just calculated
    and the first 249 items in the `circleList`. That 250-point list now becomes the
    new `circleList`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 新的一行代码将我们刚刚计算的y值与`circleList`中的前249个项连接起来。这个包含250个点的列表现在变成了新的`circleList`。
- en: At the end of the `draw()` function (before incrementing `t`), we’ll put in
    a loop that iterates over all the elements of the `circleList` and draws a new
    ellipse, to look like the green ellipse is leaving a trail. This is shown in [Listing
    6-8](ch06.xhtml#ch06list8).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在`draw()`函数的末尾（在增加`t`之前），我们将放入一个循环，遍历`circleList`中的所有元素并绘制一个新的椭圆，模拟绿色椭圆留下轨迹的效果。这在[清单6-8](ch06.xhtml#ch06list8)中有所展示。
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 6-8: Looping over the circle list and drawing an ellipse at each point
    in the list*'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单6-8：循环遍历圆形列表并在列表中的每个点绘制椭圆*'
- en: This code uses a loop, with `i` going up from 0 to the length of the `circleList`
    and drawing an ellipse for each point in the list. The x-value starts at 200 and
    is incremented by whatever value `i` is. The y-value of the ellipse is the y-value
    we saved to the `circleList`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使用了一个循环，其中`i`从0到`circleList`的长度，并为列表中的每个点绘制一个椭圆。x值从200开始，并随着`i`的变化而增加。椭圆的y值是我们保存到`circleList`中的y值。
- en: When you run this, you’ll see something like [Figure 6-13](ch06.xhtml#ch06fig13).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行此代码时，你将看到类似于[图 6-13](ch06.xhtml#ch06fig13)的效果。
- en: '![image](../images/f114-01.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f114-01.jpg)'
- en: '*Figure 6-13: A sine wave!*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-13：正弦波！*'
- en: You can see the wave being drawn out, leaving a green trail.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到波形被绘制出来，留下了绿色的轨迹。
- en: USING PYTHON’S BUILT-IN ENUMERATE() FUNCTION
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用Python内置的`enumerate()`函数
- en: You can also draw an ellipse at each point in the list using Python’s built-in
    `enumerate()` function. It’s a handy and more “Pythonic” way of keeping track
    of the index and value of the items in a list. To see this in action, open a new
    file in IDLE and enter the code in [Listing 6-9](ch06.xhtml#ch06list9).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用Python内置的`enumerate()`函数在列表中的每个点上绘制一个椭圆。这是一种更便捷、更“Pythonic”的方法，用于跟踪列表中项目的索引和值。要查看此功能的演示，请在IDLE中打开一个新文件，并输入[清单
    6-9](ch06.xhtml#ch06list9)中的代码。
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 6-9: Learning to use Python’s `enumerate()` function*'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-9：学习使用Python的`enumerate()`函数*'
- en: You’ll notice there are two variables (index and value) instead of just one
    (`i`). To use the `enumerate()` function in your circle list, you can use two
    variables to keep track of the iterator (`i`, the index) and the circle (`c`,
    the value), like in [Listing 6-10](ch06.xhtml#ch06list10).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到有两个变量（索引和值），而不仅仅是一个（`i`）。要在你的圆列表中使用`enumerate()`函数，你可以使用两个变量来跟踪迭代器（`i`，索引）和圆（`c`，值），就像在[清单
    6-10](ch06.xhtml#ch06list10)中那样。
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 6-10: Using `enumerate()` to get the index and the value of every
    item in a list*'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-10：使用`enumerate()`获取列表中每个项目的索引和值*'
- en: The final code should look like what you see in [Listing 6-11](ch06.xhtml#ch06list11).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的代码应类似于你在[清单 6-11](ch06.xhtml#ch06list11)中看到的。
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 6-11: The final code for the* CircleSineWave.pyde *sketch*'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-11：* CircleSineWave.pyde *草图的最终代码*'
- en: This is the animation that’s usually shown to beginning trig students, and you’ve
    made your own version!
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通常展示给初学三角学的学生的动画，而你已经做出了自己的版本！
- en: CREATING A SPIROGRAPH PROGRAM
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个涡轮图形程序
- en: Now that you know how to rotate circles and leave trails, let’s make a Spirograph-type
    model! *Spirograph* is a toy that’s made up of two overlapping circular gears
    that slide against each other. The gears have holes you can put pens and pencils
    through to draw cool, curvy designs. Many people played with Spirograph as kids,
    drawing the designs by hand. But we can make Spirograph-type designs using a computer
    and the sine and cosine code you just learned.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何旋转圆并留下轨迹，让我们做一个涡轮图形类型的模型！*涡轮图形*是一种由两个重叠的圆形齿轮组成的玩具，这些齿轮相互滑动。齿轮上有孔，你可以将笔和铅笔穿过这些孔来绘制酷炫的曲线图案。许多人在小时候玩过涡轮图形，手工绘制这些图案。但我们可以利用计算机和你刚刚学到的正弦和余弦代码来制作涡轮图形类型的图案。
- en: First, start a new sketch in Processing called *spirograph.pyde*. Then add the
    code in [Listing 6-12](ch06.xhtml#ch06list12).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在Processing中启动一个新的草图，命名为*spirograph.pyde*。然后添加[清单 6-12](ch06.xhtml#ch06list12)中的代码。
- en: '[PRE18]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 6-12: Getting our big circle on the screen*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-12：将大圆显示在屏幕上*'
- en: We first put a big circle in the middle of the screen and create variables for
    the big circle, and then we put a smaller circle on its circumference, like the
    discs in a Spirograph set.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在屏幕中央放一个大圆，并为大圆创建变量，然后将一个较小的圆放在其圆周上，就像涡轮图形套件中的圆盘一样。
- en: DRAWING THE SMALLER CIRCLE
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 绘制较小的圆
- en: Let’s place the smaller circle on the circumference of the big circle, as in
    [Figure 6-14](ch06.xhtml#ch06fig14).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将较小的圆放在大圆的圆周上，如[图 6-14](ch06.xhtml#ch06fig14)所示。
- en: '![image](../images/f117-01.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f117-01.jpg)'
- en: '*Figure 6-14: The two circles*'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-14：两个圆*'
- en: Next, we’ll make the smaller circle rotate around “inside” the bigger circle,
    just like a Spirograph gear. Update the code in [Listing 6-12](ch06.xhtml#ch06list12)
    with the code in [Listing 6-13](ch06.xhtml#ch06list13) to draw the second circle.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将让较小的圆绕着较大的圆“内部”旋转，就像一个涡轮图形齿轮。更新[清单 6-12](ch06.xhtml#ch06list12)中的代码，并使用[清单
    6-13](ch06.xhtml#ch06list13)中的代码绘制第二个圆。
- en: '[PRE19]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 6-13: Adding the smaller circle*'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-13：添加较小的圆*'
- en: To make the smaller circle rotate around inside the bigger circle, we need to
    add the sine and cosine parts to the location of “circle 2” so it’ll oscillate.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让较小的圆在较大的圆内部旋转，我们需要将正弦和余弦部分添加到“圆 2”的位置，使其发生振荡。
- en: ROTATING THE SMALLER CIRCLE
  id: totrans-133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 旋转较小的圆
- en: Finally, at the very end of the `draw()` function, we have to increment our
    time variable, `t`, as in [Listing 6-14](ch06.xhtml#ch06list14).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`draw()`函数的最后，我们需要像在[清单 6-14](ch06.xhtml#ch06list14)中那样递增我们的时间变量`t`。
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 6-14: The code to make the circle rotate*'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-14：使圆旋转的代码*'
- en: This means circle 2 will oscillate up and down, and left and right, in a circular
    path inside the big circle. Run the code, and you should see circle 2 spinning
    nicely! But how about that hole on the gear where the pen sits and draws the trail?
    We’ll create a third ellipse to represent that point. Its location will be the
    second circle’s center plus the difference of the radii. The code for the “drawing
    dot” is shown in [Listing 6-15](ch06.xhtml#ch06list15).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着圆 2 将在大圆内沿圆形路径上下左右振动。运行代码，你应该能看到圆 2 顺利旋转！但是，齿轮上笔的位置和绘制轨迹的那个孔怎么办呢？我们将创建第三个椭圆来表示那个点。它的位置将是第二个圆的中心加上半径差。关于“绘制点”的代码在[清单
    6-15](ch06.xhtml#ch06list15)中有展示。
- en: '[PRE21]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 6-15: Adding the drawing dot*'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-15：添加绘制点*'
- en: When you run this code, you’ll see the drawing dot right on the edge of circle
    2, rotating as if circle 2 were sliding along circle 1’s circumference. Circle
    3 (the drawing dot) has to be a certain proportion between the center of circle
    2 and its circumference, so we need to introduce a proportion variable (`prop`)
    before the `setup()` function. Be sure to declare it as a global variable at the
    beginning of the `draw()` function, as you see in [Listing 6-16](ch06.xhtml#ch06list16).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这段代码时，你会看到绘制点正好位于圆 2 的边缘，旋转得就像圆 2 沿着圆 1 的圆周滑动一样。圆 3（绘制点）必须在圆 2 的中心和其圆周之间保持一定比例，因此我们需要在`setup()`函数之前引入一个比例变量（`prop`）。在`draw()`函数的开头确保将其声明为全局变量，正如在[清单
    6-16](ch06.xhtml#ch06list16)中所示。
- en: '[PRE22]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 6-16: Adding the proportion variable*'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-16：添加比例变量*'
- en: 'Now we have to figure out how fast the drawing dot rotates. It only takes a
    little algebra to prove its angular velocity (how fast it spins around) is the
    ratio of the size of the big circle to the little circle. Note that the negative
    sign means the dot spins in the opposite direction. Change the `x3` and `y3` lines
    in the `draw()` function to this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要弄清楚绘制点旋转的速度。只需一点代数就可以证明它的角速度（旋转速度）是大圆大小与小圆大小的比例。注意，负号意味着点的旋转方向相反。将`draw()`函数中的`x3`和`y3`行改为如下：
- en: '[PRE23]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'All that’s left is to save the dot `(x3,y3)` to a `points` list and draw lines
    between the points, just like we did in the wave sketch. Add the `points` list
    to the global line:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的就是将点`(x3,y3)`保存到`points`列表中，并像我们在波形草图中一样，在点之间绘制线条。将`points`列表添加到全局线：
- en: '[PRE24]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: After drawing the third ellipse, put the points into a list. This is the same
    procedure we used in *CircleSineWave.pyde* earlier in the chapter. Finally, go
    through the list and draw lines between the points, as in [Listing 6-17](ch06.xhtml#ch06list17).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制完第三个椭圆后，将这些点放入一个列表中。这与我们在本章前面使用的*CircleSineWave.pyde*中的步骤相同。最后，遍历列表并在点之间绘制线条，就像在[清单
    6-17](ch06.xhtml#ch06list17)中所做的那样。
- en: '[PRE25]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 6-17: Graphing the points in the Spirograph*'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-17：在Spirograph中绘制点*'
- en: We used a similar trick for adding the points to the list in the circular wave
    example. We concatenated a list with the current point in it to a list with 2000
    of the items in the `circleList`. This automatically limits the number of points
    we’re saving to the points list. Run this code and watch the program draw a Spirograph,
    as shown in [Figure 6-15](ch06.xhtml#ch06fig15).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在圆形波形示例中使用了类似的技巧，将当前点的列表与包含2000个`circleList`项目的列表连接起来。这会自动限制我们保存的点数。运行这段代码，你将看到程序绘制出Spirograph，正如[图
    6-15](ch06.xhtml#ch06fig15)所示。
- en: '![image](../images/f119-01.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f119-01.jpg)'
- en: '*Figure 6-15: Drawing the Spirograph*'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-15：绘制Spirograph*'
- en: You can change the size of the second circle (`r2`) and the position of the
    drawing dot (`prop`) to draw different designs. For example, the Spirograph in
    [Figure 6-16](ch06.xhtml#ch06fig16) has `r2` equal to 105 and `prop` equal to
    0.8.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过改变第二个圆的大小（`r2`）和绘制点的位置（`prop`）来绘制不同的设计。例如，[图 6-16](ch06.xhtml#ch06fig16)中的Spirograph的`r2`为105，`prop`为0.8。
- en: '![image](../images/f120-01.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f120-01.jpg)'
- en: '*Figure 6-16: Another Spirograph design, created by changing `r2` and `prop`*'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-16：通过改变`r2`和`prop`创建的另一个Spirograph设计*'
- en: So far, we’ve been making shapes oscillate up and down, or left and right, using
    sine and cosine, but what about making shapes oscillate in two different directions?
    We’ll try that next.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用正弦和余弦让形状上下或左右振动，但如何让形状在两个不同方向上振动呢？接下来我们将尝试这一点。
- en: MAKING HARMONOGRAPHS
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 制作和谐图
- en: In the 1800s, there was an invention called the *harmonograph* that was a table
    connected to two pendulums. When the pendulums swung, the attached pen would draw
    on a piece of paper. As the pendulums swung back and forth and died down (*decayed*),
    the patterns would change in interesting ways, as illustrated in [Figure 6-17](ch06.xhtml#ch06fig17).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在 1800 年代，有一种名为 *和谐图* 的发明，它是一个与两个摆锤相连的桌子。当摆锤摆动时，附着的笔会在纸上绘画。随着摆锤来回摆动并逐渐减速（*衰减*），图案会以有趣的方式发生变化，如
    [图 6-17](ch06.xhtml#ch06fig17) 所示。
- en: '![image](../images/f120-02.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f120-02.jpg)'
- en: '*Figure 6-17: Harmonograph machine and design*'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-17：和谐图机器与设计*'
- en: Using programming and a few equations, we can model how a harmonograph draws
    its patterns. The equations to model the oscillation of one pendulum are
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编程和几个方程式，我们可以模拟和谐图如何绘制其图案。模拟一个摆锤振荡的方程式是：
- en: '![image](../images/e121-01.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e121-01.jpg)'
- en: 'In these equations, *x* and *y* represent the horizontal and vertical displacement
    left/right and up/down distance) of the pen, respectively. Variable *a* is the
    amplitude (size) of the motion, *f* is the frequency of the pendulum, *t* is the
    elapsed time, *p* is the phase shift, e is the base of the natural logarithms
    (it’s a constant, around 2.7), and *d* is the decay factor (how fast the pendulum
    slows down). The time variable, *t*, will of course be the same in both of these
    equations, but all the other variables can be different: the left/right frequency
    can be different from the up/down frequency, for example.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些方程中，*x* 和 *y* 分别表示笔的水平和垂直位移（左右和上下的距离）。变量 *a* 是运动的振幅（大小），*f* 是摆锤的频率，*t* 是经过的时间，*p*
    是相位偏移，e 是自然对数的底数（它是一个常数，约为 2.7），*d* 是衰减因子（摆锤减速的速度）。时间变量 *t* 在这两个方程中当然是相同的，但其他所有变量可以不同：例如，左右的频率可以与上下的频率不同。
- en: WRITING THE HARMONOGRAPH PROGRAM
  id: totrans-164
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编写和谐图程序
- en: Let’s create a Python-Processing sketch that models the movement of a pendulum.
    Create a new Processing sketch and call it *harmonograph.pyde*. The initial code
    is shown in [Listing 6-18](ch06.xhtml#ch06list18).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个 Python-Processing 草图来模拟摆锤的运动。创建一个新的 Processing 草图并命名为 *harmonograph.pyde*。初始代码如
    [清单 6-18](ch06.xhtml#ch06list18) 所示。
- en: '[PRE26]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Listing 6-18: The initial code for the harmonograph sketch*'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-18：和谐图草图的初始代码*'
- en: This is just the usual `setup()` and `draw()` functions with a time variable
    (`t`) and values for the amplitude (`a1,a2`), frequency (`f1,f2`), phase shift
    (`p1,p2`), and decay constants (`d1,d2`).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是通常的 `setup()` 和 `draw()` 函数，带有时间变量（`t`）和振幅（`a1,a2`）、频率（`f1,f2`）、相位偏移（`p1,p2`）以及衰减常数（`d1,d2`）的值。
- en: Then, starting at ➊, we define a bunch of variables to plug into the two formulas
    for the location of the harmonograph drawing pen. The `x =` and `y =` lines ➋
    use those variables and calculate the coordinates for the ellipse.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，从 ➊ 开始，我们定义了一堆变量来代入和谐图绘图笔位置的两个公式中。`x =` 和 `y =` 的代码行 ➋ 使用这些变量并计算椭圆的坐标。
- en: Now run this code, and you should see the circle moving, but what is it drawing?
    We need to put the points in a list and then graph all the points in the list.
    Right after declaring the `t` variable, create a list called `points`. The code
    so far is shown in [Listing 6-19](ch06.xhtml#ch06list19).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行这段代码，你应该会看到圆形在移动，但它在画什么？我们需要将点放入一个列表中，然后绘制出列表中的所有点。在声明 `t` 变量后，创建一个名为 `points`
    的列表。目前的代码如 [清单 6-19](ch06.xhtml#ch06list19) 所示。
- en: '[PRE27]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 6-19: The code to draw a harmonograph using lines between points*'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-19：用点之间的线条绘制和谐图的代码*'
- en: '![image](../images/f122-01.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f122-01.jpg)'
- en: '*Figure 6-18: The harmonograph*'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-18：和谐图*'
- en: We start by defining the `points` list at the top of the file and adding points
    to the global variables in the `draw()` function. After calculating where `x`
    and `y` are, we add the line to add the point `[x,y]` to the `points` list. Finally,
    we go through the `points` list and draw a line from each point to the next one.
    Then we use Python’s `enumerate()` function and stop one point before the last
    one. This is so we don’t get an error message telling us the index is out of range
    when it tries to draw a line from the last point to the next one. Now when we
    run the code, we see the dot leave a trail behind it, as in [Figure 6-18](ch06.xhtml#ch06fig18).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在文件顶部定义`points`列表，并在`draw()`函数中将点添加到全局变量中。在计算出`x`和`y`的位置后，我们添加一行代码，将点`[x,y]`添加到`points`列表中。最后，我们遍历`points`列表，并从每个点绘制一条线到下一个点。然后我们使用Python的`enumerate()`函数，停止在倒数第二个点之前。这样我们就不会得到索引超出范围的错误信息，当它尝试从最后一个点绘制到下一个点时。现在，当我们运行代码时，看到点在后面留下了轨迹，就像在[图
    6-18](ch06.xhtml#ch06fig18)中看到的那样。
- en: 'Notice if you comment out the decay part of the formulas, like this, the program
    will simply draw over the same lines:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果你注释掉公式中的衰减部分，如下所示，程序将简单地在相同的线条上进行绘制：
- en: '[PRE28]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The decay models the gradual decrease in a pendulum’s maximum amplitude, and
    it’s what creates the “scalloped” effect of so many harmonograph images. The first
    few times it’s cool to watch the code draw the design, but it takes a while. What
    if we could fill the `points` list all at once?
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 衰减模拟了摆锤最大振幅的逐渐减小，这也正是许多和谐图图像中“波浪状”效果的来源。前几次观看代码绘制设计时很有趣，但过程会有些慢。如果我们能够一次性填充`points`列表呢？
- en: FILLING THE LIST INSTANTLY
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 即时填充列表
- en: Instead of drawing the whole list at every frame, let’s come up with a way to
    fill the list instantly. We can cut the whole harmonograph code out of the `draw()`
    function and paste it into its own function, like in [Listing 6-20](ch06.xhtml#ch06list20).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再在每一帧都绘制整个列表，而是想出一种方法来即时填充列表。我们可以将整个和谐图的代码从`draw()`函数中剪切出来，粘贴到一个独立的函数中，像在[清单
    6-20](ch06.xhtml#ch06list20)中那样。
- en: '[PRE29]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*Listing 6-20: Separating out the `harmonograph()` function*'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-20：分离出的`harmonograph()`函数*'
- en: Now in the `draw()` function, you just need a loop where you add a bunch of
    points for values of `t`, as in [Listing 6-21](ch06.xhtml#ch06list21).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在`draw()`函数中，你只需要一个循环，在其中为`t`的值添加一堆点，就像在[清单 6-21](ch06.xhtml#ch06list21)中那样。
- en: '[PRE30]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*Listing 6-21: The new `draw()` function, which calls the `harmonograph()`
    function*'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-21：新的`draw()`函数，它调用了`harmonograph()`函数*'
- en: Run this code and you’ll instantly see a complete harmonograph! Because we changed
    the size of the ellipses and the phase shifts, this one looks different, as you
    can see in [Figure 6-19](ch06.xhtml#ch06fig19). Change each of the values yourself
    and see how this changes the design!
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这段代码，你将立即看到一个完整的和谐图！因为我们改变了椭圆的大小和相位偏移，所以下面的结果看起来与之前不同，正如你在[图 6-19](ch06.xhtml#ch06fig19)中看到的。自己改变每个值，看看它如何改变设计！
- en: '![image](../images/f124-01.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f124-01.jpg)'
- en: '*Figure 6-19: Using a different formula to make the harmonograph*'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-19：使用不同的公式来生成和谐图*'
- en: TWO PENDULUMS ARE BETTER THAN ONE
  id: totrans-189
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 两个摆锤比一个摆锤更好
- en: 'We can add another pendulum to make more complicated designs by adding another
    term to each formula, like this:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在每个公式中添加另一个项来增加另一个摆锤，从而制作出更复杂的设计，像这样：
- en: '[PRE31]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: All this does is add identical code to each line, with a few numbers changed,
    to simulate more than one pendulum in each direction. Of course, you have to create
    more variables and give them values. In [Listing 6-22](ch06.xhtml#ch06list22)
    are my suggestions for copying one of the designs I found at *[http://www.walkingrandomly.com/?p=151](http://www.walkingrandomly.com/?p=151)*.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是在每一行中添加相同的代码，只改变几个数字，以模拟每个方向上不止一个摆锤。当然，你需要创建更多的变量并给它们赋值。在[清单 6-22](ch06.xhtml#ch06list22)中是我建议的，复制我在
    *[http://www.walkingrandomly.com/?p=151](http://www.walkingrandomly.com/?p=151)*
    上找到的设计。
- en: '[PRE32]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '*Listing 6-22: The harmonograph code for the design in [Figure 6-20](ch06.xhtml#ch06fig20)*'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-22：在[图 6-20](ch06.xhtml#ch06fig20)中的和谐图设计代码*'
- en: In [Listing 6-22](ch06.xhtml#ch06list22), all we changed were the constants
    for `a`, `f`, `p`, and `d` to make a completely different design. If you add `stroke(255,0,0)`
    to the code before drawing the lines, you’ll make the lines red, as shown in [Figure
    6-20](ch06.xhtml#ch06fig20).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单 6-22](ch06.xhtml#ch06list22)中，我们只改变了`a`、`f`、`p`和`d`的常数，制作了一个完全不同的设计。如果你在绘制线条之前向代码中添加`stroke(255,0,0)`，你会使线条变成红色，正如在[图
    6-20](ch06.xhtml#ch06fig20)中看到的那样。
- en: '![image](../images/f125-01.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f125-01.jpg)'
- en: '*Figure 6-20: A complete harmonograph!*'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-20：一个完整的harmonograph！*'
- en: Listing 6-23 shows the final code for *harmonograph.pyde*.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 清单6-23显示了*harmonograph.pyde*的最终代码。
- en: '[PRE33]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '*Listing 6-23: The final code for the harmonograph sketch*'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单6-23：harmonograph草图的最终代码*'
- en: '### SUMMARY'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '### 总结'
- en: Students in trigonometry class have to solve for unknown side lengths or angle
    measurements in triangles. But now you know the *real* use of sines and cosines
    is to rotate and transform points and shapes to make Spirograph and harmonograph
    designs! In this chapter, you saw how useful it is to save points to a list and
    then loop through the list to draw lines between the points. We also revisited
    some Python tools like `enumerate()` and `vertex()`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 三角学课上的学生必须解算三角形中未知的边长或角度测量。但是现在你知道了*正弦*和*余弦*的*真正*用途是旋转和转换点与形状，从而制作Spirograph和harmonograph设计！在本章中，你看到保存点到列表中，然后遍历列表绘制点之间的线条是多么有用。我们还复习了一些Python工具，如`enumerate()`和`vertex()`。
- en: In the next chapter, we’ll use sines and cosines and the rotation ideas you
    learned in this chapter to invent a whole new kind of number! We’ll also rotate
    and transform grids using these new numbers, and we’ll create complex (pun intended)
    works of art using the locations of pixels!
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用正弦和余弦以及你在本章学到的旋转概念，发明一种全新的数字！我们还将使用这些新数字来旋转和转换网格，并通过像素的位置创造出复杂（有意为之）的艺术作品！
