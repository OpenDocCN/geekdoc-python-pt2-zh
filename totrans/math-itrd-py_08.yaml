- en: '6'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CREATING OSCILLATIONS WITH TRIGONOMETRY
  prefs: []
  type: TYPE_NORMAL
- en: '*I’ve got an oscillating fan at my house. The fan goes back and forth. It looks
    like the fan is saying “No.” So I like to ask it questions that a fan would say
    “No” to. “Do you keep my hair in place? Do you keep my documents in order? Do
    you have three settings? Liar!” My fan lied to me.—Mitch Hedberg*'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fintro-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Trigonometry* literally means the study of triangles. Specifically, it is
    the study of right triangles and the special ratios that exist between their sides.
    Judging from what’s taught in a traditional trigonometry class, though, you’d
    think that’s where it ends. [Figure 6-1](ch06.xhtml#ch06fig1) shows just one part
    of a typical trigonometry homework assignment.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f104-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-1: Question after question in traditional trig class on unknown sides
    in triangles*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the kind of task most people remember from their trigonometry class,
    where solving for unknown sides in a triangle is a common assignment. *But this
    is seldom how trig functions are used in reality*. The more common uses of trig
    functions such as sine and cosine are for oscillating motion, like water, light,
    and sound waves. Suppose you take your graphing code from *grid.pyde* in [Chapter
    4](ch04.xhtml#ch04) and change the function to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this case, you’d get this output shown in [Figure 6-2](ch06.xhtml#ch06fig2).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f104-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-2: A sine wave*'
  prefs: []
  type: TYPE_NORMAL
- en: The values on the x-axis are the radians, the input of the sine function. The
    y-axis is the output. If you put `sin(1)` into your calculator or the Python shell,
    you’ll get out a long decimal starting with 0.84. . . . That’s the height of the
    curve when x = 1\. It’s almost at the top of the curve in [Figure 6-2](ch06.xhtml#ch06fig2).
    Put `sin(3)` into the calculator and you’ll get 0.14. . . . On the curve, you
    can see it’s almost on the x-axis when x = 3\. Enter any other values for x, and
    the output should follow this up-and-down pattern, *oscillating* between 1 and
    –1\. The wave takes just over six units to make a complete wave, or one *wavelength*,
    which we also call the *period* of the function. The period of the sine function
    is 2π, or 6.28 radians in Processing and Python. In school, you won’t go any further
    than drawing lots of waves like this. But in this chapter, you’ll use sine, cosine,
    and tangent to simulate oscillating motion in real time. You’ll also use trigonometry
    to make some interesting, dynamic, interactive sketches in Processing. The main
    trig functions are shown in [Figure 6-3](ch06.xhtml#ch06fig3).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f105-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-3: The ratios of the sides of a right triangle*'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use trig functions to generate polygons of any number of sides as well
    as stars with any (odd) number of prongs. After that, you’ll create a sine wave
    from a point rotating around a circle. You’ll draw Spirograph- and harmonograph-type
    designs, which require trig functions. You’ll also oscillate a wave of colorful
    points in and out of a circle!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by discussing how using trig functions is going to make transforming,
    rotating, and oscillating shapes much easier than before.
  prefs: []
  type: TYPE_NORMAL
- en: USING TRIGONOMETRY FOR ROTATIONS AND OSCILLATIONS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First of all, sines and cosines make rotations a cinch. In [Figure 6-3](ch06.xhtml#ch06fig3),
    sin A is expressed as the opposite side divided by the hypotenuse, or side a divided
    by side c:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e105-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Solve this for side a, and you get the hypotenuse times the sine of A:'
  prefs: []
  type: TYPE_NORMAL
- en: a = c Sin A
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, the y-coordinate of a point can be expressed as the distance from
    the origin times the sine of the angle the point makes with the horizontal. Imagine
    a circle with radius r, the hypotenuse of the triangle, rotating around the point
    at (0,0), as shown in [Figure 6-4](ch06.xhtml#ch06fig4).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f106-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-4: Polar form of coordinates of a point*'
  prefs: []
  type: TYPE_NORMAL
- en: To rotate a point, we’re going to keep the radius of the circle constant and
    simply vary theta, the angle. The computer is going to do the hard part of recalculating
    all the positions of the point by multiplying the radius r by the cosine or sine
    of the angle theta! We also need to remember that sine and cosine expect radian
    input, not degrees. Fortunately, you’ve already learned how easy it is to use
    Processing’s built-in `radians()` and `degrees()` functions to convert to whatever
    units we want.
  prefs: []
  type: TYPE_NORMAL
- en: WRITING FUNCTIONS TO DRAW POLYGONS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Thinking about vertices as points that rotate around a center makes creating
    polygons very easy. Recall that a polygon is a many-sided figure; a *regular polygon*
    is made by connecting a certain number of points equally spaced around a circle.
    Remember how much geometry we needed to know to draw an equilateral triangle in
    [Chapter 5](ch05.xhtml#ch05)? With trigonometry functions helping us with rotations,
    all we have to do to draw polygons is use [Figure 6-4](ch06.xhtml#ch06fig4) to
    create a polygon function.
  prefs: []
  type: TYPE_NORMAL
- en: Open a new sketch in Processing and save it as *polygon.pyde*. Then enter the
    code in [Listing 6-1](ch06.xhtml#ch06list1) to make a polygon using by the `vertex()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-1: Drawing a polygon using `vertex()`*'
  prefs: []
  type: TYPE_NORMAL
- en: We could always draw polygons using `line()`, but once we connect all the lines,
    we couldn’t fill in the shape with color. The Processing functions `beginShape()`
    and `endShape()` define any shape we want by using the `vertex()` function to
    say where the points of the shape should be. This lets us create as many vertices
    as we want.
  prefs: []
  type: TYPE_NORMAL
- en: We always start the shape with `beginShape()`, list all the points on the shape
    by sending them to the `vertex()` function, and finally end the shape with `endShape()`.
    If we put `CLOSE` inside the `endShape()` function, the program will connect the
    last vertex with the first vertex.
  prefs: []
  type: TYPE_NORMAL
- en: When you run this code, you should see something like [Figure 6-5](ch06.xhtml#ch06fig5).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f107-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-5: A house-shaped polygon made from vertices*'
  prefs: []
  type: TYPE_NORMAL
- en: However, it’s laborious to enter more than four or five points manually. It
    would be great if we could just rotate a single point around another point using
    a loop. Let’s try that next.
  prefs: []
  type: TYPE_NORMAL
- en: DRAWING A HEXAGON WITH LOOPS
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s use a `for` loop to create six vertices of a hexagon using the code in
    [Listing 6-2](ch06.xhtml#ch06list2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-2: Trying to use `rotate()` inside a `for` loop*'
  prefs: []
  type: TYPE_NORMAL
- en: However, you’ll find out that if you run this code, you get a blank screen!
    You can’t use the `rotate()` function inside a shape because this function spins
    the entire coordinate system. This is *precisely* why we need the sine and cosine
    notation you saw in [Figure 6-4](ch06.xhtml#ch06fig4) to rotate the vertices!
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 6-6](ch06.xhtml#ch06fig6) shows how the expression `(r*cos(60*i),r*sin(60*i))`
    creates each vertex of a hexagon. When i = 0, the angle in the parentheses will
    be 0 degrees; when i = 1, the angle will be 60 degrees; and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f108-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-6: Using sines and cosines to rotate a point around the center*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To re-create this hexagon in code, we have to create a variable, `r`, that
    represents the distance from the center of rotation to each vertex, which won’t
    change. The only thing we need to change is the number of degrees in the `sin()`
    and `cos()` functions, which are all multiples of 60\. Generally, it can be written
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: First, we make `i` go from 0 to 5 so that every vertex will be a multiple of
    60 (0, 60, 120, and so on), as shown in [Figure 6-7](ch06.xhtml#ch06fig7). Let’s
    change `r` to 100 and convert the degree numbers to radians so the code looks
    like [Listing 6-3](ch06.xhtml#ch06list3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-3: Drawing a hexagon*'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f108-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-7: A hexagon built with a `vertex()` function and a `for` loop*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set `r` equal to 100 and converted the degrees to radians, when
    we run this code, we should see a hexagon like in [Figure 6-7](ch06.xhtml#ch06fig7).
  prefs: []
  type: TYPE_NORMAL
- en: In fact, we could create a function to make *any* polygon this way!
  prefs: []
  type: TYPE_NORMAL
- en: '#### DRAWING AN EQUILATERAL TRIANGLE'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s make an equilateral triangle using this function. [Listing 6-4](ch06.xhtml#ch06list4)
    shows a simpler way to make an equilateral triangle using looping instead of using
    square roots like we did in [Chapter 5](ch05.xhtml#ch05).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-4: Drawing an equilateral triangle*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we create a `polygon()` function that draws a polygon given
    the number of sides (`sides`) and the size of the polygon (`sz`). The rotation
    for each vertex is 360 divided by `sides`. For our hexagon, we rotate by 60 degrees
    because there are six sides to a hexagon (360 / 6 = 60). The line `polygon(3,100)`
    calls the polygon function and passes two inputs: 3 for the number of sides and
    100 for the distance from the center to the vertices.'
  prefs: []
  type: TYPE_NORMAL
- en: Run this code and you should get what’s shown in [Figure 6-8](ch06.xhtml#ch06fig8).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f109-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-8: An equilateral triangle!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now making regular polygons of any number of sides should be a breeze. No square
    roots necessary! [Figure 6-9](ch06.xhtml#ch06fig9) shows some sample polygons
    you can make using the `polygon()` function.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f110-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-9: All the polygons you want!*'
  prefs: []
  type: TYPE_NORMAL
- en: Try updating the numbers in `polygon(3,100)` to see how the polygons change
    shape!
  prefs: []
  type: TYPE_NORMAL
- en: MAKING SINE WAVES
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Like Mitch Hedberg’s fan at the beginning of the chapter, sines and cosines
    are for rotating and oscillating. Sine and cosine functions make waves when the
    height of a point on a circle is measured over time. To make this more concrete,
    let’s create a circle to visualize making sine waves by putting a point (shown
    as a red ellipse) on the circumference of the circle. As this point travels around
    the circle, its height over time will draw out a sine wave.
  prefs: []
  type: TYPE_NORMAL
- en: Start a new Processing sketch and save it as *CircleSineWave.pyde*. Create a
    big circle on the left side of the screen, like in [Figure 6-10](ch06.xhtml#ch06fig10).
    Try it yourself before looking at the code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f110-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-10: The start of the sine wave sketch*'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6-5 shows the code to make the sketch of a red point on the circumference
    of a big circle.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-5: Our circle and the point*'
  prefs: []
  type: TYPE_NORMAL
- en: First, we declare variables for the radii of the circles, and we use `t` to
    represent the time it takes to make the point move. In `draw()`, we set the background
    to `gray(200)`, translated to the center of the screen, and draw the big circle
    with radius `r1`. Next, we draw the circling ellipse by using our polar coordinates
    for x and y.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the ellipse rotate around the circle, all we have to do is vary the
    number inside the trig functions (in this case, `t`). At the end of the `draw()`
    function, we simply make the time variable go up by a little bit, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If you try to run this code right now, you’ll get an error message about `local
    variable ''t'' referenced before assignment`. Python functions have local variables,
    but we want the `draw()` function to use the global time variable `t`. Therefore,
    we have to add the following line to the beginning of the `draw()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now you’ll see a red ellipse traveling along the circumference of the circle,
    as in [Figure 6-11](ch06.xhtml#ch06fig11).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f112-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-11: The red ellipse travels along the circumference of the big circle*.'
  prefs: []
  type: TYPE_NORMAL
- en: Now we need to choose a place over to the right of the screen to start drawing
    the wave. We’ll extend a green line from the red ellipse to, say, x = 200\. Add
    these lines to your `draw()` function right before `t += 0.05`. The full code
    for drawing the sine wave should look like [Listing 6-6](ch06.xhtml#ch06list6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-6: Adding a line to draw the wave*'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we draw a green line on the same height (y-value) as the rotating red
    ellipse. This green line stays parallel to the horizontal, so as the red ellipse
    goes up and down, the green ellipse will be at the same height. When you run your
    program, you’ll see something like [Figure 6-12](ch06.xhtml#ch06fig12).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f113-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-12: Getting ready to draw the wave!*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that we’ve added a green ellipse that only measures how far up and
    down the red ellipse moves, nothing else.
  prefs: []
  type: TYPE_NORMAL
- en: LEAVING A TRAIL
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now we want the green ellipse to leave a trail to show its height over time.
    Leaving a trail really means that we save all the heights and display them—every
    loop. To save a bunch of things, like numbers, letters, words, points, and so
    on, we need a *list*. Add this line to the variables we declared at the beginning
    of the program, before the `setup()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates an empty list in which we’ll save the locations of the green ellipse.
    Add the `circleList` variable to the `global` line in the `draw()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'After we calculate x and y in the `draw()` function, we need to add the y-coordinate
    to the `circleList`, but there are a couple of different ways to do this. You
    already know the `append()` function, but this adds the point at the end of the
    list. We could use Python’s `insert()` function to put the new points at the beginning
    of the list, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: However, the list is going to get bigger every loop. We could limit its length
    to 250 by adding the new value to the first 249 items already in the list, as
    shown in [Listing 6-7](ch06.xhtml#ch06list7).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-7: Adding a point to a list and limiting the list to 250 points*'
  prefs: []
  type: TYPE_NORMAL
- en: The new line of code concatenates the list containing the y-value we just calculated
    and the first 249 items in the `circleList`. That 250-point list now becomes the
    new `circleList`.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the `draw()` function (before incrementing `t`), we’ll put in
    a loop that iterates over all the elements of the `circleList` and draws a new
    ellipse, to look like the green ellipse is leaving a trail. This is shown in [Listing
    6-8](ch06.xhtml#ch06list8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-8: Looping over the circle list and drawing an ellipse at each point
    in the list*'
  prefs: []
  type: TYPE_NORMAL
- en: This code uses a loop, with `i` going up from 0 to the length of the `circleList`
    and drawing an ellipse for each point in the list. The x-value starts at 200 and
    is incremented by whatever value `i` is. The y-value of the ellipse is the y-value
    we saved to the `circleList`.
  prefs: []
  type: TYPE_NORMAL
- en: When you run this, you’ll see something like [Figure 6-13](ch06.xhtml#ch06fig13).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f114-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-13: A sine wave!*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see the wave being drawn out, leaving a green trail.
  prefs: []
  type: TYPE_NORMAL
- en: USING PYTHON’S BUILT-IN ENUMERATE() FUNCTION
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also draw an ellipse at each point in the list using Python’s built-in
    `enumerate()` function. It’s a handy and more “Pythonic” way of keeping track
    of the index and value of the items in a list. To see this in action, open a new
    file in IDLE and enter the code in [Listing 6-9](ch06.xhtml#ch06list9).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-9: Learning to use Python’s `enumerate()` function*'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll notice there are two variables (index and value) instead of just one
    (`i`). To use the `enumerate()` function in your circle list, you can use two
    variables to keep track of the iterator (`i`, the index) and the circle (`c`,
    the value), like in [Listing 6-10](ch06.xhtml#ch06list10).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-10: Using `enumerate()` to get the index and the value of every
    item in a list*'
  prefs: []
  type: TYPE_NORMAL
- en: The final code should look like what you see in [Listing 6-11](ch06.xhtml#ch06list11).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-11: The final code for the* CircleSineWave.pyde *sketch*'
  prefs: []
  type: TYPE_NORMAL
- en: This is the animation that’s usually shown to beginning trig students, and you’ve
    made your own version!
  prefs: []
  type: TYPE_NORMAL
- en: CREATING A SPIROGRAPH PROGRAM
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you know how to rotate circles and leave trails, let’s make a Spirograph-type
    model! *Spirograph* is a toy that’s made up of two overlapping circular gears
    that slide against each other. The gears have holes you can put pens and pencils
    through to draw cool, curvy designs. Many people played with Spirograph as kids,
    drawing the designs by hand. But we can make Spirograph-type designs using a computer
    and the sine and cosine code you just learned.
  prefs: []
  type: TYPE_NORMAL
- en: First, start a new sketch in Processing called *spirograph.pyde*. Then add the
    code in [Listing 6-12](ch06.xhtml#ch06list12).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-12: Getting our big circle on the screen*'
  prefs: []
  type: TYPE_NORMAL
- en: We first put a big circle in the middle of the screen and create variables for
    the big circle, and then we put a smaller circle on its circumference, like the
    discs in a Spirograph set.
  prefs: []
  type: TYPE_NORMAL
- en: DRAWING THE SMALLER CIRCLE
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s place the smaller circle on the circumference of the big circle, as in
    [Figure 6-14](ch06.xhtml#ch06fig14).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f117-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-14: The two circles*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll make the smaller circle rotate around “inside” the bigger circle,
    just like a Spirograph gear. Update the code in [Listing 6-12](ch06.xhtml#ch06list12)
    with the code in [Listing 6-13](ch06.xhtml#ch06list13) to draw the second circle.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-13: Adding the smaller circle*'
  prefs: []
  type: TYPE_NORMAL
- en: To make the smaller circle rotate around inside the bigger circle, we need to
    add the sine and cosine parts to the location of “circle 2” so it’ll oscillate.
  prefs: []
  type: TYPE_NORMAL
- en: ROTATING THE SMALLER CIRCLE
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Finally, at the very end of the `draw()` function, we have to increment our
    time variable, `t`, as in [Listing 6-14](ch06.xhtml#ch06list14).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-14: The code to make the circle rotate*'
  prefs: []
  type: TYPE_NORMAL
- en: This means circle 2 will oscillate up and down, and left and right, in a circular
    path inside the big circle. Run the code, and you should see circle 2 spinning
    nicely! But how about that hole on the gear where the pen sits and draws the trail?
    We’ll create a third ellipse to represent that point. Its location will be the
    second circle’s center plus the difference of the radii. The code for the “drawing
    dot” is shown in [Listing 6-15](ch06.xhtml#ch06list15).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-15: Adding the drawing dot*'
  prefs: []
  type: TYPE_NORMAL
- en: When you run this code, you’ll see the drawing dot right on the edge of circle
    2, rotating as if circle 2 were sliding along circle 1’s circumference. Circle
    3 (the drawing dot) has to be a certain proportion between the center of circle
    2 and its circumference, so we need to introduce a proportion variable (`prop`)
    before the `setup()` function. Be sure to declare it as a global variable at the
    beginning of the `draw()` function, as you see in [Listing 6-16](ch06.xhtml#ch06list16).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-16: Adding the proportion variable*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have to figure out how fast the drawing dot rotates. It only takes a
    little algebra to prove its angular velocity (how fast it spins around) is the
    ratio of the size of the big circle to the little circle. Note that the negative
    sign means the dot spins in the opposite direction. Change the `x3` and `y3` lines
    in the `draw()` function to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'All that’s left is to save the dot `(x3,y3)` to a `points` list and draw lines
    between the points, just like we did in the wave sketch. Add the `points` list
    to the global line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: After drawing the third ellipse, put the points into a list. This is the same
    procedure we used in *CircleSineWave.pyde* earlier in the chapter. Finally, go
    through the list and draw lines between the points, as in [Listing 6-17](ch06.xhtml#ch06list17).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-17: Graphing the points in the Spirograph*'
  prefs: []
  type: TYPE_NORMAL
- en: We used a similar trick for adding the points to the list in the circular wave
    example. We concatenated a list with the current point in it to a list with 2000
    of the items in the `circleList`. This automatically limits the number of points
    we’re saving to the points list. Run this code and watch the program draw a Spirograph,
    as shown in [Figure 6-15](ch06.xhtml#ch06fig15).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f119-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-15: Drawing the Spirograph*'
  prefs: []
  type: TYPE_NORMAL
- en: You can change the size of the second circle (`r2`) and the position of the
    drawing dot (`prop`) to draw different designs. For example, the Spirograph in
    [Figure 6-16](ch06.xhtml#ch06fig16) has `r2` equal to 105 and `prop` equal to
    0.8.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f120-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-16: Another Spirograph design, created by changing `r2` and `prop`*'
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve been making shapes oscillate up and down, or left and right, using
    sine and cosine, but what about making shapes oscillate in two different directions?
    We’ll try that next.
  prefs: []
  type: TYPE_NORMAL
- en: MAKING HARMONOGRAPHS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the 1800s, there was an invention called the *harmonograph* that was a table
    connected to two pendulums. When the pendulums swung, the attached pen would draw
    on a piece of paper. As the pendulums swung back and forth and died down (*decayed*),
    the patterns would change in interesting ways, as illustrated in [Figure 6-17](ch06.xhtml#ch06fig17).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f120-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-17: Harmonograph machine and design*'
  prefs: []
  type: TYPE_NORMAL
- en: Using programming and a few equations, we can model how a harmonograph draws
    its patterns. The equations to model the oscillation of one pendulum are
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e121-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In these equations, *x* and *y* represent the horizontal and vertical displacement
    left/right and up/down distance) of the pen, respectively. Variable *a* is the
    amplitude (size) of the motion, *f* is the frequency of the pendulum, *t* is the
    elapsed time, *p* is the phase shift, e is the base of the natural logarithms
    (it’s a constant, around 2.7), and *d* is the decay factor (how fast the pendulum
    slows down). The time variable, *t*, will of course be the same in both of these
    equations, but all the other variables can be different: the left/right frequency
    can be different from the up/down frequency, for example.'
  prefs: []
  type: TYPE_NORMAL
- en: WRITING THE HARMONOGRAPH PROGRAM
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s create a Python-Processing sketch that models the movement of a pendulum.
    Create a new Processing sketch and call it *harmonograph.pyde*. The initial code
    is shown in [Listing 6-18](ch06.xhtml#ch06list18).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-18: The initial code for the harmonograph sketch*'
  prefs: []
  type: TYPE_NORMAL
- en: This is just the usual `setup()` and `draw()` functions with a time variable
    (`t`) and values for the amplitude (`a1,a2`), frequency (`f1,f2`), phase shift
    (`p1,p2`), and decay constants (`d1,d2`).
  prefs: []
  type: TYPE_NORMAL
- en: Then, starting at ➊, we define a bunch of variables to plug into the two formulas
    for the location of the harmonograph drawing pen. The `x =` and `y =` lines ➋
    use those variables and calculate the coordinates for the ellipse.
  prefs: []
  type: TYPE_NORMAL
- en: Now run this code, and you should see the circle moving, but what is it drawing?
    We need to put the points in a list and then graph all the points in the list.
    Right after declaring the `t` variable, create a list called `points`. The code
    so far is shown in [Listing 6-19](ch06.xhtml#ch06list19).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-19: The code to draw a harmonograph using lines between points*'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f122-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-18: The harmonograph*'
  prefs: []
  type: TYPE_NORMAL
- en: We start by defining the `points` list at the top of the file and adding points
    to the global variables in the `draw()` function. After calculating where `x`
    and `y` are, we add the line to add the point `[x,y]` to the `points` list. Finally,
    we go through the `points` list and draw a line from each point to the next one.
    Then we use Python’s `enumerate()` function and stop one point before the last
    one. This is so we don’t get an error message telling us the index is out of range
    when it tries to draw a line from the last point to the next one. Now when we
    run the code, we see the dot leave a trail behind it, as in [Figure 6-18](ch06.xhtml#ch06fig18).
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice if you comment out the decay part of the formulas, like this, the program
    will simply draw over the same lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The decay models the gradual decrease in a pendulum’s maximum amplitude, and
    it’s what creates the “scalloped” effect of so many harmonograph images. The first
    few times it’s cool to watch the code draw the design, but it takes a while. What
    if we could fill the `points` list all at once?
  prefs: []
  type: TYPE_NORMAL
- en: FILLING THE LIST INSTANTLY
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Instead of drawing the whole list at every frame, let’s come up with a way to
    fill the list instantly. We can cut the whole harmonograph code out of the `draw()`
    function and paste it into its own function, like in [Listing 6-20](ch06.xhtml#ch06list20).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-20: Separating out the `harmonograph()` function*'
  prefs: []
  type: TYPE_NORMAL
- en: Now in the `draw()` function, you just need a loop where you add a bunch of
    points for values of `t`, as in [Listing 6-21](ch06.xhtml#ch06list21).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-21: The new `draw()` function, which calls the `harmonograph()`
    function*'
  prefs: []
  type: TYPE_NORMAL
- en: Run this code and you’ll instantly see a complete harmonograph! Because we changed
    the size of the ellipses and the phase shifts, this one looks different, as you
    can see in [Figure 6-19](ch06.xhtml#ch06fig19). Change each of the values yourself
    and see how this changes the design!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f124-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-19: Using a different formula to make the harmonograph*'
  prefs: []
  type: TYPE_NORMAL
- en: TWO PENDULUMS ARE BETTER THAN ONE
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can add another pendulum to make more complicated designs by adding another
    term to each formula, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: All this does is add identical code to each line, with a few numbers changed,
    to simulate more than one pendulum in each direction. Of course, you have to create
    more variables and give them values. In [Listing 6-22](ch06.xhtml#ch06list22)
    are my suggestions for copying one of the designs I found at *[http://www.walkingrandomly.com/?p=151](http://www.walkingrandomly.com/?p=151)*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-22: The harmonograph code for the design in [Figure 6-20](ch06.xhtml#ch06fig20)*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 6-22](ch06.xhtml#ch06list22), all we changed were the constants
    for `a`, `f`, `p`, and `d` to make a completely different design. If you add `stroke(255,0,0)`
    to the code before drawing the lines, you’ll make the lines red, as shown in [Figure
    6-20](ch06.xhtml#ch06fig20).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f125-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-20: A complete harmonograph!*'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6-23 shows the final code for *harmonograph.pyde*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-23: The final code for the harmonograph sketch*'
  prefs: []
  type: TYPE_NORMAL
- en: '### SUMMARY'
  prefs: []
  type: TYPE_NORMAL
- en: Students in trigonometry class have to solve for unknown side lengths or angle
    measurements in triangles. But now you know the *real* use of sines and cosines
    is to rotate and transform points and shapes to make Spirograph and harmonograph
    designs! In this chapter, you saw how useful it is to save points to a list and
    then loop through the list to draw lines between the points. We also revisited
    some Python tools like `enumerate()` and `vertex()`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll use sines and cosines and the rotation ideas you
    learned in this chapter to invent a whole new kind of number! We’ll also rotate
    and transform grids using these new numbers, and we’ll create complex (pun intended)
    works of art using the locations of pixels!
  prefs: []
  type: TYPE_NORMAL
