- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Project Structure and Imports
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 项目结构与导入
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: I’ve found that structuring a Python project is one of the most often overlooked
    components of teaching the language. Many developers therefore get their project
    structure wrong, stumbling through a jumble of common mistakes until they arrive
    at something that at least works.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现结构化一个 Python 项目是教学过程中最常被忽视的部分之一。因此，许多开发者在项目结构上犯错，走过一系列常见错误，直到最终找到一个至少能工作的结构。
- en: 'Here’s the good news: you don’t have to be one of them!'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这是好消息：你不必成为其中之一！
- en: In this chapter, I’ll introduce import statements, modules, and packages, and
    I’ll show you how to fit everything together without tearing your hair out.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将介绍导入语句、模块和包，并向你展示如何把一切都拼凑在一起，而不至于抓狂。
- en: 'Be aware, I’m skipping over one critical piece of project structure in this
    chapter: *setup.cfg*, as it relies on concepts we haven’t yet covered. Without
    a *setup.cfg* or *setup.py* file, your project will not be ready to ship to end
    users. In this chapter, you’ll put everything in the right place for development.
    From there, preparing your project for distribution will be a fairly simple process.
    I’ll cover *setup.cfg*, *setup.py*, and other project structure issues relating
    to distribution in Chapter 18.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在本章中，我跳过了项目结构中的一个关键部分：*setup.cfg*，因为它依赖于我们尚未介绍的概念。没有 *setup.cfg* 或 *setup.py*
    文件，你的项目将无法准备好发布给最终用户。在本章中，你将把一切都放在开发的正确位置。从这里开始，为分发准备你的项目将是一个相对简单的过程。我将在第18章中介绍
    *setup.cfg*、*setup.py* 以及与分发相关的其他项目结构问题。
- en: Setting Up the Repository
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置版本库
- en: Before delving into the actual project structure, I want to address how it will
    fit into your *version control system (VCS)*, which I recommend using. For the
    rest of this book, I’ll assume you’re using Git, as that’s the most common option.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入讨论实际项目结构之前，我想先讲一下它如何融入到你的 *版本控制系统（VCS）* 中，我建议你使用版本控制系统。在本书的剩余部分，我将假设你使用 Git，因为它是最常见的选择。
- en: 'Once you’ve created your repository and cloned a local copy to your computer,
    you can begin to set up your project. At minimum, create the following files:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了版本库并将本地副本克隆到你的计算机上，你就可以开始设置你的项目了。至少，创建以下文件：
- en: '*README*, which is a description of your project and its goals'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*README*，它是对你项目及其目标的描述'
- en: '*LICENSE*, which is your project’s license'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*LICENSE*，这是你项目的许可证'
- en: '*.gitignore*, which is a special file that tells Git what files and directories
    to ignore'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*.gitignore*，它是一个特殊文件，告诉 Git 哪些文件和目录需要被忽略'
- en: A directory, which has the name of your project
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个目录，它的名称就是你的项目名称
- en: Your Python code belongs in a separate subdirectory and not in the root of the
    repository. This is very important, as your repository’s root directory will get
    mighty cluttered with build files, packaging scripts, documentation, virtual environments,
    and all manner of other things that aren’t actually part of the source code.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 Python 代码应该放在一个单独的子目录中，而不是放在版本库的根目录中。这非常重要，因为你的版本库根目录将会被构建文件、打包脚本、文档、虚拟环境以及其他许多与源代码无关的东西搞得杂乱无章。
- en: 'As an example, in this chapter, I’ll use one of my own Python projects: *omission*.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例，在本章中，我将使用我自己的一个 Python 项目：*omission*。
- en: A Python project is composed of modules and packages. In the next section, I’ll
    cover what those are and how to create them.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 Python 项目由模块和包组成。在接下来的部分，我将讲解这些是什么以及如何创建它们。
- en: Modules and Packages
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块与包
- en: A *module* is any Python (*.py*) file. (Anticlimactic, isn’t it?)
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*模块* 是任何 Python (*.py*) 文件。（有点反高潮，不是吗？）'
- en: A *package*, occasionally called a *regular package*, is one or more modules
    within a directory. That directory must include a file called *__init__.py* (which
    can be empty). The *__init__.py* file is important! If it isn’t there, Python
    will not know the directory constitutes a package.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*包*，有时称为 *常规包*，是一个目录中的一个或多个模块。该目录必须包含一个名为 *__init__.py* 的文件（该文件可以为空）。*__init__.py*
    文件很重要！如果它不存在，Python 就不会知道这个目录是一个包。'
- en: You can leave the *__init__.py* file empty (it often is), or you can use it
    to run certain code when the package is first imported. For example, you might
    use `__init__.py` to select and rename certain functions, so the end user of the
    package doesn’t need to understand how the modules are laid out. (See the subsection
    “Controlling Package Imports” later in the chapter.)
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 *__init__.py* 文件留空（它通常是空的），或者你可以在首次导入包时利用它运行某些代码。例如，你可以使用`__init__.py`选择并重命名某些函数，这样包的最终用户就不需要理解模块的布局。（请参阅本章稍后的“控制包导入”小节。）
- en: If you do forget *__init__.py* in your package, it becomes an *implicit namespace
    package*, also just known as a *namespace package*. These behave differently from
    regular packages. ***The two are not interchangeable!*** A namespace package allows
    you to distribute a package in multiple pieces, called *portions*. There are some
    cool advanced things you can do with namespace packages, but you will seldom need
    them. As this is a doozy of a rabbit hole, if you need namespace packages, see
    the documentation at [https://packaging.python.org/guides/packaging-namespace-packages/](https://packaging.python.org/guides/packaging-namespace-packages/).
    You can also read PEP 420, which officially defined the concept.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在包中忘记了 *__init__.py*，它就变成了*隐式命名空间包*，也称为*命名空间包*。它们与常规包的行为有所不同。***两者不可互换！***
    命名空间包允许你将一个包分成多个部分进行分发，称为*部分*。你可以用命名空间包做一些很酷的高级事情，但你很少会需要它们。由于这是一个相当复杂的技术，如果你需要命名空间包，请参阅[https://packaging.python.org/guides/packaging-namespace-packages/](https://packaging.python.org/guides/packaging-namespace-packages/)中的文档。你也可以阅读PEP
    420，它正式定义了这一概念。
- en: In my project structure, *omission* is a package that contains other packages.
    Thus, *omission* is my *top-level package*, and all the packages underneath it
    are its *subpackages*. This convention will be important once you start importing
    stuff.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的项目结构中，*omission*是一个包含其他包的包。因此，*omission*是我的*顶级包*，而它下面的所有包都是它的*子包*。这个约定在你开始导入内容时将变得非常重要。
- en: PEP 8 and Naming
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PEP 8 和 命名
- en: 'Your packages and modules need clear names to identify them. Consulting with
    PEP 8 about the naming conventions reveals this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你的包和模块需要清晰的名称来标识它们。参考PEP 8关于命名约定的内容可以得出以下结论：
- en: Modules should have short, all-lowercase names. Underscores can be used in the
    module name if it improves readability. Python packages should also have short,
    all-lowercase names, although the use of underscores is discouraged.
  id: totrans-25
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 模块应该有简短的小写名称。如果下划线有助于提高可读性，可以在模块名中使用下划线。Python 包也应有简短的小写名称，尽管不建议使用下划线。
- en: Understand that modules are named by filenames and packages are named by their
    directory name. Thus, these conventions define how you name your directories and
    code files.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 理解模块是通过文件名命名的，包是通过其目录名命名的。因此，这些约定定义了你如何命名目录和代码文件。
- en: To reiterate, filenames should be all lowercase, with underscores (`_`) if that
    improves readability. Similarly, directory names should be all lowercase, without
    underscores if at all possible. To put that another way . . .
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 重申一下，文件名应该全部小写，如果有助于提高可读性，可以使用下划线（`_`）。类似地，目录名应全部小写，尽量避免使用下划线。换句话说……
- en: 'Do this: *omission/data/data_loader.py*'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这样做：*omission/data/data_loader.py*
- en: 'NOT this: *omission/Data/DataLoader.py*'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不是这样：*omission/Data/DataLoader.py*
- en: Project Directory Structure
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 项目目录结构
- en: 'With that covered, take a look at my project’s repository directory structure:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 既然这些已经解释过了，来看一下我项目的仓库目录结构：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 4-1: Directory structure of *omission-git/*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4-1：*omission-git*的目录结构
- en: 'You’ll see that I have one top-level package called *omission*, with four subpackages:
    *common/*, *data/*, *game/*, and *tests/*. Each subpackage contains an *__init__.py*
    file, which is what designates them as packages. Every file that ends in *.py*
    is a module.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到，我有一个名为*omission*的顶级包，其中包含四个子包：*common/*、*data/*、*game/* 和 *tests/*。每个子包都包含一个
    *__init__.py* 文件，正是这个文件将它们标记为包。每个以*.py*结尾的文件都是一个模块。
- en: I also have the directory *resources/*, but that only contains game audio, images,
    and other sundry files (omitted here for brevity). The *resources/* directory
    is *not* a regular package, as it doesn’t contain an *__init__.py*.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我还拥有一个名为*resources/*的目录，但它只包含游戏音频、图像和其他杂项文件（为了简洁起见，这里省略）。*resources/*目录*不是*一个常规包，因为它不包含
    *__init__.py* 文件。
- en: 'I have another special file in my top-level package: *__main__.py*. This is
    the file that runs when I execute my top-level package directly, via this command:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我的顶级包中还有一个特殊文件：*__main__.py*。这是当我直接通过以下命令执行我的顶级包时运行的文件：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: I’ll come back to *__main__.py* in a bit (see the subsection “Package Entry
    Points” later in the chapter), as well as explain that lonely little *omission.py*
    file outside the top-level package.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我稍后会回到*__main__.py*（见本章后面的小节“包入口点”），同时解释那个孤独的*omission.py*文件，它位于顶级包之外。
- en: How import Works
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入的工作原理
- en: 'If you’ve written any meaningful Python code before, you’re almost certainly
    familiar with the `import` statement for importing modules. For example, to use
    it to import the module for regex, you’d enter this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前写过任何有意义的Python代码，你几乎肯定熟悉`import`语句，用于导入模块。例如，要导入用于正则表达式的模块，你会这样写：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Once you’ve imported a module, you can access any variables, functions, or classes
    defined within it.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你导入了一个模块，就可以访问该模块中定义的任何变量、函数或类。
- en: When you import the module, you are actually running it, which in turn executes
    any other `import` statements in the module. If there are any errors or performance
    costs in those secondarily (and onward) imported modules, they might seem to originate
    from your otherwise innocent import statement. It also means that Python has to
    be able to find all those modules.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当你导入模块时，实际上是在运行它，这进而执行模块中任何其他的`import`语句。如果那些次级（及之后）导入的模块中有任何错误或性能开销，它们可能看起来像是来自你原本无害的导入语句。这也意味着Python必须能够找到所有这些模块。
- en: 'For example, the module *re.py*, which is part of the Python standard library,
    has several import statements of its own, which are executed when you `import
    re`. The contents of those imported modules aren’t automatically available to
    the file you imported `re` from, but those module files have to exist for `import
    re` to succeed. If, for some unlikely reason, *enum.py* (another module that is
    part of the Python standard library) got deleted from your Python environment
    and you ran `import re`, it would fail with an error:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 比如，Python标准库中的模块*re.py*有几个自己的导入语句，这些语句在你`import re`时被执行。这些导入模块的内容不会自动对你导入`re`的文件可用，但这些模块文件必须存在，`import
    re`才能成功。如果出于某种不太可能的原因，*enum.py*（Python标准库中的另一个模块）被从你的Python环境中删除，而你运行`import re`，那么它会因为缺失模块而失败。
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This might seem like a confusing error message. I’ve seen people erroneously
    wonder why the outer module (in this example, `re`) couldn’t be found. Others
    have wondered why the inner module (`enum` here) is being imported at all, since
    they didn’t ask for it directly in their code.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来像是一个令人困惑的错误信息。我见过有人错误地疑惑为什么外部模块（在这个例子中是`re`）无法找到。也有人想知道为什么内部模块（这里是`enum`）会被导入，毕竟他们并没有在代码中直接请求它。
- en: The problem is that the `re` module was imported, and that in turn imported
    the `enum` module. However, because the `enum` module is missing, importing `re`
    fails with a `ModuleNotFoundError`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于`re`模块已被导入，而这反过来又导入了`enum`模块。然而，因为`enum`模块丢失，导入`re`会因`ModuleNotFoundError`而失败。
- en: 'Take note that this scenario is fictional: `import enum` and `import re` will
    never fail under normal circumstances, because both modules are part of Python’s
    standard library. However, this little example demonstrates the common problem
    of `import` statements failing due to missing modules.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个场景是虚构的：在正常情况下，`import enum`和`import re`永远不会失败，因为这两个模块是Python标准库的一部分。然而，这个小例子演示了由于缺失模块导致`import`语句失败的常见问题。
- en: Import Dos and Don’ts
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入的注意事项
- en: There are various ways of importing, but most of them should rarely, if ever,
    be used.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种导入方式，但大多数方法应该很少甚至从不使用。
- en: 'For the upcoming examples, I’ll be using a module called *smart_door.py*, which
    reads as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的示例中，我将使用一个名为*smart_door.py*的模块，它的内容如下：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 4-2: *smart_door.py*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-2：*smart_door.py*
- en: 'Let’s say I want to use this module in another Python file, which (in this
    example) is in the same directory. To run the functions defined in that module,
    I’d have to first import the module `smart_door`. The easiest way to do this is
    as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我想在另一个Python文件中使用这个模块（在这个例子中，它与当前文件位于同一目录）。要运行该模块中定义的函数，我必须首先导入模块`smart_door`。最简单的做法如下：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 4-3: *use_smart_door.py:1a*'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-3：*use_smart_door.py:1a*
- en: The *namespace* of `open()` and `close()` is `smart_door`. A *namespace* is
    an explicitly defined path to something, such as a function. The function `open()`
    has the namespace `smart_door`, which tells me that `open()` belongs to that particular
    module. Remember this from The Zen of Python?
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`open()`和`close()`的*命名空间*是`smart_door`。*命名空间*是指向某物（如函数）显式定义的路径。函数`open()`的命名空间是`smart_door`，这告诉我`open()`属于那个特定的模块。记得《Python禅》中的这一点吗？'
- en: Namespaces are one honking great idea—let’s do more of those!
  id: totrans-58
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 命名空间是个绝妙的主意——让我们多做一些这样的事情吧！
- en: Python developers really like namespaces because they make it obvious where
    functions and whatnot are coming from. That comes in handy when you have multiple
    functions that have similar names or the same name, but that are defined in different
    modules. Without that bit of namespace, `smart_door`, you would not know that
    `open()` had anything to do with opening the smart door. Appropriately using namespaces
    can help you avoid massive errors in your code. However, as important as namespaces
    are, they can get out of hand very quickly if used improperly.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Python 开发者非常喜欢命名空间，因为它们使得函数的来源一目了然。当你有多个函数，它们的名字相似或者相同，但定义在不同的模块中时，这非常有用。如果没有那个命名空间`smart_door`，你就不会知道`open()`与开启智能门有什么关系。恰当地使用命名空间可以帮助你避免代码中的严重错误。然而，命名空间虽然很重要，但如果使用不当，它们会迅速变得难以管理。
- en: Be advised, in referring to *namespaces*, I’m not necessarily talking about
    *implicit namespace packages*, which I don’t cover in this book.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，提到*命名空间*时，我不一定是在谈论*隐式命名空间包*，这是本书中没有涉及的内容。
- en: Here’s a look at some good and bad examples of namespaces in action.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些命名空间应用的好例子和坏例子。
- en: Importing Functions from Modules
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从模块导入函数
- en: In my previous `smart_door` function calls, I referenced the namespace on every
    function call. This is usually best when a function is called only a handful of
    times, but if you use a function often, it gets tedious to use a namespace for
    every single function call.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在我之前的`smart_door`函数调用中，我在每次函数调用时都引用了命名空间。当一个函数只被调用少数几次时，这通常是最好的做法，但如果你经常使用某个函数，那么每次调用都使用命名空间会显得非常繁琐。
- en: 'Thankfully, Python provides a way around that. To be able to use the `open()`
    function without constantly having to precede it with its module name (`smart_door`),
    I need only know the *qualified name*—that is, the name of the function, class,
    or variable, preceded by its complete namespace within one of its modules or packages
    (if any). Within the *smart_door.py* module, the qualified name of the function
    I want is just `open`. Thus, I import that function like this, instead:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Python 提供了一种解决方法。为了能够使用 `open()` 函数，而不需要每次都在前面加上它的模块名（`smart_door`），我只需要知道*完全限定名*——也就是说，函数、类或变量的名称，前面加上它在其模块或包中的完整命名空间（如果有的话）。在*smart_door.py*模块中，我需要的函数的完全限定名就是`open`。因此，我改为这样导入该函数：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 4-4: *use_smart_door.py:1b*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-4：*use_smart_door.py:1b*
- en: 'This introduces a new problem. Neither `close()` nor `smart_door.close()` will
    work in this example, because I didn’t import the function outright. The entire
    `smart_door` module was still run by the import command, but only the `open()`
    function was actually imported. To use `smart_door.close()`, I’d need to change
    the code to this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这带来了一个新问题。在这个例子中，`close()`和`smart_door.close()`都无法工作，因为我没有直接导入这个函数。整个`smart_door`模块确实被导入了，但只有`open()`函数被实际导入。为了使用`smart_door.close()`，我需要将代码更改为：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 4-5: *use_smart_door.py:1c*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-5：*use_smart_door.py:1c*
- en: This gives me access to both functions, no namespace required.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我可以访问两个函数，无需命名空间。
- en: The Problem of Shadowing
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 覆盖问题
- en: 'You might have noticed another problem: `open()` is already a built-in Python
    function! Assume I also need to read a file called *data.txt*, which exists in
    my current directory. If I try this after importing `open()` from the `smart_door`
    function ([Listing 4-5](#listing4-5)), my program is going to behave very badly:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到另一个问题：`open()`已经是一个内建的 Python 函数了！假设我还需要读取一个名为*data.txt*的文件，该文件存在于当前目录中。如果在从`smart_door`函数导入`open()`之后，我尝试这么做，我的程序将会表现得非常糟糕：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 4-6: *use_smart_door.py:2*'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-6：*use_smart_door.py:2*
- en: When I used `open()` earlier ([Listing 4-5](#listing4-5)), I wanted to use `smart_door.open()`.
    Now, in the same file, I’m trying to call Python’s built-in `open()` function
    to open a text file for reading. Unfortunately, because of the earlier import,
    the built-in `open()` function has been *shadowed* by `smart_door.open()`, meaning
    the presence of the latter is making it impossible for Python to even find the
    former. This code will fail!
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当我之前使用`open()`时（[列表 4-5](#listing4-5)），我本来想用`smart_door.open()`。现在，在同一个文件中，我尝试调用
    Python 内建的 `open()` 函数来打开一个文本文件进行读取。不幸的是，由于之前的导入，内建的 `open()` 函数已经被`smart_door.open()`*覆盖*，这意味着后者的存在使得
    Python 无法找到前者。这个代码会失败！
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: I got that error because I’m trying to use the built-in `open()` function, which
    accepts two arguments, but I unintentionally called `smart_door.open()`, which
    doesn’t accept any arguments.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我得到那个错误是因为我尝试使用内置的`open()`函数，它接受两个参数，但我无意中调用了`smart_door.open()`，它不接受任何参数。
- en: Getting an actual error message is one of the better failure scenarios for this
    sort of mistake. Imagine if `smart_door.open()` did accept similar arguments to
    the built-in `open()`. Depending on my code, I might wind up with an error elsewhere
    (perhaps from trying to use a file I hadn’t opened), or worse, some form of incorrect
    but technically valid behavior. This sort of mistake is infamously difficult to
    debug, so it is wise to avoid.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 获取实际的错误信息是这种错误的较好失败情境之一。想象一下，如果`smart_door.open()`接受与内置`open()`相似的参数，按照我的代码，我可能会在其他地方遇到错误（也许是因为我试图使用一个没有打开的文件），或者更糟糕的是，出现某种形式的错误，但它在技术上是有效的行为。这种错误通常非常难以调试，因此最好避免。
- en: 'So how should I fix this? If I were the one who wrote *smart_door.py*, I should
    just go and change the function name. It’s universally considered bad practice
    to use function names that shadow built-in Python functions anyhow, unless the
    entire point *is* to shadow. However, assume that I’m not the author of that module
    and I need another solution. Thankfully, Python offers one in the `as` keyword,
    which allows me to create an alias for that function:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 那我该如何解决这个问题呢？如果我是*smart_door.py*的作者，我应该直接去修改函数名。使用会覆盖内置Python函数的函数名普遍被认为是不好的做法，除非整个目的是为了覆盖。不过，假设我不是该模块的作者，需要找到另一个解决方案。幸运的是，Python提供了`as`关键字，可以让我为该函数创建别名：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 4-7: *use_smart_door.py:1d*'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 4-7: *use_smart_door.py:1d*'
- en: In the import, I use the `as` keyword to rename `smart_door.open()` to `door_open()`,
    but only in the context of this file. Then, I can refer to `door_open()` where
    I wanted `smart_door.open()`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入中，我使用`as`关键字将`smart_door.open()`重命名为`door_open()`，但仅限于此文件的上下文中。然后，我可以在需要`smart_door.open()`的地方引用`door_open()`。
- en: This leaves Python’s built-in `open()` function unshadowed, so the earlier code
    for working with the file ([Listing 4-6](#listing4-6)) can function properly.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得Python的内置`open()`函数不再被覆盖，因此之前处理文件的代码（[列表 4-6](#listing4-6)）可以正常工作。
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The Trouble with Nested Packages
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 嵌套包的问题
- en: 'As you’ve seen, packages can contain other packages. In my *omission* project,
    if I wanted to import the module *data_loader.py*, I could use this line (refer
    back to the *omission* project structure):'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，包可以包含其他包。在我的*省略*项目中，如果我想导入模块*data_loader.py*，我可以使用这一行（参见*省略*项目结构）：
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The Python interpreter looks for the *omission* package, the *data* package
    inside that, and the *data_loader* module inside that. The *data_loader* module
    (and only that module) is imported. This is a good structure, and all’s well.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Python解释器会查找*省略*包、包中的*data*包，以及其中的*data_loader*模块。只有*data_loader*模块被导入。这是一个不错的结构，一切都很好。
- en: 'At a certain point, however, nesting packages can become a pain. A function
    call like `musicapp.player.data.library.song.play()` is just ugly, not to mention,
    difficult to read. As The Zen of Python muses:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，嵌套包会变得麻烦。像`musicapp.player.data.library.song.play()`这样的函数调用看起来很难看，更不用说很难阅读了。正如《Python禅》所说：
- en: Flat is better than nested.
  id: totrans-90
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 扁平化比嵌套更好。
- en: Some nesting of packages is certainly okay, but when your project starts looking
    like an elaborate set of Matryoshka dolls, you’ve done something wrong. Organize
    your modules into packages, but keep the structure reasonably simple. Nesting
    two or three packages deep is okay; deeper is generally not advisable, if it can
    be avoided.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一定程度的包嵌套是可以的，但当你的项目开始看起来像一套精致的套娃时，你就做错了什么。组织你的模块成包，但要保持结构简洁。如果能避免，通常不建议嵌套超过两到三个包。
- en: 'Although we’d never have overly nested nightmares in an ideal world, real-life
    projects aren’t always that neat. Sometimes, it isn’t possible to avoid deep nesting
    structures. I need another way to keep my import statements sane. Graciously,
    the import system can handle this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在理想的世界里，我们永远不会有过度嵌套的噩梦，但现实中的项目并不总是那么整洁。有时候，避免深层嵌套结构是不可行的。我需要另一种方式来保持我的导入语句整洁。幸运的是，导入系统能够处理这种情况：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: I only have to deal with the deeply nested namespace once, in the actual import
    statement. After that, I just use the function name, `play()`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我只需要在实际的导入语句中处理一次深度嵌套的命名空间。之后，我只需使用函数名`play()`。
- en: 'Alternatively, if I want a little bit of namespace, I can have that, too:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果我需要一点命名空间，我也可以实现：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: My import statement has resolved all but that last bit of namespace, `song`,
    so I still know where the `play()` function is coming from.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我的导入语句已经解决了除了最后那个命名空间`song`之外的所有问题，所以我仍然知道`play()`函数来自哪里。
- en: The import system is deliciously flexible like that.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 导入系统就是如此灵活。
- en: Beware of Importing All
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小心导入所有内容
- en: 'Before long, you’ll probably find yourself tempted to import all of the hundreds
    of functions in your module, to save time. This is the point at which many developers
    go off the rails:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 不久后，你可能会发现自己想要导入模块中所有数百个函数，以节省时间。这时，许多开发者可能会走偏：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This statement imports nearly everything in the module directly, except for
    anything preceded by one or more underscores. This import-all pattern is a Very
    Bad Idea, as you won’t know what all is getting imported or what will be shadowed
    in the process.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语句几乎直接导入了模块中的所有内容，除了任何前面带有一个或多个下划线的内容。这种导入所有内容的方式非常糟糕，因为你根本不知道到底导入了什么，或者在过程中什么被覆盖了。
- en: 'The problem gets even worse when you start importing all from multiple modules:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始从多个模块导入所有内容时，问题变得更糟：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Doing this, you may be blissfully unaware that `open()`, `smart_door.open()`,
    and `gzip.open()` all exist and are fighting over the same name in your file!
    The function `gzip.open()` will win out in this example, because it’s the last
    version of `open()` that was imported. The other two functions have been shadowed,
    which means you effectively can’t call them at all.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做时，你可能会无忧无虑地不知道`open()`、`smart_door.open()`和`gzip.open()`都存在，并且在文件中争夺同一个名字！在这个例子中，`gzip.open()`会胜出，因为它是最后导入的`open()`版本。其他两个函数被覆盖了，实际上你根本无法调用它们。
- en: Since no one is likely to remember every single function, class, and variable
    in every module that gets imported, one can easily wind up with a whole lot of
    messes.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有人可能记住每个模块中每个导入的函数、类和变量，所以很容易就会弄得一团糟。
- en: 'The Zen of Python applies to this situation:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Python的禅意适用于这种情况：
- en: Explicit is better than implicit.
  id: totrans-108
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 明确优于隐式。
- en: ''
  id: totrans-109
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: (. . .)
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: (. . .)
- en: ''
  id: totrans-111
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the face of ambiguity, refuse the temptation to guess.
  id: totrans-112
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 面对模糊性时，拒绝猜测的诱惑。
- en: You should never have to guess where a function or variable is coming from.
    There should be code somewhere in the file that explicitly tells you where everything
    comes from, as seen in the preceding examples.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你永远不应该猜测一个函数或变量的来源。文件中应该有某处明确的代码告诉你每个内容的来源，正如前面的示例所示。
- en: This `import *` doesn’t quite work the same way with packages. By default, a
    line like `from some_package import *` will be functionally the same as `import
    some_package`, unless the package has been configured to work with `import *`.
    I’ll come back to this later.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`import *`在包中的工作方式不完全一样。默认情况下，像`from some_package import *`这样的语句在功能上与`import
    some_package`相同，除非该包已配置为支持`import *`。稍后我会再谈这个问题。
- en: Importing Within Your Project
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在项目中导入
- en: Now that you know how to structure your project and import from packages and
    modules, I’ll tie everything together.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何构建项目并从包和模块中导入内容，我将把一切联系起来。
- en: 'Recall my *omission* project structure from [Listing 4-1](#listing4-1). Here’s
    a subsection of that project directory:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下我的*omission*项目结构，见[列表4-1](#listing4-1)。这是该项目目录的一个子部分：
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 4-8: Directory structure of *omission-git/*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4-8：*omission-git*的目录结构
- en: Any one module in my project may need to be able to import from another module,
    whether it’s within the same package or somewhere else in the project structure.
    I’ll explain how to handle both scenarios.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 项目中的任何模块可能都需要从另一个模块导入内容，无论它是同一个包内的，还是项目结构中其他地方的。我将解释如何处理这两种情况。
- en: Absolute Imports
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绝对导入
- en: I have a class `GameMode` defined within the *game_enums.py* module, which lives
    in the *omission/common* package. I want to use that class within my *game_round_settings.py*
    module, defined in the *omission/data* package. How do I get to it?
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我在*game_enums.py*模块中定义了一个`GameMode`类，该模块位于*omission/common*包中。我想在*game_round_settings.py*模块中使用该类，这个模块位于*omission/data*包中。我该如何访问它？
- en: 'Because I defined *omission* as a top-level package and organized my modules
    into subpackages, it’s pretty straightforward. In *game_round_settings.py*, I’d
    write the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我将*omission*定义为顶级包，并将我的模块组织成子包，所以这非常简单。在*game_round_settings.py*中，我会写如下代码：
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 4-9: *game_round_settings.py:1a*'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4-9：*game_round_settings.py:1a*
- en: This line is an *absolute import*. It starts at the top-level package, *omission*,
    and walks down into the *common* package, where it looks for *game_enums.py*.
    Inside that module, it finds whatever has the name `GameMode` and imports that.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行是一个*绝对导入*。它从顶级包*omission*开始，然后进入*common*包，查找*game_enums.py*。在该模块中，它找到名为`GameMode`的内容并导入它。
- en: Relative Imports
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 相对导入
- en: 'You can also import from a module in the same package or subpackage. This is
    known as a *relative import* or an *intrapackage reference*. In practice, intra-package
    references are easy to do wrong. If some developer wanted to import `GameMode`
    (which is provided by *omission/common/game_enums.py*) into *omission/data/game_round_settings.py*,
    they might incorrectly attempt to use something like the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以从同一包或子包中的模块导入。这被称为*相对导入*或*包内引用*。在实践中，包内引用很容易出错。如果某个开发者想从*omission/common/game_enums.py*中导入`GameMode`到*omission/data/game_round_settings.py*中，他们可能会错误地尝试使用类似以下的代码：
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 4-10: *game_round_settings.py:1b*'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 4-10: *game_round_settings.py:1b*'
- en: This fails, leaving the developer wondering why it doesn’t work. The *data*
    package (where *game_round_settings.py* lives) has no knowledge of its sibling
    packages, such as *common*.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做会失败，开发者会疑惑为什么不起作用。*data*包（即*game_round_settings.py*所在的包）并不了解其兄弟包，比如*common*。
- en: A module knows what package it belongs to, and a package knows its parent package
    (if it has one). Because of this, relative imports can start the search from the
    current package and move up and down through the project structure.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一个模块知道它属于哪个包，而一个包知道它的父包（如果有的话）。因此，相对导入可以从当前包开始搜索，然后上下移动，遍历项目结构。
- en: 'Within *omission/data/game_round_settings.py*, I can use the following import
    statement:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在*omission/data/game_round_settings.py*中，我可以使用以下导入语句：
- en: '[PRE20]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 4-11: *game_round_settings.py:1c*'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 4-11: *game_round_settings.py:1c*'
- en: The two dots (`..`) mean “the current package’s direct parent package,” which,
    in this case, is *omission*. The import steps up one level, walks down into *common*,
    and finds *game_enums.py*.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 两个点（`..`）表示“当前包的直接父包”，在这个例子中就是*omission*。导入会向上一层，进入*common*，然后找到*game_enums.py*。
- en: There’s some difference of opinion among Python developers about whether to
    use absolute or relative imports. Personally, I prefer to use absolute imports
    whenever possible, because I feel it makes the code a lot more readable. You can
    make up your own mind. The only important factor is that the result should be
    *obvious*—there should be no mystery about where anything comes from.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 关于是否使用绝对导入或相对导入，Python 开发者之间有一些不同的看法。就个人而言，我更倾向于在可能的情况下使用绝对导入，因为我觉得这样可以使代码更加易读。你可以自行决定。唯一重要的因素是结果应该是*显而易见的*——任何东西的来源都不应该让人感到困惑。
- en: Importing from the Same Package
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从同一包导入
- en: 'There is one other lurking gotcha here. In *omission/data/settings.py*, I have
    this statement for importing a class from the module *omission/data/game_round_settings.py*:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个潜在的陷阱。在*omission/data/settings.py*中，我有这样一个导入语句，用于从*omission/data/game_round_settings.py*模块中导入一个类：
- en: '[PRE21]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 4-12: *settings.py:1a*'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 4-12: *settings.py:1a*'
- en: 'You might think that since both *settings.py* and *game_round_settings.py*
    are in the same package, *data*, I should be able to just use this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为，既然*settings.py*和*game_round_settings.py*都在同一个包*data*中，我应该可以直接使用这个：
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 4-13: *settings.py:1b*'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 4-13: *settings.py:1b*'
- en: However, that will not work. It will fail to locate the *game_round_settings.py*
    module because I am running the top-level package (`python3 -m omission`), and
    absolute imports for anything within the package being executed (*omission*) have
    to start from the top.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不会奏效。它无法定位到*game_round_settings.py*模块，因为我在运行顶级包（`python3 -m omission`），而执行包中的绝对导入（*omission*）必须从顶层开始。
- en: 'I can instead use a relative import, which looks much simpler than the absolute
    import:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我也可以改用相对导入，这样看起来比绝对导入简单得多：
- en: '[PRE23]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Listing 4-14: *settings.py:1c*'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 4-14: *settings.py:1c*'
- en: In this case, the single dot (`.`) means “this package.”
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，一个点（`.`）表示“当前包”。
- en: 'This probably feels familiar if you’re used to the typical UNIX filesystem,
    although Python takes the concept a bit further:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你习惯了典型的 UNIX 文件系统，这可能会让你感觉很熟悉，尽管 Python 在这个概念上做得更进一步：
- en: One dot (`.`) means the current package.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个点（`.`）表示当前包。
- en: Two dots (`..`) takes you back one level, to the parent package.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两个点（`..`）可以让你回到上一级，即父包。
- en: Three dots (`...`) takes you back two levels, to the parent of the parent package.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 三个点（`...`）可以让你回到两级，即父包的父包。
- en: Four dots (`....`) takes you back three levels.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 四个点（`....`）会让你回到上三级。
- en: And so on, and so forth.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 以此类推，等等。
- en: Keep in mind that those “levels” aren’t just plain directories; they’re packages.
    If you have two distinct packages in a plain directory that isn’t a package, you
    can’t use relative imports to jump from one to another. You’ll have to work with
    the Python search path for that. I’ll talk more about that later in this chapter.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这些“层级”不仅仅是普通目录，它们是包。如果你在一个不是包的普通目录中有两个独立的包，你不能使用相对导入来从一个跳到另一个。你必须与Python搜索路径一起工作。稍后我会在本章中详细讲解这个问题。
- en: Entry Points
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 入口点
- en: So far, you’ve learned how to create modules, packages, and projects, and how
    to make full use of the import system. The last piece of this puzzle is gaining
    the ability to control what happens when a package is imported or executed. The
    parts of the project that are run first when importing or executing are called
    *entry points*.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经学会了如何创建模块、包和项目，并充分利用导入系统。这个难题的最后一部分是获得控制包在导入或执行时发生什么的能力。项目中在导入或执行时首先运行的部分被称为*入口点*。
- en: Module Entry Points
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模块入口点
- en: 'When you import a Python module or package, it is given a special variable
    called `__name__`. This contains the *fully qualified name* of the module or package,
    which is the name as the import system sees it. For example, the fully qualified
    name of the module *omission/common/game_enums.py* would be `omission.common.game_enums`.
    There is one exception: when a module or package is run directly, its `__name__`
    is set to the value `"__main__"`.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当你导入一个Python模块或包时，它会被赋予一个特殊的变量，叫做`__name__`。这个变量包含模块或包的*完全限定名*，即导入系统看到的名称。例如，模块*omission/common/game_enums.py*的完全限定名是`omission.common.game_enums`。有一个例外：当模块或包被直接运行时，它的`__name__`会被设置为`"__main__"`。
- en: 'To demonstrate this, assume I have a package called *testpkg*, which contains
    the module *awesome.py*. It defines a function, `greet()`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，假设我有一个名为*testpkg*的包，其中包含模块*awesome.py*。它定义了一个函数，`greet()`：
- en: '[PRE24]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Listing 4-15: *awesome.py:1*'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 4-15: *awesome.py:1*'
- en: 'The bottom of that same file also contains a `print` message:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件的底部还包含一条`print`消息：
- en: '[PRE25]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Listing 4-16: *awesome.py:2a*'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 4-16: *awesome.py:2a*'
- en: 'In another module in the same directory as *testpkg*, I have this module (*example.py*),
    which I run directly with `python3 example.py`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在与*testpkg*同一目录下的另一个模块中，我有这个模块（*example.py*），我通过`python3 example.py`直接运行它：
- en: '[PRE26]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Listing 4-17: *example.py*'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 4-17: *example.py*'
- en: If I look at the `_name_` local variable—which is the `__name__` presently assigned
    to the current module, *example.py*—I’ll see the value is `"__main__"` because
    I executed *example.py* directly.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我查看`_name_`局部变量（也就是当前模块*example.py*的`__name__`），我会看到它的值是`"__main__"`，因为我直接执行了*example.py*。
- en: The package `awesome` I imported also has a `__name__` variable, which has the
    value `"testpkg.awesome"`, representing where the package came from in the import
    system.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我导入的包`awesome`也有一个`__name__`变量，它的值是`"testpkg.awesome"`，表示该包在导入系统中的来源。
- en: 'If you ran that module, you’d get the following output:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行该模块，你会得到以下输出：
- en: '[PRE27]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: That first line is coming from *testpkg/awesome.py*, which is run by the import
    command. The rest is coming from the two print commands in *example.py*.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行来自于*testpkg/awesome.py*，这是通过导入命令运行的。其余部分来自于*example.py*中的两个打印命令。
- en: 'But what if I want that first message to appear only if *awesome.py* is executed
    directly, and *not* when the module is only imported? To accomplish that, I’d
    check the value of `__name__` variable in a conditional statement. I’ve rewritten
    my *awesome.py* file to do exactly that:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我希望只有在直接执行*awesome.py*时，才显示那条第一条消息，而不是在模块仅被导入时显示呢？为了实现这一点，我会在条件语句中检查`__name__`变量的值。我已经重新编写了我的*awesome.py*文件，正是为了实现这个目标：
- en: '[PRE28]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Listing 4-18: *awesome.py:2b*'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 4-18: *awesome.py:2b*'
- en: If *awesome.py* is executed directly, `__name__` will have the value `"__main__"`,
    so the print statement will run. Otherwise, if *awesome.py* is being imported
    (or otherwise run indirectly), the conditional will fail.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*awesome.py*被直接执行，`__name__`的值将是`"__main__"`，因此打印语句将会执行。否则，如果*awesome.py*只是被导入（或者间接执行），条件语句将失败。
- en: While you’ll frequently see this pattern in Python, some Python experts consider
    it an anti-pattern, because it can encourage you to both execute and import a
    module at the same time. While I don’t agree that using `if__name__ == "__main__"`
    is an anti-pattern, you often don’t need it. In any case, be certain you never
    import your main module from anywhere else in your package.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你在Python中经常会看到这种模式，但一些Python专家认为它是一种反模式，因为它可能会鼓励你同时执行和导入一个模块。虽然我不同意使用`if __name__
    == "__main__"`是反模式，但你通常不需要它。无论如何，请确保你永远不要从包中的其他地方导入主模块。
- en: Package Entry Points
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 包入口点
- en: Notice that my *omission* project has a file called `__main__` in the top-level
    package. This file is automatically run when a package is executed directly, but
    never when importing the package.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我的*omission*项目在顶级包中有一个名为`__main__`的文件。这个文件在包被直接执行时会自动运行，但在导入包时则不会。
- en: So, when executing *omission* via `python3 -m omission`, Python first runs the
    *__init__.py* module (as always), followed by its *__main__.py* module. Otherwise,
    if the package is imported instead, only *__init__.py* is executed.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，当通过`python3 -m omission`执行*omission*时，Python首先运行*__init__.py*模块（和往常一样），然后运行它的*__main__.py*模块。否则，如果是导入包，那么只会执行*__init__.py*。
- en: If you omit *__main__.py* from a package, it cannot be executed directly.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你省略了包中的*__main__.py*，则该包不能直接执行。
- en: 'A good *__main__.py* for a top-level package would look something like the
    following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的*__main__.py*文件对于顶级包可能看起来像下面这样：
- en: '[PRE29]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Listing 4-19: *__main__.py*'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 4-19: *__main__.py*'
- en: All the logic for starting the package belongs in the `main()` function. Then,
    the `if` statement checks the `__name__` assigned to the *__main__.py* module.
    Since this package is being executed directly, the value of `__name__` is `"__main__"`,
    and the code within the `if` statement, being the call to the `main()` function,
    is run. Otherwise, if *__main__.py* were only being imported, its fully qualified
    name would include its containing package (for example, `omission.__main__`),
    the condition would fail, and the code wouldn’t run.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 所有启动包的逻辑都应该放在`main()`函数中。然后，`if`语句检查分配给*__main__.py*模块的`__name__`。由于该包是直接执行的，`__name__`的值是`"__main__"`，`if`语句中的代码，即调用`main()`函数的代码，会被执行。否则，如果只是导入*__main__.py*，它的完全限定名称将包含其所属的包（例如，`omission.__main__`），条件将不成立，代码不会运行。
- en: Controlling Package Imports
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制包的导入
- en: A package’s *__init__.py* file can come in handy when you want to change what
    is available for import and how it can be used. The most common uses for this
    file are to simplify imports and to control the behavior of import-all (`import
    *`).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 一个包的*__init__.py*文件在你想要改变可导入内容以及如何使用时非常有用。这个文件最常见的用途是简化导入和控制全量导入行为（`import *`）。
- en: Simplifying Imports
  id: totrans-190
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 简化导入
- en: 'Imagine I have a particularly complicated package, `rockets`, which is made
    up of dozens of subpackages and hundreds of modules. I can safely assume that
    many developers using the package won’t want to know about most of that functionality.
    They only want one thing: to define a rocket and then launch it! Instead of expecting
    all the users of my package to know where those few basic bits of functionality
    exist in the package structure, I can use *__init__.py* to expose said functionality
    directly, making the bits easier to import later:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我有一个特别复杂的包`rockets`，它由几十个子包和数百个模块组成。我可以安全地假设，很多使用这个包的开发者不想了解其中大部分功能。他们只想要一件事：定义一个火箭然后发射它！与其指望我包的所有用户都知道这些基本功能在包结构中的位置，不如利用*__init__.py*直接暴露这些功能，使得后续的导入更加简便：
- en: '[PRE30]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Listing 4-20: *__init__.py:1*'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 4-20: *__init__.py:1*'
- en: 'This greatly simplifies the usage of the package. I no longer need to remember
    where things like the `SmallRocket` and `Launchpad` classes live in the `rockets`
    package structure. I can import them directly from the top-level package and use
    them:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这大大简化了包的使用。我不再需要记住像`SmallRocket`和`Launchpad`类在`rockets`包结构中的位置。我可以直接从顶级包中导入并使用它们：
- en: '[PRE31]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Listing 4-21: *rocket_usage.py*'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 4-21: *rocket_usage.py*'
- en: Beautifully simple, isn’t it? Still, nothing is actually *preventing* me from
    importing things the long-form way (such as `from rockets.smallrocket.rocket import
    SmallRocket`) if I need to. The shortcut is there, but it’s optional.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 美丽而简单，不是吗？不过，实际上并没有什么*阻止*我使用传统方式导入（例如 `from rockets.smallrocket.rocket import
    SmallRocket`），如果我需要的话。快捷方式存在，但它是可选的。
- en: Because simplicity is such an essential part of the Python philosophy, it is
    also an essential component of package design. If you can anticipate the most
    common ways a user might interact with your package, you can greatly simplify
    their code by adding a few lines to *__init__.py*.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 因为简洁性是Python哲学中至关重要的一部分，它也是包设计的一个关键组成部分。如果你能够预见用户与包交互的最常见方式，你可以通过在`__init__.py`中添加几行代码大大简化他们的代码。
- en: Controlling Import-All
  id: totrans-199
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 控制Import-All
- en: By default, import-all doesn’t work with a package. You use *__init__.py* to
    enable and control the behavior of `import *`, even though such an import statement
    is generally discouraged. This can be done by assigning a list of strings to `__all__`,
    with each string containing something (such as a package or module) to import
    from the current package.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`import-all`不适用于包。你使用`__init__.py`来启用和控制`import *`的行为，尽管通常不建议使用这种导入语句。这可以通过将一个包含字符串列表分配给`__all__`来完成，每个字符串包含一个要从当前包导入的内容（如包或模块）。
- en: 'This works well with the previous trick ([Listing 4-20](#listing4-20)):'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这个技巧与之前的技巧（[列表 4-20](#listing4-20)）配合得很好：
- en: '[PRE32]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Listing 4-22: *__init__.py:2a*'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 4-22: *__init__.py:2a*'
- en: 'When Python encounters a line like `from rockets import *`, that list from
    `__all__` (seen as `rockets.__all__`) is unpacked in place of the asterisk (`*`).
    This is important in figuring out what you can include in `__all__`: each item
    in my list should make sense when substituted for the asterisk in `from rockets
    import *`.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当Python遇到像`from rockets import *`这样的行时，来自`__all__`的列表（即`rockets.__all__`）会被解包并替换星号（`*`）。这在确定你可以包含哪些内容到`__all__`中时非常重要：我列表中的每个项目在替换为`from
    rockets import *`中的星号时都应该是有意义的。
- en: 'In other words, I could change the last line of my *__init__.py* to this, and
    there would be no error in the code:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我可以将我的`__init__.py`的最后一行改为这样，这样代码就不会出错：
- en: '[PRE33]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Listing 4-23: *__init__.py:2b*'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 4-23: *__init__.py:2b*'
- en: This works because, as you already know, the line `from rockets import smallrocket`
    is a valid import statement.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 之所以这样有效，是因为，正如你已经知道的，`from rockets import smallrocket`这一行是一个有效的导入语句。
- en: 'On the other hand, this example would *not* work:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，这个例子*不会*有效：
- en: '[PRE34]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Listing 4-24: *__init__.py:2c*'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 4-24: *__init__.py:2c*'
- en: It fails because `from rockets import smallrocket.rocket` does not make sense.
    You’ll have to consider this principle when defining `__all__`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 它失败是因为`from rockets import smallrocket.rocket`是没有意义的。在定义`__all__`时，你需要考虑这一原则。
- en: If `__all__` is not defined in *__init__.py*, then `from rockets import *` will
    behave the same as `import rockets`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`__all__`在`__init__.py`中没有定义，那么`from rockets import *`将表现得与`import rockets`相同。
- en: Program Entry Points
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 程序入口点
- en: If you’ve applied all the concepts in this chapter to your project’s structure,
    you can run `python3 -m yourproject` to start your program.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已将本章中的所有概念应用到你的项目结构中，你可以运行`python3 -m yourproject`来启动你的程序。
- en: However, you (or your eventual end user) may want to run the program merely
    by double-clicking or directly executing some single Python file. With everything
    else in place, this is trivial to implement.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你（或者最终的用户）可能希望通过双击或者直接执行某个单一的Python文件来运行程序。只要其他一切准备就绪，这是很容易实现的。
- en: 'To make my *omission* project easy to run, I created a single script file *outside
    the top-level package*, named *omission.py*:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我的*omission*项目容易运行，我创建了一个位于*顶级包外部*的单个脚本文件，命名为*omission.py*：
- en: '[PRE35]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Listing 4-25: *omission.py*'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 4-25: *omission.py*'
- en: I import the `main()` function from *omission/__main__.py* and then execute
    that function. This is effectively the same as executing that package directly
    with `python3 -m omission`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我从*omission/__main__.py*导入了`main()`函数，然后执行该函数。这实际上与直接使用`python3 -m omission`执行该包是一样的。
- en: There are better ways to create a program entry point, but I’ll cover those
    in Chapter 18, once I’ve created the all-important *setup.cfg* file. Again, what
    you have so far will be enough for development.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 有更好的方法来创建程序入口点，但我会在第18章中介绍这些方法，一旦我创建了至关重要的*setup.cfg*文件。再说一次，到目前为止，你所拥有的足以用于开发。
- en: The Python Module Search Path
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python模块搜索路径
- en: The *module search path*, or *import path*, defines where Python looks for packages
    and modules and what order it searches in. When you first start the Python interpreter,
    the module search path is assembled in order, from the directory of the module
    being executed, the system variable `PYTHONPATH`, and the default path for the
    Python instance being used.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '*模块搜索路径*，或称*导入路径*，定义了Python查找包和模块的路径以及查找的顺序。当你第一次启动Python解释器时，模块搜索路径会按顺序组装，从正在执行的模块所在目录、系统变量`PYTHONPATH`，以及正在使用的Python实例的默认路径。'
- en: 'You can view the resulting module search path with the following commands:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下命令查看生成的模块搜索路径：
- en: '[PRE36]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Running that code within the context of a virtual environment (in my case,
    */home/jason/.venvs/venv310*) on my system gives me the following output:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的系统中，在虚拟环境（在我的例子中是*/home/jason/.venvs/venv310*）中运行该代码会给我以下输出：
- en: '[PRE37]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The import system looks through each of the locations in the module search path
    *in order*. As soon as it finds a match for the module or package being imported,
    it stops. You can see here that it searches the directory containing the module
    or script I’m running ❶, the standard libraries ❷ ❸ ❹, and then everything installed
    with pip in the virtual environment ❺.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 导入系统会*按顺序*查看模块搜索路径中的每一个位置。一旦找到与正在导入的模块或包匹配的项，它就会停止。你可以看到，它首先搜索包含我正在运行的模块或脚本的目录❶，然后是标准库❷
    ❸ ❹，最后是虚拟环境中通过pip安装的所有内容❺。
- en: If you need to add locations to the module search path, the best way is to use
    a virtual environment and add a file ending in *.pth* to the *lib/python3.x/site-packages*
    directory. The name of the file doesn’t matter, as long as the file extension
    is *.pth*.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要将位置添加到模块搜索路径，最好的方法是使用虚拟环境，并将一个以*.pth*结尾的文件添加到*lib/python3.x/site-packages*目录中。文件的名称并不重要，只要文件扩展名是*.pth*。
- en: 'For example, consider the following:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下情况：
- en: '[PRE38]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Listing 4-26: *venv/lib/python3.10/site-packages/stuff.pth*'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4-26：*venv/lib/python3.10/site-packages/stuff.pth*
- en: Each line must contain exactly one path to be appended. The absolute path */home/jason/bunch_of_code*
    will be appended to the module search path. The relative path *../../../awesomesauce*
    is relative to the .*pth* file, so it will point to *venv/awesomesauce*.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 每行必须包含一个将要附加的路径。绝对路径*/home/jason/bunch_of_code*将被附加到模块搜索路径中。相对路径*../../../awesomesauce*相对于.*pth*文件，因此它将指向*venv/awesomesauce*。
- en: Because these are appended to the module search path, this technique cannot
    be used to replace any packages or modules installed on the system or virtual
    environment. However, any new modules or packages in my *bunch_of_code/* or *awesomesauce/*
    directories will be available for import within the virtual environment.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这些是附加到模块搜索路径中的，所以这种方法不能用于替换系统或虚拟环境中安装的任何包或模块。然而，我的*bunch_of_code/*或*awesomesauce/*目录中的任何新模块或包将在虚拟环境中可供导入。
- en: What Really Happens
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发生了什么
- en: Let’s look at what really happens under the hood when you import a module. Most
    of the time, those details won’t matter, but every now and then (such as when
    the wrong module seems to be imported instead of the one you expect), the technical
    details leak to the surface. It never hurts to know what’s going on.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下，当你导入一个模块时，幕后究竟发生了什么。大多数情况下，这些细节并不重要，但偶尔（比如导入了错误的模块而不是你预期的那个）这些技术细节会浮出水面。了解发生了什么是没有坏处的。
- en: The `import` statement calls the built-in`__import__()` function.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`import`语句调用内建的`__import__()`函数。'
- en: 'To import a module, Python uses two special objects: a *finder* and a *loader*.
    In some cases, it uses an *importer* object, which serves as both a finder and
    a loader.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 为了导入一个模块，Python使用两个特殊对象：*查找器*和*加载器*。在某些情况下，它使用*导入器*对象，它既充当查找器又充当加载器。
- en: The *finder* is responsible for locating the module being imported. There are
    many places to look for modules—they aren’t even necessarily files—and a number
    of special situations exist that must be handled. Python has several types of
    finders to handle these different situations, and it gives each one an opportunity
    to locate a module with a given name.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '*查找器*负责定位正在导入的模块。有很多地方可以查找模块——它们甚至不一定是文件——并且存在一些特殊情况需要处理。Python有多种类型的查找器来处理这些不同的情况，并且为每个查找器提供机会来定位具有给定名称的模块。'
- en: 'First, Python uses *meta path finders*, which are stored in the `sys.meta_path`
    list. By default, there are three meta path finders:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，Python使用*元路径查找器*，这些查找器存储在`sys.meta_path`列表中。默认情况下，有三个元路径查找器：
- en: The *built-in importer* finds and loads built-in modules.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*内建导入器*查找并加载内建模块。'
- en: The *frozen importer* finds and loads *frozen* modules, meaning modules that
    have been converted to compiled bytecode (see Chapter 1).
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*冻结导入器*查找并加载*冻结*模块，也就是已经被转换为编译后的字节码的模块（参见第1章）。'
- en: The *path-based finder* looks in the filesystem for the module.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*基于路径的查找器*会在文件系统中查找该模块。'
- en: This search order is the reason why you cannot globally shadow a built-in module;
    the built-in importer runs before the path-based finder. If you need some additional
    meta path finder, such as if you were importing a module from a novel location
    not already supported, you can add it as a *meta hook* by appending it to the
    `sys.meta_path` list.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这个搜索顺序就是为什么你不能全局覆盖内建模块的原因；内建导入器会在路径查找器之前运行。如果你需要一些额外的元路径查找器，例如如果你要从一个尚未支持的新位置导入模块，可以通过将其添加到`sys.meta_path`列表中作为*元钩子*来实现。
- en: There’s some additional complexity to the path-based finder that is worth breaking
    down. The path-based finder tries each of the *path entry finders* in turn. These
    path entry finders, also known as *path entry hooks*, are stored in `sys.path_hooks`.
    Each one searches every location (known as a *path* entry) listed on the import
    path, as specified by `sys.path` or the `__path__` attribute of the current package.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 路径查找器有一些额外的复杂性，值得进一步分解。路径查找器会依次尝试每个*路径条目查找器*。这些路径条目查找器，也称为*路径条目钩子*，存储在`sys.path_hooks`中。每个查找器都会搜索在导入路径中列出的每个位置（称为*路径*条目），这些路径由`sys.path`或当前包的`__path__`属性指定。
- en: If any of the finders locates the module, it returns a *module spec* object
    with all the information about how to load the module. However, if all the meta
    path finders return `None`, you’ll get a `ModuleNotFoundError`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何一个查找器定位到模块，它会返回一个*模块规范*对象，包含关于如何加载该模块的所有信息。然而，如果所有元路径查找器都返回`None`，则会抛出`ModuleNotFoundError`。
- en: Once the module is found, the module spec goes to the *loader*, which is responsible
    for actually loading the module.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦找到模块，模块规范就会传递给*加载器*，它负责实际加载该模块。
- en: There’s a lot of technical detail regarding loading that’s beyond the scope
    of this book, but one thing worth noting is how the loader deals with *cached
    bytecode*. Ordinarily, once a Python module has been run, a *.pyc* file is generated.
    The file contains the bytecode, which from then on is *cached*. You’ll often see
    these *.pyc* files hanging out in your project directories. The loader always
    needs to be sure that the cached bytecode is not out of date before loading it,
    by using one of two strategies. The first strategy is for the bytecode to also
    store the timestamp from the last time the source code file was modified. When
    loading the module, the timestamp of the source code is checked against this cached
    timestamp. If it doesn’t match, the bytecode is out of date, and the source will
    be recompiled. The second strategy, introduced in Python 3.7, instead stores a
    *hash*, which is a short and (relatively) unique value algorithmically generated
    from the source code itself. If the source code changes, the hash will be different
    from the one stored in the cached bytecode. Python bytecode files that contain
    this hash are appropriately called *hash-based .pyc* files.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 关于加载的技术细节有很多，这超出了本书的范围，但值得注意的一点是加载器如何处理*缓存字节码*。通常情况下，一旦Python模块被执行，就会生成一个*.pyc*文件。该文件包含字节码，从此之后它会被*缓存*。你通常会在项目目录中看到这些*.pyc*文件。加载器在加载字节码之前总是需要确保缓存的字节码没有过时，可以通过两种策略之一来实现。第一种策略是字节码也会存储源代码文件最后修改的时间戳。在加载模块时，会检查源代码的时间戳与此缓存的时间戳是否匹配。如果不匹配，则字节码过时，源代码将被重新编译。第二种策略是在Python
    3.7中引入的，它会存储一个*哈希*，这是通过源代码本身算法生成的一个简短且（相对）唯一的值。如果源代码发生变化，哈希值将与缓存字节码中存储的哈希值不同。包含此哈希的Python字节码文件被称为*基于哈希的
    .pyc*文件。
- en: Regardless of how the loader is loading the module, it will add the module object
    to `sys.modules`—adding it, in fact, just before actually loading, to prevent
    an import loop if the module being loaded imports itself. Finally, the loader
    will bind the imported module object to a name in the module importing it, so
    the imported module can be referenced. (I’ll cover name binding in Chapter 5.)
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 无论加载器如何加载模块，它都会将模块对象添加到`sys.modules`中——实际上是在实际加载之前就添加它，以防止在加载的模块导入自身时出现导入循环。最后，加载器会将导入的模块对象绑定到导入该模块的名称上，这样就可以引用已导入的模块。（我将在第5章介绍名称绑定）
- en: Once the module has been imported, it’s cached in `sys.path_importer_cache`,
    along with the importer object used to import it. This is actually the first place
    the import system will check for an imported module, even before running through
    the finders, so importing a module multiple times in a project will still only
    go through the finding-and-loading process once.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦模块被导入，它会被缓存到`sys.path_importer_cache`中，以及用于导入该模块的导入器对象。实际上，这是导入系统检查已导入模块的第一个地方，甚至在运行查找器之前，所以在一个项目中多次导入模块，仍然只会经历一次查找和加载过程。
- en: This is a very broad overview of the import system, but most of the time, it’s
    all you’ll need to know. To learn all the intricate details, you can read the
    official documentation at [https://docs.python.org/3/reference/import.xhtml](https://docs.python.org/3/reference/import.xhtml).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对导入系统的一个非常宽泛的概述，但大多数时候，这就是你需要知道的所有内容。如果你想了解所有的细节，可以阅读官方文档：[https://docs.python.org/3/reference/import.xhtml](https://docs.python.org/3/reference/import.xhtml)。
- en: Wrapping Up
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: The Python import system is often overlooked when learning the language, leading
    to many headaches for new users. By understanding how to use and import modules
    and packages, you will greatly reduce the roadblocks between you and a viable
    project. A little effort now will save you countless hours of confusion and trouble
    later!
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: Python 导入系统在学习语言时常常被忽视，导致新用户常常头痛。通过了解如何使用和导入模块与包，你将大大减少你与可行项目之间的障碍。现在稍微投入一点努力，将来可以节省你无数小时的困惑与麻烦！
