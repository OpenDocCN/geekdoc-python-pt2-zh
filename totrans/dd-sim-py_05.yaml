- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Project Structure and Imports
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 项目结构与导入
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: I’ve found that structuring a Python project is one of the most often overlooked
    components of teaching the language. Many developers therefore get their project
    structure wrong, stumbling through a jumble of common mistakes until they arrive
    at something that at least works.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现结构化一个 Python 项目是教学过程中最常被忽视的部分之一。因此，许多开发者在项目结构上犯错，走过一系列常见错误，直到最终找到一个至少能工作的结构。
- en: 'Here’s the good news: you don’t have to be one of them!'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这是好消息：你不必成为其中之一！
- en: In this chapter, I’ll introduce import statements, modules, and packages, and
    I’ll show you how to fit everything together without tearing your hair out.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将介绍导入语句、模块和包，并向你展示如何把一切都拼凑在一起，而不至于抓狂。
- en: 'Be aware, I’m skipping over one critical piece of project structure in this
    chapter: *setup.cfg*, as it relies on concepts we haven’t yet covered. Without
    a *setup.cfg* or *setup.py* file, your project will not be ready to ship to end
    users. In this chapter, you’ll put everything in the right place for development.
    From there, preparing your project for distribution will be a fairly simple process.
    I’ll cover *setup.cfg*, *setup.py*, and other project structure issues relating
    to distribution in Chapter 18.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在本章中，我跳过了项目结构中的一个关键部分：*setup.cfg*，因为它依赖于我们尚未介绍的概念。没有 *setup.cfg* 或 *setup.py*
    文件，你的项目将无法准备好发布给最终用户。在本章中，你将把一切都放在开发的正确位置。从这里开始，为分发准备你的项目将是一个相对简单的过程。我将在第18章中介绍
    *setup.cfg*、*setup.py* 以及与分发相关的其他项目结构问题。
- en: Setting Up the Repository
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置版本库
- en: Before delving into the actual project structure, I want to address how it will
    fit into your *version control system (VCS)*, which I recommend using. For the
    rest of this book, I’ll assume you’re using Git, as that’s the most common option.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入讨论实际项目结构之前，我想先讲一下它如何融入到你的 *版本控制系统（VCS）* 中，我建议你使用版本控制系统。在本书的剩余部分，我将假设你使用 Git，因为它是最常见的选择。
- en: 'Once you’ve created your repository and cloned a local copy to your computer,
    you can begin to set up your project. At minimum, create the following files:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了版本库并将本地副本克隆到你的计算机上，你就可以开始设置你的项目了。至少，创建以下文件：
- en: '*README*, which is a description of your project and its goals'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*README*，它是对你项目及其目标的描述'
- en: '*LICENSE*, which is your project’s license'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*LICENSE*，这是你项目的许可证'
- en: '*.gitignore*, which is a special file that tells Git what files and directories
    to ignore'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*.gitignore*，它是一个特殊文件，告诉 Git 哪些文件和目录需要被忽略'
- en: A directory, which has the name of your project
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个目录，它的名称就是你的项目名称
- en: Your Python code belongs in a separate subdirectory and not in the root of the
    repository. This is very important, as your repository’s root directory will get
    mighty cluttered with build files, packaging scripts, documentation, virtual environments,
    and all manner of other things that aren’t actually part of the source code.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 Python 代码应该放在一个单独的子目录中，而不是放在版本库的根目录中。这非常重要，因为你的版本库根目录将会被构建文件、打包脚本、文档、虚拟环境以及其他许多与源代码无关的东西搞得杂乱无章。
- en: 'As an example, in this chapter, I’ll use one of my own Python projects: *omission*.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例，在本章中，我将使用我自己的一个 Python 项目：*omission*。
- en: A Python project is composed of modules and packages. In the next section, I’ll
    cover what those are and how to create them.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 Python 项目由模块和包组成。在接下来的部分，我将讲解这些是什么以及如何创建它们。
- en: Modules and Packages
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块与包
- en: A *module* is any Python (*.py*) file. (Anticlimactic, isn’t it?)
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*模块* 是任何 Python (*.py*) 文件。（有点反高潮，不是吗？）'
- en: A *package*, occasionally called a *regular package*, is one or more modules
    within a directory. That directory must include a file called *__init__.py* (which
    can be empty). The *__init__.py* file is important! If it isn’t there, Python
    will not know the directory constitutes a package.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*包*，有时称为 *常规包*，是一个目录中的一个或多个模块。该目录必须包含一个名为 *__init__.py* 的文件（该文件可以为空）。*__init__.py*
    文件很重要！如果它不存在，Python 就不会知道这个目录是一个包。'
- en: You can leave the *__init__.py* file empty (it often is), or you can use it
    to run certain code when the package is first imported. For example, you might
    use `__init__.py` to select and rename certain functions, so the end user of the
    package doesn’t need to understand how the modules are laid out. (See the subsection
    “Controlling Package Imports” later in the chapter.)
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 *__init__.py* 文件留空（它通常是空的），或者你可以在首次导入包时利用它运行某些代码。例如，你可以使用`__init__.py`选择并重命名某些函数，这样包的最终用户就不需要理解模块的布局。（请参阅本章稍后的“控制包导入”小节。）
- en: If you do forget *__init__.py* in your package, it becomes an *implicit namespace
    package*, also just known as a *namespace package*. These behave differently from
    regular packages. ***The two are not interchangeable!*** A namespace package allows
    you to distribute a package in multiple pieces, called *portions*. There are some
    cool advanced things you can do with namespace packages, but you will seldom need
    them. As this is a doozy of a rabbit hole, if you need namespace packages, see
    the documentation at [https://packaging.python.org/guides/packaging-namespace-packages/](https://packaging.python.org/guides/packaging-namespace-packages/).
    You can also read PEP 420, which officially defined the concept.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在包中忘记了 *__init__.py*，它就变成了*隐式命名空间包*，也称为*命名空间包*。它们与常规包的行为有所不同。***两者不可互换！***
    命名空间包允许你将一个包分成多个部分进行分发，称为*部分*。你可以用命名空间包做一些很酷的高级事情，但你很少会需要它们。由于这是一个相当复杂的技术，如果你需要命名空间包，请参阅[https://packaging.python.org/guides/packaging-namespace-packages/](https://packaging.python.org/guides/packaging-namespace-packages/)中的文档。你也可以阅读PEP
    420，它正式定义了这一概念。
- en: In my project structure, *omission* is a package that contains other packages.
    Thus, *omission* is my *top-level package*, and all the packages underneath it
    are its *subpackages*. This convention will be important once you start importing
    stuff.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的项目结构中，*omission*是一个包含其他包的包。因此，*omission*是我的*顶级包*，而它下面的所有包都是它的*子包*。这个约定在你开始导入内容时将变得非常重要。
- en: PEP 8 and Naming
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PEP 8 和 命名
- en: 'Your packages and modules need clear names to identify them. Consulting with
    PEP 8 about the naming conventions reveals this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你的包和模块需要清晰的名称来标识它们。参考PEP 8关于命名约定的内容可以得出以下结论：
- en: Modules should have short, all-lowercase names. Underscores can be used in the
    module name if it improves readability. Python packages should also have short,
    all-lowercase names, although the use of underscores is discouraged.
  id: totrans-25
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 模块应该有简短的小写名称。如果下划线有助于提高可读性，可以在模块名中使用下划线。Python 包也应有简短的小写名称，尽管不建议使用下划线。
- en: Understand that modules are named by filenames and packages are named by their
    directory name. Thus, these conventions define how you name your directories and
    code files.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 理解模块是通过文件名命名的，包是通过其目录名命名的。因此，这些约定定义了你如何命名目录和代码文件。
- en: To reiterate, filenames should be all lowercase, with underscores (`_`) if that
    improves readability. Similarly, directory names should be all lowercase, without
    underscores if at all possible. To put that another way . . .
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 重申一下，文件名应该全部小写，如果有助于提高可读性，可以使用下划线（`_`）。类似地，目录名应全部小写，尽量避免使用下划线。换句话说……
- en: 'Do this: *omission/data/data_loader.py*'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这样做：*omission/data/data_loader.py*
- en: 'NOT this: *omission/Data/DataLoader.py*'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不是这样：*omission/Data/DataLoader.py*
- en: Project Directory Structure
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 项目目录结构
- en: 'With that covered, take a look at my project’s repository directory structure:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 既然这些已经解释过了，来看一下我项目的仓库目录结构：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 4-1: Directory structure of *omission-git/*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4-1：*omission-git*的目录结构
- en: 'You’ll see that I have one top-level package called *omission*, with four subpackages:
    *common/*, *data/*, *game/*, and *tests/*. Each subpackage contains an *__init__.py*
    file, which is what designates them as packages. Every file that ends in *.py*
    is a module.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到，我有一个名为*omission*的顶级包，其中包含四个子包：*common/*、*data/*、*game/* 和 *tests/*。每个子包都包含一个
    *__init__.py* 文件，正是这个文件将它们标记为包。每个以*.py*结尾的文件都是一个模块。
- en: I also have the directory *resources/*, but that only contains game audio, images,
    and other sundry files (omitted here for brevity). The *resources/* directory
    is *not* a regular package, as it doesn’t contain an *__init__.py*.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我还拥有一个名为*resources/*的目录，但它只包含游戏音频、图像和其他杂项文件（为了简洁起见，这里省略）。*resources/*目录*不是*一个常规包，因为它不包含
    *__init__.py* 文件。
- en: 'I have another special file in my top-level package: *__main__.py*. This is
    the file that runs when I execute my top-level package directly, via this command:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我的顶级包中还有一个特殊文件：*__main__.py*。这是当我直接通过以下命令执行我的顶级包时运行的文件：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: I’ll come back to *__main__.py* in a bit (see the subsection “Package Entry
    Points” later in the chapter), as well as explain that lonely little *omission.py*
    file outside the top-level package.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: How import Works
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you’ve written any meaningful Python code before, you’re almost certainly
    familiar with the `import` statement for importing modules. For example, to use
    it to import the module for regex, you’d enter this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Once you’ve imported a module, you can access any variables, functions, or classes
    defined within it.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: When you import the module, you are actually running it, which in turn executes
    any other `import` statements in the module. If there are any errors or performance
    costs in those secondarily (and onward) imported modules, they might seem to originate
    from your otherwise innocent import statement. It also means that Python has to
    be able to find all those modules.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the module *re.py*, which is part of the Python standard library,
    has several import statements of its own, which are executed when you `import
    re`. The contents of those imported modules aren’t automatically available to
    the file you imported `re` from, but those module files have to exist for `import
    re` to succeed. If, for some unlikely reason, *enum.py* (another module that is
    part of the Python standard library) got deleted from your Python environment
    and you ran `import re`, it would fail with an error:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This might seem like a confusing error message. I’ve seen people erroneously
    wonder why the outer module (in this example, `re`) couldn’t be found. Others
    have wondered why the inner module (`enum` here) is being imported at all, since
    they didn’t ask for it directly in their code.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: The problem is that the `re` module was imported, and that in turn imported
    the `enum` module. However, because the `enum` module is missing, importing `re`
    fails with a `ModuleNotFoundError`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'Take note that this scenario is fictional: `import enum` and `import re` will
    never fail under normal circumstances, because both modules are part of Python’s
    standard library. However, this little example demonstrates the common problem
    of `import` statements failing due to missing modules.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Import Dos and Don’ts
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are various ways of importing, but most of them should rarely, if ever,
    be used.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'For the upcoming examples, I’ll be using a module called *smart_door.py*, which
    reads as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 4-2: *smart_door.py*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say I want to use this module in another Python file, which (in this
    example) is in the same directory. To run the functions defined in that module,
    I’d have to first import the module `smart_door`. The easiest way to do this is
    as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 4-3: *use_smart_door.py:1a*'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: The *namespace* of `open()` and `close()` is `smart_door`. A *namespace* is
    an explicitly defined path to something, such as a function. The function `open()`
    has the namespace `smart_door`, which tells me that `open()` belongs to that particular
    module. Remember this from The Zen of Python?
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces are one honking great idea—let’s do more of those!
  id: totrans-58
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 命名空间是个绝妙的主意——让我们多做一些这样的事情吧！
- en: Python developers really like namespaces because they make it obvious where
    functions and whatnot are coming from. That comes in handy when you have multiple
    functions that have similar names or the same name, but that are defined in different
    modules. Without that bit of namespace, `smart_door`, you would not know that
    `open()` had anything to do with opening the smart door. Appropriately using namespaces
    can help you avoid massive errors in your code. However, as important as namespaces
    are, they can get out of hand very quickly if used improperly.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Python 开发者非常喜欢命名空间，因为它们使得函数的来源一目了然。当你有多个函数，它们的名字相似或者相同，但定义在不同的模块中时，这非常有用。如果没有那个命名空间`smart_door`，你就不会知道`open()`与开启智能门有什么关系。恰当地使用命名空间可以帮助你避免代码中的严重错误。然而，命名空间虽然很重要，但如果使用不当，它们会迅速变得难以管理。
- en: Be advised, in referring to *namespaces*, I’m not necessarily talking about
    *implicit namespace packages*, which I don’t cover in this book.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，提到*命名空间*时，我不一定是在谈论*隐式命名空间包*，这是本书中没有涉及的内容。
- en: Here’s a look at some good and bad examples of namespaces in action.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些命名空间应用的好例子和坏例子。
- en: Importing Functions from Modules
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从模块导入函数
- en: In my previous `smart_door` function calls, I referenced the namespace on every
    function call. This is usually best when a function is called only a handful of
    times, but if you use a function often, it gets tedious to use a namespace for
    every single function call.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在我之前的`smart_door`函数调用中，我在每次函数调用时都引用了命名空间。当一个函数只被调用少数几次时，这通常是最好的做法，但如果你经常使用某个函数，那么每次调用都使用命名空间会显得非常繁琐。
- en: 'Thankfully, Python provides a way around that. To be able to use the `open()`
    function without constantly having to precede it with its module name (`smart_door`),
    I need only know the *qualified name*—that is, the name of the function, class,
    or variable, preceded by its complete namespace within one of its modules or packages
    (if any). Within the *smart_door.py* module, the qualified name of the function
    I want is just `open`. Thus, I import that function like this, instead:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Python 提供了一种解决方法。为了能够使用 `open()` 函数，而不需要每次都在前面加上它的模块名（`smart_door`），我只需要知道*完全限定名*——也就是说，函数、类或变量的名称，前面加上它在其模块或包中的完整命名空间（如果有的话）。在*smart_door.py*模块中，我需要的函数的完全限定名就是`open`。因此，我改为这样导入该函数：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 4-4: *use_smart_door.py:1b*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-4：*use_smart_door.py:1b*
- en: 'This introduces a new problem. Neither `close()` nor `smart_door.close()` will
    work in this example, because I didn’t import the function outright. The entire
    `smart_door` module was still run by the import command, but only the `open()`
    function was actually imported. To use `smart_door.close()`, I’d need to change
    the code to this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这带来了一个新问题。在这个例子中，`close()`和`smart_door.close()`都无法工作，因为我没有直接导入这个函数。整个`smart_door`模块确实被导入了，但只有`open()`函数被实际导入。为了使用`smart_door.close()`，我需要将代码更改为：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 4-5: *use_smart_door.py:1c*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-5：*use_smart_door.py:1c*
- en: This gives me access to both functions, no namespace required.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我可以访问两个函数，无需命名空间。
- en: The Problem of Shadowing
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 覆盖问题
- en: 'You might have noticed another problem: `open()` is already a built-in Python
    function! Assume I also need to read a file called *data.txt*, which exists in
    my current directory. If I try this after importing `open()` from the `smart_door`
    function ([Listing 4-5](#listing4-5)), my program is going to behave very badly:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到另一个问题：`open()`已经是一个内建的 Python 函数了！假设我还需要读取一个名为*data.txt*的文件，该文件存在于当前目录中。如果在从`smart_door`函数导入`open()`之后，我尝试这么做，我的程序将会表现得非常糟糕：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 4-6: *use_smart_door.py:2*'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-6：*use_smart_door.py:2*
- en: When I used `open()` earlier ([Listing 4-5](#listing4-5)), I wanted to use `smart_door.open()`.
    Now, in the same file, I’m trying to call Python’s built-in `open()` function
    to open a text file for reading. Unfortunately, because of the earlier import,
    the built-in `open()` function has been *shadowed* by `smart_door.open()`, meaning
    the presence of the latter is making it impossible for Python to even find the
    former. This code will fail!
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当我之前使用`open()`时（[列表 4-5](#listing4-5)），我本来想用`smart_door.open()`。现在，在同一个文件中，我尝试调用
    Python 内建的 `open()` 函数来打开一个文本文件进行读取。不幸的是，由于之前的导入，内建的 `open()` 函数已经被`smart_door.open()`*覆盖*，这意味着后者的存在使得
    Python 无法找到前者。这个代码会失败！
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: I got that error because I’m trying to use the built-in `open()` function, which
    accepts two arguments, but I unintentionally called `smart_door.open()`, which
    doesn’t accept any arguments.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我得到那个错误是因为我尝试使用内置的`open()`函数，它接受两个参数，但我无意中调用了`smart_door.open()`，它不接受任何参数。
- en: Getting an actual error message is one of the better failure scenarios for this
    sort of mistake. Imagine if `smart_door.open()` did accept similar arguments to
    the built-in `open()`. Depending on my code, I might wind up with an error elsewhere
    (perhaps from trying to use a file I hadn’t opened), or worse, some form of incorrect
    but technically valid behavior. This sort of mistake is infamously difficult to
    debug, so it is wise to avoid.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 获取实际的错误信息是这种错误的较好失败情境之一。想象一下，如果`smart_door.open()`接受与内置`open()`相似的参数，按照我的代码，我可能会在其他地方遇到错误（也许是因为我试图使用一个没有打开的文件），或者更糟糕的是，出现某种形式的错误，但它在技术上是有效的行为。这种错误通常非常难以调试，因此最好避免。
- en: 'So how should I fix this? If I were the one who wrote *smart_door.py*, I should
    just go and change the function name. It’s universally considered bad practice
    to use function names that shadow built-in Python functions anyhow, unless the
    entire point *is* to shadow. However, assume that I’m not the author of that module
    and I need another solution. Thankfully, Python offers one in the `as` keyword,
    which allows me to create an alias for that function:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 那我该如何解决这个问题呢？如果我是*smart_door.py*的作者，我应该直接去修改函数名。使用会覆盖内置Python函数的函数名普遍被认为是不好的做法，除非整个目的是为了覆盖。不过，假设我不是该模块的作者，需要找到另一个解决方案。幸运的是，Python提供了`as`关键字，可以让我为该函数创建别名：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 4-7: *use_smart_door.py:1d*'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 4-7: *use_smart_door.py:1d*'
- en: In the import, I use the `as` keyword to rename `smart_door.open()` to `door_open()`,
    but only in the context of this file. Then, I can refer to `door_open()` where
    I wanted `smart_door.open()`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入中，我使用`as`关键字将`smart_door.open()`重命名为`door_open()`，但仅限于此文件的上下文中。然后，我可以在需要`smart_door.open()`的地方引用`door_open()`。
- en: This leaves Python’s built-in `open()` function unshadowed, so the earlier code
    for working with the file ([Listing 4-6](#listing4-6)) can function properly.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得Python的内置`open()`函数不再被覆盖，因此之前处理文件的代码（[列表 4-6](#listing4-6)）可以正常工作。
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The Trouble with Nested Packages
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 嵌套包的问题
- en: 'As you’ve seen, packages can contain other packages. In my *omission* project,
    if I wanted to import the module *data_loader.py*, I could use this line (refer
    back to the *omission* project structure):'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，包可以包含其他包。在我的*省略*项目中，如果我想导入模块*data_loader.py*，我可以使用这一行（参见*省略*项目结构）：
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The Python interpreter looks for the *omission* package, the *data* package
    inside that, and the *data_loader* module inside that. The *data_loader* module
    (and only that module) is imported. This is a good structure, and all’s well.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Python解释器会查找*省略*包、包中的*data*包，以及其中的*data_loader*模块。只有*data_loader*模块被导入。这是一个不错的结构，一切都很好。
- en: 'At a certain point, however, nesting packages can become a pain. A function
    call like `musicapp.player.data.library.song.play()` is just ugly, not to mention,
    difficult to read. As The Zen of Python muses:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，嵌套包会变得麻烦。像`musicapp.player.data.library.song.play()`这样的函数调用看起来很难看，更不用说很难阅读了。正如《Python禅》所说：
- en: Flat is better than nested.
  id: totrans-90
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 扁平化比嵌套更好。
- en: Some nesting of packages is certainly okay, but when your project starts looking
    like an elaborate set of Matryoshka dolls, you’ve done something wrong. Organize
    your modules into packages, but keep the structure reasonably simple. Nesting
    two or three packages deep is okay; deeper is generally not advisable, if it can
    be avoided.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一定程度的包嵌套是可以的，但当你的项目开始看起来像一套精致的套娃时，你就做错了什么。组织你的模块成包，但要保持结构简洁。如果能避免，通常不建议嵌套超过两到三个包。
- en: 'Although we’d never have overly nested nightmares in an ideal world, real-life
    projects aren’t always that neat. Sometimes, it isn’t possible to avoid deep nesting
    structures. I need another way to keep my import statements sane. Graciously,
    the import system can handle this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在理想的世界里，我们永远不会有过度嵌套的噩梦，但现实中的项目并不总是那么整洁。有时候，避免深层嵌套结构是不可行的。我需要另一种方式来保持我的导入语句整洁。幸运的是，导入系统能够处理这种情况：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: I only have to deal with the deeply nested namespace once, in the actual import
    statement. After that, I just use the function name, `play()`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我只需要在实际的导入语句中处理一次深度嵌套的命名空间。之后，我只需使用函数名`play()`。
- en: 'Alternatively, if I want a little bit of namespace, I can have that, too:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果我需要一点命名空间，我也可以实现：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: My import statement has resolved all but that last bit of namespace, `song`,
    so I still know where the `play()` function is coming from.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我的导入语句已经解决了除了最后那个命名空间`song`之外的所有问题，所以我仍然知道`play()`函数来自哪里。
- en: The import system is deliciously flexible like that.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 导入系统就是如此灵活。
- en: Beware of Importing All
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小心导入所有内容
- en: 'Before long, you’ll probably find yourself tempted to import all of the hundreds
    of functions in your module, to save time. This is the point at which many developers
    go off the rails:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 不久后，你可能会发现自己想要导入模块中所有数百个函数，以节省时间。这时，许多开发者可能会走偏：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This statement imports nearly everything in the module directly, except for
    anything preceded by one or more underscores. This import-all pattern is a Very
    Bad Idea, as you won’t know what all is getting imported or what will be shadowed
    in the process.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语句几乎直接导入了模块中的所有内容，除了任何前面带有一个或多个下划线的内容。这种导入所有内容的方式非常糟糕，因为你根本不知道到底导入了什么，或者在过程中什么被覆盖了。
- en: 'The problem gets even worse when you start importing all from multiple modules:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始从多个模块导入所有内容时，问题变得更糟：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Doing this, you may be blissfully unaware that `open()`, `smart_door.open()`,
    and `gzip.open()` all exist and are fighting over the same name in your file!
    The function `gzip.open()` will win out in this example, because it’s the last
    version of `open()` that was imported. The other two functions have been shadowed,
    which means you effectively can’t call them at all.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做时，你可能会无忧无虑地不知道`open()`、`smart_door.open()`和`gzip.open()`都存在，并且在文件中争夺同一个名字！在这个例子中，`gzip.open()`会胜出，因为它是最后导入的`open()`版本。其他两个函数被覆盖了，实际上你根本无法调用它们。
- en: Since no one is likely to remember every single function, class, and variable
    in every module that gets imported, one can easily wind up with a whole lot of
    messes.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有人可能记住每个模块中每个导入的函数、类和变量，所以很容易就会弄得一团糟。
- en: 'The Zen of Python applies to this situation:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Python的禅意适用于这种情况：
- en: Explicit is better than implicit.
  id: totrans-108
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 明确优于隐式。
- en: ''
  id: totrans-109
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: (. . .)
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: (. . .)
- en: ''
  id: totrans-111
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the face of ambiguity, refuse the temptation to guess.
  id: totrans-112
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 面对模糊性时，拒绝猜测的诱惑。
- en: You should never have to guess where a function or variable is coming from.
    There should be code somewhere in the file that explicitly tells you where everything
    comes from, as seen in the preceding examples.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你永远不应该猜测一个函数或变量的来源。文件中应该有某处明确的代码告诉你每个内容的来源，正如前面的示例所示。
- en: This `import *` doesn’t quite work the same way with packages. By default, a
    line like `from some_package import *` will be functionally the same as `import
    some_package`, unless the package has been configured to work with `import *`.
    I’ll come back to this later.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`import *`在包中的工作方式不完全一样。默认情况下，像`from some_package import *`这样的语句在功能上与`import
    some_package`相同，除非该包已配置为支持`import *`。稍后我会再谈这个问题。
- en: Importing Within Your Project
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在项目中导入
- en: Now that you know how to structure your project and import from packages and
    modules, I’ll tie everything together.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何构建项目并从包和模块中导入内容，我将把一切联系起来。
- en: 'Recall my *omission* project structure from [Listing 4-1](#listing4-1). Here’s
    a subsection of that project directory:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下我的*omission*项目结构，见[列表4-1](#listing4-1)。这是该项目目录的一个子部分：
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 4-8: Directory structure of *omission-git/*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4-8：*omission-git*的目录结构
- en: Any one module in my project may need to be able to import from another module,
    whether it’s within the same package or somewhere else in the project structure.
    I’ll explain how to handle both scenarios.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 项目中的任何模块可能都需要从另一个模块导入内容，无论它是同一个包内的，还是项目结构中其他地方的。我将解释如何处理这两种情况。
- en: Absolute Imports
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绝对导入
- en: I have a class `GameMode` defined within the *game_enums.py* module, which lives
    in the *omission/common* package. I want to use that class within my *game_round_settings.py*
    module, defined in the *omission/data* package. How do I get to it?
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我在*game_enums.py*模块中定义了一个`GameMode`类，该模块位于*omission/common*包中。我想在*game_round_settings.py*模块中使用该类，这个模块位于*omission/data*包中。我该如何访问它？
- en: 'Because I defined *omission* as a top-level package and organized my modules
    into subpackages, it’s pretty straightforward. In *game_round_settings.py*, I’d
    write the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我将*omission*定义为顶级包，并将我的模块组织成子包，所以这非常简单。在*game_round_settings.py*中，我会写如下代码：
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 4-9: *game_round_settings.py:1a*'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4-9：*game_round_settings.py:1a*
- en: This line is an *absolute import*. It starts at the top-level package, *omission*,
    and walks down into the *common* package, where it looks for *game_enums.py*.
    Inside that module, it finds whatever has the name `GameMode` and imports that.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行是一个*绝对导入*。它从顶级包*omission*开始，然后进入*common*包，查找*game_enums.py*。在该模块中，它找到名为`GameMode`的内容并导入它。
- en: Relative Imports
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 相对导入
- en: 'You can also import from a module in the same package or subpackage. This is
    known as a *relative import* or an *intrapackage reference*. In practice, intra-package
    references are easy to do wrong. If some developer wanted to import `GameMode`
    (which is provided by *omission/common/game_enums.py*) into *omission/data/game_round_settings.py*,
    they might incorrectly attempt to use something like the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以从同一包或子包中的模块导入。这被称为*相对导入*或*包内引用*。在实践中，包内引用很容易出错。如果某个开发者想从*omission/common/game_enums.py*中导入`GameMode`到*omission/data/game_round_settings.py*中，他们可能会错误地尝试使用类似以下的代码：
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 4-10: *game_round_settings.py:1b*'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 4-10: *game_round_settings.py:1b*'
- en: This fails, leaving the developer wondering why it doesn’t work. The *data*
    package (where *game_round_settings.py* lives) has no knowledge of its sibling
    packages, such as *common*.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做会失败，开发者会疑惑为什么不起作用。*data*包（即*game_round_settings.py*所在的包）并不了解其兄弟包，比如*common*。
- en: A module knows what package it belongs to, and a package knows its parent package
    (if it has one). Because of this, relative imports can start the search from the
    current package and move up and down through the project structure.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一个模块知道它属于哪个包，而一个包知道它的父包（如果有的话）。因此，相对导入可以从当前包开始搜索，然后上下移动，遍历项目结构。
- en: 'Within *omission/data/game_round_settings.py*, I can use the following import
    statement:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在*omission/data/game_round_settings.py*中，我可以使用以下导入语句：
- en: '[PRE20]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 4-11: *game_round_settings.py:1c*'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 4-11: *game_round_settings.py:1c*'
- en: The two dots (`..`) mean “the current package’s direct parent package,” which,
    in this case, is *omission*. The import steps up one level, walks down into *common*,
    and finds *game_enums.py*.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 两个点（`..`）表示“当前包的直接父包”，在这个例子中就是*omission*。导入会向上一层，进入*common*，然后找到*game_enums.py*。
- en: There’s some difference of opinion among Python developers about whether to
    use absolute or relative imports. Personally, I prefer to use absolute imports
    whenever possible, because I feel it makes the code a lot more readable. You can
    make up your own mind. The only important factor is that the result should be
    *obvious*—there should be no mystery about where anything comes from.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 关于是否使用绝对导入或相对导入，Python 开发者之间有一些不同的看法。就个人而言，我更倾向于在可能的情况下使用绝对导入，因为我觉得这样可以使代码更加易读。你可以自行决定。唯一重要的因素是结果应该是*显而易见的*——任何东西的来源都不应该让人感到困惑。
- en: Importing from the Same Package
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从同一包导入
- en: 'There is one other lurking gotcha here. In *omission/data/settings.py*, I have
    this statement for importing a class from the module *omission/data/game_round_settings.py*:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个潜在的陷阱。在*omission/data/settings.py*中，我有这样一个导入语句，用于从*omission/data/game_round_settings.py*模块中导入一个类：
- en: '[PRE21]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 4-12: *settings.py:1a*'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 4-12: *settings.py:1a*'
- en: 'You might think that since both *settings.py* and *game_round_settings.py*
    are in the same package, *data*, I should be able to just use this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为，既然*settings.py*和*game_round_settings.py*都在同一个包*data*中，我应该可以直接使用这个：
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 4-13: *settings.py:1b*'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 4-13: *settings.py:1b*'
- en: However, that will not work. It will fail to locate the *game_round_settings.py*
    module because I am running the top-level package (`python3 -m omission`), and
    absolute imports for anything within the package being executed (*omission*) have
    to start from the top.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不会奏效。它无法定位到*game_round_settings.py*模块，因为我在运行顶级包（`python3 -m omission`），而执行包中的绝对导入（*omission*）必须从顶层开始。
- en: 'I can instead use a relative import, which looks much simpler than the absolute
    import:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我也可以改用相对导入，这样看起来比绝对导入简单得多：
- en: '[PRE23]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Listing 4-14: *settings.py:1c*'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 4-14: *settings.py:1c*'
- en: In this case, the single dot (`.`) means “this package.”
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，一个点（`.`）表示“当前包”。
- en: 'This probably feels familiar if you’re used to the typical UNIX filesystem,
    although Python takes the concept a bit further:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你习惯了典型的 UNIX 文件系统，这可能会让你感觉很熟悉，尽管 Python 在这个概念上做得更进一步：
- en: One dot (`.`) means the current package.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个点（`.`）表示当前包。
- en: Two dots (`..`) takes you back one level, to the parent package.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两个点（`..`）可以让你回到上一级，即父包。
- en: Three dots (`...`) takes you back two levels, to the parent of the parent package.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 三个点（`...`）可以让你回到两级，即父包的父包。
- en: Four dots (`....`) takes you back three levels.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 四个点（`....`）会让你回到上三级。
- en: And so on, and so forth.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 以此类推，等等。
- en: Keep in mind that those “levels” aren’t just plain directories; they’re packages.
    If you have two distinct packages in a plain directory that isn’t a package, you
    can’t use relative imports to jump from one to another. You’ll have to work with
    the Python search path for that. I’ll talk more about that later in this chapter.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这些“层级”不仅仅是普通目录，它们是包。如果你在一个不是包的普通目录中有两个独立的包，你不能使用相对导入来从一个跳到另一个。你必须与Python搜索路径一起工作。稍后我会在本章中详细讲解这个问题。
- en: Entry Points
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 入口点
- en: So far, you’ve learned how to create modules, packages, and projects, and how
    to make full use of the import system. The last piece of this puzzle is gaining
    the ability to control what happens when a package is imported or executed. The
    parts of the project that are run first when importing or executing are called
    *entry points*.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经学会了如何创建模块、包和项目，并充分利用导入系统。这个难题的最后一部分是获得控制包在导入或执行时发生什么的能力。项目中在导入或执行时首先运行的部分被称为*入口点*。
- en: Module Entry Points
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模块入口点
- en: 'When you import a Python module or package, it is given a special variable
    called `__name__`. This contains the *fully qualified name* of the module or package,
    which is the name as the import system sees it. For example, the fully qualified
    name of the module *omission/common/game_enums.py* would be `omission.common.game_enums`.
    There is one exception: when a module or package is run directly, its `__name__`
    is set to the value `"__main__"`.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当你导入一个Python模块或包时，它会被赋予一个特殊的变量，叫做`__name__`。这个变量包含模块或包的*完全限定名*，即导入系统看到的名称。例如，模块*omission/common/game_enums.py*的完全限定名是`omission.common.game_enums`。有一个例外：当模块或包被直接运行时，它的`__name__`会被设置为`"__main__"`。
- en: 'To demonstrate this, assume I have a package called *testpkg*, which contains
    the module *awesome.py*. It defines a function, `greet()`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，假设我有一个名为*testpkg*的包，其中包含模块*awesome.py*。它定义了一个函数，`greet()`：
- en: '[PRE24]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Listing 4-15: *awesome.py:1*'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 4-15: *awesome.py:1*'
- en: 'The bottom of that same file also contains a `print` message:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件的底部还包含一条`print`消息：
- en: '[PRE25]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Listing 4-16: *awesome.py:2a*'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 4-16: *awesome.py:2a*'
- en: 'In another module in the same directory as *testpkg*, I have this module (*example.py*),
    which I run directly with `python3 example.py`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在与*testpkg*同一目录下的另一个模块中，我有这个模块（*example.py*），我通过`python3 example.py`直接运行它：
- en: '[PRE26]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Listing 4-17: *example.py*'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 4-17: *example.py*'
- en: If I look at the `_name_` local variable—which is the `__name__` presently assigned
    to the current module, *example.py*—I’ll see the value is `"__main__"` because
    I executed *example.py* directly.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我查看`_name_`局部变量（也就是当前模块*example.py*的`__name__`），我会看到它的值是`"__main__"`，因为我直接执行了*example.py*。
- en: The package `awesome` I imported also has a `__name__` variable, which has the
    value `"testpkg.awesome"`, representing where the package came from in the import
    system.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我导入的包`awesome`也有一个`__name__`变量，它的值是`"testpkg.awesome"`，表示该包在导入系统中的来源。
- en: 'If you ran that module, you’d get the following output:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行该模块，你会得到以下输出：
- en: '[PRE27]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: That first line is coming from *testpkg/awesome.py*, which is run by the import
    command. The rest is coming from the two print commands in *example.py*.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行来自于*testpkg/awesome.py*，这是通过导入命令运行的。其余部分来自于*example.py*中的两个打印命令。
- en: 'But what if I want that first message to appear only if *awesome.py* is executed
    directly, and *not* when the module is only imported? To accomplish that, I’d
    check the value of `__name__` variable in a conditional statement. I’ve rewritten
    my *awesome.py* file to do exactly that:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我希望只有在直接执行*awesome.py*时，才显示那条第一条消息，而不是在模块仅被导入时显示呢？为了实现这一点，我会在条件语句中检查`__name__`变量的值。我已经重新编写了我的*awesome.py*文件，正是为了实现这个目标：
- en: '[PRE28]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Listing 4-18: *awesome.py:2b*'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 4-18: *awesome.py:2b*'
- en: If *awesome.py* is executed directly, `__name__` will have the value `"__main__"`,
    so the print statement will run. Otherwise, if *awesome.py* is being imported
    (or otherwise run indirectly), the conditional will fail.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*awesome.py*被直接执行，`__name__`的值将是`"__main__"`，因此打印语句将会执行。否则，如果*awesome.py*只是被导入（或者间接执行），条件语句将失败。
- en: While you’ll frequently see this pattern in Python, some Python experts consider
    it an anti-pattern, because it can encourage you to both execute and import a
    module at the same time. While I don’t agree that using `if__name__ == "__main__"`
    is an anti-pattern, you often don’t need it. In any case, be certain you never
    import your main module from anywhere else in your package.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Package Entry Points
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice that my *omission* project has a file called `__main__` in the top-level
    package. This file is automatically run when a package is executed directly, but
    never when importing the package.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: So, when executing *omission* via `python3 -m omission`, Python first runs the
    *__init__.py* module (as always), followed by its *__main__.py* module. Otherwise,
    if the package is imported instead, only *__init__.py* is executed.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: If you omit *__main__.py* from a package, it cannot be executed directly.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'A good *__main__.py* for a top-level package would look something like the
    following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Listing 4-19: *__main__.py*'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: All the logic for starting the package belongs in the `main()` function. Then,
    the `if` statement checks the `__name__` assigned to the *__main__.py* module.
    Since this package is being executed directly, the value of `__name__` is `"__main__"`,
    and the code within the `if` statement, being the call to the `main()` function,
    is run. Otherwise, if *__main__.py* were only being imported, its fully qualified
    name would include its containing package (for example, `omission.__main__`),
    the condition would fail, and the code wouldn’t run.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Controlling Package Imports
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A package’s *__init__.py* file can come in handy when you want to change what
    is available for import and how it can be used. The most common uses for this
    file are to simplify imports and to control the behavior of import-all (`import
    *`).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying Imports
  id: totrans-190
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Imagine I have a particularly complicated package, `rockets`, which is made
    up of dozens of subpackages and hundreds of modules. I can safely assume that
    many developers using the package won’t want to know about most of that functionality.
    They only want one thing: to define a rocket and then launch it! Instead of expecting
    all the users of my package to know where those few basic bits of functionality
    exist in the package structure, I can use *__init__.py* to expose said functionality
    directly, making the bits easier to import later:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Listing 4-20: *__init__.py:1*'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'This greatly simplifies the usage of the package. I no longer need to remember
    where things like the `SmallRocket` and `Launchpad` classes live in the `rockets`
    package structure. I can import them directly from the top-level package and use
    them:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Listing 4-21: *rocket_usage.py*'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Beautifully simple, isn’t it? Still, nothing is actually *preventing* me from
    importing things the long-form way (such as `from rockets.smallrocket.rocket import
    SmallRocket`) if I need to. The shortcut is there, but it’s optional.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Because simplicity is such an essential part of the Python philosophy, it is
    also an essential component of package design. If you can anticipate the most
    common ways a user might interact with your package, you can greatly simplify
    their code by adding a few lines to *__init__.py*.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Controlling Import-All
  id: totrans-199
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: By default, import-all doesn’t work with a package. You use *__init__.py* to
    enable and control the behavior of `import *`, even though such an import statement
    is generally discouraged. This can be done by assigning a list of strings to `__all__`,
    with each string containing something (such as a package or module) to import
    from the current package.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'This works well with the previous trick ([Listing 4-20](#listing4-20)):'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Listing 4-22: *__init__.py:2a*'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'When Python encounters a line like `from rockets import *`, that list from
    `__all__` (seen as `rockets.__all__`) is unpacked in place of the asterisk (`*`).
    This is important in figuring out what you can include in `__all__`: each item
    in my list should make sense when substituted for the asterisk in `from rockets
    import *`.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'In other words, I could change the last line of my *__init__.py* to this, and
    there would be no error in the code:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Listing 4-23: *__init__.py:2b*'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: This works because, as you already know, the line `from rockets import smallrocket`
    is a valid import statement.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, this example would *not* work:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Listing 4-24: *__init__.py:2c*'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: It fails because `from rockets import smallrocket.rocket` does not make sense.
    You’ll have to consider this principle when defining `__all__`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: If `__all__` is not defined in *__init__.py*, then `from rockets import *` will
    behave the same as `import rockets`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Program Entry Points
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you’ve applied all the concepts in this chapter to your project’s structure,
    you can run `python3 -m yourproject` to start your program.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: However, you (or your eventual end user) may want to run the program merely
    by double-clicking or directly executing some single Python file. With everything
    else in place, this is trivial to implement.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'To make my *omission* project easy to run, I created a single script file *outside
    the top-level package*, named *omission.py*:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Listing 4-25: *omission.py*'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: I import the `main()` function from *omission/__main__.py* and then execute
    that function. This is effectively the same as executing that package directly
    with `python3 -m omission`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: There are better ways to create a program entry point, but I’ll cover those
    in Chapter 18, once I’ve created the all-important *setup.cfg* file. Again, what
    you have so far will be enough for development.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: The Python Module Search Path
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *module search path*, or *import path*, defines where Python looks for packages
    and modules and what order it searches in. When you first start the Python interpreter,
    the module search path is assembled in order, from the directory of the module
    being executed, the system variable `PYTHONPATH`, and the default path for the
    Python instance being used.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'You can view the resulting module search path with the following commands:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Running that code within the context of a virtual environment (in my case,
    */home/jason/.venvs/venv310*) on my system gives me the following output:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The import system looks through each of the locations in the module search path
    *in order*. As soon as it finds a match for the module or package being imported,
    it stops. You can see here that it searches the directory containing the module
    or script I’m running ❶, the standard libraries ❷ ❸ ❹, and then everything installed
    with pip in the virtual environment ❺.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: If you need to add locations to the module search path, the best way is to use
    a virtual environment and add a file ending in *.pth* to the *lib/python3.x/site-packages*
    directory. The name of the file doesn’t matter, as long as the file extension
    is *.pth*.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the following:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Listing 4-26: *venv/lib/python3.10/site-packages/stuff.pth*'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Each line must contain exactly one path to be appended. The absolute path */home/jason/bunch_of_code*
    will be appended to the module search path. The relative path *../../../awesomesauce*
    is relative to the .*pth* file, so it will point to *venv/awesomesauce*.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Because these are appended to the module search path, this technique cannot
    be used to replace any packages or modules installed on the system or virtual
    environment. However, any new modules or packages in my *bunch_of_code/* or *awesomesauce/*
    directories will be available for import within the virtual environment.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: What Really Happens
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s look at what really happens under the hood when you import a module. Most
    of the time, those details won’t matter, but every now and then (such as when
    the wrong module seems to be imported instead of the one you expect), the technical
    details leak to the surface. It never hurts to know what’s going on.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: The `import` statement calls the built-in`__import__()` function.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'To import a module, Python uses two special objects: a *finder* and a *loader*.
    In some cases, it uses an *importer* object, which serves as both a finder and
    a loader.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: The *finder* is responsible for locating the module being imported. There are
    many places to look for modules—they aren’t even necessarily files—and a number
    of special situations exist that must be handled. Python has several types of
    finders to handle these different situations, and it gives each one an opportunity
    to locate a module with a given name.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'First, Python uses *meta path finders*, which are stored in the `sys.meta_path`
    list. By default, there are three meta path finders:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: The *built-in importer* finds and loads built-in modules.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *frozen importer* finds and loads *frozen* modules, meaning modules that
    have been converted to compiled bytecode (see Chapter 1).
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *path-based finder* looks in the filesystem for the module.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This search order is the reason why you cannot globally shadow a built-in module;
    the built-in importer runs before the path-based finder. If you need some additional
    meta path finder, such as if you were importing a module from a novel location
    not already supported, you can add it as a *meta hook* by appending it to the
    `sys.meta_path` list.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: There’s some additional complexity to the path-based finder that is worth breaking
    down. The path-based finder tries each of the *path entry finders* in turn. These
    path entry finders, also known as *path entry hooks*, are stored in `sys.path_hooks`.
    Each one searches every location (known as a *path* entry) listed on the import
    path, as specified by `sys.path` or the `__path__` attribute of the current package.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: If any of the finders locates the module, it returns a *module spec* object
    with all the information about how to load the module. However, if all the meta
    path finders return `None`, you’ll get a `ModuleNotFoundError`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Once the module is found, the module spec goes to the *loader*, which is responsible
    for actually loading the module.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: There’s a lot of technical detail regarding loading that’s beyond the scope
    of this book, but one thing worth noting is how the loader deals with *cached
    bytecode*. Ordinarily, once a Python module has been run, a *.pyc* file is generated.
    The file contains the bytecode, which from then on is *cached*. You’ll often see
    these *.pyc* files hanging out in your project directories. The loader always
    needs to be sure that the cached bytecode is not out of date before loading it,
    by using one of two strategies. The first strategy is for the bytecode to also
    store the timestamp from the last time the source code file was modified. When
    loading the module, the timestamp of the source code is checked against this cached
    timestamp. If it doesn’t match, the bytecode is out of date, and the source will
    be recompiled. The second strategy, introduced in Python 3.7, instead stores a
    *hash*, which is a short and (relatively) unique value algorithmically generated
    from the source code itself. If the source code changes, the hash will be different
    from the one stored in the cached bytecode. Python bytecode files that contain
    this hash are appropriately called *hash-based .pyc* files.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of how the loader is loading the module, it will add the module object
    to `sys.modules`—adding it, in fact, just before actually loading, to prevent
    an import loop if the module being loaded imports itself. Finally, the loader
    will bind the imported module object to a name in the module importing it, so
    the imported module can be referenced. (I’ll cover name binding in Chapter 5.)
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Once the module has been imported, it’s cached in `sys.path_importer_cache`,
    along with the importer object used to import it. This is actually the first place
    the import system will check for an imported module, even before running through
    the finders, so importing a module multiple times in a project will still only
    go through the finding-and-loading process once.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: This is a very broad overview of the import system, but most of the time, it’s
    all you’ll need to know. To learn all the intricate details, you can read the
    official documentation at [https://docs.python.org/3/reference/import.xhtml](https://docs.python.org/3/reference/import.xhtml).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping Up
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Python import system is often overlooked when learning the language, leading
    to many headaches for new users. By understanding how to use and import modules
    and packages, you will greatly reduce the roadblocks between you and a viable
    project. A little effort now will save you countless hours of confusion and trouble
    later!
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
