- en: '**6**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**6**'
- en: '**Drawing Geometric Shapes and Fractals**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**绘制几何形状和分形**'
- en: '![image](images/common-01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/common-01.jpg)'
- en: In this chapter, we’ll start by learning about patches in matplotlib that allow
    us to draw geometric shapes, such as circles, triangles, and polygons. We’ll then
    learn about matplotlib’s animation support and write a program to animate a projectile’s
    trajectory. In the final section, we’ll learn how to draw *fractals*—complex geometric
    shapes created by the repeated applications of simple geometric transformations.
    Let’s get started!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将首先学习 matplotlib 中的补丁（patches），它们使我们能够绘制几何形状，如圆形、三角形和多边形。接着，我们将学习 matplotlib
    的动画支持，并编写一个程序来展示投射物的轨迹。最后一部分，我们将学习如何绘制 *分形*——通过反复应用简单的几何变换创建的复杂几何形状。让我们开始吧！
- en: '**Drawing Geometric Shapes with Matplotlib’s Patches**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用 Matplotlib 补丁绘制几何形状**'
- en: 'In matplotlib, *patches* allow us to draw geometric shapes, each of which we
    refer to as a *patch*. You can specify, for example, a circle’s radius and center
    in order to add the corresponding circle to your plot. This is quite different
    from how we’ve used matplotlib so far, which has been to supply the *x*- and *y*-coordinates
    of the points to plot. Before we can write a program to make use of the patches
    feature, however, we’ll need to understand a little bit more about how a matplotlib
    plot is created. Consider the following program, which plots the points (1, 1),
    (2, 2), and (3, 3) using matplotlib:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在 matplotlib 中，*补丁*允许我们绘制几何形状，每个几何形状都被称为一个 *补丁*。例如，您可以指定圆形的半径和圆心，以便将相应的圆形添加到您的图表中。这与我们迄今为止使用
    matplotlib 的方式有很大不同，之前我们通过提供点的 *x* 和 *y* 坐标来绘制图形。然而，在编写一个程序来利用补丁功能之前，我们需要稍微了解一下
    matplotlib 图表是如何创建的。考虑以下程序，它使用 matplotlib 绘制点 (1, 1)，(2, 2) 和 (3, 3)：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This program creates a matplotlib window that shows a line passing through the
    given points. Under the hood, when the `plt.plot()` function is called, a `Figure`
    object is created, within which the axes are created, and finally the data is
    plotted within the axes (see [Figure 6-1](ch06.html#ch6fig1)).[¹](footnote.html#fn03)
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序创建了一个 matplotlib 窗口，展示了一条经过给定点的直线。在背后，当调用 `plt.plot()` 函数时，首先会创建一个 `Figure`
    对象，其中创建坐标轴，最后数据会被绘制到坐标轴中（参见 [图 6-1](ch06.html#ch6fig1)）。[¹](footnote.html#fn03)
- en: '![image](images/f06-01.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f06-01.jpg)'
- en: '*Figure 6-1: Architecture of a matplotlib plot*'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-1：matplotlib 图表的架构*'
- en: 'The following program re-creates this plot, but we’ll also explicitly create
    the `Figure` object and add axes to it, instead of just calling the `plot()` function
    and relying on it to create those:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序重新创建了这个图表，但我们将显式地创建 `Figure` 对象并向其中添加坐标轴，而不是仅仅调用 `plot()` 函数并依赖它来创建这些对象：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, we create the `Figure` object using the `figure()` function at ➊, and
    then we create the axes using the `axes()` function at ➋. The `axes()` function
    also adds the axes to the `Figure` object. The last two lines are the same as
    in the earlier program. This time, when we call the `plot()` function, it sees
    that a `Figure` object with an `Axes` object already exists and directly proceeds
    to plot the data supplied to it.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在 ➊ 使用 `figure()` 函数创建了 `Figure` 对象，然后在 ➋ 使用 `axes()` 函数创建了坐标轴。`axes()`
    函数还会将坐标轴添加到 `Figure` 对象中。最后两行与之前的程序相同。这一次，当我们调用 `plot()` 函数时，它会看到已经存在一个包含 `Axes`
    对象的 `Figure` 对象，并直接绘制提供给它的数据。
- en: Besides manually creating `Figure` and `Axes` objects, you can use two different
    functions in the `pyplot` module to get a reference to the current `Figure` and
    `Axes` objects. When you call the `gcf()` function, it returns a reference to
    the current `Figure`, and when you call the `gca()` function, it returns a reference
    to the current `Axes`. An interesting feature of these functions is that each
    will create the respective object if it doesn’t already exist. How these functions
    work will become clearer as we make use of them later in this chapter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 除了手动创建 `Figure` 和 `Axes` 对象外，您还可以使用 `pyplot` 模块中的两个不同函数来获取当前 `Figure` 和 `Axes`
    对象的引用。当调用 `gcf()` 函数时，它返回当前 `Figure` 的引用，而当调用 `gca()` 函数时，它返回当前 `Axes` 的引用。一个有趣的特点是，如果这些对象尚不存在，每个函数都会自动创建它们。随着我们在本章中逐步使用这些函数，它们的工作原理会变得更加清晰。
- en: '***Drawing a Circle***'
  id: totrans-14
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***绘制一个圆形***'
- en: 'To draw a circle, you can add the `Circle` patch to the current `Axes` object,
    as demonstrated by the following example:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要绘制一个圆形，您可以将 `Circle` 补丁添加到当前的 `Axes` 对象中，如下所示：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In this program, we’ve separated the creation of the `Circle` patch object
    and the addition of the patch to the figure into two functions: `create_circle()`
    and `show_shape()`. In `create_circle()`, we make a circle with a center at (0,
    0) and a radius of 0.5 by creating a `Circle` object with the coordinates of the
    center (0, 0) passed as a tuple and with the radius of 0.5 passed using the keyword
    argument of the same name at ➊. The function returns the created `Circle` object.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，我们将`Circle`补丁对象的创建与将补丁添加到图形中的操作分成了两个函数：`create_circle()`和`show_shape()`。在`create_circle()`中，我们通过传入中心坐标(0,
    0)和半径0.5，使用相同名称的关键字参数在第➊步创建了一个`Circle`对象。该函数返回创建的`Circle`对象。
- en: The `show_shape()` function is written such that it will work with any matplotlib
    patch. It first gets a reference to the current `Axes` object using the `gca()`
    function at ➋. Then, it adds the patch passed to it using the `add_patch()` function
    and, finally, calls the `show()` function to display the figure. We call the `axis()`
    function here with the `scaled` parameter, which basically tells matplotlib to
    automatically adjust the axis limits. We’ll need to have this statement in all
    programs that use patches to automatically scale the axes. You can, of course,
    also specify fixed values for the limits, as we saw in [Chapter 2](ch02.html#ch02).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`show_shape()`函数的编写方式使其能够与任何matplotlib补丁一起使用。首先，在第➋步，它通过`gca()`函数获取当前`Axes`对象的引用。然后，它使用`add_patch()`函数将传入的补丁添加到图形中，最后调用`show()`函数显示图形。我们在这里调用了`axis()`函数，并传入`scaled`参数，这基本上告诉matplotlib自动调整坐标轴的范围。我们需要在所有使用补丁的程序中加入此语句，以便自动缩放坐标轴。当然，你也可以像我们在[第2章](ch02.html#ch02)中看到的那样，指定固定的坐标轴范围。'
- en: At ➌, we call the `create_circle()` function using the label `c` to refer to
    the returned `Circle` object. Then, we call the `show_shape()` function, passing
    `c` as an argument. When you run the program, you’ll see a matplotlib window showing
    the circle (see [Figure 6-2](ch06.html#ch6fig2)).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在第➌步，我们通过标签`c`调用`create_circle()`函数来引用返回的`Circle`对象。然后，我们调用`show_shape()`函数，并将`c`作为参数传入。当你运行程序时，你会看到一个matplotlib窗口显示圆形（见[图
    6-2](ch06.html#ch6fig2)）。
- en: '![image](images/f06-02.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f06-02.jpg)'
- en: '*Figure 6-2: A circle with a center of (0, 0) and radius of 0.5*'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-2：中心在(0, 0)，半径为0.5的圆形*'
- en: The circle doesn’t quite look like a circle here, as you can see. This is due
    to the automatic aspect ratio, which determines the ratio of the length of the
    *x*- and *y*-axes. If you insert the statement `ax.set_aspect('equal')` after
    ➋, you will see that the circle does indeed look like a circle. The `set_aspect()`
    function is used to set the aspect ratio of the graph; using the `equal` argument,
    we ask matplotlib to set the ratio of the length of the *x*- and *y*-axes to 1:1.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这里的圆形看起来并不像圆形。这是因为自动的纵横比（aspect ratio）决定了* x *轴和* y *轴的长度比。如果你在第➋步后插入语句`ax.set_aspect('equal')`，你会看到圆形确实变得像一个圆。`set_aspect()`函数用于设置图形的纵横比；通过使用`equal`参数，我们告诉matplotlib将*
    x *轴和* y *轴的长度比设置为1:1。
- en: Both the edge color and the face color (fill color) of the patch can be changed
    using the `ec` and `fc` keyword arguments. For example, passing `fc='g'` and `ec='r'`
    will create a circle with a green face color and red edge color.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`ec`和`fc`关键字参数，可以更改补丁的边缘颜色和填充颜色。例如，传入`fc='g'`和`ec='r'`将创建一个具有绿色填充和红色边缘的圆形。
- en: Matplotlib supports a number of other patches, such as `Ellipse`, `Polygon`,
    and `Rectangle`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib支持多种其他补丁类型，如`Ellipse`、`Polygon`和`Rectangle`。
- en: '***Creating Animated Figures***'
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***创建动画图形***'
- en: Sometimes we may want to create figures with moving shapes. Matplotlib’s animation
    support will help us achieve this. At the end of this section, we’ll create an
    animated version of the projectile trajectory-drawing program.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们可能希望创建带有移动形状的图形。Matplotlib的动画支持将帮助我们实现这一点。在本节的最后，我们将创建一个动画版本的抛物线轨迹绘制程序。
- en: 'First, let’s see a simpler example. We’ll draw a matplotlib figure with a circle
    that starts off small and grows to a certain radius indefinitely (unless the matplotlib
    window is closed):'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看一个更简单的例子。我们将绘制一个matplotlib图形，其中的圆形一开始很小，然后会无限增大到某个半径（除非关闭matplotlib窗口）：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We start by importing the `animation` module from the matplotlib package. The
    `create_animation()` function carries out the core functionality here. It gets
    a reference to the current `Figure` object using the `gcf()` function at ➊ and
    then creates the axes with limits of –10 and 10 for both the *x*- and *y*-axes.
    After that, it creates a `Circle` object that represents a circle with a radius
    of 0.05 and a center at (0, 0) and adds this circle to the current axes at ➋.
    Then, we create a `FuncAnimation` object ➌, which passes the following data about
    the animation we want to create:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先从matplotlib包中导入`animation`模块。`create_animation()`函数在这里实现了核心功能。它通过在➊处使用`gcf()`函数获取当前`Figure`对象的引用，然后创建了坐标轴，坐标轴的限制为-10和10，分别适用于*x*轴和*y*轴。之后，它创建了一个`Circle`对象，表示一个半径为0.05、中心在(0,
    0)的圆，并在➋处将这个圆添加到当前坐标轴。然后，我们创建了一个`FuncAnimation`对象➌，并传递了以下关于我们想要创建的动画的数据：
- en: '`fig` This is the current `Figure` object.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`fig` 这是当前的`Figure`对象。'
- en: '`update_radius` This function will be responsible for drawing *every* frame.
    It takes two arguments—a frame number that is automatically passed to it when
    called and the patch object that we want to update every frame. This function
    also must return the object.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`update_radius` 这个函数负责绘制*每一帧*。它接受两个参数——一个帧编号，该编号在调用时会自动传递给它，另一个是我们希望每帧更新的补丁对象。这个函数还必须返回该对象。'
- en: '`fargs` This tuple consists of all the arguments to be passed to the `update_radius()`
    function other than the frame number. If there are no such arguments to pass,
    this keyword argument need not be specified.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`fargs` 这个元组包含所有传递给`update_radius()`函数的参数，除了帧编号。如果没有需要传递的参数，可以不指定这个关键字参数。'
- en: '`frames` This is the number of frames in the animation. Our function `update_radius()`
    is called this many times. Here, we’ve arbitrarily chosen 30 frames.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`frames` 这是动画中的帧数。我们的`update_radius()`函数会被调用这么多次。在这里，我们任意选择了30帧。'
- en: '`interval` This is the time interval in milliseconds between two frames. If
    your animation seems too slow, decrease this value; if it seems too fast, increase
    this value.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`interval` 这是两帧之间的时间间隔（以毫秒为单位）。如果动画看起来太慢，可以减小这个值；如果看起来太快，可以增大这个值。'
- en: We then set a title using the `title()` function and, finally, show the figure
    using the `show()` function.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用`title()`函数设置标题，最后使用`show()`函数显示图形。
- en: As mentioned earlier, the `update_radius()` function is responsible for updating
    the property of the circle that will change each frame. Here, we set the radius
    to `i*0.5`, where `i` is the frame number. As a result, you see a circle that
    grows every frame for 30 frames—thus, the radius of the largest circle is 15\.
    Because the axes’ limits are set at –10 and 10, this gives the effect of the circle
    exceeding the figure’s dimensions. When you run the program, you’ll see your first
    animated figure, as shown in [Figure 6-3](ch06.html#ch6fig3).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`update_radius()`函数负责更新每一帧会发生变化的圆的属性。在这里，我们将半径设置为`i*0.5`，其中`i`是帧编号。因此，你会看到一个在30帧内逐渐增大的圆——也就是说，最大圆的半径是15。由于坐标轴的限制被设置为-10和10，这就造成了圆超出图形尺寸的效果。当你运行程序时，你将看到你的第一个动画图形，如[图6-3](ch06.html#ch6fig3)所示。
- en: You’ll notice that the animation continues until you close the matplotlib window.
    This is the default behavior, which you can change by setting the keyword argument
    to `repeat=False` when you create the `FuncAnimation` object.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到动画会一直持续，直到你关闭matplotlib窗口。这是默认行为，你可以通过在创建`FuncAnimation`对象时将关键字参数设置为`repeat=False`来更改此行为。
- en: '![image](images/f06-03.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f06-03.jpg)'
- en: '*Figure 6-3: Simple circle animation*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-3：简单的圆形动画*'
- en: '**FUNCANIMATION OBJECT AND PERSISTENCE**'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**FUNCANIMATION对象与持久性**'
- en: You probably noted in the animated circle program that we assigned the created
    `FuncAnimation` object to the label `anim` even though we don’t use it again elsewhere.
    This is because of an issue with matplotlib’s current behavior—it doesn’t store
    any reference to the `FuncAnimation` object, making it subject to garbage collection
    by Python. This means the animation will not be created. Creating a label referring
    to the object prevents this from happening.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到，在动画圆圈程序中，我们将创建的`FuncAnimation`对象赋值给了标签`anim`，尽管我们在其他地方没有再次使用它。这是由于matplotlib当前的行为问题——它不会存储对`FuncAnimation`对象的任何引用，这使得该对象可能会被Python的垃圾回收机制回收。这意味着动画不会被创建。创建一个引用该对象的标签可以防止这种情况发生。
- en: For more on this issue, you may want to follow the discussions at *[https://github.com/matplotlib/matplotlib/issues/1656/](https://github.com/matplotlib/matplotlib/issues/1656/)*.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多相关问题，您可以关注在*[https://github.com/matplotlib/matplotlib/issues/1656/](https://github.com/matplotlib/matplotlib/issues/1656/)*上的讨论。
- en: '***Animating a Projectile’s Trajectory***'
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***动画化投射物的轨迹***'
- en: 'In [Chapter 2](ch02.html#ch02), we drew the trajectory for a ball in projectile
    motion. Here, we’ll build upon this drawing, making use of matplotlib’s animation
    support to animate the trajectory so that it will come closer to demonstrating
    how you’d see a ball travel in real life:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 2 章](ch02.html#ch02)中，我们绘制了一个抛物线运动中球的轨迹。在这里，我们将基于该图形，利用 matplotlib 的动画功能将轨迹动画化，以便更接近于展示在现实生活中看到球运动的效果：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `create_animation()` function accepts two arguments: `u` and `theta`. These
    arguments correspond to the initial velocity and the angle of projection (*θ*),
    which were supplied as input to the program. The `get_intervals()` function is
    used to find the time intervals at which to calculate the *x*- and *y*-coordinates.
    This function is implemented by making use of the same logic we used in [Chapter
    2](ch02.html#ch02), when we implemented a separate function, `frange()`, to help
    us.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`create_animation()` 函数接受两个参数：`u` 和 `theta`。这些参数对应程序输入的初速度和发射角度 (*θ*)。`get_intervals()`
    函数用于找到计算 *x* 和 *y* 坐标的时间间隔。此函数通过利用我们在[第 2 章](ch02.html#ch02)中使用的相同逻辑来实现，当时我们实现了一个单独的函数
    `frange()` 来帮助我们。'
- en: To set up the axis limits for the animation, we’ll need to find the minimum
    and maximum values of *x* and *y*. The minimum value for each is 0, which is the
    initial value for each. The maximum value of the *x*-coordinate is the value of
    the coordinate at the end of the flight of the ball, which is the last time interval
    in the list `intervals`. The maximum value of the *y*-coordinate is when the ball
    is at its highest point—that is, at ➊, where we calculate that point using the
    formula
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置动画的坐标轴范围，我们需要找出 *x* 和 *y* 的最小值和最大值。每个坐标的最小值都是 0，这是它们的初始值。*x* 坐标的最大值是球飞行结束时的坐标值，即列表
    `intervals` 中最后的时间间隔。*y* 坐标的最大值是球的最高点——也就是在 ➊ 点，我们通过公式计算这个点的位置。
- en: '![image](images/e0157-01.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/e0157-01.jpg)'
- en: Once we have the values, we create the axes at ➋, passing the appropriate axis
    limits. In the next two statements, we create a representation of the ball and
    add it to the figure’s `Axes` object by creating a circle of radius `1.0` at (`xmin`,
    `ymin`)—the minimum coordinates of the *x*- and *y*-axes, respectively.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们得到了这些值，我们就在 ➋ 创建坐标轴，并传入适当的坐标轴范围。在接下来的两条语句中，我们创建了一个球的表示，并通过在 (`xmin`, `ymin`)（即
    *x* 和 *y* 轴的最小坐标）创建一个半径为 `1.0` 的圆，将其添加到图形的 `Axes` 对象中。
- en: 'We then create the `FuncAnimation` object ➌, supplying it with the current
    figure object and the following arguments:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们创建 `FuncAnimation` 对象 ➌，并为其提供当前的图形对象以及以下参数：
- en: '`update_position` This function will change the center of the circle in each
    frame. The idea here is that a new frame is created for every time interval, so
    we set the number of frames to the size of the time intervals (see the description
    of `frames` in this list). We calculate the *x*-and *y*-coordinates of the ball
    at the time instant at the `i`th time interval, and we set the center of the circle
    to these values.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`update_position` 该函数将在每一帧中改变圆心的位置。这里的想法是每个时间间隔都会创建一个新的帧，因此我们将帧数设置为时间间隔的大小（请参阅此列表中
    `frames` 的描述）。我们计算在第 `i` 个时间间隔的时间瞬间，球的 *x* 和 *y* 坐标，并将圆心的位置设置为这些值。'
- en: '`fargs` The `update_position()` function needs to access the list of time intervals,
    intervals, initial velocity, and theta, which are specified using this keyword
    argument.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`fargs` `update_position()` 函数需要访问时间间隔列表 `intervals`、初速度和角度 `theta`，这些都通过这个关键字参数指定。'
- en: '`frames` Because we’ll draw one frame per time interval, we set the number
    of frames to the size of the `intervals` list.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`frames` 因为我们将在每个时间间隔绘制一帧，所以将帧数设置为 `intervals` 列表的大小。'
- en: '`repeat` As we discussed in the first animation example, animation repeats
    indefinitely by default. We don’t want that to happen in this case, so we set
    this keyword to `False`.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`repeat` 正如我们在第一个动画示例中讨论的，动画默认情况下会无限重复。我们不希望在这个情况下发生这种情况，因此我们将该关键字设置为 `False`。'
- en: When you run the program, it asks for the initial inputs and then creates the
    animation, as shown in [Figure 6-4](ch06.html#ch6fig4).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行程序时，它会要求输入初始值，然后生成动画，如[图 6-4](ch06.html#ch6fig4)所示。
- en: '![image](images/f06-04.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f06-04.jpg)'
- en: '*Figure 6-4: Animation of the trajectory of a projectile*'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-4：抛射物轨迹的动画*'
- en: '**Drawing Fractals**'
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**绘制分形**'
- en: Fractals are complex geometric patterns or shapes arising out of surprisingly
    simple mathematical formulas. Compared to geometric shapes, such as circles and
    rectangles, a fractal seems irregular and without any obvious pattern or description,
    but if you look closely, you see that patterns emerge and the entire shape is
    composed of numerous copies of itself. Because fractals involve the repetitive
    application of the same *geometric transformation* of points in a plane, computer
    programs are well-suited to create them. In this chapter, we’ll learn how to draw
    the Barnsley fern, the Sierpiński triangle, and the Mandelbrot set (the latter
    two in the challenges)— popular examples of fractals studied in the field. Fractals
    abound in nature, too—popular examples include coastlines, trees, and snowflakes.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 分形是从出奇简单的数学公式中产生的复杂几何图案或形状。与几何形状（如圆形和矩形）相比，分形看起来不规则且没有明显的模式或描述，但如果仔细观察，你会发现图案会显现出来，并且整个形状是由无数自我复制的部分组成的。由于分形涉及在平面上对点进行相同*几何变换*的重复应用，因此计算机程序非常适合生成它们。在本章中，我们将学习如何绘制巴恩斯利蕨、谢尔宾斯基三角形和曼德尔布罗集合（后两者在挑战中介绍）——这是分形领域中常见的例子。分形在自然界中也随处可见——常见的例子包括海岸线、树木和雪花。
- en: '***Transformations of Points in a Plane***'
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***平面上点的变换***'
- en: A basic idea in creating fractals is that of the transformation of a point.
    Given a point, *P*(*x*, *y*), in an *x*-*y* plane, an example of a transformation
    is *P* (*x*, *y*) → *Q* (*x* + 1, *y* + 1), which means that after applying the
    transformation, a new point, *Q*, which is one unit above and one unit to the
    right of *P*, is created. If you then consider *Q* as the starting point, you’ll
    get another point, *R*, that’s one unit above and one unit to the right of *Q*.
    Consider the starting point, *P*, to be (1, 1). [Figure 6-5](ch06.html#ch6fig5)
    shows what the points would look like.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 创建分形的基本思想是点的变换。给定平面上的一个点 *P*(*x*, *y*)，变换的一个例子是 *P* (*x*, *y*) → *Q* (*x* +
    1, *y* + 1)，这意味着在应用变换后，会创建一个新点 *Q*，它位于 *P* 上方和右侧各一单位。如果然后把 *Q* 作为起点，你会得到另一个点 *R*，它位于
    *Q* 上方和右侧各一单位。假设起始点 *P* 为 (1, 1)。[图 6-5](ch06.html#ch6fig5) 显示了点的变化情况。
- en: '![image](images/f06-05.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f06-05.jpg)'
- en: '*Figure 6-5: The points* Q *and* R *have been obtained by applying a transformation
    to the point* P *for two iterations.*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-5：点* Q *和* R *通过对点* P *进行两次变换获得。*'
- en: 'This transformation is, thus, a rule describing how a point moves around in
    the *x*-*y* plane, starting from an initial position and moving to a different
    point at each iteration. We can think of a transformation as the point’s *trajectory*
    in the plane. Now, consider that instead of one transformation rule, there are
    two such rules and one of these transformations is picked at *random* at every
    step. Let’s consider these rules:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这个变换是一个规则，描述了一个点在 *x*-*y* 平面中如何从初始位置开始，经过每次迭代后移动到不同的点。我们可以把变换看作是点在平面上的*轨迹*。现在，考虑到不仅有一个变换规则，而是有两个这样的规则，并且在每一步中随机选择其中一个变换规则。我们来看一下这些规则：
- en: 'Rule 1: *P* 1 (*x*, *y*) → *P* 2 (*x* + 1, *y* – 1)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '规则 1: *P* 1 (*x*, *y*) → *P* 2 (*x* + 1, *y* – 1)'
- en: 'Rule 2: *P* 1 (*x*, *y*) → *P* 2 (*x* + 1, *y* + 1)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '规则 2: *P* 1 (*x*, *y*) → *P* 2 (*x* + 1, *y* + 1)'
- en: 'Consider *P*1(1, 1) to be the starting point. If we carry out four iterations,
    we could have the following sequence of points:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 *P*1(1, 1) 为起始点。如果进行四次迭代，我们可以得到以下的点序列：
- en: '*P* 1 (1, 1) → *P* 2 (2, 0) (Rule 1)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*P* 1 (1, 1) → *P* 2 (2, 0)（规则 1）'
- en: '*P* 2 (2, 0) → *P* 3 (3, 1) (Rule 2)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*P* 2 (2, 0) → *P* 3 (3, 1)（规则 2）'
- en: '*P* 3 (3, 1) → *P* 4 (4, 2) (Rule 2)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*P* 3 (3, 1) → *P* 4 (4, 2)（规则 2）'
- en: '*P* 4 (4, 2) → *P* 5 (5, 1) (Rule 1)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*P* 4 (4, 2) → *P* 5 (5, 1)（规则 1）'
- en: '... and so on.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: …依此类推。
- en: 'The transformation rule is picked at random, with each rule having an equal
    probability of being selected. No matter which one is picked, the points will
    advance toward the right because we increase the *x*-coordinate in both cases.
    As the points go to the right, they move either up or down, thus creating a zigzag
    path. The following program charts out the path of a point when subjected to one
    of these transformations for a specified number of iterations:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 变换规则是随机选取的，每个规则被选中的概率相等。无论选中哪个规则，点都会朝右移动，因为在两种情况下我们都会增加 *x* 坐标。当点朝右移动时，它们要么向上，要么向下，从而形成锯齿状路径。以下程序绘制了一个点在进行某一变换规则下，经过指定次数迭代后的路径：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We define two functions, `transformation_1()` and `transformation_2()`, corresponding
    to the two preceding transformations. In the `transform()` function, we create
    a list with these two function names at ➊ and use the `random.choice()` function
    to pick one of the transformations from the list at ➋. Now that we’ve picked the
    transformation to apply, we call it with the point, *P*, and store the coordinates
    of the transformed point in the labels `x`, `y` ➌ and return them.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了两个函数，`transformation_1()`和`transformation_2()`，分别对应之前的两个变换。在`transform()`函数中，我们在➊处创建一个包含这两个函数名的列表，并使用`random.choice()`函数在➋处从列表中选择一个变换。现在我们已经选择了要应用的变换，我们用点*P*调用它，并将变换后的点的坐标存储在标签`x`、`y`中
    ➌，并返回它们。
- en: '**SELECTING A RANDOM ELEMENT FROM A LIST**'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**从列表中选择随机元素**'
- en: 'The `random.choice()` function we saw in our first fractal program can be used
    to select a random element from a list. Each element has an *equal* chance of
    being returned. Here’s an example:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第一个分形程序中看到的`random.choice()`函数可以用来从列表中选择一个随机元素。每个元素都有*相等*的机会被返回。以下是一个示例：
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The function also works with tuples and strings. In the latter case, it returns
    a random character from the string.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数同样适用于元组和字符串。在后者的情况下，它从字符串中返回一个随机字符。
- en: When you run the program, it asks you for the number of iterations, `n`—that
    is, the number of times the transformation would be applied. Then, it calls the
    `build_trajectory()` function with `n` and the initial point, *P*, which is set
    to (1, 1) ➍. The `build_trajectory()` function repeatedly calls the `transform()`
    function `n` times, using two lists, `x` and `y`, to store the *x*-coordinate
    and *y*-coordinate of all the transformed points. Finally, it returns the two
    lists, which are then plotted ➎.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行程序时，它会询问你迭代的次数`n`——即变换应用的次数。然后，它会调用`build_trajectory()`函数，传入`n`和初始点*P*，其值为(1,
    1) ➍。`build_trajectory()`函数会重复调用`transform()`函数`n`次，使用两个列表`x`和`y`来存储所有变换点的*x*坐标和*y*坐标。最后，它返回这两个列表，并将其绘制出来
    ➎。
- en: '[Figures 6-6](ch06.html#ch6fig6) and [6-7](ch06.html#ch6fig7) show the trajectory
    of the point for 100 and 10,000 iterations, respectively. The zigzag motion is
    quite apparent in both figures. This zigzag path is usually referred to as a *random
    walk on a line*.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-6](ch06.html#ch6fig6)和[6-7](ch06.html#ch6fig7)分别展示了点在100次和10,000次迭代中的轨迹。在这两幅图中，锯齿状运动非常明显。这种锯齿路径通常被称为*线上的随机游走*。'
- en: '![image](images/f06-06.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f06-06.jpg)'
- en: '*Figure 6-6: The zigzag path traced by the point (1, 1) when subjected to one
    or the other of the two transformations randomly for 100 iterations*'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6: 点(1, 1)在经过两种变换之一随机进行100次迭代时所描绘的锯齿路径*'
- en: '![image](images/f06-07.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f06-07.jpg)'
- en: '*Figure 6-7: The zigzag path traced by the point (1, 1) when subjected to one
    or the other of the two transformations randomly for 10,000 iterations.*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-7: 点(1, 1)在经过两种变换之一随机进行10,000次迭代时所描绘的锯齿路径。*'
- en: This example demonstrates a basic idea in creating fractals—starting from an
    initial point and applying a transformation to that point repeatedly. Next, we’ll
    see an example of applying the same ideas to draw the *Barnsley fern*.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例展示了创建分形的基本思路——从一个初始点出发，并反复对该点应用变换。接下来，我们将看到将相同的思路应用于绘制*巴恩斯利蕨*的示例。
- en: '***Drawing the Barnsley Fern***'
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***绘制巴恩斯利蕨***'
- en: The British mathematician Michael Barnsley described how to create fern-like
    structures using repeated applications of a simple transformation on a point (see
    [Figure 6-8](ch06.html#ch6fig8)).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 英国数学家迈克尔·巴恩斯利描述了如何通过对一个点反复应用简单的变换来创建蕨类植物结构（见[图 6-8](ch06.html#ch6fig8)）。
- en: '![image](images/f06-08.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f06-08.jpg)'
- en: '*Figure 6-8: Lady ferns[²](footnote.html#fn04)*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-8: 女士蕨[²](footnote.html#fn04)*'
- en: 'He proposed the following steps to create fern-like structures: start with
    the point (0, 0) and *randomly* select one of the following transformations with
    the assigned *probability*:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 他提出了以下步骤来创建类似蕨类植物的结构：从点(0, 0)开始，并*随机*选择以下变换之一，按指定的*概率*：
- en: '**Transformation 1** (0.85 probability):'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**变换 1** (0.85 概率):'
- en: '*x*[*n*+1] = 0.85*x[n]* + 0.04*y[n]*'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*x*[*n*+1] = 0.85*x[n]* + 0.04*y[n]*'
- en: '*y*[*n*+1] = –0.04*y[n]* + 0.85*y[n]* + 1.6'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*y*[*n*+1] = –0.04*y[n]* + 0.85*y[n]* + 1.6'
- en: '**Transformation 2** (0.07 probability):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**变换 2** (0.07 概率):'
- en: '*x*[*n*+1] = 0.2*x[n]* – 0.26*y[n]*'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*x*[*n*+1] = 0.2*x[n]* – 0.26*y[n]*'
- en: '*y*[*n*+1] = 0.23*y[n]* + 0.22*y[n]* + 1.6'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*y*[*n*+1] = 0.23*y[n]* + 0.22*y[n]* + 1.6'
- en: '**Transformation 3** (0.07 probability):'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**变换 3** (0.07 概率):'
- en: '*x*[*n*+1] = –0.15*x[n]* – 0.28*x[n]*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*x*[*n*+1] = –0.15*x[n]* – 0.28*x[n]*'
- en: '*y*[*n*+1] = 0.26*y[n]* + 0.24*y[n]* + 0.44'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*y*[*n*+1] = 0.26*y[n]* + 0.24*y[n]* + 0.44'
- en: '**Transformation 4** (0.01 probability):'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**变换 4**（概率 0.01）：'
- en: '*x*[*n*+1] = 0'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*x*[*n*+1] = 0'
- en: '*y*[*n*+1] = 0.16*y[n]*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*y*[*n*+1] = 0.16*y[n]*'
- en: Each of these transformations is responsible for creating a part of the fern.
    The first transformation selected with the highest probability—and hence the maximum
    number of times—creates the stem and the bottom fronds of the fern. The second
    and third transformations create the bottom frond on the left and the right, respectively,
    and the fourth transformation creates the stem of the fern.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变换中的每一个都负责创建蕨类植物的一部分。第一个变换以最高的概率被选中——因此应用的次数最多——它创建了蕨类植物的茎和底部的羽叶。第二个和第三个变换分别创建了左侧和右侧的底部羽叶，第四个变换则创建了蕨类植物的茎。
- en: 'This is an example of nonuniform probabilistic selection, which we first learned
    about in [Chapter 5](ch05.html#ch05). The following program draws the Barnsley
    fern for the specified number of points:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非均匀概率选择的例子，我们在 [第 5 章](ch05.html#ch05) 中首次学习过。以下程序会根据指定的点数绘制 Barnsley 蕨类植物：
- en: '[PRE7]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When you run this program, it asks for the number of points in the fern to be
    specified and then creates the fern. [Figures 6-9](ch06.html#ch6fig9) and [6-10](ch06.html#ch6fig10)
    show ferns with 1,000 and 10,000 points, respectively.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个程序时，它会要求指定蕨类植物的点数，然后创建蕨类植物。图 [6-9](ch06.html#ch6fig9) 和 [6-10](ch06.html#ch6fig10)
    分别展示了含有 1,000 和 10,000 个点的蕨类植物。
- en: '![image](images/f06-09.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f06-09.jpg)'
- en: '*Figure 6-9: A fern with 1,000 points*'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-9：含 1,000 个点的蕨类植物*'
- en: '![image](images/f06-10.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f06-10.jpg)'
- en: '*Figure 6-10: A fern with 10,000 points*'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-10：含 10,000 个点的蕨类植物*'
- en: The four transformation rules are defined in the `transformation_1()`, `transformation_2()`,
    `transformation_3()`, and `transformation_4()` functions. The probability of each
    being selected is declared in a list at ➊, and then one of them is selected ➋
    to be applied every time the `transform()` function is called by the `draw_fern()`
    function.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 四个变换规则分别在 `transformation_1()`、`transformation_2()`、`transformation_3()` 和 `transformation_4()`
    函数中定义。每个变换被选中的概率在 ➊ 处声明，然后在每次 `draw_fern()` 函数调用 `transform()` 时，都会随机选取其中一个进行应用
    ➋。
- en: The number of times the initial point (0, 0) is transformed is the same as the
    number of points in the fern specified as input to the program.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 初始点 (0, 0) 被变换的次数与程序输入的蕨类植物中指定的点数相同。
- en: '**What You Learned**'
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started by learning how to draw basic geometric shapes
    and how to animate them. This process introduced you to a number of new matplotlib
    features. You then learned about geometric transformations and saw how repetitive
    simple transformations help you draw complex geometric shapes called *fractals*.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你首先学习了如何绘制基本的几何形状以及如何为它们添加动画。这个过程让你接触到了一些新的 matplotlib 功能。然后，你学习了几何变换，并看到重复的简单变换如何帮助你绘制出复杂的几何形状——*分形*。
- en: '**Programming Challenges**'
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**编程挑战**'
- en: Here are a few programming challenges that should help you further apply what
    you’ve learned. You can find sample solutions at *[http://www.nostarch.com/doingmathwithpython/](http://www.nostarch.com/doingmathwithpython/)*.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些编程挑战，应该能帮助你进一步应用所学的内容。你可以在 *[http://www.nostarch.com/doingmathwithpython/](http://www.nostarch.com/doingmathwithpython/)*
    找到示例解决方案。
- en: '***#1: Packing Circles into a Square***'
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***#1：将圆形填充到正方形中***'
- en: 'I mentioned earlier that matplotlib supports the creation of other geometric
    shapes. The `Polygon` patch is especially interesting, as it allows you to draw
    polygons with different numbers of sides. Here’s how we can draw a square (each
    side of length 4):'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到过，matplotlib 支持创建其他几何形状。`Polygon` 补丁尤其有趣，因为它允许你绘制具有不同边数的多边形。以下是如何绘制一个边长为
    4 的正方形的方法：
- en: '[PRE8]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `Polygon` object is created by passing the list of the vertices’ coordinates
    as the first argument. Because we’re drawing a square, we pass the coordinates
    of the four vertices: (1, 1), (5, 1), (5, 5), and (1, 5). Passing `closed=True`
    tells matplotlib that we want to draw a closed polygon, where the starting and
    the ending vertices are the same.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`Polygon` 对象通过将顶点坐标的列表作为第一个参数来创建。因为我们绘制的是一个正方形，所以我们传入四个顶点的坐标：(1, 1)、(5, 1)、(5,
    5) 和 (1, 5)。传入 `closed=True` 告诉 matplotlib 我们想绘制一个封闭的多边形，其中起点和终点是相同的。'
- en: In this challenge, you’ll attempt a very simplified version of the “circles
    packed into a square” problem. How many circles of radius 0.5 will fit in the
    square produced by this code? Draw and find out! [Figure 6-11](ch06.html#ch6fig11)
    shows how the final image will look.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个挑战中，你将尝试解决一个简化版的“将圆圈填入正方形”问题。半径为0.5的圆圈能在这段代码生成的正方形中填充多少个？绘制并找出答案！[图6-11](ch06.html#ch6fig11)展示了最终图像的样子。
- en: '![image](images/f06-11.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f06-11.jpg)'
- en: '*Figure 6-11: Circles packed into a square*'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-11：圆圈填充进正方形*'
- en: 'The trick here is to start from the lower-left corner of the square— that is,
    (1, 1)—and then continue adding circles until the entire square is filled. The
    following snippet shows how you can create the circles and add them to the figure:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的技巧是从正方形的左下角开始——也就是(1, 1)——然后继续添加圆，直到整个正方形填满。以下代码片段展示了如何创建圆并将其添加到图形中：
- en: '[PRE9]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: A point worth noting here is that this is *not* the most optimal or, for that
    matter, the only way to pack circles into a square, and finding different ways
    of solving this problem is popular among mathematics enthusiasts.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这里值得注意的一点是，这*并不是*将圆圈填入正方形的最优方法，或者说，解决此问题的唯一方法，寻找不同的解决方案在数学爱好者中非常流行。
- en: '***#2: Drawing the Sierpiński Triangle***'
  id: totrans-128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***#2: 绘制谢尔宾斯基三角形***'
- en: The Sierpiński triangle, named after the Polish mathematician Wacław Sierpiński,
    is a fractal that is an equilateral triangle composed of smaller equilateral triangles
    embedded inside it. [Figure 6-12](ch06.html#ch6fig12) shows a Sierpiński triangle
    composed of 10,000 points.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 谢尔宾斯基三角形是以波兰数学家瓦茨瓦夫·谢尔宾斯基的名字命名的，它是一个分形，构成它的是一个等边三角形，其中嵌入了更小的等边三角形。[图6-12](ch06.html#ch6fig12)展示了一个由10,000个点组成的谢尔宾斯基三角形。
- en: '![image](images/f06-12.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f06-12.jpg)'
- en: '*Figure 6-12: Sierpiński triangle with 10,000 points*'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-12：带有10,000个点的谢尔宾斯基三角形*'
- en: 'The interesting thing here is that the same process that we used to draw a
    fern will also draw the Sierpiński triangle—only the transformation rules and
    their probability will change. Here’s how you can draw the Sierpiński triangle:
    start with the point (0, 0) and apply one of the following transformations:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，绘制蕨类植物时使用的相同过程也能绘制谢尔宾斯基三角形——只是变换规则及其概率会有所变化。以下是绘制谢尔宾斯基三角形的方法：从点(0, 0)开始，应用以下某一变换：
- en: '**Transformation 1:**'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**变换1：**'
- en: '*x*[*n*+1] = 0.5*x[n]*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*x*[*n*+1] = 0.5*x[n]*'
- en: '*y*[*n*+1] = 0.5*y[n]*'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*y*[*n*+1] = 0.5*y[n]*'
- en: '**Transformation 2**:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**变换2：**'
- en: '*x*[*n*+1] = 0.5*x[n]* + 0.5'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*x*[*n*+1] = 0.5*x[n]* + 0.5'
- en: '*y*[*n*+1] = 0.5*y[n]* + 0.5'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*y*[*n*+1] = 0.5*y[n]* + 0.5'
- en: '**Transformation 3**:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**变换3：**'
- en: '*x*[*n*+1] = 0.5*x[n]* + 1'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*x*[*n*+1] = 0.5*x[n]* + 1'
- en: '*y*[*n*+1] = 0.5*y[n]*'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*y*[*n*+1] = 0.5*y[n]*'
- en: Each of the transformations has an equal probability of being selected—1/3\.
    Your challenge here is to write a program that draws the Sierpiński triangle composed
    of a certain number of points specified as input.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 每个变换的选择概率是相等的——1/3。你的挑战是编写一个程序，绘制出由指定数量的点组成的谢尔宾斯基三角形。
- en: '***#3: Exploring Hénon’s Function***'
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***#3: 探索亨农函数***'
- en: 'In 1976, Michel Hénon introduced the Hénon function, which describes a transformation
    rule for a point *P*(*x*, *y*) as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 1976年，米歇尔·亨农（Michel Hénon）提出了亨农函数，它描述了如下的点 *P*(*x*, *y*) 的变换规则：
- en: '*P* (*x*, *y*) → *Q* (*y* + 1 – 1.4*x*², 0.3*x*)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*P* (*x*, *y*) → *Q* (*y* + 1 – 1.4*x*², 0.3*x*)'
- en: Irrespective of the initial point (provided it’s not very far from the origin),
    you’ll see that as you create more points, they start lying along curved lines,
    as shown in [Figure 6-13](ch06.html#ch6fig13).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 无论初始点在哪里（只要它距离原点不太远），你会发现随着点的增加，它们开始沿着弯曲的线排列，如[图6-13](ch06.html#ch6fig13)所示。
- en: '![image](images/f06-13.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f06-13.jpg)'
- en: '*Figure 6-13: Hénon function with 10,000 points*'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-13：带有10,000个点的亨农函数*'
- en: Your challenge here is to write a program to create a graph showing 20,000 iterations
    of this transformation, starting with the point (1, 1).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你的挑战是编写一个程序，绘制出显示20,000次迭代的图形，从点(1, 1)开始。
- en: Extra credit for writing another program to create an animated figure showing
    the points starting to lie along the curves! See *[https://www.youtube.com/watch?v=76ll818RlpQ](https://www.youtube.com/watch?v=76ll818RlpQ)*
    for an example.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 额外加分项：编写另一个程序，创建一个动画图形，展示点开始沿着曲线排列的过程！示例请见 *[https://www.youtube.com/watch?v=76ll818RlpQ](https://www.youtube.com/watch?v=76ll818RlpQ)*。
- en: 'This is an example of a dynamical system, and the curved lines that all the
    points seem attracted to are referred to as *attractors*. To learn more about
    this function, dynamical systems, and fractals in general, you may want to refer
    to *Fractals: A Very Short Introduction* by Kenneth Falconer (Oxford University
    Press, 2013).'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个动态系统的例子，所有点似乎都被吸引到的曲线被称为*吸引子*。要了解更多关于这个函数、动态系统和分形的一般知识，您可以参考肯尼斯·法尔科纳（Kenneth
    Falconer）所著的《分形：非常简短的介绍》（牛津大学出版社，2013年）。
- en: '***#4: Drawing the Mandelbrot Set***'
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***#4: 绘制曼德尔布罗集***'
- en: Your challenge here is to write a program to draw the *Mandelbrot set*—another
    example of the application of simple rules leading to a complicated-looking shape
    (see [Figure 6-14](ch06.html#ch6fig14)). Before I lay down the steps to do that,
    however, we’ll first learn about matplotlib’s `imshow()` function.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你的挑战是编写一个程序来绘制*曼德尔布罗集*——这是应用简单规则形成复杂形状的另一个例子（请参见[图 6-14](ch06.html#ch6fig14)）。不过，在我讲解具体步骤之前，我们先了解一下
    matplotlib 的 `imshow()` 函数。
- en: '![image](images/f06-14.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f06-14.jpg)'
- en: '*Figure 6-14: Mandelbrot set in the plane between (–2.5, –1.0) and (1.0, 1.0)*'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-14：曼德尔布罗集，平面范围为 (–2.5, –1.0) 到 (1.0, 1.0)*'
- en: '**The imshow() Function**'
  id: totrans-156
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**imshow() 函数**'
- en: The `imshow()` function is usually used to display an external image, such as
    a JPEG or PNG image. You can see an example at *[http://matplotlib.org/users/image_tutorial.html](http://matplotlib.org/users/image_tutorial.html)*.
    Here, however, we’ll use the function to draw a new image of our own creation
    via matplotlib.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`imshow()` 函数通常用于显示外部图像，如 JPEG 或 PNG 图像。你可以查看[http://matplotlib.org/users/image_tutorial.html](http://matplotlib.org/users/image_tutorial.html)上的示例。不过，在这里，我们将使用这个函数通过
    matplotlib 绘制我们自己创建的新图像。'
- en: 'Consider the part of the Cartesian plane where *x* and *y* both range from
    0 to 5\. Now, consider six equidistant points along each axis: (0, 1, 2, 3, 4,
    5) along the *x*-axis and the same set of points along the *y*-axis. If we take
    the Cartesian product of these points, we get 36 equally spaced points in the
    *x*-*y* plane with the coordinates (0, 0), (0, 1) ... (0, 5), (1, 0), (1, 1) ...
    (1, 5) ... (5, 5). Let’s now say that we want to color each of these points with
    a shade of gray—that is, some of these points will be black, some will be white,
    and others will be colored with a shade in between, randomly chosen. [Figure 6-15](ch06.html#ch6fig15)
    illustrates the scenario.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑笛卡尔平面中 *x* 和 *y* 均在 0 到 5 之间的部分。现在，考虑在每个轴上六个等距的点：（0, 1, 2, 3, 4, 5）沿 *x*-轴分布，沿
    *y*-轴同样分布一组相同的点。如果我们将这些点的笛卡尔积考虑进去，我们会得到 36 个等距的点，坐标为 (0, 0)、(0, 1) … (0, 5)、(1,
    0)、(1, 1) … (1, 5) … (5, 5)。现在，假设我们想为这些点中的每一个着上灰色的阴影——也就是说，其中一些点将是黑色的，有些是白色的，其他的将随机选择一个中间的灰色阴影。[图
    6-15](ch06.html#ch6fig15)展示了这个情形。
- en: '![image](images/f06-15.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f06-15.jpg)'
- en: '*Figure 6-15: Part of the* x-y *plane with* x *and* y *both ranging from 0
    to 5\. We’ve considered 36 points in the region equidistant from each other and
    colored each with a shade of gray.*'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-15：部分* x-y *平面，* x *和* y *的范围均为 0 到 5。我们在该区域内考虑了 36 个等距的点，并为每个点着上了不同深浅的灰色。*'
- en: To create this figure, we have to make a list of six lists. Each of these six
    lists will in turn consist of six integers ranging from 0 to 10\. Each number
    will correspond to the color for each point, 0 standing for black and 10 standing
    for white. We’ll then pass this list to the `imshow()` function along with other
    necessary arguments.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建这个图形，我们必须创建一个由六个列表组成的列表。这六个列表中的每一个将包含六个整数，范围从 0 到 10。每个数字代表一个点的颜色，0 代表黑色，10
    代表白色。然后我们将这个列表传递给 `imshow()` 函数，并附上其他必要的参数。
- en: '**Creating a List of Lists**'
  id: totrans-162
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**创建一个列表的列表**'
- en: 'A list can also contain lists as its members:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 一个列表也可以包含其他列表作为其成员：
- en: '[PRE10]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here, we created a list, `l`, consisting of two lists, `l1` and `l2`. The first
    element of the list, `l[0]`, is thus the same as the `l1` list and the second
    element of the list, `l[1]`, is the same as the `l2` list:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个列表 `l`，它由两个列表 `l1` 和 `l2` 组成。列表的第一个元素 `l[0]` 就是 `l1` 列表，而列表的第二个元素
    `l[1]` 就是 `l2` 列表：
- en: '[PRE11]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: To refer to an individual element within one of the member lists, we have to
    specify two indices—`l[0][1]` refers to the second element of the first list,
    `l[1][2]` refers to the third element of the second list, and so on.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 若要引用其中一个成员列表中的单个元素，我们必须指定两个索引——`l[0][1]` 指的是第一个列表中的第二个元素，`l[1][2]` 指的是第二个列表中的第三个元素，以此类推。
- en: 'Now that we know how to work with a list of lists, we can write the program
    to create a figure similar to [Figure 6-15](ch06.html#ch6fig15):'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何处理列表的列表，我们可以编写程序来创建一个类似于[图6-15](ch06.html#ch6fig15)的图形：
- en: '[PRE12]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `initialize_image()` function at ➊ creates a list of lists with each of
    the elements initialized to 0\. It accepts two arguments, `x_p` and `y_p`, which
    correspond to the number of points along the *x*-axis and *y*-axis, respectively.
    This effectively means that the initialized list image will consist of `x_p` lists
    with each list containing `y_p` zeros.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，`initialize_image()`函数创建了一个元素都初始化为0的列表列表。它接受两个参数，`x_p`和`y_p`，分别对应于* x *轴和*
    y *轴上的点数。这实际上意味着初始化后的列表`image`将由`x_p`个列表组成，每个列表包含`y_p`个零。
- en: In the `color_points()` function, once you have the image list back from `initialize_image()`,
    assign a random integer between 0 and 10 to the element `image[i][j]` at ➋. When
    we assign this random integer to the element, we are assigning a color to the
    point in the Cartesian plane that’s *i* steps along the *y*-axis and *j* steps
    along the *x*-axis from the origin. It’s important to note that the `imshow()`
    function automatically deduces the color of a point from its position in the `image`
    list and doesn’t care about its specific *x*- and *y*-coordinates.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在`color_points()`函数中，一旦你从`initialize_image()`获取到图像列表，就将一个介于0和10之间的随机整数赋值给➋处的元素`image[i][j]`。当我们将这个随机整数赋给元素时，我们实际上是将一个颜色分配给笛卡尔平面中距离原点*
    i *步沿* y *轴和* j *步沿* x *轴的点。需要注意的是，`imshow()`函数会根据点在`image`列表中的位置自动推断该点的颜色，而不关心其具体的*
    x *和* y *坐标。
- en: Then, call the `imshow()` function at ➌, passing `image` as the first argument.
    The keyword argument `origin='lower'` specifies that the number in `image[0][0]`
    corresponds to the color of the point (0, 0). The keyword argument `extent=(0,
    5, 0, 5)` sets the lower-left and upper-right corners of the image to (0, 0) and
    (5, 5), respectively. The keyword argument `cmap=cm.Greys_r` specifies that we’re
    going to create a grayscale image.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在➌处调用`imshow()`函数，将`image`作为第一个参数传入。关键字参数`origin='lower'`指定`image[0][0]`中的数字对应点（0,
    0）的颜色。关键字参数`extent=(0, 5, 0, 5)`将图像的左下角和右上角分别设置为(0, 0)和(5, 5)。关键字参数`cmap=cm.Greys_r`指定我们将创建一张灰度图像。
- en: The last keyword argument, `interpolation='nearest'`, specifies that matplotlib
    should color a point for which the color wasn’t specified with the same color
    as the one nearest to it. What does this mean? Note that we consider and specify
    the color for only 36 points in the region (0, 5) and (5, 5). Because there is
    an infinite number of points in this region, we tell matplotlib to set the color
    of an unspecified point to that of its nearest point. This is the reason you see
    color “boxes” around each point in the figure.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的关键字参数`interpolation='nearest'`指定matplotlib应该为那些没有指定颜色的点着上与其最近的点相同的颜色。这是什么意思呢？请注意，我们只考虑并为区域(0,
    5)和(5, 5)中的36个点指定了颜色。因为该区域中有无限多个点，所以我们告诉matplotlib将没有指定颜色的点设置为与其最近的点相同的颜色。这就是你在图形中看到每个点周围出现“颜色框”的原因。
- en: Call the `colorbar()` function to display a color bar in the figure showing
    which integer corresponds to which color. Finally, call `show()` to display the
    image. Note that due to the use of the `random.randint()` function, your image
    will be colored differently than the one in [Figure 6-15](ch06.html#ch6fig15).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`colorbar()`函数在图形中显示一个颜色条，显示哪个整数对应哪个颜色。最后，调用`show()`来展示图像。请注意，由于使用了`random.randint()`函数，你的图像将与[图6-15](ch06.html#ch6fig15)中的图像有所不同。
- en: If you increase the number of points along each axis by setting `x_p` and `y_p`
    to, let’s say, `20` in `color_points()`, you’ll see a figure similar to the one
    shown in [Figure 6-16](ch06.html#ch6fig16). Note that the color boxes grow smaller
    in size. If you increase the number of points even more, you’ll see the size of
    the boxes shrink further, giving the illusion that each point has a different
    color.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你通过将`color_points()`中的`x_p`和`y_p`设为，比如说`20`，增加每个轴上的点的数量，你会看到类似于[图6-16](ch06.html#ch6fig16)的图形。请注意，颜色框的大小变小了。如果你继续增加点的数量，你会看到框的大小进一步缩小，从而产生每个点颜色不同的错觉。
- en: '![image](images/f06-16.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f06-16.jpg)'
- en: '*Figure 6-16: Part of the* x-y *plane with* x *and* y *both ranging from 0
    to 5\. We’ve considered 400 points in the region equidistant from each other and
    colored each with a shade of gray.*'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-16：部分* x-y *平面，其中* x *和* y *都从0到5。我们考虑了该区域中等距离的400个点，并为每个点着上了一种灰色阴影。*'
- en: '**Drawing the Mandelbrot Set**'
  id: totrans-178
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**绘制曼德尔布罗集**'
- en: We’ll consider the area of the *x*-*y* plane between (–2.5, –1.0) and (1.0,
    1.0) and divide each axis into 400 equally spaced points. The Cartesian product
    of these points will give us 1,600 equally spaced points in this region. We’ll
    refer to these points as (*x*[1], *y*[1]), (*x*[1], *y*[2]) ... (*x*[400], *y*[400]).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将考虑* x*–* y*平面中(–2.5, –1.0)和(1.0, 1.0)之间的区域，并将每个轴划分为400个均匀间隔的点。这些点的笛卡尔积将给我们1,600个均匀分布的点。我们将这些点称为(*x*[1],
    *y*[1])，(*x*[1], *y*[2]) ... (*x*[400], *y*[400])。
- en: 'Create a list, `image`, by calling the `initialize_image()` function we saw
    earlier with both `x_p` and `y_p` set to 400\. Then, follow these steps for *each*
    of the generated points (*x[i]*, *y[k]*):'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用我们之前看到的`initialize_image()`函数并将`x_p`和`y_p`都设置为400来创建一个列表`image`。然后，按照以下步骤处理*每个*生成的点（*x[i]*，*y[k]*）：
- en: 1\. First, create two complex numbers, *z*[1] = 0 + 0*j* and *c* = *x[i]* +
    *y[k] j*. (Recall that we use *j* for ![image](images/e0176-01.jpg).)
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 首先，创建两个复数，*z*[1] = 0 + 0*j* 和 *c* = *x[i]* + *y[k] j*。（请记住，我们用*j*表示![image](images/e0176-01.jpg)。）
- en: 2\. Create a label iteration and set it to 0—that is, `iteration=0`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 创建一个标签`iteration`并将其设置为0——即`iteration=0`。
- en: 3\. Create a complex number, ![image](images/e0176-02.jpg).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 创建一个复数，![image](images/e0176-02.jpg)。
- en: 4\. Increment the value stored in `iteration` by 1—that is, `iteration = iteration
    + 1`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 4\. 将`iteration`中的值加1——即`iteration = iteration + 1`。
- en: 5\. If `abs(z1) < 2` and `iteration < max_iteration`, then go back to step 3;
    otherwise, go to step 6\. The larger the value of `max_iteration`, the more detailed
    the image, but the longer it’ll take to create the image. Set `max_iteration`
    to 1,000 here.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 5\. 如果`abs(z1) < 2`并且`iteration < max_iteration`，则返回第3步；否则，继续到第6步。`max_iteration`的值越大，图像越详细，但生成图像所需的时间也会更长。这里将`max_iteration`设置为1,000。
- en: 6\. Set the color of the point (*x[i]*, *y[k]*) to the value in `iteration`—that
    is, `image[k][i] = iteration`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 6\. 将点(*x[i]*，*y[k]*)的颜色设置为`iteration`中的值——即`image[k][i] = iteration`。
- en: Once you have the complete `image` list, call the `imshow()` function with the
    `extent` keyword argument changed to indicate the region bounded by (–2.5, –1.0)
    and (1.0, 1.0).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你完成了整个`image`列表，调用`imshow()`函数，并将`extent`关键字参数修改为表示由(–2.5, –1.0)和(1.0, 1.0)所界定的区域。
- en: This algorithm is usually referred to as the *escape-time algorithm*. When the
    maximum number of iterations is reached before a point’s magnitude exceeds 2,
    that point belongs to the Mandelbrot set and is colored white. The points that
    exceed the magnitude within fewer iterations are said to “escape”; they don’t
    belong to the Mandelbrot set and are colored black. You can experiment by decreasing
    and increasing the number of points along each axis. Decreasing the number of
    points will lead to a grainy image, while increasing them will result in a more
    detailed image.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法通常被称为*逃逸时间算法*。当一个点的幅值在达到最大迭代次数之前没有超过2时，该点属于曼德尔布罗集，并被涂成白色。那些在较少迭代次数内幅值超过2的点被称为“逃逸”；它们不属于曼德尔布罗集，并被涂成黑色。你可以通过减少或增加每个轴上的点的数量来进行实验。减少点的数量会导致图像出现颗粒感，而增加点的数量则会生成更详细的图像。
