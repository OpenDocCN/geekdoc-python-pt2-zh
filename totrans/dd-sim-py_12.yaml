- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Collections and Iteration
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: Looping through an array is one of the most elementary algorithms in programming.
    Often, it’s one of the first things a new developer does after “Hello, world!”
    The very principle of starting indices at zero was probably the first paradigm
    shift you encountered while learning to code. Yet, this is Python; loops and containers
    here operate on a whole different level.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I’ll cover Python loops and then explore the various collections
    Python offers for storing and organizing data. Next, I’ll define the concepts
    of iterables and iterators and start putting them to work in the context of loops.
    Then, I’ll provide an overview of several iteration tools. Finally, I’ll implement
    my own iterable class.
  prefs: []
  type: TYPE_NORMAL
- en: Grab a mug of your favorite beverage, and let’s go!
  prefs: []
  type: TYPE_NORMAL
- en: Loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python has two types of loops: `while` and `for`. As you’ll see in this chapter,
    they are not meant to be interchangeable. Rather each has unique purposes.'
  prefs: []
  type: TYPE_NORMAL
- en: while Loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `while` loop is the most traditional of the loops. As long as the expression
    in its header evaluates to `True`, the suite of the loop is executed. For example,
    the following loop keeps prompting the user to enter a valid number until they
    do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-1: *get_number.py:1a*'
  prefs: []
  type: TYPE_NORMAL
- en: As long as the value of `number` is `None`, the suite of the `while` loop keeps
    repeating. I request input from the user with `input()` and attempt to convert
    it to an integer with `int()`. However, if the user has typed in anything other
    than a valid integer, a `ValueError` will be raised, and no new value will be
    assigned to `number`. Thus, the loop will repeat.
  prefs: []
  type: TYPE_NORMAL
- en: As soon as the user enters a valid integer, the loop exits and the number is
    printed to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example output of this program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If I want to provide a mechanism for quitting instead of entering a number,
    I could use the `break` keyword to exit the loop manually. Here, I allow the user
    to quit by entering a *q* instead of a number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-2: *get_number.py:1b*'
  prefs: []
  type: TYPE_NORMAL
- en: I get the raw input first and check for the string value `'q'`. If I find it,
    I escape the loop manually with `break`. Otherwise, I attempt to convert the input
    to an integer as before.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one problem with this approach, as seen in the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The last line of output isn’t right. I want the program to quit right away instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix this, I use a little-known feature of loops in Python: the `else` clause.
    When a Python loop finishes normally, the `else` suite is run; however, it is
    *not* run if the loop is aborted with a `break`, `return`, or raised exception.'
  prefs: []
  type: TYPE_NORMAL
- en: 'By moving my final print statement to the `else` clause of the loop, I ensure
    it only runs if a valid number is entered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-3: *get_number.py:1c*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Running this code demonstrates the new behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Upon encountering a *q*, the loop exits immediately, without executing the last
    `print()` statement.
  prefs: []
  type: TYPE_NORMAL
- en: for Loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the majority of this chapter, I’ll focus on the mechanics of the `for` loop.
    For now, it will suffice for you to understand that the purpose of a `for` loop
    is to traverse through, or *iterate over*, a collection of values.
  prefs: []
  type: TYPE_NORMAL
- en: Like `while`, the `for` loop has an `else` clause that is only executed when
    the loop finishes normally, and not when it is manually aborted with `break`,
    `return`, or a raised exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simplistic example will be enough for now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-4: *print_list.py*'
  prefs: []
  type: TYPE_NORMAL
- en: I define a list of strings, which I assign to `numbers`. Then, I loop through
    each value in `numbers` and print each out to the terminal. When I’m done, I announce
    that fact with another message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: For the rest of this chapter, I’ll unpack everything happening behind the scenes
    here, which is surprisingly vast. You will learn how to utilize iteration to its
    fullest potential in your code.
  prefs: []
  type: TYPE_NORMAL
- en: Collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A *collection* is a container object containing one or more *items* organized
    in some fashion. Each item is bound to a value; the values themselves are not
    contained within the collection object. There are five fundamental types of collections
    in Python, each with multiple variations: `tuple`, `list`, `deque`, `set`, and
    `dict` (dictionary).'
  prefs: []
  type: TYPE_NORMAL
- en: Once you understand how each collection behaves, using collections effectively
    is simply a matter of memorizing their methods; in lieu of that, most Python developers
    rely on the documentation. In a pinch, you can also run `help(``collection``)`
    in a Python interactive shell, where `collection` is the collection you want more
    information about.
  prefs: []
  type: TYPE_NORMAL
- en: Tuples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you know from Chapter 3 and the usages since, a *tuple* is a *sequence* (an
    array-like collection) that is *immutable*, meaning that once it is created, its
    items cannot be added, removed, or reordered.
  prefs: []
  type: TYPE_NORMAL
- en: 'Conventionally, tuples are used for heterogeneously typed, sequentially ordered
    data, such as when you need to keep different but associated values together.
    For example, here’s a tuple containing a customer name, a coffee order, and an
    order size, in ounces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-5: *order_tuple.py:1*'
  prefs: []
  type: TYPE_NORMAL
- en: You define a tuple as a comma-separated sequence of values, enclosed in parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the contents of a tuple are *ordered*, you can access individual items
    by index, or *subscript*, specified in square brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-6: *order_tuple.py:2*'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need a tuple with a single item, leave a trailing comma after the item,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This is primarily useful when one of your functions is expected to return a
    tuple, but you don’t know in advance how many elements you’ll need to return in
    that tuple.
  prefs: []
  type: TYPE_NORMAL
- en: Since tuples are immutable, they don’t offer any built-in methods for adding,
    changing, or removing items. You define a tuple once, in its entirety, up front,
    and then you access the items it contains.
  prefs: []
  type: TYPE_NORMAL
- en: Named Tuples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `collections` module provides a strange little variant of the tuple called
    the *named tuple*, which allows you to define a tuple-like collection with named
    fields. Like a normal tuple, a named tuple is an immutable collection. Its primary
    use is adding keys to the values, while still retaining its subscriptable behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-7: *coffeeorder_namedtuple.py*'
  prefs: []
  type: TYPE_NORMAL
- en: 'I define a new `namedtuple` with the type name `CoffeeOrder` ❶, which I also
    bind to the name `CoffeeOrder`. I name three fields in that named tuple: `item`,
    `addons`, and `to_go` ❷.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, I create a new instance of the named tuple by passing the values to the
    `CoffeeOrder` initializer, and I bind the instance to `order`. I can access the
    values within `order` by field name ❸ or by subscript ❹.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, most Pythonistas prefer dictionaries or classes to named tuples,
    but all three have their place.
  prefs: []
  type: TYPE_NORMAL
- en: Lists
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Lists* are sequence collections that are *mutable*, meaning items can be added,
    removed, and reordered. Conventionally, lists are used for homogeneously typed,
    sequentially ordered data, such as this list of specials at the fictional Uncomment
    Café:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-8: *specials_list.py:1*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You define a list as a comma-separated sequence, enclosed in square brackets.
    As with tuples, you can access individual items via their index, specified in
    square brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-9: *specials_list.py:2*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use lists as arrays, stacks, or queues. Here are a few of the most
    commonly used methods on `list`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-10: *specials_list.py:3*'
  prefs: []
  type: TYPE_NORMAL
- en: I use `pop()` to return and remove items from the list. If I don’t pass an index
    to `pop()`, the last item is removed by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'If I pass an index as an argument to `pop()`, the indicated item is removed
    instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-11: *specials_list.py:4*'
  prefs: []
  type: TYPE_NORMAL
- en: 'I can also add new items to the end of the list, using `append()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-12: *specials_list.py:5*'
  prefs: []
  type: TYPE_NORMAL
- en: The new item, `"cold brew"`, is passed to `append()`, and it is added at the
    end of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'If I want to add an item somewhere else in the list, I can use `insert()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-13: *specials_list.py:6*'
  prefs: []
  type: TYPE_NORMAL
- en: The first argument is a target index, `1`, and the new item, `"americano"`,
    is the second argument.
  prefs: []
  type: TYPE_NORMAL
- en: These are the three most common methods for modifying lists. Python has more,
    many of which are quite interesting. As I’ve mentioned, the official documentation
    is your best resource for learning all the available methods.
  prefs: []
  type: TYPE_NORMAL
- en: Deques
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `collections` module provides another sequence, *deque* (pronounced “deck”),
    which is optimized for accessing the first and last items. This makes it a good
    option to use as a stack or queue when performance especially matters.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, I’ll use `deque` to track the people waiting in line at the
    Uncomment Café:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-14: *customers_deque.py:1*'
  prefs: []
  type: TYPE_NORMAL
- en: After I import `deque` from `collections`, I create a new `deque`, which I bind
    to `customers`. I pass a list of two customers as the list’s initial value, although
    I could have omitted this and started with an empty deque instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Simon enters the café and gets in line, so I add him to the end of the `deque`
    with `append()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-15: *customers_deque.py:2*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, the barista helps the next person in line, so I return and remove the
    first customer, Daniel, from the front (“left”) of the line, using `popleft()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-16: *customers_deque.py:3*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are once again two people in line. James slips in front of everyone else
    (how rude!), so I append him to the “left” of the `deque` with `appendleft()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-17: *customers_deque.py:4*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But that’s okay by Simon, because the last person in line wins a free drink.
    I return and remove the last item from the deque:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-18: *customers_deque.py:5*'
  prefs: []
  type: TYPE_NORMAL
- en: 'After all this, the deque only has James and Denis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-19: *customers_deque.py:6*'
  prefs: []
  type: TYPE_NORMAL
- en: Sets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *set* is a built-in, mutable, *unordered* collection, in which all items are
    guaranteed to be unique. If you try to add an item that already exists in the
    set, the new duplicate will be discarded. You’ll primarily use a set for fast
    inclusion checks and various operations relating to set theory (math), especially
    in large data sets.
  prefs: []
  type: TYPE_NORMAL
- en: Every value stored in a set must be *hashable*, which the Python documentation
    defines as having “a hash value that never changes during its lifetime.” Hashable
    objects implement the special method `__hash__()`. All the built-in immutable
    types are hashable, since they never change value throughout their lifetime. However,
    many mutable types are not hashable.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll use a set to run a raffle at the Uncomment Café, where each customer can
    only enter once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-20: *raffle_set.py:1*'
  prefs: []
  type: TYPE_NORMAL
- en: I first define the set as a comma-separated sequence of values, surrounded by
    curly braces (`{}`). In this case, I provide three initial values.
  prefs: []
  type: TYPE_NORMAL
- en: 'As customers come in, I add their names to the set with `add()`. If their name
    is already in the set, such as in the case of Denis, it won’t be added another
    time if I try to add it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-21: *raffle_set.py:2*'
  prefs: []
  type: TYPE_NORMAL
- en: The `print` statement shows the current items in the set. Just remember that
    sets are *unordered*, so there is no guarantee of the order in which the items
    will appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'I can remove items from the set using `discard()`. Since Simon won something
    earlier, I’ll remove his name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-22: *raffle_set.py:3*'
  prefs: []
  type: TYPE_NORMAL
- en: I could have also used `remove()` to remove a value, but that raises a `KeyError`
    if the specified value is not in the set; `discard()` never raises an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, I return and remove an arbitrary item from the set with `pop()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-23: *raffle_set.py:4*'
  prefs: []
  type: TYPE_NORMAL
- en: Be aware, *arbitrary* does not mean *random*! The `pop()` method always returns
    and removes whichever item happens to be in the first position in the set. Because
    `set` is unordered and Python makes no guarantees about the internal sequence
    of the items, you cannot trust `set` for reliable randomness.
  prefs: []
  type: TYPE_NORMAL
- en: frozenset
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The immutable twin to `set` is `frozenset`, which works in much the same manner.
    They differ in the same way that `list` and `tuple` do: once created, a `frozenset`
    cannot have items added or removed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate this, I’ll create a `frozenset` for storing all previous prizewinners
    and use that as part of the next raffle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-24: *raffle_frozenset.py:1*'
  prefs: []
  type: TYPE_NORMAL
- en: A `frozenset` is specified by passing a set literal (shown here), an existing
    set, or another linear collection to the `frozenset()` initializer. After I initially
    define `prev_winners`, I cannot change the contents of the `frozenset`—it’s immutable.
    The regular set, `raffle`, can still be modified.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most exciting features of `set` and `frozenset` is that they both
    support *set mathematics*. You can use math and logic operators for finding the
    union (`|`), intersection (`&`), difference (`-`), and symmetric difference (`^`).
    It’s also useful for testing if one set is a subset (`<` or `<=`) or superset
    (`>` or `>=`) of the other. The documentation also outlines several other functions
    for combining and comparing sets of either type.
  prefs: []
  type: TYPE_NORMAL
- en: 'In my example, I’ll remove all the previous winners (`prev_winners`) from the
    `raffle` set using the `-=` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-25: *raffle_frozenset.py:2*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then I can `pop()` an arbitrary item off of `raffle` to find my winner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-26: *raffle_frozenset.py:3*'
  prefs: []
  type: TYPE_NORMAL
- en: Yay for Kyle! He wins a three-day, one-night trip to Antarctica, courtesy of
    Frozen Set Airlines. (Bundle up, buddy.)
  prefs: []
  type: TYPE_NORMAL
- en: Dictionaries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *dictionary* (type `dict`) is a mutable collection that stores data in *key-value*
    pairs, instead of in linear fashion. This associative manner of storage is known
    as *mapping*. Keys can be virtually any type, as long as that type is hashable.
    It’s easiest to remember that hashable types are virtually always immutable.
  prefs: []
  type: TYPE_NORMAL
- en: The value in the pair can be anything. Looking up a value by key is particularly
    fast, regardless of the amount of data in the dictionary. (In other languages,
    this type of collection is referred to as a *hashmap*; in CPython, the dictionary
    is implemented as a hash table.)
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll use a dictionary to store the menu at the Uncomment Café:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-27: *menu_dict.py:1*'
  prefs: []
  type: TYPE_NORMAL
- en: I create the dictionary as a sequence of comma-separated key-value pairs, wrapped
    in curly braces, with a colon (`:`) separating the key and value in each pair.
    In this case, the key is a string that is the name of the drink, and the value
    is a floating-point number representing the price.
  prefs: []
  type: TYPE_NORMAL
- en: 'I access individual items by key, specified in square brackets (`[ ]`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-28: *menu_dict.py:2*'
  prefs: []
  type: TYPE_NORMAL
- en: If the key being accessed is not in the dictionary, a `KeyError` is raised.
  prefs: []
  type: TYPE_NORMAL
- en: 'I can add or modify items by assigning a value to a key specified in square
    brackets. Here, I’ll add the `"americano"` key to the menu, with a price value
    of `2.49`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-29: *menu_dict.py:3*'
  prefs: []
  type: TYPE_NORMAL
- en: 'For whatever reason, the Americano isn’t terribly popular at the café, so I
    wind up removing it from the dictionary, using the `del` operator on the key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-30: *menu_dict.py:4*'
  prefs: []
  type: TYPE_NORMAL
- en: Once again, if the key specified in the square brackets were not in the dictionary,
    a `KeyError` would be raised.
  prefs: []
  type: TYPE_NORMAL
- en: Check or Except?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There’s a bit of debate about whether one should check for a key in a dictionary
    directly with the `in` operator or use a `try` statement with a `KeyError` instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the EAFP (“Easier to Ask Forgiveness than Permission”) approach, using
    `try`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-31: *checkout_dict_eafp.py*'
  prefs: []
  type: TYPE_NORMAL
- en: Within a `try` statement, I try to access the value in the dictionary `menu`
    associated with the key `order` ❶. If the key is invalid, a `KeyError` will be
    raised and I will catch it in the `except` clause. I can then take the appropriate
    action.
  prefs: []
  type: TYPE_NORMAL
- en: This approach is better suited to instances where invalid keys are an *exceptional*
    situation (thus, “exceptions”). Typically, an `except` clause is a more expensive
    operation in terms of performance, but it’s an expense that is completely justified
    for handling errors and other exceptional situations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the LBYL (“Look Before You Leap”) approach, using the `in` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-32: *checkout_dict_lbyl.py*'
  prefs: []
  type: TYPE_NORMAL
- en: In this approach, I check whether `order` is a key in the `menu` dictionary
    before I do anything ❶. If it’s there, I can safely access the value associated
    with the key ❷. This approach may be preferable if you expect to frequently check
    for invalid keys, since either outcome is reasonably likely. Failure is more the
    *rule* than the *exception*, so it’s better for both scenarios to have roughly
    the same performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The LBYL approach is generally frowned upon when an invalid key is an exceptional
    situation, because it has to look in the dictionary for a valid key twice: once
    when checking and once when accessing. By contrast, the EAFP approach only has
    to access a valid key once, since it handles the possible `KeyError`.'
  prefs: []
  type: TYPE_NORMAL
- en: As with all issues of performance, you can’t know for sure until you profile
    the code. You can rely on the assumptions herein, unless you specifically need
    the logic structure of one approach or the other. However, if performance is critical,
    profile the code (see Chapter 19).
  prefs: []
  type: TYPE_NORMAL
- en: Dictionary Variants
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Python has a `collections` module that offers a few variations on the built-in
    `dict`. Here are the three most common variations, along with their unique behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '`defaultdict` allows you to specify a callable that produces a default value.
    If you attempt to access the value on an undefined key, a new key-value pair will
    be defined, using this default value.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`OrderedDict` has extra functionality for tracking and managing the order of
    key-value pairs. Since Python 3.7, the built-in `dict` also officially preserves
    insertion order, but `OrderedDict` is specifically *optimized* for reordering
    and has additional behaviors for it.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Counter` is designed specifically for counting hashable objects; the object
    is the key, and the count is an integer value. Other languages call this type
    of collection a *multiset*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should only use one of these specialized dictionary types if you actually
    need its behavior, so I won’t go into more detail here. Each is optimized for
    a specific use case and is not likely to have optimal performance in other scenarios.
    The official documentation is your best bet if you need further details: [https://docs.python.org/3/library/collections.xhtml](https://docs.python.org/3/library/collections.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: Unpacking Collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All collections can be *unpacked* into multiple variables, meaning each item
    is assigned to its own name. For example, I can unpack a deque of three customers
    into three separate variables. I first create the deque of customers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-33: *unpack_customers.py:1a*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, to unpack the deque. I place a comma-separated list of names to unpack
    into, in order, on the left side of an assignment operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-34: *unpack_customers.py:2a*'
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, you’ll see this left-hand part wrapped in parentheses, but using
    parentheses isn’t required when unpacking a linear collection like this. (I’ll
    demonstrate where parentheses fit into unpacking a dictionary in the next section.)
    I place the collection I’m unpacking on the right side of the assignment operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one major limitation to unpacking: you have to know how many values
    you’re unpacking! To demonstrate this, I’ll go back and add one more customer
    to the deque with the `append()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-35: *unpack_customers.py:1b*'
  prefs: []
  type: TYPE_NORMAL
- en: 'If I were to specify too many or too few names on the left, a `ValueError`
    would be raised. Since my deque contains four values, trying to unpack into three
    names fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-36: *unpack_customers.py:2b*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix this, I could specify a fourth name on the left. However, for this example,
    I want to ignore the fourth value. I can ignore any item by unpacking it into
    an underscore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-37: *unpack_customers.py:2c*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The underscore (`_`), when used as a name, conventionally indicates that the
    value should be ignored. I can use the underscore as many times as I need, such
    as if I want to ignore the last two values in the collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-38: *unpack_customers.py:2d*'
  prefs: []
  type: TYPE_NORMAL
- en: Only the first two values in `customers` will be unpacked, and the second two
    will be effectively ignored.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the way, if you ever need to unpack a collection that only contains one
    value, leave a trailing comma after the name you’re unpacking into:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Starred Expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you have no idea how many additional values there are in the collection,
    you can capture multiple unpacked values using a *starred expression*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-39: *unpack_customers.py:2e*'
  prefs: []
  type: TYPE_NORMAL
- en: The first two values are unpacked into `first` and `second`, and the remainder
    (if any) are packed into a list assigned to `rest`. As long as the collection
    being unpacked has at least two values, one for each of the nonstarred names on
    the left, this will work. If there are only two values in the collection, `rest`
    will be an empty list.
  prefs: []
  type: TYPE_NORMAL
- en: You can use starred expressions anywhere in the unpacking list, including the
    beginning. Here’s an example where I unpack the `first` and `last` values individually
    and pack all the rest into a list named `middle:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-40: *unpack_customers.py:3*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even use starred expressions to ignore multiple values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-41: *unpack_customers.py:4*'
  prefs: []
  type: TYPE_NORMAL
- en: By preceding the underscore with an asterisk, I capture multiple values but
    ignore them, instead of packing them into a list. In this scenario, I unpack the
    last two values in the collection.
  prefs: []
  type: TYPE_NORMAL
- en: You can only have one starred expression per unpacking statement, because starred
    expressions are *greedy*—consuming as many values as they’re allowed. Python unpacks
    values into all the other names before evaluating the starred expression. Using
    multiple starred expressions in the same statement makes no sense, since it’s
    impossible to tell where one stops and another starts.
  prefs: []
  type: TYPE_NORMAL
- en: Unpacking Dictionaries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Dictionaries can be unpacked like any other built-in type of collection. By
    default, only the keys are unpacked, as seen when I unpack the dictionary representing
    the café menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'I start by defining my dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-42: *unpack_menu.py:1*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, I unpack the dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-43: *unpack_menu.py:2a*'
  prefs: []
  type: TYPE_NORMAL
- en: 'If I want the values instead, I must unpack using a *dictionary view*, which
    provides access to the keys and/or values in a dictionary. In this case, I use
    the `values()` dictionary view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-44: *unpack_menu.py:2b*'
  prefs: []
  type: TYPE_NORMAL
- en: 'I can unpack the keys and values together by unpacking from the `items()` dictionary
    view. This returns each key-value pair as a tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-45: *unpack_menu.py:2c*'
  prefs: []
  type: TYPE_NORMAL
- en: 'I can also unpack each of the key-value tuples in the same statement by using
    parentheses around a pair of names a tuple will be unpacked into:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-46: *unpack_menu.py:3*'
  prefs: []
  type: TYPE_NORMAL
- en: For brevity, I chose to only unpack the first two items in the `menu` dictionary
    and ignore the rest. I unpack the first tuple from `menu.items()` into the pair
    `(a_name, a_price)`, so the first item of the tuple is stored in `a_name` and
    the second item is stored in `a_price`. The same thing happens with the second
    key-value pair in the dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: You can use this unpacking strategy with parentheses to unpack two-dimensional
    collections, such as a list of tuples or a tuple of sets.
  prefs: []
  type: TYPE_NORMAL
- en: Structural Pattern Matching on Collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Starting from Python 3.10, it is possible to perform structural pattern matching
    on tuples, lists, and dictionaries.
  prefs: []
  type: TYPE_NORMAL
- en: 'In patterns, tuples and lists are interchangeable. They are both matched against
    sequence patterns*. Sequence patterns* use the same syntax as unpacking, including
    the ability to use starred expressions. For example, I could match on the first
    and last elements of a sequence and ignore everything in the middle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-47: *match_coffee_sequence.py*'
  prefs: []
  type: TYPE_NORMAL
- en: Sequence patterns are the same, whether enclosed in parentheses or square brackets.
    The list `order` is compared against each pattern. For each, the first and last
    items are checked, and the rest of the items are captured via wildcard as `drink`.
    Within each case, I join together the elements in `drink` to determine what to
    fill the chosen vessel with.
  prefs: []
  type: TYPE_NORMAL
- en: 'I could also pattern match against specific values in a dictionary, using a
    *mapping pattern*. Here’s almost the same example, reworked to used a dictionary
    instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-48: *match_coffee_dictionary.py:1a*'
  prefs: []
  type: TYPE_NORMAL
- en: Mapping patterns are wrapped in curly braces. Only the keys I specify in the
    pattern are checked, while any other keys are ignored. In this version, I check
    the `'size'` and `'serve'` keys, as well as the value associated with the key
    `'drink'`, which I capture as `drink`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run this version of the code, versus the previous one, you’ll notice
    that I’m leaving the `''notes''` off (for example, `''no whip''`). To fix that,
    I could capture all remaining keys via wildcard instead, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-49: *match_coffee_dictionary.py:1b*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Although I chose to demonstrate capturing with a wildcard in a mapping pattern,
    it is worth noting that I can still directly access the subject, `order`, from
    within any of the cases. In this particular example, I could have just as easily
    written the code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-50: *match_coffee_dictionary.py:1c*'
  prefs: []
  type: TYPE_NORMAL
- en: As before, any keys omitted from each mapping pattern are ignored for purposes
    of pattern matching.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing by Index or Key
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Many collections are *subscriptable*, meaning individual items can be accessed
    via an index specified in square brackets. You’ve already seen this with lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-51: *subscript_specials.py:1a*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Subscriptable collection classes implement the special methods `__getitem__()`,
    `__setitem__()`, and `__delitem__()`, where each accepts a single-integer argument.
    You can see this in action by using the special methods directly, instead of the
    square-bracket notation from a moment ago. This code is functionally identical
    to the above:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-52: *subscript_specials.py:1b*'
  prefs: []
  type: TYPE_NORMAL
- en: These same special methods are implemented by the `dict` class, except that
    they accept a *key* as the sole argument. Because dictionaries don’t have a formal
    “index,” they are not considered subscriptable collections.
  prefs: []
  type: TYPE_NORMAL
- en: Slice Notation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Slice notation* allows you to access specific items or ranges of items in
    a list or tuple. Of the five fundamental types of collections, only `tuple` and
    `list` can be sliced. Neither `set` nor `dict` is subscriptable, so slice notation
    won’t work on them. While `deque` is subscriptable, it cannot be sliced using
    slice notation, because of how it is implemented.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To take a *slice* of a list or tuple, you use square brackets around the slice
    notation, which generally consists of three parts, separated by colons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The *inclusive* index of the first item you want to include in the slice is
    `start`. The *exclusive* index, `stop`, is *just past* where the slice stops.
    The `step` part allows you to skip over items and even reverse the order.
  prefs: []
  type: TYPE_NORMAL
- en: 'You aren’t required to specify all three arguments, but be mindful of the colons.
    If you want a slice, as opposed to a single element accessed by index, you must
    *always* include the colon separating `start` and `stop`, even if you don’t specify
    one or the other: (`[``start``:``stop``]`, `[``start``:]`, `[:``stop``]`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, if you define `step`, you must precede it with its own colon: (`[:``stop``:``step``]`,
    `[::``step``]`, `[``start``::``step``]`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s rather theoretical, so here are some practical examples, using a list
    of coffee orders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-53: *slice_orders.py:1*'
  prefs: []
  type: TYPE_NORMAL
- en: Start and Stop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By specifying the start and stop for a slice, I can specify a range:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-54: *slice_orders.py:2*'
  prefs: []
  type: TYPE_NORMAL
- en: The slice starts at index `3` and ends just before `6`, so it includes the items
    at indices `3`, `4`, and `5`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61] after_third = orders[4:] print(after_third)  # print [''cappuccino'',
    ''americano'', ''mocha latte''] [PRE62] next_two = orders[:2] print(next_two)  #
    prints [''caramel macchiato'', ''drip''] [PRE63] print(orders[-1])  # prints ''mocha
    latte'' [PRE64] last_three = orders[-3:] print(last_three)  # prints [''cappuccino'',
    ''americano'', ''mocha latte''] [PRE65] last_two_but_one = orders[-3:-1] print(last_two_but_one)  #
    prints [''cappuccino'', ''americano''] [PRE66] every_other = orders[1::2] print(every_other)  #
    prints [''drip'', ''drip'', ''americano''] [PRE67] reverse = orders[::-1] [PRE68]
    every_other_reverse = orders[-2::-2] print(every_other_reverse)  # prints [''americano'',
    ''drip'', ''drip''] [PRE69] three_to_five_reverse = orders[3:6:-1]  # WRONG! Returns
    empty list. print(three_to_five_reverse)            # prints [] [PRE70] three_to_five_reverse
    = orders[**5:2**:-1] print(three_to_five_reverse)  # prints [''americano'', ''cappuccino'',
    ''drip''] [PRE71] order_copy = orders[:] [PRE72] my_slice = slice(3, 5, 2)  #
    same as [3:5:2] print(my_slice) [PRE73] islice(`collection`, `start`, `stop`,
    `step`) [PRE74] from itertools import islice  menu = {''drip'': 1.95, ''cappuccino'':
    2.95, ''americano'': 2.49}  menu = dict(islice( ❶ menu.items(), 0, 3, 2))  # same
    as [0:3:2] print(menu) [PRE75] {''drip'': 1.95, ''americano'': 2.49} [PRE76] orders
    = [     "caramel macchiato",     "drip",     "pumpkin spice latte",     "drip",     "cappuccino",     "americano",     "mocha
    cappuccino", ] [PRE77] if "mocha cappuccino" in orders:     print("open chocolate
    syrup bottle") [PRE78] if "drip" not in orders:     print("shut off percolator")
    [PRE79] customers = [''Glen'', ''Todd'', ''Newman''] print(len(customers))  #
    prints 3 [PRE80] customers = []  if ❶ customers:  # if not empty...     print("There
    are customers.") else:     print("Quiet day.")  print(bool(customers)) [PRE81]
    Quiet day. False [PRE82] orders_per_day = [56, 41, 49, 22, 71, 43, 18] average_orders
    = sum(orders_per_day) // len(orders_per_day) print(average_orders) [PRE83] 42
    [PRE84] specials = ["pumpkin spice latte", "caramel macchiato", "mocha cappuccino"]
    [PRE85] first_iterator = specials.__iter__() second_iterator = specials.__iter__()
    print(type(first_iterator)) [PRE86] <class ''list_iterator''> [PRE87] item = first_iterator.__next__()
    print(item) [PRE88] pumpkin spice latte [PRE89] item = first_iterator.__next__()
    print(item) [PRE90] caramel macchiato [PRE91] item = second_iterator.__next__()
    print(item) [PRE92] pumpkin spice latte [PRE93] item = first_iterator.__next__()
    print(item) [PRE94] mocha cappuccino [PRE95] item = first_iterator.__next__()  #
    raises StopIteration [PRE96] first_iterator = **iter(specials)** second_iterator
    = **iter(specials)** print(type(first_iterator))  # prints <class ''list_iterator''>  item
    = **next(first_iterator)** print(item)                  # prints "pumpkin spice
    latte"  item = **next(first_iterator)** print(item)                  # prints
    "caramel macchiato"  item = **next(second_iterator)** print(item)                  #
    prints "pumpkin spice latte"  item = **next(first_iterator)** print(item)                  #
    prints "mocha cappuccino"  item = **next(first_iterator)**  # raises StopIteration
    [PRE97] specials = ["pumpkin spice latte", "caramel macchiato", "mocha cappuccino"]
    ❶ iterator = iter(specials)  while True:     try:         item = ❷ next(iterator)   ❸
    except StopIteration:         break     else:         print(item) [PRE98] specials
    = ["pumpkin spice latte", "caramel macchiato", "mocha cappuccino"]  for item in
    specials:     print(item) [PRE99] customers = [''Newman'', ''Daniel'', ''Simon'',
    ''James'', ''William'',              ''Kyle'', ''Jason'', ''Devin'', ''Todd'',
    ''Glen'', ''Denis'']  for customer in customers:     # Take order     # Make drink     print(f"Order
    for { ❶ customer}!") [PRE100] Order for Newman! Order for Daniel! Order for Simon!
    `# --snip--` [PRE101] customers = [     (''Newman'', ''tea''),     (''Daniel'',
    ''lemongrass tea''),     (''Simon'', ''chai latte''),     (''James'', ''medium
    roast drip, milk, 2 sugar substitutes''),     (''William'', ''french press''),     (''Kyle'',
    ''mocha cappuccino''),     (''Jason'', ''pumpkin spice latte''),     (''Devin'',
    ''double-shot espresso''),     (''Todd'', ''dark roast drip''),     (''Glen'',
    ''americano, no sugar, heavy cream''),     (''Denis'', ''cold brew'') ]  for ❶
    customer, drink in customers:     print(f"Making {drink}...")     print(f"Order
    for {customer}!") [PRE102] Making tea... Order for Newman! Making lemongrass tea...
    Order for Daniel! Making chai latte... Order for Simon! `# --snip--` [PRE103]
    for _, drink in ❶ sorted(customers, ❷ key=lambda x: ❸ x[1]):     print(f"{drink}")
    [PRE104] americano, no sugar, heavy cream chai latte cold brew `# --snip--` [PRE105]
    for number, ❶ (customer, drink) in enumerate(customers, start=1):     print(f"#{number}.
    {customer}: {drink}") [PRE106] #1\. Newman: tea #2\. Daniel: lemongrass tea #3\.
    Simon: chai latte `# --snip--` [PRE107] from collections import deque  customers
    = deque([  (''Newman'', ''tea''),     (''Daniel'', ''lemongrass tea''),     (''Simon'',
    ''chai latte''),     (''James'', ''medium roast drip, milk, 2 sugar substitutes''),     (''William'',
    ''french press''),     (''Kyle'', ''mocha cappuccino''),     (''Jason'', ''pumpkin
    spice latte''),     (''Devin'', ''double-shot espresso''),     (''Todd'', ''dark
    roast drip''),     (''Glen'', ''americano, no sugar, heavy cream''),     (''Denis'',
    ''cold brew'') ]) [PRE108] for customer, drink in customers:     print(f"Making
    {drink}...")     print(f"Order for {customer}!")     customers.popleft()  # RuntimeError
    [PRE109] for customer, drink in ❶ customers**.copy()**:     print(f"Making {drink}...")     print(f"Order
    for {customer}!")   ❷ customers.popleft()  **print(customers)  # prints deque([])**
    [PRE110] **while customers:**   ❶ **customer, drink =** ❷ **customers.popleft()**  print(f"Making
    {drink}...")     print(f"Order for {customer}!") [PRE111] orders = ["pumpkin spice
    latte", "caramel macchiato", "mocha cappuccino"] [PRE112] for order in orders:     #
    ... do whatever ...     orders.append(order)  # creates infinite loop!  print(orders)
    [PRE113] **new_orders = orders[:]** for order in orders:     # ... do whatever
    ...     **new_orders.**append(order) **orders = new_orders**  print(orders) [PRE114]
    samples = [''Costa Rica'', ''Kenya'', ''Vietnam'', ''Brazil''] guests = [''Denis'',
    ''William'', ''Todd'', ''Daniel'', ''Glen''] [PRE115] for sample in samples:     for
    guest in guests:         print(f"Give sample of {sample} coffee to {guest}.")
    [PRE116] Give sample of Costa Rica coffee to Denis. Give sample of Costa Rica
    coffee to William. Give sample of Costa Rica coffee to Todd. Give sample of Costa
    Rica coffee to Daniel. Give sample of Costa Rica coffee to Glen. Give sample of
    Kenya coffee to Denis. Give sample of Kenya coffee to William. `# --snip--` [PRE117]
    **from itertools import product  # Put this line at top of module**  **for** ❶
    **sample, guest in** ❷ **product(samples, guests):**     print(f"Give sample of
    {sample} coffee to {guest}.") [PRE118] orders = [''cold brew'', ''lemongrass tea'',
    ''chai latte'', ''medium drip'',           ''french press'', ''mocha cappuccino'',
    ''pumpkin spice latte'',           ''double-shot espresso'', ''dark roast drip'',
    ''americano'']  drip_orders = ❶ list( ❷ filter( ❸ lambda s: ''drip'' in s, ❹ orders))  print(f''There
    are { ❺ len(drip_orders)} orders for drip coffee.'') [PRE119] orders = [''cold
    brew'', ''lemongrass tea'', ''chai latte'', ''medium drip'',           ''french
    press'', ''mocha cappuccino'', ''pumpkin spice latte'',           ''double-shot
    espresso'', ''dark roast drip'', ''americano''] [PRE120] def brew(order):     print(f"Making
    {order}...")     return order [PRE121] for order in map(brew, orders):     print(f"One
    {order} is ready!") [PRE122] from operator import add  cost = [5.95, 4.95, 5.45,
    3.45, 2.95] tip = [0.25, 1.00, 2.00, 0.15, 0.00]  for total in map(add, cost,
    tip):     print(f''{total:.02f}'') [PRE123] 6.20 5.95 7.45 3.60 2.95 [PRE124]
    regulars = [''William'', ''Devin'', ''Kyle'', ''Simon'', ''Newman''] usuals =
    [''french press'', ''double-shot espresso'', ''mocha cappuccino'',           ''chai
    latte'', ''tea'', ''drip'']  usual_orders = ❶ dict( ❷ zip( ❸ regulars, ❹ usuals))
    [PRE125] print(usual_orders[''Devin''])  # prints ''double-shot espresso'' [PRE126]
    class CafeQueue:      def __init__(self):         self._queue = []         self._orders
    = {}         self._togo = {} [PRE127]  def __iter__(self):         return CafeQueueIterator(self)
    [PRE128]  def add_customer(self, customer, *orders, to_go=True):         self._queue.append(customer)         self._orders[customer]
    = tuple(orders)         self._togo[customer] = to_go [PRE129]  def __len__(self):         return
    len(self._queue) [PRE130]  def __contains__(self, customer):         return (customer
    in self._queue) [PRE131] class CafeQueueIterator:      def __init__(self, ❶ cafe_queue):         self._cafe
    = cafe_queue         self._position = 0 [PRE132]  def __next__(self):         try:             customer
    = self._cafe._queue[self._position]       ❶ except IndexError:           ❷ raise
    StopIteration          orders = self._cafe._orders[customer]         togo = self._cafe._togo[customer]   ❸
    self._position += 1        ❹ return (customer, orders, togo) [PRE133]  def __iter__(self):         return
    self [PRE134] queue = CafeQueue() queue.add_customer(''Newman'', ''tea'', ''tea'',
    ''tea'', ''tea'', to_go=False) queue.add_customer(''James'', ''medium roast drip,
    milk, 2 sugar substitutes'') queue.add_customer(''Glen'', ''americano, no sugar,
    heavy cream'') queue.add_customer(''Jason'', ''pumpkin spice latte'', to_go=False)
    [PRE135] print(len(queue))       # prints 4 print(''Glen'' in queue)  # prints
    True print(''Kyle'' in queue)  # prints False [PRE136] def brew(order):     print(f"(Making
    {order}...)")     return order [PRE137] for customer, orders, to_go in queue:    ❶
    for order in orders: brew(order)     if to_go:         print(f"Order for {customer}!")     else:         print(f"(Takes
    order to {customer})") [PRE138]`'
  prefs: []
  type: TYPE_NORMAL
