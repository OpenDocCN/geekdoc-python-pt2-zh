- en: Part I
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Basics
  prefs: []
  type: TYPE_NORMAL
- en: Part I of this book teaches you the basic concepts you’ll need to write Python
    programs. Many of these concepts are common to all programming languages, so they’ll
    be useful throughout your life as a programmer.
  prefs: []
  type: TYPE_NORMAL
- en: In **Chapter 1** you’ll install Python on your computer and run your first program,
    which prints the message *Hello world!* to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: In **Chapter 2** you’ll learn to assign information to variables and work with
    text and numerical values.
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapters 3** and **4** introduce lists. Lists can store as much information
    as you want in one place, allowing you to work with that data efficiently. You’ll
    be able to work with hundreds, thousands, and even millions of values in just
    a few lines of code.'
  prefs: []
  type: TYPE_NORMAL
- en: In **Chapter 5** you’ll use `if` statements to write code that responds one
    way if certain conditions are true, and responds in a different way if those conditions
    are not true.
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter 6** shows you how to use Python’s dictionaries, which let you make
    connections between different pieces of information. Like lists, dictionaries
    can contain as much information as you need to store.'
  prefs: []
  type: TYPE_NORMAL
- en: In **Chapter 7** you’ll learn how to accept input from users to make your programs
    interactive. You’ll also learn about `while` loops, which run blocks of code repeatedly
    as long as certain conditions remain true.
  prefs: []
  type: TYPE_NORMAL
- en: In **Chapter 8** you’ll write functions, which are named blocks of code that
    perform a specific task and can be run whenever you need them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter 9** introduces classes, which allow you to model real-world objects.
    You’ll write code that represents dogs, cats, people, cars, rockets, and more.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter 10** shows you how to work with files and handle errors so your programs
    won’t crash unexpectedly. You’ll store data before your program closes and read
    the data back in when the program runs again. You’ll learn about Python’s exceptions,
    which allow you to anticipate errors and make your programs handle those errors
    gracefully.'
  prefs: []
  type: TYPE_NORMAL
- en: In **Chapter 11** you’ll learn to write tests for your code, to check that your
    programs work the way you intend them to. As a result, you’ll be able to expand
    your programs without worrying about introducing new bugs. Testing your code is
    one of the first skills that will help you transition from beginner to intermediate
    programmer.
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Getting Started
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, you’ll run your first Python program, *hello_world.py*. First,
    you’ll need to check whether a recent version of Python is installed on your computer;
    if it isn’t, you’ll install it. You’ll also install a text editor to work with
    your Python programs. Text editors recognize Python code and highlight sections
    as you write, making it easy to understand your code’s structure.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up Your Programming Environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python differs slightly on different operating systems, so you’ll need to keep
    a few considerations in mind. In the following sections, we’ll make sure Python
    is set up correctly on your system.
  prefs: []
  type: TYPE_NORMAL
- en: Python Versions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Every programming language evolves as new ideas and technologies emerge, and
    the developers of Python have continually made the language more versatile and
    powerful. As of this writing, the latest version is Python 3.11, but everything
    in this book should run on Python 3.9 or later. In this section, we’ll find out
    if Python is already installed on your system and whether you need to install
    a newer version. Appendix A contains additional details about installing the latest
    version of Python on each major operating system as well.
  prefs: []
  type: TYPE_NORMAL
- en: Running Snippets of Python Code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can run Python’s interpreter in a terminal window, allowing you to try bits
    of Python code without having to save and run an entire program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Throughout this book, you’ll see code snippets that look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The three angle brackets (`>>>`) prompt, which we’ll refer to as a *Python prompt*,
    indicates that you should be using the terminal window. The bold text is the code
    you should type in and then execute by pressing ENTER. Most of the examples in
    this book are small, self-contained programs that you’ll run from your text editor
    rather than the terminal, because you’ll write most of your code in the text editor.
    But sometimes, basic concepts will be shown in a series of snippets run through
    a Python terminal session to demonstrate particular concepts more efficiently.
    When you see three angle brackets in a code listing, you’re looking at code and
    output from a terminal session. We’ll try coding in the interpreter on your system
    in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use a text editor to create a simple program called *Hello World!*
    that has become a staple of learning to program. There’s a long-held tradition
    in the programming world that printing the message `Hello world!` to the screen
    as your first program in a new language will bring you good luck. Such a simple
    program serves a very real purpose. If it runs correctly on your system, then
    any Python program you write should work as well.
  prefs: []
  type: TYPE_NORMAL
- en: About the VS Code Editor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*VS Code* is a powerful, professional-quality text editor that’s free and beginner-friendly.
    VS Code is great for both simple and complex projects, so if you become comfortable
    using it while learning Python, you can continue using it as you progress to larger
    and more complicated projects. VS Code can be installed on all modern operating
    systems, and it supports most programming languages, including Python.'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix B provides information on other text editors. If you’re curious about
    the other options, you might want to skim that appendix at this point. If you
    want to begin programming quickly, you can use VS Code to start. Then you can
    consider other editors, once you’ve gained some experience as a programmer. In
    this chapter, I’ll walk you through installing VS Code on your operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Python on Different Operating Systems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python is a cross-platform programming language, which means it runs on all
    the major operating systems. Any Python program you write should run on any modern
    computer that has Python installed. However, the methods for setting up Python
    on different operating systems vary slightly.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you’ll learn how to set up Python on your system. You’ll first
    check whether a recent version of Python is installed on your system, and install
    it if it’s not. Then you’ll install VS Code. These are the only two steps that
    are different for each operating system.
  prefs: []
  type: TYPE_NORMAL
- en: In the sections that follow, you’ll run *hello_world.py* and troubleshoot anything
    that doesn’t work. I’ll walk you through this process for each operating system,
    so you’ll have a Python programming environment that you can rely on.
  prefs: []
  type: TYPE_NORMAL
- en: Python on Windows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Windows doesn’t usually come with Python, so you’ll probably need to install
    it and then install VS Code.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Python
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: First, check whether Python is installed on your system. Open a command window
    by entering `command` into the Start menu and clicking the **Command Prompt**
    app. In the terminal window, enter `python` in lowercase. If you get a Python
    prompt (`>>>`) in response, Python is installed on your system. If you see an
    error message telling you that `python` is not a recognized command, or if the
    Microsoft store opens, Python isn’t installed. Close the Microsoft store if it
    opens; it’s better to download an official installer than to use Microsoft’s version.
  prefs: []
  type: TYPE_NORMAL
- en: If Python is not installed on your system, or if you see a version earlier than
    Python 3.9, you need to download a Python installer for Windows. Go to [https://python.org](https://python.org)
    and hover over the **Downloads** link. You should see a button for downloading
    the latest version of Python. Click the button, which should automatically start
    downloading the correct installer for your system. After you’ve downloaded the
    file, run the installer. Make sure you select the option **Add Python to PATH**,
    which will make it easier to configure your system correctly. [Figure 1-1](#figure1-1)
    shows this option selected.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/f01001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-1: Make sure you select the checkbox labeled *Add Python to PATH*.'
  prefs: []
  type: TYPE_NORMAL
- en: Running Python in a Terminal Session
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Open a new command window and enter `python` in lowercase. You should see a
    Python prompt (`>>>`), which means Windows has found the version of Python you
    just installed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter the following line in your Python session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You should see the output `Hello Python interpreter!` Anytime you want to run
    a snippet of Python code, open a command window and start a Python terminal session.
    To close the terminal session, press CTRL-Z and then press ENTER, or enter the
    command `exit()`.
  prefs: []
  type: TYPE_NORMAL
- en: Installing VS Code
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can download an installer for VS Code at [https://code.visualstudio.com](https://code.visualstudio.com).
    Click the **Download for Windows** button and run the installer. Skip the following
    sections about macOS and Linux, and follow the steps in “Running a Hello World
    Program” on page 9.
  prefs: []
  type: TYPE_NORMAL
- en: Python on macOS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python is not installed by default on the latest versions of macOS, so you’ll
    need to install it if you haven’t already done so. In this section, you’ll install
    the latest version of Python, and then install VS Code and make sure it’s configured
    correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Checking Whether Python 3 Is Installed
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Open a terminal window by going to **Applications**▶**Utilities**▶**Terminal**.
    You can also press ⌘-spacebar, type `terminal`, and then press ENTER. To see if
    you have a recent enough version of Python installed, enter `python3`. You’ll
    most likely see a message about installing the *command line developer tools*.
    It’s better to install these tools after installing Python, so if this message
    appears, cancel the pop-up window.
  prefs: []
  type: TYPE_NORMAL
- en: If the output shows you have Python 3.9 or a later version installed, you can
    skip the next section and go to “Running Python in a Terminal Session.” If you
    see any version earlier than Python 3.9, follow the instructions in the next section
    to install the latest version.
  prefs: []
  type: TYPE_NORMAL
- en: Note that on macOS, whenever you see the `python` command in this book, you
    need to use the `python3` command instead to make sure you’re using Python 3\.
    On most macOS systems, the `python` command either points to an outdated version
    of Python that should only be used by internal system tools, or it points to nothing
    and generates an error message.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Latest Version of Python
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can find a Python installer for your system at [https://python.org](https://python.org).
    Hover over the **Download** link, and you should see a button for downloading
    the latest version of Python. Click the button, which should automatically start
    downloading the correct installer for your system. After the file downloads, run
    the installer.
  prefs: []
  type: TYPE_NORMAL
- en: After the installer runs, a Finder window should appear. Double-click the *Install
    Certificates.command* file. Running this file will allow you to more easily install
    additional libraries that you’ll need for real-world projects, including the projects
    in the second half of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Running Python in a Terminal Session
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can now try running snippets of Python code by opening a new terminal window
    and typing `python3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This command starts a Python terminal session. You should see a Python prompt
    (`>>>`), which means macOS has found the version of Python you just installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following line in the terminal session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You should see the message `Hello Python interpreter!`, which should print directly
    in the current terminal window. You can close the Python interpreter by pressing
    CTRL-D or by entering the command `exit()`.
  prefs: []
  type: TYPE_NORMAL
- en: Installing VS Code
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To install the VS Code editor, you need to download the installer at [https://code.visualstudio.com](https://code.visualstudio.com).
    Click the **Download** button, and then open a **Finder** window and go to the
    **Downloads** folder. Drag the **Visual Studio Code** installer to your Applications
    folder, then double-click the installer to run it.
  prefs: []
  type: TYPE_NORMAL
- en: Skip over the following section about Python on Linux, and follow the steps
    in “Running a Hello World Program” on page 9.
  prefs: []
  type: TYPE_NORMAL
- en: Python on Linux
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Linux systems are designed for programming, so Python is already installed on
    most Linux computers. The people who write and maintain Linux expect you to do
    your own programming at some point, and encourage you to do so. For this reason,
    there’s very little to install and only a few settings to change to start programming.
  prefs: []
  type: TYPE_NORMAL
- en: Checking Your Version of Python
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Open a terminal window by running the Terminal application on your system (in
    Ubuntu, you can press CTRL-ALT-T). To find out which version of Python is installed,
    enter `python3` with a lowercase *p*. When Python is installed, this command starts
    the Python interpreter. You should see output indicating which version of Python
    is installed. You should also see a Python prompt (`>>>`) where you can start
    entering Python commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This output indicates that Python 3.10.4 is currently the default version of
    Python installed on this computer. When you’ve seen this output, press CTRL-D
    or enter `exit()` to leave the Python prompt and return to a terminal prompt.
    Whenever you see the `python` command in this book, enter `python3` instead.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll need Python 3.9 or later to run the code in this book. If the Python
    version installed on your system is earlier than Python 3.9, or if you want to
    update to the latest version currently available, refer to the instructions in
    Appendix A.
  prefs: []
  type: TYPE_NORMAL
- en: Running Python in a Terminal Session
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can try running snippets of Python code by opening a terminal and entering
    `python3`, as you did when checking your version. Do this again, and when you
    have Python running, enter the following line in the terminal session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The message should print directly in the current terminal window. Remember that
    you can close the Python interpreter by pressing CTRL-D or by entering the command
    `exit()`.
  prefs: []
  type: TYPE_NORMAL
- en: Installing VS Code
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: On Ubuntu Linux, you can install VS Code from the Ubuntu Software Center. Click
    the Ubuntu Software icon in your menu and search for *vscode*. Click the app called
    **Visual Studio Code** (sometimes called *code*), and then click **Install**.
    Once it’s installed, search your system for *VS Code* and launch the app.
  prefs: []
  type: TYPE_NORMAL
- en: Running a Hello World Program
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With a recent version of Python and VS Code installed, you’re almost ready to
    run your first Python program written in a text editor. But before doing so, you
    need to install the Python extension for VS Code.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Python Extension for VS Code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: VS Code works with many different programming languages; to get the most out
    of it as a Python programmer, you’ll need to install the Python extension. This
    extension adds support for writing, editing, and running Python programs.
  prefs: []
  type: TYPE_NORMAL
- en: To install the Python extension, click the Manage icon, which looks like a gear
    in the lower-left corner of the VS Code app. In the menu that appears, click **Extensions**.
    Enter `python` in the search box and click the **Python** extension. (If you see
    more than one extension named *Python*, choose the one supplied by Microsoft.)
    Click **Install** and install any additional tools that your system needs to complete
    the installation. If you see a message that you need to install Python, and you’ve
    already done so, you can ignore this message.
  prefs: []
  type: TYPE_NORMAL
- en: Running hello_world.py
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before you write your first program, make a folder called *python_work* on your
    desktop for your projects. It’s best to use lowercase letters and underscores
    for spaces in file and folder names, because Python uses these naming conventions.
    You can make this folder somewhere other than the desktop, but it will be easier
    to follow some later steps if you save the *python_work* folder directly on your
    desktop.
  prefs: []
  type: TYPE_NORMAL
- en: Open VS Code, and close the **Get Started** tab if it’s still open. Make a new
    file by clicking **File**▶**New File** or pressing CTRL-N (⌘-N on macOS). Save
    the file as *hello_world.py* in your *python_work* folder. The extension *.py*
    tells VS Code that your file is written in Python, and tells it how to run the
    program and highlight the text in a helpful way.
  prefs: []
  type: TYPE_NORMAL
- en: 'After you’ve saved your file, enter the following line in the editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '**hello_world.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To run your program, select **Run**▶**Run Without Debugging** or press CTRL-F5\.
    A terminal screen should appear at the bottom of the VS Code window, showing your
    program’s output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You’ll likely see some additional output showing the Python interpreter that
    was used to run your program. If you want to simplify the information that’s displayed
    so you only see your program’s output, see Appendix B. You can also find helpful
    suggestions about how to use VS Code more efficiently in Appendix B.
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see this output, something might have gone wrong in the program.
    Check every character on the line you entered. Did you accidentally capitalize
    `print`? Did you forget one or both of the quotation marks or parentheses? Programming
    languages expect very specific syntax, and if you don’t provide that, you’ll get
    errors. If you can’t get the program to run, see the suggestions in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you can’t get *hello_world.py* to run, here are a few remedies you can try
    that are also good general solutions for any programming problem:'
  prefs: []
  type: TYPE_NORMAL
- en: When a program contains a significant error, Python displays a *traceback*,
    which is an error report. Python looks through the file and tries to identify
    the problem. Check the traceback; it might give you a clue as to what issue is
    preventing the program from running.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Step away from your computer, take a short break, and then try again. Remember
    that syntax is very important in programming, so something as simple as mismatched
    quotation marks or mismatched parentheses can prevent a program from running properly.
    Reread the relevant parts of this chapter, look over your code, and try to find
    the mistake.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Start over again. You probably don’t need to uninstall any software, but it
    might make sense to delete your *hello_world.py* file and re-create it from scratch.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ask someone else to follow the steps in this chapter, on your computer or a
    different one, and watch what they do carefully. You might have missed one small
    step that someone else happens to catch.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See the additional installation instructions in Appendix A; some of the details
    included in the Appendix may help you solve your issue.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find someone who knows Python and ask them to help you get set up. If you ask
    around, you might find that you unexpectedly know someone who uses Python.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The setup instructions in this chapter are also available through this book’s
    companion website at [https://ehmatthes.github.io/pcc_3e](https://ehmatthes.github.io/pcc_3e).
    The online version of these instructions might work better because you can simply
    cut and paste code and click links to the resources you need.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ask for help online. Appendix C provides a number of resources, such as forums
    and live chat sites, where you can ask for solutions from people who’ve already
    worked through the issue you’re currently facing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Never worry that you’re bothering experienced programmers. Every programmer
    has been stuck at some point, and most programmers are happy to help you set up
    your system correctly. As long as you can state clearly what you’re trying to
    do, what you’ve already tried, and the results you’re getting, there’s a good
    chance someone will be able to help you. As mentioned in the introduction, the
    Python community is very friendly and welcoming to beginners.
  prefs: []
  type: TYPE_NORMAL
- en: Python should run well on any modern computer. Early setup issues can be frustrating,
    but they’re well worth sorting out. Once you get *hello_world.py* running, you
    can start to learn Python, and your programming work will become more interesting
    and satisfying.
  prefs: []
  type: TYPE_NORMAL
- en: Running Python Programs from a Terminal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’ll run most of your programs directly in your text editor. However, sometimes
    it’s useful to run programs from a terminal instead. For example, you might want
    to run an existing program without opening it for editing.
  prefs: []
  type: TYPE_NORMAL
- en: You can do this on any system with Python installed if you know how to access
    the directory where the program file is stored. To try this, make sure you’ve
    saved the *hello_world.py* file in the *python_work* folder on your desktop.
  prefs: []
  type: TYPE_NORMAL
- en: On Windows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can use the terminal command `cd`, for *change directory*, to navigate through
    your filesystem in a command window. The command `dir`, for *directory*, shows
    you all the files that exist in the current directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a new terminal window and enter the following commands to run *hello_world.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: First, use the `cd` command to navigate to the *python_work* folder, which is
    in the *Desktop* folder. Next, use the `dir` command to make sure *hello_world.py*
    is in this folder. Then run the file using the command `python hello_world.py`.
  prefs: []
  type: TYPE_NORMAL
- en: Most of your programs will run fine directly from your editor. However, as your
    work becomes more complex, you’ll want to run some of your programs from a terminal.
  prefs: []
  type: TYPE_NORMAL
- en: On macOS and Linux
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Running a Python program from a terminal session is the same on Linux and macOS.
    You can use the terminal command `cd`, for *change directory*, to navigate through
    your filesystem in a terminal session. The command `ls`, for *list*, shows you
    all the nonhidden files that exist in the current directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a new terminal window and enter the following commands to run *hello_world.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: First, use the `cd` command to navigate to the *python_work* folder, which is
    in the *Desktop* folder. Next, use the `ls` command to make sure *hello_world.py*
    is in this folder. Then run the file using the command `python3 hello_world.py`.
  prefs: []
  type: TYPE_NORMAL
- en: Most of your programs will run fine directly from your editor. But as your work
    becomes more complex, you’ll want to run some of your programs from a terminal.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you learned a bit about Python in general, and you installed
    Python on your system if it wasn’t already there. You also installed a text editor
    to make it easier to write Python code. You ran snippets of Python code in a terminal
    session, and you ran your first program, *hello_world.py*. You probably learned
    a bit about troubleshooting as well.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you’ll learn about the different kinds of data you can
    work with in your Python programs, and you’ll start to use variables as well.
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Variables and Simple Data Types
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter you’ll learn about the different kinds of data you can work
    with in your Python programs. You’ll also learn how to use variables to represent
    data in your programs.
  prefs: []
  type: TYPE_NORMAL
- en: What Really Happens When You Run hello_world.py
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s take a closer look at what Python does when you run *hello_world.py*.
    As it turns out, Python does a fair amount of work, even when it runs a simple
    program:'
  prefs: []
  type: TYPE_NORMAL
- en: '**hello_world.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run this code, you should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: When you run the file *hello_world.py*, the ending *.py* indicates that the
    file is a Python program. Your editor then runs the file through the *Python interpreter*,
    which reads through the program and determines what each word in the program means.
    For example, when the interpreter sees the word `print` followed by parentheses,
    it prints to the screen whatever is inside the parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: As you write your programs, your editor highlights different parts of your program
    in different ways. For example, it recognizes that `print()` is the name of a
    function and displays that word in one color. It recognizes that `"Hello Python
    world!"` is not Python code, and displays that phrase in a different color. This
    feature is called *syntax highlighting* and is quite useful as you start to write
    your own programs.
  prefs: []
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s try using a variable in *hello_world.py*. Add a new line at the beginning
    of the file, and modify the second line:'
  prefs: []
  type: TYPE_NORMAL
- en: '**hello_world.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Run this program to see what happens. You should see the same output you saw
    previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We’ve added a *variable* named `message`. Every variable is connected to a *value*,
    which is the information associated with that variable. In this case the value
    is the `"Hello Python world!"` text.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a variable makes a little more work for the Python interpreter. When
    it processes the first line, it associates the variable `message` with the `"Hello
    Python world!"` text. When it reaches the second line, it prints the value associated
    with `message` to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s expand on this program by modifying *hello_world.py* to print a second
    message. Add a blank line to *hello_world.py*, and then add two new lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when you run *hello_world.py*, you should see two lines of output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You can change the value of a variable in your program at any time, and Python
    will always keep track of its current value.
  prefs: []
  type: TYPE_NORMAL
- en: Naming and Using Variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you’re using variables in Python, you need to adhere to a few rules and
    guidelines. Breaking some of these rules will cause errors; other guidelines just
    help you write code that’s easier to read and understand. Be sure to keep the
    following rules in mind when working with variables:'
  prefs: []
  type: TYPE_NORMAL
- en: Variable names can contain only letters, numbers, and underscores. They can
    start with a letter or an underscore, but not with a number. For instance, you
    can call a variable `message_1` but not `1_message`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spaces are not allowed in variable names, but underscores can be used to separate
    words in variable names. For example, `greeting_message` works but `greeting message`
    will cause errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid using Python keywords and function names as variable names. For example,
    do not use the word `print` as a variable name; Python has reserved it for a particular
    programmatic purpose. (See “Python Keywords and Built-in Functions” on page 466.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variable names should be short but descriptive. For example, `name` is better
    than `n`, `student_name` is better than `s_n`, and `name_length` is better than
    `length_of_persons_name`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be careful when using the lowercase letter *l* and the uppercase letter *O*
    because they could be confused with the numbers *1* and *0*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can take some practice to learn how to create good variable names, especially
    as your programs become more interesting and complicated. As you write more programs
    and start to read through other people’s code, you’ll get better at coming up
    with meaningful names.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding Name Errors When Using Variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Every programmer makes mistakes, and most make mistakes every day. Although
    good programmers might create errors, they also know how to respond to those errors
    efficiently. Let’s look at an error you’re likely to make early on and learn how
    to fix it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll write some code that generates an error on purpose. Enter the following
    code, including the misspelled word `mesage`*,* which is shown in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'When an error occurs in your program, the Python interpreter does its best
    to help you figure out where the problem is. The interpreter provides a traceback
    when a program cannot run successfully. A *traceback* is a record of where the
    interpreter ran into trouble when trying to execute your code. Here’s an example
    of the traceback that Python provides after you’ve accidentally misspelled a variable’s
    name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The output reports that an error occurs in line 2 of the file *hello_world.py*
    ❶. The interpreter shows this line ❷ to help us spot the error quickly and tells
    us what kind of error it found ❸. In this case it found a *name error* and reports
    that the variable being printed, `mesage`, has not been defined. Python can’t
    identify the variable name provided. A name error usually means we either forgot
    to set a variable’s value before using it, or we made a spelling mistake when
    entering the variable’s name. If Python finds a variable name that’s similar to
    the one it doesn’t recognize, it will ask if that’s the name you meant to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example we omitted the letter *s* in the variable name `message` in
    the second line. The Python interpreter doesn’t spellcheck your code, but it does
    ensure that variable names are spelled consistently. For example, watch what happens
    when we spell *message* incorrectly in the line that defines the variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the program runs successfully!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The variable names match, so Python sees no issue. Programming languages are
    strict, but they disregard good and bad spelling. As a result, you don’t need
    to consider English spelling and grammar rules when you’re trying to create variable
    names and writing code.
  prefs: []
  type: TYPE_NORMAL
- en: Many programming errors are simple, single-character typos in one line of a
    program. If you find yourself spending a long time searching for one of these
    errors, know that you’re in good company. Many experienced and talented programmers
    spend hours hunting down these kinds of tiny errors. Try to laugh about it and
    move on, knowing it will happen frequently throughout your programming life.
  prefs: []
  type: TYPE_NORMAL
- en: Variables Are Labels
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Variables are often described as boxes you can store values in. This idea can
    be helpful the first few times you use a variable, but it isn’t an accurate way
    to describe how variables are represented internally in Python. It’s much better
    to think of variables as labels that you can assign to values. You can also say
    that a variable references a certain value.
  prefs: []
  type: TYPE_NORMAL
- en: This distinction probably won’t matter much in your initial programs, but it’s
    worth learning earlier rather than later. At some point, you’ll see unexpected
    behavior from a variable, and an accurate understanding of how variables work
    will help you identify what’s happening in your code.
  prefs: []
  type: TYPE_NORMAL
- en: Strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because most programs define and gather some sort of data and then do something
    useful with it, it helps to classify different types of data. The first data type
    we’ll look at is the string. Strings are quite simple at first glance, but you
    can use them in many different ways.
  prefs: []
  type: TYPE_NORMAL
- en: 'A *string* is a series of characters. Anything inside quotes is considered
    a string in Python, and you can use single or double quotes around your strings
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This flexibility allows you to use quotes and apostrophes within your strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Let’s explore some of the ways you can use strings.
  prefs: []
  type: TYPE_NORMAL
- en: Changing Case in a String with Methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of the simplest tasks you can do with strings is change the case of the
    words in a string. Look at the following code, and try to determine what’s happening:'
  prefs: []
  type: TYPE_NORMAL
- en: '**name.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Save this file as *name.py* and then run it. You should see this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the variable `name` refers to the lowercase string `"ada lovelace"`.
    The method `title()` appears after the variable in the `print()` call. A *method*
    is an action that Python can perform on a piece of data. The dot (`.`) after `name`
    in `name.title()` tells Python to make the `title()` method act on the variable
    `name`. Every method is followed by a set of parentheses, because methods often
    need additional information to do their work. That information is provided inside
    the parentheses. The `title()` function doesn’t need any additional information,
    so its parentheses are empty.
  prefs: []
  type: TYPE_NORMAL
- en: The `title()` method changes each word to title case, where each word begins
    with a capital letter. This is useful because you’ll often want to think of a
    name as a piece of information. For example, you might want your program to recognize
    the input values `Ada`, `ADA`, and `ada` as the same name, and display all of
    them as `Ada`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Several other useful methods are available for dealing with case as well. For
    example, you can change a string to all uppercase or all lowercase letters like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This will display the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `lower()` method is particularly useful for storing data. You typically
    won’t want to trust the capitalization that your users provide, so you’ll convert
    strings to lowercase before storing them. Then when you want to display the information,
    you’ll use the case that makes the most sense for each string.
  prefs: []
  type: TYPE_NORMAL
- en: Using Variables in Strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In some situations, you’ll want to use a variable’s value inside a string.
    For example, you might want to use two variables to represent a first name and
    a last name, respectively, and then combine those values to display someone’s
    full name:'
  prefs: []
  type: TYPE_NORMAL
- en: '**full_name.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: To insert a variable’s value into a string, place the letter `f` immediately
    before the opening quotation mark ❶. Put braces around the name or names of any
    variable you want to use inside the string. Python will replace each variable
    with its value when the string is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'These strings are called *f-strings*. The *f* is for *format*, because Python
    formats the string by replacing the name of any variable in braces with its value.
    The output from the previous code is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'You can do a lot with f-strings. For example, you can use f-strings to compose
    complete messages using the information associated with a variable, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The full name is used in a sentence that greets the user ❶, and the `title()`
    method changes the name to title case. This code returns a simple but nicely formatted
    greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use f-strings to compose a message, and then assign the entire
    message to a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This code displays the message `Hello, Ada Lovelace!` as well, but by assigning
    the message to a variable ❶ we make the final `print()` call much simpler ❷.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Whitespace to Strings with Tabs or Newlines
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In programming, *whitespace* refers to any nonprinting characters, such as spaces,
    tabs, and end-of-line symbols. You can use whitespace to organize your output
    so it’s easier for users to read.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a tab to your text, use the character combination `\t`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'To add a newline in a string, use the character combination `\n`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also combine tabs and newlines in a single string. The string `"\n\t"`
    tells Python to move to a new line, and start the next line with a tab. The following
    example shows how you can use a one-line string to generate four lines of output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Newlines and tabs will be very useful in the next two chapters, when you start
    to produce many lines of output from just a few lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: Stripping Whitespace
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Extra whitespace can be confusing in your programs. To programmers, `'python'`
    and `'python '` look pretty much the same. But to a program, they are two different
    strings. Python detects the extra space in `'python '` and considers it significant
    unless you tell it otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to think about whitespace, because often you’ll want to compare
    two strings to determine whether they are the same. For example, one important
    instance might involve checking people’s usernames when they log in to a website.
    Extra whitespace can be confusing in much simpler situations as well. Fortunately,
    Python makes it easy to eliminate extra whitespace from data that people enter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python can look for extra whitespace on the right and left sides of a string.
    To ensure that no whitespace exists at the right side of a string, use the `rstrip()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The value associated with `favorite_language` ❶ contains extra whitespace at
    the end of the string. When you ask Python for this value in a terminal session,
    you can see the space at the end of the value ❷. When the `rstrip()` method acts
    on the variable `favorite_language` ❸, this extra space is removed. However, it
    is only removed temporarily. If you ask for the value of `favorite_language` again,
    the string looks the same as when it was entered, including the extra whitespace
    ❹.
  prefs: []
  type: TYPE_NORMAL
- en: 'To remove the whitespace from the string permanently, you have to associate
    the stripped value with the variable name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: To remove the whitespace from the string, you strip the whitespace from the
    right side of the string and then associate this new value with the original variable
    ❶. Changing a variable’s value is done often in programming. This is how a variable’s
    value can be updated as a program is executed or in response to user input.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also strip whitespace from the left side of a string using the `lstrip()`
    method, or from both sides at once using `strip()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we start with a value that has whitespace at the beginning
    and the end ❶. We then remove the extra space from the right side ❷, from the
    left side ❸, and from both sides ❹. Experimenting with these stripping functions
    can help you become familiar with manipulating strings. In the real world, these
    stripping functions are used most often to clean up user input before it’s stored
    in a program.
  prefs: []
  type: TYPE_NORMAL
- en: Removing Prefixes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When working with strings, another common task is to remove a prefix. Consider
    a URL with the common prefix *https://*. We want to remove this prefix, so we
    can focus on just the part of the URL that users need to enter into an address
    bar. Here’s how to do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Enter the name of the variable followed by a dot, and then the method `removeprefix()`.
    Inside the parentheses, enter the prefix you want to remove from the original
    string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like the methods for removing whitespace, `removeprefix()` leaves the original
    string unchanged. If you want to keep the new value with the prefix removed, either
    reassign it to the original variable or assign it to a new variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: When you see a URL in an address bar and the *https://* part isn’t shown, the
    browser is probably using a method like `removeprefix()` behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding Syntax Errors with Strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One kind of error that you might see with some regularity is a syntax error.
    A *syntax error* occurs when Python doesn’t recognize a section of your program
    as valid Python code. For example, if you use an apostrophe within single quotes,
    you’ll produce an error. This happens because Python interprets everything between
    the first single quote and the apostrophe as a string. It then tries to interpret
    the rest of the text as Python code, which causes errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how to use single and double quotes correctly. Save this program as
    *apostrophe.py* and then run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '**apostrophe.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The apostrophe appears inside a set of double quotes, so the Python interpreter
    has no trouble reading the string correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if you use single quotes, Python can’t identify where the string should
    end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In the output you can see that the error occurs right after the final single
    quote ❶. This syntax error indicates that the interpreter doesn’t recognize something
    in the code as valid Python code, and it thinks the problem might be a string
    that’s not quoted correctly. Errors can come from a variety of sources, and I’ll
    point out some common ones as they arise. You might see syntax errors often as
    you learn to write proper Python code. Syntax errors are also the least specific
    kind of error, so they can be difficult and frustrating to identify and correct.
    If you get stuck on a particularly stubborn error, see the suggestions in Appendix
    C.
  prefs: []
  type: TYPE_NORMAL
- en: Numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Numbers are used quite often in programming to keep score in games, represent
    data in visualizations, store information in web applications, and so on. Python
    treats numbers in several different ways, depending on how they’re being used.
    Let’s first look at how Python manages integers, because they’re the simplest
    to work with.
  prefs: []
  type: TYPE_NORMAL
- en: Integers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can add (`+`), subtract (`-`), multiply (`*`), and divide (`/`) integers
    in Python.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'In a terminal session, Python simply returns the result of the operation. Python
    uses two multiplication symbols to represent exponents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Python supports the order of operations too, so you can use multiple operations
    in one expression. You can also use parentheses to modify the order of operations
    so Python can evaluate your expression in the order you specify. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The spacing in these examples has no effect on how Python evaluates the expressions;
    it simply helps you more quickly spot the operations that have priority when you’re
    reading through the code.
  prefs: []
  type: TYPE_NORMAL
- en: Floats
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python calls any number with a decimal point a *float*. This term is used in
    most programming languages, and it refers to the fact that a decimal point can
    appear at any position in a number. Every programming language must be carefully
    designed to properly manage decimal numbers so numbers behave appropriately, no
    matter where the decimal point appears.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the most part, you can use floats without worrying about how they behave.
    Simply enter the numbers you want to use, and Python will most likely do what
    you expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'However, be aware that you can sometimes get an arbitrary number of decimal
    places in your answer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This happens in all languages and is of little concern. Python tries to find
    a way to represent the result as precisely as possible, which is sometimes difficult
    given how computers have to represent numbers internally. Just ignore the extra
    decimal places for now; you’ll learn ways to deal with the extra places when you
    need to in the projects in Part II.
  prefs: []
  type: TYPE_NORMAL
- en: Integers and Floats
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you divide any two numbers, even if they are integers that result in a
    whole number, you’ll always get a float:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'If you mix an integer and a float in any other operation, you’ll get a float
    as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Python defaults to a float in any operation that uses a float, even if the output
    is a whole number.
  prefs: []
  type: TYPE_NORMAL
- en: Underscores in Numbers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you’re writing long numbers, you can group digits using underscores to
    make large numbers more readable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'When you print a number that was defined using underscores, Python prints only
    the digits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Python ignores the underscores when storing these kinds of values. Even if you
    don’t group the digits in threes, the value will still be unaffected. To Python,
    `1000` is the same as `1_000`, which is the same as `10_00`. This feature works
    for both integers and floats.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple Assignment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can assign values to more than one variable using just a single line of
    code. This can help shorten your programs and make them easier to read; you’ll
    use this technique most often when initializing a set of numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here’s how you can initialize the variables `x`, `y`, and `z`
    to zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: You need to separate the variable names with commas, and do the same with the
    values, and Python will assign each value to its respective variable. As long
    as the number of values matches the number of variables, Python will match them
    up correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Constants
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A *constant* is a variable whose value stays the same throughout the life of
    a program. Python doesn’t have built-in constant types, but Python programmers
    use all capital letters to indicate a variable should be treated as a constant
    and never be changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: When you want to treat a variable as a constant in your code, write the name
    of the variable in all capital letters.
  prefs: []
  type: TYPE_NORMAL
- en: Comments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Comments are an extremely useful feature in most programming languages. Everything
    you’ve written in your programs so far is Python code. As your programs become
    longer and more complicated, you should add notes within your programs that describe
    your overall approach to the problem you’re solving. A *comment* allows you to
    write notes in your spoken language, within your programs.
  prefs: []
  type: TYPE_NORMAL
- en: How Do You Write Comments?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In Python, the hash mark (`#`) indicates a comment. Anything following a hash
    mark in your code is ignored by the Python interpreter. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '**comment.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Python ignores the first line and executes the second line.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: What Kinds of Comments Should You Write?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The main reason to write comments is to explain what your code is supposed to
    do and how you are making it work. When you’re in the middle of working on a project,
    you understand how all of the pieces fit together. But when you return to a project
    after some time away, you’ll likely have forgotten some of the details. You can
    always study your code for a while and figure out how segments were supposed to
    work, but writing good comments can save you time by summarizing your overall
    approach clearly.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to become a professional programmer or collaborate with other programmers,
    you should write meaningful comments. Today, most software is written collaboratively,
    whether by a group of employees at one company or a group of people working together
    on an open source project. Skilled programmers expect to see comments in code,
    so it’s best to start adding descriptive comments to your programs now. Writing
    clear, concise comments in your code is one of the most beneficial habits you
    can form as a new programmer.
  prefs: []
  type: TYPE_NORMAL
- en: When you’re deciding whether to write a comment, ask yourself if you had to
    consider several approaches before coming up with a reasonable way to make something
    work; if so, write a comment about your solution. It’s much easier to delete extra
    comments later than to go back and write comments for a sparsely commented program.
    From now on, I’ll use comments in examples throughout this book to help explain
    sections of code.
  prefs: []
  type: TYPE_NORMAL
- en: The Zen of Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Experienced Python programmers will encourage you to avoid complexity and aim
    for simplicity whenever possible. The Python community’s philosophy is contained
    in “The Zen of Python” by Tim Peters. You can access this brief set of principles
    for writing good Python code by entering `import this` into your interpreter.
    I won’t reproduce the entire “Zen of Python” here, but I’ll share a few lines
    to help you understand why they should be important to you as a beginning Python
    programmer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Python programmers embrace the notion that code can be beautiful and elegant.
    In programming, people solve problems. Programmers have always respected well-designed,
    efficient, and even beautiful solutions to problems. As you learn more about Python
    and use it to write more code, someone might look over your shoulder one day and
    say, “Wow, that’s some beautiful code!”
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: If you have a choice between a simple and a complex solution, and both work,
    use the simple solution. Your code will be easier to maintain, and it will be
    easier for you and others to build on that code later on.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Real life is messy, and sometimes a simple solution to a problem is unattainable.
    In that case, use the simplest solution that works.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Even when your code is complex, aim to make it readable. When you’re working
    on a project that involves complex coding, focus on writing informative comments
    for that code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: If two Python programmers are asked to solve the same problem, they should come
    up with fairly compatible solutions. This is not to say there’s no room for creativity
    in programming. On the contrary, there is plenty of room for creativity! However,
    much of programming consists of using small, common approaches to simple situations
    within a larger, more creative project. The nuts and bolts of your programs should
    make sense to other Python programmers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: You could spend the rest of your life learning all the intricacies of Python
    and of programming in general, but then you’d never complete any projects. Don’t
    try to write perfect code; write code that works, and then decide whether to improve
    your code for that project or move on to something new.
  prefs: []
  type: TYPE_NORMAL
- en: As you continue to the next chapter and start digging into more involved topics,
    try to keep this philosophy of simplicity and clarity in mind. Experienced programmers
    will respect your code more and will be happy to give you feedback and collaborate
    with you on interesting projects.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter you learned how to work with variables. You learned to use descriptive
    variable names and resolve name errors and syntax errors when they arise. You
    learned what strings are and how to display them using lowercase, uppercase, and
    title case. You started using whitespace to organize output neatly, and you learned
    how to remove unneeded elements from a string. You started working with integers
    and floats, and you learned some of the ways you can work with numerical data.
    You also learned to write explanatory comments to make your code easier for you
    and others to read. Finally, you read about the philosophy of keeping your code
    as simple as possible, whenever possible.
  prefs: []
  type: TYPE_NORMAL
- en: In Chapter 3, you’ll learn how to store collections of information in data structures
    called *lists*. You’ll also learn how to work through a list, manipulating any
    information in that list.
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introducing Lists
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter and the next you’ll learn what lists are and how to start working
    with the elements in a list. Lists allow you to store sets of information in one
    place, whether you have just a few items or millions of items. Lists are one of
    Python’s most powerful features readily accessible to new programmers, and they
    tie together many important concepts in programming.
  prefs: []
  type: TYPE_NORMAL
- en: What Is a List?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *list* is a collection of items in a particular order. You can make a list
    that includes the letters of the alphabet, the digits from 0 to 9, or the names
    of all the people in your family. You can put anything you want into a list, and
    the items in your list don’t have to be related in any particular way. Because
    a list usually contains more than one element, it’s a good idea to make the name
    of your list plural, such as `letters`, `digits`, or `names`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, square brackets (`[]`) indicate a list, and individual elements
    in the list are separated by commas. Here’s a simple example of a list that contains
    a few kinds of bicycles:'
  prefs: []
  type: TYPE_NORMAL
- en: '**bicycles.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'If you ask Python to print a list, Python returns its representation of the
    list, including the square brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Because this isn’t the output you want your users to see, let’s learn how to
    access the individual items in a list.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing Elements in a List
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Lists are ordered collections, so you can access any element in a list by telling
    Python the position, or *index*, of the item desired. To access an element in
    a list, write the name of the list followed by the index of the item enclosed
    in square brackets.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let’s pull out the first bicycle in the list `bicycles`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'When we ask for a single item from a list, Python returns just that element
    without square brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the result you want your users to see: clean, neatly formatted output.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use the string methods from Chapter 2 on any element in this list.
    For example, you can format the element `''trek''` to look more presentable by
    using the `title()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: This example produces the same output as the preceding example, except `'Trek'`
    is capitalized.
  prefs: []
  type: TYPE_NORMAL
- en: Index Positions Start at 0, Not 1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python considers the first item in a list to be at position 0, not position
    1\. This is true of most programming languages, and the reason has to do with
    how the list operations are implemented at a lower level. If you’re receiving
    unexpected results, ask yourself if you’re making a simple but common off-by-one
    error.
  prefs: []
  type: TYPE_NORMAL
- en: The second item in a list has an index of 1\. Using this counting system, you
    can get any element you want from a list by subtracting one from its position
    in the list. For instance, to access the fourth item in a list, you request the
    item at index 3.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following asks for the bicycles at index `1` and index `3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'This code returns the second and fourth bicycles in the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Python has a special syntax for accessing the last element in a list. If you
    ask for the item at index `-1`, Python always returns the last item in the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: This code returns the value `'specialized'`. This syntax is quite useful, because
    you’ll often want to access the last items in a list without knowing exactly how
    long the list is. This convention extends to other negative index values as well.
    The index `-2` returns the second item from the end of the list, the index `-3`
    returns the third item from the end, and so forth.
  prefs: []
  type: TYPE_NORMAL
- en: Using Individual Values from a List
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can use individual values from a list just as you would any other variable.
    For example, you can use f-strings to create a message based on a value from a
    list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try pulling the first bicycle from the list and composing a message using
    that value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'We build a sentence using the value at `bicycles[0]` and assign it to the variable
    `message`. The output is a simple sentence about the first bicycle in the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Modifying, Adding, and Removing Elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most lists you create will be *dynamic*, meaning you’ll build a list and then
    add and remove elements from it as your program runs its course. For example,
    you might create a game in which a player has to shoot aliens out of the sky.
    You could store the initial set of aliens in a list and then remove an alien from
    the list each time one is shot down. Each time a new alien appears on the screen,
    you add it to the list. Your list of aliens will increase and decrease in length
    throughout the course of the game.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying Elements in a List
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The syntax for modifying an element is similar to the syntax for accessing an
    element in a list. To change an element, use the name of the list followed by
    the index of the element you want to change, and then provide the new value you
    want that item to have.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, say we have a list of motorcycles and the first item in the list
    is `''honda''`. We can change the value of this first item after the list has
    been created:'
  prefs: []
  type: TYPE_NORMAL
- en: '**motorcycles.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we define the list `motorcycles`, with `''honda''` as the first element.
    Then we change the value of the first item to `''ducati''`. The output shows that
    the first item has been changed, while the rest of the list stays the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: You can change the value of any item in a list, not just the first item.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Elements to a List
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You might want to add a new element to a list for many reasons. For example,
    you might want to make new aliens appear in a game, add new data to a visualization,
    or add new registered users to a website you’ve built. Python provides several
    ways to add new data to existing lists.
  prefs: []
  type: TYPE_NORMAL
- en: Appending Elements to the End of a List
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The simplest way to add a new element to a list is to *append* the item to
    the list. When you append an item to a list, the new element is added to the end
    of the list. Using the same list we had in the previous example, we’ll add the
    new element `''ducati''` to the end of the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Here the `append()` method adds `''ducati''` to the end of the list, without
    affecting any of the other elements in the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The `append()` method makes it easy to build lists dynamically. For example,
    you can start with an empty list and then add items to the list using a series
    of `append()` calls. Using an empty list, let’s add the elements `''honda''`,
    `''yamaha''`, and `''suzuki''` to the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting list looks exactly the same as the lists in the previous examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Building lists this way is very common, because you often won’t know the data
    your users want to store in a program until after the program is running. To put
    your users in control, start by defining an empty list that will hold the users’
    values. Then append each new value provided to the list you just created.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting Elements into a List
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can add a new element at any position in your list by using the `insert()`
    method. You do this by specifying the index of the new element and the value of
    the new item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we insert the value `''ducati''` at the beginning of the list.
    The `insert()` method opens a space at position `0` and stores the value `''ducati''`
    at that location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: This operation shifts every other value in the list one position to the right.
  prefs: []
  type: TYPE_NORMAL
- en: Removing Elements from a List
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Often, you’ll want to remove an item or a set of items from a list. For example,
    when a player shoots down an alien from the sky, you’ll most likely want to remove
    it from the list of active aliens. Or when a user decides to cancel their account
    on a web application you created, you’ll want to remove that user from the list
    of active users. You can remove an item according to its position in the list
    or according to its value.
  prefs: []
  type: TYPE_NORMAL
- en: Removing an Item Using the del Statement
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you know the position of the item you want to remove from a list, you can
    use the `del` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we use the `del` statement to remove the first item, `''honda''`, from
    the list of motorcycles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'You can remove an item from any position in a list using the `del` statement
    if you know its index. For example, here’s how to remove the second item, `''yamaha''`,
    from the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'The second motorcycle is deleted from the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: In both examples, you can no longer access the value that was removed from the
    list after the `del` statement is used.
  prefs: []
  type: TYPE_NORMAL
- en: Removing an Item Using the pop() Method
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Sometimes you’ll want to use the value of an item after you remove it from a
    list. For example, you might want to get the *x* and *y* position of an alien
    that was just shot down, so you can draw an explosion at that position. In a web
    application, you might want to remove a user from a list of active members and
    then add that user to a list of inactive members.
  prefs: []
  type: TYPE_NORMAL
- en: The `pop()` method removes the last item in a list, but it lets you work with
    that item after removing it. The term *pop* comes from thinking of a list as a
    stack of items and popping one item off the top of the stack. In this analogy,
    the top of a stack corresponds to the end of a list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s pop a motorcycle from the list of motorcycles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: We start by defining and printing the list `motorcycles` ❶. Then we pop a value
    from the list, and assign that value to the variable `popped_motorcycle` ❷. We
    print the list ❸ to show that a value has been removed from the list. Then we
    print the popped value ❹ to prove that we still have access to the value that
    was removed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output shows that the value `''suzuki''` was removed from the end of the
    list and is now assigned to the variable `popped_motorcycle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'How might this `pop()` method be useful? Imagine that the motorcycles in the
    list are stored in chronological order, according to when we owned them. If this
    is the case, we can use the `pop()` method to print a statement about the last
    motorcycle we bought:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is a simple sentence about the most recent motorcycle we owned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Popping Items from Any Position in a List
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can use `pop()` to remove an item from any position in a list by including
    the index of the item you want to remove in parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'We start by popping the first motorcycle in the list, and then we print a message
    about that motorcycle. The output is a simple sentence describing the first motorcycle
    I ever owned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Remember that each time you use `pop()`, the item you work with is no longer
    stored in the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re unsure whether to use the `del` statement or the `pop()` method,
    here’s a simple way to decide: when you want to delete an item from a list and
    not use that item in any way, use the `del` statement; if you want to use an item
    as you remove it, use the `pop()` method.'
  prefs: []
  type: TYPE_NORMAL
- en: Removing an Item by Value
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Sometimes you won’t know the position of the value you want to remove from a
    list. If you only know the value of the item you want to remove, you can use the
    `remove()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, say we want to remove the value `''ducati''` from the list of
    motorcycles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Here the `remove()` method tells Python to figure out where `''ducati''` appears
    in the list and remove that element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use the `remove()` method to work with a value that’s being removed
    from a list. Let’s remove the value `''ducati''` and print a reason for removing
    it from the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'After defining the list ❶, we assign the value `''ducati''` to a variable called
    `too_expensive` ❷. We then use this variable to tell Python which value to remove
    from the list ❸. The value `''ducati''` has been removed from the list ❹ but is
    still accessible through the variable `too_expensive`, allowing us to print a
    statement about why we removed `''ducati''` from the list of motorcycles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Organizing a List
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Often, your lists will be created in an unpredictable order, because you can’t
    always control the order in which your users provide their data. Although this
    is unavoidable in most circumstances, you’ll frequently want to present your information
    in a particular order. Sometimes you’ll want to preserve the original order of
    your list, and other times you’ll want to change the original order. Python provides
    a number of different ways to organize your lists, depending on the situation.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting a List Permanently with the sort() Method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Python’s `sort()` method makes it relatively easy to sort a list. Imagine we
    have a list of cars and want to change the order of the list to store them alphabetically.
    To keep the task simple, let’s assume that all the values in the list are lowercase:'
  prefs: []
  type: TYPE_NORMAL
- en: '**cars.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'The `sort()` method changes the order of the list permanently. The cars are
    now in alphabetical order, and we can never revert to the original order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also sort this list in reverse-alphabetical order by passing the argument
    `reverse=True` to the `sort()` method. The following example sorts the list of
    cars in reverse-alphabetical order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, the order of the list is permanently changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Sorting a List Temporarily with the sorted() Function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To maintain the original order of a list but present it in a sorted order, you
    can use the `sorted()` function. The `sorted()` function lets you display your
    list in a particular order, but doesn’t affect the actual order of the list.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try this function on the list of cars.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'We first print the list in its original order ❶ and then in alphabetical order
    ❷. After the list is displayed in the new order, we show that the list is still
    stored in its original order ❸:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the list still exists in its original order ❶ after the `sorted()`
    function has been used. The `sorted()` function can also accept a `reverse=True`
    argument if you want to display a list in reverse-alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: Printing a List in Reverse Order
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To reverse the original order of a list, you can use the `reverse()` method.
    If we originally stored the list of cars in chronological order according to when
    we owned them, we could easily rearrange the list into reverse-chronological order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that `reverse()` doesn’t sort backward alphabetically; it simply reverses
    the order of the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: The `reverse()` method changes the order of a list permanently, but you can
    revert to the original order anytime by applying `reverse()` to the same list
    a second time.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the Length of a List
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can quickly find the length of a list by using the `len()` function. The
    list in this example has four items, so its length is `4`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: You’ll find `len()` useful when you need to identify the number of aliens that
    still need to be shot down in a game, determine the amount of data you have to
    manage in a visualization, or figure out the number of registered users on a website,
    among other tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding Index Errors When Working with Lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There’s one type of error that’s common to see when you’re working with lists
    for the first time. Let’s say you have a list with three items, and you ask for
    the fourth item:'
  prefs: []
  type: TYPE_NORMAL
- en: '**motorcycles.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'This example results in an *index error*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Python attempts to give you the item at index 3\. But when it searches the list,
    no item in `motorcycles` has an index of 3\. Because of the off-by-one nature
    of indexing in lists, this error is typical. People think the third item is item
    number 3, because they start counting at 1\. But in Python the third item is number
    2, because it starts indexing at 0.
  prefs: []
  type: TYPE_NORMAL
- en: An index error means Python can’t find an item at the index you requested. If
    an index error occurs in your program, try adjusting the index you’re asking for
    by one. Then run the program again to see if the results are correct.
  prefs: []
  type: TYPE_NORMAL
- en: 'Keep in mind that whenever you want to access the last item in a list, you
    should use the index `-1`. This will always work, even if your list has changed
    size since the last time you accessed it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'The index `-1` always returns the last item in a list, in this case the value
    `''suzuki''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'The only time this approach will cause an error is when you request the last
    item from an empty list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'No items are in `motorcycles`, so Python returns another index error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: If an index error occurs and you can’t figure out how to resolve it, try printing
    your list or just printing the length of your list. Your list might look much
    different than you thought it did, especially if it has been managed dynamically
    by your program. Seeing the actual list, or the exact number of items in your
    list, can help you sort out such logical errors.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you learned what lists are and how to work with the individual
    items in a list. You learned how to define a list and how to add and remove elements.
    You learned how to sort lists permanently and temporarily for display purposes.
    You also learned how to find the length of a list and how to avoid index errors
    when you’re working with lists.
  prefs: []
  type: TYPE_NORMAL
- en: In Chapter 4 you’ll learn how to work with items in a list more efficiently.
    By looping through each item in a list using just a few lines of code you’ll be
    able to work efficiently, even when your list contains thousands or millions of
    items.
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with Lists
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: In Chapter 3 you learned how to make a simple list, and you learned to work
    with the individual elements in a list. In this chapter you’ll learn how to loop
    through an entire list using just a few lines of code, regardless of how long
    the list is. *Looping* allows you to take the same action, or set of actions,
    with every item in a list. As a result, you’ll be able to work efficiently with
    lists of any length, including those with thousands or even millions of items.
  prefs: []
  type: TYPE_NORMAL
- en: Looping Through an Entire List
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’ll often want to run through all entries in a list, performing the same
    task with each item. For example, in a game you might want to move every element
    on the screen by the same amount. In a list of numbers, you might want to perform
    the same statistical operation on every element. Or perhaps you’ll want to display
    each headline from a list of articles on a website. When you want to do the same
    action with every item in a list, you can use Python’s `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: Say we have a list of magicians’ names, and we want to print out each name in
    the list. We could do this by retrieving each name from the list individually,
    but this approach could cause several problems. For one, it would be repetitive
    to do this with a long list of names. Also, we’d have to change our code each
    time the list’s length changed. Using a `for` loop avoids both of these issues
    by letting Python manage these issues internally.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use a `for` loop to print out each name in a list of magicians:'
  prefs: []
  type: TYPE_NORMAL
- en: '**magicians.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'We begin by defining a list, just as we did in Chapter 3. Then we define a
    `for` loop. This line tells Python to pull a name from the list `magicians`, and
    associate it with the variable `magician`. Next, we tell Python to print the name
    that’s just been assigned to `magician`. Python then repeats these last two lines,
    once for each name in the list. It might help to read this code as “For every
    magician in the list of magicians, print the magician’s name.” The output is a
    simple printout of each name in the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: A Closer Look at Looping
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Looping is important because it’s one of the most common ways a computer automates
    repetitive tasks. For example, in a simple loop like we used in *magicians.py*,
    Python initially reads the first line of the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'This line tells Python to retrieve the first value from the list `magicians`
    and associate it with the variable `magician`. This first value is `''alice''`.
    Python then reads the next line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'Python prints the current value of `magician`, which is still `''alice''`.
    Because the list contains more values, Python returns to the first line of the
    loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'Python retrieves the next name in the list, `''david''`, and associates that
    value with the variable `magician`. Python then executes the line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: Python prints the current value of `magician` again, which is now `'david'`.
    Python repeats the entire loop once more with the last value in the list, `'carolina'`.
    Because no more values are in the list, Python moves on to the next line in the
    program. In this case nothing comes after the `for` loop, so the program ends.
  prefs: []
  type: TYPE_NORMAL
- en: When you’re using loops for the first time, keep in mind that the set of steps
    is repeated once for each item in the list, no matter how many items are in the
    list. If you have a million items in your list, Python repeats these steps a million
    times—and usually very quickly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also keep in mind when writing your own `for` loops that you can choose any
    name you want for the temporary variable that will be associated with each value
    in the list. However, it’s helpful to choose a meaningful name that represents
    a single item from the list. For example, here’s a good way to start a `for` loop
    for a list of cats, a list of dogs, and a general list of items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: These naming conventions can help you follow the action being done on each item
    within a `for` loop. Using singular and plural names can help you identify whether
    a section of code is working with a single element from the list or the entire
    list.
  prefs: []
  type: TYPE_NORMAL
- en: Doing More Work Within a for Loop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can do just about anything with each item in a `for` loop. Let’s build
    on the previous example by printing a message to each magician, telling them that
    they performed a great trick:'
  prefs: []
  type: TYPE_NORMAL
- en: '**magicians.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: The only difference in this code is where we compose a message to each magician,
    starting with that magician’s name. The first time through the loop the value
    of `magician` is `'alice'`, so Python starts the first message with the name `'Alice'`.
    The second time through, the message will begin with `'David'`, and the third
    time through, the message will begin with `'Carolina'`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output shows a personalized message for each magician in the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: You can also write as many lines of code as you like in the `for` loop. Every
    indented line following the line `for magician in magicians` is considered *inside
    the loop*, and each indented line is executed once for each value in the list.
    Therefore, you can do as much work as you like with each value in the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add a second line to our message, telling each magician that we’re looking
    forward to their next trick:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'Because we have indented both calls to `print()`, each line will be executed
    once for every magician in the list. The newline (`"\n"`) in the second `print()`
    call inserts a blank line after each pass through the loop. This creates a set
    of messages that are neatly grouped for each person in the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: You can use as many lines as you like in your `for` loops. In practice, you’ll
    often find it useful to do a number of different operations with each item in
    a list when you use a `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: Doing Something After a for Loop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What happens once a `for` loop has finished executing? Usually, you’ll want
    to summarize a block of output or move on to other work that your program must
    accomplish.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any lines of code after the `for` loop that are not indented are executed once
    without repetition. Let’s write a thank you to the group of magicians as a whole,
    thanking them for putting on an excellent show. To display this group message
    after all of the individual messages have been printed, we place the thank you
    message after the `for` loop, without indentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'The first two calls to `print()` are repeated once for each magician in the
    list, as you saw earlier. However, because the last line is not indented, it’s
    printed only once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: When you’re processing data using a `for` loop, you’ll find that this is a good
    way to summarize an operation that was performed on an entire dataset. For example,
    you might use a `for` loop to initialize a game by running through a list of characters
    and displaying each character on the screen. You might then write some additional
    code after this loop that displays a *Play Now* button after all the characters
    have been drawn to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding Indentation Errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python uses indentation to determine how a line, or group of lines, is related
    to the rest of the program. In the previous examples, the lines that printed messages
    to individual magicians were part of the `for` loop because they were indented.
    Python’s use of indentation makes code very easy to read. Basically, it uses whitespace
    to force you to write neatly formatted code with a clear visual structure. In
    longer Python programs, you’ll notice blocks of code indented at a few different
    levels. These indentation levels help you gain a general sense of the overall
    program’s organization.
  prefs: []
  type: TYPE_NORMAL
- en: As you begin to write code that relies on proper indentation, you’ll need to
    watch for a few common *indentation errors*. For example, people sometimes indent
    lines of code that don’t need to be indented or forget to indent lines that need
    to be indented. Seeing examples of these errors now will help you avoid them in
    the future and correct them when they do appear in your own programs.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s examine some of the more common indentation errors.
  prefs: []
  type: TYPE_NORMAL
- en: Forgetting to Indent
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Always indent the line after the `for` statement in a loop. If you forget,
    Python will remind you:'
  prefs: []
  type: TYPE_NORMAL
- en: '**magicians.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'The call to `print()` ❶ should be indented, but it’s not. When Python expects
    an indented block and doesn’t find one, it lets you know which line it had a problem
    with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: You can usually resolve this kind of indentation error by indenting the line
    or lines immediately after the `for` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Forgetting to Indent Additional Lines
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes your loop will run without any errors but won’t produce the expected
    result. This can happen when you’re trying to do several tasks in a loop and you
    forget to indent some of its lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, this is what happens when we forget to indent the second line
    in the loop that tells each magician we’re looking forward to their next trick:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'The second call to `print()` ❶ is supposed to be indented, but because Python
    finds at least one indented line after the `for` statement, it doesn’t report
    an error. As a result, the first `print()` call is executed once for each name
    in the list because it is indented. The second `print()` call is not indented,
    so it is executed only once after the loop has finished running. Because the final
    value associated with `magician` is `''carolina''`, she is the only one who receives
    the “looking forward to the next trick” message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: This is a *logical error*. The syntax is valid Python code, but the code does
    not produce the desired result because a problem occurs in its logic. If you expect
    to see a certain action repeated once for each item in a list and it’s executed
    only once, determine whether you need to simply indent a line or a group of lines.
  prefs: []
  type: TYPE_NORMAL
- en: Indenting Unnecessarily
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you accidentally indent a line that doesn’t need to be indented, Python
    informs you about the unexpected indent:'
  prefs: []
  type: TYPE_NORMAL
- en: '**hello_world.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'We don’t need to indent the `print()` call, because it isn’t part of a loop;
    hence, Python reports that error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: You can avoid unexpected indentation errors by indenting only when you have
    a specific reason to do so. In the programs you’re writing at this point, the
    only lines you should indent are the actions you want to repeat for each item
    in a `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: Indenting Unnecessarily After the Loop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you accidentally indent code that should run after a loop has finished, that
    code will be repeated once for each item in the list. Sometimes this prompts Python
    to report an error, but often this will result in a logical error.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let’s see what happens when we accidentally indent the line that
    thanked the magicians as a group for putting on a good show:'
  prefs: []
  type: TYPE_NORMAL
- en: '**magicians.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the last line ❶ is indented, it’s printed once for each person in the
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: This is another logical error, similar to the one in “Forgetting to Indent Additional
    Lines” on page 54. Because Python doesn’t know what you’re trying to accomplish
    with your code, it will run all code that is written in valid syntax. If an action
    is repeated many times when it should be executed only once, you probably need
    to unindent the code for that action.
  prefs: []
  type: TYPE_NORMAL
- en: Forgetting the Colon
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The colon at the end of a `for` statement tells Python to interpret the next
    line as the start of a loop.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'If you accidentally forget the colon ❶, you’ll get a syntax error because Python
    doesn’t know exactly what you’re trying to do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: Python doesn’t know if you simply forgot the colon, or if you meant to write
    additional code to set up a more complex loop. If the interpreter can identify
    a possible fix it will suggest one, like adding a colon at the end of a line,
    as it does here with the response `expected ':'`. Some errors have easy, obvious
    fixes, thanks to the suggestions in Python’s tracebacks. Some errors are much
    harder to resolve, even when the eventual fix only involves a single character.
    Don’t feel bad when a small fix takes a long time to find; you are absolutely
    not alone in this experience.
  prefs: []
  type: TYPE_NORMAL
- en: Making Numerical Lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many reasons exist to store a set of numbers. For example, you’ll need to keep
    track of the positions of each character in a game, and you might want to keep
    track of a player’s high scores as well. In data visualizations, you’ll almost
    always work with sets of numbers, such as temperatures, distances, population
    sizes, or latitude and longitude values, among other types of numerical sets.
  prefs: []
  type: TYPE_NORMAL
- en: Lists are ideal for storing sets of numbers, and Python provides a variety of
    tools to help you work efficiently with lists of numbers. Once you understand
    how to use these tools effectively, your code will work well even when your lists
    contain millions of items.
  prefs: []
  type: TYPE_NORMAL
- en: Using the range() Function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Python’s `range()` function makes it easy to generate a series of numbers.
    For example, you can use the `range()` function to print a series of numbers like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**first_numbers.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'Although this code looks like it should print the numbers from 1 to 5, it doesn’t
    print the number 5:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `range()` prints only the numbers 1 through 4\. This is another
    result of the off-by-one behavior you’ll see often in programming languages. The
    `range()` function causes Python to start counting at the first value you give
    it, and it stops when it reaches the second value you provide. Because it stops
    at that second value, the output never contains the end value, which would have
    been 5 in this case.
  prefs: []
  type: TYPE_NORMAL
- en: 'To print the numbers from 1 to 5, you would use `range(1, 6)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'This time the output starts at 1 and ends at 5:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: If your output is different from what you expect when you’re using `range()`,
    try adjusting your end value by 1.
  prefs: []
  type: TYPE_NORMAL
- en: You can also pass `range()` only one argument, and it will start the sequence
    of numbers at 0\. For example, `range(6)` would return the numbers from 0 through
    5.
  prefs: []
  type: TYPE_NORMAL
- en: Using range() to Make a List of Numbers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to make a list of numbers, you can convert the results of `range()`
    directly into a list using the `list()` function. When you wrap `list()` around
    a call to the `range()` function, the output will be a list of numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the example in the previous section, we simply printed out a series of numbers.
    We can use `list()` to convert that same set of numbers into a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: We can also use the `range()` function to tell Python to skip numbers in a given
    range. If you pass a third argument to `range()`, Python uses that value as a
    step size when generating numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here’s how to list the even numbers between 1 and 10:'
  prefs: []
  type: TYPE_NORMAL
- en: '**even_numbers.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the `range()` function starts with the value 2 and then adds
    2 to that value. It adds 2 repeatedly until it reaches or passes the end value,
    11, and produces this result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'You can create almost any set of numbers you want to using the `range()` function.
    For example, consider how you might make a list of the first 10 square numbers
    (that is, the square of each integer from 1 through 10). In Python, two asterisks
    (`**`) represent exponents. Here’s how you might put the first 10 square numbers
    into a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '**square_numbers.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'We start with an empty list called `squares`. Then, we tell Python to loop
    through each value from 1 to 10 using the `range()` function. Inside the loop,
    the current value is raised to the second power and assigned to the variable `square`
    ❶. Each new value of `square` is then appended to the list `squares` ❷. Finally,
    when the loop has finished running, the list of squares is printed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'To write this code more concisely, omit the temporary variable `square` and
    append each new value directly to the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: This line does the same work as the lines inside the `for` loop in the previous
    listing. Each value in the loop is raised to the second power and then immediately
    appended to the list of squares.
  prefs: []
  type: TYPE_NORMAL
- en: You can use either of these approaches when you’re making more complex lists.
    Sometimes using a temporary variable makes your code easier to read; other times
    it makes the code unnecessarily long. Focus first on writing code that you understand
    clearly, and does what you want it to do. Then look for more efficient approaches
    as you review your code.
  prefs: []
  type: TYPE_NORMAL
- en: Simple Statistics with a List of Numbers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A few Python functions are helpful when working with lists of numbers. For
    example, you can easily find the minimum, maximum, and sum of a list of numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: List Comprehensions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The approach described earlier for generating the list `squares` consisted of
    using three or four lines of code. A *list comprehension* allows you to generate
    this same list in just one line of code. A list comprehension combines the `for`
    loop and the creation of new elements into one line, and automatically appends
    each new element. List comprehensions are not always presented to beginners, but
    I’ve included them here because you’ll most likely see them as soon as you start
    looking at other people’s code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example builds the same list of square numbers you saw earlier
    but uses a list comprehension:'
  prefs: []
  type: TYPE_NORMAL
- en: '**squares.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: To use this syntax, begin with a descriptive name for the list, such as `squares`.
    Next, open a set of square brackets and define the expression for the values you
    want to store in the new list. In this example the expression is `value**2`, which
    raises the value to the second power. Then, write a `for` loop to generate the
    numbers you want to feed into the expression, and close the square brackets. The
    `for` loop in this example is `for value in range(1, 11)`, which feeds the values
    1 through 10 into the expression `value**2`. Note that no colon is used at the
    end of the `for` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result is the same list of square numbers you saw earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: It takes practice to write your own list comprehensions, but you’ll find them
    worthwhile once you become comfortable creating ordinary lists. When you’re writing
    three or four lines of code to generate lists and it begins to feel repetitive,
    consider writing your own list comprehensions.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Part of a List
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Chapter 3 you learned how to access single elements in a list, and in this
    chapter you’ve been learning how to work through all the elements in a list. You
    can also work with a specific group of items in a list, called a *slice* in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Slicing a List
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To make a slice, you specify the index of the first and last elements you want
    to work with. As with the `range()` function, Python stops one item before the
    second index you specify. To output the first three elements in a list, you would
    request indices `0` through `3`, which would return elements `0`, `1`, and `2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example involves a list of players on a team:'
  prefs: []
  type: TYPE_NORMAL
- en: '**players.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'This code prints a slice of the list. The output retains the structure of the
    list, and includes the first three players in the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'You can generate any subset of a list. For example, if you want the second,
    third, and fourth items in a list, you would start the slice at index `1` and
    end it at index `4`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: 'This time the slice starts with `''martina''` and ends with `''florence''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: 'If you omit the first index in a slice, Python automatically starts your slice
    at the beginning of the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'Without a starting index, Python starts at the beginning of the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: 'A similar syntax works if you want a slice that includes the end of a list.
    For example, if you want all items from the third item through the last item,
    you can start with index `2` and omit the second index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: 'Python returns all items from the third item through the end of the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: 'This syntax allows you to output all of the elements from any point in your
    list to the end, regardless of the length of the list. Recall that a negative
    index returns an element a certain distance from the end of a list; therefore,
    you can output any slice from the end of a list. For example, if we want to output
    the last three players on the roster, we can use the slice `players[-3:]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: This prints the names of the last three players and will continue to work as
    the list of players changes in size.
  prefs: []
  type: TYPE_NORMAL
- en: Looping Through a Slice
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can use a slice in a `for` loop if you want to loop through a subset of
    the elements in a list. In the next example, we loop through the first three players
    and print their names as part of a simple roster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of looping through the entire list of players, Python loops through
    only the first three names ❶:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: Slices are very useful in a number of situations. For instance, when you’re
    creating a game, you could add a player’s final score to a list every time that
    player finishes playing. You could then get a player’s top three scores by sorting
    the list in decreasing order and taking a slice that includes just the first three
    scores. When you’re working with data, you can use slices to process your data
    in chunks of a specific size. Or, when you’re building a web application, you
    could use slices to display information in a series of pages with an appropriate
    amount of information on each page.
  prefs: []
  type: TYPE_NORMAL
- en: Copying a List
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Often, you’ll want to start with an existing list and make an entirely new list
    based on the first one. Let’s explore how copying a list works and examine one
    situation in which copying a list is useful.
  prefs: []
  type: TYPE_NORMAL
- en: To copy a list, you can make a slice that includes the entire original list
    by omitting the first index and the second index (`[:]`). This tells Python to
    make a slice that starts at the first item and ends with the last item, producing
    a copy of the entire list.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, imagine we have a list of our favorite foods and want to make
    a separate list of foods that a friend likes. This friend likes everything in
    our list so far, so we can create their list by copying ours:'
  prefs: []
  type: TYPE_NORMAL
- en: '**foods.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we make a list of the foods we like called `my_foods`. Then we make
    a new list called `friend_foods`. We make a copy of `my_foods` by asking for a
    slice of `my_foods` without specifying any indices ❶, and assign the copy to `friend_foods`.
    When we print each list, we see that they both contain the same foods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: 'To prove that we actually have two separate lists, we’ll add a new food to
    each list and show that each list keeps track of the appropriate person’s favorite
    foods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: 'We copy the original items in `my_foods` to the new list `friend_foods`, as
    we did in the previous example ❶. Next, we add a new food to each list: we add
    `''cannoli''` to `my_foods` ❷, and we add `''ice cream''` to `friend_foods` ❸.
    We then print the two lists to see whether each of these foods is in the appropriate
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: 'The output shows that `''cannoli''` now appears in our list of favorite foods
    but `''ice cream''` does not. We can see that `''ice cream''` now appears in our
    friend’s list but `''cannoli''` does not. If we had simply set `friend_foods`
    equal to `my_foods`, we would not produce two separate lists. For example, here’s
    what happens when you try to copy a list without using a slice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: Instead of assigning a copy of `my_foods` to `friend_foods`, we set `friend_foods`
    equal to `my_foods`. This syntax actually tells Python to associate the new variable
    `friend_foods` with the list that is already associated with `my_foods`, so now
    both variables point to the same list. As a result, when we add `'cannoli'` to
    `my_foods`, it will also appear in `friend_foods`. Likewise `'ice cream'` will
    appear in both lists, even though it appears to be added only to `friend_foods`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output shows that both lists are the same now, which is not what we wanted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: Tuples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lists work well for storing collections of items that can change throughout
    the life of a program. The ability to modify lists is particularly important when
    you’re working with a list of users on a website or a list of characters in a
    game. However, sometimes you’ll want to create a list of items that cannot change.
    Tuples allow you to do just that. Python refers to values that cannot change as
    *immutable*, and an immutable list is called a *tuple*.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a Tuple
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A tuple looks just like a list, except you use parentheses instead of square
    brackets. Once you define a tuple, you can access individual elements by using
    each item’s index, just as you would for a list.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we have a rectangle that should always be a certain size, we
    can ensure that its size doesn’t change by putting the dimensions into a tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '**dimensions.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: 'We define the tuple `dimensions`, using parentheses instead of square brackets.
    Then we print each element in the tuple individually, using the same syntax we’ve
    been using to access elements in a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s see what happens if we try to change one of the items in the tuple `dimensions`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: 'This code tries to change the value of the first dimension, but Python returns
    a type error. Because we’re trying to alter a tuple, which can’t be done to that
    type of object, Python tells us we can’t assign a new value to an item in a tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: This is beneficial because we want Python to raise an error when a line of code
    tries to change the dimensions of the rectangle.
  prefs: []
  type: TYPE_NORMAL
- en: Looping Through All Values in a Tuple
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can loop over all the values in a tuple using a `for` loop, just as you
    did with a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: 'Python returns all the elements in the tuple, just as it would for a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: Writing Over a Tuple
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Although you can’t modify a tuple, you can assign a new value to a variable
    that represents a tuple. For example, if we wanted to change the dimensions of
    this rectangle, we could redefine the entire tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: 'The first four lines define the original tuple and print the initial dimensions.
    We then associate a new tuple with the variable `dimensions`, and print the new
    values. Python doesn’t raise any errors this time, because reassigning a variable
    is valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: When compared with lists, tuples are simple data structures. Use them when you
    want to store a set of values that should not be changed throughout the life of
    a program.
  prefs: []
  type: TYPE_NORMAL
- en: Styling Your Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you’re writing longer programs, it’s a good idea to learn how to style
    your code consistently. Take the time to make your code as easy as possible to
    read. Writing easy-to-read code helps you keep track of what your programs are
    doing and helps others understand your code as well.
  prefs: []
  type: TYPE_NORMAL
- en: Python programmers have agreed on a number of styling conventions to ensure
    that everyone’s code is structured in roughly the same way. Once you’ve learned
    to write clean Python code, you should be able to understand the overall structure
    of anyone else’s Python code, as long as they follow the same guidelines. If you’re
    hoping to become a professional programmer at some point, you should begin following
    these guidelines as soon as possible to develop good habits.
  prefs: []
  type: TYPE_NORMAL
- en: The Style Guide
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When someone wants to make a change to the Python language, they write a *Python
    Enhancement Proposal (PEP)*. One of the oldest PEPs is *PEP 8*, which instructs
    Python programmers on how to style their code. PEP 8 is fairly lengthy, but much
    of it relates to more complex coding structures than what you’ve seen so far.
  prefs: []
  type: TYPE_NORMAL
- en: The Python style guide was written with the understanding that code is read
    more often than it is written. You’ll write your code once and then start reading
    it as you begin debugging. When you add features to a program, you’ll spend more
    time reading your code. When you share your code with other programmers, they’ll
    read your code as well.
  prefs: []
  type: TYPE_NORMAL
- en: Given the choice between writing code that’s easier to write or code that’s
    easier to read, Python programmers will almost always encourage you to write code
    that’s easier to read. The following guidelines will help you write clear code
    from the start.
  prefs: []
  type: TYPE_NORMAL
- en: Indentation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: PEP 8 recommends that you use four spaces per indentation level. Using four
    spaces improves readability while leaving room for multiple levels of indentation
    on each line.
  prefs: []
  type: TYPE_NORMAL
- en: In a word processing document, people often use tabs rather than spaces to indent.
    This works well for word processing documents, but the Python interpreter gets
    confused when tabs are mixed with spaces. Every text editor provides a setting
    that lets you use the TAB key but then converts each tab to a set number of spaces.
    You should definitely use your TAB key, but also make sure your editor is set
    to insert spaces rather than tabs into your document.
  prefs: []
  type: TYPE_NORMAL
- en: Mixing tabs and spaces in your file can cause problems that are very difficult
    to diagnose. If you think you have a mix of tabs and spaces, you can convert all
    tabs in a file to spaces in most editors.
  prefs: []
  type: TYPE_NORMAL
- en: Line Length
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many Python programmers recommend that each line should be less than 80 characters.
    Historically, this guideline developed because most computers could fit only 79
    characters on a single line in a terminal window. Currently, people can fit much
    longer lines on their screens, but other reasons exist to adhere to the 79-character
    standard line length.
  prefs: []
  type: TYPE_NORMAL
- en: Professional programmers often have several files open on the same screen, and
    using the standard line length allows them to see entire lines in two or three
    files that are open side by side onscreen. PEP 8 also recommends that you limit
    all of your comments to 72 characters per line, because some of the tools that
    generate automatic documentation for larger projects add formatting characters
    at the beginning of each commented line.
  prefs: []
  type: TYPE_NORMAL
- en: The PEP 8 guidelines for line length are not set in stone, and some teams prefer
    a 99-character limit. Don’t worry too much about line length in your code as you’re
    learning, but be aware that people who are working collaboratively almost always
    follow the PEP 8 guidelines. Most editors allow you to set up a visual cue, usually
    a vertical line on your screen, that shows you where these limits are.
  prefs: []
  type: TYPE_NORMAL
- en: Blank Lines
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To group parts of your program visually, use blank lines. You should use blank
    lines to organize your files, but don’t do so excessively. By following the examples
    provided in this book, you should strike the right balance. For example, if you
    have five lines of code that build a list and then another three lines that do
    something with that list, it’s appropriate to place a blank line between the two
    sections. However, you should not place three or four blank lines between the
    two sections.
  prefs: []
  type: TYPE_NORMAL
- en: Blank lines won’t affect how your code runs, but they will affect the readability
    of your code. The Python interpreter uses horizontal indentation to interpret
    the meaning of your code, but it disregards vertical spacing.
  prefs: []
  type: TYPE_NORMAL
- en: Other Style Guidelines
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: PEP 8 has many additional styling recommendations, but most of the guidelines
    refer to more complex programs than what you’re writing at this point. As you
    learn more complex Python structures, I’ll share the relevant parts of the PEP
    8 guidelines.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you learned how to work efficiently with the elements in a
    list. You learned how to work through a list using a `for` loop, how Python uses
    indentation to structure a program, and how to avoid some common indentation errors.
    You learned to make simple numerical lists, as well as a few operations you can
    perform on numerical lists. You learned how to slice a list to work with a subset
    of items and how to copy lists properly using a slice. You also learned about
    tuples, which provide a degree of protection to a set of values that shouldn’t
    change, and how to style your increasingly complex code to make it easy to read.
  prefs: []
  type: TYPE_NORMAL
- en: In Chapter 5, you’ll learn to respond appropriately to different conditions
    by using `if` statements. You’ll learn to string together relatively complex sets
    of conditional tests to respond appropriately to exactly the kind of situation
    or information you’re looking for. You’ll also learn to use `if` statements while
    looping through a list to take specific actions with selected elements from a
    list.
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: if Statements
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: Programming often involves examining a set of conditions and deciding which
    action to take based on those conditions. Python’s `if` statement allows you to
    examine the current state of a program and respond appropriately to that state.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll learn to write conditional tests, which allow you to
    check any condition of interest. You’ll learn to write simple `if` statements,
    and you’ll learn how to create a more complex series of `if` statements to identify
    when the exact conditions you want are present. You’ll then apply this concept
    to lists, so you’ll be able to write a `for` loop that handles most items in a
    list one way but handles certain items with specific values in a different way.
  prefs: []
  type: TYPE_NORMAL
- en: A Simple Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following example shows how `if` tests let you respond to special situations
    correctly. Imagine you have a list of cars and you want to print out the name
    of each car. Car names are proper names, so the names of most cars should be printed
    in title case. However, the value `''bmw''` should be printed in all uppercase.
    The following code loops through a list of car names and looks for the value `''bmw''`.
    Whenever the value is `''bmw''`, it’s printed in uppercase instead of title case:'
  prefs: []
  type: TYPE_NORMAL
- en: '**cars.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: 'The loop in this example first checks if the current value of `car` is `''bmw''`
    ❶. If it is, the value is printed in uppercase. If the value of `car` is anything
    other than `''bmw''`, it’s printed in title case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: This example combines a number of the concepts you’ll learn about in this chapter.
    Let’s begin by looking at the kinds of tests you can use to examine the conditions
    in your program.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional Tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the heart of every `if` statement is an expression that can be evaluated
    as `True` or `False` and is called a *conditional test*. Python uses the values
    `True` and `False` to decide whether the code in an `if` statement should be executed.
    If a conditional test evaluates to `True`, Python executes the code following
    the `if` statement. If the test evaluates to `False`, Python ignores the code
    following the `if` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Checking for Equality
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Most conditional tests compare the current value of a variable to a specific
    value of interest. The simplest conditional test checks whether the value of a
    variable is equal to the value of interest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: The first line sets the value of `car` to `'bmw'` using a single equal sign,
    as you’ve seen many times already. The next line checks whether the value of `car`
    is `'bmw'` by using a double equal sign (`==`). This *equality operator* returns
    `True` if the values on the left and right side of the operator match, and `False`
    if they don’t match. The values in this example match, so Python returns `True`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the value of `car` is anything other than `''bmw''`, this test returns
    `False`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: 'A single equal sign is really a statement; you might read the first line of
    code here as “Set the value of `car` equal to `''audi''`.” On the other hand,
    a double equal sign asks a question: “Is the value of `car` equal to `''bmw''`?”
    Most programming languages use equal signs in this way.'
  prefs: []
  type: TYPE_NORMAL
- en: Ignoring Case When Checking for Equality
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Testing for equality is case sensitive in Python. For example, two values with
    different capitalization are not considered equal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: 'If case matters, this behavior is advantageous. But if case doesn’t matter
    and instead you just want to test the value of a variable, you can convert the
    variable’s value to lowercase before doing the comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: 'This test will return `True` no matter how the value `''Audi''` is formatted
    because the test is now case insensitive. The `lower()` method doesn’t change
    the value that was originally stored in `car`, so you can do this kind of comparison
    without affecting the original variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: We first assign the capitalized string `'Audi'` to the variable `car`. Then,
    we convert the value of `car` to lowercase and compare the lowercase value to
    the string `'audi'`. The two strings match, so Python returns `True`. We can see
    that the value stored in `car` has not been affected by the `lower()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Websites enforce certain rules for the data that users enter in a manner similar
    to this. For example, a site might use a conditional test like this to ensure
    that every user has a truly unique username, not just a variation on the capitalization
    of another person’s username. When someone submits a new username, that new username
    is converted to lowercase and compared to the lowercase versions of all existing
    usernames. During this check, a username like `'John'` will be rejected if any
    variation of `'john'` is already in use.
  prefs: []
  type: TYPE_NORMAL
- en: Checking for Inequality
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you want to determine whether two values are not equal, you can use the
    *inequality operator* (`!=`). Let’s use another `if` statement to examine how
    to use the inequality operator. We’ll store a requested pizza topping in a variable
    and then print a message if the person did not order anchovies:'
  prefs: []
  type: TYPE_NORMAL
- en: '**toppings.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: This code compares the value of `requested_topping` to the value `'anchovies'`.
    If these two values do not match, Python returns `True` and executes the code
    following the `if` statement. If the two values match, Python returns `False`
    and does not run the code following the `if` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the value of `requested_topping` is not `''anchovies''`, the `print()`
    function is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: Most of the conditional expressions you write will test for equality, but sometimes
    you’ll find it more efficient to test for inequality.
  prefs: []
  type: TYPE_NORMAL
- en: Numerical Comparisons
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Testing numerical values is pretty straightforward. For example, the following
    code checks whether a person is 18 years old:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also test to see if two numbers are not equal. For example, the following
    code prints a message if the given answer is not correct:'
  prefs: []
  type: TYPE_NORMAL
- en: '**magic_number.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: 'The conditional test passes, because the value of `answer` (`17`) is not equal
    to `42`. Because the test passes, the indented code block is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: 'You can include various mathematical comparisons in your conditional statements
    as well, such as less than, less than or equal to, greater than, and greater than
    or equal to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: Each mathematical comparison can be used as part of an `if` statement, which
    can help you detect the exact conditions of interest.
  prefs: []
  type: TYPE_NORMAL
- en: Checking Multiple Conditions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may want to check multiple conditions at the same time. For example, sometimes
    you might need two conditions to be `True` to take an action. Other times, you
    might be satisfied with just one condition being `True`. The keywords `and` and
    `or` can help you in these situations.
  prefs: []
  type: TYPE_NORMAL
- en: Using and to Check Multiple Conditions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To check whether two conditions are both `True` simultaneously, use the keyword
    `and` to combine the two conditional tests; if each test passes, the overall expression
    evaluates to `True`. If either test fails or if both tests fail, the expression
    evaluates to `False`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you can check whether two people are both over 21 by using the
    following test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: First, we define two ages, `age_0` and `age_1`. Then we check whether both ages
    are 21 or older ❶. The test on the left passes, but the test on the right fails,
    so the overall conditional expression evaluates to `False`. We then change `age_1`
    to 22 ❷. The value of `age_1` is now greater than 21, so both individual tests
    pass, causing the overall conditional expression to evaluate as `True`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To improve readability, you can use parentheses around the individual tests,
    but they are not required. If you use parentheses, your test would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: Using or to Check Multiple Conditions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The keyword `or` allows you to check multiple conditions as well, but it passes
    when either or both of the individual tests pass. An `or` expression fails only
    when both individual tests fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider two ages again, but this time we’ll look for only one person
    to be over 21:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: We start with two age variables again. Because the test for `age_0` ❶ passes,
    the overall expression evaluates to `True`. We then lower `age_0` to 18\. In the
    final test ❷, both tests now fail and the overall expression evaluates to `False`.
  prefs: []
  type: TYPE_NORMAL
- en: Checking Whether a Value Is in a List
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes it’s important to check whether a list contains a certain value before
    taking an action. For example, you might want to check whether a new username
    already exists in a list of current usernames before completing someone’s registration
    on a website. In a mapping project, you might want to check whether a submitted
    location already exists in a list of known locations.
  prefs: []
  type: TYPE_NORMAL
- en: To find out whether a particular value is already in a list, use the keyword
    `in`. Let’s consider some code you might write for a pizzeria. We’ll make a list
    of toppings a customer has requested for a pizza and then check whether certain
    toppings are in the list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: The keyword `in` tells Python to check for the existence of `'mushrooms'` and
    `'pepperoni'` in the list `requested_toppings`. This technique is quite powerful
    because you can create a list of essential values, and then easily check whether
    the value you’re testing matches one of the values in the list.
  prefs: []
  type: TYPE_NORMAL
- en: Checking Whether a Value Is Not in a List
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Other times, it’s important to know if a value does not appear in a list. You
    can use the keyword `not` in this situation. For example, consider a list of users
    who are banned from commenting in a forum. You can check whether a user has been
    banned before allowing that person to submit a comment:'
  prefs: []
  type: TYPE_NORMAL
- en: '**banned_users.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: The `if` statement here reads quite clearly. If the value of `user` is not in
    the list `banned_users`, Python returns `True` and executes the indented line.
  prefs: []
  type: TYPE_NORMAL
- en: 'The user `''marie''` is not in the list `banned_users`, so she sees a message
    inviting her to post a response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: Boolean Expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you learn more about programming, you’ll hear the term *Boolean expression*
    at some point. A Boolean expression is just another name for a conditional test.
    A *Boolean value* is either `True` or `False`, just like the value of a conditional
    expression after it has been evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Boolean values are often used to keep track of certain conditions, such as
    whether a game is running or whether a user can edit certain content on a website:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: Boolean values provide an efficient way to track the state of a program or a
    particular condition that is important in your program.
  prefs: []
  type: TYPE_NORMAL
- en: if Statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you understand conditional tests, you can start writing `if` statements.
    Several different kinds of `if` statements exist, and your choice of which to
    use depends on the number of conditions you need to test. You saw several examples
    of `if` statements in the discussion about conditional tests, but now let’s dig
    deeper into the topic.
  prefs: []
  type: TYPE_NORMAL
- en: Simple if Statements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The simplest kind of `if` statement has one test and one action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: You can put any conditional test in the first line and just about any action
    in the indented block following the test. If the conditional test evaluates to
    `True`, Python executes the code following the `if` statement. If the test evaluates
    to `False`, Python ignores the code following the `if` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say we have a variable representing a person’s age, and we want to know
    if that person is old enough to vote. The following code tests whether the person
    can vote:'
  prefs: []
  type: TYPE_NORMAL
- en: '**voting.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: 'Python checks to see whether the value of `age` is greater than or equal to
    18\. It is, so Python executes the indented `print()` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: Indentation plays the same role in `if` statements as it did in `for` loops.
    All indented lines after an `if` statement will be executed if the test passes,
    and the entire block of indented lines will be ignored if the test does not pass.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can have as many lines of code as you want in the block following the `if`
    statement. Let’s add another line of output if the person is old enough to vote,
    asking if the individual has registered to vote yet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: 'The conditional test passes, and both `print()` calls are indented, so both
    lines are printed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: If the value of `age` is less than 18, this program would produce no output.
  prefs: []
  type: TYPE_NORMAL
- en: if-else Statements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Often, you’ll want to take one action when a conditional test passes and a different
    action in all other cases. Python’s `if`-`else` syntax makes this possible. An
    `if`-`else` block is similar to a simple `if` statement, but the `else` statement
    allows you to define an action or set of actions that are executed when the conditional
    test fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll display the same message we had previously if the person is old enough
    to vote, but this time we’ll add a message for anyone who is not old enough to
    vote:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: 'If the conditional test ❶ passes, the first block of indented `print()` calls
    is executed. If the test evaluates to `False`, the `else` block ❷ is executed.
    Because `age` is less than 18 this time, the conditional test fails and the code
    in the `else` block is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: 'This code works because it has only two possible situations to evaluate: a
    person is either old enough to vote or not old enough to vote. The `if`-`else`
    structure works well in situations in which you want Python to always execute
    one of two possible actions. In a simple `if-else` chain like this, one of the
    two actions will always be executed.'
  prefs: []
  type: TYPE_NORMAL
- en: The if-elif-else Chain
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Often, you’ll need to test more than two possible situations, and to evaluate
    these you can use Python’s `if`-`elif`-`else` syntax. Python executes only one
    block in an `if`-`elif`-`else` chain. It runs each conditional test in order,
    until one passes. When a test passes, the code following that test is executed
    and Python skips the rest of the tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many real-world situations involve more than two possible conditions. For example,
    consider an amusement park that charges different rates for different age groups:'
  prefs: []
  type: TYPE_NORMAL
- en: Admission for anyone under age 4 is free.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Admission for anyone between the ages of 4 and 18 is $25.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Admission for anyone age 18 or older is $40.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How can we use an `if` statement to determine a person’s admission rate? The
    following code tests for the age group of a person and then prints an admission
    price message:'
  prefs: []
  type: TYPE_NORMAL
- en: '**amusement_park.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: The `if` test ❶ checks whether a person is under 4 years old. When the test
    passes, an appropriate message is printed and Python skips the rest of the tests.
    The `elif` line ❷ is really another `if` test, which runs only if the previous
    test failed. At this point in the chain, we know the person is at least 4 years
    old because the first test failed. If the person is under 18, an appropriate message
    is printed and Python skips the `else` block. If both the `if` and `elif` tests
    fail, Python runs the code in the `else` block ❸.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example the `if` test ❶ evaluates to `False`, so its code block is
    not executed. However, the `elif` test evaluates to `True` (12 is less than 18)
    so its code is executed. The output is one sentence, informing the user of the
    admission cost:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: Any age greater than 17 would cause the first two tests to fail. In these situations,
    the `else` block would be executed and the admission price would be $40.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rather than printing the admission price within the `if`-`elif`-`else` block,
    it would be more concise to set just the price inside the `if`-`elif`-`else` chain
    and then have a single `print()` call that runs after the chain has been evaluated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: The indented lines set the value of `price` according to the person’s age, as
    in the previous example. After the price is set by the `if`-`elif`-`else` chain,
    a separate unindented `print()` call uses this value to display a message reporting
    the person’s admission price.
  prefs: []
  type: TYPE_NORMAL
- en: This code produces the same output as the previous example, but the purpose
    of the `if`-`elif`-`else` chain is narrower. Instead of determining a price and
    displaying a message, it simply determines the admission price. In addition to
    being more efficient, this revised code is easier to modify than the original
    approach. To change the text of the output message, you would need to change only
    one `print()` call rather than three separate `print()` calls.
  prefs: []
  type: TYPE_NORMAL
- en: Using Multiple elif Blocks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can use as many `elif` blocks in your code as you like. For example, if
    the amusement park were to implement a discount for seniors, you could add one
    more conditional test to the code to determine whether someone qualifies for the
    senior discount. Let’s say that anyone 65 or older pays half the regular admission,
    or $20:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: Most of this code is unchanged. The second `elif` block now checks to make sure
    a person is less than age 65 before assigning them the full admission rate of
    $40\. Notice that the value assigned in the `else` block needs to be changed to
    $20, because the only ages that make it to this block are for people 65 or older.
  prefs: []
  type: TYPE_NORMAL
- en: Omitting the else Block
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Python does not require an `else` block at the end of an `if`-`elif` chain.
    Sometimes, an `else` block is useful. Other times, it’s clearer to use an additional
    `elif` statement that catches the specific condition of interest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: The final `elif` block assigns a price of $20 when the person is 65 or older,
    which is a little clearer than the general `else` block. With this change, every
    block of code must pass a specific test in order to be executed.
  prefs: []
  type: TYPE_NORMAL
- en: The `else` block is a catchall statement. It matches any condition that wasn’t
    matched by a specific `if` or `elif` test, and that can sometimes include invalid
    or even malicious data. If you have a specific final condition you’re testing
    for, consider using a final `elif` block and omit the `else` block. As a result,
    you’ll be more confident that your code will run only under the correct conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Testing Multiple Conditions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `if`-`elif`-`else` chain is powerful, but it’s only appropriate to use when
    you just need one test to pass. As soon as Python finds one test that passes,
    it skips the rest of the tests. This behavior is beneficial, because it’s efficient
    and allows you to test for one specific condition.
  prefs: []
  type: TYPE_NORMAL
- en: However, sometimes it’s important to check all conditions of interest. In this
    case, you should use a series of simple `if` statements with no `elif` or `else`
    blocks. This technique makes sense when more than one condition could be `True`,
    and you want to act on every condition that is `True`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s reconsider the pizzeria example. If someone requests a two-topping pizza,
    you’ll need to be sure to include both toppings on their pizza:'
  prefs: []
  type: TYPE_NORMAL
- en: '**toppings.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: We start with a list containing the requested toppings. The first `if` statement
    checks to see whether the person requested mushrooms on their pizza. If so, a
    message is printed confirming that topping. The test for pepperoni ❶ is another
    simple `if` statement, not an `elif` or `else` statement, so this test is run
    regardless of whether the previous test passed or not. The last `if` statement
    checks whether extra cheese was requested, regardless of the results from the
    first two tests. These three independent tests are executed every time this program
    is run.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because every condition in this example is evaluated, both mushrooms and extra
    cheese are added to the pizza:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: 'This code would not work properly if we used an `if`-`elif`-`else` block, because
    the code would stop running after only one test passes. Here’s what that would
    look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: 'The test for `''mushrooms''` is the first test to pass, so mushrooms are added
    to the pizza. However, the values `''extra cheese''` and `''pepperoni''` are never
    checked, because Python doesn’t run any tests beyond the first test that passes
    in an `if-elif-else` chain. The customer’s first topping will be added, but all
    of their other toppings will be missed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: In summary, if you want only one block of code to run, use an `if`-`elif`-`else`
    chain. If more than one block of code needs to run, use a series of independent
    `if` statements.
  prefs: []
  type: TYPE_NORMAL
- en: Using if Statements with Lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can do some interesting work when you combine lists and `if` statements.
    You can watch for special values that need to be treated differently than other
    values in the list. You can efficiently manage changing conditions, such as the
    availability of certain items in a restaurant throughout a shift. You can also
    begin to prove that your code works as you expect it to in all possible situations.
  prefs: []
  type: TYPE_NORMAL
- en: Checking for Special Items
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter began with a simple example that showed how to handle a special
    value like `'bmw'`, which needed to be printed in a different format than other
    values in the list. Now that you have a basic understanding of conditional tests
    and `if` statements, let’s take a closer look at how you can watch for special
    values in a list and handle those values appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s continue with the pizzeria example. The pizzeria displays a message whenever
    a topping is added to your pizza, as it’s being made. The code for this action
    can be written very efficiently by making a list of toppings the customer has
    requested and using a loop to announce each topping as it’s added to the pizza:'
  prefs: []
  type: TYPE_NORMAL
- en: '**toppings.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is straightforward because this code is just a simple `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: 'But what if the pizzeria runs out of green peppers? An `if` statement inside
    the `for` loop can handle this situation appropriately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: This time, we check each requested item before adding it to the pizza. The `if`
    statement checks to see if the person requested green peppers. If so, we display
    a message informing them why they can’t have green peppers. The `else` block ensures
    that all other toppings will be added to the pizza.
  prefs: []
  type: TYPE_NORMAL
- en: The output shows that each requested topping is handled appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: Checking That a List Is Not Empty
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ve made a simple assumption about every list we’ve worked with so far: we’ve
    assumed that each list has at least one item in it. Soon we’ll let users provide
    the information that’s stored in a list, so we won’t be able to assume that a
    list has any items in it each time a loop is run. In this situation, it’s useful
    to check whether a list is empty before running a `for` loop.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, let’s check whether the list of requested toppings is empty
    before building the pizza. If the list is empty, we’ll prompt the user and make
    sure they want a plain pizza. If the list is not empty, we’ll build the pizza
    just as we did in the previous examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: This time we start out with an empty list of requested toppings. Instead of
    jumping right into a `for` loop, we do a quick check first. When the name of a
    list is used in an `if` statement, Python returns `True` if the list contains
    at least one item; an empty list evaluates to `False`. If `requested_toppings`
    passes the conditional test, we run the same `for` loop we used in the previous
    example. If the conditional test fails, we print a message asking the customer
    if they really want a plain pizza with no toppings.
  prefs: []
  type: TYPE_NORMAL
- en: 'The list is empty in this case, so the output asks if the user really wants
    a plain pizza:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: If the list is not empty, the output will show each requested topping being
    added to the pizza.
  prefs: []
  type: TYPE_NORMAL
- en: Using Multiple Lists
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: People will ask for just about anything, especially when it comes to pizza toppings.
    What if a customer actually wants french fries on their pizza? You can use lists
    and `if` statements to make sure your input makes sense before you act on it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s watch out for unusual topping requests before we build a pizza. The following
    example defines two lists. The first is a list of available toppings at the pizzeria,
    and the second is the list of toppings that the user has requested. This time,
    each item in `requested_toppings` is checked against the list of available toppings
    before it’s added to the pizza:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we define a list of available toppings at this pizzeria. Note that this
    could be a tuple if the pizzeria has a stable selection of toppings. Then, we
    make a list of toppings that a customer has requested. There’s an unusual request
    for a topping in this example: `''french fries''` ❶. Next we loop through the
    list of requested toppings. Inside the loop, we check to see if each requested
    topping is actually in the list of available toppings ❷. If it is, we add that
    topping to the pizza. If the requested topping is not in the list of available
    toppings, the `else` block will run ❸. The `else` block prints a message telling
    the user which toppings are unavailable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This code syntax produces clean, informative output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: In just a few lines of code, we’ve managed a real-world situation pretty effectively!
  prefs: []
  type: TYPE_NORMAL
- en: Styling Your if Statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In every example in this chapter, you’ve seen good styling habits. The only
    recommendation PEP 8 provides for styling conditional tests is to use a single
    space around comparison operators, such as `==`, `>=`, and `<=`. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: 'is better than:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: Such spacing does not affect the way Python interprets your code; it just makes
    your code easier for you and others to read.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter you learned how to write conditional tests, which always evaluate
    to `True` or `False`. You learned to write simple `if` statements, `if`-`else`
    chains, and `if`-`elif`-`else` chains. You began using these structures to identify
    particular conditions you need to test and to know when those conditions have
    been met in your programs. You learned to handle certain items in a list differently
    than all other items while continuing to utilize the efficiency of a `for` loop.
    You also revisited Python’s style recommendations to ensure that your increasingly
    complex programs are still relatively easy to read and understand.
  prefs: []
  type: TYPE_NORMAL
- en: In Chapter 6 you’ll learn about Python’s dictionaries. A dictionary is similar
    to a list, but it allows you to connect pieces of information. You’ll learn how
    to build dictionaries, loop through them, and use them in combination with lists
    and `if` statements. Learning about dictionaries will enable you to model an even
    wider variety of real-world situations.
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dictionaries
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter you’ll learn how to use Python’s dictionaries, which allow you
    to connect pieces of related information. You’ll learn how to access the information
    once it’s in a dictionary and how to modify that information. Because dictionaries
    can store an almost limitless amount of information, I’ll show you how to loop
    through the data in a dictionary. Additionally, you’ll learn to nest dictionaries
    inside lists, lists inside dictionaries, and even dictionaries inside other dictionaries.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding dictionaries allows you to model a variety of real-world objects
    more accurately. You’ll be able to create a dictionary representing a person and
    then store as much information as you want about that person. You can store their
    name, age, location, profession, and any other aspect of a person you can describe.
    You’ll be able to store any two kinds of information that can be matched up, such
    as a list of words and their meanings, a list of people’s names and their favorite
    numbers, a list of mountains and their elevations, and so forth.
  prefs: []
  type: TYPE_NORMAL
- en: A Simple Dictionary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider a game featuring aliens that can have different colors and point values.
    This simple dictionary stores information about a particular alien:'
  prefs: []
  type: TYPE_NORMAL
- en: '**alien.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: 'The dictionary `alien_0` stores the alien’s color and point value. The last
    two lines access and display that information, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: As with most new programming concepts, using dictionaries takes practice. Once
    you’ve worked with dictionaries for a bit, you’ll see how effectively they can
    model real-world situations.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Dictionaries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *dictionary* in Python is a collection of *key-value pairs*. Each *key* is
    connected to a value, and you can use a key to access the value associated with
    that key. A key’s value can be a number, a string, a list, or even another dictionary.
    In fact, you can use any object that you can create in Python as a value in a
    dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, a dictionary is wrapped in braces (`{}`) with a series of key-value
    pairs inside the braces, as shown in the earlier example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: A *key-value pair* is a set of values associated with each other. When you provide
    a key, Python returns the value associated with that key. Every key is connected
    to its value by a colon, and individual key-value pairs are separated by commas.
    You can store as many key-value pairs as you want in a dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest dictionary has exactly one key-value pair, as shown in this modified
    version of the `alien_0` dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: 'This dictionary stores one piece of information about `alien_0`: the alien’s
    color. The string `''color''` is a key in this dictionary, and its associated
    value is `''green''`.'
  prefs: []
  type: TYPE_NORMAL
- en: Accessing Values in a Dictionary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To get the value associated with a key, give the name of the dictionary and
    then place the key inside a set of square brackets, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**alien.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns the value associated with the key `''color''` from the dictionary
    `alien_0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: 'You can have an unlimited number of key-value pairs in a dictionary. For example,
    here’s the original `alien_0` dictionary with two key-value pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can access either the color or the point value of `alien_0`. If a player
    shoots down this alien, you can look up how many points they should earn using
    code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the dictionary has been defined, we pull the value associated with the
    key `''points''` from the dictionary. This value is then assigned to the variable
    `new_points`. The last line prints a statement about how many points the player
    just earned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: If you run this code every time an alien is shot down, the alien’s point value
    will be retrieved.
  prefs: []
  type: TYPE_NORMAL
- en: Adding New Key-Value Pairs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Dictionaries are dynamic structures, and you can add new key-value pairs to
    a dictionary at any time. To add a new key-value pair, you would give the name
    of the dictionary followed by the new key in square brackets, along with the new
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add two new pieces of information to the `alien_0` dictionary: the alien’s
    *x*- and *y*-coordinates, which will help us display the alien at a particular
    position on the screen. Let’s place the alien on the left edge of the screen,
    25 pixels down from the top. Because screen coordinates usually start at the upper-left
    corner of the screen, we’ll place the alien on the left edge of the screen by
    setting the *x*-coordinate to 0 and 25 pixels from the top by setting its *y*-coordinate
    to positive 25, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**alien.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: 'We start by defining the same dictionary that we’ve been working with. We then
    print this dictionary, displaying a snapshot of its information. Next, we add
    a new key-value pair to the dictionary: the key `''x_position''` and the value
    `0`. We do the same for the key `''y_position''`. When we print the modified dictionary,
    we see the two additional key-value pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: The final version of the dictionary contains four key-value pairs. The original
    two specify color and point value, and two more specify the alien’s position.
  prefs: []
  type: TYPE_NORMAL
- en: Dictionaries retain the order in which they were defined. When you print a dictionary
    or loop through its elements, you will see the elements in the same order they
    were added to the dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: Starting with an Empty Dictionary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It’s sometimes convenient, or even necessary, to start with an empty dictionary
    and then add each new item to it. To start filling an empty dictionary, define
    a dictionary with an empty set of braces and then add each key-value pair on its
    own line. For example, here’s how to build the `alien_0` dictionary using this
    approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '**alien.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: 'We first define an empty `alien_0` dictionary, and then add color and point
    values to it. The result is the dictionary we’ve been using in previous examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: Typically, you’ll use empty dictionaries when storing user-supplied data in
    a dictionary or when writing code that generates a large number of key-value pairs
    automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying Values in a Dictionary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To modify a value in a dictionary, give the name of the dictionary with the
    key in square brackets and then the new value you want associated with that key.
    For example, consider an alien that changes from green to yellow as a game progresses:'
  prefs: []
  type: TYPE_NORMAL
- en: '**alien.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: 'We first define a dictionary for `alien_0` that contains only the alien’s color;
    then we change the value associated with the key `''color''` to `''yellow''`.
    The output shows that the alien has indeed changed from green to yellow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: 'For a more interesting example, let’s track the position of an alien that can
    move at different speeds. We’ll store a value representing the alien’s current
    speed and then use it to determine how far to the right the alien should move:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: We start by defining an alien with an initial *x* position and *y* position,
    and a speed of `'medium'`. We’ve omitted the color and point values for the sake
    of simplicity, but this example would work the same way if you included those
    key-value pairs as well. We also print the original value of `x_position` to see
    how far the alien moves to the right.
  prefs: []
  type: TYPE_NORMAL
- en: An `if`-`elif`-`else` chain determines how far the alien should move to the
    right, and assigns this value to the variable `x_increment` ❶. If the alien’s
    speed is `'slow'`, it moves one unit to the right; if the speed is `'medium'`,
    it moves two units to the right; and if it’s `'fast'`, it moves three units to
    the right. Once the increment has been calculated, it’s added to the value of
    `x_position` ❷, and the result is stored in the dictionary’s `x_position`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because this is a medium-speed alien, its position shifts two units to the
    right:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: 'This technique is pretty cool: by changing one value in the alien’s dictionary,
    you can change the overall behavior of the alien. For example, to turn this medium-speed
    alien into a fast alien, you would add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: The `if`-`elif`-`else` block would then assign a larger value to `x_increment`
    the next time the code runs.
  prefs: []
  type: TYPE_NORMAL
- en: Removing Key-Value Pairs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you no longer need a piece of information that’s stored in a dictionary,
    you can use the `del` statement to completely remove a key-value pair. All `del`
    needs is the name of the dictionary and the key that you want to remove.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let’s remove the key `''points''` from the `alien_0` dictionary,
    along with its value:'
  prefs: []
  type: TYPE_NORMAL
- en: '**alien.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: 'The `del` statement ❶ tells Python to delete the key `''points''` from the
    dictionary `alien_0` and to remove the value associated with that key as well.
    The output shows that the key `''points''` and its value of `5` are deleted from
    the dictionary, but the rest of the dictionary is unaffected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: A Dictionary of Similar Objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The previous example involved storing different kinds of information about
    one object, an alien in a game. You can also use a dictionary to store one kind
    of information about many objects. For example, say you want to poll a number
    of people and ask them what their favorite programming language is. A dictionary
    is useful for storing the results of a simple poll, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**favorite_languages.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we’ve broken a larger dictionary into several lines. Each key
    is the name of a person who responded to the poll, and each value is their language
    choice. When you know you’ll need more than one line to define a dictionary, press
    ENTER after the opening brace. Then indent the next line one level (four spaces)
    and write the first key-value pair, followed by a comma. From this point forward
    when you press ENTER, your text editor should automatically indent all subsequent
    key-value pairs to match the first key-value pair.
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve finished defining the dictionary, add a closing brace on a new line
    after the last key-value pair, and indent it one level so it aligns with the keys
    in the dictionary. It’s good practice to include a comma after the last key-value
    pair as well, so you’re ready to add a new key-value pair on the next line.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this dictionary, given the name of a person who took the poll, you can
    easily look up their favorite language:'
  prefs: []
  type: TYPE_NORMAL
- en: '**favorite_languages.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: 'To see which language Sarah chose, we ask for the value at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: 'We use this syntax to pull Sarah’s favorite language from the dictionary ❶
    and assign it to the variable `language`. Creating a new variable here makes for
    a much cleaner `print()` call. The output shows Sarah’s favorite language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: You could use this same syntax with any individual represented in the dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: Using get() to Access Values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using keys in square brackets to retrieve the value you’re interested in from
    a dictionary might cause one potential problem: if the key you ask for doesn’t
    exist, you’ll get an error.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see what happens when you ask for the point value of an alien that doesn’t
    have a point value set:'
  prefs: []
  type: TYPE_NORMAL
- en: '**alien_no_points.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in a traceback, showing a `KeyError`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: You’ll learn more about how to handle errors like this in general in Chapter
    10. For dictionaries specifically, you can use the `get()` method to set a default
    value that will be returned if the requested key doesn’t exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `get()` method requires a key as a first argument. As a second optional
    argument, you can pass the value to be returned if the key doesn’t exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: 'If the key `''points''` exists in the dictionary, you’ll get the corresponding
    value. If it doesn’t, you get the default value. In this case, `points` doesn’t
    exist, and we get a clean message instead of an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: If there’s a chance the key you’re asking for might not exist, consider using
    the `get()` method instead of the square bracket notation.
  prefs: []
  type: TYPE_NORMAL
- en: Looping Through a Dictionary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A single Python dictionary can contain just a few key-value pairs or millions
    of pairs. Because a dictionary can contain large amounts of data, Python lets
    you loop through a dictionary. Dictionaries can be used to store information in
    a variety of ways; therefore, several different ways exist to loop through them.
    You can loop through all of a dictionary’s key-value pairs, through its keys,
    or through its values.
  prefs: []
  type: TYPE_NORMAL
- en: Looping Through All Key-Value Pairs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before we explore the different approaches to looping, let’s consider a new
    dictionary designed to store information about a user on a website. The following
    dictionary would store one person’s username, first name, and last name:'
  prefs: []
  type: TYPE_NORMAL
- en: '**user.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: 'You can access any single piece of information about `user_0` based on what
    you’ve already learned in this chapter. But what if you wanted to see everything
    stored in this user’s dictionary? To do so, you could loop through the dictionary
    using a `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: 'To write a `for` loop for a dictionary, you create names for the two variables
    that will hold the key and value in each key-value pair. You can choose any names
    you want for these two variables. This code would work just as well if you had
    used abbreviations for the variable names, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: 'The second half of the `for` statement includes the name of the dictionary
    followed by the method `items()`, which returns a sequence of key-value pairs.
    The `for` loop then assigns each of these pairs to the two variables provided.
    In the preceding example, we use the variables to print each `key`, followed by
    the associated `value`. The `"\n"` in the first `print()` call ensures that a
    blank line is inserted before each key-value pair in the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: 'Looping through all key-value pairs works particularly well for dictionaries
    like the *favorite_languages.py* example on page 96, which stores the same kind
    of information for many different keys. If you loop through the `favorite_languages`
    dictionary, you get the name of each person in the dictionary and their favorite
    programming language. Because the keys always refer to a person’s name and the
    value is always a language, we’ll use the variables `name` and `language` in the
    loop instead of `key` and `value`. This will make it easier to follow what’s happening
    inside the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '**favorite_languages.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: This code tells Python to loop through each key-value pair in the dictionary.
    As it works through each pair the key is assigned to the variable `name`, and
    the value is assigned to the variable `language`. These descriptive names make
    it much easier to see what the `print()` call is doing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in just a few lines of code, we can display all of the information from
    the poll:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: This type of looping would work just as well if our dictionary stored the results
    from polling a thousand or even a million people.
  prefs: []
  type: TYPE_NORMAL
- en: Looping Through All the Keys in a Dictionary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `keys()` method is useful when you don’t need to work with all of the values
    in a dictionary. Let’s loop through the `favorite_languages` dictionary and print
    the names of everyone who took the poll:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: 'This `for` loop tells Python to pull all the keys from the dictionary `favorite_languages`
    and assign them one at a time to the variable `name`. The output shows the names
    of everyone who took the poll:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: 'Looping through the keys is actually the default behavior when looping through
    a dictionary, so this code would have exactly the same output if you wrote:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: 'rather than:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: You can choose to use the `keys()` method explicitly if it makes your code easier
    to read, or you can omit it if you wish.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can access the value associated with any key you care about inside the
    loop, by using the current key. Let’s print a message to a couple of friends about
    the languages they chose. We’ll loop through the names in the dictionary as we
    did previously, but when the name matches one of our friends, we’ll display a
    message about their favorite language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: First, we make a list of friends that we want to print a message to. Inside
    the loop, we print each person’s name. Then we check whether the `name` we’re
    working with is in the list `friends` ❶. If it is, we determine the person’s favorite
    language using the name of the dictionary and the current value of `name` as the
    key ❷. We then print a special greeting, including a reference to their language
    of choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Everyone’s name is printed, but our friends receive a special message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use the `keys()` method to find out if a particular person was
    polled. This time, let’s find out if Erin took the poll:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: 'The `keys()` method isn’t just for looping: it actually returns a sequence
    of all the keys, and the `if` statement simply checks if `''erin''` is in this
    sequence. Because she’s not, a message is printed inviting her to take the poll:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: Looping Through a Dictionary’s Keys in a Particular Order
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Looping through a dictionary returns the items in the same order they were inserted.
    Sometimes, though, you’ll want to loop through a dictionary in a different order.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to do this is to sort the keys as they’re returned in the `for` loop.
    You can use the `sorted()` function to get a copy of the keys in order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: 'This `for` statement is like other `for` statements, except that we’ve wrapped
    the `sorted()` function around the `dictionary.keys()` method. This tells Python
    to get all the keys in the dictionary and sort them before starting the loop.
    The output shows everyone who took the poll, with the names displayed in order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: Looping Through All Values in a Dictionary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you are primarily interested in the values that a dictionary contains, you
    can use the `values()` method to return a sequence of values without any keys.
    For example, say we simply want a list of all languages chosen in our programming
    language poll, without the name of the person who chose each language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: 'The `for` statement here pulls each value from the dictionary and assigns it
    to the variable `language`. When these values are printed, we get a list of all
    chosen languages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: 'This approach pulls all the values from the dictionary without checking for
    repeats. This might work fine with a small number of values, but in a poll with
    a large number of respondents, it would result in a very repetitive list. To see
    each language chosen without repetition, we can use a set. A *set* is a collection
    in which each item must be unique:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: When you wrap `set()` around a collection of values that contains duplicate
    items, Python identifies the unique items in the collection and builds a set from
    those items. Here we use `set()` to pull out the unique languages in `favorite_languages.values()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result is a nonrepetitive list of languages that have been mentioned by
    people taking the poll:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: As you continue learning about Python, you’ll often find a built-in feature
    of the language that helps you do exactly what you want with your data.
  prefs: []
  type: TYPE_NORMAL
- en: Nesting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes you’ll want to store multiple dictionaries in a list, or a list of
    items as a value in a dictionary. This is called *nesting*. You can nest dictionaries
    inside a list, a list of items inside a dictionary, or even a dictionary inside
    another dictionary. Nesting is a powerful feature, as the following examples will
    demonstrate.
  prefs: []
  type: TYPE_NORMAL
- en: A List of Dictionaries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `alien_0` dictionary contains a variety of information about one alien,
    but it has no room to store information about a second alien, much less a screen
    full of aliens. How can you manage a fleet of aliens? One way is to make a list
    of aliens in which each alien is a dictionary of information about that alien.
    For example, the following code builds a list of three aliens:'
  prefs: []
  type: TYPE_NORMAL
- en: '**aliens.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: 'We first create three dictionaries, each representing a different alien. We
    store each of these dictionaries in a list called `aliens` ❶. Finally, we loop
    through the list and print out each alien:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: 'A more realistic example would involve more than three aliens with code that
    automatically generates each alien. In the following example, we use `range()`
    to create a fleet of 30 aliens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: 'This example begins with an empty list to hold all of the aliens that will
    be created. The `range()` function ❶ returns a series of numbers, which just tells
    Python how many times we want the loop to repeat. Each time the loop runs, we
    create a new alien ❷ and then append each new alien to the list `aliens` ❸. We
    use a slice to print the first five aliens ❹, and finally, we print the length
    of the list to prove we’ve actually generated the full fleet of 30 aliens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: These aliens all have the same characteristics, but Python considers each one
    a separate object, which allows us to modify each alien individually.
  prefs: []
  type: TYPE_NORMAL
- en: 'How might you work with a group of aliens like this? Imagine that one aspect
    of a game has some aliens changing color and moving faster as the game progresses.
    When it’s time to change colors, we can use a `for` loop and an `if` statement
    to change the color of the aliens. For example, to change the first three aliens
    to yellow, medium-speed aliens worth 10 points each, we could do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: 'Because we want to modify the first three aliens, we loop through a slice that
    includes only the first three aliens. All of the aliens are green now, but that
    won’t always be the case, so we write an `if` statement to make sure we’re only
    modifying green aliens. If the alien is green, we change the color to `''yellow''`,
    the speed to `''medium''`, and the point value to `10`, as shown in the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: 'You could expand this loop by adding an `elif` block that turns yellow aliens
    into red, fast-moving ones worth 15 points each. Without showing the entire program
    again, that loop would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: It’s common to store a number of dictionaries in a list when each dictionary
    contains many kinds of information about one object. For example, you might create
    a dictionary for each user on a website, as we did in *user.py* on page 99, and
    store the individual dictionaries in a list called `users`. All of the dictionaries
    in the list should have an identical structure, so you can loop through the list
    and work with each dictionary object in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: A List in a Dictionary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Rather than putting a dictionary inside a list, it’s sometimes useful to put
    a list inside a dictionary. For example, consider how you might describe a pizza
    that someone is ordering. If you were to use only a list, all you could really
    store is a list of the pizza’s toppings. With a dictionary, a list of toppings
    can be just one aspect of the pizza you’re describing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, two kinds of information are stored for each pizza:
    a type of crust and a list of toppings. The list of toppings is a value associated
    with the key `''toppings''`. To use the items in the list, we give the name of
    the dictionary and the key `''toppings''`, as we would any value in the dictionary.
    Instead of returning a single value, we get a list of toppings:'
  prefs: []
  type: TYPE_NORMAL
- en: '**pizza.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: We begin with a dictionary that holds information about a pizza that has been
    ordered. One key in the dictionary is `'crust'`, and the associated value is the
    string `'thick'`. The next key, `'toppings'`, has a list as its value that stores
    all requested toppings. We summarize the order before building the pizza ❶. When
    you need to break up a long line in a `print()` call, choose an appropriate point
    at which to break the line being printed, and end the line with a quotation mark.
    Indent the next line, add an opening quotation mark, and continue the string.
    Python will automatically combine all of the strings it finds inside the parentheses.
    To print the toppings, we write a `for` loop ❷. To access the list of toppings,
    we use the key `'toppings'`, and Python grabs the list of toppings from the dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following output summarizes the pizza that we plan to build:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: 'You can nest a list inside a dictionary anytime you want more than one value
    to be associated with a single key in a dictionary. In the earlier example of
    favorite programming languages, if we were to store each person’s responses in
    a list, people could choose more than one favorite language. When we loop through
    the dictionary, the value associated with each person would be a list of languages
    rather than a single language. Inside the dictionary’s `for` loop, we use another
    `for` loop to run through the list of languages associated with each person:'
  prefs: []
  type: TYPE_NORMAL
- en: '**favorite_languages.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: 'The value associated with each name in `favorite_languages` is now a list.
    Note that some people have one favorite language and others have multiple favorites.
    When we loop through the dictionary ❶, we use the variable name `languages` to
    hold each value from the dictionary, because we know that each value will be a
    list. Inside the main dictionary loop, we use another `for` loop ❷ to run through
    each person’s list of favorite languages. Now each person can list as many favorite
    languages as they like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: To refine this program even further, you could include an `if` statement at
    the beginning of the dictionary’s `for` loop to see whether each person has more
    than one favorite language by examining the value of `len(languages)`. If a person
    has more than one favorite, the output would stay the same. If the person has
    only one favorite language, you could change the wording to reflect that. For
    example, you could say, “Sarah’s favorite language is C.”
  prefs: []
  type: TYPE_NORMAL
- en: A Dictionary in a Dictionary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can nest a dictionary inside another dictionary, but your code can get
    complicated quickly when you do. For example, if you have several users for a
    website, each with a unique username, you can use the usernames as the keys in
    a dictionary. You can then store information about each user by using a dictionary
    as the value associated with their username. In the following listing, we store
    three pieces of information about each user: their first name, last name, and
    location. We’ll access this information by looping through the usernames and the
    dictionary of information associated with each username:'
  prefs: []
  type: TYPE_NORMAL
- en: '**many_users.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: 'We first define a dictionary called `users` with two keys: one each for the
    usernames `''aeinstein''` and `''mcurie''`. The value associated with each key
    is a dictionary that includes each user’s first name, last name, and location.
    Then, we loop through the `users` dictionary ❶. Python assigns each key to the
    variable `username`, and the dictionary associated with each username is assigned
    to the variable `user_info`. Once inside the main dictionary loop, we print the
    username ❷.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we start accessing the inner dictionary ❸. The variable `user_info`,
    which contains the dictionary of user information, has three keys: `''first''`,
    `''last''`, and `''location''`. We use each key to generate a neatly formatted
    full name and location for each person, and then print a summary of what we know
    about each user ❹:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the structure of each user’s dictionary is identical. Although not
    required by Python, this structure makes nested dictionaries easier to work with.
    If each user’s dictionary had different keys, the code inside the `for` loop would
    be more complicated.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you learned how to define a dictionary and how to work with
    the information stored in a dictionary. You learned how to access and modify individual
    elements in a dictionary, and how to loop through all of the information in a
    dictionary. You learned to loop through a dictionary’s key-value pairs, its keys,
    and its values. You also learned how to nest multiple dictionaries in a list,
    nest lists in a dictionary, and nest a dictionary inside a dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter you’ll learn about `while` loops and how to accept input
    from people who are using your programs. This will be an exciting chapter, because
    you’ll learn to make all of your programs interactive: they’ll be able to respond
    to user input.'
  prefs: []
  type: TYPE_NORMAL
- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: User Input and while Loops
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: Most programs are written to solve an end user’s problem. To do so, you usually
    need to get some information from the user. For example, say someone wants to
    find out whether they’re old enough to vote. If you write a program to answer
    this question, you need to know the user’s age before you can provide an answer.
    The program will need to ask the user to enter, or *input*, their age; once the
    program has this input, it can compare it to the voting age to determine if the
    user is old enough and then report the result.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter you’ll learn how to accept user input so your program can then
    work with it. When your program needs a name, you’ll be able to prompt the user
    for a name. When your program needs a list of names, you’ll be able to prompt
    the user for a series of names. To do this, you’ll use the `input()` function.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also learn how to keep programs running as long as users want them to,
    so they can enter as much information as they need to; then, your program can
    work with that information. You’ll use Python’s `while` loop to keep programs
    running as long as certain conditions remain true.
  prefs: []
  type: TYPE_NORMAL
- en: With the ability to work with user input and the ability to control how long
    your programs run, you’ll be able to write fully interactive programs.
  prefs: []
  type: TYPE_NORMAL
- en: How the input() Function Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `input()` function pauses your program and waits for the user to enter some
    text. Once Python receives the user’s input, it assigns that input to a variable
    to make it convenient for you to work with.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following program asks the user to enter some text, then displays
    that message back to the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '**parrot.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: 'The `input()` function takes one argument: the *prompt* that we want to display
    to the user, so they know what kind of information to enter. In this example,
    when Python runs the first line, the user sees the prompt `Tell me something,
    and I will repeat it back to you:` . The program waits while the user enters their
    response and continues after the user presses ENTER. The response is assigned
    to the variable `message`, then `print(message)` displays the input back to the
    user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: Writing Clear Prompts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Each time you use the `input()` function, you should include a clear, easy-to-follow
    prompt that tells the user exactly what kind of information you’re looking for.
    Any statement that tells the user what to enter should work. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '**greeter.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a space at the end of your prompts (after the colon in the preceding example)
    to separate the prompt from the user’s response and to make it clear to your user
    where to enter their text. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes you’ll want to write a prompt that’s longer than one line. For example,
    you might want to tell the user why you’re asking for certain input. You can assign
    your prompt to a variable and pass that variable to the `input()` function. This
    allows you to build your prompt over several lines, then write a clean `input()`
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**greeter.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: This example shows one way to build a multiline string. The first line assigns
    the first part of the message to the variable `prompt`. In the second line, the
    operator `+=` takes the string that was assigned to `prompt` and adds the new
    string onto the end.
  prefs: []
  type: TYPE_NORMAL
- en: 'The prompt now spans two lines, again with space after the question mark for
    clarity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: Using int() to Accept Numerical Input
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you use the `input()` function, Python interprets everything the user
    enters as a string. Consider the following interpreter session, which asks for
    the user’s age:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: 'The user enters the number `21`, but when we ask Python for the value of `age`,
    it returns `''21''`, the string representation of the numerical value entered.
    We know Python interpreted the input as a string because the number is now enclosed
    in quotes. If all you want to do is print the input, this works well. But if you
    try to use the input as a number, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: 'When you try to use the input to do a numerical comparison ❶, Python produces
    an error because it can’t compare a string to an integer: the string `''21''`
    that’s assigned to `age` can’t be compared to the numerical value `18` ❷.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can resolve this issue by using the `int()` function, which converts the
    input string to a numerical value. This allows the comparison to run successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, when we enter `21` at the prompt, Python interprets the number
    as a string, but the value is then converted to a numerical representation by
    `int()` ❶. Now Python can run the conditional test: it compares `age` (which now
    represents the numerical value 21) and `18` to see if `age` is greater than or
    equal to 18\. This test evaluates to `True`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'How do you use the `int()` function in an actual program? Consider a program
    that determines whether people are tall enough to ride a roller coaster:'
  prefs: []
  type: TYPE_NORMAL
- en: '**rollercoaster.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: 'The program can compare `height` to `48` because `height = int(height)` converts
    the input value to a numerical representation before the comparison is made. If
    the number entered is greater than or equal to 48, we tell the user that they’re
    tall enough:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: When you use numerical input to do calculations and comparisons, be sure to
    convert the input value to a numerical representation first.
  prefs: []
  type: TYPE_NORMAL
- en: The Modulo Operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A useful tool for working with numerical information is the *modulo operator*
    (`%`), which divides one number by another number and returns the remainder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: The modulo operator doesn’t tell you how many times one number fits into another;
    it only tells you what the remainder is.
  prefs: []
  type: TYPE_NORMAL
- en: 'When one number is divisible by another number, the remainder is 0, so the
    modulo operator always returns 0\. You can use this fact to determine if a number
    is even or odd:'
  prefs: []
  type: TYPE_NORMAL
- en: '**even_or_odd.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: Even numbers are always divisible by two, so if the modulo of a number and two
    is zero (here, `if number % 2 == 0`) the number is even. Otherwise, it’s odd.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: Introducing while Loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `for` loop takes a collection of items and executes a block of code once
    for each item in the collection. In contrast, the `while` loop runs as long as,
    or *while*, a certain condition is true.
  prefs: []
  type: TYPE_NORMAL
- en: The while Loop in Action
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can use a `while` loop to count up through a series of numbers. For example,
    the following `while` loop counts from 1 to 5:'
  prefs: []
  type: TYPE_NORMAL
- en: '**counting.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: In the first line, we start counting from 1 by assigning `current_number` the
    value 1\. The `while` loop is then set to keep running as long as the value of
    `current_number` is less than or equal to 5\. The code inside the loop prints
    the value of `current_number` and then adds 1 to that value with `current_number
    += 1`. (The `+=` operator is shorthand for `current_number = current_number +
    1`.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Python repeats the loop as long as the condition `current_number <= 5` is true.
    Because 1 is less than 5, Python prints `1` and then adds 1, making the current
    number `2`. Because 2 is less than 5, Python prints `2` and adds 1 again, making
    the current number `3`, and so on. Once the value of `current_number` is greater
    than 5, the loop stops running and the program ends:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: The programs you use every day most likely contain `while` loops. For example,
    a game needs a `while` loop to keep running as long as you want to keep playing,
    and so it can stop running as soon as you ask it to quit. Programs wouldn’t be
    fun to use if they stopped running before we told them to or kept running even
    after we wanted to quit, so `while` loops are quite useful.
  prefs: []
  type: TYPE_NORMAL
- en: Letting the User Choose When to Quit
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can make the *parrot.py* program run as long as the user wants by putting
    most of the program inside a `while` loop. We’ll define a *quit value* and then
    keep the program running as long as the user has not entered the quit value:'
  prefs: []
  type: TYPE_NORMAL
- en: '**parrot.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: 'We first define a prompt that tells the user their two options: entering a
    message or entering the quit value (in this case, `''quit''`). Then we set up
    a variable `message` to keep track of whatever value the user enters. We define
    `message` as an empty string, `""`, so Python has something to check the first
    time it reaches the `while` line. The first time the program runs and Python reaches
    the `while` statement, it needs to compare the value of `message` to `''quit''`,
    but no user input has been entered yet. If Python has nothing to compare, it won’t
    be able to continue running the program. To solve this problem, we make sure to
    give `message` an initial value. Although it’s just an empty string, it will make
    sense to Python and allow it to perform the comparison that makes the `while`
    loop work. This `while` loop runs as long as the value of `message` is not `''quit''`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first time through the loop, `message` is just an empty string, so Python
    enters the loop. At `message = input(prompt)`, Python displays the prompt and
    waits for the user to enter their input. Whatever they enter is assigned to `message`
    and printed; then, Python reevaluates the condition in the `while` statement.
    As long as the user has not entered the word `''quit''`, the prompt is displayed
    again and Python waits for more input. When the user finally enters `''quit''`,
    Python stops executing the `while` loop and the program ends:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: 'This program works well, except that it prints the word `''quit''` as if it
    were an actual message. A simple `if` test fixes this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the program makes a quick check before displaying the message and only
    prints the message if it does not match the quit value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: Using a Flag
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous example, we had the program perform certain tasks while a given
    condition was true. But what about more complicated programs in which many different
    events could cause the program to stop running?
  prefs: []
  type: TYPE_NORMAL
- en: For example, in a game, several different events can end the game. When the
    player runs out of ships, their time runs out, or the cities they were supposed
    to protect are all destroyed, the game should end. It needs to end if any one
    of these events happens. If many possible events might occur to stop the program,
    trying to test all these conditions in one `while` statement becomes complicated
    and difficult.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a program that should run only as long as many conditions are true, you
    can define one variable that determines whether or not the entire program is active.
    This variable, called a *flag*, acts as a signal to the program. We can write
    our programs so they run while the flag is set to `True` and stop running when
    any of several events sets the value of the flag to `False`. As a result, our
    overall `while` statement needs to check only one condition: whether the flag
    is currently `True`. Then, all our other tests (to see if an event has occurred
    that should set the flag to `False`) can be neatly organized in the rest of the
    program.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add a flag to *parrot.py* from the previous section. This flag, which
    we’ll call `active` (though you can call it anything), will monitor whether or
    not the program should continue running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: We set the variable `active` to `True` so the program starts in an active state.
    Doing so makes the `while` statement simpler because no comparison is made in
    the `while` statement itself; the logic is taken care of in other parts of the
    program. As long as the `active` variable remains `True`, the loop will continue
    running ❶.
  prefs: []
  type: TYPE_NORMAL
- en: In the `if` statement inside the `while` loop, we check the value of `message`
    once the user enters their input. If the user enters `'quit'`, we set `active`
    to `False`, and the `while` loop stops. If the user enters anything other than
    `'quit'`, we print their input as a message.
  prefs: []
  type: TYPE_NORMAL
- en: This program has the same output as the previous example where we placed the
    conditional test directly in the `while` statement. But now that we have a flag
    to indicate whether the overall program is in an active state, it would be easy
    to add more tests (such as `elif` statements) for events that should cause `active`
    to become `False`. This is useful in complicated programs like games, in which
    there may be many events that should each make the program stop running. When
    any of these events causes the active flag to become `False`, the main game loop
    will exit, a *Game Over* message can be displayed, and the player can be given
    the option to play again.
  prefs: []
  type: TYPE_NORMAL
- en: Using break to Exit a Loop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To exit a `while` loop immediately without running any remaining code in the
    loop, regardless of the results of any conditional test, use the `break` statement.
    The `break` statement directs the flow of your program; you can use it to control
    which lines of code are executed and which aren’t, so the program only executes
    code that you want it to, when you want it to.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider a program that asks the user about places they’ve visited.
    We can stop the `while` loop in this program by calling `break` as soon as the
    user enters the `''quit''` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '**cities.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: 'A loop that starts with `while True` ❶ will run forever unless it reaches a
    `break` statement. The loop in this program continues asking the user to enter
    the names of cities they’ve been to until they enter `''quit''`. When they enter
    `''quit''`, the `break` statement runs, causing Python to exit the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: Using continue in a Loop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Rather than breaking out of a loop entirely without executing the rest of its
    code, you can use the `continue` statement to return to the beginning of the loop,
    based on the result of a conditional test. For example, consider a loop that counts
    from 1 to 10 but prints only the odd numbers in that range:'
  prefs: []
  type: TYPE_NORMAL
- en: '**counting.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we set `current_number` to 0\. Because it’s less than 10, Python enters
    the `while` loop. Once inside the loop, we increment the count by 1 ❶, so `current_number`
    is 1\. The `if` statement then checks the modulo of `current_number` and 2\. If
    the modulo is 0 (which means `current_number` is divisible by 2), the `continue`
    statement tells Python to ignore the rest of the loop and return to the beginning.
    If the current number is not divisible by 2, the rest of the loop is executed
    and Python prints the current number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE303]'
  prefs: []
  type: TYPE_PRE
- en: Avoiding Infinite Loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Every `while` loop needs a way to stop running so it won’t continue to run
    forever. For example, this counting loop should count from 1 to 5:'
  prefs: []
  type: TYPE_NORMAL
- en: '**counting.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE304]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if you accidentally omit the line `x += 1`, the loop will run forever:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the value of `x` will start at `1` but never change. As a result, the conditional
    test `x <= 5` will always evaluate to `True` and the `while` loop will run forever,
    printing a series of 1s, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: Every programmer accidentally writes an infinite `while` loop from time to time,
    especially when a program’s loops have subtle exit conditions. If your program
    gets stuck in an infinite loop, press CTRL-C or just close the terminal window
    displaying your program’s output.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid writing infinite loops, test every `while` loop and make sure the loop
    stops when you expect it to. If you want your program to end when the user enters
    a certain input value, run the program and enter that value. If the program doesn’t
    end, scrutinize the way your program handles the value that should cause the loop
    to exit. Make sure at least one part of the program can make the loop’s condition
    `False` or cause it to reach a `break` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Using a while Loop with Lists and Dictionaries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we’ve worked with only one piece of user information at a time. We received
    the user’s input and then printed the input or a response to it. The next time
    through the `while` loop, we’d receive another input value and respond to that.
    But to keep track of many users and pieces of information, we’ll need to use lists
    and dictionaries with our `while` loops.
  prefs: []
  type: TYPE_NORMAL
- en: A `for` loop is effective for looping through a list, but you shouldn’t modify
    a list inside a `for` loop because Python will have trouble keeping track of the
    items in the list. To modify a list as you work through it, use a `while` loop.
    Using `while` loops with lists and dictionaries allows you to collect, store,
    and organize lots of input to examine and report on later.
  prefs: []
  type: TYPE_NORMAL
- en: Moving Items from One List to Another
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consider a list of newly registered but unverified users of a website. After
    we verify these users, how can we move them to a separate list of confirmed users?
    One way would be to use a `while` loop to pull users from the list of unconfirmed
    users as we verify them and then add them to a separate list of confirmed users.
    Here’s what that code might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '**confirmed_users.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: We begin with a list of unconfirmed users ❶ (Alice, Brian, and Candace) and
    an empty list to hold confirmed users. The `while` loop runs as long as the list
    `unconfirmed_users` is not empty ❷. Within this loop, the `pop()` method removes
    unverified users one at a time from the end of `unconfirmed_users` ❸. Because
    Candace is last in the `unconfirmed_users` list, her name will be the first to
    be removed, assigned to `current_user`, and added to the `confirmed_users` list
    ❹. Next is Brian, then Alice.
  prefs: []
  type: TYPE_NORMAL
- en: 'We simulate confirming each user by printing a verification message and then
    adding them to the list of confirmed users. As the list of unconfirmed users shrinks,
    the list of confirmed users grows. When the list of unconfirmed users is empty,
    the loop stops and the list of confirmed users is printed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE308]'
  prefs: []
  type: TYPE_PRE
- en: Removing All Instances of Specific Values from a List
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Chapter 3, we used `remove()` to remove a specific value from a list. The
    `remove()` function worked because the value we were interested in appeared only
    once in the list. But what if you want to remove all instances of a value from
    a list?
  prefs: []
  type: TYPE_NORMAL
- en: 'Say you have a list of pets with the value `''cat''` repeated several times.
    To remove all instances of that value, you can run a `while` loop until `''cat''`
    is no longer in the list, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**pets.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE309]'
  prefs: []
  type: TYPE_PRE
- en: 'We start with a list containing multiple instances of `''cat''`. After printing
    the list, Python enters the `while` loop because it finds the value `''cat''`
    in the list at least once. Once inside the loop, Python removes the first instance
    of `''cat''`, returns to the `while` line, and then reenters the loop when it
    finds that `''cat''` is still in the list. It removes each instance of `''cat''`
    until the value is no longer in the list, at which point Python exits the loop
    and prints the list again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE310]'
  prefs: []
  type: TYPE_PRE
- en: Filling a Dictionary with User Input
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can prompt for as much input as you need in each pass through a `while`
    loop. Let’s make a polling program in which each pass through the loop prompts
    for the participant’s name and response. We’ll store the data we gather in a dictionary,
    because we want to connect each response with a particular user:'
  prefs: []
  type: TYPE_NORMAL
- en: '**mountain_poll.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE311]'
  prefs: []
  type: TYPE_PRE
- en: The program first defines an empty dictionary (`responses`) and sets a flag
    (`polling_active`) to indicate that polling is active. As long as `polling_active`
    is `True`, Python will run the code in the `while` loop.
  prefs: []
  type: TYPE_NORMAL
- en: Within the loop, the user is prompted to enter their name and a mountain they’d
    like to climb ❶. That information is stored in the `responses` dictionary ❷, and
    the user is asked whether or not to keep the poll running ❸. If they enter `yes`,
    the program enters the `while` loop again. If they enter `no`, the `polling_active`
    flag is set to `False`, the `while` loop stops running, and the final code block
    ❹ displays the results of the poll.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run this program and enter sample responses, you should see output like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE312]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use `input()` to allow users to provide
    their own information in your programs. You learned to work with both text and
    numerical input and how to use `while` loops to make your programs run as long
    as your users want them to. You saw several ways to control the flow of a `while`
    loop by setting an `active` flag, using the `break` statement, and using the `continue`
    statement. You learned how to use a `while` loop to move items from one list to
    another and how to remove all instances of a value from a list. You also learned
    how `while` loops can be used with dictionaries.
  prefs: []
  type: TYPE_NORMAL
- en: In Chapter 8 you’ll learn about functions. *Functions* allow you to break your
    programs into small parts, each of which does one specific job. You can call a
    function as many times as you want, and you can store your functions in separate
    files. By using functions, you’ll be able to write more efficient code that’s
    easier to troubleshoot and maintain and that can be reused in many different programs.
  prefs: []
  type: TYPE_NORMAL
- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functions
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter you’ll learn to write *functions*, which are named blocks of
    code designed to do one specific job. When you want to perform a particular task
    that you’ve defined in a function, you *call* the function responsible for it.
    If you need to perform that task multiple times throughout your program, you don’t
    need to type all the code for the same task again and again; you just call the
    function dedicated to handling that task, and the call tells Python to run the
    code inside the function. You’ll find that using functions makes your programs
    easier to write, read, test, and fix.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter you’ll also learn a variety of ways to pass information to functions.
    You’ll learn how to write certain functions whose primary job is to display information
    and other functions designed to process data and return a value or set of values.
    Finally, you’ll learn to store functions in separate files called *modules* to
    help organize your main program files.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here’s a simple function named `greet_user()` that prints a greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '**greeter.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE313]'
  prefs: []
  type: TYPE_PRE
- en: This example shows the simplest structure of a function. The first line uses
    the keyword `def` to inform Python that you’re defining a function. This is the
    *function definition*, which tells Python the name of the function and, if applicable,
    what kind of information the function needs to do its job. The parentheses hold
    that information. In this case, the name of the function is `greet_user()`, and
    it needs no information to do its job, so its parentheses are empty. (Even so,
    the parentheses are required.) Finally, the definition ends in a colon.
  prefs: []
  type: TYPE_NORMAL
- en: Any indented lines that follow `def greet_user():` make up the *body* of the
    function. The text on the second line is a comment called a *docstring*, which
    describes what the function does. When Python generates documentation for the
    functions in your programs, it looks for a string immediately after the function's
    definition. These strings are usually enclosed in triple quotes, which lets you
    write multiple lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'The line `print("Hello!")` is the only line of actual code in the body of this
    function, so `greet_user()` has just one job: `print("Hello!")`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you want to use this function, you have to call it. A *function call*
    tells Python to execute the code in the function. To *call* a function, you write
    the name of the function, followed by any necessary information in parentheses.
    Because no information is needed here, calling our function is as simple as entering
    `greet_user()`. As expected, it prints `Hello!`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE314]'
  prefs: []
  type: TYPE_PRE
- en: Passing Information to a Function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you modify the function `greet_user()` slightly, it can greet the user by
    name. For the function to do this, you enter `username` in the parentheses of
    the function’s definition at `def greet_user()`. By adding `username` here, you
    allow the function to accept any value of `username` you specify. The function
    now expects you to provide a value for `username` each time you call it. When
    you call `greet_user()`, you can pass it a name, such as `''jesse''`, inside the
    parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE315]'
  prefs: []
  type: TYPE_PRE
- en: 'Entering `greet_user(''jesse'')` calls `greet_user()` and gives the function
    the information it needs to execute the `print()` call. The function accepts the
    name you passed it and displays the greeting for that name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE316]'
  prefs: []
  type: TYPE_PRE
- en: Likewise, entering `greet_user('sarah')` calls `greet_user()`, passes it `'sarah'`,
    and prints `Hello, Sarah!` You can call `greet_user()` as often as you want and
    pass it any name you want to produce a predictable output every time.
  prefs: []
  type: TYPE_NORMAL
- en: Arguments and Parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the preceding `greet_user()` function, we defined `greet_user()` to require
    a value for the variable `username`. Once we called the function and gave it the
    information (a person’s name), it printed the right greeting.
  prefs: []
  type: TYPE_NORMAL
- en: The variable `username` in the definition of `greet_user()` is an example of
    a *parameter*, a piece of information the function needs to do its job. The value
    `'jesse'` in `greet_user('jesse')` is an example of an argument. An *argument*
    is a piece of information that’s passed from a function call to a function. When
    we call the function, we place the value we want the function to work with in
    parentheses. In this case the argument `'jesse'` was passed to the function `greet_user()`,
    and the value was assigned to the parameter `username`.
  prefs: []
  type: TYPE_NORMAL
- en: Passing Arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because a function definition can have multiple parameters, a function call
    may need multiple arguments. You can pass arguments to your functions in a number
    of ways. You can use *positional arguments*, which need to be in the same order
    the parameters were written; *keyword arguments*, where each argument consists
    of a variable name and a value; and lists and dictionaries of values. Let’s look
    at each of these in turn.
  prefs: []
  type: TYPE_NORMAL
- en: Positional Arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you call a function, Python must match each argument in the function call
    with a parameter in the function definition. The simplest way to do this is based
    on the order of the arguments provided. Values matched up this way are called
    *positional arguments*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how this works, consider a function that displays information about
    pets. The function tells us what kind of animal each pet is and the pet’s name,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**pets.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE317]'
  prefs: []
  type: TYPE_PRE
- en: The definition shows that this function needs a type of animal and the animal’s
    name ❶. When we call `describe_pet()`, we need to provide an animal type and a
    name, in that order. For example, in the function call, the argument `'hamster'`
    is assigned to the parameter `animal_type` and the argument `'harry'` is assigned
    to the parameter `pet_name` ❷. In the function body, these two parameters are
    used to display information about the pet being described.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output describes a hamster named Harry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE318]'
  prefs: []
  type: TYPE_PRE
- en: Multiple Function Calls
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can call a function as many times as needed. Describing a second, different
    pet requires just one more call to `describe_pet()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE319]'
  prefs: []
  type: TYPE_PRE
- en: 'In this second function call, we pass `describe_pet()` the arguments `''dog''`
    and `''willie''`. As with the previous set of arguments we used, Python matches
    `''dog''` with the parameter `animal_type` and `''willie''` with the parameter
    `pet_name`. As before, the function does its job, but this time it prints values
    for a dog named Willie. Now we have a hamster named Harry and a dog named Willie:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE320]'
  prefs: []
  type: TYPE_PRE
- en: Calling a function multiple times is a very efficient way to work. The code
    describing a pet is written once in the function. Then, anytime you want to describe
    a new pet, you call the function with the new pet’s information. Even if the code
    for describing a pet were to expand to 10 lines, you could still describe a new
    pet in just one line by calling the function again.
  prefs: []
  type: TYPE_NORMAL
- en: Order Matters in Positional Arguments
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can get unexpected results if you mix up the order of the arguments in
    a function call when using positional arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE321]'
  prefs: []
  type: TYPE_PRE
- en: 'In this function call, we list the name first and the type of animal second.
    Because the argument `''harry''` is listed first this time, that value is assigned
    to the parameter `animal_type`. Likewise, `''hamster''` is assigned to `pet_name`.
    Now we have a “harry” named “Hamster”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE322]'
  prefs: []
  type: TYPE_PRE
- en: If you get funny results like this, check to make sure the order of the arguments
    in your function call matches the order of the parameters in the function’s definition.
  prefs: []
  type: TYPE_NORMAL
- en: Keyword Arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *keyword argument* is a name-value pair that you pass to a function. You directly
    associate the name and the value within the argument, so when you pass the argument
    to the function, there’s no confusion (you won’t end up with a harry named Hamster).
    Keyword arguments free you from having to worry about correctly ordering your
    arguments in the function call, and they clarify the role of each value in the
    function call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s rewrite *pets.py* using keyword arguments to call `describe_pet()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE323]'
  prefs: []
  type: TYPE_PRE
- en: The function `describe_pet()` hasn’t changed. But when we call the function,
    we explicitly tell Python which parameter each argument should be matched with.
    When Python reads the function call, it knows to assign the argument `'hamster'`
    to the parameter `animal_type` and the argument `'harry'` to `pet_name`. The output
    correctly shows that we have a hamster named Harry.
  prefs: []
  type: TYPE_NORMAL
- en: 'The order of keyword arguments doesn’t matter because Python knows where each
    value should go. The following two function calls are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE324]'
  prefs: []
  type: TYPE_PRE
- en: Default Values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When writing a function, you can define a *default value* for each parameter.
    If an argument for a parameter is provided in the function call, Python uses the
    argument value. If not, it uses the parameter’s default value. So when you define
    a default value for a parameter, you can exclude the corresponding argument you’d
    usually write in the function call. Using default values can simplify your function
    calls and clarify the ways your functions are typically used.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you notice that most of the calls to `describe_pet()` are being
    used to describe dogs, you can set the default value of `animal_type` to `''dog''`.
    Now anyone calling `describe_pet()` for a dog can omit that information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE325]'
  prefs: []
  type: TYPE_PRE
- en: 'We changed the definition of `describe_pet()` to include a default value, `''dog''`,
    for `animal_type`. Now when the function is called with no `animal_type` specified,
    Python knows to use the value `''dog''` for this parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE326]'
  prefs: []
  type: TYPE_PRE
- en: Note that the order of the parameters in the function definition had to be changed.
    Because the default value makes it unnecessary to specify a type of animal as
    an argument, the only argument left in the function call is the pet’s name. Python
    still interprets this as a positional argument, so if the function is called with
    just a pet’s name, that argument will match up with the first parameter listed
    in the function’s definition. This is the reason the first parameter needs to
    be `pet_name`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest way to use this function now is to provide just a dog’s name in
    the function call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE327]'
  prefs: []
  type: TYPE_PRE
- en: This function call would have the same output as the previous example. The only
    argument provided is `'willie'`, so it is matched up with the first parameter
    in the definition, `pet_name`. Because no argument is provided for `animal_type`,
    Python uses the default value `'dog'`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To describe an animal other than a dog, you could use a function call like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE328]'
  prefs: []
  type: TYPE_PRE
- en: Because an explicit argument for `animal_type` is provided, Python will ignore
    the parameter’s default value.
  prefs: []
  type: TYPE_NORMAL
- en: Equivalent Function Calls
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Because positional arguments, keyword arguments, and default values can all
    be used together, you’ll often have several equivalent ways to call a function.
    Consider the following definition for `describe_pet()` with one default value
    provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE329]'
  prefs: []
  type: TYPE_PRE
- en: With this definition, an argument always needs to be provided for `pet_name`,
    and this value can be provided using the positional or keyword format. If the
    animal being described is not a dog, an argument for `animal_type` must be included
    in the call, and this argument can also be specified using the positional or keyword
    format.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of the following calls would work for this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE330]'
  prefs: []
  type: TYPE_PRE
- en: Each of these function calls would have the same output as the previous examples.
  prefs: []
  type: TYPE_NORMAL
- en: It doesn’t really matter which calling style you use. As long as your function
    calls produce the output you want, just use the style you find easiest to understand.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding Argument Errors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you start to use functions, don’t be surprised if you encounter errors
    about unmatched arguments. Unmatched arguments occur when you provide fewer or
    more arguments than a function needs to do its work. For example, here’s what
    happens if we try to call `describe_pet()` with no arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE331]'
  prefs: []
  type: TYPE_PRE
- en: 'Python recognizes that some information is missing from the function call,
    and the traceback tells us that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE332]'
  prefs: []
  type: TYPE_PRE
- en: The traceback first tells us the location of the problem ❶, allowing us to look
    back and see that something went wrong in our function call. Next, the offending
    function call is written out for us to see ❷. Last, the traceback tells us the
    call is missing two arguments and reports the names of the missing arguments ❸.
    If this function were in a separate file, we could probably rewrite the call correctly
    without having to open that file and read the function code.
  prefs: []
  type: TYPE_NORMAL
- en: Python is helpful in that it reads the function’s code for us and tells us the
    names of the arguments we need to provide. This is another motivation for giving
    your variables and functions descriptive names. If you do, Python’s error messages
    will be more useful to you and anyone else who might use your code.
  prefs: []
  type: TYPE_NORMAL
- en: If you provide too many arguments, you should get a similar traceback that can
    help you correctly match your function call to the function definition.
  prefs: []
  type: TYPE_NORMAL
- en: Return Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A function doesn’t always have to display its output directly. Instead, it can
    process some data and then return a value or set of values. The value the function
    returns is called a *return value*. The `return` statement takes a value from
    inside a function and sends it back to the line that called the function. Return
    values allow you to move much of your program’s grunt work into functions, which
    can simplify the body of your program.
  prefs: []
  type: TYPE_NORMAL
- en: Returning a Simple Value
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s look at a function that takes a first and last name, and returns a neatly
    formatted full name:'
  prefs: []
  type: TYPE_NORMAL
- en: '**formatted_name.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE333]'
  prefs: []
  type: TYPE_PRE
- en: The definition of `get_formatted_name()` takes as parameters a first and last
    name. The function combines these two names, adds a space between them, and assigns
    the result to `full_name` ❶. The value of `full_name` is converted to title case,
    and then returned to the calling line ❷.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you call a function that returns a value, you need to provide a variable
    that the return value can be assigned to. In this case, the returned value is
    assigned to the variable `musician` ❸. The output shows a neatly formatted name
    made up of the parts of a person’s name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE334]'
  prefs: []
  type: TYPE_PRE
- en: 'This might seem like a lot of work to get a neatly formatted name when we could
    have just written:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE335]'
  prefs: []
  type: TYPE_PRE
- en: However, when you consider working with a large program that needs to store
    many first and last names separately, functions like `get_formatted_name()` become
    very useful. You store first and last names separately and then call this function
    whenever you want to display a full name.
  prefs: []
  type: TYPE_NORMAL
- en: Making an Argument Optional
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes it makes sense to make an argument optional, so that people using
    the function can choose to provide extra information only if they want to. You
    can use default values to make an argument optional.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, say we want to expand `get_formatted_name()` to handle middle
    names as well. A first attempt to include middle names might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE336]'
  prefs: []
  type: TYPE_PRE
- en: 'This function works when given a first, middle, and last name. The function
    takes in all three parts of a name and then builds a string out of them. The function
    adds spaces where appropriate and converts the full name to title case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE337]'
  prefs: []
  type: TYPE_PRE
- en: 'But middle names aren’t always needed, and this function as written would not
    work if you tried to call it with only a first name and a last name. To make the
    middle name optional, we can give the `middle_name` argument an empty default
    value and ignore the argument unless the user provides a value. To make `get_formatted_name()`
    work without a middle name, we set the default value of `middle_name` to an empty
    string and move it to the end of the list of parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE338]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the name is built from three possible parts. Because there’s
    always a first and last name, these parameters are listed first in the function’s
    definition. The middle name is optional, so it’s listed last in the definition,
    and its default value is an empty string.
  prefs: []
  type: TYPE_NORMAL
- en: In the body of the function, we check to see if a middle name has been provided.
    Python interprets non-empty strings as `True`, so the conditional test `if middle_name`
    evaluates to `True` if a middle name argument is in the function call ❶. If a
    middle name is provided, the first, middle, and last names are combined to form
    a full name. This name is then changed to title case and returned to the function
    call line, where it’s assigned to the variable `musician` and printed. If no middle
    name is provided, the empty string fails the `if` test and the `else` block runs
    ❷. The full name is made with just a first and last name, and the formatted name
    is returned to the calling line where it’s assigned to `musician` and printed.
  prefs: []
  type: TYPE_NORMAL
- en: Calling this function with a first and last name is straightforward. If we’re
    using a middle name, however, we have to make sure the middle name is the last
    argument passed so Python will match up the positional arguments correctly ❸.
  prefs: []
  type: TYPE_NORMAL
- en: 'This modified version of our function works for people with just a first and
    last name, and it works for people who have a middle name as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE339]'
  prefs: []
  type: TYPE_PRE
- en: Optional values allow functions to handle a wide range of use cases while letting
    function calls remain as simple as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Returning a Dictionary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A function can return any kind of value you need it to, including more complicated
    data structures like lists and dictionaries. For example, the following function
    takes in parts of a name and returns a dictionary representing a person:'
  prefs: []
  type: TYPE_NORMAL
- en: '**person.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE340]'
  prefs: []
  type: TYPE_PRE
- en: 'The function `build_person()` takes in a first and last name, and puts these
    values into a dictionary ❶. The value of `first_name` is stored with the key `''first''`,
    and the value of `last_name` is stored with the key `''last''`. Then, the entire
    dictionary representing the person is returned ❷. The return value is printed
    ❸ with the original two pieces of textual information now stored in a dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE341]'
  prefs: []
  type: TYPE_PRE
- en: 'This function takes in simple textual information and puts it into a more meaningful
    data structure that lets you work with the information beyond just printing it.
    The strings `''jimi''` and `''hendrix''` are now labeled as a first name and last
    name. You can easily extend this function to accept optional values like a middle
    name, an age, an occupation, or any other information you want to store about
    a person. For example, the following change allows you to store a person’s age
    as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE342]'
  prefs: []
  type: TYPE_PRE
- en: We add a new optional parameter `age` to the function definition and assign
    the parameter the special value `None`, which is used when a variable has no specific
    value assigned to it. You can think of `None` as a placeholder value. In conditional
    tests, `None` evaluates to `False`. If the function call includes a value for
    `age`, that value is stored in the dictionary. This function always stores a person’s
    name, but it can also be modified to store any other information you want about
    a person.
  prefs: []
  type: TYPE_NORMAL
- en: Using a Function with a while Loop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can use functions with all the Python structures you’ve learned about so
    far. For example, let’s use the `get_formatted_name()` function with a `while`
    loop to greet users more formally. Here’s a first attempt at greeting people using
    their first and last names:'
  prefs: []
  type: TYPE_NORMAL
- en: '**greeter.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE343]'
  prefs: []
  type: TYPE_PRE
- en: For this example, we use a simple version of `get_formatted_name()` that doesn’t
    involve middle names. The `while` loop asks the user to enter their name, and
    we prompt for their first and last name separately ❶.
  prefs: []
  type: TYPE_NORMAL
- en: 'But there’s one problem with this `while` loop: We haven’t defined a quit condition.
    Where do you put a quit condition when you ask for a series of inputs? We want
    the user to be able to quit as easily as possible, so each prompt should offer
    a way to quit. The `break` statement offers a straightforward way to exit the
    loop at either prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE344]'
  prefs: []
  type: TYPE_PRE
- en: 'We add a message that informs the user how to quit, and then we break out of
    the loop if the user enters the quit value at either prompt. Now the program will
    continue greeting people until someone enters `q` for either name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE345]'
  prefs: []
  type: TYPE_PRE
- en: Passing a List
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’ll often find it useful to pass a list to a function, whether it’s a list
    of names, numbers, or more complex objects, such as dictionaries. When you pass
    a list to a function, the function gets direct access to the contents of the list.
    Let’s use functions to make working with lists more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: 'Say we have a list of users and want to print a greeting to each. The following
    example sends a list of names to a function called `greet_users()`, which greets
    each person in the list individually:'
  prefs: []
  type: TYPE_NORMAL
- en: '**greet_users.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE346]'
  prefs: []
  type: TYPE_PRE
- en: 'We define `greet_users()` so it expects a list of names, which it assigns to
    the parameter `names`. The function loops through the list it receives and prints
    a greeting to each user. Outside of the function, we define a list of users and
    then pass the list `usernames` to `greet_users()` in the function call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE347]'
  prefs: []
  type: TYPE_PRE
- en: This is the output we wanted. Every user sees a personalized greeting, and you
    can call the function anytime you want to greet a specific set of users.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying a List in a Function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you pass a list to a function, the function can modify the list. Any changes
    made to the list inside the function’s body are permanent, allowing you to work
    efficiently even when you’re dealing with large amounts of data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a company that creates 3D printed models of designs that users submit.
    Designs that need to be printed are stored in a list, and after being printed
    they’re moved to a separate list. The following code does this without using functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**printing_models.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE348]'
  prefs: []
  type: TYPE_PRE
- en: 'This program starts with a list of designs that need to be printed and an empty
    list called `completed_models` that each design will be moved to after it has
    been printed. As long as designs remain in `unprinted_designs`, the `while` loop
    simulates printing each design by removing a design from the end of the list,
    storing it in `current_design`, and displaying a message that the current design
    is being printed. It then adds the design to the list of completed models. When
    the loop is finished running, a list of the designs that have been printed is
    displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE349]'
  prefs: []
  type: TYPE_PRE
- en: 'We can reorganize this code by writing two functions, each of which does one
    specific job. Most of the code won’t change; we’re just structuring it more carefully.
    The first function will handle printing the designs, and the second will summarize
    the prints that have been made:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE350]'
  prefs: []
  type: TYPE_PRE
- en: 'We define the function `print_models()` with two parameters: a list of designs
    that need to be printed and a list of completed models ❶. Given these two lists,
    the function simulates printing each design by emptying the list of unprinted
    designs and filling up the list of completed models. We then define the function
    `show_completed_models()` with one parameter: the list of completed models ❷.
    Given this list, `show_completed_models()` displays the name of each model that
    was printed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This program has the same output as the version without functions, but the
    code is much more organized. The code that does most of the work has been moved
    to two separate functions, which makes the main part of the program easier to
    understand. Look at the body of the program and notice how easily you can follow
    what’s happening:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE351]'
  prefs: []
  type: TYPE_PRE
- en: We set up a list of unprinted designs and an empty list that will hold the completed
    models. Then, because we’ve already defined our two functions, all we have to
    do is call them and pass them the right arguments. We call `print_models()` and
    pass it the two lists it needs; as expected, `print_models()` simulates printing
    the designs. Then we call `show_completed_models()` and pass it the list of completed
    models so it can report the models that have been printed. The descriptive function
    names allow others to read this code and understand it, even without comments.
  prefs: []
  type: TYPE_NORMAL
- en: This program is easier to extend and maintain than the version without functions.
    If we need to print more designs later on, we can simply call `print_models()
    again. If we realize the printing code needs to be modified, we can change the
    code once, and our changes will take place everywhere the function is called.
    This technique is more efficient than having to update code separately in several
    places in the program.`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE352] `function_name`(`list_name`[:]) [PRE353] print_models(unprinted_designs[:],
    completed_models) [PRE354] def make_pizza(*toppings):     """Print the list of
    toppings that have been requested."""     print(toppings)  make_pizza(''pepperoni'')
    make_pizza(''mushrooms'', ''green peppers'', ''extra cheese'') [PRE355] (''pepperoni'',)
    (''mushrooms'', ''green peppers'', ''extra cheese'') [PRE356] def make_pizza(*toppings):   """Summarize
    the pizza we are about to make."""  print("\nMaking a pizza with the following
    toppings:")     for topping in toppings:         print(f"- {topping}")  make_pizza(''pepperoni'')
    make_pizza(''mushrooms'', ''green peppers'', ''extra cheese'') [PRE357] Making
    a pizza with the following toppings: - pepperoni  Making a pizza with the following
    toppings: - mushrooms - green peppers - extra cheese [PRE358] def make_pizza(size,
    *toppings):     """Summarize the pizza we are about to make."""     print(f"\nMaking
    a {size}-inch pizza with the following toppings:")     for topping in toppings:  print(f"-
    {topping}")  make_pizza(16, ''pepperoni'') make_pizza(12, ''mushrooms'', ''green
    peppers'', ''extra cheese'') [PRE359] Making a 16-inch pizza with the following
    toppings: - pepperoni  Making a 12-inch pizza with the following toppings: - mushrooms
    - green peppers - extra cheese [PRE360] def build_profile(first, last, **user_info):     """Build
    a dictionary containing everything we know about a user.""" ❶     user_info[''first_name'']
    = first     user_info[''last_name''] = last     return user_info  user_profile
    = build_profile(''albert'', ''einstein'',                              location=''princeton'',                              field=''physics'')
    print(user_profile) [PRE361] {''location'': ''princeton'', ''field'': ''physics'',
    ''first_name'': ''albert'', ''last_name'': ''einstein''} [PRE362] def make_pizza(size,
    *toppings):     """Summarize the pizza we are about to make."""     print(f"\nMaking
    a {size}-inch pizza with the following toppings:")     for topping in toppings:         print(f"-
    {topping}") [PRE363] import pizza  ❶ pizza.make_pizza(16, ''pepperoni'') pizza.make_pizza(12,
    ''mushrooms'', ''green peppers'', ''extra cheese'') [PRE364] Making a 16-inch
    pizza with the following toppings: - pepperoni  Making a 12-inch pizza with the
    following toppings: - mushrooms - green peppers - extra cheese [PRE365] `module_name`.`function_name`()
    [PRE366] from `module_name` import `function_name` [PRE367] from `module_name`
    import `function_0`, `function_1`, `function_2` [PRE368] from pizza import make_pizza  make_pizza(16,
    ''pepperoni'') make_pizza(12, ''mushrooms'', ''green peppers'', ''extra cheese'')
    [PRE369] from pizza import make_pizza as mp  mp(16, ''pepperoni'') mp(12, ''mushrooms'',
    ''green peppers'', ''extra cheese'') [PRE370] from `module_name` import `function_name`
    as `fn` [PRE371] import pizza as p  p.make_pizza(16, ''pepperoni'') p.make_pizza(12,
    ''mushrooms'', ''green peppers'', ''extra cheese'') [PRE372] import `module_name`
    as `mn` [PRE373] from pizza import *  make_pizza(16, ''pepperoni'') make_pizza(12,
    ''mushrooms'', ''green peppers'', ''extra cheese'') [PRE374] from `module_name`
    import * [PRE375] def `function_name`(`parameter_0`, `parameter_1`=''`default
    value`'') [PRE376] `function_name`(`value_0`, `parameter_1`=''`value`'') [PRE377]
    def `function_name`(         `parameter_0`, `parameter_1`, `parameter_2`,         `parameter_3`,
    `parameter_4`, `parameter_5`):     `function body...` [PRE378]`  [PRE379] ❶ class
    Dog:     """A simple attempt to model a dog."""  ❷     def __init__(self, name,
    age):         """Initialize name and age attributes.""" ❸         self.name =
    name         self.age = age  ❹     def sit(self):         """Simulate a dog sitting
    in response to a command."""         print(f"{self.name} is now sitting.")      def
    roll_over(self):         """Simulate rolling over in response to a command."""         print(f"{self.name}
    rolled over!") [PRE380] class Dog:  *--snip--*  ❶ my_dog = Dog(''Willie'', 6)  ❷
    print(f"My dog''s name is {my_dog.name}.") ❸ print(f"My dog is {my_dog.age} years
    old.") [PRE381] my_dog.name [PRE382] My dog''s name is Willie. My dog is 6 years
    old. [PRE383] class Dog:  *--snip--*  my_dog = Dog(''Willie'', 6) my_dog.sit()
    my_dog.roll_over() [PRE384] Willie is now sitting. Willie rolled over! [PRE385]
    class Dog:  *--snip--*  my_dog = Dog(''Willie'', 6) your_dog = Dog(''Lucy'', 3)  print(f"My
    dog''s name is {my_dog.name}.") print(f"My dog is {my_dog.age} years old.") my_dog.sit()  print(f"\nYour
    dog''s name is {your_dog.name}.") print(f"Your dog is {your_dog.age} years old.")
    your_dog.sit() [PRE386] My dog''s name is Willie. My dog is 6 years old. Willie
    is now sitting.  Your dog''s name is Lucy. Your dog is 3 years old. Lucy is now
    sitting. [PRE387] class Car:     """A simple attempt to represent a car."""  ❶     def
    __init__(self, make, model, year):         """Initialize attributes to describe
    a car."""         self.make = make         self.model = model         self.year
    = year  ❷     def get_descriptive_name(self):         """Return a neatly formatted
    descriptive name."""         long_name = f"{self.year} {self.make} {self.model}"  return
    long_name.title()  ❸ my_new_car = Car(''audi'', ''a4'', 2024) print(my_new_car.get_descriptive_name())
    [PRE388] 2024 Audi A4 [PRE389] class Car:   def __init__(self, make, model, year):  """Initialize
    attributes to describe a car."""  self.make = make  self.model = model  self.year
    = year ❶         self.odometer_reading = 0      def get_descriptive_name(self):  *--snip--*  ❷     def
    read_odometer(self):         """Print a statement showing the car''s mileage."""         print(f"This
    car has {self.odometer_reading} miles on it.")  my_new_car = Car(''audi'', ''a4'',
    2024) print(my_new_car.get_descriptive_name()) my_new_car.read_odometer() [PRE390]
    2024 Audi A4 This car has 0 miles on it. [PRE391] class Car:  *--snip--*  my_new_car
    = Car(''audi'', ''a4'', 2024) print(my_new_car.get_descriptive_name())  my_new_car.odometer_reading
    = 23 my_new_car.read_odometer() [PRE392] 2024 Audi A4 This car has 23 miles on
    it. [PRE393] class Car:  *--snip--*      def update_odometer(self, mileage):         """Set
    the odometer reading to the given value."""         self.odometer_reading = mileage  my_new_car
    = Car(''audi'', ''a4'', 2024) print(my_new_car.get_descriptive_name())  ❶ my_new_car.update_odometer(23)
    my_new_car.read_odometer() [PRE394] 2024 Audi A4 This car has 23 miles on it.
    [PRE395] class Car:  *--snip--*   def update_odometer(self, mileage):         """         Set
    the odometer reading to the given value.         Reject the change if it attempts
    to roll the odometer back.         """ ❶         if mileage >= self.odometer_reading:  self.odometer_reading
    = mileage         else: ❷             print("You can''t roll back an odometer!")
    [PRE396] class Car:     *--snip--*   def update_odometer(self, mileage):  *--snip--*      def
    increment_odometer(self, miles):         """Add the given amount to the odometer
    reading."""         self.odometer_reading += miles  ❶ my_used_car = Car(''subaru'',
    ''outback'', 2019) print(my_used_car.get_descriptive_name())  ❷ my_used_car.update_odometer(23_500)
    my_used_car.read_odometer()  my_used_car.increment_odometer(100) my_used_car.read_odometer()
    [PRE397] 2019 Subaru Outback This car has 23500 miles on it. This car has 23600
    miles on it. [PRE398] ❶ class Car:  """A simple attempt to represent a car."""   def
    __init__(self, make, model, year):  """Initialize attributes to describe a car.""  self.make
    = make  self.model = model  self.year = year  self.odometer_reading = 0   def
    get_descriptive_name(self):  """Return a neatly formatted descriptive name."""  long_name
    = f"{self.year} {self.make} {self.model}"  return long_name.title()   def read_odometer(self):  """Print
    a statement showing the car''s mileage."""  print(f"This car has {self.odometer_reading}
    miles on it.")   def update_odometer(self, mileage):  """Set the odometer reading
    to the given value."""  if mileage >= self.odometer_reading:  self.odometer_reading
    = mileage  else:  print("You can''t roll back an odometer!")   def increment_odometer(self,
    miles):  """Add the given amount to the odometer reading."""  self.odometer_reading
    += miles  ❷ class ElectricCar(Car):     """Represent aspects of a car, specific
    to electric vehicles."""  ❸     def __init__(self, make, model, year):         """Initialize
    attributes of the parent class.""" ❹         super().__init__(make, model, year)   ❺
    my_leaf = ElectricCar(''nissan'', ''leaf'', 2024) print(my_leaf.get_descriptive_name())
    [PRE399] 2024 Nissan Leaf [PRE400] class Car:  *--snip--*  class ElectricCar(Car):  """Represent
    aspects of a car, specific to electric vehicles."""   def __init__(self, make,
    model, year):   """         Initialize attributes of the parent class.         Then
    initialize attributes specific to an electric car.         """  super().__init__(make,
    model, year) ❶         self.battery_size = 40  ❷     def describe_battery(self):         """Print
    a statement describing the battery size."""         print(f"This car has a {self.battery_size}-kWh
    battery.")  my_leaf = ElectricCar(''nissan'', ''leaf'', 2024) print(my_leaf.get_descriptive_name())
    my_leaf.describe_battery() [PRE401] 2024 Nissan Leaf This car has a 40-kWh battery.
    [PRE402] class ElectricCar(Car):  *--snip--*      def fill_gas_tank(self):         """Electric
    cars don''t have gas tanks."""         print("This car doesn''t have a gas tank!")
    [PRE403] class Car:  *--snip--*  class Battery:     """A simple attempt to model
    a battery for an electric car."""  ❶     def __init__(self, battery_size=40):  """Initialize
    the battery''s attributes."""         self.battery_size = battery_size  ❷     def
    describe_battery(self):         """Print a statement describing the battery size."""         print(f"This
    car has a {self.battery_size}-kWh battery.")   class ElectricCar(Car):  """Represent
    aspects of a car, specific to electric vehicles."""   def __init__(self, make,
    model, year):  """  Initialize attributes of the parent class.  Then initialize
    attributes specific to an electric car.  """  super().__init__(make, model, year)
    ❸         self.battery = Battery()  my_leaf = ElectricCar(''nissan'', ''leaf'',
    2024) print(my_leaf.get_descriptive_name()) my_leaf.battery.describe_battery()
    [PRE404] my_leaf.battery.describe_battery() [PRE405] 2024 Nissan Leaf This car
    has a 40-kWh battery. [PRE406] class Car:  *--snip--*  class Battery:  *--snip--*      def
    get_range(self):         """Print a statement about the range this battery provides."""         if
    self.battery_size == 40:             range = 150         elif self.battery_size
    == 65:             range = 225          print(f"This car can go about {range}
    miles on a full charge.")  class ElectricCar(Car):  *--snip--*  my_leaf = ElectricCar(''nissan'',
    ''leaf'', 2024) print(my_leaf.get_descriptive_name()) my_leaf.battery.describe_battery()
    ❶ my_leaf.battery.get_range() [PRE407] 2024 Nissan Leaf This car has a 40-kWh
    battery. This car can go about 150 miles on a full charge. [PRE408] ❶ """A class
    that can be used to represent a car."""  class Car:  """A simple attempt to represent
    a car."""   def __init__(self, make, model, year):  """Initialize attributes to
    describe a car."""  self.make = make  self.model = model  self.year = year  self.odometer_reading
    = 0   def get_descriptive_name(self):  """Return a neatly formatted descriptive
    name."""  long_name = f"{self.year} {self.make} {self.model}"  return long_name.title()   def
    read_odometer(self):  """Print a statement showing the car''s mileage."""  print(f"This
    car has {self.odometer_reading} miles on it.")   def update_odometer(self, mileage):  """  Set
    the odometer reading to the given value.  Reject the change if it attempts to
    roll the odometer back.  """  if mileage >= self.odometer_reading:  self.odometer_reading
    = mileage  else:  print("You can''t roll back an odometer!")   def increment_odometer(self,
    miles):  """Add the given amount to the odometer reading."""  self.odometer_reading
    += miles [PRE409] ❶ from car import Car  my_new_car = Car(''audi'', ''a4'', 2024)
    print(my_new_car.get_descriptive_name())  my_new_car.odometer_reading = 23 my_new_car.read_odometer()
    [PRE410] 2024 Audi A4 This car has 23 miles on it. [PRE411] """A set of classes
    used to represent gas and electric cars."""  class Car:  *--snip--*  class Battery:  """A
    simple attempt to model a battery for an electric car."""   def __init__(self,
    battery_size=40):  """Initialize the battery''s attributes."""  self.battery_size
    = battery_size   def describe_battery(self):  """Print a statement describing
    the battery size."""  print(f"This car has a {self.battery_size}-kWh battery.")   def
    get_range(self):  """Print a statement about the range this battery provides."""  if
    self.battery_size == 40:  range = 150  elif self.battery_size == 65:  range =
    225   print(f"This car can go about {range} miles on a full charge.")  class ElectricCar(Car):  """Models
    aspects of a car, specific to electric vehicles."""   def __init__(self, make,
    model, year):  """  Initialize attributes of the parent class.  Then initialize
    attributes specific to an electric car.  """  super().__init__(make, model, year)  self.battery
    = Battery() [PRE412] from car import ElectricCar  my_leaf = ElectricCar(''nissan'',
    ''leaf'', 2024) print(my_leaf.get_descriptive_name()) my_leaf.battery.describe_battery()
    my_leaf.battery.get_range() [PRE413] 2024 Nissan Leaf This car has a 40-kWh battery.
    This car can go about 150 miles on a full charge. [PRE414] ❶ from car import Car,
    ElectricCar  ❷ my_mustang = Car(''ford'', ''mustang'', 2024) print(my_mustang.get_descriptive_name())
    ❸ my_leaf = ElectricCar(''nissan'', ''leaf'', 2024) print(my_leaf.get_descriptive_name())
    [PRE415] 2024 Ford Mustang 2024 Nissan Leaf [PRE416] ❶ import car  ❷ my_mustang
    = car.Car(''ford'', ''mustang'', 2024) print(my_mustang.get_descriptive_name())  ❸
    my_leaf = car.ElectricCar(''nissan'', ''leaf'', 2024) print(my_leaf.get_descriptive_name())
    [PRE417] from `module_name` import * [PRE418] """A set of classes that can be
    used to represent electric cars."""  from car import Car  class Battery:  *--snip--*  class
    ElectricCar(Car):  *--snip--* [PRE419] """A class that can be used to represent
    a car."""  class Car:  *--snip--* [PRE420] from car import Car from electric_car
    import ElectricCar  my_mustang = Car(''ford'', ''mustang'', 2024) print(my_mustang.get_descriptive_name())  my_leaf
    = ElectricCar(''nissan'', ''leaf'', 2024) print(my_leaf.get_descriptive_name())
    [PRE421] 2024 Ford Mustang 2024 Nissan Leaf [PRE422] from electric_car import
    ElectricCar as EC [PRE423] my_leaf = EC(''nissan'', ''leaf'', 2024) [PRE424] import
    electric_car as ec [PRE425] my_leaf = ec.ElectricCar(''nissan'', ''leaf'', 2024)
    [PRE426] >>> **from random import randint** >>> **randint(1, 6)** 3 [PRE427] >>>
    **from random import choice** >>> **players = [''charles'', ''martina'', ''michael'',
    ''florence'', ''eli'']** >>> **first_up = choice(players)** >>> **first_up** ''florence''
    [PRE428] 3.1415926535   8979323846   2643383279 [PRE429] from pathlib import Path  ❶
    path = Path(''pi_digits.txt'') ❷ contents = path.read_text() print(contents) [PRE430]
    3.1415926535   8979323846   2643383279  [PRE431] from pathlib import Path  path
    = Path(''pi_digits.txt'') contents = path.read_text() contents = contents.rstrip()
    print(contents) [PRE432] 3.1415926535   8979323846   2643383279 [PRE433] contents
    = path.read_text().rstrip() [PRE434] path = Path(''text_files/`filename`.txt'')
    [PRE435] path = Path(''/home/eric/data_files/text_files/`filename`.txt'') [PRE436]
    from pathlib import Path  path = Path(''pi_digits.txt'') ❶ contents = path.read_text()  ❷
    lines = contents.splitlines() for line in lines:     print(line) [PRE437] 3.1415926535   8979323846   2643383279
    [PRE438] from pathlib import Path  path = Path(''pi_digits.txt'') contents = path.read_text()  lines
    = contents.splitlines() pi_string = '''' ❶ for line in lines:     pi_string +=
    line  print(pi_string) print(len(pi_string)) [PRE439] 3.1415926535  8979323846  2643383279
    36 [PRE440] *--snip--* for line in lines:   pi_string += line.lstrip()  print(pi_string)
    print(len(pi_string)) [PRE441] 3.141592653589793238462643383279 32 [PRE442] from
    pathlib import Path  path = Path(''pi_million_digits.txt'') contents = path.read_text()  lines
    = contents.splitlines() pi_string = '''' for line in lines:  pi_string += line.lstrip()  print(f"{pi_string[:52]}...")
    print(len(pi_string)) [PRE443] 3.14159265358979323846264338327950288419716939937510...
    1000002 [PRE444] *--snip--* for line in lines:  pi_string += line.strip()  birthday
    = input("Enter your birthday, in the form mmddyy: ") if birthday in pi_string:     print("Your
    birthday appears in the first million digits of pi!") else:     print("Your birthday
    does not appear in the first million digits of pi.") [PRE445] Enter your birthdate,
    in the form mmddyy: **120372** Your birthday appears in the first million digits
    of pi! [PRE446] from pathlib import Path  path = Path(''programming.txt'') path.write_text("I
    love programming.") [PRE447] I love programming. [PRE448] from pathlib import
    Path  contents = "I love programming.\n" contents += "I love creating new games.\n"
    contents += "I also love working with data.\n"  path = Path(''programming.txt'')
    path.write_text(contents) [PRE449] I love programming. I love creating new games.
    I also love working with data. [PRE450] print(5/0) [PRE451] Traceback (most recent
    call last):   File "division_calculator.py", line 1, in <module>     print(5/0)           ~^~
    ❶ ZeroDivisionError: division by zero [PRE452] try:     print(5/0) except ZeroDivisionError:     print("You
    can''t divide by zero!") [PRE453] You can''t divide by zero! [PRE454] print("Give
    me two numbers, and I''ll divide them.") print("Enter ''q'' to quit.")  while
    True: ❶     first_number = input("\nFirst number: ")     if first_number == ''q'':         break
    ❷     second_number = input("Second number: ")     if second_number == ''q'':         break
    ❸     answer = int(first_number) / int(second_number)     print(answer) [PRE455]
    Give me two numbers, and I''ll divide them. Enter ''q'' to quit.  First number:
    **5** Second number: **0** Traceback (most recent call last):   File "division_calculator.py",
    line 11, in <module>     answer = int(first_number) / int(second_number)              ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
    ZeroDivisionError: division by zero [PRE456] *--snip--* while True:   *--snip--*  if
    second_number == ''q'':  break ❶     try:         answer = int(first_number) /
    int(second_number) ❷     except ZeroDivisionError:         print("You can''t divide
    by 0!") ❸     else:  print(answer) [PRE457] Give me two numbers, and I''ll divide
    them. Enter ''q'' to quit.  First number: **5** Second number: **0** You can''t
    divide by 0!  First number: **5** Second number: **2** 2.5  First number: **q**
    [PRE458] from pathlib import Path  path = Path(''alice.txt'') contents = path.read_text(encoding=''utf-8'')
    [PRE459] Traceback (most recent call last): ❶   File "alice.py", line 4, in <module>
    ❷     contents = path.read_text(encoding=''utf-8'')                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  File
    "/.../pathlib.py", line 1056, in read_text     with self.open(mode=''r'', encoding=encoding,
    errors=errors) as f:          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   File
    "/.../pathlib.py", line 1042, in open     return io.open(self, mode, buffering,
    encoding, errors, newline)            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    ❸ FileNotFoundError: [Errno 2] No such file or directory: ''alice.txt'' [PRE460]
    from pathlib import Path  path = Path(''alice.txt'') try:     contents = path.read_text(encoding=''utf-8'')
    ❶ except FileNotFoundError:     print(f"Sorry, the file {path} does not exist.")
    [PRE461] Sorry, the file alice.txt does not exist. [PRE462] from pathlib import
    Path  path = Path(''alice.txt'') try:  contents = path.read_text(encoding=''utf-8'')
    except FileNotFoundError:  print(f"Sorry, the file {path} does not exist.") else:     #
    Count the approximate number of words in the file: ❶     words = contents.split()
    ❷     num_words = len(words)     print(f"The file {path} has about {num_words}
    words.") [PRE463] The file alice.txt has about 29594 words. [PRE464] from pathlib
    import Path  def count_words(path): ❶     """Count the approximate number of words
    in a file."""     try:  contents = path.read_text(encoding=''utf-8'')  except
    FileNotFoundError:  print(f"Sorry, the file {path} does not exist.")  else:  #
    Count the approximate number of words in the file:  words = contents.split()  num_words
    = len(words)  print(f"The file {path} has about {num_words} words.")  path = Path(''alice.txt'')
    count_words(path) [PRE465] from pathlib import Path  def count_words(filename):   *--snip--*  filenames
    = [''alice.txt'', ''siddhartha.txt'', ''moby_dick.txt'',          ''little_women.txt'']
    for filename in filenames: ❶     path = Path(filename)     count_words(path) [PRE466]
    The file alice.txt has about 29594 words. Sorry, the file siddhartha.txt does
    not exist. The file moby_dick.txt has about 215864 words. The file little_women.txt
    has about 189142 words. [PRE467] def count_words(path):  """Count the approximate
    number of words in a file."""  try:   *--snip--*  except FileNotFoundError:         pass  else:   *--snip--*
    [PRE468] The file alice.txt has about 29594 words. The file moby_dick.txt has
    about 215864 words. The file little_women.txt has about 189142 words. [PRE469]
    from pathlib import Path import json  numbers = [2, 3, 5, 7, 11, 13]  ❶ path =
    Path(''numbers.json'') ❷ contents = json.dumps(numbers) path.write_text(contents)
    [PRE470] [2, 3, 5, 7, 11, 13] [PRE471] from pathlib import Path import json  ❶
    path = Path(''numbers.json'') ❷ contents = path.read_text() ❸ numbers = json.loads(contents)  print(numbers)
    [PRE472] [2, 3, 5, 7, 11, 13] [PRE473] from pathlib import Path import json  ❶
    username = input("What is your name? ")  ❷ path = Path(''username.json'') contents
    = json.dumps(username) path.write_text(contents)  ❸ print(f"We''ll remember you
    when you come back, {username}!") [PRE474] What is your name? **Eric** We''ll
    remember you when you come back, Eric! [PRE475] from pathlib import Path import
    json  ❶ path = Path(''username.json'') contents = path.read_text() ❷ username
    = json.loads(contents)  print(f"Welcome back, {username}!") [PRE476] Welcome back,
    Eric! [PRE477] from pathlib import Path import json  path = Path(''username.json'')
    ❶ if path.exists():     contents = path.read_text()     username = json.loads(contents)     print(f"Welcome
    back, {username}!") ❷ else:     username = input("What is your name? ")     contents
    = json.dumps(username)     path.write_text(contents)     print(f"We''ll remember
    you when you come back, {username}!") [PRE478] What is your name? **Eric** We''ll
    remember you when you come back, Eric! [PRE479] Welcome back, Eric! [PRE480] from
    pathlib import Path import json  def greet_user(): ❶     """Greet the user by
    name."""     path = Path(''username.json'')  if path.exists():  contents = path.read_text()  username
    = json.loads(contents)  print(f"Welcome back, {username}!")  else:  username =
    input("What is your name? ")  contents = json.dumps(username)  path.write_text(contents)  print(f"We''ll
    remember you when you come back, {username}!")  greet_user() [PRE481] from pathlib
    import Path import json  def get_stored_username(path): ❶     """Get stored username
    if available."""  if path.exists():  contents = path.read_text()  username = json.loads(contents)         return
    username     else: ❷         return None  def greet_user():  """Greet the user
    by name."""     path = Path(''username.json'')     username = get_stored_username(path)
    ❸     if username:         print(f"Welcome back, {username}!")     else:  username
    = input("What is your name? ")  contents = json.dumps(username)  path.write_text(contents)  print(f"We''ll
    remember you when you come back, {username}!")  greet_user() [PRE482] from pathlib
    import Path import json  def get_stored_username(path):  """Get stored username
    if available."""     *--snip--*  def get_new_username(path):     """Prompt for
    a new username."""     username = input("What is your name? ")  contents = json.dumps(username)  path.write_text(contents)     return
    username  def greet_user():  """Greet the user by name."""  path = Path(''username.json'')
    ❶ username = get_stored_username(path)  if username:  print(f"Welcome back, {username}!")  else:
    ❷         username = get_new_username(path)         print(f"We''ll remember you
    when you come back, {username}!")  greet_user() [PRE483] $ **python -m pip install
    --upgrade pip** ❶ Requirement already satisfied: pip in /.../python3.11/site-packages
    (22.0.4) `--snip--` ❷ Successfully installed pip-22.1.2 [PRE484] $ **python -m
    pip install --upgrade** `package_name` [PRE485] $ **python -m pip install --user
    pytest** Collecting pytest  `--snip--` Successfully installed attrs-21.4.0 iniconfig-1.1.1
    ...pytest-7.`x`.`x` [PRE486] $ **python -m pip install --user** `package_name`
    [PRE487] def get_formatted_name(first, last):     """Generate a neatly formatted
    full name."""     full_name = f"{first} {last}"     return full_name.title() [PRE488]
    from name_function import get_formatted_name  print("Enter ''q'' at any time to
    quit.") while True:     first = input("\nPlease give me a first name: ")     if
    first == ''q'':         break     last = input("Please give me a last name: ")     if
    last == ''q'':         break      formatted_name = get_formatted_name(first, last)     print(f"\tNeatly
    formatted name: {formatted_name}.") [PRE489] Enter ''q'' at any time to quit.  Please
    give me a first name: **janis** Please give me a last name: **joplin**        Neatly
    formatted name: Janis Joplin.  Please give me a first name: **bob** Please give
    me a last name: **dylan**         Neatly formatted name: Bob Dylan.  Please give
    me a first name: **q** [PRE490] from name_function import get_formatted_name  ❶
    def test_first_last_name():     """Do names like ''Janis Joplin'' work?""" ❷     formatted_name
    = get_formatted_name(''janis'', ''joplin'') ❸     assert formatted_name == ''Janis
    Joplin'' [PRE491] $ **pytest** ========================= test session starts =========================
    ❶ platform darwin -- Python 3.`x`.`x`, pytest-7.`x`.`x`, pluggy-1.`x`.`x` ❷ rootdir:
    /.../python_work/chapter_11 ❸ collected 1 item  ❹ test_name_function.py .                                          [100%]
    ========================== 1 passed in 0.00s ========================== [PRE492]
    def get_formatted_name(first, middle, last):     """Generate a neatly formatted
    full name."""     full_name = f"{first} {middle} {last}"     return full_name.title()
    [PRE493] $ **pytest** ========================= test session starts =========================
    `--snip--` ❶ test_name_function.py F                                          [100%]
    ❷ ============================== FAILURES =============================== ❸ ________________________
    test_first_last_name _________________________     def test_first_last_name():         """Do
    names like ''Janis Joplin'' work?""" ❹ >       formatted_name = get_formatted_name(''janis'',
    ''joplin'') ❺ E       TypeError: get_formatted_name() missing 1 required positional             argument:
    ''last''  test_name_function.py:5: TypeError ======================= short test
    summary info ======================= FAILED test_name_function.py::test_first_last_name
    - TypeError:     get_formatted_name() missing 1 required positional argument:
    ''last'' ========================== 1 failed in 0.04s ==========================
    [PRE494] def get_formatted_name(first, last, middle=''''):     """Generate a neatly
    formatted full name."""     if middle:         full_name = f"{first} {middle}
    {last}"     else:         full_name = f"{first} {last}"     return full_name.title()
    [PRE495] $ **pytest** ========================= test session starts =========================
    `--snip--` test_name_function.py .                                       [100%]
    ========================== 1 passed in 0.00s ========================== [PRE496]
    from name_function import get_formatted_name  def test_first_last_name():   *--snip--*  def
    test_first_last_middle_name():     """Do names like ''Wolfgang Amadeus Mozart''
    work?""" ❶     formatted_name = get_formatted_name(         ''wolfgang'', ''mozart'',
    ''amadeus'') ❷     assert formatted_name == ''Wolfgang Amadeus Mozart'' [PRE497]
    $ pytest ========================= test session starts =========================
    `--snip--` collected 2 items  ❶ test_name_function.py ..                                         [100%]
    ========================== 2 passed in 0.01s ========================== [PRE498]
    class AnonymousSurvey:     """Collect anonymous answers to a survey question."""  ❶     def
    __init__(self, question):         """Store a question, and prepare to store responses."""         self.question
    = question         self.responses = []  ❷     def show_question(self):         """Show
    the survey question."""         print(self.question)  ❸     def store_response(self,
    new_response):         """Store a single response to the survey."""         self.responses.append(new_response)  ❹     def
    show_results(self):         """Show all the responses that have been given."""         print("Survey
    results:")         for response in self.responses:             print(f"- {response}")
    [PRE499] from survey import AnonymousSurvey  # Define a question, and make a survey.
    question = "What language did you first learn to speak?" language_survey = AnonymousSurvey(question)  #
    Show the question, and store responses to the question. language_survey.show_question()
    print("Enter ''q'' at any time to quit.\n") while True:     response = input("Language:
    ")     if response == ''q'':         break     language_survey.store_response(response)  #
    Show the survey results. print("\nThank you to everyone who participated in the
    survey!") language_survey.show_results() [PRE500] What language did you first
    learn to speak? Enter ''q'' at any time to quit.  Language: **English** Language:
    **Spanish** Language: **English** Language: **Mandarin** Language: **q**  Thank
    you to everyone who participated in the survey! Survey results: - English - Spanish
    - English - Mandarin [PRE501] from survey import AnonymousSurvey  ❶ def test_store_single_response():     """Test
    that a single response is stored properly."""     question = "What language did
    you first learn to speak?" ❷     language_survey = AnonymousSurvey(question)     language_survey.store_response(''English'')
    ❸     assert ''English'' in language_survey.responses [PRE502] $ **pytest test_survey.py**
    ========================= test session starts ========================= `--snip--`
    test_survey.py .                                                 [100%] ==========================
    1 passed in 0.01s ========================== [PRE503] from survey import AnonymousSurvey  def
    test_store_single_response():  *--snip--*  def test_store_three_responses():     """Test
    that three individual responses are stored properly."""     question = "What language
    did you first learn to speak?"     language_survey = AnonymousSurvey(question)
    ❶     responses = [''English'', ''Spanish'', ''Mandarin'']     for response in
    responses:         language_survey.store_response(response)  ❷     for response
    in responses:         assert response in language_survey.responses [PRE504] $
    **pytest test_survey.py** ========================= test session starts =========================
    `--snip--` test_survey.py ..                                                [100%]
    ========================== 2 passed in 0.01s ========================== [PRE505]
    import pytest from survey import AnonymousSurvey  ❶ @pytest.fixture ❷ def language_survey():     """A
    survey that will be available to all test functions."""  question = "What language
    did you first learn to speak?"     language_survey = AnonymousSurvey(question)     return
    language_survey  ❸ def test_store_single_response(language_survey):     """Test
    that a single response is stored properly.""" ❹     language_survey.store_response(''English'')  assert
    ''English'' in language_survey.responses  ❺ def test_store_three_responses(language_survey):     """Test
    that three individual responses are stored properly."""     responses = [''English'',
    ''Spanish'', ''Mandarin'']  for response in responses: ❻ language_survey.store_response(response)   for
    response in responses:  assert response in language_survey.responses [PRE506]`'
  prefs: []
  type: TYPE_NORMAL
