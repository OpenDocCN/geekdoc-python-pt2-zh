- en: '5'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '5'
- en: LINES AND SEGMENTS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 线与线段
- en: '![Image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common01.jpg)'
- en: A point and a direction describe an infinite, straight line, with no start or
    end. Two distinct points bound a segment, which has a finite length but contains
    infinite points. In this chapter, we’ll focus on these two primitives, line segments
    and lines. We’ll implement both with the help of the points and vectors we implemented
    in the previous chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 一个点和一个方向描述了一条无限的直线，没有起点或终点。两个不同的点限定了一条线段，它具有有限的长度，但包含无限个点。在本章中，我们将重点关注这两种基本元素——线段和直线。我们将借助前一章中实现的点和向量来实现这两者。
- en: 'We’ll also spend some time understanding and implementing two algorithms: one
    that computes the closest point to a segment, and another that computes segment
    intersections. These algorithms use some vital concepts from geometry that will
    serve as the foundation for more complex problems. We’ll take our time implementing
    these operations to make sure we understand them, so get your Python IDE ready
    and grab a pen and paper—it’ll be helpful to sketch some diagrams the old-school
    way.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将花一些时间理解和实现两个算法：一个用于计算离线段最近的点，另一个用于计算线段交点。这些算法使用了一些几何学中的重要概念，这些概念将作为更复杂问题的基础。我们将花时间实现这些操作，以确保我们理解它们，所以准备好你的Python
    IDE，拿出纸笔——以老式方式画图会很有帮助。
- en: '**Segment Class**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**线段类**'
- en: 'Between any two points in the plane exists a unique *segment*, a straight line
    with finite length containing infinite points. [Figure 5-1](ch05.xhtml#ch5fig1)
    depicts a segment between two points: *S* and *E*.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在平面上任意两点之间都存在一条唯一的*线段*，它是一条有限长度、包含无限个点的直线。[图5-1](ch05.xhtml#ch5fig1)描绘了两点* S
    *和* E *之间的线段。
- en: '![Image](../images/05fig01.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/05fig01.jpg)'
- en: '*Figure 5-1: Segment defined between the points S and E*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-1：S点和E点之间的线段*'
- en: 'Let’s start by creating a class named Segment with two attributes: a start
    point *S* and an end point *E*. This is how our project’s structure looks so far:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个名为Segment的类开始，类中有两个属性：起点*S*和终点*E*。到目前为止，我们的项目结构如下所示：
- en: Mechanics
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 机械学
- en: '|- geom2d'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '|- geom2d'
- en: '|    |- __init__.py'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- __init__.py'
- en: '|    |- nums.py'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- nums.py'
- en: '|    |- point.py'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- point.py'
- en: '|    |- point_test.py'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- point_test.py'
- en: '|    |- vector.py'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- vector.py'
- en: '|    |- vector_test.py'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- vector_test.py'
- en: '|    |- vectors.py'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- vectors.py'
- en: Right-click the *geom2d* package, select **New** ▸ **Python File**, name it
    *segment*, and click **OK**. PyCharm adds the *.py* extension for you, but if
    you’re using another IDE, you may need to add it yourself. In the file, enter
    the class as it’s written in [Listing 5-1](ch05.xhtml#ch5lis1).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 右键点击*geom2d*包，选择**新建** ▸ **Python文件**，命名为*segment*，然后点击**确定**。PyCharm会为你自动添加*.py*扩展名，但如果你使用的是其他IDE，可能需要手动添加。在文件中，输入如[列表5-1](ch05.xhtml#ch5lis1)所写的类。
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 5-1: Segment initialization*'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表5-1：线段初始化*'
- en: 'We start by importing the Point class from the *geom2d.point* module. Then,
    we define the Segment class with an initializer that accepts two points: start
    and end. These are stored in corresponding attributes.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先从*geom2d.point*模块导入Point类。然后，我们定义了Segment类，并为其创建了一个初始化函数，该函数接受两个点：起点和终点。这些点将存储在相应的属性中。
- en: 'Note that we are typing the parameters; more specifically, we’re saying they
    must be of type Point. These are the *type hints* we saw in [Chapter 2](ch02.xhtml#ch02),
    mostly for the IDE to give us some context help. If the IDE knows both start and
    end are objects from Point, it’ll detect if we’re trying to use any attribute
    the class doesn’t implement. But it’s important to realize this won’t prevent
    us from passing the wrong argument type at runtime. In fact, if you try the following
    in the console:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们对参数进行了类型标注；更具体地说，我们表示它们必须是Point类型。这些是我们在[第2章](ch02.xhtml#ch02)中看到的*类型提示*，主要是为了让IDE为我们提供一些上下文帮助。如果IDE知道起点和终点都是Point类的对象，它会检测我们是否在尝试使用该类没有实现的属性。但需要注意的是，这不会阻止我们在运行时传递错误的参数类型。事实上，如果你在控制台尝试以下代码：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: you should see that Python allowed us to pass strings instead of Points without
    complaining, as type hints are ignored by Python’s interpreter at runtime.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到，Python允许我们传递字符串而不是Points而不报错，因为类型提示在Python解释器运行时会被忽略。
- en: '***The Segment’s Direction***'
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***线段的方向***'
- en: An important property of a segment is its *direction*, defined as a vector going
    from its start point *S* to its end point *E*. If we call it ![Image](../images/dvictorit.jpg),
    we can compute it using [Equation 5.1](ch05.xhtml#ch05eqa01).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 线段的一个重要属性是它的*方向*，定义为从起点*S*到终点*E*的向量。如果我们将其称为![Image](../images/dvictorit.jpg)，我们可以通过[方程式5.1](ch05.xhtml#ch05eqa01)来计算它。
- en: '![Image](../images/05eqa01.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/05eqa01.jpg)'
- en: The normalization of the direction vector yields the direction versor, also
    commonly used in many operations with segments. The *direction vector* is a vector
    with the same length as the segment and parallel to it, with a direction going
    from its start point toward the end point. The *direction versor* is the normalized
    version of the direction vector, that is, a vector with the same direction but
    with unitary length.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 方向向量的归一化得到方向单位向量，这在许多与线段的操作中也常常使用。*方向向量*是一个与线段长度相同并与其平行的向量，方向从起点指向终点。*方向单位向量*是方向向量的归一化版本，即一个具有相同方向但单位长度的向量。
- en: The direction versor ![Image](../images/dcapit.jpg), given the segment with
    a length of *l*, is then as shown in [Equation 5.2](ch05.xhtml#ch05eqa02).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 方向单位向量 ![Image](../images/dcapit.jpg)，给定一个长度为*l*的线段，计算公式如[公式 5.2](ch05.xhtml#ch05eqa02)所示。
- en: '![Image](../images/05eqa02.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/05eqa02.jpg)'
- en: '**NOTE**'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Most of the time when we say* segment’s direction*, we’ll mean* direction
    versor ![Image](../images/dcapit.jpg)*, but we’ll also sometimes use that phrase
    to refer to the* direction vector ![Image](../images/dvictorit.jpg)*. If that’s
    the case, we’ll explicitly note it. So, if nothing is said, assume by direction
    we mean the direction versor.*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*当我们说*线段的方向*时，大多数时候我们指的是*方向单位向量 ![Image](../images/dcapit.jpg)*，但有时我们也会用这个短语来指代*方向向量
    ![Image](../images/dvictorit.jpg)*。如果是这种情况，我们会明确说明。所以，如果没有特别说明，假设我们指的是方向单位向量。*'
- en: Let’s implement both as properties of the class. Enter the code in [Listing
    5-2](ch05.xhtml#ch5lis2) in your *segment.py* file.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将它们作为类的属性进行实现。将[清单 5-2](ch05.xhtml#ch5lis2)中的代码输入到你的*segment.py*文件中。
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 5-2: Calculating a segment’s direction vector and versor*'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-2：计算线段的方向向量和方向单位向量*'
- en: Since we’re using the make_vector_between and make_versor_between factory functions
    we defined in *vectors.py*, these two attributes are straightforward to implement.
    We simply make a vector or versor between our start and end points.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用了在*vectors.py*中定义的 make_vector_between 和 make_versor_between 工厂函数，这两个属性的实现非常简单。我们只是创建一个起点和终点之间的向量或单位向量。
- en: Now, as important as the direction of the segment is, it’s just as important
    that we know the direction perpendicular to it. We might use this perpendicular
    direction, for instance, to compute the velocity direction of a particle colliding
    against a straight line, which may represent a wall or the ground, such as the
    case in [Figure 5-2](ch05.xhtml#ch5fig2).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，线段的方向和它的垂直方向一样重要。我们可能会使用这个垂直方向，例如计算与直线碰撞的粒子速度方向，这条直线可能代表一堵墙或地面，就像[图 5-2](ch05.xhtml#ch5fig2)中的情况。
- en: '![Image](../images/05fig02.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/05fig02.jpg)'
- en: '*Figure 5-2: Computing the collision angle using the normal direction*'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-2：使用法线方向计算碰撞角度*'
- en: Rotating the direction versor ![Image](../images/dcapit.jpg) *π*/4 radians (90^°)
    yields the segment’s *normal versor*. Computing this versor is quite simple using
    Vector’s perpendicular attribute. Enter the new property in [Listing 5-3](ch05.xhtml#ch5lis3)
    in the Segment class.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 将方向单位向量 ![Image](../images/dcapit.jpg) 旋转 *π*/4 弧度（90^°）得到线段的*法线单位向量*。使用 Vector
    的 perpendicular 属性计算这个单位向量非常简单。将新的属性输入到[清单 5-3](ch05.xhtml#ch5lis3)中，放在 Segment
    类中。
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 5-3: Computing a vector perpendicular to the segment’s direction*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-3：计算垂直于线段方向的向量*'
- en: 'This new property we have added works by chaining two attributes: direction_versor
    and perpendicular. We first call self’s direction_versor to obtain the segment’s
    direction versor. The result is an instance of Vector, upon which we call the
    perpendicular method, which returns a versor perpendicular to the segment’s direction.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加的这个新属性通过链式调用两个属性：direction_versor 和 perpendicular。我们首先调用 self 的 direction_versor
    来获取线段的方向单位向量。结果是一个 Vector 实例，接着我们调用 perpendicular 方法，它返回一个垂直于线段方向的单位向量。
- en: 'We could have stored the direction versor in a new variable and then called
    the perpendicular method on that variable:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以将方向单位向量存储在一个新变量中，然后对该变量调用垂直方法：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this case, the d variable doesn’t add readability to the code, and since
    we use it only once, we can chain both methods and return the result. You’ll see
    this pattern used often in our code.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，d 变量并没有增加代码的可读性，并且由于我们只使用它一次，我们可以将两个方法链式调用并返回结果。你会在我们的代码中经常看到这种模式。
- en: You can see a visual representation of the concepts we just implemented in [Figure
    5-3](ch05.xhtml#ch5fig3). The segment on the left shows the direction vector ![Image](../images/dvictorit.jpg),
    with its origin at *S* (the start point) and tip at *E* (the end point). The segment
    on the right shows the normalized version ![Image](../images/dcapit.jpg) of the
    direction vector and its perpendicular counterpart ![Image](../images/ncapit.jpg),
    the direction and normal versors, respectively.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[图 5-3](ch05.xhtml#ch5fig3)中看到我们刚刚实现的概念的可视化表示。左侧的线段显示了方向向量![Image](../images/dvictorit.jpg)，其起点为*S*（起点），终点为*E*（终点）。右侧的线段显示了方向向量的标准化版本![Image](../images/dcapit.jpg)及其垂直对应物![Image](../images/ncapit.jpg)，分别是方向向量和法向量。
- en: '![Image](../images/05fig03.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/05fig03.jpg)'
- en: '*Figure 5-3: Segment direction vector (left) and direction and normal versors
    (right)*'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-3：线段方向向量（左）以及方向和法向量（右）*'
- en: We’ll skip writing unit tests in this section, but that doesn’t mean you shouldn’t
    do them. From here on out, I won’t write tests for every method we do, just some
    chosen ones, so we can keep focus and get through the content. But it’s a great
    exercise for you to write unit tests for these untested methods. You can refer
    to the tests in the *Mechanics* project accompanying the book.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中我们将跳过编写单元测试，但这并不意味着你不应该写单元测试。从现在开始，我不会为我们编写的每个方法都写测试，只会挑选一些方法，以便保持专注并推进内容。但你可以写单元测试来测试这些未测试的方法，这对你是一个很好的练习。你可以参考书中附带的*Mechanics*项目中的测试。
- en: '***The Segment’s Length***'
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***线段的长度***'
- en: Another important property of a segment is its *length*, or the distance between
    its end points.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 线段的另一个重要属性是它的*长度*，即其端点之间的距离。
- en: '**Calculating Length**'
  id: totrans-54
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**计算长度**'
- en: 'There are at least two ways we can compute the length of the segment: we can
    either compute the distance between points *S* and *E* or compute the length of
    the direction vector ![Image](../images/dvictorit.jpg).'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过至少两种方式计算该段的长度：我们可以计算点*S*和*E*之间的距离，或者计算方向向量的长度![Image](../images/dvictorit.jpg)。
- en: We’ll use the first one, which is shown in [Listing 5-4](ch05.xhtml#ch5lis4),
    but if you prefer, you can implement the second one. The result should be the
    same.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用第一种方法，如[Listing 5-4](ch05.xhtml#ch5lis4)所示，但如果你愿意，也可以实现第二种方法。结果应该是相同的。
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 5-4: Calculating the length of a segment*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 5-4：计算线段的长度*'
- en: Note again that using our previously implemented methods makes this calculation
    a breeze. Your *segment.py* file should look like [Listing 5-5](ch05.xhtml#ch5lis5)
    at this point.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 再次注意，使用我们之前实现的方法使得这个计算变得轻松。此时，你的*segment.py*文件应该看起来像[Listing 5-5](ch05.xhtml#ch5lis5)。
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 5-5: Segment class*'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 5-5：Segment类*'
- en: Let’s test the method we just wrote.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试一下刚写的方法。
- en: '**Unit Testing Length**'
  id: totrans-63
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**单元测试长度**'
- en: To make sure we made no mistakes implementing the length property, let’s write
    a unit test. Start by creating a new test file. Right-click the *geom2d* package,
    select **New** ▸ **Python File**, name it *segment_test.py*, and click **OK**.
    Then enter the code in [Listing 5-6](ch05.xhtml#ch5lis6).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们在实现长度属性时没有犯错，让我们编写一个单元测试。首先创建一个新的测试文件。右键点击*geom2d*包，选择**新建** ▸ **Python文件**，命名为*segment_test.py*，然后点击**确定**。然后输入[Listing
    5-6](ch05.xhtml#ch5lis6)中的代码。
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 5-6: Testing a segment’s length property*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 5-6：测试线段的长度属性*'
- en: 'We import the *unittest* and *math* modules and the Segment and Point classes.
    Then, we define two points: start at (400, 0) and end at (0, 400). Using these
    points, we create segment, which is our test subject. Following Rule 1 for good
    unit tests, a test should fail for one and only one reason, our expected result
    is expressed directly as ![Image](../images/f00107-p1.jpg), which comes from ![Image](../images/f00107-p2.jpg).
    The temptation here would be to write the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入了*unittest*和*math*模块以及Segment和Point类。接着，我们定义了两个点：起点为（400, 0），终点为（0, 400）。利用这两个点，我们创建了segment，它是我们的测试对象。按照好单元测试的规则1，一个测试应该仅因一个原因失败，我们的预期结果直接表示为![Image](../images/f00107-p1.jpg)，该结果来自![Image](../images/f00107-p2.jpg)。这里的诱惑是写下如下内容：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'However, that would violate Rule 1, as the test could fail for more than one
    reason. Moreover, in this case, both the expected and actual values would be computed
    using the same method: distance_to. This breaks the test’s independence from the
    code it’s supposed to test.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这会违反规则1，因为测试可能因为多个原因失败。此外，在这种情况下，预期值和实际值将使用相同的方法进行计算：distance_to。这破坏了测试与它应该测试的代码之间的独立性。
- en: 'Run the test by clicking the green play button to the left of the TestSegment
    class definition and selecting **Run ‘Unittests for segment’**. You can run it
    from the console like so:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击TestSegment类定义左侧的绿色播放按钮，并选择**运行‘线段单元测试’**来运行测试。你也可以通过控制台运行：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'It may seem silly to test the distance property because the only thing it does
    is call the distance_to method, which has already been tested. Even with such
    simple implementations we could have made mistakes such as, for example, trying
    to compute the distance using the same point twice:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 测试距离属性可能看起来有些愚蠢，因为它唯一的作用就是调用已经测试过的distance_to方法。即使是这样简单的实现，我们也可能会犯错误，比如尝试用同一个点计算两次距离：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you probably know from your own experience, we developers make mistakes like
    this more often than not.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能从自己的经验中知道的那样，我们开发者经常会犯这样的错误。
- en: '***The t Parameter and Middle Points***'
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***t 参数和中点***'
- en: We said earlier that there are an infinite number of points between the endpoints
    *E* and *S* of a segment. How do we go about obtaining them? It’s common to use
    a parameter with values going from 0 to 1 (inclusive) to obtain every point along
    the segment. We’ll call this parameter *t* and define it as done in [Equation
    5.3](ch05.xhtml#ch05eqa03).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前说过，线段的起点 *E* 和终点 *S* 之间有无数个点。我们该如何获取这些点呢？通常使用一个从0到1（包括1）的参数来获取线段上的每个点。我们将这个参数称为
    *t*，并按照[方程 5.3](ch05.xhtml#ch05eqa03)中的定义进行定义。
- en: '![Image](../images/05eqa03.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/05eqa03.jpg)'
- en: All points between the segment’s start and end points can be obtained by varying
    the value of *t*. For *t* = 0, we get exactly the segment’s start point *S*. Similarly,
    for *t* = 1, we get the end point *E*. To compute any middle point *P* given a
    value of *t*, we can use [Equation 5.4](ch05.xhtml#ch05eqa04).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 所有线段上的点都可以通过变化 *t* 的值来获得。对于 *t* = 0，我们得到线段的起点 *S*。同样，对于 *t* = 1，我们得到终点 *E*。为了计算给定
    *t* 值的任何中点 *P*，我们可以使用[方程 5.4](ch05.xhtml#ch05eqa04)。
- en: '![Image](../images/05eqa04.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/05eqa04.jpg)'
- en: By realizing that the vector in the previous expression is exactly the direction
    vector as defined in [Equation 5.1](ch05.xhtml#ch05eqa01), we can simplify the
    expression as in [Equation 5.5](ch05.xhtml#ch05eqa05).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 通过意识到前面表达式中的向量正是[方程 5.1](ch05.xhtml#ch05eqa01)中定义的方向向量，我们可以将表达式简化为[方程 5.5](ch05.xhtml#ch05eqa05)中的形式。
- en: '![Image](../images/05eqa05.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/05eqa05.jpg)'
- en: We can easily implement [Equation 5.5](ch05.xhtml#ch05eqa05) using Point’s displaced
    method. Enter the method point_at in [Listing 5-7](ch05.xhtml#ch5lis7) into your
    Segment class file (*segment.py*).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地通过 Point 类的 displaced 方法实现[方程 5.5](ch05.xhtml#ch05eqa05)。将[清单 5-7](ch05.xhtml#ch5lis7)中的point_at方法代码添加到你的Segment类文件中（*segment.py*）。
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 5-7: Obtaining a point from a segment using parameter t*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-7: 使用参数 t 从线段获取点*'
- en: By displacing the start point by the direction vector *t* times (with 0.0 ≤
    *t* ≤ 1.0), we obtain any point on the segment. Let’s implement a property that
    directly yields the middle point of the segment, that is, the point for *t* =
    0.5 (see [Figure 5-4](ch05.xhtml#ch5fig4)).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将起始点沿着方向向量* t *方向平移*t*倍（其中0.0 ≤ *t* ≤ 1.0），我们可以得到线段上的任何一点。我们来实现一个属性，直接得到线段的中点，也就是当
    *t* = 0.5 时的点（见[图 5-4](ch05.xhtml#ch5fig4)）。
- en: '![Image](../images/05fig04.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/05fig04.jpg)'
- en: '*Figure 5-4: A segment’s middle point*'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-4: 线段的中点*'
- en: This is a special point we’ll be computing often, so we want a convenient way
    of obtaining it. Enter the code in [Listing 5-8](ch05.xhtml#ch5lis8)).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们经常计算的特殊点，因此我们希望能够方便地获取它。将[清单 5-8](ch05.xhtml#ch5lis8)中的代码添加进去。
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 5-8: Segment’s middle point*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-8: 线段的中点*'
- en: '**Validating t Values**'
  id: totrans-91
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**验证 t 值**'
- en: You may have realized that in point_at, we don’t check that the passed-in *t*
    value is inside the expected range given by [Equation 5.3](ch05.xhtml#ch05eqa03).
    We can pass it a wrong value for *t*, and it works without complaining, yielding
    points that are out of the segment. For instance, if we passed it a value of *t*
    = 1.5, we’d obtain the point depicted in [Figure 5-5](ch05.xhtml#ch5fig5).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经意识到，在point_at方法中，我们并没有检查传入的 *t* 值是否在[方程 5.3](ch05.xhtml#ch05eqa03)给出的预期范围内。我们可以传入一个错误的
    *t* 值，它依然可以正常工作，返回超出线段的点。例如，如果我们传入 *t* = 1.5 的值，我们将得到[图 5-5](ch05.xhtml#ch5fig5)中所示的点。
- en: '![Image](../images/05fig05.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/05fig05.jpg)'
- en: '*Figure 5-5: Point out of the segment for t = 1.5*'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-5: t = 1.5 时线段外的点*'
- en: Without validating the *t* value, this method silently fails by returning a
    point that the user may be tricked into thinking lies between the segment end
    points. By *silently fail*, we mean that the result is conceptually wrong, but
    the method happily computes it for us without any kind of warning or complaint
    that there may be some kind of error.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不验证 *t* 值，这个方法会悄悄地失败，返回一个点，用户可能会误以为它位于线段的端点之间。我们所说的 *悄悄失败*，是指结果在概念上是错误的，但方法仍然愉快地为我们计算出这个结果，并没有任何警告或提示，表示可能存在错误。
- en: Robust software *fails fast*, meaning that as soon as an erroneous condition
    is detected, the program panics and quits, if possible with a message giving comprehensive
    information about the error.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 稳健的软件 *快速失败*，意味着一旦检测到错误条件，程序就会出现故障并退出，如果可能的话，附带一条提供全面错误信息的消息。
- en: 'This may sound scary, but it helps a lot. Imagine we allow users to pass a
    wrong value of *t* to our point_at(t) method. Now say that the user without noticing
    passes in a *t* like 739928393839\. . . You can imagine the point obtained from
    this value is quite far from the segment that is supposed to contain it. Such
    a value wouldn’t crash our program, and it would continue to execute. We may not
    notice that we’ve gotten such a value until some calculation several minutes later,
    when everything fails. Debugging all of what happened before we found the error
    could take hours (or maybe days, depending on the complexity of the code and how
    far the error spread). It’d be much simpler if we could detect the wrong value
    right away. Perhaps we could tell the user something like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来可能有些可怕，但它帮助很大。假设我们允许用户向我们的 `point_at(t)` 方法传递一个错误的 *t* 值。现在，假设用户没有注意到，传入了一个像
    739928393839... 这样的 *t* 值。你可以想象，从这个值得到的点将远离应该包含它的线段。这样的值不会导致我们的程序崩溃，程序会继续执行。我们可能直到几分钟后的某次计算才会发现得到了这样一个值，这时一切都失败了。在我们发现错误之前调试这些发生的事情可能需要几个小时（或者根据代码的复杂性和错误传播的范围，甚至几天）。如果我们能够立刻检测到错误的值，那就简单多了。也许我们可以像这样告诉用户：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This message is crystal clear. It’s telling the user the program had to quit
    because of an error. This error could have gotten worse had the program continued
    to execute. The nice thing is the user gets the chance to analyze where the wrong
    value came from and take action to prevent it from happening again.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这个消息非常清晰。它告诉用户程序因错误必须退出。如果程序继续执行，错误可能会变得更严重。好的一点是，用户有机会分析错误值的来源，并采取措施防止其再次发生。
- en: '**NOTE**'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Here we’re using the word* user *to reference anyone using our code, not the
    end user of the applications we write. This includes yourself, as you’ll be the
    user of your own code quite often.*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这里我们使用“用户”这个词，指的是任何使用我们代码的人，而不是我们编写的应用程序的最终用户。这包括你自己，因为你将经常是自己代码的用户。*'
- en: 'Since there’s going to be a bunch of functionality defined for the *t* parameter,
    we’d better create a module for it. At this point, your project’s structure should
    look like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 由于需要为 *t* 参数定义一堆功能，我们最好为它创建一个模块。此时，你的项目结构应该是这样的：
- en: Mechanics
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Mechanics
- en: '|- geom2d'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '|- geom2d'
- en: '|    |- __init__.py'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- __init__.py'
- en: '|    |- nums.py'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- nums.py'
- en: '|    |- point.py'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- point.py'
- en: '|    |- point_test.py'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- point_test.py'
- en: '|    |- segment.py'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- segment.py'
- en: '|    |- segment_test.py'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- segment_test.py'
- en: '|    |- vector.py'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- vector.py'
- en: '|    |- vector_test.py'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- vector_test.py'
- en: '|    |- vectors.py'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- vectors.py'
- en: Create a new file inside the *geom2d* package named *tparam.py*. Inside it,
    enter the code from [Listing 5-9](ch05.xhtml#ch5lis9).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *geom2d* 包内创建一个新文件，命名为 *tparam.py*。在其中输入 [Listing 5-9](ch05.xhtml#ch5lis9)
    中的代码。
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 5-9: Validating parameter t values*'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 5-9: 验证 t 参数值*'
- en: We start by defining three useful constants. There’s MIN, the minimum value
    *t* can take. There’s MIDDLE, the value of (MIN + MAX) / 2\. Finally, there’s
    MAX, the maximum value *t* can take.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义三个有用的常量。MIN 是 *t* 可以取的最小值。MIDDLE 是 (MIN + MAX) / 2 的值。最后，MAX 是 *t* 可以取的最大值。
- en: These values are going to be used a lot, so instead of writing *magic numbers*
    (numbers that appear hard-coded without explanation about their nature) everywhere,
    we’ve given them a name to understand what they refer to.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值将会被多次使用，因此我们没有在每个地方写 *魔法数字*（硬编码的数字，没有解释它们的含义），而是给它们命名以便理解它们代表的意义。
- en: 'Once we’ve defined the values, we define the function make to create a parameter
    with a valid value. Then comes the function ensure_valid, which checks that *t*
    is not less or greater than the range limits using another method: is_valid. If
    *t* has a value outside the valid range, an exception is raised. TParam Error
    is an implementation of Python’s Exception. This is a user-defined exception we
    provide with a nice formatted message. In the initializer for TParam Error, we
    pass the offending *t* value, and in the special method __str__, we return the
    actual message. Recall that a class may define the __str__ method to provide a
    textual (string) representation of the instance when it’s called.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了这些值，我们定义了一个函数 `make` 来创建一个具有有效值的参数。接着是 `ensure_valid` 函数，它通过另一个方法 `is_valid`
    来检查 *t* 是否小于或大于范围限制。如果 *t* 的值超出了有效范围，将会引发异常。TParam Error 是 Python 异常的实现。这是一个用户自定义的异常，我们为其提供了格式良好的信息。在
    TParam Error 的初始化器中，我们传递了出错的 *t* 值，在特殊方法 `__str__` 中，我们返回实际的错误信息。回想一下，一个类可以定义
    `__str__` 方法来提供实例的文本（字符串）表示形式，当该方法被调用时。
- en: 'To see how it prints the message, try the following in the console:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看它如何打印信息，请在控制台尝试以下操作：
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The error message is nice and clear:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 错误信息清晰明了：
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let’s use this validation in the point_at method from the Segment class. First,
    import the module in your *segment.py* file:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `Segment` 类的 `point_at` 方法中使用这个验证。首先，在你的 *segment.py* 文件中导入模块：
- en: '[PRE17]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Go back to *segment.py* and refactor point_at(t) to include the validation,
    as in [Listing 5-10](ch05.xhtml#ch5lis10).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 *segment.py*，重构 `point_at(t)`，包括验证，如 [列表 5-10](ch05.xhtml#ch5lis10) 中所示。
- en: '[PRE18]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 5-10: Validating values of t in segment’s point_at method*'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-10：在 segment 的 point_at 方法中验证 t 的值*'
- en: Then refactor the middle property to remove the 0.5 magic number as shown in
    [Listing 5-11](ch05.xhtml#ch5lis11).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然后按照 [列表 5-11](ch05.xhtml#ch5lis11) 中的示例，重构中点属性，去除 0.5 的魔法数字。
- en: '[PRE19]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 5-11: Removing the magic number from our middle point computation*'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-11：从中点计算中去除魔法数字*'
- en: If you followed along, your *segment.py* file should look like [Listing 5-12](ch05.xhtml#ch5lis12).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你跟着做，你的 *segment.py* 文件应该如下所示：[列表 5-12](ch05.xhtml#ch5lis12)。
- en: '[PRE20]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 5-12: The Segment class*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-12：Segment 类*'
- en: With our Segment class complete, let’s write some tests.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `Segment` 类完成后，让我们编写一些测试。
- en: '**Unit Testing Segment Points**'
  id: totrans-136
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**单元测试 Segment 点**'
- en: 'Since we’ll use point_at as part of more complex computations, we really want
    to make sure it works, so let’s start with a test to assert that if it passes
    a wrong value of *t*, an exception is actually raised. This gives us the opportunity
    to learn a new assertion method: assertRaises.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将把 `point_at` 作为更复杂计算的一部分，我们真的很想确保它能正常工作，因此让我们从一个测试开始，断言如果它传入一个错误的 *t* 值，实际上会引发异常。这为我们提供了一个学习新断言方法
    `assertRaises` 的机会。
- en: 'In the file *segment_test.py*, start by importing the *tparam* module:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *segment_test.py* 文件中，首先导入 *tparam* 模块：
- en: '[PRE21]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Then write the test in [Listing 5-13](ch05.xhtml#ch5lis13).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然后编写 [列表 5-13](ch05.xhtml#ch5lis13) 中的测试。
- en: '[PRE22]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 5-13: Testing wrong values of t*'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-13：测试 t 的错误值*'
- en: This assertion is a bit more complex than the ones we’ve seen so far. We are
    passing it three arguments. First is the expected exception to be raised (TParamError)
    ➊. Second, we pass the method that is expected to raise the exception ➋. Last,
    we pass the arguments to be passed into the previous method (point_at in this
    case) as comma-separated arguments ➌.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这个断言比我们之前看到的那些稍微复杂一点。我们传递了三个参数。第一个是预期引发的异常（TParamError） ➊。第二个，我们传递了预期引发异常的方法
    ➋。最后，我们传递了要传递给前面方法的参数（此例中为 `point_at`），作为以逗号分隔的参数 ➌。
- en: 'The assertion can be read as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这个断言可以理解为：
- en: assert that method 'point_at' from instance 'self.segment'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 断言方法 'point_at' 来自实例 'self.segment'
- en: raises an exception of type 'tparam.TParamError'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 引发类型为 'tparam.TParamError' 的异常
- en: when called with arguments '56.7'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用参数为 '56.7' 时
- en: If point_at accepted more than one argument, you would include them as arguments
    of assertRaises. Now, let’s include the two test cases from [Listing 5-14](ch05.xhtml#ch5lis14).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `point_at` 方法接受多个参数，你可以将它们作为 `assertRaises` 的参数。现在，让我们包含来自 [列表 5-14](ch05.xhtml#ch5lis14)
    的两个测试用例。
- en: '[PRE23]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 5-14: Testing the point_at method*'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-14：测试 point_at 方法*'
- en: 'In the first test case, we ensure that a middle point for a valid *t* value,
    0.25 in this case, yields the expected point. Using [Equation 5.4](ch05.xhtml#ch05eqa04),
    this point can be computed as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个测试案例中，我们确保对于有效的 *t* 值（在此情况下为 0.25），可以得到预期的中点。使用 [方程 5.4](ch05.xhtml#ch05eqa04)，可以按以下方式计算该点：
- en: '![Image](../images/f0114-01.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0114-01.jpg)'
- en: 'The second test is for the middle attribute, which computes the point at *t*
    = 0.5\. Take a pen and some paper and make sure point (200, 200) is right in our
    test. Then run all the tests in the *segment_test.py* file to make sure all of
    them pass. You can do this from the console as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个测试是中间属性，它计算 *t* = 0.5 时的点。拿一支笔和一些纸，确保点 (200, 200) 在我们的测试中。然后运行 *segment_test.py*
    文件中的所有测试，以确保它们都通过。你可以通过以下方式在控制台运行：
- en: '[PRE24]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '***Closest Point***'
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***最近点***'
- en: 'Now suppose we want to know what the segment’s point is that is closest to
    an outside point. If the outside point is not aligned with the segment, that is,
    a line perpendicular to the segment going through the point doesn’t intersect
    with the segment, then the closest point has to be one of the two end points:
    *S* or *E*. If, on the other hand, the point is aligned with the segment, the
    intersection between the perpendicular line and the segment itself yields the
    closest point. [Figure 5-6](ch05.xhtml#ch5fig6) illustrates this.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们想知道线段上离外部点最近的点是什么。如果外部点与线段不对齐，即通过该点的垂线不与线段相交，那么最近的点必须是两个端点之一：*S* 或 *E*。另一方面，如果外部点与线段对齐，则垂直线与线段的交点就是最近的点。[图
    5-6](ch05.xhtml#ch5fig6)展示了这一点。
- en: '![Image](../images/05fig06.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/05fig06.jpg)'
- en: '*Figure 5-6: A segment’s closest points*'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-6：线段的最近点*'
- en: In the figure, point *S* ≡ *A′* is the closest point to *A*, point *E* ≡ *B′*
    is the closest point to *B*, and *C′* is the closest point to *C*. Let’s see how
    we can implement this procedure.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在图中，点 *S* ≡ *A′* 是距离 *A* 最近的点，点 *E* ≡ *B′* 是距离 *B* 最近的点，*C′* 是距离 *C* 最近的点。接下来让我们看看如何实现这个过程。
- en: '**The Algorithm**'
  id: totrans-160
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**算法**'
- en: With the help of the method projection_over from [Chapter 4](ch04.xhtml#ch04),
    we can find the closest point easily. We’ll use *P* as the external point, *l*
    as the length of the segment, and the various points, segments, and vectors in
    [Figure 5-7](ch05.xhtml#ch5fig7).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 4 章](ch04.xhtml#ch04)中使用 `projection_over` 方法的帮助下，我们可以轻松找到最近点。我们将 *P* 作为外部点，*l*
    作为线段的长度，并且使用[图 5-7](ch05.xhtml#ch5fig7)中的各个点、线段和向量。
- en: '![Image](../images/05fig07.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/05fig07.jpg)'
- en: '*Figure 5-7: Auxiliary vectors for the algorithm that computes a segment’s
    closest point*'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-7：计算线段最近点的算法辅助向量*'
- en: 'The algorithm is as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 算法如下：
- en: Compute a vector ![Image](../images/vvictorit.jpg) going from segment’s *S*
    to external point *P*.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算一个向量![Image](../images/vvictorit.jpg)，它从线段的 *S* 指向外部点 *P*。
- en: Compute the projection of ![Image](../images/vvictorit.jpg) over the segment’s
    direction versor, ![Image](../images/dcapit.jpg).
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算![Image](../images/vvictorit.jpg)在线段方向单位向量![Image](../images/dcapit.jpg)上的投影。
- en: Depending on the value of the projection, call it *v*[*s*]. The closest point
    *P′* can be calculated using [Equation 5.6](ch05.xhtml#ch05eqa06).
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据投影的值，称之为 *v*[*s*]。最近的点 *P′* 可以通过[方程 5.6](ch05.xhtml#ch05eqa06)计算得出。
- en: '![Image](../images/05eqa06.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/05eqa06.jpg)'
- en: If the value of the projection *v*[*s*] is negative, the projection lies outside
    the segment on *S*’s side; hence, the closest point is *S*. For numbers greater
    than *l*, the projection over the segment’s direction is longer than the segment
    itself. Thus, the result is the end point *E*. For any value of *v*[*s*] in the
    closed range [0,*l*], we obtain the point by displacing *S* in the direction of
    ![Image](../images/dcapit.jpg) *v*[*s*] times. [Figure 5-7](ch05.xhtml#ch5fig7)
    depicts this last case where the external point *P* is aligned with the segment.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果投影 *v*[*s*] 的值为负，则投影位于线段的 *S* 侧之外，因此最近的点是 *S*。对于大于 *l* 的值，线段方向上的投影长度大于线段本身。因此，结果是端点
    *E*。对于闭区间 [0,*l*] 中的任何 *v*[*s*] 值，我们通过在![Image](../images/dcapit.jpg)方向上移动 *S*
    *v*[*s*] 倍来获得该点。[图 5-7](ch05.xhtml#ch5fig7)展示了外部点 *P* 与线段对齐的最后一种情况。
- en: The code for this operation is in [Listing 5-15](ch05.xhtml#ch5lis15).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 此操作的代码见[清单 5-15](ch05.xhtml#ch5lis15)。
- en: '[PRE25]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 5-15: Closest point to a segment*'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-15：线段的最近点*'
- en: 'We start by computing vector ![Image](../images/vvictorit.jpg). We then get
    *v*[*s*]: the projection of ![Image](../images/vvictorit.jpg) over the segment’s
    direction versor ![Image](../images/dcapit.jpg). If *v*[*s*] is smaller than zero,
    we return the start point. If greater than the length of the segment, we return
    the end point; otherwise, we compute the displacement of the start point that
    yields the resulting point on the segment.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先计算向量 ![图片](../images/vvictorit.jpg)。然后得到 *v*[*s*]：这是向量 ![图片](../images/vvictorit.jpg)
    在段的方向单位向量 ![图片](../images/dcapit.jpg) 上的投影。如果 *v*[*s*] 小于零，我们返回起点。如果大于段的长度，我们返回终点；否则，我们计算起点的位移，得到段上的结果点。
- en: '**Unit Testing Closest Points**'
  id: totrans-174
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**单元测试最近点**'
- en: Let’s test the three different cases defined earlier, namely, *v*[*s*] < 0,
    *v*[*s*] > *l*, and 0 < *v*[*s*] < *l*. [Listing 5-16](ch05.xhtml#ch5lis16) shows
    the code for the tests.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试之前定义的三种不同情况，即 *v*[*s*] < 0，*v*[*s*] > *l* 和 0 < *v*[*s*] < *l*。[清单 5-16](ch05.xhtml#ch5lis16)显示了测试的代码。
- en: '[PRE26]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Listing 5-16: Testing a segment’s closest point*'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-16：测试段的最近点*'
- en: To better understand the tests, it may be a good exercise to draw the segment
    and each of the external points by hand to see whether you can figure out why
    the expected results have the values they have. Your drawing should look similar
    to [Figure 5-8](ch05.xhtml#ch5fig8). Furthermore, trying to solve the three cases
    by hand will presumably give you some insight into the algorithm.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这些测试，手动绘制段和每个外部点可能是一个不错的练习，这样你可以看出预期结果为什么会有这些值。你的绘图应该类似于[图 5-8](ch05.xhtml#ch5fig8)。此外，尝试手动解决这三种情况可能会帮助你更好地理解算法。
- en: '![Image](../images/05fig08.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/05fig08.jpg)'
- en: '*Figure 5-8: The segment’s closest points and their test cases*'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-8：该段的最近点及其测试案例*'
- en: 'Don’t forget to run all tests and make sure they all succeed. You can do this
    from the console as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 别忘了运行所有的测试并确保它们都通过。你可以通过控制台如下操作：
- en: '[PRE27]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '***Distance to a Point***'
  id: totrans-183
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***点到点的距离***'
- en: Now that we know the closest point in the segment to an external point, we can
    easily compute the distance between it and the segment. Enter the method in [Listing
    5-17](ch05.xhtml#ch5lis17).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了段与外部点之间最近的点，我们可以轻松地计算出它与该段的距离。输入方法见[清单 5-17](ch05.xhtml#ch5lis17)。
- en: '[PRE28]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*Listing 5-17: Computing the distance from a point to the segment*'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-17：计算点到段的距离*'
- en: As you can see in the code, the distance between the segment and any given external
    point is the distance between the point and that in the segment that is closest
    to it. Simple, isn’t it?
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在代码中看到的，段与任何给定外部点之间的距离就是该点与段上最接近它的点之间的距离。很简单，不是吗？
- en: '***Segment Intersections***'
  id: totrans-188
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***段交点***'
- en: Now we get to the fun stuff. How do we test whether two segments intersect?
    If they do intersect, how do we compute the intersection point? Consider the cases
    from [Figure 5-9](ch05.xhtml#ch5fig9).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们进入有趣的部分。我们如何测试两段是否相交？如果它们相交，我们如何计算交点？请参考[图 5-9](ch05.xhtml#ch5fig9)中的情况。
- en: '![Image](../images/05fig09.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/05fig09.jpg)'
- en: '*Figure 5-9: Possible segment intersection cases*'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-9：可能的段交点情况*'
- en: The two cases from the left column have no intersection, but there is a difference
    between them. In the first case, the direction vectors of the segments are parallel
    (![Image](../images/d1victorit.jpg) × ![Image](../images/d2victorit.jpg) = 0).
    Thus, it’s easy to know there will be no intersection. In the other case, if instead
    of segments we had infinite lines, there would be an intersection point. It might
    be far from where the segments are, but there’d be one nonetheless. As we’ll see
    in the following equations, we’ll have to compute the intersection point as if
    we were working with lines and then ensure the point lies inside both segments.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 左列的两个案例没有交点，但它们之间有区别。在第一个案例中，段的方向向量是平行的 (![图片](../images/d1victorit.jpg) × ![图片](../images/d2victorit.jpg)
    = 0)。因此，很容易知道它们不会相交。在另一个案例中，如果我们用无限长的直线代替段，它们会有交点。交点可能远离段的位置，但仍然会有交点。如我们在接下来的方程中所看到的，我们需要像处理直线那样计算交点，然后确保该点位于两个段内部。
- en: 'In the upper-right case, the two segments overlap; hence, there is more than
    one intersection point—an infinite number, to be precise. For our analysis we’ll
    define two possible cases: segments either have an intersection point or don’t
    intersect at all (we won’t be considering the upper-right case). We’ll forget
    about the overlapping case since we won’t be needing it for our applications,
    and we want simplified code.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在右上角的情况中，两个线段重叠，因此有不止一个交点——准确地说，是无限多个交点。对于我们的分析，我们将定义两种可能的情况：线段要么有交点，要么根本不相交（我们不会考虑右上角的情况）。我们会忽略重叠的情况，因为我们的应用中不需要它，而且我们希望代码更加简化。
- en: '**Overlapping Segments**'
  id: totrans-194
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**重叠的线段**'
- en: 'If we were to include the case where the segments overlap, the return object
    for the intersection function could be either a Point or a Segment. A function
    that returns different object types is hard to work with. Once we have the result,
    we’d need to check what type of object we got and act accordingly. This could
    look as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们包括线段重叠的情况，交点函数的返回对象可能是点或线段。返回不同对象类型的函数很难操作。一旦得到结果，我们还需要检查返回的对象类型，并采取相应的操作。可以如下实现：
- en: '[PRE29]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: But this code is messy. There are better ways of handling this logic, but we
    won’t get into it, as for us there will be either an intersection point or no
    intersection at all. That will make our code simpler and easier to work with.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 但是这段代码比较混乱。有更好的方式来处理这个逻辑，不过我们不讨论这些，因为对于我们来说，要么有交点，要么根本没有交点。这样会让我们的代码更加简洁，易于操作。
- en: Let’s take a look at the algorithm.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下这个算法。
- en: '**The Algorithm**'
  id: totrans-199
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**算法**'
- en: 'Let’s find the intersection point of a case like the one in the lower right
    of [Figure 5-9](ch05.xhtml#ch5fig9). Say we have two segments:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们找出像[图 5-9](ch05.xhtml#ch5fig9)右下角那种情况的交点。假设我们有两条线段：
- en: Segment 1 with start point *S*[1] and end point *E*[1]
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线段 1，起点 *S*[1] 和终点 *E*[1]
- en: Segment 2 with start point *S*[2] and end point *E*[2]
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线段 2，起点 *S*[2] 和终点 *E*[2]
- en: We can compute every point in segment 1, let’s call it *P*[1], using the following
    expression,
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以计算线段 1 上的每个点，记为 *P*[1]，使用如下表达式：
- en: '![Image](../images/f0118-01.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0118-01.jpg)'
- en: 'where *t*[1] is the parameter that goes from 0 to 1 and ![Image](../images/d1victorit.jpg)
    is the direction vector (not versor) for the segment. Similarly, here is segment
    2:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *t*[1] 是从 0 到 1 的参数，![Image](../images/d1victorit.jpg) 是该线段的方向向量（不是单位向量）。同样，线段
    2 如下：
- en: '![Image](../images/f0118-02.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0118-02.jpg)'
- en: 'To find the intersection point, we have to look for a pair of values *t*[1]
    and *t*[2] such that *P*[1](*t*[1]) = *P*[2](*t*[2]):'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找出交点，我们必须寻找一对 *t*[1] 和 *t*[2] 的值，使得 *P*[1](*t*[1]) = *P*[2](*t*[2])：
- en: '![Image](../images/f0119-01.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0119-01.jpg)'
- en: 'If both segments intersect, plugging those *t* parameter values in their respective
    segment expressions should result in the same point, the intersection point *P*.
    Let’s rewrite the expression in its vector form:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这两条线段相交，将这两个*t*参数值代入各自的线段表达式应能得到相同的点，即交点 *P*。让我们将表达式重写为向量形式：
- en: '![Image](../images/f0119-02.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0119-02.jpg)'
- en: 'We can use this form to obtain a scalar system of two equations and two unknowns,
    *t*[1] and *t*[2]:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这种形式来得到一个标量系统，包含两个方程和两个未知数，*t*[1] 和 *t*[2]：
- en: '![Image](../images/f0119-03.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0119-03.jpg)'
- en: I’ll spare you the details and give you the result, though it may be a good
    exercise to solve the system yourself for *t*[1] and *t*[2]. The final expressions
    for the *t* parameters are as shown in [Equations 5.7](ch05.xhtml#ch05eqa07) and
    [5.8](ch05.xhtml#ch05eqa08).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我不打算详细介绍这些细节，直接给你结果，不过自己解这个系统来求解 *t*[1] 和 *t*[2] 可能是一个不错的练习。最终的 *t* 参数表达式如[方程
    5.7](ch05.xhtml#ch05eqa07)和[5.8](ch05.xhtml#ch05eqa08)所示。
- en: '![Image](../images/05eqa07.jpg)![Image](../images/05eqa08.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/05eqa07.jpg)![Image](../images/05eqa08.jpg)'
- en: Here, Δ*S*[*x*] = *S*[2*x*] *– S*[1*x*], Δ*S*[*y*] = *S*[2*y*] *– S*[1*y*],
    and ![Image](../images/f00119-p1.jpg). Note that these formulas would yield *∞*
    if the segments were parallel ![Image](../images/f00119-p2.jpg). We can’t attempt
    a division by zero; that would raise an exception in our Python code, so we’ll
    need to detect this case before we try to compute the values of *t*[1] and *t*[2].
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，Δ*S*[*x*] = *S*[2*x*] *– S*[1*x*]，Δ*S*[*y*] = *S*[2*y*] *– S*[1*y*]，并且 ![Image](../images/f00119-p1.jpg)。请注意，如果线段平行，这些公式将产生
    *∞* 的结果 ![Image](../images/f00119-p2.jpg)。我们不能尝试除以零，因为那会在我们的 Python 代码中引发异常，所以我们需要在尝试计算
    *t*[1] 和 *t*[2] 的值之前先检测这种情况。
- en: 'With these two values computed for the case where segments were not parallel,
    we have two possible outcomes:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 对于线段不平行的情况，当计算出这两个值后，我们有两种可能的结果：
- en: Values *t*[1] and *t*[2] are both inside range [0, 1]. The intersection point
    belongs to both segments.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值 *t*[1] 和 *t*[2] 都在范围 [0, 1] 内。交点属于两个线段。
- en: One or both of *t*[1] and *t*[2] are outside range [0, 1]. The intersection
    point is outside of at least one of the segments.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*t*[1] 和 *t*[2] 中的一个或两个超出了范围 [0, 1]。交点位于至少一个线段之外。'
- en: Now we’re ready to implement the logic in an algorithm. In your *segment.py*
    file, implement the intersection_with method as shown in [Listing 5-18](ch05.xhtml#ch5lis18).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备将逻辑实现为算法。在你的 *segment.py* 文件中，按照 [列表 5-18](ch05.xhtml#ch5lis18) 中所示实现
    intersection_with 方法。
- en: '[PRE30]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*Listing 5-18: Intersection between two segments*'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-18：两个线段的交点*'
- en: We start by storing both segments’ direction vectors in the variables d1 and
    d2 using Python’s multiple assignment. With the multiple assignment, several values
    can be assigned to variables at once. Then we check whether the directions are
    parallel, in which case we return None. If we find the segments aren’t parallel,
    we compute ![Image](../images/f00120-p1.jpg) and Δ*S* and store them in the variables
    cross_prod and delta. With the help of these values, we then compute *t*[1] and
    *t*[2]. If these values are inside their valid range, we then return the resulting
    intersection point by calling point_at on the current Segment object (self). Make
    sure you understand that we could have computed *P* using *t*[2] and called point_at
    on other. The result would’ve been the same.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过使用 Python 的多重赋值将两个线段的方向向量存储到变量 d1 和 d2 中。通过多重赋值，可以一次为多个变量赋值。接着，我们检查方向是否平行，如果平行，则返回
    None。如果发现线段不平行，我们计算![Image](../images/f00120-p1.jpg) 和 Δ*S*并将其存储在变量 cross_prod
    和 delta 中。借助这些值，我们再计算 *t*[1] 和 *t*[2]。如果这些值在其有效范围内，我们通过在当前线段对象（self）上调用 point_at
    返回交点。请确保理解我们也可以使用 *t*[2] 来计算 *P* 并在另一个上调用 point_at，结果会是一样的。
- en: '**NOTE**'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Similarly to other languages such as Java or C# with* null*, one should use*
    None *judiciously. Use it for cases where having an empty-like value is a perfectly
    valid outcome. For instance, in our* intersection_with *method,* None *represents
    the case where there exists no intersection point.*'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '*与其他语言（如 Java 或 C# 中的* null*）类似，*None* 应谨慎使用。它应该用于那些拥有类似空值且是完全有效结果的情况。例如，在我们的*intersection_with*方法中，*None*
    代表没有交点的情况。*'
- en: '**Unit Testing Segment Intersections**'
  id: totrans-225
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**线段交点单元测试**'
- en: As we advance with the book material and our code becomes more complex, testing
    these code fragments will become more involved. The method we just wrote for computing
    intersection between segments has a couple of branches or paths the execution
    can take. With the objective of being as exhaustive as possible with our unit
    tests, let’s compile every case we want covered (see [Table 5-1](ch05.xhtml#ch5tab1)).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们书籍内容的推进以及代码变得更加复杂，测试这些代码片段将变得更加复杂。我们刚刚写的用于计算线段交点的方法有几个分支或路径可以执行。为了尽可能全面地进行单元测试，让我们列出我们希望覆盖的每一种情况（参见
    [表 5-1](ch05.xhtml#ch5tab1)）。
- en: '**Table 5-1:** Segment Intersection Algorithm Outcomes'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 5-1：** 线段交点算法结果'
- en: '| **Segment Directions** | t[1] | t[2] | **Intersection Result** |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| **线段方向** | t[1] | t[2] | **交点结果** |'
- en: '| ![Image](../images/f00120-p2.jpg) | — | — | None |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| ![Image](../images/f00120-p2.jpg) | — | — | None |'
- en: '| ![Image](../images/f00120-p3.jpg) | Out of range | Out of range | None |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| ![Image](../images/f00120-p3.jpg) | 超出范围 | 超出范围 | None |'
- en: '| ![Image](../images/f00120-p3.jpg) | In range | Out of range | None |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| ![Image](../images/f00120-p3.jpg) | 在范围内 | 超出范围 | None |'
- en: '| ![Image](../images/f00120-p3.jpg) | Out of range | In range | None |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| ![Image](../images/f00120-p3.jpg) | 超出范围 | 在范围内 | None |'
- en: '| ![Image](../images/f00120-p3.jpg) | In range | In range | ![Image](../images/f00120-p4.jpg)
    |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| ![Image](../images/f00120-p3.jpg) | 在范围内 | 在范围内 | ![Image](../images/f00120-p4.jpg)
    |'
- en: We’ll be writing unit tests for the first and last cases from [Table 5-1](ch05.xhtml#ch5tab1);
    I’ll leave the other three as an exercise for you. In file *segment_test.py*,
    include the tests in [Listing 5-19](ch05.xhtml#ch5lis19) in the TestSegmentclass.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为 [表 5-1](ch05.xhtml#ch5tab1) 中的第一个和最后一个情况编写单元测试；其他三个留给你作为练习。在 *segment_test.py*
    文件中，将 [列表 5-19](ch05.xhtml#ch5lis19) 中的测试包含到 TestSegment 类中。
- en: '[PRE31]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '*Listing 5-19: Testing segment intersections*'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-19：测试线段交点*'
- en: 'So, in the first test, we construct a parallel segment and assert that the
    intersection between the two is None with the assertion assertIsNone, which checks
    that the passed-in value is None. In the second, we construct a segment perpendicular
    to the first one that intersects it at (200, 200) and assert we get that point
    as the result. You can run all the tests in the file from the IDE by clicking
    the green play button or from the console as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个测试中，我们构造了一个平行线段，并通过断言 assertIsNone 来验证这两个线段的交点为 None，assertIsNone 会检查传入的值是否为
    None。在第二个测试中，我们构造了一个垂直于第一个线段的线段，并在交点 (200, 200) 与第一个线段相交，断言我们得到了该点作为结果。你可以通过点击
    IDE 中的绿色播放按钮，或者在控制台中如下运行文件中的所有测试：
- en: '[PRE32]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Can you come up with the segments needed for the other three cases?
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 你能想出其他三种情况所需的线段吗？
- en: '***Equality and String Representation***'
  id: totrans-240
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***相等性和字符串表示***'
- en: Just as we did with the Point and Vector classes, we want to overload the ==
    operator so that Python understands two segments with equal start and end points
    as logically equal, and we want to implement a __str__ method so we can get a
    nice string representation of the segment. Enter the code in [Listing 5-20](ch05.xhtml#ch5lis20)
    in the *segment.py* file.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在 Point 和 Vector 类中所做的那样，我们想要重载 == 运算符，以便 Python 能够理解具有相同起点和终点的两个线段在逻辑上是相等的，并且我们希望实现一个
    `__str__` 方法，以便我们可以获得该线段的漂亮字符串表示。在 *segment.py* 文件中输入代码，[列表 5-20](ch05.xhtml#ch5lis20)。
- en: '[PRE33]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '*Listing 5-20: Equality of segments and string representation*'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-20：线段的相等性和字符串表示*'
- en: We’ll add one last property once we’ve developed the Line class. If you followed
    along, your Segment class should look similar to [Listing 5-21](ch05.xhtml#ch5lis21).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们开发了 Line 类，我们将添加最后一个属性。如果你跟随代码，您的 Segment 类应该类似于 [列表 5-21](ch05.xhtml#ch5lis21)。
- en: '[PRE34]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '*Listing 5-21: The Segment class*'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-21：线段类*'
- en: '**Line Class**'
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Line 类**'
- en: An infinite line can be described by a base point *B* and a direction vector
    ![Image](../images/dvictorit.jpg), like that in [Figure 5-10](ch05.xhtml#ch5fig10).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 一条无限长的线可以通过一个基准点 *B* 和一个方向向量 ![图像](../images/dvictorit.jpg) 来描述，正如 [图 5-10](ch05.xhtml#ch5fig10)
    所示。
- en: '![Image](../images/05fig10.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/05fig10.jpg)'
- en: '*Figure 5-10: A line with a base point B and direction vector ![Image](../images/dvictor_normal.jpg)*'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-10：带有基准点 B 和方向向量的线 ![图像](../images/dvictor_normal.jpg)*'
- en: Lines are useful helper primitives; with them we can build more complex geometries
    and operations. One common usage of lines, for example, is finding where two nonparallel
    directions intersect. You’ll see in the next chapter how operations such as constructing
    a circle out of three points are effortless using line intersections.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 线是有用的辅助原始数据；通过它们我们可以构建更复杂的几何体和操作。例如，线的一个常见用途是找到两条不平行方向的交点。你将在下一章看到，利用线的交点，像通过三点构建一个圆这样的操作变得轻而易举。
- en: 'Let’s create a new Line class with these two properties: a base point and a
    direction. In the *geom2d* package, add a new file named *line.py* and enter the
    code in [Listing 5-22](ch05.xhtml#ch5lis22).'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的 Line 类，包含这两个属性：基准点和方向。在 *geom2d* 包中，添加一个名为 *line.py* 的新文件，并在其中输入 [列表
    5-22](ch05.xhtml#ch5lis22) 中的代码。
- en: '[PRE35]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '*Listing 5-22: Line initialization*'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-22：线初始化*'
- en: The initializer sets our properties base and direction based on the values passed
    into their corresponding arguments. Like before, we’ve typed the base and direction
    arguments so our IDE can warn us of any potential errors.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化器根据传入的相应参数值设置我们的基准点和方向属性。像之前一样，我们已经为基准点和方向参数添加了类型注解，以便我们的 IDE 能警告我们潜在的错误。
- en: Let’s now provide two methods that check whether a line is parallel or perpendicular
    to another line ([Listing 5-23](ch05.xhtml#ch5lis23)).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们提供两个方法，检查一条线是否平行或垂直于另一条线（[列表 5-23](ch05.xhtml#ch5lis23)）。
- en: '[PRE36]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '*Listing 5-23: Checking whether lines are parallel or perpendicular*'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-23：检查线条是否平行或垂直*'
- en: We didn’t implement these methods for Segment, because our concern was with
    the segment’s infinite points and how they’re located in the plane; here, on the
    other hand, we’re working with directions. Working with directions requires knowledge
    of their relative positioning; Are they parallel? Are they perpendicular?
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有为 Segment 实现这些方法，因为我们关心的是线段的无限点及其在平面上的位置；而在这里，我们处理的是方向。处理方向需要了解它们的相对位置：它们是平行的吗？它们是垂直的吗？
- en: With lines, the question is usually about how they are positioned with respect
    to other lines; with segments, the question is usually about how they are positioned
    themselves.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 对于线，问题通常是它们相对于其他线的位置；而对于线段，问题通常是它们自身的位置。
- en: 'To check whether two lines are parallel, we could simply access their direction
    properties and use their methods like so:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查两条直线是否平行，我们可以简单地访问它们的方向属性，并像这样使用它们的方法：
- en: '[PRE37]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This is definitely possible, but it’s not considered good practice. There is
    a guideline commonly known as the *principle of least knowledge* or *law of Demeter*,
    which states that “you should only talk to your immediate friends.” In this case,
    as we are working with lines, lines are our immediate friends. The Line properties
    base point and direction vector are not our immediate friends; thus, we shouldn’t
    ask them for stuff. If we need something from them, we have to ask our immediate
    friend, the Line holding such properties, to do it for us.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实是可能的，但通常不被认为是最佳做法。常有一种指导原则，称为*最小知识原则*或*德梅特法则*，它指出：“你应该只与你的直接朋友交谈。”在这种情况下，由于我们正在处理直线，直线是我们的直接朋友。直线的基准点和方向向量不是我们的直接朋友；因此，我们不应该向它们索取信息。如果我们需要它们的某些内容，我们必须要求我们的直接朋友——包含这些属性的直线——为我们做。
- en: 'So, here’s how we should check whether two lines are parallel or perpendicular:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们应该如何检查两条直线是否平行或垂直呢：
- en: '[PRE38]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Let’s also include two more methods to create new lines that are perpendicular
    or parallel to an existing line and that go through a point. In your file, enter
    the code in [Listing 5-24](ch05.xhtml#ch5lis24).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再增加两个方法，用于创建与现有直线垂直或平行并通过某个点的新直线。在你的文件中，输入[示例 5-24](ch05.xhtml#ch5lis24)中的代码。
- en: '[PRE39]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '*Listing 5-24: Creating perpendicular and parallel lines*'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 5-24：创建垂直和平行的直线*'
- en: The method perpendicular_through receives point as an argument and returns a
    new line, which uses that base point and direction vector perpendicular to the
    original line. Similarly, parallel_through constructs a new line with the given
    base point but using the same direction vector as the original line.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 方法perpendicular_through接收一个点作为参数，并返回一条新直线，该直线使用该基准点和与原始直线垂直的方向向量。类似地，parallel_through构造一条新的直线，该直线具有给定的基准点，但使用与原始直线相同的方向向量。
- en: '***Line Intersections***'
  id: totrans-270
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***直线交点***'
- en: A general algorithm to compute the intersection between two segments was explained
    in depth earlier in the chapter. The algorithm was based on the start point and
    direction vector of segments but can be extended to work with lines by using the
    base point of the line instead of the start point of the segment. The nice thing
    is that in the case of lines, parameters *t*[1] and *t*[2] are not bounded to
    range [0, 1]; they can go from *– ∞* to *∞*.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 本章早些时候已详细解释了计算两条线段交点的一般算法。该算法基于线段的起点和方向向量，但可以通过使用直线的基准点而不是线段的起点，扩展为适用于直线。值得注意的是，在直线的情况下，参数*t*[1]和*t*[2]不再局限于[0,
    1]范围；它们可以从*– ∞*到*∞*。
- en: If we rewrite [Equations 5.7](ch05.xhtml#ch05eqa07) and [5.8](ch05.xhtml#ch05eqa08)
    for lines, we get [Equations 5.9](ch05.xhtml#ch05eqa09) and [5.10](ch05.xhtml#ch05eqa10).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将[方程 5.7](ch05.xhtml#ch05eqa07)和[5.8](ch05.xhtml#ch05eqa08)重写为直线方程，我们得到[方程
    5.9](ch05.xhtml#ch05eqa09)和[5.10](ch05.xhtml#ch05eqa10)。
- en: '![Image](../images/05eqa09.jpg)![Image](../images/05eqa10.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/05eqa09.jpg)![Image](../images/05eqa10.jpg)'
- en: 'In this case, Δ*B*[*x*] = *B*[2*x*] *– B*[1*x*], and Δ*B*[*y*] = *B*[2*y*]
    *– B*[1*y*]. For these formulas to yield the correct values, recall that ![Image](../images/f00119-p1.jpg).
    Since the *t* values are not bounded anymore, there’s no need to compute both
    *t*[1] and *t*[2] and check whether they fall into the range [0, 1]. Computing
    one of them will suffice in getting the resulting intersection point. Let’s choose
    [Equation 5.9](ch05.xhtml#ch05eqa09) to compute *t*[1]. With *t*[1], we can determine
    the actual intersection point as follows:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，Δ*B*[*x*] = *B*[2*x*] *– B*[1*x*]，Δ*B*[*y*] = *B*[2*y*] *– B*[1*y*]。为了使这些公式得出正确的值，请回忆一下![Image](../images/f00119-p1.jpg)。由于*t*值不再受限制，因此无需计算*t*[1]和*t*[2]并检查它们是否落在[0,
    1]范围内。计算其中一个值就足以得到交点。让我们选择[方程 5.9](ch05.xhtml#ch05eqa09)来计算*t*[1]。有了*t*[1]，我们可以按如下方式确定实际的交点：
- en: '![Image](../images/f00126-p1.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f00126-p1.jpg)'
- en: Implement method intersection_with in your Line class as in [Listing 5-25](ch05.xhtml#ch5lis25).
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的Line类中实现intersection_with方法，如[示例 5-25](ch05.xhtml#ch5lis25)所示。
- en: '[PRE40]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '*Listing 5-25: Calculating the intersection between two lines*'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 5-25：计算两条直线的交点*'
- en: The code looks similar to the algorithm in Segment, but it’s a bit simpler.
    To check for parallelism, we use the self method instead of using the directions.
    As we implemented is_parallel_to on the Line class, it makes sense to use it (and
    it helps the code read even better!).
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 代码与 Segment 中的算法类似，但更简单一些。为了检查平行性，我们使用 self 方法，而不是使用方向。由于我们在 Line 类中实现了 is_parallel_to
    方法，使用它更合适（并且使代码更加易读！）。
- en: '**Unit Testing Line Intersections**'
  id: totrans-280
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**单元测试线段交点**'
- en: Let’s make sure our tweaked algorithm works. Create a new file *line_test.py*
    and enter the test for the Line class in [Listing 5-26](ch05.xhtml#ch5lis26).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们确保我们修改后的算法有效。创建一个新的文件 *line_test.py* 并输入 [列表 5-26](ch05.xhtml#ch5lis26) 中的
    Line 类测试代码。
- en: '[PRE41]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '*Listing 5-26: Testing line intersections*'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-26：测试线段交点*'
- en: In the first test, test_parallel_lines_no_intersection, we create two parallel
    lines with different base points but the same direction vectors. We then assert
    intersection_with returns None. The second test, test_lines_intersection, creates
    two lines, the first of which is vertical at *x* = 50 and the second horizontal
    at *y* = 30; hence, the intersection point is (50, 30).
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个测试中，test_parallel_lines_no_intersection，我们创建了两条平行线，它们有不同的基点，但方向向量相同。然后我们断言
    intersection_with 返回 None。第二个测试 test_lines_intersection，创建了两条线，第一条在 *x* = 50 处垂直，第二条在
    *y* = 30 处水平；因此，它们的交点是 (50, 30)。
- en: 'Run the tests by clicking the green play button beside the class definition.
    You should see this in the console:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击类定义旁边的绿色播放按钮来运行测试。你应该在控制台中看到如下内容：
- en: '[PRE42]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'You can also run the tests from the console:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过控制台运行测试：
- en: '[PRE43]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[Listing 5-27](ch05.xhtml#ch5lis27) contains all the code we wrote for the
    Line class.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5-27](ch05.xhtml#ch5lis27) 包含了我们为 Line 类编写的所有代码。'
- en: '[PRE44]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '*Listing 5-27: The Line class*'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-27：Line 类*'
- en: '**Segment’s Bisector**'
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Segment 的平分线**'
- en: 'Now that we have both segments and lines, we can implement a new attribute
    in Segment: its *bisector*. This attribute is the line going through the segment’s
    middle point *M* that’s perpendicular to it. [Figure 5-11](ch05.xhtml#ch5fig11)
    illustrates this concept.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了 Segment 和 Line，我们可以在 Segment 中实现一个新的属性：它的 *平分线*。这个属性是穿过 Segment 中点 *M*
    且与之垂直的线。[图 5-11](ch05.xhtml#ch5fig11) 展示了这一概念。
- en: '![Image](../images/05fig11.jpg)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/05fig11.jpg)'
- en: '*Figure 5-11: A segment’s bisector*'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-11：Segment 的平分线*'
- en: Computing a bisector line for a segment is simple since we already have access
    to the segment’s middle point and normal versor (don’t forget to import the Line
    class), as shown in [Listing 5-28](ch05.xhtml#ch5lis28).
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 计算 Segment 的平分线很简单，因为我们已经可以访问到 Segment 的中点和法向量（别忘了导入 Line 类），如 [列表 5-28](ch05.xhtml#ch5lis28)
    所示。
- en: '[PRE45]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '*Listing 5-28: Segment’s bisector*'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-28：Segment 的平分线*'
- en: In the next chapter, we’ll be using the bisectors of segments to create a circle
    passing through three points—a common way of obtaining circles in CAD software.
    In [Part III](part03.xhtml#part03) of the book, we’ll create a program that computes
    a circle passing through three points and draws a beautiful image with captions
    indicating its center and radius.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将使用 Segment 的平分线来创建一个通过三点的圆——这是 CAD 软件中常用的一种求圆方法。在本书的[第三部分](part03.xhtml#part03)，我们将创建一个程序，计算通过三点的圆并绘制一个美丽的图像，图中会标注圆心和半径。
- en: '**Summary**'
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: 'In this chapter, we used the Point and Vector classes to create two new primitives:
    Segment and Line. Both have a defined direction, and both represent a set of infinite
    aligned points, but segments are bounded between two points, whereas lines have
    no ends.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用了 Point 和 Vector 类来创建两个新的原始类型：Segment 和 Line。它们都有一个定义好的方向，且都表示一组无限对齐的点，但
    Segment 是在两个点之间有限制的，而 Line 没有尽头。
- en: We also implemented a way of obtaining the infinite points in Segment using
    a parameter *t* that is defined in the range [0, 1]. There was no need to do the
    same for Line, as we’re not usually interested in what points make it up.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还实现了一种方法，通过一个参数 *t* 来获取 Segment 中的无限点，*t* 的取值范围为 [0, 1]。对 Line 来说没有必要做相同的操作，因为我们通常不关心构成它的点。
- en: 'We then created two algorithms: we included a method in the Segment class that
    looks for its closest point to an external point. Although we didn’t implement
    it in Line, we could have done so. We used this method to compute the distance
    from a point to a segment. We also implemented an algorithm to compute intersections
    between two segments and two lines. These intersections result in a point or the
    value None returned. Lastly, we used the Line class to represent the bisector
    of a segment.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建了两个算法：我们在 Segment 类中添加了一个方法，用于查找其与外部点的最近点。尽管我们没有在 Line 类中实现该方法，但我们本来可以实现它。我们利用这个方法来计算点到线段的距离。我们还实现了一个算法，用于计算两个线段和两条直线的交点。这些交点的结果是一个点，或者返回值为
    None。最后，我们使用 Line 类表示线段的平分线。
- en: These linear primitives are going to prove invaluable for building more complex
    ones called polygons, the topic of our next chapter.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这些线性原语对于构建更复杂的几何图形——多边形，将证明是无价的，这也是我们下一章的主题。
