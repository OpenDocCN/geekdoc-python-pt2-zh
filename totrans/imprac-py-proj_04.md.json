["```py\n>>> list_of_lists = [['16', '12', '8', '4', '0'], ['1', '5', '9', '13', '17'],\n['18', '14', '10', '6', '2'], ['3', '7', '11', '15', '19']]\n```", "```py\n>>> for nested_list in list_of_lists\n        print(nested_list)\n[16, 12, 8, 4, 0]\n[1, 5, 9, 13, 17]\n[18, 14, 10, 6, 2]\n[3, 7, 11, 15, 19]\n```", "```py\n[16, 12, 8, 4, 0]\n[17, 13, 9, 5, 1]\n[18, 14, 10, 6, 2]\n[19, 15, 11, 7, 3]\n```", "```py\n'0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19'\n```", "```py\nLoad the ciphertext string.\nConvert ciphertext into a cipherlist to split out individual words.\nGet input for the number of columns and rows.\nGet input for the key.\nConvert key into a list to split out individual numbers.\nCreate a new list for the translation matrix.\nFor every number in the key:\n    Create a new list and append every n items (n = # of rows) from the cipherlist.\n    Use the sign of key number to decide whether to read the row forward or backward.\n    Using the chosen direction, add the new list to the matrix. The index of each\n    new list is based on the column number used in the key.\nCreate a new string to hold translation results.\nFor range of rows:\n    For the nested list in translation matrix:\n          Remove the last word in nested list\n          Add the word to the translation string.\nPrint the translation string.\n```", "```py\n➊ ciphertext = \"16 12 8 4 0 1 5 9 13 17 18 14 10 6 2 3 7 11 15 19\"\n\n   # split elements into words, not letters\n\n➋ cipherlist = list(ciphertext.split())\n\n➌ # initialize variables\n\n   COLS = 4\n\n   ROWS = 5\n\n   key = '-1 2 -3 4'  # neg number means read UP column vs. DOWN\n\n   translation_matrix = [None] * COLS\n\n   plaintext = ''\n\n   start = 0\n\n   stop = ROWS\n\n   # turn key_int into list of integers:\n\n➍ key_int = [int(i) for i in key.split()]\n\n   # turn columns into items in list of lists:\n\n➎ for k in key_int:\n\n    ➏ if k < 0:  # reading bottom-to-top of column\n\n           col_items = cipherlist[start:stop]\n\n       elif k > 0:  # reading top-to-bottom of columnn\n\n           col_items = list((reversed(cipherlist[start:stop])))\n\n       translation_matrix[abs(k) - 1] = col_items\n\n       start += ROWS\n\n       stop += ROWS\n\n   print(\"\\nciphertext = {}\".format(ciphertext))\n\n   print(\"\\ntranslation matrix =\", *translation_matrix, sep=\"\\n\")\n\n   print(\"\\nkey length = {}\".format(len(key_int)))\n\n   # loop through nested lists popping off last item to new list:\n\n➐ for i in range(ROWS):\n\n       for col_items in translation_matrix:\n\n        ➑ word = str(col_items.pop())\n\n        ➒ plaintext += word + ' '\n\n   print(\"\\nplaintext = {}\".format(plaintext))\n```", "```py\nplaintext = 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19\n```", "```py\n➊ \"\"\"Decrypt a path through a Union Route Cipher.\n\n➋ Designed for whole-word transposition ciphers with variable rows & columns.\n   Assumes encryption began at either top or bottom of a column.\n   Key indicates the order to read columns and the direction to traverse.\n   Negative column numbers mean start at bottom and read up.\n   Positive column numbers mean start at top & read down.\n\n   Example below is for 4x4 matrix with key -1 2 -3 4.\n   Note \"0\" is not allowed.\n   Arrows show encryption route; for negative key values read UP.\n\n     1   2   3   4\n\n    ___ ___ ___ ___\n   | ^ | | | ^ | | | MESSAGE IS WRITTEN\n   |_|_|_v_|_|_|_v_|\n   | ^ | | | ^ | | | ACROSS EACH ROW\n   |_|_|_v_|_|_|_v_|\n   | ^ | | | ^ | | | IN THIS MANNER\n   |_|_|_v_|_|_|_v_|\n   | ^ | | | ^ | | | LAST ROW IS FILLED WITH DUMMY WORDS\n   |_|_|_v_|_|_|_v_|\n   START        END\n\n   Required inputs - a text message, # of columns, # of rows, key string\n\n   Prints translated plaintext\n   \"\"\"\n➌ import sys\n\n   #==============================================================================\n➍ # USER INPUT:\n\n➎ # the string to be decrypted (type or paste between triple-quotes):\n   ciphertext = \"\"\"16 12 8 4 0 1 5 9 13 17 18 14 10 6 2 3 7 11 15 19\n   \"\"\"\n\n➏ # number of columns in the transposition matrix:\n   COLS = 4\n\n   # number of rows in the transposition matrix:\n   ROWS = 5\n\n➐ # key with spaces between numbers; negative to read UP column (ex = -1 2 -3 4):\n   key = \"\"\" -1 2 -3 4 \"\"\"\n\n➑ # END OF USER INPUT - DO NOT EDIT BELOW THIS LINE!\n   #==============================================================================\n\n➒ ________________________________________________________________________________\n```", "```py\ndef main():\n    \"\"\"Run program and print decrypted plaintext.\"\"\"\n ➊ print(\"\\nCiphertext = {}\".format(ciphertext))\n    print(\"Trying {} columns\".format(COLS))\n    print(\"Trying {} rows\".format(ROWS))\n    print(\"Trying key = {}\".format(key))\n\n    # split elements into words, not letters\n ➋ cipherlist = list(ciphertext.split())\n ➌ validate_col_row(cipherlist)\n ➍ key_int = key_to_int(key)\n ➎ translation_matrix = build_matrix(key_int, cipherlist)\n ➏ plaintext = decrypt(translation_matrix)\n\n ➐ print(\"Plaintext = {}\".format(plaintext))\n```", "```py\n➊ def validate_col_row(cipherlist):\n       \"\"\"Check that input columns & rows are valid vs. message length.\"\"\"\n       factors = []\n       len_cipher = len(cipherlist)\n    ➋ for i in range(2, len_cipher):  # range excludes 1-column ciphers\n           if len_cipher % i == 0:\n               factors.append(i)\n    ➌ print(\"\\nLength of cipher = {}\".format(len_cipher))\n       print(\"Acceptable column/row values include: {}\".format(factors))\n       print()\n    ➍ if ROWS * COLS != len_cipher:\n           print(\"\\nError - Input columns & rows not factors of length \"\n                 \"of cipher. Terminating program.\", file=sys.stderr)\n           sys.exit(1)\n\n➎ def key_to_int(key):\n       \"\"\"Turn key into list of integers & check validity.\"\"\"\n    ➏ key_int = [int(i) for i in key.split()]\n       key_int_lo = min(key_int)\n       key_int_hi = max(key_int)\n    ➐ if len(key_int) != COLS or key_int_lo < -COLS or key_int_hi > COLS \\\n           or 0 in key_int:\n        ➑ print(\"\\nError - Problem with key. Terminating.\", file=sys.stderr)\n           sys.exit(1)\n       else:\n        ➒ return key_int\n```", "```py\n➊ def build_matrix(key_int, cipherlist):\n       \"\"\"Turn every n items in a list into a new item in a list of lists.\"\"\"\n       translation_matrix = [None] * COLS\n       start = 0\n       stop = ROWS\n       for k in key_int:\n           if k < 0:  # read bottom-to-top of column\n               col_items = cipherlist[start:stop]\n           elif k > 0:  # read top-to-bottom of columnn\n               col_items = list((reversed(cipherlist[start:stop])))\n           translation_matrix[abs(k) - 1] = col_items\n           start += ROWS\n           stop += ROWS\n       return translation_matrix\n\n➋ def decrypt(translation_matrix):\n       \"\"\"Loop through nested lists popping off last item to a string.\"\"\"\n       plaintext = ''\n       for i in range(ROWS):\n           for matrix_col in translation_matrix:\n               word = str(matrix_col.pop())\n               plaintext += word + ' '\n       return plaintext\n\n➌ if __name__ == '__main__':\n       main()\n```", "```py\nCiphertext = 16 12 8 4 0 1 5 9 13 17 18 14 10 6 2 3 7 11 15 19\n\nTrying 4 columns\nTrying 5 rows\nTrying key = -1 2 -3 4\n\nLength of cipher = 20\nAcceptable column/row values include: [2, 4, 5, 10]\n\nPlaintext = 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19\n```", "```py\n➊ r\"\"\"Encrypt a Civil War 'rail fence' type cipher.\n\n   This is for a \"2-rail\" fence cipher for short messages.\n\n   Example text to encrypt:  'Buy more Maine potatoes'\n\n   Rail fence style:  B Y O E A N P T T E\n                       U M R M I E O A O S\n\n   Read zigzag:       \\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\n\n   Encrypted:  BYOEA NPTTE UMRMI EOSOS\n\n   \"\"\"\n   #------------------------------------------------------------------------------\n➋ # USER INPUT:\n\n   # the string to be encrypted (paste between quotes):\n➌ plaintext = \"\"\"Let us cross over the river and rest under the shade of the trees\n   \"\"\"\n\n➍ # END OF USER INPUT - DO NOT EDIT BELOW THIS LINE!\n   #------------------------------------------------------------------------------\n```", "```py\n➊ def main():\n       \"\"\"Run program to encrypt message using 2-rail rail fence cipher.\"\"\"\n       message = prep_plaintext(plaintext)\n       rails = build_rails(message)\n       encrypt(rails)\n\n➋ def prep_plaintext(plaintext):\n       \"\"\"Remove spaces & leading/trailing whitespace.\"\"\"\n    ➌ message = \"\".join(plaintext.split())\n    ➍ message = message.upper()  # convention for ciphertext is uppercase\n       print(\"\\nplaintext = {}\".format(plaintext))\n       return message\n\n➎ def build_rails(message):\n       \"\"\"Build strings with every other letter in a message.\"\"\"\n       evens = message[::2]\n       odds = message[1::2]\n    ➏ rails = evens + odds\n       return rails\n\n➐ def encrypt(rails):\n       \"\"\"Split letters in ciphertext into chunks of 5 & join to make string.\"\"\"\n    ➑ ciphertext = ' '.join([rails[i:i+5] for i in range(0, len(rails), 5)])\n       print(\"ciphertext = {}\".format(ciphertext))\n\n➒ if __name__ == '__main__':\n       main()\n```", "```py\nplaintext = Let us cross over the river and rest under the shade of the trees\nciphertext = LTSRS OETEI EADET NETEH DOTER EEUCO SVRHR VRNRS UDRHS AEFHT ES\n```", "```py\n   r\"\"\"Decrypt a Civil War 'rail fence' type cipher.\n\n   This is for a 2-rail fence cipher for short messages.\n\n   Example plaintext:  'Buy more Maine potatoes'\n\n   Rail fence style:  B Y O E A N P T T E\n                       U M R M I E O A O S\n\n   Read zigzag:       \\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\n\n   Ciphertext:  BYOEA NPTTE UMRMI EOSOS\n\n   \"\"\"\n➊ import math\n   import itertools\n\n   #------------------------------------------------------------------------------\n   # USER INPUT:\n\n   # the string to be decrypted (paste between quotes):\n➋ ciphertext = \"\"\"LTSRS OETEI EADET NETEH DOTER EEUCO SVRHR VRNRS UDRHS AEFHT ES\n\n   \"\"\"\n\n   # END OF USER INPUT - DO NOT EDIT BELOW THIS LINE!\n   #------------------------------------------------------------------------------\n```", "```py\n➊ def main():\n\n       \"\"\"Run program to decrypt 2-rail rail fence cipher.\"\"\"\n\n       message = prep_ciphertext(ciphertext)\n\n       row1, row2 = split_rails(message)\n\n       decrypt(row1, row2)\n\n➋ def prep_ciphertext(ciphertext):\n\n       \"\"\"Remove whitespace.\"\"\"\n\n       message = \"\".join(ciphertext.split())\n\n       print(\"\\nciphertext = {}\".format(ciphertext))\n\n       return message\n\n➌ def split_rails(message):\n\n       \"\"\"Split message in two, always rounding UP for 1st row.\"\"\"\n\n    ➍ row_1_len = math.ceil(len(message)/2)\n\n    ➎ row1 = (message[:row_1_len]).lower()\n\n       row2 = (message[row_1_len:]).lower()\n\n       return row1, row2\n\n➏ def decrypt(row1, row2):\n\n       \"\"\"Build list with every other letter in 2 strings & print.\"\"\"\n\n    ➐ plaintext = []\n\n    ➑ for r1, r2 in itertools.zip_longest(row1, row2):\n\n           plaintext.append(r1)\n\n           plaintext.append(r2)\n\n    ➒ if None in plaintext:\n\n           plaintext.pop()\n\n       print(\"rail 1 = {}\".format(row1))\n\n       print(\"rail 2 = {}\".format(row2))\n\n       print(\"\\nplaintext = {}\".format(''.join(plaintext)))\n\n➓ if __name__ == '__main__':\n\n       main()\n```", "```py\nciphertext = LTSRS OETEI EADET NETEH DOTER EEUCO SVRHR VRNRS UDRHS AEFHT ES\n\nrail 1 = LTSRSOETEIEADETNETEHDOTERE\nrail 2 = EUCOSVRHRVRNRSUDRHSAEFHTES\n\nplaintext = letuscrossovertheriverandrestundertheshadeofthetrees\n```", "```py\nusing key = [-4, -1, -2, -3]\ntranslated = IS HEADING FILLER VILLAGE YOUR SNOW SOUTH GODWIN ARE FREE TO YOU\nWITH SUPPLIES GONE TRANSPORT ROANOKE JUST TO REST\n\nusing key = [1, 2, -3, 4]\ntranslated = REST ROANOKE HEADING TO TRANSPORT WITH SNOW GONE YOU ARE FREE TO\nGODWIN YOUR SUPPLIES SOUTH VILLAGE IS JUST FILLER\n\nusing key = [-1, 2, -3, 4]\ntranslated = VILLAGE ROANOKE HEADING TO GODWIN WITH SNOW GONE YOU ARE FREE TO\nTRANSPORT YOUR SUPPLIES SOUTH REST IS JUST FILLER\n\nusing key = [4, -1, 2, -3]\ntranslated = IS JUST FILLER REST YOUR SUPPLIES SOUTH TRANSPORT ARE FREE TO YOU\nWITH SNOW GONE GODWIN ROANOKE HEADING TO VILLAGE\n```"]