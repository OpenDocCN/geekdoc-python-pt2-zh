- en: '[3](nsp-venkitachalam503045-0008.xhtml#rch03)'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[3](nsp-venkitachalam503045-0008.xhtml#rch03)'
- en: Conway’s Game of Life
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 康威的生命游戏
- en: '![](images/nsp-venkitachalam503045-circle-image.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-circle-image.jpg)'
- en: You can use a computer to study a system by creating a mathematical model for
    that system, writing a program to represent the model, and then letting the model
    evolve over time. There are many kinds of computer simulations, but I’ll focus
    on a famous one called Conway’s Game of Life, the work of the British mathematician
    John Conway. The Game of Life is an example of a *cellular automaton*, a collection
    of colored cells on a grid that evolve through a number of time steps according
    to a set of rules defining the states of neighboring cells.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过创建该系统的数学模型、编写程序来表示该模型，然后让模型随时间演变，从而用计算机来研究一个系统。计算机仿真有许多种类型，但我将重点介绍一个著名的仿真——康威的生命游戏，这是英国数学家约翰·康威的作品。生命游戏是一个*元胞自动机*的例子，它是一个由网格上的彩色单元格组成的集合，这些单元格通过一组定义相邻单元格状态的规则，在多个时间步骤中演化。
- en: In this project, you’ll create an *N*×*N* grid of cells and simulate the evolution
    of the system over time by applying the rules of Conway’s Game of Life. You’ll
    display the state of the game at each time step and provide ways to save the output
    to a file. You’ll set the initial condition of the system to either a random distribution
    or a predesigned pattern.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将创建一个*N*×*N*的单元格网格，并通过应用康威生命游戏的规则模拟系统随时间演变的过程。你将展示每个时间步骤中的游戏状态，并提供将输出保存到文件的方法。你将设置系统的初始条件，可以选择随机分布或预设计的模式。
- en: 'This simulation consists of the following components:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 该仿真由以下组件组成：
- en: • A property defined in one- or two-dimensional space
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 在一维或二维空间中定义的属性
- en: • A mathematical rule to change this property for each step in the simulation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 一个数学规则，用于在仿真的每个步骤中改变这个属性
- en: • A way to display or capture the state of the system as it evolves
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 一种展示或捕捉系统状态随时间演变的方法
- en: The cells in Conway’s Game of Life can be either ON or OFF. The game starts
    with an initial condition, in which each cell is assigned one of these states.
    Then, mathematical rules determine how each cell’s state will change over time.
    The amazing thing about Conway’s Game of Life is that with just four simple rules
    the system evolves to produce patterns that behave in incredibly complex ways,
    almost as if they were alive. Patterns include “gliders” that slide across the
    grid, “blinkers” that flash on and off, and even replicating patterns.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 康威生命游戏中的单元格可以是开（ON）或关（OFF）。游戏从一个初始条件开始，每个单元格被分配其中一种状态。然后，数学规则决定每个单元格的状态如何随着时间变化。康威生命游戏的神奇之处在于，仅凭四个简单的规则，系统就能演化出表现得极其复杂的模式，几乎像是活的一样。模式包括“滑行者”（gliders），它们会在网格上滑动，“闪烁者”（blinkers），它们会闪烁开关，甚至是自我复制的模式。
- en: Of course, the philosophical implications of this game are also significant
    because they suggest that complex structures can evolve from simple rules without
    following any sort of preset pattern.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个游戏的哲学含义也很深远，因为它表明复杂的结构可以通过简单的规则演化出来，而无需遵循任何预设的模式。
- en: 'Here are some of the main concepts covered in this project:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本项目涵盖的一些主要概念：
- en: • Using `matplotlib imshow` to represent a 2D grid of data
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用`matplotlib imshow`表示二维数据网格
- en: • Using `matplotlib` for animation
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用`matplotlib`进行动画制作
- en: • Using the `numpy` array
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用`numpy`数组
- en: • Using the `%` operator for boundary conditions
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用`%`操作符处理边界条件
- en: • Setting up a random distribution of values
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 设置随机分布的值
- en: '[How It Works](nsp-venkitachalam503045-0008.xhtml#rah0501)'
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[它是如何工作的](nsp-venkitachalam503045-0008.xhtml#rah0501)'
- en: Because the Game of Life is built on a grid of nine squares, every cell has
    eight neighboring cells, as shown in [Figure 3-1](nsp-venkitachalam503045-0015.xhtml#fig3-1).
    A given cell (*i*, *j*) in the simulation is accessed on a grid [*i*][*j*], where
    *i* and *j* are the row and column indices, respectively. The value of a given
    cell at a given instant of time depends on the state of its neighbors at the previous
    time step.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 因为生命游戏建立在一个由九个方格组成的网格上，所以每个单元格有八个相邻单元格，如[图3-1](nsp-venkitachalam503045-0015.xhtml#fig3-1)所示。仿真中的某个单元格（*i*，*j*）通过网格[*i*][*j*]进行访问，其中*i*和*j*分别是行和列的索引。某个单元格在特定时间点的值取决于它在前一个时间步骤时相邻单元格的状态。
- en: '![](images/nsp-venkitachalam503045-f03001.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f03001.jpg)'
- en: 'Figure 3-1: A central cell (*i*, *j*) with eight neighboring cells'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-1：一个中心单元格（*i*，*j*）与八个相邻单元格
- en: 'Conway’s Game of Life has four rules:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 康威的生命游戏有四个规则：
- en: 1\. If a cell is ON and has fewer than two neighbors that are ON, it turns OFF.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1. 如果一个单元格为 ON 并且有少于两个邻居为 ON，它将变为 OFF。
- en: 2\. If a cell is ON and has either two or three neighbors that are ON, it remains
    ON.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2. 如果一个单元格为 ON 并且有两个或三个邻居为 ON，它将保持 ON。
- en: 3\. If a cell is ON and has more than three neighbors that are ON, it turns OFF.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3. 如果一个单元格为 ON 并且有超过三个邻居为 ON，它将变为 OFF。
- en: 4\. If a cell is OFF and has exactly three neighbors that are ON, it turns ON.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 4. 如果一个单元格为 OFF 并且恰好有三个邻居为 ON，它将变为 ON。
- en: 'These rules are meant to mirror some basic ways that a group of organisms might
    fare over time: underpopulation and overpopulation kill cells by turning a cell
    OFF when it has fewer than two neighbors or more than three, but when the population
    is balanced, cells stay ON and reproduce by turning another cell from OFF to ON.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规则旨在模拟群体生物随时间变化的基本方式：人口过少和过多通过当单元格少于两个邻居或超过三个邻居时使其变为 OFF 来杀死单元格，但当人口平衡时，单元格保持
    ON 并通过将另一个单元格从 OFF 转变为 ON 来繁殖。
- en: I said that each cell has eight neighboring cells, but what about cells at the
    edge of the grid? Which cells are their neighbors? To answer this question, you
    need to think about *boundary conditions*, the rules that govern what happens
    to cells at the edges or boundaries of the grid. I’ll address this question by
    using *toroidal boundary conditions*, meaning that the square grid wraps around
    as if its shape were a torus. As shown in [Figure 3-2](nsp-venkitachalam503045-0015.xhtml#fig3-2),
    the grid is first warped so that its horizontal edges (A and B) join to form a
    cylinder, and then the cylinder’s vertical edges (C and D) are joined to form
    a torus. Once the torus has been formed, all cells have neighbors because the
    whole space has no edge.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到每个单元格有八个邻居，但网格边缘的单元格呢？它们的邻居是谁？为了回答这个问题，你需要考虑 *边界条件*，即控制网格边缘或边界单元格行为的规则。我将通过使用
    *环形边界条件* 来解决这个问题，这意味着方形网格将像圆环一样环绕。正如[图 3-2](nsp-venkitachalam503045-0015.xhtml#fig3-2)所示，网格首先被扭曲，使其水平边缘（A
    和 B）连接形成一个圆柱体，然后圆柱体的垂直边缘（C 和 D）连接形成一个环形。形成环形后，所有单元格都有邻居，因为整个空间没有边界。
- en: '![](images/nsp-venkitachalam503045-f03002.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f03002.jpg)'
- en: 'Figure 3-2: A conceptual visualization of toroidal boundary conditions'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-2：环形边界条件的概念性可视化
- en: 'Toroidal boundary conditions are common in 2D simulations and games. For example,
    the game *Pac-Man* uses them. If you go off the top of the screen, you reappear
    on the bottom. If you go off the left side of the screen, you reappear on the
    right side. You’ll follow the same logic for the Game of Life simulation: for
    the cell in the top-left corner of the grid, for example, the neighbor directly
    above it will be the cell in the bottom-left corner, and the neighbor directly
    to the left of it will be in the cell in the top-right corner.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 环形边界条件在二维仿真和游戏中很常见。例如，游戏 *吃豆人* 就使用了这种条件。如果你从屏幕顶部离开，你会出现在屏幕底部。如果你从屏幕的左边离开，你会出现在右边。你将在“生命游戏”仿真中遵循相同的逻辑：例如，对于网格左上角的单元格，直接在其上方的邻居将是左下角的单元格，而直接在其左侧的邻居将是右上角的单元格。
- en: 'Here’s a description of the algorithm you’ll use to apply the four rules and
    run the simulation:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是你将用来应用四条规则并运行仿真算法的描述：
- en: 1\. Initialize the cells in the grid.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1. 初始化网格中的单元格。
- en: '2\. At each time step in the simulation, for each cell (*i*, *j*) in the grid,
    do the following:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2. 在仿真的每个时间步中，对于网格中的每个单元格（*i*, *j*），执行以下操作：
- en: a. Update the value of cell (*i*, *j*) based on its neighbors, taking into account
    the boundary conditions.
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: a. 根据邻居的状态更新单元格（*i*, *j*）的值，同时考虑边界条件。
- en: b. Update the display of grid values.
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: b. 更新网格值的显示。
- en: '[Requirements](nsp-venkitachalam503045-0008.xhtml#rah0502)'
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[需求](nsp-venkitachalam503045-0008.xhtml#rah0502)'
- en: You’ll use `numpy` arrays and the `matplotlib` library to display the simulation
    output, and you’ll use the `matplotlib` `animation` module to update the simulation.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用 `numpy` 数组和 `matplotlib` 库来显示仿真输出，并使用 `matplotlib` 的 `animation` 模块来更新仿真。
- en: '[The Code](nsp-venkitachalam503045-0008.xhtml#rah0503)'
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[代码](nsp-venkitachalam503045-0008.xhtml#rah0503)'
- en: We’ll examine key aspects of the program piece by piece, including how to represent
    the simulation grid using `numpy` and `matplotlib`, how to set the initial conditions
    for the simulation, how to account for toroidal boundary conditions, and how to
    implement the Game of Life rules. We’ll also look at the program’s `main()` function,
    which sends command line arguments to the program and sets the simulation into
    motion. To see the full project code, skip ahead to [“The Complete Code”](nsp-venkitachalam503045-0015.xhtml#ah0507)
    on [page 56](nsp-venkitachalam503045-0015.xhtml#p56). You can also download the
    code from [https://github.com/mkvenkit/pp2e/tree/main/conway](https://github.com/mkvenkit/pp2e/tree/main/conway).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐步检查程序的关键方面，包括如何使用 `numpy` 和 `matplotlib` 表示模拟网格，如何设置模拟的初始条件，如何考虑环形边界条件，以及如何实现“生命游戏”规则。我们还将查看程序的
    `main()` 函数，它将命令行参数传递给程序并启动模拟。要查看完整的项目代码，请跳到[“完整代码”](nsp-venkitachalam503045-0015.xhtml#ah0507)，该部分位于[第56页](nsp-venkitachalam503045-0015.xhtml#p56)。你还可以从[https://github.com/mkvenkit/pp2e/tree/main/conway](https://github.com/mkvenkit/pp2e/tree/main/conway)下载代码。
- en: '[Representing the Grid](nsp-venkitachalam503045-0008.xhtml#rbh0501)'
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[表示网格](nsp-venkitachalam503045-0008.xhtml#rbh0501)'
- en: 'To represent whether a cell is alive (ON) or dead (OFF) on the grid, you’ll
    use the values `255` and `0` for ON and OFF, respectively. You’ll display the
    current state of the grid using the `imshow()` method in `matplotlib`, which represents
    a matrix of numbers as an image. To get a feel for how it works, let’s try a simple
    example inside the Python interpreter. Enter the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了表示网格上一个单元格是活着（开）还是死了（关），你将使用 `255` 和 `0` 来分别表示开和关。你将使用 `matplotlib` 中的 `imshow()`
    方法来显示当前网格的状态，该方法将一个数字矩阵表示为图像。为了更好地理解它是如何工作的，让我们在 Python 解释器中尝试一个简单的例子。输入以下内容：
- en: '>>> `import numpy as np`'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> `import numpy as np`'
- en: '>>> `import matplotlib.pyplot as plt`'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> `import matplotlib.pyplot as plt`'
- en: ❶ >>> `x = np.array([[0, 0, 255], [255, 255, 0], [0, 255, 0]])`
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ >>> `x = np.array([[0, 0, 255], [255, 255, 0], [0, 255, 0]])`
- en: ❷ >>> `plt.imshow(x, interpolation='nearest')`
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ >>> `plt.imshow(x, interpolation='nearest')`
- en: '>>> `plt.show()`'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> `plt.show()`'
- en: You define a 2D `numpy` array of shape (3, 3) ❶, meaning the array has three
    rows and three columns. Each element of the array is an integer value. You then
    use the `plt.imshow()` method to display this matrix of values as an image ❷,
    passing in the interpolation option as `'nearest'` to get sharp edges for the
    cells (otherwise, they’d be fuzzy). [Figure 3-3](nsp-venkitachalam503045-0015.xhtml#fig3-3)
    shows the output of this code.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你定义了一个形状为 (3, 3) 的二维 `numpy` 数组 ❶，意味着数组有三行三列。数组的每个元素都是整数值。然后，你使用 `plt.imshow()`
    方法将这个数值矩阵作为图像显示 ❷，并将插值选项设置为 `'nearest'`，以确保单元格的边缘清晰（否则它们会模糊）。[图 3-3](nsp-venkitachalam503045-0015.xhtml#fig3-3)
    显示了此代码的输出。
- en: '![](images/nsp-venkitachalam503045-f03003.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f03003.jpg)'
- en: 'Figure 3-3: Displaying a grid of values'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-3：显示值的网格
- en: Notice that squares with a value of `0` (OFF) are given a darker color, while
    squares with a value of `255` (ON) are given a lighter color.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，值为 `0`（关）的方格显示为较深的颜色，而值为 `255`（开）的方格显示为较浅的颜色。
- en: '[Setting the Initial Conditions](nsp-venkitachalam503045-0008.xhtml#rbh0502)'
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[设置初始条件](nsp-venkitachalam503045-0008.xhtml#rbh0502)'
- en: To begin the simulation, set an initial state for each cell in the 2D grid.
    You can use a random distribution of ON and OFF cells and see what kinds of patterns
    emerge, or you can add some specific patterns and see how they evolve. We’ll look
    at both approaches.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始模拟，首先为二维网格中的每个单元格设置初始状态。你可以使用随机分布的开和关单元格，看看会出现什么样的模式，或者你可以添加一些特定的模式并观察它们如何发展。我们将同时查看这两种方法。
- en: 'For a random initial state, use the `choice()` method from the `random` module
    in `numpy`. Enter the following in the Python interpreter to see how it works:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对于随机初始状态，使用 `numpy` 中 `random` 模块的 `choice()` 方法。在 Python 解释器中输入以下内容，看看它是如何工作的：
- en: '>>> `np.random.choice([0, 255], 4*4, p=[0.1, 0.9]).reshape(4, 4)`'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> `np.random.choice([0, 255], 4*4, p=[0.1, 0.9]).reshape(4, 4)`'
- en: 'The output will be something like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将类似于以下内容：
- en: array([[255, 255, 255, 255],
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: array([[255, 255, 255, 255],
- en: '[255, 255, 255, 255],'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '[255, 255, 255, 255],'
- en: '[255, 255, 255, 255],'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[255, 255, 255, 255],'
- en: '[255, 255, 255, 0]])'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '[255, 255, 255, 0]])'
- en: '`np.random.choice()` chooses a value from the given list `[0, 255]`, with the
    probability of the appearance of each value given in the parameter `p=[0.1, 0.9]`.
    Here you ask for 0 to appear with a probability of 0.1 (or 10 percent) and for
    255 to appear with a probability of 90 percent. (The two values in `p` must add
    up to 1.) The `choice()` method creates a one-dimensional array, in this case
    with 16 values (specified with `4*4`). You use `reshape()` to make it a two-dimensional
    array with four rows and four columns.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`np.random.choice()`从给定的列表`[0, 255]`中选择一个值，选择每个值的概率由参数`p=[0.1, 0.9]`给出。在这里，你要求0出现的概率为0.1（即10%），255出现的概率为90%。（`p`中的两个值必须加起来等于1。）`choice()`方法创建一个一维数组，这里是16个值（由`4*4`指定）。你使用`reshape()`方法将其转换为一个包含四行四列的二维数组。'
- en: 'To set up the initial condition to match a particular pattern instead of just
    filling in a random set of values, first use `np.zeros()` to initialize the grid
    with all zeros:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将初始条件设置为匹配特定模式，而不是仅仅填充随机的值，首先使用`np.zeros()`初始化网格，使所有单元格的值都为零：
- en: grid = np.zeros(N*N).reshape(N, N)
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: grid = np.zeros(N*N).reshape(N, N)
- en: 'This creates an *N*×*N* array of zeros. Now define a function to add a pattern
    at a particular row and column in the grid:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个*N*×*N*的零数组。现在定义一个函数，用来在网格中的特定行和列添加一个模式：
- en: 'def addGlider(i, j, grid):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 'def addGlider(i, j, grid):'
- en: '"""adds a glider with top left cell at (i, j)"""'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '"""在（i, j）位置添加一个滑翔机，左上角单元格在此处"""'
- en: ❶ glider = np.array([[0, 0, 255],
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ glider = np.array([[0, 0, 255],
- en: '[255, 0, 255],'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[255, 0, 255]，'
- en: '[0, 255, 255]])'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '[0, 255, 255]])'
- en: ❷ grid[i:i+3, j:j+3] = glider
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ grid[i:i+3, j:j+3] = glider
- en: You define the glider pattern (an observed pattern that moves steadily across
    the grid) using a `numpy` array of shape (3, 3) ❶. Then you use the `numpy` slice
    operation to copy the `glider` array into the simulation’s two-dimensional grid
    ❷, with the pattern’s top-left corner placed at the coordinates you specify as
    `i` and `j`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用形状为（3, 3）的`numpy`数组❶定义滑翔机模式（观察到的在网格中稳定移动的模式）。然后你使用`numpy`切片操作将`glider`数组复制到模拟的二维网格❷中，并将模式的左上角放置在你指定的`i`和`j`坐标位置。
- en: 'Now you can add a glider pattern to the grid of zeros with a call to the `addGlider()`
    function you just defined:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以通过调用刚刚定义的`addGlider()`函数，将滑翔机模式添加到零网格中了：
- en: addGlider(1, 1, grid)
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: addGlider(1, 1, grid)
- en: You specify coordinates of (1, 1) to add the glider near the top-left corner
    of the grid, which is (0, 0). Note that for `grid[i, j]`, `i` starts at `0` and
    runs from top to bottom, and `j` starts at `0` and runs from left to right.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你指定坐标（1, 1）将滑翔机添加到靠近网格左上角的位置（0, 0）。请注意，对于`grid[i, j]`，`i`从`0`开始，按从上到下的顺序运行，而`j`从`0`开始，按从左到右的顺序运行。
- en: '[Enforcing the Boundary Conditions](nsp-venkitachalam503045-0008.xhtml#rbh0503)'
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[执行边界条件](nsp-venkitachalam503045-0008.xhtml#rbh0503)'
- en: 'Now we can think about how to implement the toroidal boundary conditions. First,
    let’s see what happens at the right edge of a grid of size *N*×*N*. The cell at
    the end of row *i* is accessed as `grid[i, N-1]`. Its neighbor to the right is
    `grid[i, N]`, but according to the toroidal boundary conditions, the value accessed
    as `grid[i, N]` should be replaced by `grid[i, 0]`. Here’s one way to do that:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以考虑如何实现环形边界条件。首先，让我们看看在大小为*N*×*N*的网格的右边缘发生了什么。行*i*末尾的单元格是通过`grid[i, N-1]`访问的。它右边的邻居是`grid[i,
    N]`，但是根据环形边界条件，访问`grid[i, N]`时应该用`grid[i, 0]`替换它。这是实现的一个方法：
- en: 'if j == N-1:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 'if j == N-1:'
- en: right = grid[i, 0]
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: right = grid[i, 0]
- en: 'else:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: right = grid[i, j+1]
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: right = grid[i, j+1]
- en: 'Of course, you’d need to apply similar boundary conditions to the left, top,
    and bottom sides of the grid, but doing so would require adding a lot more code
    because each of the four edges of the grid would need to be tested. A much more
    compact way to implement the boundary conditions is with Python’s modulus (`%`)
    operator, demonstrated here in the Python interpreter:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你还需要对网格的左边、顶部和底部应用类似的边界条件，但这样做需要添加更多的代码，因为网格的四个边缘都需要进行测试。一种更加简洁的方法是使用Python的取模（`%`）运算符，以下是Python解释器中的示范：
- en: '>>> `N = 16`'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> `N = 16`'
- en: '>>> `i1 = 14`'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> `i1 = 14`'
- en: '>>> `i2 = 15`'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> `i2 = 15`'
- en: '>>> `(i1+1)%N`'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> `(i1+1)%N`'
- en: '15'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '15'
- en: '>>> `(i2+1)%N`'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> `(i2+1)%N`'
- en: '0'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: 'As you can see, the `%` operator gives the remainder for the integer division
    by `N`. In this example, `15%16` yields `15`, but `16%16` yields `0`. You can
    use the `%` operator to make the values wrap around at the right edge by rewriting
    the grid access code like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`%`运算符给出了整数除法后余数的值。在这个例子中，`15%16`得到`15`，而`16%16`得到`0`。你可以使用`%`运算符让值在右边缘处环绕，通过如下方式重写网格访问代码：
- en: right = grid[i, (j+1)%N]
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: right = grid[i, (j+1)%N]
- en: 'Now when a cell is on the edge of the grid (in other words, when `j = N-1`),
    asking for the cell to the right with this method will give you `(j+1)%N`, which
    sets `j` back to `0`, making the right side of the grid wrap to the left side.
    When you do the same for the bottom of the grid, it wraps around to the top:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当一个单元格位于网格的边缘时（换句话说，当 `j = N-1`），用这种方法请求右侧的单元格会返回 `(j+1)%N`，这将使 `j` 回到 `0`，从而让网格的右侧与左侧相连。对网格底部做同样操作时，底部也会环绕到顶部：
- en: bottom = grid[(i+1)%N, j]
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: bottom = grid[(i+1)%N, j]
- en: '[Implementing the Rules](nsp-venkitachalam503045-0008.xhtml#rbh0504)'
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[实现规则](nsp-venkitachalam503045-0008.xhtml#rbh0504)'
- en: 'The rules of the Game of Life are based on the number of neighboring cells
    that are ON or OFF. To simplify the application of these rules, you can just calculate
    the total number of neighboring cells in the ON state. Because ON corresponds
    to a value of 255, simply sum the values of all the neighbors and divide by 255
    to get the number of ON cells. Here’s the relevant code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 生命游戏的规则基于邻居单元格的开启或关闭状态。为了简化这些规则的应用，你可以仅计算开启状态的邻居单元格总数。由于开启状态对应的值为 255，只需将所有邻居的值相加，再除以
    255 就可以得到开启状态的单元格数量。下面是相关代码：
- en: total = int((grid[i, (j-1)%N] + grid[i, (j+1)%N] +
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: total = int((grid[i, (j-1)%N] + grid[i, (j+1)%N] +
- en: grid[(i-1)%N, j] + grid[(i+1)%N, j] +
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: grid[(i-1)%N, j] + grid[(i+1)%N, j] +
- en: grid[(i-1)%N, (j-1)%N] + grid[(i-1)%N, (j+1)%N] +
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: grid[(i-1)%N, (j-1)%N] + grid[(i-1)%N, (j+1)%N] +
- en: grid[(i+1)%N, (j-1)%N] + grid[(i+1)%N, (j+1)%N])/255)
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: grid[(i+1)%N, (j-1)%N] + grid[(i+1)%N, (j+1)%N])/255)
- en: 'For any given cell (*i*, *j*), you sum the value of its eight neighbors, using
    the `%` operator to account for toroidal boundary conditions. Dividing the result
    by 255 gives you the number of neighbors that are ON, which you store in the variable
    `total`. Now you can use `total` to apply the Game of Life rules:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何给定的单元格（*i*，*j*），你需要将其八个邻居的值相加，使用 `%` 运算符来处理环形边界条件。将结果除以 255 得到开启状态的邻居数量，这个数值存储在变量
    `total` 中。现在你可以用 `total` 来应用生命游戏的规则：
- en: apply Conway's rules
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用康威的规则
- en: 'if grid[i, j] == ON:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 'if grid[i, j] == ON:'
- en: '❶ if (total < 2) or (total > 3):'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '❶ if (total < 2) or (total > 3):'
- en: newGrid[i, j] = OFF
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: newGrid[i, j] = OFF
- en: 'else:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: '❷ if total == 3:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '❷ if total == 3:'
- en: newGrid[i, j] = ON
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: newGrid[i, j] = ON
- en: 'Any cell that is ON is turned OFF if it has fewer than two neighbors that are
    ON or if it has more than three neighbors that are ON ❶. The code in the `else`
    branch applies only to OFF cells: a cell is turned ON if exactly three neighbors
    are ON ❷. The changes are applied to the corresponding cells in `newGrid`, which
    starts as a copy of `grid`. Once every cell has been evaluated and updated, `newGrid`
    contains the data for displaying the next time step in the simulation. You can’t
    make changes directly to `grid`, or the states of the cells would keep changing
    as you try to evaluate them.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 任意一个开启的单元格，如果它的邻居小于两个开启状态，或者邻居多于三个开启状态，它会被关闭 ❶。在 `else` 分支中的代码只应用于关闭状态的单元格：如果恰好有三个邻居是开启状态，单元格会被开启
    ❷。这些变化应用到 `newGrid` 中的对应单元格，而 `newGrid` 一开始是 `grid` 的一个副本。一旦每个单元格都被评估并更新，`newGrid`
    就包含了显示下一时间步的数据。你不能直接修改 `grid`，否则在评估单元格状态时，它们会不断变化。
- en: '[Sending Command Line Arguments to the Program](nsp-venkitachalam503045-0008.xhtml#rbh0505)'
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[发送命令行参数到程序](nsp-venkitachalam503045-0008.xhtml#rbh0505)'
- en: 'Now you can begin writing the `main()` function of the simulation, which starts
    by sending command line arguments to the program:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以开始编写模拟的 `main()` 函数，该函数首先通过命令行参数来启动程序：
- en: 'def main():'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 'def main():'
- en: '# command line arguments are in sys.argv[1], sys.argv[2], ...'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '# 命令行参数位于 sys.argv[1], sys.argv[2], ...'
- en: '# sys.argv[0] is the script name and can be ignored'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '# sys.argv[0] 是脚本名，可以忽略'
- en: '# parse arguments'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '# 解析参数'
- en: ❶ parser = argparse.ArgumentParser(description="Runs Conway's Game of Life
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ parser = argparse.ArgumentParser(description="运行康威的生命游戏
- en: simulation.")
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: simulation.")
- en: '# add arguments'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '# 添加参数'
- en: ❷ parser.add_argument('--grid-size', dest='N', required=False)
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ parser.add_argument('--grid-size', dest='N', required=False)
- en: ❸ parser.add_argument('--interval', dest='interval', required=False)
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ parser.add_argument('--interval', dest='interval', required=False)
- en: ❹ parser.add_argument('--glider', action='store_true', required=False)
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ parser.add_argument('--glider', action='store_true', required=False)
- en: args = parser.parse_args()
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: args = parser.parse_args()
- en: You create an `argparse.ArgumentParser` object to add command line options to
    the code ❶, and then you add various options to it in the following lines. The
    option at ❷ specifies the simulation grid size *N*, and the option at ❸ sets the
    animation update interval in milliseconds. You also create an option to start
    the simulation with a glider pattern ❹. If this option isn’t set, the simulation
    will start with random ON and OFF values.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 您创建了一个`argparse.ArgumentParser`对象，以便向代码中添加命令行选项 ❶，然后在接下来的几行中添加各种选项。❷处的选项指定了模拟的网格大小*N*，而❸处的选项设置了动画更新间隔（以毫秒为单位）。您还创建了一个选项，以启动带有滑行器模式的模拟
    ❹。如果没有设置此选项，模拟将从随机的开/关值开始。
- en: '[Initializing the Simulation](nsp-venkitachalam503045-0008.xhtml#rbh0506)'
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[初始化模拟](nsp-venkitachalam503045-0008.xhtml#rbh0506)'
- en: 'Continuing through the `main()` function, you come to the following section,
    which initializes the simulation:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 继续进入`main()`函数，您将进入以下部分，该部分初始化了模拟：
- en: '# set grid size'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置网格大小'
- en: ❶ N = 100
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ N = 100
- en: '# set animation update interval'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置动画更新间隔'
- en: ❷ updateInterval = 50
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ updateInterval = 50
- en: 'if args.interval:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 'if args.interval:'
- en: updateInterval = int(args.interval)
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: updateInterval = int(args.interval)
- en: '# declare grid'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '# 声明网格'
- en: grid = np.array([])
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: grid = np.array([])
- en: '# check if "glider" demo flag is specified'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '# 检查是否指定了“滑行器”演示标志'
- en: '❸ if args.glider:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '❸ if args.glider:'
- en: grid = np.zeros(N*N).reshape(N, N)
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: grid = np.zeros(N*N).reshape(N, N)
- en: addGlider(1, 1, grid)
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: addGlider(1, 1, grid)
- en: '❹ else:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '❹ else:'
- en: '# set N if specified and valid'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '# 如果指定且有效，设置N'
- en: 'if args.N and int(args.N) > 8:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 'if args.N and int(args.N) > 8:'
- en: N = int(args.N)
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: N = int(args.N)
- en: '# populate grid with random on/off - more off than on'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '# 使用随机开/关填充网格 - 关的比开的多'
- en: grid = randomGrid(N)
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: grid = randomGrid(N)
- en: This portion of the code applies any parameters called at the command line,
    once the command line options have been parsed. First, a default grid size of
    100×100 cells ❶ and an update interval of 50 milliseconds ❷ are set, in case these
    options aren’t set at the command line. Then you set up the initial conditions,
    either a random pattern by default ❹ or a glider pattern ❸.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分代码在命令行选项解析后应用任何在命令行中调用的参数。首先，设置默认的网格大小为100×100单元 ❶，并将更新间隔设置为50毫秒 ❷，以防这些选项未在命令行中设置。然后，您设置初始条件，默认是随机模式
    ❹，或者是滑行器模式 ❸。
- en: 'Finally, you set up the animation:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您设置动画：
- en: '# set up the animation'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置动画'
- en: ❶ fig, ax = plt.subplots()
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ fig, ax = plt.subplots()
- en: img = ax.imshow(grid, interpolation='nearest')
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: img = ax.imshow(grid, interpolation='nearest')
- en: ❷ ani = animation.FuncAnimation(fig, update, fargs=(img, grid, N, ),
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ ani = animation.FuncAnimation(fig, update, fargs=(img, grid, N, ),
- en: interval=updateInterval,
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: interval=updateInterval,
- en: save_count=50)
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: save_count=50)
- en: plt.show()
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: plt.show()
- en: Still within the `main()` function, you configure the `matplotlib` plot and
    animation parameters ❶. Then you set `animation.FuncAnimation()` to regularly
    call the function `update()`, defined earlier in the program, which updates the
    grid according to the rules of Conway’s Game of Life using toroidal boundary conditions
    ❷.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然在`main()`函数内，您配置了`matplotlib`绘图和动画参数 ❶。然后，您设置`animation.FuncAnimation()`定期调用之前在程序中定义的`update()`函数，该函数根据康威生命游戏的规则使用环面边界条件更新网格
    ❷。
- en: '[Running the Game of Life Simulation](nsp-venkitachalam503045-0008.xhtml#rah0504)'
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[运行生命游戏模拟](nsp-venkitachalam503045-0008.xhtml#rah0504)'
- en: 'Now run the code:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行代码：
- en: $ `python conway.py`
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: $ `python conway.py`
- en: 'This uses the default parameters for the simulation: a grid of 100×100 cells
    and an update interval of 50 milliseconds. As you watch the simulation, you’ll
    see how it progresses to create and sustain various patterns over time, as in
    [Figure 3-4 (a) and (b)](nsp-venkitachalam503045-0015.xhtml#fig3-4).'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用了模拟的默认参数：一个100×100单元的网格和50毫秒的更新间隔。当您观看模拟时，您将看到它是如何进展的，并随着时间的推移创建并维持各种模式，正如[图3-4
    (a)和(b)](nsp-venkitachalam503045-0015.xhtml#fig3-4)所示。
- en: '![](images/nsp-venkitachalam503045-f03004a.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f03004a.jpg)'
- en: (a)
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: (a)
- en: '![](images/nsp-venkitachalam503045-f03004b.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f03004b.jpg)'
- en: (b)
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: (b)
- en: 'Figure 3-4: The Game of Life in progress'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-4：生命游戏的进行
- en: '[Figure 3-5](nsp-venkitachalam503045-0015.xhtml#fig3-5) shows some of the patterns
    to look for in the simulation. Besides the glider, look for a three-cell blinker
    and static patterns such as a block or loaf shape.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3-5](nsp-venkitachalam503045-0015.xhtml#fig3-5)展示了在模拟中可以看到的一些模式。除了滑行器外，还可以找到三单元闪烁器和静态模式，例如方块或面包形状。'
- en: '![](images/nsp-venkitachalam503045-f03005.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f03005.jpg)'
- en: 'Figure 3-5: Some patterns in the Game of Life'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-5：生命游戏中的一些模式
- en: 'Now change things up a bit by running the simulation with these parameters:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在通过运行带有这些参数的模拟来改变一些设置：
- en: $ `python conway.py --grid-size 32 --interval 500 --glider`
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: $ `python conway.py --grid-size 32 --interval 500 --glider`
- en: This creates a simulation grid of 32×32, updates the animation every 500 milliseconds,
    and uses the initial glider pattern shown in the bottom right of [Figure 3-5](nsp-venkitachalam503045-0015.xhtml#fig3-5).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了一个32×32的仿真网格，每500毫秒更新一次动画，并使用在[图3-5](nsp-venkitachalam503045-0015.xhtml#fig3-5)右下角显示的初始滑行器模式。
- en: '[Summary](nsp-venkitachalam503045-0008.xhtml#rah0505)'
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[总结](nsp-venkitachalam503045-0008.xhtml#rah0505)'
- en: In this project, you explored Conway’s Game of Life. You learned how to set up
    a basic computer simulation based on some rules and how to use `matplotlib` to
    visualize the state of the system as it evolves.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你探索了康威的生命游戏。你学习了如何根据一些规则设置一个基本的计算机仿真，以及如何使用`matplotlib`可视化系统状态的演变过程。
- en: My implementation of Conway’s Game of Life emphasizes simplicity over performance.
    You can speed up the computations in the Game of Life in many different ways,
    and a tremendous amount of research has been done on how to do this. You’ll find
    a lot of this research through a quick internet search.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我的康威生命游戏实现强调简单性，而非性能。你可以通过许多不同的方式加速生命游戏的计算，关于如何做到这一点，已经有大量的研究。你可以通过快速的互联网搜索找到很多相关的研究。
- en: '[Experiments!](nsp-venkitachalam503045-0008.xhtml#rah0506)'
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[实验！](nsp-venkitachalam503045-0008.xhtml#rah0506)'
- en: 'Here are some ways to experiment further with Conway’s Game of Life:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些进一步实验康威生命游戏的方法：
- en: 1\. Write an `addGosperGun()` method to add the pattern shown in [Figure 3-6](nsp-venkitachalam503045-0015.xhtml#fig3-6)
    to the grid. This pattern is called the *Gosper Glider Gun*. Run the simulation
    and observe what the gun does.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1\. 编写一个`addGosperGun()`方法，将[图3-6](nsp-venkitachalam503045-0015.xhtml#fig3-6)中显示的模式添加到网格中。这个模式被称为*戈斯珀滑行枪*。运行仿真并观察这个滑行枪的行为。
- en: '![](images/nsp-venkitachalam503045-f03006.jpg)'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f03006.jpg)'
- en: 'Figure 3-6: The Gosper Glider Gun'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图3-6：戈斯珀滑行枪
- en: '2\. Write a `readPattern()` method that reads in an initial pattern from a
    text file and uses it to set the initial conditions for the simulation. You can
    use Python methods such as `open` and `file.read` to do this. Here’s a suggested
    format for the input file:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2\. 编写一个`readPattern()`方法，从文本文件中读取初始模式，并用它来设置仿真的初始条件。你可以使用Python方法，如`open`和`file.read`来实现这一点。以下是输入文件的建议格式：
- en: '8'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '8'
- en: 0 0 0 255...
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 0 0 0 255...
- en: The first line of the file defines *N*, and the rest of the file is just *N*×*N*
    integers (0 or 255) separated by whitespace. This exploration will help you study
    how any given pattern evolves with the rules of the Game of Life. Add a `--pattern-file`
    command line option to use this file while running the program.
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 文件的第一行定义了*N*，其余部分是*N*×*N*的整数（0或255），它们通过空格分隔。这个探索将帮助你研究任何给定模式在生命游戏规则下的演化。添加一个`--pattern-file`命令行选项，在运行程序时使用这个文件。
- en: '[The Complete Code](nsp-venkitachalam503045-0008.xhtml#rah0507)'
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[完整代码](nsp-venkitachalam503045-0008.xhtml#rah0507)'
- en: 'Here’s the complete code for the Game of Life project:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是生命游戏项目的完整代码：
- en: '"""'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: conway.py
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: conway.py
- en: A simple Python/matplotlib implementation of Conway's Game of Life.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的Python/matplotlib实现的康威生命游戏。
- en: 'Author: Mahesh Venkitachalam'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 作者：Mahesh Venkitachalam
- en: '"""'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: import sys, argparse
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: import sys, argparse
- en: import numpy as np
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: import numpy as np
- en: import matplotlib.pyplot as plt
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: import matplotlib.pyplot as plt
- en: import matplotlib.animation as animation
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: import matplotlib.animation as animation
- en: 'def randomGrid(N):'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 'def randomGrid(N):'
- en: '"""returns a grid of NxN random values"""'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '"""返回一个NxN的随机值网格"""'
- en: return np.random.choice([255, 0], N*N, p=[0.2, 0.8]).reshape(N, N)
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: return np.random.choice([255, 0], N*N, p=[0.2, 0.8]).reshape(N, N)
- en: 'def addGlider(i, j, grid):'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 'def addGlider(i, j, grid):'
- en: '"""adds a glider with top left cell at (i, j)"""'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '"""在(i, j)处添加一个滑行器"""'
- en: glider = np.array([[0,    0, 255],
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: glider = np.array([[0,    0, 255],
- en: '[255,  0, 255],'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '[255,  0, 255],'
- en: '[0,  255, 255]])'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '[0,  255, 255]])'
- en: grid[i:i+3, j:j+3] = glider
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: grid[i:i+3, j:j+3] = glider
- en: 'def update(frameNum, img, grid, N):'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 'def update(frameNum, img, grid, N):'
- en: '# copy grid since we require 8 neighbors for calculation'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '# 复制网格，因为我们需要8个邻居来计算'
- en: '# and we go line by line'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '# 我们逐行进行'
- en: newGrid = grid.copy()
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: newGrid = grid.copy()
- en: 'for i in range(N):'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(N):'
- en: 'for j in range(N):'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 'for j in range(N):'
- en: '# compute 8-neighbor sum'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '# 计算8邻域的总和'
- en: '# using toroidal boundary conditions - x and y wrap around'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '# 使用环面边界条件 - x和y会循环'
- en: '# so that the simulation takes place on a toroidal surface'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '# 这样仿真就会在一个环面上进行'
- en: total = int((grid[i, (j-1)%N] + grid[i, (j+1)%N] +
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: total = int((grid[i, (j-1)%N] + grid[i, (j+1)%N] +
- en: grid[(i-1)%N, j] + grid[(i+1)%N, j] +
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: grid[(i-1)%N, j] + grid[(i+1)%N, j] +
- en: grid[(i-1)%N, (j-1)%N] + grid[(i-1)%N, (j+1)%N] +
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: grid[(i-1)%N, (j-1)%N] + grid[(i-1)%N, (j+1)%N] +
- en: grid[(i+1)%N, (j-1)%N] + grid[(i+1)%N, (j+1)%N])/255)
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: grid[(i+1)%N, (j-1)%N] + grid[(i+1)%N, (j+1)%N])/255)
- en: '# apply Conway''s rules'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '# 应用 Conway 的规则'
- en: 'if grid[i, j]  == 255:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 grid[i, j] == 255:'
- en: 'if (total < 2) or (total > 3):'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 (total < 2) 或 (total > 3):'
- en: newGrid[i, j] = 0
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: newGrid[i, j] = 0
- en: 'else:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 否则：
- en: 'if total == 3:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 total == 3:'
- en: newGrid[i, j] = 255
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: newGrid[i, j] = 255
- en: '# update data'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '# 更新数据'
- en: img.set_data(newGrid)
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: img.set_data(newGrid)
- en: grid[:] = newGrid[:]
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: grid[:] = newGrid[:]
- en: '# need to return a tuple here, since this callback'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '# 这里需要返回一个元组，因为这个回调'
- en: '# function needs to return an iterable'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '# 函数需要返回一个可迭代对象'
- en: return img,
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: return img,
- en: main() function
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: main() 函数
- en: 'def main():'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 'def main():'
- en: '# command line args are in sys.argv[1], sys.argv[2]...'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '# 命令行参数在 sys.argv[1], sys.argv[2]...'
- en: '# sys.argv[0] is the script name itself and can be ignored'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '# sys.argv[0] 是脚本的名称，可以忽略'
- en: '# parse arguments'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '# 解析参数'
- en: parser = argparse.ArgumentParser(description="Runs Conway's Game of Life
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: parser = argparse.ArgumentParser(description="运行 Conway 的生命游戏
- en: simulation.")
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: simulation.")
- en: '# add arguments'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '# 添加参数'
- en: parser.add_argument('--grid-size', dest='N', required=False)
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: parser.add_argument('--grid-size', dest='N', required=False)
- en: parser.add_argument('--interval', dest='interval', required=False)
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: parser.add_argument('--interval', dest='interval', required=False)
- en: parser.add_argument('--glider', action='store_true', required=False)
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: parser.add_argument('--glider', action='store_true', required=False)
- en: parser.add_argument('--gosper', action='store_true', required=False)
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: parser.add_argument('--gosper', action='store_true', required=False)
- en: args = parser.parse_args()
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: args = parser.parse_args()
- en: '# set grid size'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置网格大小'
- en: N = 100
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: N = 100
- en: '# set animation update interval'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置动画更新间隔'
- en: updateInterval = 50
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: updateInterval = 50
- en: 'if args.interval:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 args.interval:'
- en: updateInterval = int(args.interval)
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: updateInterval = int(args.interval)
- en: '# declare grid'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '# 声明网格'
- en: grid = np.array([])
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: grid = np.array([])
- en: '# check if "glider" demo flag is specified'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '# 检查是否指定了 "glider" 演示标志'
- en: 'if args.glider:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 args.glider:'
- en: grid = np.zeros(N*N).reshape(N, N)
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: grid = np.zeros(N*N).reshape(N, N)
- en: addGlider(1, 1, grid)
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: addGlider(1, 1, grid)
- en: 'elif args.gosper:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif args.gosper:'
- en: grid = np.zeros(N*N).reshape(N, N)
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: grid = np.zeros(N*N).reshape(N, N)
- en: addGosperGliderGun(10, 10, grid)
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: addGosperGliderGun(10, 10, grid)
- en: 'else:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 否则：
- en: '# set N if specified and valid'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '# 如果指定并且有效，设置 N'
- en: 'if args.N and int(args.N) > 8:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 args.N 且 int(args.N) > 8:'
- en: N = int(args.N)
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: N = int(args.N)
- en: '# populate grid with random on/off - more off than on'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '# 使用随机的开/关状态填充网格 - 关的更多'
- en: grid = randomGrid(N)
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: grid = randomGrid(N)
- en: '# set up animation'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置动画'
- en: fig, ax = plt.subplots()
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: fig, ax = plt.subplots()
- en: img = ax.imshow(grid, interpolation='nearest')
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: img = ax.imshow(grid, interpolation='nearest')
- en: ani = animation.FuncAnimation(fig, update, fargs=(img, grid, N, ),
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: ani = animation.FuncAnimation(fig, update, fargs=(img, grid, N, ),
- en: frames = 10,
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: frames = 10,
- en: interval=updateInterval)
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: interval=updateInterval)
- en: plt.show()
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: plt.show()
- en: call main
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用 main
- en: 'if __name__ == ''__main__'':'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 __name__ == ''__main__'':'
- en: main()
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: main()
