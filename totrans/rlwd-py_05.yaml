- en: '5'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '5'
- en: FINDING PLUTO
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 发现冥王星
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: According to Woody Allen, 80 percent of success is just showing up. This certainly
    describes the success of Clyde Tombaugh, an untrained Kansas farm boy growing
    up in the 1920s. With a passion for astronomy but no money for college, he took
    a stab in the dark and mailed his best astronomical sketches to Lowell Observatory.
    To his great surprise, he was hired as an assistant. A year later, he had discovered
    Pluto and gained eternal glory!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 根据伍迪·艾伦的说法，成功的80%仅仅是出现在场。这无疑描述了克莱德·汤博的成功，一个没有受过训练的堪萨斯农场男孩，在1920年代长大。由于对天文学充满热情却没有上大学的钱，他尝试了一下，邮寄了自己最好的天文素描给洛威尔天文台。令他大吃一惊的是，他被聘为助手。一年后，他发现了冥王星，并因此获得了永恒的荣耀！
- en: Percival Lowell, the famous astronomer and founder of Lowell Observatory, had
    postulated the presence of Pluto based on perturbations in the orbit of Neptune.
    His calculations were wrong, but by pure coincidence, he correctly predicted Pluto’s
    orbital path. Between 1906 and his death in 1916, he had photographed Pluto twice.
    Both times, his team failed to notice it. Tombaugh, on the other hand, photographed
    *and* recognized Pluto in January 1930, after only a year of searching ([Figure
    5-1](ch05.xhtml#ch05fig1)).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 费尔西瓦尔·洛威尔，这位著名的天文学家和洛威尔天文台的创始人，基于海王星轨道的扰动提出了冥王星的存在。他的计算是错误的，但纯粹巧合的是，他正确预测了冥王星的轨道路径。在1906年到他1916年去世之间，他曾两次拍摄冥王星。每次，他的团队都未能注意到它。而汤博则在1930年1月，经过仅一年寻找，拍摄并识别出了冥王星（[图5-1](ch05.xhtml#ch05fig1)）。
- en: '![Image](../images/fig05_01.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig05_01.jpg)'
- en: 'Figure 5-1: Discovery plates for Pluto, indicated by the arrow'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-1：冥王星的发现底片，箭头指示的位置
- en: What Tombaugh accomplished was extraordinary. Without computers, the methodology
    he followed was impractical, tedious, and demanding. He had to photograph and
    re-photograph small parts of the sky night after night, usually in a freezing
    cold dome shaken by icy winds. He then developed and sifted through all the negatives,
    searching for the faintest signs of movement within crowded star fields.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 汤博所取得的成就非凡。在没有计算机的情况下，他所遵循的方法论既不切实际，又繁琐且要求极高。他必须一夜又一夜地拍摄并重新拍摄天空的某些小部分，通常是在一个冰冷的圆顶下，圆顶被刺骨的寒风吹动。然后，他需要冲洗并筛选所有底片，寻找在星星密集区域中任何微弱的运动迹象。
- en: Although he lacked a computer, he did have a state-of-the-art device, known
    as a *blink comparator*, that let him rapidly switch between negatives from successive
    nights. As viewed through the blink comparator, the stars remained stationary,
    but Pluto, a moving object, flashed on and off like a beacon.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然他没有计算机，但他确实拥有一台先进的设备，叫做*闪烁比较器*，这使他能够快速在连续几晚的底片之间切换。在通过闪烁比较器观察时，恒星保持静止，但冥王星作为一个移动物体，像信标一样闪烁。
- en: In this chapter, you’ll first write a Python program that replicates an early
    20th-century blink comparator. Then you’ll move into the 21st century and write
    a program that automates the detection of moving objects using modern computer
    vision techniques.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将首先编写一个Python程序，复制20世纪初期的闪烁比较器。接着，你将进入21世纪，编写一个程序，利用现代计算机视觉技术自动检测运动物体。
- en: '**NOTE**'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In 2006, the International Astronomical Union reclassified Pluto as a dwarf
    planet. This was based on the discovery of other Pluto-sized bodies in the Kuiper
    Belt, including one—Eris—that is volumetrically smaller but 27 percent more massive
    than Pluto.*'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*2006年，国际天文学联合会将冥王星重新分类为矮行星。这是基于在柯伊伯带中发现了其他与冥王星相似的天体，包括一个——厄里斯——它的体积较小，但质量比冥王星大27%。*'
- en: '**Project #7: Replicating a Blink Comparator**'
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**项目#7：复制闪烁比较器**'
- en: Pluto may have been photographed with a telescope, but it was found with a microscope.
    The blink comparator ([Figure 5-2](ch05.xhtml#ch05fig2)), also called the *blink
    microscope*, lets the user mount two photographic plates and rapidly switch from
    looking at one to the other. During this “blinking,” any object that changes position
    between photographs will appear to jump back and forth.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 冥王星可能是用望远镜拍摄的，但它是用显微镜发现的。闪烁比较器（[图5-2](ch05.xhtml#ch05fig2)），也叫做*闪烁显微镜*，允许用户安装两张照片板并快速切换查看其中一张到另一张。在这种“闪烁”过程中，任何在两张照片之间发生位置变化的物体都会显得来回跳动。
- en: '![Image](../images/fig05_02.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig05_02.jpg)'
- en: 'Figure 5-2: A blink comparator'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-2：闪烁比较器
- en: For this technique to work, the photos need to be taken with the same exposure
    and under similar viewing conditions. Most importantly, the stars in the two images
    must line up perfectly. In Tombaugh’s day, technicians achieved this through painstaking
    manual labor; they carefully guided the telescope during the hour-long exposures,
    developed the photographic plates, and then shifted them in the blink comparator
    to fine-tune the alignment. Because of this exacting work, it would sometimes
    take Tombaugh a week to examine a single pair of plates.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使该技术有效，照片需要在相同的曝光条件下拍摄，并且具有相似的观看条件。最重要的是，两张图像中的星星必须完全对齐。在汤博（Tombaugh）时代，技术人员通过艰苦的手工劳动来完成这一过程；他们在长达一个小时的曝光过程中小心引导望远镜，显影胶片后，再通过闪烁比较器进行微调对齐。正因为这项精细的工作，汤博有时需要花费一周的时间来检查一对胶片。
- en: In this project, you’ll digitally duplicate the process of aligning the plates
    and blinking them on and off. You’ll work with bright and dim objects, see the
    impact of different exposures between photos, and compare the use of positive
    images to the negative ones that Tombaugh used.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将数字化复制对齐胶片并进行闪烁显示的过程。你将处理明亮和昏暗的物体，观察不同曝光下照片的影响，并比较使用正片与汤博所用的负片的效果。
- en: THE OBJECTIVE
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标**'
- en: Write a Python program that aligns two nearly identical images and displays
    each one in rapid succession in the same window.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个Python程序，将两张几乎相同的图像对齐，并在同一窗口中快速交替显示它们。
- en: '***The Strategy***'
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***策略***'
- en: The photos for this project are already taken, so all you need to do is align
    them and flash them on and off. Aligning images is often referred to as image
    *registration*. This involves making a combination of vertical, horizontal, or
    rotational transformations to one of the images. If you’ve ever taken a panorama
    with a digital camera, you’ve seen registration at work.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目的照片已经拍摄完成，因此你只需要将它们对齐并进行闪烁显示。图像对齐通常被称为图像*配准*。这涉及对其中一张图像进行垂直、水平或旋转的变换。如果你曾用数码相机拍摄过全景照片，那么你一定见过配准技术的应用。
- en: 'Image registration follows these steps:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图像配准按照以下步骤进行：
- en: Locate distinctive features in each image.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每张图像中定位出独特的特征。
- en: Numerically describe each feature.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用数字描述每个特征。
- en: Use the numerical descriptors to match identical features in each image.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用数字描述符匹配每张图像中相同的特征。
- en: Warp one image so that matched features share the same pixel locations in both
    images.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一张图像进行扭曲，使得匹配的特征在两张图像中的像素位置相同。
- en: For this to work well, the images should be the same size and cover close to
    the same area.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得良好的效果，图像应该具有相同的大小，并覆盖几乎相同的区域。
- en: Fortunately, the OpenCV Python package ships with algorithms that perform these
    steps. If you skipped [Chapter 1](ch01.xhtml), you can read about OpenCV on [page
    6](ch01.xhtml#page_6).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，OpenCV Python 包附带了可以执行这些步骤的算法。如果你跳过了[第1章](ch01.xhtml)，你可以在[第6页](ch01.xhtml#page_6)阅读关于OpenCV的内容。
- en: Once the images are registered, you’ll need to display them in the same window
    so that they overlay exactly and then loop through the display a set number of
    times. Again, you can easily accomplish this with the help of OpenCV.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦图像完成配准，你需要将它们显示在同一个窗口中，使其精确重叠，然后循环显示若干次。再次强调，你可以借助OpenCV轻松实现这一点。
- en: '***The Data***'
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***数据***'
- en: The images you’ll need are in the *Chapter_5* folder in the book’s supporting
    files, downloadable from *[https://nostarch.com/real-world-python/](https://nostarch.com/real-world-python/)*.
    The folder structure should look like [Figure 5-3](ch05.xhtml#ch05fig3). After
    downloading the folders, don’t change this organizational structure or the folder
    contents and names.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要的图像位于书籍支持文件中的*Chapter_5*文件夹，可以从*[https://nostarch.com/real-world-python/](https://nostarch.com/real-world-python/)*下载。文件夹结构应如[图5-3](ch05.xhtml#ch05fig3)所示。下载文件夹后，请不要更改此组织结构或文件夹内容和名称。
- en: '![Image](../images/fig05_03.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig05_03.jpg)'
- en: 'Figure 5-3: The folder structure for Project 7'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-3：项目7的文件夹结构
- en: The *night_1* and *night_2* folders contain the input images you’ll use to get
    started. In theory, these would be images of the same region of space taken on
    different nights. The ones used here are the same star field image to which I’ve
    added an artificial *transient*. A transient, short for *transient astronomical
    event*, is a celestial object whose motion is detectable over relatively short
    time frames. Comets, asteroids, and planets can all be considered transients,
    as their movement is easily detected against the more static background of the
    galaxy.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*night_1* 和 *night_2* 文件夹包含你将用来开始的输入图像。从理论上讲，这些图像应该是拍摄于不同夜晚的同一片区域的图像。这里使用的是相同的星空图像，且我添加了一个人工的
    *短暂天体*。短暂天体，简称 *短暂天文事件*，是一个在相对较短的时间框架内可以检测到其运动的天体。彗星、小行星和行星都可以被视为短暂天体，因为它们的运动在更静态的银河背景下很容易被检测到。'
- en: '[Table 5-1](ch05.xhtml#ch05table1) briefly describes the contents of the *night_1*
    folder. This folder contains files with *left* in their filenames, which means
    they should go on the left side of a blink comparator. The images in the *night_2*
    folder contain *right* in the filenames and should go on the other side.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 5-1](ch05.xhtml#ch05table1) 简要描述了 *night_1* 文件夹的内容。该文件夹包含文件名中带有 *left* 的文件，表示它们应该放置在闪烁比较仪的左侧。*night_2*
    文件夹中的图像文件名包含 *right*，应放置在另一侧。'
- en: '**Table 5-1:** Files in the *night_1* folder'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 5-1:** *night_1* 文件夹中的文件'
- en: '| Filename | Description |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 文件名 | 描述 |'
- en: '| --- | --- |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| *1_bright_transient_left.png* | Contains a large, bright transient |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| *1_bright_transient_left.png* | 包含一个明亮的短暂天体 |'
- en: '| *2_dim_transient_left.png* | Contains a dim transient a single pixel in diameter
    |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| *2_dim_transient_left.png* | 包含一个直径为单个像素的暗短暂天体 |'
- en: '| *3_diff_exposures_left.png* | Contains a dim transient with an overexposed
    background |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| *3_diff_exposures_left.png* | 包含一个背景过曝的暗短暂天体 |'
- en: '| *4_single_transient_left.png* | Contains a bright transient in left image
    only |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| *4_single_transient_left.png* | 仅包含左侧图像中的明亮短暂天体 |'
- en: '| *5_no_transient_left.png* | Star field with no transient |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| *5_no_transient_left.png* | 没有短暂天体的星空 |'
- en: '| *6_bright_transient_neg_left.png* | A negative of the first file to show
    the type of image Tombaugh used |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| *6_bright_transient_neg_left.png* | 第一个文件的负片，显示汤博使用的图像类型 |'
- en: '[Figure 5-4](ch05.xhtml#ch05fig4) is an example of one of the images. The arrow
    points to the transient (but isn’t part of the image file).'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-4](ch05.xhtml#ch05fig4) 是其中一张图像的示例。箭头指向短暂天体（但不属于图像文件的一部分）。'
- en: '![Image](../images/fig05_04.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/fig05_04.jpg)'
- en: 'Figure 5-4: 1_bright_transient_left.png with an arrow indicating the transient'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '图 5-4: 1_bright_transient_left.png，箭头指示短暂天体'
- en: To duplicate the difficulty in perfectly aligning a telescope from night to
    night, I’ve slightly shifted the images in the *night_2* folder with respect to
    those in *night_1*. You’ll need to loop through the contents of the two folders,
    registering and comparing each pair of photos. For this reason, the number of
    files in each folder should be the same, and the naming convention should ensure
    that the photos are properly paired.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟完美对齐望远镜的困难，我稍微移动了 *night_2* 文件夹中的图像，使它们相对于 *night_1* 文件夹中的图像有所偏移。你需要遍历这两个文件夹中的内容，注册并比较每一对照片。因此，每个文件夹中的文件数应相同，且命名规则应确保照片正确配对。
- en: '***The Blink Comparator Code***'
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***闪烁比较仪代码***'
- en: The following *blink_comparator.py* code will digitally duplicate a blink comparator.
    Find this program in the *Chapter_5* folder from the website. You’ll also need
    the folders described in the previous section. Keep the code in the folder above
    the *night_1* and *night_2* folders.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 *blink_comparator.py* 代码将数字化复制一个闪烁比较仪。可以在网站的 *Chapter_5* 文件夹中找到此程序。你还需要上一节描述的文件夹。将代码保存在
    *night_1* 和 *night_2* 文件夹之上的文件夹中。
- en: '**Importing Modules and Assigning a Constant**'
  id: totrans-51
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**导入模块并分配常量**'
- en: '[Listing 5-1](ch05.xhtml#ch05list1) imports the modules you’ll need to run
    the program and assigns a constant for the minimum number of keypoint matches
    to accept. Also called interest points, *keypoints* are interesting features in
    an image that you can use to characterize the image. They’re usually associated
    with sharp changes in intensity, such as corners or, in this case, stars.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5-1](ch05.xhtml#ch05list1) 导入了运行程序所需的模块，并为接受的最小关键点匹配数分配了常量。关键点，也叫兴趣点，是图像中的有趣特征，可用于表征图像。它们通常与强烈的亮度变化相关，例如角点，或者在这个例子中是星体。'
- en: '[PRE0]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 5-1: Importing modules and assigning a constant for keypoint matches'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-1: 导入模块并为关键点匹配分配常量'
- en: Start by importing the operating system module, which you’ll use to list the
    contents of folders. Then import pathlib, a handy module that simplifies working
    with files and folders. Finish by importing NumPy and cv (OpenCV) for working
    with images. If you skipped [Chapter 1](ch01.xhtml), you can find installation
    instructions for NumPy on [page 8](ch01.xhtml#page_8).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 首先导入操作系统模块，使用它来列出文件夹中的内容。接着导入pathlib，一个简化处理文件和文件夹的有用模块。最后导入NumPy和cv（OpenCV）用于处理图像。如果你跳过了[第1章](ch01.xhtml)，你可以在[第8页](ch01.xhtml#page_8)找到NumPy的安装说明。
- en: Assign a constant variable for the minimum number of keypoint matches to accept.
    For efficiency, you ideally want the smallest value that will yield an acceptable
    registration result. In this project, the algorithm runs so quickly that you can
    increase this value without a significant cost.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为接受的最小关键点匹配数量分配一个常量变量。为了提高效率，你最好选择一个能够产生可接受配准结果的最小值。在这个项目中，算法运行非常快，因此可以增加这个值，而不会产生显著的成本。
- en: '**Defining the main() Function**'
  id: totrans-57
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**定义main()函数**'
- en: '[Listing 5-2](ch05.xhtml#ch05list2) defines the first part of the main() function,
    used to run the program. These initial steps create lists and directory paths
    used to access the various image files.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 5-2](ch05.xhtml#ch05list2)定义了main()函数的第一部分，用于运行程序。这些初步步骤创建了列表和目录路径，用于访问各种图像文件。'
- en: '[PRE1]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 5-2: Defining the first part of main(), used to manipulate files and
    folders'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 5-2：定义main()的第一部分，用于操作文件和文件夹
- en: 'Start by defining main() and then use the os module’s listdir() method to create
    a list of the filenames in the *night_1* and *night_2* folders. For the *night_1*
    folder, listdir() returns the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 首先定义main()函数，然后使用os模块的listdir()方法来创建*night_1*和*night_2*文件夹中所有文件名的列表。对于*night_1*文件夹，listdir()返回以下内容：
- en: '[PRE2]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note that os.listdir() does not impose an order on the files when they’re returned.
    The underlying operating system determines the order, meaning macOS will return
    a different list than Windows! To ensure that the lists are consistent and the
    files are paired correctly, wrap os.listdir() with the built-in sorted() function.
    This function will return the files in numerical order, based on the first character
    in the filename.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，os.listdir()在返回文件时并不对文件进行排序。底层操作系统决定了排序顺序，这意味着macOS返回的列表将与Windows不同！为了确保列表一致且文件正确配对，可以用内建的sorted()函数包装os.listdir()。该函数会基于文件名的第一个字符返回按数字顺序排列的文件。
- en: Next, assign path names to variables using the pathlib Path class. The first
    two variables will point to the two input folders, and the third will point to
    an output folder to hold the registered images.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用pathlib的Path类将路径名分配给变量。前两个变量将指向两个输入文件夹，第三个变量将指向一个输出文件夹，用于存放配准后的图像。
- en: The pathlib module, introduced in Python 3.4, is an alternative to os.path for
    handling file paths. The os module treats paths as strings, which can be cumbersome
    and requires you to use functionality from across the Standard Library. Instead,
    the pathlib module treats paths as objects and gathers the necessary functionality
    in one place. The official documentation for pathlib is at *[https://docs.python.org/3/library/pathlib.html](https://docs.python.org/3/library/pathlib.html)*.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: pathlib模块是Python 3.4引入的，它是os.path的替代方案，用于处理文件路径。os模块将路径视为字符串，这可能会很麻烦，并且需要你使用标准库中的多个功能。相反，pathlib模块将路径视为对象，并将所需的功能集中在一个地方。pathlib的官方文档位于*
    [https://docs.python.org/3/library/pathlib.html](https://docs.python.org/3/library/pathlib.html)
    *。
- en: For the first part of the directory path, use the cwd() class method to get
    the current working directory. If you have at least one Path object, you can use
    a mix of objects and strings in the path designation. You can join the string,
    representing the folder name, with the / symbol. This is similar to using os.path.join(),
    if you’re familiar with the os module.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 对于目录路径的第一部分，使用cwd()类方法获取当前工作目录。如果你至少有一个Path对象，你可以在路径指定中混合使用对象和字符串。你可以将表示文件夹名称的字符串与/符号连接起来。这与使用os.path.join()类似，如果你熟悉os模块的话。
- en: Note that you will need to execute the program from within the project directory.
    If you call it from elsewhere in the filesystem, it will fail.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你需要在项目目录内执行程序。如果从文件系统的其他地方调用它，将会失败。
- en: '**Looping in main()**'
  id: totrans-68
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**在main()中的循环**'
- en: '[Listing 5-3](ch05.xhtml#ch05list3), still in the main() function, runs the
    program with a big for loop. This loop will take a file from each of the two “night”
    folders, load them as grayscale images, find matching keypoints in each image,
    use the keypoints to warp (or *register*) the first image to match the second,
    save the registered image, and then compare (or *blink*) the registered first
    image with the original second image. I’ve also included a few optional quality
    control steps that you can comment out once you’re satisfied with the results.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 5-3](ch05.xhtml#ch05list3)，仍然在main()函数中，通过一个大的for循环运行程序。这个循环会从两个“night”文件夹中的每一个提取一个文件，将它们作为灰度图像加载，找到每张图像中的匹配关键点，利用这些关键点将第一张图像变换（或*配准*）以匹配第二张图像，保存配准后的图像，然后比较（或*闪烁*）配准后的第一张图像和原始的第二张图像。我还包括了一些可选的质量控制步骤，在你确认结果满意后可以将它们注释掉。'
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 5-3: Running the program loop in main()'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-3：在main()函数中运行程序循环
- en: Begin the loop by enumerating the night1_files list. The enumerate() built-in
    function adds a counter to each item in the list and returns this counter along
    with the item. Since you only need the counter, use a single underscore (_) for
    the list item. By convention, the single underscore indicates a temporary or insignificant
    variable. It also keeps code-checking programs, such as Pylint, happy. Were you
    to use a variable name here, such as infile, Pylint would complain about an *unused
    variable*.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 通过枚举night1_files列表开始循环。内置的enumerate()函数为列表中的每个项目添加一个计数器，并返回该计数器以及项目。由于你只需要计数器，可以使用单个下划线(_)表示列表项。按惯例，单个下划线表示一个临时或不重要的变量。它还可以让代码检查程序（例如Pylint）保持正常。如果你在这里使用一个变量名，例如infile，Pylint会抱怨一个*未使用的变量*。
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Next, load the image, along with its pair from the night2_files list, using
    OpenCV. Note that you have to convert the path to a string for the imread() method.
    You’ll also want to convert the image to grayscale. This way, you’ll need to work
    with only a single channel, which represents intensity. To keep track of what’s
    going on during the loop, print a message to the shell indicating which files
    are being compared.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用OpenCV加载图像及其在night2_files列表中的配对图像。注意，你必须将路径转换为字符串，以便传递给imread()方法。你还需要将图像转换为灰度图像。这样，你只需处理单通道图像，它表示强度。为了跟踪循环过程中发生的事情，可以在shell中打印一条消息，指示正在比较哪些文件。
- en: 'Now, find the keypoints and their best matches ➊. The find_best_matches() function,
    which you’ll define later, will return these values as three variables: kp1, which
    represents the keypoints for the first loaded image; kp2, which represents the
    keypoints for the second; and best_matches, which represents a list of the matching
    keypoints.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，找到关键点及其最佳匹配 ➊。find_best_matches()函数（稍后你将定义）将返回这三个变量：kp1，表示第一个加载图像的关键点；kp2，表示第二个图像的关键点；以及best_matches，表示匹配的关键点列表。
- en: So you can visually check the matches, draw them on img1 and img2 using OpenCV’s
    drawMatches() method. As arguments, this method takes each image with its keypoints,
    the list of best matching keypoints, and an output image. In this case, the output
    image argument is set to None, as you’re just going to look at the output, not
    save it to a file.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你可以通过视觉检查匹配结果，使用OpenCV的drawMatches()方法在img1和img2上绘制它们。作为参数，该方法接受每张图像及其关键点、最佳匹配关键点列表和输出图像。在此例中，输出图像参数设置为None，因为你只是查看输出，而不是将其保存到文件中。
- en: To distinguish between the two images, draw a vertical white line down the right
    side of img1. First get the height and width of the image using shape. Next, call
    OpenCV’s line() method and pass it the image on which you want to draw, the start
    and end coordinates, the line color, and the thickness. Note that this is a color
    image, so to represent white, you need the full BGR tuple (255, 255, 255) rather
    than the single intensity value (255) used in grayscale images.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了区分这两张图像，在img1的右侧画一条垂直的白线。首先，使用shape获取图像的高度和宽度。接下来，调用OpenCV的line()方法，并传入你要绘制的图像、起始和结束坐标、线条颜色以及线条粗细。请注意，这是一张彩色图像，因此要表示白色，你需要使用完整的BGR元组(255,
    255, 255)，而不是在灰度图像中使用的单一强度值(255)。
- en: Now, call the quality control function—which you’ll define later—to display
    the matches ➋. [Figure 5-5](ch05.xhtml#ch05fig5) shows an example output. You
    may want to comment out this line after you confirm the program is behaving correctly.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，调用质量控制函数——稍后你将定义——来显示匹配结果 ➋。[图 5-5](ch05.xhtml#ch05fig5)展示了一个示例输出。你可能希望在确认程序正常运行后注释掉这一行。
- en: '![Image](../images/fig05_05.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig05_05.jpg)'
- en: 'Figure 5-5: Example output of the QC_best_matches() function'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-5：QC_best_matches() 函数的示例输出
- en: With the best keypoint matches found and checked, it’s time to register the
    first image to the second. Do this with a function you’ll write later. Pass the
    function the two images, the keypoints, and the list of best matches.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 找到并检查了最佳关键点匹配后，是时候将第一张图像注册到第二张图像了。使用稍后编写的函数来执行此操作。将两张图像、关键点和最佳匹配列表传递给该函数。
- en: The blink comparator, named blink(), is another function that you’ll write later.
    Call it here to see the effect of the registration process on the first image.
    Pass it the original and registered images, a name for the display window, and
    the number of blinks you want to perform ➌. The function will flash between the
    two images. The amount of “wiggle” you see will depend on the amount of warping
    needed to match img2. This is another line you may want to comment out after you’ve
    confirmed that the program runs as intended.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Blink 比较器（名为 blink()）是你稍后将编写的另一个函数。在这里调用它，查看注册过程对第一张图像的影响。传递给它原始图像和注册后的图像、显示窗口的名称以及你希望执行的闪烁次数
    ➌。该函数将在两张图像之间闪烁。你看到的“摇晃”程度将取决于匹配 img2 所需的扭曲量。确认程序按预期运行后，可能想注释掉这一行。
- en: Next, save the registered image into a folder named *night_1_registered*, which
    the path3 variable points to. Start by assigning a filename variable that references
    the original filename, with *_registered.png* appended to the end. So you don’t
    repeat the file extension in the name, use index slicing ([:-4]) to remove it
    before adding the new ending. Finish by using imwrite() to save the file. Note
    that this will overwrite existing files with the same name without warning.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将注册后的图像保存到名为 *night_1_registered* 的文件夹中，该文件夹路径由 path3 变量指向。首先，分配一个文件名变量，引用原始文件名，并在末尾附加
    *_registered.png*。为了避免在名称中重复文件扩展名，使用索引切片（[:-4]）将其去除，然后再添加新的结尾。最后，使用 imwrite()
    保存文件。请注意，这将覆盖具有相同名称的现有文件，而不会发出警告。
- en: You’ll want an uncluttered view when you start looking for transients, so call
    the method to destroy all the current OpenCV windows. Then call the blink() function
    again, passing it the registered image, the second image, a window name, and the
    number of times to loop through the images. The first images are shown side by
    side in [Figure 5-6](ch05.xhtml#ch05fig6). Can you find the transient?
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始寻找瞬时变化时，你需要一个干净的视图，因此调用方法销毁所有当前的 OpenCV 窗口。然后再次调用 blink() 函数，将注册后的图像、第二张图像、窗口名称以及循环图像的次数传递给它。第一张图像将并排显示在
    [图 5-6](ch05.xhtml#ch05fig6) 中。你能找到瞬时变化吗？
- en: '![Image](../images/fig05_06.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/fig05_06.jpg)'
- en: 'Figure 5-6: Blink Comparator windows for first image in night_1_registered
    and night_2 folders'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-6：night_1_registered 和 night_2 文件夹中第一张图像的 Blink Comparator 窗口
- en: '**Finding the Best Keypoint Matches**'
  id: totrans-87
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**查找最佳关键点匹配**'
- en: Now it’s time to define the functions used in main(). [Listing 5-4](ch05.xhtml#ch05list4)
    defines the function that finds the best keypoint matches between each pair of
    images extracted from the *night_1* and *night_2* folders. It should locate, describe,
    and match keypoints, generate a list of the matches, and then truncate that list
    by the constant for the minimum number of acceptable keypoints. The function returns
    the list of keypoints for each image and the list of best matches.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候定义主函数中使用的函数了。[列表 5-4](ch05.xhtml#ch05list4)定义了一个函数，用于查找从 *night_1* 和 *night_2*
    文件夹中提取的每对图像之间的最佳关键点匹配。它应该定位、描述并匹配关键点，生成匹配列表，然后通过最小可接受关键点数的常量截断该列表。该函数返回每张图像的关键点列表和最佳匹配列表。
- en: '[PRE5]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 5-4: Defining the function to find the best keypoint matches'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5-4：定义用于查找最佳关键点匹配的函数
- en: Start by defining the function, which takes two images as arguments. The main()
    function will pick these images from the input folders with each run of the for
    loop.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 首先定义该函数，该函数以两张图像作为参数。主函数（main()）将在每次运行 for 循环时从输入文件夹中选择这些图像。
- en: 'Next, create an orb object using OpenCV’s ORB_create() method. ORB is an acronym
    of nested acronyms: *O*riented FAST and *R*otated *B*RIEF.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用 OpenCV 的 ORB_create() 方法创建一个 orb 对象。ORB 是嵌套首字母缩写词的缩写：*O*riented FAST
    和 *R*otated *B*RIEF。
- en: FAST, short for *F*eatures from *A*ccelerated *S*egment *T*est, is a fast, efficient,
    and free algorithm for *detecting* keypoints. To *describe* the keypoints so that
    you can compare them across different images, you need BRIEF. Short for *B*inary
    *R*obust *I*ndependent *E*lementary *F*eatures, BRIEF is also fast, compact, and
    open source.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: FAST，即*F*eatures from *A*ccelerated *S*egment *T*est，是一种快速、高效且免费的算法，用于*检测*关键点。为了*描述*这些关键点，以便可以在不同图像之间进行比较，你需要使用
    BRIEF。BRIEF 是*B*inary *R*obust *I*ndependent *E*lementary *F*eatures的缩写，它同样快速、紧凑且是开源的。
- en: ORB combines FAST and BRIEF into a matching algorithm that works by first detecting
    distinctive regions in an image, where pixel values change sharply, and then recording
    the position of these distinctive regions as *keypoints*. Next, ORB describes
    the feature found at the keypoint using numerical arrays, or *descriptors*, by
    defining a small area, called a *patch*, around a keypoint. Within the image patch,
    the algorithm uses a pattern template to take regular samples of intensity. It
    then compares preselected pairs of samples and converts them into binary strings
    called *feature vectors* ([Figure 5-7](ch05.xhtml#ch05fig7)).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ORB 将 FAST 和 BRIEF 结合成一个匹配算法，该算法通过首先检测图像中像素值剧烈变化的独特区域，然后记录这些独特区域的位置作为*关键点*。接下来，ORB
    使用数值数组，或*描述符*，通过在关键点周围定义一个小区域，称为*补丁*，来描述在关键点处发现的特征。在图像补丁内，算法使用模式模板定期采样强度。然后，它将预选的样本对进行比较，并将它们转换为二进制字符串，称为*特征向量*（参见[图
    5-7](ch05.xhtml#ch05fig7)）。
- en: A *vector* is a series of numbers. A *matrix* is a rectangular array of numbers
    in rows and columns that’s treated as a single entity and manipulated according
    to rules. A *feature vector* is a matrix with one row and multiple columns. To
    build one, the algorithm converts the sample pairs into a binary series by concatenating
    a 1 to the end of the vector if the first sample has the largest intensity and
    a 0 if the reverse is true.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*向量*是一系列数字。*矩阵*是一个由行和列组成的矩形数字数组，它被视为一个整体并按照规则进行操作。*特征向量*是一个具有一行和多列的矩阵。为了构建一个特征向量，算法通过将
    1 添加到向量的末尾（如果第一个样本具有最大强度）或将 0 添加到末尾（如果相反）来将样本对转换为二进制系列。'
- en: '![Image](../images/fig05_07.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig05_07.jpg)'
- en: 'Figure 5-7: Cartoon example of how ORB generates keypoint descriptors'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-7：ORB 如何生成关键点描述符的卡通示例
- en: Some example feature vectors are shown next. I’ve shortened the list of vectors,
    because ORB usually compares and records 512 pairs of samples!
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下显示了一些示例特征向量。我缩短了向量列表，因为 ORB 通常会比较并记录 512 对样本！
- en: '[PRE6]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: These descriptors act as digital fingerprints for features. OpenCV uses additional
    code to compensate for rotation and scale changes. This allows it to match similar
    features even if the feature sizes and orientations are different (see [Figure
    5-8](ch05.xhtml#ch05fig8)).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这些描述符作为特征的数字指纹。OpenCV 使用额外的代码来补偿旋转和尺度变化，这使得即使特征的大小和方向不同，它也能匹配相似的特征（参见[图 5-8](ch05.xhtml#ch05fig8)）。
- en: '![Image](../images/fig05_08.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig05_08.jpg)'
- en: 'Figure 5-8: OpenCV can match keypoints despite differences in scale and orientation.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-8：OpenCV 可以匹配关键点，尽管它们在尺度和方向上存在差异。
- en: When you create the ORB object, you can specify the number of keypoints to examine.
    The method defaults to 500, but 100 will be more than enough for the image registration
    needed in this project.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 ORB 对象时，你可以指定要检查的关键点数量。默认方法为 500，但对于本项目所需的图像配准，100 个就足够了。
- en: Next, using the orb.detectAndCompute() method ➊, find the keypoints and their
    descriptors. Pass it img1 and then repeat the code for img2.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用 orb.detectAndCompute() 方法 ➊，找到关键点及其描述符。传入 img1，然后对 img2 重复相同的代码。
- en: With the keypoints located and described, the next step is to find the keypoints
    common to both images. Start this process by creating a BFMatcher object that
    includes a distance measurement. The brute-force matcher takes the descriptor
    of one feature in the first image and compares it to all the features in the second
    image using the Hamming distance. It returns the closest feature.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在定位并描述了关键点后，下一步是找到两幅图像中共同的关键点。通过创建一个包含距离度量的 BFMatcher 对象来开始此过程。暴力匹配器将第一幅图像中一个特征的描述符与第二幅图像中的所有特征进行比较，使用哈明距离。它返回最接近的特征。
- en: 'For two strings of equal length, the *Hamming distance* is the number of positions,
    or indexes, at which the corresponding values are different. For the following
    feature vectors, the positions that don’t match are shown in bold, and the Hamming
    distance is 3:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 对于两个相同长度的字符串，*汉明距离*是指对应位置或索引中值不同的数量。对于以下特征向量，不匹配的位置以粗体显示，汉明距离为 3：
- en: '[PRE7]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The bf variable will be a BFMatcher object. Call the match() method and pass
    it the descriptors for the two images ➋. Assign the returned list of DMatch objects
    to a variable named matches.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: bf 变量将是一个 BFMatcher 对象。调用 match() 方法并将两个图像的描述符传递给它 ➋。将返回的 DMatch 对象列表分配给名为 matches
    的变量。
- en: The best matches will have the lowest Hamming distance, so sort the objects
    in ascending order to move these to the start of the list. Note that you use a
    lambda function along with the object’s distance attribute. A *lambda function*
    is a small, one-off, unnamed function defined on the fly. Words and characters
    that directly follow lambda are parameters. Expressions come after the colon,
    and returns are automatic.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳匹配将具有最小的汉明距离，因此请按升序排序对象，将这些最佳匹配项移到列表的开头。请注意，您需要使用 lambda 函数以及对象的距离属性。*lambda
    函数*是一个小型的、一次性的、没有名称的函数，通常是动态定义的。紧随 lambda 之后的词和字符是参数。表达式在冒号后面，返回值是自动的。
- en: Since you only need the minimum number of keypoint matches defined at the start
    of the program, create a new list by slicing the matches list. The best matches
    are at the start, so slice from the start of matches up to the value specified
    in MIN_NUM_KEYPOINT_MATCHES.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您只需要在程序开始时定义的最小关键点匹配数，因此通过切片匹配列表来创建一个新列表。最佳匹配项位于列表开头，因此从匹配列表的起始位置切片直到 MIN_NUM_KEYPOINT_MATCHES
    指定的值。
- en: 'At this point, you’re still dealing with arcane objects, as shown here:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您仍在处理神秘的对象，如下所示：
- en: '[PRE8]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Fortunately, OpenCV knows how to handle these. Complete the function by returning
    the two sets of keypoints and the list of best matching objects.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，OpenCV 知道如何处理这些。通过返回两组关键点和最佳匹配对象列表，完成该函数。
- en: '**Checking the Best Matches**'
  id: totrans-114
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**检查最佳匹配**'
- en: '[Listing 5-5](ch05.xhtml#ch05list5) defines a short function to let you visually
    check the keypoint matches. You saw the results of this function in [Figure 5-5](ch05.xhtml#ch05fig5).
    By encapsulating these tasks in a function, you can reduce the clutter in main()
    and allow the user to turn off the functionality by commenting out a single line.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 5-5](ch05.xhtml#ch05list5) 定义了一个简短的函数，帮助您视觉检查关键点匹配。您已经在 [Figure 5-5](ch05.xhtml#ch05fig5)
    中看到了这个函数的结果。通过将这些任务封装到一个函数中，您可以减少 main() 中的杂乱，并通过注释掉一行代码来让用户关闭此功能。'
- en: '[PRE9]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 5-5: Defining a function to check the best keypoint matches'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 5-5: 定义一个函数来检查最佳关键点匹配'
- en: 'Define the function with one parameter: the matched image. This image was generated
    by the main() function in [Listing 5-3](ch05.xhtml#ch05list3). It consists of
    the left and right images with the keypoints drawn as colored circles and with
    colored lines connecting corresponding keypoints.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 定义该函数时使用一个参数：匹配的图像。这个图像是通过 [Listing 5-3](ch05.xhtml#ch05list3) 中的 main() 函数生成的。它由左图和右图组成，关键点以彩色圆圈表示，并且通过彩色线条连接对应的关键点。
- en: Next, call OpenCV’s imshow() method to display the window. You can use the format()
    method when naming the window. Pass it the constant for the number of minimum
    keypoint matches.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，调用 OpenCV 的 imshow() 方法显示窗口。您可以在命名窗口时使用 format() 方法。传递最小关键点匹配数的常量给它。
- en: Complete the function by giving the user 2.5 seconds to view the window. Note
    that the waitKey() method doesn’t destroy the window; it just suspends the program
    for the allocated amount of time. After the wait period, new windows will appear
    as the program resumes.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 完成该功能后，给用户 2.5 秒的时间查看窗口。请注意，waitKey() 方法并不会销毁窗口；它只是暂停程序指定的时间。等待时间过后，程序恢复执行，新窗口将会出现。
- en: '**Registering Images**'
  id: totrans-121
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**注册图像**'
- en: '[Listing 5-6](ch05.xhtml#ch05list6) defines the function to register the first
    image to the second image.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 5-6](ch05.xhtml#ch05list6) 定义了一个函数，将第一张图像注册到第二张图像。'
- en: '[PRE10]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 5-6: Defining a function to register one image to another'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 5-6: 定义一个函数将一张图像注册到另一张图像'
- en: Define a function that takes the two input images, their keypoint lists, and
    the list of DMatch objects returned from the find_best_matches() function as arguments.
    Next, load the location of the best matches into NumPy arrays. Start with a conditional
    to check that the list of best matches equals or exceeds the MIN_NUM_KEYPOINT_MATCHES
    constant. If it does, then initialize two NumPy arrays with as many rows as there
    are best matches.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个函数，接收两张输入图像、它们的关键点列表以及由 find_best_matches() 函数返回的 DMatch 对象列表作为参数。接下来，将最佳匹配的位置加载到
    NumPy 数组中。从一个条件判断开始，检查最佳匹配列表是否等于或超过 MIN_NUM_KEYPOINT_MATCHES 常量。如果是，则初始化两个 NumPy
    数组，行数与最佳匹配的数量相等。
- en: 'The np.zeros() NumPy method returns a new array of a given shape and data type,
    filled with zeros. For example, the following snippet produces a zero-filled array
    three rows tall and two columns wide:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: np.zeros() NumPy 方法返回一个具有给定形状和数据类型的新数组，填充为零。例如，下面的代码片段生成一个三行两列的零填充数组：
- en: '[PRE11]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the actual code, the arrays will be at least 50×2, since you stipulated a
    minimum of 50 matches.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际代码中，数组至少会是 50×2，因为你规定了至少要有 50 个匹配点。
- en: Now, enumerate the matches list and start populating the arrays with actual
    data ➊. For the source points, use the queryIdx.pt attribute to get the index
    of the descriptor in the list of descriptors for kp1. Repeat this for the next
    set of points, but use the trainIdx.pt attribute. The query/train terminology
    is a bit confusing but basically refers to the first and second images, respectively.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，枚举匹配列表并开始用实际数据填充数组 ➊。对于源点，使用 queryIdx.pt 属性获取描述符在 kp1 描述符列表中的索引。对下一组点重复此操作，但使用
    trainIdx.pt 属性。查询/训练术语有点混淆，但基本上分别指代第一张和第二张图像。
- en: The next step is to apply *homography*. Homography is a transformation, using
    a 3×3 matrix, that maps points in one image to corresponding points in another
    image. Two images can be related by a homography if both are viewing the same
    plane from a different angle or if both images are taken from the same camera
    rotated around its optical axis with no shift. To run correctly, homography needs
    at least four corresponding points in two images.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是应用*单应性*。单应性是一种使用 3×3 矩阵的变换，将一张图像中的点映射到另一张图像中的对应点。如果两张图像分别从不同角度观察同一平面，或者两张图像是通过相同相机绕光轴旋转而无平移的，那么这两张图像可以通过单应性关联。为了正确运行，单应性需要至少四个在两张图像中对应的点。
- en: Homography assumes that the matching points really are corresponding points.
    But if you look carefully at [Figures 5-5](ch05.xhtml#ch05fig5) and [5-8](ch05.xhtml#ch05fig8),
    you’ll see that the feature matching isn’t perfect. In [Figure 5-8](ch05.xhtml#ch05fig8),
    around 30 percent of the matches are incorrect!
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 单应性假设匹配点确实是对应点。但是，如果仔细查看[图 5-5](ch05.xhtml#ch05fig5)和[图 5-8](ch05.xhtml#ch05fig8)，你会发现特征匹配并不完美。在[图
    5-8](ch05.xhtml#ch05fig8)中，约 30% 的匹配是错误的！
- en: Fortunately, OpenCV includes a findHomography() method with an outlier detector
    called *random sample consensus* (RANSAC). RANSAC takes random samples of the
    matching points, finds a mathematical model that explains their distribution,
    and favors the model that predicts the most points. It then discards outliers.
    For example, consider the points in the “Raw data” box in [Figure 5-9](ch05.xhtml#ch05fig9).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，OpenCV 包括了一个带有离群点检测器的 findHomography() 方法，称为*随机采样一致性*（RANSAC）。RANSAC 随机采样匹配点，找到一个解释其分布的数学模型，并优先选择预测最多点的模型。然后它丢弃离群点。例如，考虑
    [图 5-9](ch05.xhtml#ch05fig9) 中的“原始数据”框中的点。
- en: '![Image](../images/fig05_09.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/fig05_09.jpg)'
- en: 'Figure 5-9: Example line fit using RANSAC to ignore outliers'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-9：使用 RANSAC 进行示例线性拟合以忽略离群点
- en: As you can see, you want to fit a line through the true data points (called
    the *inliers*) and ignore the smaller number of spurious points (the *outliers*).
    Using RANSAC, you randomly sample a subset of the raw data points, fit a line
    to these, and then repeat this process a set number of times. Each line-fit equation
    would then be applied to all the points. The line that passes through the most
    points is used for the final line fit. In [Figure 5-9](ch05.xhtml#ch05fig9), this
    would be the line in the rightmost box.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你想通过真实数据点（称为*内点*）拟合一条线，并忽略较少数量的伪点（*离群点*）。使用 RANSAC，你随机采样一组原始数据点，拟合一条线，然后重复此过程若干次。每个线性拟合方程都会应用到所有点。通过最多点的那条线被用于最终的线性拟合。在[图
    5-9](ch05.xhtml#ch05fig9)中，这将是最右侧框中的线。
- en: To run findHomography(), pass it the source and destination points and call
    the RANSAC method. This returns a NumPy array and a mask. The mask specifies the
    inlier and outlier points or the good matches and bad matches, respectively. You
    can use it to do tasks like draw only the good matches.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行 findHomography()，传入源点和目标点，并调用 RANSAC 方法。这将返回一个 NumPy 数组和一个掩码。掩码指定了内点和外点，或是好的匹配和坏的匹配。你可以使用它执行诸如仅绘制好匹配之类的任务。
- en: The final step is to warp the first image so that it perfectly aligns with the
    second. You’ll need the dimensions of the second image, so use shape() to get
    the height and width of img2 ➋. Pass this information, along with img1 and the
    homography h_array, to the warpPerspective() method. Return the registered image,
    which will be a NumPy array.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的步骤是将第一张图像扭曲，使其与第二张图像完美对齐。你需要第二张图像的尺寸，因此使用 shape() 获取 img2 的高度和宽度 ➋。将这些信息与
    img1 和单应性矩阵 h_array 一同传入 warpPerspective() 方法。返回已注册的图像，它将是一个 NumPy 数组。
- en: If the number of keypoint matches is less than the minimum number you stipulated
    at the start of the program, the image *may not* be properly aligned. So, print
    a warning and return the original, nonregistered image. This will allow the main()
    function to continue looping through the folder images uninterrupted. If the registration
    is poor, the user will be aware something is wrong as the problem pair of images
    won’t be properly aligned in the blink comparator window. An error message will
    also appear in the shell.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果关键点匹配数少于你在程序开始时设定的最小数目，图像*可能没有*正确对齐。因此，打印一个警告并返回原始的、未注册的图像。这将允许 main() 函数继续不间断地循环处理文件夹中的图像。如果配准效果不好，用户将能察觉到问题，因为问题图像对不会在闪烁比较器窗口中正确对齐。错误信息也会出现在命令行中。
- en: '[PRE12]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '**Building the Blink Comparator**'
  id: totrans-140
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**构建闪烁比较器**'
- en: '[Listing 5-7](ch05.xhtml#ch05list7) defines a function to run the blink comparator
    and then calls main() if the program is run in stand-alone mode. The blink() function
    loops through a specified range, showing first the registered image and then the
    second image, both in the same window. It shows each image for only one-third
    of a second, Clyde Tombaugh’s preferred frequency when using a blink comparator.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5-7](ch05.xhtml#ch05list7) 定义了一个运行闪烁比较器的函数，并在程序以独立模式运行时调用 main()。blink()
    函数会在指定范围内循环，先显示注册后的图像，再显示第二张图像，且都显示在同一个窗口中。每张图像只显示三分之一秒，这是 Clyde Tombaugh 使用闪烁比较器时偏好的频率。'
- en: '[PRE13]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 5-7: Defining a function to blink images on and off'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5-7：定义一个函数以实现图像闪烁效果
- en: 'Define the blink() function with four parameters: two image files, a window
    name, and the number of blinks to perform. Start a for loop with a range set to
    the number of blinks. Since you don’t need access to the running index, use a
    single underscore (_) to indicate the use of an insignificant variable. As mentioned
    previously in this chapter, this will prevent code-checking programs from raising
    an “unused variable” warning.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 blink() 函数，包含四个参数：两个图像文件、一个窗口名称和需要执行的闪烁次数。用一个范围值设置一个 for 循环，循环次数等于闪烁的次数。由于你不需要访问运行中的索引，因此可以使用一个下划线
    (_) 来表示该变量是无关紧要的。正如本章前面提到的，这可以防止代码检查程序引发“未使用的变量”警告。
- en: Now call OpenCV’s imshow() method and pass it the window name and the first
    image. This will be the *registered* first image. Then pause the program for 330
    milliseconds, the amount of time recommended by Clyde Tombaugh himself.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在调用 OpenCV 的 imshow() 方法，并传入窗口名称和第一张图片。这将是*注册的*第一张图片。然后暂停程序 330 毫秒，这是 Clyde
    Tombaugh 自己推荐的时间。
- en: Repeat the previous two lines of code for the second image. Because the two
    images are aligned, the only thing that will change in the window are transients.
    If only one image contains a transient, it will appear to blink on and off. If
    both images capture the transient, it will appear to dance back and forth.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 对第二张图像重复前两行代码。由于两张图像已经对齐，窗口中唯一会变化的就是瞬态。如果只有一张图像包含瞬态，它将会出现闪烁的效果。如果两张图像都捕捉到瞬态，它将会表现出来回跳动的效果。
- en: End the program with the standard code that lets it run in stand-alone mode
    or be imported as a module.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标准代码结束程序，以便它能够在独立模式下运行或作为模块导入。
- en: '***Using the Blink Comparator***'
  id: totrans-148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用闪烁比较器***'
- en: Before you run *blink_comparator.py*, dim your room lights to simulate looking
    through the device’s eyepieces. Then launch the program. You should first see
    two obvious bright dots flashing near the center of the image. In the next pair
    of images, the same dots will become very small—only a pixel across—but you should
    still be able to detect them.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行*blink_comparator.py*之前，先将房间的灯光调暗，模拟通过设备目镜观察的情况。然后启动程序。你应该首先看到图像中心附近闪烁的两个明显亮点。在下一对图像中，这些点会变得非常小——只有一个像素大小——但你应该仍然能检测到它们。
- en: The third loop will show the same small transient, only this time the second
    image will be brighter overall than the first. You should still be able to find
    the transient, but it will be much more difficult. This is why Tombaugh had to
    carefully take and develop the images to a consistent exposure.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 第三轮将显示相同的小型瞬态，只不过这次第二张图片的整体亮度会比第一张更亮。你应该仍然能够找到这个瞬态，但会更难以发现。这就是为什么汤博曾经需要小心地拍摄并冲洗图像，以确保曝光一致。
- en: The fourth loop contains a single transient, shown in the left image. It should
    blink on and off rather than dance back and forth as in the previous images.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 第四轮包含一个单一的瞬态，显示在左侧的图像中。它应该是闪烁的，而不是像之前的图像那样来回跳动。
- en: 'The fifth image pair represents control images with no transients. This is
    what the astronomer would see almost all the time: disappointing static star fields.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 第五对图像是控制图像，没有瞬态。这是天文学家几乎一直看到的：令人失望的静态星空。
- en: The final loop uses negative versions of the first image pair. The bright transient
    appears as flashing black dots. This is the type of image Clyde Tombaugh used,
    as it saved time. Since a black dot is as easy to spot as a white one, he felt
    no need to print positive images for each negative.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一轮使用的是第一对图像的负片版本。亮的瞬态显示为闪烁的黑点。这是克莱德·汤博用过的图像类型，因为这样可以节省时间。由于黑点和白点一样容易被发现，他认为没有必要为每张负片打印正片。
- en: If you look along the left side of the registered negative image, you’ll see
    a black stripe that represents the amount of translation needed to align the images
    ([Figure 5-10](ch05.xhtml#ch05fig10)). You won’t notice this on the positive images
    because it blends in with the black background.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看注册的负片图像的左侧，你会看到一条黑色条纹，表示对齐图像所需的平移量（[图 5-10](ch05.xhtml#ch05fig10)）。你在正片图像中不会注意到这一点，因为它与黑色背景融为一体。
- en: '![Image](../images/fig05_10.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig05_10.jpg)'
- en: 'Figure 5-10: The negative image, 6_bright_transient_neg_left_registered.png'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-10：负片图像，6_bright_transient_neg_left_registered.png
- en: 'In all the loops, you may notice a dim star blinking in the upper-left corner
    of each image pair. This is not a transient but a false positive caused by an
    *edge artifact*. An edge artifact is a change to an image caused by image misalignment.
    An experienced astronomer would ignore this dim star because: it occurs very close
    to the edge of the image, and the possible transient doesn’t move between images
    but just dims.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有的轮次中，你可能会注意到每一对图像的左上角有一颗暗淡的星星在闪烁。这不是瞬态，而是由*边缘伪影*引起的假阳性。边缘伪影是图像错位导致的图像变化。经验丰富的天文学家会忽略这颗暗星，因为：它发生在图像的边缘附近，而且可能的瞬态在不同图像之间并没有移动，只是变暗了。
- en: You can see the cause of this false positive in [Figure 5-11](ch05.xhtml#ch05fig11).
    Because only part of a star is captured in the first frame, its brightness is
    reduced relative to the same star in the second image.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[图 5-11](ch05.xhtml#ch05fig11)中看到这个假阳性的原因。因为在第一帧中只捕捉到了星星的一部分，相比第二张图中的同一颗星星，其亮度降低了。
- en: '![Image](../images/fig05_11.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig05_11.jpg)'
- en: 'Figure 5-11: Registering a truncated star in Image 1 results in a noticeably
    dimmer star than in Image 2'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-11：在图像 1 中注册一个截断的星星，导致星星的亮度明显比图像 2 中的暗。
- en: Humans can handle edge effects intuitively, but computers require explicit rules.
    In the next project, you’ll address this issue by excluding the edges of images
    when searching for transients.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 人类能够直观地处理边缘效应，但计算机需要明确的规则。在下一个项目中，你将通过在寻找瞬态时排除图像的边缘来解决这个问题。
- en: '**Project #8: Detecting Astronomical Transients with Image Differencing**'
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**项目 #8：通过图像差异检测天文瞬态**'
- en: Blink comparators, once considered as important as telescopes, now sit idly
    gathering dust in museums. Astronomers no longer need them, as modern image-differencing
    techniques are much better at detecting moving objects than human eyes. Today,
    every part of Clyde Tombaugh’s work would be done by computers.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 闪光比较仪曾被认为与望远镜同样重要，但现在它们安静地摆放在博物馆里积满灰尘。天文学家们不再需要它们，因为现代的图像差异化技术比人眼更擅长检测移动物体。如今，克莱德·汤博的每一项工作都将由计算机完成。
- en: In this project, let’s pretend you’re a summer intern at an observatory. Your
    job is to produce a digital workflow for an ancient astronomer still clinging
    to his rusty blink comparator.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，假设你是一个天文台的暑期实习生。你的任务是为一位仍在使用生锈的闪光比较仪的古老天文学家创建一个数字化工作流。
- en: THE OBJECTIVE
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 目标
- en: Write a Python program that takes two registered images and highlights any differences
    between them.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个 Python 程序，接受两张已注册的图像，并突出显示它们之间的任何差异。
- en: '***The Strategy***'
  id: totrans-167
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***策略***'
- en: Instead of an algorithm that blinks the images, you now want one that automatically
    finds the transients. This process will still require registered images, but for
    convenience, just use the ones already produced in Project 7.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在需要的是一个自动寻找瞬态物体的算法，而不是一个简单的闪烁图像的算法。这个过程仍然需要已注册的图像，但为了方便起见，可以直接使用项目 7 中已经生成的图像。
- en: Detecting differences between images is a common enough practice that OpenCV
    ships with an absolute difference method, absdiff(), dedicated to this purpose.
    It takes the per-element difference between two arrays. But just detecting the
    differences isn’t enough. Your program will need to recognize that a difference
    exists and show the user only the images containing transients. After all, astronomers
    have more important things to do, like demoting planets!
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 检测图像之间的差异是一个常见的操作，OpenCV 自带了一个专门用于此目的的绝对差异方法 absdiff()。它计算两个数组之间的逐元素差异。但仅仅检测差异还不够。你的程序需要识别出差异的存在，并只显示包含瞬态物体的图像。毕竟，天文学家有更重要的事情要做，比如将行星降级！
- en: Because the objects you’re looking for rest on a black background and matching
    bright objects are removed, any bright object remaining after differencing is
    worth noting. And since the odds of having more than one transient in a star field
    are astronomically low, flagging one or two differences should be enough to get
    an astronomer’s attention.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你要找的物体位于黑色背景上，且匹配的亮物体已经被去除，所以在差异化过程中剩下的任何亮物体都值得注意。由于在星空中出现多个瞬态物体的几率极低，标记一到两个差异应该足以引起天文学家的注意。
- en: '***The Transient Detector Code***'
  id: totrans-171
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***瞬态检测器代码***'
- en: The following *transient_detector.py* code will automate the process of detecting
    transients in astronomical images. Find it in the *Chapter_5* folder from the
    website. To avoid duplicating code, the program uses the images already registered
    by *blink_comparator.py*, so you’ll need the *night_1_registered_transients* and
    *night_2* folders in the directory for this project (see [Figure 5-3](ch05.xhtml#ch05fig3)).
    As in the previous project, keep the Python code in the folder *above* these two
    folders.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 以下的*transient_detector.py* 代码将自动化地检测天文图像中的瞬态物体。你可以在网站的*Chapter_5* 文件夹中找到它。为了避免代码重复，程序使用了*blink_comparator.py*
    已经注册的图像，因此你需要在项目目录中包含*night_1_registered_transients* 和 *night_2* 文件夹（见[图 5-3](ch05.xhtml#ch05fig3)）。和之前的项目一样，保持
    Python 代码文件位于这两个文件夹的*上层*文件夹。
- en: '**Importing Modules and Assigning a Constant**'
  id: totrans-173
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**导入模块并分配常量**'
- en: '[Listing 5-8](ch05.xhtml#ch05list8) imports the modules needed to run the program
    and assigns a pad constant to manage edge artifacts (see [Figure 5-11](ch05.xhtml#ch05fig11)).
    The pad represents a small distance, measured perpendicular to the image’s edges,
    that you want to exclude from the analysis. Any objects detected between the edge
    of the image and the pad will be ignored.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5-8](ch05.xhtml#ch05list8) 导入了运行程序所需的模块，并分配了一个用于管理边缘伪影的常量（见[图 5-11](ch05.xhtml#ch05fig11)）。这个常量代表一个小的距离，垂直于图像的边缘测量，用来排除在分析中的区域。任何在图像边缘和这个常量之间检测到的物体将被忽略。'
- en: '[PRE14]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 5-8: Importing modules and assigning a constant to manage edge effects'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5-8：导入模块并分配常量以管理边缘效应
- en: You’ll need all the modules used in the previous project except for NumPy, so
    import them here. Set the pad distance to 5 pixels. This value may change slightly
    with different datasets. Later, you’ll draw a rectangle around the edge space
    within the image so you can see how much area this parameter is excluding.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要导入上一个项目中使用的所有模块，除了 NumPy，因此在这里导入它们。将填充距离设置为 5 像素。这个值可能会因数据集的不同而略有变化。稍后，你将在图像的边缘区域画一个矩形，这样你就可以看到这个参数排除了多少区域。
- en: '**Detecting and Circling Transients**'
  id: totrans-178
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**检测并圈出暂态**'
- en: '[Listing 5-9](ch05.xhtml#ch05list9) defines a function you’ll use to find and
    circle up to two transients in each image pair. It will ignore transients in the
    padded area.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5-9](ch05.xhtml#ch05list9) 定义了一个函数，你将用它来找到并圈出每对图像中的最多两个暂态。它会忽略填充区域中的暂态。'
- en: '[PRE15]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 5-9: Defining a function to detect and circle transients'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5-9：定义一个函数来检测并圈出暂态
- en: 'The find_transient() function has three parameters: the input image, an image
    representing the difference between the first and second input images (representing
    the *difference map*), and the PAD constant. The function will find the location
    of the brightest pixel in the difference map, draw a circle around it, and return
    the location along with a Boolean indicating that an object was found.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: find_transient() 函数有三个参数：输入图像、表示第一和第二个输入图像之间差异的图像（表示 *差异图*）以及 PAD 常量。该函数将找到差异图中最亮像素的位置，在其周围画一个圆，并返回该位置以及一个布尔值，指示是否找到了对象。
- en: Begin the function by setting a variable, named transient, to False. You’ll
    use this variable to indicate whether a transient has been discovered. As transients
    are rare in real life, its base state should be False.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 从设置一个名为 transient 的变量开始，初始值为 False。你将用这个变量来指示是否发现了暂态。由于现实生活中暂态比较少见，所以它的初始状态应为
    False。
- en: To apply the PAD constant and exclude the area near the edge of the image, you’ll
    need the limits of the image. Get these with the shape attribute, which returns
    a tuple of the image’s height and width.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应用 PAD 常量并排除图像边缘附近的区域，你需要获取图像的边界。通过 shape 属性可以获取这些信息，它返回图像的高度和宽度的元组。
- en: Use the height and width variables and the PAD constant to draw a white rectangle
    on the image variable using OpenCV’s rectangle() method. Later, this will show
    the user which parts of the image were ignored.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 使用高度和宽度变量以及 PAD 常量，使用 OpenCV 的 rectangle() 方法在图像变量上绘制一个白色矩形。稍后，这将向用户显示图像中哪些部分被忽略了。
- en: The diff_image variable is a NumPy array representing pixels. The background
    is black, and any “stars” that changed position (or appeared out of nowhere) between
    the two input images will be gray or white (see [Figure 5-12](ch05.xhtml#ch05fig12)).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: diff_image 变量是一个表示像素的 NumPy 数组。背景为黑色，两个输入图像之间位置发生变化（或突然出现）的任何“星星”将显示为灰色或白色（参见
    [图 5-12](ch05.xhtml#ch05fig12)）。
- en: '![Image](../images/fig05_12.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig05_12.jpg)'
- en: 'Figure 5-12: Difference image derived from the “bright transient” input images'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-12：由“亮暂态”输入图像导出的差异图
- en: To locate the brightest transient present, use OpenCV’s minMaxLoc() method,
    which returns the minimum and maximum pixel values in the image, along with their
    location tuple. Note that I’m naming the variables to be consistent with OpenCV’s
    mixed-case naming scheme (evident in names such as maxLoc). If you want to use
    something more acceptable to Python’s PEP8 style guide (*[https://www.python.org/dev/peps/pep-0008/](https://www.python.org/dev/peps/pep-0008/)*),
    feel free to use names like max_loc in place of maxLoc.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 要定位最亮的暂态，使用 OpenCV 的 minMaxLoc() 方法，它返回图像中的最小和最大像素值及其位置元组。请注意，我将变量命名为与 OpenCV
    的大小写命名约定一致（例如 maxLoc）。如果你希望使用更符合 Python PEP8 风格指南的命名方式（* [https://www.python.org/dev/peps/pep-0008/](https://www.python.org/dev/peps/pep-0008/)*），可以自由地使用像
    max_loc 这样的名称代替 maxLoc。
- en: You may have found a maximum value near the edge of the image, so run a conditional
    to exclude this case by ignoring values found in the area delimited by the PAD
    constant ➊. If the location passes, circle it on the image variable. Use a white
    circle with a radius of 10 pixels and a line width of 0.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能在图像的边缘附近找到了一个最大值，因此运行一个条件来排除这种情况，忽略在 PAD 常量 ➊ 限定的区域内找到的值。如果该位置通过，则在图像变量上圈出它。使用一个半径为
    10 像素、线宽为 0 的白色圆圈。
- en: If you’ve drawn a circle, then you’ve found a transient, so set the transient
    variable to True. This will trigger additional activity later in the program.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经画出了一个圆圈，那么你就找到了一个暂态，因此将 transient 变量设置为 True。这将在程序稍后的部分触发额外的操作。
- en: End the function by returning the transient and maxLoc variables.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 通过返回瞬时天体和 maxLoc 变量来结束函数。
- en: '**NOTE**'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The minMaxLoc() method is susceptible to noise, such as false positives, as
    it works on individual pixels. Normally, you would first run a preprocessing step,
    like blurring, to remove spurious pixels. This can cause you to miss dim astronomical
    objects, however, which can be indistinguishable from noise in a single image.*'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '*minMaxLoc() 方法容易受到噪声（例如假阳性）的影响，因为它作用于单个像素。通常，你会首先运行一个预处理步骤，比如模糊处理，以去除多余的像素。然而，这也可能导致你错过较暗的天体，这些天体在单张图像中可能无法与噪声区分开来。*'
- en: '**Preparing Files and Folders**'
  id: totrans-195
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**准备文件和文件夹**'
- en: '[Listing 5-10](ch05.xhtml#ch05list10) defines the main() function, creates
    lists of the filenames in the input folders, and assigns the folder paths to variables.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5-10](ch05.xhtml#ch05list10) 定义了 main() 函数，创建了输入文件夹中文件名的列表，并将文件夹路径分配给变量。'
- en: '[PRE16]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 5-10: Defining main(), listing the folder contents, and assigning path
    variables'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5-10：定义 main() 函数，列出文件夹内容，并分配路径变量
- en: Define the main() function. Then, just as you did in [Listing 5-2](ch05.xhtml#ch05list2)
    on [page 100](ch05.xhtml#page_100), list the contents of the folders containing
    the input images and assign their paths to variables. You’ll use an existing folder
    to hold images containing identified transients.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 main() 函数。然后，就像你在 [列表 5-2](ch05.xhtml#ch05list2) 中在 [第 100 页](ch05.xhtml#page_100)
    所做的那样，列出包含输入图像的文件夹内容，并将它们的路径分配给变量。你将使用现有文件夹来存放包含已识别瞬时天体的图像。
- en: '**Looping Through Images and Calculating Absolute Difference**'
  id: totrans-200
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**遍历图像并计算绝对差异**'
- en: '[Listing 5-11](ch05.xhtml#ch05list11) starts the for loop through the image
    pairs. The function reads corresponding image pairs as grayscale arrays, calculates
    the difference between the images, and shows the result in a window. It then calls
    the find_transient() function on the difference image.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5-11](ch05.xhtml#ch05list11) 启动了一个 for 循环，遍历图像对。该函数读取对应的图像对，作为灰度数组，计算图像之间的差异，并在一个窗口中显示结果。然后，它在差异图像上调用
    find_transient() 函数。'
- en: '[PRE17]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 5-11: Looping through the images and finding the transients'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5-11：遍历图像并找到瞬时天体
- en: Start a for loop that iterates through the images in the *night1_files* list.
    The program is designed to work on *positive* images, so use image slicing ([:-1])
    to exclude the negative image. Use enumerate() to get a counter; name it i, rather
    than _, since you’ll use it as an index later.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 启动一个 for 循环，遍历 *night1_files* 列表中的图像。该程序设计用于处理 *正向* 图像，因此使用图像切片（[:-1]）来排除负向图像。使用
    enumerate() 获取一个计数器；命名为 i，而不是 _，因为稍后你将用它作为索引。
- en: To find the differences between images, just call the cv.absdiff() method and
    pass it the variables for the two images. Show the results for two seconds before
    continuing the program.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找图像之间的差异，只需调用 cv.absdiff() 方法，并传递两个图像的变量。显示结果两秒钟后再继续程序。
- en: Since you’re going to blank out the brightest transient, first make a copy of
    diff_imgs1_2. Name this copy temp, for temporary. Now, call the find_transient()
    function you wrote earlier. Pass it the first input image, the difference image,
    and the PAD constant. Use the results to update the transient variable and to
    create a new variable, transient_loc1, that records the location of the brightest
    pixel in the difference image.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你将要遮盖最亮的瞬时天体，首先请复制 diff_imgs1_2。将此副本命名为 temp，表示临时文件。现在，调用你之前编写的 find_transient()
    函数。传递给它第一个输入图像、差异图像以及 PAD 常量。使用结果更新瞬时天体变量，并创建一个新变量 transient_loc1，用来记录差异图像中最亮像素的位置。
- en: The transient may or may not have been captured in both images taken on successive
    nights. To see if it was, obliterate the bright spot you just found by covering
    it with a black circle. Do this on the temp image by using black as the color
    and a line width of –1, which tells OpenCV to fill the circle. Continue to use
    a radius of 10, though you can reduce this if you’re concerned the two transients
    will be very close together.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 瞬时天体可能已经或尚未在连续两个晚上的图像中都被捕获。为了确认它是否被捕获，遮盖你刚才找到的亮点，使用黑色圆圈覆盖它。通过在 temp 图像上使用黑色作为颜色，并将线宽设置为
    -1，这会告诉 OpenCV 填充圆圈。继续使用半径 10，但如果你担心两个瞬时天体非常接近，也可以适当减小这个半径。
- en: Call the find_transient() function again but use a single underscore for the
    location variable, as you won’t be using it again. It’s unlikely there’ll be more
    than two transients present, and finding even one will be enough to open the images
    up to further scrutiny, so don’t bother looking for more.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 再次调用find_transient()函数，但对于位置变量使用单个下划线，因为你不会再使用它。瞬态的数量不太可能超过两个，甚至找到一个就足够让图像接受进一步检查，所以无需再寻找更多。
- en: '**Revealing the Transient and Saving the Image**'
  id: totrans-209
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**揭示瞬态并保存图像**'
- en: '[Listing 5-12](ch05.xhtml#ch05list12), still in the for loop of the main()
    function, displays the first input image with any transients circled, posts the
    names of the image files involved, and saves the image with a new filename. You’ll
    also print a log of the results for each image pair in the interpreter window.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单5-12](ch05.xhtml#ch05list12)，仍然是在main()函数的for循环中，显示第一张输入图像，并将任何瞬态用圆圈标出，发布涉及的图像文件名，并保存图像为新的文件名。你还将打印每对图像结果的日志到解释器窗口。'
- en: '[PRE18]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 5-12: Showing the circled transients, logging the results, and saving
    the results'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 清单5-12：显示标记了瞬态的图像，记录结果并保存结果
- en: 'Start a conditional that checks whether a transient was found. If this evaluates
    to True, print a message in the shell. For the four images evaluated by the for
    loop, you should get this result:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 启动一个条件语句，检查是否发现瞬态。如果评估结果为True，则在终端输出一条信息。对于for循环评估的四张图像，你应该得到以下结果：
- en: '[PRE19]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Posting a negative outcome shows that the program is working as expected and
    leaves no doubt that the images were compared.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 发布一个负结果显示程序按预期工作，并且不容置疑地证明图像已被比较。
- en: Next, post the names of the two images with a positive response on the img1
    array. Start by assigning a font variable for OpenCV ➊. For a listing of available
    fonts, search for *HersheyFonts* at *[https://docs.opencv.org/4.3.0/](https://docs.opencv.org/4.3.0/)*.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，发布两张在img1数组上有正响应的图像的文件名。首先为OpenCV分配一个字体变量➊。要查看可用字体的列表，可以在* [https://docs.opencv.org/4.3.0/](https://docs.opencv.org/4.3.0/)*上搜索*HersheyFonts*。
- en: Now call OpenCV’s putText() method and pass it the first input image, the filename
    of the image, a position, the font variable, a size, a color (white), a thickness,
    and a line type. The LINE_AA attribute creates an anti-aliased line. Repeat this
    code for the second image.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在调用OpenCV的putText()方法，传递第一张输入图像、图像的文件名、位置、字体变量、大小、颜色（白色）、厚度和线型。LINE_AA属性创建一个抗锯齿线条。对第二张图像重复这段代码。
- en: If you found two transients, you can show them both on the same image using
    OpenCV’s addWeighted() method. This method calculates the weighted sum of two
    arrays. The arguments are the first image and a weight, the second image and a
    weight, and a scalar that’s added to each sum. Use the first input image and the
    difference image, set the weights to 1 so that each image is used fully, and set
    the scalar to 0. Assign the result to a variable named blended.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找到了两个瞬态，可以使用OpenCV的addWeighted()方法将它们显示在同一张图像上。该方法计算两个数组的加权和。参数包括第一张图像及其权重，第二张图像及其权重，以及添加到每个和中的标量。使用第一张输入图像和差异图像，将权重设置为1，以便每张图像都被充分使用，并将标量设置为0。将结果赋值给名为blended的变量。
- en: Show the blended image in a window named Surveyed. [Figure 5-13](ch05.xhtml#ch05fig13)
    shows an example outcome for the “bright” transient.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个名为Surveyed的窗口中显示合成图像。[图5-13](ch05.xhtml#ch05fig13)展示了“明亮”瞬态的示例结果。
- en: '![Image](../images/fig05_13.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/fig05_13.jpg)'
- en: 'Figure 5-13: Example output window of transient_detector.py with the pad rectangle
    indicated by the arrow'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-13：瞬态检测器（transient_detector.py）的示例输出窗口，箭头指示了垫片矩形
- en: Note the white rectangle near the edges of the image. This represents the PAD
    distance. Any transients outside this rectangle were ignored by the program.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 注意图像边缘附近的白色矩形。这代表PAD距离。矩形外的瞬态被程序忽略。
- en: Save the blended image using the filename of the current input image plus “DETECTED”
    ➋. The dim transient in [Figure 5-13](ch05.xhtml#ch05fig13) would be saved as
    *1_bright_transient_left_registered_DECTECTED.png*. Write it to the *night_1_2_transients*
    folder, using the path3 variable.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 使用当前输入图像的文件名加上“DETECTED” ➋来保存合成图像。[图5-13](ch05.xhtml#ch05fig13)中的暗淡瞬态将被保存为*1_bright_transient_left_registered_DECTECTED.png*。将其写入*night_1_2_transients*文件夹，使用path3变量。
- en: If no transients were found, document the result in the shell window. Then end
    the program with the code to run it as a module or in stand-alone mode.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有找到瞬态，请在终端窗口中记录结果。然后，用代码结束程序，作为模块或独立模式运行。
- en: '***Using the Transient Detector***'
  id: totrans-225
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用瞬态检测器***'
- en: Imagine how happy Clyde Tombaugh would’ve been with your transient detector.
    It’s truly set-it-and-forget-it. Even the changing brightness between the third
    pair of images, so problematic with the blink comparator, is no challenge for
    this program.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，克莱德·汤博（Clyde Tombaugh）如果使用你的瞬态检测器会有多高兴。它真的是“设置并忘记”型。即使是第三对图像之间变化的亮度，这在闪光比较器中是个大问题，但对于这个程序来说毫无挑战。
- en: '**Summary**'
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter, you replicated an old-time blink comparator device and then
    updated the process using modern computer vision techniques. Along the way, you
    used the pathLib module to simplify working with directory paths, and you used
    a single underscore for insignificant, unused variable names. You also used OpenCV
    to find, describe, and match interesting features in images, align the features
    with homography, blend the images together, and write the result to a file.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你复制了一个老式的闪光比较器设备，并使用现代计算机视觉技术更新了这一过程。在这个过程中，你使用了 pathLib 模块简化了目录路径的操作，并且对不重要的未使用的变量名使用了单个下划线。你还使用了
    OpenCV 来寻找、描述和匹配图像中的有趣特征，使用单应性对齐这些特征，合成图像并将结果写入文件。
- en: '**Further Reading**'
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**进一步阅读**'
- en: '*Out of the Darkness: The Planet Pluto* (Stackpole Books, 2017), by Clyde Tombaugh
    and Patrick Moore, is the standard reference on the discovery of Pluto, told in
    the discoverer’s own words.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '*走出黑暗：冥王星行星*（Stackpole Books，2017年），由克莱德·汤博和帕特里克·摩尔（Patrick Moore）编写，是关于冥王星发现的标准参考书，讲述了发现者自己的故事。'
- en: '*Chasing New Horizons: Inside the Epic First Mission to Pluto* (Picador, 2018),
    by Alan Stern and David Grinspoon, records the monumental effort to finally send
    a spacecraft—which, incidentally, contained Clyde Tombaugh’s ashes—to Pluto.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '*追逐新视野：冥王星首次史诗任务的内幕*（Picador，2018年），由艾伦·斯特恩（Alan Stern）和大卫·格林斯彭（David Grinspoon）编写，记录了将宇宙飞船（顺便说一下，里面装有克莱德·汤博的遗
    ashes）送往冥王星的伟大努力。'
- en: '**Practice Project: Plotting the Orbital Path**'
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**实践项目：绘制轨道路径**'
- en: Edit the *transient_detector.py* program so that if the transient is present
    in both input image pairs, OpenCV draws a line connecting the two transients.
    This will reveal the transient’s orbital path against the background stars.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑 *transient_detector.py* 程序，使其在两个输入图像对中都有瞬态时，OpenCV 会绘制一条连接两个瞬态的线。这样可以揭示瞬态在背景星体中的轨道路径。
- en: This kind of information was key to the discovery of Pluto. Clyde Tombaugh used
    the distance Pluto traveled in the two discovery plates, along with the time between
    exposures, to verify that the planet was near Lowell’s predicted path and not
    just some asteroid orbiting closer to Earth.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这种信息对于冥王星的发现至关重要。克莱德·汤博通过冥王星在两张发现板之间的运动距离，以及曝光之间的时间，验证了这颗行星接近洛厄尔预测的轨道，而不仅仅是某颗靠近地球的小行星。
- en: You can find a solution, *practice_orbital_path.py*, in the appendix and in
    the *Chapter_5* folder.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在附录和 *Chapter_5* 文件夹中找到解决方案 *practice_orbital_path.py*。
- en: '**Practice Project: What’s the Difference?**'
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**实践项目：找出差异**'
- en: The feature matching you did in this chapter has broad-reaching applications
    beyond astronomy. For example, marine biologists use similar techniques to identify
    whale sharks by their spots. This improves the accuracy of the scientists’ population
    counts.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 你在本章中进行的特征匹配不仅在天文学领域具有广泛应用。例如，海洋生物学家使用类似的技术通过鲸鲨的斑点来识别它们。这提高了科学家们对鲸鲨种群数量的准确估算。
- en: In [Figure 5-14](ch05.xhtml#ch05fig14), something has changed between the left
    and right photos. Can you spot it? Even better, can you write Python programs
    that align and compare the two images and circle the change?
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [图 5-14](ch05.xhtml#ch05fig14) 中，左右照片之间有变化。你能找到吗？更棒的是，你能编写 Python 程序来对齐和比较这两张图像，并圈出变化的部分吗？
- en: '![Image](../images/fig05_14.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig05_14.jpg)'
- en: 'Figure 5-14: Spot the difference between the left and right images.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-14：找出左右图像之间的差异。
- en: The starting images can be found in the *montages* folder in the *Chapter_5*
    folder, downloadable from the book’s website. These are color images that you’ll
    need to convert to grayscale and align prior to object detection. You can find
    solutions, *practice_montage_aligner.py* and *practice_montage_difference_finder.py*,
    in the appendix and in the *montages* folder.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 起始图像可以在 *montages* 文件夹中的 *Chapter_5* 文件夹找到，这些图像可以从书籍官网下载。这些是彩色图像，你需要将其转换为灰度图像并在进行物体检测之前进行对齐。你可以在附录和
    *montages* 文件夹中找到解决方案 *practice_montage_aligner.py* 和 *practice_montage_difference_finder.py*。
- en: '**Challenge Project: Counting Stars**'
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**挑战项目：数星星**'
- en: According to *Sky and Telescope* magazine, there are 9,096 stars visible to
    the naked eye from both hemispheres (*[https://www.skyandtelescope.com/astronomy-resources/how-many-stars-night-sky-09172014/](https://www.skyandtelescope.com/astronomy-resources/how-many-stars-night-sky-09172014/)*).
    That’s a lot on its own, but if you look through a telescope, the number increases
    exponentially.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 根据*Sky and Telescope*杂志，从两半球裸眼可见的星星有9,096颗（*[https://www.skyandtelescope.com/astronomy-resources/how-many-stars-night-sky-09172014/](https://www.skyandtelescope.com/astronomy-resources/how-many-stars-night-sky-09172014/)*）。这个数字本身已经很多，但如果通过望远镜观察，星星的数量会呈指数级增长。
- en: To estimate large numbers of stars, astronomers survey small regions of the
    sky, use a computer program to count the stars, and then extrapolate the results
    to larger areas. For this challenge project, pretend you’re an assistant at Lowell
    Observatory and you’re on a survey team. Write a Python program that counts the
    number of stars in the image *5_no_transient_left.png*, used in Projects 7 and
    8.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 为了估算大量的星星，天文学家们会对天空的小区域进行调查，使用计算机程序计算星星数量，然后将结果外推到更大的区域。对于这个挑战项目，假设你是洛威尔天文台的助手，参与一个调查小组。编写一个Python程序，计算在项目7和8中使用的图像*5_no_transient_left.png*中星星的数量。
- en: For hints, search online for *how to count dots in an image with Python and
    OpenCV*. For a solution using Python and SciPy, see *[http://prancer.physics.louisville.edu/astrowiki/index.php/Image_processing_with_Python_and_SciPy](http://prancer.physics.louisville.edu/astrowiki/index.php/Image_processing_with_Python_and_SciPy)*.
    You may find your results improve if you divide the image into smaller parts.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 若需要提示，可以在线搜索*如何使用Python和OpenCV计算图像中的点数*。有关使用Python和SciPy的解决方案，参见*[http://prancer.physics.louisville.edu/astrowiki/index.php/Image_processing_with_Python_and_SciPy](http://prancer.physics.louisville.edu/astrowiki/index.php/Image_processing_with_Python_and_SciPy)*。如果将图像分成更小的部分，你可能会发现结果有所改善。
