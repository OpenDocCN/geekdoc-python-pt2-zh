<html><head></head><body>
<h2 class="h2" id="ch02"><span epub:type="pagebreak" id="page_19"/><strong><span class="big">2</span><br/>FINDING PALINGRAM SPELLS</strong></h2>
<div class="image1"><img src="../images/common01.jpg" alt="image"/></div>
<p class="noindent">Radar. Kayak. Rotator. Sexes. What do these words all have in common? They’re <em>palindromes</em>, words that are spelled the same forward and backward. Even better are <em>palingrams</em>, whole phrases that behave the same way. Napoleon is the author of the most famous palingram. When he first saw Elba, the island of his exile, he said, “Able was I ere I saw Elba.”</p>
<p class="indent">In 2011, DC Comics published an interesting story that made clever use of palingrams. The superhero sorceress Zatanna was cursed so that she could cast spells only by speaking palindromically. She managed to think up just enough two-word phrases like <em>nurses run</em>, <em>stack cats</em>, and <em>puff up</em> to defeat her sword-wielding attacker. This got me wondering: just how many “combative” palingrams are there? And are there better choices for Zatanna?</p>
<p class="indent"><span epub:type="pagebreak" id="page_20"/>In this chapter, you’ll load dictionary files from the internet and use Python to discover first palindromes and then the more complex palingrams in those files. Then you’ll use a tool called <span class="literal">cProfile</span> to analyze your palingram code so that you can make it more performant. Finally, you’ll sift through the palingrams to see how many have an “aggressive” nature.</p>
<h3 class="h3" id="lev33"><strong>Finding and Opening a Dictionary</strong></h3>
<p class="noindent">All the projects in this chapter require a listing of words in a text file format, commonly referred to as a <em>dictionary file</em>, so let’s start by learning how to load one.</p>
<p class="indent">Despite their name, dictionary files contain only words—no pronunciation, syllable count, definitions, and so on. This is good news, as those things would just get in our way. And even better, dictionary files are available online for free.</p>
<p class="indent">You can find suitable dictionary files at the locations listed in <a href="ch02.xhtml#ch02tab1">Table 2-1</a>. Download one of the files or, if it opens directly, copy and paste the contents into a text editor like Notepad or WordPad (TextEdit on macOS) and save it as a <em>.txt</em> file. Keep the dictionary in the same folder as the Python code. I used the <em>2of4brif.txt</em> file to prepare this project. It can be found in the downloadable <em>12dicts-6.0.2.zip</em> file on the website listed first in <a href="ch02.xhtml#ch02tab1">Table 2-1</a>.</p>
<p class="tabcap" id="ch02tab1"><strong>Table 2-1:</strong> Downloadable Dictionary Files</p>
<table class="topbot-d">
<thead>
<tr>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>File</strong></p></td>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Number of words</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><em><a href="http://wordlist.aspell.net/12dicts/">http://wordlist.aspell.net/12dicts/</a></em></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">60,388</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><em><a href="https://inventwithpython.com/dictionary.txt">https://inventwithpython.com/dictionary.txt</a></em></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">45,000</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><em><a href="http://www-personal.umich.edu/~jlawler/wordlist.html">http://www-personal.umich.edu/~jlawler/wordlist.html</a></em></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">69,903</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-ba"><p class="taba"><em><a href="http://greenteapress.com/thinkpython2/code/words.txt">http://greenteapress.com/thinkpython2/code/words.txt</a></em></p></td>
<td style="vertical-align: top;" class="table-ba"><p class="taba">113,809</p></td>
</tr>
</tbody>
</table>
<p class="indent">In addition to the files in <a href="ch02.xhtml#ch02tab1">Table 2-1</a>, Unix and Unix-like operating systems come packaged with a large newline-delimited word file of more than 200,000 words. It is usually stored in <em>/usr/share/dict/words</em> or <em>/usr/dict/words</em>. On Debian GNU/Linux, word lists are in <em>/usr/share/opendict/dictionaries</em>. The macOS dictionaries are generally found in <em>/Library/Dictionaries</em>, and non-English dictionaries are included. You may need to do an online search for your operating system and version to find the exact directory path if you want to use one of these files.</p>
<p class="indent">Some dictionary files exclude <em>a</em> and <em>I</em> as words. Others may include every letter in the dictionary as a single word “header” (such as <em>d</em> at the start of words beginning with <em>d</em>). We’ll ignore one-letter palindromes in these projects, so these issues shouldn’t be a problem.</p>
<h4 class="h4" id="lev34"><span epub:type="pagebreak" id="page_21"/><strong><em>Handling Exceptions When Opening Files</em></strong></h4>
<p class="noindent">Whenever you load an external file, your program should automatically check for I/O issues, like missing files or incorrect filenames, and let you know if there is a problem.</p>
<p class="indent">Use the following <span class="literal">try</span> and <span class="literal">except</span> statements to catch and handle <em>exceptions</em>, which are errors detected during execution:</p>
<p class="programs"><span class="ent">➊</span> try:<br/>    <span class="ent">➋</span> with open(file) as in_file:<br/>           <span class="codeitalic1">do something</span><br/>   except IOError<span class="ent">➌</span> as e:<br/>    <span class="ent">➍</span> print("{}\nError opening {}. Terminating program.".format(e, file),<br/>              file=sys.stderr)   <br/>    <span class="ent">➎</span> sys.exit(1)</p>
<p class="indent">The <span class="literal">try</span> clause is executed first <span class="ent">➊</span>. The <span class="literal">with</span> statement will automatically close the file after the nested block of code, regardless of how the block exits <span class="ent">➋</span>. Closing files prior to terminating a process is a good practice. If you don’t close those files, you could run out of file descriptors (mainly a problem with large scripts that run for a long time), lock the file from further access in Windows, corrupt the files, or lose data if you are writing to the file.</p>
<p class="indent">If something goes wrong and if the type of error matches the exception named after the <span class="literal">except</span> keyword <span class="ent">➌</span>, the rest of the <span class="literal">try</span> clause is skipped, and the <span class="literal">except</span> clause is executed <span class="ent">➍</span>. If nothing goes wrong, the <span class="literal">try</span> clause is executed, and the <span class="literal">except</span> clause is skipped. The <span class="literal">print</span> statement in the <span class="literal">except</span> clause lets you know there’s a problem, and the <span class="literal">file=sys.stderr</span> argument colors the error statement red in the IDLE interpreter window.</p>
<p class="indent">The <span class="literal">sys.exit(1)</span> <span class="ent">➎</span> statement is used to terminate the program. The <span class="literal">1</span> in <span class="literal">sys.exit(1)</span> indicates that the program experienced an error and did not close successfully.</p>
<p class="indent">If an exception occurs that <em>doesn’t</em> match the named exception in the <span class="literal">except</span> clause, it is passed to any outer <span class="literal">try</span> statements or the main program execution. If no handler is found, the <em>unhandled exception</em> causes the program to stop with a standard “traceback” error message.</p>
<h4 class="h4" id="lev35"><strong><em>Loading the Dictionary File</em></strong></h4>
<p class="noindent"><a href="ch02.xhtml#ch02list1">Listing 2-1</a> loads a dictionary file as a list. Manually enter this script or download it as <em>load_dictionary.py</em> from <em><a href="https://nostarch.com/impracticalpython/">https://nostarch.com/impracticalpython/</a></em>.</p>
<p class="indent">You can import this file into other programs as a module and run it with a one-line statement. Remember, a module is simply a Python program that can be used in another Python program. As you’re probably aware, modules represent a form of <em>abstraction</em>. Abstraction means you don’t have to worry about all the coding details. A principle of abstraction is <em>encapsulation</em>, the act of hiding the details. We encapsulate the file-loading code in a module so you don’t have to see or worry about the detailed code in another program.</p>
<p class="margin"><span epub:type="pagebreak" id="page_22"/><em>load_dictionary.py</em></p>
<p class="programs">   """Load a text file as a list.<br/><br/>   Arguments:<br/>   -text file name (and directory path, if needed)<br/><br/>   Exceptions:<br/>   -IOError if filename not found.<br/><br/>   Returns:<br/>   -A list of all words in a text file in lower case.<br/><br/>   Requires-import sys<br/><br/>   """<br/><span class="ent">➊</span> import sys<br/><br/><span class="ent">➋</span> def load(file):<br/>       """Open a text file &amp; return a list of lowercase strings."""<br/>       try:<br/>           with open(file) as in_file:<br/>            <span class="ent">➌</span> loaded_txt = in_file.read().strip().split('\n')<br/>            <span class="ent">➍</span> loaded_txt = [x.lower() for x in loaded_txt]<br/>               return loaded_txt<br/>       except IOError as e:<br/>        <span class="ent">➎</span> print("{}\nError opening {}. Terminating program.".format(e, file),<br/>               file=sys.stderr)<br/>           sys.exit(1)</p>
<p class="listing" id="ch02list1"><em>Listing 2-1: The module for loading a dictionary file as a list</em></p>
<p class="indent">After the docstring, we import system functions with <span class="literal">sys</span> so that our error-handling code will work <span class="ent">➊</span>. The next block of code defines a function based on the previous file-opening discussion <span class="ent">➋</span>. The function takes a filename as an argument.</p>
<p class="indent">If no exceptions are raised, the text file’s whitespace is removed, and its items are split into separate lines and added to a list <span class="ent">➌</span>. We want each word to be a separate item in the list, before the list is returned. And since case matters to Python, the words in the list are converted to lowercase via <em>list comprehension</em> <span class="ent">➍</span>. List comprehension is a shorthand way to convert a list, or other iterable, into another list. In this case, it replaces a <span class="literal">for</span> loop.</p>
<p class="indent">If an I/O error is encountered, the program displays the standard error message, designated by the <span class="literal">e</span>, along with a message describing the event and informing the user that the program is ending <span class="ent">➎</span>. The <span class="literal">sys.exit(1)</span> command then terminates the program.</p>
<p class="indent">This code example is for illustrative purposes, to show how these steps work together. Generally, you wouldn’t call <span class="literal">sys.exit()</span> from a module, as you may want your program to do something—like write a log file—prior to terminating. In later chapters, we’ll move both the <span class="literal">try</span>-<span class="literal">except</span> blocks and <span class="literal">sys.exit()</span> into a <span class="literal">main()</span> function for clarity and control.</p>
<h3 class="h3a" id="lev36"><span epub:type="pagebreak" id="page_23"/><strong>Project #2: Finding Palindromes</strong></h3>
<p class="noindent">You’ll start by finding single-word palindromes in a dictionary and then move on to the more difficult palindromic phrases.</p>
<div class="sidebar">
<p class="sidebart"><strong>THE OBJECTIVE</strong></p>
<p class="spara">Use Python to search an English language dictionary file for palindromes.</p>
</div>
<h4 class="h4" id="lev37"><strong><em>The Strategy and Pseudocode</em></strong></h4>
<p class="noindent">Before you get into the code, step back and think about what you want to do conceptually. Identifying palindromes is easy: simply compare a word to itself sliced backward. Here is an example of slicing a word front to back and then back to front:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">word = 'NURSES'</span><br/>&gt;&gt;&gt; <span class="codestrong1">word[:]</span><br/>'NURSES'<br/>&gt;&gt;&gt; <span class="codestrong1">word[::-1]</span><br/>'SESRUN'</p>
<p class="indent">If you don’t provide values when slicing a string (or any sliceable type), the default is to use the start of the string, the end of the string, and a positive step equal to <span class="literal">1</span>.</p>
<p class="indent"><a href="ch02.xhtml#ch02fig1">Figure 2-1</a> illustrates the reverse slicing process. I’ve provided a starting position of <span class="literal">2</span> and a step of <span class="literal">–1</span>. Because no end index is provided (there is no index or space between the colons), the implication is to go backward (because the index step is <span class="literal">–1</span>) until there are no more characters left.</p>
<div class="image"><a id="ch02fig1"/><img src="../images/f0023-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 2-1: An example of negative slicing for</em> <span class="codeitalic">word = 'NURSES'</span></p>
<p class="indent"><span epub:type="pagebreak" id="page_24"/>Negative slicing doesn’t behave exactly the same way as forward slicing, and the positive and negative position values and endpoints are asymmetrical. This can lead to confusion, so let’s restrict our negative slicing to the simple <span class="literal">[::-1]</span> format.</p>
<p class="indent">Finding palindromes in the dictionary will take fewer lines of code than loading the dictionary file! Here’s the pseudocode:</p>
<p class="programs">Load digital dictionary file as a list of words<br/>Create an empty list to hold palindromes<br/>Loop through each word in the word list:<br/>    If word sliced forward is the same as word sliced backward:<br/>        Append word to palindrome list<br/>Print palindrome list</p>
<h4 class="h4" id="lev38"><strong><em>The Palindrome Code</em></strong></h4>
<p class="noindent"><a href="ch02.xhtml#ch02list2">Listing 2-2</a>, <em>palindromes.py</em>, reads in an English dictionary file, identifies which words are palindromes, saves them to a list, and prints the list as stacked items. You can download this code from the book’s resources at <em><a href="https://www.nostarch.com/impracticalpython/">https://www.nostarch.com/impracticalpython/</a></em>. You will also need <em>load_dictionary.py</em> and a dictionary file; save all three files in the same folder.</p>
<p class="margin"><em>palindromes.py</em></p>
<p class="programs">   """Find palindromes (letter palingrams) in a dictionary file."""<br/><span class="ent">➊</span> import load_dictionary<br/><span class="ent">➋</span> word_list = load_dictionary.load('2of4brif.txt')<br/><span class="ent">➌</span> pali_list = []<br/><br/><span class="ent">➍</span> for word in word_list:<br/>       if len(word) &gt; 1 and word == word[::-1]:<br/>           pali_list.append(word)<br/><br/>   print("\nNumber of palindromes found = {}\n".format(len(pali_list)))<br/><span class="ent">➎</span> print(*pali_list, sep='\n')</p>
<p class="listing" id="ch02list2"><em>Listing 2-2: Finds palindromes in loaded dictionary file</em></p>
<p class="indent">Start by importing <em>load_dictionary.py</em> as a module <span class="ent">➊</span>. Note that the <em>.py</em> extension is not used for importing. Also, the module is in the same folder as this script, so we don’t have to specify a directory path to the module. And since the module contains the required <span class="literal">import sys</span> line, we don’t need to repeat it here.</p>
<p class="indent">To populate our word list with words from the dictionary, call the <span class="literal">load()</span> function in the <span class="literal">load_dictionary</span> module with dot notation <span class="ent">➋</span>. Pass it the name of the external dictionary file. Again, you don’t need to specify a path if the dictionary file is in the same folder as the Python script. The filename you use may be different depending on the dictionary you downloaded.</p>
<p class="indent">Next, create an empty list to hold the palindromes <span class="ent">➌</span> and start looping through every word in <span class="literal">word_list</span> <span class="ent">➍</span>, comparing the forward slice to the reverse slice. If the two slices are identical, append the word to <span class="literal">pali_list</span>. Notice that only words with more than one letter are allowed (<span class="literal">len(word) &gt; 1</span>), which follows the strictest definition of a palindrome.</p>
<p class="indent"><span epub:type="pagebreak" id="page_25"/>Finally, print the palindromes in an attractive way—stacked and with no quotation marks or commas <span class="ent">➎</span>. You can accomplish this by looping through every word in the list, but there is a more efficient way to do it. You can use the <em>splat</em> operator (designated by the <span class="literal">*</span>), which takes a list as input and expands it into positional arguments in the function call. The last argument is the separator used between multiple list values for printing. The default separator is a space (<span class="literal">sep=' '</span>), but instead, print each item on a new line (<span class="literal">sep='\n'</span>).</p>
<p class="indent">Single-word palindromes are rare, at least in English. Using a 60,000-word dictionary file, you’ll be lucky to find about 60, or only 0.1 percent of all the words. Despite their rarity, however, they’re easy enough to find with Python. So, let’s move on to the more interesting, and more complicated, palingrams.</p>
<h3 class="h3a" id="lev39"><strong>Project #3: Finding Palingrams</strong></h3>
<p class="noindent">Finding palingrams requires a bit more effort than finding one-word palindromes. In this section, we’ll plan and write code to find word-pair palingrams.</p>
<div class="sidebar">
<p class="sidebart"><strong>THE OBJECTIVE</strong></p>
<p class="spara">Use Python to search an English language dictionary for two-word palingrams. Analyze and optimize the palingram code using the cProfile tool.</p>
</div>
<h4 class="h4" id="lev40"><strong><em>The Strategy and Pseudocode</em></strong></h4>
<p class="noindent">Example word-pair palingrams are <em>nurses run</em> and <em>stir grits</em>. (In case you’re wondering, grits are a ground-corn breakfast dish, similar to Italian polenta.)</p>
<p class="indent">Like palindromes, palingrams read the same forward and backward. I like to think of these as a <em>core</em> word, like <em>nurses</em>, from which a <em>palindromic sequence</em> and <em>reversed word</em> are derived (see <a href="ch02.xhtml#ch02fig2">Figure 2-2</a>).</p>
<div class="image"><a id="ch02fig2"/><img src="../images/f0025-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 2-2: Dissecting word-pair palingrams</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_26"/>Our program will examine the core word. Based on <a href="ch02.xhtml#ch02fig2">Figure 2-2</a>, we can make the following inferences about the core word:</p>
<ol>
<li class="noindent">It can have either an odd or even number of letters.</li>
<li class="noindent">One contiguous part of the word spells a real word when read backward.</li>
<li class="noindent">This contiguous part can occupy part or all of the core word.</li>
<li class="noindent">The other contiguous part contains a palindromic sequence of letters.</li>
<li class="noindent">The palindromic sequence can occupy part or all of the core word.</li>
<li class="noindent">The palindromic sequence does not have to be a real word (unless it occupies the <em>whole</em> word).</li>
<li class="noindent">The two parts cannot overlap or share letters.</li>
<li class="noindent">The sequence is reversible.</li>
</ol>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>If the reversed word occupies the whole core word and is not a palindrome, it’s called a</em> semordnilap<em>. A semordnilap is similar to a palindrome except for one key difference: rather than spelling the</em> same <em>word when read backward, it spells a</em> different <em>word. Examples are</em> bats <em>and</em> stab<em>, and</em> wolf <em>and</em> flow<em>. Semordnilap, by the way, is</em> palindromes <em>spelled backward.</em></p>
</div>
<p class="indent"><a href="ch02.xhtml#ch02fig3">Figure 2-3</a> represents an arbitrary word of six letters. The Xs represent the part of the word that <em>might</em> form a real word when read backward (like <em>run</em> in <em>nurses</em>). The Os represent the <em>possible</em> palindromic sequence (like <em>ses</em> in <em>nurses</em>). The word represented in the left column in <a href="ch02.xhtml#ch02fig3">Figure 2-3</a> behaves like <em>nurses</em> in <a href="ch02.xhtml#ch02fig2">Figure 2-2</a>, with the reversed word at the start. The word represented by the right column behaves like <em>grits</em>, with the reversed word at the end. Note that the number of combinations in each column is the total number of letters in the word plus one; note too that the top and bottom rows represent an identical circumstance.</p>
<p class="indent">The top row in each column represents a semordnilap. The bottom row in each represents a palindrome. These are both reversed words, just different <em>types</em> of reversed words. Hence, they count as one entity and both can be identified with a single line of code in a single loop.</p>
<div class="image"><a id="ch02fig3"/><img src="../images/f0026-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 2-3: Possible positions for letters of the reversed word (X) and the palindromic sequence (O) in a six-letter core word</em></p>
<p class="indent">To see the diagram in action, consider <a href="ch02.xhtml#ch02fig4">Figure 2-4</a>, which shows the palingrams <em>devils lived</em> and <em>retro porter</em>. <em>Devils</em> and <em>porter</em> are both core words and mirror images of each other with respect to palindromic sequences and reversed words. Compare this to the semordnilap <em>evil</em> and the palindrome <em>kayak</em>.</p>
<div class="image"><span epub:type="pagebreak" id="page_27"/><a id="ch02fig4"/><img src="../images/f0027-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 2-4: Reversed words (Xs) and palindromic sequences (Os) in words, semordnilaps, and palindromes.</em></p>
<p class="indent">Palindromes are both reversed words <em>and</em> palindromic sequences. Since they have the same pattern of Xs as in semordnilaps, they can be handled with the same code used for semordnilaps.</p>
<p class="indent">From a strategy perspective, you’ll need to loop through each word in the dictionary and evaluate it for <em>all of the combinations</em> in <a href="ch02.xhtml#ch02fig3">Figure 2-3</a>. Assuming a 60,000-word dictionary, the program will need to take about 500,000 passes.</p>
<p class="indent">To understand the loops, take a look at the core word for the palingram <em>stack cats</em> in <a href="ch02.xhtml#ch02fig5">Figure 2-5</a>. Your program needs to loop through the letters in the word, starting with an end letter and adding a letter with each iteration. To find palingrams like <em>stack cats</em>, it will simultaneously evaluate the word for the presence of a palindromic sequence at the end of the core word, <em>stack</em>, and a reversed word at the start. Note that the first loop in <a href="ch02.xhtml#ch02fig5">Figure 2-5</a> will be successful, as a single letter (<em>k</em>) can serve as a palindrome in this situation.</p>
<div class="image"><a id="ch02fig5"/><img src="../images/f0027-02.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 2-5: Example loops through a core word, simultaneously looking for palindromes and reversed words</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_28"/>But you’re not through yet. To capture the “mirror image” behavior in <a href="ch02.xhtml#ch02fig3">Figure 2-3</a>, you have to run the loops in reverse, looking for palindromic sequences at the start of the word and reversed words at the end. This will allow you to find palingrams like <em>stir grits</em>.</p>
<p class="indent">Here is the pseudocode for a palingram-finding algorithm:</p>
<p class="programs">Load digital dictionary as a list of words<br/>Start an empty list to hold palingrams<br/>For word in word list:<br/>    Get length of word<br/>    If length &gt; 1:<br/>        Loop through the letters in the word:<br/>            If reversed word fragment at front of word is in word list and letters<br/>            after form a palindromic sequence:<br/>               Append word and reversed word to palingram list<br/>            If reversed word fragment at end of word is in word list and letters<br/>            before form a palindromic sequence:<br/>               Append reversed word and word to palingram list<br/>Sort palingram list alphabetically<br/>Print word-pair palingrams from palingram list</p>
<h4 class="h4" id="lev41"><strong><em>The Palingrams Code</em></strong></h4>
<p class="noindent"><a href="ch02.xhtml#ch02list3">Listing 2-3</a>, <em>palingrams.py</em>, loops through a word list, identifies which words form word-pair palingrams, saves those pairs to a list, and prints the list as stacked items. You can download the code from <em><a href="https://www.nostarch.com/impracticalpython/">https://www.nostarch.com/impracticalpython/</a></em>. I suggest you use the <em>2of4brif.txt</em> dictionary file to start so that your results will match mine. Store your dictionary and <em>load_dictionary.py</em> in the same folder as the palingrams script.</p>
<p class="margin"><em>palingrams.py</em></p>
<p class="programs">   """Find all word-pair palingrams in a dictionary file."""<br/>
   import load_dictionary<br/>
<br/>
   word_list = load_dictionary.load('2of4brif.txt')<br/>
<br/>
   # find word-pair palingrams<br/>
<span class="ent">➊</span> def find_palingrams():<br/>
       """Find dictionary palingrams."""<br/>
       pali_list = []<br/>
       for word in word_list:<br/>
        <span class="ent">➋</span> end = len(word)<br/>
        <span class="ent">➌</span> rev_word = word[::-1]<br/>
        <span class="ent">➍</span> if end &gt; 1:<br/>
            <span class="ent">➎</span> for i in range(end):<br/>
                <span class="ent">➏</span> if word[i:] == rev_word[:end-i] and rev_word[end-i:] in word_list:<br/>
                       pali_list.append((word, rev_word[end-i:]))<br/>
                <span class="ent">➐</span> if word[:i] == rev_word[end-i:] and rev_word[:end-i] in word_list:<br/>
                       pali_list.append((rev_word[:end-i], word))<br/>
    <span class="ent">➑</span> return pali_list<br/>
<br/>
<span class="ent">➒</span> palingrams = find_palingrams()<br/>
<span epub:type="pagebreak" id="page_29"/>   # sort palingrams on first word<br/>
   palingrams_sorted = sorted(palingrams)<br/>
<br/>
   # display list of palingrams<br/>
<span class="ent">➓</span> print("\nNumber of palingrams = {}\n".format(len(palingrams_sorted)))<br/>
   for first, second in palingrams_sorted:<br/>
       print("{} {}".format(first, second))</p>
<p class="listing" id="ch02list3"><em>Listing 2-3: Finds and prints word-pair palingrams in loaded dictionary</em></p>
<p class="indent">After repeating the steps you used in the <em>palindromes.py</em> code to load a dictionary file, define a function to find palingrams <span class="ent">➊</span>. Using a function will allow you to isolate the code later and time how long it takes to process all the words in the dictionary.</p>
<p class="indent">Immediately start a list called <span class="literal">pali_list</span> to hold all the palingrams the program discovers. Next, start a <span class="literal">for</span> loop to evaluate the words in <span class="literal">word_list</span>. For each word, find its length and assign its length to the variable <span class="literal">end</span> <span class="ent">➋</span>. The word’s length determines the indexes the program uses to slice through the word, looking for every possible reversed word-palindromic sequence combination, as in <a href="ch02.xhtml#ch02fig3">Figure 2-3</a>.</p>
<p class="indent">Next, negatively slice through the word and assign the results to the variable <span class="literal">rev_word</span> <span class="ent">➌</span>. An alternative to <span class="literal">word[::-1]</span> is <span class="literal">''.join(reversed(word))</span>, which some consider more readable.</p>
<p class="indent">Since you are looking for word-pair palingrams, exclude single-letter words <span class="ent">➍</span>. Then nest another <span class="literal">for</span> statement to loop through the letters in the current word <span class="ent">➎</span>.</p>
<p class="indent">Now, run a conditional requiring the back end of the word to be palindromic and the front end to be a reverse word in the word list (in other words, a “real” word) <span class="ent">➏</span>. If a word passes the test, it is appended to the palingram list, immediately followed by the reversed word.</p>
<p class="indent">Based on <a href="ch02.xhtml#ch02fig3">Figure 2-3</a>, you know you have to repeat the conditional, but change the slicing direction and word order to reverse the output. In other words, you must capture palindromic sequences at the start of the word rather than at the end <span class="ent">➐</span>. Return the list of palingrams to complete the function <span class="ent">➑</span>.</p>
<p class="indent">With the function defined, call it <span class="ent">➒</span>. Since the order in which dictionary words are added to the palingram list switches during the loop, the palingrams won’t be in alphabetical order. So, sort the list so that the first words in the word pair are in alphabetical order. Print the length of the list <span class="ent">➓</span>, then print each word-pair on a separate line.</p>
<p class="indent">As written, <em>palingrams.py</em> will take about three minutes to run on a dictionary file with about 60,000 words. In the next sections, we’ll investigate the cause of this long runtime and see what we can do to fix it.</p>
<h4 class="h4" id="lev42"><strong><em>Palingram Profiling</em></strong></h4>
<p class="noindent"><em>Profiling</em> is an analytical process that gathers statistics on a program’s behavior—for example, the number and duration of function calls—as <span epub:type="pagebreak" id="page_30"/>the program executes. Profiling is a key part of the optimization process. It tells you exactly what parts of a program are taking the most time or memory. That way, you’ll know where to focus your efforts to improve performance.</p>
<h5 class="h5" id="lev43"><strong>Profiling with cProfile</strong></h5>
<p class="noindent">A <em>profile</em> is a measurement output—a record of how long and how often parts of a program are executed. The Python standard library provides a handy profiling interface, <span class="literal">cProfile</span>, which is a C extension suitable for profiling long-running programs.</p>
<p class="indent">Something in the <span class="literal">find_palingrams()</span> function probably accounts for the relatively long runtime of the <em>palingrams.py</em> program. To confirm, let’s run <span class="literal">cProfile</span>.</p>
<p class="indent">Copy the following code into a new file named <em>cprofile_test.py</em> and save it in the same folder as <em>palingrams.py</em> and the dictionary file. This code imports <span class="literal">cProfile</span> and the palingrams program, and it runs <span class="literal">cProfile</span> on the <span class="literal">find_palingrams()</span> function—called with dot notation. Note again that you don’t need to specify the <em>.py</em> extension.</p>
<p class="programs">import cProfile<br/>import palingrams<br/>cProfile.run('palingrams.find_palingrams()')</p>
<p class="indent">Run <em>cprofile_test.py</em> and, after it finishes (you will see the <span class="literal">&gt;&gt;&gt;</span> in the interpreter window), you should see something similar to the following:</p>
<p class="programs">         62622 function calls in 199.452 seconds<br/><br/>   Ordered by: standard name<br/><br/>   ncalls  tottime  percall  cumtime  percall filename:lineno(function)<br/>        1    0.000    0.000  199.451  199.451 &lt;string&gt;:1(&lt;module&gt;)<br/>        1  199.433  199.433  199.451  199.451 palingrams.py:7(find_palingrams)<br/>        1    0.000    0.000  199.452  199.452 {built-in method builtins.exec}<br/>    60388    0.018    0.000    0.018    0.000 {built-in method builtins.len}<br/>     2230    0.001    0.000    0.001    0.000 {method 'append' of 'list' objects}</p>
<p class="indent">All that looping, slicing, and searching took 199.452 seconds on my machine, but of course your times may differ from mine. You also get additional information on some of the built-in functions, and since each palingram called the built-in <span class="literal">append()</span> function, you can even see the number of palingrams found (2,230).</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>The most common way to run</em> <span class="codeitalic">cProfile</span> <em>is directly in the interpreter. This lets you dump your output to a text file and view it with a web viewer. For more information, visit</em> <a href="https://docs.python.org/3/library/profile.html">https://docs.python.org/3/library/profile.html</a>.</p>
</div>
<h5 class="h5" id="lev44"><span epub:type="pagebreak" id="page_31"/><strong>Profiling with time</strong></h5>
<p class="noindent">Another way to time the program is to use <span class="literal">time.time()</span>, which returns an <em>epoch timestamp</em>—the number of seconds since 12 <small>AM</small> on January 1, 1970 UTC (the <em>Unix epoch</em>). Copy <em>palingrams.py</em> to a new file, save it as <em>palingrams_timed.py</em>, and insert the following code at the very top:</p>
<p class="programs">import time<br/>start_time = time.time()</p>
<p class="indent">Now go to the end of the file and add the following code:</p>
<p class="programs">end_time = time.time()<br/>print("Runtime for this program was {} seconds.".format(end_time - start_time))</p>
<p class="indent">Save and run the file. You should get the following feedback at the bottom of the interpreter window—give or take a few seconds:</p>
<p class="programs">Runtime for this program was 222.73954558372498 seconds.</p>
<p class="indent">The runtime is longer than before, as you are now evaluating the whole program, including printing, rather than just the <span class="literal">find_palingrams()</span> function.</p>
<p class="indent">Unlike <span class="literal">cProfile</span>, <span class="literal">time</span> doesn’t provide detailed statistics, but like <span class="literal">cProfile</span>, it can be run on individual code components. Edit the file you just ran, moving the start and end time statements (as shown below in bold) so they bracket our long-running <span class="literal">find_palingrams()</span> function. Leave the <span class="literal">import</span> and <span class="literal">print</span> statements unchanged at the top and bottom of the file, respectively.</p>
<p class="programs"><span class="codestrong1">start_time = time.time()</span><br/>palingrams = find_palingrams()<br/><span class="codestrong1">end_time = time.time()</span></p>
<p class="indent">Save and run the file. You should get the following feedback at the bottom of the interpreter window:</p>
<p class="programs">Runtime for this program was 199.42786622047424 seconds.</p>
<p class="indent">This now matches the initial results using <span class="literal">cProfile</span>. You won’t get the exact same time if you rerun the program or use a different timer, but don’t get hung up on it. It’s the <em>relative</em> times that are important for guiding code optimization.</p>
<h4 class="h4" id="lev45"><strong><em>Palingram Optimization</em></strong></h4>
<p class="noindent">I’m sorry, but three minutes of my life is too long to wait for palingrams. Armed with our profiling results, we know that the <span class="literal">find_palingrams()</span> function accounts for most of the processing time. This probably has something to do with reading and writing to lists, slicing over lists, or searching in lists. Using an alternative data structure to lists—like tuples, sets, or dictionaries—might <span epub:type="pagebreak" id="page_32"/>speed up the function. Sets, in particular, are significantly faster than lists when using the <span class="literal">in</span> keyword. Sets use a hashtable for very fast lookups. With hashing, strings of text are converted to unique numbers that are much smaller than the referenced text and much more efficient to search. With a list, on the other hand, you have to do a linear search through each item.</p>
<p class="indent">Think of it this way: if you’re searching your house for your lost cell phone, you could emulate a list by looking through every room before finding it (in the proverbial last place you look). But by emulating a set, you can basically dial your cell number from another phone, listen for the ringtone, and go straight to the proper room.</p>
<p class="indent">A downside to using sets is that the order of the items in the set isn’t controllable and duplicate values aren’t allowed. With lists, the order is preserved and duplicates are allowed, but lookups take longer. Fortunately for us, we don’t care about order or duplicates, so sets are the way to go!</p>
<p class="indent"><a href="ch02.xhtml#ch02list4">Listing 2-4</a> is the <span class="literal">find_palingrams()</span> function from the original <em>palingrams.py</em> program, edited to use a set of words rather than a list of words. You can find it in a new program named <em>palingrams_optimized.py</em>, which you can download from <em><a href="https://www.nostarch.com/impracticalpython/">https://www.nostarch.com/impracticalpython/</a></em>, or just make these changes to your copy of <em>palingrams_timed.py</em> if you want to check the new runtime yourself.</p>
<p class="margin"><em>palingrams_optimized.py</em></p>
<p class="programs">def find_palingrams():<br/>
    """Find dictionary palingrams."""<br/>
    pali_list = []<br/>
 <span class="ent">➊</span> words = set(word_list)<br/>
 <span class="ent">➋</span> for word in words:<br/>
        end = len(word)<br/>
        rev_word = word[::-1]<br/>
        if end &gt; 1:<br/>
            for i in range(end):<br/>
             <span class="ent">➌</span> if word[i:] == rev_word[:end-i] and rev_word[end-i:] in words:<br/>
                    pali_list.append((word, rev_word[end-i:]))<br/>
             <span class="ent">➍</span> if word[:i] == rev_word[end-i:] and rev_word[:end-i] in words:<br/>
                    pali_list.append((rev_word[:end-i], word))<br/>
    return pali_list</p>
<p class="listing" id="ch02list4"><em>Listing 2-4: The</em> <span class="codeitalic">find_palingrams()</span> <em>function optimized with sets</em></p>
<p class="indent">Only four lines change. Define a new variable, <span class="literal">words</span>, which is a set of <span class="literal">word_list</span> <span class="ent">➊</span>. Then loop through the set <span class="ent">➋</span>, looking for membership of word slices in this set <span class="ent">➌</span><span class="ent">➍</span>, rather than in a list as before.</p>
<p class="indent">Here’s the new runtime for the <span class="literal">find_palingrams()</span> function in <em>palingrams_optimized.py</em>:</p>
<p class="programs">Runtime for this program was 0.4858267307281494 seconds.</p>
<p class="indent">Wow! From over three minutes to under a second! <em>That’s</em> optimization! And the difference is in the data structure. Verifying the membership of a word in a <em>list</em> was the thing that was killing us.</p>
<p class="indent"><span epub:type="pagebreak" id="page_33"/>Why did I first show you the “incorrect” way to do this? Because that’s how things happen in the real world. You get the code to work, and then you optimize it. This is a simple example that an experienced programmer would have gotten right from the start, but it is emblematic of the overall concept of optimization: get it to work as best as you can, then make it better.</p>
<h3 class="h3" id="lev46"><strong>dnE ehT</strong></h3>
<p class="noindent">You’ve written code to find palindromes and palingrams, profiled code using <span class="literal">cProfile</span>, and optimized code by using the appropriate data structure for the task. So how did we do with respect to Zatanna? Does she have a fighting chance?</p>
<p class="indent">Here I’ve listed some of the more “aggressive” palingrams found in the <em>2of4brif</em> dictionary file—everything from the unexpected <em>sameness enemas</em> to the harsh <em>torsos rot</em> to my personal favorite as a geologist: <em>eroded ore</em>.</p>
<table class="topbot-d">
<tbody>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba">dump mud</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabaa">drowsy sword</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabaa">sameness enemas</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba">legs gel</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabaa">denims mined</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabaa">lepers repel</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba">sleet eels</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabaa">dairy raid</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabaa">slam mammals</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba">eroded ore</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabaa">rise sir</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabaa">pots nonstop</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba">strafe farts</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabaa">torsos rot</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabaa">swan gnaws</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba">wolfs flow</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabaa">partner entrap</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabaa">nuts stun</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba">slaps pals</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabaa">flack calf</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabaa">knobs bonk</p></td>
</tr>
</tbody>
</table>
<h3 class="h3" id="lev47"><strong>Further Reading</strong></h3>
<p class="noindent"><em>Think Python, 2nd Edition</em> (O’Reilly, 2015) by Allen Downey has a short and lucid description of hashtables and why they are so efficient. It’s also an excellent Python reference book.</p>
<h3 class="h3" id="lev48"><strong>Practice Project: Dictionary Cleanup</strong></h3>
<p class="noindent">Data files available on the internet are not always “plug and play.” You may find you need to massage the data a bit before applying it to your project. As mentioned earlier, some online dictionary files include each letter of the alphabet as a word. These will cause problems if you want to permit the use of one-letter words in palingrams like <em>acidic a</em>. You could always remove them by directly editing the dictionary text file, but this is tedious and for losers. Instead, write a short script that removes these after the dictionary has been loaded into Python. To test that it works, edit your dictionary file to include a few one-letter words like <em>b</em> and <em>c</em>. For a solution, see the appendix, or find a copy (<em>dictionary_cleanup_practice.py</em>) online at <em><a href="https://www.nostarch.com/impracticalpython/">https://www.nostarch.com/impracticalpython/</a></em>.</p>
<h3 class="h3" id="lev49"><span epub:type="pagebreak" id="page_34"/><strong>Challenge Project: Recursive Approach</strong></h3>
<p class="noindent">With Python, there is usually more than one way to skin a cat. Take a look at the discussion and pseudocode at the Khan Academy website (<em><a href="https://www.khanacademy.org/computing/computer-science/algorithms/recursive-algorithms/a/using-recursion-to-determine-whether-a-word-is-a-palindrome/">https://www.khanacademy.org/computing/computer-science/algorithms/recursive-algorithms/a/using-recursion-to-determine-whether-a-word-is-a-palindrome/</a></em>). Then rewrite the <em>palindrome.py</em> program so that it uses recursion to identify palindromes.</p>
</body></html>