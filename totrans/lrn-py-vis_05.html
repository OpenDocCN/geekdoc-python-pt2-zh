<html><head></head><body>
		<section>
			<header>
				<h1 class="chapter"><span class="ChapterNumber"><span epub:type="pagebreak" id="Page_85" title="85"/>5</span><br/><span class="ChapterTitle">Iteration and Randomness</span></h1>
			</header>
			<figure class="opener">
				<img alt="" src="image_fi/book_art/chapterart.png"/>
			</figure>
			<p class="ChapterIntro">In <span class="xref">Chapter 4</span>, you learned how to program divergent paths for Python to follow. In this chapter, you’ll create looped paths with <code>while</code> and <code>for</code> loop statements. <em>Loop statements</em> repeat actions, so you don’t need to rewrite the same or similar code multiple times, resulting in fewer lines of code. In other words, you can solve problems more efficiently with code that’s easier to adapt. You’ll use these loop statements to generate visual patterns in Processing.</p>
			<p>
				You’ll also learn to apply randomness to your patterns to make them more compelling and unpredictable. Processing’s <code>random()</code> function is useful for generating randomized arguments in your shape functions, allowing you to create irregular designs. You can also randomize the conditions for your control flow statements so that your code executes differently on each run. Randomness is, undoubtedly, one of the most useful and exciting tools in the creative coder’s toolset, because it allows you to write programs that can produce unpredictable results.</p>
			<h2 id="h1-500969c05-0001"><span epub:type="pagebreak" id="Page_86" title="86"/>Iteration</h2>
			<p class="BodyFirst">In computer programming, <em>iteration</em> is the process of repeating a series of instructions a specified number of times or until a condition is met. As an example, say you want to tile a floor. Starting in one corner, you lay one tile. Then you place another tile next to it, repeating the process until you’ve reached the opposite wall, at which point you move down a row and continue. In this scenario, placing an individual tile is a single iteration. In many iterative processes, the result of a previous iteration defines the starting point of the next.</p>
			<p>Tasks like tiling can be tedious work, though. Humans are exemplary in reasoning and creative thought, but if not sufficiently stimulated, they tend to lose interest in performing such monotonous activities. Computers, however, excel at performing repetitive tasks rapidly and accurately, especially when numbers are involved.</p>
			<h3 id="h2-500969c05-0001">Using Iteration to Draw Concentric Circles</h3>
			<p class="BodyFirst">To begin exploring iteration in Processing, create a new sketch and save it as <em>concentric_circles</em>. Add the following code:</p>
			<pre><code><span class="ProcessingBlue">size</span>(500, 500)<span class="ProcessingBlue">background</span>(<span class="ProcessingPurple">'#004477'</span>)<span class="ProcessingBlue">noFill</span>()<span class="ProcessingBlue">stroke</span>(<span class="ProcessingPurple">'#FFFFFF'</span>)<span class="ProcessingBlue">strokeWeight</span>(3)<span class="ProcessingBlue">circle</span>(<span class="ProcessingRaspberry">width</span>/2, <span class="ProcessingRaspberry">height</span>/2, 30)<span class="ProcessingBlue">circle</span>(<span class="ProcessingRaspberry">width</span>/2, <span class="ProcessingRaspberry">height</span>/2, 60)<span class="ProcessingBlue">circle</span>(<span class="ProcessingRaspberry">width</span>/2, <span class="ProcessingRaspberry">height</span>/2, 90)</code></pre>
			<p>
				Each <code>circle()</code> function has its x-y coordinate placed in the center of the display window. The first circle is the smallest, with a diameter argument of <code>30</code>; each subsequent circle is 30 pixels larger in diameter than the one preceding it. The program runs each <code>circle()</code> function line by line, advancing toward a display window filled with concentric circles (<a href="#figure5-1" id="figureanchor5-1">Figure 5-1</a>).</p>
			<figure>
				<img alt="f05001" src="image_fi/500969c05/f05001.png"/>
				<figcaption>
					<p><a id="figure5-1">Figure 5-1</a>: Three circles rendered using three <span class="LiteralInCaption"><code>circle()</code></span> functions</p>
				</figcaption>
			</figure>
			<p><span epub:type="pagebreak" id="Page_87" title="87"/>However, to fill the entire window, you’d need to write many more <code>circle()</code> lines. Instead of adding <code>circle()</code> functions manually, you can use a Python <code>while</code><em> </em>loop to run them iteratively.</p>
			<h3 id="h2-500969c05-0002">while Loops</h3>
			<p class="BodyFirst">A <code>while</code> loop is a control flow statement that looks and behaves much like <code>if</code>. The key difference is that <code>while</code> continues to execute the lines indented beneath it <em>until</em> its accompanying condition is no longer true.</p>
			<p>
				Back in your <em>concentric_circles</em> sketch, comment out the <code>circle()</code> lines by using<code> ''' </code>for multiline comments, and add a basic <code>while</code> loop structure:</p>
			<pre><code><span class="LiteralGray">. . .</span><span class="ProcessingPurple">'''</span><span class="ProcessingPurple">circle(width/2, height/2, 30, 30)</span><span class="ProcessingPurple">circle(width/2, height/2, 60, 60)</span><span class="ProcessingPurple">circle(width/2, height/2, 90, 90)</span><span class="ProcessingPurple">'''</span>
i = 0<span class="ProcessingOlive">while</span> i &lt; 24: <span class="ProcessingBlue">print</span>(i)</code></pre>
			<p>
				The <code>i</code> variable is defined to serve as your <em>loop counter</em>, controlling the iterations of the <code>while</code> statement. For the <code>while</code> expression, <code>i</code> is equal to 0 and, therefore, is less than 24. Unlike an <code>if</code> statement that would execute the <code>print()</code> function a single time, the <code>while</code> repeatedly executes the <code>print</code> line until the value of <code>i</code> reaches 24—which, in this case, is never.</p>
			<aside epub:type="sidebar">
				<div class="top hr">
					<hr/>
				</div>
				<section class="note">
					<h2><span class="NoteHead">NOTE</span></h2>
					<p>
							As with any other variable, you can name <var>i</var> whatever you like, but it’s a popular convention to represent a loop counter value with an <var>i</var>.</p>
					<div class="bottom hr">
						<hr/>
					</div>
				</section>
			</aside>
			<p>
				Running the sketch should print an endless list of <code>0</code> digits to the console (<a href="#figure5-2" id="figureanchor5-2">Figure 5-2</a>).</p>
			<figure>
				<img alt="f05002" src="image_fi/500969c05/f05002.png"/>
				<figcaption>
					<p><a id="figure5-2">Figure 5-2</a>: The console lists endless lines of zeros.</p>
				</figcaption>
			</figure>
			<p><span epub:type="pagebreak" id="Page_88" title="88"/>This code has crashed your program by sending it into an infinitive loop! To exit the program, click the <b>Stop</b> button. Processing may take some time to respond. The variable <code>i</code> remains 0, and the <code>i &lt; 24</code> condition never achieves the <code>False</code> required to conclude the loop.</p>
			<p>
				To correct this, add 1 to <code>i</code> with each iteration of the <code>while</code> loop:</p>
			<pre><code><span class="LiteralGray">. . .</span><span class="LiteralGray">while i &lt; 24:</span><span class="LiteralGray">    print(i)</span> i = i + 1</code></pre>
			<p>
				This new line states that the loop counter, <code>i</code>, is equal to itself plus 1. On the first iteration, <code>i</code> is 0, which is less than 24, so the program prints <code>0</code>, adds 1 to <code>i</code>, and then begins the process again. On the next iteration, <code>i</code> is 1, which is still less than 24, so the program prints <code>1</code>, adds 1 to it, and restarts the process. The iteration continues as long as <code>i &lt; 24</code> evaluates to <code>True</code>. Once <code>i</code> reaches 24, the program exits the loop and runs any other code that follows the <code>while</code> block.</p>
			<p>
				Note that the output never reaches 24 (<a href="#figure5-3" id="figureanchor5-3">Figure 5-3</a>), because the <code>while</code> condition states “where <code>i</code> is less than 24,” not “less than or equal to 24.”</p>
			<p>
				To draw 24 circles, place a <code>circle()</code> function within the loop:</p>
			<pre><code><span class="LiteralGray">. . .</span><span class="LiteralGray">while i &lt; 24:</span><span class="LiteralGray">    print(i)</span> <span class="ProcessingBlue">circle</span>(<span class="ProcessingRaspberry">width</span>/2, <span class="ProcessingRaspberry">height</span>/2, 30*i) <span class="LiteralGray">i = i + 1</span></code></pre>
			<figure>
				<img alt="f05003" src="image_fi/500969c05/f05003.png"/>
				<figcaption>
					<p><a id="figure5-3">Figure 5-3</a>: The console displays 0 to 23, but not 24.</p>
				</figcaption>
			</figure>
			<p>
				To avoid drawing 24 circles of exactly the same size, in the same position, use <code>i</code> as a multiplier for the <code>circle()</code> diameter argument. On the first iteration, the diameter argument is equal to <code>30*0</code>. Therefore, the first circle, placed in the very center of the display window, has a diameter of 0 and doesn’t render (<a href="#figure5-4" id="figureanchor5-4">Figure 5-4</a>).</p>
			<p>
				The other 23 circles are enough to fill the 500 × 500 pixel area. By changing the number in the <code>while</code> statement, you may draw as many (or as few) circles as you like.</p>
				<span epub:type="pagebreak" id="Page_89" title="89"/>
				<figure>
				<img alt="f05004" src="image_fi/500969c05/f05004.png"/>
				<figcaption>
					<p><a id="figure5-4">Figure 5-4</a>: The drawing now has 24 circles (one invisible, and some partially cropped).</p>
				</figcaption>
			</figure>
			<aside epub:type="sidebar">
				<div class="top hr">
					<hr/>
				</div>
				<section class="box">
					<h2>Augmented Assignment Operators</h2>
					<p class="BoxBodyFirst">You’re already familiar with the <code>=</code> operator (assignment), but not its arithmetic variants. In the <em>concentric_circles</em> example, you incremented <code>i</code> by using this line of code:</p>
					<pre><code>i = i + 1</code></pre>
					<p>
						This states that <code>i</code> is equal to itself plus 1. To simplify this statement, you can instead write this:</p>
					<pre><code>i += 1</code></pre>
					<p>
						The result is exactly the same, but the latter is easier to read and write. <a href="#table5-1" id="tableanchor5-1">Table 5-1</a> provides a list of these <em>augmented assignment operators</em>, along with an example of each.</p>
					<figure>
						<figcaption>
							<p class="TableTitle"><a id="table5-1">Table 5-1</a>: Augmented Assignment Operators</p>
						</figcaption>
						<table border="1" id="tabular-500969c05-">
							<thead>
								<tr>
									<td><b>Operator</b></td>
									<td><b>Example</b></td>
								</tr>
							</thead>
							<tbody>
								<tr>
									<td><code>+=</code></td>
									<td><code>i += 1</code> is equivalent to <code>i = i + 1</code></td>
								</tr>
								<tr>
									<td><code>-=</code></td>
									<td><code>i -= 1</code> is equivalent to <code>i = i - 1</code></td>
								</tr>
								<tr>
									<td><code>*=</code></td>
									<td><code>i *= 1</code> is equivalent to <code>i = i * 1</code></td>
								</tr>
								<tr>
									<td><code>/=</code></td>
									<td><code>i /= 1</code> is equivalent to <code>i = i / 1</code></td>
								</tr>
							</tbody>
						</table>
					</figure>
					<div class="bottom hr">
						<hr/>
					</div>
				</section>
			</aside>
			<h3 id="h2-500969c05-0003"><span epub:type="pagebreak" id="Page_90" title="90"/>for Loops</h3>
			<p class="BodyFirst">The Python <code>for</code> loop executes a given block of code a specified number of times. Unlike the <code>while</code> loop that relies on a conditional expression, the <code>for</code> loop iterates a sequence. A <em>sequence</em> is a collection of values; for instance, string data is a sequence of characters. Python <em>lists</em> are particularly versatile sequences, which I cover in <span class="xref">Chapter 7</span>. To generate sequences for the <code>for</code> loops in this section, you’ll use the <code>range()</code> function.</p>
			<p>
				A <code>for</code> loop is more appropriate than a <code>while</code> loop when you’ve established the number of iterations required before entering the loop. Generally speaking, the <code>for</code> loop is shorter and simpler, and won’t trigger infinite loops. When either a <code>while</code> or <code>for</code> will do, opt for the <code>for</code> loop.</p>
			<p>
				One of the easiest ways to understand the <code>for</code> loop is to convert something you already wrote that uses a <code>while</code> statement. Save <em>concentric_circles</em> as a new sketch called <em>for_loop</em> by using <b>File</b><span class="MenuArrow">▶</span><b>Save As</b>. Comment out the <code>while</code> loop parts, and add the following <code>for</code> loop:</p>
			<pre><code><span class="LiteralGray">. . .</span><span class="ProcessingPurple">'''</span><span aria-label="annotation1" class="CodeAnnotationHang">1</span> <span class="ProcessingPurple">i = 0</span><span class="ProcessingPurple">while i &lt; 24:</span><span class="ProcessingPurple">    print(i)</span><span class="ProcessingPurple">    circle(width/2, height/2, 30*i)</span><span aria-label="annotation2" class="CodeAnnotationHang">2</span> <span class="ProcessingPurple">    i = i + 1</span><span class="ProcessingPurple">'''</span><span aria-label="annotation3" class="CodeAnnotationHang">3</span> <span class="ProcessingOlive">for</span> i <span class="ProcessingTealGreen">in</span> <span class="ProcessingTealGreen">range</span>(24): <span class="ProcessingBlue">print</span>(i) <span class="ProcessingBlue">circle</span>(<span class="ProcessingRaspberry">width</span>/2, <span class="ProcessingRaspberry">height</span>/2, 30*i)</code></pre>
			<p>
				In the <code>while</code> loop version, recall that you had to define the <code>i</code> variable to serve as a loop counter. With each iteration of the <code>while</code> block, you also had to increment <code>i</code> to avoid entering an endless loop. The <code>for</code> statement does away with the need to define and manage a separate counter variable.</p>
			<p>
				So, <code>i = 0</code> <span aria-label="annotation1" class="CodeAnnotation">1</span> is no longer necessary, nor is the nested statement to increment it <span aria-label="annotation2" class="CodeAnnotation">2</span>. Instead, the <code>range()</code> function takes its argument of <code>24</code> to generate a sequence from 0 up to but not including 24 that controls the <code>for</code> <span aria-label="annotation3" class="CodeAnnotation">3</span> loop iteration behavior. On the first iteration, <code>i</code> is equal to 0, the first value in the sequence. With each subsequent iteration, the next value in the <code>range()</code> sequence is assigned to <code>i</code>. When <code>i</code> reaches 23, the <code>for</code> block runs for the last time, and then Python exits the loop. Run the sketch to confirm that the display window looks the same as <a href="#figure5-4">Figure 5-4</a>.</p>
			<p>
				The <code>range()</code> function can handle up to three parameters. Provide two arguments for a start and end value, respectively:</p>
			<pre><code><span class="LiteralGray">. . .</span><span class="ProcessingOlive">for</span> i <span class="ProcessingTealGreen">in</span> <span class="ProcessingTealGreen">range</span>(10, 13):<span class="LiteralGray">    print(i)</span><span class="LiteralGray">    circle(width/2, height/2, 30*i)</span></code></pre>
			<p><span epub:type="pagebreak" id="Page_91" title="91"/>In this instance, the <code>circle()</code> function should execute three times, for <code>i </code>= 10, <code>i </code>= 11, and <code>i</code> = 12. Run the sketch to see the result (<a href="#figure5-5" id="figureanchor5-5">Figure 5-5</a>).</p>
			<p>You should see three concentric rings.</p>
			<figure>
				<img alt="f05005" src="image_fi/500969c05/f05005.png"/>
				<figcaption>
					<p><a id="figure5-5">Figure 5-5</a>: Result for <span class="LiteralInCaption"><code>range(10, 13)</code></span></p>
				</figcaption>
			</figure>
			<p>
				Now use three range arguments to represent a start, end, and step size, respectively. The <em>step size</em> is the difference between each integer in the sequence:</p>
			<pre><code><span class="LiteralGray">. . .</span><span class="ProcessingOlive">for</span> i <span class="ProcessingTealGreen">in</span> <span class="ProcessingTealGreen">range</span>(3, 13, 3):<span class="LiteralGray">    print(i)</span><span class="LiteralGray">    circle(width/2, height/2, 30*i)</span></code></pre>
			<p>
				In this instance, the <code>circle()</code> function should execute four times, for <code>i</code> = 3, <code>i</code> = 6, <code>i</code> = 9, and <code>i</code> = 12. The result should be four rings with enlarged spacing (<a href="#figure5-6" id="figureanchor5-6">Figure 5-6</a>).</p>
			<figure>
				<img alt="f05006" src="image_fi/500969c05/f05006.png"/>
				<figcaption>
					<p><a id="figure5-6">Figure 5-6</a>: Result for <span class="LiteralInCaption"><code>range(3, 13, 3)</code></span></p>
				</figcaption>
			</figure>
			<p>Experiment with different range arguments to see how the circles are affected.</p>
			<h4 class="HeadProject"><span><span epub:type="pagebreak" id="Page_92" title="92"/>Challenge #4: Create Line Patterns</span></h4>
			<p class="BodyFirst">In this challenge, recreate the three patterns shown in <a href="#figure5-7" id="figureanchor5-7">Figure 5-7</a> by using the <code>line()</code> function and one <code>for</code> loop for each. Don’t worry if your code produces a slightly different result, as long as the basic pattern remains the same.</p>
			<p>If you’re not sure where to begin, here are a few clues to help you approach each pattern:</p>
			<ul>
				<li>The left pattern is similar to the concentric circles, except it has 12 diagonal lines.</li>
				<li>
					For the middle pattern, the line spacing increases by a multiple of 1.5 with each <code>for</code> loop iteration. Defining an additional variable may help.</li>
				<li>
					The right pattern requires an <code>if...else</code> structure nested within the <code>for</code> loop. You might consider using a modulo (<code>%</code>) operator, described in <span class="xref">Chapter 1</span>, to establish whether <code>i</code> is odd or even.</li>
			</ul>
			<p>
				If you need help, you can find the solution at <a class="LinkURL" href="https://github.com/tabreturn/processing.py-book/tree/master/chapter-05-iteration_and_randomness/for_loop_patterns/">https://github.com/tabreturn/processing.py-book/tree/master/chapter-05-iteration_and_randomness/for_loop_patterns/</a>.</p>
			<figure>
				<img alt="f05007" src="image_fi/500969c05/f05007.png"/>
				<figcaption>
					<p><a id="figure5-7">Figure 5-7</a>: Three <span class="LiteralInCaption"><code>for</code></span> loop patterns</p>
				</figcaption>
			</figure>
			<h2 id="h1-500969c05-0002">break and continue Statements</h2>
			<p class="BodyFirst">Loops provide an efficient way to automate and repeat tasks. Sometimes, though, you need to exit a loop prematurely. For example, when you draw a series of concentric circles to fill the display window, like in the earlier task, you might want to <em>break</em> the loop if the circles reach the edge of the display window before exhausting the sequence of <code>range()</code> values. If Python encounters a <code>break</code> statement within a <code>for</code> or <code>while</code> loop, it will immediately terminate the loop. Once the loop is terminated, your program will move along as usual.</p>
			<p>
				Sometimes you need to terminate an iteration (not the entire loop), prompting Python to begin the next iteration immediately. For this, use the <code>continue</code> statement.</p>
			<p><span epub:type="pagebreak" id="Page_93" title="93"/>Let’s look at a brief example comparing an ordinary loop, a loop with a <code>break</code> statement, and a loop with a <code>continue</code> statement. There’s no need to write any code. <a href="#figure5-8" id="figureanchor5-8">Figure 5-8</a> depicts three dotted lines, drawn from left to right using each type of loop.</p>
			<p>The loop for the pale blue (top) dotted line looks like this:</p>
			<pre><code><span class="ProcessingOlive">for</span> i <span class="ProcessingTealGreen">in range</span>(20, <span class="ProcessingRaspberry">width</span>, 20): <span class="ProcessingBlue">fill</span>(<span class="ProcessingPurple">'#0099FF'</span>) <span class="ProcessingBlue">circle</span>(i, 75, 10)</code></pre>
			<p>
				With each iteration, the <code>circle()</code> function draws a new dot, placing it 20 pixels to the right of its predecessor. The first dot has an x-coordinate of 20; the loop completes as the dotted line reaches the <code>width</code> of the display window. This loop is not concerned with the two vertical red bands and draws dots right through them.</p>
			<figure>
				<img alt="f05008" src="image_fi/500969c05/f05008.png"/>
				<figcaption>
					<p><a id="figure5-8">Figure 5-8</a>: Drawing dotted lines using different loops</p>
				</figcaption>
			</figure>
			<p>The loop for the orange (middle) dotted line looks like this:</p>
			<pre><code><span class="ProcessingOlive">for</span> i <span class="ProcessingTealGreen">in range</span>(20, <span class="ProcessingRaspberry">width</span>, 20): <span class="ProcessingOlive">if</span> <span class="ProcessingBlue">red</span>(<span class="ProcessingBlue">get</span>(i, 150)) == 255: <span class="ProcessingOlive">break</span> <span class="ProcessingBlue">fill</span>(<span class="ProcessingPurple">'#FF9900'</span>) <span class="ProcessingBlue">circle</span>(i, 150, 10)</code></pre>
			<p>
				The <code>get()</code> function accepts an x-y coordinate and returns the color for the pixel at that position; to extract the red value for the pixel, you wrap the <code>get()</code> function with a <code>red()</code> function. This will return a red value between 0 and 255 based on the RGB mixture, which means a value of 255 for any pixels in the bright red bands (<code>#FF0000</code>). The loop will check for a red pixel before it draws a dot; if detected, the <code>break</code> statement will terminate the loop. The <code>fill()</code> and <code>circle()</code> functions do not draw a dot on the final iteration, because the <code>break</code> statement exits the loop immediately.</p>
			<p><span epub:type="pagebreak" id="Page_94" title="94"/>The loop for the green (bottom) dotted line looks like this:</p>
			<pre><code><span class="ProcessingOlive">for</span> i <span class="ProcessingTealGreen">in range</span>(20, <span class="ProcessingRaspberry">width</span>, 20): <span class="ProcessingOlive">if</span> <span class="ProcessingBlue">red</span>(<span class="ProcessingBlue">get</span>(i, 225)) == 255: <span class="ProcessingOlive">continue</span> <span class="ProcessingBlue">fill</span>(<span class="ProcessingPurple">'#00FF00'</span>) <span class="ProcessingBlue">circle</span>(i, 225, 10)</code></pre>
			<p>
				This loop will check for a red pixel before it draws a dot; if the pixel is detected, the <code>continue</code> statement immediately terminates the current iteration of the loop to start at the beginning of the next, skipping over the <code>fill()</code> and <code>circle()</code> functions.</p>
			<h2 id="h1-500969c05-0003">Randomness</h2>
			<p class="BodyFirst">Randomness is an important concept in computer programming because of its applications in cryptography. Moreover, randomness is programmed into everything from video games to simulations to gambling software. However, computer-generated random numbers aren’t truly random, because they’re created using a specific algorithm. If you know the algorithm and the conditions used to generate “random” numbers, you can predict patterns in the sequence. Therefore, a computer can simulate randomness only by generating <em>pseudorandom</em> numbers, which are not truly random but statistically similar enough to actual random numbers.</p>
			<p>
				In this section, you’ll use the Processing <code>random()</code> and <code>randomSeed()</code> functions to generate pseudorandom values. With these randomized values, you’ll draw more interesting patterns than you might be able to create with predefined values.</p>
			<h3 id="h2-500969c05-0004">random() Function</h3>
			<p class="BodyFirst">Each time you call Processing’s <code>random()</code> function, it produces an unexpected value within a specified range. To begin experimenting with randomness, create a new sketch and save it as <em>random_functions</em>. Add the following setup code:</p>
			<pre><code><span class="ProcessingBlue">size</span>(600, 250)<span class="ProcessingBlue">background</span>(<span class="ProcessingPurple">'#004477'</span>)<span class="ProcessingBlue">noFill</span>()<span class="ProcessingBlue">stroke</span>(<span class="ProcessingPurple">'#FFFFFF'</span>)<span class="ProcessingBlue">strokeWeight</span>(9)</code></pre>
			<p>
				The new sketch has a blue background. Soon, you’ll draw points; the size of your points is affected by the <code>strokeWeight()</code> function.</p>
			<p><span epub:type="pagebreak" id="Page_95" title="95"/>The <code>random()</code> function can accept up to two arguments. In the case of a single argument, you’re defining an upper limit:</p>
			<pre><code><span class="ProcessingBlue">print</span>(<span class="ProcessingBlue">random</span>(5))</code></pre>
			<p>This code will display a random floating-point value ranging from 0 up to but not including 5.</p>
			<p>Two arguments represent an upper and lower limit, respectively:</p>
			<pre><code><span class="ProcessingBlue">print</span>(<span class="ProcessingBlue">random</span>(5, 10))</code></pre>
			<p>This time around, the console displays a random floating-point number ranging from 5 up to but not including 10.</p>
			<p>
				If you want a random integer instead, wrap the <code>random()</code> function in <code>int()</code>. This converts the floating point to an integer by removing the decimal point and everything that follows it:</p>
			<pre><code><span class="ProcessingBlue">print</span>(<span class="ProcessingBlue">int</span>(<span class="ProcessingBlue">random</span>(5, 10)))</code></pre>
			<p><a href="#figure5-9" id="figureanchor5-9">Figure 5-9</a> shows what you can expect to see. Of course, given that the values are random, the console output will appear differently on your computer, as well as each time you run the sketch.</p>
			<figure>
				<img alt="f05009" src="image_fi/500969c05/f05009.png"/>
				<figcaption>
					<p><a id="figure5-9">Figure 5-9</a>: Experimenting with different <span class="LiteralInCaption"><code>random</code></span><span class="LiteralInCaption"><code>()</code></span> arguments</p>
				</figcaption>
			</figure>
			<p>Next, let’s generate 50 random values. Rather than print a long list in the console area, plot them as a series of points sharing a y-coordinate. Add the following code:</p>
			<pre><code><span class="LiteralGray">. . .</span><span class="ProcessingOlive">for</span> i <span class="ProcessingTealGreen">in range</span>(50): <span class="ProcessingBlue">point</span>(<span class="ProcessingBlue">random</span>(<span class="ProcessingRaspberry">width</span>), <span class="ProcessingRaspberry">height</span>/2)</code></pre>
			<p>
				This <code>point()</code> function uses the <code>random()</code> function to define its x-coordinate. The y-coordinate is always <code>height/2</code>. The points should distribute differently each time you run the sketch (<a href="#figure5-10" id="figureanchor5-10">Figure 5-10</a>).</p>
				<span epub:type="pagebreak" id="Page_96" title="96"/>
				<figure>
				<img alt="f05010" src="image_fi/500969c05/f05010.png"/>
				<figcaption>
					<p><a id="figure5-10">Figure 5-10</a>: Random values distributed along a line</p>
				</figcaption>
			</figure>
			<p>
				Now change the <code>range</code> argument from <code>50</code> to <code>500</code>, and plot the point using random x- and y-coordinates:</p>
			<pre><code><span class="LiteralGray">. . .</span><span class="LiteralGray">for i in range(</span><b>500</b><span class="LiteralGray">):</span> <span class="LiteralGray">point(random(width),</span> <b>random(height)</b><span class="LiteralGray">)</span></code></pre>
			<p>
				The result should be a display window filled with 500 randomly positioned points (<a href="#figure5-11" id="figureanchor5-11">Figure 5-11</a>).</p>
			<figure>
				<img alt="f05011" src="image_fi/500969c05/f05011.png"/>
				<figcaption>
					<p><a id="figure5-11">Figure 5-11</a>: Filling the display window with randomly positioned points</p>
				</figcaption>
			</figure>
			<p>Each time you run the sketch, it produces a (slightly) different arrangement.</p>
			<h3 id="h2-500969c05-0005">Random Seed</h3>
			<p class="BodyFirst">In Figures 5-10 and 5-11, Processing picks the coordinates from a pseudorandom <em>sequence</em> of numbers. This pseudorandom sequence itself relies on a <em>random seed</em>, which is an initial number the random function selects based on something unpredictable, like keystroke timing. For instance, you may have pressed your last key 684 milliseconds past the tick of the previous <span epub:type="pagebreak" id="Page_97" title="97"/>second. For a random number between 0 and 9, your computer can grab the last digit of the 684 (which is a 4). The random seed determines what you’ll get from your first <code>random()</code> call as well as all subsequent calls.</p>
			<p>
				You can use Processing’s <code>randomSeed()</code> function to set the random seed manually. Change the range argument to <code>10</code>, and insert a <code>randomSeed()</code> line at the very top of your working sketch:</p>
			<pre><code><span class="ProcessingBlue">randomSeed</span>(213)<span class="LiteralGray">size(600, 250)</span><span class="LiteralGray">. . .</span><span class="LiteralGray">for i in range(</span><b>10</b><span class="LiteralGray">):</span><span class="LiteralGray">    point(random(width), random(height))</span></code></pre>
			<p>
				This <code>randomSeed()</code> function accepts a single argument, any integer of your choice, but you’ll use <code>213</code> for this example. Unlike the 500-point (<a href="#figure5-11">Figure 5-11</a>) version in which no random seed had been defined, every run of the code produces the same pattern, on any computer that executes it.</p>
			<p>This ability to ensure that the program generates the same sequence of pseudorandom numbers with every run is useful in many applications. For example, suppose you developed a platform game using levels composed of randomly positioned obstacles. Not having to place obstacles manually would save a lot of time. However, you discover that specific sequences of pseudorandom numbers produce more engaging levels than others. What’s more, the resulting levels vary in difficulty, so you need to control the order in which the player progresses through them. If you’re aware of the seed values that produce each level, you can reproduce any of them, on demand, with just an integer.</p>
			<p>
				In the next section, you’ll combine a <code>for</code> loop and the <code>random()</code> function to create interesting tile arrangements.</p>
			<h2 id="h1-500969c05-0004">Truchet Tiles</h2>
			<p class="BodyFirst">Sébastien Truchet (1657–1729), a French Dominican priest, was active in the fields of mathematics, hydraulics, graphics, and typography. Among his many contributions, he developed a scheme for creating interesting patterns using tiles, which have since become known as <em>Truchet tiles</em>. The original Truchet tile is square and divided by a diagonal line between its opposing corners. This tile can be rotated in multiples of 90 degrees to produce four variants, as shown in <a href="#figure5-12" id="figureanchor5-12">Figure 5-12</a>.</p>
			<figure>
				<img alt="f05012" src="image_fi/500969c05/f05012.png"/>
				<figcaption>
					<p><a id="figure5-12">Figure 5-12</a>: A Truchet tile, presented in its four possible orientations</p>
				</figcaption>
			</figure>
			<p><span epub:type="pagebreak" id="Page_98" title="98"/>These tiles are arranged on a square grid, either randomly or according to a pattern, to create aesthetically pleasing designs. <a href="#figure5-13" id="figureanchor5-13">Figure 5-13</a> presents just four possible arrangements, including a randomized tiling (bottom right) with some ordered approaches.</p>
			<figure>
				<img alt="f05013" src="image_fi/500969c05/f05013.png"/>
				<figcaption>
					<p><a id="figure5-13">Figure 5-13</a>: Four Truchet tile layouts</p>
				</figcaption>
			</figure>
			<p>
				Next, you’ll use the quarter-circle Truchet tile, shown in <a href="#figure5-14" id="figureanchor5-14">Figure 5-14</a>, in its two possible orientations.</p>
			<p>
				Let’s apply the looping and randomness techniques you learned in this chapter to create different patterns using this tile. Create a new sketch and save it as <em>truchet_tiles</em>. Add the following setup code:</p>
			<pre><code><span class="ProcessingBlue">size</span>(600, 600)<span class="ProcessingBlue">background</span>(<span class="ProcessingPurple">'#004477'</span>)<span class="ProcessingBlue">noFill</span>()<span class="ProcessingBlue">stroke</span>(<span class="ProcessingPurple">'#FFFFFF'</span>)<span class="ProcessingBlue">strokeWeight</span>(3)<span class="ProcessingOlive">for</span> i <span class="ProcessingTealGreen">in range</span>(1, 145): <span class="ProcessingBlue">arc</span>(0, 0, 50, 50, 0, <span class="ProcessingKhaki">PI</span>/2) <span class="ProcessingBlue">arc</span>(50, 50, 50, 50, <span class="ProcessingKhaki">PI</span>, <span class="ProcessingKhaki">PI</span>*1.5)</code></pre>
			<p>
				The new sketch has a blue background. Every shape you draw will have no fill and a white stroke of 3 pixels. This is for drawing the quarter-circle designs shown in <a href="#figure5-14">Figure 5-14</a>. Each tile is 50 × 50 pixels, so there’s room for exactly 12 (600 ÷ 50) columns and 12 rows. Filling the display window, therefore, requires 144 (12 × 12) tiles, hence the <code>range(1, 145)</code>.</p>
				<span epub:type="pagebreak" id="Page_99" title="99"/>
				<figure>
				<img alt="f05014" src="image_fi/500969c05/f05014.png"/>
				<figcaption>
					<p><a id="figure5-14">Figure 5-14</a>: Quarter-circle Truchet tiles</p>
				</figcaption>
			</figure>
			<p>
				Run the sketch. A single tile should appear in the upper left corner (<a href="#figure5-15" id="figureanchor5-15">Figure 5-15</a>).</p>
			<figure>
				<img alt="f05015" src="image_fi/500969c05/f05015.png"/>
				<figcaption>
					<p><a id="figure5-15">Figure 5-15</a>: All 144 tiles placed in the upper left corner</p>
				</figcaption>
			</figure>
			<p>
				In actuality, in <a href="#figure5-15">Figure 5-15</a>, you’re looking at all 144 tiles placed in the same position!</p>
			<p>
				To control the column and row positioning, use <code>col</code> and <code>row</code> variables. Amend your script as per the boldface code:</p>
			<pre><code><span class="LiteralGray">. . .</span><b>col = 0</b><b>row = 0</b><span class="LiteralGray">for i in range(1, 145):</span> <span class="LiteralGray">arc(</span><b>col</b><span class="LiteralGray">,</span> <b>row</b><span class="LiteralGray">, 50, 50, 0, PI/2)</span> <span class="LiteralGray">arc(</span><b>col+</b><span class="LiteralGray">50,</span> <b>row+</b><span class="LiteralGray">50, 50, 50, PI, PI*1.5)</span> <b>col += 50</b></code></pre>
			<p><span epub:type="pagebreak" id="Page_100" title="100"/>With each iteration of the loop, the <code>col</code> variable (tile y-coordinate) is increased by <code>50</code>. The result should be that each tile is placed to the right of its predecessor, as shown in <a href="#figure5-16" id="figureanchor5-16">Figure 5-16</a>.</p>
			<figure>
				<img alt="f05016" src="image_fi/500969c05/f05016.png"/>
				<figcaption>
					<p><a id="figure5-16">Figure 5-16</a>: The remaining 132 tiles lie beyond the right edge.</p>
				</figcaption>
			</figure>
			<p>There’s a problem, though: the program doesn’t know when to return to the left edge and begin a new row. Instead, the tiles overflow, extending out beyond the right edge where you cannot see them.</p>
			<p>
				To correct this, nest an <code>if</code> statement within the loop:</p>
			<pre><code><span class="LiteralGray">. . .</span><span class="LiteralGray">for i in range(1, 145):</span> <span class="LiteralGray">. . .</span> <span class="ProcessingOlive">if</span> i % 12 == 0: row += 50 col = 0</code></pre>
			<p>
				The <code>i % 12</code> will return 0 for any value of <code>i</code> divisible by 12. In other words, if the remainder of a divide-by-12 operation is equal to 0, you know that you’ve just laid another 12 tiles. At this moment, the <code>row</code> variable is advanced by 50, and the <code>col</code> resets to 0. The next tile is now set up for placement at the beginning of a new row, which should result in a display window filled with tiles (<a href="#figure5-17" id="figureanchor5-17">Figure 5-17</a>).</p>
				<span epub:type="pagebreak" id="Page_101" title="101"/>
				<figure>
				<img alt="f05017" src="image_fi/500969c05/f05017.png"/>
				<figcaption>
					<p><a id="figure5-17">Figure 5-17</a>: The display window filled with quarter-circle Truchet tiles</p>
				</figcaption>
			</figure>
			<p>
				To make things more interesting, randomize the orientation of each tile by adding this <code>if...else</code> structure:</p>
			<pre><code><span class="LiteralGray">. . .</span><span class="LiteralGray">for i in range(1, 145):</span> <span class="ProcessingOlive">if</span> <span class="ProcessingBlue">int</span>(<span class="ProcessingBlue">random</span>(2)<span aria-label="annotation1" class="CodeAnnotation">1</span>):<span class="LiteralGray">        arc(col, row, 50, 50, 0, PI/2)</span><span class="LiteralGray">        arc(col+50, row+50, 50, 50, PI, PI*1.5)</span> <span aria-label="annotation2" class="CodeAnnotation">2</span> <span class="ProcessingOlive">else</span>: <span class="ProcessingBlue">arc</span>(col+50, row, 50, 50, <span class="ProcessingKhaki">PI</span>/2, <span class="ProcessingKhaki">PI</span>) <span class="ProcessingBlue">arc</span>(col, row+50, 50, 50, <span class="ProcessingKhaki">PI</span>*1.5, 2*<span class="ProcessingKhaki">PI</span>) <span class="LiteralGray">col += 50</span> <span class="LiteralGray">. . .</span></code></pre>
			<p>
				A <code>random(2)</code> function <span aria-label="annotation1" class="CodeAnnotation">1</span> will return a floating-point value ranging from 0 up to but not including 2. Converting the result to an integer by wrapping it in an <code>int()</code>, therefore, produces a 0 or 1. This is akin to flipping a coin, which is now performed with each iteration to decide which of the two tile orientations to pick. Because this “coin flip” operation returns a Boolean-compatible value—a 0 or 1—it can stand alone as the <code>if</code> statement’s condition, no relational operators necessary. The <code>else</code> code <span aria-label="annotation2" class="CodeAnnotation">2</span> runs if the result of the coin flip is a 0, because a <code>0</code> is equivalent to <code>False</code> (and <code>if</code> runs only on a <code>True</code>).</p>
			<p><span epub:type="pagebreak" id="Page_102" title="102"/>Each time you run the sketch, the display window presents a different pattern (<a href="#figure5-18" id="figureanchor5-18">Figure 5-18</a>).</p>
			<figure>
				<img alt="f05018" src="image_fi/500969c05/f05018.png"/>
				<figcaption>
					<p><a id="figure5-18">Figure 5-18</a>: An arrangement of randomized quarter-circle Truchet tiles</p>
				</figcaption>
			</figure>
			<p>
				If you’ve ever played the strategy game <em>Trax</em>, this pattern will look familiar. Another tile-based strategy game, <em>Tantrix</em>, uses a hexagonal adaptation of a Truchet tile. Of course, there’s far more to tiles than the Truchet variety. You can try adding fills, switching out semicircles for diagonal lines, adding extra tiles to the set, or adding rules about which tiles can be placed next to one another (<a href="#figure5-19" id="figureanchor5-19">Figure 5-19</a>). If you’re looking for some fun projects, plenty of tiling patterns are available for inspiration.</p>
			<figure>
				<img alt="f05019" src="image_fi/500969c05/f05019.png"/>
				<figcaption>
					<p><a id="figure5-19">Figure 5-19</a>: Variations of Truchet tiles</p>
				</figcaption>
			</figure>
			<p><span epub:type="pagebreak" id="Page_103" title="103"/>You can find code for some Truchet tile variations at <a class="LinkURL" href="https://github.com/tabreturn/processing.py-book/tree/master/chapter-05-iteration_and_randomness/truchet_tiles_variations">https://github.com/tabreturn/processing.py-book/tree/master/chapter-05-iteration_and_randomness/truchet_tiles_variations</a>.</p>
			<p>
				As your programs grow more complex, you’ll find multiple ways to code the same outcome. For example, you could have laid the quarter-circle Truchet tiles by using a loop within a loop, using <code>range()</code> functions with a step-size argument, in various combinations. Among the Truchet tile variations on Github, you’ll find an example named <em>loop_within_a_loop</em> that uses this approach. Now that you understand control flow, you can begin thinking about how to optimize your algorithms for improved readability and efficiency.</p>
			<h2 id="h1-500969c05-0005">Summary</h2>
			<p class="BodyFirst">You’ve now learned about iteration and how to program loops using <code>while</code> and <code>for</code> statements; this allows you to accomplish more in fewer lines of code, with code that’s more adaptable. Loops will reappear throughout the course of this book, providing plenty more opportunities for you to master them.</p>
			<p>
				This chapter also introduced randomness, which is useful in a variety of computing applications, including creative coding. The Processing <code>random()</code> function generates sequences of pseudorandom numbers, which you can control using a random seed in order to produce the same sequence of values each time you run your sketch.</p>
			<p>The next chapter deals with motion. You’ll learn how to add movement to your Processing sketches, and you’ll also look at transformation functions as efficient ways to move, rotate, and scale your elements, which is especially useful for groups of shapes.</p>
		</section>
	</body></html>