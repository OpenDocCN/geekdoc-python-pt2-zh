- en: '**17'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: THE GEOVIS LIBRARIES**
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Geospatial* data is anything that includes a reference to geographical location,
    such as latitude and longitude, street address, and ZIP code. It’s important to
    many fields of science, including geology, geography, meteorology, climatology,
    biology, archeology, anthropology, oceanography, economics, and sociology. As
    a result, there are lots of Python libraries dedicated to working with geospatial
    data.'
  prefs: []
  type: TYPE_NORMAL
- en: Geospatial data comprises *vector* and *raster* data ([Figure 17-1](ch17.xhtml#ch017fig1)).
    With vector data, spatial elements (think polygons, lines, and points) are represented
    by x and y coordinates. Examples include road centerlines, country boundaries,
    and Starbucks locations. Raster data consists of a matrix of rows and columns
    with some information associated with each cell (think pixels). Examples include
    aerial photos and satellite images. These data types can be applied to maps as
    *layers*, letting you show just what you need for a given task, such as using
    only vector-based street maps for navigation. You can also use vector data to
    calculate distances and areas.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/17fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-1: Representing the world with a combination of vector and raster
    data*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Geographic Information Systems (GIS)*, *Global Positioning Systems (GPS)*,
    and remote sensing are examples of technology used to acquire, process, and store
    geospatial data. Python’s flexibility makes it great for wrangling this data from
    a file or a database into something usable. Around 2008, major GIS platforms such
    as ArcGIS and QGIS adopted Python for scripting, toolmaking, and analysis. As
    a result, Python is now the dominant computer language for performing geospatial
    analysis. And just as with statistical visualization, there are a daunting number
    of Python libraries designed to help you visualize geospatial data.'
  prefs: []
  type: TYPE_NORMAL
- en: '**The Geospatial Libraries**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The purpose of geospatial libraries is to keep track of and use spatial object
    types (like points and polygons), spatial reference systems (for projecting the
    Earth’s curved surface onto a plane), geography and geometry formats (for measuring
    distances and areas accurately or quickly), common GIS data formats (for input/output),
    spatial indexing (to speed up processing), and map decorators (such as country
    borders and coastlines). Most will let you create animations, either by converting
    frames to MP4 or directly as live animation.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](ch17.xhtml#ch017tab1) lists some of the more important and popular
    geospatial libraries, along with a few specialty libraries. We’ll take a high-level
    look at several of these in the sections that follow.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Python’s More Important Geospatial Libraries'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Library** | **Description** | **Website** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| GeoPandas | GIS library meets “pandas with geometry” | *[https://geopandas.org/](https://geopandas.org/)*
    |'
  prefs: []
  type: TYPE_TB
- en: '| Cartopy | Tools for projection-aware plots with Matplotlib | *[https://scitools.org.uk/cartopy/](https://scitools.org.uk/cartopy/)*
    |'
  prefs: []
  type: TYPE_TB
- en: '| geoplot | Cartopy extension (“seaborn for geospatial”) | *[https://residentmario.github.io/geoplot/](https://residentmario.github.io/geoplot/)*
    |'
  prefs: []
  type: TYPE_TB
- en: '| Plotly | Easy interactive maps | *[https://plotly.com/python/maps/](https://plotly.com/python/maps/)*
    |'
  prefs: []
  type: TYPE_TB
- en: '| folium | Easy interactive maps with low resource usage | *[https://python-visualization.github.io/folium/](https://python-visualization.github.io/folium/)*
    |'
  prefs: []
  type: TYPE_TB
- en: '| ipyleaflet | Jupyter-LeafletJS bridge based on ipywidgets | *[https://github.com/jupyter-widgets/ipyleaflet/](https://github.com/jupyter-widgets/ipyleaflet/)*
    |'
  prefs: []
  type: TYPE_TB
- en: '| GeoViews | Geographic plots with HoloViews and Cartopy. | *[http://geoviews.org/](http://geoviews.org/)*
    |'
  prefs: []
  type: TYPE_TB
- en: '| KeplerGL | Tools to visualize large datasets in Jupyter | *[https://docs.kepler.gl/docs/keplergl-jupyter/](https://docs.kepler.gl/docs/keplergl-jupyter/)*
    |'
  prefs: []
  type: TYPE_TB
- en: '| pydeck | Large-scale interactivity tools optimized for Jupyter | *[https://pydeck.gl/](https://pydeck.gl/)*
    |'
  prefs: []
  type: TYPE_TB
- en: '| PyGMT | Python wrapper for Generic Mapping tools | *[https://www.pygmt.org/](https://www.pygmt.org/)*
    |'
  prefs: []
  type: TYPE_TB
- en: '| Bokeh | Reactive plots including on Google Maps | *[https://docs.bokeh.org/](https://docs.bokeh.org/)*
    |'
  prefs: []
  type: TYPE_TB
- en: '| EarthPy | Helper functions for working with spatial data | *[https://earthpy.readthedocs.io/](https://earthpy.readthedocs.io/)*
    |'
  prefs: []
  type: TYPE_TB
- en: '| gmplot | Matplotlib-like interface to plot on Google Maps | *[https://github.com/gmplot/gmplot/](https://github.com/gmplot/gmplot/)*
    |'
  prefs: []
  type: TYPE_TB
- en: '| MovingPandas | Tools to track and analyze movement data | *[https://anitagraser.github.io/movingpandas/](https://anitagraser.github.io/movingpandas/)*
    |'
  prefs: []
  type: TYPE_TB
- en: '| cuSpatial | GPU acceleration tool for common spatial operations | *[https://github.com/rapidsai/cuspatial/](https://github.com/rapidsai/cuspatial/)*
    |'
  prefs: []
  type: TYPE_TB
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The plotting examples in this chapter are intended to demonstrate the complexity
    of the code and the types of plots produced. You’re not expected to run the code
    snippets, because most of the libraries discussed do not come preinstalled with
    Anaconda. If you do want to test them for yourself, you can find installation
    instructions in the product web page cited in each section. I recommend that you
    install them all in a dedicated conda environment (see [Chapter 2](ch02.xhtml))
    rather than dump them in your base environment.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***GeoPandas***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*GeoPandas* is the most popular open source library for parsing geospatial
    data in Python. As you can guess from the name, it extends the data types used
    by pandas (see “pandas” on [page 403](ch15.xhtml#ch00lev2sec198)) and makes working
    with geospatial vector data similar to working with tabular data. It also enables
    operations in Python that would otherwise require a dedicated spatial database
    such as PostGIS.'
  prefs: []
  type: TYPE_NORMAL
- en: A *GeoDataFrame* in GeoPandas looks a lot like a tabular DataFrame in pandas
    but with a special “geometry” column for the location data ([Figure 17-2](ch17.xhtml#ch017fig2)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/17fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-2: The geometry column (boxed) distinguishes a GeoDataFrame from
    a DataFrame.*'
  prefs: []
  type: TYPE_NORMAL
- en: This geometry column bundles together both the *type* of geometric object ([Table
    17-2](ch17.xhtml#ch017tab2)) and the *coordinates* (as longitude and latitude)
    needed to draw it.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** Geometries Used in GeoPandas'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Geometry type** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Point | A point |'
  prefs: []
  type: TYPE_TB
- en: '| MultiPoint | A set of points |'
  prefs: []
  type: TYPE_TB
- en: '| LineString | A line segment |'
  prefs: []
  type: TYPE_TB
- en: '| MultiLineSting | A sequence of connected line segments |'
  prefs: []
  type: TYPE_TB
- en: '| LinearRing | A closed collection of lines (zero-area polygon) |'
  prefs: []
  type: TYPE_TB
- en: '| Polygon | A closed shape defined by a sequence of points |'
  prefs: []
  type: TYPE_TB
- en: '| MultiPolygon | A collection of polygons |'
  prefs: []
  type: TYPE_TB
- en: GeoPandas uses not only pandas but several other important open source libraries
    to produce a simple and convenient framework for handling geospatial data. It
    relies on the capabilities of *Shapely* (*[https://pypi.org/project/Shapely/](https://pypi.org/project/Shapely/)*)
    for working with planar geometric shapes (such as street centerlines or country
    boundary polygons), Fiona (*[https://pypi.org/project/Fiona/](https://pypi.org/project/Fiona/)*)
    for reading and writing geographic data file formats, pyproj (*[https://pypi.org/project/pyproj/](https://pypi.org/project/pyproj/)*)
    for handling projections, Matplotlib for plotting, and descartes (*[https://pypi.org/project/descartes/](https://pypi.org/project/descartes/)*)
    for integrating Shapely geometry objects with Matplotlib.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a result, you can plot a map from a GeoSeries or GeoDataFrame with only
    a couple of lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![Image](../images/f0461-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this Jupyter Notebook example, the `world` variable represents a GeoDataFrame
    made from one of GeoPandas’ internal global datasets. Of course, this simple plot
    can be customized further. Style options that you can pass to Matplotlib, especially
    those for lines, will work with the `plot()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of a choropleth map—where regions are shaded based on a data
    value—for population by country:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![Image](../images/f0462-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'With the world data loaded as a GeoDataFrame, it’s easy to filter the data
    and replot it. In the previous plot, we removed Antarctica, given that it has
    no permanent population. Now let’s look at all the countries with a population
    greater than 300 million by changing one line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Rerunning the code block reveals only China, India, and the United States:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0462-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Historically, you could plot only static maps with GeoPandas. Now, thanks to
    Contextily (*[https://github.com/geopandas/contextily](https://github.com/geopandas/contextily)*)
    for base maps, and IPYMPL (*[https://github.com/matplotlib/ipympl](https://github.com/matplotlib/ipympl)*)
    for interactive Matplotlib plots in Jupyter, it’s possible to make interactive
    maps with GeoPandas. Likewise, hvPlot, built on HoloViews (see [Chapter 16](ch16.xhtml)),
    uses an interactive Bokeh-based plotting API to add zooming, panning, querying,
    sliders, and clickable legends to both pandas and GeoPandas output ([Figure 17-3](ch17.xhtml#ch017fig3)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/17fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: An interactive hvPlot with toolbar and slider widget (courtesy
    of [holoviz.org](http://holoviz.org))*'
  prefs: []
  type: TYPE_NORMAL
- en: With the Contextily library installed and imported, GeoPandas can support *tile-based*
    maps as well as the outline-based geo-maps shown previously. A tile map (or *web
    map tile*) is a map displayed in a browser by seamlessly joining dozens of individually
    requested image or vector data files over the Internet. The street and terrain
    layers in Google Maps are familiar examples of tile-based maps. Contextily provides
    easy access to popular tile sources like OpenStreetMap and Stamen, letting you
    add backgrounds similar to those in Google Maps ([Figure 17-4](ch17.xhtml#ch017fig4)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/17fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: A tile map of part of Tokyo, Japan*'
  prefs: []
  type: TYPE_NORMAL
- en: Like pandas, GeoPandas operates on a single core, but it also supports *spatial
    indexing*, a technique that can significantly boost performance when querying
    large geospatial datasets. GeoPandas can generate spatial indexes, automatically
    in some cases and manually in others, by letting you call the `sindex` attribute
    on a GeoDataFrame. In addition, a new library, *geofeather* (*[https://pypi.org/project/geofeather/](https://pypi.org/project/geofeather/)*),
    can significantly speed-up reading and writing standard spatial file formats (such
    as *shapefile*).
  prefs: []
  type: TYPE_NORMAL
- en: GeoPandas is a good all-purpose tool if you’re not planning to perform complex
    data transformations or work with millions of records. Plotting with this tool
    requires knowledge of the somewhat arcane Matplotlib syntax, and add-ons are needed
    to add interactivity. GeoPandas works best with vector data but you can also perform
    limited raster processing using *rasterio* (*[https://rasterio.readthedocs.io/en/latest/](https://rasterio.readthedocs.io/en/latest/)*).
    Fortunately, many other geospatial libraries work well with GeoPandas, so you
    have the option of organizing your data in GeoPandas and plotting it with a different
    tool.
  prefs: []
  type: TYPE_NORMAL
- en: '***Cartopy***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Cartopy* is an open source library for producing maps and performing geospatial
    analyses. It’s engineered for scientists and maintained by an active development
    community. Cartopy is an extension of Python’s standard plotting library, Matplotlib,
    and makes use of other libraries, including NumPy, Shapely, and PROJ.4.'
  prefs: []
  type: TYPE_NORMAL
- en: Cartopy prides itself on being very “projection aware.” That is, it can handle
    a large number of projections ([Figure 17-5](ch17.xhtml#ch017fig5)) and transform
    points, lines, vectors, polygons, and images between these projections. It also
    pairs well with GeoPandas, allowing you to easily create cartographically accurate
    maps while using raster data more easily than in GeoPandas alone. If you use Matplotlib
    for basic plots, Cartopy lets you extend your skills into cartography with little
    extra effort.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/17fig05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: A few of the many map projections available in Cartopy*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As with many other geospatial libraries, you can make a basic map using only
    a few lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![Image](../images/f0465-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Depending on your setup, Cartopy can post up to a million points quickly but
    performance noticeably drags with larger datasets. You can see more Cartopy plot
    examples on its gallery page (*[https://scitools.org.uk/cartopy/docs/latest/gallery/index.html](https://scitools.org.uk/cartopy/docs/latest/gallery/index.html)*)
    and a list of supported map projections at *[https://scitools.org.uk/cartopy/docs/v0.19/crs/projections.html](https://scitools.org.uk/cartopy/docs/v0.19/crs/projections.html)*.
  prefs: []
  type: TYPE_NORMAL
- en: '***Geoplot***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Geoplot* is a fairly new, high-level, open source geospatial plotting library.
    As an extension to Cartopy and Matplotlib, it claims to be the “seaborn of geospatial,”
    which means that it builds on the underlying libraries to make mapping easy.'
  prefs: []
  type: TYPE_NORMAL
- en: Geoplot is designed to work well with GeoPandas input and provides a selection
    of easy-to-use geospatial visualizations (presumably, 90 percent of what you will
    ever need). And because geoplot is built on Cartopy, it can take advantage of
    Cartopy’s extensive list of map projections.
  prefs: []
  type: TYPE_NORMAL
- en: 'A standout feature for geoplot is the *cartogram*, a thematic map of polygons,
    such as provinces or states, whose geographic size is warped to be proportional
    to a selected variable, like population, gross domestic product, or obesity level.
    In the following example from geoplot’s plot reference page, you use geopandas
    and one of geoplot’s native datasets, `contiguous_usa`, to easily generate a cartogram
    of the US population by state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![Image](../images/f0466-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this cartogram, California, the most populous state, is shown at its true
    size. The remaining states are reduced in size based on the relative size of their
    population.
  prefs: []
  type: TYPE_NORMAL
- en: Geoplot also lets you produce Sankey diagrams. These are a type of flow diagram
    in which the width of lines and arrows is proportional to the volume of movement
    being visualized, such as the flow of traffic over city streets ([Figure 17-6](ch17.xhtml#ch017fig6)).
    The most famous Sankey diagram depicts Napoleon’s infamous Russian campaign and
    retreat from Moscow.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/17fig06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-6: Sankey diagram of streets in Washington DC by average daily traffic
    (courtesy of geoplot)*'
  prefs: []
  type: TYPE_NORMAL
- en: Like GeoPandas, geoplot makes only static maps. With some extra work, however,
    such as writing your figure to HTML and using the mplleaflet library, you can
    enable interactivity like zooming and panning.
  prefs: []
  type: TYPE_NORMAL
- en: Geoplot lets you easily make maps if you’re comfortable with giving up a lot
    of design control. To move beyond the basic functionality and produce highly customized
    maps, you’ll need to be familiar with Matplotlib. And even though the core documentation
    is not bad, the immaturity of geoplot means you might have trouble finding tutorials
    or examples to match your specific use cases. Geoplot is also in “maintenance”
    state, with no new features planned.
  prefs: []
  type: TYPE_NORMAL
- en: '***Plotly***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Plotly and Plotly Express, introduced in [Chapter 16](ch16.xhtml), have extensive
    geospatial data visualization capabilities. They offer many mapping options and
    the Plotly Express API is easy to use. You can make an animated choropleth map
    with a single line of code and deploy it to the web using Dash.
  prefs: []
  type: TYPE_NORMAL
- en: Plotly maps are useful for quickly exploring data, identifying outliers, and
    recognizing trends. You can use the convenience of GeoPandas, or if you have latitude
    and longitude in columns, plot straight from a pandas DataFrame. The following
    Jupyter Notebook example, using Plotly Express, turns a Plotly dataset on worldwide
    volcanoes into a highly interactive figure with only a few lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![Image](../images/f0468-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Most of the code consists of importing libraries ➊ and loading the data before
    performing the actual plotting ➋. Within this plot, you can use the cursor to
    grab and rotate the map as if it were a real three-dimensional globe. You can
    hover the cursor over a volcano marker and get a pop-up window listing the type
    of volcano along with other information such as its location, country, and name.
    You also have the option to make markers clickable so that pop-up windows appear
    only when you deliberately use a mouse button.
  prefs: []
  type: TYPE_NORMAL
- en: If you look at the upper-right corner of this plot, you’ll see a toolbar that
    lets you take screenshots, pan, zoom, and so on. These tools are hugely helpful,
    especially when you need to resolve closely packed data points, such as the numerous
    volcanoes in Iceland ([Figure 17-7](ch17.xhtml#ch017fig7)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/17fig07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-7: Plotly Express reposts data at the appropriate scale for the
    zoom level.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also make 3D surface plots with Plotly, whose automatic toolbars permit
    rotations about multiple axes. Here’s an example for a single volcano:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![Image](../images/f0469-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Like most other geospatial libraries, Plotly and Plotly Express support *tile-based*
    maps (see [Figure 17-4](ch17.xhtml#ch017fig4)) for adding streets, terrain, imagery,
    and so on. Unlike GeoPandas, you can access these directly, without the need for
    a separate library, like Contextily.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to quickly build interactive plots in which you can query a map
    by hovering the cursor over a region, or position user-input widgets like sliders
    on the same screen as the map, Plotly and Plotly Express are sound choices. And
    with Plotly’s Dash library (see “Dash” on [page 446](ch16.xhtml#ch00lev2sec220)),
    you can seamlessly convert your work into a dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: '***folium***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The open source *folium* library lets you visualize maps using *Leaflet.JS*,
    a powerful JavaScript library for building interactive web-mapping applications
    on most mobile and desktop platforms. First released in 2013, folium is extremely
    popular, and as a result, you’ll find a wealth of material on the internet to
    help you learn how to use it and customize it to your needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'With folium, you can select from a number of *tilesets* from mapping services
    like OpenStreetMap, Mapbox, and Stamen. Tilesets are collections of raster or
    vector data broken up into a uniform grid of square tiles with up to 22 preset
    zoom levels. They let you produce beautiful leaflet maps with no effort at all:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![Image](../images/f0470-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This Jupyter Notebook example uses the OpenStreetMap tile by default. The location
    coordinates for the center of the map are in latitude and longitude (this can
    trip you up, as many libraries use the modern longitude-latitude order). You can
    look up these values for an address using tools like *LatLong.net* (*[https://www.latlong.net/geo-tools](https://www.latlong.net/geo-tools)*)
    or by simply doing an online search for a geographic feature’s coordinates. It’s
    also possible to query folium maps for this information using your cursor. This
    map is also scalable; when you zoom in, you get more and more detailed information
    until you exhaust the available tileset zoom levels.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another strength of folium is its support of *markers*. You’ve probably seen
    these teardrop-shaped icons used to identify search locations on Google maps.
    Folium comes with several predefined markers and will also let you build a custom
    marker by using an image or by accessing free icon libraries. You can also include
    a pop-up window with content. Let’s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![Image](../images/f0471-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code uses the “Stamen Terrain” tile depicting the area around Lake Powell
    in Utah. The marker represents the location of a water quality sample, and clicking
    it reveals the sample number.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s revisit the volcanoes dataset used in “Plotly” on [page 467](ch17.xhtml#ch00lev2sec233).
    If you’re running the code, you can download the volcano icon from sites such
    as Free [onlinewebfonts.com](http://onlinewebfonts.com) (*[https://onlinewebfonts.com/fonts](https://onlinewebfonts.com/fonts))*
    or Iconfinder (*[https://iconfinder.com/](https://iconfinder.com/))*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This script produces another world map of volcano locations. [Figure 17-8](ch17.xhtml#ch017fig8)
    is this map zoomed in to Iceland, similar to [Figure 17-7](ch17.xhtml#ch017fig7).
    Note the custom volcano icons, terrain background, hover window, index map at
    lower right, and scale bar at lower left. All with just a few lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/17fig08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-8: Icelandic volcanoes plotted with folium*'
  prefs: []
  type: TYPE_NORMAL
- en: Because folium embeds lots of information, file sizes can grow quite large.
    For example, the previous code produced a 138MB notebook file.
  prefs: []
  type: TYPE_NORMAL
- en: Combining folium with the popular GeoPandas library is a great way to visualize
    georeferenced data. Imagine that you’re studying the urban “heat island” effect
    around Paris, France. You’ve recorded thousands of temperature measurements east
    of the city and you’re using GeoPandas to manipulate this data. With a folium
    heatmap, the measurements will aggregate or separate depending on the map’s zoom
    level ([Figure 17-9](ch17.xhtml#ch017fig9)). You can also add a time series, making
    it possible for you to see temperature variations throughout the day, month, year,
    and so on. And with folium’s `MarkerCluster` plug-in, you can adapt this same
    technique to individual markers. Just don’t try adding a legend; folium’s support
    for this feature extends only to choropleth maps.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/17fig09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-9: A heatmap of temperature data zoomed out (left) versus zoomed
    in (right)*'
  prefs: []
  type: TYPE_NORMAL
- en: The folium library is designed for simplicity, performance, and usability. By
    combining the data analysis capabilities of Python libraries like GeoPandas with
    the mapping strengths of LeafletJS, folium lets you generate maps with multiple
    layers of data representation. It’s extremely easy to include useful backgrounds
    such as street maps and terrain maps, and there are lots of plug-ins available
    to extend folium’s functionality (see *[https://python-visualization.github.io/folium/plugins.html#folium-plugins/](https://python-visualization.github.io/folium/plugins.html#folium-plugins/)*).
  prefs: []
  type: TYPE_NORMAL
- en: '***ipyleaflet***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *ipyleaflet* open source interactive widgets library is based on ipywidgets
    (*[https://github.com/jupyter-widgets/ipywidgets/](https://github.com/jupyter-widgets/ipywidgets/)*).
    Like folium, ipyleaflet wraps Leaflet.JS to bring mapping capabilities to both
    Jupyter Notebook and JupyterLab. Although folium is considered easier to use,
    ipyleaflet is considered more customizable and provides more avenues for interactivity.
  prefs: []
  type: TYPE_NORMAL
- en: Everything in ipyleaflet, such as tile maps and markers, is interactive, and
    you can dynamically update attributes from Python or the Notebook interface. And
    because ipyleaflet is built upon ipywidgets, you can write programs that use widgets
    to capture user input.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that you’re compiling statistics on terrestrial impact craters. In
    this example, you use the measure control widget and your mouse to interactively
    find both the radius and area of Aorounga Crater in the Republic of Chad:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![Image](../images/f0474-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Clicking the square (![Image](../images/icon01.jpg)) icon on the map activates
    the Measure Distances and Areas tool. You can then click two locations to get
    the linear measurement between them or draw a polygon to get an area, as shown
    in the preceding example. You can even customize the units.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another interesting control option is the *SplitMap*, which lets you compare
    a different set of layers at the same location. Imagine that you’re studying a
    night view of Europe and you’re curious about which city is causing a bright cluster
    of lights. With only a few lines of code, you can generate a dual-layer display
    to answer the question:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '![Image](../images/f0475-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The previous code produces a “split” map with cities and streets on the left
    and the nighttime satellite view on the right. You can grab the round “|||” marker
    at the center of the screen and drag it to each side to extend one of the maps
    at the expense of the other ([Figure 17-10](ch17.xhtml#ch017fig10)). This lets
    you peek beneath the nighttime map to see the cities and roads, without the need
    to clutter one map by combining it with another or by adjusting the upper map’s
    transparency. You can also zoom in to see smaller cities.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/17fig10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-10: The SplitMap boundary dragged to the right*'
  prefs: []
  type: TYPE_NORMAL
- en: The *Magnifying Glass* is a particularly fun feature that lets you view details
    without changing the overall zoom level of a map. When it’s active, you simply
    move a circle over a map with your cursor to get a zoomed-in view within the circle
    ([Figure 17-11](ch17.xhtml#ch017fig11)). It works at any zoom level and with all
    of the available base maps.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/17fig11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-11: The Magnifying Glass option in ipyleaflet*'
  prefs: []
  type: TYPE_NORMAL
- en: Much of this functionality, along with things like marker clustering, is also
    available in folium, though you might need to use a plug-in (*[https://python-visualization.github.io/folium/plugins.html#folium-plugins/](https://python-visualization.github.io/folium/plugins.html#folium-plugins/)*)
    to replicate what you can do in ipyleaflet. However, this functionality overlap
    does not include ways to get user interactions such as selections back into Python
    for further processing, as folium provides only a one-way path from Python into
    a JavaScript map.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Similar to ipyleaflet, Jupyter-gmaps ([https://github.com/pbugnion/gmaps/](https://github.com/pbugnion/gmaps/))
    is also built upon the Jupyter interactive widgets framework but bridges between
    Jupyter and Google Maps rather than Leaflet.JS.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***GeoViews: The HoloViz Approach***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The HoloViz-maintained libraries, discussed in [Chapter 16](ch16.xhtml) (see
    [Figure 16-9](ch16.xhtml#ch016fig9)), provide a unified solution for working with
    geospatial data. This includes dashboards and other types of interactive visualization.
    Within this collection of open source libraries, HoloViews provides a lot of support
    for geospatial data, including the ability to perform basic geoscience work.
  prefs: []
  type: TYPE_NORMAL
- en: For more advanced work, especially work involving map projections, HoloViz includes
    a dedicated geospatial library called *GeoViews*. Built on HoloViews, and with
    geographic plot types based on the Cartopy library, GeoViews can use either Matplotlib
    or Bokeh as a plotting backend.
  prefs: []
  type: TYPE_NORMAL
- en: GeoViews lets you work with large, multidimensional geographic datasets, quickly
    visualizing subsets or combinations with access to the underlying raw data. It’s
    designed to work with Iris and xarray libraries and can accept multiple data formats
    including NumPy arrays, pandas DataFrames, and GeoPandas GeoDataFrames. In these
    cases, the data is wrapped in a HoloViews or GeoViews object that provides instant
    interactive visualizations (see “HoloViews” on [page 436](ch16.xhtml#ch00lev2sec217)).
    Geographic projections use the extensive Cartopy coordinate reference system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like other geospatial libraries, GeoViews gives you access to all kinds of
    useful databases, polygon sets (such as for country boundaries), and tile maps
    of streets and terrain. Plots can be made from only a few lines of code, as in
    this Jupyter Notebook example from the official web page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '![Image](../images/f0477-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'GeoViews’ support for GeoPandas data structures allows for easy plotting of
    shapefiles and choropleths. Here’s an example of plotting a human population choropleth
    map using a GeoPandas dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '![Image](../images/f0478-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, here’s the volcanoes example with a twist. Because GeoViews is part
    of HoloViz, you have the option of plotting with hvPlot, which I personally find
    easier to use (much like Plotly Express versus Plotly):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '![Image](../images/f0479-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this case, all the volcano types other than shield volcanoes, stratovolcanoes,
    and cones were dropped from the DataFrame ➊. The map was then customized to plot
    these volcano types with unique shapes ➋, sizes, and colors. Although not shown
    here, you also have the option of assigning a default shape and size.
  prefs: []
  type: TYPE_NORMAL
- en: Note the toolbar along the right side, with icons for panning, zooming, saving,
    and so on, and the customizable hover window. Unfortunately, there’s no tool for
    rotating a globe in an orthographic projection as you can do with Plotly Express,
    as hvPlot uses only Bokeh rather than Plotly as a plotting backend.
  prefs: []
  type: TYPE_NORMAL
- en: A major selling point for GeoViews is that it’s part of a holistic, forward-looking
    solution designed to satisfy all your plotting and mapping needs. On the downside,
    documentation is somewhat limited compared to other libraries.
  prefs: []
  type: TYPE_NORMAL
- en: '***KeplerGL***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*KeplerGL JupyterLab extension* is an advanced open source geospatial library
    built on top of Mapbox GL (*[https://www.mapbox.com/](https://www.mapbox.com/)*)
    and deck.gl (*[https://deck.gl/](https://deck.gl/)*). The latter is a WebGL (GPU)-powered
    framework for visually exploring large datasets using a layered approach. It has
    an extensive catalog of layer types for bitmaps, icons, point clouds, grids, contours,
    terrain, and more (see *[https://deck.gl/docs/api-reference/layers/](https://deck.gl/docs/api-reference/layers/)*).'
  prefs: []
  type: TYPE_NORMAL
- en: Uber developed KeplerGL (*[https://kepler.gl/](https://kepler.gl/)*) as a web-based
    tool to make it easier for users with a variety of experience and skill levels
    to create meaningful data visualizations. It’s designed for working with large
    geospatial datasets, especially those related to mobility. It includes impressive
    functionality including a GUI ([Figure 17-12](ch17.xhtml#ch017fig12)) that lets
    you drag and drop datasets, use built-in time–series animations, visualize in
    3D, handle millions of data points, perform spatial aggregations on the fly, and
    customize maps by tweaking colors, changing sizes, filtering, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/17fig12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-12: The KeplerGL interface for customizing maps works in JupyterLab
    (courtesy of KeplerGL).*'
  prefs: []
  type: TYPE_NORMAL
- en: With the KeplerGL GUI running in Jupyter, you can eschew Python completely.
    You can drag and drop a data file into the browser, visualize it with different
    map layers, explore it by filtering and aggregating it, and eventually export
    the final visualization as a static map or an animated video. The website will
    walk you through the map-making workflow (*[https://docs.kepler.gl/docs/user-guides/b-kepler-gl-workflow/](https://docs.kepler.gl/docs/user-guides/b-kepler-gl-workflow/)*)
    and show you how to use the GUI’s friendly menus ([Figure 17-13](ch17.xhtml#ch017fig13)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/17fig13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-13: A KeplerGL interface menu for selecting a map layer type (courtesy
    of KeplerGL)*'
  prefs: []
  type: TYPE_NORMAL
- en: KeplerGL provides a set of Mapbox basemaps for backgrounds including ones for
    land, water, roads, building footprints, 3D buildings, and labels. You have to
    register with Mapbox, and the free plan comes with 50,000 map downloads per month,
    sufficient for most small applications. You’re also restricted to using data in
    CSV, GeoJSON, pandas DataFrame, or GeoPandas GeoDataFrame formats, which rules
    out live streaming.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up and using KeplerGL is a little more involved than other geospatial
    libraries. It works in JupyterLab and (currently) must be installed using Python’s
    standard package manager (`pip`) rather than with conda or conda-forge.
  prefs: []
  type: TYPE_NORMAL
- en: '***pydeck***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *pydeck* graphics library is a set of Python bindings, optimized for a Jupyter
    Notebook environment, for making spatial visualizations using deck.gl. As mentioned
    in the previous section, deck.gl is a WebGL-powered framework for visually exploring
    large datasets using a layered approach.
  prefs: []
  type: TYPE_NORMAL
- en: The pydeck library grants you access to the full deck.gl layer catalog in Python.
    You can create beautiful deck.gl maps ([Figure 17-14](ch17.xhtml#ch017fig14))
    without using a lot of JavaScript, and you can embed these maps in a Jupyter notebook
    or export them to a stand-alone HTML file. The library has been designed to work
    in tandem with popular JavaScript base map providers, especially Mapbox, but other
    map tile solutions, like OpenStreetMap, may come with different levels of compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/17fig14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-14: Personal injury road accidents in Great Britain ([https://pydeck.gl/gallery/hexagon_layer.html](https://pydeck.gl/gallery/hexagon_layer.html))*'
  prefs: []
  type: TYPE_NORMAL
- en: Pydeck supports large-scale updates, such as color changes or data modification,
    to hundreds of thousands of visualized data points in 2D and 3D. And like ipyleaflet,
    there’s support for two-way communication, by which data selected in a visualization
    can be passed back to the Jupyter Notebook kernel. For example, you can pass geometry
    data loaded into a map from a government source into a pandas DataFrame.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s visit our volcano database yet again. The following code snippet, entered
    in a Jupyter notebook, loads the data as a pandas DataFrame and then produces
    a global map zoomed-in on the Horn of Africa:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '![Image](../images/f0482-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After importing the libraries and reading the CSV file in as a DataFrame, you
    call pydeck’s `Layer` method and choose a `ScatterplotLayer` ➊. In the process,
    you also make the points 10 km in radius, color them white, and make them “pickable”
    so that you can hover the cursor over each point to see the associated data in
    the DataFrame (as shown on the map for the “Dama Ali” volcano).
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to set the `view_state`, which tells pydeck where to center the
    map, how far in to zoom, and the `pitch` and `bearing` ➋. These last two let you
    produce a tilted view, like the one in [Figure 17-14](ch17.xhtml#ch017fig14).
    You end by telling pydeck how to render the map and save it as an HTML file ➌.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you play with this example for a few minutes, some issues become apparent.
    To assign each type of volcano a unique color, you need to create a new column
    in the DataFrame using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Likewise, if you want a legend, you’ll need to use an external library like
    Matplotlib to make one (search for `matplotlib.pyplot.colorbar`) and then render
    it beside your pydeck visualization. Compare this to the Plotly Express and hvPlot
    examples, in which both of these tasks were either extremely intuitive or completely
    automatic.
  prefs: []
  type: TYPE_NORMAL
- en: These issues are partly a function of pydeck’s immaturity and might be addressed
    by the time you read this. However, the current takeaway is that pydeck is best
    reserved for data analytics use cases with large datasets—and that’s where it
    excels.
  prefs: []
  type: TYPE_NORMAL
- en: With pydeck, you can use Python to access *Google Earth Engine* (*[https://earthengine.google.com/](https://earthengine.google.com/)*),
    a cloud computing platform for processing satellite imagery and other Earth observation
    data. Earth Engine hosts a multi-petabyte catalog of geospatial datasets and satellite
    imagery that includes historical earth images going back more than 40 years. It
    ingests images on a daily basis, stores them in a public data archive, and then
    makes them freely available for global-scale data mining by academic, nonprofit,
    business, and government users.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to allowing access to a large warehouse of geospatial data, Earth
    Engine provides the computational power, APIs, and other tools needed to analyze
    the large datasets. According to the website, these tools provide planetary-scale
    analysis capabilities that allow scientists, researchers, and developers to detect
    changes, map trends, and quantify differences on the Earth’s surface.
  prefs: []
  type: TYPE_NORMAL
- en: The *pydeck-earthengine-layer* wrapper (*[https://github.com/UnfoldedInc/earthengine-layers/tree/master/py/](https://github.com/UnfoldedInc/earthengine-layers/tree/master/py/)*)
    connects pydeck to Google Earth Engine using deck.gl layers for the Earth Engine
    API (*[https://earthengine-layers.com/](https://earthengine-layers.com/)*). This
    makes it possible to visualize enormous geospatial datasets with Python. The pydeck
    wrapper, released in 2020, can be easily installed through conda-forge. To use
    it, you’ll need to authenticate with an Earth Engine–enabled Google Account (you
    can sign up at *[https://earthengine.google.com/new_signup/](https://earthengine.google.com/new_signup/)*).
  prefs: []
  type: TYPE_NORMAL
- en: Whereas Earth Engine visualizations are typically raster based, pydeck gives
    you the ability to mix raster- and vector-based graphics to open up new visualization
    opportunities. You can add interactivity, such as hover-based tooltips, and you
    can interpret Earth Engine data as terrain elevations to display them in 3D. You
    can even upload and manipulate your own datasets using Earth Engine *platform*
    (*[https://earthengine.google.com/platform/](https://earthengine.google.com/platform/)*).
  prefs: []
  type: TYPE_NORMAL
- en: To help you get started, Earth Engine comes with many prepackaged datasets (*[https://developers.google.com/earth-engine/datasets/](https://developers.google.com/earth-engine/datasets/)*)
    and example case studies (*[https://earthengine.google.com/case_studies/](https://earthengine.google.com/case_studies/)*).
    With pydeck and Earth Engine, you can monitor rainfall and floods, vegetation
    changes, forest fires and deforestation, urban sprawl, and more, without the need
    to download thousands of satellite images to your computer.
  prefs: []
  type: TYPE_NORMAL
- en: If you expect to work regularly with “planetary scale” datasets, pydeck is a
    great solution. It’s also easier to install than KeplerGL because you can use
    conda-forge. Though it can’t compete with Plotly Express or hvPlot for making
    quick and simple plots on smaller datasets, that gap should start to close as
    the product matures.
  prefs: []
  type: TYPE_NORMAL
- en: '***Bokeh***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Bokeh, introduced in [Chapter 16](ch16.xhtml), is one of the major plotting
    libraries for Python. Like the Matplotlib and Plotly libraries, it comes with
    its own geospatial capabilities (*[https://docs.bokeh.org/en/latest/docs/user_guide/geo.html](https://docs.bokeh.org/en/latest/docs/user_guide/geo.html)*).
  prefs: []
  type: TYPE_NORMAL
- en: Bokeh can accept geospatial data from multiple sources, including GeoPandas
    and GeoJSON. It can also consume XYZ tile services which use the Web Mercator
    projection. With the `gmap()` method you can plot glyphs over a Google Map, though
    you must pass the method a Google API Key, and any use of Bokeh with Google Maps
    must be within Google’s Terms of Service.
  prefs: []
  type: TYPE_NORMAL
- en: Although Bokeh lets you reproduce geospatial capabilities available in other
    libraries, such as choropleths, heatmaps, map tiles, and so on, you might find
    the process more difficult. A common user complaint is that the documentation
    and learning resources are limited. Beginners can also struggle with the “mid-level”
    API that is not exactly difficult, but it’s not exactly easy, either. This can
    be mitigated somewhat by using a high-level API like hvPlot that uses Bokeh as
    its plotting backend.
  prefs: []
  type: TYPE_NORMAL
- en: '**Choosing a GeoVis Library**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At this point, you’ve probably concluded that choosing any kind of visualization
    library in Python is like shopping for a new car. You’ll never get all the features
    you want in one place, and for every really useful feature there’s an offsetting
    limitation that forces you to compromise.
  prefs: []
  type: TYPE_NORMAL
- en: There is hope, however. Thanks to “bridging” libraries like Contextily, IPYMPL,
    hvPlot, and others, the lines between geospatial plotting libraries are becoming
    increasingly blurred. In addition, most libraries can work with GeoPandas, Python’s
    workhorse for parsing geospatial data, and libraries like Datashader can help
    with plotting large datasets.
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, there are still some important differences that can inform your
    decision of which library, or libraries, to use. As noted in the previous chapter,
    maturity can be a discriminating factor among plotting libraries. [Figure 17-15](ch17.xhtml#ch017fig15)
    shows the age of the various GeoVis libraries as of the year 2022\. This plot
    is at the same scale as Figure 16-26, and if you compare the two, you’ll see that
    even the oldest GeoVis libraries are less than half the age of the oldest InfoVis
    and SciVis library.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/17fig15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-15: The relative ages of the GeoVis libraries*'
  prefs: []
  type: TYPE_NORMAL
- en: Still, the volume of discussion around mature and widely used libraries such
    as GeoPandas, folium, and Plotly means you’ll find abundant material on how to
    use them. They will be more battle-tested, and you’re unlikely to be the first
    person to encounter a frustrating bug or show-stopping limitation. At the same
    time, some younger libraries have “old bones.” For example, geoplot is built on
    Cartopy, and GeoViews is built on HoloViews and Cartopy, both of which have 10
    times the number of users of GeoViews itself. Whether a library is mature and
    well used depends to some degree on the libraries on which it is built.
  prefs: []
  type: TYPE_NORMAL
- en: To further discriminate among libraries, let’s focus on strongpoints. This book
    assumes that most scientists will want to abstract away as much programming as
    possible and learn only one API. To this end, the shaded cells in [Figure 17-16](ch17.xhtml#ch017fig16)
    indicate an out-of-the-box distinguishing feature of a library, based on a combination
    of factors such as the developer’s claims, online tutorials and reviews, and my
    own personal experience. The darker the shade the better, and qualifying factors
    are annotated. Lack of shading does not necessarily mean a feature is absent from
    a library but that 1) it’s subordinate to what you can find in competing libraries,
    or 2) it requires the use of additional libraries for implementation.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/17fig16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-16: Strongpoints (shaded with qualifiers) of important Python geospatial
    libraries*'
  prefs: []
  type: TYPE_NORMAL
- en: As an example, one of Cartopy’s main selling points is its powerful projection
    system, permitting highly accurate mapping together with the ability to perform
    complex data transformations between reference systems. This doesn’t mean the
    other libraries will plot New York City in the middle of the Atlantic, it just
    means that they are subordinate to Cartopy, and libraries built on it, when it
    comes to handling projections. So, if this capability is very important to you,
    Cartopy, geoplot, and GeoViews should be on your radar.
  prefs: []
  type: TYPE_NORMAL
- en: The folium and ipyleaflet libraries come with a large selection of easily accessible
    map tiles. GeoPandas provides access to these through the Contextily library.
    Although this isn’t a high hurdle to clear, it does break the premise of *science
    first, programming second*.
  prefs: []
  type: TYPE_NORMAL
- en: If you expect to do a lot of remote sensing work, the pydeck library comes with
    an easy connection to Google Earth Engine with its petabytes of satellite imagery.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to ease of use, Plotly Express and folium can’t be beat. They
    represent plotting “sweet spots” that do many things well, as long as you’re not
    using huge datasets. To appreciate this, try to reproduce the Plotly Express map
    in [Figure 17-7](ch17.xhtml#ch017fig7) with other libraries and the same amount
    of code, as shown on [page 467](ch17.xhtml#ch00lev2sec233).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re already a seaborn and Matplotlib user, you should find GeoPandas,
    Cartopy, and geoplot somewhat intuitive. GeoViews suffers from limited documentation,
    but you can use hvPlot, also part of the HoloViz family, as an easy-to-use “Plotly
    Express-like” plotting option (see “GeoViews: The HoloViz Approach” on [page 476](ch17.xhtml#ch00lev2sec236)).'
  prefs: []
  type: TYPE_NORMAL
- en: GeoViews appears to check all the boxes to some degree. It’s a single, do-it-all,
    cradle-to-grave library that, as part of the unified HoloViz family, may position
    you well for the future. First released in 2016, GeoViews has time to grow its
    popularity and, hopefully, its supporting documentation.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of data size, most libraries have no trouble plotting hundreds of thousands
    of points, but many begin to choke on larger datasets. This can be mitigated somewhat
    with Datashader. Though not a geospatial library per se, it’s a must-have library
    for scientists who deal with really large geospatial datasets. It breaks the visualization
    process into multiple steps and runs in parallel to quickly create displays for
    large datasets. Likewise, pydeck helps you manage the enormous datasets available
    through sites like Google Earth Engine.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, just because GeoPandas doesn’t tick many boxes doesn’t mean you won’t
    be using it. It’s still the most popular way to wrangle geospatial data. There
    are just better ways to plot and explore the results.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Geospatial data comprises vector and/or raster data that includes a reference
    to geographical location. In this chapter, we reviewed the more important Python
    libraries for plotting this type of data.
  prefs: []
  type: TYPE_NORMAL
- en: The most popular open source Python library for parsing geospatial data is GeoPandas,
    which also comes with plotting capability built on top of Matplotlib. As many
    other packages work with GeoPandas, you might find yourself using this library
    for preparing data while plotting the results using a different tool.
  prefs: []
  type: TYPE_NORMAL
- en: As with the InfoVis libraries discussed in the [Chapter 16](ch16.xhtml), your
    personal choice for a geospatial plotting library will depend largely on what
    you need to plot—both now and in the future—and how much effort you want to expend.
    To help you choose, [Figure 17-16](ch17.xhtml#ch017fig16) provided a summary of
    the out-of-the-box distinguishing features of the major geospatial libraries.
    Keep in mind, however, that it’s always possible to cobble-together a custom suite
    of packages using “bridging” libraries that fill-in missing capabilities.
  prefs: []
  type: TYPE_NORMAL
