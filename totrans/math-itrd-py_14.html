<html><head></head><body>
<h2 class="h2" id="ch11"><span epub:type="pagebreak" id="page_225"/><span class="big">11</span><br/>CELLULAR AUTOMATA</h2>&#13;
<p class="epigraph"><em>I like to put a humidifier and a dehumidifier in a room and just let them fight it out.<br/>—Steven Wright</em></p>&#13;
<div class="image"><img alt="image" src="../images/fintro-01.jpg"/></div>&#13;
<p class="intro">Math equations are a very powerful tool for modeling things we can measure; equations even got us to the moon, after all. But as powerful as they are, equations are of limited use in the biological and social sciences because organisms don’t grow according to equations.</p>&#13;
<p class="indent">Organisms grow in an environment among many other organisms and spend their day performing innumerable interactions. That web of interactions determines how something will grow, and equations often can’t capture this complicated relationship. Equations can help us calculate the energy or mass converted by a single interaction or reaction, but to model a biological system, for example, you’d have to repeat that calculation hundreds or thousands of times.</p>&#13;
<p class="indent">Fortunately, there’s a tool that models how cells, organisms, and other living systems grow and change according to their environment. Because of their similarity to independent biological organisms, these models are <span epub:type="pagebreak" id="page_226"/>called <em>cellular automata (CAs)</em>. The term <em>automaton</em> refers to something that can run on its own. <a href="ch11.xhtml#ch11fig1">Figure 11-1</a> shows two examples of cellular automata generated using a computer.</p>&#13;
<div class="image"><a id="ch11fig1"/><img alt="image" src="../images/f226-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 11-1: An example of an elementary cellular automaton, and a screen full of virtual organisms</em></p>&#13;
<p class="indent">The CAs we’ll create in this chapter are grids made up of <em>cells</em>. Each cell in a CA has a number of <em>states</em> (for example, on/off, alive/dead, or colored/blank). Cells change according to the state of their neighbors, which allows them to grow and change as if they were alive!</p>&#13;
<p class="indent">CAs have been the subject of some study, as far back as the 1940s, but they really took off when computers became more commonplace. In fact, CAs can really only be studied using computers because, even though they follow very simple rules, like “if an organism doesn’t have enough neighbors, it dies,” these rules produce useful results only if hundreds or thousands of these organisms are created and allowed to run for hundreds or thousands of generations.</p>&#13;
<p class="indent">Because math is the study of patterns, the math topic of cellular automata is rife with interesting ideas, programming challenges, and endless possibilities for beautiful output!</p>&#13;
<h3 class="h3" id="ch11_1">CREATING A CELLULAR AUTOMATON</h3>&#13;
<p class="noindent">Open a new Processing sketch and name it <em>cellularAutomata.pyde</em>. Let’s start with a square grid where our cells will reside. We can easily draw a 10-by-10 grid of squares of size 20, as shown in <a href="ch11.xhtml#ch11list1">Listing 11-1</a>.</p>&#13;
<p class="programs"><span class="pd_g1"><em>cellular Automata.pyde</em></span><br/><span class="pd_green1">def</span> <span class="pd_bluebold">setup</span>():<br/>    <span class="pd_blue1">size</span>(600,600)<br/><br/><span class="pd_green1">def</span> <span class="pd_bluebold">draw</span>():<br/>    <span class="pd_lime">for</span> x <span class="pd_green1">in</span> <span class="pd_lime">range</span>(10):<br/><span epub:type="pagebreak" id="page_227"/>&#13;
        <span class="pd_lime">for</span> y <span class="pd_green1">in</span> <span class="pd_lime">range</span>(10):<br/>            <span class="pd_blue1">rect</span>(20*x,20*y,20,20)</p>&#13;
<p class="listing" id="ch11list1"><em>Listing 11-1: Creating a grid of squares</em></p>&#13;
<p class="indent">Save and run this sketch, and you should see a grid like the one shown in <a href="ch11.xhtml#ch11fig2">Figure 11-2</a>.</p>&#13;
<div class="image"><a id="ch11fig2"/><img alt="image" src="../images/f227-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 11-2: A 10 × 10 grid</em></p>&#13;
<p class="indent">However, we need to change a bunch of numbers every time we want bigger cells, for example, or a grid with different dimensions. Therefore, it’s much easier to change things later if we use variables. Because the keywords <span class="literal">height</span>, <span class="literal">width</span>, and <span class="literal">size</span> already exist for the graphics window, we have to use different variable names. <a href="ch11.xhtml#ch11list2">Listing 11-2</a> improves on <a href="ch11.xhtml#ch11list1">Listing 11-1</a> by creating a grid that’s easy to resize, with cells that are also easy to resize—all by using variables.</p>&#13;
<p class="programs"><span class="pd_g1"><em>cellular Automata.pyde</em></span><br/>GRID_W = 15<br/>GRID_H = 15<br/><br/><span class="pd_gray">#size of cell</span><br/>SZ = 18<br/><span class="pd_gray">def setup():</span><br/>    <span class="pd_gray">size(600,600)</span><br/><br/><span class="pd_green1">def</span> <span class="pd_bluebold">draw</span>():<br/>    <span class="pd_lime">for</span> c <span class="pd_green1">in</span> <span class="pd_lime">range</span>(GRID_W): <span class="pd_gray">#the columns</span><br/>        <span class="pd_lime">for</span> r <span class="pd_green1">in</span> <span class="pd_lime">range</span>(GRID_H): <span class="pd_gray">#the rows</span><br/>            <span class="pd_blue1">rect</span>(SZ*c,SZ*r,SZ,SZ)</p>&#13;
<p class="listing" id="ch11list2"><em>Listing 11-2: Improved grid program using variables</em></p>&#13;
<p class="indent">We create variables for the height (<span class="literal">GRID_H</span>) and width (<span class="literal">GRID_W</span>) of the grid using all capital letters to indicate that these are constants and their values won’t be changing. The size of the cell is also a constant (for now), <span epub:type="pagebreak" id="page_228"/>so we capitalize it as well (<span class="literal">SZ</span>) when declaring its initial value. Now when you run this code, you should see a larger grid, like the one shown in <a href="ch11.xhtml#ch11fig3">Figure 11-3</a>.</p>&#13;
<div class="image"><a id="ch11fig3"/><img alt="image" src="../images/f228-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 11-3: A larger grid, made with variables</em></p>&#13;
<h4 class="h4" id="ch11_1_1">WRITING A CELL CLASS</h4>&#13;
<p class="noindent">We need to write a class because every cell we create needs its own location, state (“on” or “off”), neighbors (the cells next to it), and so on. We create the <span class="literal">Cell</span> class by adding the code shown in <a href="ch11.xhtml#ch11list3">Listing 11-3</a>.</p>&#13;
<p class="programs"><span class="pd_g1"><em>cellular Automata.pyde</em></span><br/><span class="pd_gray">#size of cell</span><br/><span class="pd_gray">SZ = 18</span><br/><br/><span class="pd_green1">class</span> Cell:<br/>    <span class="pd_green1">def</span> <span class="pd_blue1">__init__</span>(<span class="pd_green1">self</span>,c,r,state=0):<br/>        <span class="pd_green1">self</span>.c = c<br/>        <span class="pd_green1">self</span>.r = r<br/>        <span class="pd_green1">self</span>.state = state<br/><br/>    <span class="pd_green1">def</span> display(<span class="pd_green1">self</span>):<br/>        <span class="pd_lime">if</span> <span class="pd_green1">self</span>.state == 1:<br/>            <span class="pd_blue1">fill</span>(0) <span class="pd_gray">#black</span><br/>        <span class="pd_lime">else</span>:<br/>            <span class="pd_blue1">fill</span>(255) <span class="pd_gray">#white</span><br/>        <span class="pd_blue1">rect</span>(SZ*<span class="pd_green1">self</span>.r,SZ*<span class="pd_green1">self</span>.c,SZ,SZ)</p>&#13;
<p class="listing" id="ch11list3"><em>Listing 11-3: Creating the <span class="literal">Cell</span> class</em></p>&#13;
<span epub:type="pagebreak" id="page_229"/>&#13;
<p class="indent">The cell’s initial <span class="literal">state</span> property is 0 (or off). The code <span class="literal">state=0</span> in the parameters of the <span class="literal">__init__</span> method means that if we don’t specify a state, <span class="literal">state</span> is set to 0. The <span class="literal">display()</span> method just tells the <span class="literal">Cell</span> object how to display itself on the screen. If it’s “on,” the cell is black; otherwise, it’s white. Also, each cell is a square, and we need to spread out the cells by multiplying their column and row numbers by their size (<span class="literal">self.SZ</span>).</p>&#13;
<p class="indent">After the <span class="literal">draw()</span> function, we need to write a function to create an empty list to put our <span class="literal">Cell</span> objects in and use a nested loop to append these <span class="literal">Cell</span> objects to the list instead of drawing them one by one, as shown in <a href="ch11.xhtml#ch11list4">Listing 11-4</a>.</p>&#13;
<p class="programs"><span class="pd_g1"><em>cellular Automata.pyde</em></span><br/><span class="pd_green1">def</span> createCellList():<br/><span class="pd_purple">    '''Creates a big list of off cells with</span><br/><span class="pd_purple">    one on Cell in the center'''</span><br/> <span class="ent">➊</span> newList=[]<span class="pd_gray">#empty list for cells</span><br/>    <span class="pd_gray">#populate the initial cell list</span><br/>    <span class="pd_lime">for</span> j <span class="pd_green1">in</span> <span class="pd_lime">range</span>(GRID_H):<br/>     <span class="ent">➋</span> newList.<span class="pd_blue1">append</span>([]) <span class="pd_gray">#add empty row</span><br/>        <span class="pd_lime">for</span> i <span class="pd_green1">in</span> <span class="pd_lime">range</span>(GRID_W):<br/>         <span class="ent">➌</span> newList [j].<span class="pd_blue1">append</span>(Cell(i,j,0)) <span class="pd_gray">#add off Cells or zeroes</span><br/>    <span class="pd_gray">#center cell is set to on</span><br/> <span class="ent">➍</span> newList [GRID_H//2][GRID_W//2].state = 1<br/>    <span class="pd_lime">return</span> newList</p>&#13;
<p class="listing" id="ch11list4"><em>Listing 11-4: Function for creating a list of cells</em></p>&#13;
<p class="indent">First, we create an empty list called <span class="literal">newList</span> <span class="ent">➊</span> and add an empty list as a row <span class="ent">➋</span> to be filled in with <span class="literal">Cell</span> objects <span class="ent">➌</span>. Then, we get the index of the center square by dividing the number of rows and columns by 2 (the double slash means integer division) and setting that cell’s <span class="literal">state</span> property to 1 (or “on”) <span class="ent">➍</span>.</p>&#13;
<p class="indent">In <span class="literal">setup()</span>, we’ll use the <span class="literal">createCellList()</span> function and declare <span class="literal">cellList</span> as a global variable so it can be used in the <span class="literal">draw()</span> function. Finally, in <span class="literal">draw()</span>, we’ll loop over each row in <span class="literal">cellList</span> and update it. The new <span class="literal">setup()</span> and <span class="literal">draw()</span> functions are shown in <a href="ch11.xhtml#ch11list5">Listing 11-5</a>.</p>&#13;
<p class="programs"><span class="pd_green1">def</span> <span class="pd_bluebold">setup</span>():<br/>    <span class="pd_green1">global</span> cellList<br/>    <span class="pd_blue1">size</span>(600,600)<br/>    cellList = createCellList()<br/><br/><span class="pd_green1">def</span> <span class="pd_bluebold">draw</span>():<br/>    <span class="pd_lime">for</span> row <span class="pd_green1">in</span> cellList:<br/>        <span class="pd_lime">for</span> cell <span class="pd_green1">in</span> row:<br/>            cell.display()</p>&#13;
<p class="listing" id="ch11list5"><em>Listing 11-5: The new <span class="literal">setup()</span> and <span class="literal">draw()</span> functions for creating a grid</em></p>&#13;
<p class="indent">However, when we run this code, we get a grid with smaller cells in the corner of the display window, as shown in <a href="ch11.xhtml#ch11fig4">Figure 11-4</a>.</p>&#13;
<span epub:type="pagebreak" id="page_230"/>&#13;
<div class="image"><a id="ch11fig4"/><img alt="image" src="../images/f230-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 11-4: A grid of cells that’s not yet centered</em></p>&#13;
<p class="indent">Now we’re able to make as big or small a list of cells as we want by changing the size of our 15-by-15 grid.</p>&#13;
<h4 class="h4" id="ch11_1_2">RESIZING EACH CELL</h4>&#13;
<p class="noindent">To resize our cells, we can make <span class="literal">SZ</span> automatically dependent on the width of the window. Right now the width is 600, so let’s change <span class="literal">setup()</span> using the code in <a href="ch11.xhtml#ch11list6">Listing 11-6</a>.</p>&#13;
<p class="programs"><span class="pd_g1"><em>cellular Automata.pyde</em></span><br/><span class="pd_green1">def</span> <span class="pd_bluebold">setup</span>():<br/>    <span class="pd_green1">global</span> SZ,cellList<br/>    <span class="pd_gray">size(600,600)</span><br/>    SZ = <span class="pd_raspberry">width</span> // GRID_W + 1<br/>    <span class="pd_gray">cellList = createCellList()</span></p>&#13;
<p class="listing" id="ch11list6"><em>Listing 11-6: Resizing the cells to autofit the display window</em></p>&#13;
<p class="indent">The double forward slash (<span class="literal">//</span>) means <em>integer division</em>, which returns only the integer part of the quotient. Now, when you run the program, it should produce a grid with all empty cells except for one colored cell in the center, like in <a href="ch11.xhtml#ch11fig5">Figure 11-5</a>.</p>&#13;
<span epub:type="pagebreak" id="page_231"/>&#13;
<div class="image"><a id="ch11fig5"/><img alt="image" src="../images/f231-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 11-5: Grids with the center cell “on”</em></p>&#13;
<p class="indent">Note that this code works better when you add 1 to <span class="literal">SZ</span>, the size of the <span class="literal">Cell</span>, as in Listing 11-16, because otherwise the grid sometimes doesn’t fill the whole display window. But feel free to leave it out.</p>&#13;
<h4 class="h4" id="ch11_1_3">MAKING A CA GROW</h4>&#13;
<p class="noindent">Now we want to make the cells change according to the number of their neighbors whose state is “on.” This section was inspired by a two-dimensional CA from Stephen Wolfram’s <em>New Kind of Science</em>. You can see how a version of this CA grows in <a href="ch11.xhtml#ch11fig6">Figure 11-6</a>.</p>&#13;
<div class="image"><a id="ch11fig6"/><img alt="image" src="../images/f231-02.jpg"/></div>&#13;
<p class="caption"><em>Figure 11-6: Stages of growth of a cellular automaton</em></p>&#13;
<span epub:type="pagebreak" id="page_232"/>&#13;
<p class="indent">In this design, if a cell has <em>one or four</em> neighbors that are on, we make it turn on (and stay on).</p>&#13;
<h4 class="h4" id="ch11_1_4">PUTTING THE CELLS INTO A MATRIX</h4>&#13;
<p class="noindent">It’s easy to find the cells immediately before and after a cell in the list, which gives us the neighbors to its left and right. But how do we find the neighbors above and below a cell? To do this more easily, we can put the cells in a two-dimensional <em>array</em> or <em>matrix</em>, which is a list with lists for the rows. That way, if a cell is in column 5, for example, we know that its “above” and “below” neighbors will also be in column 5.</p>&#13;
<p class="indent">In the <span class="literal">Cell</span> class, we add a method called <span class="literal">checkNeighbors()</span> so that a cell can count how many of its neighbors are on, and if the count is 1 or 4, that cell will return 1 for “on.” Otherwise, it returns 0 for “off.” We begin by checking the neighbor above:</p>&#13;
<p class="programs">    <span class="pd_green1">def</span> checkNeighbors(<span class="pd_green1">self</span>):<br/>        <span class="pd_lime">if</span> <span class="pd_green1">self</span>.state == 1: <span class="pd_lime">return</span> 1 <span class="pd_gray">#on Cells stay on</span><br/>        neighbs = 0<br/>        <span class="pd_gray">#check the neighbor above</span><br/>        <span class="pd_lime">if</span> cellList[<span class="pd_green1">self</span>.r-1][<span class="pd_green1">self</span>.c].state == 1:<br/>            neighbs += 1</p>&#13;
<p class="indent">This code checks for the item in <span class="literal">cellList</span> that’s in the same column (<span class="literal">self.c</span>) but in the previous row (<span class="literal">self.r – 1</span>). If that item’s <span class="literal">state</span> property is 1, then it’s on, and we increment the <span class="literal">neighbs</span> variable by 1. Then we have to do the same for the cell’s neighbor below, and then for the neighbors to the left and right. Do you see an easy pattern here?</p>&#13;
<p class="programs">cellList[<span class="pd_green1">self</span>.r - 1][<span class="pd_green1">self</span>.c + 0] <span class="pd_gray">#above</span><br/>cellList[<span class="pd_green1">self</span>.r + 1][<span class="pd_green1">self</span>.c + 0] <span class="pd_gray">#below</span><br/>cellList[<span class="pd_green1">self</span>.r + 0][<span class="pd_green1">self</span>.c - 1] <span class="pd_gray">#left</span><br/>cellList[<span class="pd_green1">self</span>.r + 0][<span class="pd_green1">self</span>.c + 1] <span class="pd_gray">#right</span></p>&#13;
<p class="indent">We only need to keep track of the change in the row number and the change in the column number. There are only four directions we need to check, for the “one to the left, one to the right” neighbors, and so on: <span class="literal">[-1,0]</span>, <span class="literal">[1,0]</span>, <span class="literal">[0,-1]</span> and <span class="literal">[0,1]</span>. If we call those <span class="literal">dr</span> and <span class="literal">dc</span> (<em>d</em>, or the Greek letter <em>delta</em>, is the traditional math symbol for change), we can keep from repeating ourselves:</p>&#13;
<p class="programs"><span class="pd_g1"><em>cellular Automata.pyde</em></span><br/><span class="pd_gray">def checkNeighbors(self</span><span class="pd_gray">):</span><br/>    <span class="pd_gray">if self.state == 1: return 1 #on Cells stay on</span><br/>    <span class="pd_gray">neighbs = 0 #check the neighbors</span><br/>    <span class="pd_lime">for</span> dr,dc <span class="pd_green1">in</span> [[-1,0],[1,0],[0,-1],[0,1]]:<br/>        <span class="pd_lime">if</span> cellList[<span class="pd_green1">self</span>.r + dr][<span class="pd_green1">self</span>.c + dc].state == 1:<br/>            neighbs += 1<br/>    <span class="pd_lime">if</span> neighbs <span class="pd_green1">in</span> [1,4]:<br/>        <span class="pd_lime">return</span> 1<br/>    <span class="pd_lime">else</span>:<br/>        <span class="pd_lime">return</span> 0</p>&#13;
<span epub:type="pagebreak" id="page_233"/>&#13;
<p class="indent">Finally, if the neighbor count is 1 or 4, the <span class="literal">state</span> property will be set to 1. In Python, <span class="literal">if neighbs in [1,4]</span> is the same as saying <span class="literal">if neighbs == 1 or neighbs == 4:</span>.</p>&#13;
<h4 class="h4" id="ch11_1_5">CREATING THE CELL LIST</h4>&#13;
<p class="noindent">So far, we’ve created the cell list by running the <span class="literal">createCellList()</span> function in <span class="literal">setup()</span> and assigning the output to <span class="literal">cellList</span>, and we’ve gone through every row in <span class="literal">cellList</span> and updated each cell in the row. Now we have to check whether the rules work. The four squares surrounding the center cell should change state in the next step. That means we’ll have to run the <span class="literal">checkNeighbors()</span> method and then show the result. Update your <span class="literal">draw()</span> function as follows:</p>&#13;
<p class="programs"><span class="pd_gray">def draw():</span><br/>    <span class="pd_gray">for</span> <span class="pd_gray">row in cellList:</span><br/>        <span class="pd_gray">for cell in row:</span><br/>         <span class="ent">➊</span> cell.state = cell.checkNeighbors()<br/>            <span class="pd_gray">cell.display()</span></p>&#13;
<p class="indent">The updated line <span class="ent">➊</span> runs all the <span class="literal">checkNeighbors()</span> code and sets the cell on or off according to the result. Run it, and you should get the following error:</p>&#13;
<p class="programs">IndexError: index out of range: 15</p>&#13;
<p class="indent">The error is in the line that checks the neighbor to the right. Sure enough, because there are only 15 cells in a row, it makes sense that the 15th cell has no neighbor to the right.</p>&#13;
<p class="indent">If a cell has no neighbor to the right (meaning its column number is <span class="literal">GRID_W</span> minus one), we obviously don’t need to check that neighbor and can continue on to the next cell. The same for checking the neighbor above the cells in row 0, because they have no cells above them. Similarly, the cells in column 0 have no neighbors to the left, and the cells in row 14 (<span class="literal">GRID_H</span> minus 1) have no cells below them. In <a href="ch11.xhtml#ch11list7">Listing 11-7</a>, we add a valuable Python trick called <em>exception handling</em> to the <span class="literal">checkNeighbors()</span> method using the keywords <span class="literal">try</span> and <span class="literal">except</span>.</p>&#13;
<p class="programs">    <span class="pd_g1"><em>cellular Automata.pyde</em></span><br/>    <span class="pd_green1">def</span> checkNeighbors(<span class="pd_green1">self</span>,cellList):<br/>        <span class="pd_lime">if</span> <span class="pd_green1">self</span>.state == 1: <span class="pd_lime">return</span> 1 <span class="pd_gray">#on Cells stay on</span><br/>        neighbs = 0<br/>        <span class="pd_gray">#check the neighbors</span><br/>        <span class="pd_lime">for</span> dr,dc <span class="pd_green1">in</span> [[-1,0],[1,0],[0,-1],[0,1]]:<br/>         <span class="ent">➊</span> <span class="pd_lime">try</span>:<br/>                <span class="pd_lime">if</span> cellList[<span class="pd_green1">self</span>.r + dr][<span class="pd_green1">self</span>.c + dc].state == 1:<br/>                    neighbs += 1<br/>         <span class="ent">➋</span> <span class="pd_lime">except</span> IndexError:<br/>                <span class="pd_lime">continue</span><br/>        <span class="pd_lime">if</span> neighbs <span class="pd_green1">in</span> [1,4]:<br/>            <span class="pd_lime">return</span> 1<br/>        <span class="pd_lime">else</span>:<br/>            <span class="pd_lime">return</span> 0</p>&#13;
<p class="listing" id="ch11list7"><em>Listing 11-7: Adding conditionals to <span class="literal">checkNeighbors()</span></em></p>&#13;
<span epub:type="pagebreak" id="page_234"/>&#13;
<p class="indent">The <span class="literal">try</span> keyword <span class="ent">➊</span> literally means “try to run this next line of code.” In the earlier error message, we got an <span class="literal">IndexError</span>. We use the <span class="literal">except</span> keyword <span class="ent">➋</span> to mean “if you get this error, do this.” Therefore, if we get an <span class="literal">IndexError</span>, we continue on to the next loop. Run this code, and you’ll get something interesting, as shown in <a href="ch11.xhtml#ch11fig7">Figure 11-7</a>. This is definitely not what we saw in <a href="ch11.xhtml#ch11fig6">Figure 11-6</a>.</p>&#13;
<div class="image"><a id="ch11fig7"/><img alt="image" src="../images/f234-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 11-7: Not what we expected!</em></p>&#13;
<p class="indent">The problem is that we’re checking neighbors and changing the state of the current cell. Then the cell’s neighbors are checking their neighbors, but they’re checking the new state of their neighbors. We want all the cells to check their neighbors and save the information in a new list; then, when all the cells are done, we can update the grid all at once. That calls for another list for our cells, <span class="literal">newList</span>, that will replace <span class="literal">cellList</span> at the end of the loop.</p>&#13;
<p class="indent">So all we need to do is declare that <span class="literal">newList</span> is equal to <span class="literal">cellList</span>, right?</p>&#13;
<p class="programs">cellList = newList  <span class="pd_gray">#?</span></p>&#13;
<p class="indent">Although that seems to make sense, Python doesn’t copy the contents of <span class="literal">newList</span> over the previous contents of <span class="literal">cellList</span>, which is what you might have expected. It technically refers to the <span class="literal">newList</span>, but when you change <span class="literal">newList</span>, you end up changing <span class="literal">cellList</span> as well.</p>&#13;
<h3 class="h3" id="ch11_2">PYTHON LISTS ARE STRANGE</h3>&#13;
<p class="noindent">Python lists have an odd behavior. Let’s say you declare a list and set another one equal to it, and then you change the first list. You wouldn’t expect the second one to change too, but that’s exactly what happens, as shown here:</p>&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">a = [1,2,3]</span><br/>&gt;&gt;&gt; <span class="codestrong1">b = a</span><br/>&gt;&gt;&gt; <span class="codestrong1">b</span><br/><span class="pd_blue">[1, 2, 3]</span><br/><span epub:type="pagebreak" id="page_235"/>&#13;
&gt;&gt;&gt; <span class="codestrong1">a.append(4)</span><br/>&gt;&gt;&gt; <span class="codestrong1">a</span><br/><span class="pd_blue">[1, 2, 3, 4]</span><br/>&gt;&gt;&gt; <span class="codestrong1">b</span><br/><span class="pd_blue">[1, 2, 3, 4]</span></p>&#13;
<p class="indent">As you can see, we created list <span class="literal">a</span>, then assigned the value of list <span class="literal">a</span> to list <span class="literal">b</span>. When we change list <span class="literal">a</span> without updating list <span class="literal">b</span>, Python also changes list <span class="literal">b</span>!</p>&#13;
<h4 class="h4" id="ch11_1_6">LIST INDEX NOTATION</h4>&#13;
<p class="noindent">One way to make sure when we’re updating one list that we’re not updating another one accidentally is to use index notation. Giving list <span class="literal">b</span> all the contents of list <span class="literal">a</span> should prevent this from happening:</p>&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">a = [1,2,3]</span><br/>&gt;&gt;&gt; <span class="codestrong1">b = a[::]</span><br/>&gt;&gt;&gt; <span class="codestrong1">b</span><br/><span class="pd_blue">[1, 2, 3]</span><br/>&gt;&gt;&gt; <span class="codestrong1">a.append(4)</span><br/>&gt;&gt;&gt; <span class="codestrong1">a</span><br/><span class="pd_blue">[1, 2, 3, 4]</span><br/>&gt;&gt;&gt; <span class="codestrong1">b</span><br/><span class="pd_blue">[1, 2, 3]</span></p>&#13;
<p class="indent">Here, we use <span class="literal">b = a[::]</span> to say “assign all the contents inside list <span class="literal">a</span> to the variable <span class="literal">b</span>,” as opposed to simply declaring that list <span class="literal">a</span> is equal to list <span class="literal">b</span>. This way, the lists aren’t linked to each other.</p>&#13;
<p class="indent">After we declare <span class="literal">SZ</span>, we need to add the following line of code to declare the initial value of the <span class="literal">generation</span> variable, which will keep track of which generation we’re looking at:</p>&#13;
<p class="programs">generation = 0</p>&#13;
<p class="indent">We’re going to avoid the list reference problem by using the index notation at the end of the updating code. Let’s create a new <span class="literal">update()</span> function after <span class="literal">draw()</span> so that all the updating will be done in that separate function. <a href="ch11.xhtml#ch11list8">Listing 11-8</a> shows how your <span class="literal">setup()</span> and <span class="literal">draw()</span> functions should look.</p>&#13;
<p class="programs"><span class="pd_g1"><em>cellular Automata.pyde</em></span><br/><span class="pd_green1">def</span> <span class="pd_bluebold">setup</span>():<br/>    <span class="pd_green1">global</span> SZ, cellList<br/>    <span class="pd_blue1">size</span>(600,600)<br/>    SZ = <span class="pd_raspberry">width</span> // GRID_W + 1<br/>    cellList = createCellList()<br/><br/><span class="pd_green1">def</span> <span class="pd_bluebold">draw</span>():<br/>    <span class="pd_blue1">global</span> generation,cellList<br/>    cellList = update(cellList)<br/>    <span class="pd_lime">for</span> row <span class="pd_green1">in</span> cellList:<br/>        <span class="pd_lime">for</span> cell <span class="pd_green1">in</span> row:<br/>            cell.display()<br/><span epub:type="pagebreak" id="page_236"/>&#13;
    generation += 1<br/>    <span class="pd_lime">if</span> generation == 3:<br/>        <span class="pd_blue1">noLoop</span>()<br/><br/><span class="pd_green1">def</span> update(cellList):<br/>    newList = []<br/>    <span class="pd_lime">for</span> r,row <span class="pd_green1">in</span> enumerate(cellList):<br/>        newList.<span class="pd_blue1">append</span>([])<br/>        <span class="pd_lime">for</span> c,cell <span class="pd_green1">in</span> enumerate(row):<br/>            newList[r].<span class="pd_blue1">append</span>(Cell(c,r,cell.checkNeighbors()))<br/>    <span class="pd_lime">return</span> newList[::]</p>&#13;
<p class="listing" id="ch11list8"><em>Listing 11-8: Checking whether the updating is working and then stopping after three generations</em></p>&#13;
<p class="indent">We create the first <span class="literal">cellList</span> once in the <span class="literal">setup()</span> function and then declare it a global variable so we can use it in other functions. In the <span class="literal">draw()</span> function, we use the <span class="literal">generation</span> variable for however many generations we want to check (in this case, three); then we make a call to update the <span class="literal">cellList</span>. We draw the cells as before, using the <span class="literal">display()</span> method, and then increment <span class="literal">generation</span> and check whether it has reached our desired generation. If it has, the built-in Processing function <span class="literal">noLoop()</span> stops the loop.</p>&#13;
<p class="indent">We use <span class="literal">noLoop()</span> to turn off the infinite loop, because we only want to draw the given number of generations. If you comment it out, the program will keep going! <a href="ch11.xhtml#ch11fig8">Figure 11-8</a> shows what the CA looks like after three generations.</p>&#13;
<div class="image"><a id="ch11fig8"/><img alt="image" src="../images/f236-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 11-8: A working CA!</em></p>&#13;
<span epub:type="pagebreak" id="page_237"/>&#13;
<p class="indent">What’s great about using variables for our grid size is that we can change the CA drastically by simply changing the <span class="literal">GRID_W</span> and <span class="literal">GRID_H</span> variables, like so:</p>&#13;
<p class="programs">GRID_W = 41<br/>GRID_H = 41</p>&#13;
<p class="indent">If we increase the number of generations to 13 (in the line that currently reads <span class="literal">if generation == 3</span>), the output should look like <a href="ch11.xhtml#ch11fig9">Figure 11-9</a>.</p>&#13;
<div class="image"><a id="ch11fig9"/><img alt="image" src="../images/f237-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 11-9: Our CA at a higher level, with a grid (left) and without a grid (right)</em></p>&#13;
<p class="indent">To remove the grid around the empty cells in the CA, simply add this line to the <span class="literal">setup()</span> function:</p>&#13;
<p class="programs">    noStroke()</p>&#13;
<p class="indent">That should turn off the outline around the squares, but the fill color will still be drawn, like <a href="ch11.xhtml#ch11fig9">Figure 11-9</a>.</p>&#13;
<p class="indent">So far we’ve done a lot! We’ve created two-dimensional lists, filled them with cells, and turned on certain cells according to a simple rule. Then we updated the cells and displayed them. The CA just keeps growing!</p>&#13;
<div class="sidebar">&#13;
<p class="title">EXERCISE 11-1: MANUALLY GROWING THE CA</p>&#13;
<p class="noindent">Use the <span class="literal">keyPressed()</span> function you learned about in <a href="ch10.xhtml#ch10">Chapter 10</a> to manually grow the CA.</p>&#13;
</div>&#13;
<span epub:type="pagebreak" id="page_238"/>&#13;
<h4 class="h4" id="ch11_1_7">LETTING YOUR CA GROW AUTOMATICALLY</h4>&#13;
<p class="noindent">If you want the CA to cycle from level 0 to a maximum number of generations (you choose the right number for your window), simply change the <span class="literal">draw()</span> function to what’s shown in <a href="ch11.xhtml#ch11list9">Listing 11-9</a>.</p>&#13;
<p class="programs"><span class="pd_g1"><em>cellular Automata.pyde</em></span><br/><span class="pd_green1">def</span> <span class="pd_bluebold">draw</span>():<br/>    <span class="pd_green1">global</span> generation,cellList<br/> <span class="ent">➊</span> <span class="pd_blue1">frameRate</span>(10)<br/>    cellList = update(cellList)<br/>    <span class="pd_lime">for</span> row <span class="pd_green1">in</span> cellList:<br/>        <span class="pd_lime">for</span> cell <span class="pd_green1">in</span> row:<br/>            cell.display()<br/>    generation += 1<br/> <span class="ent">➋</span> <span class="pd_lime">if</span> generation == 30:<br/>        generation = 1<br/>        cellList = createCellList()</p>&#13;
<p class="listing" id="ch11list9"><em>Listing 11-9: Making the CA grow and regrow automatically</em></p>&#13;
<p class="indent">To slow down the animation, we use Processing’s built-in <span class="literal">frameRate()</span> function <span class="ent">➊</span>. The default is 60 frames per second, so here we slowed it down to 10. Then we tell the program that if the <span class="literal">generation</span> variable reaches 30 <span class="ent">➋</span> (you can change this to another number), reset <span class="literal">generation</span> to 1, and create a new <span class="literal">cellList</span>. Now you should be able to watch the CA grow as quickly or slowly as you want. Change the rule and see how that changes the CA. You can change the colors too!</p>&#13;
<p class="indent">We’ve just taken a simple rule (if a cell has 1 or 4 neighbors, it’s “on”) and wrote a program to apply that rule to thousands of cells at once! The result looks like a living, growing organism. Now we’ll expand our code into a famous CA where the virtual organisms can move around, grow, and die!</p>&#13;
<h3 class="h3" id="ch11_3">PLAYING THE GAME OF LIFE</h3>&#13;
<p class="noindent">In a 1970 issue of <em>Scientific American</em>, math popularizer Martin Gardner brought attention to a strange and wonderful game where cells live or die according to how many neighbors they have. The brainchild of English mathematician John Conway, this game features three simple rules:</p>&#13;
<ol>&#13;
<li class="noindent">If a living cell has less than two living neighbors, it dies.</li>&#13;
<li class="noindent">If a living cell has more than three living neighbors, it dies.</li>&#13;
<li class="noindent">If a dead cell has exactly three living neighbors, it comes to life.</li>&#13;
</ol>&#13;
<p class="indent">With a simple set of rules like that, it’s surprising how intricate this game gets. In 1970, most people could only use checkers on a board to visualize the game, and one generation could take quite a while to calculate. Conveniently, we have a computer, and the CA code we just wrote has most of the code necessary to create this game in Python. Save the CA file we’ve been working on so far and then save it with different name, like <em>GameOfLife</em>.</p>&#13;
<span epub:type="pagebreak" id="page_239"/>&#13;
<p class="indent">In this game, our cells will have diagonal neighbors too. That means we have to add four more values to our <span class="literal">dr,dc</span> line. <a href="ch11.xhtml#ch11list10">Listing 11-10</a> shows the changes you need to make to the <span class="literal">checkNeighbors()</span> code.</p>&#13;
<p class="programs">    <span class="pd_g1"><em>GameOfLife.pyde</em></span><br/>    <span class="pd_green1">def</span> checkNeighbors(<span class="pd_green1">self</span>):<br/>        neighbs = 0  <span class="pd_gray">#check the neighbors</span><br/>     <span class="ent">➊</span> <span class="pd_lime">for</span> dr,dc <span class="pd_lime">in</span> [[-1,-1],[-1,0],[-1,1],[1,0],[1,-1],[1,1],[0,-1],[0,1]]:<br/>            <span class="pd_gray">try:</span><br/>                <span class="pd_gray">if cellList[self.r + dr][self</span><span class="pd_gray">.c + dc].state == 1:</span><br/>                    <span class="pd_gray">neighbs += 1</span><br/>            <span class="pd_gray">except IndexError:</span><br/>                <span class="pd_gray">continue</span><br/>     <span class="ent">➋</span> <span class="pd_lime">if</span> <span class="pd_green1">self</span>.state == 1:<br/>            <span class="pd_lime">if</span> neighbs <span class="pd_green1">in</span> [2,3]:<br/>                <span class="pd_lime">return</span> 1<br/>            <span class="pd_lime">return</span> 0<br/>        <span class="pd_lime">if</span> neighbs == 3:<br/>            <span class="pd_lime">return</span> 1<br/>        <span class="pd_lime">return</span> 0</p>&#13;
<p class="listing" id="ch11list10"><em>Listing 11-10: Changes to the <span class="literal">checkNeighbors()</span> code to include diagonal neighbors</em></p>&#13;
<p class="indent">First, we add four values <span class="ent">➊</span> to check the diagonal neighbors: <span class="literal">[-1,-1]</span> for the neighbor to the left and up, <span class="literal">[1,1]</span> for the neighbor to the right and down, and so on. Then we tell the program that if the cell is on <span class="ent">➋</span>, check if it has two or three neighbors that are also on. If so, we tell the program to return 1, and if not, we tell the program to return 0. Otherwise, if the cell is off, we tell it to check if it has three neighbors that are on. If it does, return 1; if doesn’t, return 0.</p>&#13;
<p class="indent">Then we place living cells randomly around the grid, so we have to import the <span class="literal">choice()</span> function from Python’s <span class="literal">random</span> module. Add this line to the top of the program:</p>&#13;
<p class="programs"><span class="pd_green1">from</span> <span class="pd_blue1">random</span> <span class="pd_green1">import</span> choice</p>&#13;
<p class="indent">Then we use the <span class="literal">choice()</span> function to randomly choose whether a new <span class="literal">Cell</span> is on or off. So all we have to do is change the <span class="literal">append</span> line in the <span class="literal">createCellList()</span> function to the following:</p>&#13;
<p class="programs">newList [j].<span class="pd_blue1">append</span>(Cell(i,j,choice([0,1])))</p>&#13;
<p class="indent">Now we no longer need the generation code from the previous file. The remaining code in the <span class="literal">draw()</span> function looks like this:</p>&#13;
<p class="programs"><span class="pd_green1">def</span> <span class="pd_bluebold">draw</span>():<br/>    <span class="pd_green1">global</span> cellList<br/>    <span class="pd_blue1">frameRate</span>(10)<br/>    cellList = update(cellList)<br/>    <span class="pd_lime">for</span> row <span class="pd_green1">in</span> cellList:<br/>        <span class="pd_lime">for</span> cell <span class="pd_green1">in</span> row:<br/>            cell.display()</p>&#13;
<span epub:type="pagebreak" id="page_240"/>&#13;
<p class="indent">Run this code, and you’ll see a wild, dynamic game play out, where organisms are moving, morphing, splitting, and interacting with other organisms, like in <a href="ch11.xhtml#ch11fig10">Figure 11-10</a>.</p>&#13;
<div class="image"><a id="ch11fig10"/><img alt="image" src="../images/f240-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 11-10: The Game of Life in action!</em></p>&#13;
<p class="indent">It’s interesting how the “clouds” of cells morph, move, and collide with other clouds (families? colonies?). Some organisms wander around the screen until, eventually, the grid will settle into a kind of equilibrium. <a href="ch11.xhtml#ch11fig11">Figure 11-11</a> shows an example of that kind of equilibrium.</p>&#13;
<div class="image"><a id="ch11fig11"/><img alt="image" src="../images/f240-02.jpg"/></div>&#13;
<p class="caption"><em>Figure 11-11: An example of the Game of Life that has entered a stable state</em></p>&#13;
<span epub:type="pagebreak" id="page_241"/>&#13;
<p class="indent">In this example of a state of equilibrium, some shapes appear stable and unmoving, while other shapes become stuck in repeating patterns.</p>&#13;
<h3 class="h3" id="ch11_4">THE ELEMENTARY CELLULAR AUTOMATON</h3>&#13;
<p class="noindent">This last CA is really cool and involves a little more math, but it’s still a simple pattern that’s extended, though only in one dimension (which is why it’s called an “elementary CA”). We start off with one row of cells and set the middle cell’s state to one, as shown in <a href="ch11.xhtml#ch11fig12">Figure 11-12</a>.</p>&#13;
<div class="image"><a id="ch11fig12"/><img alt="image" src="../images/f241-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 11-12: The first row of an elementary CA</em></p>&#13;
<p class="indent">This is easy to code. Start a new Processing sketch and call it <em>elementaryCA.pyde</em>. The code to draw the first row of cells is shown in <a href="ch11.xhtml#ch11list11">Listing 11-11</a>.</p>&#13;
<p class="programs">   <span class="pd_g1"><em>elementaryCA.pyde</em></span><br/><span class="ent">➊</span> <span class="pd_gray">#CA variables</span><br/>   w = 50<br/>   <span class="pd_blue1">rows</span> = 1<br/>   cols = 11<br/><br/>   <span class="pd_green1">def</span> <span class="pd_bluebold">setup</span>():<br/>       <span class="pd_green1">global</span> cells<br/>       <span class="pd_blue1">size</span>(600,600)<br/>       <span class="pd_gray">#first row:</span><br/>    <span class="ent">➋</span> cells = []<br/>       <span class="pd_lime">for</span> r <span class="pd_blue1">in</span> <span class="pd_lime">range</span>(<span class="pd_blue1">rows</span>):<br/>           cells.<span class="pd_blue1">append</span>([])<br/>           <span class="pd_lime">for</span> c <span class="pd_blue1">in</span> <span class="pd_lime">range</span>(cols):<br/>               cells[r].<span class="pd_blue1">append</span>(0)<br/>    <span class="ent">➌</span> cells[0][cols//2] = 1<br/><br/>   <span class="pd_green1">def</span> <span class="pd_bluebold">draw</span>():<br/>       <span class="pd_blue1">background</span>(255) <span class="pd_gray">#white</span><br/>       <span class="pd_gray">#draw the CA</span><br/>       <span class="pd_lime">for</span> i, cell <span class="pd_green1">in</span> enumerate(cells): <span class="pd_gray">#rows</span><br/>         <span class="pd_lime">for</span> j, v <span class="pd_green1">in</span> enumerate(cell): <span class="pd_gray">#columns</span><br/>          <span class="ent">➍</span> <span class="pd_lime">if</span> v == 1:<br/>                 <span class="pd_blue1">fill</span>(0)<br/>            <span class="pd_lime">else</span>: <span class="pd_blue1">fill</span>(255)<br/>          <span class="ent">➎</span> <span class="pd_blue1">rect</span>(j*w-(cols*w-<span class="pd_raspberry">width</span>)/2,w*i,w,w)</p>&#13;
<p class="listing" id="ch11list11"><em>Listing 11-11: Drawing the first row (generation) of the elementary CA</em></p>&#13;
<p class="indent">First, we declare a few important variables <span class="ent">➊</span>, such as the size of each cell and the number of rows and columns in our CA. Next, we start our <span class="literal">cells</span> list <span class="ent">➋</span>. We create <span class="literal">rows</span> number of rows and append <span class="literal">cols</span> number of 0’s in each list inside <span class="literal">cells</span>. We set the middle cell in the row to 1 (or on) <span class="ent">➌</span>. In the <span class="literal">draw()</span> function, we loop through the rows (there will be more than <span epub:type="pagebreak" id="page_242"/>one row soon!) and columns using <span class="literal">enumerate</span>. We check if the element is a 1, and if so, we color it black <span class="ent">➍</span>. Otherwise, we color it white. Finally, we draw the square for the cell <span class="ent">➎</span>. The x-value looks a bit complicated, but this just makes sure the CA is always centered.</p>&#13;
<p class="indent">When you run this code, you should see what’s shown in <a href="ch11.xhtml#ch11fig12">Figure 11-12</a>: a row of cells with one “on” cell in the center. The state of the cells in the next row of the CA will depend on the rules we set up for a cell and its two neighbors. How many possibilities are there? Each cell has two possible states (1 or 0, or “on” or “off”) so that’s two states for the left neighbor, two for the center cell, and two for the right neighbor. That’s 2 × 2 × 2 = 8 possibilities. All the combinations are shown in <a href="ch11.xhtml#ch11fig13">Figure 11-13</a>.</p>&#13;
<div class="image"><a id="ch11fig13"/><img alt="image" src="../images/f242-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 11-13: All the possible combinations of a cell and its two neighbors</em></p>&#13;
<p class="indent">The first possibility is that the center cell is on and both its neighbors are on. The next possibility is that the center cell is on, the left neighbor is on, and the right neighbor is off—and so on. This order is very important. (Do you see the pattern?) How are we going to describe these possibilities to the computer program? We could write eight conditional statements like this one:</p>&#13;
<p class="programs"><span class="pd_lime">if</span> left == 1 <span class="pd_green1">and</span> me == 1 <span class="pd_green1">and</span> right == 1:</p>&#13;
<p class="indent">But there’s an easier way. In A <em>New Kind of Science</em>, Stephen Wolfram assigns numbers to the possibilities according to the binary number the three cells represent. Keeping in mind that 1 is on and 0 is off, you can see that 111 is 7 in binary, 110 is 6 in binary, and so on, as illustrated in <a href="ch11.xhtml#ch11fig14">Figure 11-14</a>.</p>&#13;
<div class="image"><a id="ch11fig14"/><img alt="image" src="../images/f242-02.jpg"/></div>&#13;
<p class="caption"><em>Figure 11-14: The numbering method for the eight possibilities</em></p>&#13;
<p class="indent">Now that we’ve numbered each possibility, we can create a rule set—that is, a list that will contain the rules for what to do with each possibility in the next generation. Notice the numbers are like the indices of a list, except backwards. We can easily get around that. We can assign a result to each one randomly or because of some plan. <a href="ch11.xhtml#ch11fig15">Figure 11-15</a> shows one set of results.</p>&#13;
<div class="image"><a id="ch11fig15"/><img alt="image" src="../images/f242-03.jpg"/></div>&#13;
<p class="caption"><em>Figure 11-15: A set of results assigned to each possibility in the CA</em></p>&#13;
<span epub:type="pagebreak" id="page_243"/>&#13;
<p class="indent">The box under each possibility signifies the result, or the state of the cell in the next generation of the CA. The white box under “possibility 7” on the left means “if the cell is on and both of its neighbors are on, it will be off in the next generation.” Same for the next two possibilities (which don’t exist in our CA so far): the result is “off.” As illustrated earlier in <a href="ch11.xhtml#ch11fig12">Figure 11-12</a>, we have a lot of “off” cells surrounded by “off” cells, which is the possibility shown on the far right of <a href="ch11.xhtml#ch11fig14">Figure 11-14</a>: three white squares. In this case, the cell in the middle will be off in the next generation. We also have one “on” cell surrounded by two “off” cells (possibility 5). In the next generation, the cell will be on. We’ll use 0’s and 1’s for our <span class="literal">ruleset</span> list, as illustrated in <a href="ch11.xhtml#ch11fig16">Figure 11-16</a>.</p>&#13;
<div class="image"><a id="ch11fig16"/><img alt="image" src="../images/f243-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 11-16: Putting the rules for generating the next row into a list</em></p>&#13;
<p class="indent">We’ll collect all these numbers into a list called <span class="literal">ruleset</span>, which we’ll add just before the <span class="literal">setup()</span> function:</p>&#13;
<p class="programs">ruleset = [0,0,0,1,1,1,1,0]</p>&#13;
<p class="indent">The order of the possibilities is important because this rule set is referred to as “Rule 30” (00011110 is 30 in binary). Our task is to create the next row according to the rules. Let’s create a <span class="literal">generate()</span> function that looks at the first row and generates the second row, then looks at the second row and generates the third row, and so on. Add the code shown in <a href="ch11.xhtml#ch11list12">Listing 11-12</a>.</p>&#13;
<p class="programs">   <span class="pd_g1"><em>elementaryCA.pyde</em></span><br/>   <span class="pd_gray">#CA variables</span><br/>   w = 50<br/><span class="ent">➊</span> <span class="pd_blue1">rows</span> = 10<br/>   cols = 100<br/>   <span class="codeitalic1">--snip--</span><br/>   ruleset = [0,0,0,1,1,1,1,0] <span class="pd_gray">#rule 30</span><br/><br/><span class="ent">➋</span> <span class="pd_green1">def</span> rules(a,b,c):<br/>       <span class="pd_lime">return</span> ruleset[7 - (4*a + 2*b + c)]<br/><br/>   <span class="pd_green1">def</span> generate():<br/>       <span class="pd_lime">for</span> i, row <span class="pd_green1">in</span> enumerate(cells): <span class="pd_gray">#look at first row</span><br/>           <span class="pd_lime">for</span> j <span class="pd_green1">in</span> <span class="pd_lime">range</span>(1,<span class="pd_blue1">len</span>(row)-1):<br/>               left = row[j-1]<br/>               me = row[j]<br/>               right = row[j+1]<br/>               <span class="pd_lime">if</span> i &lt; <span class="pd_blue1">len</span>(cells) - 1:<br/>                    cells[i+1][j] = rules(left,me,right)<br/>       <span class="pd_lime">return</span> cells</p>&#13;
<p class="listing" id="ch11list12"><em>Listing 11-12: Writing the <span class="literal">generate()</span> function to generate new rows in the CA</em></p>&#13;
<span epub:type="pagebreak" id="page_244"/>&#13;
<p class="indent">First, we make the CA larger by updating the number of rows and columns <span class="ent">➊</span>. Next, we create the <span class="literal">rules()</span> function <span class="ent">➋</span>, which takes three parameters: the left neighbor’s number, the current cell’s number, and the right neighbor’s number. The function checks the <span class="literal">ruleset</span> and returns the value for the cell in the next generation. We make use of the binary numbers, and the line <span class="literal">4*a + 2*b + c</span> converts “1,1,1” to 7 and “1,1,0” to 6, and so on. However, as you’ll recall from <a href="ch11.xhtml#ch11fig15">Figure 11-15</a>, the indices are in reverse order, so we subtract the total from 7 to get the proper index of the <span class="literal">ruleset</span>.</p>&#13;
<p class="indent">Add the following line to the end of the <span class="literal">setup()</span> function:</p>&#13;
<p class="programs">cells = generate()</p>&#13;
<p class="indent">This creates the full CA and not just the first row. When you run this code, you should see the first 10 rows of a CA made using “Rule 30,” as illustrated in <a href="ch11.xhtml#ch11fig17">Figure 11-17</a>.</p>&#13;
<div class="image"><a id="ch11fig17"/><img alt="image" src="../images/f244-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 11-17: The first 10 rows of Rule 30</em></p>&#13;
<div class="image"><a id="ch11fig18"/><img alt="image" src="../images/f244-02.jpg"/></div>&#13;
<p class="caption"><em>Figure 11-18: More of Rule 30</em></p>&#13;
<p class="indent">The program is going through each row, starting at the top, and generating the next row according to the rules we gave it in the <span class="literal">ruleset</span>. What if we keep going? Change the number of rows and columns to 1000 and the width (<span class="literal">w</span>) of each cell to 3. Add <span class="literal">noStroke()</span> to the <span class="literal">setup()</span> function to get rid of the outline of the cells, and then run the sketch. You should see what’s in <a href="ch11.xhtml#ch11fig18">Figure 11-18</a>.</p>&#13;
<p class="indent">Rule 30 is a fascinating design because it’s not completely random, but it’s not completely regular either. <span epub:type="pagebreak" id="page_245"/>Rule 73 is also cool; in fact a woman named Fabienne Serriere programs the rule into a knitting machine to create scarves with the pattern, like in <a href="ch11.xhtml#ch11fig19">Figure 11-19</a>. You can order scarves with this and other algorithmically generated rules on them from <em><a href="https://knityak.com/">https://knityak.com/</a></em>.</p>&#13;
<div class="image"><a id="ch11fig19"/><img alt="image" src="../images/f245-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 11-19: A scarf whose design is a cellular automaton: Rule 73!</em></p>&#13;
<div class="sidebar">&#13;
<p class="title">EXERCISE 11-2: CHANGING THE RULE SET</p>&#13;
<p class="noindent">Change <span class="literal">ruleset</span> to the binary form of the number 90. What does the resulting CA look like? Hint: it’s a fractal.</p>&#13;
</div>&#13;
<div class="sidebar">&#13;
<p class="title">EXERCISE 11-3: ZOOMING IN AND OUT</p>&#13;
<p class="noindent">Use the <span class="literal">keyPressed()</span> function you learned about in <a href="ch10.xhtml#ch10">Chapter 10</a> to change the value of the width variable <span class="literal">w</span> using the up and down arrow keys. This should let you zoom in and out of the CA!</p>&#13;
</div>&#13;
<span epub:type="pagebreak" id="page_246"/>&#13;
<h3 class="h3" id="ch11_5">SUMMARY</h3>&#13;
<p class="noindent">In this chapter, you learned to use Python to create cellular automata, or cells that act independently, according to specific rules. We wrote programs to make a huge grid of these cells follow certain rules and update themselves, generation after generation, and we created unexpectedly beautiful designs and surprisingly life-like behavior.</p>&#13;
<p class="indent">In the next chapter, we’ll create virtual organisms that solve problems for us! These organisms will be able to guess a secret phrase and find the shortest route through a bunch of cities just by evolving better and better solutions.</p>&#13;
</body></html>