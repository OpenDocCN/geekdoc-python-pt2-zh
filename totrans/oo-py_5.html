<html><head></head><body>
<p class="calibre1">Otherwise, it sets self.playing to True to indicate that the animation is now </p>
<p class="calibre1">running. </p>
<p class="calibre1">When a SimpleAnimation is created, the caller specifies the amount of time </p>
<p class="calibre1">that each image should be shown, and this is saved in self.durationPerImage. </p>
<p class="calibre1">Therefore, we must keep track of time as a SimpleAnimation runs to know when </p>
<p class="calibre1">to switch to the next image. We call time.time() to get the current time (in mil-</p>
<p class="calibre1">liseconds) and save that in an instance variable. Making the class time based </p>
<p class="calibre1">means that any SimpleAnimation object built from this class will work correctly, </p>
<p class="calibre1">independent of the frame rate used for the main loop. Finally, we set the vari-</p>
<p class="calibre1">able self.index to 0 to indicate that we should be showing the first image. </p>
<p class="calibre1">The update() method 4 needs to be called in every frame of the </p>
<p class="calibre1">main loop. If the animation is not playing, update() does nothing and just </p>
<p class="calibre1">returns. Otherwise, update() calculates how much time has elapsed since </p>
<p class="calibre1">the current image started showing by getting the current time using the </p>
<p class="calibre1">system time.time() function and subtracting that from the time at which </p>
<p class="calibre1">the current image started showing. </p>
<p class="calibre1">If the elapsed time is greater than the amount of time that each image </p>
<p class="calibre1">should be showing, it’s time move to the next image. In this case, we incre-</p>
<p class="calibre1">ment self.index so that the upcoming call to the draw() method will draw </p>
<p class="calibre1">the appropriate image. We then check whether the animation has finished. </p>
<p class="calibre1">If not, we save the start time for the new image. If the animation is done, we </p>
<p class="calibre1">set self.playing back to False (to indicate that we are no longer playing the </p>
<p class="calibre1">animation), and we reset self.index to 0 so that the draw() method will show </p>
<p class="calibre1">the first image again. </p>
<p class="calibre1">Finally, we call draw() in every frame 5 to draw the current image of </p>
<p class="calibre1">the animation. The draw() method assumes that self.index has been set cor-</p>
<p class="calibre1">rectly by a previous method, and uses it to index into the list of images. It </p>
<p class="calibre1">then draws that image in the window at the specified location. </p>
<p class="calibre1"><b class="calibre3">Example Main Program</b></p>
<p class="calibre1">Listing 14-2 shows a main program that creates and uses a SimpleAnimation </p>
<p class="calibre1">object. This will animate a dinosaur riding a bicycle. </p>
<p class="calibre1"><b class="calibre3">File: SimpleAnimation/Main_SimpleAnimation.py</b></p>
<p class="calibre1"># Animation example</p>
<p class="calibre1"># Shows example of SimpleAnimation object</p>
<p class="calibre1"># 1 - Import library</p>
<p class="calibre1">import pygame</p>
<p class="calibre1">from pygame.locals import *</p>
<p class="calibre1">import sys</p>
<p class="calibre1">import pygwidgets</p>
<p class="calibre1">from SimpleAnimation import *</p>
<p class="calibre1"># 2 Define constants</p>
<p class="calibre1">SCREEN_WIDTH = 640</p>
<p class="calibre1"><b class="calibre3">298</b>   Chapter 14</p>
<p class="calibre1"><a id="p328"/>SCREEN_HEIGHT = 480</p>
<p class="calibre1">FRAMES_PER_SECOND = 30</p>
<p class="calibre1">BGCOLOR = (0, 128, 128)</p>
<p class="calibre1"># 3 - Initialize the world</p>
<p class="calibre1">pygame.init()</p>
<p class="calibre1">window = pygame.display.set_mode([SCREEN_WIDTH, SCREEN_HEIGHT])</p>
<p class="calibre1">clock = pygame.time.Clock()</p>
<p class="calibre1"># 4 - Load assets: images(s), sound(s), etc. </p>
<p class="calibre1">1 dinosaurAnimTuple = ('images/Dinobike/f1.gif', </p>
<p class="calibre1">'images/Dinobike/f2.gif', </p>
<p class="calibre1">'images/Dinobike/f3.gif', </p>
<p class="calibre1">'images/Dinobike/f4.gif', </p>
<p class="calibre1">'images/Dinobike/f5.gif', </p>
<p class="calibre1">'images/Dinobike/f6.gif', </p>
<p class="calibre1">'images/Dinobike/f7.gif', </p>
<p class="calibre1">'images/Dinobike/f8.gif', </p>
<p class="calibre1">'images/Dinobike/f9.gif', </p>
<p class="calibre1">'images/Dinobike/f10.gif')</p>
<p class="calibre1"># 5 - Initialize variables</p>
<p class="calibre1">oDinosaurAnimation = SimpleAnimation(window, (22, 140), </p>
<p class="calibre1">dinosaurAnimTuple, .1)</p>
<p class="calibre1">oPlayButton = pygwidgets.TextButton(window, (20, 240), "Play")</p>
<p class="calibre1"># 6 - Loop forever</p>
<p class="calibre1">while True:</p>
<p class="calibre1"># 7 - Check for and handle events</p>
<p class="calibre1">for event in pygame.event.get():</p>
<p class="calibre1">if event.type == QUIT:</p>
<p class="calibre1">pygame.quit()</p>
<p class="calibre1">sys.exit()</p>
<p class="calibre1">2 if oPlayButton.handleEvent(event):</p>
<p class="calibre1">oDinosaurAnimation.play()</p>
<p class="calibre1"># 8 - Do any "per frame" actions</p>
<p class="calibre1">3 oDinosaurAnimation.update()</p>
<p class="calibre1"># 9 - Clear the window</p>
<p class="calibre1">window.fill(BGCOLOR)</p>
<p class="calibre1"># 10 - Draw all window elements</p>
<p class="calibre1">4 oDinosaurAnimation.draw()</p>
<p class="calibre1">oPlayButton.draw()</p>
<p class="calibre1"># 11 - Update the window</p>
<p class="calibre1">pygame.display.update()</p>
<p class="calibre1"/>
<p class="calibre1"># 12 - Slow things down a bit</p>
<p class="calibre1">clock.tick(FRAMES_PER_SECOND)  # make pygame wait</p>
<p class="calibre1"> <i class="calibre4">Listing 14-2:  The main program that instantiates and plays a SimpleAnimation</i></p>
<p class="calibre1">Animation   <b class="calibre3">299</b></p>
<p class="calibre1"><a id="p329"/><img src="index-329_1.png" alt="Image 38" class="calibre2"/></p>
<p class="calibre1">All the images for the animated dinosaur are in the folder  <i class="calibre4">images/</i></p>
<p class="calibre1"> <i class="calibre4">DinoBike/</i>. We first build a tuple of the images 1. Then, using that tuple, </p>
<p class="calibre1">we create a SimpleAnimation object and specify that each image should be </p>
<p class="calibre1">shown for a tenth of a second. We also instantiate a Play button. </p>
<p class="calibre1">In the main loop, we call the update() and draw() methods of the </p>
<p class="calibre1">oDinosaurAnimation object. The program loops while continuously drawing </p>
<p class="calibre1">the current image of the animation and the Play button. When the anima-</p>
<p class="calibre1">tion is not running, the user just sees the first image. </p>
<p class="calibre1">When the user clicks the Play button 2, the program calls the play() </p>
<p class="calibre1">method of oDinosaurAnimation to start the animation running. </p>
<p class="calibre1">In the main loop, we call the update() method of oDinosaur Animation 3, </p>
<p class="calibre1">which determines whether enough time has elapsed for the animation to </p>
<p class="calibre1">move on to the next image. </p>
<p class="calibre1">Finally, we call draw() 4, and the object draws the appropriate image. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">SimpleSpriteSheetAnimation Class</b></i></p>
<p class="calibre1">The second type of animation is implemented in the SimpleSpriteSheetAnimation </p>
<p class="calibre1">class. A  <i class="calibre4">sprite sheet</i> is a single image made up of a number of equally sized smaller images, intended to appear in order to create an animation. From a </p>
<p class="calibre1">developer’s point of view, there are three advantages to a sprite sheet. First, </p>
<p class="calibre1">all the images are in a single file, so there is no need to worry about building </p>
<p class="calibre1">a name for each separate file. Second, it’s possible to see the progression of </p>
<p class="calibre1">an animation in a single file, rather than having to flip through a sequence </p>
<p class="calibre1">of images. Finally, loading a single file is faster than loading a list of files that make up an animation. </p>
<p class="calibre1">Figure 14-1 shows an example of a sprite sheet. </p>
<p class="calibre1"> <i class="calibre4">Figure 14-1: A sprite sheet image made up of  </i></p>
<p class="calibre1"> <i class="calibre4">18 smal er images </i></p>
<p class="calibre1">This example is designed to show the numbers from 0 to 17. The origi-</p>
<p class="calibre1">nal file contains an image that is 384×192 pixels. A quick division shows that </p>
<p class="calibre1">each individual number image is 64×64 pixels. The key idea here is that we </p>
<p class="calibre1">use pygame to create  <i class="calibre4">subimages</i> of a larger image to give us a set of 18 new 64×64 pixel images. The smaller images can then be displayed using the </p>
<p class="calibre1">same technique as we used in the SimpleAnimation class. </p>
<p class="calibre1"><b class="calibre3">300</b>   Chapter 14</p>
<p class="calibre1"><a id="p330"/><b class="calibre3">Creating the Class</b></p>
<p class="calibre1">Listing 14-3 contains the SimpleSpriteSheetAnimation class to handle sprite </p>
<p class="calibre1">sheet–based animations. During initialization, the contents of the single </p>
<p class="calibre1">sprite sheet image are split up into a list of smaller images, which are then </p>
<p class="calibre1">displayed by the other methods. </p>
<p class="calibre1"><b class="calibre3">File: SimpleSpriteSheetAnimation/SimpleSpriteSheetAnimation.py</b></p>
<p class="calibre1"># SimpleSpriteSheetAnimation class</p>
<p class="calibre1">import pygame</p>
<p class="calibre1">import time</p>
<p class="calibre1">class SimpleSpriteSheetAnimation():</p>
<p class="calibre1">def __init__(self, window, loc, imagePath, nImages, width, height, durationPerImage): 1 </p>
<p class="calibre1">self.window = window</p>
<p class="calibre1">self.loc = loc</p>
<p class="calibre1">self.nImages = nImages</p>
<p class="calibre1">self.imagesList = []</p>
<p class="calibre1"># Load the sprite sheet</p>
<p class="calibre1">spriteSheetImage = pygame.image.load(imagePath)  </p>
<p class="calibre1"># Optimize blitting</p>
<p class="calibre1">spriteSheetImage = pygame.Surface.convert_alpha(spriteSheetImage)</p>
<p class="calibre1"># Calculate the number of columns in the starting image</p>
<p class="calibre1">nCols = spriteSheetImage.get_width() // width</p>
<p class="calibre1"># Break up the starting image into subimages</p>
<p class="calibre1">row = 0</p>
<p class="calibre1">col = 0</p>
<p class="calibre1">for imageNumber in range(nImages):</p>
<p class="calibre1">x = col * height</p>
<p class="calibre1">y = row * width</p>
<p class="calibre1"># Create a subsurface from the bigger spriteSheet</p>
<p class="calibre1">subsurfaceRect = pygame.Rect(x, y, width, height)</p>
<p class="calibre1">image = spriteSheetImage.subsurface(subsurfaceRect)</p>
<p class="calibre1">self.imagesList.append(image)</p>
<p class="calibre1">col = col + 1</p>
<p class="calibre1">if col == nCols:</p>
<p class="calibre1">col = 0</p>
<p class="calibre1">row = row + 1</p>
<p class="calibre1">self.durationPerImage = durationPerImage</p>
<p class="calibre1">self.playing = False</p>
<p class="calibre1">self.index = 0</p>
<p class="calibre1">def play(self):</p>
<p class="calibre1">if self.playing:</p>
<p class="calibre1">return</p>
<p class="calibre1">self.playing = True</p>
<p class="calibre1">Animation   <b class="calibre3">301</b></p>
<p class="calibre1"><a id="p331"/>        self.imageStartTime = time.time()</p>
<p class="calibre1">self.index = 0</p>
<p class="calibre1">def update(self):</p>
<p class="calibre1">if not self.playing:</p>
<p class="calibre1">return</p>
<p class="calibre1"># How much time has elapsed since we started showing this image</p>
<p class="calibre1">self.elapsed = time.time() - self.imageStartTime</p>
<p class="calibre1"># If enough time has elapsed, move on to the next image</p>
<p class="calibre1">if self.elapsed &gt; self.durationPerImage:</p>
<p class="calibre1">self.index = self.index + 1</p>
<p class="calibre1">if self.index &lt; self.nImages: # move on to next image</p>
<p class="calibre1">self.imageStartTime = time.time()</p>
<p class="calibre1">else:  # animation is finished</p>
<p class="calibre1">self.playing = False</p>
<p class="calibre1">self.index = 0  # reset to the beginning</p>
<p class="calibre1">def draw(self):</p>
<p class="calibre1"># Assumes that self.index has been set earlier - in the update() method. </p>
<p class="calibre1"># It is used as the index into the imagesList to find the current image. </p>
<p class="calibre1">theImage = self.imagesList[self.index]  # choose the image to show</p>
<p class="calibre1">self.window.blit(theImage, self.loc)  # show it</p>
<p class="calibre1"> <i class="calibre4">Listing 14-3: The SimpleSpriteSheetAnimation class</i></p>
<p class="calibre1">This class is very similar to SimpleAnimation, but because this animation </p>
<p class="calibre1">is based on a sprite sheet, the __init__() method must be passed different </p>
<p class="calibre1">information 1. The method requires the standard window and loc param-</p>
<p class="calibre1">eters, as well as:</p>
<p class="calibre1"><b class="calibre3">imagePath     </b>A path to a sprite sheet image (single file)</p>
<p class="calibre1"><b class="calibre3">nImages     </b>The number of images in the sprite sheet</p>
<p class="calibre1"><b class="calibre3">width     </b>The width of each subimage</p>
<p class="calibre1"><b class="calibre3">height     </b>The height of each subimage</p>
<p class="calibre1"><b class="calibre3">durationPerImage     </b>How long (in seconds) to show each image</p>
<p class="calibre1">Given these values, the __init__() method loads the sprite sheet file, and </p>
<p class="calibre1">it uses a loop to split up the larger image into a list of smaller subimages </p>
<p class="calibre1">through a call to the pygame subsurface() method. The smaller images are </p>
<p class="calibre1">then appended into the self.imagesList list for use by the other methods. </p>
<p class="calibre1">The __init__() method uses a counter to count the number of subimages, </p>
<p class="calibre1">up to the number specified by the caller; therefore, the last row of images </p>
<p class="calibre1">does not need to be a full row. For example, we could have used a sprite </p>
<p class="calibre1">sheet image that only had the numbers 0 through 14, rather than needing </p>
<p class="calibre1">to fill the row to 17. The nImages parameter is the key to making this work. </p>
<p class="calibre1">This rest of this class has the exact same methods as the previous </p>
<p class="calibre1">SimpleAnimation class: play(), update(), and draw(). </p>
<p class="calibre1"><b class="calibre3">302</b>   Chapter 14</p>
<p class="calibre1"><a id="p332"/><b class="calibre3">Example Main Program</b></p>
<p class="calibre1">Listing 14-4 provides a sample main program that creates and shows </p>
<p class="calibre1">a SimpleSpriteSheetAnimation object that shows an animated drop of </p>
<p class="calibre1">water landing and spreading out. If you download everything in the </p>
<p class="calibre1"> <i class="calibre4">SpriteSheetAnimation </i> folder of this book’s resources, you will get the </p>
<p class="calibre1">code and the appropriate artwork. </p>
<p class="calibre1"><b class="calibre3">File: SimpleSpriteSheetAnimation/Main_SimpleSpriteSheetAnimation.py</b></p>
<p class="calibre1"># Shows example of SimpleSpriteSheetAnimation object</p>
<p class="calibre1"># 1 - Import library</p>
<p class="calibre1">import pygame</p>
<p class="calibre1">from pygame.locals import *</p>
<p class="calibre1">import sys</p>
<p class="calibre1">import pygwidgets</p>
<p class="calibre1">from SimpleSpriteSheetAnimation import *</p>
<p class="calibre1"># 2 Define constants</p>
<p class="calibre1">SCREEN_WIDTH = 640</p>
<p class="calibre1">SCREEN_HEIGHT = 480</p>
<p class="calibre1">FRAMES_PER_SECOND = 30</p>
<p class="calibre1">BGCOLOR = (0, 128, 128)</p>
<p class="calibre1"># 3 - Initialize the world</p>
<p class="calibre1">pygame.init()</p>
<p class="calibre1">window = pygame.display.set_mode([SCREEN_WIDTH, SCREEN_HEIGHT])</p>
<p class="calibre1">clock = pygame.time.Clock()</p>
<p class="calibre1"># 4 - Load assets: images(s), sound(s), etc. </p>
<p class="calibre1"># 5 - Initialize variables</p>
<p class="calibre1">1 oWaterAnimation = SimpleSpriteSheetAnimation(window, (22, 140), </p>
<p class="calibre1">'images/water_003.png', </p>
<p class="calibre1">5, 50, 192, 192, .05)</p>
<p class="calibre1">oPlayButton = pygwidgets.TextButton(window, (60, 320), "Play")</p>
<p class="calibre1"># 6 - Loop forever</p>
<p class="calibre1">while True:</p>
<p class="calibre1"># 7 - Check for and handle events</p>
<p class="calibre1">for event in pygame.event.get():</p>
<p class="calibre1">if event.type == QUIT:</p>
<p class="calibre1">pygame.quit()</p>
<p class="calibre1">sys.exit()</p>
<p class="calibre1">if oPlayButton.handleEvent(event):</p>
<p class="calibre1">oWaterAnimation.play()</p>
<p class="calibre1"># 8 - Do any "per frame" actions</p>
<p class="calibre1">oWaterAnimation.update()</p>
<p class="calibre1">Animation   <b class="calibre3">303</b></p>
<p class="calibre1"><a id="p333"/>    # 9 - Clear the window</p>
<p class="calibre1">window.fill(BGCOLOR)</p>
<p class="calibre1"># 10 - Draw all window elements</p>
<p class="calibre1">oWaterAnimation.draw()</p>
<p class="calibre1">oPlayButton.draw()</p>
<p class="calibre1"># 11 - Update the window</p>
<p class="calibre1">pygame.display.update()</p>
<p class="calibre1"/>
<p class="calibre1"># 12 - Slow things down a bit</p>
<p class="calibre1">clock.tick(FRAMES_PER_SECOND)  # make pygame wait</p>
<p class="calibre1"> <i class="calibre4">Listing 14-4: A sample main program that creates and uses a SimpleSpriteSheetAnimation</i> <i class="calibre4">object</i></p>
<p class="calibre1">The only significant difference with this example is that it instantiates a </p>
<p class="calibre1">SimpleSpriteSheetAnimation object 1 instead of a SimpleAnimation object. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Merging Two Classes</b></i></p>
<p class="calibre1">The __init__() methods in SimpleAnimation and SimpleSpriteSheetAnimation </p>
<p class="calibre1">have different parameters, but the other three methods (start(), update(), </p>
<p class="calibre1">and draw()) are identical. Once you instantiate either of these classes, the </p>
<p class="calibre1">way that you access the resulting objects is exactly the same. The “Don’t </p>
<p class="calibre1">Repeat Yourself” (DRY) principle says that having these duplicated meth-</p>
<p class="calibre1">ods is a bad idea, because any bug fixes and/or enhancements would have </p>
<p class="calibre1">to be applied in both copies of the methods. </p>
<p class="calibre1">Instead, this is a good opportunity to merge classes. We can create </p>
<p class="calibre1">a common abstract base class for these classes to inherit from. The base </p>
<p class="calibre1">class will have its own __init__() method that includes any common code </p>
<p class="calibre1">from the __init__() methods of both original classes, and it will contain the </p>
<p class="calibre1">play(), update(), and draw() methods. </p>
<p class="calibre1">Each original class will inherit from the new base class and implement </p>
<p class="calibre1">its own __init__() method using the appropriate parameters. Each will do </p>
<p class="calibre1">its own work to create self.imagesList, which is then used in the other three </p>
<p class="calibre1">methods in the new base class. </p>
<p class="calibre1">Rather than showing the result of merging these two “simple” classes, </p>
<p class="calibre1">I’ll show the result of this merge in the “professional strength” Animation and </p>
<p class="calibre1">SpriteSheetAnimation classes that are part of the pygwidgets package. </p>
<p class="calibre1"><b class="calibre3">Animation Classes in pygwidgets</b></p>
<p class="calibre1">The pygwidgets module contains the following three animation classes:</p>
<p class="calibre1"><b class="calibre3">PygAnimation     </b>An abstract base class for the Animation and </p>
<p class="calibre1">SpriteSheetAnimation classes</p>
<p class="calibre1"><b class="calibre3">Animation     </b>A class for image-based animations (separate image files)</p>
<p class="calibre1"><b class="calibre3">SpriteSheetAnimation     </b>A class for sprite sheet–based animations (a </p>
<p class="calibre1">single large image)</p>
<p class="calibre1"><b class="calibre3">304</b>   Chapter 14</p>
<p class="calibre1"><a id="p334"/>We’ll look at each class in turn. The Animation and SpriteSheetAnimation classes use the same basic concepts discussed, but also have more options </p>
<p class="calibre1">available via initialization parameters. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Animation Class</b></i></p>
<p class="calibre1">You use pygwidget’s Animation class to create an animation from many differ-</p>
<p class="calibre1">ent image files. Here is the interface:</p>
<p class="calibre1">Animation(window, loc, animTuplesList, autoStart=False, </p>
<p class="calibre1">loop=False, nickname=None, callBack=None, nIterations=1):</p>
<p class="calibre1">The required parameters are:</p>
<p class="calibre1"><b class="calibre3">window</b></p>
<p class="calibre1">The window to draw in. </p>
<p class="calibre1"><b class="calibre3">loc </b></p>
<p class="calibre1">The upper-left corner where images should be drawn. </p>
<p class="calibre1"><b class="calibre3">animTuplesList </b></p>
<p class="calibre1">A list (or tuple) of tuples describing the sequence of the animation. </p>
<p class="calibre1">Each inner tuple contains:</p>
<p class="calibre1"><b class="calibre3">pathToImage  </b>The relative path to an image file. </p>
<p class="calibre1"><b class="calibre3">Duration  </b>The duration this image should be shown (in seconds, float-</p>
<p class="calibre1">ing point). </p>
<p class="calibre1"><b class="calibre3">offset (optional)    </b>If present, an (x, y) tuple used as an offset from the </p>
<p class="calibre1">main loc to show this image. </p>
<p class="calibre1">These parameters are all optional:</p>
<p class="calibre1"><b class="calibre3">autoStart</b></p>
<p class="calibre1">True if you want the animation to start right away; defaults to False. </p>
<p class="calibre1"><b class="calibre3">loop </b></p>
<p class="calibre1">True if you want the animation to loop continuously; defaults to False. </p>
<p class="calibre1"><b class="calibre3">showFirstImageAtEnd </b></p>
<p class="calibre1">When an animation ends, show the first image again; defaults to True. </p>
<p class="calibre1"><b class="calibre3">nickname </b></p>
<p class="calibre1">An internal name to assign to this animation, used as an argument </p>
<p class="calibre1">when a callBack is specified. </p>
<p class="calibre1"><b class="calibre3">callBack </b></p>
<p class="calibre1">The function or object method to call when the animation is done. </p>
<p class="calibre1"><b class="calibre3">nIterations </b></p>
<p class="calibre1">The number of times to loop through the animation; defaults to 1. </p>
<p class="calibre1">Unlike SimpleAnimation, which uses a single duration for all images, </p>
<p class="calibre1">the Animation class lets you specify a duration for  <i class="calibre4">each</i> image, allowing for Animation   <b class="calibre3">305</b></p>
<p class="calibre1"><a id="p335"/>greater flexibility in the timing of how the images are displayed. You can also specify an x, y offset when drawing each image, but in general this </p>
<p class="calibre1">isn’t needed. Here is some sample code that creates an Animation object that </p>
<p class="calibre1">shows a running T-rex dinosaur:</p>
<p class="calibre1">TRexAnimationList = [('images/TRex/f1.gif', .1), </p>
<p class="calibre1">('images/TRex/f2.gif', .1), </p>
<p class="calibre1">('images/TRex/f3.gif', .1), </p>
<p class="calibre1">('images/TRex/f4.gif', .1), </p>
<p class="calibre1">('images/TRex/f5.gif', .1), </p>
<p class="calibre1">('images/TRex/f6.gif', .1), </p>
<p class="calibre1">('images/TRex/f7.gif', .1), </p>
<p class="calibre1">('images/TRex/f8.gif', .1), </p>
<p class="calibre1">('images/TRex/f9.gif', .1), </p>
<p class="calibre1">('images/TRex/f10.gif', .4)]</p>
<p class="calibre1"># 5 - Initialize variables</p>
<p class="calibre1">oDinosaurAnimation = pygwidgets.Animation(window, (22, 145), </p>
<p class="calibre1">TRexAnimationList, callBack=myFunction, nickname='Dinosaur')</p>
<p class="calibre1">This creates an Animation object that will show 10 different images. The </p>
<p class="calibre1">first nine images each show for one-tenth of a second, but the last image </p>
<p class="calibre1">shows for four-tenths of a second. The animation will only play once and </p>
<p class="calibre1">will not automatically start playing. When the animation is finished, </p>
<p class="calibre1">myFunction() will be called with the argument 'Dinosaur'. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">SpriteSheetAnimation Class</b></i></p>
<p class="calibre1">For SpriteSheetAnimation, you pass in a path to the single sprite sheet file. In </p>
<p class="calibre1">order for SpriteSheetAnimation to break up the large animation into many </p>
<p class="calibre1">smaller images, you must specify the width and height of all subimages. For </p>
<p class="calibre1">durations, you have two choices: you can specify a single value to say that all </p>
<p class="calibre1">images should be shown for the same amount of time, or you can specify a </p>
<p class="calibre1">list or tuple of durations, one for each image. Here’s the interface:</p>
<p class="calibre1">SpriteSheetAnimation(window, loc, imagePath, nImages, </p>
<p class="calibre1">width, height, durationOrDurationsList, </p>
<p class="calibre1">autoStart=False, loop=False, nickname=None, </p>
<p class="calibre1">callBack=None, nIterations=1):</p>
<p class="calibre1">The required parameters are:</p>
<p class="calibre1"><b class="calibre3">window     </b>The window to draw in</p>
<p class="calibre1"><b class="calibre3">loc     </b>The upper-left corner where images should be drawn</p>
<p class="calibre1"><b class="calibre3">imagePath     </b>The relative path to the sprite sheet image file</p>
<p class="calibre1"><b class="calibre3">nImages     </b>The total number of subimages in the sprite sheet subimage</p>
<p class="calibre1"><b class="calibre3">width     </b>The width of each single resulting subimage</p>
<p class="calibre1"><b class="calibre3">height  </b>The height of each single resulting subimage</p>
<p class="calibre1"><b class="calibre3">durationOrDurationsList     </b>The amount of time for which each subim-</p>
<p class="calibre1">age should be shown during animation or a list of durations, one per </p>
<p class="calibre1">subimage (the length must be nImages)</p>
<p class="calibre1"><b class="calibre3">306</b>   Chapter 14</p>
<p class="calibre1"><a id="p336"/>These are the optional parameters:</p>
<p class="calibre1"><b class="calibre3">autoStart </b></p>
<p class="calibre1">True if you want the animation to start right away; defaults to False. </p>
<p class="calibre1"><b class="calibre3">loop </b></p>
<p class="calibre1">True if you want to animation to loop continuously; defaults to False. </p>
<p class="calibre1"><b class="calibre3">showFirstImageAtEnd </b></p>
<p class="calibre1">When an animation ends, show the first image again; defaults to True. </p>
<p class="calibre1"><b class="calibre3">nickname </b></p>
<p class="calibre1">An internal name to assign to this animation, used as an argument </p>
<p class="calibre1">when a callBack is specified. </p>
<p class="calibre1"><b class="calibre3">callBack </b></p>
<p class="calibre1">The function or object method to call when the animation is done. </p>
<p class="calibre1"><b class="calibre3">nIterations </b></p>
<p class="calibre1">The number of times to loop through the animation; defaults to 1. </p>
<p class="calibre1">Here is a typical statement to create a SpriteSheetAnimation object:</p>
<p class="calibre1">oEffectAnimation = pygwidgets.SpriteSheetAnimation(window, (400, 150), </p>
<p class="calibre1">'images/effect.png', 35, 192, 192, .1, </p>
<p class="calibre1">autoStart=True, loop=True)</p>
<p class="calibre1">This creates a SpriteSheetAnimation object using a single image file found </p>
<p class="calibre1">at the given path. The original image contains 35 subimages. Each smaller </p>
<p class="calibre1">image is 192×192 pixels, and each subimage will be shown for one-tenth of a </p>
<p class="calibre1">second. The animation will start automatically and loop continuously. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Common Base Class: PygAnimation</b></i></p>
<p class="calibre1">The Animation and SpriteSheetAnimation classes each consist only of an </p>
<p class="calibre1">__init__() method and inherit from a common abstract base class, </p>
<p class="calibre1">PygAnimation. The __init__() methods of both classes call the inherited </p>
<p class="calibre1">__init__() method of the PygAnimation base class. Therefore, the __init__() </p>
<p class="calibre1">methods of the Animation and SpriteSheetAnimation classes only initialize </p>
<p class="calibre1">the unique data in their classes. </p>
<p class="calibre1">After creating an Animation or SpriteSheetAnimation object, client code </p>
<p class="calibre1">needs to include calls to update() and draw() in every frame. The following is </p>
<p class="calibre1">a list of the methods available to both classes through the base class:</p>
<p class="calibre1"><b class="calibre3">handleEvent( <i class="calibre4">event</i></b><b class="calibre3">)</b></p>
<p class="calibre1">Must be called in every frame if you want to check if the user has clicked </p>
<p class="calibre1">on the animation. If so, you pass in the event supplied by pygame. This </p>
<p class="calibre1">method returns False most of the time, but returns True when the user </p>
<p class="calibre1">clicks down on the image, in which case you would typically call play(). </p>
<p class="calibre1"><b class="calibre3">play() </b></p>
<p class="calibre1">Starts the animation playing. </p>
<p class="calibre1">Animation   <b class="calibre3">307</b></p>
<p class="calibre1"><a id="p337"/><b class="calibre3">stop() </b></p>
<p class="calibre1">Stops the animation wherever it is, and resets to showing only the first </p>
<p class="calibre1">image. </p>
<p class="calibre1"><b class="calibre3">pause() </b></p>
<p class="calibre1">Causes the animation to temporarily stop on the current image. You </p>
<p class="calibre1">can continue playing with a call to play(). </p>
<p class="calibre1"><b class="calibre3">update() </b></p>
<p class="calibre1">Should be called in every frame. When the animation is running, this </p>
<p class="calibre1">method takes care of calculating the proper time to advance to the </p>
<p class="calibre1">next image. It typically returns False, but returns True when the anima-</p>
<p class="calibre1">tion ends (and it is not set to loop). </p>
<p class="calibre1"><b class="calibre3">draw() </b></p>
<p class="calibre1">Should be called in every frame. This method draws the current image </p>
<p class="calibre1">of the animation. </p>
<p class="calibre1"><b class="calibre3">setLoop( <i class="calibre4">trueOrFalse</i></b><b class="calibre3">)</b></p>
<p class="calibre1">Pass in True or False to indicate whether the animation should loop or </p>
<p class="calibre1">not. </p>
<p class="calibre1"><b class="calibre3">getLoop() </b></p>
<p class="calibre1">Returns True if the animation is set to loop or False if it is not. </p>
<p class="calibre1"><b class="calibre3">N O T E </b> <i class="calibre4"> </i></p>
<p class="calibre1"> <i class="calibre4">The location of an animation in the window is determined by the original value of</i> <i class="calibre4">loc that’s passed to __init__(). Both Animation and SpriteSheetAnimation inherit</i> <i class="calibre4">from the common PygAnimation class, and that class inherits from PygWidget. Since</i> <i class="calibre4">all the methods available in PygWidget are therefore available in both animation</i> <i class="calibre4">classes, you could easily construct an animation that also changes its location while</i> <i class="calibre4">it is playing. You can make any animation move by calling setLoc(), inherited from</i> <i class="calibre4">PygWidget, and supplying any x and y location you like for each image. </i></p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Example Animation Program</b></i></p>
<p class="calibre1">Figure 14-2 shows a screenshot of a sample program that demonstrates mul-</p>
<p class="calibre1">tiple animations built from the Animation and SpriteSheetAnimation classes. </p>
<p class="calibre1">The little dinosaur on the left is an Animation object. It’s set to autoStart so </p>
<p class="calibre1">the animation plays when the program begins, but only once. Clicking the </p>
<p class="calibre1">buttons below the small dinosaur makes appropriate calls to the Animation </p>
<p class="calibre1">object. If you click Play, the animation plays again. While the animation is </p>
<p class="calibre1">playing, clicking Pause will freeze the animation until you click Play again. </p>
<p class="calibre1">If you play the animation and then click Stop, the animation will stop and </p>
<p class="calibre1">show the first image. Below those buttons are two checkboxes. By default, this </p>
<p class="calibre1">animation will not loop. If you check Loop, then press Play, the animation </p>
<p class="calibre1">repeats until you uncheck Loop. The Show checkbox makes the animation </p>
<p class="calibre1">visible or invisible. </p>
<p class="calibre1"><b class="calibre3">308</b>   Chapter 14</p>
<p class="calibre1"><a id="p338"/><img src="index-338_1.png" alt="Image 39" class="calibre2"/></p>
<p class="calibre1"> <i class="calibre4">Figure 14-2: An example animation program using the Animation and </i></p>
<p class="calibre1"> <i class="calibre4">SpriteSheetAnimation classes</i></p>
<p class="calibre1">The second (T-rex) Animation object is not set to autoStart, so you only </p>
<p class="calibre1">see the first image of the animation. If you click this image, the anima-</p>
<p class="calibre1">tion is set to iterate through all its images three times (three loops) before </p>
<p class="calibre1">stopping. </p>
<p class="calibre1">At the top right is a firework SpriteSheetAnimation object, which comes </p>
<p class="calibre1">from a single image containing 35 subimages. This animation is set to loop, </p>
<p class="calibre1">so you see it run continuously. </p>
<p class="calibre1">At the bottom right is a walking SpriteSheetAnimation from a single image </p>
<p class="calibre1">with 36 subimages. When you click Start, the animation plays through all </p>
<p class="calibre1">the images once. </p>
<p class="calibre1">The full source code of this program is available in the  <i class="calibre4">AnimationExample/ </i></p>
<p class="calibre1"> <i class="calibre4">Main_AnimationExample.py </i> file along with the rest of the book’s resources.  <i class="calibre4"> </i></p>
<p class="calibre1">The program instantiates two Animation objects (the small dinosaur and </p>
<p class="calibre1">the T-rex) and two SpriteSheetAnimation objects (the firework and the walk-</p>
<p class="calibre1">ing person). When a button below the little dinosaur is clicked, we call the </p>
<p class="calibre1">appropriate method of the dinosaur animation object. A click on the little </p>
<p class="calibre1">dinosaur or T-rex results in a call to the start() method of that animation. </p>
<p class="calibre1">The program shows that multiple animations can run at the same </p>
<p class="calibre1">time. This works because the main loop calls the update() and draw() meth-</p>
<p class="calibre1">ods of  <i class="calibre4">each</i> animation in every frame in the main loop, and each animation </p>
<p class="calibre1">makes its own decision about keeping the current image or showing the </p>
<p class="calibre1">next image. </p>
<p class="calibre1">Animation   <b class="calibre3">309</b></p>
<p class="calibre1"><a id="p339"/><b class="calibre3">Summary</b></p>
<p class="calibre1">In this chapter, we explored the mechanisms required in an animation class </p>
<p class="calibre1">by building our own SimpleAnimation and SimpleSpriteSheetAnimation classes. </p>
<p class="calibre1">The former is made up of multiple images, whereas the latter uses a single </p>
<p class="calibre1">larger image that contains multiple subimages. </p>
<p class="calibre1">These two classes have different initializations, but the remaining meth-</p>
<p class="calibre1">ods of the classes are identical. I explained the process of merging the two </p>
<p class="calibre1">classes by building a common abstract base class. </p>
<p class="calibre1">I then introduced the Animation class and the SpriteSheetAnimation class </p>
<p class="calibre1">in pygwidgets. I explained that these two classes only implement their own </p>
<p class="calibre1">versions of the __init__() method, inheriting their other methods from the </p>
<p class="calibre1">common base class, PygAnimation. I concluded by showing a demonstration </p>
<p class="calibre1">program that provides examples of animations and sprite sheet animations. </p>
<p class="calibre1"><a id="p340"/><b class="calibre3">15</b></p>
<p class="calibre1"><b class="calibre3">S C E N E S</b></p>
<p class="calibre1">Games and programs will often need to </p>
<p class="calibre1">present different scenes to the user. For the </p>
<p class="calibre1">purpose of this discussion, I’ll define a  <i class="calibre4">scene</i> </p>
<p class="calibre1">as any window layout and related user interac-</p>
<p class="calibre1">tions that are significantly different from any other. For </p>
<p class="calibre1">example, a game like  <i class="calibre4">Space Invaders</i> may have a starting </p>
<p class="calibre1">or  <i class="calibre4">splash</i> scene, a main game play scene, a high scores </p>
<p class="calibre1">scene, and perhaps an ending or goodbye scene. </p>
<p class="calibre1">In this chapter I will discuss two different approaches to writing a pro-</p>
<p class="calibre1">gram that has multiple scenes. First, I’ll introduce the state machine tech-</p>
<p class="calibre1">nique, which works well for relatively small programs. Then I’ll show a fully </p>
<p class="calibre1">object-oriented approach where each scene is implemented as an object, </p>
<p class="calibre1">under the control of a scene manager. The latter is much more scalable for </p>
<p class="calibre1">larger programs. </p>
<p class="calibre1"><a id="p341"/><b class="calibre3">The State Machine Approach</b></p>
<p class="calibre1">At the beginning of this book, we developed a software simulation of a </p>
<p class="calibre1">light switch. I<a href="index_split_000.html#p32">n Chapter 1, w</a>e first implemented a light switch using procedural code, and then we rewrote it using a class. In both cases, the position </p>
<p class="calibre1">(or state) of the switch was represented by a single Boolean variable; True </p>
<p class="calibre1">represented on and False represented off. </p>
<p class="calibre1">There are many situations where a program or an object can be in </p>
<p class="calibre1">one of a number of different states, and different code needs to run based </p>
<p class="calibre1">on the current state. For example, consider the series of steps involved in </p>
<p class="calibre1">using an ATM. There is a starting (greeting) state, then you need to put in </p>
<p class="calibre1">your ATM card; after this you’re prompted to enter your PIN, choose which </p>
<p class="calibre1">action you want to do, and so on. At any point, you may need to go back a </p>
<p class="calibre1">step or even start over. The general implementation approach is to use a </p>
<p class="calibre1"> <i class="calibre4">state machine</i>. </p>
<p class="calibre1"><b class="calibre3">state machine</b> </p>
<p class="calibre1">A model that represents and controls the flow of execution through a series of states . </p>
<p class="calibre1">The implementation of a state machine consists of: </p>
<p class="calibre1">•  A collection of predefined states, typically expressed as constants whose </p>
<p class="calibre1">values are strings comprised of a word or short phrase that describes </p>
<p class="calibre1">what happens in the state</p>
<p class="calibre1">•  A single variable to track the current state</p>
<p class="calibre1">•  A starting state (from the set of predefined states)</p>
<p class="calibre1">•  A set of clearly defined transitions between states</p>
<p class="calibre1">A state machine can only be in one state at any given time, but can </p>
<p class="calibre1">move to a new state, typically based on specific input from the user. </p>
<p class="calibre1">I<a href="index_split_003.html#p172">n Chapter 7 w</a>e discussed the GUI button classes in the pygwidgets package. When rolling over and clicking a button, a user sees three different images—up, over, and down—which correspond to different states of </p>
<p class="calibre1">the button. The image switching is done in the handleEvent() method (which </p>
<p class="calibre1">is called whenever an event occurs). Let’s take a closer look at how this is </p>
<p class="calibre1">implemented. </p>
<p class="calibre1">The handleEvent() method is built as a state machine. The state is kept </p>
<p class="calibre1">in an instance variable, self.state. Each button starts in the up state, show-</p>
<p class="calibre1">ing the “up” image. When the user moves the cursor over a button, we </p>
<p class="calibre1">show the “over” image and the code transitions to the over state. When the </p>
<p class="calibre1">user clicks down on the button, we show the “down” image and the code </p>
<p class="calibre1">moves into the down state (internally called the  <i class="calibre4">armed</i> state). When the user releases the mouse button (clicks up), we again show the “over” image, and </p>
<p class="calibre1">the code transitions back to the over state (and handleEvent() returns True to </p>
<p class="calibre1">indicate that a click has happened). If the user then moves the cursor off the </p>
<p class="calibre1">button, we show the “up” image again and transition back to the up state. </p>
<p class="calibre1"><b class="calibre3">312</b>   Chapter 15</p>
<p class="calibre1"><a id="p342"/>Next, I’ll show you how we can use a state machine to represent different scenes that a user can encounter in a larger program. As a generic </p>
<p class="calibre1">example, we’ll have the following scenes:  <i class="calibre4">Splash</i> (starting),  <i class="calibre4">Play</i>, and  <i class="calibre4">End</i>. </p>
<p class="calibre1">We’ll create a set of constants that represent the different states, create a </p>
<p class="calibre1">variable called state, and assign it the value of the starting state:</p>
<p class="calibre1">STATE_SPLASH = 'splash' </p>
<p class="calibre1">STATE_PLAY = 'play' </p>
<p class="calibre1">STATE_END = 'end' </p>
<p class="calibre1">state = STATE_SPLASH  # initialize to starting state</p>
<p class="calibre1">In order to perform different actions in the different states, in the pro-</p>
<p class="calibre1">gram’s main loop we use an if/elif/elif/.../else construct that branches </p>
<p class="calibre1">based on the current value of the state variable:</p>
<p class="calibre1">while True:</p>
<p class="calibre1">if state == STATE_SPLASH:</p>
<p class="calibre1"># Do whatever you want to do in the Splash state here</p>
<p class="calibre1">elif state == STATE_PLAY:</p>
<p class="calibre1"># Do whatever you want to do in the Play state here</p>
<p class="calibre1">elif state == STATE_END:</p>
<p class="calibre1"># Do whatever you want to do in the End state here</p>
<p class="calibre1">else:</p>
<p class="calibre1">raise ValueError('Unknown value for state: ' + state)</p>
<p class="calibre1">Since state is initially set to STATE_SPLASH, only the first branch of the if </p>
<p class="calibre1">statement will run. </p>
<p class="calibre1">The idea of a state machine is that under certain circumstances, typi-</p>
<p class="calibre1">cally triggered by some event, the program changes its state by assigning a </p>
<p class="calibre1">different value to the state variable. For example, the starting Splash scene </p>
<p class="calibre1">could just show a game introduction with a Start button. When the user </p>
<p class="calibre1">clicks the Start button, the game will execute an assignment statement that </p>
<p class="calibre1">changes the value of the state variable to transition into the Play state:</p>
<p class="calibre1">state = STATE_PLAY</p>
<p class="calibre1">Once that line runs, only the code in the first elif runs and completely </p>
<p class="calibre1">different code will execute—the code to show and react to the Play state. </p>
<p class="calibre1">Similarly, whenever and however the program reaches the ending con-</p>
<p class="calibre1">dition for the game, it will execute the following line to transition to the </p>
<p class="calibre1">End state:</p>
<p class="calibre1">state = STATE_END</p>
<p class="calibre1">From then on, every time the program goes around the while loop, the </p>
<p class="calibre1">code of the second elif branch will run. </p>
<p class="calibre1">In summary, a state machine has a set of states, one variable to keep </p>
<p class="calibre1">track of which state the program is in, and a set of events that cause the pro-</p>
<p class="calibre1">gram to transition from one state to another. Since there is a single variable </p>
<p class="calibre1">Scenes   <b class="calibre3">313</b></p>
<p class="calibre1"><a id="p343"/><img src="index-343_1.png" alt="Image 40" class="calibre2"/></p>
<p class="calibre1">that keeps track of the state, the program can be in only one of the states at </p>
<p class="calibre1">any time. Different actions that the user takes (clicking a button, pressing </p>
<p class="calibre1">a key, dragging an item, and so on) or other events (such as a timer run-</p>
<p class="calibre1">ning out) can cause the program to transition from one state to another. </p>
<p class="calibre1">Depending on which state it is in, the program may listen for different </p>
<p class="calibre1">events and will typically execute different code. </p>
<p class="calibre1"><b class="calibre3">A pygame Example with a State Machine</b></p>
<p class="calibre1">Next, we’ll build a Rock, Paper, Scissors game that uses a state machine. </p>
<p class="calibre1">The user chooses rock, paper, or scissors; then the computer randomly </p>
<p class="calibre1">chooses among the three. If the person and computer choose the same </p>
<p class="calibre1">item, it’s a tie. Otherwise, one point is awarded to the player or the com-</p>
<p class="calibre1">puter, according to the following rules:</p>
<p class="calibre1">•  Rock crushes scissors. </p>
<p class="calibre1">•  Scissors cuts paper. </p>
<p class="calibre1">•  Paper covers rock. </p>
<p class="calibre1">The user will see the game as three scenes: an opening or Splash scene </p>
<p class="calibre1">(Figure 15-1), a Play scene (Figure 15-2), and a Results scene (Figure 15-3). </p>
<p class="calibre1"> <i class="calibre4">Figure 15-1: The Rock, Paper, Scissors Splash scene </i></p>
<p class="calibre1">The Splash scene waits for the user to click the Start button. </p>
<p class="calibre1"><b class="calibre3">314</b>   Chapter 15</p>
<p class="calibre1"><a id="p344"/><img src="index-344_1.png" alt="Image 41" class="calibre2"/></p>
<p class="calibre1"><img src="index-344_2.png" alt="Image 42" class="calibre2"/></p>
<p class="calibre1"> <i class="calibre4">Figure 15-2: The Rock, Paper, Scissors Play scene </i></p>
<p class="calibre1">The Play scene is where the user makes a choice. After the user clicks </p>
<p class="calibre1">an icon to indicate their choice, the computer makes a randomized choice. </p>
<p class="calibre1"> <i class="calibre4">Figure 15-3: The Rock, Paper, Scissors Results scene </i></p>
<p class="calibre1">Scenes   <b class="calibre3">315</b></p>
<p class="calibre1"><a id="p345"/>The Results scene shows the outcome of the round and the score. It waits for the user to click Restart to play another round. </p>
<p class="calibre1">In this game, each value of state corresponds to a different scene. </p>
<p class="calibre1">Figure 15-4 is a  <i class="calibre4">state diagram</i> that shows the states and transitions (the </p>
<p class="calibre1">actions or events that cause the program to move from one state to </p>
<p class="calibre1">another). </p>
<p class="calibre1">Choose rock, paper, or scissors</p>
<p class="calibre1">Press Start button</p>
<p class="calibre1">Splash</p>
<p class="calibre1">Play</p>
<p class="calibre1">Results</p>
<p class="calibre1">Press Restart button</p>
<p class="calibre1"> <i class="calibre4">Figure 15-4: Rock, Paper, Scissors state diagram</i></p>
<p class="calibre1">When sitting idle (waiting for the user), the current scene will typically </p>
<p class="calibre1">remain unchanged. That is, inside the main event loop, the program will </p>
<p class="calibre1">usually not change the value of the state variable. (The state might change </p>
<p class="calibre1">when a timer ends, but this will be rare.) This game starts in the Splash </p>
<p class="calibre1">scene, and when the user presses the Start button, the game moves to the </p>
<p class="calibre1">Play scene. The play of the game then alternates between the Play and </p>
<p class="calibre1">Results scenes. Though this is a simple example, a state diagram can be very </p>
<p class="calibre1">useful in understanding the flow of more complicated programs. </p>
<p class="calibre1">Listing 15-1 provides the code of the Rock, Paper, Scissors program, </p>
<p class="calibre1">with the boilerplate code omitted to save space. </p>
<p class="calibre1"><b class="calibre3">File: RockPaperScissorsStateMachine/RockPaperScissors.py</b></p>
<p class="calibre1"># Rock, Paper, Scissors in pygame</p>
<p class="calibre1"># Demonstration of a state machine</p>
<p class="calibre1">--- snip ---</p>
<p class="calibre1">ROCK = 'Rock' </p>
<p class="calibre1">PAPER = 'Paper' </p>
<p class="calibre1">SCISSORS = 'Scissors' </p>
<p class="calibre1"># Set constants for each of the three states</p>
<p class="calibre1">STATE_SPLASH = 'Splash' 1</p>
<p class="calibre1">STATE_PLAYER_CHOICE = 'PlayerChoice' </p>
<p class="calibre1">STATE_SHOW_RESULTS = 'ShowResults' </p>
<p class="calibre1"># 3 - Initialize the world</p>
<p class="calibre1">--- snip ---</p>
<p class="calibre1"/>
<p class="calibre1"># 4 - Load assets: image(s), sound(s), etc. </p>
<p class="calibre1">--- snip ---</p>
<p class="calibre1"><b class="calibre3">316</b>   Chapter 15</p>
<p class="calibre1"><a id="p346"/># 5 - Initialize variables</p>
<p class="calibre1">playerScore = 0</p>
<p class="calibre1">computerScore = 0</p>
<p class="calibre1">state = STATE_SPLASH 2  # the starting state</p>
<p class="calibre1"># 6 - Loop forever</p>
<p class="calibre1">while True:</p>
<p class="calibre1"># 7 - Check for and handle events</p>
<p class="calibre1">for event in pygame.event.get():</p>
<p class="calibre1">if event.type == pygame.QUIT: </p>
<p class="calibre1">pygame.quit()  </p>
<p class="calibre1">sys.exit() </p>
<p class="calibre1"/>
<p class="calibre1">if state == STATE_SPLASH: 3</p>
<p class="calibre1">if startButton.handleEvent(event):</p>
<p class="calibre1">state = STATE_PLAYER_CHOICE</p>
<p class="calibre1">elif state == STATE_PLAYER_CHOICE: 4  # let the user choose</p>
<p class="calibre1">playerChoice = ''  # indicates no choice yet</p>
<p class="calibre1">if rockButton.handleEvent(event):</p>
<p class="calibre1">playerChoice = ROCK</p>
<p class="calibre1">rpsCollectionPlayer.replace(ROCK)</p>
<p class="calibre1"/>
<p class="calibre1">elif paperButton.handleEvent(event):</p>
<p class="calibre1">playerChoice = PAPER</p>
<p class="calibre1">rpsCollectionPlayer.replace(PAPER)</p>
<p class="calibre1"/>
<p class="calibre1">elif scissorButton.handleEvent(event):</p>
<p class="calibre1">playerChoice = SCISSORS</p>
<p class="calibre1">rpsCollectionPlayer.replace(SCISSORS)</p>
<p class="calibre1">if playerChoice != '':  # player has made a choice, make computer choice</p>
<p class="calibre1"># Computer chooses from tuple of moves</p>
<p class="calibre1">rps = (ROCK, PAPER, SCISSORS)</p>
<p class="calibre1">computerChoice = random.choice(rps) # computer chooses</p>
<p class="calibre1">rpsCollectionComputer.replace(computerChoice)</p>
<p class="calibre1"># Evaluate the game</p>
<p class="calibre1">if playerChoice == computerChoice:  # tie</p>
<p class="calibre1">resultsField.setValue('It is a tie!')</p>
<p class="calibre1">tieSound.play()</p>
<p class="calibre1"/>
<p class="calibre1">elif playerChoice == ROCK and computerChoice == SCISSORS:</p>
<p class="calibre1">resultsField.setValue('Rock breaks Scissors. You win!')</p>
<p class="calibre1">playerScore = playerScore + 1</p>
<p class="calibre1">winnerSound.play()</p>
<p class="calibre1">elif playerChoice == ROCK and computerChoice == PAPER:</p>
<p class="calibre1">resultsField.setValue('Rock is covered by Paper. You lose.')</p>
<p class="calibre1">computerScore = computerScore + 1</p>
<p class="calibre1">loserSound.play()</p>
<p class="calibre1"/>
<p class="calibre1">Scenes   <b class="calibre3">317</b></p>
<p class="calibre1"><a id="p347"/>                elif playerChoice == SCISSORS and computerChoice == PAPER: resultsField.setValue('Scissors cuts Paper. You win!')</p>
<p class="calibre1">playerScore = playerScore + 1</p>
<p class="calibre1">winnerSound.play()</p>
<p class="calibre1">elif playerChoice == SCISSORS and computerChoice == ROCK:</p>
<p class="calibre1">resultsField.setValue('Scissors crushed by Rock. You lose.')</p>
<p class="calibre1">computerScore = computerScore + 1</p>
<p class="calibre1">loserSound.play()</p>
<p class="calibre1">elif playerChoice == PAPER and computerChoice == ROCK:</p>
<p class="calibre1">resultsField.setValue('Paper covers Rock. You win!')</p>
<p class="calibre1">playerScore = playerScore + 1</p>
<p class="calibre1">winnerSound.play()</p>
<p class="calibre1">elif playerChoice == PAPER and computerChoice == SCISSORS:</p>
<p class="calibre1">resultsField.setValue('Paper is cut by Scissors. You lose.')</p>
<p class="calibre1">computerScore = computerScore + 1</p>
<p class="calibre1">loserSound.play()</p>
<p class="calibre1"># Show the player's score</p>
<p class="calibre1">playerScoreCounter.setValue('Your Score: '+ str(playerScore))</p>
<p class="calibre1"># Show the computer's score</p>
<p class="calibre1">computerScoreCounter.setValue('Computer Score: '+ str(computerScore))</p>
<p class="calibre1">state = STATE_SHOW_RESULTS  # change state</p>
<p class="calibre1">elif state == STATE_SHOW_RESULTS: 5</p>
<p class="calibre1">if restartButton.handleEvent(event):</p>
<p class="calibre1">state = STATE_PLAYER_CHOICE  # change state</p>
<p class="calibre1">else:</p>
<p class="calibre1">raise ValueError('Unknown value for state:', state)</p>
<p class="calibre1"># 8 - Do any "per frame" actions</p>
<p class="calibre1">if state == STATE_PLAYER_CHOICE:</p>
<p class="calibre1">messageField.setValue('       Rock             Paper         Scissors')</p>
<p class="calibre1">elif state == STATE_SHOW_RESULTS:</p>
<p class="calibre1">messageField.setValue('You                     Computer')</p>
<p class="calibre1"># 9 - Clear the window</p>
<p class="calibre1">window.fill(GRAY)</p>
<p class="calibre1"># 10 - Draw all window elements</p>
<p class="calibre1">messageField.draw()</p>
<p class="calibre1">if state == STATE_SPLASH: 6</p>
<p class="calibre1">rockImage.draw()</p>
<p class="calibre1">paperImage.draw()</p>
<p class="calibre1">scissorsImage.draw()</p>
<p class="calibre1">startButton.draw()</p>
<p class="calibre1"># Draw player choices</p>
<p class="calibre1">elif state == STATE_PLAYER_CHOICE: 7</p>
<p class="calibre1">rockButton.draw()</p>
<p class="calibre1"><b class="calibre3">318</b>   Chapter 15</p>
<p class="calibre1"><a id="p348"/>        paperButton.draw()</p>
<p class="calibre1">scissorButton.draw()</p>
<p class="calibre1">chooseText.draw()       </p>
<p class="calibre1"># Draw the results</p>
<p class="calibre1">elif state == STATE_SHOW_RESULTS: 8</p>
<p class="calibre1">resultsField.draw()</p>
<p class="calibre1">rpsCollectionPlayer.draw()</p>
<p class="calibre1">rpsCollectionComputer.draw()</p>
<p class="calibre1">playerScoreCounter.draw()</p>
<p class="calibre1">computerScoreCounter.draw()</p>
<p class="calibre1">restartButton.draw()</p>
<p class="calibre1"># 11 - Update the window</p>
<p class="calibre1">pygame.display.update()</p>
<p class="calibre1"># 12 - Slow things down a bit</p>
<p class="calibre1">clock.tick(FRAMES_PER_SECOND)  # make pygame wait</p>
<p class="calibre1"> <i class="calibre4">Listing 15-1: The Rock, Paper, Scissors game</i></p>
<p class="calibre1">In this listing, I have snipped the code that creates images, buttons, and </p>
<p class="calibre1">text fields for the Splash, Play, and Results scenes. The downloadable files </p>
<p class="calibre1">for the book contain the full source code and all the associated art. </p>
<p class="calibre1">Before the program goes into the main loop, we define all three states 1, </p>
<p class="calibre1">instantiate and load all the screen elements, and set the starting state 2. </p>
<p class="calibre1">We do different event checks depending on which state the program is </p>
<p class="calibre1">in. In the Splash state, we only check for clicking the Start button 3. In the </p>
<p class="calibre1">Play state, we check for a click on the Rock, Paper, or Scissors icon buttons 4. </p>
<p class="calibre1">In the Results state, we only check for a click on the Restart button 5. </p>
<p class="calibre1">Pressing a button or making a selection in one scene changes the value </p>
<p class="calibre1">of the state variable and therefore moves the game into a different scene. </p>
<p class="calibre1">At the bottom of the main loop 6 7 8, we draw different screen elements </p>
<p class="calibre1">depending on which state the program is currently in. </p>
<p class="calibre1">This technique works well for a small number of states/scenes. However, </p>
<p class="calibre1">in a program with more complicated rules or one that has many scenes and/</p>
<p class="calibre1">or states, keeping track of what should be done where can become very dif-</p>
<p class="calibre1">ficult. Instead, we can take advantage of many of the object-oriented pro-</p>
<p class="calibre1">gramming techniques introduced earlier in this book and build a different </p>
<p class="calibre1">architecture based on independent scenes, all controlled by an object man-</p>
<p class="calibre1">ager object. </p>
<p class="calibre1"><b class="calibre3">A Scene Manager for Managing Many Scenes</b></p>
<p class="calibre1">The second approach to building a program with multiple scenes is to use </p>
<p class="calibre1">a  <i class="calibre4">scene manager</i>: an object that centralizes the handling of different scenes. </p>
<p class="calibre1">We’ll create a SceneMgr class and instantiate a single oSceneMgr object from </p>
<p class="calibre1">it. In the following discussion, I’ll refer to the oSceneMgr object as the scene </p>
<p class="calibre1">manager, since we only instantiate one. As you’ll see, the scene manager </p>
<p class="calibre1">and the related scenes take advantage of encapsulation, inheritance, and </p>
<p class="calibre1">polymorphism. </p>
<p class="calibre1">Scenes   <b class="calibre3">319</b></p>
<p class="calibre1"><a id="p349"/><img src="index-349_1.png" alt="Image 43" class="calibre2"/></p>
<p class="calibre1">Using the scene manager can be a little tricky, but the resulting pro-</p>
<p class="calibre1">gram architecture results in a highly modular, easy-to-modify program. A </p>
<p class="calibre1">program that uses the scene manager will be made up of the following files:  </p>
<p class="calibre1"><b class="calibre3">Main program      </b>The small main program (that you write) must first </p>
<p class="calibre1">create an instance of every scene identified in your program, then cre-</p>
<p class="calibre1">ate an instance of the scene manager, passing a list of the scenes and </p>
<p class="calibre1">a frame rate. To start your program, you call the run() method of the </p>
<p class="calibre1">scene manager. For each new project you build, you must write a new </p>
<p class="calibre1">main program. </p>
<p class="calibre1"><b class="calibre3">Scene manager      </b>The scene manager is written for you and is avail-</p>
<p class="calibre1">able as the SceneMgr class in the  <i class="calibre4">pyghelpers.py</i> file. It keeps track of all the different scenes, remembers which one is current, calls methods in the </p>
<p class="calibre1">current scene, allows for switching between scenes, and handles com-</p>
<p class="calibre1">munication between scenes. </p>
<p class="calibre1"><b class="calibre3">Scenes      </b>Your program can have as many scenes as you want or need. </p>
<p class="calibre1">Each scene is typically developed as a separate Python file. Each scene </p>
<p class="calibre1">class must inherit from the prewritten Scene base class and have a set of </p>
<p class="calibre1">methods whose names are predefined. The scene manager uses poly-</p>
<p class="calibre1">morphism to call these methods in the current scene. I have provided a </p>
<p class="calibre1">template  <i class="calibre4">ExampleScene.py</i> file to show you how to build a scene. </p>
<p class="calibre1">The code for the SceneMgr class and the code for the Scene base class live </p>
<p class="calibre1">in the pyghelpers package. The scene manager is an object manager object </p>
<p class="calibre1">that manages any number of Scene objects. </p>
<p class="calibre1"><b class="calibre3">A Demo Program Using a Scene Manager</b></p>
<p class="calibre1">As a demonstration, we’ll build a Scene Demo program that contains three </p>
<p class="calibre1">simple scenes: Scene A, Scene B, and Scene C. The idea is that from any </p>
<p class="calibre1">scene, you can click a button to get to any other scene. Figures 15-5 through </p>
<p class="calibre1">15-7 show screenshots of the three scenes. </p>
<p class="calibre1"> <i class="calibre4">Figure 15-5: What the user sees in Scene A</i></p>
<p class="calibre1">From Scene A, you can get to Scene B or Scene C. </p>
<p class="calibre1"><b class="calibre3">320</b>   Chapter 15</p>
<p class="calibre1"><a id="p350"/><img src="index-350_1.png" alt="Image 44" class="calibre2"/></p>
<p class="calibre1"><img src="index-350_2.png" alt="Image 45" class="calibre2"/></p>
<p class="calibre1"><img src="index-350_3.png" alt="Image 46" class="calibre2"/></p>
<p class="calibre1"> <i class="calibre4">Figure 15-6: What the user sees in Scene B</i></p>
<p class="calibre1">From Scene B, you can get to Scene A or Scene C. </p>
<p class="calibre1"> <i class="calibre4">Figure 15-7: What the user sees in Scene C</i></p>
<p class="calibre1">From Scene C, you can get to Scene A or Scene B. </p>
<p class="calibre1">The structure of the project folder is shown in Figure 15-8. Note that </p>
<p class="calibre1">this assumes that you have already installed the pygwidgets and pyghelpers </p>
<p class="calibre1">modules in the proper  <i class="calibre4">site-packages</i> folder. </p>
<p class="calibre1"> <i class="calibre4">Figure 15-8: The project folder showing the main program and the different scene files</i> <i class="calibre4">Main_SceneDemo.py</i> is the main program.  <i class="calibre4">Constants.py</i> contains a few </p>
<p class="calibre1">constants shared by the main program and all the scenes.  <i class="calibre4">SceneA.py</i>,  <i class="calibre4">SceneB.py</i>, and  <i class="calibre4">SceneC.py</i> are the actual scenes, each containing a related scene class. </p>
<p class="calibre1"> <i class="calibre4">SceneExample.py</i> is a sample file that shows what a typical scene file might Scenes   <b class="calibre3">321</b></p>
<p class="calibre1"><a id="p351"/>look like. It’s not used in this program, but you can refer to it to get an understanding of the basics of writing a typical scene. </p>
<p class="calibre1">Figure 15-9 shows how the objects in the program relate to each other. </p>
<p class="calibre1"><b class="calibre3">Main</b></p>
<p class="calibre1"> <i class="calibre4">(Instantiates all scenes</i></p>
<p class="calibre1"> <i class="calibre4">and the scene manager)</i></p>
<p class="calibre1"> <i class="calibre4">Starts the</i></p>
<p class="calibre1"> <i class="calibre4">scene manager</i></p>
<p class="calibre1"><b class="calibre3">Scene manager</b></p>
<p class="calibre1"> <i class="calibre4">(Manages navigation and</i></p>
<p class="calibre1"> <i class="calibre4">communication between scenes)</i></p>
<p class="calibre1">Scene 1</p>
<p class="calibre1">Scene 2</p>
<p class="calibre1">Scene 3</p>
<p class="calibre1">…</p>
<p class="calibre1">Scene N</p>
<p class="calibre1"> <i class="calibre4">All scenes inherit from the Scene base class</i></p>
<p class="calibre1"> <i class="calibre4">Figure 15-9: The hierarchy of objects in a project</i></p>
<p class="calibre1">Let’s see how the different parts of a program using the scene manager </p>
<p class="calibre1">work together, starting with the main program. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">The Main Program</b></i></p>
<p class="calibre1">The main program will be unique for every project. Its purpose is to initial-</p>
<p class="calibre1">ize the pygame environment, instantiate all the scenes, create an instance </p>
<p class="calibre1">of the SceneMgr, then transfer control to the scene manager, oSceneMgr. </p>
<p class="calibre1">Listing 15-2 presents the code of the demo main program. </p>
<p class="calibre1"><b class="calibre3">File: SceneDemo/Main_SceneDemo.py</b></p>
<p class="calibre1"># Scene Demo main program with three scenes</p>
<p class="calibre1">--- snip ---</p>
<p class="calibre1"># 1 - Import packages</p>
<p class="calibre1">import pygame</p>
<p class="calibre1">1 import pyghelpers</p>
<p class="calibre1">from SceneA import *</p>
<p class="calibre1">from SceneB import *</p>
<p class="calibre1">from SceneC import *</p>
<p class="calibre1"># 2 - Define constants</p>
<p class="calibre1">2 WINDOW_WIDTH = 640</p>
<p class="calibre1">WINDOW_HEIGHT = 180</p>
<p class="calibre1">FRAMES_PER_SECOND = 30</p>
<p class="calibre1"><b class="calibre3">322</b>   Chapter 15</p>
<p class="calibre1"><a id="p352"/># 3 - Initialize the world</p>
<p class="calibre1">pygame.init()</p>
<p class="calibre1">window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))</p>
<p class="calibre1"># 4 - Load assets: image(s), sound(s), etc. </p>
<p class="calibre1"># 5 - Initialize variables</p>
<p class="calibre1"># Instantiate all scenes and store them into a list</p>
<p class="calibre1">3 scenesList = [SceneA(window), </p>
<p class="calibre1">SceneB(window), </p>
<p class="calibre1">SceneC(window)]</p>
<p class="calibre1"># Create the scene manager, passing in the scenes list and the FPS</p>
<p class="calibre1">4 oSceneMgr = pyghelpers.SceneMgr(scenesList, FRAMES_PER_SECOND)</p>
<p class="calibre1"># Tell the scene manager to start running</p>
<p class="calibre1">5 oSceneMgr.run()</p>
<p class="calibre1"> <i class="calibre4">Listing 15-2: A sample main program using the scene manager</i></p>
<p class="calibre1">The code of the main program is relatively short. We start by import-</p>
<p class="calibre1">ing pyghelpers, then all the scenes (in this case, Scene A, Scene B, and </p>
<p class="calibre1">Scene C) 1. We then define a few more constants, initialize pygame, and </p>
<p class="calibre1">create the window 2. Next, we create an instance of each scene and store </p>
<p class="calibre1">all the scenes in a list 3. After this line executes, we have an initialized </p>
<p class="calibre1">object for each scene. </p>
<p class="calibre1">We then instantiate the scene manager object (oSceneMgr) 4 from the </p>
<p class="calibre1">SceneMgr class. When we create this object, we need to pass in two values: </p>
<p class="calibre1">•  The list of scenes, so the scene manager can be aware of all the scenes. </p>
<p class="calibre1">The first scene in the list of scenes is used as the starting scene for the </p>
<p class="calibre1">program. </p>
<p class="calibre1">•  The frames per second (frame rate) that the program should maintain. </p>
<p class="calibre1">Finally, we tell the scene manager to start running by calling its run() </p>
<p class="calibre1">method 5. The scene manager always maintains a single scene as the cur-</p>
<p class="calibre1">rent scene—the one that the user sees and interacts with. </p>
<p class="calibre1">Notice that with this approach, the main program implements the ini-</p>
<p class="calibre1">tialization of a typical pygame program but does  <i class="calibre4">not</i> build the main loop. </p>
<p class="calibre1">Instead, the main loop is built into the scene manager itself. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Building the Scenes</b></i></p>
<p class="calibre1">To understand the interaction between the scene manager and any indi-</p>
<p class="calibre1">vidual scene, I’ll explain how a typical scene is built. </p>
<p class="calibre1">Each time through its loop, the scene manager calls a predefined set </p>
<p class="calibre1">of methods in the current scene that are intended to handle events, do any </p>
<p class="calibre1">per-frame actions, and draw anything that needs to be drawn in that scene. </p>
<p class="calibre1">Therefore, the code of each scene must be split up into these methods. The </p>
<p class="calibre1">approach makes use of polymorphism: each scene needs to implement a </p>
<p class="calibre1">common set of methods. </p>
<p class="calibre1">Scenes   <b class="calibre3">323</b></p>
<p class="calibre1"><a id="p353"/><b class="calibre3">Methods to Implement in Each Scene</b></p>
<p class="calibre1">Each scene is implemented as a class that inherits from the Scene base </p>
<p class="calibre1">class defined in the  <i class="calibre4">pyghelpers.py</i> file. Therefore, each scene must import </p>
<p class="calibre1">pyghelpers. At a minimum, a scene needs to contain an __init__() method </p>
<p class="calibre1">and must override the getSceneKey(), handleInputs(), and draw() methods </p>
<p class="calibre1">from the base class. </p>
<p class="calibre1">Every scene must have a unique  <i class="calibre4">scene key</i>—a string used by the scene </p>
<p class="calibre1">manager to identify each scene. I recommend that you build a file with a </p>
<p class="calibre1">name like  <i class="calibre4">Constants.py</i> that contains the keys for all the scenes and import this file into each scene file. For example, the  <i class="calibre4">Constants.py</i> file for the sample program contains:</p>
<p class="calibre1"># Scene keys (any unique values):</p>
<p class="calibre1">SCENE_A = 'scene A' </p>
<p class="calibre1">SCENE_B = 'scene B' </p>
<p class="calibre1">SCENE_C = 'scene C' </p>
<p class="calibre1">During its initialization, the scene manager calls the getSceneKey() </p>
<p class="calibre1">method of each scene, which simply returns its unique scene key. The </p>
<p class="calibre1">scene manager then builds an internal dictionary of scene keys and scene </p>
<p class="calibre1">objects. When any scene in the program wants to switch to a different </p>
<p class="calibre1">scene, it will call self.goToScene() (described in the following section) and </p>
<p class="calibre1">pass in the scene key of the target scene. The scene manager uses this key </p>
<p class="calibre1">in the dictionary to find the associated scene object; it then sets the new </p>
<p class="calibre1">scene object as the current scene and calls its methods. </p>
<p class="calibre1">Each scene must contain its own version of handleInputs() to handle any </p>
<p class="calibre1">events that would typically be handled in the main loop and its own version </p>
<p class="calibre1">of draw() to draw anything the scene wants to draw in the window. If your </p>
<p class="calibre1">scene does not override these two methods, it will not be able to respond to </p>
<p class="calibre1">any events and will not draw anything in the window. </p>
<p class="calibre1">Let’s take a closer look at the four methods you need to implement for </p>
<p class="calibre1">each scene:</p>
<p class="calibre1"><b class="calibre3">def __init__(self, window):</b></p>
<p class="calibre1">Each scene should begin with its own __init__() method. The window </p>
<p class="calibre1">parameter is the window into which your program draws. You should </p>
<p class="calibre1">start your method with this statement to save the window parameter for </p>
<p class="calibre1">use in the draw() method:</p>
<p class="calibre1">self.window = window</p>
<p class="calibre1">After that, you can include any other initialization code you want or </p>
<p class="calibre1">need, such as code for instantiating buttons and text fields, loading </p>
<p class="calibre1">images and sounds, and so on. </p>
<p class="calibre1"><b class="calibre3">def getSceneKey(self):</b></p>
<p class="calibre1">This method must be implemented in every scene that you write. Your </p>
<p class="calibre1">method must return the unique scene key associated with this scene. </p>
<p class="calibre1"><b class="calibre3">324</b>   Chapter 15</p>
<p class="calibre1"><a id="p354"/><b class="calibre3">def handleInputs(self, events, keyPressedList):</b></p>
<p class="calibre1">This method must be implemented in every scene that you write. It </p>
<p class="calibre1">should do everything needed to deal with events or keys. The events </p>
<p class="calibre1">parameter is a list of events that happened since the last frame, and </p>
<p class="calibre1">keyPressedList is a list of Booleans representing the state of all keyboard </p>
<p class="calibre1">keys (True means down). To find whether a particular key is up or down, </p>
<p class="calibre1">you should use a constant rather than an integer index. The constants </p>
<p class="calibre1">representing all keys of the keyboard are available in the pygame docu-</p>
<p class="calibre1">mentation<a href="https://www.pygame.org/docs/ref/key.html"> ( <i class="calibre4">https://www.pygame.org/docs/ref/key.html</i>). </a></p>
<p class="calibre1">Your implementation of this method should contain a for loop that </p>
<p class="calibre1">loops through all events in the list that is passed in. If you want, it can </p>
<p class="calibre1">also contain code to implement the continuous mode of handling the </p>
<p class="calibre1">keyboard, as described i<a href="index_split_002.html#p118">n Chapter 5. </a></p>
<p class="calibre1"><b class="calibre3">def draw(self):</b></p>
<p class="calibre1">This method must be implemented in every scene that you write. It </p>
<p class="calibre1">should draw everything that needs to be drawn in the current scene. </p>
<p class="calibre1">The scene manager also calls the following methods in each scene. In </p>
<p class="calibre1">the Scene base class, these methods each contain a simple pass statement, so </p>
<p class="calibre1">they don’t do anything. You can override any or all of them to execute any </p>
<p class="calibre1">code you want for a particular scene: </p>
<p class="calibre1"><b class="calibre3">def enter(self, data):</b></p>
<p class="calibre1">This method is called after the scene manager has made the transi-</p>
<p class="calibre1">tion into this scene. There is a single data parameter, with None as a </p>
<p class="calibre1">default. If data is not None, then the information it contains was sent </p>
<p class="calibre1">from the previous scene when it called goToScene() (described in the </p>
<p class="calibre1">next section). The value of data can take any form—from a single </p>
<p class="calibre1">string or numeric value to a list or dictionary to an object—as long </p>
<p class="calibre1">as the leaving scene and the entering scene agree on the type of data </p>
<p class="calibre1">being passed. The enter() method should do whatever it needs to do </p>
<p class="calibre1">when this scene is about to be given control. </p>
<p class="calibre1"><b class="calibre3">def update(self):</b></p>
<p class="calibre1">This method is called in every frame. Here, you can perform any </p>
<p class="calibre1">actions you would have done in step 8 of the original 12-step template </p>
<p class="calibre1">introduced in <a href="index_split_002.html#p118">Chapter 5. F</a>or example, you might want this method to move images on the screen, check for collisions, and so on. </p>
<p class="calibre1"><b class="calibre3">def leave(self):</b></p>
<p class="calibre1">This method is called by the scene manager whenever the program </p>
<p class="calibre1">is about to transition to a different scene. It should do any cleanup </p>
<p class="calibre1">that needs to be done before leaving, such as writing information to </p>
<p class="calibre1">a file. </p>
<p class="calibre1">Scenes   <b class="calibre3">325</b></p>
<p class="calibre1"><a id="p355"/><b class="calibre3">Navigating Between Scenes</b></p>
<p class="calibre1">The scene manager and the Scene base class provide a simple way to navi-</p>
<p class="calibre1">gate between scenes. When the program wants to transition to another </p>
<p class="calibre1">scene, the current scene should call its own goToScene() method, which is in </p>
<p class="calibre1">the inherited Scene base class, like this:</p>
<p class="calibre1">self.goToScene(nextSceneKey, data)  </p>
<p class="calibre1">The goToScene() method communicates to the scene manager that you </p>
<p class="calibre1">want to transition to a different scene, whose scene key is nextSceneKey. You </p>
<p class="calibre1">should make all scene keys available via a file such as  <i class="calibre4">Constants.py</i>. The data parameter is any optional information that you want to pass on to the next </p>
<p class="calibre1">scene. If no data needs to be transferred, you can eliminate this argument. </p>
<p class="calibre1">Typical calls would look like this:</p>
<p class="calibre1">self.goToScene( <i class="calibre4">SOME_SCENE_KEY</i>)  # no data to be passed</p>
<p class="calibre1"># Or</p>
<p class="calibre1">self.goToScene( <i class="calibre4">ANOTHER_SCENE_KEY</i>, data= <i class="calibre4">someValueOrValues</i>)  # go to a scene and pass data The value of data can take any form, as long as the scenes being left and </p>
<p class="calibre1">entered both understand the format. In response to this call, before leav-</p>
<p class="calibre1">ing the current scene, the scene manager calls that scene’s leave() method. </p>
<p class="calibre1">When the next scene is about to be activated, the scene manager calls that </p>
<p class="calibre1">scene’s enter() method and passes the value of data to the new scene. </p>
<p class="calibre1"><b class="calibre3">Quitting the Program</b></p>
<p class="calibre1">The scene manager takes care of three different ways that the user can quit </p>
<p class="calibre1">the currently running program:</p>
<p class="calibre1">•  By clicking the close button at the top of the window. </p>
<p class="calibre1">•  By pressing the ESCAPE key. </p>
<p class="calibre1">•  Through any additional mechanism such as a Quit button. In this case, </p>
<p class="calibre1">make the following call (which is also built into the Scene base class):</p>
<p class="calibre1">self.quit()  # quits the program </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">A Typical Scene</b></i></p>
<p class="calibre1">Listing 15-3 shows an example of a typical scene—this is the  <i class="calibre4">SceneA.py</i> file that implements Scene A in the demo program, shown in Figure 15-5. Remember </p>
<p class="calibre1">that the main loop is implemented by the scene manager. Inside its main loop, </p>
<p class="calibre1">the scene manager calls the handleInputs(), update(), and draw() methods for </p>
<p class="calibre1">the current scene. </p>
<p class="calibre1"><b class="calibre3">326</b>   Chapter 15</p>
<p class="calibre1"><a id="p356"/><b class="calibre3">File: SceneDemo/SceneA.py</b></p>
<p class="calibre1"># Scene A</p>
<p class="calibre1">import pygwidgets</p>
<p class="calibre1">import pyghelpers</p>
<p class="calibre1">import pygame</p>
<p class="calibre1">from pygame.locals import *</p>
<p class="calibre1">from Constants import *</p>
<p class="calibre1">class SceneA(pyghelpers.Scene):</p>
<p class="calibre1">1 def __init__(self, window):</p>
<p class="calibre1">self.window = window</p>
<p class="calibre1">self.messageField = pygwidgets.DisplayText(self.window, </p>
<p class="calibre1">(15, 25), 'This is Scene A', fontSize=50, </p>
<p class="calibre1">textColor=WHITE, width=610, justified='center')</p>
<p class="calibre1">self.gotoAButton = pygwidgets.TextButton(self.window, </p>
<p class="calibre1">(250, 100), 'Go to Scene A')</p>
<p class="calibre1">self.gotoBButton = pygwidgets.TextButton(self.window, </p>
<p class="calibre1">(250, 100), 'Go to Scene B')</p>
<p class="calibre1">self.gotoCButton = pygwidgets.TextButton(self.window, </p>
<p class="calibre1">(400, 100), 'Go to Scene C')</p>
<p class="calibre1">self.gotoAButton.disable()</p>
<p class="calibre1">2 def getSceneKey(self):</p>
<p class="calibre1">return SCENE_A</p>
<p class="calibre1">3 def handleInputs(self, eventsList, keyPressedList):</p>
<p class="calibre1">for event in eventsList:</p>
<p class="calibre1">if self.gotoBButton.handleEvent(event):</p>
<p class="calibre1">4 self.goToScene(SCENE_B)</p>
<p class="calibre1">if self.gotoCButton.handleEvent(event):</p>
<p class="calibre1">5 self.goToScene(SCENE_C)</p>
<p class="calibre1">--- snip (testing code to send messages) ---</p>
<p class="calibre1">6 def draw(self):</p>
<p class="calibre1">self.window.fill(GRAYA)</p>
<p class="calibre1">self.messageField.draw()</p>
<p class="calibre1">self.gotoAButton.draw()</p>
<p class="calibre1">self.gotoBButton.draw()</p>
<p class="calibre1">self.gotoCButton.draw()</p>
<p class="calibre1">--- snip (testing code to respond to messages) ---</p>
<p class="calibre1"> <i class="calibre4">Listing 15-3: A typical scene (Scene A in the Scene Demo program)</i></p>
<p class="calibre1">Scenes   <b class="calibre3">327</b></p>
<p class="calibre1"><a id="p357"/>In the __init__() method 1, we save away the window parameter in an instance variable. We then create an instance of a DisplayText field to show a </p>
<p class="calibre1">title and create some TextButtons to allow for navigation to the other scenes. </p>
<p class="calibre1">The getSceneKey() method 2 just returns the unique scene key (found </p>
<p class="calibre1">in  <i class="calibre4">Constants.py</i>) for this scene. In the handleInputs() method 3, if the user has clicked the button for a different scene, we call the self.goToScene() </p>
<p class="calibre1">navigation method 4 5 to transfer control to the new scene. In the draw() </p>
<p class="calibre1">method 6, we fill the background, draw the message field, and draw the </p>
<p class="calibre1">buttons. This example scene does very little, so we don’t need to write our </p>
<p class="calibre1">own enter(), update(), and leave() methods. Calls to these methods will be </p>
<p class="calibre1">handled by methods of the same names in the Scene base class, and those </p>
<p class="calibre1">methods don’t do anything—they simply execute a pass statement. </p>
<p class="calibre1">The two other scene files are  <i class="calibre4">SceneB.py</i> and  <i class="calibre4">SceneC.py</i>. The only differences are the titles shown, the buttons drawn, and the effects of clicking the </p>
<p class="calibre1">buttons to transfer to the appropriate new scene. </p>
<p class="calibre1"><b class="calibre3">Rock, Paper, Scissors Using Scenes</b></p>
<p class="calibre1">Let’s build an alternate implementation of the Rock, Paper, Scissors game </p>
<p class="calibre1">using the scene manager. To the user, the game will work exactly the same </p>
<p class="calibre1">way as the earlier state machine version. We’ll build a Splash scene, a Play </p>
<p class="calibre1">scene, and a Results scene. </p>
<p class="calibre1">All of the source code is available, so I won’t go through every Python </p>
<p class="calibre1">file. The Splash scene is just a background picture with a Start button. When </p>
<p class="calibre1">the user presses the Start button, the code executes goToScene(SCENE_PLAY) to </p>
<p class="calibre1">transfer to the Play scene. In the Play scene, the user is presented with a set </p>
<p class="calibre1">of images (rock, paper, and scissors) and asked to choose one. Clicking an </p>
<p class="calibre1">image transfers control to the Results scene. Listing 15-4 contains the code </p>
<p class="calibre1">of the Play scene. </p>
<p class="calibre1"><b class="calibre3">File: RockPaperScissorsWithScenes/ScenePlay.py</b></p>
<p class="calibre1"># The Play scene</p>
<p class="calibre1"># The player chooses among rock, paper, or scissors</p>
<p class="calibre1">import pygwidgets</p>
<p class="calibre1">import pyghelpers</p>
<p class="calibre1">import pygame</p>
<p class="calibre1">from Constants import *</p>
<p class="calibre1">import random</p>
<p class="calibre1">class ScenePlay(pyghelpers.Scene):</p>
<p class="calibre1">def __init__(self, window):</p>
<p class="calibre1">self.window = window</p>
<p class="calibre1">self.RPSTuple = (ROCK, PAPER, SCISSORS)</p>
<p class="calibre1"><b class="calibre3">328</b>   Chapter 15</p>
<p class="calibre1"><a id="p358"/>        --- snip ---</p>
<p class="calibre1">def getSceneKey(self): 1</p>
<p class="calibre1">return SCENE_PLAY</p>
<p class="calibre1">def handleInputs(self, eventsList, keyPressedList): 2</p>
<p class="calibre1">playerChoice = None</p>
<p class="calibre1">for event in eventsList:</p>
<p class="calibre1">if self.rockButton.handleEvent(event):</p>
<p class="calibre1">playerChoice = ROCK</p>
<p class="calibre1">if self.paperButton.handleEvent(event):</p>
<p class="calibre1">playerChoice = PAPER</p>
<p class="calibre1">if self.scissorButton.handleEvent(event):</p>
<p class="calibre1">playerChoice = SCISSORS</p>
<p class="calibre1">if playerChoice is not None: 3  # user has made a choice</p>
<p class="calibre1">computerChoice = random.choice(self.RPSTuple)  # computer chooses</p>
<p class="calibre1">dataDict = {'player': playerChoice, 'computer': computerChoice} 4</p>
<p class="calibre1">self.goToScene(SCENE_RESULTS, dataDict) 5  # go to Results scene</p>
<p class="calibre1"># No need to include update method, defaults to inherited one which does nothing</p>
<p class="calibre1">def draw(self):</p>
<p class="calibre1">self.window.fill(GRAY)</p>
<p class="calibre1">self.titleField.draw()</p>
<p class="calibre1">self.rockButton.draw()</p>
<p class="calibre1">self.paperButton.draw()</p>
<p class="calibre1">self.scissorButton.draw()</p>
<p class="calibre1">self.messageField.draw()</p>
<p class="calibre1"> <i class="calibre4">Listing 15-4: The Play scene in Rock, Paper, Scissors</i></p>
<p class="calibre1">I’ve snipped the code to create text fields and the rock, paper, and scis-</p>
<p class="calibre1">sors buttons. The getSceneKey() method 1 simply returns the scene key for </p>
<p class="calibre1">this scene. </p>
<p class="calibre1">The most important method is handleInputs() 2, which is called in every </p>
<p class="calibre1">frame. If any button is clicked, we set a variable named playerChoice to an </p>
<p class="calibre1">appropriate constant 3, and we make a random choice for the computer. </p>
<p class="calibre1">We then take the player’s choice and the computer’s choice and build a </p>
<p class="calibre1">simple dictionary 4 incorporating both, so we can pass this information </p>
<p class="calibre1">as data to the Results scene. Finally, to transfer to the Results scene, we call </p>
<p class="calibre1">goToScene() and pass the dictionary 5. </p>
<p class="calibre1">The scene manager receives this call, calls leave() for the current scene </p>
<p class="calibre1">(Play), changes the current scene to the new scene (Results), and calls enter() </p>
<p class="calibre1">for the new scene (Results). It passes the data from the leaving scene into the </p>
<p class="calibre1">enter() method of the new scene. </p>
<p class="calibre1">Listing 15-5 contains the code of the Results scene. There’s a lot of code </p>
<p class="calibre1">here, but most of it deals with showing the appropriate icons and the evalu-</p>
<p class="calibre1">ation of the results of the round. </p>
<p class="calibre1">Scenes   <b class="calibre3">329</b></p>
<p class="calibre1"><a id="p359"/><b class="calibre3">File: RockPaperScissorsWithScenes/SceneResults.py</b></p>
<p class="calibre1"># The Results scene</p>
<p class="calibre1"># The player is shown the results of the current round</p>
<p class="calibre1">import pygwidgets</p>
<p class="calibre1">import pyghelpers</p>
<p class="calibre1">import pygame</p>
<p class="calibre1">from Constants import *</p>
<p class="calibre1">class SceneResults(pyghelpers.Scene):</p>
<p class="calibre1">def __init__(self, window, sceneKey):</p>
<p class="calibre1">self.window = window</p>
<p class="calibre1">self.playerScore = 0</p>
<p class="calibre1">self.computerScore = 0</p>
<p class="calibre1">1 self.rpsCollectionPlayer = pygwidgets.ImageCollection(</p>
<p class="calibre1">window, (50, 62), </p>
<p class="calibre1">{ROCK: 'images/Rock.png', </p>
<p class="calibre1">PAPER: 'images/Paper.png', </p>
<p class="calibre1">SCISSORS: 'images/Scissors.png'}, '')</p>
<p class="calibre1">self.rpsCollectionComputer = pygwidgets.ImageCollection(</p>
<p class="calibre1">window, (350, 62), </p>
<p class="calibre1">{ROCK: 'images/Rock.png', </p>
<p class="calibre1">PAPER: 'images/Paper.png', </p>
<p class="calibre1">SCISSORS: 'images/Scissors.png'}, '')</p>
<p class="calibre1">self.youComputerField = pygwidgets.DisplayText(</p>
<p class="calibre1">window, (22, 25), </p>
<p class="calibre1">'You                     Computer', </p>
<p class="calibre1">fontSize=50, textColor=WHITE, </p>
<p class="calibre1">width=610, justified='center')</p>
<p class="calibre1">self.resultsField = pygwidgets.DisplayText(</p>
<p class="calibre1">self.window, (20, 275), '', </p>
<p class="calibre1">fontSize=50, textColor=WHITE, </p>
<p class="calibre1">width=610, justified='center')</p>
<p class="calibre1">self.restartButton = pygwidgets.CustomButton(</p>
<p class="calibre1">self.window, (220, 310), </p>
<p class="calibre1">up='images/restartButtonUp.png', </p>
<p class="calibre1">down='images/restartButtonDown.png' </p>
<p class="calibre1">over='images/restartButtonHighlight.png')</p>
<p class="calibre1">self.playerScoreCounter = pygwidgets.DisplayText(</p>
<p class="calibre1">self.window, (86, 315), 'Score:', </p>
<p class="calibre1">fontSize=50, textColor=WHITE)</p>
<p class="calibre1">self.computerScoreCounter = pygwidgets.DisplayText(</p>
<p class="calibre1">self.window, (384, 315), 'Score:', </p>
<p class="calibre1">fontSize=50, textColor=WHITE)</p>
<p class="calibre1"><b class="calibre3">330</b>   Chapter 15</p>
<p class="calibre1"><a id="p360"/>        # Sounds</p>
<p class="calibre1">self.winnerSound = pygame.mixer.Sound("sounds/ding.wav")</p>
<p class="calibre1">self.tieSound = pygame.mixer.Sound("sounds/push.wav")</p>
<p class="calibre1">self.loserSound = pygame.mixer.Sound("sounds/buzz.wav")</p>
<p class="calibre1">2 def enter(self, data):</p>
<p class="calibre1"># data is a dictionary (comes from the Play scene) that looks like:</p>
<p class="calibre1">#      {'player': playerChoice, 'computer': computerChoice}</p>
<p class="calibre1">playerChoice = data['player']</p>
<p class="calibre1">computerChoice = data['computer']</p>
<p class="calibre1"># Set the player and computer images</p>
<p class="calibre1">3 self.rpsCollectionPlayer.replace(playerChoice)</p>
<p class="calibre1">self.rpsCollectionComputer.replace(computerChoice)</p>
<p class="calibre1"># Evaluate the game's win/lose/tie conditions</p>
<p class="calibre1">4 if playerChoice == computerChoice:</p>
<p class="calibre1">self.resultsField.setValue("It's a tie!")</p>
<p class="calibre1">self.tieSound.play()</p>
<p class="calibre1">elif playerChoice == ROCK and computerChoice == SCISSORS:</p>
<p class="calibre1">self.resultsField.setValue("Rock breaks Scissors. You win!")</p>
<p class="calibre1">self.playerScore = self.playerScore + 1</p>
<p class="calibre1">self.winnerSound.play()</p>
<p class="calibre1">--- snip ---</p>
<p class="calibre1"># Show the player's and computer's scores</p>
<p class="calibre1">self.playerScoreCounter.setValue(</p>
<p class="calibre1">'Score: ' + str(self.playerScore))</p>
<p class="calibre1">self.computerScoreCounter.setValue(</p>
<p class="calibre1">'Score: ' + str(self.computerScore))</p>
<p class="calibre1">5 def handleInputs(self, eventsList, keyPressedList):</p>
<p class="calibre1">for event in eventsList:</p>
<p class="calibre1">if self.restartButton.handleEvent(event):</p>
<p class="calibre1">self.goToScene(SCENE_PLAY)</p>
<p class="calibre1"># No need to include update method, </p>
<p class="calibre1"># defaults to inherited one which does nothing</p>
<p class="calibre1">6 def draw(self):</p>
<p class="calibre1">self.window.fill(OTHER_GRAY)</p>
<p class="calibre1">self.youComputerField.draw()</p>
<p class="calibre1">self.resultsField.draw()</p>
<p class="calibre1">self.rpsCollectionPlayer.draw()</p>
<p class="calibre1">self.rpsCollectionComputer.draw()</p>
<p class="calibre1">self.playerScoreCounter.draw()</p>
<p class="calibre1">self.computerScoreCounter.draw()</p>
<p class="calibre1">self.restartButton.draw()</p>
<p class="calibre1"> <i class="calibre4">Listing 15-5: The Results scene in Rock, Paper, Scissors</i></p>
<p class="calibre1">Scenes   <b class="calibre3">331</b></p>
<p class="calibre1"><a id="p361"/>Here, I’ve snipped some of the game evaluation logic. The enter() </p>
<p class="calibre1">method 2 is the most important method in this class. When the player </p>
<p class="calibre1">makes a choice in the previous Play scene, the program transitions to this </p>
<p class="calibre1">Results scene. First, we extract the player’s and computer’s choices that were </p>
<p class="calibre1">passed in from the Play scene as a dictionary, which looks like this:  </p>
<p class="calibre1">{'player': playerChoice, 'computer': computerChoice}</p>
<p class="calibre1">In the __init__() method 1, we create ImageCollection objects for the </p>
<p class="calibre1">player and computer, each containing the rock, paper, and scissors images. </p>
<p class="calibre1">In the enter() method 2, we use the replace() method of ImageCollection 3 </p>
<p class="calibre1">to show the images that represent the player’s and the computer’s choices. </p>
<p class="calibre1">Then, the evaluation is quite simple 4. If the computer and the player </p>
<p class="calibre1">made the same choice, we have a tie, and we play an appropriate tie sound. </p>
<p class="calibre1">If the player wins, we increment the player’s score and play a happy sound. </p>
<p class="calibre1">If the computer wins, we increment the computer’s score and play a sad </p>
<p class="calibre1">sound. We update the player’s or the computer’s score and show the scores </p>
<p class="calibre1">in the matching text display fields. </p>
<p class="calibre1">After the enter() method runs (one time for each round), the </p>
<p class="calibre1">handleInputs() method 5 is called in every frame by the scene manager. </p>
<p class="calibre1">When the user clicks Restart, we call the inherited goToScene() method </p>
<p class="calibre1">to transfer back to the Play scene. </p>
<p class="calibre1">The draw() method 6 draws everything in the window for this scene. </p>
<p class="calibre1">In this scene, we don’t do any additional work in each frame, so we don’t </p>
<p class="calibre1">need to write an update() method. When the scene manager calls update(), </p>
<p class="calibre1">the inherited method in the Scene base class runs and just executes a pass </p>
<p class="calibre1">statement. </p>
<p class="calibre1"><b class="calibre3">Communication Between Scenes</b></p>
<p class="calibre1">The scene manager provides a set of methods that allow scenes to com-</p>
<p class="calibre1">municate with each other by sending or requesting information. This com-</p>
<p class="calibre1">munication won’t be needed by all programs but can be highly useful. The </p>
<p class="calibre1">scene manager allows any scene to:</p>
<p class="calibre1">•  Request information from another scene</p>
<p class="calibre1">•  Send information to another scene</p>
<p class="calibre1">•  Send information to all other scenes</p>
<p class="calibre1">In the following sections, I’ll call the scene the user is seeing the  <i class="calibre4">cur-</i></p>
<p class="calibre1"> <i class="calibre4">rent</i> scene. The scene that the current scene is sending information to or </p>
<p class="calibre1">requesting information from is the  <i class="calibre4">target</i> scene. The methods used to trans-</p>
<p class="calibre1">fer information are all implemented in the Scene base class. Therefore, all </p>
<p class="calibre1">scenes (which must inherit from the Scene base class) have access to these </p>
<p class="calibre1">methods using self.  <i class="calibre4">&lt;method&gt; </i>(). </p>
<p class="calibre1"><b class="calibre3">332</b>   Chapter 15</p>
<p class="calibre1"><a id="p362"/> <i class="calibre4"><b class="calibre3">Requesting Information from a Target Scene</b></i></p>
<p class="calibre1">To request information from any other scene, a scene makes a call to the </p>
<p class="calibre1">inherited request() method, like this:</p>
<p class="calibre1">self.request(targetSceneKey, requestID)</p>
<p class="calibre1">This call allows the current scene to ask for information from a target </p>
<p class="calibre1">scene, identified by its scene key (targetSceneKey). The requestID uniquely </p>
<p class="calibre1">identifies the information you are asking for. The value used for a requestID </p>
<p class="calibre1">would normally be a constant defined in a file like  <i class="calibre4">Constants.py</i>. The call </p>
<p class="calibre1">returns the requested information. A typical call would look like this: </p>
<p class="calibre1">someData = self.request( <i class="calibre4">SOME_SCENE_KEY</i>,  <i class="calibre4">SOME_INFO_CONSTANT</i>)</p>
<p class="calibre1">This effectively says, “Issue a request to the  <i class="calibre4">SOME_SCENE_KEY</i> scene asking </p>
<p class="calibre1">for information identified by  <i class="calibre4">SOME_INFO_CONSTANT</i>.” The data is returned and assigned to the someData variable. </p>
<p class="calibre1">The scene manager acts as an intermediary: it receives the call to </p>
<p class="calibre1">request() and turns it into a call to respond() in the target scene. To make </p>
<p class="calibre1">a target scene able to give information, you must implement a respond() </p>
<p class="calibre1">method in that scene’s class. The method should start like this:</p>
<p class="calibre1">def respond(self, requestID):</p>
<p class="calibre1">The typical code of a respond() method checks the value of the requestID </p>
<p class="calibre1">parameter and returns the appropriate data. The data returned can be for-</p>
<p class="calibre1">matted in any way that the current scene and the target scene agree on. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Sending Information to a Target Scene</b></i></p>
<p class="calibre1">To send information to a target scene, the current scene makes a call to the </p>
<p class="calibre1">inherited send() method, like this: </p>
<p class="calibre1">self.send(targetSceneKey, sendID, info)</p>
<p class="calibre1">This call allows the current scene to send information to a target scene, </p>
<p class="calibre1">identified by its scene key (targetSceneKey). The sendID uniquely identifies the </p>
<p class="calibre1">information you are sending. The info parameter is the information you </p>
<p class="calibre1">want to send to the target scene. </p>
<p class="calibre1">A typical call would look like this: </p>
<p class="calibre1">self.send( <i class="calibre4">SOME_SCENE_KEY</i>,  <i class="calibre4">SOME_INFO_CONSTANT</i>, data)</p>
<p class="calibre1">This effectively says, “Send information to the  <i class="calibre4">SOME_SCENE_KEY</i> scene. The </p>
<p class="calibre1">information is identified by  <i class="calibre4">SOME_INFO_CONSTANT</i>, and the information is in the value of the variable data.” </p>
<p class="calibre1">The scene manager receives the call to send() and turns it into a call </p>
<p class="calibre1">to receive() in the target scene. To allow a scene to send information to </p>
<p class="calibre1">Scenes   <b class="calibre3">333</b></p>
<p class="calibre1"><a id="p363"/>another scene, you must implement a receive() method in your target scene class, like this:</p>
<p class="calibre1">def receive(self, receiveID, info):</p>
<p class="calibre1">The receive() method can contain an if/elif/else construct if it needs </p>
<p class="calibre1">to handle different values for receiveID. The transmitted information can be </p>
<p class="calibre1">formatted in any way that the current scene and the target scene agree on. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Sending Information to All Scenes</b></i></p>
<p class="calibre1">As an additional convenience, a scene can send information to all other </p>
<p class="calibre1">scenes using the single method sendAll():</p>
<p class="calibre1">self.sendAll(sendID, info)</p>
<p class="calibre1">This call allows the current scene to send information to all the other </p>
<p class="calibre1">scenes. The sendID uniquely identifies the information you are sending. The </p>
<p class="calibre1">info parameter is the information you want to send to all scenes. </p>
<p class="calibre1">A typical call would look like this: </p>
<p class="calibre1">self.sendAll( <i class="calibre4">SOME_INFO_CONSTANT</i>, data)</p>
<p class="calibre1">This effectively says, “Send information to all scenes. The information </p>
<p class="calibre1">is identified by  <i class="calibre4">SOME_INFO_CONSTANT</i>, and the information is in the value of the variable data.” </p>
<p class="calibre1">For this to work, all scenes other than the current scene must implement </p>
<p class="calibre1">the receive() method, as described in the previous section. The scene manager </p>
<p class="calibre1">sends the message to all scenes (other than the current scene). The current </p>
<p class="calibre1">scene may contain a receive() method for information sent by other scenes. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Testing Communications Among Scenes</b></i></p>
<p class="calibre1">The Scene Demo program (with Scene A, Scene B, and Scene C), discussed </p>
<p class="calibre1">earlier with Listings 15-2 and 15-3, contains code in each scene that demon-</p>
<p class="calibre1">strates calls to send(), request(), and sendAll(). In addition, the scenes each </p>
<p class="calibre1">implement simple versions of the receive() and respond() methods. In the demo </p>
<p class="calibre1">program, you can send a message to another scene by pressing A, B, or C. </p>
<p class="calibre1">Pressing X sends a message to all scenes. Pressing 1, 2, or 3 sends a request </p>
<p class="calibre1">to get data from a target scene. The target scene responds with a string. </p>
<p class="calibre1"><b class="calibre3">Implementation of the Scene Manager</b></p>
<p class="calibre1">Here we’ll look at how the scene manager is implemented. However, one </p>
<p class="calibre1">important lesson of OOP is that the developer of client code doesn’t need to </p>
<p class="calibre1">understand the implementation of a class, only the interface. With respect to </p>
<p class="calibre1">the scene manager, you don’t need to know how it works, only what methods </p>
<p class="calibre1">you must implement in your scenes, when they are called, and what methods </p>
<p class="calibre1">you can call. Therefore, if you’re not interested in the internals, you can go </p>
<p class="calibre1">right to the Summary. If you are interested, this section goes through the </p>
<p class="calibre1"><b class="calibre3">334</b>   Chapter 15</p>
<p class="calibre1"><a id="p364"/>implementation details, and along the way you’ll learn an interesting technique to allow for two-way communication between objects. </p>
<p class="calibre1">The scene manager is implemented in a class named SceneMgr in the </p>
<p class="calibre1">pyghelpers module. As explained previously, in your main program, you cre-</p>
<p class="calibre1">ate a single instance of the scene manager like this:</p>
<p class="calibre1">oSceneMgr = SceneMgr(scenesList, FRAMES_PER_SECOND) </p>
<p class="calibre1">The last line of your main program needs to be:</p>
<p class="calibre1">oSceneMgr.run()</p>
<p class="calibre1">Listing 15-6 contains the code of the __init__() method of the SceneMgr </p>
<p class="calibre1">class. </p>
<p class="calibre1">--- snip ---</p>
<p class="calibre1">def __init__(self, scenesList, fps):</p>
<p class="calibre1"/>
<p class="calibre1"># Build a dictionary, each entry of which is a sceneKey : scene object</p>
<p class="calibre1">1 self.scenesDict = {}</p>
<p class="calibre1">2 for oScene in scenesList:</p>
<p class="calibre1">key = oScene.getSceneKey()</p>
<p class="calibre1">self.scenesDict[key] = oScene</p>
<p class="calibre1"># The first element in the list is used as the starting scene</p>
<p class="calibre1">3 self.oCurrentScene = scenesList[0]</p>
<p class="calibre1">self.framesPerSecond = fps</p>
<p class="calibre1"># Give each scene a reference back to the SceneMgr. </p>
<p class="calibre1"># This allows any scene to do a goToScene, request, send, </p>
<p class="calibre1"># or sendAll, which gets forwarded to the scene manager. </p>
<p class="calibre1">4 for key, oScene in self.scenesDict.items():</p>
<p class="calibre1">oScene._setRefToSceneMgr(self)</p>
<p class="calibre1"> <i class="calibre4">Listing 15-6: The __init__() method of the SceneMgr class</i></p>
<p class="calibre1">The __init__() method keeps track of all scenes in a dictionary 1. It </p>
<p class="calibre1">iterates through the list of scenes, asking each scene for its scene key, and </p>
<p class="calibre1">builds a dictionary 2. The first scene object in the list of scenes is used as </p>
<p class="calibre1">the starting scene 3. </p>
<p class="calibre1">The last part of the __init__() method does some interesting work. The </p>
<p class="calibre1">scene manager holds a reference to every scene, so it can send messages to </p>
<p class="calibre1">any and every scene. But every scene also needs to be able to send messages </p>
<p class="calibre1">to the scene manager. To allow each scene to do that, the last for loop in </p>
<p class="calibre1">the __init__() method calls the special method _setRefToSceneMgr() 4 that </p>
<p class="calibre1">lives in the base class of every scene, and it passes self, which is a reference </p>
<p class="calibre1">to the scene manager. The entire code of this method consists of a single line:</p>
<p class="calibre1">def _setRefToSceneMgr(self, oSceneMgr):</p>
<p class="calibre1">--- snip ---</p>
<p class="calibre1">self.oSceneMgr = oSceneMgr </p>
<p class="calibre1">Scenes   <b class="calibre3">335</b></p>
<p class="calibre1"><a id="p365"/>This method just stores this reference back to the scene manager in an instance variable, self.oSceneMgr. Each scene can use this variable to make </p>
<p class="calibre1">calls to the scene manager. I’ll show how scenes use this a little later in this </p>
<p class="calibre1">section. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">run() Method</b></i></p>
<p class="calibre1">For every project you build, you have to write a small main program that </p>
<p class="calibre1">instantiates the scene manager. The last step in your main program is a call </p>
<p class="calibre1">to the run() method of the scene manager. This is where the main loop of </p>
<p class="calibre1">the whole program lives. Listing 15-7 contains the code of that method. </p>
<p class="calibre1">def run(self):</p>
<p class="calibre1">--- snip ---</p>
<p class="calibre1">clock = pygame.time.Clock()</p>
<p class="calibre1"># 6 - Loop forever</p>
<p class="calibre1">while True:</p>
<p class="calibre1">1 keysDownList = pygame.key.get_pressed()</p>
<p class="calibre1"># 7 - Check for and handle events</p>
<p class="calibre1">2 eventsList = []</p>
<p class="calibre1">for event in pygame.event.get():</p>
<p class="calibre1">if (event.type == pygame.QUIT) or \</p>
<p class="calibre1">((event.type == pygame.KEYDOWN) and </p>
<p class="calibre1">(event.key == pygame.K_ESCAPE)):</p>
<p class="calibre1"># Tell the current scene we're leaving</p>
<p class="calibre1">self.oCurrentScene.leave()</p>
<p class="calibre1">pygame.quit()</p>
<p class="calibre1">sys.exit()</p>
<p class="calibre1">eventsList.append(event)</p>
<p class="calibre1"># Here, we let the current scene process all events, </p>
<p class="calibre1"># do any "per frame" actions in its update method, </p>
<p class="calibre1"># and draw everything that needs to be drawn. </p>
<p class="calibre1">3 self.oCurrentScene.handleInputs(eventsList, keysDownList)</p>
<p class="calibre1">4 self.oCurrentScene.update()</p>
<p class="calibre1">5 self.oCurrentScene.draw()</p>
<p class="calibre1"># 11 - Update the window</p>
<p class="calibre1">6 pygame.display.update()</p>
<p class="calibre1"># 12 - Slow things down a bit</p>
<p class="calibre1">clock.tick(self.framesPerSecond) </p>
<p class="calibre1"> <i class="calibre4">Listing 15-7: The run() method of the SceneMgr class</i></p>
<p class="calibre1"><b class="calibre3">336</b>   Chapter 15</p>
<p class="calibre1"><a id="p366"/>The run() method is the key to how the scene manager works. Remember that all scenes must be polymorphic—at a minimum, each must implement </p>
<p class="calibre1">a handleInputs() and a draw() method. Each time through the loop, the run() </p>
<p class="calibre1">method does the following:</p>
<p class="calibre1">•  Gets a list of all keyboard keys 1 (False means up, True means down). </p>
<p class="calibre1">•  Builds a list of events 2 that have happened since the last time through </p>
<p class="calibre1">the loop. </p>
<p class="calibre1">•  Makes calls to the polymorphic methods 3 of the current scene. The cur-</p>
<p class="calibre1">rent scene is always kept in an instance variable named self.oCurrentScene. </p>
<p class="calibre1">In the call to the scene’s handleInputs() method, the scene manager </p>
<p class="calibre1">passes in the list of events that have happened and the list of keys. Each </p>
<p class="calibre1">scene is responsible for handling the events and for dealing with the </p>
<p class="calibre1">state of the keyboard. </p>
<p class="calibre1">•  Calls the update() method 4 to allow the scene to do any per-frame </p>
<p class="calibre1">actions. The Scene base class implements an update() method that just </p>
<p class="calibre1">contains a pass statement, but a scene can override this method with </p>
<p class="calibre1">any code it wants to execute. </p>
<p class="calibre1">•  Calls the draw() method 5 to allow the scene to draw anything it needs </p>
<p class="calibre1">to draw in the window. </p>
<p class="calibre1">At the bottom of the loop (identical to the standard main loop with-</p>
<p class="calibre1">out a scene manager), the method updates the window 6 and waits for an </p>
<p class="calibre1">appropriate amount of time. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Main Methods</b></i></p>
<p class="calibre1">The remaining methods of the SceneMgr class implement the navigation and </p>
<p class="calibre1">communication between scenes:</p>
<p class="calibre1"><b class="calibre3">_goToScene()  </b>Called to transfer to a different scene</p>
<p class="calibre1"><b class="calibre3">_request_respond()  </b>Called to query data in another scene</p>
<p class="calibre1"><b class="calibre3">_send_receive()  </b>Called to send information from one scene to another</p>
<p class="calibre1"><b class="calibre3">_sendAll_receive()  </b>Called to send information from one scene to all </p>
<p class="calibre1">other scenes</p>
<p class="calibre1">The code of any scenes that you write should not call these methods </p>
<p class="calibre1">directly, and they should not be overwritten. The underscore in front of </p>
<p class="calibre1">their names implies that these are private (internal) methods. While they </p>
<p class="calibre1">are not called directly within the scene manager itself, they are called by </p>
<p class="calibre1">the Scene base class. </p>
<p class="calibre1">To explain how these methods work, I’ll start by giving an overview </p>
<p class="calibre1">of the steps involved when a scene wants to navigate to another scene. To </p>
<p class="calibre1">make a transition to a target scene, the current scene calls:</p>
<p class="calibre1">self.goToScene( <i class="calibre4">SOME_SCENE_KEY</i>)</p>
<p class="calibre1">Scenes   <b class="calibre3">337</b></p>
<p class="calibre1"><a id="p367"/>When a scene makes this call, the call goes to the goToScene() method in the inherited Scene base class. The code of the inherited method consists of </p>
<p class="calibre1">a single line:</p>
<p class="calibre1">def goToScene(self, nextSceneKey, data=None):</p>
<p class="calibre1">--- snip ---</p>
<p class="calibre1">self.oSceneMgr._goToScene(nextSceneKey, data)</p>
<p class="calibre1">This makes a call to the private _goToScene() method in the scene man-</p>
<p class="calibre1">ager. Within the scene manager’s method, we need to give the current </p>
<p class="calibre1">scene an opportunity to do any cleanup that might be needed, then trans-</p>
<p class="calibre1">fer control to the new scene. Here is the code of the _goToScene() method of </p>
<p class="calibre1">the scene manager:</p>
<p class="calibre1">def _goToScene(self, nextSceneKey, dataForNextScene):</p>
<p class="calibre1">--- snip ---</p>
<p class="calibre1">if nextSceneKey is None:  # meaning, exit</p>
<p class="calibre1">pygame.quit()</p>
<p class="calibre1">sys.exit()</p>
<p class="calibre1"># Call the leave method of the old scene to allow it to clean up. </p>
<p class="calibre1"># Set the new scene (based on the key) and</p>
<p class="calibre1"># call the enter method of the new scene. </p>
<p class="calibre1">1 self.oCurrentScene.leave()</p>
<p class="calibre1">pygame.key.set_repeat(0) # turn off repeating characters</p>
<p class="calibre1">try:</p>
<p class="calibre1">2 self.oCurrentScene = self.scenesDict[nextSceneKey]</p>
<p class="calibre1">except KeyError:</p>
<p class="calibre1">raise KeyError("Trying to go to scene '" + nextSceneKey +</p>
<p class="calibre1">"' but that key is not in the dictionary of scenes.")</p>
<p class="calibre1">3 self.oCurrentScene.enter(dataForNextScene)</p>
<p class="calibre1">The _goToScene() method performs a number of steps to transition </p>
<p class="calibre1">from the current scene to the target scene. First, it calls leave() in the cur-</p>
<p class="calibre1">rent scene 1 so the current scene can do any necessary cleanup. Then, </p>
<p class="calibre1">using the target scene key that was passed in, it finds the object for the target </p>
<p class="calibre1">scene 2 and sets that as the current scene. Finally, it calls enter() for the new </p>
<p class="calibre1">current scene 3 to allow the new current scene to do any required setup. </p>
<p class="calibre1">From this point on, the run() method of the scene manager loops and </p>
<p class="calibre1">calls the handleInputs(), update(), and draw() methods of the current scene. </p>
<p class="calibre1">These methods will be called in the current scene until the program exe-</p>
<p class="calibre1">cutes another call to self.goToScene() to transition to yet another scene or </p>
<p class="calibre1">the user quits the program. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Communication Between Scenes</b></i></p>
<p class="calibre1">Finally, let’s discuss how one scene communicates with another scene. To </p>
<p class="calibre1">request information from another scene, a scene only needs to make a call </p>
<p class="calibre1">to self.request(), which lives in the Scene base class, like this:</p>
<p class="calibre1">dataRequested = self.request( <i class="calibre4">SOME_SCENE_KEY</i>,  <i class="calibre4">SOME_DATA_IDENTIFIER</i>)</p>
<p class="calibre1"><b class="calibre3">338</b>   Chapter 15</p>
<p class="calibre1"><a id="p368"/>The target scene must have a respond() method. That method needs to be defined like this:</p>
<p class="calibre1">def respond(self, requestID):</p>
<p class="calibre1">It uses the value of requestID to uniquely identify what data to retrieve </p>
<p class="calibre1">and returns that data. Again, the requesting scene and the target scene </p>
<p class="calibre1">must agree on the value of any identifier(s). The full process is shown in </p>
<p class="calibre1">Figure 15-10. </p>
<p class="calibre1"><b class="calibre3">Scene manager</b></p>
<p class="calibre1">self._request_respond()</p>
<p class="calibre1">Return data</p>
<p class="calibre1">2</p>
<p class="calibre1">5</p>
<p class="calibre1"><b class="calibre3">Scene</b></p>
<p class="calibre1"><b class="calibre3">Scene</b></p>
<p class="calibre1"> <i class="calibre4">(Base class)</i></p>
<p class="calibre1"> <i class="calibre4">(Base class)</i></p>
<p class="calibre1">arget.respond()</p>
<p class="calibre1">Return data</p>
<p class="calibre1">oT</p>
<p class="calibre1">4</p>
<p class="calibre1">3</p>
<p class="calibre1">self.request()</p>
<p class="calibre1">Return data</p>
<p class="calibre1">1</p>
<p class="calibre1"><b class="calibre3">Current</b></p>
<p class="calibre1">6</p>
<p class="calibre1"><b class="calibre3">Current</b></p>
<p class="calibre1"><b class="calibre3">scene</b></p>
<p class="calibre1"><b class="calibre3">scene</b></p>
<p class="calibre1"> <i class="calibre4">Figure 15-10: The communication path of one scene asking for information from  </i></p>
<p class="calibre1"> <i class="calibre4">another scene</i></p>
<p class="calibre1">The current scene cannot get information from another scene directly, </p>
<p class="calibre1">since the current scene does not have a reference to any other scene. </p>
<p class="calibre1">Instead, it uses the scene manager as an intermediary. Here is how it all </p>
<p class="calibre1">works:</p>
<p class="calibre1">1.  The current scene makes a call to self.request(), which lives in the </p>
<p class="calibre1">inherited Scene base class. </p>
<p class="calibre1">2. The </p>
<p class="calibre1">Scene base class has a reference to the scene manager in its </p>
<p class="calibre1">instance variable self.oSceneMgr, to allow its methods to call methods </p>
<p class="calibre1">of the scene manager. The self.request() method calls the scene </p>
<p class="calibre1">manager’s _request_respond() method to request information from a </p>
<p class="calibre1">target scene. </p>
<p class="calibre1">3.  The scene manager has a dictionary of all scene keys and related </p>
<p class="calibre1">objects, and it uses the parameter that’s passed in to find the object </p>
<p class="calibre1">associated with the target scene. It then calls the respond() method in </p>
<p class="calibre1">the target scene. </p>
<p class="calibre1">4. The </p>
<p class="calibre1">respond() method in the target scene (which you must write) does </p>
<p class="calibre1">whatever it needs to do to generate the data that was asked for, then </p>
<p class="calibre1">returns the data to the scene manager. </p>
<p class="calibre1">Scenes   <b class="calibre3">339</b></p>
<p class="calibre1"><a id="p369"/>5.  The scene manager returns the data to the request() method in the Scene base class inherited by the current scene. </p>
<p class="calibre1">6.  Finally, the request() method in the Scene base class returns the data to </p>
<p class="calibre1">the original caller. </p>
<p class="calibre1">The same mechanism is used to implement send() and sendAll(). The </p>
<p class="calibre1">only difference is that when sending a message to a scene or to all scenes, </p>
<p class="calibre1">there is no data to be returned to the original caller. </p>
<p class="calibre1"><b class="calibre3">Summary</b></p>
<p class="calibre1">In this chapter, I introduced two different ways to implement a program </p>
<p class="calibre1">that incorporates multiple scenes. A state machine is a technique for rep-</p>
<p class="calibre1">resenting and controlling the flow of execution through a series of states; </p>
<p class="calibre1">you can use it to implement a program with a small number of scenes. The </p>
<p class="calibre1">scene manager is designed to help you build larger multi-scene applications </p>
<p class="calibre1">by providing navigation and a general way for scenes to communicate with </p>
<p class="calibre1">each other. I also explained how the scene manager implements all this </p>
<p class="calibre1">functionality. </p>
<p class="calibre1">The scene manager and the Scene base class provide clear examples of </p>
<p class="calibre1">the three main tenets of object-oriented programming: encapsulation, poly-</p>
<p class="calibre1">morphism, and inheritance. Each scene is a good example of encapsulation </p>
<p class="calibre1">because all the code and data of a scene is written as a class. Each scene class </p>
<p class="calibre1">must be polymorphic, in that it must implement a common set of methods </p>
<p class="calibre1">in order for it to work with calls from the scene manager. Finally, each scene </p>
<p class="calibre1">inherits from a common Scene base class. Two-way communication between </p>
<p class="calibre1">the scene manager and the Scene base class is implemented by every scene </p>
<p class="calibre1">using the inherited methods and instance variables in the base class. </p>
<p class="calibre1"><b class="calibre3">340</b>   Chapter 15</p>
<p class="calibre1"><a id="p370"/><b class="calibre3">16</b></p>
<p class="calibre1"><b class="calibre3">F U L L   G A M E :   D O D G E R</b></p>
<p class="calibre1">In this chapter we’ll build a full game called </p>
<p class="calibre1">Dodger that uses many of the techniques </p>
<p class="calibre1">and concepts that have been explained </p>
<p class="calibre1">in this book. This is a fully object-oriented </p>
<p class="calibre1">extended version of a game originally developed by </p>
<p class="calibre1">Al Sweigart in his book  <i class="calibre4">Invent Your Own Computer Games </i></p>
<p class="calibre1"> <i class="calibre4">with Python</i> (No Starch, 2016; the basic game concept, </p>
<p class="calibre1">graphics, and sounds are used by permission). </p>
<p class="calibre1">Before I get into the game itself, I’ll introduce a set of functions that </p>
<p class="calibre1">present modal dialogs that we’ll use in the game. A  <i class="calibre4">modal dialog </i> is one </p>
<p class="calibre1">that forces the user to interact with it—choosing an option, for example—</p>
<p class="calibre1">before they can continue using the underlying program. These dialogs </p>
<p class="calibre1">stop the program from running until an option is clicked. </p>
<p class="calibre1"><a id="p371"/><b class="calibre3">Modal Dialogs </b></p>
<p class="calibre1">The pyghelpers module has two types of modal dialogs: </p>
<p class="calibre1">•   <i class="calibre4">Yes/No dialogs</i> present a question and wait for the user to click one of </p>
<p class="calibre1">two buttons. The text of these buttons defaults to Yes and No, though </p>
<p class="calibre1">you can use any text you like (for example, OK and Cancel). If no text </p>
<p class="calibre1">is specified for the No button, this dialog can be used as an alert, with </p>
<p class="calibre1">only a Yes (or typically, OK) button. </p>
<p class="calibre1">•   <i class="calibre4">Answer dialogs</i> present a question, a text field for the user to type in, and a set of buttons with text defaulting to OK and Cancel.  The user can </p>
<p class="calibre1">answer the question and click OK or cancel (close) the dialog by click-</p>
<p class="calibre1">ing Cancel. </p>
<p class="calibre1">You present each type of dialog to the user by calling a particular func-</p>
<p class="calibre1">tion in the pyghelpers module. Each dialog comes in two flavors: a simple </p>
<p class="calibre1">TextButton-based version and a more complicated custom version. The sim-</p>
<p class="calibre1">ple text version uses a default layout with two TextButton objects that’s great </p>
<p class="calibre1">for quick prototyping. In the custom version, you can provide a background </p>
<p class="calibre1">for the dialog, customize the question text, customize the answer text (with </p>
<p class="calibre1">an Answer dialog), and provide customized artwork for the buttons. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Yes/No and Alert Dialogs</b></i></p>
<p class="calibre1">We’ll first look at the Yes/No dialog, starting with the text version. </p>
<p class="calibre1"><b class="calibre3">Text Version</b></p>
<p class="calibre1">Here is the interface of the textYesNoDialog() function:</p>
<p class="calibre1">textYesNoDialog(theWindow, theRect, prompt, yesButtonText='Yes', </p>
<p class="calibre1">noButtonText='No', </p>
<p class="calibre1">backgroundColor=DIALOG_BACKGROUND_COLOR, </p>
<p class="calibre1">textColor=DIALOG_BLACK)</p>
<p class="calibre1">When you call this function, you need to pass in the window to draw </p>
<p class="calibre1">into, a rectangle object or tuple representing the location and size of the </p>
<p class="calibre1">dialog to create, and a text prompt to be shown. You can also optionally </p>
<p class="calibre1">specify the text of the two buttons, a background color, and the color of the </p>
<p class="calibre1">prompt text. If not specified, the button text defaults to Yes and No. </p>
<p class="calibre1">Here is a typical call to this function:</p>
<p class="calibre1">returnedValue = pyghelpers.textYesNoDialog(window, </p>
<p class="calibre1">(75, 100, 500, 150), </p>
<p class="calibre1">'Do you want fries with that?')</p>
<p class="calibre1">This call shows the dialog in Figure 16-1. </p>
<p class="calibre1"><b class="calibre3">342</b>   Chapter 16</p>
<p class="calibre1"><a id="p372"/><img src="index-372_1.png" alt="Image 47" class="calibre2"/></p>
<p class="calibre1"><img src="index-372_2.png" alt="Image 48" class="calibre2"/></p>
<p class="calibre1"> <i class="calibre4">Figure 16-1: A typical textYesNoDialog dialog </i></p>
<p class="calibre1">The Yes and No buttons are instances of the TextButton class in pygwidgets. </p>
<p class="calibre1">The main program stops while the dialog shows. When the user clicks a </p>
<p class="calibre1">button, the function returns True for Yes or False for No. Your code does </p>
<p class="calibre1">whatever needs to be done based on the returned Boolean value; then the </p>
<p class="calibre1">main program continues running where it left off. </p>
<p class="calibre1">You can also use this function to create a simple Alert dialog with only </p>
<p class="calibre1">one button. If the value passed in for noButtonText is None, that button will not </p>
<p class="calibre1">be shown. For example, you can make a call like this to show only one button:</p>
<p class="calibre1">ignore = pyghelpers.textYesNoDialog(window, (75, 80, 500, 150), </p>
<p class="calibre1">'This is an alert!', 'OK', None)</p>
<p class="calibre1">Figure 16-2 shows the resulting Alert dialog. </p>
<p class="calibre1"> <i class="calibre4">Figure 16-2: A textYesNoDialog used as an Alert dialog </i></p>
<p class="calibre1"><b class="calibre3">Custom Version</b></p>
<p class="calibre1">Setting up a custom Yes/No dialog is more complicated but allows for much </p>
<p class="calibre1">more control. Here is the interface of the customYesNoDialog() function:</p>
<p class="calibre1">customYesNoDialog(theWindow, oDialogImage, oPromptText, oYesButton, </p>
<p class="calibre1">oNoButton)</p>
<p class="calibre1">Before you can call this function, you need to create objects for the </p>
<p class="calibre1">background of the dialog, the prompt text, and the Yes and No buttons. You </p>
<p class="calibre1">would typically use Image, DisplayText, and CustomButton (or TextButton) objects </p>
<p class="calibre1">created from pygwidgets classes for this purpose. The customYesNoDialog() </p>
<p class="calibre1">code demonstrates polymorphism by calling the handleEvent() method of the </p>
<p class="calibre1">buttons, so it doesn’t matter whether you use CustomButtons or TextButtons, and </p>
<p class="calibre1">by calling the draw() method of all objects that make up the dialog. Because </p>
<p class="calibre1">you create all these objects, you can customize the look of any or all of them. </p>
<p class="calibre1">You will need to supply your own artwork for any Image and CustomButton </p>
<p class="calibre1">objects and customarily place them in the  <i class="calibre4">images</i> folder of the project. </p>
<p class="calibre1">Full Game: Dodger   <b class="calibre3">343</b></p>
<p class="calibre1"><a id="p373"/>When implementing a custom Yes/No dialog, typically you would write an intermediate function like showCustomYesNoDialog(), shown in Listing 16-1. </p>
<p class="calibre1">Then, at the place in your code where you want to show the dialog, rather </p>
<p class="calibre1">than calling customYesNoDialog() directly, you instead call the intermediate </p>
<p class="calibre1">function, which both instantiates the widgets and makes the actual call. </p>
<p class="calibre1">def showCustomYesNoDialog(theWindow, theText):</p>
<p class="calibre1">1 oDialogBackground = pygwidgets.Image(theWindow, (60, 120), </p>
<p class="calibre1">'images/dialog.png')</p>
<p class="calibre1">2 oPromptDisplayText = pygwidgets.DisplayText(theWindow, (0, 170), </p>
<p class="calibre1">theText, width=WINDOW_WIDTH, </p>
<p class="calibre1">justified='center', fontSize=36)</p>
<p class="calibre1">3 oNoButton = pygwidgets.CustomButton(theWindow, (95, 265), </p>
<p class="calibre1">'images/noNormal.png', </p>
<p class="calibre1">over='images/noOver.png', </p>
<p class="calibre1">down='images/noDown.png', </p>
<p class="calibre1">disabled='images/noDisabled.png')</p>
<p class="calibre1">oYesButton = pygwidgets.CustomButton(theWindow, (355, 265), </p>
<p class="calibre1">'images/yesNormal.png', </p>
<p class="calibre1">over='images/yesOver.png', </p>
<p class="calibre1">down='images/yesDown.png', </p>
<p class="calibre1">disabled='images/yesDisabled.png')</p>
<p class="calibre1">4 userAnswer = pyghelpers.customYesNoDialog(theWindow, </p>
<p class="calibre1">oDialogBackground, </p>
<p class="calibre1">oPromptDisplayText, </p>
<p class="calibre1">oYesButton, oNoButton)</p>
<p class="calibre1">5 return userAnswer </p>
<p class="calibre1"> <i class="calibre4">Listing 16-1: An intermediate function to create a custom Yes/No dialog</i></p>
<p class="calibre1">Inside the function you write code to create an Image object for the </p>
<p class="calibre1">background using an image you specify 1. You also create a DisplayText </p>
<p class="calibre1">object for the prompt 2, in which you specify the placement, text size, </p>
<p class="calibre1">font, and so on. Then you create buttons as either TextButton objects or, </p>
<p class="calibre1">more likely, CustomButton objects so you can show custom images 3. Finally, </p>
<p class="calibre1">this function calls customYesNoDialog(), passing in all the objects you just </p>
<p class="calibre1">created 4. The call to customYesNoDialog() returns the user’s choice to this </p>
<p class="calibre1">intermediate function, and the intermediate function returns the user’s </p>
<p class="calibre1">choice to the original caller 5. This approach works well because the wid-</p>
<p class="calibre1">get objects (oDialogBackground, oPromptDisplayText, oYesButton, and oNoButton) </p>
<p class="calibre1">created inside this function are all local variables and therefore will all go </p>
<p class="calibre1">away when the intermediate function ends. </p>
<p class="calibre1">When you call this function, you only need to pass in the window and </p>
<p class="calibre1">the text prompt to be displayed. For example:</p>
<p class="calibre1">returnedValue = showCustomYesNoDialog(window, </p>
<p class="calibre1">'Do you want fries with that?')</p>
<p class="calibre1">Figure 16-3 shows the resulting dialog. This is just one example; you </p>
<p class="calibre1">can design any layout you like. </p>
<p class="calibre1"><b class="calibre3">344</b>   Chapter 16</p>
<p class="calibre1"><a id="p374"/><img src="index-374_1.png" alt="Image 49" class="calibre2"/></p>
<p class="calibre1"> <i class="calibre4">Figure 16-3: A typical customYesNoDialog dialog </i></p>
<p class="calibre1">As with the simple text version, if the value passed in for oNoButton is </p>
<p class="calibre1">None, that button will not be shown, which is useful for building and display-</p>
<p class="calibre1">ing an Alert dialog. </p>
<p class="calibre1">Internally, the textYesNoDialog() and customYesNoDialog() functions each </p>
<p class="calibre1">run their own while loop that handles events and updates and draws the </p>
<p class="calibre1">dialog. That way, the calling program is suspended (its main loop does </p>
<p class="calibre1">not run) until the user clicks a button and the modal dialog returns the </p>
<p class="calibre1">selected answer. (The source code of both functions is available in the </p>
<p class="calibre1">pyghelpers module.)</p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Answer Dialogs</b></i></p>
<p class="calibre1">An Answer dialog adds an input text field where the user can type a </p>
<p class="calibre1">response. The pyghelpers module also contains functions textAnswerDialog() </p>
<p class="calibre1">and customAnswerDialog() to handle these dialogs, which work similarly to </p>
<p class="calibre1">their Yes/No counterparts. </p>
<p class="calibre1"><b class="calibre3">Text Version </b></p>
<p class="calibre1">Here is the interface of the textAnswerDialog() function:</p>
<p class="calibre1">textAnswerDialog(theWindow, theRect, prompt, okButtonText='OK' </p>
<p class="calibre1">cancelButtonText='Cancel', </p>
<p class="calibre1">backgroundColor=DIALOG_BACKGROUND_COLOR, </p>
<p class="calibre1">promptTextColor=DIALOG_BLACK, </p>
<p class="calibre1">inputTextColor=DIALOG_BLACK)</p>
<p class="calibre1">If the user clicks the OK button, the function returns whatever text the </p>
<p class="calibre1">user entered. If the user clicks the Cancel button, the function returns None. </p>
<p class="calibre1">Here is a typical call:</p>
<p class="calibre1">userAnswer = pyghelpers.textAnswerDialog(window, (75, 100, 500, 200), </p>
<p class="calibre1">'What is your favorite flavor of ice cream?')</p>
<p class="calibre1">if userAnswer is not None:</p>
<p class="calibre1"># User pressed OK, do whatever you want with the variable userAnswer</p>
<p class="calibre1">else:</p>
<p class="calibre1"># Here do whatever you want knowing that the user pressed Cancel</p>
<p class="calibre1">Full Game: Dodger   <b class="calibre3">345</b></p>
<p class="calibre1"><a id="p375"/><img src="index-375_1.png" alt="Image 50" class="calibre2"/></p>
<p class="calibre1">This will display the dialog in Figure 16-4. </p>
<p class="calibre1"> <i class="calibre4">Figure 16-4: A typical textAnswerDialog dialog </i></p>
<p class="calibre1"><b class="calibre3">Custom Version</b></p>
<p class="calibre1">To implement a custom Answer dialog, you should write an intermediate </p>
<p class="calibre1">function, similar to the approach shown with customYesNoDialog(). Your main </p>
<p class="calibre1">code calls the intermediate function, which in turn calls customAnswerDialog(). </p>
<p class="calibre1">Listing 16-2 shows the code of a typical intermediate function. </p>
<p class="calibre1">def showCustomAnswerDialog(theWindow, theText):</p>
<p class="calibre1">oDialogBackground = pygwidgets.Image(theWindow, (60, 80), </p>
<p class="calibre1">'images/dialog.png')</p>
<p class="calibre1">oPromptDisplayText = pygwidgets.DisplayText(theWindow, (0, 120), </p>
<p class="calibre1">theText, width=WINDOW_WIDTH, </p>
<p class="calibre1">justified='center', fontSize=36)</p>
<p class="calibre1">oUserInputText = pygwidgets.InputText(theWindow, (225, 165), '', </p>
<p class="calibre1">fontSize=36, initialFocus=True)</p>
<p class="calibre1">oNoButton = pygwidgets.CustomButton(theWindow, (105, 235), </p>
<p class="calibre1">'images/cancelNormal.png', </p>
<p class="calibre1">over='images/cancelOver.png', </p>
<p class="calibre1">down='images/cancelDown.png', </p>
<p class="calibre1">isabled='images/cancelDisabled.png')</p>
<p class="calibre1">oYesButton = pygwidgets.CustomButton(theWindow, (375, 235), </p>
<p class="calibre1">'images/okNormal.png', </p>
<p class="calibre1">over='images/okOver.png', </p>
<p class="calibre1">down='images/okDown.png', </p>
<p class="calibre1">disabled='images/okDisabled.png')</p>
<p class="calibre1">response = pyghelpers.customAnswerDialog(theWindow, </p>
<p class="calibre1">oDialogBackground, oPromptDisplayText, </p>
<p class="calibre1">oUserInputText, </p>
<p class="calibre1">oYesButton, oNoButton)</p>
<p class="calibre1">return response</p>
<p class="calibre1"> <i class="calibre4">Listing 16-2: An intermediate function to create a custom Answer dialog</i></p>
<p class="calibre1">You can customize the entire appearance of the dialog: background </p>
<p class="calibre1">image, fonts, and sizes and placement of the display and input text fields </p>
<p class="calibre1"><b class="calibre3">346</b>   Chapter 16</p>
<p class="calibre1"><a id="p376"/><img src="index-376_1.png" alt="Image 51" class="calibre2"/></p>
<p class="calibre1">and the two buttons. To show a custom dialog, your main code would call </p>
<p class="calibre1">the intermediate function and pass in the prompt text, like this:</p>
<p class="calibre1">userAnswer = showCustomAnswerDialog(window, </p>
<p class="calibre1">'What is your favorite flavor of ice cream?')</p>
<p class="calibre1">That call displays a custom Answer dialog like the one shown in </p>
<p class="calibre1">Figure 16-5. </p>
<p class="calibre1"> <i class="calibre4">Figure 16-5: A typical customAnswerDialog dialog </i></p>
<p class="calibre1">If user clicks OK, the function returns the text the user entered. If the </p>
<p class="calibre1">user clicks the Cancel button, the function returns None. </p>
<p class="calibre1">A demo program that demonstrates all the types of dialogs,  <i class="calibre4">DialogTester/</i></p>
<p class="calibre1"> <i class="calibre4">Main_DialogTester.py</i>, is available with the downloadable resources for the </p>
<p class="calibre1">book. </p>
<p class="calibre1"><b class="calibre3">Building a Full Game: Dodger</b></p>
<p class="calibre1">In this section, we’ll put all the material from this part of the book together </p>
<p class="calibre1">in the context of a game called Dodger. From the user’s point of view, the </p>
<p class="calibre1">game is extremely simple: get as many points as you can by dodging the red </p>
<p class="calibre1">Baddies and making contact with the green Goodies. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Game Overview</b></i></p>
<p class="calibre1">Red Baddies will drop from the top of the window, and the user must avoid </p>
<p class="calibre1">them. Any Baddie that makes it all the way down to the bottom of the game </p>
<p class="calibre1">area is removed, and the user gains one point. The user moves the mouse to </p>
<p class="calibre1">control a Player icon. If the Player touches any Baddie, the game is over. A </p>
<p class="calibre1">small number of green Goodies show up randomly and move horizontally, </p>
<p class="calibre1">and the user gets 25 points for any Goodie they touch. </p>
<p class="calibre1">The game has three scenes: a starting or Splash scene with instructions, </p>
<p class="calibre1">a Play scene where you play the game, and a High Scores scene where you </p>
<p class="calibre1">can view the top 10 high scores. If you score within the top 10, you’re given </p>
<p class="calibre1">the option of entering your name and score into the high scores table. </p>
<p class="calibre1">Figure 16-6 shows the three scenes. </p>
<p class="calibre1">Full Game: Dodger   <b class="calibre3">347</b></p>
<p class="calibre1"><a id="p377"/><img src="index-377_1.png" alt="Image 52" class="calibre2"/></p>
<p class="calibre1"> <i class="calibre4">Figure 16-6: The Splash, Play, and High Score scenes (left to right)</i></p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Implementation</b></i></p>
<p class="calibre1">The contents of the  <i class="calibre4">Dodger</i> project folder are as follows (filenames are in italic):</p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">__init__.py</b></i><b class="calibre3">  </b>Empty file that indicates that this is a Python package</p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Baddies.py</b></i><b class="calibre3">  </b>Contains the Baddie and BaddieMgr classes</p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Constants.py</b></i><b class="calibre3">  </b>Contains constants used by multiple scenes</p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Goodies.py</b></i><b class="calibre3">  </b>Contains the Goodie and GoodieMgr classes</p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">HighScoresData.py</b></i><b class="calibre3">  </b>Contains the HighScoresData class</p>
<p class="calibre1"><b class="calibre3">images  </b>Folder that contains all the artwork for the game</p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Main_Dodger.py</b></i><b class="calibre3">  </b>The main program</p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Player.py</b></i><b class="calibre3">  </b>Contains the Player class</p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">SceneHighScores.py</b></i><b class="calibre3">  </b>The scene that shows and records high scores</p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">ScenePlay.py</b></i><b class="calibre3">  </b>The main Play scene</p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Scene.Splash.py</b></i><b class="calibre3">  </b>The Splash scene</p>
<p class="calibre1"><b class="calibre3">sounds  </b>Folder that contains all the sound files for the game</p>
<p class="calibre1">The project folder is included with the book’s resources. I won’t talk </p>
<p class="calibre1">through the entirety of the code, but I’ll go through the source files and </p>
<p class="calibre1">explain how the key parts work. </p>
<p class="calibre1"><b class="calibre3">File: Dodger/Constants.py </b></p>
<p class="calibre1">This file contains constants that can be used by more than one source file. </p>
<p class="calibre1">The most important constants are the scene keys: </p>
<p class="calibre1"># Scene keys</p>
<p class="calibre1">SCENE_SPLASH = 'scene splash' </p>
<p class="calibre1">SCENE_PLAY = 'scene play' </p>
<p class="calibre1">SCENE_HIGH_SCORES = 'scene high scores' </p>
<p class="calibre1"><b class="calibre3">348</b>   Chapter 16</p>
<p class="calibre1"><a id="p378"/>The values of these constants are unique strings that identify the different scenes. </p>
<p class="calibre1"><b class="calibre3">File: Main_Dodger.py</b></p>
<p class="calibre1">The main file performs the necessary initialization, then passes control to </p>
<p class="calibre1">the scene manager. The most important code in the file is this:</p>
<p class="calibre1"># Instantiate all scenes and store them in a list</p>
<p class="calibre1">scenesList = [SceneSplash(window)</p>
<p class="calibre1">SceneHighScores(window)</p>
<p class="calibre1">ScenePlay(window)] </p>
<p class="calibre1"># Create the scene manager, passing in the scenes list and the FPS</p>
<p class="calibre1">oSceneMgr = pyghelpers.SceneMgr(scenesList, FRAMES_PER_SECOND)</p>
<p class="calibre1"># Tell the scene manager to start running</p>
<p class="calibre1">oSceneMgr.run()</p>
<p class="calibre1">Here we create an instance of each scene, instantiate the scene man-</p>
<p class="calibre1">ager, then turn over control to the scene manager. The scene manager’s </p>
<p class="calibre1">run() method gives control to the first scene in the list. In this game, it gives </p>
<p class="calibre1">control to the Splash scene. </p>
<p class="calibre1">As discussed in the previous chapter, each scene class inherits from the </p>
<p class="calibre1">Scene base class. In addition to providing its own __init__() method, each </p>
<p class="calibre1">of these classes is required to override the getSceneKey(), handleInputs(), and </p>
<p class="calibre1">draw() methods from the base class. </p>
<p class="calibre1"><b class="calibre3">File: Dodger/SceneSplash.py</b></p>
<p class="calibre1">The Splash scene shows the user a graphic with the rules of the game and </p>
<p class="calibre1">three buttons: Start, Quit, and Go to High Scores. The code for this scene’s </p>
<p class="calibre1">class only contains the required methods; all other methods default to the </p>
<p class="calibre1">ones in the Scene base class. </p>
<p class="calibre1">The __init__() method creates an Image object for the background </p>
<p class="calibre1">image and three CustomButton objects for the user’s options. </p>
<p class="calibre1">The getSceneKey() method must be implemented in all scenes; it just </p>
<p class="calibre1">returns a unique key for the scene. </p>
<p class="calibre1">The handleInputs() method checks for the user clicking any of the but-</p>
<p class="calibre1">tons. If the user clicks Start, we call the inherited self.goToScene() method </p>
<p class="calibre1">to ask the scene manager to transfer control to the Play scene. Similarly, </p>
<p class="calibre1">clicking the Go to High Scores button takes the user to the High Scores </p>
<p class="calibre1">scene. If the user clicks Quit, we call the scene’s inherited self.quit() </p>
<p class="calibre1">method, which quits the program. </p>
<p class="calibre1">In the draw() method, the program draws the background and all three </p>
<p class="calibre1">buttons. </p>
<p class="calibre1"><b class="calibre3">File: Dodger/ScenePlay.py</b></p>
<p class="calibre1">The Play scene manages the actual playing of the game: the user moving </p>
<p class="calibre1">the Player icon, generation and movement of the Baddies and Goodies, </p>
<p class="calibre1">Full Game: Dodger   <b class="calibre3">349</b></p>
<p class="calibre1"><a id="p379"/>and collision detection. It also manages the display elements at the bottom of the window, including the current game score and high score, and </p>
<p class="calibre1">responds to clicks on the Quit, Go to High Scores, and Start buttons and </p>
<p class="calibre1">the Background Music checkbox. </p>
<p class="calibre1">There is quite a bit of code for the Play scene, so I’ll break it up into </p>
<p class="calibre1">smaller chunks (Listings 16-3 through 16-7) to explain the methods. The </p>
<p class="calibre1">scene adheres to the design rules established i<a href="#p340">n Chapter 15 by i</a>mplementing the __init__(), handleInputs(), update(), and draw() methods. It also implements </p>
<p class="calibre1">an enter() method to handle what the scene should do when it becomes the </p>
<p class="calibre1">active scene and a leave() method for what the scene should do when the user </p>
<p class="calibre1">navigates away. Finally, it has a reset() method for resetting the state before </p>
<p class="calibre1">starting a new round. Listing 16-3 shows the initialization code. </p>
<p class="calibre1">#  Play scene - the main game play scene</p>
<p class="calibre1">--- snip imports and showCustomYesNoDialog ---</p>
<p class="calibre1">BOTTOM_RECT = (0, GAME_HEIGHT + 1, WINDOW_WIDTH, </p>
<p class="calibre1">WINDOW_HEIGHT - GAME_HEIGHT)</p>
<p class="calibre1">STATE_WAITING = 'waiting' </p>
<p class="calibre1">STATE_PLAYING = 'playing' </p>
<p class="calibre1">STATE_GAME_OVER = 'game over' </p>
<p class="calibre1">class ScenePlay(pyghelpers.Scene):</p>
<p class="calibre1">def __init__(self, window):</p>
<p class="calibre1">1 self.window = window</p>
<p class="calibre1">self.controlsBackground = pygwidgets.Image(self.window, </p>
<p class="calibre1">(0, GAME_HEIGHT), </p>
<p class="calibre1">'images/controlsBackground.jpg')</p>
<p class="calibre1">self.quitButton = pygwidgets.CustomButton(self.window, </p>
<p class="calibre1">(30, GAME_HEIGHT + 90), </p>
<p class="calibre1">up='images/quitNormal.png', </p>
<p class="calibre1">down='images/quitDown.png', </p>
<p class="calibre1">over='images/quitOver.png', </p>
<p class="calibre1">disabled='images/quitDisabled.png')</p>
<p class="calibre1">self.highScoresButton = pygwidgets.CustomButton(self.window, </p>
<p class="calibre1">(190, GAME_HEIGHT + 90), </p>
<p class="calibre1">up='images/gotoHighScoresNormal.png', </p>
<p class="calibre1">down='images/gotoHighScoresDown.png', </p>
<p class="calibre1">over='images/gotoHighScoresOver.png', </p>
<p class="calibre1">disabled='images/gotoHighScoresDisabled.png')</p>
<p class="calibre1">self.startButton = pygwidgets.CustomButton(self.window, </p>
<p class="calibre1">(450, GAME_HEIGHT + 90), </p>
<p class="calibre1">up='images/startNewNormal.png', </p>
<p class="calibre1">down='images/startNewDown.png', </p>
<p class="calibre1">over='images/startNewOver.png', </p>
<p class="calibre1">disabled='images/startNewDisabled.png', </p>
<p class="calibre1">enterToActivate=True)</p>
<p class="calibre1"><b class="calibre3">350</b>   Chapter 16</p>
<p class="calibre1"><a id="p380"/>        self.soundCheckBox = pygwidgets.TextCheckBox(self.window, </p>
<p class="calibre1">(430, GAME_HEIGHT + 17), </p>
<p class="calibre1">'Background music', </p>
<p class="calibre1">True, textColor=WHITE)</p>
</body></html>