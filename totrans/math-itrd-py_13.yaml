- en: '10'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '10'
- en: CREATING FRACTALS USING RECURSION
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用递归创建分形
- en: '*What’s another word for* thesaurus*?'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*“thesaurus”还有另一个词是什么？*'
- en: —Steven Wright*
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: —史蒂文·赖特*
- en: '![image](../images/fintro-01.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fintro-01.jpg)'
- en: Fractals are delightfully complicated designs, where each smaller part of the
    design contains the entire design (see [Figure 10-1](ch10.xhtml#ch10fig1)). They
    were invented (or discovered, since fractals exist in nature) by Benoit Mandelbrot
    in 1980 when he was visualizing some complex functions on a state-of-the-art IBM
    computer.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 分形是一种令人愉悦的复杂设计，其中每个设计的较小部分都包含整个设计（见[图10-1](ch10.xhtml#ch10fig1)）。它们是由Benoit
    Mandelbrot在1980年发明的（或者说是发现的，因为分形在自然界中就存在），当时他正在用一台先进的IBM计算机可视化一些复杂的函数。
- en: '![image](../images/f201-01.jpg)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f201-01.jpg)'
- en: '*Figure 10-1: Examples of fractals*'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-1：分形的例子*'
- en: Fractals don’t look like regular shapes we recognize from geometry, like squares,
    triangles, and circles. Their shapes are crooked and jagged, making them great
    models for simulating natural phenomena. In fact, scientists use fractals to model
    everything from the arteries in your heart, to earthquakes, to neurons in your
    brain.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 分形的形状看起来与我们在几何学中认知的规则形状不同，比如正方形、三角形和圆形。它们的形状曲折不规则，使它们成为模拟自然现象的极好模型。实际上，科学家们使用分形来模拟从心脏动脉到地震，再到大脑中的神经元等一切事物。
- en: What makes fractals so interesting is that they illustrate how you can get surprisingly
    complex designs from simple rules being run over and over and patterns being repeated
    at smaller and smaller scale.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 分形之所以如此有趣，是因为它们展示了如何通过简单的规则不断运行和在更小的尺度上重复图案，从而产生出令人惊讶的复杂设计。
- en: Our main interest is the interesting, complicated designs you can make using
    fractals. There’s a picture of a fractal in every math book these days, but textbooks
    never show you how to make one—you need a computer to do that. In this chapter,
    you learn how to make your own fractals using Python.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的主要兴趣是通过分形可以制作出有趣且复杂的设计。如今，每本数学书中都有分形的图片，但教科书从未告诉你如何制作分形——你需要用计算机来实现。在本章中，你将学习如何使用Python制作你自己的分形。
- en: THE LENGTH OF A COASTLINE
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 海岸线的长度
- en: Before you can start creating fractals, let’s look at a simple example to understand
    how fractals can be useful. A mathematician named Lewis Richardson asked a simple
    question; “How long is the coastline of England?” As you can see in [Figure 10-2](ch10.xhtml#ch10fig2),
    the answer depends on how long your ruler is.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始创建分形之前，让我们看一个简单的例子，来理解分形如何有用。一位数学家名叫Lewis Richardson提出了一个简单的问题：“英格兰的海岸线有多长？”正如你在[图10-2](ch10.xhtml#ch10fig2)中看到的，答案取决于你标尺的长度。
- en: '![image](../images/f202-01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f202-01.jpg)'
- en: '*Figure 10-2: Approximating the length of a coastline*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-2：近似海岸线长度*'
- en: The smaller your ruler, the more closely you can approximate the coastline’s
    jagged edges, which means you’ll end up with a longer measurement. The cool thing
    is that *the length of the coastline approaches infinity as the length of the
    ruler gets close to zero!* This is known as the Coastline Paradox.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你的标尺越小，你就能越接近逼近海岸线的曲折边缘，这意味着你最终会得到一个更长的测量值。更酷的是，*当标尺长度接近零时，海岸线的长度趋向于无限大！* 这被称为海岸线悖论。
- en: Think this is just abstract mathematical noodling? Coastline length estimates
    can vary wildly in the real world. Even with modern technology, it all depends
    on the scale used to measure the map. We’ll draw a figure like [Figure 10-3](ch10.xhtml#ch10fig3),
    the Koch snowflake, to show how a fractal can prove a rough enough coastline can
    get as long as you want!
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 觉得这只是抽象的数学涂鸦吗？在现实世界中，海岸线长度的估算可以有很大的差异。即使是现代技术，也完全取决于用来测量地图的尺度。我们将绘制一个类似于[图10-3](ch10.xhtml#ch10fig3)的图形——科赫雪花，展示分形如何证明即使是一个粗略的海岸线，也可以延长到你想要的任何长度！
- en: '![image](../images/f203-01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f203-01.jpg)'
- en: '*Figure 10-3: An increasingly detailed fractal, modeling an increasingly rough
    coastline*'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-3：一个越来越详细的分形，模拟越来越粗糙的海岸线*'
- en: First, you’re going to need to learn a few tricks, like recursion.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要学习一些技巧，比如递归。
- en: WHAT IS RECURSION?
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 什么是递归？
- en: 'The power of fractals is that you can repeat patterns of numbers or shapes
    that get smaller at every step until you’re dealing with very small numbers. The
    key to repeating all this code is a concept called *recursion*, which is when
    something is defined in terms of itself. Some of these jokes illustrate how recursion
    works:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 分形的强大之处在于，你可以重复缩小的数字或形状的模式，直到你处理的是非常小的数字。重复所有这些代码的关键是一个叫做*递归*的概念，递归是指某个事物通过自身来定义。以下一些笑话展示了递归是如何工作的：
- en: If you google “recursion,” it asks you, “Did you mean *recursion*?”
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你在谷歌搜索“递归”，它会问你：“你是想搜索 *recursion* 吗？”
- en: 'In the index to more than one computer programming book, there’s an entry like
    this: “recursion, see *recursion*.”'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在很多计算机编程书籍的索引中，会看到类似这样的条目：“递归，参见 *recursion*。”
- en: As you can imagine, recursion is a pretty strange concept. The virtue of recursion
    is that it can tidy up code that would otherwise be too complicated, but the disadvantage
    is that you can end up using up too much memory.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所想，递归是一个相当奇怪的概念。递归的优点是它可以简化本来可能过于复杂的代码，但缺点是它可能会耗费太多内存。
- en: WRITING THE FACTORIAL() FUNCTION
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编写 factorial() 函数
- en: Let’s see recursion in action by writing a function for the factorial of a number.
    You may recall from math class that the *factorial* of *n* (expressed as *n!*)
    is defined as the product of all the integers from 1 to *n*. For example, 5! =
    1 × 2 × 3 × 4 × 5 = 120.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过编写一个计算数字阶乘的函数来看递归的实际应用。你可能还记得数学课上，*n* 的阶乘（表示为 *n!*）是从 1 到 *n* 的所有整数的乘积。例如，5!
    = 1 × 2 × 3 × 4 × 5 = 120。
- en: 'The formula looks like this: *n*! = 1 × 2 × 3 . . . × (*n* – 2) × (*n* – 1)
    × *n*. This is an example of a recursive sequence, because 5! = 5 × 4! and 4!
    = 4 × 3!, and so on. Recursion is an important concept in math because math is
    all about patterns, and recursion allows you to copy and extend patterns infinitely!'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这个公式看起来是这样的：*n*! = 1 × 2 × 3 . . . × (*n* – 2) × (*n* – 1) × *n*。这是递归序列的一个例子，因为
    5! = 5 × 4!，而 4! = 4 × 3!，依此类推。递归是数学中的一个重要概念，因为数学的核心就是模式，而递归让你能够无限复制和扩展这些模式！
- en: We can define the factorial of n as the product of n and the factorial of n
    – 1\. We just have to define the factorial of 0 (which is 1, not 0) and the factorial
    of 1 and then use a recursive statement. Open a new file in IDLE, save it as *factorial.py*,
    and then enter with the code in [Listing 10-1](ch10.xhtml#ch10list1).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将 *n* 的阶乘定义为 *n* 与 *n* – 1 的阶乘的乘积。我们只需要定义 0 的阶乘（为 1，而不是 0）和 1 的阶乘，然后使用递归语句。打开
    IDLE 中的新文件，将其保存为 *factorial.py*，然后输入 [清单 10-1](ch10.xhtml#ch10list1) 中的代码。
- en: '*factorial.py*'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*factorial.py*'
- en: 'def factorial(n):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 'def factorial(n):'
- en: 'if n == 0:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 'if n == 0:'
- en: return 1
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: return 1
- en: 'else:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: return n * factorial(n – 1)
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: return n * factorial(n – 1)
- en: '*Listing 10-1: Using a recursive statement to write the factorial() function*'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-1：使用递归语句编写 factorial() 函数*'
- en: First, we’re saying, “If the user (or the program) asks for the factorial of
    0 or 1, return 1.” This is because 0! and 1! both equal 1\. Then we tell the program,
    “For any other number *n*, return *n* times the factorial of the number 1 less
    than *n*.”
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在这里说的是，“如果用户（或程序）请求计算 0 或 1 的阶乘，返回 1。”这是因为 0! 和 1! 都等于 1。接着我们告诉程序，“对于任何其他的数字
    *n*，返回 *n* 乘以 *n* 减去 1 的阶乘。”
- en: Notice that on the last line of [Listing 10-1](ch10.xhtml#ch10list1), we’re
    calling the factorial() function *inside* the definition of the factorial() function!
    That’s like a recipe for a loaf of bread containing the step “Bake a loaf of bread.”
    People wouldn’t even begin following a recipe written like that. But computers
    can start going through the steps and follow them throughout the process.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在 [清单 10-1](ch10.xhtml#ch10list1) 的最后一行，我们在调用 factorial() 函数时，是在 factorial()
    函数的定义内部进行调用！这就像一份面包制作食谱，其中写着“烤一块面包”。人们根本不会开始按照这样的食谱制作面包。但是计算机可以从头到尾按照步骤执行。
- en: In this example, when we ask for the factorial of 5, the program proceeds obediently
    and makes it to the last line, where it asks for the factorial of *n* – 1, which
    in this case (because *n* = 5) is the factorial of 4\. To calculate factorial
    (5 – 1), the program starts the factorial() function again with *n* = 4 and tries
    to evaluate the factorial of 4 the same way, followed by the factorial of 3, the
    factorial of 2, the factorial of 1, and finally the factorial of 0\. Because we
    already defined the function to return the factorial of 0 as 1, the function can
    go back up through the process, evaluating the factorial of 1, then 2, then 3,
    then 4, and finally 5.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当我们请求 5 的阶乘时，程序会顺从地执行，直到最后一行，它会请求 *n* – 1 的阶乘，在这个例子中（因为 *n* = 5），就是 4
    的阶乘。为了计算 factorial(5 – 1)，程序会再次启动 factorial() 函数，将 *n* 设置为 4，并尝试以相同的方式计算 4 的阶乘，接着是
    3 的阶乘、2 的阶乘、1 的阶乘，最后是 0 的阶乘。因为我们已经定义了 0 的阶乘为 1，所以函数可以沿着这个过程返回，计算 1 的阶乘，再是 2 的阶乘、3
    的阶乘、4 的阶乘，最后是 5 的阶乘。
- en: 'Defining a function recursively (by calling the function inside its own definition)
    might seem confusing, but it’s the key to making all the fractals in this chapter.
    Let’s start with a classic: the fractal tree.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 递归定义一个函数（在函数内部调用自身）可能看起来有些困惑，但这是本章中所有分形图形的关键。我们从一个经典例子开始：分形树。
- en: BUILDING A FRACTAL TREE
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 构建分形树
- en: Making a fractal starts with defining a simple function and adding a call to
    the function inside the function itself. Let’s try building a fractal tree that
    looks like [Figure 10-4](ch10.xhtml#ch10fig4).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 创建分形图形从定义一个简单的函数开始，并在函数内部添加对该函数的调用。让我们尝试创建一个看起来像[图 10-4](ch10.xhtml#ch10fig4)的分形树。
- en: '![image](../images/f204-01.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f204-01.jpg)'
- en: '*Figure 10-4: A fractal tree*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-4：一棵分形树*'
- en: This would be an incredibly complicated design to create if you had to tell
    the program every line to draw. But it takes surprisingly little code if you use
    recursion. Using translations, rotations, and the line() function, we’ll first
    draw a Y in Processing, as shown in [Figure 10-5](ch10.xhtml#ch10fig5).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你必须告诉程序每一条线如何绘制，这将是一个非常复杂的设计。但如果使用递归，代码量惊人地少。通过使用平移、旋转和 line() 函数，我们首先会在 Processing
    中绘制一个 Y 形状，正如[图 10-5](ch10.xhtml#ch10fig5)所示。
- en: '![image](../images/f205-01.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f205-01.jpg)'
- en: '*Figure 10-5: The beginnings of a fractal tree*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-5：分形树的初步形态*'
- en: The only requirement to eventually make this Y into a fractal is that after
    the program draws the Y tree, along with the branches, the program has to return
    to the bottom of the “trunk.” This is because the “branches” are going to become
    Y’s themselves. If the program doesn’t return to the bottom of the Y every time,
    we won’t get our tree.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要使这个 Y 最终成为一个分形图形，唯一的要求是，在程序绘制完 Y 树及其分支后，程序必须返回到“树干”的底部。这是因为“分支”将会变成 Y 形状。如果程序每次都不返回到
    Y 的底部，我们就无法得到树形。
- en: WRITING THE Y() FUNCTION
  id: totrans-48
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 编写 y() 函数
- en: Your Y doesn’t have to be perfect or symmetrical, but here’s my code for drawing
    a Y. Open a new sketch in Processing, name it *fractals.pyde*, and enter the code
    in [Listing 10-2](ch10.xhtml#ch10list2).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 Y 不必是完美或对称的，但这是我绘制 Y 形状的代码。在 Processing 中打开一个新草图，将其命名为 *fractals.pyde*，并输入[清单
    10-2](ch10.xhtml#ch10list2)中的代码。
- en: '*fractals.pyde*'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*fractals.pyde*'
- en: 'def setup():'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 'def setup():'
- en: size(600,600)
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: size(600,600)
- en: 'def draw():'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 'def draw():'
- en: background(255)
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: background(255)
- en: translate(300,500)
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: translate(300,500)
- en: y(100)
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: y(100)
- en: 'def y(sz):'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 'def y(sz):'
- en: line(0,0,0,-sz)
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: line(0,0,0,-sz)
- en: translate(0,-sz)
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: translate(0,-sz)
- en: rotate(radians(30))
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: rotate(radians(30))
- en: 'line(0,0,0,-0.8*sz) #right branch'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 'line(0,0,0,-0.8*sz) #右侧分支'
- en: rotate(radians(-60))
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: rotate(radians(-60))
- en: 'line(0,0,0,-0.8*sz) #left branch'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 'line(0,0,0,-0.8*sz) #左侧分支'
- en: rotate(radians(30))
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: rotate(radians(30))
- en: translate(0,sz)
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: translate(0,sz)
- en: '*Listing 10-2: Writing the y() function for the fractal tree*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-2：为分形树编写 y() 函数*'
- en: 'We set up the Processing sketch the way we always do: in the setup() function
    we tell the program what size to make the display window, and then in the draw()
    function we set the background color (255 is white) and translate to where we
    want to start drawing. Finally, we call the y() function and pass the number 100
    for the size of the “trunk” of the fractal tree.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们像往常一样设置 Processing 草图：在 setup() 函数中，我们告诉程序设置显示窗口的大小，然后在 draw() 函数中，我们设置背景颜色（255
    是白色）并平移到我们想要开始绘制的位置。最后，我们调用 y() 函数，并传递数字 100 作为分形树“树干”的大小。
- en: The y() function takes a number sz as a parameter to be the length of the trunk
    of the tree. Then all the branches will be based on that number. The first line
    of code in the y() function draws the trunk of the tree using a vertical line.
    To create a line branching off to the right, we translate the vertical line up
    the trunk of the tree (in the negative y-direction) and then rotate it 30 degrees
    to the right. Next, we draw another line for the right branch, rotate to the left
    (negative 60 degrees), and draw another line for the left branch. Finally, we
    have to rotate so we’re facing straight up again so that we can translate down
    the trunk again. Save and run this sketch, and you should see the Y in [Figure
    10-5](ch10.xhtml#ch10fig5).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: y() 函数接受一个数字 sz 作为参数，表示树干的长度。然后所有的分支都基于这个数字。y() 函数中的第一行代码通过一条垂直线绘制树干。为了创建一个向右分叉的线，我们将垂直线沿树干（沿负
    y 方向）平移，并将其旋转 30 度到右边。接下来，我们绘制另一条右分支线，向左旋转（负 60 度），并绘制另一条左分支线。最后，我们必须旋转以使我们再次面朝上，这样才能再次沿着树干向下平移。保存并运行这个草图，你应该会看到[图
    10-5](ch10.xhtml#ch10fig5)中的 Y 形状。
- en: 'We can convert this program that draws a single Y into one that draws a fractal
    by making the branches into *smaller* Y’s. But if we simply replace “line” with
    “y” in the y() function, our program will get stuck in an infinite loop, throwing
    an error like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个绘制单个 Y 的程序改造为绘制分形，通过将分支变成 *更小* 的 Y。但是，如果我们在 y() 函数中简单地将 “line” 替换为 “y”，程序就会陷入无限循环，并抛出如下错误：
- en: 'RuntimeError: maximum recursion depth exceeded'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 'RuntimeError: 超过最大递归深度'
- en: Recall that we didn’t call factorial(n) inside the factorial function but rather
    called factorial(n-1). We have to introduce a level parameter to the y() function.
    Then each branch up, the tree will be a level down, so the branch will get the
    parameter level – 1. This means the trunk is always the highest numbered level
    and the last set of branches up the tree is always level 0\. Here’s how to change
    the y() function in [Listing 10-3](ch10.xhtml#ch10list3).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，我们没有在 factorial 函数内部调用 factorial(n)，而是调用了 factorial(n-1)。我们需要在 y() 函数中引入一个
    level 参数。然后，每次分支向上，树的级别会减小，因此分支会获得参数 level - 1。这意味着树干始终是最高级别，最后一组分支总是第 0 级。以下是如何修改
    [清单 10-3](ch10.xhtml#ch10list3) 中的 y() 函数。
- en: '*fractals.pyde*'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*fractals.pyde*'
- en: 'def setup():'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 'def setup():'
- en: size(600,600)
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: size(600,600)
- en: 'def draw():'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 'def draw():'
- en: background(255)
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: background(255)
- en: translate(300,500)
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: translate(300,500)
- en: y(100,2)
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: y(100,2)
- en: 'def y(sz,level):'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 'def y(sz,level):'
- en: 'if level > 0:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 'if level > 0:'
- en: line(0,0,0,-sz)
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: line(0,0,0,-sz)
- en: translate(0,-sz)
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: translate(0,-sz)
- en: rotate(radians(30))
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: rotate(radians(30))
- en: y(0.8*sz,level-1)
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: y(0.8*sz,level-1)
- en: rotate(radians(-60))
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: rotate(radians(-60))
- en: y(0.8*sz,level-1)
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: y(0.8*sz,level-1)
- en: rotate(radians(30))
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: rotate(radians(30))
- en: translate(0,sz)
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: translate(0,sz)
- en: '*Listing 10-3: Adding recursion to the y() function*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-3：向 y() 函数添加递归*'
- en: Notice that we replaced all the line() functions in the code with y() functions
    to draw the branches. Because we changed the call to the y() function in draw()
    to y(100,2), we’ll get a tree of trunk size 100 with two levels. Try a three-level
    tree, a four-level one, and so on! You should see something like [Figure 10-6](ch10.xhtml#ch10fig6).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们将代码中的所有 line() 函数替换为 y() 函数来绘制分支。由于我们将 draw() 中对 y() 函数的调用改为 y(100,2)，我们将得到一个树干大小为
    100 且有两个级别的树。尝试三层树、四层树，等等！你应该会看到像 [图 10-6](ch10.xhtml#ch10fig6) 这样的效果。
- en: '![image](../images/f207-01.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f207-01.jpg)'
- en: '*Figure 10-6: Trees of levels 1 through 4*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-6：1 到 4 级的树木*'
- en: Mapping the Mouse
  id: totrans-93
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 映射鼠标
- en: Now let’s make a program that allows you to control the shape of the fractal
    in real time, just by moving your mouse up or down! We can vary the level of rotation
    dynamically by tracking the mouse and returning a value between 0 and 10 based
    on its location. Update the draw() function with the code in [Listing 10-4](ch10.xhtml#ch10list4).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们制作一个程序，允许你通过上下移动鼠标来实时控制分形的形状！我们可以通过跟踪鼠标并根据其位置返回一个介于 0 到 10 之间的值来动态地改变旋转的级别。使用
    [清单 10-4](ch10.xhtml#ch10list4) 中的代码更新 draw() 函数。
- en: '*fractals.pyde*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*fractals.pyde*'
- en: 'def draw():'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 'def draw():'
- en: background(255)
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: background(255)
- en: translate(300,500)
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: translate(300,500)
- en: level = int(map(mouseX,0,width,0,10))
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: level = int(map(mouseX,0,width,0,10))
- en: y(100,level)
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: y(100,level)
- en: '*Listing 10-4: Adding the level parameter to the draw() function*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-4：向 draw() 函数添加 level 参数*'
- en: Our mouse’s x-value can be anywhere between 0 and the width of the window. The
    map() function replaces one range of values with another. In [Listing 10-4](ch10.xhtml#ch10list4),
    map() will take the x-value and instead of the output being between 0 and 600
    (the width of the display screen), it will be between 0 and 10, the range of levels
    we want to draw. So we assign that value to a variable called level and pass that
    value to the y() function in the next line.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们鼠标的 x 值可以是从 0 到窗口宽度之间的任何值。map() 函数将一个值范围转换为另一个范围。在 [清单 10-4](ch10.xhtml#ch10list4)
    中，map() 将取 x 值，并将其输出范围从 0 到 600（显示屏的宽度）转换为 0 到 10，这正是我们想要绘制的级别范围。所以我们将该值赋给一个名为
    level 的变量，并将其传递给 y() 函数的下一行。
- en: Now that we’ve tweaked the draw() function to return a value based on the position
    of the mouse, we can vary the shape of our tree by linking the y-coordinate of
    the mouse to the angle we’re rotating by.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经调整了 draw() 函数，使其根据鼠标的位置返回一个值，我们可以通过将鼠标的 y 坐标与旋转角度关联，来改变树的形状。
- en: The angle of rotation should only go up to 180 because the tree will “fold up”
    completely at 180 degrees, but the mouse’s y-value can go up to 600 since that’s
    the height of the screen we declared in setup(). We could do a little math to
    convert the values ourselves, but it would be easier to just use Processing’s
    built-in map() function. We tell the map() function what variable we want to map,
    specifying its current minimum and maximum values and the desired minimum and
    maximum values. The entire code for the Y fractal tree is shown in [Listing 10-5](ch10.xhtml#ch10list5).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转角度应该最大为180度，因为树木在180度时会“完全折叠”，但是鼠标的y值可以达到600，因为我们在setup()中声明了屏幕的高度。我们本可以自己做一些数学计算来转换这些值，但使用Processing的内置map()函数会更简单。我们告诉map()函数我们想要映射的变量，指定其当前的最小值和最大值以及所需的最小值和最大值。Y分形树的完整代码见[列表
    10-5](ch10.xhtml#ch10list5)。
- en: '*fractals.pyde*'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*fractals.pyde*'
- en: 'def setup():'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 'def setup():'
- en: size(600,600)
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: size(600,600)
- en: 'def draw():'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 'def draw():'
- en: background(255)
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: background(255)
- en: translate(300,500)
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: translate(300,500)
- en: level = int(map(mouseX,0,width,0,15))
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: level = int(map(mouseX,0,width,0,15))
- en: y(100,level)
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: y(100,level)
- en: 'def y(sz,level):'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 'def y(sz,level):'
- en: 'if level > 0:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 'if level > 0:'
- en: line(0,0,0,-sz)
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: line(0,0,0,-sz)
- en: translate(0,-sz)
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: translate(0,-sz)
- en: angle = map(mouseY,0,height,0,180)
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: angle = map(mouseY,0,height,0,180)
- en: rotate(radians(angle))
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: rotate(radians(angle))
- en: y(0.8*sz,level-1)
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: y(0.8*sz,level-1)
- en: rotate(radians(-2*angle))
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: rotate(radians(-2*angle))
- en: y(0.8*sz,level-1)
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: y(0.8*sz,level-1)
- en: rotate(radians(angle))
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: rotate(radians(angle))
- en: translate(0,sz)
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: translate(0,sz)
- en: '*Listing 10-5: The entire code to make a dynamic fractal tree*'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 10-5：制作动态分形树的完整代码*'
- en: We take the mouse’s y-value and convert it to a range between 0 and 180 (if
    you already think in radians, you can map it to between 0 and pi). In the rotate()
    lines, we give it that angle (which is in degrees) and have Processing convert
    the degrees to radians. The first rotate() line will rotate to the right. The
    second rotate() line will rotate a negative angle, meaning to the left. It’ll
    rotate twice as much to the left. Then the third rotate() line will rotate to
    the right again.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们取鼠标的y值，并将其转换为0到180之间的范围（如果你已经习惯用弧度思考，可以将其映射到0到pi之间）。在rotate()语句中，我们传入这个角度（单位为度），并让Processing将度数转换为弧度。第一条rotate()语句将旋转到右侧。第二条rotate()语句将旋转一个负角度，意味着向左旋转。它会向左旋转两倍的角度。然后，第三条rotate()语句将再次向右旋转。
- en: When you run the code, you should see something like [Figure 10-7](ch10.xhtml#ch10fig7).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行代码时，你应该看到类似于[图 10-7](ch10.xhtml#ch10fig7)的效果。
- en: '![image](../images/f208-01.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f208-01.jpg)'
- en: '*Figure 10-7: A dynamic fractal tree*'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-7：动态分形树*'
- en: Now when you move the mouse up or down, left or right, the level and shape of
    the fractal should change accordingly.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你上下、左右移动鼠标时，分形的级别和形状应该相应变化。
- en: Through drawing the fractal tree, you learned how to use recursion to draw complicated
    designs using a surprisingly small amount of code. Now we’ll return to the coastline
    problem. How could a coastline, or any line, double or triple in length just from
    getting more jagged?
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 通过绘制分形树，你学会了如何使用递归在非常少量的代码中绘制复杂的设计。现在我们将回到海岸线问题。如何通过增加锯齿状的曲折，使得海岸线或任何线条的长度翻倍或三倍？
- en: KOCH SNOWFLAKE
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 科赫雪花
- en: The Koch snowflake is a famous fractal named after Swedish mathematician Helge
    von Koch, who wrote about the shape in a paper in 1904! It’s made from an equilateral
    triangle. We start with a line and add a “bump” to it. Then, we add a smaller
    bump to each resulting line segment and repeat the process, like in [Figure 10-8](ch10.xhtml#ch10fig8).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 科赫雪花是一个著名的分形图形，得名于瑞典数学家Helge von Koch，他在1904年的一篇论文中描述了这个形状！它是由一个等边三角形构成的。我们从一条线开始，然后在其上添加一个“凸起”。接着，我们为每个结果线段添加一个更小的凸起并重复这个过程，就像[图
    10-8](ch10.xhtml#ch10fig8)中展示的那样。
- en: '![image](../images/f209-01.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f209-01.jpg)'
- en: '*Figure 10-8: Adding a “bump” to each segment*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-8：给每个线段添加一个“凸起”*'
- en: Let’s start a new Processing sketch, call it *snowflake.pyde*, and add the code
    in [Listing 10-6](ch10.xhtml#ch10list6), which will give us an upside-down equilateral
    triangle.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始一个新的Processing草图，命名为*snowflake.pyde*，并添加[列表 10-6](ch10.xhtml#ch10list6)中的代码，这将绘制一个倒立的等边三角形。
- en: '*snowflake.pyde*'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*snowflake.pyde*'
- en: 'def setup():'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 'def setup():'
- en: size(600,600)
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: size(600,600)
- en: 'def draw():'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 'def draw():'
- en: background(255)
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: background(255)
- en: translate(100,100)
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: translate(100,100)
- en: snowflake(400,1)
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: snowflake(400,1)
- en: 'def snowflake(sz,level):'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 'def snowflake(sz,level):'
- en: 'for i in range(3):'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(3):'
- en: line(0,0,sz,0)
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: line(0,0,sz,0)
- en: translate(sz,0)
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: translate(sz,0)
- en: rotate(radians(120))
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: rotate(radians(120))
- en: '*Listing 10-6: Writing the snowflake() function*'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 10-6：编写snowflake()函数*'
- en: 'In the draw() function, we call the snowflake() function, which for now takes
    only two parameters: sz (the size of the initial triangle) and level (the level
    of the fractal). The snowflake() function draws a triangle by starting a loop
    that repeats the code three times. Inside the loop we draw a line of length sz,
    which will be the side of the triangle, and then translate along the line to the
    next vertex of the triangle and rotate 120 degrees. Then we draw the next side
    of the triangle.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在draw()函数中，我们调用snowflake()函数，该函数目前只接受两个参数：sz（三角形的初始大小）和level（分形的级别）。snowflake()函数通过开始一个循环绘制一个三角形，该循环重复执行三次代码。在循环内部，我们绘制长度为sz的线段，这将是三角形的边，然后沿着该线段平移到三角形的下一个顶点并旋转120度。然后我们绘制三角形的下一条边。
- en: When you run the code in [Listing 10-6](ch10.xhtml#ch10list6), you should see
    [Figure 10-9](ch10.xhtml#ch10fig9).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行[清单10-6](ch10.xhtml#ch10list6)中的代码时，你应该看到[图10-9](ch10.xhtml#ch10fig9)。
- en: '![image](../images/f210-01.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f210-01.jpg)'
- en: '*Figure 10-9: Level 1 snowflake: a triangle*'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-9：级别1的雪花：一个三角形*'
- en: WRITING THE SEGMENT() FUNCTION
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编写SEGMENT()函数
- en: Now we need to tell the program how to change a line into a segment that will
    have different levels. Level 0 will just be a straight line, but the next level
    will introduce the “bump” in the side. We’re really dividing the segment into
    three segments and then taking the middle segment and replicating it to make it
    into a little equilateral triangle. We’ll change the snowflake() function to call
    another function to draw the segment. This will be the recursive function, because
    as the levels go up, the segments will become smaller copies of the segment in
    [Figure 10-10](ch10.xhtml#ch10fig10).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要告诉程序如何将一条线变成一个具有不同级别的线段。级别0只是一条直线，但下一个级别会在边上添加“凸起”。我们实际上是将线段分成三段，然后将中间段复制，使其成为一个小等边三角形。我们将修改snowflake()函数，调用另一个函数来绘制这段线段。这将是递归函数，因为随着级别的提高，线段将变成[图10-10](ch10.xhtml#ch10fig10)中线段的更小副本。
- en: '![image](../images/f210-02.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f210-02.jpg)'
- en: '*Figure 10-10: Cutting a segment into thirds and adding a “bump” to the middle
    third*'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-10：将一段线切成三等分，并在中间三分之一处添加一个“凸起”*'
- en: 'We’ll call the side a *segment*. If the level is 0, the segment is simply a
    straight line, the side of the triangle. In the next step, a bump is added in
    the middle of the side. All the segments in [Figure 10-10](ch10.xhtml#ch10fig10)
    are the same length, a third of the whole sidelength. This requires 11 steps:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将边称为*线段*。如果级别为0，则线段只是直线，即三角形的边。在下一步中，边的中间会添加一个凸起。[图10-10](ch10.xhtml#ch10fig10)中的所有线段长度相同，都是整个边长的三分之一。这个过程需要11步：
- en: Draw a line a third of the sidelength.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制三分之一的边长。
- en: Translate to the end of the segment you just drew.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 翻译到你刚刚绘制的线段的末尾。
- en: Rotate –60 degrees (to the left).
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 旋转-60度（向左）。
- en: Draw another segment.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制另一段线段。
- en: Translate to the end of that segment.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 翻译到该段落的末尾。
- en: Rotate 120 degrees (to the right).
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 旋转120度（向右）。
- en: Draw a third segment.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制第三段线段。
- en: Translate to the end of that segment.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 翻译到该段落的末尾。
- en: Rotate –60 degrees again (to the left).
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次旋转-60度（向左）。
- en: Draw the last segment.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制最后一段。
- en: Translate to the end of that segment.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 翻译到该段落的末尾。
- en: Now, instead of drawing a line, the snowflake() function will call a segment()
    function, which will do the drawing and translating. Add the segment() function
    in [Listing 10-7](ch10.xhtml#ch10list7).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，snowflake()函数不再绘制一条线，而是调用segment()函数，这个函数将进行绘制和平移。请在[清单10-7](ch10.xhtml#ch10list7)中添加segment()函数。
- en: '*snowflake.pyde*'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '*snowflake.pyde*'
- en: 'def snowflake(sz,level):'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 'def snowflake(sz,level):'
- en: 'for i in range(3):'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(3):'
- en: segment(sz,level)
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: segment(sz,level)
- en: rotate(radians(120))
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: rotate(radians(120))
- en: 'def segment(sz,level):'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 'def segment(sz,level):'
- en: 'if level == 0:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '如果级别 == 0:'
- en: line(0,0,sz,0)
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: line(0,0,sz,0)
- en: translate(sz,0)
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: translate(sz,0)
- en: 'else:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: line(0,0,sz/3.0,0)
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: line(0,0,sz/3.0,0)
- en: translate(sz/3.0,0)
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: translate(sz/3.0,0)
- en: rotate(radians(-60))
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: rotate(radians(-60))
- en: line(0,0,sz/3.0,0)
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: line(0,0,sz/3.0,0)
- en: translate(sz/3.0,0)
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: translate(sz/3.0,0)
- en: rotate(radians(120))
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: rotate(radians(120))
- en: line(0,0,sz/3.0,0)
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: line(0,0,sz/3.0,0)
- en: translate(sz/3.0,0)
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: translate(sz/3.0,0)
- en: rotate(radians(-60))
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: rotate(radians(-60))
- en: line(0,0,sz/3.0,0)
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: line(0,0,sz/3.0,0)
- en: translate(sz/3.0,0)
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: translate(sz/3.0,0)
- en: '*Listing 10-7: Drawing a “bump” on the sides of the triangle*'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单10-7：在三角形的边上绘制一个“凸起”*'
- en: In the segment() function, if the level is 0, it’s just a straight line, and
    we translate to the end of the line. Otherwise, we have 11 lines of code corresponding
    to the 11 steps of making a “bump.” First, we draw a line a third of the length
    of the side and then translate to the end of that line. We rotate left (–60 degrees)
    to draw the second segment in the line. That segment is also a third of the length
    of the side of the triangle. We translate to the end of that segment and then
    turn right by rotating 120 degrees. We then draw a segment and turn left one last
    time by rotating –60 degrees. Finally, we draw a fourth line (segment) and translate
    to the end of the side.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在`segment()`函数中，如果级别为0，它只是画一条直线，并且我们将其平移到该线的末端。否则，我们有11行代码对应于制作“凸起”的11个步骤。首先，我们画出三角形边长的三分之一的线段，然后将其平移到该线段的末端。我们向左旋转（–60度）画第二段线。该段的长度也是三角形边长的三分之一。我们将平移到该段的末端，然后向右旋转120度。接着我们画一段线，并最后一次通过旋转–60度向左转。最后，我们画第四条线段，并将其平移到边的末端。
- en: This draws a triangle if the level is 0 and puts a bump on each side if the
    level isn’t 0\. As you can see in [Figure 10-8](ch10.xhtml#ch10fig8), at every
    step, every segment in the previous step gets a bump. This would be a headache
    to do without recursion! But we’ll take the line of code that draws a line and
    change that into a segment, just one level lower. This is the recursive step.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果级别为0，则画出一个三角形，如果级别不为0，则在每条边上添加一个凸起。正如你在[图 10-8](ch10.xhtml#ch10fig8)中看到的那样，在每一步，前一步中的每个段落都会得到一个凸起。没有递归的话，做这个会让人头疼！但是我们会将绘制直线的代码行改成一个线段，只是级别低一个级别。这就是递归步骤。
- en: Next, we need to replace each line with a segment one level down, whose length
    is sz divided by 3\. The code for the segment() function is shown in [Listing
    10-8](ch10.xhtml#ch10list8).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将每条线替换为一个级别较低的线段，长度为sz除以3。`segment()`函数的代码见[列表 10-8](ch10.xhtml#ch10list8)。
- en: '*snowflake.pyde*'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '*snowflake.pyde*'
- en: 'def segment(sz,level):'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 'def segment(sz,level):'
- en: 'if level == 0:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 'if level == 0:'
- en: line(0,0,sz,0)
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: line(0,0,sz,0)
- en: translate(sz,0)
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: translate(sz,0)
- en: 'else:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: segment(sz/3.0,level-1)
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: segment(sz/3.0,level-1)
- en: rotate(radians(-60))
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: rotate(radians(-60))
- en: segment(sz/3.0,level-1)
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: segment(sz/3.0,level-1)
- en: rotate(radians(120))
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: rotate(radians(120))
- en: segment(sz/3.0,level-1)
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: segment(sz/3.0,level-1)
- en: rotate(radians(-60))
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: rotate(radians(-60))
- en: segment(sz/3.0,level-1)
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: segment(sz/3.0,level-1)
- en: '*Listing 10-8: Replacing the lines with segments*'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 10-8: 将线替换为线段*'
- en: So all we did was replace each instance of line in [Listing 10-7](ch10.xhtml#ch10list7)
    (whose level is greater than 0) with segment(). Because we don’t want to enter
    an infinite loop, the segments have to be one level down (level – 1) from the
    previous segment. Now we can change the level of the snowflake in the draw() function,
    as shown in the following code, and we’ll see different designs, as shown in [Figure
    10-11](ch10.xhtml#ch10fig11).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们所做的就是将[列表 10-7](ch10.xhtml#ch10list7)中每个line的实例（其级别大于0）替换为segment()。因为我们不想进入无限循环，段落必须比前一段低一个级别（level
    – 1）。现在我们可以在`draw()`函数中更改雪花的级别，如下所示的代码所示，并且我们将看到不同的设计，正如[图 10-11](ch10.xhtml#ch10fig11)所示。
- en: 'def draw():'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 'def draw():'
- en: background(255)
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: background(255)
- en: translate(100,height-100)
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: translate(100,height-100)
- en: snowflake(400,3)
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: snowflake(400,3)
- en: '![image](../images/f212--01.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f212--01.jpg)'
- en: '*Figure 10-11: A level 3 snowflake*'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-11: 三级雪花*'
- en: 'Even better, we can make it interactive by mapping the mouse’s x-value to the
    level. The mouse’s x-value can be anywhere from 0 to whatever the width of the
    screen is. We want to change that range to between 0 and 7\. Here’s the code for
    that:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的是，我们可以通过将鼠标的x值映射到级别来使其具有交互性。鼠标的x值可以从0到屏幕的宽度。我们想要将这个范围更改为0到7之间。以下是实现这一点的代码：
- en: level = map(mouseX,0,width,0,7)
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: level = map(mouseX,0,width,0,7)
- en: 'However, we want only integer levels, so we’ll change that value to an integer
    using int, like this:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们只想要整数级别，所以我们将使用`int`将该值转换为整数，像这样：
- en: level = int(map(mouseX,0,width,0,7))
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: level = int(map(mouseX,0,width,0,7))
- en: We’ll add that to our draw() function and send the output “level” to the snowflake()
    function. The entire code for the Koch snowflake is shown in [Listing 10-9](ch10.xhtml#ch10list9).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将其添加到我们的`draw()`函数中，并将输出的“level”传递给`snowflake()`函数。科赫雪花的完整代码见[列表 10-9](ch10.xhtml#ch10list9)。
- en: '*snowflake.pyde*'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '*snowflake.pyde*'
- en: 'def setup():'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 'def setup():'
- en: size(600,600)
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: size(600,600)
- en: 'def draw():'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 'def draw():'
- en: background(255)
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: background(255)
- en: translate(100,200)
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: translate(100,200)
- en: level = int(map(mouseX,0,width,0,7))
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: level = int(map(mouseX,0,width,0,7))
- en: '#y(100,level)'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '#y(100,level)'
- en: snowflake(400,level)
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: snowflake(400,level)
- en: 'def snowflake(sz,level):'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 'def snowflake(sz,level):'
- en: 'for i in range(3):'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(3):'
- en: segment(sz,level)
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: segment(sz,level)
- en: rotate(radians(120))
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: rotate(radians(120))
- en: 'def segment(sz,level):'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 'def segment(sz,level):'
- en: 'if level == 0:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 'if level == 0:'
- en: line(0,0,sz,0)
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: line(0,0,sz,0)
- en: translate(sz,0)
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: translate(sz,0)
- en: 'else:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: segment(sz/3.0,level-1)
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: segment(sz/3.0,level-1)
- en: rotate(radians(-60))
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: rotate(radians(-60))
- en: segment(sz/3.0,level-1)
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: segment(sz/3.0,level-1)
- en: rotate(radians(120))
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: rotate(radians(120))
- en: segment(sz/3.0,level-1)
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: segment(sz/3.0,level-1)
- en: rotate(radians(-60))
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: rotate(radians(-60))
- en: segment(sz/3.0,level-1)
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: segment(sz/3.0,level-1)
- en: '*Listing 10-9: Complete code for the Koch snowflake*'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 10-9：Koch 雪花的完整代码*'
- en: Now when you run the program and move your mouse left and right, you’ll see
    the snowflake get more “bumps” on its segments, like in [Figure 10-12](ch10.xhtml#ch10fig12).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你运行程序并左右移动鼠标时，你会看到雪花的各个段落上出现更多的“凸起”，就像在[图 10-12](ch10.xhtml#ch10fig12)中所示。
- en: '![image](../images/f213-01.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f213-01.jpg)'
- en: '*Figure 10-12: A level 7 snowflake*'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-12：7级雪花*'
- en: How does this help us understand the Coastline Paradox? Looking back at [Figure
    10-3](ch10.xhtml#ch10fig3), let’s call the length of the line (the side of the
    triangle) 1 unit (for example, 1 mile). When we split it in thirds, take out the
    middle, and add a “bump” two thirds long in the middle, the side is now 1 1/3
    units long. It just got 1/3 longer, right? The perimeter of the snowflake (the
    “coastline”) gets 1/3 longer every step. So at the *n*th step, the length of the
    coastline is (4/3)^(*n*) times the perimeter of the original triangle. It might
    not be possible to see, but after 20 steps, the coastline of the snowflake is
    so jagged that its total length is over 300 times the original measurement!
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这如何帮助我们理解海岸线悖论呢？回顾[图 10-3](ch10.xhtml#ch10fig3)，我们把线段的长度（即三角形的一边）设为 1 个单位（例如
    1 英里）。当我们将其分为三等份，去掉中间部分，并在中间加上一个长度为三分之二的“凸起”时，边长变成了 1 1/3 个单位。它刚刚变长了三分之一，对吧？雪花的周长（即“海岸线”）每一步都变长三分之一。因此，在第
    *n* 步时，海岸线的长度是原始三角形周长的 (4/3)^(*n*) 倍。虽然可能不容易察觉，但经过 20 步后，雪花的海岸线已经如此锯齿状，以至于其总长度是原始测量值的
    300 多倍！
- en: SIERPINSKI TRIANGLE
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SIERPINSKI 三角形
- en: 'The Sierpinski triangle is a famous fractal first described by Polish mathematician
    Wacław Sierpiński in 1915, but there are examples of the design on the floors
    of churches in Italy from as far back as the 11th century! It follows a geometric
    pattern that’s easy to describe, but the design is surprisingly complicated. It
    works on an interesting recursive idea: draw a triangle for the first level, and
    for the next level turn each triangle into three smaller triangles at its corners,
    as shown in [Figure 10-13](ch10.xhtml#ch10fig13).'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: Sierpinski 三角形是一个著名的分形，最早由波兰数学家 Wacław Sierpiński 在 1915 年描述，但在意大利的教堂地板上，从 11
    世纪起就有这种设计的例子！它遵循一种几何模式，描述起来很简单，但设计却出奇复杂。它基于一个有趣的递归思想：在第一层画一个三角形，在下一层将每个三角形的角落转变为三个更小的三角形，如[图
    10-13](ch10.xhtml#ch10fig13)所示。
- en: '![image](../images/f214-01.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f214-01.jpg)'
- en: '*Figure 10-13: Sierpinski triangles, levels 0, 1, and 2*'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-13：Sierpinski 三角形，第 0、1 和 2 级*'
- en: 'The first step is easy: just draw a triangle. Open a new sketch and name it
    *sierpinski.pyde*. We set it up as usual, with setup() and draw() functions. In
    setup(), we set the size of the output window to 600 pixels by 600 pixels. In
    draw(), we set the background white and translate to a point (50,450) in the bottom
    left of the screen to start drawing our triangle. Next, we write a function named
    sierpinski(), similar to what we did with tree(), that draws a triangle if the
    level is 0\. The code so far is shown in [Listing 10-10](ch10.xhtml#ch10list10).'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步很简单：只需要画一个三角形。打开一个新的草图并命名为 *sierpinski.pyde*。我们像往常一样设置它，包括 setup() 和 draw()
    函数。在 setup() 中，我们将输出窗口的大小设置为 600 像素 × 600 像素。在 draw() 中，我们设置背景为白色，并将坐标系平移到屏幕左下角的
    (50,450) 点开始绘制三角形。接下来，我们写一个名为 sierpinski() 的函数，类似于我们在 tree() 中做的，如果级别是 0，就绘制一个三角形。目前为止的代码如[列表
    10-10](ch10.xhtml#ch10list10)所示。
- en: '*sierpinski.pyde*'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '*sierpinski.pyde*'
- en: 'def setup():'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 'def setup():'
- en: size(600,600)
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: size(600,600)
- en: 'def draw():'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 'def draw():'
- en: background(255)
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: background(255)
- en: translate(50,450)
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: translate(50,450)
- en: sierpinski(400,0)
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: sierpinski(400,0)
- en: 'def sierpinski(sz, level):'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 'def sierpinski(sz, level):'
- en: 'if level == 0: #draw a black triangle'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 'if level == 0: #画一个黑色三角形'
- en: fill(0)
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: fill(0)
- en: triangle(0,0,sz,0,sz/2.0,-sz*sqrt(3)/2.0)
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: triangle(0,0,sz,0,sz/2.0,-sz*sqrt(3)/2.0)
- en: '*Listing 10-10: The setup of the Sierpinski fractal*'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 10-10：Sierpinski 分形的设置*'
- en: 'The sierpinski() function takes two parameters: the size of the figure (sz)
    and the level variable. The fill color is 0 for black, but you can make it any
    color you want by using RGB values. The triangle line contains six numbers: the
    x- and y-coordinates of the three corners of an equilateral triangle with sidelength
    sz.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: sierpinski() 函数接受两个参数：图形的大小 (sz) 和级别 (level) 变量。填充颜色为 0，表示黑色，但你可以使用 RGB 值来设置为任何颜色。三角形的线包含六个数字：等边三角形三个角的
    x 和 y 坐标，边长为 sz。
- en: As you can see in [Figure 10-13](ch10.xhtml#ch10fig13), level 1 contains three
    triangles at each corner of the original triangle. These triangles are also half
    the size of the triangle in the previous level. What we’ll do is create a smaller,
    lower-level Sierpinski triangle, translate to the next corner, and then rotate
    120 degrees. Add the code in [Listing 10-11](ch10.xhtml#ch10list11) to the sierpinski()
    function.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在 [Figure 10-13](ch10.xhtml#ch10fig13) 中看到的，级别 1 包含了原三角形每个角上的三个小三角形。这些三角形的大小是上一级三角形的一半。我们将做的是创建一个较小的、较低级别的谢尔宾斯基三角形，平移到下一个角，并旋转
    120 度。将 [Listing 10-11](ch10.xhtml#ch10list11) 中的代码添加到 sierpinski() 函数中。
- en: 'def draw():'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 'def draw():'
- en: background(255)
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: background(255)
- en: translate(50,450)
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: translate(50,450)
- en: sierpinski(400,8)
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: sierpinski(400,8)
- en: 'def sierpinski(sz, level):'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 'def sierpinski(sz, level):'
- en: 'if level == 0: #draw a black triangle'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 'if level == 0: # 绘制一个黑色三角形'
- en: fill(0)
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: fill(0)
- en: triangle(0,0,sz,0,sz/2.0,-sz*sqrt(3)/2.0)
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: triangle(0,0,sz,0,sz/2.0,-sz*sqrt(3)/2.0)
- en: 'else: #draw sierpinskis at each vertex'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 'else: # 在每个顶点绘制谢尔宾斯基三角形'
- en: 'for i in range(3):'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(3):'
- en: sierpinski(sz/2.0,level-1)
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: sierpinski(sz/2.0,level-1)
- en: translate(sz/2.0,-sz*sqrt(3)/2.0)
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: translate(sz/2.0,-sz*sqrt(3)/2.0)
- en: rotate(radians(120))
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: rotate(radians(120))
- en: '*Listing 10-11: Adding the recursive step to the Sierpinski program*'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 10-11: 为谢尔宾斯基程序添加递归步骤*'
- en: 'This new code tells Processing what to do when the level isn’t 0 (the line
    for i in range(3): means “repeat this three times”): draw a half-sized Sierpinski
    triangle of one level lower, and then translate halfway across and halfway up
    the equilateral triangle and turn right 120 degrees. Notice the sierpinski() function
    in sierpinski(sz/2.0,level-1) is executed inside the definition of the sierpinski()
    function itself. That’s the recursive step! When you call'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '这段新代码告诉 Processing 在级别不为 0 时该做什么（i in range(3): 意味着“重复三次”）：绘制一个半尺寸的谢尔宾斯基三角形，级别比当前低一级，然后平移到等边三角形的中点并旋转
    120 度。注意在 sierpinski(sz/2.0,level-1) 中执行了 sierpinski() 函数，这就是递归步骤！当你调用'
- en: sierpinski(400,8)
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: sierpinski(400,8)
- en: '![image](../images/f215-01.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f215-01.jpg)'
- en: '*Figure 10-14: A level 8 Sierpinski triangle*'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '*Figure 10-14: 8 级谢尔宾斯基三角形*'
- en: in the draw() function, you get a level 8 Sierpinski triangle, which you see
    in [Figure 10-14](ch10.xhtml#ch10fig14).
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在 draw() 函数中，你将得到一个 8 级谢尔宾斯基三角形，正如 [Figure 10-14](ch10.xhtml#ch10fig14) 所示。
- en: An interesting thing about the Sierpinski triangle is that it shows up in other
    fractals too, like the next one, which doesn’t start with a triangle.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 关于谢尔宾斯基三角形，一个有趣的现象是它也出现在其他分形中，像下一个分形，尽管它并不是以三角形为起点。
- en: '### SQUARE FRACTAL'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '### 正方形分形'
- en: We can make the Sierpinski triangle out of squares too. For example, we can
    create a square, remove the lower-right quadrant, and then replace each remaining
    quadrant with the resulting shape. When we repeat this process, we should get
    something like [Figure 10-15](ch10.xhtml#ch10fig15).
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以用正方形来创建谢尔宾斯基三角形。例如，我们可以创建一个正方形，去掉右下角的四分之一部分，然后用得到的形状替换其余的四分之一部分。当我们重复这个过程时，应该会得到类似于
    [Figure 10-15](ch10.xhtml#ch10fig15) 的图形。
- en: '![image](../images/f216--01.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f216--01.jpg)'
- en: '*Figure 10-15: The square fractal at levels 0, 1, 2, and 3*'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '*Figure 10-15: 正方形分形在级别 0、1、2 和 3 的表现*'
- en: To create this fractal, we have to make each of the three smaller squares into
    a copy of the whole. Start a new Processing sketch called *squareFractal.pyde*
    and then set up the sketch with the code in [Listing 10-12](ch10.xhtml#ch10list12).
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建这个分形，我们需要将三个较小的正方形每个都变成整个图形的一个副本。启动一个新的 Processing 草图，命名为 *squareFractal.pyde*，然后用
    [Listing 10-12](ch10.xhtml#ch10list12) 中的代码设置草图。
- en: '*squareFractal.pyde*'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '*squareFractal.pyde*'
- en: 'def setup():'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 'def setup():'
- en: size(600,600)
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: size(600,600)
- en: 'fill(150,0,150) #purple'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 'fill(150,0,150) # 紫色'
- en: noStroke()
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: noStroke()
- en: 'def draw():'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 'def draw():'
- en: background(255)
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: background(255)
- en: translate(50,50)
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: translate(50,50)
- en: squareFractal(500,0)
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: squareFractal(500,0)
- en: 'def squareFractal(sz,level):'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 'def squareFractal(sz,level):'
- en: 'if level == 0:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 'if level == 0:'
- en: rect(0,0,sz,sz)
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: rect(0,0,sz,sz)
- en: '*Listing 10-12: Creating the squareFractal() function*'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 10-12: 创建 squareFractal() 函数*'
- en: '![image](../images/f216--02.jpg)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f216--02.jpg)'
- en: '*Figure 10-16: Purple square (level 0)*'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '*Figure 10-16: 紫色正方形（级别 0）*'
- en: We can use the RGB values for purple in the setup() function just because we
    won’t be changing the fill anywhere else. We use noStroke() so that we won’t see
    black outlines on the squares. In the draw() function we call the squareFractal()
    function, telling it to make the size of each square 500 pixels and level 0\.
    In the function definition, we tell the program to simply draw a square if the
    level is zero. This should give us a nice big purple square, as shown in [Figure
    10-16](ch10.xhtml#ch10fig16).
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在setup()函数中使用紫色的RGB值，因为我们在其他地方不会更改填充颜色。我们使用noStroke()，这样就看不见方块的黑色轮廓。在draw()函数中，我们调用squareFractal()函数，告诉它将每个方块的大小设置为500像素，层级为0。在函数定义中，我们告诉程序如果层级为零，就简单地绘制一个方块。这应该会给我们一个漂亮的大紫色方块，如[图10-16](ch10.xhtml#ch10fig16)所示。
- en: For the next level, we’ll make squares of half the sidelength of the initial
    square. One will be positioned at the top left of the figure; then we’ll translate
    around to put the other two squares at the bottom left and top right of [Figure
    10-16](ch10.xhtml#ch10fig16). [Listing 10-13](ch10.xhtml#ch10list13) does this
    while leaving out a quarter of the big square.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 对于下一层，我们将创建初始方块边长的一半的方块。其中一个将位于图形的左上角；然后我们将进行平移，将另外两个方块放在左下角和右上角，如[图10-16](ch10.xhtml#ch10fig16)所示。[示例10-13](ch10.xhtml#ch10list13)执行了这个操作，同时将大方块的四分之一去掉。
- en: '*squareFractal.pyde*'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '*squareFractal.pyde*'
- en: 'def squareFractal(sz,level):'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 'def squareFractal(sz,level):'
- en: 'if level == 0:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 'if level == 0:'
- en: rect(0,0,sz,sz)
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: rect(0,0,sz,sz)
- en: 'else:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: rect(0,0,sz/2.0,sz/2.0)
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: rect(0,0,sz/2.0,sz/2.0)
- en: translate(sz/2.0,0)
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: translate(sz/2.0,0)
- en: rect(0,0,sz/2.0,sz/2.0)
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: rect(0,0,sz/2.0,sz/2.0)
- en: translate(-sz/2.0,sz/2.0)
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: translate(-sz/2.0,sz/2.0)
- en: rect(0,0,sz/2.0,sz/2.0)
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: rect(0,0,sz/2.0,sz/2.0)
- en: '*Listing 10-13: Adding more squares to the square fractal*'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例10-13：向方块分形添加更多方块*'
- en: Here, we draw a big square if the level is 0\. If the level is not 0, we add
    a smaller square in the top left of the screen, translate to the right, add another
    smaller square in the top right, translate left (negative x) and down (positive
    y), and add a smaller square at the bottom left of the screen.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，如果层级为0，我们绘制一个大方块。如果层级不是0，我们在屏幕的左上角添加一个较小的方块，接着向右平移，添加另一个较小的方块在右上角，然后向左（负x方向）和平移向下（正y方向），并在屏幕左下角添加一个较小的方块。
- en: That’s the next level, and when we update squareFractal(500,0) in the draw()
    function to squareFractal(500,1), it should give us a square with the bottom-right
    quarter left out, as shown in [Figure 10-17](ch10.xhtml#ch10fig17).
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 这是下一层，当我们在draw()函数中将squareFractal(500,0)更新为squareFractal(500,1)时，它应该给我们一个没有右下四分之一的方块，如[图10-17](ch10.xhtml#ch10fig17)所示。
- en: '![image](../images/f217-01.jpg)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f217-01.jpg)'
- en: '*Figure 10-17: The next level of the square fractal*'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-17：方块分形的下一层*'
- en: For the next levels, we want each of the squares to be further subdivided into
    fractals, so we’ll replace the rect lines with squareFractal(), divide the value
    in sz by 2, and tell it to move one level down, like in [Listing 10-14](ch10.xhtml#ch10list14).
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 对于下一层，我们希望每个方块都进一步细分为分形，因此我们将rect行替换为squareFractal()，将sz的值除以2，并告诉它降一级，就像在[示例10-14](ch10.xhtml#ch10list14)中那样。
- en: '*squareFractal.pyde*'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '*squareFractal.pyde*'
- en: 'def squareFractal(sz,level):'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 'def squareFractal(sz,level):'
- en: 'if level == 0:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 'if level == 0:'
- en: rect(0,0,sz,sz)
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: rect(0,0,sz,sz)
- en: 'else:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: squareFractal(sz/2.0,level-1)
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: squareFractal(sz/2.0,level-1)
- en: translate(sz/2.0,0)
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: translate(sz/2.0,0)
- en: squareFractal(sz/2.0,level-1)
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: squareFractal(sz/2.0,level-1)
- en: translate(-sz/2.0,sz/2.0)
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: translate(-sz/2.0,sz/2.0)
- en: squareFractal(sz/2.0,level-1)
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: squareFractal(sz/2.0,level-1)
- en: '*Listing 10-14: Adding the recursive step to the square fractal*'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例10-14：向方块分形添加递归步骤*'
- en: '![image](../images/f218-01.jpg)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f218-01.jpg)'
- en: '*Figure 10-18: Not what we were expecting!*'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-18：不是我们预期的结果！*'
- en: In [Listing 10-14](ch10.xhtml#ch10list14), notice that the rect lines (when
    the level isn’t 0) are replaced with squareFractal(). When we call squareFractal(500,2)
    in the draw() function, we don’t get the output we were expecting—we get [Figure
    10-18](ch10.xhtml#ch10fig18) instead.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例10-14](ch10.xhtml#ch10list14)中，注意到rect行（当层级不是0时）被squareFractal()替换。当我们在draw()函数中调用squareFractal(500,2)时，我们没有得到预期的输出，而是得到了[图10-18](ch10.xhtml#ch10fig18)。
- en: This is because we didn’t translate back to the starting point like we did with
    our Y fractal earlier in the chapter.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们没有像本章前面所做的那样，将平移操作恢复到起始点。
- en: Although we can calculate how much to translate manually, we can also use the
    pushMatrix() and popMatrix() functions in Processing, which you learned about
    in [Chapter 5](ch05.xhtml#ch05).
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以手动计算平移量，但我们也可以在Processing中使用pushMatrix()和popMatrix()函数，你在[第5章](ch05.xhtml#ch05)中已经学过这些。
- en: We can use the pushMatrix() function to save the current orientation of the
    screen—that is, where the origin (0,0) is located and how much the grid is rotated.
    After that, we can do as much translating and rotating as we like and then use
    the popMatrix() function to return to the saved orientation without any calculating!
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用pushMatrix()函数保存当前屏幕的方向——也就是原点(0,0)的位置以及网格的旋转角度。之后，我们可以任意进行平移和旋转，最后使用popMatrix()函数恢复到之前保存的方向，而无需进行任何计算！
- en: Let’s add pushMatrix() at the beginning of the squareFractal() function and
    popMatrix() at the end, like in [Listing 10-15](ch10.xhtml#ch10list15).
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在squareFractal()函数的开头添加pushMatrix()，并在结尾添加popMatrix()，就像[列表10-15](ch10.xhtml#ch10list15)中一样。
- en: '*squareFractal.pyde*'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '*squareFractal.pyde*'
- en: 'def squareFractal(sz,level):'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 'def squareFractal(sz,level):'
- en: 'if level == 0:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 'if level == 0:'
- en: rect(0,0,sz,sz)
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: rect(0,0,sz,sz)
- en: 'else:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: pushMatrix()
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: pushMatrix()
- en: squareFractal(sz/2.0,level-1)
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: squareFractal(sz/2.0,level-1)
- en: translate(sz/2.0,0)
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: translate(sz/2.0,0)
- en: squareFractal(sz/2.0,level-1)
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: squareFractal(sz/2.0,level-1)
- en: translate(-sz/2.0,sz/2.0)
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: translate(-sz/2.0,sz/2.0)
- en: squareFractal(sz/2.0,level-1)
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: squareFractal(sz/2.0,level-1)
- en: popMatrix()
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: popMatrix()
- en: '*Listing 10-15: Using pushMatrix() and popMatrix() to complete the squares*'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表10-15：使用pushMatrix()和popMatrix()完成方形分形*'
- en: Now, each of the smaller squares from level 1 should be transformed into a fractal,
    with the bottom-right square removed, as shown in [Figure 10-19](ch10.xhtml#ch10fig19).
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，第1层中的每个小方形都应该转变为一个分形，右下角的方形被去除，正如[图10-19](ch10.xhtml#ch10fig19)所示。
- en: '![image](../images/f219-01.jpg)'
  id: totrans-360
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f219-01.jpg)'
- en: '*Figure 10-19: Level 2 of the square fractal*'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-19：方形分形的第2层*'
- en: Now let’s try making our mouse generate the level numbers like we’ve done before
    by replacing squareFractal(500,2) with the code in [Listing 10-16](ch10.xhtml#ch10list16).
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试通过将squareFractal(500,2)替换为[列表10-16](ch10.xhtml#ch10list16)中的代码，让鼠标生成层数。
- en: '*squareFractal.pyde*'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '*squareFractal.pyde*'
- en: 'def draw():'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 'def draw():'
- en: background(255)
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: background(255)
- en: translate(50,50)
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: translate(50,50)
- en: level = int(map(mouseX,0,width,0,7))
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: level = int(map(mouseX,0,width,0,7))
- en: squareFractal(500,level)
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: squareFractal(500,level)
- en: '*Listing 10-16: Making the square fractal interactive*'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表10-16：让方形分形变得交互式*'
- en: At higher levels, the square fractal looks a lot like the Sierpinski triangle,
    as you can see in [Figure 10-20](ch10.xhtml#ch10fig20)!
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在更高层次中，方形分形看起来很像谢尔宾斯基三角形，正如你在[图10-20](ch10.xhtml#ch10fig20)中所看到的那样！
- en: '![image](../images/f219-02.jpg)'
  id: totrans-371
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f219-02.jpg)'
- en: '*Figure 10-20: High-level square fractals look like the Sierpinski triangle!*'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-20：高层次的方形分形看起来像谢尔宾斯基三角形！*'
- en: '### DRAGON CURVE'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '### 龙曲线'
- en: The final fractal we’ll create looks different from the others we’ve created
    so far in that the shapes on each level don’t get smaller, they get bigger. [Figure
    10-21](ch10.xhtml#ch10fig21) shows an example of the dragon curve for levels 0
    through 3.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要创建的最终分形与之前创建的其他分形有所不同，因为每一层的形状不是变小，而是变大。[图10-21](ch10.xhtml#ch10fig21)展示了龙曲线从第0层到第3层的例子。
- en: '![image](../images/f220-01.jpg)'
  id: totrans-375
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f220-01.jpg)'
- en: '*Figure 10-21: The first four levels of the dragon curve*'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-21：龙曲线的前四个层次*'
- en: As mathematical entertainer Vi Hart shows in one of her YouTube videos, the
    second half of the dragon curve is a perfect copy of the first half, and she models
    it by folding and then unfolding pieces of paper. The third level (level 2) in
    [Figure 10-21](ch10.xhtml#ch10fig21) looks like two left turns followed by a right
    turn. The “hinge” or “fold” is at the midpoint of each dragon curve. See if you
    can find it in your dragon curves! Later, you’ll rotate part of the curve dynamically
    to match the next-level curve.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 正如数学娱乐家Vi Hart在她的一段YouTube视频中展示的那样，龙曲线的后半部分是前半部分的完美复制，她通过折叠然后展开纸片来模拟这一过程。[图10-21](ch10.xhtml#ch10fig21)中的第三层（level
    2）看起来像是两个左转后接一个右转。每条龙曲线的“铰链”或“折叠”位于曲线的中点。看看你能不能在你的龙曲线中找到它！接下来，你将动态地旋转曲线的一部分，以匹配下一层的曲线。
- en: Open a new Processing sketch and name it *dragonCurve.pyde*. To create this
    fractal, we first create a function for the “left dragon,” as in [Listing 10-17](ch10.xhtml#ch10list17).
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个新的Processing草图，并命名为*dragonCurve.pyde*。为了创建这个分形，我们首先创建一个“左龙”的函数，就像[列表10-17](ch10.xhtml#ch10list17)中所示。
- en: '*dragonCurve.pyde*'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '*dragonCurve.pyde*'
- en: 'def setup():'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 'def setup():'
- en: size(600,600)
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: size(600,600)
- en: 'strokeWeight(2) #a little thicker lines'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 'strokeWeight(2) #稍微加粗的线条'
- en: 'def draw():'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 'def draw():'
- en: background(255)
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: background(255)
- en: translate(width/2,height/2)
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: translate(width/2,height/2)
- en: leftDragon(5,11)
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: leftDragon(5,11)
- en: 'def leftDragon(sz,level):'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 'def leftDragon(sz,level):'
- en: 'if level == 0:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 'if level == 0:'
- en: line(0,0,sz,0)
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: line(0,0,sz,0)
- en: translate(sz,0)
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: translate(sz,0)
- en: 'else:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: leftDragon(sz,level-1)
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: leftDragon(sz,level-1)
- en: rotate(radians(-90))
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: rotate(radians(-90))
- en: rightDragon(sz,level-1)
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: rightDragon(sz,level-1)
- en: '*Listing 10-17: Writing the leftDragon() function*'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 10-17: 编写 leftDragon() 函数*'
- en: After the usual setup() and draw() functions, we define our leftDragon() function.
    If the level is 0, we just draw a line and then translate along the line. It’s
    kind of like the turtle from [Chapter 1](ch01.xhtml#ch01) drawing a line as it
    walks along. If the level is greater than 0, make a left dragon (one level down),
    turn left 90 degrees, and make a right dragon (one level down).
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在常规的 setup() 和 draw() 函数之后，我们定义了我们的 leftDragon() 函数。如果 level 为 0，我们只需画一条线，然后沿线平移。这有点像
    [第 1 章](ch01.xhtml#ch01) 中的海龟在行进时画线。如果 level 大于 0，先画一个左龙（降一级），然后左转 90 度，画一个右龙（降一级）。
- en: Now we’ll make the “right dragon” function (see [Listing 10-18](ch10.xhtml#ch10list18)).
    It’s pretty similar to the leftDragon() function. If the level is 0, simply draw
    a line and move along it. Otherwise, make a left dragon, and this time turn *right*
    90 degrees and make a right dragon.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将创建 “右龙” 函数（见 [Listing 10-18](ch10.xhtml#ch10list18)）。它与 leftDragon() 函数非常相似。如果
    level 为 0，只需画一条线并沿着它移动。否则，先画一个左龙，然后这次右转 90 度，画一个右龙。
- en: '*dragonCurve.pyde*'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '*dragonCurve.pyde*'
- en: 'def rightDragon(sz,level):'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 'def rightDragon(sz,level):'
- en: 'if level == 0:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 level == 0:'
- en: line(0,0,sz,0)
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: line(0,0,sz,0)
- en: translate(sz,0)
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: translate(sz,0)
- en: 'else:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '否则:'
- en: leftDragon(sz,level-1)
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: leftDragon(sz,level-1)
- en: rotate(radians(90))
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: rotate(radians(90))
- en: rightDragon(sz,level-1)
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: rightDragon(sz,level-1)
- en: '*Listing 10-18: Writing the rightDragon() function*'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 10-18: 编写 rightDragon() 函数*'
- en: It’s interesting that the recursive statement in this case is not only inside
    one function, but it also jumps back and forth from the left dragon function to
    the right dragon function! Execute it, and the 11th level will look like [Figure
    10-22](ch10.xhtml#ch10fig22).
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，这里的递归语句不仅存在于一个函数内，而且还在左龙函数和右龙函数之间来回跳跃！执行它，第 11 级的图形将像[图 10-22](ch10.xhtml#ch10fig22)一样。
- en: '![image](../images/f221-01.jpg)'
  id: totrans-409
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f221-01.jpg)'
- en: '*Figure 10-22: A level 11 dragon curve*'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '*Figure 10-22: 第 11 级龙曲线*'
- en: Far from being simply a chaotic jumble of angles, this fractal starts to look
    like a dragon after enough levels! Remember I said the dragon curve is “folded”
    in the middle? In the version shown in [Listing 10-19](ch10.xhtml#ch10list19),
    I’ve added a few variables to change the level and the size, and I made an angle
    variable change with the mouse’s x-coordinate. This will rotate a dragon curve
    around a “hinge” in the middle of the next-level dragon curve. See how you can
    simply rotate the curve to get both halves of the next-level curve!
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 这条分形曲线远不只是一个混乱的角度堆砌，经过足够的层级，它开始看起来像一条龙！还记得我说过龙曲线在中间是“折叠”的吗？在[Listing 10-19](ch10.xhtml#ch10list19)中，我添加了一些变量来改变层级和大小，并且让我添加了一个角度变量，该变量根据鼠标的
    x 坐标发生变化。这将使龙曲线绕着“铰链”旋转，铰链位于下一层龙曲线的中间。看看如何通过简单地旋转曲线来得到下一层曲线的两个半部分！
- en: '*dragonCurve.pyde*'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '*dragonCurve.pyde*'
- en: ➊ RED = color(255,0,0)
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ RED = color(255,0,0)
- en: BLACK = color(0)
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: BLACK = color(0)
- en: 'def setup():'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 'def setup():'
- en: ➋ global thelevel,size1
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ global thelevel,size1
- en: size(600,600)
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: size(600,600)
- en: ➌ thelevel = 1
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ thelevel = 1
- en: size1 = 40
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: size1 = 40
- en: 'def draw():'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 'def draw():'
- en: global thelevel
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: global thelevel
- en: background(255)
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: background(255)
- en: translate(width/2,height/2)
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: translate(width/2,height/2)
- en: ➍ angle = map(mouseX,0,width,0,2*PI)
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ angle = map(mouseX,0,width,0,2*PI)
- en: stroke(RED)
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: stroke(RED)
- en: strokeWeight(3)
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: strokeWeight(3)
- en: pushMatrix()
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: pushMatrix()
- en: leftDragon(size1,thelevel)
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: leftDragon(size1,thelevel)
- en: popMatrix()
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: popMatrix()
- en: leftDragon(size1,thelevel-1)
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: leftDragon(size1,thelevel-1)
- en: ➎ rotate(angle)
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ rotate(angle)
- en: stroke(BLACK)
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: stroke(BLACK)
- en: rightDragon(size1,thelevel-1)
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: rightDragon(size1,thelevel-1)
- en: 'def leftDragon(sz,level):'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 'def leftDragon(sz,level):'
- en: 'if level == 0:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 level == 0:'
- en: line(0,0,sz,0)
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: line(0,0,sz,0)
- en: translate(sz,0)
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: translate(sz,0)
- en: 'else:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '否则:'
- en: leftDragon(sz,level-1)
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: leftDragon(sz,level-1)
- en: rotate(radians(-90))
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: rotate(radians(-90))
- en: rightDragon(sz,level-1)
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: rightDragon(sz,level-1)
- en: 'def rightDragon(sz,level):'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 'def rightDragon(sz,level):'
- en: 'if level == 0:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 level == 0:'
- en: line(0,0,sz,0)
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: line(0,0,sz,0)
- en: translate(sz,0)
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: translate(sz,0)
- en: 'else:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '否则:'
- en: leftDragon(sz,level-1)
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: leftDragon(sz,level-1)
- en: rotate(radians(90))
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: rotate(radians(90))
- en: rightDragon(sz,level-1)
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: rightDragon(sz,level-1)
- en: 'def keyPressed():'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 'def keyPressed():'
- en: global thelevel,size1
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: global thelevel,size1
- en: '➏ if key == CODED:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '➏ 如果 key == CODED:'
- en: 'if keyCode == UP:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 keyCode == UP:'
- en: thelevel += 1
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: thelevel += 1
- en: 'if keyCode == DOWN:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 keyCode == DOWN:'
- en: thelevel -= 1
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: thelevel -= 1
- en: 'if keyCode == LEFT:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 keyCode == LEFT:'
- en: size1 -= 5
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: size1 -= 5
- en: 'if keyCode == RIGHT:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 keyCode == RIGHT:'
- en: size1 += 5
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: size1 += 5
- en: '*Listing 10-19: A dynamic dragon curve*'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 10-19: 一个动态的龙曲线*'
- en: In [Listing 10-19](ch10.xhtml#ch10list19), we add a couple of colors ➊ to use
    for the curves. In the setup() function, we declare two global variables, thelevel
    and size1 ➋, whose initial values we declare at ➌ and which we change with the
    arrow keys in the keyPressed() function at the end of the file.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [清单 10-19](ch10.xhtml#ch10list19) 中，我们添加了几种颜色 ➊ 用于曲线。在 setup() 函数中，我们声明了两个全局变量，`thelevel`
    和 `size1` ➋，并在 ➌ 处声明了它们的初始值，随后在文件末尾的 keyPressed() 函数中通过箭头键来更改它们。
- en: In the draw() function, we link an angle variable ➍ to the x-position of the
    mouse. After that, we set the stroke color to red, make the stroke weight a little
    heavier, and draw a left dragon with the initial values of thelevel and size1.
    The pushMatrix() and popMatrix() functions, as you’ll remember, simply return
    the drawing point to the original spot, to draw another curve. Then we rotate
    the grid by however many radians the angle variable is ➎, and draw another dragon
    curve, in black. The leftDragon() and rightDragon() functions are exactly the
    same as before.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 在 draw() 函数中，我们将一个角度变量 ➍ 与鼠标的 x 坐标关联。之后，我们将描边颜色设置为红色，稍微加大描边宽度，并用 `thelevel`
    和 `size1` 的初始值绘制一个左龙曲线。你会记得，pushMatrix() 和 popMatrix() 函数仅仅是将绘图点恢复到原来的位置，以便绘制另一条曲线。然后，我们将网格旋转角度变量所表示的弧度
    ➎，并绘制另一条黑色的龙曲线。leftDragon() 和 rightDragon() 函数与之前完全相同。
- en: Processing’s built-in keyPressed() function could come in handy for changing
    variables in a sketch! All you have to do is declare the global variables you
    want to change with the left (in this case), right, up, and down arrow keys on
    the keyboard. Note that CODED ➏ just means it’s not a letter or character key.
    Finally, it checks which arrow key is being pressed and makes the level variable
    go up or down (if the up or down arrow key is being pressed) or the size variable
    go up or down (if the left or right arrow key is being pressed).
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: Processing 内置的 keyPressed() 函数对于在草图中更改变量非常有用！你只需要声明你想要通过键盘上的左（在此情况下）、右、上和下箭头键来更改的全局变量。请注意，CODED
    ➏ 只是表示它不是字母或字符键。最后，程序会检查哪个箭头键被按下，并根据按下的上或下箭头键使 `level` 变量增加或减少，或者根据按下的左或右箭头键使
    `size` 变量增加或减少。
- en: When you run this version of the *dragonCurve* sketch, it draws a dragon curve
    at level 5 in red; then you can rotate a level 4 curve and see how the level 5
    curve is made up of two level 4’s, just rotated in the middle, as shown in [Figure
    10-23](ch10.xhtml#ch10fig23).
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个版本的 *dragonCurve* 草图时，它会绘制一个五级的红色龙曲线；然后你可以旋转一个四级曲线，看到五级曲线由两个四级曲线组成，只是中间进行了旋转，正如
    [图 10-23](ch10.xhtml#ch10fig23) 所示。
- en: '![image](../images/f223-01.jpg)'
  id: totrans-466
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f223-01.jpg)'
- en: '*Figure 10-23: A level 5 dragon curve and a dynamic, interactive level 4 curve*'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-23：一个五级龙曲线和一个动态的、互动的四级曲线*'
- en: When you move the mouse, the black dragon curve should rotate, and you can see
    how it fits both halves of the red curve. The up and down arrow keys control the
    level of the curve; press the up arrow key and the curve gets longer. If the curve
    extends off the display window, use the left arrow key to make each segment shorter,
    so it’ll fit on the screen. The right arrow key makes it bigger.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 当你移动鼠标时，黑色的龙曲线会旋转，你可以看到它如何适应红色曲线的两半。上下箭头键控制曲线的级别；按下上箭头键，曲线变长。如果曲线超出了显示窗口，可以按左箭头键将每个段缩短，以使其适应屏幕。右箭头键使其变大。
- en: 'This makes sense, because the leftDragon() function comes first, turns left,
    and makes a right dragon curve. The rightDragon() function just turns the opposite
    way from leftDragon(): it makes a right turn in the middle instead of a left.
    No wonder it turns out to be a perfect copy.'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 这很有道理，因为 leftDragon() 函数先执行，向左转，绘制一个右龙曲线。而 rightDragon() 函数则与 leftDragon() 相反：它在中间向右转，而不是向左转。难怪它会变成一个完美的复制。
- en: SUMMARY
  id: totrans-470
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: We’ve only scratched the surface of fractals, but hopefully you got a taste
    of how beautiful fractals can be and how powerful they are at modeling the messiness
    of nature. Fractals and recursion can help us reevaluate our ideas about logic
    and measurement. The question is no longer “how long is the coastline?” but rather
    “how jagged is it?”
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是刚刚触及分形的表面，但希望你已经领略到了分形的美丽，以及它们在模拟自然的复杂性方面的强大能力。分形和递归可以帮助我们重新审视关于逻辑和度量的观念。问题不再是“海岸线有多长？”而是“它有多么曲折？”
- en: For fractal lines like coastlines and meandering rivers, the standard characteristic
    is the scale of self-similarity, or how much we have to scale the map up by before
    it looks like a different scale of the same thing. This is effectively what you
    did by feeding 0.8*sz, sz/2.0, or sz/3.0 into the next level.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像海岸线和蜿蜒河流这样的分形线条，标准特征是自相似的尺度，或者我们需要将地图缩放多少，才能使其看起来像是同一事物的不同尺度。这实际上就是你通过输入0.8*sz、sz/2.0或sz/3.0到下一个层级所做的。
- en: In the next chapter, we’ll create cellular automata (CAs), which we’ll draw
    as little squares on the screen that are born, grow, and respond to their surroundings.
    Just like with our grass-eating sheep in [Chapter 9](ch09.xhtml#ch09), we’ll create
    CAs and let them run—and just like with fractals, we’ll watch the surprising and
    beautiful patterns that are created from very simple rules.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将创建细胞自动机（CAs），我们将在屏幕上绘制它们，作为小方块，它们会诞生、成长并响应周围的环境。就像在[第9章](ch09.xhtml#ch09)中我们的吃草的羊一样，我们将创建CAs并让它们运行——就像分形一样，我们将观察从非常简单的规则中产生的惊人而美丽的图案。
