- en: '10'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '10'
- en: CREATING FRACTALS USING RECURSION
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用递归创建分形
- en: '*What’s another word for* thesaurus*?'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*“thesaurus”的另一个词是什么？*'
- en: —Steven Wright*
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: — 史蒂文·赖特*
- en: '![image](../images/fintro-01.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fintro-01.jpg)'
- en: Fractals are delightfully complicated designs, where each smaller part of the
    design contains the entire design (see [Figure 10-1](ch10.xhtml#ch10fig1)). They
    were invented (or discovered, since fractals exist in nature) by Benoit Mandelbrot
    in 1980 when he was visualizing some complex functions on a state-of-the-art IBM
    computer.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 分形是令人愉快的复杂设计，其中设计的每个小部分都包含了整个设计（参见[图 10-1](ch10.xhtml#ch10fig1)）。它们由贝努瓦·曼德布罗特于1980年发明（或者说是发现，因为分形在自然界中存在），当时他在一台先进的IBM计算机上可视化一些复杂函数。
- en: '![image](../images/f201-01.jpg)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f201-01.jpg)'
- en: '*Figure 10-1: Examples of fractals*'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-1：分形的例子*'
- en: Fractals don’t look like regular shapes we recognize from geometry, like squares,
    triangles, and circles. Their shapes are crooked and jagged, making them great
    models for simulating natural phenomena. In fact, scientists use fractals to model
    everything from the arteries in your heart, to earthquakes, to neurons in your
    brain.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 分形看起来不像我们在几何学中认识的常规形状，比如正方形、三角形和圆形。它们的形状曲折且 jagged（锯齿状），使得它们成为模拟自然现象的绝佳模型。实际上，科学家使用分形来模拟从你心脏的动脉，到地震，再到大脑中的神经元等一切。
- en: What makes fractals so interesting is that they illustrate how you can get surprisingly
    complex designs from simple rules being run over and over and patterns being repeated
    at smaller and smaller scale.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 分形之所以如此有趣，是因为它们展示了如何通过简单的规则反复运行，以及模式在更小尺度上不断重复，从而获得出乎意料的复杂设计。
- en: Our main interest is the interesting, complicated designs you can make using
    fractals. There’s a picture of a fractal in every math book these days, but textbooks
    never show you how to make one—you need a computer to do that. In this chapter,
    you learn how to make your own fractals using Python.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的主要兴趣是你可以用分形制作的那些有趣且复杂的设计。如今每本数学书中都有分形的图像，但教科书从不告诉你如何制作分形——你需要计算机来做这件事。在本章中，你将学习如何使用
    Python 创建自己的分形。
- en: THE LENGTH OF A COASTLINE
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 海岸线的长度
- en: Before you can start creating fractals, let’s look at a simple example to understand
    how fractals can be useful. A mathematician named Lewis Richardson asked a simple
    question; “How long is the coastline of England?” As you can see in [Figure 10-2](ch10.xhtml#ch10fig2),
    the answer depends on how long your ruler is.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始创建分形之前，让我们看一个简单的例子，帮助理解分形如何有用。一位数学家名叫路易斯·理查森提出了一个简单的问题：“英国的海岸线有多长？”正如你在[图
    10-2](ch10.xhtml#ch10fig2)中看到的，答案取决于你使用的尺子的长度。
- en: '![image](../images/f202-01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f202-01.jpg)'
- en: '*Figure 10-2: Approximating the length of a coastline*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-2：逼近海岸线长度*'
- en: The smaller your ruler, the more closely you can approximate the coastline’s
    jagged edges, which means you’ll end up with a longer measurement. The cool thing
    is that *the length of the coastline approaches infinity as the length of the
    ruler gets close to zero!* This is known as the Coastline Paradox.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你的尺子越小，你就能越精确地逼近海岸线的曲折边缘，这意味着你最终得到的测量值会更长。有趣的是，*当尺子的长度接近零时，海岸线的长度接近无限大！* 这被称为海岸线悖论。
- en: Think this is just abstract mathematical noodling? Coastline length estimates
    can vary wildly in the real world. Even with modern technology, it all depends
    on the scale used to measure the map. We’ll draw a figure like [Figure 10-3](ch10.xhtml#ch10fig3),
    the Koch snowflake, to show how a fractal can prove a rough enough coastline can
    get as long as you want!
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 认为这只是抽象的数学胡思乱想？在现实世界中，海岸线的长度估算差异很大。即使是现代技术，最终还是取决于用来测量地图的尺度。我们将绘制一幅像[图 10-3](ch10.xhtml#ch10fig3)这样的图，科赫雪花，以展示分形如何证明一个足够粗糙的海岸线可以变得任意长！
- en: '![image](../images/f203-01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f203-01.jpg)'
- en: '*Figure 10-3: An increasingly detailed fractal, modeling an increasingly rough
    coastline*'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-3：一个越来越详细的分形，模拟一个越来越崎岖的海岸线*'
- en: First, you’re going to need to learn a few tricks, like recursion.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要学习一些技巧，比如递归。
- en: WHAT IS RECURSION?
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 递归是什么？
- en: 'The power of fractals is that you can repeat patterns of numbers or shapes
    that get smaller at every step until you’re dealing with very small numbers. The
    key to repeating all this code is a concept called *recursion*, which is when
    something is defined in terms of itself. Some of these jokes illustrate how recursion
    works:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 分形的强大之处在于你可以重复数值或形状的模式，每一步都会变得更小，直到你处理的是非常小的数字。重复这些代码的关键是一个叫做*递归*的概念，它是指某事物以自身为定义的方式进行描述。以下一些笑话说明了递归的工作原理：
- en: If you google “recursion,” it asks you, “Did you mean *recursion*?”
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你在谷歌中搜索“递归”，它会问你：“你是想搜*递归*吗？”
- en: 'In the index to more than one computer programming book, there’s an entry like
    this: “recursion, see *recursion*.”'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多本计算机编程书籍的索引中，你会看到类似这样的条目：“递归，见*递归*。”
- en: As you can imagine, recursion is a pretty strange concept. The virtue of recursion
    is that it can tidy up code that would otherwise be too complicated, but the disadvantage
    is that you can end up using up too much memory.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可以想象的，递归是一个相当奇怪的概念。递归的优点是它能够简化本来过于复杂的代码，但缺点是你可能会用尽过多的内存。
- en: WRITING THE FACTORIAL() FUNCTION
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编写`factorial()`函数
- en: Let’s see recursion in action by writing a function for the factorial of a number.
    You may recall from math class that the *factorial* of *n* (expressed as *n!*)
    is defined as the product of all the integers from 1 to *n*. For example, 5! =
    1 × 2 × 3 × 4 × 5 = 120.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过编写一个计算数字阶乘的函数来观察递归的实际应用。你可能还记得数学课上，*n*的阶乘（表示为*n!*）被定义为从1到*n*的所有整数的乘积。例如，5!
    = 1 × 2 × 3 × 4 × 5 = 120。
- en: 'The formula looks like this: *n*! = 1 × 2 × 3 . . . × (*n* – 2) × (*n* – 1)
    × *n*. This is an example of a recursive sequence, because 5! = 5 × 4! and 4!
    = 4 × 3!, and so on. Recursion is an important concept in math because math is
    all about patterns, and recursion allows you to copy and extend patterns infinitely!'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 公式看起来像这样：*n*! = 1 × 2 × 3 . . . × (*n* – 2) × (*n* – 1) × *n*。这是递归序列的一个例子，因为5!
    = 5 × 4!，4! = 4 × 3!，依此类推。递归是数学中的一个重要概念，因为数学本质上是关于模式的，而递归使你能够无限地复制和扩展模式！
- en: We can define the factorial of n as the product of n and the factorial of n
    – 1\. We just have to define the factorial of 0 (which is 1, not 0) and the factorial
    of 1 and then use a recursive statement. Open a new file in IDLE, save it as *factorial.py*,
    and then enter with the code in [Listing 10-1](ch10.xhtml#ch10list1).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将n的阶乘定义为n与n – 1的阶乘的乘积。我们只需要定义0的阶乘（它是1，而不是0）和1的阶乘，然后使用递归语句。在IDLE中打开一个新文件，保存为*factorial.py*，然后输入[清单10-1](ch10.xhtml#ch10list1)中的代码。
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 10-1: Using a recursive statement to write the `factorial()` function*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单10-1：使用递归语句编写`factorial()`函数*'
- en: First, we’re saying, “If the user (or the program) asks for the factorial of
    0 or 1, return 1.” This is because 0! and 1! both equal 1\. Then we tell the program,
    “For any other number *n*, return *n* times the factorial of the number 1 less
    than *n*.”
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们说：“如果用户（或程序）请求0或1的阶乘，返回1。”这是因为0!和1!都等于1。然后我们告诉程序，“对于任何其他数字*n*，返回*n*乘以比*n*小1的数字的阶乘。”
- en: Notice that on the last line of [Listing 10-1](ch10.xhtml#ch10list1), we’re
    calling the `factorial()` function *inside* the definition of the `factorial()`
    function! That’s like a recipe for a loaf of bread containing the step “Bake a
    loaf of bread.” People wouldn’t even begin following a recipe written like that.
    But computers can start going through the steps and follow them throughout the
    process.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在[清单10-1](ch10.xhtml#ch10list1)的最后一行，我们在定义`factorial()`函数时*内部*调用了`factorial()`函数！这就像是一个面包食谱，里面有“烤一个面包”这样的步骤。人们根本不会开始按照这样的食谱去做。但是计算机可以从头到尾地执行这些步骤。
- en: In this example, when we ask for the factorial of 5, the program proceeds obediently
    and makes it to the last line, where it asks for the factorial of *n* – 1, which
    in this case (because *n* = 5) is the factorial of 4\. To calculate factorial
    (5 – 1), the program starts the `factorial()` function again with *n* = 4 and
    tries to evaluate the factorial of 4 the same way, followed by the factorial of
    3, the factorial of 2, the factorial of 1, and finally the factorial of 0\. Because
    we already defined the function to return the factorial of 0 as 1, the function
    can go back up through the process, evaluating the factorial of 1, then 2, then
    3, then 4, and finally 5.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当我们请求5的阶乘时，程序会顺从地执行，直到最后一行，它请求*n* – 1的阶乘，在这种情况下（因为*n* = 5），就是4的阶乘。为了计算阶乘（5
    – 1），程序会再次启动`factorial()`函数，*n* = 4，并试图以相同的方式计算4的阶乘，然后是3的阶乘、2的阶乘、1的阶乘，最后是0的阶乘。因为我们已经定义了函数将0的阶乘返回为1，所以函数可以按照顺序回到上一步，计算1的阶乘、2的阶乘、3的阶乘、4的阶乘，最后是5的阶乘。
- en: 'Defining a function recursively (by calling the function inside its own definition)
    might seem confusing, but it’s the key to making all the fractals in this chapter.
    Let’s start with a classic: the fractal tree.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 递归地定义一个函数（通过在其自身定义中调用该函数）可能会让人感到困惑，但它是本章所有分形图案的关键。我们从一个经典的例子开始：分形树。
- en: BUILDING A FRACTAL TREE
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 构建一个分形树
- en: Making a fractal starts with defining a simple function and adding a call to
    the function inside the function itself. Let’s try building a fractal tree that
    looks like [Figure 10-4](ch10.xhtml#ch10fig4).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 创建分形图形从定义一个简单的函数开始，并在函数内部调用该函数。让我们尝试构建一个像[图10-4](ch10.xhtml#ch10fig4)一样的分形树。
- en: '![image](../images/f204-01.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f204-01.jpg)'
- en: '*Figure 10-4: A fractal tree*'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-4：一棵分形树*'
- en: This would be an incredibly complicated design to create if you had to tell
    the program every line to draw. But it takes surprisingly little code if you use
    recursion. Using translations, rotations, and the `line()` function, we’ll first
    draw a Y in Processing, as shown in [Figure 10-5](ch10.xhtml#ch10fig5).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要告诉程序每一条要画的线，这将是一个非常复杂的设计。但如果使用递归，这所需的代码 surprisingly 少。通过平移、旋转和`line()`函数，我们将在Processing中首先绘制一个Y形，如[图10-5](ch10.xhtml#ch10fig5)所示。
- en: '![image](../images/f205-01.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f205-01.jpg)'
- en: '*Figure 10-5: The beginnings of a fractal tree*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-5：分形树的初步形态*'
- en: The only requirement to eventually make this Y into a fractal is that after
    the program draws the Y tree, along with the branches, the program has to return
    to the bottom of the “trunk.” This is because the “branches” are going to become
    Y’s themselves. If the program doesn’t return to the bottom of the Y every time,
    we won’t get our tree.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 最终将这个Y形转变为分形的唯一要求是，在程序绘制完Y树和分支后，程序必须返回到“树干”的底部。因为“分支”将会变成Y形本身。如果程序每次不返回到Y的底部，我们就无法得到树的结构。
- en: WRITING THE Y() FUNCTION
  id: totrans-43
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 编写`y()`函数
- en: Your Y doesn’t have to be perfect or symmetrical, but here’s my code for drawing
    a Y. Open a new sketch in Processing, name it *fractals.pyde*, and enter the code
    in [Listing 10-2](ch10.xhtml#ch10list2).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你的Y形不必完美或对称，但这是我绘制Y形的代码。打开Processing中新建一个草图，将其命名为*fractals.pyde*，并输入[清单10-2](ch10.xhtml#ch10list2)中的代码。
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 10-2: Writing the `y()` function for the fractal tree*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单10-2：编写用于分形树的`y()`函数*'
- en: 'We set up the Processing sketch the way we always do: in the `setup()` function
    we tell the program what size to make the display window, and then in the `draw()`
    function we set the background color (255 is white) and translate to where we
    want to start drawing. Finally, we call the `y()` function and pass the number
    100 for the size of the “trunk” of the fractal tree.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们像往常一样设置Processing草图：在`setup()`函数中告诉程序显示窗口的大小，然后在`draw()`函数中设置背景色（255为白色）并进行平移，确定绘制起始点。最后，我们调用`y()`函数并传递数字100作为分形树“树干”的大小。
- en: The `y()` function takes a number `sz` as a parameter to be the length of the
    trunk of the tree. Then all the branches will be based on that number. The first
    line of code in the `y()` function draws the trunk of the tree using a vertical
    line. To create a line branching off to the right, we translate the vertical line
    up the trunk of the tree (in the negative y-direction) and then rotate it 30 degrees
    to the right. Next, we draw another line for the right branch, rotate to the left
    (negative 60 degrees), and draw another line for the left branch. Finally, we
    have to rotate so we’re facing straight up again so that we can translate down
    the trunk again. Save and run this sketch, and you should see the Y in [Figure
    10-5](ch10.xhtml#ch10fig5).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`y()`函数接受一个数字`sz`作为参数，表示树干的长度。然后，所有分支将基于这个数字。`y()`函数中的第一行代码使用垂直线绘制树干。为了创建一条向右分叉的线，我们将垂直线沿着树干（负y方向）平移，然后将其向右旋转30度。接下来，我们绘制另一条右分支的线，再将其旋转到左侧（负60度），并绘制另一条左分支的线。最后，我们需要旋转回直立的方向，以便再次沿着树干向下平移。保存并运行这个草图，你应该能够看到[图10-5](ch10.xhtml#ch10fig5)中的Y形。'
- en: 'We can convert this program that draws a single Y into one that draws a fractal
    by making the branches into *smaller* Y’s. But if we simply replace “line” with
    “y” in the `y()` function, our program will get stuck in an infinite loop, throwing
    an error like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将分支变成*更小*的Y形状，将这个绘制单一Y的程序转换为绘制分形的程序。但是，如果我们仅仅在`y()`函数中将“line”替换为“y”，程序就会陷入无限循环，抛出类似这样的错误：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Recall that we didn’t call `factorial(n)` inside the factorial function but
    rather called `factorial(n-1)`. We have to introduce a `level` parameter to the
    `y()` function. Then each branch up, the tree will be a level down, so the branch
    will get the parameter `level – 1`. This means the trunk is always the highest
    numbered level and the last set of branches up the tree is always level 0\. Here’s
    how to change the `y()` function in [Listing 10-3](ch10.xhtml#ch10list3).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，我们在阶乘函数中并没有直接调用 `factorial(n)`，而是调用了 `factorial(n-1)`。我们必须在 `y()` 函数中引入一个
    `level` 参数。然后，每向上分支一次，树的级别就会下降一级，因此该分支将获得 `level - 1` 参数。这意味着树干总是最高编号的级别，树上最后一组分支总是级别
    0。下面是如何更改 [Listing 10-3](ch10.xhtml#ch10list3) 中的 `y()` 函数。
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 10-3: Adding recursion to the `y()` function*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 10-3: 向 `y()` 函数添加递归*'
- en: Notice that we replaced all the `line()` functions in the code with `y()` functions
    to draw the branches. Because we changed the call to the `y()` function in `draw()`
    to `y(100,2)`, we’ll get a tree of trunk size 100 with two levels. Try a three-level
    tree, a four-level one, and so on! You should see something like [Figure 10-6](ch10.xhtml#ch10fig6).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们已经将代码中所有的 `line()` 函数替换为 `y()` 函数来绘制分支。因为我们将 `draw()` 函数中的 `y()` 调用改为 `y(100,2)`，所以我们将得到一个树干大小为
    100 且有两个级别的树。试试三级树，四级树，依此类推！你应该能看到类似 [Figure 10-6](ch10.xhtml#ch10fig6) 的效果。
- en: '![image](../images/f207-01.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f207-01.jpg)'
- en: '*Figure 10-6: Trees of levels 1 through 4*'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*Figure 10-6: 1 到 4 级的树*'
- en: Mapping the Mouse
  id: totrans-57
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 映射鼠标
- en: Now let’s make a program that allows you to control the shape of the fractal
    in real time, just by moving your mouse up or down! We can vary the level of rotation
    dynamically by tracking the mouse and returning a value between 0 and 10 based
    on its location. Update the `draw()` function with the code in [Listing 10-4](ch10.xhtml#ch10list4).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个程序，允许你通过上下移动鼠标实时控制分形的形状！我们可以通过追踪鼠标并根据其位置返回一个 0 到 10 之间的值，动态地改变旋转的级别。用
    [Listing 10-4](ch10.xhtml#ch10list4) 中的代码更新 `draw()` 函数。
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 10-4: Adding the `level` parameter to the `draw()` function*'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 10-4: 向 `draw()` 函数添加 `level` 参数*'
- en: Our mouse’s x-value can be anywhere between 0 and the width of the window. The
    `map()` function replaces one range of values with another. In [Listing 10-4](ch10.xhtml#ch10list4),
    `map()` will take the x-value and instead of the output being between 0 and 600
    (the width of the display screen), it will be between 0 and 10, the range of levels
    we want to draw. So we assign that value to a variable called `level` and pass
    that value to the `y()` function in the next line.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的鼠标 x 值可以在 0 和窗口宽度之间的任何地方。`map()` 函数将一个范围的值替换为另一个范围的值。在 [Listing 10-4](ch10.xhtml#ch10list4)
    中，`map()` 会将 x 值转换为 0 到 10 之间的值，而不是 0 到 600（显示屏的宽度），这是我们希望绘制的级别范围。所以我们将该值分配给一个名为
    `level` 的变量，并将该值传递给下一行中的 `y()` 函数。
- en: Now that we’ve tweaked the `draw()` function to return a value based on the
    position of the mouse, we can vary the shape of our tree by linking the y-coordinate
    of the mouse to the angle we’re rotating by.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经调整了 `draw()` 函数，使其根据鼠标的位置返回一个值，我们可以通过将鼠标的 y 坐标与旋转角度关联，来改变树的形状。
- en: The angle of rotation should only go up to 180 because the tree will “fold up”
    completely at 180 degrees, but the mouse’s y-value can go up to 600 since that’s
    the height of the screen we declared in `setup()`. We could do a little math to
    convert the values ourselves, but it would be easier to just use Processing’s
    built-in `map()` function. We tell the `map()` function what variable we want
    to map, specifying its current minimum and maximum values and the desired minimum
    and maximum values. The entire code for the Y fractal tree is shown in [Listing
    10-5](ch10.xhtml#ch10list5).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转角度应该限制在 180 度以内，因为树木在 180 度时会“完全折叠”，但是鼠标的 y 值可以达到 600，因为这是我们在 `setup()` 中声明的屏幕高度。我们可以做一些数学运算来自己转换这些值，但直接使用
    Processing 内置的 `map()` 函数会更简单。我们告诉 `map()` 函数我们想要映射的变量，指定它的当前最小值和最大值，以及所需的最小值和最大值。Y
    分形树的完整代码显示在 [Listing 10-5](ch10.xhtml#ch10list5) 中。
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 10-5: The entire code to make a dynamic fractal tree*'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 10-5: 创建动态分形树的完整代码*'
- en: We take the mouse’s y-value and convert it to a range between 0 and 180 (if
    you already think in radians, you can map it to between 0 and pi). In the `rotate()`
    lines, we give it that angle (which is in degrees) and have Processing convert
    the degrees to radians. The first `rotate()` line will rotate to the right. The
    second `rotate()` line will rotate a negative angle, meaning to the left. It’ll
    rotate twice as much to the left. Then the third `rotate()` line will rotate to
    the right again.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们取鼠标的y值，并将其转换为0到180之间的范围（如果你已经习惯使用弧度，则可以将其映射到0到π之间）。在`rotate()`行中，我们为其指定该角度（以度为单位），并让Processing将度数转换为弧度。第一行`rotate()`将向右旋转。第二行`rotate()`将旋转一个负角度，也就是向左旋转两倍。然后第三行`rotate()`将再次向右旋转。
- en: When you run the code, you should see something like [Figure 10-7](ch10.xhtml#ch10fig7).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行代码时，你应该看到类似于[图 10-7](ch10.xhtml#ch10fig7)的内容。
- en: '![image](../images/f208-01.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f208-01.jpg)'
- en: '*Figure 10-7: A dynamic fractal tree*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-7：动态分形树*'
- en: Now when you move the mouse up or down, left or right, the level and shape of
    the fractal should change accordingly.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你上下、左右移动鼠标时，分形的级别和形状应该会相应地改变。
- en: Through drawing the fractal tree, you learned how to use recursion to draw complicated
    designs using a surprisingly small amount of code. Now we’ll return to the coastline
    problem. How could a coastline, or any line, double or triple in length just from
    getting more jagged?
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 通过绘制分形树，你学会了如何使用递归绘制复杂的设计，而仅需写非常少的代码。现在，我们将回到海岸线问题。海岸线或任何线条，如何通过变得更崎岖而使长度加倍或加三倍呢？
- en: KOCH SNOWFLAKE
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 科赫雪花
- en: The Koch snowflake is a famous fractal named after Swedish mathematician Helge
    von Koch, who wrote about the shape in a paper in 1904! It’s made from an equilateral
    triangle. We start with a line and add a “bump” to it. Then, we add a smaller
    bump to each resulting line segment and repeat the process, like in [Figure 10-8](ch10.xhtml#ch10fig8).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 科赫雪花（Koch snowflake）是一个著名的分形，得名于瑞典数学家赫尔格·冯·科赫（Helge von Koch），他在1904年发表的论文中讨论了这一形状！它由一个等边三角形构成。我们从一条线开始，并为其添加一个“突起”。然后，我们在每个结果线段上添加一个更小的突起，并重复这一过程，如[图
    10-8](ch10.xhtml#ch10fig8)所示。
- en: '![image](../images/f209-01.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f209-01.jpg)'
- en: '*Figure 10-8: Adding a “bump” to each segment*'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-8：为每个线段添加“突起”*'
- en: Let’s start a new Processing sketch, call it *snowflake.pyde*, and add the code
    in [Listing 10-6](ch10.xhtml#ch10list6), which will give us an upside-down equilateral
    triangle.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始一个新的Processing草图，命名为*snowflake.pyde*，并添加[清单 10-6](ch10.xhtml#ch10list6)中的代码，这将给我们一个倒置的等边三角形。
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 10-6: Writing the `snowflake()` function*'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-6：编写`snowflake()`函数*'
- en: 'In the `draw()` function, we call the `snowflake()` function, which for now
    takes only two parameters: `sz` (the size of the initial triangle) and `level`
    (the level of the fractal). The `snowflake()` function draws a triangle by starting
    a loop that repeats the code three times. Inside the loop we draw a line of length
    `sz`, which will be the side of the triangle, and then translate along the line
    to the next vertex of the triangle and rotate 120 degrees. Then we draw the next
    side of the triangle.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在`draw()`函数中，我们调用了`snowflake()`函数，目前该函数仅接受两个参数：`sz`（初始三角形的大小）和`level`（分形的级别）。`snowflake()`函数通过启动一个循环绘制三角形，这个循环重复三次。在循环内部，我们绘制一条长度为`sz`的线段，它将是三角形的一边，然后沿着这条线段平移到三角形的下一个顶点并旋转120度。然后，我们绘制三角形的下一条边。
- en: When you run the code in [Listing 10-6](ch10.xhtml#ch10list6), you should see
    [Figure 10-9](ch10.xhtml#ch10fig9).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行[清单 10-6](ch10.xhtml#ch10list6)中的代码时，你应该能看到[图 10-9](ch10.xhtml#ch10fig9)。
- en: '![image](../images/f210-01.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f210-01.jpg)'
- en: '*Figure 10-9: Level 1 snowflake: a triangle*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-9：级别1雪花：一个三角形*'
- en: WRITING THE SEGMENT() FUNCTION
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编写`SEGMENT()`函数
- en: Now we need to tell the program how to change a line into a segment that will
    have different levels. Level 0 will just be a straight line, but the next level
    will introduce the “bump” in the side. We’re really dividing the segment into
    three segments and then taking the middle segment and replicating it to make it
    into a little equilateral triangle. We’ll change the `snowflake()` function to
    call another function to draw the segment. This will be the recursive function,
    because as the levels go up, the segments will become smaller copies of the segment
    in [Figure 10-10](ch10.xhtml#ch10fig10).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要告诉程序如何将一条线变成具有不同级别的线段。级别0时只是直线，但下一级别会在边上添加“凸起”。我们实际上是将线段分成三等分，然后将中间的线段复制，使它变成一个小等边三角形。我们将修改`snowflake()`函数，调用另一个函数来绘制线段。这将是递归函数，因为随着级别的增加，线段会变成图[10-10](ch10.xhtml#ch10fig10)中更小的线段副本。
- en: '![image](../images/f210-02.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f210-02.jpg)'
- en: '*Figure 10-10: Cutting a segment into thirds and adding a “bump” to the middle
    third*'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-10：将线段分成三等分，并在中间三分之一处添加一个“凸起”*'
- en: 'We’ll call the side a *segment*. If the level is 0, the segment is simply a
    straight line, the side of the triangle. In the next step, a bump is added in
    the middle of the side. All the segments in [Figure 10-10](ch10.xhtml#ch10fig10)
    are the same length, a third of the whole sidelength. This requires 11 steps:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将边称为*线段*。如果级别是0，线段仅仅是一条直线，即三角形的边。在下一步中，我们在边的中间添加一个凸起。图[10-10](ch10.xhtml#ch10fig10)中的所有线段长度相同，为整个边长的三分之一。这需要11个步骤：
- en: Draw a line a third of the sidelength.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制一条边长三分之一的线段。
- en: Translate to the end of the segment you just drew.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 平移到你刚才绘制的线段的末端。
- en: Rotate –60 degrees (to the left).
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 旋转–60度（向左）。
- en: Draw another segment.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制另一个线段。
- en: Translate to the end of that segment.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 平移到该线段的末端。
- en: Rotate 120 degrees (to the right).
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 旋转120度（向右）。
- en: Draw a third segment.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制第三个线段。
- en: Translate to the end of that segment.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 平移到该线段的末端。
- en: Rotate –60 degrees again (to the left).
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次旋转–60度（向左）。
- en: Draw the last segment.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制最后一个线段。
- en: Translate to the end of that segment.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 平移到该线段的末端。
- en: Now, instead of drawing a line, the `snowflake()` function will call a `segment()`
    function, which will do the drawing and translating. Add the `segment()` function
    in [Listing 10-7](ch10.xhtml#ch10list7).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们不再画直线，而是调用`snowflake()`函数中的`segment()`函数，这个函数将完成绘制和移动操作。在[清单10-7](ch10.xhtml#ch10list7)中添加`segment()`函数。
- en: '[PRE7]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 10-7: Drawing a “bump” on the sides of the triangle*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单10-7：在三角形的边上绘制一个“凸起”*'
- en: In the `segment()` function, if the level is 0, it’s just a straight line, and
    we translate to the end of the line. Otherwise, we have 11 lines of code corresponding
    to the 11 steps of making a “bump.” First, we draw a line a third of the length
    of the side and then translate to the end of that line. We rotate left (–60 degrees)
    to draw the second segment in the line. That segment is also a third of the length
    of the side of the triangle. We translate to the end of that segment and then
    turn right by rotating 120 degrees. We then draw a segment and turn left one last
    time by rotating –60 degrees. Finally, we draw a fourth line (segment) and translate
    to the end of the side.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在`segment()`函数中，如果级别为0，它就是一条直线，然后我们平移到该直线的末端。否则，我们有11行代码，对应着制作“凸起”的11个步骤。首先，我们画一条边长三分之一的线段，然后平移到该线段的末端。我们向左旋转（–60度）绘制第二个线段。该线段的长度也是三角形边长的三分之一。我们平移到该线段的末端，然后右转120度。接着，我们绘制一个线段，再次向左旋转–60度。最后，我们绘制第四条线（线段），并平移到边的末端。
- en: This draws a triangle if the level is 0 and puts a bump on each side if the
    level isn’t 0\. As you can see in [Figure 10-8](ch10.xhtml#ch10fig8), at every
    step, every segment in the previous step gets a bump. This would be a headache
    to do without recursion! But we’ll take the line of code that draws a line and
    change that into a segment, just one level lower. This is the recursive step.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果级别是0，这会绘制一个三角形，如果级别不为0，则在每条边上添加一个凸起。正如[图10-8](ch10.xhtml#ch10fig8)所示，在每一步中，前一步中的每个线段都会有一个凸起。没有递归的话，这将非常头疼！但我们将绘制直线的那行代码改成绘制线段，只是把级别降低了一个。这就是递归步骤。
- en: Next, we need to replace each line with a segment one level down, whose length
    is `sz` divided by 3\. The code for the `segment()` function is shown in [Listing
    10-8](ch10.xhtml#ch10list8).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将每条线替换为一个更低一级的线段，其长度为`sz`除以3。`segment()`函数的代码如[清单10-8](ch10.xhtml#ch10list8)所示。
- en: '[PRE8]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 10-8: Replacing the lines with segments*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单10-8：用线段替代直线*'
- en: So all we did was replace each instance of `line` in [Listing 10-7](ch10.xhtml#ch10list7)
    (whose level is greater than 0) with `segment()`. Because we don’t want to enter
    an infinite loop, the segments have to be one level down (`level – 1`) from the
    previous segment. Now we can change the level of the snowflake in the `draw()`
    function, as shown in the following code, and we’ll see different designs, as
    shown in [Figure 10-11](ch10.xhtml#ch10fig11).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们所做的只是将[清单10-7](ch10.xhtml#ch10list7)中每个`line`的实例（其层级大于0）替换为`segment()`。因为我们不想进入无限循环，所以这些片段必须比前一个片段低一级（`level
    - 1`）。现在我们可以通过在`draw()`函数中更改雪花的层级，如下面的代码所示，从而看到不同的设计，如[图10-11](ch10.xhtml#ch10fig11)所示。
- en: '[PRE9]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![image](../images/f212--01.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f212--01.jpg)'
- en: '*Figure 10-11: A level 3 snowflake*'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-11：一个3级雪花*'
- en: 'Even better, we can make it interactive by mapping the mouse’s x-value to the
    level. The mouse’s x-value can be anywhere from 0 to whatever the width of the
    screen is. We want to change that range to between 0 and 7\. Here’s the code for
    that:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的是，我们可以通过将鼠标的x值映射到层级来实现交互式功能。鼠标的x值可以在0到屏幕宽度之间的任何位置。我们希望将这个范围更改为0到7之间。以下是相应的代码：
- en: '[PRE10]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'However, we want only integer levels, so we’ll change that value to an integer
    using `int`, like this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们只希望得到整数层级，因此我们将使用`int`将该值转换为整数，如下所示：
- en: '[PRE11]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We’ll add that to our `draw()` function and send the output “level” to the `snowflake()`
    function. The entire code for the Koch snowflake is shown in [Listing 10-9](ch10.xhtml#ch10list9).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把它添加到`draw()`函数中，并将输出的“层级”传递给`snowflake()`函数。科赫雪花的完整代码见[清单10-9](ch10.xhtml#ch10list9)。
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 10-9: Complete code for the Koch snowflake*'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单10-9：科赫雪花的完整代码*'
- en: Now when you run the program and move your mouse left and right, you’ll see
    the snowflake get more “bumps” on its segments, like in [Figure 10-12](ch10.xhtml#ch10fig12).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你运行程序并左右移动鼠标时，你会看到雪花的片段上出现更多的“凸起”，就像在[图10-12](ch10.xhtml#ch10fig12)中看到的那样。
- en: '![image](../images/f213-01.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f213-01.jpg)'
- en: '*Figure 10-12: A level 7 snowflake*'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-12：一个7级雪花*'
- en: How does this help us understand the Coastline Paradox? Looking back at [Figure
    10-3](ch10.xhtml#ch10fig3), let’s call the length of the line (the side of the
    triangle) 1 unit (for example, 1 mile). When we split it in thirds, take out the
    middle, and add a “bump” two thirds long in the middle, the side is now 1 1/3
    units long. It just got 1/3 longer, right? The perimeter of the snowflake (the
    “coastline”) gets 1/3 longer every step. So at the *n*th step, the length of the
    coastline is (4/3)^(*n*) times the perimeter of the original triangle. It might
    not be possible to see, but after 20 steps, the coastline of the snowflake is
    so jagged that its total length is over 300 times the original measurement!
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这如何帮助我们理解海岸线悖论呢？回顾[图10-3](ch10.xhtml#ch10fig3)，我们将三角形的边长（即边长）定为1个单位（例如1英里）。当我们将它分成三份，取出中间部分，并在中间加入一个长为三分之二的“凸起”时，这一边现在的长度变为1
    1/3单位。它变长了三分之一，对吧？雪花的周长（即“海岸线”）在每一步都会增加三分之一。所以在第*n*步时，海岸线的长度是原始三角形周长的(4/3)^(n)倍。虽然可能不容易看出，但经过20步，雪花的海岸线变得如此曲折，以至于其总长度已经超过了原始长度的300倍！
- en: SIERPINSKI TRIANGLE
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 谢尔宾斯基三角形
- en: 'The Sierpinski triangle is a famous fractal first described by Polish mathematician
    Wacław Sierpiński in 1915, but there are examples of the design on the floors
    of churches in Italy from as far back as the 11th century! It follows a geometric
    pattern that’s easy to describe, but the design is surprisingly complicated. It
    works on an interesting recursive idea: draw a triangle for the first level, and
    for the next level turn each triangle into three smaller triangles at its corners,
    as shown in [Figure 10-13](ch10.xhtml#ch10fig13).'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 谢尔宾斯基三角形是一个著名的分形，首次由波兰数学家瓦茨瓦夫·谢尔宾斯基（Wacław Sierpiński）在1915年描述，但早在11世纪，就有意大利教堂地板上出现过类似的设计！它遵循了一种简单易懂的几何图案，但其设计却出奇复杂。它基于一个有趣的递归思想：首先画一个三角形作为第一层，接着在下一层，将每个三角形的三个角落各自转化为三个更小的三角形，如[图10-13](ch10.xhtml#ch10fig13)所示。
- en: '![image](../images/f214-01.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f214-01.jpg)'
- en: '*Figure 10-13: Sierpinski triangles, levels 0, 1, and 2*'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-13：谢尔宾斯基三角形，层级0、1和2*'
- en: 'The first step is easy: just draw a triangle. Open a new sketch and name it
    *sierpinski.pyde*. We set it up as usual, with `setup()` and `draw()` functions.
    In `setup()`, we set the size of the output window to 600 pixels by 600 pixels.
    In `draw()`, we set the background white and translate to a point (50,450) in
    the bottom left of the screen to start drawing our triangle. Next, we write a
    function named `sierpinski()`, similar to what we did with `tree()`, that draws
    a triangle if the level is 0\. The code so far is shown in [Listing 10-10](ch10.xhtml#ch10list10).'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步很简单：只需绘制一个三角形。打开一个新草图并命名为*sierpinski.pyde*。我们像往常一样设置它，包括`setup()`和`draw()`函数。在`setup()`中，我们将输出窗口的大小设置为600像素乘600像素。在`draw()`中，我们将背景设为白色，并将画布平移到屏幕左下角的(50,450)点，开始绘制三角形。接下来，我们编写一个名为`sierpinski()`的函数，类似于我们在`tree()`中做的，当级别为0时绘制一个三角形。到目前为止的代码如[清单10-10](ch10.xhtml#ch10list10)所示。
- en: '[PRE13]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 10-10: The setup of the Sierpinski fractal*'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-10：谢尔宾斯基分形的设置*'
- en: 'The `sierpinski()` function takes two parameters: the size of the figure (`sz`)
    and the `level` variable. The fill color is 0 for black, but you can make it any
    color you want by using RGB values. The triangle line contains six numbers: the
    x- and y-coordinates of the three corners of an equilateral triangle with sidelength
    `sz`.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`sierpinski()`函数有两个参数：图形的大小(`sz`)和`level`变量。填充颜色为0，表示黑色，但你可以通过使用RGB值将其设置为任何颜色。三角形的线包含六个数字：等边三角形的三个角的x和y坐标，边长为`sz`。'
- en: As you can see in [Figure 10-13](ch10.xhtml#ch10fig13), level 1 contains three
    triangles at each corner of the original triangle. These triangles are also half
    the size of the triangle in the previous level. What we’ll do is create a smaller,
    lower-level Sierpinski triangle, translate to the next corner, and then rotate
    120 degrees. Add the code in [Listing 10-11](ch10.xhtml#ch10list11) to the `sierpinski()`
    function.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在[图10-13](ch10.xhtml#ch10fig13)中看到的，级别1包含在原始三角形的每个角落的三个三角形。这些三角形的大小也比前一层的三角形小一半。我们的做法是创建一个较小的低层次谢尔宾斯基三角形，平移到下一个角落，然后旋转120度。将[清单10-11](ch10.xhtml#ch10list11)中的代码添加到`sierspinski()`函数中。
- en: '[PRE14]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 10-11: Adding the recursive step to the Sierpinski program*'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-11：向谢尔宾斯基程序中添加递归步骤*'
- en: 'This new code tells Processing what to do when the level isn’t 0 (the line
    `for i in range(3):` means “repeat this three times”): draw a half-sized Sierpinski
    triangle of one level lower, and then translate halfway across and halfway up
    the equilateral triangle and turn right 120 degrees. Notice the `sierpinski()`
    function in `sierpinski(sz/2.0,level-1)` is executed inside the definition of
    the `sierpinski()` function itself. That’s the recursive step! When you call'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这段新代码告诉Processing当级别不为0时该做什么（行`for i in range(3):`表示“重复三次”）：绘制一个比当前小一半大小的谢尔宾斯基三角形，并将其平移到等边三角形的中点，再向右旋转120度。注意`sierspinski()`函数在`sierspinski(sz/2.0,level-1)`中被执行，这就是递归步骤！当你调用
- en: '[PRE15]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '![image](../images/f215-01.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f215-01.jpg)'
- en: '*Figure 10-14: A level 8 Sierpinski triangle*'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-14：一个8级谢尔宾斯基三角形*'
- en: in the `draw()` function, you get a level 8 Sierpinski triangle, which you see
    in [Figure 10-14](ch10.xhtml#ch10fig14).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在`draw()`函数中，你将看到一个8级谢尔宾斯基三角形，如[图10-14](ch10.xhtml#ch10fig14)所示。
- en: An interesting thing about the Sierpinski triangle is that it shows up in other
    fractals too, like the next one, which doesn’t start with a triangle.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，谢尔宾斯基三角形也出现在其他分形中，比如下一个，它并不是从三角形开始的。
- en: '### SQUARE FRACTAL'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '### 方形分形'
- en: We can make the Sierpinski triangle out of squares too. For example, we can
    create a square, remove the lower-right quadrant, and then replace each remaining
    quadrant with the resulting shape. When we repeat this process, we should get
    something like [Figure 10-15](ch10.xhtml#ch10fig15).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以用方形来创建谢尔宾斯基三角形。例如，我们可以创建一个方形，去掉右下象限，然后将剩余的每个象限用相同的形状替换。当我们重复这个过程时，应该会得到类似[图10-15](ch10.xhtml#ch10fig15)的效果。
- en: '![image](../images/f216--01.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f216--01.jpg)'
- en: '*Figure 10-15: The square fractal at levels 0, 1, 2, and 3*'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-15：0级、1级、2级和3级的方形分形*'
- en: To create this fractal, we have to make each of the three smaller squares into
    a copy of the whole. Start a new Processing sketch called *squareFractal.pyde*
    and then set up the sketch with the code in [Listing 10-12](ch10.xhtml#ch10list12).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建这个分形，我们必须将三个较小的方形变成整个形状的副本。开始一个新的Processing草图，命名为*squareFractal.pyde*，然后使用[清单10-12](ch10.xhtml#ch10list12)中的代码设置草图。
- en: '[PRE16]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 10-12: Creating the `squareFractal()` function*'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-12：创建`squareFractal()`函数*'
- en: '![image](../images/f216--02.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f216--02.jpg)'
- en: '*Figure 10-16: Purple square (level 0)*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-16：紫色正方形（层级 0）*'
- en: We can use the RGB values for purple in the `setup()` function just because
    we won’t be changing the fill anywhere else. We use `noStroke()` so that we won’t
    see black outlines on the squares. In the `draw()` function we call the `squareFractal()`
    function, telling it to make the size of each square 500 pixels and level 0\.
    In the function definition, we tell the program to simply draw a square if the
    level is zero. This should give us a nice big purple square, as shown in [Figure
    10-16](ch10.xhtml#ch10fig16).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 `setup()` 函数中使用紫色的 RGB 值，因为我们不会在其他地方更改填充颜色。我们使用 `noStroke()` 以避免看到正方形上的黑色轮廓。在
    `draw()` 函数中，我们调用 `squareFractal()` 函数，告诉它每个正方形的大小为 500 像素，层级为 0。在函数定义中，我们告诉程序如果层级为零，就简单地绘制一个正方形。这应该会给我们一个漂亮的大紫色正方形，如
    [图 10-16](ch10.xhtml#ch10fig16) 所示。
- en: For the next level, we’ll make squares of half the sidelength of the initial
    square. One will be positioned at the top left of the figure; then we’ll translate
    around to put the other two squares at the bottom left and top right of [Figure
    10-16](ch10.xhtml#ch10fig16). [Listing 10-13](ch10.xhtml#ch10list13) does this
    while leaving out a quarter of the big square.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 对于下一个层级，我们将制作初始正方形边长一半的正方形。一个将放置在图形的左上角；然后我们将进行平移，将另外两个正方形放置在左下角和右上角，[图 10-16](ch10.xhtml#ch10fig16)
    中展示了这个过程。[列表 10-13](ch10.xhtml#ch10list13) 在此过程中去掉了大正方形的四分之一。
- en: '[PRE17]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 10-13: Adding more squares to the square fractal*'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 10-13：向正方形分形中添加更多正方形*'
- en: Here, we draw a big square if the level is 0\. If the level is not 0, we add
    a smaller square in the top left of the screen, translate to the right, add another
    smaller square in the top right, translate left (negative x) and down (positive
    y), and add a smaller square at the bottom left of the screen.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，如果层级为 0，我们绘制一个大正方形。如果层级不是 0，我们会在屏幕的左上角添加一个较小的正方形，向右平移后，在右上角添加另一个较小的正方形，再向左（负
    x 轴）和平移向下（正 y 轴），并在屏幕的左下角添加一个较小的正方形。
- en: That’s the next level, and when we update `squareFractal(500,0)` in the `draw()`
    function to `squareFractal(500,1)`, it should give us a square with the bottom-right
    quarter left out, as shown in [Figure 10-17](ch10.xhtml#ch10fig17).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这是下一个层级，当我们在 `draw()` 函数中将 `squareFractal(500,0)` 更新为 `squareFractal(500,1)`
    时，它应该给我们一个底部右侧四分之一被去掉的正方形，如 [图 10-17](ch10.xhtml#ch10fig17) 所示。
- en: '![image](../images/f217-01.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f217-01.jpg)'
- en: '*Figure 10-17: The next level of the square fractal*'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-17：正方形分形的下一个层级*'
- en: For the next levels, we want each of the squares to be further subdivided into
    fractals, so we’ll replace the `rect` lines with `squareFractal()`, divide the
    value in `sz` by 2, and tell it to move one level down, like in [Listing 10-14](ch10.xhtml#ch10list14).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 对于接下来的层级，我们希望每个正方形进一步细分为分形，因此我们将 `rect` 线条替换为 `squareFractal()`，将 `sz` 中的值除以
    2，并告诉它向下一层级移动，像在 [列表 10-14](ch10.xhtml#ch10list14) 中那样。
- en: '[PRE18]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 10-14: Adding the recursive step to the square fractal*'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 10-14：向正方形分形中添加递归步骤*'
- en: '![image](../images/f218-01.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f218-01.jpg)'
- en: '*Figure 10-18: Not what we were expecting!*'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-18：不是我们预期的！*'
- en: In [Listing 10-14](ch10.xhtml#ch10list14), notice that the `rect` lines (when
    the level isn’t 0) are replaced with `squareFractal()`. When we call `squareFractal(500,2)`
    in the `draw()` function, we don’t get the output we were expecting—we get [Figure
    10-18](ch10.xhtml#ch10fig18) instead.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 10-14](ch10.xhtml#ch10list14) 中，注意到 `rect` 线条（当层级不是 0 时）被 `squareFractal()`
    替代。当我们在 `draw()` 函数中调用 `squareFractal(500,2)` 时，我们并没有得到预期的输出——而是得到了 [图 10-18](ch10.xhtml#ch10fig18)。
- en: This is because we didn’t translate back to the starting point like we did with
    our Y fractal earlier in the chapter.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们没有像在本章的 Y 分形中那样返回到起始点。
- en: Although we can calculate how much to translate manually, we can also use the
    `pushMatrix()` and `popMatrix()` functions in Processing, which you learned about
    in [Chapter 5](ch05.xhtml#ch05).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以手动计算需要多少平移，但我们也可以在 Processing 中使用 `pushMatrix()` 和 `popMatrix()` 函数，这些你在
    [第 5 章](ch05.xhtml#ch05) 中学过。
- en: We can use the `pushMatrix()` function to save the current orientation of the
    screen—that is, where the origin (0,0) is located and how much the grid is rotated.
    After that, we can do as much translating and rotating as we like and then use
    the `popMatrix()` function to return to the saved orientation without any calculating!
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `pushMatrix()` 函数来保存当前屏幕的方向——即原点 (0,0) 的位置以及网格的旋转角度。之后，我们可以进行任意多的平移和旋转，然后使用
    `popMatrix()` 函数返回到保存的方向，而无需任何计算！
- en: Let’s add `pushMatrix()` at the beginning of the `squareFractal()` function
    and `popMatrix()` at the end, like in [Listing 10-15](ch10.xhtml#ch10list15).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `squareFractal()` 函数的开头添加 `pushMatrix()`，在结尾添加 `popMatrix()`，就像在[清单 10-15](ch10.xhtml#ch10list15)中一样。
- en: '[PRE19]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 10-15: Using `pushMatrix()` and `popMatrix()` to complete the squares*'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-15：使用 `pushMatrix()` 和 `popMatrix()` 完成方形分形*'
- en: Now, each of the smaller squares from level 1 should be transformed into a fractal,
    with the bottom-right square removed, as shown in [Figure 10-19](ch10.xhtml#ch10fig19).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，来自第 1 层的每个小方块都应该转变成一个分形，右下角的方块被去除，如[图 10-19](ch10.xhtml#ch10fig19)所示。
- en: '![image](../images/f219-01.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f219-01.jpg)'
- en: '*Figure 10-19: Level 2 of the square fractal*'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-19：方形分形的第 2 层*'
- en: Now let’s try making our mouse generate the level numbers like we’ve done before
    by replacing `squareFractal(500,2)` with the code in [Listing 10-16](ch10.xhtml#ch10list16).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试让鼠标生成层级数字，像我们之前做的那样，通过将 `squareFractal(500,2)` 替换为[清单 10-16](ch10.xhtml#ch10list16)中的代码。
- en: '[PRE20]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 10-16: Making the square fractal interactive*'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-16：让方形分形变得互动*'
- en: At higher levels, the square fractal looks a lot like the Sierpinski triangle,
    as you can see in [Figure 10-20](ch10.xhtml#ch10fig20)!
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在更高的层级，方形分形看起来非常像谢尔宾斯基三角形，正如你在[图 10-20](ch10.xhtml#ch10fig20)中所看到的那样！
- en: '![image](../images/f219-02.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f219-02.jpg)'
- en: '*Figure 10-20: High-level square fractals look like the Sierpinski triangle!*'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-20：高级方形分形看起来像是谢尔宾斯基三角形！*'
- en: '### DRAGON CURVE'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '### 龙曲线'
- en: The final fractal we’ll create looks different from the others we’ve created
    so far in that the shapes on each level don’t get smaller, they get bigger. [Figure
    10-21](ch10.xhtml#ch10fig21) shows an example of the dragon curve for levels 0
    through 3.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要创建的最终分形与我们迄今为止创建的其他分形不同，因为每个层级上的形状不是变小，而是变大。[图 10-21](ch10.xhtml#ch10fig21)展示了从第
    0 层到第 3 层的龙曲线示例。
- en: '![image](../images/f220-01.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f220-01.jpg)'
- en: '*Figure 10-21: The first four levels of the dragon curve*'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-21：龙曲线的前四个层级*'
- en: As mathematical entertainer Vi Hart shows in one of her YouTube videos, the
    second half of the dragon curve is a perfect copy of the first half, and she models
    it by folding and then unfolding pieces of paper. The third level (level 2) in
    [Figure 10-21](ch10.xhtml#ch10fig21) looks like two left turns followed by a right
    turn. The “hinge” or “fold” is at the midpoint of each dragon curve. See if you
    can find it in your dragon curves! Later, you’ll rotate part of the curve dynamically
    to match the next-level curve.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 正如数学娱乐家 Vi Hart 在她的 YouTube 视频中展示的那样，龙曲线的后半部分是前半部分的完美复制，她通过折叠和展开纸张来模拟这一过程。[图
    10-21](ch10.xhtml#ch10fig21)中的第三层（第 2 层）看起来像是两次左转后跟随一次右转。“铰链”或“折痕”位于每个龙曲线的中点。看看你能否在你的龙曲线中找到它！稍后，你将动态旋转曲线的一部分，以匹配下一个层级的曲线。
- en: Open a new Processing sketch and name it *dragonCurve.pyde*. To create this
    fractal, we first create a function for the “left dragon,” as in [Listing 10-17](ch10.xhtml#ch10list17).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个新的 Processing 草图，并将其命名为 *dragonCurve.pyde*。为了创建这个分形，我们首先创建一个“左龙”的函数，像在[清单
    10-17](ch10.xhtml#ch10list17)中一样。
- en: '[PRE21]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 10-17: Writing the `leftDragon()` function*'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-17：编写 `leftDragon()` 函数*'
- en: After the usual `setup()` and `draw()` functions, we define our `leftDragon()`
    function. If the level is 0, we just draw a line and then translate along the
    line. It’s kind of like the turtle from [Chapter 1](ch01.xhtml#ch01) drawing a
    line as it walks along. If the level is greater than 0, make a left dragon (one
    level down), turn left 90 degrees, and make a right dragon (one level down).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在常规的 `setup()` 和 `draw()` 函数之后，我们定义我们的 `leftDragon()` 函数。如果层级为 0，我们只需画一条线，然后沿着线进行平移。这有点像[第
    1 章](ch01.xhtml#ch01)中的海龟画线。当层级大于 0 时，先画一个左龙（降低一级），然后左转 90 度，再画一个右龙（降低一级）。
- en: Now we’ll make the “right dragon” function (see [Listing 10-18](ch10.xhtml#ch10list18)).
    It’s pretty similar to the `leftDragon()` function. If the level is 0, simply
    draw a line and move along it. Otherwise, make a left dragon, and this time turn
    *right* 90 degrees and make a right dragon.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来创建“右龙”函数（参见[清单 10-18](ch10.xhtml#ch10list18)）。它与 `leftDragon()` 函数非常相似。如果层级为
    0，只需画一条线并沿着它移动。否则，先画一个左龙，然后这次向 *右* 转 90 度，再画一个右龙。
- en: '[PRE22]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 10-18: Writing the `rightDragon()` function*'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-18：编写 `rightDragon()` 函数*'
- en: It’s interesting that the recursive statement in this case is not only inside
    one function, but it also jumps back and forth from the left dragon function to
    the right dragon function! Execute it, and the 11th level will look like [Figure
    10-22](ch10.xhtml#ch10fig22).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，在这种情况下，递归语句不仅仅在一个函数内，而且还在左龙函数和右龙函数之间来回跳转！执行它后，第11级将呈现如[图 10-22](ch10.xhtml#ch10fig22)所示的样子。
- en: '![image](../images/f221-01.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f221-01.jpg)'
- en: '*Figure 10-22: A level 11 dragon curve*'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-22：第11级龙形曲线*'
- en: Far from being simply a chaotic jumble of angles, this fractal starts to look
    like a dragon after enough levels! Remember I said the dragon curve is “folded”
    in the middle? In the version shown in [Listing 10-19](ch10.xhtml#ch10list19),
    I’ve added a few variables to change the level and the size, and I made an `angle`
    variable change with the mouse’s x-coordinate. This will rotate a dragon curve
    around a “hinge” in the middle of the next-level dragon curve. See how you can
    simply rotate the curve to get both halves of the next-level curve!
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 远非单纯的混乱角度堆积，这个分形在足够的级别后开始看起来像一条龙！记得我说过龙形曲线在中间是“折叠”的吗？在[代码清单 10-19](ch10.xhtml#ch10list19)中，我添加了一些变量来改变级别和大小，并且我让一个`angle`变量随鼠标的x坐标变化。这将使龙形曲线围绕下一级龙形曲线的“铰链”旋转。看看你是如何通过简单地旋转曲线，得到下一级曲线的两个部分！
- en: '[PRE23]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 10-19: A dynamic dragon curve*'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '*代码清单 10-19：动态龙形曲线*'
- en: In [Listing 10-19](ch10.xhtml#ch10list19), we add a couple of colors ➊ to use
    for the curves. In the `setup()` function, we declare two global variables, `thelevel`
    and `size1` ➋, whose initial values we declare at ➌ and which we change with the
    arrow keys in the `keyPressed()` function at the end of the file.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在[代码清单 10-19](ch10.xhtml#ch10list19)中，我们添加了一些颜色 ➊ 用于曲线。在`setup()`函数中，我们声明了两个全局变量，`thelevel`和`size1`
    ➋，它们的初始值在 ➌ 声明，并且我们在文件末尾的`keyPressed()`函数中使用箭头键来改变它们。
- en: In the `draw()` function, we link an `angle` variable ➍ to the x-position of
    the mouse. After that, we set the stroke color to red, make the stroke weight
    a little heavier, and draw a left dragon with the initial values of `thelevel`
    and `size1`. The `pushMatrix()` and `popMatrix()` functions, as you’ll remember,
    simply return the drawing point to the original spot, to draw another curve. Then
    we rotate the grid by however many radians the angle variable is ➎, and draw another
    dragon curve, in black. The `leftDragon()` and `rightDragon()` functions are exactly
    the same as before.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在`draw()`函数中，我们将一个`angle`变量 ➍ 与鼠标的x位置关联。之后，我们设置描边颜色为红色，稍微加大描边宽度，并使用`thelevel`和`size1`的初始值绘制左龙形曲线。你还记得`pushMatrix()`和`popMatrix()`函数，它们只是将绘图点返回到原始位置，以便绘制另一个曲线。然后我们按照`angle`变量的弧度数
    ➎ 来旋转网格，并绘制另一个黑色的龙形曲线。`leftDragon()`和`rightDragon()`函数与之前完全相同。
- en: Processing’s built-in `keyPressed()` function could come in handy for changing
    variables in a sketch! All you have to do is declare the global variables you
    want to change with the left (in this case), right, up, and down arrow keys on
    the keyboard. Note that `CODED` ➏ just means it’s not a letter or character key.
    Finally, it checks which arrow key is being pressed and makes the level variable
    go up or down (if the up or down arrow key is being pressed) or the size variable
    go up or down (if the left or right arrow key is being pressed).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Processing的内置`keyPressed()`函数对于在草图中改变变量非常有用！你只需要声明你想要改变的全局变量，并通过键盘上的左（在此情况下），右，上，下箭头键来控制它们的变化。请注意，`CODED`
    ➏ 表示它不是字母或字符键。最后，它检查按下的是哪个箭头键，并根据按下的是上下箭头键（则调整`level`变量），还是左右箭头键（则调整`size`变量）来改变变量。
- en: When you run this version of the *dragonCurve* sketch, it draws a dragon curve
    at level 5 in red; then you can rotate a level 4 curve and see how the level 5
    curve is made up of two level 4’s, just rotated in the middle, as shown in [Figure
    10-23](ch10.xhtml#ch10fig23).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个版本的*dragonCurve*草图时，它会在第5级绘制一个红色的龙形曲线；然后你可以旋转一个第4级曲线，看看第5级曲线是如何由两个第4级曲线组成的，只不过在中间旋转过，如[图
    10-23](ch10.xhtml#ch10fig23)所示。
- en: '![image](../images/f223-01.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f223-01.jpg)'
- en: '*Figure 10-23: A level 5 dragon curve and a dynamic, interactive level 4 curve*'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-23：第5级龙形曲线与动态交互式第4级曲线*'
- en: When you move the mouse, the black dragon curve should rotate, and you can see
    how it fits both halves of the red curve. The up and down arrow keys control the
    level of the curve; press the up arrow key and the curve gets longer. If the curve
    extends off the display window, use the left arrow key to make each segment shorter,
    so it’ll fit on the screen. The right arrow key makes it bigger.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当你移动鼠标时，黑龙曲线应该会旋转，你可以看到它如何与红色曲线的两半相吻合。上下箭头控制曲线的级别；按下上箭头，曲线会变长。如果曲线超出显示窗口，可以使用左箭头使每段变短，这样它就能适应屏幕。右箭头则使其变大。
- en: 'This makes sense, because the `leftDragon()` function comes first, turns left,
    and makes a right dragon curve. The `rightDragon()` function just turns the opposite
    way from `leftDragon()`: it makes a right turn in the middle instead of a left.
    No wonder it turns out to be a perfect copy.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这很有道理，因为`leftDragon()`函数首先执行，向左转，形成了一个右龙曲线。`rightDragon()`函数只是在`leftDragon()`的基础上转向相反的方向：它在中间右转，而不是左转。难怪它最终成了一个完美的复制品。
- en: SUMMARY
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: We’ve only scratched the surface of fractals, but hopefully you got a taste
    of how beautiful fractals can be and how powerful they are at modeling the messiness
    of nature. Fractals and recursion can help us reevaluate our ideas about logic
    and measurement. The question is no longer “how long is the coastline?” but rather
    “how jagged is it?”
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仅仅触及了分形的表面，但希望你已经感受到分形的美丽以及它们在模拟自然界的复杂性方面的强大功能。分形和递归可以帮助我们重新审视关于逻辑和测量的观念。问题不再是“海岸线有多长？”而是“它有多崎岖？”
- en: For fractal lines like coastlines and meandering rivers, the standard characteristic
    is the scale of self-similarity, or how much we have to scale the map up by before
    it looks like a different scale of the same thing. This is effectively what you
    did by feeding `0.8*sz`, `sz/2.0`, or `sz/3.0` into the next level.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像海岸线和蜿蜒河流这样的分形线条，标准特征是自相似的尺度，或者说我们需要把地图放大多少，才能让它看起来像是同一事物的不同尺度。这实际上就是你通过输入`0.8*sz`、`sz/2.0`或`sz/3.0`到下一个层级所做的。
- en: In the next chapter, we’ll create cellular automata (CAs), which we’ll draw
    as little squares on the screen that are born, grow, and respond to their surroundings.
    Just like with our grass-eating sheep in [Chapter 9](ch09.xhtml#ch09), we’ll create
    CAs and let them run—and just like with fractals, we’ll watch the surprising and
    beautiful patterns that are created from very simple rules.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将创建元胞自动机（CAs），我们会将它们绘制为屏幕上的小方块，这些方块会出生、成长并响应周围的环境。就像在[第9章](ch09.xhtml#ch09)中我们的吃草羊一样，我们将创建元胞自动机并让它们运行——就像分形一样，我们将观察到由非常简单的规则生成的惊人且美丽的图案。
