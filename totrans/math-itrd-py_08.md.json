["```py\ndef f(x):\n    return sin(x)\n```", "```py\n*polygon.pyde*\ndef setup():\n    size(600,600)\n\ndef draw():\n    beginShape()\n    vertex(100,100)\n    vertex(100,200)\n    vertex(200,200)\n    vertex(200,100)\n    vertex(150,50)\n    endShape(CLOSE)\n```", "```py\n*polygon.pyde*\ndef draw():\n    translate(width/2,height/2)\n    beginShape()\n    for i in range(6):\n        vertex(100,100)\n        rotate(radians(60))\n    endShape(CLOSE)\n```", "```py\nfor i in range(6):\n    vertex(r*cos(60*i),r*sin(60*i))\n```", "```py\n*polygon.pyde*\ndef setup():\n    size(600,600)\n\ndef draw():\n    translate(width/2,height/2)\n    beginShape()\n    for i in range(6):\n        vertex(100*cos(radians(60*i)),\n               100*sin(radians(60*i)))\n    endShape(CLOSE)\n```", "```py\n*polygon.pyde*\ndef setup():\n    size(600,600)\n\ndef draw():\n    translate(width/2,height/2)\n    polygon(3,100) #3 sides, vertices 100 units from the center\n\ndef polygon(sides,sz):\n    '''draws a polygon given the number\n    of sides and length from the center'''\n    beginShape()\n    for i in range(sides):\n    step = radians(360/sides)\n        vertex(sz*cos(i * step),\n               sz*sin(i * step))\n    endShape(CLOSE)\n```", "```py\n*CircleSineWave.pyde*\nr1 = 100 #radius of big circle\nr2 = 10  #radius of small circle\nt = 0 #time variable\n\ndef setup():\n    size(600,600)\n\ndef draw():\n    background(200)\n    #move to left-center of screen\n    translate(width/4,height/2)\n    noFill() #don't color in the circle\n    stroke(0) #black outline\n    ellipse(0,0,2*r1,2*r1)\n\n    #circling ellipse:\n    fill(255,0,0) #red\n    y = r1*sin(t)\n    x = r1*cos(t)\n    ellipse(x,y,r2,r2)\n```", "```py\n    t += 0.05\n```", "```py\nglobal t\n```", "```py\n*CircleSineWave.pyde*\nr1 = 100 #radius of big circle\nr2 = 10  #radius of small circle\nt = 0 #time variable\n\ndef setup():\n    size(600,600)\n\ndef draw():\n    global t\n    background(200)\n    #move to left-center of screen\n    translate(width/4,height/2)\n    noFill() #don't color in the circle\n    stroke(0) #black outline\n    ellipse(0,0,2*r1,2*r1)\n    #circling ellipse:\n    fill(255,0,0) #red\n    y = r1*sin(t)\n    x = r1*cos(t)\n    ellipse(x,y,r2,r2)\n    stroke(0,255,0) #green for the line\n    line(x,y,200,y)\n    fill(0,255,0) #green for the ellipse\n    ellipse(200,y,10,10)\n\n    t += 0.05\n```", "```py\ncircleList = []\n```", "```py\nglobal t, circleList\n```", "```py\ncircleList.insert(0,y)\n```", "```py\n    y = r1*sin(t)\n    x = r1*cos(t)\n    #add point to list:\n    circleList = [y] + circleList[:249]\n```", "```py\n    #loop over circleList to leave a trail:\n    for i in range(len(circleList)):\n        #small circle for trail:\n        ellipse(200+i,circleList[i],5,5)\n```", "```py\n>>> myList = [\"I\",\"love\",\"using\",\"Python\"]\n>>> for index, value in enumerate(myList):\n        print(index,value)\n\n0 I\n1 love\n2 using\n3 Python\n```", "```py\n    #loop over circleList to leave a trail:\n    for i,c in enumerate(circleList):\n        #small circle for trail:\n        ellipse(200+i,c,5,5)\n```", "```py\n*CircleSineWave.pyde*\nr1 = 100 #radius of big circle\nr2 = 10  #radius of small circle\nt = 0 #time variable\ncircleList = []\ndef setup():\n    size(600,600)\ndef draw():\n    global t, circleList\n    background(200)\n    #move to left-center of screen\n    translate(width/4,height/2)\n    noFill() #don't color in the circle\n    stroke(0) #black outline\n    ellipse(0,0,2*r1,2*r1)\n    #circling ellipse:\n    fill(255,0,0) #red\n    y = r1*sin(t)\n    x = r1*cos(t)\n    #add point to list:\n    circleList = [y] + circleList[:245]\n    ellipse(x,y,r2,r2)\n    stroke(0,255,0) #green for the line\n    line(x,y,200,y)\n    fill(0,255,0) #green for the ellipse\n    ellipse(200,y,10,10)\n #loop over circleList to leave a trail:\n    for i,c in enumerate(circleList):\n        #small circle for trail:\n        ellipse(200+i,c,5,5)\n\n    t += 0.05\n```", "```py\n*spirograph.pyde*\nr1 = 300.0 #radius of big circle\nr2 = 175.0 #radius of circle 2\nr3 = 5.0   #radius of drawing \"dot\"\n#location of big circle:\nx1 = 0\ny1 = 0\nt = 0 #time variable\npoints = [] #empty list to put points in\n\ndef setup():\n    size(600,600)\n\ndef draw():\n    global r1,r2,x1,y1,t\n    translate(width/2,height/2)\n    background(255)\n    noFill()\n    #big circle\n    stroke(0)\n    ellipse(x1,y1,2*r1,2*r1)\n```", "```py\n    #big circle\n    stroke(0)\n    ellipse(x1,y1,2*r1,2*r1)\n\n    #circle 2\n    x2 = (r1 - r2)\n    y2 = 0\n    ellipse(x2,y2,2*r2,2*r2)\n```", "```py\n    #big circle\n    stroke(0)\n    ellipse(x1,y1,2*r1,2*r1)\n #circle 2\n    x2 = (r1 - r2)*cos(t)\n    y2 = (r1 - r2)*sin(t)\n    ellipse(x2,y2,2*r2,2*r2)\n    t += 0.05\n```", "```py\n    #drawing dot\n    x3 = x2+(r2 - r3)*cos(t)\n    y3 = y2+(r2 - r3)*sin(t)\n    fill(255,0,0)\n    ellipse(x3,y3,2*r3,2*r3)\n```", "```py\nprop = 0.9\n*--snip--*\n\nglobal r1,r2,x1,y1,t,prop\n*--snip--*\n\nx3 = x2+prop*(r2 - r3)*cos(t)\ny3 = y2+prop*(r2 - r3)*sin(t)\n```", "```py\nx3 = x2+prop*(r2 - r3)*cos(-((r1-r2)/r2)*t)\ny3 = y2+prop*(r2 - r3)*sin(-((r1-r2)/r2)*t)\n```", "```py\nglobal r1,r2,x1,y1,t,prop,points\n```", "```py\n    fill(255,0,0)\n    ellipse(x3,y3,2*r3,2*r3)\n    #add points to list\n    points = [[x3, y3]] + points[:2000]\n    for i,p in enumerate(points): #go through the points list\n        if i < len(points)-1: #up to the next to last point\n            stroke(255,0,0) #draw red lines between the points\n            line(p[0],p[1],points[i+1][0],points[i+1][1])\n\n    t += 0.05\n```", "```py\n*harmonograph.pyde*\nt = 0\n\ndef setup():\n    size(600,600)\n    noStroke()\n\ndef draw():\n      global t\n    ➊ a1,a2 = 100,200 #amplitudes\n      f1,f2 = 1,2 #frequencies\n      p1,p2 = 0,PI/2 #phase shifts\n      d1,d2 = 0.02,0.02 #decay constants\n      background(255)\n      translate(width/2,height/2)\n    ➋ x = a1*cos(f1*t + p1)*exp(-d1*t) \n      y = a2*cos(f2*t + p2)*exp(-d2*t)\n      fill(0) #black\n      ellipse(x,y,5,5)\n      t += .1\n```", "```py\n*harmonograph.pyde*\nt = 0\npoints = []\n\ndef setup():\n    size(600,600)\n    noStroke()\n\ndef draw():\n    global t,points\n    a1,a2 = 100,200\n    f1,f2 = 1,2\n    p1,p2 = 0,PI/2\n    d1,d2 = 0.02,0.02\n    background(255)\n    translate(width/2,height/2)\n    x = a1*cos(f1*t + p1)*exp(-d1*t)\n    y = a2*cos(f2*t + p2)*exp(-d2*t)\n    #save location to points List\n    points.append([x,y])\n    #go through points list and draw lines between them\n    for i,p in enumerate(points):\n        stroke(0) #black\n        if i < len(points) - 1:\n            line(p[0],p[1],points[i+1][0],points[i+1][1])\n    t += .1\n```", "```py\n    x = a1*cos(f1*t + p1)#*exp(-d1*t)\n    y = a2*cos(f2*t + p2)#*exp(-d2*t)\n```", "```py\ndef harmonograph(t):\n    a1,a2 = 100,200\n    f1,f2 = 1,2\n    p1,p2 = PI/6,PI/2\n    d1,d2 = 0.02,0.02\n    x = a1*cos(f1*t + p1)*exp(-d1*t)\n    y = a2*cos(f2*t + p2)*exp(-d2*t)\n    return [x,y]\n```", "```py\ndef draw():\n    background(255)\n    translate(width/2,height/2)\n    points = []\n    t = 0\n    while t < 1000:\n        points.append(harmonograph(t))\n        t += 0.01\n\n    #go through points list and draw lines between them\n    for i,p in enumerate(points):\n        stroke(0) #black\n        if i < len(points) - 1:\n            line(p[0],p[1],points[i+1][0],points[i+1][1])\n```", "```py\n    x = a1*cos(f1*t + p1)*exp(-d1*t) + a3*cos(f3*t + p3)*exp(-d3*t)\n    y = a2*sin(f2*t + p2)*exp(-d2*t) + a4*sin(f4*t + p4)*exp(-d4*t)\n```", "```py\ndef harmonograph(t):\n    a1=a2=a3=a4 = 100\n    f1,f2,f3,f4 = 2.01,3,3,2\n    p1,p2,p3,p4 = -PI/2,0,-PI/16,0\n    d1,d2,d3,d4 = 0.00085,0.0065,0,0\n    x = a1*cos(f1*t + p1)*exp(-d1*t) + a3*cos(f3*t + p3)*exp(-d3*t)\n    y = a2*sin(f2*t + p2)*exp(-d2*t) + a4*sin(f4*t + p4)*exp(-d4*t)\n    return [x,y]\n```", "```py\n*harmonograph.pyde*\nt = 0\npoints = []\n\ndef setup():\n    size(600,600)\n    noStroke()\n\ndef draw():\n    background(255)\n    translate(width/2,height/2)\n    points = []\n    t = 0\n    while t < 1000:\n        points.append(harmonograph(t))\n        t += 0.01\n    #go through points list and draw lines between them\n    for i,p in enumerate(points):\n        stroke(255,0,0) #red\n        if i < len(points) - 1:\n            line(p[0],p[1],points[i+1][0],points[i+1][1])\n\ndef harmonograph(t):\n    a1=a2=a3=a4 = 100\n    f1,f2,f3,f4 = 2.01,3,3,2\n    p1,p2,p3,p4 = -PI/2,0,-PI/16,0\n    d1,d2,d3,d4 = 0.00085,0.0065,0,0\n    x = a1*cos(f1*t + p1)*exp(-d1*t) + a3*cos(f3*t + p3)*exp(-d3*t)\n    y = a2*sin(f2*t + p2)*exp(-d2*t) + a4*sin(f4*t + p4)*exp(-d4*t)\n    return [x,y]\n```"]