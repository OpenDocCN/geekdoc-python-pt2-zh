<html><head></head><body>
<h2 class="h2" id="ch11"><span epub:type="pagebreak" id="page_217"/><strong><span class="big">11</span><br/>THE MONTY HALL PROBLEM</strong></h2>
<div class="image1"><img src="../images/common01.jpg" alt="image"/></div>
<p class="noindent">As host of the TV game show <em>Let’s Make a Deal</em>, Monty Hall would show contestants three closed doors and ask them to choose one. Behind one door was a valuable prize; behind the other two were smelly old goats. As soon as the contestant chose a door, Monty would open one of the remaining doors to reveal a goat. The contestant was then given a final choice: switch doors or stay with their initial pick.</p>
<p class="indent">In 1990, Marilyn vos Savant, “the world’s smartest woman,” stated in her weekly <em>Parade</em> magazine column, “Ask Marilyn,” that the contestant should choose to switch doors. Though her answer was correct, it ignited a firestorm of hate mail, gender profiling, and academic persecution. Many math professors embarrassed themselves in the process, but there was a bright side to the ugly affair. The heated discussion exposed the public to <span epub:type="pagebreak" id="page_218"/>the science of statistics, and an exercise that vos Savant proposed found its way into thousands of classrooms. These manual tests—later duplicated by computers—all vindicated her derided “female logic.”</p>
<p class="indent">In this chapter, you’ll use <em>Monte Carlo simulation (MCS)</em>, a method for modeling the probability of different outcomes from a range of random inputs, to verify that vos Savant was right. After that, you’ll use <code>tkinter</code> to build a fun graphical interface that addresses her request for schoolchildren to help with the experiment.</p>
<h3 class="h3" id="lev249"><strong>Monte Carlo Simulation</strong></h3>
<p class="noindent">Imagine you want to know the probability of rolling a die six times and getting a different face with each roll. If you’re a math whiz, you’d probably just compute this using the deterministic equation 6! / 6<sup>6</sup> or</p>
<div class="imagec"><img src="../images/f0218-01.jpg" alt="image"/></div>
<p class="noindent">yielding 0.015. If you’re not so mathematically inclined, you could get the same answer with Python and a lot of rolls:</p>
<pre>&gt;&gt;&gt; <span class="codestrong1">from random import randint</span><br/>
&gt;&gt;&gt; <span class="codestrong1">trials = 100000</span><br/>
&gt;&gt;&gt; <span class="codestrong1">success = 0</span><br/>
&gt;&gt;&gt; <span class="codestrong1">for trial in range(trials):</span><br/>
           <span class="codestrong1">faces = set()</span><br/>
       <span class="codestrong1">    for rolls in range(6):</span><br/>
       <span class="codestrong1">        roll = randint(1, 6)</span><br/>
       <span class="codestrong1">        faces.add(roll)</span><br/>
       <span class="codestrong1">    if len(faces) == 6:</span><br/>
       <span class="codestrong1">        success += 1</span><br/>
&gt;&gt;&gt; <span class="codestrong1">print("probability of success = {}".format(success/trials))</span><br/>
probability of success = 0.01528</pre>
<p class="indent">This example uses a <code>for</code> loop and <code>randint</code> to randomly pick a number between 1 and 6, representing one of the faces on the die, six times in a row. It adds each result to a set named <code>faces</code>, which doesn’t permit duplicates. The only way for the length of the set to reach 6 is if each roll yields a unique number, which equals a success case. An outer <code>for</code> loop performs the six-roll trial 100,000 times. Dividing the number of successes by the number of trials yields the same probability, 0.015, as the deterministic equation.</p>
<p class="indent">Monte Carlo simulation uses <em>repeated random sampling</em>—in this case, each roll of the die is a random sample—to predict different outcomes under a specified range of conditions. For this example, the range of conditions was one six-faced die, six rolls with no repeats per trial, and 100,000 trials. <span epub:type="pagebreak" id="page_219"/>Of course, MCS is usually applied to more complex problems—those with lots of variables and wide ranges of uncertainty, where the results cannot be easily predicted.</p>
<p class="indent">There are multiple types of MCS, but most applications follow these basic steps:</p>
<ul>
<li class="noindent">List the input variables.</li>
<li class="noindent">Provide a probability distribution for each variable.</li>
<li class="noindent"><p class="list">Start a loop:</p>
<ul>
<li class="noindent">Randomly select a value from the distributions for each input.</li>
<li class="noindent">Use the values in a deterministic calculation, which is a calculation that will always produce the same output from the same input.</li>
<li class="noindent">Repeat a specified number of times.</li>
</ul></li>
<li class="noindent">Aggregate the results and generate statistics, such as the average outcome for the calculation.</li>
</ul>
<p class="indent">For the die-roll example, these steps were:</p>
<ul>
<li class="noindent">Input variables = the results of six die rolls.</li>
<li class="noindent">Probability distribution for roll = uniform (1/6 for each face).</li>
<li class="noindent"><p class="list">Loop:</p>
<ul>
<li class="noindent">Randomly selected value = die roll (draw from distribution).</li>
<li class="noindent">Calculation = add the six values to a set and, if set length equals 6, add 1 to <code>success</code> variable.</li>
<li class="noindent">Repeat = 100,000 times.</li>
</ul></li>
<li class="noindent">Aggregate: divide <code>success</code> variable by 100,0000 for probability calculation.</li>
</ul>
<p class="indent">Nassim Taleb, the critically acclaimed author of <em>The Black Swan</em> and <em>Fooled by Randomness</em>, is a fan of MCS. He posits that our brains are designed to get us out of trouble quickly, rather than handle complicated uncertainty or probability problems. We aren’t cut out for highly skewed distributions and nonlinearities, but some people’s brains are inherently more capable of understanding risks using MCS than other methods. In real life, we don’t observe probability distributions; we just observe events.</p>
<p class="indent">Each MCS run represents a single event, such as whether you run out of money in retirement. For many of us, MCS makes risk real. It helps us understand how bad or good things can be—something we can’t always glean from mathematical abstractions. With the insight from MCS, we can prepare to both defend against the downside and exploit the upside.</p>
<p class="indent">To support the math behind the Monty Hall problem, you’ll use an MCS application like the preceding die-roll example. Then, in <a href="ch12.xhtml#ch12">Chapter 12</a>, you’ll use MCS to build a nest-egg simulator to plan your (or your parents’) secure retirement.</p>
<h3 class="h3a" id="lev250"><span epub:type="pagebreak" id="page_220"/><strong>Project #18: Verify vos Savant</strong></h3>
<p class="noindent">To verify that vos Savant was right, use a Monte Carlo approach and simulate tens of thousands of “games” in order to see how things shake out. This can be a bare-bones program, since the goal is a simple confirmation with no embellishments.</p>
<div class="sidebar">
<p class="sidebart"><strong>THE OBJECTIVE</strong></p>
<p class="spara">Write a simple Python program that uses Monte Carlo simulation to determine the probability of winning the Monty Hall problem by changing the initial pick.</p>
</div>
<h4 class="h4" id="lev251"><strong><em>The Strategy</em></strong></h4>
<p class="noindent">The correct response to the Monty Hall problem is to switch doors after Monty reveals the goat. Statistically, this will double your chances of winning!</p>
<p class="indent">Look at <a href="ch11.xhtml#ch11fig1">Figure 11-1</a>. At the start of the game, all the doors are closed, and the odds of a given door hiding the prize are 1 in 3. The user can choose only one door, which means the odds of the prize being behind one of the other two doors are 2 in 3. After the goat is revealed, the odds remain 2 in 3, but they revert to the remaining door. Remember, Monty knows where the prize is hidden, and he will never reveal <em>that</em> door. So the probability of success is 1/3 for staying with your first choice versus 2/3 for switching.</p>
<div class="image"><a id="ch11fig1"/><img src="../images/f0220-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 11-1: Odds of winning the Monty Hall problem before and after a goat is revealed</em></p>
<p class="indent">If you’re dubious about the math, you can use MCS to provide corroborating evidence, just as we did with the die-roll example. You simply need to pick a winning door at random, choose a contestant’s pick at random, and record how many times the two coincide. Repeat this thousands of times, and you will converge on the deterministic mathematical solution.</p>
<h4 class="h4" id="lev252"><span epub:type="pagebreak" id="page_221"/><strong><em>The vos Savant Verification Code</em></strong></h4>
<p class="noindent">The <em>monty_hall_mcs.py</em> program described in this section will automate the process of choosing doors and recording the results so that you can run thousands of trials and evaluate them in less than a second. You can download the code from <em><a href="https://www.nostarch.com/impracticalpython.com/">https://www.nostarch.com/impracticalpython.com/</a></em>.</p>
<h5 class="h5" id="lev253"><strong>Getting the Number of Runs Input</strong></h5>
<p class="noindent"><a href="ch11.xhtml#ch11list1">Listing 11-1</a> starts the <em>monty_hall_mcs.py</em> program by asking the user how many runs—or games—they want to simulate. You’ll also provide the user with a default value. This is a great way to guide a user to a reasonable first response, as well as save them a few keystrokes.</p>
<p class="margin"><em>monty_hall_mcs.py,</em> part 1</p>
<pre><span class="ent">➊</span> import random<br/><br/><span class="ent">➋</span> def user_prompt(prompt, default=None):<br/>       """Allow use of default values in input."""<br/>    <span class="ent">➌</span> prompt = '{} [{}]: '.format(prompt, default)<br/>    <span class="ent">➍</span> response = input(prompt)<br/>    <span class="ent">➎</span> if not response and default:<br/>           return default<br/>       else:<br/>           return response<br/><br/>   # input number of times to run simulation<br/><span class="ent">➏</span> num_runs = int(user_prompt("Input number of runs", "20000"))</pre>
<p class="listing" id="ch11list1"><em>Listing 11-1: Imports modules and defines the</em> <span class="codeitalic">user_prompt()</span> <em>function</em></p>
<p class="indent">Start by importing the <code>random</code> module to run MCS <span class="ent">➊</span>. Next, define a function, called <code>user_prompt()</code>, that asks the user to either input the number of games to run or else accept a default value, if provided <span class="ent">➋</span>. This function takes two arguments; the first is the text prompt that tells the user what to do, and the second is the default value, which will start out as <code>None</code>. Immediately redefine the <code>prompt</code> variable so that it will display with the default value in brackets, per convention <span class="ent">➌</span>. Assign the user’s input to a variable named <code>response</code> <span class="ent">➍</span>. If the user presses <small>ENTER</small> without providing any input and a default value exists, the <code>user_prompt()</code> function will return the default value <span class="ent">➎</span>. Otherwise, the function returns the user’s input. Use the function to determine the number of runs to make by assigning the returned value to the <code>num_runs</code> variable <span class="ent">➏</span>. Each run will represent a contestant playing the game once.</p>
<h5 class="h5" id="lev254"><strong>Running MCS and Displaying the Results</strong></h5>
<p class="noindent"><a href="ch11.xhtml#ch11list2">Listing 11-2</a> picks the winning door and the user’s first choice at random, then aggregates and presents the statistics. Interestingly, the user’s second choice—to switch doors or not—isn’t required to get the correct answer. If the initial choice is the winning door, the correct answer is to not change <span epub:type="pagebreak" id="page_222"/>doors. Likewise, if the initial choice and the winning door differ, the correct answer is to change doors. There’s no reason to model what a contestant might or might not do.</p>
<p class="margin"><em>monty_hall_mcs.py,</em> part 2</p>
<pre>   # assign counters for ways to win<br/><span class="ent">➊</span> first_choice_wins = 0<br/>   pick_change_wins = 0<br/><span class="ent">➋</span> doors = ['a', 'b', 'c']<br/><br/>   # run Monte Carlo<br/><span class="ent">➌</span> for i in range(num_runs):<br/>       winner = random.choice(doors)<br/>       pick = random.choice(doors)<br/><br/>    <span class="ent">➍</span> if pick == winner:<br/>           first_choice_wins += 1<br/>       else:<br/>           pick_change_wins += 1<br/><br/><span class="ent">➎</span> print("Wins with original pick = {}".format(first_choice_wins))<br/>   print("Wins with changed pick = {}".format(pick_change_wins))<br/>   print("Probability of winning with initial guess: {:.2f}"<br/>         .format(first_choice_wins / num_runs))<br/>   print("Probability of winning by switching: {:.2f}"<br/>         .format(pick_change_wins / num_runs))<br/><br/><span class="ent">➏</span> input("\nPress Enter key to exit.")</pre>
<p class="listing" id="ch11list2"><em>Listing 11-2: Runs the Monte Carlo simulation and displays the results</em></p>
<p class="indent">Assign two variables to keep track of whether switching or staying put is the winning outcome <span class="ent">➊</span>. Then, create a list to represent the three doors <span class="ent">➋</span>.</p>
<p class="indent">MCS starts with a <code>for</code> loop that goes through the number of runs <span class="ent">➌</span>. Inside that loop, choose the winning door and the user’s first choice from the <code>doors</code> list, using <code>random.choice()</code>, and assign them to variables.</p>
<p class="indent">Since this is a binary system—the user switches or doesn’t—you’ll only need a conditional that adds to the counters based on the relationship of the <code>pick</code> variable to the <code>winning</code> variable <span class="ent">➍</span>.</p>
<p class="indent">Finish the program by presenting the final results. Display the actual counts, plus the calculated probabilities <span class="ent">➎</span>. Then let the user know the program is finished <span class="ent">➏</span>.</p>
<p class="indent">Here’s an example output for the default 20,000 runs:</p>
<pre>Input number of runs [20000]:<br/>Wins with original pick = 6628<br/>Wins with changed pick = 13372<br/>Probability of winning with initial guess: 0.33<br/>Probability of winning by switching: 0.67<br/><br/>Press Enter key to exit.</pre>
<p class="indent"><span epub:type="pagebreak" id="page_223"/>Some people aren’t impressed with a computer printout. They need something more convincing, so in the next project, you’ll repackage your code in a more hands-on format—one that’s complete with doors, prizes, and goats. This will also satisfy Marilyn vos Savant’s appeal for schoolchildren to join in and help restore her honor.</p>
<h3 class="h3a" id="lev255"><strong>Project #19: The Monty Hall Game</strong></h3>
<p class="noindent">The three-door game used in the Monty Hall problem is simple enough for you to build with <code>tkinter</code>. You began working with <code>tkinter</code> graphics in <a href="ch10.xhtml#ch10">Chapter 10</a>. Now you’ll build on this knowledge by adding interactive buttons for the user to click.</p>
<div class="sidebar">
<p class="sidebart"><strong>THE OBJECTIVE</strong></p>
<p class="spara">Simulate the Monty Hall problem using a GUI built with <code>tkinter</code>. Keep track of whether switching doors or staying put results in a win. In addition, update and display these statistics as the game is played.</p>
</div>
<h4 class="h4" id="lev256"><strong><em>A Brief Introduction to Object-Oriented Programming</em></strong></h4>
<p class="noindent">The <code>tkinter</code> module was written using <em>object-oriented programming (OOP)</em>. OOP is a language model built around data structures, known as <em>objects</em>, consisting of <em>data</em> and <em>methods</em> and the interactions between them—as opposed to the <em>actions</em> and <em>logic</em> used in procedural programming. Objects are built from <em>classes</em>, which are like blueprints for the objects.</p>
<p class="indent">OOP is an abstract concept and easier to appreciate when you’re writing large, complex programs. It reduces code duplication and makes code easier to update, maintain, and reuse. As a result, most commercial software is now built using OOP.</p>
<p class="indent">If you implemented OOP in small programs, like the ones we’ve written so far, most of them would feel overengineered. In fact, one of my all-time favorite quotes, attributed to British computer scientist Joe Armstrong, concerns this aspect of OOP: “The problem with object-oriented languages is they’ve got all this implicit environment that they carry around with them. You wanted a banana, but what you got was a gorilla holding the banana and the entire jungle!”</p>
<p class="indent">Despite this, the objects produced by OOP lend themselves very well to GUIs and gaming, even for some small projects. Let’s look at an example using a <em>Dungeons and Dragons</em>–type board game in which players can be different characters, such as dwarves, elves, and wizards. These games use character cards to list important information for each character type. If you let your playing piece represent a dwarf, it inherits the characteristics on the card (see <a href="ch11.xhtml#ch11fig2">Figure 11-2</a>).</p>
<div class="image"><span epub:type="pagebreak" id="page_224"/><a id="ch11fig2"/><img src="../images/f0224-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 11-2: A dwarf character card from a role-playing board game</em></p>
<p class="indent"><a href="ch11.xhtml#ch11list3">Listings 11-3</a> and <a href="ch11.xhtml#ch11list4">11-4</a> reproduce board game–style play, letting you create virtual cards for a dwarf and an elf, name your pieces, and have them fight. The outcome of the fight will impact one of the character’s <em>body points</em>, which represent the character’s health. Be sure to note how OOP can allow you to easily create many identical objects—in this case, dwarves or elves—by “stamping” them out of the predefined template, called a <em>class</em>.</p>
<pre><span class="ent">➊</span> &gt;&gt;&gt; <span class="codestrong1">import random</span><br/><span class="ent">➋</span> &gt;&gt;&gt; <span class="codestrong1">class Dwarf(object):</span><br/>        <span class="ent">➌</span> <span class="codestrong1">def __init__(self, name):</span><br/>  <span class="codestrong1">          </span><span class="ent">➍</span> <span class="codestrong1">self.name = name</span><br/>     <span class="codestrong1">          self.attack = 3</span><br/>     <span class="codestrong1">          self.defend = 4</span><br/>     <span class="codestrong1">          self.body = 5</span><br/>   <span class="codestrong1">     </span><span class="ent">➎</span> <span class="codestrong1">def talk(self):</span><br/>     <span class="codestrong1">          print("I'm a blade-man, I'll cut ya!!!")</span><br/><span class="ent">➏</span> &gt;&gt;&gt; <span class="codestrong1">lenn = Dwarf("Lenn")</span><br/>   &gt;&gt;&gt; <span class="codestrong1">print("Dwarf name = {}".format(lenn.name))</span><br/>   Dwarf name = Lenn<br/>   &gt;&gt;&gt; <span class="codestrong1">print("Lenn's attack strength = {}".format(lenn.attack))</span><br/>   Lenn's attack strength = 3<br/>   &gt;&gt;&gt;<br/><span class="ent">➐</span> &gt;&gt;&gt; <span class="codestrong1">lenn.talk()</span><br/>   I'm a blade-man, I'll cut ya!!!</pre>
<p class="listing" id="ch11list3"><em>Listing 11-3: Imports</em> <span class="codeitalic">random</span> <em>module, creates a</em> <span class="codeitalic">Dwarf</span> <em>class, and instantiates a dwarf object</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_225"/>Start by importing <code>random</code> to simulate rolling a die <span class="ent">➊</span>; this is how your character will fight. Now define a class for a dwarf character, capitalizing the first letter of the class name, and pass it an <code>object</code> argument, which will be the name of your dwarf <span class="ent">➋</span>. A class is a template for creating objects of a certain type. For example, when you create a list or dictionary, you are creating them from a class.</p>
<p class="indent">The <code>Dwarf</code> class definition is like the card in <a href="ch11.xhtml#ch11fig2">Figure 11-2</a>; it is basically the genetic blueprint for a dwarf. It will assign <em>attributes</em>, like strength and vitality, and <em>methods</em>, like how the character moves or talks. Attributes are variables scoped to an <em>instance</em> of the class, and methods are attributes that also happen to be functions, which are passed a reference to their instance when they run. A class is a data type, and when you create an object of that data type, it is also known as an instance of that class. The process of setting the initial values and behaviors of the instance is called <em>instantiation</em>.</p>
<p class="indent">Next, define a <em>constructor</em> method, also referred to as the <em>initialization</em> method. It sets up the initial attribute values for your object <span class="ent">➌</span>. The <code>__init__()</code> method is a special built-in method that Python automatically invokes as soon as a new object is created. In this case, you’ll pass two arguments: <code>self</code> and the <code>name</code> of your object.</p>
<p class="indent">The <code>self</code> parameter is a reference to the instance of this class that is being created, or a reference to the instance a method was invoked on, technically referred to as a <em>context</em> instance. If you create a new dwarf and name it “Steve,” <code>self</code> will become Steve behind the scenes. For example, <code>self.attack</code> becomes “Steve’s attack.” If you create another dwarf named “Sue,” <code>self</code> for that object will become “Sue.” This way, the scope of Steve’s health attribute is kept separate from Sue’s.</p>
<p class="indent">Next, list some attributes for a dwarf beneath the constructor definition <span class="ent">➍</span>. You’ll want a name so you can tell one dwarf from another, as well as the value of key combat characteristics. Notice how this list resembles the card in <a href="ch11.xhtml#ch11fig2">Figure 11-2</a>.</p>
<p class="indent">Define a <code>talk()</code> method and pass it <code>self</code> <span class="ent">➎</span>. By passing it <code>self</code>, you link the method to the object. In more comprehensive games, methods might include behaviors like movement and the ability to disarm traps.</p>
<p class="indent">With the class definition complete, create an instance of the <code>Dwarf</code> class and assign this object to the local variable <code>lenn</code>, the dwarf’s name <span class="ent">➏</span>. Now, print the name and attack attributes to demonstrate that you have access to them. Finish by invoking the <code>talk()</code> method <span class="ent">➐</span>. This should display a message.</p>
<p class="indent"><a href="ch11.xhtml#ch11list4">Listing 11-4</a> creates an elf character, using the same process you used in <a href="ch11.xhtml#ch11list3">Listing 11-3</a>, and has it fight the dwarf. The elf’s <code>body</code> attribute is updated to reflect the outcome of the battle.</p>
<pre><span class="ent">➊</span> &gt;&gt;&gt; <span class="codestrong1">class Elf(object):</span><br/>           <span class="codestrong1">def __init__(self, name):</span><br/>   <span class="codestrong1">            self.name = name</span><br/>   <span class="codestrong1">            self.attack = 4</span><br/>   <span class="codestrong1">            self.defend = 4</span><br/>   <span class="codestrong1">            self.body = 4</span><br/>   &gt;&gt;&gt; <span class="codestrong1">esseden = Elf("Esseden")</span><br/>   <span epub:type="pagebreak" id="page_226"/>&gt;&gt;&gt; <span class="codestrong1">print("Elf name = {}".format(esseden.name))</span><br/>   Elf name = Esseden<br/>   &gt;&gt;&gt; <span class="codestrong1">print("Esseden body value = {}".format(esseden.body))</span><br/>   Esseden body value = 4<br/>   &gt;&gt;&gt;<br/><span class="ent">➋</span> &gt;&gt;&gt; <span class="codestrong1">lenn_attack_roll = random.randrange(1, lenn.attack + 1)</span><br/>   &gt;&gt;&gt; <span class="codestrong1">print("Lenn attack roll = {}".format(lenn_attack_roll))</span><br/>   Lenn attack roll = 3<br/><span class="ent">➌</span> &gt;&gt;&gt; <span class="codestrong1">esseden_defend_roll = random.randrange(1, esseden.defend + 1)</span><br/>   &gt;&gt;&gt; <span class="codestrong1">print("Esseden defend roll = {}".format(esseden_defend_roll))</span><br/>   Esseden defend roll = 1<br/>   &gt;&gt;&gt;<br/><span class="ent">➍</span> &gt;&gt;&gt; <span class="codestrong1">damage = lenn_attack_roll - esseden_defend_roll</span><br/>   &gt;&gt;&gt; <span class="codestrong1">if damage &gt; 0:</span><br/>   <span class="codestrong1">    esseden.body -= damage</span><br/><span class="ent">➎</span> &gt;&gt;&gt; <span class="codestrong1">print("Esseden body value = {}".format(esseden.body))</span><br/>   Esseden body value = 2</pre>
<p class="listing" id="ch11list4"><em>Listing 11-4: Creates an</em> <span class="codeitalic">Elf</span> <em>class, instantiates an elf object, simulates a battle, and updates an object attribute</em></p>
<p class="indent">Define an <code>Elf</code> class and provide some attributes <span class="ent">➊</span>. Make them slightly different from the dwarf’s and well balanced, like an elf. Instantiate an elf named <code>Esseden</code> and access his <code>name</code> and <code>body</code> attributes using <code>print</code>.</p>
<p class="indent">Have your two characters interact using the roll of a virtual die with a maximum value equal to the character’s attack or defend value. Use the <code>random</code> module to choose a roll value in a range of 1 to Lenn’s <code>attack</code> attribute plus 1 <span class="ent">➋</span>, then repeat this process to get Esseden’s defense <span class="ent">➌</span>. Calculate the damage to Esseden by subtracting Esseden’s roll value from Lenn’s roll value <span class="ent">➍</span>, and if the damage is a positive number, subtract it from Esseden’s body attribute. Use <code>print()</code> to confirm the elf’s current health <span class="ent">➎</span>.</p>
<p class="indent">As you can imagine, building many similar characters and keeping track of their changing attributes could quickly get complicated with procedural programming. OOP provides a modular structure for your program, makes it easy to hide complexity and ownership of scope with encapsulation, permits problem solving in bite-sized chunks, and produces sharable templates that can be modified and used elsewhere.</p>
<h4 class="h4" id="lev257"><strong><em>The Strategy and Pseudocode</em></strong></h4>
<p class="noindent">Now back to our three-door game. The rules for the game form the bulk of the pseudocode for the program:</p>
<pre>Initialize game window and show closed doors and instructions<br/>Choose winning door at random<br/>Get player's door choice<br/>Reveal a door that isn't the winning door or the player's choice<br/>Get player's choice to switch doors or not<br/>If player switches:<br/>    Reveal new door<br/><span epub:type="pagebreak" id="page_227"/>    If winner:<br/>        Record as win for switching<br/>    Otherwise:<br/>        Record as win for staying put<br/>Else if player stays with first choice:<br/>    Reveal chosen door<br/>    If winner:<br/>        Record as win for staying put<br/>    Otherwise:<br/>        Record as win for switching<br/>Display number of wins for each strategy in game window<br/>Reset game and close all doors</pre>
<p class="indent">It’s useful to start designing a game by sketching out how the game window should look, complete with instructions, messages, and button types. I doubt you want to see my crude scribblings, so instead check out <a href="ch11.xhtml#ch11fig3">Figure 11-3</a>.</p>
<div class="image"><a id="ch11fig3"/><img src="../images/f0227-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 11-3: View of the game window after the first round of play</em></p>
<p class="indent">This is how the finished game will look after the first round, with the win statistics visible at the far right. Note that the radio buttons for changing doors are grayed out until an initial pick has been made.</p>
<h4 class="h4" id="lev258"><strong><em>Game Assets</em></strong></h4>
<p class="noindent"><em>Game assets</em> is a fancy term for things that you’ll need to build the game. These will consist of a series of images to represent the doors, goats, and prize (<a href="ch11.xhtml#ch11fig4">Figure 11-4</a>).</p>
<div class="image"><span epub:type="pagebreak" id="page_228"/><a id="ch11fig4"/><img src="../images/f0228-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 11-4: Building-block images for the</em> monty_hall_gui.py <em>program</em></p>
<p class="indent">I used Microsoft PowerPoint to composite the 3 base images into 10 images that represent all the possible states of the game (<a href="ch11.xhtml#ch11fig5">Figure 11-5</a>). This was a design decision; with extra lines of code, I could have obtained the same results using only the base images.</p>
<div class="image"><a id="ch11fig5"/><img src="../images/f0228-02.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 11-5: Composited images for the</em> monty_hall_gui.py <em>program</em></p>
<h4 class="h4" id="lev259"><strong><em>The Monty Hall Game Code</em></strong></h4>
<p class="noindent">The <em>monty_hall_gui.py</em> program described in this section turns the Monty Hall problem into a fun and educational game. You will also need the 10 game assets shown in <a href="ch11.xhtml#ch11fig5">Figure 11-5</a>. Download them from <em><a href="https://www.nostarch.com/impracticalpython/">https://www.nostarch.com/impracticalpython/</a></em> and keep all the files in the same folder.</p>
<h5 class="h5" id="lev260"><strong>Importing Modules and Defining the Game Class</strong></h5>
<p class="noindent"><a href="ch11.xhtml#ch11list5">Listing 11-5</a> imports modules and defines the <code>Game</code> class and the initialization method, <code>__init__()</code>.</p>
<p class="margin"><span epub:type="pagebreak" id="page_229"/><em>monty_hall_gui.py,</em> part 1</p>
<pre><span class="ent">➊</span> import random<br/>   import tkinter as tk<br/><br/><span class="ent">➋</span> class Game(tk.Frame):<br/>       """GUI application for Monty Hall Problem game."""<br/><br/>    <span class="ent">➌</span> doors = ('a', 'b', 'c')<br/><br/>    <span class="ent">➍</span> def __init__(self, parent):<br/>           """Initialize the frame."""<br/>        <span class="ent">➎</span> super(Game, self).__init__(parent)  # parent will be the root window<br/>        <span class="ent">➏</span> self.parent = parent<br/>           self.img_file = 'all_closed.png'  # current image of doors<br/>           self.choice = ''  # player's door choice<br/>           self.winner = ''  # winning door<br/>           self.reveal = ''  # revealed goat door<br/>        <span class="ent">➐</span> self.first_choice_wins = 0  # counter for statistics<br/>           self.pick_change_wins = 0  # counter for statistics<br/>        <span class="ent">➑</span> self.create_widgets()</pre>
<p class="listing" id="ch11list5"><em>Listing 11-5: Imports modules and defines the</em> <span class="codeitalic">Game</span> <em>class and</em> <span class="codeitalic">_ _init_ _()</span> <em>method</em></p>
<p class="indent">Start by importing the <code>random</code> and <code>tkinter</code> modules <span class="ent">➊</span>. Next, define a class called <code>Game</code> <span class="ent">➋</span>. The <em>ancestor</em> for this class, shown in parentheses, will be a <code>tkinter</code> <code>Frame</code> class. This means that the <code>Game</code> class is <em>derived</em> from the existing <code>Frame</code> “base” class and will conveniently inherit useful methods from it. The <code>Frame</code> widget mainly serves as a geometry master for other widgets, helping to group them into complex layouts.</p>
<p class="indent">Note that classes have their own docstring conventions, which you can find at <em><a href="https://www.python.org/dev/peps/pep-0257/">https://www.python.org/dev/peps/pep-0257/</a></em>. As stated in <a href="ch01.xhtml#ch01">Chapter 1</a>, I will mainly show single-line docstrings in this book for brevity.</p>
<p class="indent">Every instance of <code>Game</code> will use the same three doors, so you can use a <em>class attribute</em> for this <span class="ent">➌</span>. Any variable assigned a value outside of a method becomes a class attribute, much as variables assigned outside of functions in procedural programs become global variables. You don’t want this attribute to get changed inadvertently, so make it immutable by using a tuple. Later, you’ll make lists from this tuple whenever you want to manipulate the doors.</p>
<p class="indent">Now, just as with the earlier dwarf and elf examples, define an initializer method for the game object <span class="ent">➍</span>. A <code>self</code> parameter is required, but you’ll also need a <code>parent</code>, which will be the <code>root</code> window that will hold the game.</p>
<p class="indent">A base class can also be called a <em>superclass</em>, and the <code>super()</code> function lets you invoke the method of a superclass to gain access to inherited methods—in this case, from a parent class. First, pass <code>Game</code> to <code>super()</code>, which means you want to invoke a method of the superclass of <code>Game</code>, which is <code>Frame</code> <span class="ent">➎</span>. Then pass it <code>self</code> as an argument to reference the newly instantiated <code>Game</code> object. The <code>__init__(parent)</code> part of the statement invokes the initializer method of <code>Frame</code> with <code>parent</code> (the root window) as the argument. Now attributes in the prebuilt <code>tkinter</code> <code>Frame</code> class can be used by your <code>Game</code> object. Note that this statement can be simplified to <code>super().__init__()</code>.</p>
<p class="indent"><span epub:type="pagebreak" id="page_230"/>Next, assign values to a series of instance attributes <span class="ent">➏</span>. It is best to initialize attributes through the <code>__init__()</code> method, as it is the first method called after an object is created. This way, these attributes will be immediately available to any other methods in the class. Start by assigning the parent, which will be the <code>root</code> window, to the instance. Then name an attribute to hold one of the image files (shown in <a href="ch11.xhtml#ch11fig5">Figure 11-5</a>) and assign it the image with all the doors closed, which is what the player will see at the start of each game. Next, name attributes for the player’s door choice, the winning door, and the door used to reveal the first goat.</p>
<p class="indent">Use a counter to keep track of the number of wins achieved if the player sticks with the first door choice and another to record wins achieved when the player switches doors <span class="ent">➐</span>. Finally, call a method that will create the label, button, and text widgets needed to run the game <span class="ent">➑</span>.</p>
<h5 class="h5" id="lev261"><strong>Creating Widgets for Images and Instructions</strong></h5>
<p class="noindent"><a href="ch11.xhtml#ch11list6">Listing 11-6</a> defines the first part of the <code>create_widgets()</code> method, used to build the labels, buttons, and text widgets for the game. The first two widgets will be <code>tkinter</code> labels used to display the images in <a href="ch11.xhtml#ch11fig5">Figure 11-5</a> and to provide game instructions.</p>
<p class="margin"><em>monty_hall_gui.py,</em> part 2</p>
<pre>    <span class="ent">➊</span> def create_widgets(self):<br/>           """Create label, button, and text widgets for game."""<br/>           # create label to hold image of doors<br/>        <span class="ent">➋</span> img = tk.PhotoImage(file='all_closed.png')<br/>        <span class="ent">➌</span> self.photo_lbl = tk.Label(self.parent, image=img,<br/>                                     text='', borderwidth=0)<br/>        <span class="ent">➍</span> self.photo_lbl.grid(row=0, column=0, columnspan=10, sticky='W')<br/>        <span class="ent">➎</span> self.photo_lbl.image = img<br/><br/>           # create the instruction label<br/>        <span class="ent">➏</span> instr_input = [<br/>               ('Behind one door is CASH!', 1, 0, 5, 'W'),<br/>               ('Behind the others:  GOATS!!!', 2, 0, 5, 'W'),<br/>               ('Pick a door:', 1, 3, 1, 'E')<br/>               ]<br/>        <span class="ent">➐</span> for text, row, column, columnspan, sticky in instr_input:<br/>               instr_lbl = tk.Label(self.parent, text=text)<br/>               instr_lbl.grid(row=row, column=column, columnspan=columnspan,<br/>                              sticky=sticky, <span class="ent">➑</span>ipadx=30)</pre>
<p class="listing" id="ch11list6"><em>Listing 11-6: Defines a method to create widgets</em></p>
<p class="indent">Define a method, called <code>create_widgets()</code>, that takes <code>self</code> as an argument <span class="ent">➊</span>. Then assign an attribute to hold an image of the doors <span class="ent">➋</span>. Note that you don’t have to precede this attribute name with <code>self</code>, as it will be used only locally within the method. The <code>PhotoImage</code> class, which takes the image filename as an argument, is used by <code>tkinter</code> to display images in canvas, label, text, or button widgets. After this step, you can use the image in a <code>tkinter</code> label, so assign a <code>photo_lbl</code> variable, pass it the parent and image as arguments, and specify no text and a thin border <span class="ent">➌</span>.</p>
<p class="indent"><span epub:type="pagebreak" id="page_231"/>To place the label in the parent window, use the <code>grid()</code> method and pass it the first row and first column, let the image span 10 columns, and left-justify it using <code>W</code> <span class="ent">➍</span>. This will fill the top part of the window with the image of the closed doors. The <code>columnspan</code> option lets the widget span more than one column. The value won’t affect the image size but <em>will</em> change the number of locations available for placing the instruction text and other widgets below the image. For example, if you set <code>columnspan=2</code>, you’ll have only two columns available for placing instructions, buttons, and messages.</p>
<p class="indent">Finish the photo label by creating a reference to the image object <span class="ent">➎</span>. If you don’t do this, the image won’t always show up.</p>
<p class="indent">According to the <code>tkinter</code> documentation, <code>tkinter</code> is a layer built over another product (<code>Tk</code>), and the interface between the two doesn’t handle references to image objects properly. The <code>Tk</code> widget holds a reference to the internal object, but <code>tkinter</code> doesn’t. Python uses a garbage-collector module to automatically reclaim memory from objects no longer needed. When the garbage collector in Python’s memory allocator discards the <code>tkinter</code> object, <code>tkinter</code> tells <code>Tk</code> to release the image. But because it’s in use, <code>Tk</code> can’t, so it sets it to transparent instead. Suggestions for solving the problem include using a global variable, using an instance attribute, or as you did here, adding an attribute to the widget instance (<code>photo_lbl.image = img</code>). For more information, see <em><a href="http://effbot.org/tkinterbook/photoimage.htm">http://effbot.org/tkinterbook/photoimage.htm</a></em>.</p>
<p class="indent">Finally, add the instruction text as label widgets. The process is to provide a list of parameters and then loop through them to build the widgets. Start with a list of tuples <span class="ent">➏</span>, where each tuple contains the options for making a <code>Label</code> object; you can see what each represents in the next statement <span class="ent">➐</span>. As you progress through the <code>for</code> loop, create each label in the <code>parent</code> window and assign it some text. Then use the <code>grid()</code> method to place the text, based on the information in the list of tuples, into the window.</p>
<p class="indent">Use the <code>ipadx</code> option with <code>grid()</code> <span class="ent">➑</span>. This option refers to internal padding in the x-direction within the label, so you can play with it to tweak the appearance of the text in the window. In this case, you add 30 pixels to the label so that the text will align in a visually pleasing way.</p>
<h5 class="h5" id="lev262"><strong>Creating Radio Buttons and Text Widgets</strong></h5>
<p class="noindent"><a href="ch11.xhtml#ch11list7">Listing 11-7</a> continues the definition of the <code>create_widgets()</code> method by creating radio button widgets for the three doors. The player makes their initial door choice by selecting the A, B, or C radio button. Their choice is then processed by the <code>win_reveal()</code> method, which you’ll build later. This method will determine the winning door and reveal a goat.</p>
<p class="indent">Another set of radio buttons is created to get the player’s choice to switch doors or not. The result will be processed by the <code>show_final()</code> method, also defined later. Besides revealing what’s behind the player’s final door choice, this method will update the win statistics, using <code>Text</code> widgets defined at the end of this listing.</p>
<p class="margin"><em>monty_hall_gui.py,</em> part 3</p>
<pre>          # create radio buttons for getting initial user choice<br/>        <span class="ent">➊</span> self.door_choice = tk.StringVar()<br/>           self.door_choice.set(None)<br/><br/>   <span epub:type="pagebreak" id="page_232"/>     <span class="ent">➋</span> a = tk.Radiobutton(self.parent, text='A', variable=self.door_choice,<br/>                              value='a', command=self.win_reveal)<br/>           b = tk.Radiobutton(self.parent, text='B', variable=self.door_choice,<br/>                              value='b', command=self.win_reveal)<br/>           c = tk.Radiobutton(self.parent, text='C', variable=self.door_choice,<br/>                              value='c', command=self.win_reveal)<br/><br/>           # create widgets for changing door choice<br/>        <span class="ent">➌</span> self.change_door = tk.StringVar()<br/>           self.change_door.set(None)<br/><br/>        <span class="ent">➍</span> instr_lbl = tk.Label(self.parent, text='Change doors?')<br/>           instr_lbl.grid(row=2, column=3, columnspan=1, sticky='E')<br/><br/>        <span class="ent">➎</span> self.yes = tk.Radiobutton(self.parent, state='disabled', text='Y',<br/>                                     variable=self.change_door, value='y',<br/>                                     command=self.show_final)<br/>           self.no = tk.Radiobutton(self.parent, state='disabled', text='N',<br/>                                    variable=self.change_door, value='n',<br/>                                    command=self.show_final)<br/><br/>           # create text widgets for win statistics<br/>        <span class="ent">➏</span> defaultbg = self.parent.cget('bg')<br/>        <span class="ent">➐</span> self.unchanged_wins_txt = tk.Text(self.parent, width=20,<br/>                                             height=1, wrap=tk.WORD,<br/>                                             bg=defaultbg, fg='black',<br/>                                             borderwidth=0)<br/>           self.changed_wins_txt = tk.Text(self.parent, width=20,<br/>                                           height=1, wrap=tk.WORD, bg=defaultbg,<br/>                                           fg='black', borderwidth=0)</pre>
<p class="listing" id="ch11list7"><em>Listing 11-7: Builds radio buttons and text widgets for the</em> <span class="codeitalic">create_widgets()</span> <em>method</em></p>
<p class="indent">Start by creating radio buttons for doors A, B, and C. When a user interacts with a <code>tkinter</code> widget, the result is an <em>event</em>. You can use variables to track these events, such as when the player selects a door by pressing a radio button. For widget-specific variables, <code>tkinter</code> has a variable class. Use the <em>string</em> variable class, <code>StringVar</code>, and assign it to a variable named <code>door_choice</code> <span class="ent">➊</span>. Immediately use the <code>set()</code> method to assign the variable a value of <code>None</code>.</p>
<p class="indent">Next, set up the button widgets for the three doors <span class="ent">➋</span>. The player will click on one of these for their first door pick. Use the <code>Radiobutton</code> class and pass it the parent window, the text to display, the <code>door_choice</code> variable you just assigned, a value equal to the door name, and a command. The command calls the <code>win_reveal()</code> method, which you’ll define shortly. Note that you don’t include the parentheses after the method name.</p>
<p class="indent">Repeat this process for buttons B and C. This is mainly a cut-and-paste exercise, because all you need to change are the door designations.</p>
<p class="indent">Now, build the radio buttons for switching doors. Start by making another string variable, as you did for the initial door choice <span class="ent">➌</span>. This will hold either <code>y</code> or <code>n</code>, depending on which radio button is selected.</p>
<p class="indent"><span epub:type="pagebreak" id="page_233"/>Build an instruction label using the <code>Label</code> class <span class="ent">➍</span>. Then build the <code>self.yes</code> radio button <span class="ent">➎</span>. Use the <code>Radiobutton</code> class, pass it the parent window, and set its state to <code>disabled</code>. This way, the window will initialize with the yes/no buttons grayed out, so the player can’t jump the gun and try to change a door before first choosing one. The text parameter is the button name; use an abbreviated Y for <em>yes</em>. Set the widget’s variable argument to the <code>change_door</code> variable, set its value to <code>y</code>, and call the <code>show_final()</code> function. Repeat the process for the no button.</p>
<p class="indent">The last widgets you’ll need are <code>Text</code> widgets to show the counts for switching doors versus staying put. Use the <code>Text</code> class to display the statistics and set the text box color to match the parent window. To do this, use <code>cget()</code> to get the background (<code>bg</code>) color of <code>parent</code> and then assign it to a variable <span class="ent">➏</span>. The <code>cget()</code> method returns the current value for a <code>tkinter</code> option as a string.</p>
<p class="indent">Create a text object to display the wins for sticking with the first choice <span class="ent">➐</span>. You need to pass the widget the parent window, a width and height, how to wrap text if it extends beyond a row, a background color, a foreground color—the text color—and a border width for the text box. Note that you don’t include any actual text; this will be added later by the <code>show_final()</code> method.</p>
<p class="indent">Finish with another text widget to display the number of wins attributed to switching doors.</p>
<h5 class="h5" id="lev263"><strong>Arranging the Widgets</strong></h5>
<p class="noindent"><a href="ch11.xhtml#ch11list8">Listing 11-8</a> completes the <code>create_widgets()</code> method by using the <code>tkinter</code> <code>Grid</code> geometry manager to position the remaining nongridded widgets in the game window.</p>
<p class="margin"><em>monty_hall_gui.py,</em> part 4</p>
<pre>           # place the widgets in the frame<br/>        <span class="ent">➊</span> a.grid(row=1, column=4, sticky='W', padx=20)<br/>           b.grid(row=1, column=4, sticky='N', padx=20)<br/>           c.grid(row=1, column=4, sticky='E', padx=20)<br/>           self.yes.grid(row=2, column=4, sticky='W', padx=20)<br/>           self.no.grid(row=2, column=4, sticky='N', padx=20)<br/>        <span class="ent">➋</span> self.unchanged_wins_txt.grid(row=1, column=5, columnspan=5)<br/>           self.changed_wins_txt.grid(row=2, column=5, columnspan=5)</pre>
<p class="listing" id="ch11list8"><em>Listing 11-8: Calls the</em> <span class="codeitalic">grid()</span> <em>method on the widgets to position them in the frame</em></p>
<p class="indent">Use <code>grid()</code> to position the door buttons in the parent window <span class="ent">➊</span>. Group the three door buttons together in the same row and column and separate them using the <code>sticky</code> justification: <code>W</code> means left, <code>N</code> is center, and <code>E</code> is right. Use <code>padx</code> to tweak the positions laterally. Repeat this process for the remaining buttons, then position the win statistics text widgets and allow them to span the five columns on the right side of the window <span class="ent">➋</span>.</p>
<h5 class="h5" id="lev264"><span epub:type="pagebreak" id="page_234"/><strong>Updating the Door Image</strong></h5>
<p class="noindent">You’ll need to open and close doors throughout the game, so <a href="ch11.xhtml#ch11list9">Listing 11-9</a> defines a helper method to update the door image as appropriate. Note that, with OOP, you don’t need to pass a filename to the method as an argument. All the methods for an object have direct access to attributes that begin with <code>self</code>.</p>
<p class="margin"><em>monty_hall_gui.py,</em> part 5</p>
<pre>    <span class="ent">➊</span> def update_image(self):<br/>           """Update current doors image."""<br/>        <span class="ent">➋</span> img = tk.PhotoImage(file=self.img_file)<br/>        <span class="ent">➌</span> self.photo_lbl.configure(image=img)<br/>        <span class="ent">➍</span> self.photo_lbl.image = img</pre>
<p class="listing" id="ch11list9"><em>Listing 11-9: Defines a method to update the current door image</em></p>
<p class="indent">Define a function, called <code>update_image()</code>, that takes <code>self</code> as an argument <span class="ent">➊</span>. Then use the <code>PhotoImage</code> class as you did in <a href="ch11.xhtml#ch11list6">Listing 11-6</a> <span class="ent">➋</span>. The filename, <em>self.img_file</em>, will be updated in other methods.</p>
<p class="indent">Because you’ve already created the label that holds the door image, use the <code>configure()</code> method to change the label—in this case, by loading a new image <span class="ent">➌</span>. You can use either <code>configure()</code> or <code>config()</code>. Finish by assigning the image to a widget attribute to fend off garbage collection <span class="ent">➍</span>, as described for <a href="ch11.xhtml#ch11list6">Listing 11-6</a>.</p>
<h5 class="h5" id="lev265"><strong>Selecting the Winning Door and Revealing a Goat</strong></h5>
<p class="noindent"><a href="ch11.xhtml#ch11list10">Listing 11-10</a> defines a method that selects the winning door and the reveal door and then opens and closes the reveal door. It also activates the yes/no buttons, which are grayed out until the player makes their first door choice.</p>
<p class="margin"><em>monty_hall_gui.py,</em> part 6</p>
<pre>    <span class="ent">➊</span> def win_reveal(self):<br/>           """Randomly pick winner and reveal unchosen door with goat."""<br/>        <span class="ent">➋</span> door_list = list(self.doors)<br/>        <span class="ent">➌</span> self.choice = self.door_choice.get()<br/>           self.winner = random.choice(door_list)<br/><br/>        <span class="ent">➍</span> door_list.remove(self.winner)<br/><br/>        <span class="ent">➎</span> if self.choice in door_list:<br/>               door_list.remove(self.choice)<br/>               self.reveal = door_list[0]<br/>           else:<br/>               self.reveal = random.choice(door_list)<br/><br/>        <span class="ent">➏</span> self.img_file = ('reveal_{}.png'.format(self.reveal))<br/>           self.update_image()<br/><br/>           # turn on and clear yes/no buttons<br/>        <span class="ent">➐</span> self.yes.config(state='normal')<br/>           self.no.config(state='normal')<br/>           self.change_door.set(None)<br/><br/><span epub:type="pagebreak" id="page_235"/>           # close doors 2 seconds after opening<br/>        <span class="ent">➑</span> self.img_file = 'all_closed.png'<br/>           self.parent.after(2000, self.update_image)</pre>
<p class="listing" id="ch11list10"><em>Listing 11-10: Defines a method to randomly select the winning door and reveal door</em></p>
<p class="indent">Define a method, called <code>win_reveal()</code>, that takes <code>self</code> as an argument <span class="ent">➊</span>. Immediately make a list of the doors from the class attribute <code>doors</code> <span class="ent">➋</span>. You’ll alter this list based on the player’s first door choice and then the winning door, picked at random by the program.</p>
<p class="indent">Now, assign a <code>self.choice</code> attribute to the <code>self.door_choice</code> string variable, accessed with the <code>get()</code> method <span class="ent">➌</span>. The value of this attribute was determined by the door radio button that the user clicked as their first choice. Next, choose the winning door, at random, from the door list.</p>
<p class="indent">Remove the winning door from the door list <span class="ent">➍</span>. Then use a conditional to see whether the player’s choice is still in the door list; if it is, remove it so that it can’t be revealed <span class="ent">➎</span>. This will leave only one door in the list, so assign it to the <code>self.reveal</code> attribute.</p>
<p class="indent">If the player picked the winning door, there are two doors left in the list, so randomly choose one of them and assign it to <code>self.reveal</code>. Update the <code>self.img_file</code> attribute for this door <span class="ent">➏</span>, then call the method that updates the photo label to show the new image. <a href="ch11.xhtml#ch11fig6">Figure 11-6</a> is an example of the reveal image for door B.</p>
<div class="image"><a id="ch11fig6"/><img src="../images/f0235-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 11-6: The reveal image for Door B</em></p>
<p class="indent">Next, set the state of the yes and no buttons to <code>normal</code> <span class="ent">➐</span>. After this, they will no longer be grayed out. End the method by changing the image file to <em>all_closed.png</em> and calling the <code>self.update_image()</code> method on the <code>parent</code> window after 2,000 milliseconds have elapsed <span class="ent">➑</span>. This will ensure the doors stay open no longer than 2 seconds.</p>
<h5 class="h5" id="lev266"><span epub:type="pagebreak" id="page_236"/><strong>Revealing the Player’s Final Choice</strong></h5>
<p class="noindent"><a href="ch11.xhtml#ch11list11">Listing 11-11</a> defines the first part of a function that takes the player’s final door choice and reveals what’s behind it. The function will also keep track of the number of wins for switching doors or staying put.</p>
<p class="margin"><em>monty_hall_gui.py,</em> part 7</p>
<pre>    <span class="ent">➊</span> def show_final(self):<br/>           """Reveal image behind user's final door choice &amp; count wins."""<br/>        <span class="ent">➋</span> door_list = list(self.doors)<br/><br/>        <span class="ent">➌</span> switch_doors = self.change_door.get()<br/><br/>        <span class="ent">➍</span> if switch_doors == 'y':<br/>               door_list.remove(self.choice)<br/>               door_list.remove(self.reveal)<br/>            <span class="ent">➎</span> new_pick = door_list[0]<br/>            <span class="ent">➏</span> if new_pick == self.winner:<br/>                   self.img_file = 'money_{}.png'.format(new_pick)<br/>                   self.pick_change_wins += 1<br/>               else:<br/>                   self.img_file = 'goat_{}.png'.format(new_pick)<br/>                   self.first_choice_wins += 1<br/>        <span class="ent">➐</span> elif switch_doors == 'n':<br/>            <span class="ent">➑</span> if self.choice == self.winner:<br/>                   self.img_file = 'money_{}.png'.format(self.choice)<br/>                   self.first_choice_wins += 1<br/>               else:<br/>                   self.img_file = 'goat_{}.png'.format(self.choice)<br/>                   self.pick_change_wins += 1<br/><br/>           # update door image<br/>        <span class="ent">➒</span> self.update_image()</pre>
<p class="listing" id="ch11list11"><em>Listing 11-11: Defines a method to reveal the player’s final choice and update win lists</em></p>
<p class="indent">Define a method, called <code>show_final()</code>, that takes—you guessed it—<code>self</code> as an argument <span class="ent">➊</span>. Make a new copy of the door list <span class="ent">➋</span>, then get the <code>self.change_doors</code> variable and assign it to an attribute named <code>switch_doors</code> <span class="ent">➌</span>. This variable will hold either a <code>'y'</code> or an <code>'n'</code>, depending on which radio button the player clicked.</p>
<p class="indent">If the player chose to switch doors <span class="ent">➍</span>, remove their first choice and the revealed door from the list and assign a <code>new_pick</code> attribute to the remaining door <span class="ent">➎</span>. If this new pick is the winning door <span class="ent">➏</span>, reference the proper image and advance the <code>self.pick_change_wins</code> counter. Otherwise, set the image to a goat and advance the <code>self.first_choice_wins</code> counter.</p>
<p class="indent">If the player decides to not change doors <span class="ent">➐</span> and if their first choice was the winning door <span class="ent">➑</span>, reveal the money bag and advance the <code>self.first_choice_</code><code>wins</code> counter. Otherwise, show a goat and advance the <code>self.pick_change_wins</code> counter.</p>
<p class="indent">Finish by calling the <code>update_image()</code> method to update the image <span class="ent">➒</span>. Again, you don’t need to pass it the name of the new image file, as it can access the <code>self.img_file</code> attribute that you changed in the preceding code.</p>
<h5 class="h5" id="lev267"><span epub:type="pagebreak" id="page_237"/><strong>Displaying Statistics</strong></h5>
<p class="noindent"><a href="ch11.xhtml#ch11list12">Listing 11-12</a> completes the <code>show_final()</code> method by updating the game window for the number of wins statistics, disabling the yes/no buttons, and closing all the doors.</p>
<p class="margin"><em>monty_hall_gui.py,</em> part 8</p>
<pre>           # update displayed statistics<br/>        <span class="ent">➊</span> self.unchanged_wins_txt.delete(1.0, 'end')<br/>        <span class="ent">➋</span> self.unchanged_wins_txt.insert(1.0, 'Unchanged wins = {:d}'<br/>                                          .format(self.first_choice_wins))<br/>           self.changed_wins_txt.delete(1.0, 'end')<br/>           self.changed_wins_txt.insert(1.0, 'Changed wins = {:d}'<br/>                                        .format(self.pick_change_wins))<br/><br/>           # turn off yes/no buttons and clear door choice buttons<br/>        <span class="ent">➌</span> self.yes.config(state='disabled')<br/>           self.no.config(state='disabled')<br/>        <span class="ent">➍</span> self.door_choice.set(None)<br/><br/>        <span class="ent">➎</span> # close doors 2 seconds after opening<br/>           self.img_file = 'all_closed.png'<br/>           self.parent.after(2000, self.update_image)</pre>
<p class="listing" id="ch11list12"><em>Listing 11-12: Displays win statistics, disables the yes/no buttons, and closes all the doors</em></p>
<p class="indent">Start by deleting any text in the <code>self.unchanged_wins_txt</code> text widget <span class="ent">➊</span>. Begin deleting at a text index of <code>1.0</code>. The format is <code>line.column</code>, so you are specifying the first line and first column of the text widget (line numbering starts at 1, column numbering at 0). Finish with <code>'end'</code>, which will ensure that all the text after the starting index is deleted.</p>
<p class="indent">Next, use the <code>insert()</code> method to add the <code>self.first_choice_wins</code> attribute value, along with some descriptive text, to the text widget <span class="ent">➋</span>. Begin inserting at text index <code>1.0</code>.</p>
<p class="indent">Repeat this process for the <code>self.changed_wins_txt</code> text widget, and then disable the yes/no buttons by setting their <code>config</code> state to <code>'disabled'</code> <span class="ent">➌</span>. Set the <code>self.door_choice</code> string variable back to <code>None</code>, and you’re ready to start a new game <span class="ent">➍</span>.</p>
<p class="indent">End the method by closing the doors, as you did in <a href="ch11.xhtml#ch11list10">Listing 11-10</a> <span class="ent">➎</span>.</p>
<h5 class="h5" id="lev268"><strong>Setting Up the Root Window and Running the Event Loop</strong></h5>
<p class="noindent"><a href="ch11.xhtml#ch11list13">Listing 11-13</a> completes the <em>monty_hall_gui.py</em> program by setting up the <code>tkinter</code> <code>root</code> window, instantiating the game object, and running <code>mainloop()</code>. Alternatively, this code could be encapsulated in a <code>main()</code> function.</p>
<p class="margin"><em>monty_hall_gui.py,</em> part 9</p>
<pre>   # set up root window &amp; run event loop<br/><span class="ent">➊</span> root = tk.Tk()<br/><span class="ent">➋</span> root.title('Monty Hall Problem')<br/><span class="ent">➌</span> root.geometry('1280x820')  # pics are 1280 x 720<br/><span class="ent">➍</span> game = Game(root)<br/>   root.mainloop()</pre>
<p class="listing" id="ch11list13"><em>Listing 11-13: Sets up the</em> <span class="codeitalic">root</span> <em>window, creates a game object, and runs</em> <span class="codeitalic">mainloop()</span></p>
<p class="indent"><span epub:type="pagebreak" id="page_238"/>The <code>Tk</code> class is instantiated without arguments <span class="ent">➊</span>. This creates a top-level <code>tkinter</code> widget, which will be the main window of the game application. Assign it to a variable named <code>root</code>.</p>
<p class="indent">Give the window a title <span class="ent">➋</span> and a size in pixels <span class="ent">➌</span>. Note that the size of the images influences the geometry so that they fit attractively in the window, with ample room below for instructions and messages.</p>
<p class="indent">Now, create the game <span class="ent">➍</span>. Pass it the <code>root</code> window, which will be the <em>master</em> that will contain the game. This results in a new game being placed inside the <code>root</code> window.</p>
<p class="indent">Finish by invoking the <code>mainloop()</code> method on <code>root</code>, which keeps the window open and waiting to handle events.</p>
<h3 class="h3" id="lev269"><strong>Summary</strong></h3>
<p class="noindent">In this chapter, you used a simple Monte Carlo simulation to confirm that switching doors is the best strategy for the Monty Hall problem. You then used <code>tkinter</code> to build a fun interface to let schoolchildren test this conclusion manually, game by game. Best of all, you learned how to use object-oriented programming to build interactive widgets that respond to user input.</p>
<h3 class="h3" id="lev270"><strong>Further Reading</strong></h3>
<p class="noindent">Useful <code>tkinter</code> references can be found in “<a href="ch10.xhtml#lev241">Further Reading</a>” on <a href="ch10.xhtml#page_212">page 212</a>.</p>
<p class="indent">You can find a summary of the 1990 Monty Hall problem controversy online at <em><a href="http://marilynvossavant.com/game-show-problem/">http://marilynvossavant.com/game-show-problem/</a></em>.</p>
<h3 class="h3" id="lev271"><strong>Practice Project: The Birthday Paradox</strong></h3>
<p class="noindent">How many people need to be in a room for there to be a 50/50 chance that two of them share the same birth month and day? According to the <em>birthday paradox</em>, not that many! As with the Monty Hall problem, the outcome is counterintuitive.</p>
<p class="indent">Use MCS to determine how many people it takes to reach the 50 percent mark. Have the program print out the number of people and the probability for a range of room occupants. If you find yourself looking up how to format dates, stop and simplify! You can find a solution, <em>birthday_paradox_practice.py</em>, in the appendix or online at <em><a href="https://www.nostarch.com/impracticalpython/">https://www.nostarch.com/impracticalpython/</a></em>.</p>
</body></html>