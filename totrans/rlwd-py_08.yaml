- en: '8'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: DETECTING DISTANT EXOPLANETS
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Extrasolar planets, called exoplanets for short, are planets that orbit alien
    suns. By the end of 2019, more than 4,000 exoplanets had been discovered. That’s
    an average of 150 per year since the first confirmed discovery in 1992! These
    days, finding a faraway planet seems as easy as catching a cold, yet it took almost
    all human history—up to 1930—to discover the eight planets, plus Pluto, that make
    up our own solar system.
  prefs: []
  type: TYPE_NORMAL
- en: Astronomers detected the first exoplanets by observing gravitationally induced
    wobble in the motion of stars. Today, they rely mainly on the slight dimming of
    a star’s light as the exoplanet passes between the star and Earth. And with powerful
    next-generation devices like the James Webb Space Telescope, they’ll directly
    image exoplanets and learn about their rotation, seasons, weather, vegetation,
    and more.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll use OpenCV and matplotlib to simulate an exoplanet passing
    before its sun. You’ll record the resulting light curve and then use it to detect
    the planet and estimate its diameter. Then, you’ll simulate how an exoplanet might
    look to the James Webb Space Telescope. In the “Practice Project” sections, you’ll
    investigate unusual light curves that may represent enormous alien megastructures
    designed to harness a star’s energy.
  prefs: []
  type: TYPE_NORMAL
- en: '**Transit Photometry**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In astronomy, a *transit* occurs when a relatively small celestial body passes
    directly between the disc of a larger body and an observer. When the small body
    moves across the face of the larger body, the larger body dims slightly. The best-known
    transits are those of Mercury and Venus against our own sun ([Figure 8-1](ch08.xhtml#ch08fig1)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-1: Clouds and Venus (the black dot) passing before the sun in June
    2012'
  prefs: []
  type: TYPE_NORMAL
- en: With today’s technology, astronomers can detect the subtle dimming of a faraway
    star’s light during a transit event. The technique, called *transit photometry*,
    outputs a plot of a star’s brightness over time ([Figure 8-2](ch08.xhtml#ch08fig2)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-2: The transit photometry technique for detecting exoplanets'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 8-2](ch08.xhtml#ch08fig2), the dots on the light curve graph represent
    measurements of the light given off by a star. When a planet is not positioned
    over the star ➊, the measured brightness is at a maximum. (We’ll ignore light
    reflected off the exoplanet as it goes through its phases, which would very slightly
    increase the apparent brightness of the star). As the leading edge of a planet
    moves onto the disc ➋, the emitted light progressively dims, forming a ramp in
    the light curve. When the entire planet is visible against the disc ➌, the light
    curve flattens, and it remains flat until the planet begins exiting the far side
    of the disc. This creates another ramp ➍, which rises until the planet passes
    completely off the disc ➎. At that point, the light curve flattens at its maximum
    value, as the star is no longer obscured.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the amount of light blocked during a transit is proportional to the
    size of the planet’s disc, you can calculate the radius of the planet using the
    following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/equ_page_179_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: where *R*[p] is the planet’s radius and *R*[*s*] is the star’s radius. Astronomers
    determine the star’s radius using its distance, brightness, and color, which relates
    to its temperature. *Depth* refers to the total change in brightness during the
    transit ([Figure 8-3](ch08.xhtml#ch08fig3)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-3: Depth represents the total change in brightness observed in a light
    curve.'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, these calculations assume that the whole exoplanet, not just part
    of it, moved over the face of the star. The latter may occur if the exoplanet
    skims either the top or bottom of the star (from our point of view). We’ll look
    at this case in “Experimenting with Transit Photometry” on [page 182](ch08.xhtml#page_182).
  prefs: []
  type: TYPE_NORMAL
- en: '**Project #11: Simulating an Exoplanet Transit**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before I flew to Idaho to photograph the Great American Eclipse of 2017, I did
    my homework. The totality event, when the moon completely covered the sun, lasted
    only 2 minutes and 10 seconds. That left no time for experimenting, testing, or
    figuring things out on the fly. To successfully capture images of the penumbra,
    umbra, solar flares, and diamond ring effect ([Figure 8-4](ch08.xhtml#ch08fig4)),
    I had to know exactly what equipment to take, what camera settings to use, and
    when these events would occur.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-4: Diamond ring effect at the end of totality, 2017 solar eclipse'
  prefs: []
  type: TYPE_NORMAL
- en: In a similar fashion, computer simulations prepare you for making observations
    of the natural world. They help you understand what to expect, when to expect
    it, and how to calibrate your instruments. In this project, you’ll create a simulation
    of an exoplanet transit event. You can run this simulation with different planet
    sizes to understand the impact of a transit’s size on the light curve. Later,
    you’ll use this simulation to evaluate light curves related to asteroid fields
    and possible alien megastructures.
  prefs: []
  type: TYPE_NORMAL
- en: THE OBJECTIVE
  prefs: []
  type: TYPE_NORMAL
- en: Write a Python program that simulates an exoplanet transit, plots the resulting
    light curve, and calculates the radius of the exoplanet.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Strategy***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To generate a light curve, you need to be able to measure changes in brightness.
    You can do this by performing mathematical operations on pixels, such as finding
    mean, minimum, and maximum values, with OpenCV.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of using an image of a real transit and star, you’ll draw circles on
    a black rectangle, just as you drew rectangles on the Mars map in the previous
    chapter. To plot the light curve, you can use matplotlib, Python’s main plotting
    library. You installed matplotlib in “Installing NumPy and Other Scientific Packages
    with pip” on [page 8](ch01.xhtml#page_8) and began using it to make graphs in
    [Chapter 2](ch02.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: '***The Transit Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *transit.py* program uses OpenCV to generate a visual simulation of an exoplanet
    transiting a star, plots the resulting light curve with matplotlib, and estimates
    the size of the planet using the planetary radius equation from [page 179](ch08.xhtml#page_179).
    You can enter the code yourself or download it from *[https://nostarch.com/real-world-python/](https://nostarch.com/real-world-python/)*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Importing Modules and Assigning Constants**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 8-1](ch08.xhtml#ch08list1) imports modules and assigns constants representing
    user input.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-1: Importing modules and assigning constants'
  prefs: []
  type: TYPE_NORMAL
- en: Import the math module for the planetary radius equation, NumPy for calculating
    the brightness of the image, OpenCV for drawing the simulation, and matplotlib
    for plotting the light curve. Then start assigning constants that will represent
    user-input values.
  prefs: []
  type: TYPE_NORMAL
- en: Start with a height and width for the simulation window. The window will be
    a black, rectangular image built using the np.zeros() method, which returns an
    array of a given shape and type filled with zeros.
  prefs: []
  type: TYPE_NORMAL
- en: Recall that OpenCV images are NumPy arrays and items in the arrays must have
    the same type. The uint8 data type represents an unsigned integer from 0 to 255\.
    You can find a useful listing of other data types and their descriptions at *[https://numpy.org/devdocs/user/basics.types.html](https://numpy.org/devdocs/user/basics.types.html)*.
  prefs: []
  type: TYPE_NORMAL
- en: Next, assign radius values, in pixels, for the star and exoplanet. OpenCV will
    use these constants when it draws circles representing them.
  prefs: []
  type: TYPE_NORMAL
- en: The exoplanet will move across the face of the star, so you need to define how
    quickly it will move. The EXO_DX constant will increment the exoplanet’s *x* position
    by three pixels with each programming loop, causing the exoplanet to move left
    to right.
  prefs: []
  type: TYPE_NORMAL
- en: Assign two constants to set the exoplanet’s starting position. Then assign a
    NUM_FRAMES constant to control the number of simulation updates. Although you
    can calculate this number (IMG_WIDTH/EXO_DX), assigning it lets you fine-tune
    the duration of the simulation.
  prefs: []
  type: TYPE_NORMAL
- en: '**Defining the main() Function**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 8-2](ch08.xhtml#ch08list2) defines the main() function used to run
    the program. Although you can define main() anywhere, placing it at the start
    lets it serve as a summary for the whole program, thus giving context to the functions
    defined later. As part of main(), you’ll calculate the exoplanet’s radius, nesting
    the equation within the call to the print() function.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-2: Defining the main() function'
  prefs: []
  type: TYPE_NORMAL
- en: After defining the main() function, name a variable intensity_samples and call
    the record_transit() function. *Intensity* refers to the amount of light, represented
    by the numerical value of a pixel. The record_transit() function draws the simulation
    to the screen, measures its intensity, appends the measurement to a list called
    intensity_samples, and returns the list. It needs the starting point (*x*, *y*)
    coordinates for the exoplanet. Pass it the starting constants EXO_START_X and
    EXO_START_Y, which will place the planet in a position similar to ➊ in [Figure
    8-2](ch08.xhtml#ch08fig2). Note that if you increase the exoplanet’s radius significantly,
    you may need to move the starting point farther to the left (negative values are
    acceptable).
  prefs: []
  type: TYPE_NORMAL
- en: Next, name a variable relative_brightness and call the calc_rel_brightness()
    function. As its name suggests, this function calculates *relative* brightness,
    which is the measured intensity divided by the maximum recorded intensity. It
    takes the list of intensity measurements as an argument, converts the measurements
    to relative brightness, and returns the new list.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll use the list of relative brightness values to calculate the radius of
    the exoplanet, in pixels, using the equation from [page 179](ch08.xhtml#page_179).
    You can perform the calculation as part of the print() function. Use the {:.2f}
    format to report the answer to two decimal points.
  prefs: []
  type: TYPE_NORMAL
- en: End the main() function by calling the function to plot the light curve. Pass
    it the relative_brightness list.
  prefs: []
  type: TYPE_NORMAL
- en: '**Recording the Transit**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 8-3](ch08.xhtml#ch08list3) defines a function to simulate and record
    the transit event. It draws the star and exoplanet on a black rectangular image
    and then moves the exoplanet. It also calculates and displays the average intensity
    of the image with each move, appends the intensity to a list, and returns the
    list at the end.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-3: Drawing the simulation, calculating the image intensity, and returning
    it as a list'
  prefs: []
  type: TYPE_NORMAL
- en: The record_transit() function takes a pair of (*x*, *y*) coordinates as arguments.
    These represent the starting point for the exoplanet or, more specifically, the
    pixel to use as the center of the first circle drawn in the simulation. It should
    not overlap with the star’s circle, which will be centered in the image.
  prefs: []
  type: TYPE_NORMAL
- en: Next, create an empty list to hold the intensity measurements. Then start a
    for loop that uses the NUM_FRAMES constant to repeat the simulation a certain
    number of times. The simulation should last slightly longer than it takes for
    the exoplanet to exit the face of the star. That way, you get a full light curve
    that includes post-transit measurements.
  prefs: []
  type: TYPE_NORMAL
- en: Drawings and text placed on an image with OpenCV become part of that image.
    Consequently, you need to replace the previous image with each loop by copying
    the original BLACK_IMG to a local variable called temp_img.
  prefs: []
  type: TYPE_NORMAL
- en: Now you can draw the star by using the OpenCV circle() method. Pass it the temporary
    image, the (*x*, *y*) coordinates for the center of the circle that correspond
    to the center of the image, the STAR_RADIUS constant, a fill color of white, and
    a line thickness. Using a negative number for thickness fills the circle with
    color.
  prefs: []
  type: TYPE_NORMAL
- en: Draw the exoplanet circle next. Use the exo_x and exo_y coordinates as its starting
    point, the EXO_RADIUS constant as its size, and a black fill color ➊.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you should record the intensity of the image. Since the pixels
    already represent intensity, all you need to do is take the mean of the image.
    The number of measurements you take is dependent on the EXO_DX constant. The larger
    this value, the faster the exoplanet will move, and the fewer times you will record
    the mean intensity.
  prefs: []
  type: TYPE_NORMAL
- en: Display the intensity reading on the image using OpenCV’s putText() method.
    Pass it the temporary image, a text string that includes the measurement, the
    (*x*, *y*) coordinates for the bottom-left corner of the text string, a font,
    a text size, and a color.
  prefs: []
  type: TYPE_NORMAL
- en: Now, name the window Transit and display it using OpenCV’s imshow() method.
    [Figure 8-5](ch08.xhtml#ch08fig5) shows a loop iteration.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-5: The exoplanet transiting the star'
  prefs: []
  type: TYPE_NORMAL
- en: After showing the image, use the OpenCV waitKey() method to update it every
    30 milliseconds. The lower the number passed to waitKey(), the faster the exoplanet
    will move across the star.
  prefs: []
  type: TYPE_NORMAL
- en: Append the intensity measurement to the intensity_samples list and then advance
    the exoplanet circle by incrementing its exo_x value by the EXO_DX constant ➋.
    Finish the function by returning the list of mean intensity measurements.
  prefs: []
  type: TYPE_NORMAL
- en: '**Calculating Relative Brightness and Plotting the Light Curve**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 8-4](ch08.xhtml#ch08list4) defines functions to calculate the relative
    brightness of each intensity sample and display the light curve graph. It then
    calls the main() function if the program is not being used as a module in another
    program.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-4: Calculating relative brightness, plotting the light curve, and
    calling main()'
  prefs: []
  type: TYPE_NORMAL
- en: Light curves display the *relative* brightness over time so that an un-obscured
    star has a value of 1.0 and a totally eclipsed star has a value of 0.0\. To convert
    the mean intensity measurements to relative values, define the calc_rel_brightness()
    function, which takes a list of mean intensity measurements as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: Within the function, start an empty list to hold the converted values and then
    use Python’s built-in max() function to find the maximum value in the intensity_samples
    list. To get relative brightness, loop through the items in this list and divide
    them by the maximum value. Append the result to the rel_brightness list as you
    go. End the function by returning the new list.
  prefs: []
  type: TYPE_NORMAL
- en: Define a second function to plot the light curve and pass it the rel_brightness
    list ➊. Use the matplotlib plot() method and pass it the list, a line color, a
    line style, a line width, and a label for the plot legend. Add the legend and
    plot title and then show the plot. You should see the chart in [Figure 8-6](ch08.xhtml#ch08fig6).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-6: Example light curve plot from transit.py'
  prefs: []
  type: TYPE_NORMAL
- en: 'The brightness variation on the plot might seem extreme at first glance, but
    if you look closely at the *y*-axis, you’ll see that the exoplanet diminished
    the star’s brightness by only 0.175 percent! To see how this looks on a plot of
    the star’s absolute brightness ([Figure 8-7](ch08.xhtml#ch08fig7)), add the following
    line just before plt.show():'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The deflection in the light curve caused by the transit is subtle but detectable.
    Still, you don’t want to go blind squinting at a light curve, so continue to let
    matplotlib automatically fit the *y*-axis as in [Figure 8-6](ch08.xhtml#ch08fig6).
  prefs: []
  type: TYPE_NORMAL
- en: Finish the program by calling the main() function ➋. In addition to the light
    curve, you should see the estimated radius of the exoplanet in the shell.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: That’s all there is to it. With fewer than 50 lines of Python code, you’ve developed
    a means of discovering exoplanets!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig08_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-7: Light curve from [Figure 8-6](ch08.xhtml#ch08fig6) with rescaled
    y-axis'
  prefs: []
  type: TYPE_NORMAL
- en: '***Experimenting with Transit Photometry***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that you have a working simulation, you can use it to model the behavior
    of transits, allowing you to better analyze real-life observations you’ll make
    in the future. One approach would be to run a lot of possible cases and produce
    an “atlas” of expected exoplanet responses. Researchers could use this atlas to
    help them interpret actual light curves.
  prefs: []
  type: TYPE_NORMAL
- en: For example, what if the plane of an exoplanet’s orbit is tilted with respect
    to Earth so that the exoplanet only partly crosses the star during transit? Would
    researchers be able to detect its position from its light curve signature, or
    would it just look like a smaller exoplanet doing a complete transit?
  prefs: []
  type: TYPE_NORMAL
- en: If you run the simulation with an exoplanet radius of 7 and let it skim the
    base of the star, you should get a U-shaped curve ([Figure 8-8](ch08.xhtml#ch08fig8)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig08_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-8: Light curve for an exoplanet with a radius of 7 that only partly
    crosses its star'
  prefs: []
  type: TYPE_NORMAL
- en: If you run the simulation again with an exoplanet radius of 5 and let the exoplanet
    pass fully over the face of the star, you get the graph in [Figure 8-9](ch08.xhtml#ch08fig9).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig08_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-9: Light curve for an exoplanet with a radius of 5 that fully crosses
    its star'
  prefs: []
  type: TYPE_NORMAL
- en: When an exoplanet skims the side of a star, never fully passing over it, the
    overlapping area changes constantly, generating the U-shaped curve in [Figure
    8-8](ch08.xhtml#ch08fig8). If the entire exoplanet passes over the face of the
    star, the base of the curve is flatter, as in [Figure 8-9](ch08.xhtml#ch08fig9).
    And because you never see the planet’s full disc against the star in a partial
    transit, you have no way to measure its true size. Thus, size estimates should
    be taken with a grain of salt if your light curve lacks a flattish bottom.
  prefs: []
  type: TYPE_NORMAL
- en: If you run a range of exoplanet sizes, you’ll see that the light curve changes
    in predictable ways. As size increases, the curve deepens, with longer ramps on
    either side, because a larger fraction of the star’s brightness is diminished
    ([Figures 8-10](ch08.xhtml#ch08fig10) and [8-11](ch08.xhtml#ch08fig11)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig08_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-10: Light curve for EXO_RADIUS = 28'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig08_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-11: Light curve for EXO_RADIUS = 145'
  prefs: []
  type: TYPE_NORMAL
- en: Because exoplanets are circular objects with smooth edges, they should produce
    light curves with smooth ramps that continuously increase or decrease. This is
    important knowledge, as astronomers have recorded decidedly bumpy curves when
    looking for exoplanets. In the “Practice Project” sections at the end of the chapter,
    you’ll use your program to explore oddly shaped light curves that might be explained
    by extraterrestrial engineering!
  prefs: []
  type: TYPE_NORMAL
- en: '**Project #12: Imaging Exoplanets**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By 2025, three powerful telescopes—two on Earth and one in space—will use infrared
    and visible light to directly image Earth-sized exoplanets. In the best-case scenario,
    the exoplanet will show up as a single saturated pixel with some bleed into the
    surrounding pixels, but that’s enough to tell whether the planet rotates, has
    continents and seas, experiences weather and seasons, and could support life as
    we know it!
  prefs: []
  type: TYPE_NORMAL
- en: In this project, you’ll simulate the process of analyzing an image taken from
    those telescopes. You’ll use Earth as a stand-in for a distant exoplanet. This
    way, you can easily relate known features, such as continents and oceans, to what
    you see in a single pixel. You’ll focus on the color composition and intensity
    of reflected light and make inferences about the exoplanet’s atmosphere, surface
    features, and rotation.
  prefs: []
  type: TYPE_NORMAL
- en: THE OBJECTIVE
  prefs: []
  type: TYPE_NORMAL
- en: Write a Python program that pixelates images of Earth and plots the intensity
    of the red, green, and blue color channels.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Strategy***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To demonstrate that you can capture different surface features and cloud formations
    with a single saturated pixel, you need only two images: one of the western hemisphere
    and one of the eastern. Conveniently, NASA has already photographed both hemispheres
    of Earth from space ([Figure 8-12](ch08.xhtml#ch08fig12)).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig08_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-12: Images of the western and eastern hemispheres'
  prefs: []
  type: TYPE_NORMAL
- en: The size of these images is 474×474 pixels, a resolution far too high for a
    future exoplanet image, where the exoplanet is expected to occupy 9 pixels, with
    only the center pixel fully covered by the planet ([Figure 8-13](ch08.xhtml#ch08fig13)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig08_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-13: The earth_west.png and earth_east.png images overlaid with a 9-pixel
    grid'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll need to degrade the Earth images by mapping them into a 3×3 array. Since
    OpenCV uses NumPy, this will be easy to do. To detect changes in the exoplanet’s
    surface, you’ll need to extract the dominant colors (blue, green, and red). OpenCV
    will let you average these color channels. Then you can display the results with
    matplotlib.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Pixelator Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *pixelator.py* program loads the two images of Earth, resizes them to 3×3
    pixels, and then resizes them again to 300×300 pixels. These final images are
    just for visualization; they have the same color information as the 3×3 images.
    The program then averages the color channels in both resized images and plots
    the results as pie charts that you can compare. You can download the code and
    two images (*earth_west.png* and *earth_east.png*) from the book’s website. Keep
    them in the same folder and don’t rename the images.
  prefs: []
  type: TYPE_NORMAL
- en: '**Importing Modules and Downscaling Images**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 8-5](ch08.xhtml#ch08list5) imports modules for plotting and image
    processing and then loads and degrades two images of Earth. It first reduces each
    to 9 pixels in a 3×3 array. It then enlarges the decimated images to 300×300 pixels
    so they are large enough to see and posts them to the screen.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-5: Importing modules and loading, degrading, and showing images'
  prefs: []
  type: TYPE_NORMAL
- en: Import NumPy and OpenCV to work with the images and use matplotlib to plot their
    color components as pie charts. Then start a list of filenames containing the
    two images of Earth.
  prefs: []
  type: TYPE_NORMAL
- en: Now start looping through the files in the list and use OpenCV to load them
    as NumPy arrays. Recall that OpenCV loads color images by default, so you don’t
    need to add an argument for this.
  prefs: []
  type: TYPE_NORMAL
- en: Your goal is to reduce the image of Earth into a single saturated pixel surrounded
    by partially saturated pixels. To degrade the images from their original 474×474
    size to 3×3, use OpenCV’s resize() method. First, name the new image *pixelated*
    and pass the method the current image, the new width and height in pixels, and
    an interpolation method. *Interpolation* occurs when you resize an image and use
    known data to estimate values at unknown points. The OpenCV documentation recommends
    the INTER_AREA interpolation method for shrinking images (see the geometric image
    transformations at *[https://docs.opencv.org/4.3.0/da/d54/group__imgproc__transform.html](https://docs.opencv.org/4.3.0/da/d54/group__imgproc__transform.html)*).
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you have a tiny image that’s too small to visualize, so resize
    it again to 300×300 so you can check the results. Use either INTER_NEAREST or
    INTER_AREA as the interpolation method, as these will preserve the pixel boundaries.
  prefs: []
  type: TYPE_NORMAL
- en: Show the image ([Figure 8-14](ch08.xhtml#ch08fig14)) and delay the program for
    two seconds using waitKey().
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig08_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-14: Grayscale view of the pixelated color images'
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can’t restore the images to their original state by resizing them
    to 474×474\. Once you average the pixel values down to a 3×3 matrix, all the detailed
    information is lost forever.
  prefs: []
  type: TYPE_NORMAL
- en: '**Averaging the Color Channels and Making the Pie Charts**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Still in the for loop, [Listing 8-6](ch08.xhtml#ch08list6) makes and displays
    pie charts of the blue, green, and red color components of each pixelated image.
    You can compare these to make inferences about the planet’s weather, landmasses,
    rotation, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-6: Splitting out and averaging color channels and making a pie chart
    of colors'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use OpenCV’s split() method to break out the blue, green, and red color channels
    in the pixelated image and unpack the results into b, g, and r variables. These
    are arrays, and if you call print(b), you should see this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Each number represents a pixel—specifically, the pixel’s blue value—in the 3×3
    pixelated image. To average the arrays, first make an empty list to hold the averages
    and then loop through the arrays and call the NumPy average method, appending
    the results to the list.
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re ready to make pie charts of the color averages in each pixelated
    image. Start by assigning color names to a variable named labels, which you’ll
    use to annotate the pie wedges. Next, specify the colors you want to use in the
    pie chart. These will override the matplotlib default choices. To make the chart,
    use the fig, ax naming convention for figure and axis, call the subplots() method,
    and pass it a figure size in inches.
  prefs: []
  type: TYPE_NORMAL
- en: Because the colors will vary only slightly between images, you’ll want to post
    the percentage of each color in its pie wedge so you can easily see whether there’s
    a difference between them. Unfortunately, the matplotlib default is to use black
    text that can be hard to see against a dark background. To fix this, call the
    ax.pie() method for making pie charts and use its autotexts list ➊. The method
    returns three lists, one concerning the pie wedges, one concerning the labels,
    and one for numeric labels, called *autotexts*. You need only the last one, so
    treat the first two as unused variables by assigning them to an underscore symbol.
  prefs: []
  type: TYPE_NORMAL
- en: Pass ax.pie() the list of color averages and the list of labels and set its
    autopct parameter to show numbers to one decimal place. If this parameter is set
    to None, the autotexts list will not be returned. Finish the arguments by passing
    the list of colors to use for the pie wedges.
  prefs: []
  type: TYPE_NORMAL
- en: 'The autotexts list for the first image looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Each Text object has (*x*, *y*) coordinates and a percent value as a text string.
    These will still post in black, so you need to loop through the objects and change
    the color to white using their set_color() method. Now all you need to do is set
    the chart title to the filename and show the plots ([Figure 8-15](ch08.xhtml#ch08fig15)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig08_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-15: The pie charts produced by pixelator.py'
  prefs: []
  type: TYPE_NORMAL
- en: Although the pie charts are similar, the differences are meaningful. If you
    compare the original color images, you’ll see that the *earth_west.png* photograph
    includes more ocean and should produce a larger blue wedge.
  prefs: []
  type: TYPE_NORMAL
- en: '**Plotting a Single Pixel**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The charts in [Figure 8-15](ch08.xhtml#ch08fig15) are for the whole image, which
    includes a sampling of black space. For an uncontaminated sample, you could use
    the single saturated pixel at the center of each image, as shown in [Listing 8-7](ch08.xhtml#ch08list7).
    This code represents an edited copy of *pixelator.py*, with the lines that change
    annotated. You can find a digital copy in the *Chapter_8* folder as *pixelator_saturated_only.py*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-7: Plotting pie charts for the colors in the center pixel of the
    pixelated image'
  prefs: []
  type: TYPE_NORMAL
- en: The four lines of code in [Listing 8-6](ch08.xhtml#ch08list6) that split the
    image and averaged the color channels can be replaced with one line ➊. The pixelated
    variable is a NumPy array, and [1, 1] represents row 1, column 1 in the array.
    Remember that Python starts counting at 0, so these values correspond to the center
    of a 3×3 array. If you print the color_values variable, you’ll see another array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: These are the blue, green, and red color channel values for the center pixel,
    and you can pass them directly to matplotlib ➋. For clarity, change the plot title
    so it indicates that you’re analyzing the center pixel only ➌. [Figure 8-16](ch08.xhtml#ch08fig16)
    shows the resulting plots.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig08_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-16: The single-pixel pie charts produced by pixelator_saturated_only.py'
  prefs: []
  type: TYPE_NORMAL
- en: The color differences between the western and eastern hemispheres in [Figures
    8-15](ch08.xhtml#ch08fig15) and [8-16](ch08.xhtml#ch08fig16) are subtle, but you
    know they’re real because you *forward modeled* the response. That is, you produced
    the result from actual observations, so you know the result is meaningful, repeatable,
    and unique.
  prefs: []
  type: TYPE_NORMAL
- en: In a real exoplanet survey, you’d want to take as many images as possible. If
    similar intensity and color patterns persist over time, then you can rule out
    stochastic effects such as weather. If the color patterns change predictably over
    long time periods, you may be seeing the effect of seasons, such as the presence
    of white polar caps in the winter and the spread of green vegetation in the spring
    and summer.
  prefs: []
  type: TYPE_NORMAL
- en: If measurements repeat periodically over relatively short time spans, you can
    infer that the planet is rotating on its axis. In the “Practice Project” sections
    at the end of the chapter, you’ll get a chance to calculate the length of an exoplanet’s
    day.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you used OpenCV, NumPy, and matplotlib to create images and
    measure their properties. You also resized images to different resolutions and
    plotted image intensity and color channel information. With short and simple Python
    programs, you simulated important methods that astronomers use to discover and
    study distant exoplanets.
  prefs: []
  type: TYPE_NORMAL
- en: '**Further Reading**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*How to Search for Exoplanets*, by the Planetary Society (*[https://www.planetary.org/](https://www.planetary.org/)*),
    is a good overview of the techniques used to search for exoplanets, including
    the strengths and weaknesses of each method.'
  prefs: []
  type: TYPE_NORMAL
- en: “Transit Light Curve Tutorial,” by Andrew Vanderburg, explains the basics of
    the transit photometry method and provides links to Kepler Space Observatory transit
    data. You can find it at *[https://www.cfa.harvard.edu/~avanderb/tutorial/tutorial.html](https://www.cfa.harvard.edu/~avanderb/tutorial/tutorial.html)*.
  prefs: []
  type: TYPE_NORMAL
- en: “NASA Wants to Photograph the Surface of an Exoplanet” (Wired, 2020), by Daniel
    Oberhaus, describes the effort to turn the sun into a giant camera lens for studying
    exoplanets.
  prefs: []
  type: TYPE_NORMAL
- en: '“Dyson Spheres: How Advanced Alien Civilizations Would Conquer the Galaxy”
    ([Space.com](http://Space.com), 2014), by Karl Tate, is an infographic on how
    an advanced civilization could capture the power of a star using vast arrays of
    solar panels.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Ringworld* (Ballantine Books, 1970), by Larry Niven, is one of the classic
    novels of science fiction. It tells the story of a mission to a massive abandoned
    alien construct—the Ringworld—that encircles an alien star.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Practice Project: Detecting Alien Megastructures**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In 2015, citizen scientists working on data from the Kepler space telescope
    noticed something odd about Tabby’s Star, located in the constellation Cygnus.
    The star’s light curve, recorded in 2013, exhibited irregular changes in brightness
    that were far too large to be caused by a planet ([Figure 8-17](ch08.xhtml#ch08fig17)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig08_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-17: Light curve for Tabby’s Star, measured by the Kepler Space Observatory'
  prefs: []
  type: TYPE_NORMAL
- en: Besides the dramatic drop in brightness, the light curve was asymmetrical and
    included weird bumps that aren’t seen in typical planetary transits. Proposed
    explanations posited that the light curve was caused by the consumption of a planet
    by the star, the transit of a cloud of disintegrating comets, a large ringed planet
    trailed by swarms of asteroids, or an *alien megastructure*.
  prefs: []
  type: TYPE_NORMAL
- en: Scientists speculated that an artificial structure of this size was most likely
    an attempt by an alien civilization to collect energy from its sun. Both science
    literature and science fiction describe these staggeringly large solar panel projects.
    Examples include Dyson swarms, Dyson spheres, ringworlds, and Pokrovsky shells
    ([Figure 8-18](ch08.xhtml#ch08fig18)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig08_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-18: Pokrovsky shell system of rings around a star designed to intercept
    the star’s radiation'
  prefs: []
  type: TYPE_NORMAL
- en: In this practice project, use the *transit.py* program to approximate the shape
    and depth of the Tabby’s Star light curve. Replace the circular exoplanet used
    in the program with other simple geometric shapes. You don’t need to match the
    curve exactly; just capture key features such as the asymmetry, the “bump” seen
    around February 28, and the large drop in brightness.
  prefs: []
  type: TYPE_NORMAL
- en: You can find my attempt, *practice_tabbys_star.py*, in the *Chapter_8* folder,
    downloadable from the book’s website at *[https://nostarch.com/real-world-python/](https://nostarch.com/real-world-python/),*
    and in the appendix. It produces the light curve shown in [Figure 8-19](ch08.xhtml#ch08fig19).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig08_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-19: Light curve produced by practice_tabbys_star.py'
  prefs: []
  type: TYPE_NORMAL
- en: We now know that whatever is orbiting Tabby’s Star allows some wavelengths of
    light to pass, so it can’t be a solid object. Based on this behavior and the wavelengths
    it absorbed, scientists believe dust is responsible for the weird shape of the
    star’s light curve. Other stars, however, like HD 139139 in the constellation
    Libra, have bizarre light curves that remain unexplained at the time of this writing.
  prefs: []
  type: TYPE_NORMAL
- en: '**Practice Project: Detecting Asteroid Transits**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Asteroid fields may be responsible for some bumpy and asymmetrical light curves.
    These belts of debris often originate from planetary collisions or the creation
    of a solar system, like the Trojan asteroids in Jupiter’s orbit ([Figure 8-20](ch08.xhtml#ch08fig20)).
    You can find an interesting animation of the Trojan asteroids on the web page
    “Lucy: The First Mission to the Trojan Asteroids” at *[https://www.nasa.gov/](https://www.nasa.gov/)*.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig08_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-20: More than one million Trojan asteroids share Jupiter’s orbit.'
  prefs: []
  type: TYPE_NORMAL
- en: Modify the *transit.py* program so that it randomly creates asteroids with radii
    between 1 and 3, weighted heavily toward 1\. Allow the user to input the number
    of asteroids. Don’t bother calculating the exoplanet radius, since the calculation
    assumes you’re dealing with a single spherical object, which you’re not. Experiment
    with the number of asteroids, the size of the asteroids, and the spread (the *x*-range
    and *y*-range in which the asteroids exist) to see the impact on the light curve.
    [Figure 8-21](ch08.xhtml#ch08fig21) shows one such example.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig08_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-21: Irregular, asymmetrical light curve produced by a randomly generated
    asteroid field'
  prefs: []
  type: TYPE_NORMAL
- en: You can find a solution, *practice_asteroids.py*, in the appendix and on the
    book’s web page. This program uses object-oriented programming (OOP) to simplify
    the management of multiple asteroids.
  prefs: []
  type: TYPE_NORMAL
- en: '**Practice Project: Incorporating Limb Darkening**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *photosphere* is the luminous outer layer of a star that radiates light
    and heat. Because the temperature of the photosphere falls as the distance from
    the star’s center increases, the edges of a star’s disk are cooler and therefore
    appear dimmer than the center of the star ([Figure 8-22](ch08.xhtml#ch08fig22)).
    This effect is known as *limb darkening*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig08_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-22: Limb darkening and sunspots on the sun'
  prefs: []
  type: TYPE_NORMAL
- en: Rewrite the *transit.py* program so that it addresses limb darkening. Rather
    than draw the star, use the image *limb_darkening.png* in the *Chapter_8* folder,
    downloadable from the book’s website.
  prefs: []
  type: TYPE_NORMAL
- en: Limb darkening will affect the light curves produced by planetary transits.
    Compared to the theoretical curves you produced in Project 11, they will appear
    less boxy, with rounder, softer edges and a curved bottom ([Figure 8-23](ch08.xhtml#ch08fig23)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig08_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-23: The effect of limb darkening on a light curve'
  prefs: []
  type: TYPE_NORMAL
- en: Use your modified program to revisit “Experimenting with Transit Photometry”
    on [page 186](ch08.xhtml#page_186), where you analyzed the light curves produced
    by partial transits. You should see that, compared to partial transits, full transits
    still produce broader dips with flattish bottoms ([Figure 8-24](ch08.xhtml#ch08fig24)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig08_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-24: Limb-darkened light curves for full and partial transits (R =
    exoplanet radius)'
  prefs: []
  type: TYPE_NORMAL
- en: If the full transit of a small planet occurs near the edge of a star, limb darkening
    may make it difficult to distinguish from the partial transit of a larger planet.
    You can see this in [Figure 8-25](ch08.xhtml#ch08fig25), where arrows denote the
    location of the planets.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig08_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-25: Partial transit of planet with a radius of 8 pixels versus full
    transit of planet with a radius of 5 pixels'
  prefs: []
  type: TYPE_NORMAL
- en: Astronomers have many tools for extracting information entangled in a light
    curve. By recording multiple transit events, they can determine an exoplanet’s
    orbital parameters, such as the distance between the planet and the star. They
    can use subtle inflections in the light curve to tease out the amount of time
    the planet is fully over the surface of the star. They can estimate the theoretical
    amount of limb darkening, and they can use modeling, as you’re doing here, to
    bring it all together and test their assumptions against actual observations.
  prefs: []
  type: TYPE_NORMAL
- en: You can find a solution, *practice_limb_darkening.py*, in the appendix and in
    the *Chapter_8* folder downloadable from the book’s website.
  prefs: []
  type: TYPE_NORMAL
- en: '**Practice Project: Detecting Starspots**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sunspots—called *starspots* on alien suns—are regions of reduced surface temperature
    caused by variations in the star’s magnetic field. Starspots can darken the face
    of stars and do interesting things to light curves. In [Figure 8-26](ch08.xhtml#ch08fig26),
    an exoplanet passes over a starspot, causing a “bump” in the light curve.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig08_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-26: An exoplanet (arrow, left image) passing over a starspot produces
    a bump in the light curve.'
  prefs: []
  type: TYPE_NORMAL
- en: To experiment with starspots, use the *practice_limb_darkening.py* code from
    the previous practice project and edit it so that an exoplanet roughly the same
    size as the starspots passes over them during its transit. To reproduce [Figure
    8-26](ch08.xhtml#ch08fig26), use EXO_RADIUS = 4, EXO_DX = 3, and EXO_START_Y =
    205.
  prefs: []
  type: TYPE_NORMAL
- en: '**Practice Project: Detecting an Alien Armada**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The hyper-evolved beavers of exoplanet BR549 have been as busy as, well, beavers.
    They’ve amassed an armada of colossal colony ships that are now loaded and ready
    to leave orbit. Thanks to some exoplanet detection of their own, they’ve decided
    to abandon their chewed-out homeworld for the lush green forests of Earth!
  prefs: []
  type: TYPE_NORMAL
- en: Write a Python program that simulates multiple spaceships transiting a star.
    Give the ships different sizes, shapes, and speeds (such as those in [Figure 8-27](ch08.xhtml#ch08fig27)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig08_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-27: An armada of alien colony ships preparing to invade Earth'
  prefs: []
  type: TYPE_NORMAL
- en: Compare the resultant light curves to those from Tabby’s Star ([Figure 8-17](ch08.xhtml#ch08fig17))
    and the asteroids practice project. Do the ships produce distinctive curves, or
    can you get similar patterns from asteroid swarms, starspots, or other natural
    phenomena?
  prefs: []
  type: TYPE_NORMAL
- en: You can find a solution, *practice_alien_armada.py*, in the appendix and in
    the *Chapter_8* folder, downloadable from the book’s website.
  prefs: []
  type: TYPE_NORMAL
- en: '**Practice Project: Detecting a Planet with a Moon**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What kind of light curve would an exoplanet with an orbiting moon produce? Write
    a Python program that simulates a small exomoon orbiting a larger exoplanet and
    calculate the resulting light curve. You can find a solution, *practice_planet_moon.py*,
    in the appendix and on the book’s website.
  prefs: []
  type: TYPE_NORMAL
- en: '**Practice Project: Measuring the Length of an Exoplanet’s Day**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Your astronomer boss has given you 34 images of an exoplanet designated BR549\.
    The images were taken an hour apart. Write a Python program that loads the images
    in order, measures the intensity of each image, and plots the measurements as
    a single light curve ([Figure 8-28](ch08.xhtml#ch08fig28)). Use the curve to determine
    the length of a day on BR549.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig08_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-28: Composite light curve for 34 images of exoplanet BR549'
  prefs: []
  type: TYPE_NORMAL
- en: You can find a solution, *practice_length_of_day.py,* in the appendix. The digital
    version of the code, along with the folder of images (*br549_pixelated*), are
    in the *Chapter_8* folder downloadable from the book’s website.
  prefs: []
  type: TYPE_NORMAL
- en: '**Challenge Project: Generating a Dynamic Light Curve**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Rewrite *transit.py* so that the light curve dynamically updates as the simulation
    runs, rather than just appearing at the end.
  prefs: []
  type: TYPE_NORMAL
