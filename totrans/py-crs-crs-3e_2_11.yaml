- en: '19'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '19'
- en: User Accounts
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 用户账户
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: At the heart of a web application is the ability for any user, anywhere in the
    world, to register an account with your app and start using it. In this chapter,
    you’ll build forms so users can add their own topics and entries, and edit existing
    entries. You’ll also learn how Django guards against common attacks against form-based
    pages, so you won’t have to spend much time thinking about securing your apps.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Web 应用程序的核心是让全球任何用户都能够在你的应用中注册账户并开始使用。在本章中，你将构建表单，让用户能够添加自己的主题和条目，并编辑现有条目。你还将学习
    Django 如何防范常见的基于表单的页面攻击，这样你就不必花太多时间考虑如何确保应用的安全。
- en: You’ll also implement a user authentication system. You’ll build a registration
    page for users to create accounts, and then restrict access to certain pages to
    logged-in users only. Then you’ll modify some of the view functions so users can
    only see their own data. You’ll learn to keep your users’ data safe and secure.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你还将实现一个用户身份验证系统。你将构建一个注册页面，让用户创建账户，然后将某些页面的访问权限限制为仅登录用户可见。接着，你将修改一些视图函数，让用户只能看到自己的数据。你将学习如何保持用户数据的安全性。
- en: Allowing Users to Enter Data
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 允许用户输入数据
- en: Before we build an authentication system for creating accounts, we’ll first
    add some pages that allow users to enter their own data. We’ll give users the
    ability to add a new topic, add a new entry, and edit their previous entries.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们构建用于创建账户的身份验证系统之前，我们将首先添加一些允许用户输入自己数据的页面。我们将赋予用户添加新主题、添加新条目以及编辑其先前条目的能力。
- en: Currently, only a superuser can enter data through the admin site. We don’t
    want users to interact with the admin site, so we’ll use Django’s form-building
    tools to build pages that allow users to enter data.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，只有超级用户才能通过管理站点输入数据。我们不希望用户与管理站点进行交互，因此我们将使用 Django 的表单构建工具来构建允许用户输入数据的页面。
- en: Adding New Topics
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加新主题
- en: 'Let’s start by allowing users to add a new topic. Adding a form-based page
    works in much the same way as adding the pages we’ve already built: we define
    a URL, write a view function, and write a template. The one significant difference
    is the addition of a new module called *forms.py*, which will contain the forms.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们允许用户添加一个新主题。添加基于表单的页面与添加我们已经构建的页面方式类似：我们定义一个 URL，编写视图函数，然后编写模板。唯一显著的区别是增加了一个名为*forms.py*的新模块，它将包含表单。
- en: The Topic ModelForm
  id: totrans-10
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 主题 `ModelForm`
- en: Any page that lets a user enter and submit information on a web page involves
    an HTML element called a *form*. When users enter information, we need to *validate*
    that the information provided is the right kind of data and is not malicious,
    such as code designed to interrupt our server. We then need to process and save
    valid information to the appropriate place in the database. Django automates much
    of this work.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 任何让用户输入并提交信息的网页都涉及一个 HTML 元素，称为*表单*。当用户输入信息时，我们需要*验证*所提供的信息是否是正确的数据类型，且不包含恶意内容，例如设计用来干扰服务器的代码。然后，我们需要处理并将有效的信息保存到数据库的适当位置。Django
    自动化了这项工作。
- en: 'The simplest way to build a form in Django is to use a `ModelForm`, which uses
    the information from the models we defined in Chapter 18 to build a form automatically.
    Write your first form in the file *forms.py*, which should be created in the same
    directory as *models.py*:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Django 中构建表单的最简单方法是使用 `ModelForm`，它利用我们在第 18 章中定义的模型信息自动构建表单。在 *forms.py*
    文件中编写你的第一个表单，该文件应与 *models.py* 位于同一目录：
- en: '**forms.py**'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**forms.py**'
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We first import the `forms` module and the model we’ll work with, `Topic`. We
    then define a class called `TopicForm`, which inherits from `forms.ModelForm`
    ❶.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入 `forms` 模块和我们将要使用的模型 `Topic`。然后，我们定义一个名为 `TopicForm` 的类，它继承自 `forms.ModelForm`
    ❶。
- en: The simplest version of a `ModelForm` consists of a nested `Meta` class telling
    Django which model to base the form on and which fields to include in the form.
    Here we specify that the form should be based on the `Topic` model ❷, and that
    it should only include the `text` field ❸. The empty string in the labels dictionary
    tells Django not to generate a label for the `text` field ❹.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`ModelForm` 的最简单版本由一个嵌套的 `Meta` 类构成，该类告诉 Django 基于哪个模型构建表单，并指定应包含哪些字段。这里，我们指定表单应基于
    `Topic` 模型 ❷，并且只包含 `text` 字段 ❸。标签字典中的空字符串告诉 Django 不为 `text` 字段生成标签 ❹。'
- en: The new_topic URL
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 新主题的 URL
- en: 'The URL for a new page should be short and descriptive. When the user wants
    to add a new topic, we’ll send them to *http://localhost:8000/new_topic/*. Here’s
    the URL pattern for the `new_topic` page; add this to *learning_logs/urls.py*:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 新页面的 URL 应该简短且富有描述性。当用户想要添加新主题时，我们将引导他们访问 *http://localhost:8000/new_topic/*。这是
    `new_topic` 页面的网址模式；将其添加到 *learning_logs/urls.py* 中：
- en: '**learning_logs/urls.py**'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**learning_logs/urls.py**'
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This URL pattern sends requests to the view function `new_topic()`, which we’ll
    write next.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 URL 模式会将请求发送到视图函数 `new_topic()`，我们将在接下来编写它。
- en: The new_topic() View Function
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`new_topic()` 视图函数'
- en: 'The `new_topic()` function needs to handle two different situations: initial
    requests for the `new_topic` page, in which case it should show a blank form;
    and the processing of any data submitted in the form. After data from a submitted
    form is processed, it needs to redirect the user back to the `topics` page:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`new_topic()` 函数需要处理两种不同的情况：初次请求 `new_topic` 页面时，应该显示一个空白表单；以及处理任何在表单中提交的数据。在表单数据处理完后，需要将用户重定向回
    `topics` 页面：'
- en: '**views.py**'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**views.py**'
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We import the function `redirect`, which we’ll use to redirect the user back
    to the `topics` page after they submit their topic. We also import the form we
    just wrote, `TopicForm`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入了 `redirect` 函数，用于在用户提交主题后将他们重定向回 `topics` 页面。我们还导入了刚刚写的表单 `TopicForm`。
- en: GET and POST Requests
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: GET 和 POST 请求
- en: The two main types of requests you’ll use when building apps are GET and POST.
    You use *GET* requests for pages that only read data from the server. You usually
    use *POST* requests when the user needs to submit information through a form.
    We’ll be specifying the POST method for processing all of our forms. (A few other
    kinds of requests exist, but we won’t use them in this project.)
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 构建应用时，您将使用的两种主要请求类型是 GET 和 POST。您使用 *GET* 请求来访问只从服务器读取数据的页面。通常，在用户需要通过表单提交信息时，您会使用
    *POST* 请求。我们将为处理所有表单指定 POST 方法。（虽然存在一些其他类型的请求，但在这个项目中我们不会使用它们。）
- en: The `new_topic()` function takes in the `request` object as a parameter. When
    the user initially requests this page, their browser will send a GET request.
    Once the user has filled out and submitted the form, their browser will submit
    a POST request. Depending on the request, we’ll know whether the user is requesting
    a blank form (GET) or asking us to process a completed form (POST).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`new_topic()` 函数接收 `request` 对象作为参数。当用户最初请求这个页面时，他们的浏览器会发送一个 GET 请求。当用户填写并提交表单后，他们的浏览器会发送一个
    POST 请求。根据请求，我们可以判断用户是请求一个空白表单（GET）还是要求我们处理已填写的表单（POST）。'
- en: We use an `if` test to determine whether the request method is GET or POST ❶.
    If the request method isn’t POST, the request is probably GET, so we need to return
    a blank form. (If it’s another kind of request, it’s still safe to return a blank
    form.) We make an instance of `TopicForm` ❷, assign it to the variable `form`,
    and send the form to the template in the `context` dictionary ❼. Because we included
    no arguments when instantiating `TopicForm`, Django creates a blank form that
    the user can fill out.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `if` 语句来判断请求方法是 GET 还是 POST ❶。如果请求方法不是 POST，那么请求可能是 GET，因此我们需要返回一个空白表单。（如果是其他类型的请求，返回空白表单也是安全的。）我们创建一个
    `TopicForm` 的实例 ❷，将其赋值给变量 `form`，并通过 `context` 字典将表单传递给模板 ❼。因为在实例化 `TopicForm`
    时没有传递任何参数，Django 会创建一个空白表单，用户可以填写。
- en: If the request method is POST, the `else` block runs and processes the data
    submitted in the form. We make an instance of `TopicForm` ❸ and pass it the data
    entered by the user, which is assigned to `request.POST`. The `form` object that’s
    returned contains the information submitted by the user.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果请求方法是 POST，`else` 块将运行并处理表单中提交的数据。我们创建一个 `TopicForm` 的实例 ❸，并将用户输入的数据传递给它，这些数据存储在
    `request.POST` 中。返回的 `form` 对象包含用户提交的信息。
- en: We can’t save the submitted information in the database until we’ve checked
    that it’s valid ❹. The `is_valid()` method checks that all required fields have
    been filled in (all fields in a form are required by default) and that the data
    entered matches the field types expected—for example, that the length of `text`
    is less than 200 characters, as we specified in *models.py* in Chapter 18. This
    automatic validation saves us a lot of work. If everything is valid, we can call
    `save()` ❺, which writes the data from the form to the database.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能在数据库中保存提交的信息，直到我们检查它是否有效 ❹。`is_valid()` 方法检查所有必填字段是否已填写（表单中的所有字段默认都是必填的），并且检查输入的数据是否符合预期的字段类型——例如，`text`
    的长度是否小于 200 个字符，如我们在第 18 章的 *models.py* 中指定的那样。这个自动验证为我们节省了很多工作。如果一切有效，我们可以调用
    `save()` ❺，它将表单中的数据写入数据库。
- en: Once we’ve saved the data, we can leave this page. The `redirect()` function
    takes in the name of a view and redirects the user to the page associated with
    that view. Here we use `redirect()` to redirect the user’s browser to the `topics`
    page ❻, where the user should see the topic they just entered in the list of topics.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们保存了数据，就可以离开这个页面。`redirect()` 函数接受一个视图的名称，并将用户重定向到与该视图关联的页面。在这里，我们使用 `redirect()`
    将用户的浏览器重定向到 `topics` 页面 ❻，在该页面上用户应该能看到他们刚刚输入的话题。
- en: The `context` variable is defined at the end of the view function, and the page
    is rendered using the template *new_topic.xhtml*, which we’ll create next. This
    code is placed outside of any `if` block; it will run if a blank form was created,
    and it will run if a submitted form is determined to be invalid. An invalid form
    will include some default error messages to help the user submit acceptable data.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`context` 变量在视图函数的末尾定义，页面是使用模板 *new_topic.xhtml* 渲染的，我们接下来会创建这个模板。这段代码放在任何
    `if` 块之外；无论是创建了一个空白表单，还是提交的表单被判断为无效时，这段代码都会运行。无效表单会包含一些默认的错误信息，帮助用户提交有效的数据。'
- en: The new_topic Template
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: new_topic 模板
- en: 'Now we’ll make a new template called *new_topic.xhtml* to display the form
    we just created:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将创建一个新模板 *new_topic.xhtml*，以展示我们刚刚创建的表单：
- en: '**new_topic.xhtml**'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**new_topic.xhtml**'
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This template extends *base.xhtml*, so it has the same base structure as the
    rest of the pages in Learning Log. We use the `<form></form>` tags to define an
    HTML form ❶. The `action` argument tells the browser where to send the data submitted
    in the form; in this case, we send it back to the view function `new_topic()`.
    The `method` argument tells the browser to submit the data as a POST request.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模板继承了*base.xhtml*，因此它与学习日志中其他页面具有相同的基本结构。我们使用 `<form></form>` 标签来定义一个 HTML
    表单 ❶。`action` 参数告诉浏览器将表单提交的数据发送到哪里；在这种情况下，我们将数据发送回视图函数 `new_topic()`。`method`
    参数告诉浏览器将数据作为 POST 请求提交。
- en: Django uses the template tag `{% csrf_token %}` ❷ to prevent attackers from
    using the form to gain unauthorized access to the server. (This kind of attack
    is called a *cross-site request forgery*.) Next, we display the form; here you
    can see how simple Django can make certain tasks, such as displaying a form. We
    only need to include the template variable `{{ form.as_div }}` for Django to create
    all the fields necessary to display the form automatically ❸. The `as_div` modifier
    tells Django to render all the form elements as HTML `<div></div>` elements; this
    is a simple way to display the form neatly.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Django 使用模板标签 `{% csrf_token %}` ❷ 来防止攻击者利用表单获取未经授权的服务器访问权限。（这种攻击被称为 *跨站请求伪造*。）接下来，我们展示表单；在这里你可以看到
    Django 如何简化某些任务，例如显示表单。我们只需包含模板变量 `{{ form.as_div }}`，Django 就会自动创建所有必要的字段来展示表单
    ❸。`as_div` 修饰符告诉 Django 将所有表单元素渲染为 HTML `<div></div>` 元素；这是一种简单而整洁的方式来显示表单。
- en: Django doesn’t create a submit button for forms, so we define one before closing
    the form ❹.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Django 并不会为表单创建提交按钮，因此我们在关闭表单之前定义一个按钮 ❹。
- en: Linking to the new_topic Page
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 链接到新话题页面
- en: 'Next, we include a link to the `new_topic` page on the `topics` page:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在 `topics` 页面中包含一个指向 `new_topic` 页面链接：
- en: '**topics.xhtml**'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**topics.xhtml**'
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Place the link after the list of existing topics. [Figure 19-1](#figure19-1)
    shows the resulting form; try using the form to add a few new topics of your own.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 将链接放置在现有话题列表后面。[图 19-1](#figure19-1) 显示了最终的表单；尝试使用表单添加一些你自己的新话题。
- en: '![](image_fi/502703c19/f19001.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502703c19/f19001.png)'
- en: 'Figure 19-1: The page for adding a new topic'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 19-1：添加新话题的页面
- en: Adding New Entries
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加新条目
- en: Now that the user can add a new topic, they’ll want to add new entries too.
    We’ll again define a URL, write a view function and a template, and link to the
    page. But first, we’ll add another class to *forms.py*.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在用户可以添加新主题了，他们也希望添加新的条目。我们将再次定义一个 URL，编写视图函数和模板，并链接到页面。但首先，我们将向 *forms.py*
    添加另一个类。
- en: The Entry ModelForm
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Entry ModelForm
- en: 'We need to create a form associated with the `Entry` model, but this time,
    with a bit more customization than `TopicForm`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建一个与 `Entry` 模型关联的表单，但这一次，我们需要比 `TopicForm` 更多的自定义：
- en: '**forms.py**'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**forms.py**'
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We update the `import` statement to include `Entry` as well as `Topic`. We make
    a new class called `EntryForm` that inherits from `forms.ModelForm`. The `EntryForm`
    class has a nested `Meta` class listing the model it’s based on, and the field
    to include in the form. We again give the field `'text'` a blank label ❶.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更新了 `import` 语句，包含了 `Entry` 和 `Topic`。我们创建了一个新的类 `EntryForm`，它继承自 `forms.ModelForm`。`EntryForm`
    类有一个嵌套的 `Meta` 类，列出了它所基于的模型以及表单中要包含的字段。我们再次为字段 `'text'` 设置一个空的标签 ❶。
- en: For `EntryForm`, we include the `widgets` attribute ❷. A *widget* is an HTML
    form element, such as a single-line text box, multiline text area, or drop-down
    list. By including the `widgets` attribute, you can override Django’s default
    widget choices. Here we’re telling Django to use a `forms.Textarea` element with
    a width of 80 columns, instead of the default 40 columns. This gives users enough
    room to write a meaningful entry.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `EntryForm`，我们包括了 `widgets` 属性 ❷。一个 *widget* 是一个 HTML 表单元素，如单行文本框、多行文本区域或下拉列表。通过包含
    `widgets` 属性，你可以覆盖 Django 默认的 widget 选择。在这里，我们告诉 Django 使用一个 `forms.Textarea`
    元素，宽度为 80 列，而不是默认的 40 列。这为用户提供了足够的空间来写下有意义的条目。
- en: The new_entry URL
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: new_entry URL
- en: 'New entries must be associated with a particular topic, so we need to include
    a `topic_id` argument in the URL for adding a new entry. Here’s the URL, which
    you add to *learning_logs/urls.py*:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 新条目必须与特定主题关联，因此我们需要在添加新条目的 URL 中包含 `topic_id` 参数。以下是你需要添加到 *learning_logs/urls.py*
    的 URL：
- en: '**learning_logs/urls.py**'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**learning_logs/urls.py**'
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This URL pattern matches any URL with the form *http://localhost:8000/new_entry/id/*,
    where `id` is a number matching the topic ID. The code `<int:topic_id>` captures
    a numerical value and assigns it to the variable `topic_id`. When a URL matching
    this pattern is requested, Django sends the request and the topic’s ID to the
    `new_entry()` view function.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 URL 模式匹配任何形如 *http://localhost:8000/new_entry/id/* 的 URL，其中 `id` 是与主题 ID
    匹配的数字。代码 `<int:topic_id>` 捕获一个数字值并将其赋值给变量 `topic_id`。当请求匹配这个模式的 URL 时，Django 会将请求和主题的
    ID 发送到 `new_entry()` 视图函数。
- en: The new_entry() View Function
  id: totrans-62
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: new_entry() 视图函数
- en: 'The view function for `new_entry` is much like the function for adding a new
    topic. Add the following code to your *views.py* file:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`new_entry` 的视图函数与添加新主题的函数非常相似。将以下代码添加到你的 *views.py* 文件中：'
- en: '**views.py**'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**views.py**'
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We update the `import` statement to include the `EntryForm` we just made. The
    definition of `new_entry()` has a `topic_id` parameter to store the value it receives
    from the URL. We’ll need the topic to render the page and process the form’s data,
    so we use `topic_id` to get the correct topic object ❶.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更新了 `import` 语句，包含了我们刚刚创建的 `EntryForm`。`new_entry()` 的定义有一个 `topic_id` 参数，用于存储它从
    URL 中接收到的值。我们需要主题来渲染页面并处理表单数据，因此我们使用 `topic_id` 来获取正确的主题对象 ❶。
- en: Next, we check whether the request method is POST or GET ❷. The `if` block executes
    if it’s a GET request, and we create a blank instance of `EntryForm` ❸.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查请求方法是 POST 还是 GET ❷。如果是 GET 请求，`if` 块将会执行，我们创建一个空的 `EntryForm` 实例 ❸。
- en: If the request method is POST, we process the data by making an instance of
    `EntryForm`, populated with the POST data from the `request` object ❹. We then
    check whether the form is valid. If it is, we need to set the entry object’s `topic`
    attribute before saving it to the database. When we call `save()`, we include
    the argument `commit=False` ❺ to tell Django to create a new entry object and
    assign it to `new_entry`, without saving it to the database yet. We set the `topic`
    attribute of `new_entry` to the topic we pulled from the database at the beginning
    of the function ❻. Then we call `save()` with no arguments, saving the entry to
    the database with the correct associated topic.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果请求方法是 POST，我们通过实例化 `EntryForm` 并用 `request` 对象中的 POST 数据填充它来处理数据❹。然后我们检查表单是否有效。如果有效，我们需要在保存条目到数据库之前设置条目对象的
    `topic` 属性。当我们调用 `save()` 时，包含 `commit=False` 参数❺，告诉 Django 创建一个新的条目对象并将其分配给 `new_entry`，但暂时不保存到数据库。我们将
    `new_entry` 的 `topic` 属性设置为函数开始时从数据库中获取的主题❻。然后我们再次调用 `save()`，不带参数，将条目与正确关联的主题一起保存到数据库。
- en: 'The `redirect()` call requires two arguments: the name of the view we want
    to redirect to and the argument that view function requires ❼. Here, we’re redirecting
    to `topic()`, which needs the argument `topic_id`. This view then renders the
    topic page that the user made an entry for, and they should see their new entry
    in the list of entries.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`redirect()` 调用需要两个参数：我们希望重定向的视图名称和该视图函数所需的参数❼。在这里，我们将重定向到 `topic()`，它需要 `topic_id`
    参数。这个视图随后会渲染用户创建条目的主题页面，用户应该能在条目列表中看到他们的新条目。'
- en: At the end of the function, we create a `context` dictionary and render the
    page using the *new_entry.xhtml* template. This code will execute for a blank
    form, or for a form that’s been submitted but turns out to be invalid.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数的末尾，我们创建一个 `context` 字典，并使用 *new_entry.xhtml* 模板渲染页面。此代码会在空白表单或提交后发现无效的表单时执行。
- en: The new_entry Template
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`new_entry` 模板'
- en: 'As you can see in the following code, the template for `new_entry` is similar
    to the template for `new_topic`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 正如以下代码所示，`new_entry` 的模板类似于 `new_topic` 的模板：
- en: '**new_entry.xhtml**'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**new_entry.xhtml**'
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We show the topic at the top of the page ❶, so the user can see which topic
    they’re adding an entry to. The topic also acts as a link back to the main page
    for that topic.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在页面顶部显示主题❶，以便用户可以看到他们正在为哪个主题添加条目。该主题还充当返回该主题主页面的链接。
- en: The form’s `action` argument includes the `topic.id` value in the URL, so the
    view function can associate the new entry with the correct topic ❷. Other than
    that, this template looks just like *new_topic.xhtml*.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 表单的 `action` 参数在 URL 中包含了 `topic.id` 的值，以便视图函数能够将新条目与正确的主题关联❷。除此之外，这个模板与 *new_topic.xhtml*
    看起来几乎相同。
- en: Linking to the new_entry Page
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 链接到 `new_entry` 页面
- en: 'Next, we need to include a link to the `new_entry` page from each topic page,
    in the topic template:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在每个主题页面的主题模板中包括一个指向 `new_entry` 页面的链接：
- en: '**topic.xhtml**'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**topic.xhtml**'
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We place the link to add entries just before showing the entries, because adding
    a new entry will be the most common action on this page. [Figure 19-2](#figure19-2)
    shows the `new_entry` page. Now users can add new topics and as many entries as
    they want for each topic. Try out the `new_entry` page by adding a few entries
    to some of the topics you’ve created.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加条目的链接放在显示条目之前，因为添加新条目将是此页面上最常见的操作。[图 19-2](#figure19-2) 显示了 `new_entry`
    页面。现在，用户可以为每个主题添加新的条目，且每个主题可以添加任意数量的条目。通过向你创建的一些主题添加条目，尝试一下 `new_entry` 页面。
- en: '![](image_fi/502703c19/f19002.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502703c19/f19002.png)'
- en: 'Figure 19-2: The `new_entry` page'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 19-2：`new_entry` 页面
- en: Editing Entries
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编辑条目
- en: Now we’ll make a page so users can edit the entries they’ve added.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将创建一个页面，用户可以在其中编辑他们添加的条目。
- en: The edit_entry URL
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: edit_entry URL
- en: 'The URL for the page needs to pass the ID of the entry to be edited. Here’s
    *learning_logs/urls.py*:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 页面 URL 需要传递要编辑的条目的 ID。这里是 *learning_logs/urls.py*：
- en: '**urls.py**'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**urls.py**'
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This URL pattern matches URLs like *http://localhost:8000/edit_entry/id/*. Here
    the value of `id` is assigned to the parameter `entry_id`. Django sends requests
    that match this format to the view function `edit_entry()`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 URL 模式匹配像 *http://localhost:8000/edit_entry/id/* 这样的 URL。在这里，`id` 的值被分配给
    `entry_id` 参数。Django 会将与此格式匹配的请求发送到视图函数 `edit_entry()`。
- en: The edit_entry() View Function
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: edit_entry() 视图函数
- en: 'When the `edit_entry` page receives a GET request, the `edit_entry()` function
    returns a form for editing the entry. When the page receives a POST request with
    revised entry text, it saves the modified text into the database:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当`edit_entry`页面收到GET请求时，`edit_entry()`函数将返回一个用于编辑条目的表单。当页面收到包含修改后条目文本的POST请求时，它会将修改后的文本保存到数据库中：
- en: '**views.py**'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**views.py**'
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We first import the `Entry` model. We then get the entry object that the user
    wants to edit ❶ and the topic associated with this entry. In the `if` block, which
    runs for a GET request, we make an instance of `EntryForm` with the argument `instance=entry`
    ❷. This argument tells Django to create the form, prefilled with information from
    the existing entry object. The user will see their existing data and be able to
    edit that data.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入`Entry`模型。然后我们获取用户想要编辑的条目对象❶，以及与该条目相关联的主题。在`if`块中，这部分代码会在GET请求时执行，我们用`instance=entry`参数实例化`EntryForm`❷。该参数告诉Django创建表单，并预填充来自现有条目对象的信息。用户将看到他们现有的数据，并可以编辑这些数据。
- en: When processing a POST request, we pass both the `instance=entry` and the `data=request.POST`
    arguments ❸. These arguments tell Django to create a form instance based on the
    information associated with the existing entry object, updated with any relevant
    data from `request.POST`. We then check whether the form is valid; if it is, we
    call `save()` with no arguments because the entry is already associated with the
    correct topic ❹. We then redirect to the `topic` page, where the user should see
    the updated version of the entry they edited ❺.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理POST请求时，我们传递`instance=entry`和`data=request.POST`参数❸。这些参数告诉Django根据与现有条目对象关联的信息创建一个表单实例，并用`request.POST`中的相关数据更新它。然后，我们检查表单是否有效；如果有效，我们调用`save()`方法且不传递任何参数，因为条目已经与正确的主题关联❹。接着，我们重定向到`topic`页面，用户应该能看到他们编辑过的条目的更新版本❺。
- en: If we’re showing an initial form for editing the entry or if the submitted form
    is invalid, we create the `context` dictionary and render the page using the *edit_entry.xhtml*
    template.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们展示的是用于编辑条目的初始表单，或者提交的表单无效，我们将创建`context`字典，并使用*edit_entry.xhtml*模板来渲染页面。
- en: The edit_entry Template
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: edit_entry模板
- en: 'Next, we create an *edit_entry.xhtml* template, which is similar to *new_entry.xhtml*:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个*edit_entry.xhtml*模板，它类似于*new_entry.xhtml*：
- en: '**edit_entry.xhtml**'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**edit_entry.xhtml**'
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `action` argument sends the form back to the `edit_entry()` function for
    processing ❶. We include the `entry.id` as an argument in the `{% url %}` tag,
    so the view function can modify the correct entry object. We label the submit
    button as `Save changes` to remind the user they’re saving edits, not creating
    a new entry ❷.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`action`参数将表单发送回`edit_entry()`函数进行处理❶。我们在`{% url %}`标签中包含`entry.id`作为参数，以便视图函数可以修改正确的条目对象。我们将提交按钮标记为`Save
    changes`，提醒用户他们正在保存编辑内容，而不是创建新条目❷。'
- en: Linking to the edit_entry Page
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 链接到edit_entry页面
- en: 'Now we need to include a link to the `edit_entry` page for each entry on the
    topic page:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要为每个条目在主题页面上添加指向`edit_entry`页面的链接：
- en: '**topic.xhtml**'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**topic.xhtml**'
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We include the edit link after each entry’s date and text has been displayed.
    We use the `{% url %}` template tag to determine the URL for the named URL pattern
    `edit_entry`, along with the ID attribute of the current entry in the loop (`entry.id`).
    The link text `Edit entry` appears after each entry on the page. [Figure 19-3](#figure19-3)
    shows what the topic page looks like with these links.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在每个条目的日期和文本展示后，添加编辑链接。我们使用`{% url %}`模板标签来确定`edit_entry`的命名URL模式的URL，并结合当前条目在循环中的ID属性（`entry.id`）。链接文本`Edit
    entry`将出现在页面上每个条目之后。[图19-3](#figure19-3)展示了带有这些链接的主题页面样式。
- en: '![](image_fi/502703c19/f19003.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502703c19/f19003.png)'
- en: 'Figure 19-3: Each entry now has a link for editing that entry.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图19-3：每个条目现在都有一个编辑该条目的链接。
- en: Learning Log now has most of the functionality it needs. Users can add topics
    and entries, and they can read through any set of entries they want. In the next
    section, we’ll implement a user registration system so anyone can make an account
    with Learning Log and create their own set of topics and entries.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Learning Log现在已经具备了大部分所需功能。用户可以添加主题和条目，并且可以浏览他们想要的任何一组条目。在下一节中，我们将实现一个用户注册系统，以便任何人都可以在Learning
    Log上注册账户并创建自己的主题和条目。
- en: Setting Up User Accounts
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置用户账户
- en: In this section, we’ll set up a user registration and authorization system so
    people can register an account, log in, and log out. We’ll create a new app to
    contain all the functionality related to working with users. We’ll use the default
    user authentication system included with Django to do as much of the work as possible.
    We’ll also modify the `Topic` model slightly so every topic belongs to a certain
    user.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将设置一个用户注册和授权系统，以便用户可以注册帐户、登录和登出。我们将创建一个新应用来包含与用户相关的所有功能。我们将尽可能使用 Django
    提供的默认用户认证系统来完成大部分工作。同时，我们还会稍微修改 `Topic` 模型，使每个主题都属于某个用户。
- en: The accounts App
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 账户应用
- en: 'We’ll start by creating a new app called `accounts`, using the `startapp` command:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过使用 `startapp` 命令创建一个名为 `accounts` 的新应用：
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The default authentication system is built around the concept of user accounts,
    so using the name `accounts` makes integration with the default system easier.
    The `startapp` command shown here makes a new directory called *accounts* ❶ with
    a structure identical to the `learning_logs` app ❷.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的认证系统是围绕用户帐户的概念构建的，因此使用 `accounts` 这个名称使得与默认系统的集成更加容易。这里显示的 `startapp` 命令会创建一个名为
    *accounts* ❶ 的新目录，其结构与 `learning_logs` 应用 ❷ 完全相同。
- en: Adding accounts to settings.py
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将账户添加到 settings.py
- en: 'We need to add our new app to `INSTALLED_APPS` in *settings.py*, like so:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将新应用添加到 *settings.py* 的 `INSTALLED_APPS` 中，如下所示：
- en: '**settings.py**'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**settings.py**'
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now Django will include the `accounts` app in the overall project.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Django 会将 `accounts` 应用包含到整个项目中。
- en: Including the URLs from accounts
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 包含来自 accounts 的 URL
- en: 'Next, we need to modify the root *urls.py* so it includes the URLs we’ll write
    for the `accounts` app:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要修改根目录下的 *urls.py*，以便它包含我们为 `accounts` 应用编写的 URL：
- en: '**ll_project/urls.py**'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**ll_project/urls.py**'
- en: '[PRE16]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We add a line to include the file *urls.py* from `accounts`. This line will
    match any URL that starts with the word *accounts*, such as *http://localhost:8000/accounts/login/*.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加一行代码以包含来自 `accounts` 的 *urls.py* 文件。这一行代码将匹配任何以 *accounts* 开头的 URL，如 *http://localhost:8000/accounts/login/*。
- en: The Login Page
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 登录页面
- en: 'We’ll first implement a login page. We’ll use the default `login` view Django
    provides, so the URL pattern for this app looks a little different. Make a new
    *urls.py* file in the directory *ll_project/accounts/* and add the following to
    it:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先实现一个登录页面。我们将使用 Django 提供的默认 `login` 视图，因此该应用的 URL 模式看起来稍微不同。在 *ll_project/accounts/*
    目录下创建一个新的 *urls.py* 文件，并向其中添加以下内容：
- en: '**accounts/urls.py**'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**accounts/urls.py**'
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We import the `path` function, and then import the `include` function so we
    can include some default authentication URLs that Django has defined. These default
    URLs include named URL patterns, such as `'login'` and `'logout'`. We set the
    variable `app_name` to `'accounts'` so Django can distinguish these URLs from
    URLs belonging to other apps. Even default URLs provided by Django, when included
    in the `accounts` app’s *urls.py* file, will be accessible through the `accounts`
    namespace.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入 `path` 函数，然后导入 `include` 函数，这样我们可以包含一些 Django 已定义的默认认证 URL。这些默认的 URL 包括命名的
    URL 模式，如 `'login'` 和 `'logout'`。我们将变量 `app_name` 设置为 `'accounts'`，以便 Django 可以区分这些
    URL 和属于其他应用的 URL。即使是 Django 提供的默认 URL，当包含在 `accounts` 应用的 *urls.py* 文件中时，也将通过
    `accounts` 命名空间进行访问。
- en: The login page’s pattern matches the URL *http://localhost:8000/accounts/login/*.
    When Django reads this URL, the word *accounts* tells Django to look in *accounts/urls.py*,
    and *login* tells it to send requests to Django’s default `login` view.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 登录页面的模式匹配网址 *http://localhost:8000/accounts/login/*。当 Django 读取这个 URL 时，*accounts*
    会告诉 Django 去查看 *accounts/urls.py*，而 *login* 则会告诉它将请求发送到 Django 默认的 `login` 视图。
- en: The login Template
  id: totrans-133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 登录模板
- en: 'When the user requests the login page, Django will use a default view function,
    but we still need to provide a template for the page. The default authentication
    views look for templates inside a folder called *registration*, so we’ll need
    to make that folder. Inside the *ll_project/accounts/* directory, make a directory
    called *templates*; inside that, make another directory called *registration*.
    Here’s the *login.xhtml* template, which should be saved in *ll_project/accounts/templates/registration*:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户请求登录页面时，Django 会使用默认的视图函数，但我们仍然需要为该页面提供一个模板。默认的认证视图会在一个名为 *registration*
    的文件夹中查找模板，因此我们需要创建这个文件夹。在 *ll_project/accounts/* 目录下，创建一个名为 *templates* 的目录；在其中，再创建一个名为
    *registration* 的目录。以下是 *login.xhtml* 模板，应该保存在 *ll_project/accounts/templates/registration*
    中：
- en: '**login.xhtml**'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**login.xhtml**'
- en: '[PRE18]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This template extends *base.xhtml* to ensure that the login page will have the
    same look and feel as the rest of the site. Note that a template in one app can
    inherit from a template in another app.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模板继承自 *base.xhtml*，确保登录页面与网站的其他部分保持相同的外观和感觉。请注意，一个应用中的模板可以继承自另一个应用中的模板。
- en: If the form’s `errors` attribute is set, we display an error message ❶, reporting
    that the username and password combination doesn’t match anything stored in the
    database.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果表单的 `errors` 属性已设置，我们会显示一条错误信息 ❶，报告用户名和密码组合与数据库中存储的内容不匹配。
- en: We want the login view to process the form, so we set the `action` argument
    as the URL of the login page ❷. The login view sends a `form` object to the template,
    and it’s up to us to display the form ❸ and add a submit button ❹.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望登录视图处理表单，因此我们将 `action` 参数设置为登录页面的 URL ❷。登录视图会将一个 `form` 对象传递给模板，接下来由我们来显示表单
    ❸ 并添加提交按钮 ❹。
- en: The LOGIN_REDIRECT_URL Settting
  id: totrans-140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: LOGIN_REDIRECT_URL 设置
- en: Once a user logs in successfully, Django needs to know where to send that user.
    We control this in the settings file.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户成功登录，Django 需要知道将该用户重定向到哪里。我们在设置文件中控制这一点。
- en: 'Add the following code to the end of *settings.py*:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到 *settings.py* 的末尾：
- en: '**settings.py**'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**settings.py**'
- en: '[PRE19]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: With all the default settings in *settings.py*, it’s helpful to mark off the
    section where we’re adding new settings. The first new setting we’ll add is `LOGIN_REDIRECT_URL`,
    which tells Django which URL to redirect to after a successful login attempt.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *settings.py* 中的所有默认设置时，标记出我们添加新设置的部分会很有帮助。我们要添加的第一个新设置是 `LOGIN_REDIRECT_URL`，它告诉
    Django 在成功登录后应该重定向到哪个 URL。
- en: Linking to the Login Page
  id: totrans-146
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 链接到登录页面
- en: 'Let’s add the login link to *base.xhtml* so it appears on every page. We don’t
    want the link to display when the user is already logged in, so we nest it inside
    an `{% if %}` tag:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来将登录链接添加到 *base.xhtml* 中，以便它出现在每个页面上。我们不希望在用户已经登录时显示该链接，因此我们将它嵌套在 `{% if %}`
    标签内：
- en: '**base.xhtml**'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**base.xhtml**'
- en: '[PRE20]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In Django’s authentication system, every template has a `user` object available
    that always has an `is_authenticated` attribute set: the attribute is `True` if
    the user is logged in and `False` if they aren’t. This attribute allows you to
    display one message to authenticated users and another to unauthenticated users.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Django 的认证系统中，每个模板都有一个可用的 `user` 对象，该对象始终具有 `is_authenticated` 属性：当用户登录时，属性值为
    `True`，否则为 `False`。这个属性可以让你为已认证用户和未认证用户显示不同的消息。
- en: Here we display a greeting to users currently logged in ❶. Authenticated users
    have an additional `username` attribute set, which we use to personalize the greeting
    and remind the user they’re logged in ❷. For users who haven’t been authenticated,
    we display a link to the login page ❸.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们显示了当前已登录用户的问候信息 ❶。已认证的用户会有一个额外的 `username` 属性，我们利用这个属性来个性化问候并提醒用户他们已经登录
    ❷。对于未认证的用户，我们会显示一个指向登录页面的链接 ❸。
- en: Using the Login Page
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用登录页面
- en: We’ve already set up a user account, so let’s log in to see if the page works.
    Go to *http://localhost:8000/admin/*. If you’re still logged in as an admin, look
    for a **logout** link in the header and click it.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经设置好了用户账户，现在让我们登录看看页面是否正常工作。访问 *http://localhost:8000/admin/*。如果你仍然以管理员身份登录，可以在页眉中找到一个
    **logout** 链接并点击它。
- en: When you’re logged out, go to *http://localhost:8000/accounts/login/*. You should
    see a login page similar to the one shown in [Figure 19-4](#figure19-4). Enter
    the username and password you set up earlier, and you should be brought back to
    the home page. The header on the home page should display a greeting personalized
    with your username.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当你注销后，访问 *http://localhost:8000/accounts/login/*。你应该看到一个类似于 [图 19-4](#figure19-4)
    所示的登录页面。输入你之前设置的用户名和密码，应该会跳转回主页。主页的页眉应该会显示一个带有用户名的个性化问候。
- en: '![](image_fi/502703c19/f19004.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502703c19/f19004.png)'
- en: 'Figure 19-4: The login page'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图 19-4：登录页面
- en: Logging Out
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注销
- en: Now we need to provide a way for users to log out. Logout requests should be
    submitted as POST requests, so we’ll add a small logout form to *base.xhtml*.
    When users click the logout button, they’ll go to a page confirming that they’ve
    been logged out.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要提供一个方法，让用户可以注销。注销请求应该以 POST 请求的形式提交，因此我们将向 *base.xhtml* 添加一个小的注销表单。当用户点击注销按钮时，他们会看到一个确认已注销的页面。
- en: Adding a Logout Form to base.xhtml
  id: totrans-159
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将登出表单添加到 base.xhtml
- en: 'We’ll add the form for logging out to *base.xhtml* so it’s available on every
    page. We’ll include it in another `if` block, so only users who are already logged
    in can see it:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将注销表单添加到 *base.xhtml*，这样它在每个页面上都可用。我们将其包含在另一个 `if` 语句块中，这样只有已登录的用户才能看到它：
- en: '**base.xhtml**'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**base.xhtml**'
- en: '[PRE21]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The default URL pattern for logging out is `'accounts/logout/'`. However, the
    request has to be sent as a POST request; otherwise, attackers can easily force
    logout requests. To make the logout request use POST, we define a simple form.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 登出的默认 URL 模式是 `'accounts/logout/'`。但是，请求必须作为 POST 请求发送；否则，攻击者可以轻易发起强制注销请求。为了让注销请求使用
    POST 方法，我们定义了一个简单的表单。
- en: We place the form at the bottom of the page, below a horizontal rule element
    (`<hr />`) ❶. This is an easy way to always keep the logout button in a consistent
    position below any other content on the page. The form itself has the logout URL
    as its `action` argument, and `'post'` as the request method ❷. Every form in
    Django needs to include the `{% csrf_token %}`, even a simple form like this one.
    This form is empty except for the submit button.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将表单放在页面底部，位于水平线元素 (`<hr />`) ❶ 下面。这是一种简单的方式，确保注销按钮始终处于页面中任何其他内容下方的统一位置。表单本身的
    `action` 参数是注销 URL，`'post'` 是请求方法 ❷。Django 中的每个表单都需要包含 `{% csrf_token %}`，即使是像这样的简单表单。这个表单除了提交按钮外是空的。
- en: The LOGOUT_REDIRECT_URL Setting
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`LOGOUT_REDIRECT_URL` 设置'
- en: 'When the user clicks the logout button, Django needs to know where to send
    them. We control this behavior in *settings.py*:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击注销按钮时，Django 需要知道将用户发送到哪里。我们在 *settings.py* 中控制这一行为：
- en: '**settings.py**'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**settings.py**'
- en: '[PRE22]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `LOGOUT_REDIRECT_URL` setting shown here tells Django to redirect logged-out
    users back to the home page. This is a simple way to confirm that they were logged
    out, because they should no longer see their username after logging out.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`LOGOUT_REDIRECT_URL` 设置指示 Django 在用户注销后将其重定向到主页。这是确认用户已注销的简单方法，因为注销后他们不应再看到自己的用户名。'
- en: The Registration Page
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注册页面
- en: Next, we’ll build a page so new users can register. We’ll use Django’s default
    `UserCreationForm`, but write our own view function and template.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将构建一个页面，让新用户可以注册。我们将使用 Django 的默认 `UserCreationForm`，但会编写我们自己的视图函数和模板。
- en: The register URL
  id: totrans-172
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注册 URL
- en: 'The following code provides the URL pattern for the registration page, which
    should be placed in *accounts/urls.py*:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码提供了注册页面的 URL 模式，应当放在 *accounts/urls.py* 中：
- en: '**accounts/urls.py**'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**accounts/urls.py**'
- en: '[PRE23]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We import the `views` module from `accounts`, which we need because we’re writing
    our own view for the registration page. The pattern for the registration page
    matches the URL *http://localhost:8000/accounts/register/* and sends requests
    to the `register()` function we’re about to write.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 `accounts` 导入 `views` 模块，这是因为我们正在为注册页面编写自己的视图。注册页面的 URL 模式对应于 *http://localhost:8000/accounts/register/*
    并将请求发送到我们即将编写的 `register()` 函数。
- en: The register() View Function
  id: totrans-177
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`register()` 视图函数'
- en: 'The `register()` view function needs to display a blank registration form when
    the registration page is first requested, and then process completed registration
    forms when they’re submitted. When a registration is successful, the function
    also needs to log the new user in. Add the following code to *accounts/views.py*:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`register()` 视图函数需要在首次请求注册页面时显示一个空白的注册表单，然后在表单提交后处理已完成的注册表单。当注册成功时，该函数还需要将新用户登录。将以下代码添加到
    *accounts/views.py* 中：'
- en: '**accounts/views.py**'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**accounts/views.py**'
- en: '[PRE24]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We import the `render()` and `redirect()` functions, and then we import the
    `login()` function to log the user in if their registration information is correct.
    We also import the default `UserCreationForm`. In the `register()` function, we
    check whether we’re responding to a POST request. If we’re not, we make an instance
    of `UserCreationForm` with no initial data ❶.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入 `render()` 和 `redirect()` 函数，然后导入 `login()` 函数，以便在用户的注册信息正确时将其登录。我们还导入了默认的
    `UserCreationForm`。在 `register()` 函数中，我们检查是否是对 POST 请求做出响应。如果不是，我们就用没有初始数据的 `UserCreationForm`
    实例化 ❶。
- en: If we’re responding to a POST request, we make an instance of `UserCreationForm`
    based on the submitted data ❷. We check that the data is valid ❸—in this case,
    that the username has the appropriate characters, the passwords match, and the
    user isn’t trying to do anything malicious in their submission.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对 POST 请求做出响应，我们就基于提交的数据实例化 `UserCreationForm` ❷。然后我们检查数据是否有效 ❸——在这种情况下，检查用户名是否符合要求，密码是否匹配，并且用户没有在提交中尝试恶意操作。
- en: If the submitted data is valid, we call the form’s `save()` method to save the
    username and the hash of the password to the database ❹. The `save()` method returns
    the newly created user object, which we assign to `new_user`. When the user’s
    information is saved, we log them in by calling the `login()` function with the
    `request` and `new_user` objects ❺, which creates a valid session for the new
    user. Finally, we redirect the user to the home page ❻, where a personalized greeting
    in the header tells them their registration was successful.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提交的数据有效，我们调用表单的`save()`方法，将用户名和密码的哈希值保存到数据库中❹。`save()`方法返回新创建的用户对象，我们将其赋值给`new_user`。当用户信息保存后，我们通过调用`login()`函数并传入`request`和`new_user`对象❺来登录用户，这会为新用户创建一个有效的会话。最后，我们将用户重定向到主页❻，在页眉中显示个性化的问候，告诉他们注册成功。
- en: At the end of the function, we render the page, which will be either a blank
    form or a submitted form that’s invalid.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数的末尾，我们渲染页面，该页面可能是一个空白表单，或者是一个提交但无效的表单。
- en: The register Template
  id: totrans-185
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注册模板
- en: 'Now create a template for the registration page, which will be similar to the
    login page. Be sure to save it in the same directory as *login.xhtml*:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建一个注册页面的模板，它将类似于登录页面。请确保将其保存在与*login.xhtml*相同的目录中：
- en: '**register.xhtml**'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**register.xhtml**'
- en: '[PRE25]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This should look like the other form-based templates we’ve been writing. We
    use the `as_div` method again so Django will display all the fields in the form
    appropriately, including any error messages if the form isn’t filled out correctly.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该与我们一直在编写的其他基于表单的模板类似。我们再次使用`as_div`方法，这样Django会适当地显示表单中的所有字段，包括如果表单填写不正确时的错误信息。
- en: Linking to the Registration Page
  id: totrans-190
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 链接到注册页面
- en: 'Next, we’ll add code to show the registration page link to any user who isn’t
    currently logged in:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加代码，向任何未登录的用户显示注册页面链接：
- en: '**base.xhtml**'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '**base.xhtml**'
- en: '[PRE26]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now users who are logged in see a personalized greeting and a logout button.
    Users who aren’t logged in see a registration link and a login link. Try out the
    registration page by making several user accounts with different usernames.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，已登录的用户会看到个性化的问候语和登出按钮。未登录的用户则会看到注册链接和登录链接。通过创建多个不同用户名的用户账户来试用注册页面。
- en: In the next section, we’ll restrict some of the pages so they’re available only
    to registered users, and we’ll make sure every topic belongs to a specific user.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一部分，我们将限制一些页面的访问，使其仅对注册用户可用，并确保每个主题都属于特定的用户。
- en: Allowing Users to Own Their Data
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 允许用户拥有自己的数据
- en: Users should be able to enter private data in their learning logs, so we’ll
    create a system to figure out which data belongs to which user. Then we’ll restrict
    access to certain pages so users can only work with their own data.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 用户应该能够在他们的学习日志中输入私人数据，因此我们将创建一个系统来识别哪些数据属于哪个用户。然后，我们将限制某些页面的访问，确保用户只能操作自己的数据。
- en: We’ll modify the `Topic` model so every topic belongs to a specific user. This
    will also take care of entries, because every entry belongs to a specific topic.
    We’ll start by restricting access to certain pages.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将修改`Topic`模型，使每个主题都属于一个特定用户。这也将处理条目，因为每个条目都属于特定的主题。我们将从限制某些页面的访问开始。
- en: Restricting Access with @login_required
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用@login_required限制访问
- en: Django makes it easy to restrict access to certain pages through the `@login_required`
    decorator. Recall from Chapter 11 that a *decorator* is a directive placed just
    before a function definition, which modifies how the function behaves. Let’s look
    at an example.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Django使得通过`@login_required`装饰器限制某些页面的访问变得非常容易。回想一下第11章中的内容，*装饰器*是一个放置在函数定义之前的指令，它修改函数的行为。我们来看一个示例。
- en: Restricting Access to the Topics Page
  id: totrans-201
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 限制访问主题页面
- en: 'Each topic will be owned by a user, so only registered users can request the
    topics page. Add the following code to *learning_logs/views.py*:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 每个主题将由一个用户拥有，因此只有注册用户才能请求访问该主题页面。请将以下代码添加到*learning_logs/views.py*中：
- en: '**learning_logs/views.py**'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**learning_logs/views.py**'
- en: '[PRE27]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We first import the `login_required()` function. We apply `login_required()`
    as a decorator to the `topics()` view function by prepending `login_required`
    with the `@` symbol. As a result, Python knows to run the code in `login_required()`
    before the code in `topics()`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入`login_required()`函数。我们通过在`topics()`视图函数前加上`@`符号来将`login_required()`作为装饰器应用到`topics()`视图函数。因此，Python会在运行`topics()`中的代码之前先运行`login_required()`中的代码。
- en: The code in `login_required()` checks whether a user is logged in, and Django
    runs the code in `topics()` only if they are. If the user isn’t logged in, they’re
    redirected to the login page.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`login_required()`中的代码检查用户是否已登录，只有在用户登录后，Django才会执行`topics()`中的代码。如果用户未登录，他们将被重定向到登录页面。'
- en: 'To make this redirect work, we need to modify *settings.py* so Django knows
    where to find the login page. Add the following at the end of *settings.py*:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个重定向生效，我们需要修改*settings.py*，以便Django知道在哪里找到登录页面。在*settings.py*的末尾添加以下内容：
- en: '**settings.py**'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**settings.py**'
- en: '[PRE28]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now when an unauthenticated user requests a page protected by the `@login_required`
    decorator, Django will send the user to the URL defined by `LOGIN_URL` in *settings.py*.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当未经过身份验证的用户请求受`@login_required`装饰器保护的页面时，Django将把用户发送到*settings.py*中定义的`LOGIN_URL`
    URL。
- en: You can test this setting by logging out of any user accounts and going to the
    home page. Click the **Topics** link, which should redirect you to the login page.
    Then log in to any of your accounts, and from the home page, click the **Topics**
    link again. You should be able to access the topics page.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过注销任何用户帐户并访问主页来测试此设置。点击**Topics**链接，这应该会将你重定向到登录页面。然后登录到任何一个账户，再次从主页点击**Topics**链接。你应该能够访问主题页面。
- en: Restricting Access Throughout Learning Log
  id: totrans-212
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 限制在学习日志中的访问
- en: Django makes it easy to restrict access to pages, but you have to decide which
    pages to protect. It’s best to think about which pages need to be unrestricted
    first, and then restrict all the other pages in the project. You can easily correct
    over-restricted access, and it’s less dangerous than leaving sensitive pages unrestricted.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Django使得限制页面访问变得简单，但你需要决定哪些页面需要保护。最好先考虑哪些页面需要公开访问，然后限制项目中的所有其他页面。你可以轻松纠正过度限制的访问，这比让敏感页面没有限制更安全。
- en: In Learning Log, we’ll keep the home page and the registration page unrestricted.
    We’ll restrict access to every other page.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在Learning Log中，我们将保持主页和注册页面不受限制。我们将限制对其他页面的访问。
- en: 'Here’s *learning_logs/views.py* with `@login_required` decorators applied to
    every view except `index()`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这是带有`@login_required`装饰器的*learning_logs/views.py*，除了`index()`之外，其他每个视图都应用了该装饰器：
- en: '**learning_logs/views.py**'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**learning_logs/views.py**'
- en: '[PRE29]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Try accessing each of these pages while logged out; you should be redirected
    back to the login page. You’ll also be unable to click links to pages such as
    `new_topic`. But if you enter the URL *http://localhost:8000/new_topic/*, you’ll
    be redirected to the login page. You should restrict access to any URL that’s
    publicly accessible and relates to private user data.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在登出状态下访问这些页面；你应该会被重定向回登录页面。你还无法点击像`new_topic`这样的页面链接。但如果你输入URL *http://localhost:8000/new_topic/*，你会被重定向到登录页面。你应该限制任何与私人用户数据相关并且是公开访问的URL。
- en: Connecting Data to Certain Users
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将数据与特定用户关联
- en: Next, we need to connect the data to the user who submitted it. We only need
    to connect the data highest in the hierarchy to a user, and the lower-level data
    will follow. In Learning Log, topics are the highest level of data in the app,
    and all entries are connected to a topic. As long as each topic belongs to a specific
    user, we can trace the ownership of each entry in the database.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将数据与提交的用户关联。我们只需要将层次结构中最高级的数据与用户关联，低级数据会随之而来。在Learning Log中，主题是应用中最高级的数据，所有条目都与一个主题相关。只要每个主题属于一个特定的用户，我们就可以追溯到数据库中每个条目的所有者。
- en: We’ll modify the `Topic` model by adding a foreign key relationship to a user.
    We’ll then have to migrate the database. Finally, we’ll modify some of the views
    so they only show the data associated with the currently logged-in user.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过向`Topic`模型添加一个外键关系来关联用户。接着，我们需要迁移数据库。最后，我们将修改一些视图，使它们只显示当前登录用户相关的数据。
- en: Modifying the Topic Model
  id: totrans-222
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 修改主题模型
- en: 'The modification to *models.py* is just two lines:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 对*models.py*的修改仅仅是两行代码：
- en: '**models.py**'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '**models.py**'
- en: '[PRE30]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We import the `User` model from `django.contrib.auth`. Then we add an `owner`
    field to `Topic`, which establishes a foreign key relationship to the `User` model.
    If a user is deleted, all the topics associated with that user will be deleted
    as well.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`django.contrib.auth`导入`User`模型。然后，我们在`Topic`中添加一个`owner`字段，这样就建立了与`User`模型的外键关系。如果用户被删除，所有与该用户相关的主题也将被删除。
- en: Identifying Existing Users
  id: totrans-227
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 识别现有用户
- en: When we migrate the database, Django will modify the database so it can store
    a connection between each topic and a user. To make the migration, Django needs
    to know which user to associate with each existing topic. The simplest approach
    is to start by assigning all existing topics to one user—for example, the superuser.
    But first, we need to know that user’s ID.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们迁移数据库时，Django将修改数据库，以便能够存储每个话题与用户之间的关联。为了进行迁移，Django需要知道与每个现有话题关联的用户。最简单的方法是先将所有现有话题分配给一个用户——例如，超级用户。但首先，我们需要知道该用户的ID。
- en: 'Let’s look at the IDs of all users created so far. Start a Django shell session
    and issue the following commands:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看目前为止创建的所有用户的ID。在Django shell会话中输入以下命令：
- en: '[PRE31]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We first import the `User` model into the shell session ❶. We then look at
    all the users that have been created so far ❷. The output shows three users for
    my version of the project: `ll_admin`, `eric`, and `willie`.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将`User`模型导入到shell会话中❶。然后查看到目前为止创建的所有用户❷。输出显示了我版本中的三个用户：`ll_admin`、`eric`和`willie`。
- en: Next, we loop through the list of users and print each user’s username and ID
    ❸. When Django asks which user to associate the existing topics with, we’ll use
    one of these ID values.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们循环遍历用户列表，打印每个用户的用户名和ID❸。当Django询问要将现有话题与哪个用户关联时，我们将使用这些ID值之一。
- en: Migrating the Database
  id: totrans-233
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 迁移数据库
- en: 'Now that we know the IDs, we can migrate the database. When we do this, Python
    will ask us to connect the `Topic` model to a particular owner temporarily or
    to add a default to our *models.py* file to tell it what to do. Choose option
    **1**:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了用户的ID，可以开始迁移数据库。当我们进行迁移时，Python会要求我们暂时将`Topic`模型与某个特定的用户关联，或者在我们的*models.py*文件中添加默认值来告诉它该如何操作。选择选项**1**：
- en: '[PRE32]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We start by issuing the `makemigrations` command ❶. In the output, Django indicates
    that we’re trying to add a required (*non-nullable*) field to an existing model
    (`topic`) with no default value specified ❷. Django gives us two options: we can
    provide a default right now, or we can quit and add a default value in *models.py*
    ❸. Here I’ve chosen the first option ❹. Django then asks us to enter the default
    value ❺.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先执行`makemigrations`命令❶。在输出中，Django表示我们正在尝试向现有模型(`topic`)中添加一个必需的（*非空*）字段，但未指定默认值❷。Django提供了两个选项：我们可以立即提供默认值，或者可以退出并在*models.py*中添加默认值❸。在这里，我选择了第一个选项❹。然后，Django会要求我们输入默认值❺。
- en: To associate all existing topics with the original admin user, `ll_admin`, I
    entered the user ID of `1` ❻. You can use the ID of any user you’ve created; it
    doesn’t have to be a superuser. Django then migrates the database using this value
    and generates the migration file *0003_topic_owner.py*, which adds the field `owner`
    to the `Topic` model.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将所有现有话题与原始管理员用户`ll_admin`关联，我输入了用户ID `1` ❻。你可以使用任何你创建的用户的ID，它不必是超级用户。Django然后使用该值迁移数据库，并生成迁移文件*0003_topic_owner.py*，该文件将`owner`字段添加到`Topic`模型中。
- en: 'Now we can execute the migration. Enter the following in an active virtual
    environment:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以执行迁移。在一个活动的虚拟环境中输入以下命令：
- en: '[PRE33]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Django applies the new migration, and the result is `OK` ❶.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: Django应用新迁移，结果是`OK` ❶。
- en: 'We can verify that the migration worked as expected in a shell session, like
    this:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在shell会话中执行以下命令来验证迁移是否按预期工作：
- en: '[PRE34]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We import `Topic` from `learning_logs.models` and then loop through all existing
    topics, printing each topic and the user it belongs to. You can see that each
    topic now belongs to the user `ll_admin`. (If you get an error when you run this
    code, try exiting the shell and starting a new shell.)
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`learning_logs.models`导入`Topic`，然后循环遍历所有现有话题，打印每个话题以及它所属的用户。你可以看到每个话题现在都属于用户`ll_admin`。（如果运行这段代码时遇到错误，请尝试退出shell并重新启动一个新的shell。）
- en: Restricting Topics Access to Appropriate Users
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 限制话题访问权限到适当的用户
- en: Currently, if you’re logged in, you’ll be able to see all the topics, no matter
    which user you’re logged in as. We’ll change that by showing users only the topics
    that belong to them.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，如果你登录了系统，你将能够看到所有话题，无论你以哪个用户身份登录。我们将通过只显示属于该用户的话题来改变这一点。
- en: 'Make the following change to the `topics()` function in *views.py*:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在*views.py*中的`topics()`函数中进行以下更改：
- en: '**learning_logs/views.py**'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '**learning_logs/views.py**'
- en: '[PRE35]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: When a user is logged in, the `request` object has a `request.user` attribute
    set, which contains information about the user. The query `Topic.objects.filter(owner=request.user)`
    tells Django to retrieve only the `Topic` objects from the database whose `owner`
    attribute matches the current user. Because we’re not changing how the topics
    are displayed, we don’t need to change the template for the topics page at all.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户登录时，`request`对象会设置`request.user`属性，其中包含用户信息。查询`Topic.objects.filter(owner=request.user)`会告诉
    Django 只检索数据库中`owner`属性与当前用户匹配的`Topic`对象。由于我们没有改变主题的显示方式，所以不需要更改主题页面的模板。
- en: To see if this works, log in as the user you connected all existing topics to,
    and go to the topics page. You should see all the topics. Now log out and log
    back in as a different user. You should see the message “No topics have been added
    yet.”
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查这是否有效，首先以你已将所有现有主题关联的用户身份登录，然后访问主题页面。你应该能看到所有的主题。接下来注销，并以另一个用户身份重新登录。你应该看到消息“尚未添加任何主题”。
- en: Protecting a User’s Topics
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保护用户的主题
- en: We haven’t restricted access to the topic pages yet, so any registered user
    could try a bunch of URLs (like *http://localhost:8000/topics/1/*) and retrieve
    topic pages that happen to match.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有限制访问主题页面，因此任何注册用户都可以尝试多个 URL（如*http://localhost:8000/topics/1/*），并检索到恰好匹配的主题页面。
- en: Try it yourself. While logged in as the user that owns all topics, copy the
    URL or note the ID in the URL of a topic, and then log out and log back in as
    a different user. Enter that topic’s URL. You should be able to read the entries,
    even though you’re logged in as a different user.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 亲自尝试一下。当以拥有所有主题的用户身份登录时，复制一个主题的 URL 或记下 URL 中的 ID，然后注销并以另一个用户身份重新登录。输入该主题的 URL。即使你以不同的用户身份登录，你仍然应该能够读取该条目。
- en: 'We’ll fix this now by performing a check before retrieving the requested entries
    in the `topic()` view function:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在通过在`topic()`视图函数中执行检查，来解决这个问题，在检索请求的条目之前进行检查：
- en: '**learning_logs/views.py**'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '**learning_logs/views.py**'
- en: '[PRE36]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: A 404 response is a standard error response that’s returned when a requested
    resource doesn’t exist on a server. Here we import the `Http404` exception ❶,
    which we’ll raise if the user requests a topic they shouldn’t have access to.
    After receiving a topic request, we make sure the topic’s user matches the currently
    logged-in user before rendering the page. If the requested topic’s owner is not
    the same as the current user, we raise the `Http404` exception ❷, and Django returns
    a 404-error page.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 404 响应是标准的错误响应，当请求的资源在服务器上不存在时返回。在这里，我们导入了`Http404`异常❶，如果用户请求一个他们没有权限访问的主题，我们将抛出此异常。在接收到主题请求后，我们在渲染页面之前，确保主题的拥有者与当前登录的用户匹配。如果请求的主题的拥有者与当前用户不相同，我们会抛出`Http404`异常❷，然后
    Django 返回一个 404 错误页面。
- en: Now if you try to view another user’s topic entries, you’ll see a “Page Not
    Found” message from Django. In Chapter 20, we’ll configure the project so users
    will see a proper error page instead of a debugging page.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你尝试查看其他用户的主题条目，你会看到 Django 的“页面未找到”消息。在第 20 章，我们将配置项目，使用户看到一个合适的错误页面，而不是调试页面。
- en: Protecting the edit_entry Page
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保护`edit_entry`页面
- en: 'The `edit_entry` pages have URLs of the form *http://localhost:8000/edit_entry/entry_id/*,
    where the `entry_id` is a number. Let’s protect this page so no one can use the
    URL to gain access to someone else’s entries:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`edit_entry`页面的 URL 形式为*http://localhost:8000/edit_entry/entry_id/*，其中 `entry_id`
    是一个数字。我们来保护这个页面，以便没有人能通过 URL 访问他人的条目：'
- en: '**learning_logs/views.py**'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '**learning_logs/views.py**'
- en: '[PRE37]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We retrieve the entry and the topic associated with this entry. We then check
    whether the owner of the topic matches the currently logged-in user; if they don’t
    match, we raise an `Http404` exception.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检索与该条目关联的主题。然后我们检查该主题的拥有者是否与当前登录的用户匹配；如果不匹配，我们会抛出一个`Http404`异常。
- en: Associating New Topics with the Current User
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将新主题与当前用户关联
- en: 'Currently, the page for adding new topics is broken because it doesn’t associate
    new topics with any particular user. If you try adding a new topic, you’ll see
    the message `IntegrityError` along with `NOT NULL constraint failed: learning_logs_topic.owner_id`.
    Django is saying you can’t create a new topic without specifying a value for the
    topic’s `owner` field.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '当前，添加新主题的页面无法正常工作，因为它没有将新主题与任何特定用户关联。如果你尝试添加新主题，你会看到 `IntegrityError` 消息，伴随
    `NOT NULL constraint failed: learning_logs_topic.owner_id`。Django 表示你无法创建一个新主题，除非为主题的
    `owner` 字段指定一个值。'
- en: 'There’s a straightforward fix for this problem, because we have access to the
    current user through the `request` object. Add the following code, which associates
    the new topic with the current user:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题有一个直接的解决办法，因为我们可以通过`request`对象访问当前用户。添加以下代码，将新主题与当前用户关联起来：
- en: '**learning_logs/views.py**'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '**learning_logs/views.py**'
- en: '[PRE38]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: When we first call `form.save()`, we pass the `commit=False` argument because
    we need to modify the new topic before saving it to the database ❶. We then set
    the new topic’s `owner` attribute to the current user ❷. Finally, we call `save()`
    on the topic instance we just defined ❸. Now the topic has all the required data
    and will save successfully.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们第一次调用`form.save()`时，我们传递了`commit=False`参数，因为在将新主题保存到数据库之前，我们需要修改它 ❶。然后，我们将新主题的`owner`属性设置为当前用户
    ❷。最后，我们在刚刚定义的主题实例上调用`save()` ❸。现在，主题拥有了所有必需的数据，并将成功保存。
- en: You should be able to add as many new topics as you want for as many different
    users as you want. Each user will only have access to their own data, whether
    they’re viewing data, entering new data, or modifying old data.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能够为不同的用户添加尽可能多的新主题，每个用户只能访问属于他们自己的数据，无论他们是在查看数据、输入新数据，还是修改旧数据。
- en: Summary
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 小结
- en: In this chapter, you learned how forms allow users to add new topics and entries,
    and edit existing entries. You then learned how to implement user accounts. You
    gave existing users the ability to log in and out, and used Django’s default `UserCreationForm`
    to let people create new accounts.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了如何使用表单让用户添加新主题和条目，并编辑现有条目。然后，你学会了如何实现用户账户。你让现有用户能够登录和退出，并使用Django的默认`UserCreationForm`来让人们创建新账户。
- en: After building a simple user authentication and registration system, you restricted
    access to logged-in users for certain pages using the `@login_required` decorator.
    You then assigned data to specific users through a foreign key relationship. You
    also learned to migrate the database when the migration requires you to specify
    some default data.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建一个简单的用户身份验证和注册系统之后，你使用`@login_required`装饰器限制了登录用户访问某些页面。然后，你通过外键关系将数据分配给特定的用户。你还学会了在迁移时，如何在迁移需要你指定某些默认数据时进行数据库迁移。
- en: Finally, you learned how to make sure a user can only see data that belongs
    to them by modifying the view functions. You retrieved appropriate data using
    the `filter()` method, and compared the owner of the requested data to the currently
    logged-in user.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你学会了通过修改视图函数来确保用户只能看到属于他们的数据。你使用`filter()`方法检索了适当的数据，并将请求数据的所有者与当前登录用户进行了比较。
- en: 'It might not always be immediately obvious what data you should make available
    and what data you should protect, but this skill will come with practice. The
    decisions we’ve made in this chapter to secure our users’ data also illustrate
    why working with others is a good idea when building a project: having someone
    else look over your project makes it more likely that you’ll spot vulnerable areas.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 可能并不总是显而易见你应该提供哪些数据，哪些数据需要保护，但这个技能会通过实践逐渐掌握。本章中我们为了保护用户数据所做的决策也说明了在构建项目时与他人合作的好处：让别人检查你的项目可以提高你发现漏洞的可能性。
- en: You now have a fully functioning project running on your local machine. In the
    final chapter, you’ll style Learning Log to make it visually appealing, and you’ll
    deploy the project to a server so anyone with internet access can register and
    make an account.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经在本地机器上运行了一个功能完整的项目。在最后一章中，你将对Learning Log进行样式美化，使其更具视觉吸引力，并将项目部署到服务器上，这样任何有互联网访问的人都可以注册并创建账户。
