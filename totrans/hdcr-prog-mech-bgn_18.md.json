["```py\nimport math\n\nfrom eqs.matrix import Matrix\nfrom eqs.vector import Vector\n\ndef cholesky_solve(sys_mat: Matrix, sys_vec: Vector):\n    validate_system(sys_mat, sys_vec)\n\n    low_matrix = lower_matrix_decomposition(sys_mat)\n    low_solution = solve_lower_sys(low_matrix, sys_vec)\n    return solve_upper_sys(low_matrix, low_solution)\n```", "```py\n--snip--\n\ndef validate_system(sys_matrix: Matrix, sys_vector: Vector):\n    if sys_matrix.cols_count != sys_vector.length:\n        raise ValueError('Size mismatch between matrix and vector')\n\n    if not sys_matrix.is_square:\n        raise ValueError('System matrix must be square')\n```", "```py\nimport unittest\n\nfrom eqs.cholesky import lower_matrix_decomposition\nfrom eqs.matrix import Matrix\n\nclass CholeskyTest(unittest.TestCase):\n    sys_matrix = Matrix(4, 4).set_data([\n        4, -2, 4, 2,\n        -2, 10, -2, -7,\n        4, -2, 8, 4,\n        2, -7, 4, 7\n    ])\n    low_matrix = Matrix(4, 4).set_data([\n        2, 0, 0, 0,\n        -1, 3, 0, 0,\n        2, 0, 2, 0,\n        1, -2, 1, 1\n    ])\n\n    def test_lower_matrix_decomposition(self):\n        actual = lower_matrix_decomposition(self.sys_matrix)\n        self.assertEqual(self.low_matrix, actual)\n```", "```py\n--snip--\n\ndef lower_matrix_decomposition(sys_mat: Matrix):\n    size = sys_mat.rows_count\n    low_mat = Matrix(size, size)\n\n    for i in range(size):\n        sq_sum = 0\n\n        for j in range(i + 1): \n         ➊ m_ij = sys_mat.value_at(i, j)\n\n           if i == j:\n               # main diagonal value\n            ➋ diag_val = math.sqrt(m_ij - sq_sum)\n            ➌ low_mat.set_value(diag_val, i, j)\n\n           else:\n               # value under main diagonal\n               non_diag_sum = 0\n            ➍ for k in range(j):\n                   l_ik = low_mat.value_at(i, k)\n                   l_jk = low_mat.value_at(j, k)\n                   non_diag_sum += l_ik * l_jk\n\n               l_jj = low_mat.value_at(j, j)\n            ➎ non_diag_val = (m_ij - non_diag_sum) / l_jj\n            ➏ sq_sum += non_diag_val * non_diag_val\n\n            ➐ low_mat.set_value(non_diag_val, i, j)\n\n    return low_mat\n```", "```py\n$ python3 -m unittest eqs/tests/cholesky_test.py\n```", "```py\nimport unittest\n\nfrom eqs.cholesky import lower_matrix_decomposition, \\\n    solve_lower_sys\nfrom eqs.matrix import Matrix\nfrom eqs.vector import Vector\n\nclass CholeskyTest(unittest.TestCase):\n    --snip--\n  ➊ sys_vec = Vector(4).set_data([20, -16, 40, 28])\n  ➋ low_solution = Vector(4).set_data([10, -2, 10, 4])\n\n    def test_lower_matrix_decomposition(self):\n        actual = lower_matrix_decomposition(self.sys_matrix)\n        self.assertEqual(self.low_matrix, actual)\n\n  ➌ def test_lower_system_resolution(self):\n        actual = solve_lower_sys(self.low_matrix, self.sys_vec)\n        self.assertEqual(self.low_solution, actual)\n```", "```py\n--snip--\n\ndef solve_lower_sys(low_mat: Matrix, vector: Vector):\n    size = vector.length\n    solution = Vector(size)\n\n ➊ for i in range(size):\n        _sum = 0.0\n\n     ➋ for j in range(i):\n            l_ij = low_mat.value_at(i, j)\n            y_j = solution.value_at(j)\n            _sum += l_ij * y_j\n\n        b_i = vector.value_at(i)\n        l_ii = low_mat.value_at(i, i)\n     ➌ solution_val = (b_i - _sum) / l_ii\n        solution.set_value(solution_val, i)\n\n    return solution\n```", "```py\n$ python3 -m unittest eqs/tests/cholesky_test.py\n```", "```py\nimport unittest\n\nfrom eqs.cholesky import lower_matrix_decomposition, \\\n    solve_lower_sys, solve_upper_sys\nfrom eqs.matrix import Matrix\nfrom eqs.vector import Vector\n\nclass CholeskyTest(unittest.TestCase):\n    --snip--\n ➊ solution = Vector(4).set_data([1, 2, 3, 4])\n\n    def test_lower_matrix_decomposition(self):\n        actual = lower_matrix_decomposition(self.sys_matrix)\n        self.assertEqual(self.low_matrix, actual)\n\n    def test_lower_system_resolution(self):\n        actual = solve_lower_sys(self.low_matrix, self.sys_vec)\n        self.assertEqual(self.low_solution, actual)\n\n ➋ def test_upper_system_resolution(self):\n        actual = solve_upper_sys(\n            self.low_matrix,\n            self.low_solution\n        )\n        self.assertEqual(self.solution, actual)\n```", "```py\n--snip--\n\ndef solve_upper_sys(up_matrix: Matrix, vector: Vector):\n    size = vector.length\n    last_index = size - 1\n    solution = Vector(size)\n\n ➊ for i in range(last_index, -1, -1):\n        _sum = 0.0\n\n     ➋ for j in range(i + 1, size):\n         ➌ u_ij = up_matrix.value_transposed_at(i, j)\n            x_j = solution.value_at(j)\n            _sum += u_ij * x_j\n\n        y_i = vector.value_at(i)\n     ➍ u_ii = up_matrix.value_transposed_at(i, i)\n     ➎ solution_val = (y_i - _sum) / u_ii\n        solution.set_value(solution_val, i)\n\n    return solution\n```", "```py\nimport math\n\nfrom eqs.matrix import Matrix\nfrom eqs.vector import Vector\n\ndef cholesky_solve(sys_mat: Matrix, sys_vec: Vector) -> Vector:\n    validate_system(sys_mat, sys_vec)\n\n    low_matrix = lower_matrix_decomposition(sys_mat)\n    low_solution = solve_lower_sys(low_matrix, sys_vec)\n    return solve_upper_sys(low_matrix, low_solution)\n\ndef validate_system(sys_matrix: Matrix, sys_vector: Vector):\n    if sys_matrix.cols_count != sys_vector.length:\n        raise ValueError('Size mismatch between matrix and vector')\n\n    if not sys_matrix.is_square:\n        raise ValueError('System matrix must be square')\n\ndef lower_matrix_decomposition(sys_mat: Matrix) -> Matrix:\n    size = sys_mat.rows_count\n    low_mat = Matrix(size, size)\n\n    for i in range(size):\n        sq_sum = 0\n\n        for j in range(i + 1):\n            m_ij = sys_mat.value_at(i, j)\n\n            if i == j:\n                # main diagonal value\n                diag_val = math.sqrt(m_ij - sq_sum)\n                low_mat.set_value(diag_val, i, j)\n\n            else:\n                # value under main diagonal\n                non_diag_sum = 0\n                for k in range(j):\n                    l_ik = low_mat.value_at(i, k)\n                    l_jk = low_mat.value_at(j, k)\n                    non_diag_sum += l_ik * l_jk\n\n                l_jj = low_mat.value_at(j, j)\n                non_diag_val = (m_ij - non_diag_sum) / l_jj\n                sq_sum += non_diag_val * non_diag_val\n\n                low_mat.set_value(non_diag_val, i, j)\n\n    return low_mat\n\ndef solve_lower_sys(low_mat: Matrix, vector: Vector):\n    size = vector.length\n    solution = Vector(size)\n\n    for i in range(size):\n        _sum = 0.0\n\n        for j in range(i):\n            l_ij = low_mat.value_at(i, j)\n            y_j = solution.value_at(j)\n            _sum += l_ij * y_j\n\n        b_i = vector.value_at(i)\n        l_ii = low_mat.value_at(i, i)\n        solution_val = (b_i - _sum) / l_ii\n        solution.set_value(solution_val, i)\n\n    return solution\n\ndef solve_upper_sys(up_matrix: Matrix, vector: Vector):\n    size = vector.length\n    last_index = size - 1\n    solution = Vector(size)\n\n    for i in range(last_index, -1, -1):\n        _sum = 0.0\n\n        for j in range(i + 1, size):\n            u_ij = up_matrix.value_transposed_at(i, j)\n            x_j = solution.value_at(j)\n            _sum += u_ij * x_j\n\n        y_i = vector.value_at(i)\n        u_ii = up_matrix.value_transposed_at(i, i)\n        solution_val = (y_i - _sum) / u_ii\n        solution.set_value(solution_val, i)\n\n    return solution\n```", "```py\nimport unittest\n\nfrom eqs.cholesky import lower_matrix_decomposition, \\\n    solve_lower_sys, solve_upper_sys, cholesky_solve\nfrom eqs.matrix import Matrix\nfrom eqs.vector import Vector\n\nclass CholeskyTest(unittest.TestCase):\n    sys_matrix = Matrix(4, 4).set_data([\n        4, -2, 4, 2,\n        -2, 10, -2, -7,\n        4, -2, 8, 4,\n        2, -7, 4, 7\n    ])\n    low_matrix = Matrix(4, 4).set_data([\n        2, 0, 0, 0,\n        -1, 3, 0, 0,\n        2, 0, 2, 0,\n        1, -2, 1, 1\n    ])\n    sys_vec = Vector(4).set_data([20, -16, 40, 28])\n    low_solution = Vector(4).set_data([10, -2, 10, 4])\n    solution = Vector(4).set_data([1, 2, 3, 4])\n\n    def test_lower_matrix_decomposition(self):\n        actual = lower_matrix_decomposition(self.sys_matrix)\n        self.assertEqual(self.low_matrix, actual)\n\n    def test_lower_system_resolution(self):\n        actual = solve_lower_sys(self.low_matrix, self.sys_vec)\n        self.assertEqual(self.low_solution, actual)\n\n    def test_upper_system_resolution(self):\n        actual = solve_upper_sys(\n            self.low_matrix,\n            self.low_solution\n        )\n        self.assertEqual(self.solution, actual)\n\n    def test_solve_system(self):\n        actual = cholesky_solve(self.sys_matrix, self.sys_vec)\n        self.assertEqual(self.solution, actual)\n```", "```py\n$ python3 -m unittest eqs/tests/cholesky_test.py\n```"]