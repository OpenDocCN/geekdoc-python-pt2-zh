- en: '**2**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**2**'
- en: '**MODULES, LIBRARIES, AND FRAMEWORKS**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**模块、库和框架**'
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: Modules are an essential part of what makes Python extensible. Without them,
    Python would just be a language built around a monolithic interpreter; it wouldn’t
    flourish within a giant ecosystem that allows developers to build applications
    quickly and simply by combining extensions. In this chapter, I’ll introduce you
    to some of the features that make Python modules great, from the built-in modules
    you need to know to externally managed frameworks.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 模块是使 Python 可扩展性得以实现的关键部分。没有它们，Python 就只会是一个围绕着单体解释器构建的语言；它也无法在一个巨大的生态系统中蓬勃发展，无法让开发者通过组合扩展迅速且简便地构建应用程序。在这一章中，我将向你介绍一些使
    Python 模块如此出色的特性，包括你需要了解的内置模块和外部管理的框架。
- en: '**The Import System**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**导入系统**'
- en: To use modules and libraries in your programs, you have to import them using
    the import keyword. As an example, [Listing 2-1](ch02.xhtml#ch2list1) imports
    the all-important Zen of Python guidelines.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 要在你的程序中使用模块和库，必须使用 import 关键字导入它们。举个例子，[示例 2-1](ch02.xhtml#ch2list1) 导入了至关重要的
    Python 之禅指导原则。
- en: '>>> import this'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> import this'
- en: The Zen of Python, by Tim Peters
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 《Python之禅》，Tim Peters 编写
- en: Beautiful is better than ugly.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 美丽优于丑陋。
- en: Explicit is better than implicit.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 明确优于隐式。
- en: Simple is better than complex.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 简单优于复杂。
- en: Complex is better than complicated.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂优于复杂化。
- en: Flat is better than nested.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 扁平优于嵌套。
- en: Sparse is better than dense.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 稀疏优于密集。
- en: Readability counts.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性很重要。
- en: Special cases aren't special enough to break the rules.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊情况不足以打破规则。
- en: Although practicality beats purity.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管实用性优于纯粹性。
- en: Errors should never pass silently.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 错误永远不应默默地通过。
- en: Unless explicitly silenced.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 除非明确地被静默处理。
- en: In the face of ambiguity, refuse the temptation to guess.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 面对模糊时，拒绝猜测的诱惑。
- en: There should be one-- and preferably only one --obvious way to do it.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 应该有一种——并且最好只有一种——显而易见的做法。
- en: Although that way may not be obvious at first unless you're Dutch.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管除非你是荷兰人，否则这种方式一开始可能不太明显。
- en: Now is better than never.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在比永远都好。
- en: Although never is often better than *right* now.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有时永远比*现在*更好。
- en: If the implementation is hard to explain, it's a bad idea.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果实现难以解释，那就不是一个好主意。
- en: If the implementation is easy to explain, it may be a good idea.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果实现容易解释，那么这可能是个好主意。
- en: Namespaces are one honking great idea -- let's do more of those!
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间是一个极棒的想法——我们应该多做一些！
- en: '*Listing 2-1: The Zen of Python*'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 2-1：Python之禅*'
- en: The import system is quite complex, and I’m assuming you already know the basics,
    so here I’ll show you some of the internals of this system, including how the
    sys module works, how to change or add import paths, and how to use custom importers.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 导入系统相当复杂，我假设你已经掌握了基础知识，因此在这里我将向你展示该系统的一些内部机制，包括 sys 模块如何工作、如何更改或添加导入路径，以及如何使用自定义导入器。
- en: 'First, you need to know that the import keyword is actually a wrapper around
    a function named __import__. Here is a familiar way of importing a module:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要知道 import 关键字实际上是一个包装函数，名为 __import__。以下是一个导入模块的常见方式：
- en: '>>> import itertools'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> import itertools'
- en: '>>> itertools'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> itertools'
- en: <module 'itertools' from '/usr/.../>
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: <module 'itertools' from '/usr/.../>
- en: 'This is precisely equivalent to this method:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这与以下方法完全等效：
- en: '>>> itertools = __import__("itertools")'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> itertools = __import__("itertools")'
- en: '>>> itertools'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> itertools'
- en: <module 'itertools' from '/usr/.../>
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: <module 'itertools' from '/usr/.../>
- en: 'You can also imitate the as keyword of import, as these two equivalent ways
    of importing show:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以模仿 import 的 as 关键字，如以下两种等效的导入方式所示：
- en: '>>> import itertools as it'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> import itertools as it'
- en: '>>> it'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> it'
- en: <module 'itertools' from '/usr/.../>
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: <module 'itertools' from '/usr/.../>
- en: 'And here’s the second example:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第二个例子：
- en: '>>> it = __import__("itertools")'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> it = __import__("itertools")'
- en: '>>> it'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> it'
- en: <module 'itertools' from '/usr/.../>
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: <module 'itertools' from '/usr/.../>
- en: 'While import is a keyword in Python, internally it’s a simple function that’s
    accessible through the __import__ name. The __import__ function is extremely useful
    to know, as in some (corner) cases, you might want to import a module whose name
    is unknown beforehand, like so:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 import 是 Python 中的一个关键字，但从内部来看，它是一个通过 __import__ 名称访问的简单函数。__import__ 函数非常有用，因为在某些（特殊）情况下，你可能想导入一个事先不知道名称的模块，像这样：
- en: '>>> random = __import__("RANDOM".lower())'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> random = __import__("RANDOM".lower())'
- en: '>>> random'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> random'
- en: <module 'random' from '/usr/.../>
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: <module 'random' from '/usr/.../>
- en: Don’t forget that modules, once imported, are essentially objects whose attributes
    (classes, functions, variables, and so on) are objects.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记，模块一旦被导入，本质上就是对象，它的属性（类、函数、变量等）也是对象。
- en: '***The sys Module***'
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***sys 模块***'
- en: The sys module provides access to variables and functions related to Python
    itself and the operating system it is running on. This module also contains a
    lot of information about Python’s import system.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: sys 模块提供了与 Python 本身及其运行操作系统相关的变量和函数的访问权限。这个模块还包含了关于 Python 导入系统的大量信息。
- en: 'First of all, you can retrieve the list of modules currently imported using
    the sys.modules variable. The sys.modules variable is a dictionary whose key is
    the module name you want to inspect and whose returned value is the module object.
    For example, once the os module is imported, we can retrieve it by entering:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以使用 sys.modules 变量检索当前已导入的模块列表。sys.modules 是一个字典，键是你想检查的模块名，返回的值是模块对象。例如，一旦
    os 模块被导入，我们可以通过输入以下内容来获取它：
- en: '>>> import sys'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> import sys'
- en: '>>> import os'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> import os'
- en: '>>> sys.modules[''os'']'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> sys.modules[''os'']'
- en: <module 'os' from '/usr/lib/python2.7/os.pyc'>
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: <module 'os' from '/usr/lib/python2.7/os.pyc'>
- en: The sys.modules variable is a standard Python dictionary that contains all loaded
    modules. That means that calling sys.modules.keys(), for example, will return
    the complete list of the names of loaded modules.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: sys.modules 变量是一个标准的 Python 字典，包含所有已加载的模块。这意味着，例如，调用 sys.modules.keys() 将返回已加载模块的完整名称列表。
- en: You can also retrieve the list of modules that are built in by using the sys.builtin_module_names
    variable. The built-in modules compiled to your interpreter can vary depending
    on what compilation options were passed to the Python build system.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 sys.builtin_module_names 变量来检索内建模块的列表。根据传递给 Python 构建系统的编译选项，编译到解释器中的内建模块可能会有所不同。
- en: '***Import Paths***'
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***导入路径***'
- en: When importing modules, Python relies on a list of paths to know where to look
    for the module. This list is stored in the sys.path variable. To check which paths
    your interpreter will search for modules, just enter sys.path.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当导入模块时，Python 依赖于一个路径列表来确定从哪里查找模块。这个列表存储在 sys.path 变量中。要检查解释器将搜索哪些路径，只需输入 sys.path。
- en: 'You can change this list, adding or removing paths as necessary, or even modify
    the PYTHONPATH environment variable to add paths without writing Python code at
    all. Adding paths to the sys.path variable can be useful if you want to install
    Python modules to nonstandard locations, such as a test environment. In normal
    operations, however, it should not be necessary to change the path variable. The
    following approaches are almost equivalent—*almost* because the path will not
    be placed at the same level in the list; this difference may not matter, depending
    on your use case:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以更改这个列表，根据需要添加或删除路径，或者甚至修改 PYTHONPATH 环境变量来添加路径，而无需编写任何 Python 代码。如果你想将 Python
    模块安装到非标准位置（例如测试环境），将路径添加到 sys.path 变量中会很有用。然而，在正常操作中，通常不需要修改路径变量。以下方法几乎等效——*几乎*因为路径在列表中的位置不会完全相同；这种差异可能不重要，取决于你的使用场景：
- en: '>>> import sys'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> import sys'
- en: '>>> sys.path.append(''/foo/bar'')'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> sys.path.append(''/foo/bar'')'
- en: 'This would be (almost) the same as:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎等同于：
- en: $ PYTHONPATH=/foo/bar python
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: $ PYTHONPATH=/foo/bar python
- en: '>>> import sys'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> import sys'
- en: '>>> ''/foo/bar'' in sys.path'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> ''/foo/bar'' in sys.path'
- en: 'True'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 'True'
- en: It’s important to note that the list will be iterated over to find the requested
    module, so the order of the paths in sys.path is important. It’s useful to put
    the path most likely to contain the modules you are importing early in the list
    to speed up search time. Doing so also ensures that if two modules with the same
    name are available, the first match will be picked.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，这个列表会被逐一迭代来查找请求的模块，因此 sys.path 中路径的顺序非常重要。将最有可能包含你正在导入的模块的路径放在列表前面，可以加快搜索速度。这样做还确保如果有两个同名的模块可用，解释器会选择第一个匹配的模块。
- en: This last property is especially important because one common mistake is to
    shadow Python built-in modules with your own. Your current directory is searched
    before the Python Standard Library directory. That means that if you decide to
    name one of your scripts *random.py* and then try using import random, the file
    from your current directory will be imported rather than the Python module.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个属性尤其重要，因为一个常见的错误是用你自己的模块覆盖 Python 内建模块。你的当前目录会在 Python 标准库目录之前被搜索。这意味着，如果你决定将某个脚本命名为
    *random.py*，然后尝试使用 `import random`，当前目录中的文件将被导入，而不是 Python 的标准模块。
- en: '***Custom Importers***'
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***自定义导入器***'
- en: You can also extend the import mechanism using custom importers. This is the
    technique that the Lisp-Python dialect Hy uses to teach Python how to import files
    other than standard *.py* or *.pyc* files. (Hy is a Lisp implementation on top
    of Python, discussed later in the section “[A Quick Introduction to Hy](ch09.xhtml#lev1sec48)”
    on [page 145](ch09.xhtml#page_145).)
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用自定义导入器扩展导入机制。这正是Lisp-Python方言Hy所使用的技术，它教Python如何导入标准的*.py*或*.pyc*文件以外的文件。（Hy是一个基于Python的Lisp实现，稍后将在“[Hy简介](ch09.xhtml#lev1sec48)”部分中讨论，参见[第145页](ch09.xhtml#page_145)。）
- en: The *import hook mechanism*, as this technique is called, is defined by PEP
    302\. It allows you to extend the standard import mechanism, which in turn allows
    you to modify how Python imports modules and build your own system of import.
    For example, you could write an extension that imports modules from a database
    over the network or that does some sanity checking before importing any module.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*导入钩子机制*，也就是这种技术，是由PEP 302定义的。它允许你扩展标准的导入机制，从而修改Python导入模块的方式，并构建你自己的导入系统。例如，你可以编写一个扩展，从网络上的数据库导入模块，或者在导入任何模块之前做一些完整性检查。'
- en: 'Python offers two different but related ways to broaden the import system:
    the meta path finders for use with sys.meta_path and the path entry finders for
    use with sys.path_hooks.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了两种不同但相关的方式来扩展导入系统：用于sys.meta_path的元路径查找器和用于sys.path_hooks的路径条目查找器。
- en: '***Meta Path Finders***'
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***元路径查找器***'
- en: The *meta path finder* is an object that will allow you to load custom objects
    as well as standard *.py* files. A meta path finder object must expose a find_module(fullname,
    path=None) method that returns a loader object. The loader object must also have
    a load_module(fullname) method responsible for loading the module from a source
    file.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*元路径查找器*是一个对象，它允许你加载自定义对象以及标准的*.py*文件。一个元路径查找器对象必须暴露一个find_module(fullname,
    path=None)方法，该方法返回一个加载器对象。加载器对象还必须拥有一个load_module(fullname)方法，负责从源文件加载模块。'
- en: To illustrate, [Listing 2-2](ch02.xhtml#ch2list2) shows how Hy uses a custom
    meta path finder to enable Python to import source files ending with *.hy* instead
    of *.py*.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，[示例 2-2](ch02.xhtml#ch2list2)展示了Hy如何使用自定义元路径查找器，使Python能够导入以*.hy*结尾的源文件，而不是*.py*文件。
- en: 'class MetaImporter(object):'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 'class MetaImporter(object):'
- en: 'def find_on_path(self, fullname):'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 'def find_on_path(self, fullname):'
- en: fls = ["%s/__init__.hy", "%s.hy"]
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: fls = ["%s/__init__.hy", "%s.hy"]
- en: dirpath = "/".join(fullname.split("."))
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: dirpath = "/".join(fullname.split("."))
- en: 'for pth in sys.path:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 对于sys.path中的每个pth：
- en: pth = os.path.abspath(pth)
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: pth = os.path.abspath(pth)
- en: 'for fp in fls:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 对于fp中的每个文件：
- en: composed_path = fp % ("%s/%s" % (pth, dirpath))
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: composed_path = fp % ("%s/%s" % (pth, dirpath))
- en: 'if os.path.exists(composed_path):'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '如果os.path.exists(composed_path):'
- en: return composed_path
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 返回composed_path
- en: 'def find_module(self, fullname, path=None):'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 'def find_module(self, fullname, path=None):'
- en: path = self.find_on_path(fullname)
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: path = self.find_on_path(fullname)
- en: 'if path:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果path存在：
- en: return MetaLoader(path)
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 返回MetaLoader(path)
- en: sys.meta_path.append(MetaImporter())
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: sys.meta_path.append(MetaImporter())
- en: '*Listing 2-2: A Hy module importer*'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 2-2: 一个Hy模块导入器*'
- en: Once Python has determined that the path is valid and that it points to a module,
    a MetaLoader object is returned, as shown in [Listing 2-3](ch02.xhtml#ch2list3).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Python确定路径有效且指向一个模块，就会返回一个MetaLoader对象，如[示例 2-3](ch02.xhtml#ch2list3)所示。
- en: 'class MetaLoader(object):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 'class MetaLoader(object):'
- en: 'def __init__(self, path):'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, path):'
- en: self.path = path
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: self.path = path
- en: 'def is_package(self, fullname):'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 'def is_package(self, fullname):'
- en: dirpath = "/".join(fullname.split("."))
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: dirpath = "/".join(fullname.split("."))
- en: 'for pth in sys.path:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对于sys.path中的每个pth：
- en: pth = os.path.abspath(pth)
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: pth = os.path.abspath(pth)
- en: composed_path = "%s/%s/__init__.hy" % (pth, dirpath)
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: composed_path = "%s/%s/__init__.hy" % (pth, dirpath)
- en: 'if os.path.exists(composed_path):'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '如果os.path.exists(composed_path):'
- en: return True
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 返回True
- en: return False
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 返回False
- en: 'def load_module(self, fullname):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 'def load_module(self, fullname):'
- en: 'if fullname in sys.modules: return sys.modules[fullname]'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果fullname在sys.modules中：返回sys.modules[fullname]
- en: 'if not self.path:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果self.path为空：
- en: return
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: sys.modules[fullname] = None
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: sys.modules[fullname] = None
- en: ➊ mod = import_file_to_module(fullname, self.path)
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ mod = import_file_to_module(fullname, self.path)
- en: ispkg = self.is_package(fullname)
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ispkg = self.is_package(fullname)
- en: mod.__file__ = self.path
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: mod.__file__ = self.path
- en: mod.__loader__ = self
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: mod.__loader__ = self
- en: mod.__name__ = fullname
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: mod.__name__ = fullname
- en: 'if ispkg:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是包：
- en: mod.__path__ = []
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: mod.__path__ = []
- en: mod.__package__ = fullname
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: mod.__package__ = fullname
- en: 'else:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 否则：
- en: mod.__package__ = fullname.rpartition('.')[0]
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: mod.__package__ = fullname.rpartition('.')[0]
- en: sys.modules[fullname] = mod
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: sys.modules[fullname] = mod
- en: return mod
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 返回mod
- en: '*Listing 2-3: A Hy module loader object*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 2-3: 一个Hy模块加载器对象*'
- en: At ➊, import_file_to_module reads a *.hy* source file, compiles it to Python
    code, and returns a Python module object.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，import_file_to_module 读取一个 *.hy* 源文件，将其编译为 Python 代码，并返回一个 Python 模块对象。
- en: 'This loader is pretty straightforward: once the *.hy* file is found, it’s passed
    to this loader, which compiles the file if necessary, registers it, sets some
    attributes, and then returns it to the Python interpreter.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这个加载器相当简单：一旦找到 *.hy* 文件，它会传递给这个加载器，必要时进行编译、注册、设置一些属性，然后返回给 Python 解释器。
- en: The uprefix module is another good example of this feature in action. Python
    3.0 through 3.2 didn’t support the u prefix for denoting Unicode strings that
    was featured in Python 2; the uprefix module ensures compatibility between Python
    versions 2 and 3 by removing the u prefix from strings before compilation.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: uprefix 模块是另一个该功能运作的良好示例。Python 3.0 到 3.2 不支持 Python 2 中用于表示 Unicode 字符串的 u
    前缀；uprefix 模块通过在编译前移除字符串中的 u 前缀，确保 Python 2 和 3 之间的兼容性。
- en: '**Useful Standard Libraries**'
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**有用的标准库**'
- en: Python comes with a huge standard library packed with tools and features for
    almost any purpose you can think of. Newcomers to Python who are used to having
    to write their own functions for basic tasks are often shocked to find that the
    language itself ships with so much functionality built in and ready for use.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Python 自带一个庞大的标准库，里面包含了几乎任何你能想到的工具和功能。对于那些习惯于自己编写基本任务函数的新手来说，通常会惊讶于 Python 本身已经内建了这么多功能，随时可以使用。
- en: Whenever you’re tempted to write your own function to handle a simple task,
    first stop and look through the standard library. In fact, skim through the whole
    thing at least once before you begin working with Python so that next time you
    need a function, you have an idea of whether it already exists in the standard
    library.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你想要编写自己的函数来处理一个简单任务时，首先停下来查看标准库。事实上，在开始使用 Python 之前，至少浏览一遍整个标准库，这样下次需要某个函数时，你就知道它是否已经在标准库中存在。
- en: 'We’ll talk about some of these modules, such as functools and itertools, in
    later chapters, but here are a few of the standard modules that you’ll definitely
    find useful:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后续章节讨论一些这些模块，如 functools 和 itertools，但这里列出的是一些你绝对会觉得有用的标准模块：
- en: atexit allows you to register functions for your program to call when it exits.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: atexit 允许你注册程序退出时调用的函数。
- en: argparse provides functions for parsing command line arguments.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: argparse 提供用于解析命令行参数的函数。
- en: bisect provides bisection algorithms for sorting lists (see [Chapter 10](ch10.xhtml#ch10)).
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: bisect 提供排序列表的二分查找算法（参见 [第 10 章](ch10.xhtml#ch10)）。
- en: calendar provides a number of date-related functions.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: calendar 提供多个与日期相关的函数。
- en: codecs provides functions for encoding and decoding data.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: codecs 提供用于编码和解码数据的函数。
- en: collections provides a variety of useful data structures.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: collections 提供多种有用的数据结构。
- en: copy provides functions for copying data.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: copy 提供用于复制数据的函数。
- en: csv provides functions for reading and writing CSV files.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: csv 提供用于读取和写入 CSV 文件的函数。
- en: datetime provides classes for handling dates and times.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: datetime 提供处理日期和时间的类。
- en: fnmatch provides functions for matching Unix-style filename patterns.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: fnmatch 提供用于匹配 Unix 风格文件名模式的函数。
- en: concurrent provides asynchronous computation (native in Python 3, available
    for Python 2 via PyPI).
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: concurrent 提供异步计算（Python 3 中是原生支持，Python 2 可通过 PyPI 使用）。
- en: glob provides functions for matching Unix-style path patterns.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: glob 提供用于匹配 Unix 风格路径模式的函数。
- en: io provides functions for handling I/O streams. In Python 3, it also contains
    StringIO (inside the module of the same name in Python 2), which allows you to
    treat strings as files.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: io 提供处理 I/O 流的函数。在 Python 3 中，它还包含 StringIO（在 Python 2 中是同名模块的一部分），允许你将字符串当作文件来处理。
- en: json provides functions for reading and writing data in JSON format.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json 提供用于读取和写入 JSON 格式数据的函数。
- en: logging provides access to Python’s own built-in logging functionality.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: logging 提供对 Python 内置日志功能的访问。
- en: multiprocessing allows you to run multiple subprocesses from your application,
    while providing an API that makes them look like threads.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: multiprocessing 允许你从应用程序中运行多个子进程，同时提供一个 API，使它们看起来像线程。
- en: operator provides functions implementing the basic Python operators, which you
    can use instead of having to write your own lambda expressions (see [Chapter 10](ch10.xhtml#ch10)).
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: operator 提供实现基本 Python 运算符的函数，你可以使用这些函数，而无需编写自己的 lambda 表达式（参见 [第 10 章](ch10.xhtml#ch10)）。
- en: os provides access to basic OS functions.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: os 提供对基本操作系统功能的访问。
- en: random provides functions for generating pseudorandom numbers.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: random 提供生成伪随机数的功能。
- en: re provides regular expression functionality.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: re 提供正则表达式功能。
- en: sched provides an event scheduler without using multithreading.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: sched 提供一个无需多线程的事件调度器。
- en: select provides access to the select() and poll() functions for creating event
    loops.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: select 提供访问 select() 和 poll() 函数的接口，用于创建事件循环。
- en: shutil provides access to high-level file functions.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: shutil 提供访问高级文件操作功能的接口。
- en: signal provides functions for handling POSIX signals.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: signal 提供处理 POSIX 信号的功能。
- en: tempfile provides functions for creating temporary files and directories.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: tempfile 提供创建临时文件和目录的功能。
- en: threading provides access to high-level threading functionality.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: threading 提供访问高级线程功能的接口。
- en: urllib (and urllib2 and urlparse in Python 2.*x*) provides functions for handling
    and parsing URLs.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: urllib（在 Python 2.*x* 中为 urllib2 和 urlparse）提供处理和解析 URL 的功能。
- en: uuid allows you to generate Universally Unique Identifiers (UUIDs).
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: uuid 允许你生成全球唯一标识符（UUID）。
- en: Use this list as a quick reference for what these useful libraries modules do.
    If you can memorize even part of this list, all the better. The less time you
    have to spend looking up library modules, the more time you can spend writing
    the code you actually need.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个列表作为快速参考，了解这些有用的库模块的功能。如果你能记住其中的一部分，那就更好了。你花在查找库模块上的时间越少，你就能花更多时间编写实际需要的代码。
- en: Most of the standard library is written in Python, so there’s nothing stopping
    you from looking at the source code of the modules and functions. When in doubt,
    crack open the code and see what it does for yourself. Even if the documentation
    has everything you need to know, there’s always a chance you could learn something
    useful.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分标准库是用 Python 编写的，因此你完全可以查看模块和函数的源代码。当有疑问时，打开代码亲自看看它是如何工作的。即便文档已经提供了你所需的所有信息，仍然有可能从中学到一些有用的东西。
- en: '**External Libraries**'
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**外部库**'
- en: Python’s “batteries included” philosophy is that, once you have Python installed,
    you should have everything you need to build whatever you want. This is to prevent
    the programming equivalent of unwrapping an awesome gift only to find out that
    whoever gave it to you forgot to buy batteries for it.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的“内置电池”理念是，一旦你安装了 Python，你就应该拥有构建任何你想要的项目所需的一切。这是为了避免出现类似于打开一个很棒的礼物，却发现送礼人忘了买电池的情况。
- en: Unfortunately, there’s no way the people behind Python can predict *everything*
    you might want to make. And even if they could, most people wouldn’t want to deal
    with a multigigabyte download, especially if they just wanted to write a quick
    script for renaming files. So even with its extensive functionality, the Python
    Standard Library doesn’t cover everything. Luckily, members of the Python community
    have created external libraries.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，Python 的开发者无法预测你可能想要制作的*所有*东西。即使他们能做到，大多数人也不愿意处理一个多吉字节的下载，特别是当他们只是想写一个简单的脚本来重命名文件时。因此，即使
    Python 标准库功能非常丰富，它也不能涵盖所有内容。幸运的是，Python 社区的成员创建了外部库。
- en: 'The Python Standard Library is safe, well-charted territory: its modules are
    heavily documented, and enough people use it on a regular basis that you can feel
    assured it won’t break messily when you give it a try—and in the unlikely event
    that it *does* break, you can be confident someone will fix it in short order.
    External libraries, on the other hand, are the parts of the map labeled “here
    there be dragons”: documentation may be sparse, functionality may be buggy, and
    updates may be sporadic or even nonexistent. Any serious project will likely need
    functionality that only external libraries can provide, but you need to be mindful
    of the risks involved in using them.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Python 标准库是安全且已有充分文档记录的领域：它的模块都有详尽的文档，且有足够多的人定期使用它，因此你可以放心地尝试它，不会在使用时发生混乱——如果发生了不太可能的故障，你也可以相信会有人在短时间内修复它。而外部库则是地图上标注有“这里有龙”的地方：文档可能很稀缺，功能可能存在
    bug，更新可能不稳定，甚至没有更新。任何严肃的项目都可能需要外部库才能提供的功能，但你需要意识到使用它们时所涉及的风险。
- en: Here’s a tale of external library dangers from the trenches. OpenStack uses
    SQLAlchemy, a database toolkit for Python. If you’re familiar with SQL, you know
    that database schemas can change over time, so OpenStack also made use of sqlalchemy-migrate
    to handle schema migration needs. And it worked . . . until it didn’t. Bugs started
    piling up, and nothing was getting done about them. At this time, OpenStack was
    also interested in supporting Python 3, but there was no sign that sqlalchemy-migrate
    was moving toward Python 3 support. It was clear by that point that sqlalchemy-migrate
    was effectively dead for our needs and we needed to switch to something else—our
    needs had outlived the capabilities of the external library. At the time of this
    writing, OpenStack projects are migrating toward using Alembic instead, a new
    SQL database migrations tool with Python 3 support. This is happening not without
    some effort, but fortunately without much pain.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是来自实践中的外部库危险故事。OpenStack 使用 SQLAlchemy，这是一个 Python 数据库工具包。如果你熟悉 SQL，你就知道数据库模式会随着时间变化，因此
    OpenStack 还使用了 sqlalchemy-migrate 来处理模式迁移需求。它曾经有效……直到它不再有效。Bug 开始积累，但没有人处理。此时，OpenStack
    还希望支持 Python 3，但没有迹象表明 sqlalchemy-migrate 正朝着 Python 3 支持的方向发展。到那时，显然 sqlalchemy-migrate
    对我们的需求已经基本上不适用了，我们需要切换到其他方案——我们的需求超出了外部库的能力范围。撰写本文时，OpenStack 项目正迁移到使用 Alembic，这是一个支持
    Python 3 的新 SQL 数据库迁移工具。这一过程并非没有努力，但幸运的是，几乎没有痛苦。
- en: '***The External Libraries Safety Checklist***'
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***外部库安全检查清单***'
- en: 'All of this builds up to one important question: how can you be sure you won’t
    fall into this external libraries trap? Unfortunately, you can’t: programmers
    are people, too, and there’s no way you can know for sure whether a library that’s
    zealously maintained today will still be in good shape in a few months. However,
    using such libraries may be worth the risk; it’s just important to carefully assess
    your situation. At OpenStack, we use the following checklist when choosing whether
    to use an external library, and I encourage you to do the same.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都归结为一个重要的问题：你如何确保不会陷入外部库的陷阱？不幸的是，你无法做到：程序员也是人，无法百分之百确定今天积极维护的库在几个月后是否仍然健康。然而，使用这些库可能值得冒险；关键是要仔细评估你的情况。在
    OpenStack，我们在选择是否使用外部库时会使用以下清单，我鼓励你也这么做。
- en: '**Python 3 compatibility** Even if you’re not targeting Python 3 right now,
    odds are good that you will somewhere down the line, so it’s a good idea to check
    that your chosen library is already Python 3–compatible and committed to staying
    that way.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python 3 兼容性** 即使你现在并不针对 Python 3 进行开发，未来某个时候你很可能会遇到 Python 3，因此最好检查你选择的库是否已经兼容
    Python 3，并且承诺会保持这种兼容性。'
- en: '**Active development** GitHub and Ohloh usually provide enough information
    to determine whether a given library is being actively developed by its maintainers.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**积极开发** GitHub 和 Ohloh 通常提供足够的信息来判断一个库是否在其维护者的积极开发下。'
- en: '**Active maintenance** Even if a library is considered finished (that is, feature
    complete), the maintainers should be ensuring it remains bug-free. Check the project’s
    tracking system to see how quickly the maintainers respond to bugs.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**积极维护** 即使一个库被认为已经完成（即功能已完善），维护者仍应确保其保持无 Bug。检查该项目的跟踪系统，看看维护者响应 Bug 的速度。'
- en: '**Packaged with OS distributions** If a library is packaged with major Linux
    distributions, that means other projects are depending on it—so if something goes
    wrong, you won’t be the only one complaining. It’s also a good idea to check this
    if you plan to release your software to the public: your code will be easier to
    distribute if its dependencies are already installed on the end user’s machine.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**与操作系统发行版捆绑** 如果一个库被包含在主要的 Linux 发行版中，这意味着其他项目也依赖于它——所以如果出现问题，你不会是唯一一个抱怨的人。如果你计划将软件发布给公众，检查这一点也很重要：如果其依赖项已经安装在最终用户的机器上，你的代码会更容易分发。'
- en: '**API compatibility commitment** Nothing’s worse than having your software
    suddenly break because a library it depends on has changed its entire API. You
    might want to check whether your chosen library has had anything like this happen
    in the past.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**API 兼容性承诺** 没有什么比依赖的库突然更改其整个 API 导致软件崩溃更糟糕的了。你可能想检查一下你选择的库是否曾经发生过类似的情况。'
- en: '**License** You need to make sure that the license is compatible with the software
    you’re planning to write and that it allows you to do whatever you intend to do
    with your code in terms of distribution, modification, and execution.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**许可证** 你需要确保许可证与你计划编写的软件兼容，并且它允许你根据分发、修改和执行的需求进行任何你打算做的事情。'
- en: Applying this checklist to dependencies is also a good idea, though that could
    turn out to be a huge undertaking. As a compromise, if you know your application
    is going to depend heavily on a particular library, you should apply this checklist
    to each of that library’s dependencies.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 对依赖项应用此检查清单也是一个好主意，尽管这可能是一个巨大的工作量。作为折中，如果你知道你的应用将严重依赖某个特定库，应该将此检查清单应用到该库的每个依赖项上。
- en: '***Protecting Your Code with an API Wrapper***'
  id: totrans-175
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***用 API 包装器保护你的代码***'
- en: 'No matter what libraries you end up using, you need to treat them as useful
    devices that could potentially do some serious damage. For safety, libraries should
    be treated like any physical tool: kept in your tool shed, away from your fragile
    valuables but available when you actually need them.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你最终使用什么库，都需要将它们视为有用的工具，但也可能会带来严重的风险。为了安全起见，应该像对待任何物理工具一样对待库：将它们放在工具棚里，远离你的易损贵重物品，但在需要时可以使用。
- en: No matter how useful an external library might be, be wary of letting it get
    its hooks into your actual source code. Otherwise, if something goes wrong and
    you need to switch libraries, you might have to rewrite huge swaths of your program.
    A better idea is to write your own API—a wrapper that encapsulates your external
    libraries and keeps them out of your source code. Your program never has to know
    what external libraries it’s using, only what functionality your API provides.
    Then, if you need to use a different library, all you have to change is your wrapper.
    As long as the new library provides the same functionality, you won’t have to
    touch the rest of your codebase at all. There might be exceptions, but probably
    not many; most libraries are designed to solve a tightly focused range of problems
    and can therefore be easily isolated.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 无论外部库有多么有用，都要小心不要让它深度嵌入到你的源代码中。否则，如果发生错误并且你需要更换库，可能需要重写程序的大部分代码。更好的方法是编写你自己的
    API——一个封装外部库的包装器，将它们隔离在源代码之外。你的程序无需知道它正在使用哪些外部库，只需知道你的 API 提供了哪些功能。如果你需要使用不同的库，只需更改你的包装器。只要新库提供相同的功能，你就不需要修改其余的代码库。可能会有例外情况，但应该不多；大多数库设计是为了解决一个特定范围的问题，因此可以轻松隔离。
- en: Later in [Chapter 5](ch05.xhtml#ch05), we’ll also look at how you can use entry
    points to build driver systems that will allow you to treat parts of your projects
    as modules you can switch out at will.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 5 章](ch05.xhtml#ch05)中，我们还将探讨如何使用入口点构建驱动系统，从而允许你将项目的某些部分视为可以随时切换的模块。
- en: '**Package Installation: Getting More from pip**'
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**包安装：从 pip 获得更多功能**'
- en: The pip project offers a really simple way to handle package and external library
    installations. It is actively developed, well maintained, and included with Python
    starting at version 3.4\. It can install or uninstall packages from the *Python
    Packaging Index (PyPI)*, a tarball, or a Wheel archive (we’ll discuss these in
    [Chapter 5](ch05.xhtml#ch05)).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: pip 项目提供了一种非常简单的方法来处理包和外部库的安装。它在积极开发中，得到良好维护，并且从 Python 3.4 版本开始包含在内。它可以从 *Python
    包索引（PyPI）*、tar 包或 Wheel 存档中安装或卸载包（我们将在[第 5 章](ch05.xhtml#ch05)中讨论这些内容）。
- en: 'Its usage is simple:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 它的使用方法很简单：
- en: $ pip install --user voluptuous
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: $ pip install --user voluptuous
- en: Downloading/unpacking voluptuous
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 正在下载/解包 voluptuous
- en: Downloading voluptuous-0.8.3.tar.gz
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 正在下载 voluptuous-0.8.3.tar.gz
- en: Storing download in cache at ./.cache/pip/https%3A%2F%2Fpypi.python.org%2Fpa
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 正在将下载内容存储在缓存中：./.cache/pip/https%3A%2F%2Fpypi.python.org%2Fpa
- en: ckages%2Fsource%2Fv%2Fvoluptuous%2Fvoluptuous-0.8.3.tar.gz
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ckages%2Fsource%2Fv%2Fvoluptuous%2Fvoluptuous-0.8.3.tar.gz
- en: Running setup.py egg_info for package voluptuous
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 正在为包 voluptuous 运行 setup.py egg_info
- en: 'Requirement already satisfied (use --upgrade to upgrade): distribute in /usr/'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 要求已满足（使用 --upgrade 来升级）：distribute 在 /usr/
- en: lib/python2.7/dist-packages (from voluptuous)
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: lib/python2.7/dist-packages（来自 voluptuous）
- en: 'Installing collected packages: voluptuous'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 安装已收集的包：voluptuous
- en: Running setup.py install for voluptuous
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 正在为 voluptuous 运行 setup.py install
- en: Successfully installed voluptuous
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 成功安装 voluptuous
- en: Cleaning up...
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 正在清理...
- en: By looking it up on the PyPI distribution index, where anyone can upload a package
    for distribution and installation by others, pip install can install any package.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 PyPI 分发索引中查找，任何人都可以上传包以供他人分发和安装，pip install 可以安装任何包。
- en: You can also provide a --user option that makes pip install the package in your
    home directory. This avoids polluting your operating system directories with packages
    installed system-wide.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以提供 --user 选项，使 pip 将包安装到您的主目录中。这可以避免将包安装到操作系统的系统范围目录中，避免污染系统目录。
- en: 'You can list the packages you already have installed using the pip freeze command,
    like so:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 pip freeze 命令列出已经安装的包，如下所示：
- en: $ pip freeze
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: $ pip freeze
- en: Babel==1.3
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Babel==1.3
- en: Jinja2==2.7.1
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Jinja2==2.7.1
- en: commando=0.3.4
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: commando=0.3.4
- en: --snip--
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: --snip--
- en: 'Uninstalling packages is also supported by pip, using the uninstall command:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: pip 还支持卸载包，使用 uninstall 命令：
- en: $ pip uninstall pika-pool
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: $ pip uninstall pika-pool
- en: 'Uninstalling pika-pool-0.1.3:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 正在卸载 pika-pool-0.1.3：
- en: /usr/local/lib/python2.7/site-packages/pika_pool-0.1.3.dist-info/
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: /usr/local/lib/python2.7/site-packages/pika_pool-0.1.3.dist-info/
- en: DESCRIPTION.rst
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: DESCRIPTION.rst
- en: /usr/local/lib/python2.7/site-packages/pika_pool-0.1.3.dist-info/INSTALLER
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: /usr/local/lib/python2.7/site-packages/pika_pool-0.1.3.dist-info/INSTALLER
- en: /usr/local/lib/python2.7/site-packages/pika_pool-0.1.3.dist-info/METADATA
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: /usr/local/lib/python2.7/site-packages/pika_pool-0.1.3.dist-info/METADATA
- en: --snip--
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: --snip--
- en: Proceed (y/n)? y
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 继续（y/n）？ y
- en: Successfully uninstalled pika-pool-0.1.3
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 成功卸载 pika-pool-0.1.3
- en: 'One very valuable feature of pip is its ability to install a package without
    copying the package’s file. The typical use case for this feature is when you’re
    actively working on a package and want to avoid the long and boring process of
    reinstalling it each time you need to test a change. This can be achieved by using
    the -e <directory> flag:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: pip 的一个非常有价值的功能是它能够安装包而不复制包的文件。这个功能的典型使用场景是，当你在积极开发一个包时，想避免每次需要测试更改时重新安装的漫长和乏味过程。通过使用
    -e <directory> 标志可以实现这一点：
- en: $ pip install -e .
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: $ pip install -e .
- en: Obtaining file:///Users/jd/Source/daiquiri
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 从 file:///Users/jd/Source/daiquiri 获取
- en: 'Installing collected packages: daiquiri'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 正在安装收集的包：daiquiri
- en: Running setup.py develop for daiquiri
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 正在为 daiquiri 运行 setup.py develop
- en: Successfully installed daiquiri
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 成功安装 daiquiri
- en: 'Here, pip does not copy the files from the local source directory but places
    a special file, called an egg-link, in your distribution path. For example:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，pip 不会将文件从本地源目录复制，而是将一个名为 egg-link 的特殊文件放置在您的分发路径中。例如：
- en: $ cat /usr/local/lib/python2.7/site-packages/daiquiri.egg-link
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: $ cat /usr/local/lib/python2.7/site-packages/daiquiri.egg-link
- en: /Users/jd/Source/daiquiri
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: /Users/jd/Source/daiquiri
- en: 'The egg-link file contains the path to add to sys.path to look for packages.
    The result can be easily checked by running the following command:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: egg-link 文件包含要添加到 sys.path 以查找包的路径。可以通过运行以下命令轻松检查结果：
- en: $ python -c "import sys; print('/Users/jd/Source/daiquiri' in sys.path)"
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: $ python -c "import sys; print('/Users/jd/Source/daiquiri' in sys.path)"
- en: 'True'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 'True'
- en: 'Another useful pip tool is the -e option of pip install, helpful for deploying
    code from repositories of various version control systems: git, Mercurial, Subversion,
    and even Bazaar are supported. For example, you can install any library directly
    from a git repository by passing its address as a URL after the -e option:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的 pip 工具是 pip install 的 -e 选项，它有助于从各种版本控制系统的仓库中部署代码：支持 git、Mercurial、Subversion，甚至
    Bazaar。例如，您可以直接从 git 仓库安装任何库，只需将其地址作为 URL 传递给 -e 选项：
- en: $ pip install -e git+https://github.com/jd/daiquiri.git\#egg=daiquiri
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: $ pip install -e git+https://github.com/jd/daiquiri.git\#egg=daiquiri
- en: Obtaining daiquiri from git+https://github.com/jd/daiquiri.git#egg=daiquiri
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 从 git+https://github.com/jd/daiquiri.git#egg=daiquiri 获取 daiquiri
- en: Cloning https://github.com/jd/daiquiri.git to ./src/daiquiri
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 克隆 https://github.com/jd/daiquiri.git 到 ./src/daiquiri
- en: 'Installing collected packages: daiquiri'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 正在安装收集的包：daiquiri
- en: Running setup.py develop for daiquiri
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 正在为 daiquiri 运行 setup.py develop
- en: Successfully installed daiquiri
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 成功安装 daiquiri
- en: 'For the installation to work correctly, you need to provide the package egg
    name by adding #egg= at the end of the URL. Then, pip just uses git clone to clone
    the repository inside a src/<eggname> and creates an egg-link file pointing to
    that same cloned directory.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '为了正确安装，您需要通过在 URL 末尾添加 #egg= 来提供包的 egg 名称。然后，pip 会使用 git clone 克隆仓库到 src/<eggname>
    目录，并创建一个指向该克隆目录的 egg-link 文件。'
- en: This mechanism is extremely handy when depending on unreleased versions of libraries
    or when working in a continuous testing system. However, since there is no versioning
    behind it, the -e option can also be very nasty. You cannot know in advance that
    the next commit in this remote repository is not going to break everything.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这种机制在依赖尚未发布的库版本或在持续测试系统中工作时非常方便。然而，由于它没有版本控制，-e 选项也可能非常糟糕。你无法提前知道该远程仓库中的下一个提交是否会破坏一切。
- en: Finally, all other installation tools are being deprecated in favor of pip,
    so you can confidently treat it as your one-stop shop for all your package management
    needs.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，所有其他安装工具都被弃用，转而推荐使用 pip，因此你可以放心地将其作为你所有包管理需求的一站式解决方案。
- en: '**Using and Choosing Frameworks**'
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用和选择框架**'
- en: 'Python has a variety of frameworks available for various kinds of Python applications:
    if you’re writing a web application, you could use Django, Pylons, TurboGears,
    Tornado, Zope, or Plone; if you’re looking for an event-driven framework, you
    could use Twisted or Circuits; and so on.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: Python 提供了各种框架，适用于各种 Python 应用程序：如果你正在编写一个 web 应用程序，可以选择 Django、Pylons、TurboGears、Tornado、Zope
    或 Plone；如果你需要一个事件驱动的框架，可以选择 Twisted 或 Circuits；等等。
- en: 'The main difference between frameworks and external libraries is that applications
    use frameworks by building on top of them: your code will extend the framework
    rather than vice versa. Unlike a library, which is basically an add-on you can
    bring in to give your code some extra oomph, a framework forms the *chassis* of
    your code: everything you do builds on that chassis in some way. This can be a
    double-edged sword. There are plenty of upsides to using frameworks, such as rapid
    prototyping and development, but there are also some noteworthy downsides, such
    as lock-in. You need to take these considerations into account when you decide
    whether to use a framework.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 框架和外部库的主要区别在于，应用程序是通过在框架之上构建来使用框架的：你的代码会扩展框架，而不是框架扩展你的代码。与库不同，库基本上是你可以引入的附加功能，用来为你的代码增加额外的功能，而框架则构成了你代码的*底盘*：你所做的每件事都在某种程度上依赖于这个底盘。这可能是把双刃剑。使用框架有很多优点，比如快速原型设计和开发，但也有一些值得注意的缺点，比如被框架束缚。你需要在决定是否使用框架时考虑到这些因素。
- en: The recommendations for what to check when choosing the right framework for
    your Python application are largely the same as those described in “[The External
    Libraries Safety Checklist](ch02.xhtml#lev2sec9)” on [page 23](ch02.xhtml#page_23)—which
    makes sense, as frameworks are distributed as bundles of Python libraries. Sometimes
    frameworks also include tools for creating, running, and deploying applications,
    but that doesn’t change the criteria you should apply. We’ve established that
    replacing an external library after you’ve already written code that makes use
    of it is a pain, but replacing a framework is a thousand times worse, usually
    requiring a complete rewrite of your program from the ground up.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 选择适合 Python 应用程序的框架时需要检查的推荐事项，基本与“[外部库安全检查表](ch02.xhtml#lev2sec9)”中描述的相同，见[第
    23 页](ch02.xhtml#page_23)—这也是合乎逻辑的，因为框架通常作为 Python 库的集合发布。有时框架还包含用于创建、运行和部署应用程序的工具，但这并不改变你应该应用的标准。我们已经确定，替换一个外部库在你已经写了依赖它的代码后会很麻烦，但替换框架则更加糟糕，通常需要从头开始完全重写程序。
- en: 'To give an example, the Twisted framework mentioned earlier still doesn’t have
    full Python 3 support: if you wrote a program using Twisted a few years back and
    wanted to update it to run on Python 3, you’d be out of luck. Either you’d have
    to rewrite your entire program to use a different framework, or you’d have to
    wait until someone finally gets around to upgrading Twisted with full Python 3
    support.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，前面提到的 Twisted 框架至今还没有完全支持 Python 3：如果你几年前使用 Twisted 编写了一个程序，并且希望将其更新为支持
    Python 3，你会遇到麻烦。要么你必须重写整个程序，换用另一个框架，要么你得等到有人最终为 Twisted 提供完全的 Python 3 支持。
- en: 'Some frameworks are lighter than others. For example, Django has its own built-in
    ORM functionality; Flask, on the other hand, has nothing of the sort. The *less*
    a framework tries to do for you, the fewer problems you’ll have with it in the
    future. However, each feature a framework lacks is another problem for you to
    solve, either by writing your own code or going through the hassle of handpicking
    another library to handle it. It’s your choice which scenario you’d rather deal
    with, but choose wisely: migrating away from a framework when things go sour can
    be a Herculean task, and even with all its other features, there’s nothing in
    Python that can help you with that.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 有些框架比其他框架更轻量。例如，Django 有自己的内置 ORM 功能；而 Flask 则没有类似的功能。框架为你做的事情越少，未来遇到的问题就越少。然而，框架缺少的每一个功能，都会变成你需要解决的另一个问题，要么自己编写代码，要么麻烦地挑选另一个库来处理。这完全取决于你愿意处理哪种情况，但要明智选择：当事情出现问题时，迁移离开一个框架可能是一个艰巨的任务，即使它有其他功能，Python
    也没有任何东西能帮你解决这个问题。
- en: '**Doug Hellmann, Python Core Developer, on Python Libraries**'
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Doug Hellmann，Python 核心开发者，谈 Python 库**'
- en: Doug Hellmann is a senior developer at DreamHost and a fellow contributor to
    the OpenStack project. He launched the website Python Module of the Week (*[http://www.pymotw.com/](http://www.pymotw.com/)*)
    and has written an excellent book called *The Python Standard Library by Example*.
    He is also a Python core developer. I’ve asked Doug a few questions about the
    Standard Library and designing libraries and applications around it.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: Doug Hellmann 是 DreamHost 的高级开发者，也是 OpenStack 项目的贡献者之一。他创建了网站 Python Module
    of the Week (*[http://www.pymotw.com/](http://www.pymotw.com/)*), 并且写了一本名为 *《Python
    标准库示例》* 的优秀书籍。他也是 Python 核心开发者。我向 Doug 提出了关于标准库以及围绕它设计库和应用程序的一些问题。
- en: '**When you start writing a Python application from scratch, what’s your first
    move?**'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '**当你从零开始编写一个 Python 应用程序时，你的第一步是什么？**'
- en: The steps for writing an application from scratch are similar to hacking an
    existing application, in the abstract, but the details change.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 从零开始编写应用程序的步骤在抽象层面上与破解现有应用程序类似，但细节有所不同。
- en: 'When I change existing code, I start by figuring out how it works and where
    my changes would need to go. I may use some debugging techniques: adding logging
    or print statements, or using pdb, and running the app with test data to make
    sure I understand what it’s doing. I usually make the change and test it by hand,
    then add any automated tests before contributing a patch.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 当我修改现有代码时，我通常会先弄清楚它是如何工作的，以及我的修改需要添加到哪里。我可能会使用一些调试技巧：添加日志或打印语句，或使用 pdb，然后用测试数据运行应用程序，确保我理解它的运行方式。我通常会先手动修改并测试，然后在提交补丁之前添加任何自动化测试。
- en: I take the same exploratory approach when I create a new application—create
    some code and run it by hand, and then once I have the basic functionality working,
    I write tests to make sure I’ve covered all of the edge cases. Creating the tests
    may also lead to some refactoring to make the code easier to work with.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 当我创建一个新应用程序时，我也采用相同的探索性方法——编写一些代码并手动运行，然后一旦基本功能正常工作，我会编写测试来确保涵盖所有边缘情况。创建测试的过程也可能导致一些重构，以便让代码更易于操作。
- en: That was definitely the case with smiley [a tool for spying on your Python programs
    and recording their activities]. I started by experimenting with Python’s trace
    API, using some throwaway scripts, before building the real application. Originally,
    I planned to have one piece to instrument and collect data from another running
    application, and another to collect the data sent over the network and save it.
    While adding a couple of reporting features, I realized that the processing for
    replaying the collected data was almost identical to the processing for collecting
    it in the first place. I refactored a few classes and was able to create a base
    class for the data collection, database access, and report generator. Making those
    classes conform to the same API allowed me to easily create a version of the data
    collection app that wrote directly to the database instead of sending information
    over the network.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这在 smiley [一个用于监控你的 Python 程序并记录其活动的工具] 中的确是这样的。我先通过 Python 的 trace API 进行实验，使用一些临时脚本，然后再构建真正的应用程序。最初，我计划有一个部分用于监控并收集另一个正在运行的应用程序的数据，另一个部分用于收集通过网络发送的数据并保存它。在添加了几个报告功能之后，我意识到重播收集到的数据的处理过程与最初收集数据的过程几乎相同。我重构了几个类，并成功创建了一个用于数据收集、数据库访问和报告生成器的基类。使这些类符合相同的
    API 允许我轻松创建一个将数据直接写入数据库而不是通过网络发送信息的数据收集应用版本。
- en: While designing an app, I think about how the user interface works, but for
    libraries, I focus on how a developer will use the API. It can also be easier
    to write the tests for programs that will use the new library first, then the
    library code. I usually create a series of example programs in the form of tests
    and then build the library to work that way.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计应用程序时，我会考虑用户界面的工作方式，但对于库，我更关注开发者如何使用 API。对于将要使用新库的程序，先编写测试可能更容易，然后再编写库代码。我通常会以测试的形式创建一系列示例程序，然后构建库以使其工作。
- en: I’ve also found that writing documentation for a library before writing any
    code helps me think through the features and workflows without committing to the
    implementation details, and it lets me record the choices I made in the design
    so the reader understands not just how to use the library but the expectations
    I had while creating it.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我还发现，在编写任何代码之前编写库的文档可以帮助我理清功能和工作流程，而不需要纠结于实现细节，并且它可以让我记录下我在设计时做出的选择，这样读者不仅能理解如何使用库，还能理解我在创建过程中所期望的。
- en: '**What’s the process for getting a module into the Python Standard Library?**'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '**将模块加入 Python 标准库的流程是什么？**'
- en: The full process and guidelines for submitting a module into the standard library
    can be found in the Python Developer’s Guide at *[https://docs.python.org/devguide/stdlibchanges.html](https://docs.python.org/devguide/stdlibchanges.html)*.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 提交模块到标准库的完整过程和指南可以在 Python 开发者指南中的 *[https://docs.python.org/devguide/stdlibchanges.html](https://docs.python.org/devguide/stdlibchanges.html)*
    找到。
- en: Before a module can be added, the submitter needs to prove that it’s stable
    and widely useful. The module should provide something that is either hard to
    implement correctly on your own or so useful that many developers have created
    their own variations. The API should be clear, and any module dependencies should
    be inside the Standard Library only.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块被添加之前，提交者需要证明它是稳定的且广泛有用的。该模块应该提供一些功能，这些功能要么是自己实现起来很难做到正确，要么是如此有用，以至于许多开发者已经创建了自己的变体。API
    应该清晰，且任何模块的依赖应该仅限于标准库内部。
- en: The first step would be to run the idea of introducing the module into the standard
    library by the community via the *python-ideas* list to informally gauge the level
    of interest. Assuming the response is positive, the next step is to create a Python
    Enhancement Proposal (PEP), which should include the motivation for adding the
    module and implementation details of how the transition will happen.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是通过 *python-ideas* 邮件列表将引入模块到标准库的想法提交给社区，非正式地评估兴趣的程度。如果反馈是积极的，下一步是创建一个 Python
    增强提案（PEP），其中应包括添加该模块的动机和过渡的实现细节。
- en: Because package management and discovery tools have become so reliable, especially
    pip and the PyPI, it may be more practical to maintain a new library outside of
    the Python Standard Library. A separate release allows for more frequent updates
    with new features and bug fixes, which can be especially important for libraries
    addressing new technologies or APIs.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 由于包管理和发现工具变得如此可靠，特别是 pip 和 PyPI，可能更实际的做法是将一个新的库保持在 Python 标准库之外。单独发布允许更频繁地更新新功能和修复bug，这对于处理新技术或
    API 的库尤其重要。
- en: '**What are the top three modules from the Standard Library that you wish people
    knew more about?**'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '**你希望人们更多了解标准库中的三个最重要模块是什么？**'
- en: One really useful tool from the Standard Library is the abc module. I use the
    abc module to define the APIs for dynamically loaded extensions as abstract base
    classes, to help extension authors understand which methods of the API are required
    and which are optional. Abstract base classes are built into some other OOP [object-oriented
    programming] languages, but I’ve found a lot of Python programmers don’t know
    we have them as well.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库中有一个非常有用的工具是 abc 模块。我使用 abc 模块来将动态加载的扩展的 API 定义为抽象基类，以帮助扩展的作者理解哪些方法是必需的，哪些是可选的。抽象基类在一些其他面向对象编程（OOP）语言中是内置的，但我发现许多
    Python 程序员并不知道我们也有它们。
- en: The binary search algorithm in the bisect module is a good example of a useful
    feature that’s often implemented incorrectly, which makes it a great fit for the
    Standard Library. I especially like the fact that it can search sparse lists where
    the search value may not be included in the data.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: bisect 模块中的二分查找算法是一个很好的示例，它是一个有用的功能，但经常被错误地实现，因此非常适合放在标准库中。我尤其喜欢它能够搜索稀疏的列表，在这些列表中搜索值可能并不包含在数据中。
- en: There are some useful data structures in the collections module that aren’t
    used as often as they could be. I like to use namedtuple for creating small, class-like
    data structures that need to hold data without any associated logic. It’s very
    easy to convert from a namedtuple to a regular class if logic does need to be
    added later, since namedtuple supports accessing attributes by name. Another interesting
    data structure from the module is ChainMap, which makes a good stackable namespace.
    ChainMap can be used to create contexts for rendering templates or managing configuration
    settings from different sources with clearly defined precedence.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: collections 模块中有一些有用的数据结构，但它们的使用频率并不像它们应有的那样高。我喜欢使用 namedtuple 来创建小型、类似类的数据结构，这些结构只需要存储数据，而没有关联的逻辑。如果以后需要添加逻辑，从
    namedtuple 转换为普通类是非常容易的，因为 namedtuple 支持按名称访问属性。这个模块中的另一个有趣的数据结构是 ChainMap，它是一个很好的可堆叠命名空间。ChainMap
    可以用于创建渲染模板的上下文，或者管理来自不同来源并具有明确优先级的配置设置。
- en: '**A lot of projects, including OpenStack and external libraries, roll their
    own abstractions on top of the Standard Library, like for date/time handling,
    for example. In your opinion, should programmers stick to the Standard Library,
    roll their own functions, switch to some external library, or start sending patches
    to Python?**'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '**许多项目，包括 OpenStack 和外部库，都会在标准库之上构建自己的抽象层，比如日期/时间处理。你认为程序员应该坚持使用标准库，自己编写函数，切换到某个外部库，还是开始为
    Python 提交补丁？**'
- en: All of the above! I prefer to avoid reinventing the wheel, so I advocate strongly
    for contributing fixes and enhancements upstream to projects that can be used
    as dependencies. On the other hand, sometimes it makes sense to create another
    abstraction and maintain that code separately, either within an application or
    as a new library.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 以上所有方法！我倾向于避免重复造轮子，因此我强烈主张为可以作为依赖使用的项目贡献修复和增强功能。另一方面，有时创建另一个抽象层并单独维护这段代码是有意义的，可以在应用程序内部或作为一个新的库来实现。
- en: The timeutils module, used in your example, is a fairly thin wrapper around
    Python’s datetime module. Most of the functions are short and simple, but creating
    a module with the most common operations ensures they’re handled consistently
    throughout all projects. Because a lot of the functions are application specific,
    in the sense that they enforce decisions about things like timestamp format strings
    or what “now” means, they are not good candidates for patches to Python’s library
    or to be released as a general purpose library and adopted by other projects.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的示例中使用的 timeutils 模块，实际上是对 Python datetime 模块的一个相对简洁的封装。大多数函数都很短小简单，但创建一个包含最常用操作的模块，可以确保它们在所有项目中始终如一地处理。因为许多函数具有应用特定性，例如强制决定时间戳格式字符串或“当前时间”的定义，它们并不适合作为
    Python 库的补丁或作为通用库发布供其他项目使用。
- en: In contrast, I have been working to move the API services in OpenStack away
    from the WSGI [Web Server Gateway Interface] framework created in the early days
    of the project and onto a third-party web development framework. There are a lot
    of options for creating WSGI applications in Python, and while we may need to
    enhance one to make it completely suitable for OpenStack’s API servers, contributing
    those reusable changes upstream is preferable to maintaining a “private” framework.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我一直在努力将 OpenStack 中的 API 服务从项目早期创建的 WSGI [Web Server Gateway Interface] 框架迁移到第三方
    Web 开发框架。Python 中有很多用于创建 WSGI 应用程序的选择，尽管我们可能需要对其中一个进行增强，以使其完全适用于 OpenStack 的 API
    服务器，但将这些可复用的改动提交给上游项目总比维护一个“私有”框架要好。
- en: '**What would your advice be to developers hesitating between major Python versions?**'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '**对于犹豫不决的开发者，您有什么建议，特别是在选择 Python 主要版本时？**'
- en: The number of third-party libraries supporting Python 3 has reached critical
    mass. It’s easier than ever to build new libraries and applications for Python
    3, and thanks to the compatibility features added to 3.3, maintaining support
    for Python 2.7 is also easier. The major Linux distributions are working on shipping
    releases with Python 3 installed by default. Anyone starting a new project in
    Python should look seriously at Python 3, unless they have a dependency that hasn’t
    been ported. At this point, though, libraries that don’t run on Python 3 could
    almost be classified as “unmaintained.”
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 支持 Python 3 的第三方库数量已经达到了临界点。现在比以往任何时候都更容易为 Python 3 构建新库和应用程序，得益于 3.3 版本新增的兼容性功能，维护对
    Python 2.7 的支持也变得更加容易。主要的 Linux 发行版正在致力于默认安装 Python 3 的发布版本。任何开始新项目的人都应该认真考虑使用
    Python 3，除非他们依赖的库尚未移植到该版本。不过，到目前为止，不支持 Python 3 的库几乎可以被视为“未维护”。
- en: '**What are the best ways to branch code out from an application into a library
    in terms of design, planning ahead, migration, etc.?**'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '**在设计、规划、迁移等方面，将代码从应用程序分支到库的最佳方式是什么？**'
- en: Applications are collections of “glue code” holding libraries together for a
    specific purpose. Designing your application with the features to achieve that
    purpose as a library first and then building the application ensures that code
    is properly organized into logical units, which in turn makes testing simpler.
    It also means the features of an application are accessible through the library
    and can be remixed to create other applications. If you don’t take this approach,
    you risk the features of the application being tightly bound to the user interface,
    which makes them harder to modify and reuse.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序是将库为特定目的结合在一起的“胶水代码”集合。首先将应用程序设计为一个实现该目的的库，再构建应用程序，能确保代码被正确地组织成逻辑单元，从而简化测试。这还意味着应用程序的功能通过库可以访问，并且可以重新组合以创建其他应用程序。如果你不采用这种方法，应用程序的功能可能会与用户界面紧密绑定，这使得它们更难修改和重用。
- en: '**What advice would you give to people planning to design their own Python
    libraries?**'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '**对于计划设计自己 Python 库的人，您有什么建议？**'
- en: I always recommend designing libraries and APIs from the top down, applying
    design criteria such as the Single Responsibility Principle (SRP) at each layer.
    Think about what the caller will want to do with the library and create an API
    that supports those features. Think about what values can be stored in an instance
    and used by the methods versus what needs to be passed to each method every time.
    Finally, think about the implementation and whether the underlying code should
    be organized differently than the code of the public API.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我总是推荐从上到下设计库和 API，在每一层应用设计准则，如单一职责原则（SRP）。考虑调用者希望如何使用库，并创建支持这些功能的 API。思考哪些值可以存储在实例中并被方法使用，而不需要每次都传递给每个方法。最后，思考实现方式，以及底层代码是否应该与公共
    API 的代码有所不同。
- en: SQLAlchemy is an excellent example of applying those guidelines. The declarative
    ORM [object relational mapping], data mapping, and expression generation layers
    are all separate. A developer can decide the right level of abstraction for entering
    the API and using the library based on their needs rather than constraints imposed
    by the library’s design.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 是应用这些指南的一个优秀例子。声明式 ORM（对象关系映射）、数据映射和表达式生成层都是分开的。开发人员可以根据自己的需求决定进入
    API 和使用库的合适抽象层次，而不是受限于库设计所强加的限制。
- en: '**What are the most common programming errors you encounter while reading Python
    developers’ code?**'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '**在阅读 Python 开发者的代码时，你遇到的最常见编程错误是什么？**'
- en: One area where Python’s idioms are significantly different from other languages
    is in looping and iteration. For example, one of the most common anti-patterns
    I see is the use of a for loop to filter a list by first appending items to a
    new list and then processing the result in a second loop (possibly after passing
    the list as an argument to a function). I almost always suggest converting filtering
    loops like these into generator expressions, which are more efficient and easier
    to understand. It’s also common to see lists being combined so their contents
    can be processed together in some way, rather than using itertools.chain().
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的习惯用法与其他语言在循环和迭代方面有显著的不同。例如，我常看到的一个反模式是使用 `for` 循环来过滤列表，方法是先将项目附加到一个新列表，然后在第二个循环中处理结果（可能是在将列表作为参数传递给函数之后）。我几乎总是建议将这种过滤循环转换为生成器表达式，这样既更高效，又更易于理解。还常见到将多个列表合并，以便以某种方式处理它们的内容，而不是使用
    `itertools.chain()`。
- en: There are other, more subtle things I often suggest in code reviews, like using
    a dict() as a lookup table instead of a long if:then:else block, making sure functions
    always return the same type of object (for example, an empty list instead of None),
    reducing the number of arguments a function requires by combining related values
    into an object with either a tuple or a new class, and defining classes to use
    in public APIs instead of relying on dictionaries.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码审查中，我经常建议一些更细微的事项，比如使用 `dict()` 作为查找表，而不是一个冗长的 if:then:else 块，确保函数总是返回相同类型的对象（例如，返回一个空列表而不是
    None），通过将相关的值组合成元组或新类来减少函数所需的参数数量，以及在公共 API 中定义类而不是依赖字典。
- en: '**What’s your take on frameworks?**'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '**你对框架有什么看法？**'
- en: Frameworks are like any other kind of tool. They can help, but you need to take
    care when choosing one to make sure that it’s right for the job at hand.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 框架就像其他任何工具一样。它们能提供帮助，但在选择时需要小心，以确保它适合手头的工作。
- en: Pulling out the common parts of your app into a framework helps you focus your
    development efforts on the unique aspects of an application. Frameworks also provide
    a lot of bootstrapping code, for doing things like running in development mode
    and writing a test suite, that helps you bring an application to a useful state
    more quickly. They also encourage consistency in the implementation of the application,
    which means you end up with code that is easier to understand and more reusable.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序的共同部分提取到框架中，可以帮助你将开发工作集中在应用程序的独特方面。框架还提供了大量的启动代码，用于执行诸如在开发模式下运行和编写测试套件等任务，帮助你更快地将应用程序带到有用的状态。它们还鼓励应用程序实现的一致性，这意味着你最终得到的代码更容易理解且更具可重用性。
- en: There are some potential pitfalls too, though. The decision to use a particular
    framework usually implies something about the design of the application itself.
    Selecting the wrong framework can make an application harder to implement if those
    design constraints do not align naturally with the application’s requirements.
    You may end up fighting with the framework if you try to use patterns or idioms
    that differ from what it recommends.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，也存在一些潜在的陷阱。选择使用特定框架通常意味着对应用程序设计的某些假设。选择错误的框架可能会使应用程序的实现更加困难，尤其是当这些设计约束与应用程序的需求不自然契合时。如果你尝试使用与框架推荐的模式或习惯不同的方式，可能会和框架产生冲突。
