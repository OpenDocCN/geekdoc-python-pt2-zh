- en: '6'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: DESIGNING PROGRAMS WITH FUNCTIONS
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When writing large programs, it’s important to organize our code into smaller
    logical pieces, each of which contributes to the overall goal. That way, we’ll
    be able to think about each piece on its own, without worrying about what other
    pieces are doing. Then we’ll put the pieces together. These pieces are called
    *functions*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll use functions to break down and solve two problems:
    calculating the score in a two-player card game and determining whether boxes
    of action figures can be nicely organized.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem #14: Card Game'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this problem, we’ll implement a two-player card game. As part of thinking
    through the problem, we’ll find that the same bit of logic crops up several times.
    We’ll learn how to bundle this code into a Python function to avoid code duplication
    and enhance code clarity.
  prefs: []
  type: TYPE_NORMAL
- en: This is DMOJ problem `ccc99s1`.
  prefs: []
  type: TYPE_NORMAL
- en: The Challenge
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Two players, A and B, are playing a card game. (You don’t need to know about
    playing cards or card games to understand this problem.)
  prefs: []
  type: TYPE_NORMAL
- en: The game starts with a deck of 52 cards. Player A takes a card from the deck,
    then player B takes a card from the deck, then player A, then player B, until
    there are no cards left in the deck.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are 13 types of cards in the deck. These types are as follows: two, three,
    four, five, six, seven, eight, nine, ten, jack, queen, king, ace. There are four
    cards of each of these types in the deck. For example, there are four twos, four
    threes, and so on, all the way up to four aces. (That’s why there are 52 cards
    in the deck: 13 types times 4 cards per type.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'A *high card* is a card that is a jack, queen, king, or ace. When a player
    takes a high card, they may score some points. Here are the rules by which points
    are scored:'
  prefs: []
  type: TYPE_NORMAL
- en: If a player takes a jack, after which there is at least one card remaining in
    the deck, and the next card in the deck is not a high card, then the player scores
    1 point.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a player takes a queen, after which there are at least two cards remaining
    in the deck, and neither of the next two cards in the deck is a high card, then
    the player scores 2 points.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a player takes a king, after which there are at least three cards remaining
    in the deck, and none of the next three cards in the deck is a high card, then
    the player scores 3 points.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a player takes an ace, after which there are at least four cards remaining
    in the deck, and none of the next four cards in the deck is a high card, then
    the player scores 4 points.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’re asked to output information each time a player scores, as well as the
    total score for each player at the end of the game.
  prefs: []
  type: TYPE_NORMAL
- en: Input
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The input consists of 52 lines. Each line contains the type of a card in the
    deck. The lines are in the order that cards will be taken from the deck; that
    is, the first line is the first card taken from the deck, the second line is the
    second card taken, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Output
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Whenever a player scores, output the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: where p is `A` for player A or `B` for player B, and q is the number of points
    that they just scored.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the game ends, output the following two lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: where m is the total score for player A and n is the total score for player
    B.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring a Test Case
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you think through how to solve this problem, you might be left wondering
    whether we can just solve it, right now, without learning anything new. Indeed,
    we can! We’re in great shape. We can use a list to represent the deck of cards.
    We know how to use the list `append` method to add a card to the deck. We can
    access values in the list to look for high cards. We’ve even got f-strings to
    help us output the player and points information.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than dive in, though, let’s go through a small example. Doing so is going
    to highlight that we’re missing one crucial feature of Python that will make it
    easier to organize our solution and solve this problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll be here all year if we go through a 52-card example, so let’s use a smaller
    one with just 10 cards. This isn’t a complete test case, so the program we write
    won’t work on it, but it’s enough for us to understand the mechanics of the game
    and what our solution will have to do. Here’s the test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Player A takes the first card, which is a queen. A queen is a high card, and
    player A might score 2 points here. First, we confirm that there are at least
    two cards remaining in the deck after this queen. Next, we have to check these
    next two cards, hoping there is no high card among them. The next two cards are
    not high cards—they are a three and a seven—so player A gets 2 points.
  prefs: []
  type: TYPE_NORMAL
- en: Player B now takes the second card, which is a three. Three isn’t a high card,
    so no points for player B.
  prefs: []
  type: TYPE_NORMAL
- en: Player A now takes the seven. No points.
  prefs: []
  type: TYPE_NORMAL
- en: Player B now takes the king, so there’s a chance for 3 points for player B.
    There are at least three cards remaining in the deck after this king. We have
    to check these next three cards, hoping there is no high card among them. Sadly,
    there is a high card, a jack, among those three. No points for player B.
  prefs: []
  type: TYPE_NORMAL
- en: Player A now takes the nine. No points.
  prefs: []
  type: TYPE_NORMAL
- en: 'Player B now takes the first jack. There is at least one card remaining in
    the deck after this jack. We have to check this next card, hoping it isn’t a high
    card. Good news: it’s not a high card—it’s an eight—so player B gets 1 point.'
  prefs: []
  type: TYPE_NORMAL
- en: There’s only one more point scored, and it’s by player A when they take the
    second-last card (the jack) from the deck.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, this is the output for this test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that each time a player takes a high card, we need to check two things:
    that there are at least a certain number of cards remaining in the deck and that
    there is no high card among these cards. The first we should be able to manage
    by using a variable that tells us how many cards have been taken. The second is
    more difficult. We’d need some code to check a given number of cards for a high
    card. Worse, if we’re not careful, we’d end up duplicating very similar code four
    times: once to check the card after a jack, once to check the two cards after
    a queen, once to check the three cards after a king, and once to check the four
    cards after an ace. If we later found a flaw in our logic, we would have to fix
    it in up to four different places.'
  prefs: []
  type: TYPE_NORMAL
- en: Is there a Python feature that lets us package that “no high cards here” logic,
    just once, and invoke it four times? There is. It’s called a *function*, and it’s
    just a named block of code that carries out a small task. Functions are essential
    to the organization and clarity of our code. All programmers use them. Without
    them, writing large software systems like games and word processors would be untenable.
    Let’s learn how to use functions.
  prefs: []
  type: TYPE_NORMAL
- en: Defining and Calling Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ve already learned how to call functions that come with Python. For example,
    we’ve used the `input` function to read input. Here’s a call of `input` with no
    arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ve also used Python’s `print` function to output text. Here’s a call of
    `print` with one argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The built-in Python functions are general-purpose, designed to be used in a
    wide variety of settings. When we want a function to solve a problem-specific
    task, we’ll have to define it ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: Functions Without Arguments
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To *define*, or create, a function, we use Python’s `def` keyword. Here’s the
    definition of a function that outputs three lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The structure of a function definition mirrors that of an `if` statement or
    loop. The name after `def` is the name of the function that we’re defining; here,
    we’re defining a function named `intro`. Following the name of the function, we
    have a pair of empty parentheses, `()`. We’ll see later that we can include information
    in these parentheses to pass arguments to functions. This `intro` function doesn’t
    take any arguments, which is why the parentheses are empty. Following the parentheses
    is a colon; as with `if` statements or loops, leaving out the colon is a syntax
    error. On the following lines, we provide an indented block of statements that
    will run each time the function is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you defined the `intro` function, you may have expected to see this as
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'But no: so far we’ve only defined the function, not called it. Defining a function
    has no observable effect; it simply stores the function in the computer’s memory
    so we can call it later. We call our own functions just like we call any of Python’s
    built-in functions. Since this `intro` function doesn’t take any arguments, we
    use an empty set of parentheses in the call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You can call this function as many times as you like. It’s there as often as
    we need it.
  prefs: []
  type: TYPE_NORMAL
- en: Functions with Arguments
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Our `intro` function isn’t very flexible, as it does the same thing each time
    it’s called. We can change the function so that we can pass arguments to it, and
    the arguments we pass can influence what the function does. Here’s a new version
    of the `intro` function that allows us to pass a single argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To call this function, we provide a string argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We can’t call this `intro2` function without an argument—if we try, we get
    an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The error reminds us that we have not provided an argument for `message`. The
    name `message` is known as a function *parameter*. When we call `intro2`, Python
    first makes `message` refer to whatever our argument refers to; that is, `message`
    becomes an alias for our argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create functions with more than one parameter. Here’s a function that
    takes two parameters, a message to print and the number of times to print it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'To call this one, we provide two arguments. Python works from left to right,
    assigning the first argument to the first parameter and the second argument to
    the second parameter. In the following call, `''high''` is assigned to the `message`
    parameter and `5` is assigned to the `num_times` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Be sure to provide the correct number of arguments. For `intro3`, we need two
    arguments. Anything else is an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We also have to be sure to provide values of the proper types. Wrong types
    won’t stop us from calling the function, but they will cause an error within the
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This `TypeError` arises because `intro3` uses a range `for` loop on variable
    `num_times`. If the argument we provide for `num_times` is not an integer, the
    range `for` loop fails.
  prefs: []
  type: TYPE_NORMAL
- en: Keyword Arguments
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'It’s possible to override the left-to-right correspondence between arguments
    and parameters when calling a function. To do that, we use the names of parameters
    in whatever order we like. An argument that uses the name of a parameter is called
    a *keyword argument*. Here’s how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Each function call here uses two keyword arguments. A keyword argument is written
    as the name of a parameter, an equal sign, and its corresponding argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even start with regular arguments and finish with keyword arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'But once you use a keyword argument, you can’t go back to regular ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In “Sorting a List” in [Chapter 5](ch05.xhtml#ch05) we used a `reverse` keyword
    argument when calling the `sort` method. The Python designers decided that `reverse`
    would be a keyword-only parameter, which means that it’s impossible to fill in
    its value without using a keyword argument. Python lets us do that with our functions,
    too, but we won’t need that level of control in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Local Variables
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Names of parameters work like regular variables, but are *local* to the function
    in which they’re defined. That is, a function parameter doesn’t exist outside
    of its function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'What about that `line_length` variable—is it local, too? It is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'What happens if you have a variable and you call a function that uses a parameter
    or local variable of the same name? Is your value lost? Let’s see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Phew—it’s still `999`, just as we left it. Local variables are created when
    a function is called and destroyed when the function terminates, all without affecting
    other variables with shared names.
  prefs: []
  type: TYPE_NORMAL
- en: A function can access a variable that was created outside of that function.
    It’s ill-advised to rely on that, though, because then that function isn’t self-contained,
    instead hoping that variables it expects to be there are actually there. In this
    book, we’ll write functions so that they only use local variables. All information
    that a function needs will be provided to the function through its parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Mutable Parameters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since a parameter is an alias for its corresponding argument, it can be used
    to change a mutable value. Here’s a function that removes all occurrences of `value`
    from a list `lst`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we passed a list to `remove_all` by using a variable. This function
    won’t accomplish anything useful if you call it with a list value directly (rather
    than with a variable referring to a list):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The function removed all the 5s from the list, but because we didn’t use a variable,
    we have no way to refer to that list ever again.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONCEPT CHECK**'
  prefs: []
  type: TYPE_NORMAL
- en: What is the output of the following code?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: A. `a [1]`
  prefs: []
  type: TYPE_NORMAL
- en: B. `a [1, 2]`
  prefs: []
  type: TYPE_NORMAL
- en: C. `A [1]`
  prefs: []
  type: TYPE_NORMAL
- en: D. `A [1, 2]`
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer: A. When `mystery` is called, its `s` parameter is made to reference
    whatever the `s` argument refers to, which is the `''a''` string. Similarly, its
    `lst` parameter is made to reference whatever the `lst` argument refers to, which
    is the `[1]` list. Inside of `mystery`, `s` and `lst` are local variables.'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s study the two statements of the function itself.
  prefs: []
  type: TYPE_NORMAL
- en: First, `s = s.upper()`. This makes the local variable `s` refer to `'A'` (uppercase).
    But it hasn’t changed what `s` refers to outside of the function. That still refers
    to `'a'` (lowercase).
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, `lst = lst + [2]`. Using `+` with lists creates a new list (it doesn’t
    change an existing list!), so this makes the local variable `lst` refer to the
    new list: `[1, 2]`. But, again, it hasn’t changed what `lst` refers to outside
    of the function; it’s still `[1]`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'What gives—didn’t I tell you previously that functions can change a mutable
    parameter? I did; but to make that happen, you really do need to change the value
    itself, not what a local variable refers to. Compare the previous program with
    the next one, whose output is different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Return Values
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s come back to our Card Game problem. Our goal is to define a function
    that tells us whether there are no high cards in a list of cards. We’ll name that
    function `no_high`. We haven’t written `no_high` yet, but we can still specify
    what we hope to accomplish. Here’s what we’re after:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We want the first two calls to return `True`, because there are no high cards
    in those lists of cards. And we want the third and fourth calls to return `False`,
    because there’s at least one high card in those lists of cards.
  prefs: []
  type: TYPE_NORMAL
- en: How can we define a function that returns these `True` and `False` values? That’s
    the final piece of the function puzzle.
  prefs: []
  type: TYPE_NORMAL
- en: To return a value from a function, we use Python’s `return` keyword. As soon
    as a `return` is reached, execution of the function terminates, and the specified
    value is returned to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how we can write the `no_high` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We first check whether there are any `'jack'` cards in the list. If there are,
    then we know that the list contains one or more high cards, so we immediately
    return `False`.
  prefs: []
  type: TYPE_NORMAL
- en: If we’re still here, then we know that there are no jacks. But there could be
    other high cards, so we need to check for them. The rest of the `if` statements
    check for queens, kings, and aces, respectively, returning `False` if any of them
    is in the list.
  prefs: []
  type: TYPE_NORMAL
- en: If we don’t hit any of those four `return` statements, then there are no high
    cards in the list. In that case, we return `True`.
  prefs: []
  type: TYPE_NORMAL
- en: A `return` by itself, with no value given, returns the value `None`. That’s
    useful if you’re writing a function that doesn’t return anything useful and you
    need to terminate the function before reaching the bottom of its code.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a `return` is encountered inside a loop, the function still terminates immediately,
    regardless of how deeply nested it is. Here’s an example showing a `return` getting
    us out of a nested loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'A `return` is like a super-`break`! Some people don’t like using `return` from
    within a loop for the same reason that they don’t like `break`: it can obscure
    the purpose and logic of a loop. I’ll use `return` within a loop when convenient.
    Unlike `break`, which can show up anywhere, a `return` is restricted to showing
    up within a function, separated from other code. If we keep our functions small,
    then using a `return` within a loop can help us write clear code without interfering
    with the code around it.'
  prefs: []
  type: TYPE_NORMAL
- en: '**CONCEPT CHECK**'
  prefs: []
  type: TYPE_NORMAL
- en: Is the following version of `no_high` correct? That is, does it return `True`
    if there is at least one high card in the list, and `False` otherwise?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: A. Yes
  prefs: []
  type: TYPE_NORMAL
- en: B. No; for example, it returns the wrong value for `['two', 'three']`
  prefs: []
  type: TYPE_NORMAL
- en: C. No; for example, it returns the wrong value for `['jack']`
  prefs: []
  type: TYPE_NORMAL
- en: D. No; for example, it returns the wrong value for `['jack', 'two']`
  prefs: []
  type: TYPE_NORMAL
- en: E. No; for example, it returns the wrong value for `['two', 'jack']`
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer: E. The `if-else` statement causes the loop to always terminate on its
    first iteration. If the first card is a high card, the function terminates and
    returns `False`; if the first card is not a high card, the function terminates
    and returns `True`. It doesn’t look at any of the other cards! And that’s why
    it fails on `[''two'', ''jack'']`: the first card is not a high card, so the function
    returns `True`. Returning `True` tells us that there are no high cards in the
    list. But that’s wrong: there’s a jack in there! The function did the wrong thing.
    It should have returned `False`.'
  prefs: []
  type: TYPE_NORMAL
- en: Function Documentation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s clear to us right now what our `no_high` function does and how we should
    call it. But what about in a few months, when the purpose of our old code doesn’t
    come readily to mind? And what about once we’ve amassed a large collection of
    our own functions, making it difficult to remember what each one does?
  prefs: []
  type: TYPE_NORMAL
- en: 'For each function we write, we’ll add documentation that specifies the meaning
    of each parameter and what the function returns. Such documentation is called
    a *docstring*, for “documentation string.” The docstring should be written starting
    at the first line of the function’s block. Here’s the `no_high` function, this
    time with documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The docstring begins and ends with three double quotes (`"""`). Like a single
    quote (`'`) or double quote (`"`), three double quotes can be used to start and
    end any string. A string created with three quotes is called a *triple-quoted
    string*. (Three single quotes work as well, but Python convention is to use three
    double quotes.) They have the bonus of letting us add multiple lines of text to
    the string by just pressing ENTER after each line; strings created with `'` or
    `"` can’t span lines like that. We use triple-quoted strings for docstrings so
    that we can include as many lines as we like.
  prefs: []
  type: TYPE_NORMAL
- en: 'The docstring here tells us what `lst` is: it’s a list of strings representing
    cards. It also tells us that the function returns a `True` or `False` value and
    what each return value means. This is sufficient information to enable someone
    to call the function without having to look at its code. As long as someone knows
    what a function does, they can just use it. We’ve been using Python functions
    all along without ever having looked at their code. How does `print` work? How
    does `input` work? We don’t know! But it doesn’t matter: we know what the functions
    do, so we can just focus on calling them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For functions with multiple parameters, the docstring should name each one
    and give its expected type. Here’s `remove_all`, from “Mutable Parameters” in
    this chapter, with a suitable docstring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Notice that this docstring doesn’t talk about returning anything. That’s because
    this function doesn’t return anything useful! It removes from `lst`, which is
    what the docstring says it does.
  prefs: []
  type: TYPE_NORMAL
- en: Solving the Problem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ve just learned the fundamentals of defining and calling functions. For the
    rest of the book, whenever we’re faced with a large problem to solve, we’ll be
    able to break down its solution into smaller tasks, each of which will be solved
    by a function.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s use our `no_high` function in a solution to Card Game. The code is in
    [Listing 6-1](ch06.xhtml#ch06ex01).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-1: Solving Card Game*'
  prefs: []
  type: TYPE_NORMAL
- en: I’ve introduced the constant `NUM_CARDS` to refer to `52` ❶. We’ll use it a
    couple of times in the code, and it’s easier to remember what `NUM_CARDS` means
    than what `52` means.
  prefs: []
  type: TYPE_NORMAL
- en: Next we define the `no_high` function, including docstring, that we’ve discussed
    in depth ❷. We’ll always put our functions near the top of our programs. This
    way, the functions are available to be called by any code that follows them.
  prefs: []
  type: TYPE_NORMAL
- en: The main part of the program starts with creating a list that will hold the
    cards in the deck ❸. We then read the cards from the input ❹, appending each to
    the deck. You’ll notice that cards are never literally removed or taken from the
    deck (the deck remains as is throughout program execution). We could have done
    it that way. Instead, I’ve chosen to track where we are in the deck so that we
    know which card would be removed next.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three other crucial variables that we maintain: `score_a`, the current
    total score for player A; `score_b`, the current total score for player B; and
    `player`, the name of the current player.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our next task is to look at each card in the deck to give points to the players.
    A regular `for` loop would let us look at the current card. But that’s not enough:
    if the current card is a high card, then we have to be able to look at later cards
    as well. To facilitate that, we use a range `for` loop ❺.'
  prefs: []
  type: TYPE_NORMAL
- en: On each iteration of this loop, we determine the number of points awarded to
    the current player based on the card that they take from the deck. Each rule for
    getting points depends on the deck having some number of remaining cards. The
    `remaining` variable ❻ tells us the number of remaining cards. When `i` is `0`,
    the number of remaining cards is `51`, because we’ve just taken the first card.
    When `i` is `1`, the number of remaining cards is `50`, because we’ve just taken
    the second card. In general, the expression for the number of remaining cards
    is the total number of cards, minus `i`, minus `1`.
  prefs: []
  type: TYPE_NORMAL
- en: And now we have four tests, one for each way to score points ❼. Each one checks
    the current card and the number of cards remaining. If both of those conditions
    are `True`, then a call is made to our `no_high` function with a slice of the
    deck containing the appropriate number of cards. For example, if the current card
    is a `'jack'` and there is at least `1` card remaining, then we pass a list of
    length `1` to `no_high` ❼. If `no_high` returns `True`, then there are no high
    cards in the slice of the list, so the current player gets points. The `points`
    variable determines the number of points that will be awarded; it starts at `0`
    on each iteration of the loop and is set to `1`, `2`, `3`, or `4` as appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: If the player scored points ❽, then we output a message indicating the player
    who scored points and the number of points they scored.
  prefs: []
  type: TYPE_NORMAL
- en: All that’s left for the current iteration is to add the points to the current
    player’s score and make it the other player’s turn. We accomplish both of these
    tasks with an `if-else` statement ❾. (If `points` is `0` on this iteration, then
    a harmless `0` is added to a player’s score. There’s no reason to explicitly test
    for and avoid that.)
  prefs: []
  type: TYPE_NORMAL
- en: The final two `print` calls output the total points for each player.
  prefs: []
  type: TYPE_NORMAL
- en: 'There we go: a solution to the problem that uses a function to organize our
    code and make it easier to read. Feel free to submit our code to the judge, and
    you should see that all test cases pass.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem #15: Action Figures'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To solve Card Game, we first went through an example, and that example highlighted
    where a function might be useful. Now, we’ll solve another problem using functions,
    but we’ll discover the needed functions using a more systematic approach.
  prefs: []
  type: TYPE_NORMAL
- en: This is Timus problem `2144`. This is the only problem in the book from the
    Timus judge. To find the problem, go to *[https://acm.timus.ru/](https://acm.timus.ru/)*,
    click **Problem set**, click **Volume 12**, and find problem 2144 (it’s called
    Cleaning the Room on the judge).
  prefs: []
  type: TYPE_NORMAL
- en: The Challenge
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Lena has *n* unopened boxes of action figures. The boxes cannot be opened (otherwise
    the action figures lose their value), so the order of action figures in a box
    cannot be changed. Further, a box cannot be rotated (otherwise the action figures
    will be facing the wrong way).
  prefs: []
  type: TYPE_NORMAL
- en: Each action figure is specified by its height. For example, one of the boxes
    might have three action figures, from left to right, of heights 4, 5, and 7\.
    When I talk about a box of action figures, I’ll always list the heights from left
    to right.
  prefs: []
  type: TYPE_NORMAL
- en: Lena wants to *organize the boxes*, which means to arrange the boxes so that
    heights of action figures increase or stay the same from left to right.
  prefs: []
  type: TYPE_NORMAL
- en: Whether she can organize the boxes or not depends on the heights of action figures
    in the boxes. For example, if a first box has action figures of heights 4, 5,
    and 7, and a second box has action figures of heights 1 and 2, then she can organize
    these boxes by putting the second box first. But if we keep the first box as is
    and change the second box to have action figures of heights 6 and 8, then there’s
    no way to organize these boxes.
  prefs: []
  type: TYPE_NORMAL
- en: Determine whether it’s possible for Lena to organize the boxes.
  prefs: []
  type: TYPE_NORMAL
- en: Input
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The input consists of the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: A line containing integer *n*, the number of boxes. *n* is between 1 and 100.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*n* lines, one for each box. Each of these lines begins with integer *k*, indicating
    the number of action figures in this box. *k* is between 1 and 100\. (Since *k*
    is at least 1, we don’t have to worry about empty boxes.) Following *k*, there
    are *k* integers giving the heights of the action figures from left to right in
    this box. Each height is an integer between 1 and 10,000\. There is a space between
    each pair of integers on the line.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If Lena can organize the boxes, output `YES`; otherwise, output `NO`.
  prefs: []
  type: TYPE_NORMAL
- en: Representing the Boxes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This problem consists of several smaller problems, each of which we can solve
    by writing a function. Let’s first see how to represent the boxes in Python, and
    then we’ll design the functions that we need.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 5](ch05.xhtml#ch05), when we solved Baker Bonus, we learned that
    lists can have other lists as their values. This allows us to nest lists inside
    of lists. We can use such an arrangement to represent the boxes of action figures.
    For example, here’s a list that represents two boxes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The first box has three action figures, and the second has two. We can access
    each box individually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We’ll read the contents of the boxes from the input and put that information
    into a nested list, like the one I’ve shown. Then we’ll use that nested list to
    determine whether the boxes can be organized.
  prefs: []
  type: TYPE_NORMAL
- en: Top-Down Design
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ll solve this problem using a program design approach called *top-down design*.
    Top-down design breaks a large problem into several smaller problems. That’s useful
    because each of the smaller problems will be easier to solve. We can then assemble
    those subproblem solutions to solve the original problem.
  prefs: []
  type: TYPE_NORMAL
- en: Doing Top-Down Design
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Here’s how top-down design works. We start by writing an incomplete Python program
    that captures the main tasks in a solution. Some of these tasks won’t require
    much code, so we can proceed to solve them directly. Other tasks will require
    more from us, and we’ll turn each of those into a function that we’ll call. We
    might also solve a task by writing a little code *and* calling a function. However,
    those functions won’t exist yet. We’ll have to write them!
  prefs: []
  type: TYPE_NORMAL
- en: To write a needed function, we repeat this same process for that function’s
    task. That is, we start by writing down the tasks for that function. If we can
    write code for a task outright, then we do it; otherwise, we call another function
    (that we’ll write later) to handle that task.
  prefs: []
  type: TYPE_NORMAL
- en: We keep doing this until we have no more functions to write. At that point,
    we’ll have a solution to our problem.
  prefs: []
  type: TYPE_NORMAL
- en: It’s called top-down design because we start at the top, or highest, level of
    the problem and make our way downward, through the guts of the problem, until
    each task has been completely written in code. We’ll now use this to solve Action
    Figures.
  prefs: []
  type: TYPE_NORMAL
- en: The Top Level
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To begin our design, we focus on the main tasks that we’ll need to solve.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll certainly have to read the input, so that’s our first task.
  prefs: []
  type: TYPE_NORMAL
- en: Now, assume that we’ve read the input. What should we do to determine whether
    the boxes can be organized? One important thing to do is check each box on its
    own to make sure that its action figures have their heights in order. For example,
    suppose that we had the box `[18, 20, 4]`. This box, with heights out of order,
    means that we have no chance of organizing all of the boxes. We can’t even organize
    this one!
  prefs: []
  type: TYPE_NORMAL
- en: 'So, that’s our second task: determine whether each box, on its own, has its
    action figures in order. If any of these boxes has its action figures out of order,
    then we know that the boxes can’t be organized. If all boxes are OK, then we have
    more to check.'
  prefs: []
  type: TYPE_NORMAL
- en: If each box on its own is OK, the next question is whether we can organize all
    of the boxes. One important observation we can make here is that the only action
    figures we care about from now on are the ones at the left and right sides of
    each box. The action figures between these don’t matter anymore.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this example where we have three boxes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The first box starts with an action figure of height 9 and ends with an action
    figure of height 25\. Action figures placed to the left of this box must all have
    height 9 or less; for example, we can place the third box to the left of this
    box. Action figures placed to the right of this box must all have height 25 or
    more; for example, we can place the second box to the right of this box. The action
    figures of heights 13, 14, and 17 change nothing; they may as well not be there.
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s our third task then: ignore all action figures except those on the ends
    of boxes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Following that third task, we’ll have a list that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s a lot easier to tell whether we can organize these boxes if we first sort
    them, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Now it’s easy to see what the neighboring boxes of a box must be. (We used a
    similar approach when solving Village Neighborhood in [Chapter 5](ch05.xhtml#ch05).)
    So, our fourth task is to sort the boxes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our fifth and final task is to determine whether these sorted boxes are organized.
    They are organized if the heights of action figures are sorted from left to right.
    The action figures of heights 1, 6, 9, 25, 32, and 36 are appropriately sorted,
    so the previous boxes can be organized. But consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: These boxes can’t be organized because of that huge action figure in the second
    box. That second box takes up heights 9 to 50; the third box can’t go on the right
    of the second box because its heights are too small.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve now finished working through the problem and have decided on five main
    tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Read input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check whether all boxes are OK.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Obtain a new list of boxes with only the left and right action figure heights
    from each box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sort these new boxes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Determine whether these sorted boxes are organized.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You might wonder why we have a “Read input” task but not a “Write output” task.
    For this problem, writing output involves just outputting `YES` or `NO` as needed;
    there won’t be much to it. In addition, we’ll output `YES` or `NO` as soon as
    we know the answer, so output will be interleaved with other tasks. For those
    reasons, I’ve decided not to include it as a main task. When working through top-down
    design on your own, don’t worry if you later realize that you’ve left out a task.
    You can just add it and continue with your design.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how we can capture our required tasks in code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: I’m calling this the main program ❶. Any functions we write should be included
    in the program before this comment.
  prefs: []
  type: TYPE_NORMAL
- en: Each task is written as just a comment for now. The `TODO` markings are there
    to highlight that these are tasks for us to convert from English to Python. Once
    we finish a task, we’ll remove its `TODO`. That way, we’ll be able to track which
    tasks we’ve completed and which we haven’t. Let’s do this!
  prefs: []
  type: TYPE_NORMAL
- en: 'Task 1: Read Input'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We need to read the line containing *n* (the number of boxes) and then read
    the boxes. Reading an integer is something we can do in a single line, so let’s
    read *n* directly. Reading the boxes, on the other hand, is a well-defined task
    that will take a few lines of code, so let’s solve that one with a function; we’ll
    call it `read_boxes`. Here’s where that leaves us in our main program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: I’ve removed the `TODO` from the comment ❶, since from the perspective of the
    main program, we’ve solved that task. We do need to write the `read_boxes` function,
    of course, so let’s do that now.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `read_boxes` function takes an integer `n` as a parameter and reads and
    returns `n` boxes. Here’s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We’re asked to read `n` boxes, so we loop `n` times ❶. On each iteration of
    this loop, we read the current line and split it into its individual action figure
    heights. The line starts with an integer indicating the number of heights in the
    line, so we remove that value from the list (it’s at index `0`) before continuing
    ❷. Then we convert each height to an integer and add the current box to the list
    of boxes. Finally, we return the list of boxes.
  prefs: []
  type: TYPE_NORMAL
- en: We didn’t defer any part of `read_boxes` to some as-yet-written function, so
    we’re done with this task! We’ll include this function, along with other functions
    we write, before the `# Main Program` comment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Task 2: Check Whether All Boxes Are OK'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Does each box, on its own, have the action figures going from shortest to tallest?
    Good question, and not one we know how to answer in just a line or two of code.
    Let’s rely on a new function, `all_boxes_ok`, to tell us. If that function returns
    `False`, then at least one box has its heights messed up, so we won’t be able
    to organize the boxes. In that case, we should output `NO`. If `all_boxes_ok`
    returns `True`, then we should carry out our remaining tasks to determine whether
    the boxes can be organized. Let’s add this bit of `if-else` logic to our program,
    too. Here’s what we’ve got:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Now we need to write the `all_boxes_ok` function that we’re calling ❶. We can
    check each box to determine whether it’s in order. If it isn’t, we return `False`
    right away. If it is in order, then we check the next box. If we check every box
    and they’re all in order, then we return `True`.
  prefs: []
  type: TYPE_NORMAL
- en: Aha, so we need to be able to check an individual box! Sounds like another function
    to me. Let’s call that one `box_ok`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what we have for `all_boxes_ok`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: I’ve used the word `nondecreasing` in the comment, rather than `increasing`,
    because heights of action figures are allowed to be equal. For example, the box
    `[4, 4, 4]` is just fine; claiming that this box is “increasing” would be incorrect.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve pushed part of the `all_boxes_ok` task into `box_ok`, so let’s write
    that function next. Here goes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: If any height is greater than the height to its right, we return `False` since
    the heights are not in order. If we get past the `for` loop, then there are no
    height violations, so we return `True`.
  prefs: []
  type: TYPE_NORMAL
- en: 'One nice side effect of using top-down design is that we get little chunks
    of code, wrapped up as functions, that we can test in isolation. For example,
    enter the code for `box_ok` into the Python shell. Then we can test it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We’re hoping for `True` to be returned here, because the box is in order from
    small heights to big heights. We certainly weren’t hoping for what we actually
    get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Errors are never fun, and they’re even less fun when we have to trawl through
    pages and pages of code to find them. But here, we know that the error is localized
    to this little function, so our work to find it is reduced considerably. The problem
    here is that we’ll eventually compare the rightmost height to the height to its
    right—and of course the latter doesn’t exist! So we need to stop one iteration
    earlier, comparing the second-to-last height to the last height. Here’s the updated
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The only change is in the call to `range` ❶. If you test this version of the
    function, you’ll see that it works as required. We’re done with Task 2!
  prefs: []
  type: TYPE_NORMAL
- en: 'Task 3: Obtain a New List of Boxes with Only Left and Right Heights'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now we’re getting the hang of top-down design. In this task, we need a way to
    go from boxes with all of their action figures to boxes only with their leftmost
    and rightmost action figures. I’ll refer to the leftmost and rightmost action
    figures as box *endpoints*.
  prefs: []
  type: TYPE_NORMAL
- en: One approach is to create a new list of boxes with only the endpoints, and that’s
    what I’ll do here. You could also think about actually removing heights from the
    original boxes, though that’s a little trickier.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ve called the function for this task `boxes_endpoints`. Here’s the main part
    of the program, updated with a call to that function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'When we call `boxes_endpoints` with a list of boxes ❶, we expect to get back
    a new list with only the box endpoints. Here’s the `boxes_endpoints` code that
    satisfies this description:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: We create a new list ❶ that will hold the endpoints of each box. Then we loop
    through the boxes. For each box, we use indexing to find the leftmost and rightmost
    heights in the box and append them to our endpoints list ❷. Finally, we return
    the endpoints list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Wait a sec: what happens if there’s a box with just one action figure in it?
    What will our `boxes_endpoints` function do with it? According to its docstring,
    it will give us back a list of two values for any valid box. So that had better
    happen here; otherwise, the function isn’t doing what it promises. Let’s test
    it. Enter the `boxes_endpoints` function into the Python shell, and try it with
    a list of one box with one action figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Success! The leftmost height is `2`, and the rightmost height is `2`, so we
    get a list with two occurrences of `2`. Our function works correctly in this case
    because `box[0]` and `box[-1]` both refer to the same value when `box` has only
    one value. (Don’t worry about the possibility of empty boxes. The problem description
    prohibits them.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Task 4: Sort Boxes'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'At this point, we have a list of endpoints—something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: We want to sort them. Do we need another function for this? Some sort of `sort_endpoints`
    function?
  prefs: []
  type: TYPE_NORMAL
- en: 'Not this time! The list `sort` method does exactly what we need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: When called on a list of two-value lists, `sort` sorts using the first value.
    (If there’s a tie, then it further sorts using the second value.)
  prefs: []
  type: TYPE_NORMAL
- en: 'We can immediately update the main part of our program with a call to `sort`
    and knock off one more `TODO`. Here’s the updated code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: We’re nearly there. Just one `TODO` to go.
  prefs: []
  type: TYPE_NORMAL
- en: 'Task 5: Determine Whether Boxes Are Organized'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Our final task is to check the endpoints. They might be in order, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they might not be, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'In the former case, we should print `YES`; in the latter, we should print `NO`.
    We need a function to tell us whether the endpoints are in order. Updating the
    main part of the program for the final time, we end up with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: All that stands between us and a complete solution to the problem is that `all_endpoints_ok`
    function that we’re calling ❶. It takes a list where each value is a list of endpoints
    and returns `True` if the endpoints are in order and `False` otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s get a feel for how we can implement this function by working through
    an example. Here’s the list of endpoints we’ll use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The first box has a right endpoint of height 6\. So, the second box better have
    a left endpoint of height 6 or more. If it doesn’t, then we return `False` indicating
    that the endpoints are not in order. But we’re good here, because the second box
    has a left endpoint of height 9.
  prefs: []
  type: TYPE_NORMAL
- en: Now we repeat that check using 25, the right endpoint of the second box. The
    left endpoint of the third box is 32, so we’re good again because 32 is at least
    25.
  prefs: []
  type: TYPE_NORMAL
- en: In general, if the left endpoint of a box is ever less than the right endpoint
    of the previous box, we return `False`. Otherwise, if all of these checks pass,
    we return `True`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: I’ve added some information to the docstring reminding us what the function
    requires when it’s called ❶. Specifically, we must remember to have the endpoints
    sorted before calling this function. Otherwise, the function could return the
    wrong value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each value of `endpoints` is a list with two values: index `0` is the leftmost
    (minimum) height, and index `1` is the rightmost (maximum) height. The code uses
    the `maximum` variable to track the maximum height of a box. Prior to the `for`
    loop, it refers to the maximum height in the first box ❷. The `for` loop compares
    the minimum of the next box to that maximum. If the minimum of the next box is
    too small, we return `False`, because these two boxes cannot be organized correctly.
    The last thing to do in each iteration is update `maximum` so that it refers to
    the maximum of the next box ❸.'
  prefs: []
  type: TYPE_NORMAL
- en: Putting It All Together
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Having written code for all tasks, including the functions that sprang up as
    part of the design, we’re ready to put it all together into a complete solution.
    It’s up to you whether to keep the comments in the main part of the program. I’ve
    left them in, but in practice this may be a case of over-documenting the code,
    since the function names on their own are chosen to convey what the code is doing.
    See [Listing 6-2](ch06.xhtml#ch06ex02) for the complete code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-2: Solving Action Figures*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the largest program that we’ve written to this point in the book. But
    look how tidy and minimal the main part of the program is: it’s mostly calls to
    functions, with a little bit of `if-else` logic to glue them together.'
  prefs: []
  type: TYPE_NORMAL
- en: We’re calling each function only once here. Compare that to the `no_high` Card
    Game function that we called four times. Even if a function is called only once,
    it still contributes to organized, readable code.
  prefs: []
  type: TYPE_NORMAL
- en: Time to submit to the Timus judge. You should see that all test cases pass.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONCEPT CHECK**'
  prefs: []
  type: TYPE_NORMAL
- en: In Task 2, we wrote function `box_ok` for determining whether a single box has
    its heights in order. It uses a range `for` loop. Is the following `while` loop
    version of `box_ok` correct?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: A. Yes
  prefs: []
  type: TYPE_NORMAL
- en: B. No; it can cause an `IndexError`
  prefs: []
  type: TYPE_NORMAL
- en: C. No; it doesn’t cause any errors, but it can return the wrong value
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer: A. This is equivalent to our earlier version using the range `for`
    loop. The `ok` variable starts off as `True`, meaning that all heights we have
    checked are fine (because we haven’t checked any yet!). The `while` loop continues
    as long'
  prefs: []
  type: TYPE_NORMAL
- en: as there are more boxes to check and there are no height violations. If an action
    figure is out of order, `ok` is set to `False`, which terminates the loop. If
    all action figures are in order, then the value of `ok` never changes from `True`
    to `False`. Therefore, when we `return ok` at the bottom of the function, we return
    `True` if all action figures are in order and `False` if not.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we learned about functions. A function is a self-contained
    block of code that solves a small part of a larger problem. We learned how to
    pass information to a function (through arguments) and get information back (through
    a return value).
  prefs: []
  type: TYPE_NORMAL
- en: To determine which functions to write in the first place, we can use top-down
    design. Top-down design helps us break a solution to a large problem into a number
    of smaller tasks; for each task, we solve it directly if we can or write a function
    for it if we can’t. If a given task is too unwieldy, we can perform further top-down
    design on it.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll learn how to work with files of our choosing, rather
    than using standard input and standard output. As we continue to push the boundaries
    of what we know, we’ll find many uses for functions in that chapter and the rest
    of the book. Practice with some of the following exercises to increase your confidence
    using functions.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here are some exercises for you to try. For each, use top-down design to identify
    one or more functions that help you organize your code. Include a docstring in
    each function!
  prefs: []
  type: TYPE_NORMAL
- en: DMOJ problem `ccc13s1`, From 1987 to 2013
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DMOJ problem `ccc18j3`, Are we there yet?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DMOJ problem `ecoo12r1p2`, Decoding DNA
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DMOJ problem `crci07p1`, Platforme
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DMOJ problem `coci13c2p2`, Misa
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Revisit some of the exercises from [Chapter 5](ch05.xhtml#ch05) and improve
    your solutions by using functions. I particularly suggest revisiting DMOJ problem
    `coci18c2p1` (Preokret) and DMOJ problem `ccc00s2` (Babbling Brooks).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Card Game is originally from the 1999 Canadian Computing Competition. Action
    Figures is originally from the 2019 Ural School Programming Contest.
  prefs: []
  type: TYPE_NORMAL
- en: Many modern programming languages, Python included, support two distinct programming
    paradigms. One is based on functions; that’s what we studied in this chapter.
    The other is based on *objects* and leads to a paradigm known as *object-oriented
    programming (OOP)*. OOP involves defining new types and writing methods for those
    types. We use Python types (such as integers and strings) throughout the book,
    but we won’t otherwise discuss OOP. For an introduction to OOP, and case studies
    of OOP in practice, I recommend *Python Crash Course*, 2nd edition by Eric Matthes
    (No Starch Press, 2019).
  prefs: []
  type: TYPE_NORMAL
