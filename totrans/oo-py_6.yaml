- en: self.gameOverImage = pygwidgets.Image(self.window, (140, 180),
  prefs: []
  type: TYPE_NORMAL
- en: '''images/gameOver.png'')'
  prefs: []
  type: TYPE_NORMAL
- en: self.titleText = pygwidgets.DisplayText(self.window,
  prefs: []
  type: TYPE_NORMAL
- en: (70, GAME_HEIGHT + 17),
  prefs: []
  type: TYPE_NORMAL
- en: '''Score: High Score:'','
  prefs: []
  type: TYPE_NORMAL
- en: fontSize=24, textColor=WHITE)
  prefs: []
  type: TYPE_NORMAL
- en: self.scoreText = pygwidgets.DisplayText(self.window,
  prefs: []
  type: TYPE_NORMAL
- en: (80, GAME_HEIGHT + 47), '0',
  prefs: []
  type: TYPE_NORMAL
- en: fontSize=36, textColor=WHITE,
  prefs: []
  type: TYPE_NORMAL
- en: justified='right')
  prefs: []
  type: TYPE_NORMAL
- en: self.highScoreText = pygwidgets.DisplayText(self.window,
  prefs: []
  type: TYPE_NORMAL
- en: (270, GAME_HEIGHT + 47), '',
  prefs: []
  type: TYPE_NORMAL
- en: fontSize=36, textColor=WHITE,
  prefs: []
  type: TYPE_NORMAL
- en: justified='right')
  prefs: []
  type: TYPE_NORMAL
- en: pygame.mixer.music.load('sounds/background.mid')
  prefs: []
  type: TYPE_NORMAL
- en: self.dingSound = pygame.mixer.Sound('sounds/ding.wav')
  prefs: []
  type: TYPE_NORMAL
- en: self.gameOverSound = pygame.mixer.Sound('sounds/gameover.wav')
  prefs: []
  type: TYPE_NORMAL
- en: Instantiate objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 2 self.oPlayer = Player(self.window)
  prefs: []
  type: TYPE_NORMAL
- en: self.oBaddieMgr = BaddieMgr(self.window)
  prefs: []
  type: TYPE_NORMAL
- en: self.oGoodieMgr = GoodieMgr(self.window)
  prefs: []
  type: TYPE_NORMAL
- en: self.highestHighScore = 0
  prefs: []
  type: TYPE_NORMAL
- en: self.lowestHighScore = 0
  prefs: []
  type: TYPE_NORMAL
- en: self.backgroundMusic = True
  prefs: []
  type: TYPE_NORMAL
- en: self.score = 0
  prefs: []
  type: TYPE_NORMAL
- en: 3 self.playingState = STATE_WAITING
  prefs: []
  type: TYPE_NORMAL
- en: '4 def getSceneKey(self):'
  prefs: []
  type: TYPE_NORMAL
- en: return SCENE_PLAY
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 16-3: The __init__() and getSceneKey() methods of the ScenePlay class*'
  prefs: []
  type: TYPE_NORMAL
- en: When run, the main code of the game instantiates all the scenes. In the
  prefs: []
  type: TYPE_NORMAL
- en: Play scene, the __init__() method creates all the buttons and text display
  prefs: []
  type: TYPE_NORMAL
- en: fields for the bottom of the window 1, then loads the sounds. Very impor-
  prefs: []
  type: TYPE_NORMAL
- en: tantly, we use composition, discussed in Chapters 4 and 10, to create a
  prefs: []
  type: TYPE_NORMAL
- en: Player object (oPlayer), a Baddie manager object (oBaddieMgr), and a Goodie
  prefs: []
  type: TYPE_NORMAL
- en: manager object (oGoodieMgr) 2\. The Play scene object creates these manag-
  prefs: []
  type: TYPE_NORMAL
- en: ers and expects them to create and manage all the Baddies and Goodies.
  prefs: []
  type: TYPE_NORMAL
- en: The __init__() method runs when the program starts, but doesn’t actually
  prefs: []
  type: TYPE_NORMAL
- en: start the game. Instead, it implements a state machine (as discussed in
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 15) t](index_split_006.html#p340)hat starts in the waiting state 3\.
    A round of the game starts when the user presses New Game.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Full Game: Dodger **351**'
  prefs: []
  type: TYPE_NORMAL
- en: All scenes must have a getSceneKey() method 4 that returns a string representing
    the current scene. Listing 16-4 shows the code that retrieves the
  prefs: []
  type: TYPE_NORMAL
- en: scores and resets the game upon request.
  prefs: []
  type: TYPE_NORMAL
- en: '1 def enter(self, data):'
  prefs: []
  type: TYPE_NORMAL
- en: self.getHiAndLowScores()
  prefs: []
  type: TYPE_NORMAL
- en: '2 def getHiAndLowScores(self):'
  prefs: []
  type: TYPE_NORMAL
- en: Ask the High Scores scene for a dict of scores
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'that looks like this:'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '{''highest'': highestScore, ''lowest'': lowestScore}'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 3 infoDict = self.request(SCENE_HIGH_SCORES, HIGH_SCORES_DATA)
  prefs: []
  type: TYPE_NORMAL
- en: self.highestHighScore = infoDict['highest']
  prefs: []
  type: TYPE_NORMAL
- en: self.highScoreText.setValue(self.highestHighScore)
  prefs: []
  type: TYPE_NORMAL
- en: self.lowestHighScore = infoDict['lowest']
  prefs: []
  type: TYPE_NORMAL
- en: '4 def reset(self): # start a new game'
  prefs: []
  type: TYPE_NORMAL
- en: self.score = 0
  prefs: []
  type: TYPE_NORMAL
- en: self.scoreText.setValue(self.score)
  prefs: []
  type: TYPE_NORMAL
- en: self.getHiAndLowScores()
  prefs: []
  type: TYPE_NORMAL
- en: Tell the managers to reset themselves
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 5 self.oBaddieMgr.reset()
  prefs: []
  type: TYPE_NORMAL
- en: self.oGoodieMgr.reset()
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.backgroundMusic:'
  prefs: []
  type: TYPE_NORMAL
- en: pygame.mixer.music.play(-1, 0.0)
  prefs: []
  type: TYPE_NORMAL
- en: 6 self.startButton.disable()
  prefs: []
  type: TYPE_NORMAL
- en: self.highScoresButton.disable()
  prefs: []
  type: TYPE_NORMAL
- en: self.soundCheckBox.disable()
  prefs: []
  type: TYPE_NORMAL
- en: self.quitButton.disable()
  prefs: []
  type: TYPE_NORMAL
- en: pygame.mouse.set_visible(False)
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 16-4: The enter(), getHiAndLowScores(), and reset() methods of the
    ScenePlay* *class*'
  prefs: []
  type: TYPE_NORMAL
- en: When navigating to the Play scene, the scene manager calls enter() 1,
  prefs: []
  type: TYPE_NORMAL
- en: which in turn calls the getHiAndLowScores() method 2\. That method issues a
  prefs: []
  type: TYPE_NORMAL
- en: request to the High Scores scene 3 to retrieve the highest and lowest scores
  prefs: []
  type: TYPE_NORMAL
- en: from the high scores table, so we can draw the highest score from that table
  prefs: []
  type: TYPE_NORMAL
- en: in the bar at the bottom of the window. At the end of each game, it com-
  prefs: []
  type: TYPE_NORMAL
- en: pares the game’s score to the lowest top 10 score to see if this game ranks
    in
  prefs: []
  type: TYPE_NORMAL
- en: the top 10\.
  prefs: []
  type: TYPE_NORMAL
- en: When the user clicks the New Game button, the reset() method 4
  prefs: []
  type: TYPE_NORMAL
- en: is called to reinitialize everything that needs to be reset before starting
    a
  prefs: []
  type: TYPE_NORMAL
- en: new round of the game. The reset() method tells the Baddie manager and
  prefs: []
  type: TYPE_NORMAL
- en: the Goodie manager to reinitialize themselves by calling their own reset()
  prefs: []
  type: TYPE_NORMAL
- en: methods 5, disables the buttons at the bottom of the screen so they cannot
  prefs: []
  type: TYPE_NORMAL
- en: be pressed during game play 6, and hides the pointer cursor. During play,
  prefs: []
  type: TYPE_NORMAL
- en: the user moves the mouse to control the Player icon in the window.
  prefs: []
  type: TYPE_NORMAL
- en: The code in Listing 16-5 deals with user input.
  prefs: []
  type: TYPE_NORMAL
- en: '**352** Chapter 16'
  prefs: []
  type: TYPE_NORMAL
- en: '1 def handleInputs(self, eventsList, keyPressedList):'
  prefs: []
  type: TYPE_NORMAL
- en: '2 if self.playingState == STATE_PLAYING:'
  prefs: []
  type: TYPE_NORMAL
- en: 'return # ignore button events while playing'
  prefs: []
  type: TYPE_NORMAL
- en: 'for event in eventsList:'
  prefs: []
  type: TYPE_NORMAL
- en: '3 if self.startButton.handleEvent(event):'
  prefs: []
  type: TYPE_NORMAL
- en: self.reset()
  prefs: []
  type: TYPE_NORMAL
- en: self.playingState = STATE_PLAYING
  prefs: []
  type: TYPE_NORMAL
- en: '4 if self.highScoresButton.handleEvent(event):'
  prefs: []
  type: TYPE_NORMAL
- en: self.goToScene(SCENE_HIGH_SCORES)
  prefs: []
  type: TYPE_NORMAL
- en: '5 if self.soundCheckBox.handleEvent(event):'
  prefs: []
  type: TYPE_NORMAL
- en: self.backgroundMusic = self.soundCheckBox.getValue()
  prefs: []
  type: TYPE_NORMAL
- en: '6 if self.quitButton.handleEvent(event):'
  prefs: []
  type: TYPE_NORMAL
- en: self.quit()
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 16-5: The handleInputs() method of the ScenePlay class*'
  prefs: []
  type: TYPE_NORMAL
- en: The handleInputs() method 1 is responsible for click events. If the state
  prefs: []
  type: TYPE_NORMAL
- en: machine is in the playing state, the user cannot click the buttons, so we
  prefs: []
  type: TYPE_NORMAL
- en: don’t bother checking for events 2\. If the user presses New Game 3, we
  prefs: []
  type: TYPE_NORMAL
- en: call reset() to reinitialize variables and change the state machine to the
  prefs: []
  type: TYPE_NORMAL
- en: playing state. If the user presses Go to High Scores 4, we navigate to the
  prefs: []
  type: TYPE_NORMAL
- en: High Scores scene using the inherited self.goToScene() method. If the user
  prefs: []
  type: TYPE_NORMAL
- en: toggles the Background Music checkbox 5, we call its getValue() method
  prefs: []
  type: TYPE_NORMAL
- en: to retrieve its new setting; the reset() method uses this setting to decide
    if
  prefs: []
  type: TYPE_NORMAL
- en: background music should be played. If the user presses Quit 6, we call the
  prefs: []
  type: TYPE_NORMAL
- en: inherited self.quit() method from the base class. Listing 16-6 shows the
  prefs: []
  type: TYPE_NORMAL
- en: code for the actual game play.
  prefs: []
  type: TYPE_NORMAL
- en: '1 def update(self):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.playingState != STATE_PLAYING:'
  prefs: []
  type: TYPE_NORMAL
- en: 'return # only update when playing'
  prefs: []
  type: TYPE_NORMAL
- en: Move the Player to the mouse position, get back its rect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 2 mouseX, mouseY = pygame.mouse.get_pos()
  prefs: []
  type: TYPE_NORMAL
- en: playerRect = self.oPlayer.update(mouseX, mouseY)
  prefs: []
  type: TYPE_NORMAL
- en: Tell the GoodieMgr to move all Goodies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Returns the number of Goodies that the Player contacted
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 3 nGoodiesHit = self.oGoodieMgr.update(playerRect)
  prefs: []
  type: TYPE_NORMAL
- en: 'if nGoodiesHit > 0:'
  prefs: []
  type: TYPE_NORMAL
- en: self.dingSound.play()
  prefs: []
  type: TYPE_NORMAL
- en: self.score = self.score + (nGoodiesHit * POINTS_FOR_GOODIE)
  prefs: []
  type: TYPE_NORMAL
- en: Tell the BaddieMgr to move all the Baddies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Returns the number of Baddies that fell off the bottom
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 4 nBaddiesEvaded = self.oBaddieMgr.update()
  prefs: []
  type: TYPE_NORMAL
- en: self.score = self.score + (nBaddiesEvaded * POINTS_FOR_BADDIE_EVADED)
  prefs: []
  type: TYPE_NORMAL
- en: self.scoreText.setValue(self.score)
  prefs: []
  type: TYPE_NORMAL
- en: 'Full Game: Dodger **353**'
  prefs: []
  type: TYPE_NORMAL
- en: Check if the Player has hit any Baddie
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '5 if self.oBaddieMgr.hasPlayerHitBaddie(playerRect):'
  prefs: []
  type: TYPE_NORMAL
- en: pygame.mouse.set_visible(True)
  prefs: []
  type: TYPE_NORMAL
- en: pygame.mixer.music.stop()
  prefs: []
  type: TYPE_NORMAL
- en: self.gameOverSound.play()
  prefs: []
  type: TYPE_NORMAL
- en: self.playingState = STATE_GAME_OVER
  prefs: []
  type: TYPE_NORMAL
- en: '6 self.draw() # force drawing of game over message'
  prefs: []
  type: TYPE_NORMAL
- en: '7 if self.score > self.lowestHighScore:'
  prefs: []
  type: TYPE_NORMAL
- en: 'scoreAsString = ′Your score: ′ + str(self.score) + ′\n′'
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.score > self.highestHighScore:'
  prefs: []
  type: TYPE_NORMAL
- en: dialogText = (scoreString +
  prefs: []
  type: TYPE_NORMAL
- en: '''is a new high score, CONGRATULATIONS!'')'
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: dialogText = (scoreString +
  prefs: []
  type: TYPE_NORMAL
- en: '''gets you on the high scores list.'')'
  prefs: []
  type: TYPE_NORMAL
- en: result = showCustomYesNoDialog(self.window, dialogText)
  prefs: []
  type: TYPE_NORMAL
- en: 'if result: # navigate'
  prefs: []
  type: TYPE_NORMAL
- en: self.goToScene(SCENE_HIGH_SCORES, self.score)
  prefs: []
  type: TYPE_NORMAL
- en: self.startButton.enable()
  prefs: []
  type: TYPE_NORMAL
- en: self.highScoresButton.enable()
  prefs: []
  type: TYPE_NORMAL
- en: self.soundCheckBox.enable()
  prefs: []
  type: TYPE_NORMAL
- en: self.quitButton.enable()
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 16-6: The update() method of the ScenePlay class*'
  prefs: []
  type: TYPE_NORMAL
- en: The scene manager calls the update() method of the ScenePlay class 1 in
  prefs: []
  type: TYPE_NORMAL
- en: every frame. This method handles everything that happens while the game
  prefs: []
  type: TYPE_NORMAL
- en: is being played. First, it tells the Player object to move the Player’s icon
    to
  prefs: []
  type: TYPE_NORMAL
- en: the position of the mouse. Then it calls the Player’s update() method 2,
  prefs: []
  type: TYPE_NORMAL
- en: which returns the current rectangle of the icon in the window. We use this
  prefs: []
  type: TYPE_NORMAL
- en: to see if the Player’s icon has contacted any Goodies or Baddies.
  prefs: []
  type: TYPE_NORMAL
- en: Next, it calls the Goodie manager’s update() method 3 to move all the
  prefs: []
  type: TYPE_NORMAL
- en: Goodies. This method returns the number of Goodies that the Player has
  prefs: []
  type: TYPE_NORMAL
- en: contacted, which we use to increase the score.
  prefs: []
  type: TYPE_NORMAL
- en: This is followed by a call to the Baddie manager’s update() method 4
  prefs: []
  type: TYPE_NORMAL
- en: to move all the Baddies. That method returns the number of Baddies that
  prefs: []
  type: TYPE_NORMAL
- en: have fallen off the bottom of the game area.
  prefs: []
  type: TYPE_NORMAL
- en: We then check to see if the Player has contacted any Baddies 5\. If so,
  prefs: []
  type: TYPE_NORMAL
- en: the game is over and we display a Game Over graphic. We also make a spe-
  prefs: []
  type: TYPE_NORMAL
- en: cial call to our draw() method 6 because we may put up a dialog for the
  prefs: []
  type: TYPE_NORMAL
- en: user, and the game’s main loop will not draw the Game Over graphic until
  prefs: []
  type: TYPE_NORMAL
- en: the user clicks one of the buttons in the dialog.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, when the game ends, if the current game score is higher than
  prefs: []
  type: TYPE_NORMAL
- en: the tenth-best score 7, we put up a dialog giving the user the option of
  prefs: []
  type: TYPE_NORMAL
- en: recording their score into the high scores list. If the score of the current
  prefs: []
  type: TYPE_NORMAL
- en: game is a new all-time high score, we give a special message in the dialog.
  prefs: []
  type: TYPE_NORMAL
- en: The code in Listing 16-7 draws the game characters.
  prefs: []
  type: TYPE_NORMAL
- en: '**354** Chapter 16'
  prefs: []
  type: TYPE_NORMAL
- en: '1 def draw(self):'
  prefs: []
  type: TYPE_NORMAL
- en: self.window.fill(BLACK)
  prefs: []
  type: TYPE_NORMAL
- en: Tell the managers to draw all the Baddies and Goodies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: self.oBaddieMgr.draw()
  prefs: []
  type: TYPE_NORMAL
- en: self.oGoodieMgr.draw()
  prefs: []
  type: TYPE_NORMAL
- en: Tell the Player to draw itself
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: self.oPlayer.draw()
  prefs: []
  type: TYPE_NORMAL
- en: Draw all the info at the bottom of the window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 2 self.controlsBackground.draw()
  prefs: []
  type: TYPE_NORMAL
- en: self.titleText.draw()
  prefs: []
  type: TYPE_NORMAL
- en: self.scoreText.draw()
  prefs: []
  type: TYPE_NORMAL
- en: self.highScoreText.draw()
  prefs: []
  type: TYPE_NORMAL
- en: self.soundCheckBox.draw()
  prefs: []
  type: TYPE_NORMAL
- en: self.quitButton.draw()
  prefs: []
  type: TYPE_NORMAL
- en: self.highScoresButton.draw()
  prefs: []
  type: TYPE_NORMAL
- en: self.startButton.draw()
  prefs: []
  type: TYPE_NORMAL
- en: '3 if self.playingState == STATE_GAME_OVER:'
  prefs: []
  type: TYPE_NORMAL
- en: self.gameOverImage.draw()
  prefs: []
  type: TYPE_NORMAL
- en: '4 def leave(self):'
  prefs: []
  type: TYPE_NORMAL
- en: pygame.mixer.music.stop()
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 16-7: The draw() and leave() methods of the ScenePlay class*'
  prefs: []
  type: TYPE_NORMAL
- en: The draw() method tells the Player to draw itself and the Goodie and
  prefs: []
  type: TYPE_NORMAL
- en: Baddie managers to draw all the Goodies and Baddies 1\. We then draw the
  prefs: []
  type: TYPE_NORMAL
- en: bottom portion of the window 2 with all the buttons and text display fields.
  prefs: []
  type: TYPE_NORMAL
- en: If we are in the game over state 3, we draw the Game Over image.
  prefs: []
  type: TYPE_NORMAL
- en: When the user navigates away from this scene, the scene manager calls
  prefs: []
  type: TYPE_NORMAL
- en: the leave() method 4 and we stop any music.
  prefs: []
  type: TYPE_NORMAL
- en: '**File: Dodger/Baddies.py**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The *Baddies.py* file contains two classes: Baddie and BaddieMgr. The Play
    scene creates the single Baddie manager object, which creates and maintains a'
  prefs: []
  type: TYPE_NORMAL
- en: list of all Baddies. The Baddie manager instantiates objects from the Baddie
  prefs: []
  type: TYPE_NORMAL
- en: class every few frames, based on a timer. Listing 16-8 contains the code for
  prefs: []
  type: TYPE_NORMAL
- en: the Baddie class.
  prefs: []
  type: TYPE_NORMAL
- en: Baddie class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '--- snip imports ---'
  prefs: []
  type: TYPE_NORMAL
- en: 'class Baddie():'
  prefs: []
  type: TYPE_NORMAL
- en: MIN_SIZE = 10
  prefs: []
  type: TYPE_NORMAL
- en: MAX_SIZE = 40
  prefs: []
  type: TYPE_NORMAL
- en: MIN_SPEED = 1
  prefs: []
  type: TYPE_NORMAL
- en: MAX_SPEED = 8
  prefs: []
  type: TYPE_NORMAL
- en: Load the image only once
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Full Game: Dodger **355**'
  prefs: []
  type: TYPE_NORMAL
- en: 1 BADDIE_IMAGE = pygame.image.load('images/baddie.png')
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, window):'
  prefs: []
  type: TYPE_NORMAL
- en: self.window = window
  prefs: []
  type: TYPE_NORMAL
- en: Create the image object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: size = random.randrange(Baddie.MIN_SIZE, Baddie.MAX_SIZE + 1)
  prefs: []
  type: TYPE_NORMAL
- en: self.x = random.randrange(0, WINDOW_WIDTH - size)
  prefs: []
  type: TYPE_NORMAL
- en: 'self.y = 0 - size # start above the window'
  prefs: []
  type: TYPE_NORMAL
- en: 2 self.image = pygwidgets.Image(self.window, (self.x, self.y),
  prefs: []
  type: TYPE_NORMAL
- en: Baddie.BADDIE_IMAGE)
  prefs: []
  type: TYPE_NORMAL
- en: Scale it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: percent = (size * 100) / Baddie.MAX_SIZE
  prefs: []
  type: TYPE_NORMAL
- en: self.image.scale(percent, False)
  prefs: []
  type: TYPE_NORMAL
- en: self.speed = random.randrange(Baddie.MIN_SPEED,
  prefs: []
  type: TYPE_NORMAL
- en: Baddie.MAX_SPEED + 1)
  prefs: []
  type: TYPE_NORMAL
- en: '3 def update(self): # move the Baddie down'
  prefs: []
  type: TYPE_NORMAL
- en: self.y = self.y + self.speed
  prefs: []
  type: TYPE_NORMAL
- en: self.image.setLoc((self.x, self.y))
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.y > GAME_HEIGHT:'
  prefs: []
  type: TYPE_NORMAL
- en: 'return True # needs to be deleted'
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: 'return False # stays in the window'
  prefs: []
  type: TYPE_NORMAL
- en: '4 def draw(self):'
  prefs: []
  type: TYPE_NORMAL
- en: self.image.draw()
  prefs: []
  type: TYPE_NORMAL
- en: '5 def collide(self, playerRect):'
  prefs: []
  type: TYPE_NORMAL
- en: collidedWithPlayer = self.image.overlaps(playerRect)
  prefs: []
  type: TYPE_NORMAL
- en: return collidedWithPlayer
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 16-8: The Baddie class*'
  prefs: []
  type: TYPE_NORMAL
- en: We load the image of the Baddie as a class variable 1 so the single
  prefs: []
  type: TYPE_NORMAL
- en: image is shared by *all* Baddies.
  prefs: []
  type: TYPE_NORMAL
- en: The __init__() method 2 chooses a random size for each new Baddie,
  prefs: []
  type: TYPE_NORMAL
- en: so the user sees differently sized Baddies. It chooses a random x-coordinate
  prefs: []
  type: TYPE_NORMAL
- en: and a y-coordinate that will place the image just above the window. It then
  prefs: []
  type: TYPE_NORMAL
- en: creates an Image object and scales the image down to the selected size 2\.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, it chooses a random speed.
  prefs: []
  type: TYPE_NORMAL
- en: The Baddie manager, the code for which I’ll show in a moment, calls
  prefs: []
  type: TYPE_NORMAL
- en: 'the update() method 3 in every frame: the code here moves the location of'
  prefs: []
  type: TYPE_NORMAL
- en: the Baddie down by the number of pixels that represents its speed. If the
  prefs: []
  type: TYPE_NORMAL
- en: Baddie has moved off the bottom of the game area, we return True to say
  prefs: []
  type: TYPE_NORMAL
- en: this Baddie is ready to be removed. Otherwise, we return False to tell the
  prefs: []
  type: TYPE_NORMAL
- en: Baddie manager to leave this Baddie in the window.
  prefs: []
  type: TYPE_NORMAL
- en: The draw() method 4 draws the Baddie at its new location.
  prefs: []
  type: TYPE_NORMAL
- en: The collide() method 5 checks to see if the Player and the Baddie
  prefs: []
  type: TYPE_NORMAL
- en: intersect.
  prefs: []
  type: TYPE_NORMAL
- en: '**356** Chapter 16'
  prefs: []
  type: TYPE_NORMAL
- en: The BaddieMgr class, shown in Listing 16-9, creates and manages a list of Baddie
    objects; this is a classic example of an object manager object.
  prefs: []
  type: TYPE_NORMAL
- en: BaddieMgr class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'class BaddieMgr():'
  prefs: []
  type: TYPE_NORMAL
- en: 'ADD_NEW_BADDIE_RATE = 8 # how often to add a new Baddie'
  prefs: []
  type: TYPE_NORMAL
- en: '1 def __init__(self, window):'
  prefs: []
  type: TYPE_NORMAL
- en: self.window = window
  prefs: []
  type: TYPE_NORMAL
- en: self.reset()
  prefs: []
  type: TYPE_NORMAL
- en: '2 def reset(self): # called when starting a new game'
  prefs: []
  type: TYPE_NORMAL
- en: self.baddiesList = []
  prefs: []
  type: TYPE_NORMAL
- en: self.nFramesTilNextBaddie = BaddieMgr.ADD_NEW_BADDIE_RATE
  prefs: []
  type: TYPE_NORMAL
- en: '3 def update(self):'
  prefs: []
  type: TYPE_NORMAL
- en: Tell each Baddie to update itself
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Count how many Baddies have fallen off the bottom
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: nBaddiesRemoved = 0
  prefs: []
  type: TYPE_NORMAL
- en: 4 baddiesListCopy = self.baddiesList.copy()
  prefs: []
  type: TYPE_NORMAL
- en: 'for oBaddie in baddiesListCopy:'
  prefs: []
  type: TYPE_NORMAL
- en: 5 deleteMe = oBaddie.update()
  prefs: []
  type: TYPE_NORMAL
- en: 'if deleteMe:'
  prefs: []
  type: TYPE_NORMAL
- en: self.baddiesList.remove(oBaddie)
  prefs: []
  type: TYPE_NORMAL
- en: nBaddiesRemoved = nBaddiesRemoved + 1
  prefs: []
  type: TYPE_NORMAL
- en: Check if it's time to add a new Baddie
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 6 self.nFramesTilNextBaddie = self.nFramesTilNextBaddie - 1
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.nFramesTilNextBaddie == 0:'
  prefs: []
  type: TYPE_NORMAL
- en: oBaddie = Baddie(self.window)
  prefs: []
  type: TYPE_NORMAL
- en: self.baddiesList.append(oBaddie)
  prefs: []
  type: TYPE_NORMAL
- en: self.nFramesTilNextBaddie = BaddieMgr.ADD_NEW_BADDIE_RATE
  prefs: []
  type: TYPE_NORMAL
- en: Return the count of Baddies that were removed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: return nBaddiesRemoved
  prefs: []
  type: TYPE_NORMAL
- en: '7 def draw(self):'
  prefs: []
  type: TYPE_NORMAL
- en: 'for oBaddie in self.baddiesList:'
  prefs: []
  type: TYPE_NORMAL
- en: oBaddie.draw()
  prefs: []
  type: TYPE_NORMAL
- en: '8 def hasPlayerHitBaddie(self, playerRect):'
  prefs: []
  type: TYPE_NORMAL
- en: 'for oBaddie in self.baddiesList:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if oBaddie.collide(playerRect):'
  prefs: []
  type: TYPE_NORMAL
- en: return True
  prefs: []
  type: TYPE_NORMAL
- en: return False
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 16-9: The BaddieMgr class*'
  prefs: []
  type: TYPE_NORMAL
- en: The __init__() method calls 1 the BaddieMgr’s own reset() method to
  prefs: []
  type: TYPE_NORMAL
- en: set the list of Baddie objects to the empty list. We use the frame-counting
  prefs: []
  type: TYPE_NORMAL
- en: approach to create a new Baddie relatively often, to keep things interesting.
  prefs: []
  type: TYPE_NORMAL
- en: We use the instance variable self.nFramesTilNextBaddie for counting frames.
  prefs: []
  type: TYPE_NORMAL
- en: 'Full Game: Dodger **357**'
  prefs: []
  type: TYPE_NORMAL
- en: The reset() method 2 is called when starting a new round of the game.
  prefs: []
  type: TYPE_NORMAL
- en: It clears the list of Baddies and resets the frame counter.
  prefs: []
  type: TYPE_NORMAL
- en: The update() method 3 is where the real management of Baddies hap-
  prefs: []
  type: TYPE_NORMAL
- en: pens. Our intent here is to loop through all the Baddies, telling each one to
  prefs: []
  type: TYPE_NORMAL
- en: update its own position and removing any that have fallen off the bottom of
  prefs: []
  type: TYPE_NORMAL
- en: the window. However, there is a potential bug. If you simply iterate through
  prefs: []
  type: TYPE_NORMAL
- en: a list and remove an element that matches your criteria for deletion, the list
  prefs: []
  type: TYPE_NORMAL
- en: is immediately compacted. When this happens, the element directly follow-
  prefs: []
  type: TYPE_NORMAL
- en: ing the one that was deleted will be skipped; in this loop, that element will
  prefs: []
  type: TYPE_NORMAL
- en: not be told to update itself. Though I didn’t go into detail at the time, we
  prefs: []
  type: TYPE_NORMAL
- en: encountered the same problem i[n Chapter 11 i](index_split_004.html#p270)n the
    Balloon game, where we needed to eliminate balloons that floated off the top of
    the window.
  prefs: []
  type: TYPE_NORMAL
- en: There I employed a solution using the reversed() function applied to the
  prefs: []
  type: TYPE_NORMAL
- en: list, to iterate in the reverse order (see Listing 11-6).
  prefs: []
  type: TYPE_NORMAL
- en: Here I’ve implemented a more generalized solution 4\. The approach
  prefs: []
  type: TYPE_NORMAL
- en: used in the BaddieMgr class is to make a copy of the list and iterate over the
  prefs: []
  type: TYPE_NORMAL
- en: '*copied* list; then, if we find an element that meets the criteria for deletion
    (in this case a Baddie that has fallen off the bottom of the window), we'
  prefs: []
  type: TYPE_NORMAL
- en: remove that element (that specific Baddie) from the *original* list. With this
    approach, we are iterating over a different list than the one from which we
  prefs: []
  type: TYPE_NORMAL
- en: are removing elements.
  prefs: []
  type: TYPE_NORMAL
- en: As we iterate through the Baddies, the call to the update() method of
  prefs: []
  type: TYPE_NORMAL
- en: 'each Baddie 5 returns a Boolean: False to indicate it’s still moving down'
  prefs: []
  type: TYPE_NORMAL
- en: the window or True to indicate that it has fallen off the bottom. We count the
  prefs: []
  type: TYPE_NORMAL
- en: number of Baddies that fall off the bottom and remove each one from the
  prefs: []
  type: TYPE_NORMAL
- en: list. At the end of the method, we return the count to the main code so it
  prefs: []
  type: TYPE_NORMAL
- en: can update the score.
  prefs: []
  type: TYPE_NORMAL
- en: In every frame, we also check to see if it’s time to create a new
  prefs: []
  type: TYPE_NORMAL
- en: Baddie 6\. When we’ve gone through the constant ADD_NEW_BADDIE_RATE num-
  prefs: []
  type: TYPE_NORMAL
- en: ber of frames, we create a new Baddie object and add it to the list of Baddies.
  prefs: []
  type: TYPE_NORMAL
- en: The draw() method 7 iterates through the list of Baddies and calls the
  prefs: []
  type: TYPE_NORMAL
- en: draw() method of each Baddie to draw itself at its appropriate location.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the hasPlayerHitBaddie() method 8 checks to see if the Player’s
  prefs: []
  type: TYPE_NORMAL
- en: rectangle intersects any Baddie. The code iterates through the list of
  prefs: []
  type: TYPE_NORMAL
- en: Baddies and calls the collide() method of each. If there was an intersec-
  prefs: []
  type: TYPE_NORMAL
- en: tion (overlap) with any Baddie, then we report that back to the main code,
  prefs: []
  type: TYPE_NORMAL
- en: which ends the game.
  prefs: []
  type: TYPE_NORMAL
- en: '**File: Dodger/Goodies.py**'
  prefs: []
  type: TYPE_NORMAL
- en: The GoodieMgr and Goodie classes are very similar to the BaddieMgr and Baddie
  prefs: []
  type: TYPE_NORMAL
- en: classes. The Goodie manager is an object manager object that maintains a
  prefs: []
  type: TYPE_NORMAL
- en: list of Goodies. The difference from the Baddie manager is that it will ran-
  prefs: []
  type: TYPE_NORMAL
- en: domly place a Goodie at either the left edge of the window (in which case it
  prefs: []
  type: TYPE_NORMAL
- en: moves right) or the right edge (so it moves left). It also creates new Goodies
  prefs: []
  type: TYPE_NORMAL
- en: after a randomized number of frames. When the Player intersects with a
  prefs: []
  type: TYPE_NORMAL
- en: Goodie, the user is rewarded with 25 points. The update() method of the
  prefs: []
  type: TYPE_NORMAL
- en: 'Goodie manager uses the technique described in the previous section: it'
  prefs: []
  type: TYPE_NORMAL
- en: makes a copy of the Goodies list and iterates through the copy.
  prefs: []
  type: TYPE_NORMAL
- en: '**358** Chapter 16'
  prefs: []
  type: TYPE_NORMAL
- en: '**File: Dodger/Player.py**'
  prefs: []
  type: TYPE_NORMAL
- en: The Player class, shown in Listing 16-10, manages the Player icon and keeps
  prefs: []
  type: TYPE_NORMAL
- en: track of where it should appear in the game window.
  prefs: []
  type: TYPE_NORMAL
- en: Player class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '--- snip imports ---'
  prefs: []
  type: TYPE_NORMAL
- en: 'class Player():'
  prefs: []
  type: TYPE_NORMAL
- en: '1 def __init__(self, window):'
  prefs: []
  type: TYPE_NORMAL
- en: self.window = window
  prefs: []
  type: TYPE_NORMAL
- en: self.image = pygwidgets.Image(window,
  prefs: []
  type: TYPE_NORMAL
- en: (-100, -100), 'images/player.png')
  prefs: []
  type: TYPE_NORMAL
- en: playerRect = self.image.getRect()
  prefs: []
  type: TYPE_NORMAL
- en: self.maxX = WINDOW_WIDTH - playerRect.width
  prefs: []
  type: TYPE_NORMAL
- en: self.maxY = GAME_HEIGHT - playerRect.height
  prefs: []
  type: TYPE_NORMAL
- en: Every frame, move the Player icon to the mouse position
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Limits the x- and y-coordinates to the game area of the window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '2 def update(self, x, y):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if x < 0:'
  prefs: []
  type: TYPE_NORMAL
- en: x = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'elif x > self.maxX:'
  prefs: []
  type: TYPE_NORMAL
- en: x = self.maxX
  prefs: []
  type: TYPE_NORMAL
- en: 'if y < 0:'
  prefs: []
  type: TYPE_NORMAL
- en: y = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'elif y > self.maxY:'
  prefs: []
  type: TYPE_NORMAL
- en: y = self.maxY
  prefs: []
  type: TYPE_NORMAL
- en: self.image.setLoc((x, y))
  prefs: []
  type: TYPE_NORMAL
- en: return self.image.getRect()
  prefs: []
  type: TYPE_NORMAL
- en: '3 def draw(self):'
  prefs: []
  type: TYPE_NORMAL
- en: self.image.draw()
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 16-10: The Player class*'
  prefs: []
  type: TYPE_NORMAL
- en: The __init__() method 1 loads the Player icon image and sets up a
  prefs: []
  type: TYPE_NORMAL
- en: number of instance variables for use later.
  prefs: []
  type: TYPE_NORMAL
- en: The update() method 2 is called in every frame by the Play scene. The
  prefs: []
  type: TYPE_NORMAL
- en: basic idea is to show the Player icon at the mouse location, which is passed
  prefs: []
  type: TYPE_NORMAL
- en: in. We do a few checks to ensure that the icon remains within the rect-
  prefs: []
  type: TYPE_NORMAL
- en: angle of the playable area. In every frame, the update() method returns the
  prefs: []
  type: TYPE_NORMAL
- en: updated rectangle of the Player icon so the main Play code in Listing 16-6
  prefs: []
  type: TYPE_NORMAL
- en: can check if the Player’s rectangle intersects with any Baddie or Goodie.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the draw() method 3 draws the Player icon at the new location.
  prefs: []
  type: TYPE_NORMAL
- en: The use of the Goodie manager, the Baddie manager, and the Player
  prefs: []
  type: TYPE_NORMAL
- en: object clearly demonstrates the power of OOP. We can just send messages to
  prefs: []
  type: TYPE_NORMAL
- en: these objects, asking them to update or reset themselves, and they do what-
  prefs: []
  type: TYPE_NORMAL
- en: ever they need to do in response. The Goodie and Baddie managers pass
  prefs: []
  type: TYPE_NORMAL
- en: these messages on to all the Goodies and Baddies that they manage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Full Game: Dodger **359**'
  prefs: []
  type: TYPE_NORMAL
- en: '**File: Dodger/SceneHighScores.py**'
  prefs: []
  type: TYPE_NORMAL
- en: The High Scores scene displays the top 10 high scores (and the names of
  prefs: []
  type: TYPE_NORMAL
- en: the players) in a table. It also allows a user who has scored in the top 10
    to
  prefs: []
  type: TYPE_NORMAL
- en: optionally enter their name and score into the table. The scene instantiates
  prefs: []
  type: TYPE_NORMAL
- en: a HighScoresData object to manage the actual data, which includes reading
  prefs: []
  type: TYPE_NORMAL
- en: and writing the data file. This allows the High Scores scene to update the
  prefs: []
  type: TYPE_NORMAL
- en: table and to respond to requests from the Play scene for the current high
  prefs: []
  type: TYPE_NORMAL
- en: and low scores in the table.
  prefs: []
  type: TYPE_NORMAL
- en: Listings 16-11 through 16-13 contain the code of the SceneHighScores
  prefs: []
  type: TYPE_NORMAL
- en: class. We’ll start with the __init__() and getSceneKey() methods in
  prefs: []
  type: TYPE_NORMAL
- en: Listing 16-11\.
  prefs: []
  type: TYPE_NORMAL
- en: High Scores scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '--- snip imports, showCustomAnswersDialog, and showCustomResetDialog ---'
  prefs: []
  type: TYPE_NORMAL
- en: 'class SceneHighScores(pyghelpers.Scene):'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, window):'
  prefs: []
  type: TYPE_NORMAL
- en: self.window = window
  prefs: []
  type: TYPE_NORMAL
- en: 1 self.oHighScoresData = HighScoresData()
  prefs: []
  type: TYPE_NORMAL
- en: self.backgroundImage = pygwidgets.Image(self.window,
  prefs: []
  type: TYPE_NORMAL
- en: (0, 0),
  prefs: []
  type: TYPE_NORMAL
- en: '''images/highScoresBackground.jpg'')'
  prefs: []
  type: TYPE_NORMAL
- en: self.namesField = pygwidgets.DisplayText(self.window,
  prefs: []
  type: TYPE_NORMAL
- en: (260, 84), '', fontSize=48,
  prefs: []
  type: TYPE_NORMAL
- en: textColor=BLACK,
  prefs: []
  type: TYPE_NORMAL
- en: width=300, justified='left')
  prefs: []
  type: TYPE_NORMAL
- en: self.scoresField = pygwidgets.DisplayText(self.window,
  prefs: []
  type: TYPE_NORMAL
- en: (25, 84), '', fontSize=48,
  prefs: []
  type: TYPE_NORMAL
- en: textColor=BLACK,
  prefs: []
  type: TYPE_NORMAL
- en: width=175, justified='right')
  prefs: []
  type: TYPE_NORMAL
- en: self.quitButton = pygwidgets.CustomButton(self.window,
  prefs: []
  type: TYPE_NORMAL
- en: (30, 650),
  prefs: []
  type: TYPE_NORMAL
- en: up='images/quitNormal.png',
  prefs: []
  type: TYPE_NORMAL
- en: down='images/quitDown.png',
  prefs: []
  type: TYPE_NORMAL
- en: over='images/quitOver.png',
  prefs: []
  type: TYPE_NORMAL
- en: disabled='images/quitDisabled.png')
  prefs: []
  type: TYPE_NORMAL
- en: self.backButton = pygwidgets.CustomButton(self.window,
  prefs: []
  type: TYPE_NORMAL
- en: (240, 650),
  prefs: []
  type: TYPE_NORMAL
- en: up='images/backNormal.png',
  prefs: []
  type: TYPE_NORMAL
- en: down='images/backDown.png',
  prefs: []
  type: TYPE_NORMAL
- en: over='images/backOver.png',
  prefs: []
  type: TYPE_NORMAL
- en: disabled='images/backDisabled.png')
  prefs: []
  type: TYPE_NORMAL
- en: self.resetScoresButton = pygwidgets.CustomButton(self.window,
  prefs: []
  type: TYPE_NORMAL
- en: (450, 650),
  prefs: []
  type: TYPE_NORMAL
- en: up='images/resetNormal.png',
  prefs: []
  type: TYPE_NORMAL
- en: down='images/resetDown.png',
  prefs: []
  type: TYPE_NORMAL
- en: over='images/resetOver.png',
  prefs: []
  type: TYPE_NORMAL
- en: '**360** Chapter 16'
  prefs: []
  type: TYPE_NORMAL
- en: disabled='images/resetDisabled.png') 2 self.showHighScores()
  prefs: []
  type: TYPE_NORMAL
- en: '3 def getSceneKey(self):'
  prefs: []
  type: TYPE_NORMAL
- en: return SCENE_HIGH_SCORES
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 16-11: The __init__() and getSceneKey() methods of the SceneHighScores
    class* The __init__() method 1 creates an instance of the HighScoresData class,'
  prefs: []
  type: TYPE_NORMAL
- en: which maintains all the data for the High Scores scene. We then create all
  prefs: []
  type: TYPE_NORMAL
- en: the images, fields, and buttons for this scene. At the end of the initializa-
  prefs: []
  type: TYPE_NORMAL
- en: tion, we call self.showHighScores() 2 to populate the name and score fields.
  prefs: []
  type: TYPE_NORMAL
- en: The getSceneKey() method 3 returns a unique key for the scene and
  prefs: []
  type: TYPE_NORMAL
- en: must be implemented in all scenes.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 16-12 shows the code for the enter() method of the
  prefs: []
  type: TYPE_NORMAL
- en: SceneHighScores class.
  prefs: []
  type: TYPE_NORMAL
- en: '1 def enter(self, newHighScoreValue=None):'
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be called two different ways:'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 1\. If no new high score, newHighScoreValue will be None
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 2\. newHighScoreValue is score of the current game - in top 10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '2 if newHighScoreValue is None:'
  prefs: []
  type: TYPE_NORMAL
- en: 'return # nothing to do'
  prefs: []
  type: TYPE_NORMAL
- en: '3 self.draw() # draw before showing dialog'
  prefs: []
  type: TYPE_NORMAL
- en: We have a new high score sent in from the Play scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: dialogQuestion = ('To record your score of ' +
  prefs: []
  type: TYPE_NORMAL
- en: str(newHighScoreValue) + ',\n' +
  prefs: []
  type: TYPE_NORMAL
- en: '''please enter your name:'')'
  prefs: []
  type: TYPE_NORMAL
- en: 4 playerName = showCustomAnswerDialog(self.window,
  prefs: []
  type: TYPE_NORMAL
- en: dialogQuestion)
  prefs: []
  type: TYPE_NORMAL
- en: '5 if playerName is None:'
  prefs: []
  type: TYPE_NORMAL
- en: 'return # user pressed Cancel'
  prefs: []
  type: TYPE_NORMAL
- en: Add user and score to high scores
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'if playerName == '''':'
  prefs: []
  type: TYPE_NORMAL
- en: playerName = 'Anonymous'
  prefs: []
  type: TYPE_NORMAL
- en: 6 self.oHighScoresData.addHighScore(playerName,
  prefs: []
  type: TYPE_NORMAL
- en: newHighScoreValue)
  prefs: []
  type: TYPE_NORMAL
- en: Show the updated high scores table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: self.showHighScores()
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 16-12: The enter() method of the SceneHighScores class*'
  prefs: []
  type: TYPE_NORMAL
- en: The scene manager calls the enter() method of the High Scores scene 1
  prefs: []
  type: TYPE_NORMAL
- en: when navigating to that scene from the Play scene. If the game the user just
  prefs: []
  type: TYPE_NORMAL
- en: finished did not have a score in the top 10, this method just returns 2\. But
  prefs: []
  type: TYPE_NORMAL
- en: if the user did earn a top 10 score, the enter() method is called with an extra
  prefs: []
  type: TYPE_NORMAL
- en: value—the score of the game that the user just completed.
  prefs: []
  type: TYPE_NORMAL
- en: In that case, we call draw() 3 to draw the contents of the High Scores
  prefs: []
  type: TYPE_NORMAL
- en: scene before showing the dialog offering the user the choice to add their
  prefs: []
  type: TYPE_NORMAL
- en: 'Full Game: Dodger **361**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 53](index-391_1.png)'
  prefs: []
  type: TYPE_IMG
- en: score to the list. We then call an intermediate function, showCustom
  prefs: []
  type: TYPE_NORMAL
- en: AnswerDialog(), that builds and displays the custom dialog 4, as shown
  prefs: []
  type: TYPE_NORMAL
- en: in Figure 16-7\.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 16-7: A customAnswerDialog to let the user add their name to the high
    scores list* If the user selects No Thanks, we get a returned value of None and'
  prefs: []
  type: TYPE_NORMAL
- en: we skip the rest of this method 5\. Otherwise, we take the name that is
  prefs: []
  type: TYPE_NORMAL
- en: returned and add the name and score to the table 6 by calling a method
  prefs: []
  type: TYPE_NORMAL
- en: in the HighScoresData object. Finally, we update the fields by calling the
  prefs: []
  type: TYPE_NORMAL
- en: showHighScores() method. If there is no score in the call to this method 2,
  prefs: []
  type: TYPE_NORMAL
- en: there is nothing to do, since the current list is already displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 16-13 contains the code for the remaining methods of this class.
  prefs: []
  type: TYPE_NORMAL
- en: 'def showHighScores(self): 1'
  prefs: []
  type: TYPE_NORMAL
- en: Get the scores and names, show them in two fields
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: scoresList, namesList = self.oHighScoresData.getScoresAndNames()
  prefs: []
  type: TYPE_NORMAL
- en: self.namesField.setValue(namesList)
  prefs: []
  type: TYPE_NORMAL
- en: self.scoresField.setValue(scoresList)
  prefs: []
  type: TYPE_NORMAL
- en: 'def handleInputs(self, eventsList, keyPressedList): 2'
  prefs: []
  type: TYPE_NORMAL
- en: 'for event in eventsList:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.quitButton.handleEvent(event):'
  prefs: []
  type: TYPE_NORMAL
- en: self.quit()
  prefs: []
  type: TYPE_NORMAL
- en: 'elif self.backButton.handleEvent(event):'
  prefs: []
  type: TYPE_NORMAL
- en: self.goToScene(SCENE_PLAY)
  prefs: []
  type: TYPE_NORMAL
- en: 'elif self.resetScoresButton.handleEvent(event):'
  prefs: []
  type: TYPE_NORMAL
- en: confirmed = showCustomResetDialog(self.window, 3
  prefs: []
  type: TYPE_NORMAL
- en: '''Are you sure you want to \nRESET the high scores?'')'
  prefs: []
  type: TYPE_NORMAL
- en: 'if confirmed:'
  prefs: []
  type: TYPE_NORMAL
- en: self.oHighScoresData.resetScores()
  prefs: []
  type: TYPE_NORMAL
- en: self.showHighScores()
  prefs: []
  type: TYPE_NORMAL
- en: 'def draw(self): 4'
  prefs: []
  type: TYPE_NORMAL
- en: self.backgroundImage.draw()
  prefs: []
  type: TYPE_NORMAL
- en: self.scoresField.draw()
  prefs: []
  type: TYPE_NORMAL
- en: self.namesField.draw()
  prefs: []
  type: TYPE_NORMAL
- en: self.quitButton.draw()
  prefs: []
  type: TYPE_NORMAL
- en: self.resetScoresButton.draw()
  prefs: []
  type: TYPE_NORMAL
- en: self.backButton.draw()
  prefs: []
  type: TYPE_NORMAL
- en: '**362** Chapter 16'
  prefs: []
  type: TYPE_NORMAL
- en: 'def respond(self, requestID): 5'
  prefs: []
  type: TYPE_NORMAL
- en: 'if requestID == HIGH_SCORES_DATA:'
  prefs: []
  type: TYPE_NORMAL
- en: Request from Play scene for the highest and lowest scores
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Build a dictionary and return it to the Play scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: highestScore, lowestScore = self.oHighScoresData.getHighestAndLowest()
  prefs: []
  type: TYPE_NORMAL
- en: return {'highest':highestScore, 'lowest':lowestScore}
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 16-13: The showHighScores(), handleInputs(), draw(), and respond()
    methods of the SceneHighScores* *class*'
  prefs: []
  type: TYPE_NORMAL
- en: The showHighScores() method 1 starts by asking the HighScoresData
  prefs: []
  type: TYPE_NORMAL
- en: 'object for two lists: the top 10 names and scores. It takes the lists that
    are'
  prefs: []
  type: TYPE_NORMAL
- en: returned and sends them to two display fields to be shown. If you pass a list
  prefs: []
  type: TYPE_NORMAL
- en: to the setValue() method of a DisplayText object, it will display each element
  prefs: []
  type: TYPE_NORMAL
- en: on a separate line. We use two DisplayText objects because self.namesField is
  prefs: []
  type: TYPE_NORMAL
- en: left justified, while self.scoresField is right justified.
  prefs: []
  type: TYPE_NORMAL
- en: The handleInputs() method 2 only needs to check for and respond to
  prefs: []
  type: TYPE_NORMAL
- en: the user clicking the Quit, Back, and Reset Scores buttons. Because the
  prefs: []
  type: TYPE_NORMAL
- en: Reset Scores button wipes data, we should ask for confirmation before per-
  prefs: []
  type: TYPE_NORMAL
- en: forming this action. Therefore, when the user clicks this button, we call an
  prefs: []
  type: TYPE_NORMAL
- en: intermediate function, showCustomResetDialog() 3, to put up a dialog asking
  prefs: []
  type: TYPE_NORMAL
- en: the user to confirm that they really want to clear out all the current scores.
  prefs: []
  type: TYPE_NORMAL
- en: The draw() method 4 draws all the elements in the window.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the respond() method 5 allows another scene to ask this scene for
  prefs: []
  type: TYPE_NORMAL
- en: information. This is what allows the Play scene to request the highest current
  prefs: []
  type: TYPE_NORMAL
- en: score and the tenth-highest score—the minimum score to qualify a player for
  prefs: []
  type: TYPE_NORMAL
- en: the high scores list. The caller sends a value that indicates what information
  prefs: []
  type: TYPE_NORMAL
- en: it’s looking for. In this case, the requested info is HIGH_SCORES_DATA, a constant
  prefs: []
  type: TYPE_NORMAL
- en: that is shared from the *Constants.py* file. This method builds up a dictionary
    of the two requested values and returns it to the calling scene.
  prefs: []
  type: TYPE_NORMAL
- en: '**File: Dodger/HighScoresData.py**'
  prefs: []
  type: TYPE_NORMAL
- en: The final class is HighScoresData, responsible for managing the high score
  prefs: []
  type: TYPE_NORMAL
- en: information. It reads and writes the data as a file in JSON format. The data
  prefs: []
  type: TYPE_NORMAL
- en: is always kept in order, from the highest to the lowest score. For example,
  prefs: []
  type: TYPE_NORMAL
- en: 'the file representing the 10 highest scores might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[[''Moe'', 987], [''Larry'', 812], ... [''Curly'', 597]]'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 16-14 shows the code of the HighScoresData class.
  prefs: []
  type: TYPE_NORMAL
- en: HighScoresData class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: from Constants import *
  prefs: []
  type: TYPE_NORMAL
- en: from pathlib import Path
  prefs: []
  type: TYPE_NORMAL
- en: import json
  prefs: []
  type: TYPE_NORMAL
- en: 'class HighScoresData():'
  prefs: []
  type: TYPE_NORMAL
- en: '"""The data file is stored as a list of lists in JSON format.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each list is made up of a name and a score:'
  prefs: []
  type: TYPE_NORMAL
- en: '[[name, score], [name, score], [name, score] ...]'
  prefs: []
  type: TYPE_NORMAL
- en: In this class, all scores are kept in self.scoresList.
  prefs: []
  type: TYPE_NORMAL
- en: 'Full Game: Dodger **363**'
  prefs: []
  type: TYPE_NORMAL
- en: The list is kept in order of scores, highest to lowest.
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: '1 def __init__(self):'
  prefs: []
  type: TYPE_NORMAL
- en: self.BLANK_SCORES_LIST = N_HIGH_SCORES * [['-----', 0]]
  prefs: []
  type: TYPE_NORMAL
- en: 2 self.oFilePath = Path('HighScores.json')
  prefs: []
  type: TYPE_NORMAL
- en: Try to open and load the data from the data file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'try:'
  prefs: []
  type: TYPE_NORMAL
- en: 3 data = self.oFilePath.read_text()
  prefs: []
  type: TYPE_NORMAL
- en: 'except FileNotFoundError: # no file, set to blank scores and save'
  prefs: []
  type: TYPE_NORMAL
- en: 4 self.scoresList = self.BLANK_SCORES_LIST.copy()
  prefs: []
  type: TYPE_NORMAL
- en: self.saveScores()
  prefs: []
  type: TYPE_NORMAL
- en: return
  prefs: []
  type: TYPE_NORMAL
- en: File exists, load the scores from the JSON file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 5 self.scoresList = json.loads(data)
  prefs: []
  type: TYPE_NORMAL
- en: '6 def addHighScore(self, name, newHighScore):'
  prefs: []
  type: TYPE_NORMAL
- en: Find the appropriate place to add the new high score
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: placeFound = False
  prefs: []
  type: TYPE_NORMAL
- en: 'for index, nameScoreList in enumerate(self.scoresList):'
  prefs: []
  type: TYPE_NORMAL
- en: thisScore = nameScoreList[1]
  prefs: []
  type: TYPE_NORMAL
- en: 'if newHighScore > thisScore:'
  prefs: []
  type: TYPE_NORMAL
- en: Insert into proper place, remove last entry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: self.scoresList.insert(index, [name, newHighScore])
  prefs: []
  type: TYPE_NORMAL
- en: self.scoresList.pop(N_HIGH_SCORES)
  prefs: []
  type: TYPE_NORMAL
- en: placeFound = True
  prefs: []
  type: TYPE_NORMAL
- en: break
  prefs: []
  type: TYPE_NORMAL
- en: 'if not placeFound:'
  prefs: []
  type: TYPE_NORMAL
- en: 'return # score does not belong in the list'
  prefs: []
  type: TYPE_NORMAL
- en: Save the updated scores
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: self.saveScores()
  prefs: []
  type: TYPE_NORMAL
- en: '7 def saveScores(self):'
  prefs: []
  type: TYPE_NORMAL
- en: scoresAsJson = json.dumps(self.scoresList)
  prefs: []
  type: TYPE_NORMAL
- en: self.oFilePath.write_text(scoresAsJson)
  prefs: []
  type: TYPE_NORMAL
- en: '8 def resetScores(self):'
  prefs: []
  type: TYPE_NORMAL
- en: self.scoresList = self.BLANK_SCORES_LIST.copy()
  prefs: []
  type: TYPE_NORMAL
- en: self.saveScores()
  prefs: []
  type: TYPE_NORMAL
- en: '9 def getScoresAndNames(self):'
  prefs: []
  type: TYPE_NORMAL
- en: namesList = []
  prefs: []
  type: TYPE_NORMAL
- en: scoresList = []
  prefs: []
  type: TYPE_NORMAL
- en: 'for nameAndScore in self.scoresList:'
  prefs: []
  type: TYPE_NORMAL
- en: thisName = nameAndScore[0]
  prefs: []
  type: TYPE_NORMAL
- en: thisScore = nameAndScore[1]
  prefs: []
  type: TYPE_NORMAL
- en: namesList.append(thisName)
  prefs: []
  type: TYPE_NORMAL
- en: scoresList.append(thisScore)
  prefs: []
  type: TYPE_NORMAL
- en: return scoresList, namesList
  prefs: []
  type: TYPE_NORMAL
- en: 'a def getHighestAndLowest(self):'
  prefs: []
  type: TYPE_NORMAL
- en: Element 0 is the highest entry, element -1 is the lowest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**364** Chapter 16'
  prefs: []
  type: TYPE_NORMAL
- en: highestEntry = self.scoresList[0]
  prefs: []
  type: TYPE_NORMAL
- en: lowestEntry = self.scoresList[-1]
  prefs: []
  type: TYPE_NORMAL
- en: Get the score (element 1) of each sublist
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: highestScore = highestEntry[1]
  prefs: []
  type: TYPE_NORMAL
- en: lowestScore = lowestEntry[1]
  prefs: []
  type: TYPE_NORMAL
- en: return highestScore, lowestScore
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 16-14: The HighScoresData class*'
  prefs: []
  type: TYPE_NORMAL
- en: In the __init__() method 1, we first create a list of all blank entries. We
  prefs: []
  type: TYPE_NORMAL
- en: use the Path module to create a path object with the location of the data
  prefs: []
  type: TYPE_NORMAL
- en: file 2\.
  prefs: []
  type: TYPE_NORMAL
- en: '**N O T E**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The path shown in this listing is in the same folder as the code. This is
    fine for learning the concept of file input and output. However, if you intend
    to share your program with other people to play on their computers, it would be
    better to use a different* *path in the user’s home folder. This path can be constructed
    like this:*'
  prefs: []
  type: TYPE_NORMAL
- en: import os.path
  prefs: []
  type: TYPE_NORMAL
- en: DATA_FILE_PATH = os.path.expanduser('~/DodgerHighScores.json')
  prefs: []
  type: TYPE_NORMAL
- en: '*or:*'
  prefs: []
  type: TYPE_NORMAL
- en: from pathlib import Path
  prefs: []
  type: TYPE_NORMAL
- en: DATA_FILE_PATH = Path('~/DodgerHighScores.json').expanduser()
  prefs: []
  type: TYPE_NORMAL
- en: Next, we check if we already have some high scores saved by checking
  prefs: []
  type: TYPE_NORMAL
- en: for the existence of the data file 3\. If the file is not found 4, we set the
  prefs: []
  type: TYPE_NORMAL
- en: scores to the list of blank entries, call saveScores() to save the scores, and
  prefs: []
  type: TYPE_NORMAL
- en: return. Otherwise, we read the contents of the file 5 and convert from
  prefs: []
  type: TYPE_NORMAL
- en: JSON format to a list of lists.
  prefs: []
  type: TYPE_NORMAL
- en: The addHighScores() method 6 is responsible for adding a new high
  prefs: []
  type: TYPE_NORMAL
- en: score to the list. Since the data is always kept in order, we iterate through
  prefs: []
  type: TYPE_NORMAL
- en: the list of scores until we find the appropriate index and insert the new
  prefs: []
  type: TYPE_NORMAL
- en: name and score. Because that operation will extend the list, we remove
  prefs: []
  type: TYPE_NORMAL
- en: the last element to only keep the top 10\. We also check that the new score
  prefs: []
  type: TYPE_NORMAL
- en: should actually be inserted into the list. Finally, we call saveScores() to
    save
  prefs: []
  type: TYPE_NORMAL
- en: the scores to the data file.
  prefs: []
  type: TYPE_NORMAL
- en: The saveScores() method 7 saves the score data to a JSON-formatted
  prefs: []
  type: TYPE_NORMAL
- en: file. It’s called from various places.
  prefs: []
  type: TYPE_NORMAL
- en: The resetScores() method 8 is called when the user says that they wish
  prefs: []
  type: TYPE_NORMAL
- en: to reset all the names and scores to the starting point (all blank names and
  prefs: []
  type: TYPE_NORMAL
- en: all scores set to zero). We call saveScores() to rewrite the data file.
  prefs: []
  type: TYPE_NORMAL
- en: The getScoresAndNames() method 9 is called by the High Scores scene to
  prefs: []
  type: TYPE_NORMAL
- en: get the top 10 scores and names. We iterate through the list of lists of high
  prefs: []
  type: TYPE_NORMAL
- en: scores data to create one list of scores and another of names; both lists are
  prefs: []
  type: TYPE_NORMAL
- en: returned.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the getHighestAndLowest() method a is called by the High Scores
  prefs: []
  type: TYPE_NORMAL
- en: scene to get the highest and lowest scores in the table. It uses these results
  prefs: []
  type: TYPE_NORMAL
- en: to determine if a user’s score qualifies the user to enter their name and
  prefs: []
  type: TYPE_NORMAL
- en: score into the high scores table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Full Game: Dodger **365**'
  prefs: []
  type: TYPE_NORMAL
- en: '***Extensions to the Game***'
  prefs: []
  type: TYPE_NORMAL
- en: The overall architecture is modular, allowing for ease of modification. Each
  prefs: []
  type: TYPE_NORMAL
- en: scene encapsulates its own data and methods, while communication and
  prefs: []
  type: TYPE_NORMAL
- en: navigation are handled by the scene manager. Extensions can be handled
  prefs: []
  type: TYPE_NORMAL
- en: in one scene without affecting anything in other scenes.
  prefs: []
  type: TYPE_NORMAL
- en: For example, rather than the game ending as soon as the Player icon
  prefs: []
  type: TYPE_NORMAL
- en: hits a Baddie, you might want the user to start with some number of lives;
  prefs: []
  type: TYPE_NORMAL
- en: when the Player icon hits a Baddie, the number of lives is decremented by
  prefs: []
  type: TYPE_NORMAL
- en: one, and the game is over when the player runs out of lives. This kind of
  prefs: []
  type: TYPE_NORMAL
- en: change would be relatively easy to implement and would affect only the
  prefs: []
  type: TYPE_NORMAL
- en: Play scene.
  prefs: []
  type: TYPE_NORMAL
- en: As another idea, the user might start with a small number of bombs
  prefs: []
  type: TYPE_NORMAL
- en: that they can detonate when they’re in a bind, eliminating all Baddies
  prefs: []
  type: TYPE_NORMAL
- en: within a given radius around the Player icon. The count of bombs would
  prefs: []
  type: TYPE_NORMAL
- en: be decremented each time one is used, until it reaches zero. This change
  prefs: []
  type: TYPE_NORMAL
- en: would affect only the code of the Play scene and the Baddie manager.
  prefs: []
  type: TYPE_NORMAL
- en: Or maybe you want to keep track of more high scores—say, 20 instead
  prefs: []
  type: TYPE_NORMAL
- en: of 10\. A change like that can be made in the High Scores scene without
  prefs: []
  type: TYPE_NORMAL
- en: affecting the Play or Splash scenes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter demonstrated how to create and use Yes/No and Answer
  prefs: []
  type: TYPE_NORMAL
- en: dialogs—both text and customizable versions. We then focused on building
  prefs: []
  type: TYPE_NORMAL
- en: a full object-oriented game program, Dodger.
  prefs: []
  type: TYPE_NORMAL
- en: We used the pygwidgets module for all the buttons, text displays, and
  prefs: []
  type: TYPE_NORMAL
- en: input text fields. We used the pyghelpers module for all the dialogs. The
  prefs: []
  type: TYPE_NORMAL
- en: SceneMgr allowed us to split up the game into smaller, more manageable
  prefs: []
  type: TYPE_NORMAL
- en: pieces (Scene objects) and to navigate between scenes.
  prefs: []
  type: TYPE_NORMAL
- en: The game used or demonstrated the following object-oriented
  prefs: []
  type: TYPE_NORMAL
- en: 'concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Encapsulation** Each scene handles only the things specific to the'
  prefs: []
  type: TYPE_NORMAL
- en: scene.
  prefs: []
  type: TYPE_NORMAL
- en: '**Polymorphism** Each scene implements the same methods.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Inheritance** Each scene inherits from the Scene base class.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Object manager object** The Play scene uses composition to create a'
  prefs: []
  type: TYPE_NORMAL
- en: Baddie manager object, self.oBaddieMgr, and a Goodie manager object,
  prefs: []
  type: TYPE_NORMAL
- en: self.oGoodieMgr, each of which manages a list of its objects.
  prefs: []
  type: TYPE_NORMAL
- en: '**Shared constants** We use separate modules for Goodies and Baddies,'
  prefs: []
  type: TYPE_NORMAL
- en: and a *Constants.py* file allows us to easily share constants across modules.
  prefs: []
  type: TYPE_NORMAL
- en: '**366** Chapter 16'
  prefs: []
  type: TYPE_NORMAL
- en: '**17**'
  prefs: []
  type: TYPE_NORMAL
- en: '**D E S I G N P A T T E R N S**'
  prefs: []
  type: TYPE_NORMAL
- en: '**A N D W R A P - U P**'
  prefs: []
  type: TYPE_NORMAL
- en: In this final chapter, I’ll introduce the
  prefs: []
  type: TYPE_NORMAL
- en: object-oriented programming concept of
  prefs: []
  type: TYPE_NORMAL
- en: '*design patterns*, which are reusable OOP solu-'
  prefs: []
  type: TYPE_NORMAL
- en: tions to commonly occurring software prob-
  prefs: []
  type: TYPE_NORMAL
- en: lems. We’ve already seen one design pattern in this
  prefs: []
  type: TYPE_NORMAL
- en: 'book: using an object manager object to manage a list'
  prefs: []
  type: TYPE_NORMAL
- en: or dictionary of objects. Many full books have been written on the topic of
  prefs: []
  type: TYPE_NORMAL
- en: design patterns, so we obviously cannot discuss all of them. In this chapter
  prefs: []
  type: TYPE_NORMAL
- en: we’ll focus on the Model View Controller pattern that’s used to break a sys-
  prefs: []
  type: TYPE_NORMAL
- en: tem into smaller, more manageable and more modifiable parts. Lastly, I’ll
  prefs: []
  type: TYPE_NORMAL
- en: give a wrap-up on OOP.
  prefs: []
  type: TYPE_NORMAL
- en: '**Model View Controller**'
  prefs: []
  type: TYPE_NORMAL
- en: The *Model View Controller (MVC)* design pattern enforces a clear split
  prefs: []
  type: TYPE_NORMAL
- en: between a collection of data and the way that data is represented to the
  prefs: []
  type: TYPE_NORMAL
- en: 'user. The pattern separates the functionality into three parts: the model,'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 54](index-397_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '![Image 55](index-397_2.png)'
  prefs: []
  type: TYPE_IMG
- en: the view, and the controller. Each part has a clearly defined responsibility,
  prefs: []
  type: TYPE_NORMAL
- en: and each is implemented by one or more objects.
  prefs: []
  type: TYPE_NORMAL
- en: The model stores data. The view is responsible for drawing the infor-
  prefs: []
  type: TYPE_NORMAL
- en: mation from the model in one of perhaps multiple ways. The controller
  prefs: []
  type: TYPE_NORMAL
- en: typically creates the model and view objects, handles all user interactions,
  prefs: []
  type: TYPE_NORMAL
- en: communicates changes to the model, and tells the view to display the
  prefs: []
  type: TYPE_NORMAL
- en: data. This separation makes the overall system highly maintainable and
  prefs: []
  type: TYPE_NORMAL
- en: modifiable.
  prefs: []
  type: TYPE_NORMAL
- en: '***File Display Example***'
  prefs: []
  type: TYPE_NORMAL
- en: As a good example of the MVC pattern, consider the way files are displayed
  prefs: []
  type: TYPE_NORMAL
- en: in the macOS Finder or the Windows File Explorer. Say we have a folder that
  prefs: []
  type: TYPE_NORMAL
- en: contains four files and a subfolder. The end user can choose to display these
  prefs: []
  type: TYPE_NORMAL
- en: items as a list, as in Figure 17-1\.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 17-1: Files in a folder shown as a list*'
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, the user can choose to display the same items as icons, as
  prefs: []
  type: TYPE_NORMAL
- en: in Figure 17-2\.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 17-2: Files in a folder shown as icons*'
  prefs: []
  type: TYPE_NORMAL
- en: The underlying data for both displays is identical, but the representa-
  prefs: []
  type: TYPE_NORMAL
- en: tion of the information to the user is different. In this example, the data
    is
  prefs: []
  type: TYPE_NORMAL
- en: the list of files and subfolders; it’s kept in a model object. The view object
  prefs: []
  type: TYPE_NORMAL
- en: 'displays the data in whatever way the user chooses: as a list, as icons, as
    a'
  prefs: []
  type: TYPE_NORMAL
- en: detailed list, and so on. The controller tells the view to display the informa-
  prefs: []
  type: TYPE_NORMAL
- en: tion in the layout chosen by the user.
  prefs: []
  type: TYPE_NORMAL
- en: '***Statistical Display Example***'
  prefs: []
  type: TYPE_NORMAL
- en: As a more extensive example of the MVC pattern, let’s consider a program
  prefs: []
  type: TYPE_NORMAL
- en: that simulates rolling a pair of dice many times and shows the results. In
  prefs: []
  type: TYPE_NORMAL
- en: '**368** Chapter 17'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 56](index-398_1.png)'
  prefs: []
  type: TYPE_IMG
- en: each roll we’ll add the values of the two dice, so the sum—which we’ll call
  prefs: []
  type: TYPE_NORMAL
- en: an *outcome*—must be between 2 and 12\. The data consists of the count of
  prefs: []
  type: TYPE_NORMAL
- en: the number of times each outcome is rolled and the percentage of the
  prefs: []
  type: TYPE_NORMAL
- en: total number of rolls each outcome makes up. The program can display
  prefs: []
  type: TYPE_NORMAL
- en: 'this data in three different representations: a bar chart, a pie chart, and
    a'
  prefs: []
  type: TYPE_NORMAL
- en: text table. It defaults to a bar chart and displays the result after simulating
  prefs: []
  type: TYPE_NORMAL
- en: rolling a pair of dice 2,500 times. Since this program is just intended as
  prefs: []
  type: TYPE_NORMAL
- en: a working demonstration of the MVC pattern, we’ll generate the output
  prefs: []
  type: TYPE_NORMAL
- en: using pygame and pygwidgets. For more professional-looking charts and
  prefs: []
  type: TYPE_NORMAL
- en: displays, I suggest that you look into Python data visualization libraries
  prefs: []
  type: TYPE_NORMAL
- en: such as Matplotlib, Seaborn, Plotly, Bokeh, and others that are designed
  prefs: []
  type: TYPE_NORMAL
- en: for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17-3 shows the data displayed as a bar chart.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 17-3: Dice roll data as a bar chart*'
  prefs: []
  type: TYPE_NORMAL
- en: Beneath each bar is the outcome, the count of the number of times that
  prefs: []
  type: TYPE_NORMAL
- en: outcome was rolled, and the percentage of the total number of rolls that
  prefs: []
  type: TYPE_NORMAL
- en: count represents. The height of each bar corresponds to the count (or per-
  prefs: []
  type: TYPE_NORMAL
- en: centage). Clicking Roll Dice runs the simulation again, using the number
  prefs: []
  type: TYPE_NORMAL
- en: of rolls specified in the input field. The user can click the different radio
  prefs: []
  type: TYPE_NORMAL
- en: buttons to show different views of the same data. If the user selects the Pie
  prefs: []
  type: TYPE_NORMAL
- en: Chart radio button, the data is displayed as in Figure 17-4\.
  prefs: []
  type: TYPE_NORMAL
- en: Design Patterns and Wrap-Up **369**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 57](index-399_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '![Image 58](index-399_2.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: Dice roll data as a pie chart*'
  prefs: []
  type: TYPE_NORMAL
- en: If the user selects the Text radio button, the data is displayed as in
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17-5\.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 17-5: Dice roll data as text*'
  prefs: []
  type: TYPE_NORMAL
- en: '**370** Chapter 17'
  prefs: []
  type: TYPE_NORMAL
- en: The user can change the value in the “Number of rolls” field to roll the dice
    as many times as they wish. This data in this program is based on statistics
  prefs: []
  type: TYPE_NORMAL
- en: and randomness. With different sample sizes the exact counts will obviously
  prefs: []
  type: TYPE_NORMAL
- en: vary, but the percentages should always be approximately the same.
  prefs: []
  type: TYPE_NORMAL
- en: I won’t show the full listing of the program here, but will focus on a few
  prefs: []
  type: TYPE_NORMAL
- en: key lines that demonstrate the setup and the flow of control in the MVC
  prefs: []
  type: TYPE_NORMAL
- en: pattern. The full program is available for download with the rest of the
  prefs: []
  type: TYPE_NORMAL
- en: book’s resources, in the *MVC_RollTheDice* folder. The folder contains the
  prefs: []
  type: TYPE_NORMAL
- en: 'following files:'
  prefs: []
  type: TYPE_NORMAL
- en: '***Main_MVC.py***The main Python file'
  prefs: []
  type: TYPE_NORMAL
- en: '***Controller.py***Contains the Controller class'
  prefs: []
  type: TYPE_NORMAL
- en: '***Model.py***Contains the Model class'
  prefs: []
  type: TYPE_NORMAL
- en: '***BarView.py***Contains the BarView class that displays the bar chart'
  prefs: []
  type: TYPE_NORMAL
- en: '***Bin.py***Contains the Bin class that draws a single bar in the bar chart'
  prefs: []
  type: TYPE_NORMAL
- en: '***PieView.py***Contains the PieView class that displays the pie chart'
  prefs: []
  type: TYPE_NORMAL
- en: '***TextView.py***Contains the TextView class that displays the text view'
  prefs: []
  type: TYPE_NORMAL
- en: '***Constants.py***Contains constants that are shared by multiple modules The
    main program instantiates a Controller object and runs the main'
  prefs: []
  type: TYPE_NORMAL
- en: loop. Code in the main loop forwards all events (other than the pygame.QUIT
  prefs: []
  type: TYPE_NORMAL
- en: event) to the controller to handle.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Controller**'
  prefs: []
  type: TYPE_NORMAL
- en: The controller is the supervisor of the whole program. It starts by instan-
  prefs: []
  type: TYPE_NORMAL
- en: tiating the Model object. It then instantiates one of each of the different
  prefs: []
  type: TYPE_NORMAL
- en: 'view objects: BarView, PieView, and TextView. Here is the startup code in the'
  prefs: []
  type: TYPE_NORMAL
- en: '__init__() method of the Controller class:'
  prefs: []
  type: TYPE_NORMAL
- en: Instantiate the model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: self.oModel = Model()
  prefs: []
  type: TYPE_NORMAL
- en: Instantiate different view objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: self.oBarView = BarView(self.window, self.oModel)
  prefs: []
  type: TYPE_NORMAL
- en: self.oPieView = PieView(self.window, self.oModel)
  prefs: []
  type: TYPE_NORMAL
- en: self.oTextView = TextView(self.window, self.oModel)
  prefs: []
  type: TYPE_NORMAL
- en: When the Controller object instantiates these View objects, it passes in
  prefs: []
  type: TYPE_NORMAL
- en: the Model object so each View object can request information directly from
  prefs: []
  type: TYPE_NORMAL
- en: the model. Different implementations of the MVC pattern might handle
  prefs: []
  type: TYPE_NORMAL
- en: communication between these three elements differently; for example, a
  prefs: []
  type: TYPE_NORMAL
- en: controller could act as an intermediary, requesting data from the model
  prefs: []
  type: TYPE_NORMAL
- en: and forwarding it on to the current view, rather than allowing the model
  prefs: []
  type: TYPE_NORMAL
- en: and view to communicate directly.
  prefs: []
  type: TYPE_NORMAL
- en: The controller draws and reacts to everything outside the black rectan-
  prefs: []
  type: TYPE_NORMAL
- en: gle in the window, including the title, the image of the dice, and the radio
  prefs: []
  type: TYPE_NORMAL
- en: buttons. It draws the Quit and Roll Dice buttons and reacts when they’re
  prefs: []
  type: TYPE_NORMAL
- en: clicked, and it handles any changes the user makes to the number of rolls.
  prefs: []
  type: TYPE_NORMAL
- en: Design Patterns and Wrap-Up **371**
  prefs: []
  type: TYPE_NORMAL
- en: The Controller object keeps a current View object, which determines which view
    is currently displayed. We set it by default to the BarView object
  prefs: []
  type: TYPE_NORMAL
- en: '(the bar chart):'
  prefs: []
  type: TYPE_NORMAL
- en: self.oView = self.oBarView
  prefs: []
  type: TYPE_NORMAL
- en: When the user clicks a radio button, the Controller sets its current View
  prefs: []
  type: TYPE_NORMAL
- en: object to the newly selected view and tells the new View object to update
  prefs: []
  type: TYPE_NORMAL
- en: 'itself by calling its update() method:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.oBarButton.handleEvent(event):'
  prefs: []
  type: TYPE_NORMAL
- en: self.oView = self.oBarView
  prefs: []
  type: TYPE_NORMAL
- en: self.oView.update()
  prefs: []
  type: TYPE_NORMAL
- en: 'elif self.oPieButton.handleEvent(event):'
  prefs: []
  type: TYPE_NORMAL
- en: self.oView = self.oPieView
  prefs: []
  type: TYPE_NORMAL
- en: self.oView.update()
  prefs: []
  type: TYPE_NORMAL
- en: 'elif self.oTextButton.handleEvent(event):'
  prefs: []
  type: TYPE_NORMAL
- en: self.oView = self.oTextView
  prefs: []
  type: TYPE_NORMAL
- en: self.oView.update()
  prefs: []
  type: TYPE_NORMAL
- en: At startup, and whenever the user clicks Roll Dice, the controller vali-
  prefs: []
  type: TYPE_NORMAL
- en: dates the number of rolls specified in the “Number of rolls” field and tells
  prefs: []
  type: TYPE_NORMAL
- en: 'the model to generate new data:'
  prefs: []
  type: TYPE_NORMAL
- en: self.oModel.generateRolls(nRounds)
  prefs: []
  type: TYPE_NORMAL
- en: All the views are polymorphic, so in each frame the Controller object
  prefs: []
  type: TYPE_NORMAL
- en: 'calls the draw() method of the current View object:'
  prefs: []
  type: TYPE_NORMAL
- en: 'self.oView.draw() # tell the current view to draw itself'
  prefs: []
  type: TYPE_NORMAL
- en: '**The Model**'
  prefs: []
  type: TYPE_NORMAL
- en: The model is responsible for obtaining (and potentially updating) informa-
  prefs: []
  type: TYPE_NORMAL
- en: 'tion. In this program, the Model object is simple: it simulates rolling a pair'
  prefs: []
  type: TYPE_NORMAL
- en: of dice many times, stores the results in instance variables, and reports the
  prefs: []
  type: TYPE_NORMAL
- en: data when a View object requests it.
  prefs: []
  type: TYPE_NORMAL
- en: When asked to generate data, the model runs a loop simulating rolling
  prefs: []
  type: TYPE_NORMAL
- en: 'the dice and stores its data in two dictionaries: self.rollsDict, which uses'
  prefs: []
  type: TYPE_NORMAL
- en: each outcome as a key and the count as a value, and self.percentsDict, which
  prefs: []
  type: TYPE_NORMAL
- en: uses each outcome as a key and the percentage of rolls as a value.
  prefs: []
  type: TYPE_NORMAL
- en: In more complex programs, the model could get its data from a data-
  prefs: []
  type: TYPE_NORMAL
- en: base, the internet, or other sources. For example, a Model object could main-
  prefs: []
  type: TYPE_NORMAL
- en: tain stock information, population data, city housing data, temperature
  prefs: []
  type: TYPE_NORMAL
- en: readings, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In this model, the getRoundsRollsPercents() method is called by the
  prefs: []
  type: TYPE_NORMAL
- en: View objects to retrieve all the data at once. However, a model may contain
  prefs: []
  type: TYPE_NORMAL
- en: more information than any one view might need. Therefore, different View
  prefs: []
  type: TYPE_NORMAL
- en: objects can call different methods in the Model object to request different
  prefs: []
  type: TYPE_NORMAL
- en: information from the same model. To support this, in the sample program
  prefs: []
  type: TYPE_NORMAL
- en: '**372** Chapter 17'
  prefs: []
  type: TYPE_NORMAL
- en: I’ve included a number of additional getter methods (getNumberOfRounds(), getRolls(),
    and getPercents()) that a programmer could use when building a
  prefs: []
  type: TYPE_NORMAL
- en: new View object, to get only the data that the new view might want to display.
  prefs: []
  type: TYPE_NORMAL
- en: '**The View**'
  prefs: []
  type: TYPE_NORMAL
- en: A View object is responsible for displaying data to the user. In our sample
  prefs: []
  type: TYPE_NORMAL
- en: program, we have three different View objects that display the same under-
  prefs: []
  type: TYPE_NORMAL
- en: lying information in three different forms; each displays the information
  prefs: []
  type: TYPE_NORMAL
- en: within the black rectangle in the window. At startup, and when the user
  prefs: []
  type: TYPE_NORMAL
- en: clicks Roll Dice, the controller calls the update() method of the current View
  prefs: []
  type: TYPE_NORMAL
- en: object. All View objects then make the same call to the Model object to get
    the
  prefs: []
  type: TYPE_NORMAL
- en: 'current data:'
  prefs: []
  type: TYPE_NORMAL
- en: nRounds, resultsDict, percentsDict = self.oModel.getRoundsRollsPercents()
  prefs: []
  type: TYPE_NORMAL
- en: The View object then formats the data in its own way and presents it to
  prefs: []
  type: TYPE_NORMAL
- en: the user.
  prefs: []
  type: TYPE_NORMAL
- en: '***Advantages of the MVC Pattern***'
  prefs: []
  type: TYPE_NORMAL
- en: The MVC design pattern breaks up responsibility into separate classes that
  prefs: []
  type: TYPE_NORMAL
- en: act independently but work collectively. Building the components as dis-
  prefs: []
  type: TYPE_NORMAL
- en: tinct classes and minimizing the interactions between the resulting objects
  prefs: []
  type: TYPE_NORMAL
- en: allows each individual component to be less complex and less error prone.
  prefs: []
  type: TYPE_NORMAL
- en: Once the interface of each component is defined, the code of the classes
  prefs: []
  type: TYPE_NORMAL
- en: can even be written by different programmers.
  prefs: []
  type: TYPE_NORMAL
- en: With the MVC approach, each component demonstrates the core OOP
  prefs: []
  type: TYPE_NORMAL
- en: concepts of encapsulation and abstraction. Using an MVC object structure,
  prefs: []
  type: TYPE_NORMAL
- en: the model can change the way it represents the data internally without
  prefs: []
  type: TYPE_NORMAL
- en: affecting the controller or the view. As mentioned previously, the model
  prefs: []
  type: TYPE_NORMAL
- en: might contain more data than any single view needs. And as long as the
  prefs: []
  type: TYPE_NORMAL
- en: controller doesn’t change the way it communicates with the model, and
  prefs: []
  type: TYPE_NORMAL
- en: the model continues to return the requested information to the view in an
  prefs: []
  type: TYPE_NORMAL
- en: agreed-upon way, the model can add new data without breaking the system.
  prefs: []
  type: TYPE_NORMAL
- en: The MVC model also makes it easy to add enhancements. For example,
  prefs: []
  type: TYPE_NORMAL
- en: in our dice-rolling program, the model could keep track of the count of the
  prefs: []
  type: TYPE_NORMAL
- en: different combinations of rolls of the two dice that make up each outcome,
  prefs: []
  type: TYPE_NORMAL
- en: such as getting a 5 by rolling a 1 and a 4 or a 2 and a 3\. We could then mod-
  prefs: []
  type: TYPE_NORMAL
- en: ify the BarChart view to obtain this additional information from the model
  prefs: []
  type: TYPE_NORMAL
- en: and show each bar split into smaller bars to display the percentages of each
  prefs: []
  type: TYPE_NORMAL
- en: combination.
  prefs: []
  type: TYPE_NORMAL
- en: Each of the View objects is entirely customizable. The TextView could use
  prefs: []
  type: TYPE_NORMAL
- en: different fonts and font sizes, or a different layout. The PieView could show
  prefs: []
  type: TYPE_NORMAL
- en: the wedges in different colors. The bars in the BarView could be thicker or
  prefs: []
  type: TYPE_NORMAL
- en: taller, or be shown in different colors, or even be displayed horizontally.
  prefs: []
  type: TYPE_NORMAL
- en: Any such changes would be made only in the appropriate View object, com-
  prefs: []
  type: TYPE_NORMAL
- en: pletely independent of the model or the controller.
  prefs: []
  type: TYPE_NORMAL
- en: Design Patterns and Wrap-Up **373**
  prefs: []
  type: TYPE_NORMAL
- en: The MVC pattern also makes it easy to add a new way to view the data, by writing
    a new View class. The only additional changes required would be
  prefs: []
  type: TYPE_NORMAL
- en: to have the controller draw another radio button, instantiate the new View
  prefs: []
  type: TYPE_NORMAL
- en: object, and call the new View object’s update() method when the user selects
  prefs: []
  type: TYPE_NORMAL
- en: the new view.
  prefs: []
  type: TYPE_NORMAL
- en: '**N O T E**'
  prefs: []
  type: TYPE_NORMAL
- en: '*MVC and other design patterns are independent of any specific computer language*
    *and can be used in any language that supports OOP. If you’re interested in learning*
    *more, I suggest that you search the web for OOP design patterns such as the Factory,*
    *Flyweight, Observer, and Visitor patterns; there are numerous video and text
    tutorials (as well as books) available on all of these. For a general introduction,*
    Design Patterns: Elements of Reusable Object-Oriented Software *(Addison-Wesley)
    by*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides (the Gang of
    Four)* *is considered the bible of design patterns.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Wrap-Up**'
  prefs: []
  type: TYPE_NORMAL
- en: When thinking about object-oriented programming, remember my initial
  prefs: []
  type: TYPE_NORMAL
- en: 'definition of an object: data plus code that acts on that data over time.'
  prefs: []
  type: TYPE_NORMAL
- en: OOP gives you a new way to think about programming, offering an easy
  prefs: []
  type: TYPE_NORMAL
- en: and convenient way to group together data and code that acts on that data.
  prefs: []
  type: TYPE_NORMAL
- en: You write classes and instantiate objects from those classes. Each object gets
  prefs: []
  type: TYPE_NORMAL
- en: a set of all instance variables defined in the class, but the instance variables
  prefs: []
  type: TYPE_NORMAL
- en: in different objects can contain different data and remain independent of
  prefs: []
  type: TYPE_NORMAL
- en: each other. The methods of the objects can work differently because they’re
  prefs: []
  type: TYPE_NORMAL
- en: working on different data. Objects can be instantiated at any time and can
  prefs: []
  type: TYPE_NORMAL
- en: be destroyed at any time.
  prefs: []
  type: TYPE_NORMAL
- en: When instantiating multiple objects from one class, you typically build
  prefs: []
  type: TYPE_NORMAL
- en: a list or dictionary of objects, then later iterate over that list or dictionary,
  prefs: []
  type: TYPE_NORMAL
- en: calling methods of each object.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a final reminder, the three main tenets of OOP are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Encapsulation** Everything in one place, objects own their data.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Polymorphism** Different objects can implement the same methods.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Inheritance** A class can extend or modify the behavior of another class.'
  prefs: []
  type: TYPE_NORMAL
- en: Objects often work in hierarchies; they can use composition to instanti-
  prefs: []
  type: TYPE_NORMAL
- en: ate other objects and can call methods of lower-level objects to ask them to
  prefs: []
  type: TYPE_NORMAL
- en: do work or provide information.
  prefs: []
  type: TYPE_NORMAL
- en: To give you a clear visual representation of OOP in action, most of the
  prefs: []
  type: TYPE_NORMAL
- en: examples in this book focused on widgets and other objects that can be
  prefs: []
  type: TYPE_NORMAL
- en: useful in a gaming environment. I developed the pygwidgets and pyghelpers
  prefs: []
  type: TYPE_NORMAL
- en: packages to demonstrate many different OOP techniques and to allow you
  prefs: []
  type: TYPE_NORMAL
- en: to easily use GUI widgets in pygame programs. I hope you find these pack-
  prefs: []
  type: TYPE_NORMAL
- en: ages useful and go on to use them to develop fun or useful programs of
  prefs: []
  type: TYPE_NORMAL
- en: your own.
  prefs: []
  type: TYPE_NORMAL
- en: '**374** Chapter 17'
  prefs: []
  type: TYPE_NORMAL
- en: More importantly, I hope that you recognize that object-oriented programming
    is a general-purpose approach that can be applied in a wide
  prefs: []
  type: TYPE_NORMAL
- en: variety of circumstances. Any time you see two or more functions that need
  prefs: []
  type: TYPE_NORMAL
- en: to operate on a shared set of data, you should consider building a class and
  prefs: []
  type: TYPE_NORMAL
- en: instantiating an object. You may also want to consider building an object
  prefs: []
  type: TYPE_NORMAL
- en: manager object to manage a group of objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'With all that said, I’d like to offer my congratulations: you’ve made it'
  prefs: []
  type: TYPE_NORMAL
- en: to the end of the book! Although actually, this should be considered the
  prefs: []
  type: TYPE_NORMAL
- en: beginning of your journey into object-oriented programming. Hopefully,
  prefs: []
  type: TYPE_NORMAL
- en: the concepts described in this book have given you a framework that you
  prefs: []
  type: TYPE_NORMAL
- en: can build on—but the only way to truly get a handle on how OOP works
  prefs: []
  type: TYPE_NORMAL
- en: is to write lots and lots of code. Over time, you will start to notice patterns
  prefs: []
  type: TYPE_NORMAL
- en: that you will use again and again in your code. Understanding how to struc-
  prefs: []
  type: TYPE_NORMAL
- en: ture your classes is a difficult process. Only through experience will it begin
  prefs: []
  type: TYPE_NORMAL
- en: to become easier to ensure that you have the proper methods and instance
  prefs: []
  type: TYPE_NORMAL
- en: variables in the correct classes.
  prefs: []
  type: TYPE_NORMAL
- en: Practice, practice, practice!
  prefs: []
  type: TYPE_NORMAL
- en: Design Patterns and Wrap-Up **375**
  prefs: []
  type: TYPE_NORMAL
- en: '**I N D E X**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Symbols**'
  prefs: []
  type: TYPE_NORMAL
- en: Animation class, 149, 304–306
  prefs: []
  type: TYPE_NORMAL
- en: + operator example, polymorphism,
  prefs: []
  type: TYPE_NORMAL
- en: animation classes
  prefs: []
  type: TYPE_NORMAL
- en: 193–194
  prefs: []
  type: TYPE_NORMAL
- en: building, 296–304
  prefs: []
  type: TYPE_NORMAL
- en: '* (asterisk), using with import'
  prefs: []
  type: TYPE_NORMAL
- en: merging, 304
  prefs: []
  type: TYPE_NORMAL
- en: statement, 61
  prefs: []
  type: TYPE_NORMAL
- en: in pygwidgets, 304–309
  prefs: []
  type: TYPE_NORMAL
- en: '@ (at) property, 174–177'
  prefs: []
  type: TYPE_NORMAL
- en: SimpleAnimation class, 296–300
  prefs: []
  type: TYPE_NORMAL
- en: == (equal to), magic method
  prefs: []
  type: TYPE_NORMAL
- en: SimpleSpriteSheetAnimation class,
  prefs: []
  type: TYPE_NORMAL
- en: name, 196
  prefs: []
  type: TYPE_NORMAL
- en: 300–304
  prefs: []
  type: TYPE_NORMAL
- en: (greater than), magic method
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: animation program, pygwidgets
  prefs: []
  type: TYPE_NORMAL
- en: name, 196
  prefs: []
  type: TYPE_NORMAL
- en: package, 308–309
  prefs: []
  type: TYPE_NORMAL
- en: '>= (greater than or equal to), magic'
  prefs: []
  type: TYPE_NORMAL
- en: Answer dialogs, Dodger game, 345–347
  prefs: []
  type: TYPE_NORMAL
- en: method name, 196
  prefs: []
  type: TYPE_NORMAL
- en: anti-aliased line, drawing, 118
  prefs: []
  type: TYPE_NORMAL
- en: < (less than), magic method
  prefs: []
  type: TYPE_NORMAL
- en: API (application programming
  prefs: []
  type: TYPE_NORMAL
- en: name, 196
  prefs: []
  type: TYPE_NORMAL
- en: interface), 137, 158
  prefs: []
  type: TYPE_NORMAL
- en: <= (less than or equal to), magic
  prefs: []
  type: TYPE_NORMAL
- en: arc, drawing, 118
  prefs: []
  type: TYPE_NORMAL
- en: method name, 196
  prefs: []
  type: TYPE_NORMAL
- en: arguments
  prefs: []
  type: TYPE_NORMAL
- en: '!= (not equal to), magic method'
  prefs: []
  type: TYPE_NORMAL
- en: methods and parameters, 144
  prefs: []
  type: TYPE_NORMAL
- en: name, 196
  prefs: []
  type: TYPE_NORMAL
- en: passing to methods, 40–41
  prefs: []
  type: TYPE_NORMAL
- en: rearranging in calls to methods,
  prefs: []
  type: TYPE_NORMAL
- en: '**A**'
  prefs: []
  type: TYPE_NORMAL
- en: '53'
  prefs: []
  type: TYPE_NORMAL
- en: abc (abstract base class) module,
  prefs: []
  type: TYPE_NORMAL
- en: asterisk (*), using with import
  prefs: []
  type: TYPE_NORMAL
- en: Python Standard Library, 232
  prefs: []
  type: TYPE_NORMAL
- en: statement, 61
  prefs: []
  type: TYPE_NORMAL
- en: AbortTransaction exception, 79, 81
  prefs: []
  type: TYPE_NORMAL
- en: at (@) property, 174–177
  prefs: []
  type: TYPE_NORMAL
- en: absolute path, using with pygame, 101
  prefs: []
  type: TYPE_NORMAL
- en: abstract base class (abc) module,
  prefs: []
  type: TYPE_NORMAL
- en: '**B**'
  prefs: []
  type: TYPE_NORMAL
- en: Python Standard Library, 232
  prefs: []
  type: TYPE_NORMAL
- en: background music, playing in pygame,
  prefs: []
  type: TYPE_NORMAL
- en: abstract classes and methods, 231–234\.
  prefs: []
  type: TYPE_NORMAL
- en: 115–116
  prefs: []
  type: TYPE_NORMAL
- en: '*See also* classes; methods'
  prefs: []
  type: TYPE_NORMAL
- en: Baddies and Goodies, 347
  prefs: []
  type: TYPE_NORMAL
- en: abstraction, 179–181
  prefs: []
  type: TYPE_NORMAL
- en: Ball class, 122–125
  prefs: []
  type: TYPE_NORMAL
- en: Account class
  prefs: []
  type: TYPE_NORMAL
- en: Ball objects, creating, 125–127
  prefs: []
  type: TYPE_NORMAL
- en: error handling in, 59
  prefs: []
  type: TYPE_NORMAL
- en: Balloon game
  prefs: []
  type: TYPE_NORMAL
- en: with exceptions, 78–79
  prefs: []
  type: TYPE_NORMAL
- en: main code, 252–256
  prefs: []
  type: TYPE_NORMAL
- en: testing, 62
  prefs: []
  type: TYPE_NORMAL
- en: module of constants, 253
  prefs: []
  type: TYPE_NORMAL
- en: Account objects, 59, 71
  prefs: []
  type: TYPE_NORMAL
- en: object diagram, 252
  prefs: []
  type: TYPE_NORMAL
- en: dictionary of, 66–67
  prefs: []
  type: TYPE_NORMAL
- en: project folder, 252
  prefs: []
  type: TYPE_NORMAL
- en: in lists, 64–66
  prefs: []
  type: TYPE_NORMAL
- en: screenshot, 251
  prefs: []
  type: TYPE_NORMAL
- en: accounts, creating, 62–64
  prefs: []
  type: TYPE_NORMAL
- en: source files, 252
  prefs: []
  type: TYPE_NORMAL
- en: Alert dialog, Dodger game, 343
  prefs: []
  type: TYPE_NORMAL
- en: balloon manager, 256–258
  prefs: []
  type: TYPE_NORMAL
- en: angle brackets (<>), values in, 16
  prefs: []
  type: TYPE_NORMAL
- en: Balloon sample program, 251–261
  prefs: []
  type: TYPE_NORMAL
- en: Balloon class and objects,
  prefs: []
  type: TYPE_NORMAL
- en: inside vs. outside, 164–165
  prefs: []
  type: TYPE_NORMAL
- en: 258–261
  prefs: []
  type: TYPE_NORMAL
- en: making available, 29–30
  prefs: []
  type: TYPE_NORMAL
- en: bank account class, 58–60
  prefs: []
  type: TYPE_NORMAL
- en: and methods, 51
  prefs: []
  type: TYPE_NORMAL
- en: bank account simulations. *See also*
  prefs: []
  type: TYPE_NORMAL
- en: and objects, 23–25
  prefs: []
  type: TYPE_NORMAL
- en: procedural implementations
  prefs: []
  type: TYPE_NORMAL
- en: objects and instantiation, 25–33
  prefs: []
  type: TYPE_NORMAL
- en: operations and data, 7–8
  prefs: []
  type: TYPE_NORMAL
- en: representing physical objects as,
  prefs: []
  type: TYPE_NORMAL
- en: table of data, 15–16
  prefs: []
  type: TYPE_NORMAL
- en: 35–44
  prefs: []
  type: TYPE_NORMAL
- en: Bank class, 70, 79–81
  prefs: []
  type: TYPE_NORMAL
- en: in use, 45
  prefs: []
  type: TYPE_NORMAL
- en: Bank object, 70–71, 82
  prefs: []
  type: TYPE_NORMAL
- en: writing, 26–27
  prefs: []
  type: TYPE_NORMAL
- en: bank program, using exceptions in,
  prefs: []
  type: TYPE_NORMAL
- en: class hierarchy, inheritance, 236–238
  prefs: []
  type: TYPE_NORMAL
- en: 78–83
  prefs: []
  type: TYPE_NORMAL
- en: class scope, 27
  prefs: []
  type: TYPE_NORMAL
- en: base class, inheritance, 212–214,
  prefs: []
  type: TYPE_NORMAL
- en: class statement, inheritance, 216
  prefs: []
  type: TYPE_NORMAL
- en: 227–231
  prefs: []
  type: TYPE_NORMAL
- en: class variables. *See also* variables
  prefs: []
  type: TYPE_NORMAL
- en: Blackjack deck, 278
  prefs: []
  type: TYPE_NORMAL
- en: constants, 249–250
  prefs: []
  type: TYPE_NORMAL
- en: blit() method, 102, 114, 124, 137
  prefs: []
  type: TYPE_NORMAL
- en: for counting, 250
  prefs: []
  type: TYPE_NORMAL
- en: Boolean True, 105
  prefs: []
  type: TYPE_NORMAL
- en: creating, 248–249
  prefs: []
  type: TYPE_NORMAL
- en: Button class, building, 128–130
  prefs: []
  type: TYPE_NORMAL
- en: client code
  prefs: []
  type: TYPE_NORMAL
- en: buttons, building, 131–132
  prefs: []
  type: TYPE_NORMAL
- en: explained, 164
  prefs: []
  type: TYPE_NORMAL
- en: using direct access, 170
  prefs: []
  type: TYPE_NORMAL
- en: '**C**'
  prefs: []
  type: TYPE_NORMAL
- en: collidepoint(), 104
  prefs: []
  type: TYPE_NORMAL
- en: callbacks, 137–141
  prefs: []
  type: TYPE_NORMAL
- en: comparison operator magic methods,
  prefs: []
  type: TYPE_NORMAL
- en: CanastaDeck class, 279
  prefs: []
  type: TYPE_NORMAL
- en: 195–196
  prefs: []
  type: TYPE_NORMAL
- en: Card class, 268–270
  prefs: []
  type: TYPE_NORMAL
- en: '*composition*, 71'
  prefs: []
  type: TYPE_NORMAL
- en: card games. *See also* Higher or Lower
  prefs: []
  type: TYPE_NORMAL
- en: '*composition* and inheritance, 238'
  prefs: []
  type: TYPE_NORMAL
- en: card game
  prefs: []
  type: TYPE_NORMAL
- en: Controller object, 371–372
  prefs: []
  type: TYPE_NORMAL
- en: Blackjack, 278
  prefs: []
  type: TYPE_NORMAL
- en: CountDownTimer class, 293–294
  prefs: []
  type: TYPE_NORMAL
- en: Card class, 268–270
  prefs: []
  type: TYPE_NORMAL
- en: counting objects, 250
  prefs: []
  type: TYPE_NORMAL
- en: Deck class, 270–272
  prefs: []
  type: TYPE_NORMAL
- en: CountUpTimer class, pyghelpers package,
  prefs: []
  type: TYPE_NORMAL
- en: Higher or Lower game, 272–276
  prefs: []
  type: TYPE_NORMAL
- en: 291–293
  prefs: []
  type: TYPE_NORMAL
- en: testing with __name__, 276–278
  prefs: []
  type: TYPE_NORMAL
- en: '*CPython*, 242'
  prefs: []
  type: TYPE_NORMAL
- en: with unusual decks, 279
  prefs: []
  type: TYPE_NORMAL
- en: customAnswerDialog dialog, Dodger
  prefs: []
  type: TYPE_NORMAL
- en: Cartesian coordinate system,
  prefs: []
  type: TYPE_NORMAL
- en: game, 347
  prefs: []
  type: TYPE_NORMAL
- en: 91–95, 201
  prefs: []
  type: TYPE_NORMAL
- en: CustomButton class, 148, 235–236
  prefs: []
  type: TYPE_NORMAL
- en: catching exceptions, 76
  prefs: []
  type: TYPE_NORMAL
- en: CustomCheckBox class, pygwidgets
  prefs: []
  type: TYPE_NORMAL
- en: child class, inheritance, 212
  prefs: []
  type: TYPE_NORMAL
- en: package, 149
  prefs: []
  type: TYPE_NORMAL
- en: circle, drawing, 119
  prefs: []
  type: TYPE_NORMAL
- en: CustomRadioButton class, pygwidgets
  prefs: []
  type: TYPE_NORMAL
- en: Circle class, 187–190, 227, 230
  prefs: []
  type: TYPE_NORMAL
- en: package, 149
  prefs: []
  type: TYPE_NORMAL
- en: class code, importing, 60–61
  prefs: []
  type: TYPE_NORMAL
- en: customYesNoDialog dialog, Dodger
  prefs: []
  type: TYPE_NORMAL
- en: classes. *See also* abstract classes and
  prefs: []
  type: TYPE_NORMAL
- en: game, 345
  prefs: []
  type: TYPE_NORMAL
- en: methods
  prefs: []
  type: TYPE_NORMAL
- en: building, 33–35
  prefs: []
  type: TYPE_NORMAL
- en: '**D**'
  prefs: []
  type: TYPE_NORMAL
- en: creating instances from, 31–32
  prefs: []
  type: TYPE_NORMAL
- en: data, validating, 168–170
  prefs: []
  type: TYPE_NORMAL
- en: creating objects from, 28–30
  prefs: []
  type: TYPE_NORMAL
- en: databases, accessing with objects and
  prefs: []
  type: TYPE_NORMAL
- en: form of, 26
  prefs: []
  type: TYPE_NORMAL
- en: XTRAS, 178–179
  prefs: []
  type: TYPE_NORMAL
- en: implementing data types as, 32–33
  prefs: []
  type: TYPE_NORMAL
- en: data types, implementation as classes,
  prefs: []
  type: TYPE_NORMAL
- en: and inheritance, 212–213
  prefs: []
  type: TYPE_NORMAL
- en: 32–33
  prefs: []
  type: TYPE_NORMAL
- en: inheriting from same base class,
  prefs: []
  type: TYPE_NORMAL
- en: debugging approach, 203
  prefs: []
  type: TYPE_NORMAL
- en: 227–231
  prefs: []
  type: TYPE_NORMAL
- en: Deck class, 270–272
  prefs: []
  type: TYPE_NORMAL
- en: '**378** Index'
  prefs: []
  type: TYPE_NORMAL
- en: decorators and at (@) property,
  prefs: []
  type: TYPE_NORMAL
- en: with functions, 164
  prefs: []
  type: TYPE_NORMAL
- en: 174–177
  prefs: []
  type: TYPE_NORMAL
- en: interpretations of, 165–172
  prefs: []
  type: TYPE_NORMAL
- en: __del__() method, 246–248, 260
  prefs: []
  type: TYPE_NORMAL
- en: making instance variables more
  prefs: []
  type: TYPE_NORMAL
- en: design patterns, MVC (Model View
  prefs: []
  type: TYPE_NORMAL
- en: private, 172–173
  prefs: []
  type: TYPE_NORMAL
- en: Controller), 367–374
  prefs: []
  type: TYPE_NORMAL
- en: with objects, 164–165
  prefs: []
  type: TYPE_NORMAL
- en: dice roll data, MVC (Model View
  prefs: []
  type: TYPE_NORMAL
- en: in pygwidgets classes, 177
  prefs: []
  type: TYPE_NORMAL
- en: Controller) design pattern,
  prefs: []
  type: TYPE_NORMAL
- en: enter() method used with scenes, 325
  prefs: []
  type: TYPE_NORMAL
- en: 369–370
  prefs: []
  type: TYPE_NORMAL
- en: __eq__() magic method name, 196,
  prefs: []
  type: TYPE_NORMAL
- en: __dict__ dictionary, 261–263
  prefs: []
  type: TYPE_NORMAL
- en: 198–199
  prefs: []
  type: TYPE_NORMAL
- en: dictionary
  prefs: []
  type: TYPE_NORMAL
- en: equal to (==), magic method name, 196
  prefs: []
  type: TYPE_NORMAL
- en: of account objects, 66–67
  prefs: []
  type: TYPE_NORMAL
- en: error handling
  prefs: []
  type: TYPE_NORMAL
- en: using with instance variables,
  prefs: []
  type: TYPE_NORMAL
- en: in Account class, 59
  prefs: []
  type: TYPE_NORMAL
- en: 261–263
  prefs: []
  type: TYPE_NORMAL
- en: with exceptions, 76–78
  prefs: []
  type: TYPE_NORMAL
- en: DimmerSwitch class, 33, 48–50, 52–53
  prefs: []
  type: TYPE_NORMAL
- en: event-driven programs, 95–96
  prefs: []
  type: TYPE_NORMAL
- en: DimmerSwitch objects, creating, 50, 53
  prefs: []
  type: TYPE_NORMAL
- en: event loop, 99
  prefs: []
  type: TYPE_NORMAL
- en: direct access, avoiding, 166–170
  prefs: []
  type: TYPE_NORMAL
- en: except and try, 76–77
  prefs: []
  type: TYPE_NORMAL
- en: Director from Macromedia project, 178
  prefs: []
  type: TYPE_NORMAL
- en: exceptions
  prefs: []
  type: TYPE_NORMAL
- en: DisplayMoney class, 222–227
  prefs: []
  type: TYPE_NORMAL
- en: in bank program, 78–83
  prefs: []
  type: TYPE_NORMAL
- en: DisplayText class, 149, 222
  prefs: []
  type: TYPE_NORMAL
- en: error handling with, 76–78
  prefs: []
  type: TYPE_NORMAL
- en: Dodger game
  prefs: []
  type: TYPE_NORMAL
- en: handling, 81–83
  prefs: []
  type: TYPE_NORMAL
- en: Alert dialog, 343
  prefs: []
  type: TYPE_NORMAL
- en: Answer dialogs, 345–347
  prefs: []
  type: TYPE_NORMAL
- en: '**F**'
  prefs: []
  type: TYPE_NORMAL
- en: customAnswerDialog dialog, 347
  prefs: []
  type: TYPE_NORMAL
- en: file display example, 368
  prefs: []
  type: TYPE_NORMAL
- en: customYesNoDialog dialog, 345
  prefs: []
  type: TYPE_NORMAL
- en: Fraction class, magic methods,
  prefs: []
  type: TYPE_NORMAL
- en: extensions to, 366
  prefs: []
  type: TYPE_NORMAL
- en: 205–208
  prefs: []
  type: TYPE_NORMAL
- en: implementation, 348
  prefs: []
  type: TYPE_NORMAL
- en: functions
  prefs: []
  type: TYPE_NORMAL
- en: modal dialogs, 342–347
  prefs: []
  type: TYPE_NORMAL
- en: encapsulation with, 164
  prefs: []
  type: TYPE_NORMAL
- en: overview, 347
  prefs: []
  type: TYPE_NORMAL
- en: len(), 164
  prefs: []
  type: TYPE_NORMAL
- en: ScenePlay class, 351–355
  prefs: []
  type: TYPE_NORMAL
- en: vs. methods, 28
  prefs: []
  type: TYPE_NORMAL
- en: textYesNoDialog dialog, 343
  prefs: []
  type: TYPE_NORMAL
- en: super(), 216
  prefs: []
  type: TYPE_NORMAL
- en: Yes/No dialog, 344
  prefs: []
  type: TYPE_NORMAL
- en: vars(), 52
  prefs: []
  type: TYPE_NORMAL
- en: Don’t Repeat Yourself (DRY), 253
  prefs: []
  type: TYPE_NORMAL
- en: Dragger class, pygwidgets package, 149
  prefs: []
  type: TYPE_NORMAL
- en: '**G**'
  prefs: []
  type: TYPE_NORMAL
- en: drawing shapes, 116–120
  prefs: []
  type: TYPE_NORMAL
- en: Game class, 274
  prefs: []
  type: TYPE_NORMAL
- en: draw() method used with pygwidgets,
  prefs: []
  type: TYPE_NORMAL
- en: Game object, 272
  prefs: []
  type: TYPE_NORMAL
- en: 150, 155, 157, 193, 308
  prefs: []
  type: TYPE_NORMAL
- en: games, transient objects in, 242
  prefs: []
  type: TYPE_NORMAL
- en: draw() method used with scenes, 325
  prefs: []
  type: TYPE_NORMAL
- en: garbage collection, 248
  prefs: []
  type: TYPE_NORMAL
- en: draw.rect(), 187
  prefs: []
  type: TYPE_NORMAL
- en: __ge__() magic method name, 196
  prefs: []
  type: TYPE_NORMAL
- en: DRY (Don’t Repeat Yourself), 253
  prefs: []
  type: TYPE_NORMAL
- en: getrefcount() function, 244
  prefs: []
  type: TYPE_NORMAL
- en: getSceneKey() method used with
  prefs: []
  type: TYPE_NORMAL
- en: '**E**'
  prefs: []
  type: TYPE_NORMAL
- en: scenes, 328
  prefs: []
  type: TYPE_NORMAL
- en: educational project, 178–179
  prefs: []
  type: TYPE_NORMAL
- en: getters and setters, 170–171, 175–176
  prefs: []
  type: TYPE_NORMAL
- en: ellipse, drawing, 119
  prefs: []
  type: TYPE_NORMAL
- en: '*Ghostbusters*, 138'
  prefs: []
  type: TYPE_NORMAL
- en: Ellipse class, 192
  prefs: []
  type: TYPE_NORMAL
- en: GitHub repository, accessing, 157
  prefs: []
  type: TYPE_NORMAL
- en: Employee class, inheritance, 218
  prefs: []
  type: TYPE_NORMAL
- en: global scope, 27
  prefs: []
  type: TYPE_NORMAL
- en: encapsulation
  prefs: []
  type: TYPE_NORMAL
- en: Goodies and Baddies, 347
  prefs: []
  type: TYPE_NORMAL
- en: decorators and @property, 174–177
  prefs: []
  type: TYPE_NORMAL
- en: goToScene() method used with
  prefs: []
  type: TYPE_NORMAL
- en: direct access, 166–172
  prefs: []
  type: TYPE_NORMAL
- en: scenes, 326
  prefs: []
  type: TYPE_NORMAL
- en: Index **379**
  prefs: []
  type: TYPE_NORMAL
- en: graphic file formats, using with
  prefs: []
  type: TYPE_NORMAL
- en: employee and manager example,
  prefs: []
  type: TYPE_NORMAL
- en: pygame, 100–101
  prefs: []
  type: TYPE_NORMAL
- en: 214–218
  prefs: []
  type: TYPE_NORMAL
- en: greater than (>), magic method
  prefs: []
  type: TYPE_NORMAL
- en: example usage, 224–227
  prefs: []
  type: TYPE_NORMAL
- en: name, 196
  prefs: []
  type: TYPE_NORMAL
- en: implementing, 213–214
  prefs: []
  type: TYPE_NORMAL
- en: greater than or equal to (>=), magic
  prefs: []
  type: TYPE_NORMAL
- en: InputNumber class, 219–222,
  prefs: []
  type: TYPE_NORMAL
- en: method name, 196
  prefs: []
  type: TYPE_NORMAL
- en: 224–227
  prefs: []
  type: TYPE_NORMAL
- en: __gt__() magic method name, 196, 198
  prefs: []
  type: TYPE_NORMAL
- en: “is a” relationship, 213
  prefs: []
  type: TYPE_NORMAL
- en: GUI programs, event-driven model,
  prefs: []
  type: TYPE_NORMAL
- en: Law of Demeter, 238
  prefs: []
  type: TYPE_NORMAL
- en: 95–96
  prefs: []
  type: TYPE_NORMAL
- en: in object-oriented programming,
  prefs: []
  type: TYPE_NORMAL
- en: 212–213
  prefs: []
  type: TYPE_NORMAL
- en: '**H**'
  prefs: []
  type: TYPE_NORMAL
- en: and pygwidgets, 234–236
  prefs: []
  type: TYPE_NORMAL
- en: handleEvent() method used with
  prefs: []
  type: TYPE_NORMAL
- en: real-world examples, 219–227
  prefs: []
  type: TYPE_NORMAL
- en: pygwidgets, 150, 192, 221,
  prefs: []
  type: TYPE_NORMAL
- en: from same base class, 227–231
  prefs: []
  type: TYPE_NORMAL
- en: 307, 312
  prefs: []
  type: TYPE_NORMAL
- en: subclass, 212
  prefs: []
  type: TYPE_NORMAL
- en: handleInputs() method used with
  prefs: []
  type: TYPE_NORMAL
- en: test code, 217–218
  prefs: []
  type: TYPE_NORMAL
- en: scenes, 363
  prefs: []
  type: TYPE_NORMAL
- en: use by pygwidgets, 234–236
  prefs: []
  type: TYPE_NORMAL
- en: help() function, 152
  prefs: []
  type: TYPE_NORMAL
- en: initialization parameters, 43–44
  prefs: []
  type: TYPE_NORMAL
- en: Higher or Lower card game, 268\.
  prefs: []
  type: TYPE_NORMAL
- en: __init__() method, 28, 37, 43, 216
  prefs: []
  type: TYPE_NORMAL
- en: '*See also* card games'
  prefs: []
  type: TYPE_NORMAL
- en: Account class, 59, 79
  prefs: []
  type: TYPE_NORMAL
- en: Game object, 274–276
  prefs: []
  type: TYPE_NORMAL
- en: Ball class, 123
  prefs: []
  type: TYPE_NORMAL
- en: implementation, 4–7
  prefs: []
  type: TYPE_NORMAL
- en: Bank class, 73
  prefs: []
  type: TYPE_NORMAL
- en: main program, 272–274
  prefs: []
  type: TYPE_NORMAL
- en: inheritance examples, 228–229,
  prefs: []
  type: TYPE_NORMAL
- en: representing data, 4
  prefs: []
  type: TYPE_NORMAL
- en: 232–233
  prefs: []
  type: TYPE_NORMAL
- en: reusable code, 7
  prefs: []
  type: TYPE_NORMAL
- en: InputNumber, 221
  prefs: []
  type: TYPE_NORMAL
- en: HighScoresData class, 363
  prefs: []
  type: TYPE_NORMAL
- en: pronouncing, 194
  prefs: []
  type: TYPE_NORMAL
- en: property decorators, 175–176
  prefs: []
  type: TYPE_NORMAL
- en: '**I**'
  prefs: []
  type: TYPE_NORMAL
- en: SceneMgr class, 335
  prefs: []
  type: TYPE_NORMAL
- en: IDLE development environment,
  prefs: []
  type: TYPE_NORMAL
- en: subclass in inheritance, 216
  prefs: []
  type: TYPE_NORMAL
- en: 90, 100–101
  prefs: []
  type: TYPE_NORMAL
- en: using, 27
  prefs: []
  type: TYPE_NORMAL
- en: Image class, pygwidgets package,
  prefs: []
  type: TYPE_NORMAL
- en: input() function, 133, 155
  prefs: []
  type: TYPE_NORMAL
- en: 149\. *See also* subimages
  prefs: []
  type: TYPE_NORMAL
- en: InputNumber class, 219–222, 224–227
  prefs: []
  type: TYPE_NORMAL
- en: ImageCollection class, pygwidgets
  prefs: []
  type: TYPE_NORMAL
- en: InputText class, 149, 219, 222
  prefs: []
  type: TYPE_NORMAL
- en: package, 149, 157
  prefs: []
  type: TYPE_NORMAL
- en: installing
  prefs: []
  type: TYPE_NORMAL
- en: implementation vs. interface,
  prefs: []
  type: TYPE_NORMAL
- en: pygame, 90–91
  prefs: []
  type: TYPE_NORMAL
- en: 84–85, 137
  prefs: []
  type: TYPE_NORMAL
- en: pyghelpers, 287
  prefs: []
  type: TYPE_NORMAL
- en: importing class code, 60–61
  prefs: []
  type: TYPE_NORMAL
- en: pygwidgets package, 149–150
  prefs: []
  type: TYPE_NORMAL
- en: import statements, 98
  prefs: []
  type: TYPE_NORMAL
- en: instance and scope variables, 27–28
  prefs: []
  type: TYPE_NORMAL
- en: inheritance. *See also* multiple
  prefs: []
  type: TYPE_NORMAL
- en: instances, 26, 31–32, 41–43\. *See also*
  prefs: []
  type: TYPE_NORMAL
- en: inheritance
  prefs: []
  type: TYPE_NORMAL
- en: multiple instances
  prefs: []
  type: TYPE_NORMAL
- en: abstract classes and methods,
  prefs: []
  type: TYPE_NORMAL
- en: instance scope, 27
  prefs: []
  type: TYPE_NORMAL
- en: 231–234
  prefs: []
  type: TYPE_NORMAL
- en: instance variables. *See also* slots
  prefs: []
  type: TYPE_NORMAL
- en: base class, 212
  prefs: []
  type: TYPE_NORMAL
- en: changing into calculations,
  prefs: []
  type: TYPE_NORMAL
- en: class hierarchy, 236–238
  prefs: []
  type: TYPE_NORMAL
- en: 167–168
  prefs: []
  type: TYPE_NORMAL
- en: client’s view of subclass, 218–219
  prefs: []
  type: TYPE_NORMAL
- en: changing names of, 166–167
  prefs: []
  type: TYPE_NORMAL
- en: and composition, 238
  prefs: []
  type: TYPE_NORMAL
- en: using, 27, 165
  prefs: []
  type: TYPE_NORMAL
- en: difficulty of programming with,
  prefs: []
  type: TYPE_NORMAL
- en: instantiate, explained, 26
  prefs: []
  type: TYPE_NORMAL
- en: 238–239
  prefs: []
  type: TYPE_NORMAL
- en: instantiation process, 25–33
  prefs: []
  type: TYPE_NORMAL
- en: DisplayMoney class, 222–227
  prefs: []
  type: TYPE_NORMAL
- en: interactive menu, building, 68–70
  prefs: []
  type: TYPE_NORMAL
- en: '**380** Index'
  prefs: []
  type: TYPE_NORMAL
- en: interface vs. implementation, 84–85, 137
  prefs: []
  type: TYPE_NORMAL
- en: and classes, 51
  prefs: []
  type: TYPE_NORMAL
- en: '*Invent Your Own Computer Games with*'
  prefs: []
  type: TYPE_NORMAL
- en: vs. functions, 28
  prefs: []
  type: TYPE_NORMAL
- en: '*Python*, 341'
  prefs: []
  type: TYPE_NORMAL
- en: passing arguments to, 40–41
  prefs: []
  type: TYPE_NORMAL
- en: “is a” relationship, inheritance, 213
  prefs: []
  type: TYPE_NORMAL
- en: modal dialogs, Dodger game, 342–347
  prefs: []
  type: TYPE_NORMAL
- en: isInstance() function, 196
  prefs: []
  type: TYPE_NORMAL
- en: Model object, 371–372
  prefs: []
  type: TYPE_NORMAL
- en: items() method, 271
  prefs: []
  type: TYPE_NORMAL
- en: module of constants, Balloon game, 253
  prefs: []
  type: TYPE_NORMAL
- en: mouse click, detecting in pygame,
  prefs: []
  type: TYPE_NORMAL
- en: '**J**'
  prefs: []
  type: TYPE_NORMAL
- en: 102–104
  prefs: []
  type: TYPE_NORMAL
- en: JSON format, 363–365
  prefs: []
  type: TYPE_NORMAL
- en: MOUSEDOWN event, 257
  prefs: []
  type: TYPE_NORMAL
- en: multiple inheritance, 239\. *See also*
  prefs: []
  type: TYPE_NORMAL
- en: '**K**'
  prefs: []
  type: TYPE_NORMAL
- en: inheritance
  prefs: []
  type: TYPE_NORMAL
- en: keyword parameters, pygame, 145–146
  prefs: []
  type: TYPE_NORMAL
- en: multiple instances, 41–43\. *See also*
  prefs: []
  type: TYPE_NORMAL
- en: instances
  prefs: []
  type: TYPE_NORMAL
- en: '**L**'
  prefs: []
  type: TYPE_NORMAL
- en: music, playing in pygame, 115–116
  prefs: []
  type: TYPE_NORMAL
- en: Law of Demeter, inheritance, 238
  prefs: []
  type: TYPE_NORMAL
- en: MVC (Model View Controller) design
  prefs: []
  type: TYPE_NORMAL
- en: __le__() magic method name, 196
  prefs: []
  type: TYPE_NORMAL
- en: pattern
  prefs: []
  type: TYPE_NORMAL
- en: leave() method used with scenes, 325
  prefs: []
  type: TYPE_NORMAL
- en: advantages of, 373–374
  prefs: []
  type: TYPE_NORMAL
- en: len() function, 15, 164
  prefs: []
  type: TYPE_NORMAL
- en: Controller object, 371–372
  prefs: []
  type: TYPE_NORMAL
- en: less than (<), magic method name, 196
  prefs: []
  type: TYPE_NORMAL
- en: dice roll data, 369–370
  prefs: []
  type: TYPE_NORMAL
- en: less than or equal to (<=), magic
  prefs: []
  type: TYPE_NORMAL
- en: file display example, 368
  prefs: []
  type: TYPE_NORMAL
- en: method name, 196
  prefs: []
  type: TYPE_NORMAL
- en: Model object, 372–373
  prefs: []
  type: TYPE_NORMAL
- en: LIFO (last in, first out) order, 179
  prefs: []
  type: TYPE_NORMAL
- en: overview, 367–368
  prefs: []
  type: TYPE_NORMAL
- en: LightSwitch class and test code, 30
  prefs: []
  type: TYPE_NORMAL
- en: statistical display example, 368–371
  prefs: []
  type: TYPE_NORMAL
- en: light switch example, 22–23, 25–31
  prefs: []
  type: TYPE_NORMAL
- en: View object, 373
  prefs: []
  type: TYPE_NORMAL
- en: LightSwitch object, instantiating, 29
  prefs: []
  type: TYPE_NORMAL
- en: line, drawing, 119
  prefs: []
  type: TYPE_NORMAL
- en: '**N**'
  prefs: []
  type: TYPE_NORMAL
- en: Lingo language, 178
  prefs: []
  type: TYPE_NORMAL
- en: __name__, testing card games with,
  prefs: []
  type: TYPE_NORMAL
- en: local scope, 27
  prefs: []
  type: TYPE_NORMAL
- en: 276–278
  prefs: []
  type: TYPE_NORMAL
- en: __lt__() magic method name, 196,
  prefs: []
  type: TYPE_NORMAL
- en: naming convention, 26
  prefs: []
  type: TYPE_NORMAL
- en: 198, 200
  prefs: []
  type: TYPE_NORMAL
- en: __ne__() magic method name, 196
  prefs: []
  type: TYPE_NORMAL
- en: not equal to (!=), magic method
  prefs: []
  type: TYPE_NORMAL
- en: '**M**'
  prefs: []
  type: TYPE_NORMAL
- en: name, 196
  prefs: []
  type: TYPE_NORMAL
- en: Macromedia project, 178
  prefs: []
  type: TYPE_NORMAL
- en: magic methods, 194–201\. *See also*
  prefs: []
  type: TYPE_NORMAL
- en: '**O**'
  prefs: []
  type: TYPE_NORMAL
- en: methods
  prefs: []
  type: TYPE_NORMAL
- en: object composition, 71
  prefs: []
  type: TYPE_NORMAL
- en: Manager class, inheritance, 219
  prefs: []
  type: TYPE_NORMAL
- en: object lifetime
  prefs: []
  type: TYPE_NORMAL
- en: memory management, slots, 261–263
  prefs: []
  type: TYPE_NORMAL
- en: cascading deletion, 246–248
  prefs: []
  type: TYPE_NORMAL
- en: memory used by objects. *See also* objects
  prefs: []
  type: TYPE_NORMAL
- en: death notice, 246–248
  prefs: []
  type: TYPE_NORMAL
- en: Balloon sample program, 251–261
  prefs: []
  type: TYPE_NORMAL
- en: garbage collection, 246–248
  prefs: []
  type: TYPE_NORMAL
- en: class variables, 248–250
  prefs: []
  type: TYPE_NORMAL
- en: reference count, 242–246
  prefs: []
  type: TYPE_NORMAL
- en: managing with slots, 261–263
  prefs: []
  type: TYPE_NORMAL
- en: transaction objects, 242
  prefs: []
  type: TYPE_NORMAL
- en: mental models, 49–52
  prefs: []
  type: TYPE_NORMAL
- en: transient objects, 242
  prefs: []
  type: TYPE_NORMAL
- en: menu, making interactive, 68–70
  prefs: []
  type: TYPE_NORMAL
- en: object manager object, creating, 70–76
  prefs: []
  type: TYPE_NORMAL
- en: methods. *See also* abstract classes and
  prefs: []
  type: TYPE_NORMAL
- en: object-oriented programming (OOP)
  prefs: []
  type: TYPE_NORMAL
- en: methods; magic methods
  prefs: []
  type: TYPE_NORMAL
- en: explained, 3
  prefs: []
  type: TYPE_NORMAL
- en: calling, 30, 41
  prefs: []
  type: TYPE_NORMAL
- en: as solution, 45
  prefs: []
  type: TYPE_NORMAL
- en: calling for objects, 30–31
  prefs: []
  type: TYPE_NORMAL
- en: tenets, 374
  prefs: []
  type: TYPE_NORMAL
- en: calling on lists of objects, 83–84
  prefs: []
  type: TYPE_NORMAL
- en: wrap-up, 374–375
  prefs: []
  type: TYPE_NORMAL
- en: Index **381**
  prefs: []
  type: TYPE_NORMAL
- en: object-oriented pygame.
  prefs: []
  type: TYPE_NORMAL
- en: '**P**'
  prefs: []
  type: TYPE_NORMAL
- en: '*See also* pygame'
  prefs: []
  type: TYPE_NORMAL
- en: parent class, inheritance, 212
  prefs: []
  type: TYPE_NORMAL
- en: Ball class, 122–125
  prefs: []
  type: TYPE_NORMAL
- en: path, using with pygame, 100
  prefs: []
  type: TYPE_NORMAL
- en: Ball objects, 125–127
  prefs: []
  type: TYPE_NORMAL
- en: pathname, using with pygame, 100
  prefs: []
  type: TYPE_NORMAL
- en: callbacks, 137–141
  prefs: []
  type: TYPE_NORMAL
- en: patterns, extending with
  prefs: []
  type: TYPE_NORMAL
- en: demo ball with SimpleText and
  prefs: []
  type: TYPE_NORMAL
- en: polymorphism, 192
  prefs: []
  type: TYPE_NORMAL
- en: SimpleButton, 135–137
  prefs: []
  type: TYPE_NORMAL
- en: physical objects. *See also* objects
  prefs: []
  type: TYPE_NORMAL
- en: interface vs. implementation, 137
  prefs: []
  type: TYPE_NORMAL
- en: building software models of,
  prefs: []
  type: TYPE_NORMAL
- en: program with buttons, 131–132
  prefs: []
  type: TYPE_NORMAL
- en: 22–23
  prefs: []
  type: TYPE_NORMAL
- en: reusable object-oriented button,
  prefs: []
  type: TYPE_NORMAL
- en: classes and objects, 23–25, 45
  prefs: []
  type: TYPE_NORMAL
- en: 127–132
  prefs: []
  type: TYPE_NORMAL
- en: classes, objects, and instantiation,
  prefs: []
  type: TYPE_NORMAL
- en: reusable object-oriented text
  prefs: []
  type: TYPE_NORMAL
- en: 25–33
  prefs: []
  type: TYPE_NORMAL
- en: display, 133–135
  prefs: []
  type: TYPE_NORMAL
- en: complicated classes, 33–44
  prefs: []
  type: TYPE_NORMAL
- en: SimpleButton, 130–131
  prefs: []
  type: TYPE_NORMAL
- en: OOP as solution, 45
  prefs: []
  type: TYPE_NORMAL
- en: SimpleText class, 133–135
  prefs: []
  type: TYPE_NORMAL
- en: representing as classes, 35–44
  prefs: []
  type: TYPE_NORMAL
- en: steps to display text, 133
  prefs: []
  type: TYPE_NORMAL
- en: PIE (polymorphism, inheritance,
  prefs: []
  type: TYPE_NORMAL
- en: object-oriented solutions
  prefs: []
  type: TYPE_NORMAL
- en: encapsulation), 161
  prefs: []
  type: TYPE_NORMAL
- en: classes, 19–20
  prefs: []
  type: TYPE_NORMAL
- en: PinochleDeck class, 279
  prefs: []
  type: TYPE_NORMAL
- en: objects. *See also* memory used by
  prefs: []
  type: TYPE_NORMAL
- en: pixels
  prefs: []
  type: TYPE_NORMAL
- en: objects; physical objects
  prefs: []
  type: TYPE_NORMAL
- en: colors, 94–95
  prefs: []
  type: TYPE_NORMAL
- en: calling methods of, 30–31
  prefs: []
  type: TYPE_NORMAL
- en: in window coordinate
  prefs: []
  type: TYPE_NORMAL
- en: calling methods on lists of,
  prefs: []
  type: TYPE_NORMAL
- en: system, 91
  prefs: []
  type: TYPE_NORMAL
- en: 83–84
  prefs: []
  type: TYPE_NORMAL
- en: playing sounds, 114–116
  prefs: []
  type: TYPE_NORMAL
- en: and classes, 23–25
  prefs: []
  type: TYPE_NORMAL
- en: Play scene, Rock, Paper, Scissors
  prefs: []
  type: TYPE_NORMAL
- en: counting, 250
  prefs: []
  type: TYPE_NORMAL
- en: game, 315
  prefs: []
  type: TYPE_NORMAL
- en: creating from classes, 28–30
  prefs: []
  type: TYPE_NORMAL
- en: polygon, drawing, 119
  prefs: []
  type: TYPE_NORMAL
- en: definition of, 33
  prefs: []
  type: TYPE_NORMAL
- en: polymorphism
  prefs: []
  type: TYPE_NORMAL
- en: encapsulation with, 164
  prefs: []
  type: TYPE_NORMAL
- en: classic example of, 184–185
  prefs: []
  type: TYPE_NORMAL
- en: garbage collection, 248
  prefs: []
  type: TYPE_NORMAL
- en: extending patterns, 192
  prefs: []
  type: TYPE_NORMAL
- en: inside vs. outside, 164–165
  prefs: []
  type: TYPE_NORMAL
- en: Fraction class with magic methods,
  prefs: []
  type: TYPE_NORMAL
- en: owning data, 165
  prefs: []
  type: TYPE_NORMAL
- en: 205–208
  prefs: []
  type: TYPE_NORMAL
- en: reference count, 242–248
  prefs: []
  type: TYPE_NORMAL
- en: magic methods, 194–201
  prefs: []
  type: TYPE_NORMAL
- en: sending messages to, 184
  prefs: []
  type: TYPE_NORMAL
- en: main program creating shapes,
  prefs: []
  type: TYPE_NORMAL
- en: string representations of values in,
  prefs: []
  type: TYPE_NORMAL
- en: 190–192
  prefs: []
  type: TYPE_NORMAL
- en: 203–205
  prefs: []
  type: TYPE_NORMAL
- en: for operators, 193–203
  prefs: []
  type: TYPE_NORMAL
- en: transient type, 242
  prefs: []
  type: TYPE_NORMAL
- en: pygame shapes, 185–192
  prefs: []
  type: TYPE_NORMAL
- en: with unique identifiers, 66
  prefs: []
  type: TYPE_NORMAL
- en: and pygwidgets, 192–193
  prefs: []
  type: TYPE_NORMAL
- en: variables referring to, 244
  prefs: []
  type: TYPE_NORMAL
- en: sending messages to real-world
  prefs: []
  type: TYPE_NORMAL
- en: object scope, 27
  prefs: []
  type: TYPE_NORMAL
- en: objects, 184
  prefs: []
  type: TYPE_NORMAL
- en: OOP (object-oriented programming)
  prefs: []
  type: TYPE_NORMAL
- en: string representations of values in
  prefs: []
  type: TYPE_NORMAL
- en: explained, 3
  prefs: []
  type: TYPE_NORMAL
- en: objects, 203–205
  prefs: []
  type: TYPE_NORMAL
- en: as solution, 45
  prefs: []
  type: TYPE_NORMAL
- en: vector example, 201–203
  prefs: []
  type: TYPE_NORMAL
- en: tenets, 374
  prefs: []
  type: TYPE_NORMAL
- en: pop operation, using with
  prefs: []
  type: TYPE_NORMAL
- en: wrap-up, 374–375
  prefs: []
  type: TYPE_NORMAL
- en: stacks, 179
  prefs: []
  type: TYPE_NORMAL
- en: operators
  prefs: []
  type: TYPE_NORMAL
- en: positional parameters, pygame, 145
  prefs: []
  type: TYPE_NORMAL
- en: magic methods, 194–201
  prefs: []
  type: TYPE_NORMAL
- en: primitive shapes, drawing in pygame,
  prefs: []
  type: TYPE_NORMAL
- en: polymorphism for, 193–203
  prefs: []
  type: TYPE_NORMAL
- en: 116–120
  prefs: []
  type: TYPE_NORMAL
- en: o prefix, 26
  prefs: []
  type: TYPE_NORMAL
- en: print() function, 133, 205
  prefs: []
  type: TYPE_NORMAL
- en: '**382** Index'
  prefs: []
  type: TYPE_NORMAL
- en: procedural implementations. *See also*
  prefs: []
  type: TYPE_NORMAL
- en: pygame.Rect(), 104
  prefs: []
  type: TYPE_NORMAL
- en: bank account simulations
  prefs: []
  type: TYPE_NORMAL
- en: pygame shapes
  prefs: []
  type: TYPE_NORMAL
- en: classes, 19–20
  prefs: []
  type: TYPE_NORMAL
- en: Circle and Triangle shape classes,
  prefs: []
  type: TYPE_NORMAL
- en: Higher or Lower card game, 3–4
  prefs: []
  type: TYPE_NORMAL
- en: 187–190
  prefs: []
  type: TYPE_NORMAL
- en: problems with, 18–19, 45
  prefs: []
  type: TYPE_NORMAL
- en: Square shape class, 186–187
  prefs: []
  type: TYPE_NORMAL
- en: properties
  prefs: []
  type: TYPE_NORMAL
- en: PygAnimation base class, 304, 307–308
  prefs: []
  type: TYPE_NORMAL
- en: '@ (at) and decorators, 174–177'
  prefs: []
  type: TYPE_NORMAL
- en: pyghelpers package
  prefs: []
  type: TYPE_NORMAL
- en: and abstraction, 181
  prefs: []
  type: TYPE_NORMAL
- en: classes for tracking time, 290
  prefs: []
  type: TYPE_NORMAL
- en: explained, 174
  prefs: []
  type: TYPE_NORMAL
- en: CountDownTimer class, 293–294
  prefs: []
  type: TYPE_NORMAL
- en: push operation, using with stacks, 179
  prefs: []
  type: TYPE_NORMAL
- en: CountUpTimer class, 291–293
  prefs: []
  type: TYPE_NORMAL
- en: PyCharm IDE, 100–101
  prefs: []
  type: TYPE_NORMAL
- en: installing, 287
  prefs: []
  type: TYPE_NORMAL
- en: '**.py* file extension, 61'
  prefs: []
  type: TYPE_NORMAL
- en: pygwidgets classes, encapsulation in, 177
  prefs: []
  type: TYPE_NORMAL
- en: pygame. *See also* object-oriented pygame
  prefs: []
  type: TYPE_NORMAL
- en: pygwidgets package. *See also* pygame
  prefs: []
  type: TYPE_NORMAL
- en: anti-aliased line, 118
  prefs: []
  type: TYPE_NORMAL
- en: GUI widgets
  prefs: []
  type: TYPE_NORMAL
- en: arc, 119
  prefs: []
  type: TYPE_NORMAL
- en: adding images, 151
  prefs: []
  type: TYPE_NORMAL
- en: bringing up blank window, 97–100
  prefs: []
  type: TYPE_NORMAL
- en: Animation class, 304–309
  prefs: []
  type: TYPE_NORMAL
- en: Cartesian coordinate system, 91–94
  prefs: []
  type: TYPE_NORMAL
- en: animation program, 308–309
  prefs: []
  type: TYPE_NORMAL
- en: circle, 119
  prefs: []
  type: TYPE_NORMAL
- en: button object, 154
  prefs: []
  type: TYPE_NORMAL
- en: colors in, 94–95
  prefs: []
  type: TYPE_NORMAL
- en: buttons, 152–154
  prefs: []
  type: TYPE_NORMAL
- en: detecting mouse click, 102–105
  prefs: []
  type: TYPE_NORMAL
- en: checkboxes, 152–154
  prefs: []
  type: TYPE_NORMAL
- en: drawing images, 100–102
  prefs: []
  type: TYPE_NORMAL
- en: classes, 148–149, 157
  prefs: []
  type: TYPE_NORMAL
- en: drawing shapes, 116–120
  prefs: []
  type: TYPE_NORMAL
- en: class hierarchy, 237
  prefs: []
  type: TYPE_NORMAL
- en: ellipse, 119
  prefs: []
  type: TYPE_NORMAL
- en: consistency of API, 158
  prefs: []
  type: TYPE_NORMAL
- en: event-driven programs, 95–96
  prefs: []
  type: TYPE_NORMAL
- en: CustomButton class, 153–154
  prefs: []
  type: TYPE_NORMAL
- en: handling keyboard, 105–109
  prefs: []
  type: TYPE_NORMAL
- en: design approach, 150–151
  prefs: []
  type: TYPE_NORMAL
- en: installing, 90–91
  prefs: []
  type: TYPE_NORMAL
- en: DisplayText class, 155, 222
  prefs: []
  type: TYPE_NORMAL
- en: line, 119
  prefs: []
  type: TYPE_NORMAL
- en: example program, 157–158
  prefs: []
  type: TYPE_NORMAL
- en: location-based animation, 109–111
  prefs: []
  type: TYPE_NORMAL
- en: goals and classes, 148–149
  prefs: []
  type: TYPE_NORMAL
- en: pixel colors, 94–95
  prefs: []
  type: TYPE_NORMAL
- en: images, 151
  prefs: []
  type: TYPE_NORMAL
- en: playing sounds, 114–116
  prefs: []
  type: TYPE_NORMAL
- en: and inheritance, 234–236
  prefs: []
  type: TYPE_NORMAL
- en: polygon, 119
  prefs: []
  type: TYPE_NORMAL
- en: InputText class, 219
  prefs: []
  type: TYPE_NORMAL
- en: primitive shapes, 118–120
  prefs: []
  type: TYPE_NORMAL
- en: polymorphism, 192–193
  prefs: []
  type: TYPE_NORMAL
- en: recognizing key presses, 105–107
  prefs: []
  type: TYPE_NORMAL
- en: PygAnimation base class, 307–308
  prefs: []
  type: TYPE_NORMAL
- en: rectobjects, 104, 107, 111–114, 119
  prefs: []
  type: TYPE_NORMAL
- en: radio buttons, 152–154
  prefs: []
  type: TYPE_NORMAL
- en: repeating keys in continuous
  prefs: []
  type: TYPE_NORMAL
- en: setting up, 149–150
  prefs: []
  type: TYPE_NORMAL
- en: mode, 107–109
  prefs: []
  type: TYPE_NORMAL
- en: sprite module, 151
  prefs: []
  type: TYPE_NORMAL
- en: Splash scene, 314
  prefs: []
  type: TYPE_NORMAL
- en: SpriteSheetAnimation class, 306–307
  prefs: []
  type: TYPE_NORMAL
- en: state machine example, 314–319
  prefs: []
  type: TYPE_NORMAL
- en: TextButton class, 152–153
  prefs: []
  type: TYPE_NORMAL
- en: window coordinate system, 91–95
  prefs: []
  type: TYPE_NORMAL
- en: text output and input, 154–157
  prefs: []
  type: TYPE_NORMAL
- en: pygame.display.set_mode() function, 98
  prefs: []
  type: TYPE_NORMAL
- en: using buttons, 154
  prefs: []
  type: TYPE_NORMAL
- en: pygame GUI widgets. *See also*
  prefs: []
  type: TYPE_NORMAL
- en: PyPI (Python Package Index), 149
  prefs: []
  type: TYPE_NORMAL
- en: pygwidgets package
  prefs: []
  type: TYPE_NORMAL
- en: Python, philosophy of, 242
  prefs: []
  type: TYPE_NORMAL
- en: arguments, functions, and
  prefs: []
  type: TYPE_NORMAL
- en: Python Software Foundation, 242
  prefs: []
  type: TYPE_NORMAL
- en: methods, 144–148
  prefs: []
  type: TYPE_NORMAL
- en: Python Standard Library
  prefs: []
  type: TYPE_NORMAL
- en: keywords and default values, 148
  prefs: []
  type: TYPE_NORMAL
- en: abc (abstract base class) module, 232
  prefs: []
  type: TYPE_NORMAL
- en: None as default value, 146–147
  prefs: []
  type: TYPE_NORMAL
- en: calls to, 76–77
  prefs: []
  type: TYPE_NORMAL
- en: positional and keyword
  prefs: []
  type: TYPE_NORMAL
- en: getrefcount() function, 244
  prefs: []
  type: TYPE_NORMAL
- en: parameters, 145–146
  prefs: []
  type: TYPE_NORMAL
- en: Python Tutor website, 50, 243
  prefs: []
  type: TYPE_NORMAL
- en: Index **383**
  prefs: []
  type: TYPE_NORMAL
- en: '**R**'
  prefs: []
  type: TYPE_NORMAL
- en: navigating between scenes, 326
  prefs: []
  type: TYPE_NORMAL
- en: raise statement and custom exceptions,
  prefs: []
  type: TYPE_NORMAL
- en: project folder, 321
  prefs: []
  type: TYPE_NORMAL
- en: 77–78
  prefs: []
  type: TYPE_NORMAL
- en: quitting program, 326
  prefs: []
  type: TYPE_NORMAL
- en: RAM memory space, 262
  prefs: []
  type: TYPE_NORMAL
- en: Rock, Paper, Scissors, 328–332
  prefs: []
  type: TYPE_NORMAL
- en: random package, 104
  prefs: []
  type: TYPE_NORMAL
- en: run() method, 336–337
  prefs: []
  type: TYPE_NORMAL
- en: real-world objects, sending messages
  prefs: []
  type: TYPE_NORMAL
- en: using, 319–320
  prefs: []
  type: TYPE_NORMAL
- en: to, 184
  prefs: []
  type: TYPE_NORMAL
- en: SceneMgr class, 337
  prefs: []
  type: TYPE_NORMAL
- en: receive() method used with scenes, 334
  prefs: []
  type: TYPE_NORMAL
- en: ScenePlay class, Dodger game,
  prefs: []
  type: TYPE_NORMAL
- en: rectangle, drawing, 120
  prefs: []
  type: TYPE_NORMAL
- en: 351–355
  prefs: []
  type: TYPE_NORMAL
- en: Rectangle class
  prefs: []
  type: TYPE_NORMAL
- en: scenes
  prefs: []
  type: TYPE_NORMAL
- en: inheritance example, 233–234
  prefs: []
  type: TYPE_NORMAL
- en: communication between, 332–334
  prefs: []
  type: TYPE_NORMAL
- en: with magic methods, 196–198
  prefs: []
  type: TYPE_NORMAL
- en: current and target, 332
  prefs: []
  type: TYPE_NORMAL
- en: reference count, 242–246
  prefs: []
  type: TYPE_NORMAL
- en: state machine approach, 312–319
  prefs: []
  type: TYPE_NORMAL
- en: decrementing, 245–246
  prefs: []
  type: TYPE_NORMAL
- en: testing communications among,
  prefs: []
  type: TYPE_NORMAL
- en: incrementing, 245
  prefs: []
  type: TYPE_NORMAL
- en: '334'
  prefs: []
  type: TYPE_NORMAL
- en: relative path, using with pygame,
  prefs: []
  type: TYPE_NORMAL
- en: scope and instance variables,
  prefs: []
  type: TYPE_NORMAL
- en: 100–101
  prefs: []
  type: TYPE_NORMAL
- en: 27–28
  prefs: []
  type: TYPE_NORMAL
- en: respond() method used with scenes, 333
  prefs: []
  type: TYPE_NORMAL
- en: screensaver ball, building with
  prefs: []
  type: TYPE_NORMAL
- en: Results scene, Rock, Paper, Scissors
  prefs: []
  type: TYPE_NORMAL
- en: object-oriented pygame, 121–127
  prefs: []
  type: TYPE_NORMAL
- en: game, 315–316
  prefs: []
  type: TYPE_NORMAL
- en: “self,” meaning of, 52–55
  prefs: []
  type: TYPE_NORMAL
- en: reusable object-oriented button,
  prefs: []
  type: TYPE_NORMAL
- en: self parameter, 41–42
  prefs: []
  type: TYPE_NORMAL
- en: building, 127–132
  prefs: []
  type: TYPE_NORMAL
- en: self. prefix, 27
  prefs: []
  type: TYPE_NORMAL
- en: reusable object-oriented text display,
  prefs: []
  type: TYPE_NORMAL
- en: send() method used with scenes, 333
  prefs: []
  type: TYPE_NORMAL
- en: building, 133–135
  prefs: []
  type: TYPE_NORMAL
- en: sendAll() method used with scenes, 334
  prefs: []
  type: TYPE_NORMAL
- en: RGB (red, green, blue), 94
  prefs: []
  type: TYPE_NORMAL
- en: setters and getters, 170–171, 175–176
  prefs: []
  type: TYPE_NORMAL
- en: Rock, Paper, Scissors game
  prefs: []
  type: TYPE_NORMAL
- en: Shape class
  prefs: []
  type: TYPE_NORMAL
- en: Play scene, 315
  prefs: []
  type: TYPE_NORMAL
- en: inheritance example, 232–233
  prefs: []
  type: TYPE_NORMAL
- en: Results scene, 315–316
  prefs: []
  type: TYPE_NORMAL
- en: using as base class, 228
  prefs: []
  type: TYPE_NORMAL
- en: Splash scene, 314
  prefs: []
  type: TYPE_NORMAL
- en: shapes, drawing in pygame, 116–120
  prefs: []
  type: TYPE_NORMAL
- en: using scenes, 328–332
  prefs: []
  type: TYPE_NORMAL
- en: SimpleAnimation class, 296–300
  prefs: []
  type: TYPE_NORMAL
- en: run() method of the scene manager,
  prefs: []
  type: TYPE_NORMAL
- en: SimpleButton class, 129, 131–132,
  prefs: []
  type: TYPE_NORMAL
- en: 336, 349
  prefs: []
  type: TYPE_NORMAL
- en: 139–141
  prefs: []
  type: TYPE_NORMAL
- en: SimpleButton objects, 130–131,
  prefs: []
  type: TYPE_NORMAL
- en: '**S**'
  prefs: []
  type: TYPE_NORMAL
- en: 137–138, 141
  prefs: []
  type: TYPE_NORMAL
- en: Sample class, 250
  prefs: []
  type: TYPE_NORMAL
- en: SimpleText class, 133–137
  prefs: []
  type: TYPE_NORMAL
- en: Scene base class, 322
  prefs: []
  type: TYPE_NORMAL
- en: SimpleText object, 135
  prefs: []
  type: TYPE_NORMAL
- en: scene manager
  prefs: []
  type: TYPE_NORMAL
- en: Slider class, 193
  prefs: []
  type: TYPE_NORMAL
- en: building scenes, 323–326
  prefs: []
  type: TYPE_NORMAL
- en: Slider Puzzle user interface, 290, 293
  prefs: []
  type: TYPE_NORMAL
- en: communication between scenes,
  prefs: []
  type: TYPE_NORMAL
- en: slots, using for memory management,
  prefs: []
  type: TYPE_NORMAL
- en: 338–340
  prefs: []
  type: TYPE_NORMAL
- en: 261–263\. *See also* instance
  prefs: []
  type: TYPE_NORMAL
- en: demo program, 320–328
  prefs: []
  type: TYPE_NORMAL
- en: variables
  prefs: []
  type: TYPE_NORMAL
- en: example scene, 326–328
  prefs: []
  type: TYPE_NORMAL
- en: software models, building for physical
  prefs: []
  type: TYPE_NORMAL
- en: features, 319–320
  prefs: []
  type: TYPE_NORMAL
- en: objects, 22–23
  prefs: []
  type: TYPE_NORMAL
- en: implementation of, 334–340
  prefs: []
  type: TYPE_NORMAL
- en: sound effects, playing in pygame,
  prefs: []
  type: TYPE_NORMAL
- en: main methods, 337–338
  prefs: []
  type: TYPE_NORMAL
- en: 114–116
  prefs: []
  type: TYPE_NORMAL
- en: main program, 322–323
  prefs: []
  type: TYPE_NORMAL
- en: SpaceShip class, 249
  prefs: []
  type: TYPE_NORMAL
- en: methods for implementing scenes,
  prefs: []
  type: TYPE_NORMAL
- en: special methods, 194
  prefs: []
  type: TYPE_NORMAL
- en: 324–325
  prefs: []
  type: TYPE_NORMAL
- en: Splash scene, 313–314, 347
  prefs: []
  type: TYPE_NORMAL
- en: '**384** Index'
  prefs: []
  type: TYPE_NORMAL
- en: SpriteSheetAnimation class, 149, 304,
  prefs: []
  type: TYPE_NORMAL
- en: timers
  prefs: []
  type: TYPE_NORMAL
- en: 306–307
  prefs: []
  type: TYPE_NORMAL
- en: building into main loop, 286
  prefs: []
  type: TYPE_NORMAL
- en: sprite sheet image, 300
  prefs: []
  type: TYPE_NORMAL
- en: calculating elapsed time,
  prefs: []
  type: TYPE_NORMAL
- en: Square class, 195, 227
  prefs: []
  type: TYPE_NORMAL
- en: 285–287
  prefs: []
  type: TYPE_NORMAL
- en: inheritance example, 229
  prefs: []
  type: TYPE_NORMAL
- en: counting frames, 283
  prefs: []
  type: TYPE_NORMAL
- en: pygame shapes, 186–187
  prefs: []
  type: TYPE_NORMAL
- en: demonstration program, 282
  prefs: []
  type: TYPE_NORMAL
- en: for reference counting, 243
  prefs: []
  type: TYPE_NORMAL
- en: implementing, 283–287
  prefs: []
  type: TYPE_NORMAL
- en: Square object, 243
  prefs: []
  type: TYPE_NORMAL
- en: installing pyghelpers, 287
  prefs: []
  type: TYPE_NORMAL
- en: Stack class, 181
  prefs: []
  type: TYPE_NORMAL
- en: overview, 281–282
  prefs: []
  type: TYPE_NORMAL
- en: stack operations, 179–180
  prefs: []
  type: TYPE_NORMAL
- en: toggle, using, 38
  prefs: []
  type: TYPE_NORMAL
- en: state diagram, 316
  prefs: []
  type: TYPE_NORMAL
- en: transaction objects, 242
  prefs: []
  type: TYPE_NORMAL
- en: state machine, pygame example,
  prefs: []
  type: TYPE_NORMAL
- en: transient objects, 242
  prefs: []
  type: TYPE_NORMAL
- en: 312–319
  prefs: []
  type: TYPE_NORMAL
- en: Triangle class, 187, 227, 230–231
  prefs: []
  type: TYPE_NORMAL
- en: statistical display example, 368–373
  prefs: []
  type: TYPE_NORMAL
- en: try/except techniques, 76–81
  prefs: []
  type: TYPE_NORMAL
- en: __str__() method, 203–204
  prefs: []
  type: TYPE_NORMAL
- en: tuple, setting x- and y-coordinates
  prefs: []
  type: TYPE_NORMAL
- en: subclasses
  prefs: []
  type: TYPE_NORMAL
- en: as, 151
  prefs: []
  type: TYPE_NORMAL
- en: client’s view of, 218–219
  prefs: []
  type: TYPE_NORMAL
- en: TV class, creating, 35–40
  prefs: []
  type: TYPE_NORMAL
- en: inheritance, 212–213, 215–217
  prefs: []
  type: TYPE_NORMAL
- en: TV objects, creating, 42
  prefs: []
  type: TYPE_NORMAL
- en: inheriting from base class, 227
  prefs: []
  type: TYPE_NORMAL
- en: type() function, 32
  prefs: []
  type: TYPE_NORMAL
- en: subimages, creating, 300\.
  prefs: []
  type: TYPE_NORMAL
- en: '*See also* Image class'
  prefs: []
  type: TYPE_NORMAL
- en: '**U**'
  prefs: []
  type: TYPE_NORMAL
- en: superclass, inheritance, 212
  prefs: []
  type: TYPE_NORMAL
- en: update() method used with scenes, 325
  prefs: []
  type: TYPE_NORMAL
- en: super() function, 216
  prefs: []
  type: TYPE_NORMAL
- en: Sweigart, Al, 341
  prefs: []
  type: TYPE_NORMAL
- en: '**V**'
  prefs: []
  type: TYPE_NORMAL
- en: variables. *See also* class variables
  prefs: []
  type: TYPE_NORMAL
- en: '**T**'
  prefs: []
  type: TYPE_NORMAL
- en: referring to same object, 244
  prefs: []
  type: TYPE_NORMAL
- en: temporary variable, using, 66
  prefs: []
  type: TYPE_NORMAL
- en: using temporarily, 66
  prefs: []
  type: TYPE_NORMAL
- en: test code
  prefs: []
  type: TYPE_NORMAL
- en: vars() function, 52
  prefs: []
  type: TYPE_NORMAL
- en: accounts, 62–64
  prefs: []
  type: TYPE_NORMAL
- en: vector example, polymorphism,
  prefs: []
  type: TYPE_NORMAL
- en: creating, 61–62
  prefs: []
  type: TYPE_NORMAL
- en: 201–203
  prefs: []
  type: TYPE_NORMAL
- en: inheritance, 217–218
  prefs: []
  type: TYPE_NORMAL
- en: View object, 371, 373
  prefs: []
  type: TYPE_NORMAL
- en: test programming, 177
  prefs: []
  type: TYPE_NORMAL
- en: textAnswerDialog dialog, Dodger
  prefs: []
  type: TYPE_NORMAL
- en: '**W**'
  prefs: []
  type: TYPE_NORMAL
- en: game, 346
  prefs: []
  type: TYPE_NORMAL
- en: WidgetWithFrills class, 214
  prefs: []
  type: TYPE_NORMAL
- en: TextButton class, 148, 235
  prefs: []
  type: TYPE_NORMAL
- en: window coordinate system, pygame,
  prefs: []
  type: TYPE_NORMAL
- en: TextCheckBox class, pygwidgets
  prefs: []
  type: TYPE_NORMAL
- en: 91–95
  prefs: []
  type: TYPE_NORMAL
- en: package, 149
  prefs: []
  type: TYPE_NORMAL
- en: working directory, using with
  prefs: []
  type: TYPE_NORMAL
- en: text display, building, 133–135
  prefs: []
  type: TYPE_NORMAL
- en: pygame, 100
  prefs: []
  type: TYPE_NORMAL
- en: TextRadioButton class, pygwidgets
  prefs: []
  type: TYPE_NORMAL
- en: package, 149
  prefs: []
  type: TYPE_NORMAL
- en: '**X**'
  prefs: []
  type: TYPE_NORMAL
- en: textYesNoDialog dialog, Dodger
  prefs: []
  type: TYPE_NORMAL
- en: x- and y-coordinates, setting as
  prefs: []
  type: TYPE_NORMAL
- en: game, 343
  prefs: []
  type: TYPE_NORMAL
- en: tuple, 151
  prefs: []
  type: TYPE_NORMAL
- en: throwing exceptions, 76
  prefs: []
  type: TYPE_NORMAL
- en: XTRAs and objects, accessing
  prefs: []
  type: TYPE_NORMAL
- en: time, displaying, 290–294
  prefs: []
  type: TYPE_NORMAL
- en: databases with, 178–179
  prefs: []
  type: TYPE_NORMAL
- en: Timer class, 287–290
  prefs: []
  type: TYPE_NORMAL
- en: timer demonstration program, 282
  prefs: []
  type: TYPE_NORMAL
- en: '**Y**'
  prefs: []
  type: TYPE_NORMAL
- en: timer event, 284–285
  prefs: []
  type: TYPE_NORMAL
- en: Yes/No and Alert dialogs, Dodger
  prefs: []
  type: TYPE_NORMAL
- en: Timer object, 288
  prefs: []
  type: TYPE_NORMAL
- en: game, 342–345
  prefs: []
  type: TYPE_NORMAL
- en: Index **385**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 59](index-416_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Never before has the world relied so heavily on the Internet
  prefs: []
  type: TYPE_NORMAL
- en: to stay connected and informed. That makes the Electronic
  prefs: []
  type: TYPE_NORMAL
- en: Frontier Foundation’s mission—to ensure that technology
  prefs: []
  type: TYPE_NORMAL
- en: supports freedom, justice, and innovation for all people—
  prefs: []
  type: TYPE_NORMAL
- en: more urgent than ever.
  prefs: []
  type: TYPE_NORMAL
- en: For over 30 years, EFF has fought for tech users through
  prefs: []
  type: TYPE_NORMAL
- en: activism, in the courts, and by developing software to over-
  prefs: []
  type: TYPE_NORMAL
- en: come obstacles to your privacy, security, and free expression.
  prefs: []
  type: TYPE_NORMAL
- en: This dedication empowers all of us through darkness. With
  prefs: []
  type: TYPE_NORMAL
- en: your help we can navigate toward a brighter digital future.
  prefs: []
  type: TYPE_NORMAL
- en: LEARN MORE AND JOIN EFF AT EFF.ORG/NO-STARCH-PRESS
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 60](index-417_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '![Image 61](index-417_2.png)'
  prefs: []
  type: TYPE_IMG
- en: '![Image 62](index-417_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '![Image 63](index-417_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '![Image 64](index-417_5.png)'
  prefs: []
  type: TYPE_IMG
- en: '![Image 65](index-417_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**RESOURCES**'
  prefs: []
  type: TYPE_NORMAL
- en: Visit [*https://nostarch.com/object-oriented-python/*](https://nostarch.com/object-oriented-python/)
    for errata and more information.
  prefs: []
  type: TYPE_NORMAL
- en: '*More no-nonsense books from*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NO STARCH PRESS**'
  prefs: []
  type: TYPE_NORMAL
- en: '**BEYOND THE BASIC STUFF**'
  prefs: []
  type: TYPE_NORMAL
- en: '**SERIOUS PYTHON**'
  prefs: []
  type: TYPE_NORMAL
- en: '**THE MISSING README**'
  prefs: []
  type: TYPE_NORMAL
- en: '**WITH PYTHON**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Black-Belt Advice on Deployment,**'
  prefs: []
  type: TYPE_NORMAL
- en: '**A Guide for the New Software Engineer**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Scalability, Testing, and More**'
  prefs: []
  type: TYPE_NORMAL
- en: '*by* Chris Riccomini and'
  prefs: []
  type: TYPE_NORMAL
- en: '**Best Practices for Writing Clean Code**'
  prefs: []
  type: TYPE_NORMAL
- en: '*by* Julien Danjou'
  prefs: []
  type: TYPE_NORMAL
- en: Dmitriy Ryaboy
  prefs: []
  type: TYPE_NORMAL
- en: '*by* Al Sweigart'
  prefs: []
  type: TYPE_NORMAL
- en: 240 pp., $34.95
  prefs: []
  type: TYPE_NORMAL
- en: 288 pp., $24.99
  prefs: []
  type: TYPE_NORMAL
- en: 384 pp., $34.95
  prefs: []
  type: TYPE_NORMAL
- en: 'ISBN: 978-1-59327-878-6'
  prefs: []
  type: TYPE_NORMAL
- en: 'ISBN: 978-1-7185-0183-6'
  prefs: []
  type: TYPE_NORMAL
- en: 'ISBN: 978-1-59327-966-0'
  prefs: []
  type: TYPE_NORMAL
- en: '**ALGORITHMIC THINKING**'
  prefs: []
  type: TYPE_NORMAL
- en: '**THE SECRET LIFE OF PROGRAMS**'
  prefs: []
  type: TYPE_NORMAL
- en: '**WRITE GREAT CODE, VOLUME 3**'
  prefs: []
  type: TYPE_NORMAL
- en: '**A Problem-Based Introduction**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Understand Computers—Craft Better Code**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Engineering Software**'
  prefs: []
  type: TYPE_NORMAL
- en: '*by* Daniel Zingaro'
  prefs: []
  type: TYPE_NORMAL
- en: '*by* Jonathan E. Steinhart'
  prefs: []
  type: TYPE_NORMAL
- en: '*by* Randall Hyde'
  prefs: []
  type: TYPE_NORMAL
- en: 408 pp., $49.95
  prefs: []
  type: TYPE_NORMAL
- en: 504 pp., $44.95
  prefs: []
  type: TYPE_NORMAL
- en: 376 pp., $49.95
  prefs: []
  type: TYPE_NORMAL
- en: 'ISBN: 978-1-7185-0080-8'
  prefs: []
  type: TYPE_NORMAL
- en: 'ISBN: 978-1-59327-970-7'
  prefs: []
  type: TYPE_NORMAL
- en: 'ISBN: 978-1-59327-979-0'
  prefs: []
  type: TYPE_NORMAL
- en: '**phone:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**email:**'
  prefs: []
  type: TYPE_NORMAL
- en: 800.420.7240 or
  prefs: []
  type: TYPE_NORMAL
- en: sales@nostarch.com
  prefs: []
  type: TYPE_NORMAL
- en: 415.863.9900
  prefs: []
  type: TYPE_NORMAL
- en: '**web:**'
  prefs: []
  type: TYPE_NORMAL
- en: www.nostarch.com
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 66](index-418_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '![Image 67](index-418_2.png)'
  prefs: []
  type: TYPE_IMG
- en: '![Image 68](index-418_3.png)'
  prefs: []
  type: TYPE_IMG
- en: '![Image 69](index-418_4.png)'
  prefs: []
  type: TYPE_IMG
- en: '![Image 70](index-418_5.png)'
  prefs: []
  type: TYPE_IMG
- en: '![Image 71](index-418_6.png)'
  prefs: []
  type: TYPE_IMG
- en: '![Image 72](index-418_7.png)'
  prefs: []
  type: TYPE_IMG
- en: '![Image 73](index-418_8.png)'
  prefs: []
  type: TYPE_IMG
- en: '![Image 74](index-418_9.png)'
  prefs: []
  type: TYPE_IMG
- en: '![Image 75](index-418_10.png)'
  prefs: []
  type: TYPE_IMG
- en: '**B U I LT W I T H**'
  prefs: []
  type: TYPE_NORMAL
- en: '**T A K E C O N T R O L**'
  prefs: []
  type: TYPE_NORMAL
- en: '**P Y T H O N 3 . x A N D**'
  prefs: []
  type: TYPE_NORMAL
- en: '**O F Y O U R P Y T H O N**'
  prefs: []
  type: TYPE_NORMAL
- en: '**P Y G A M E 2 . x**'
  prefs: []
  type: TYPE_NORMAL
- en: '**O B J E C T S**'
  prefs: []
  type: TYPE_NORMAL
- en: '**O B J E C T- O R I E N T E D**'
  prefs: []
  type: TYPE_NORMAL
- en: '**OBJECT-ORIENTED PYTHON**'
  prefs: []
  type: TYPE_NORMAL
- en: '**P Y T H O N**'
  prefs: []
  type: TYPE_NORMAL
- en: Object-oriented programming (OOP) is a paradigm
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll learn how to:'
  prefs: []
  type: TYPE_NORMAL
- en: '**M A S T E R O O P B Y**'
  prefs: []
  type: TYPE_NORMAL
- en: that combines data and code into cohesive units,
  prefs: []
  type: TYPE_NORMAL
- en: • Create and manage multiple objects using an object
  prefs: []
  type: TYPE_NORMAL
- en: '**B U I L D I N G G A M E S A N D G U I S**'
  prefs: []
  type: TYPE_NORMAL
- en: allowing you to think differently about computational
  prefs: []
  type: TYPE_NORMAL
- en: problems and solve them in a highly reusable way.
  prefs: []
  type: TYPE_NORMAL
- en: manager object
  prefs: []
  type: TYPE_NORMAL
- en: Aimed at intermediate-level programmers, *Object-*
  prefs: []
  type: TYPE_NORMAL
- en: • Use encapsulation to hide the inner details of objects
  prefs: []
  type: TYPE_NORMAL
- en: '*Oriented Python* is a hands-on tutorial that goes deep'
  prefs: []
  type: TYPE_NORMAL
- en: from client code
  prefs: []
  type: TYPE_NORMAL
- en: '**I R V K A L B**'
  prefs: []
  type: TYPE_NORMAL
- en: into the core tenets of OOP, showing you how to use
  prefs: []
  type: TYPE_NORMAL
- en: encapsulation, polymorphism, and inheritance to write
  prefs: []
  type: TYPE_NORMAL
- en: • Use polymorphism to defi ne one interface and
  prefs: []
  type: TYPE_NORMAL
- en: games and apps using Python.
  prefs: []
  type: TYPE_NORMAL
- en: implement it in multiple classes
  prefs: []
  type: TYPE_NORMAL
- en: The book begins by demonstrating key problems
  prefs: []
  type: TYPE_NORMAL
- en: • Apply inheritance to build on existing code
  prefs: []
  type: TYPE_NORMAL
- en: inherent in procedural programming, then guides you
  prefs: []
  type: TYPE_NORMAL
- en: through the basics of creating classes and objects in
  prefs: []
  type: TYPE_NORMAL
- en: '*Object-Oriented Python* is a visual, intuitive guide to'
  prefs: []
  type: TYPE_NORMAL
- en: Python. You’ll build on this groundwork by developing
  prefs: []
  type: TYPE_NORMAL
- en: fully understanding how OOP operates and how you
  prefs: []
  type: TYPE_NORMAL
- en: buttons, text fi elds, and other GUI elements that are
  prefs: []
  type: TYPE_NORMAL
- en: can use it to make your code more maintainable,
  prefs: []
  type: TYPE_NORMAL
- en: standard in event-driven environments. You’ll also use
  prefs: []
  type: TYPE_NORMAL
- en: readable, and effi cient—without sacrifi cing
  prefs: []
  type: TYPE_NORMAL
- en: many real-world code examples and two pygame-
  prefs: []
  type: TYPE_NORMAL
- en: functionality.
  prefs: []
  type: TYPE_NORMAL
- en: based packages to help turn theory into practice,
  prefs: []
  type: TYPE_NORMAL
- en: enabling you to easily write interactive games and
  prefs: []
  type: TYPE_NORMAL
- en: '**A B O U T T H E A U T H O R**'
  prefs: []
  type: TYPE_NORMAL
- en: applications complete with GUI widgets, animations,
  prefs: []
  type: TYPE_NORMAL
- en: Irv Kalb is an adjunct professor at UCSC Silicon
  prefs: []
  type: TYPE_NORMAL
- en: multiple scenes, and reusable game logic. In the final
  prefs: []
  type: TYPE_NORMAL
- en: Valley Extension and the University of Silicon Valley,
  prefs: []
  type: TYPE_NORMAL
- en: chapter, you’ll bring it all together by building a
  prefs: []
  type: TYPE_NORMAL
- en: where he teaches introductory and object-oriented
  prefs: []
  type: TYPE_NORMAL
- en: fully functional video game that incorporates many
  prefs: []
  type: TYPE_NORMAL
- en: programming courses in Python. He is also the author
  prefs: []
  type: TYPE_NORMAL
- en: of the OOP techniques and GUI elements covered in
  prefs: []
  type: TYPE_NORMAL
- en: 'of *Learn to Program with Python 3: A Step-by-Step*'
  prefs: []
  type: TYPE_NORMAL
- en: the book.
  prefs: []
  type: TYPE_NORMAL
- en: '*Guide to Programming.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***THE FINEST IN GEEK ENTERTAINMENT ™***'
  prefs: []
  type: TYPE_NORMAL
- en: www.nostarch.com
  prefs: []
  type: TYPE_NORMAL
- en: '**KALB**'
  prefs: []
  type: TYPE_NORMAL
- en: '**$44.99 ($59.99 CDN)**'
  prefs: []
  type: TYPE_NORMAL
- en: Document Outline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Acknowledgments](index_split_000.html#p20)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Introduction](index_split_000.html#p22)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Part I: Introducing Object-oriented Programming](index_split_000.html#p30)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 1: Procedural Python Examples](index_split_000.html#p32)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Higher or Lower Card Game](index_split_000.html#p33)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Bank Account Simulations](index_split_000.html#p36)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Common Problems with Procedural Implementation](index_split_000.html#p47)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Object-Oriented Solution—First Look at a Class](index_split_000.html#p48)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summary](index_split_000.html#p49)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 2: Modeling Physical Objects with Object-Oriented Programming](index_split_000.html#p50)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Building Software Models of Physical Objects](index_split_000.html#p51)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Introduction to Classes and Objects](index_split_000.html#p52)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Classes, Objects, and Instantiation](index_split_000.html#p54)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Building a Slightly More Complicated Class](index_split_001.html#p62)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Representing a More Complicated Physical Object as a Class](index_split_001.html#p64)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Classes in Use](index_split_001.html#p74)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[OOP as a Solution](index_split_001.html#p74)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summary](index_split_001.html#p75)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 3: Mental Models of Objects and the Meaning of “self”](index_split_001.html#p76)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Revisiting the DimmerSwitch Class](index_split_001.html#p77)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[High-Level Mental Model #1](index_split_001.html#p78)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[A Deeper Mental Model #2](index_split_001.html#p78)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[What Is the Meaning of “self”?](index_split_001.html#p81)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summary](index_split_001.html#p84)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 4: Managing Multiple Objects](index_split_001.html#p86)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Bank Account Class](index_split_001.html#p87)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Importing Class Code](index_split_001.html#p89)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Creating Some Test Code](index_split_001.html#p90)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Creating an Object Manager Object](index_split_001.html#p99)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Better Error Handling with Exceptions](index_split_001.html#p105)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Using Exceptions in Our Bank Program](index_split_001.html#p107)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Calling the Same Method on a List of Objects](index_split_002.html#p112)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Interface vs. Implementation](index_split_002.html#p113)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summary](index_split_002.html#p114)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Part II: Graphical User interfaces with Pygame](index_split_002.html#p116)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 5: Introduction to Pygame](index_split_002.html#p118)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Installing Pygame](index_split_002.html#p119)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Window Details](index_split_002.html#p120)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Event-Driven Programs](index_split_002.html#p124)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Using Pygame](index_split_002.html#p125)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Playing Sounds](index_split_002.html#p143)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Drawing Shapes](index_split_002.html#p145)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summary](index_split_002.html#p149)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 6: Object-Oriented Pygame](index_split_002.html#p150)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Building the Screensaver Ball with OOP Pygame](index_split_002.html#p150)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Building a Reusable Object-Oriented Button](index_split_002.html#p156)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Building a Reusable Object-Oriented Text Display](index_split_002.html#p162)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Demo Ball with SimpleText and SimpleButton](index_split_003.html#p164)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Interface vs. Implementation](index_split_003.html#p166)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Callbacks](index_split_003.html#p166)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summary](index_split_003.html#p170)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 7: Pygame GUI Widgets](index_split_003.html#p172)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Passing Arguments into a Function or Method](index_split_003.html#p173)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The pygwidgets Package](index_split_003.html#p177)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The Importance of a Consistent API](index_split_003.html#p187)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summary](index_split_003.html#p187)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Part III: Encapsulation, Polymorphism, and Inheritance](index_split_003.html#p190)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 8: Encapsulation](index_split_003.html#p192)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Encapsulation with Functions](index_split_003.html#p193)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Encapsulation with Objects](index_split_003.html#p193)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Interpretations of Encapsulation](index_split_003.html#p194)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Making Instance Variables More Private](index_split_003.html#p201)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Decorators and @property](index_split_003.html#p203)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Encapsulation in pygwidgets Classes](index_split_003.html#p206)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[A Story from the Real World](index_split_003.html#p207)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Abstraction](index_split_003.html#p208)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summary](index_split_003.html#p211)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 9: Polymorphism](index_split_003.html#p212)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Sending Messages to Real-World Objects](index_split_003.html#p213)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[A Classic Example of Polymorphism in Programming](index_split_003.html#p213)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example Using Pygame Shapes](index_split_003.html#p214)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[pygwidgets Exhibits Polymorphism](index_split_004.html#p221)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Polymorphism for Operators](index_split_004.html#p222)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Creating a String Representation of Values in an Object](index_split_004.html#p232)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[A Fraction Class with Magic Methods](index_split_004.html#p234)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summary](index_split_004.html#p237)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 10: Inheritance](index_split_004.html#p240)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Inheritance in Object-Oriented Programming](index_split_004.html#p241)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Implementing Inheritance](index_split_004.html#p242)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Employee and Manager Example](index_split_004.html#p243)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The Client’s View of a Subclass](index_split_004.html#p247)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Real-World Examples of Inheritance](index_split_004.html#p248)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Multiple Classes Inheriting from the Same Base Class](index_split_004.html#p256)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Abstract Classes and Methods](index_split_004.html#p260)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[How pygwidgets Uses Inheritance](index_split_004.html#p263)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Class Hierarchy](index_split_004.html#p265)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The Difficulty of Programming with Inheritance](index_split_004.html#p267)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summary](index_split_004.html#p268)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 11: Managing Memory Used by Objects](index_split_004.html#p270)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Object Lifetime](index_split_005.html#p271)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Class Variables](index_split_005.html#p277)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Putting It All Together: Balloon Sample Program](index_split_005.html#p280)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Managing Memory: Slots](index_split_005.html#p290)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summary](index_split_005.html#p292)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Part IV: Using OOP in Game Development](index_split_005.html#p294)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 12: Card Games](index_split_005.html#p296)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The Card Class](index_split_005.html#p297)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The Deck Class](index_split_005.html#p299)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The Higher or Lower Game](index_split_005.html#p301)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Testing with __name__](index_split_005.html#p305)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Other Card Games](index_split_005.html#p307)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summary](index_split_005.html#p308)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 13: Timers](index_split_005.html#p310)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Timer Demonstration Program](index_split_005.html#p311)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Three Approaches for Implementing Timers](index_split_005.html#p312)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Installing pyghelpers](index_split_005.html#p316)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The Timer Class](index_split_005.html#p316)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Displaying Time](index_split_005.html#p319)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summary](index_split_005.html#p323)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 14: Animation](index_split_005.html#p324)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Building Animation Classes](index_split_005.html#p325)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Animation Classes in pygwidgets](index_split_006.html#p333)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summary](index_split_006.html#p339)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 15: Scenes](index_split_006.html#p340)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The State Machine Approach](index_split_006.html#p341)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[A pygame Example with a State Machine](index_split_006.html#p343)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[A Scene Manager for Managing Many Scenes](index_split_006.html#p348)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[A Demo Program Using a Scene Manager](index_split_006.html#p349)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Rock, Paper, Scissors Using Scenes](index_split_006.html#p357)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Communication Between Scenes](index_split_006.html#p361)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Implementation of the Scene Manager](index_split_006.html#p363)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summary](index_split_006.html#p369)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 16: Full Game: Dodger](index_split_006.html#p370)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Modal Dialogs](index_split_006.html#p371)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Building a Full Game: Dodger](index_split_006.html#p376)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summary](index_split_007.html#p395)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 17: Design Patterns and Wrap-Up](index_split_007.html#p396)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Model View Controller](index_split_007.html#p396)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Wrap-Up](index_split_007.html#p403)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Index](index_split_007.html#p406)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
