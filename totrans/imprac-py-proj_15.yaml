- en: '**15'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: IMPROVING YOUR ASTROPHOTOGRAPHY WITH PLANET STACKING**
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you’ve ever looked through a telescope at Jupiter, Mars, or Saturn, you were
    probably a little disappointed. The planets appeared small and featureless. You
    wanted to zoom in and crank up the magnification, but it didn’t work. Anything
    bigger than about 200x magnification tends to be blurry.
  prefs: []
  type: TYPE_NORMAL
- en: The problem is air turbulence, or what astronomers call *seeing*. Even on a
    clear night, the air is constantly in motion, with thermal updrafts and downdrafts
    that can easily blur the pinpoints of light that represent celestial objects.
    But with the commercialization of the *charge-coupled device (CCD)* in the 1980s,
    astronomers found a way to overcome the turbulence. Digital photography permits
    a technique known as *image stacking*, in which many photos—some good, some bad—are
    averaged together, or stacked, into a single image. With enough photos, the persistent,
    unchanging features (like a planet’s surface) dominate transient features (like
    a stray cloud). This allows astrophotographers to increase magnification limits,
    as well as compensate for less-than-optimal seeing conditions.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll use a third-party Python module called `pillow` to stack
    hundreds of images of Jupiter. The result will be a single image with a higher
    signal-to-noise ratio than any of the individual frames. You’ll also work with
    files in different folders than your Python code and manipulate both the files
    and folders using the Python operating system (`os`) and shell utilities (`shutil`)
    modules.
  prefs: []
  type: TYPE_NORMAL
- en: '**Project #23: Stacking Jupiter**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Large, bright, and colorful, the gas giant Jupiter is a favorite target of astrophotographers.
    Even amateur telescopes can resolve its orange striping, caused by linear cloud
    bands, and the Great Red Spot, an oval-shaped storm so large it could swallow
    the Earth (see [Figure 15-1](ch15.xhtml#ch15fig1)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0326-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-1: Jupiter as photographed by the Cassini spacecraft*'
  prefs: []
  type: TYPE_NORMAL
- en: Jupiter is a great subject for studying image stacking. Its linear cloud bands
    and Great Red Spot provide the eye with calibration points for judging improvements
    in edge definition and clarity, and its relatively large size makes it easy to
    detect noise.
  prefs: []
  type: TYPE_NORMAL
- en: Noise manifests itself as “graininess.” Each color band has its own artifacts,
    resulting in colored speckles across an image. The main sources of noise are the
    camera (electronic readout noise and thermal signal) and photon noise from the
    light itself, as a variable number of photons strike the sensor over time. Noise
    artifacts are fortunately random in nature and can be largely canceled out by
    stacking images.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE OBJECTIVE**'
  prefs: []
  type: TYPE_NORMAL
- en: Write programs that crop, scale, stack, and enhance images to create a clearer
    photograph of Jupiter.
  prefs: []
  type: TYPE_NORMAL
- en: '**The pillow Module**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To work with images, you’ll need a free third-party Python module called `pillow`.
    It’s the successor project to the Python Imaging Library (PIL), which was discontinued
    in 2011\. The `pillow` module “forked” the PIL repository and upgraded the code
    for Python 3.
  prefs: []
  type: TYPE_NORMAL
- en: You can use `pillow` on Windows, macOS, and Linux, and it supports many image
    formats including PNG, JPEG, GIF, BMP, and TIFF. It offers standard image-manipulation
    procedures, such as altering individual pixels, masking, handling transparency,
    filtering and enhancing, and adding text. But the real strength of `pillow` is
    its ability to edit many images with ease.
  prefs: []
  type: TYPE_NORMAL
- en: Installing `pillow` is easy with the pip tool (for more about pip, see “[Manipulating
    Word Documents with `python-docx`](ch06.xhtml#lev136)” on [page 110](ch06.xhtml#page_110)).
    From the command line, enter pip install pillow.
  prefs: []
  type: TYPE_NORMAL
- en: Most major Linux distributions include `pillow` in packages that previously
    contained PIL, so you may already have `pillow` on your system. Regardless of
    your platform, if PIL is already installed, you’ll need to uninstall it before
    installing `pillow`. For more installation instructions, see *[http://pillow.readthedocs.io/en/latest/installation.html](http://pillow.readthedocs.io/en/latest/installation.html)*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Working with Files and Folders**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In all the previous projects in this book, you’ve kept supporting files and
    modules in the same folder as your Python code. This was handy for simple projects,
    but not very realistic for broad use, and it’s certainly not good when you’re
    dealing with the hundreds of image files you’ll generate in this project. Fortunately,
    Python ships with several modules that can help with this, like `os` and `shutil`.
    But first, I’ll briefly discuss directory paths.
  prefs: []
  type: TYPE_NORMAL
- en: '***Directory Paths***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The directory path is the address to a file or folder. It starts with a root
    directory, which is designated with a letter (such as *C:\*) in Windows, and a
    forward slash (*/*) in Unix-based systems. Additional drives in Windows are assigned
    a different letter than *C*, those in macOS are placed under */volume*, and those
    in Unix under */mnt* (for “mount”).
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*I use the Windows operating system for the examples in this chapter, but you
    can achieve the same result on macOS and other systems. And as is commonly done,
    I use the terms* directory *and* folder *interchangeably here.*'
  prefs: []
  type: TYPE_NORMAL
- en: Pathnames appear differently depending on the operating system. Windows separates
    folders with a backslash (*\*), while macOS and Unix systems use a forward slash
    (*/*). Also, in Unix, folder and file names are case sensitive.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re writing your program in Windows and type in pathnames with backslashes,
    other platforms won’t recognize the paths. Fortunately, the `os.path.join()` method
    will automatically ensure your pathname is suitable for whatever operating system
    Python is running on. Let’s take a look at this, and other examples, in [Listing
    15-1](ch15.xhtml#ch15list1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 15-1: Working with Windows pathnames using the* os *module*'
  prefs: []
  type: TYPE_NORMAL
- en: After importing the `os` module for access to operating system–dependent functionality
    ➊, get the *current working directory*, or *cwd* ➋. The cwd is assigned to a process
    when it starts up; that is, when you run a script from your shell, the cwd of
    the shell and the script will be the same. For a Python program, the cwd is the
    folder that contains the program. When you get the cwd, you’re shown the full
    path. Note that you must use extra backslashes in order to escape the backslash
    characters used as file separators.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you change the cwd using the `os.chdir()` method ➌, passing it the full
    path in quotes, using double backslashes. Then you get the cwd again to see the
    new path.
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t want to type the double backslash, you can enter an r before the
    pathname argument string to convert it to a *raw string* ➍. Raw strings use different
    rules for backslash escape sequences, but even a raw string can’t end in a single
    backslash. The path will still be displayed with double backslashes ➎.
  prefs: []
  type: TYPE_NORMAL
- en: If you want your program to be compatible with all operating systems, use the
    `os.path.join()` method and pass it the folder names and filenames without a separator
    character ➏. The `os.path` methods are aware of the system you’re using and return
    the proper separators. This allows for platform-independent manipulation of filenames
    and folder names.
  prefs: []
  type: TYPE_NORMAL
- en: The `os.path.normpath()` method corrects separators for the system you are using
    ➐. In the Windows example shown, incorrect Unix-type separators are replaced with
    backslashes. Native Windows also supports use of the forward slash and will automatically
    make the conversion ➑.
  prefs: []
  type: TYPE_NORMAL
- en: The full directory path—from the root down—is called the *absolute path*. You
    can use shortcuts, called *relative paths*, to make working with directories easier.
    Relative paths are interpreted from the perspective of the current working directory.
    Whereas absolute paths start with a forward slash or drive label, relative paths
    do not. In the following code snippet, you can change directories without entering
    an absolute path—Python is aware of the new location because it is *within* the
    cwd. Behind the scenes, the relative path is joined to the path leading to the
    cwd to make a complete absolute path.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You can identify folders and save more typing with dot (`.`) and dot-dot (`..`).
    For example, in Windows, `.\` refers to the cwd, and `..\` refers to the parent
    directory that holds the cwd. You can also use a dot to get the absolute path
    to your cwd:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Dot folders can be used in Windows, macOS, and Linux. For more on the `os` module,
    see *[https://docs.python.org/3/library/os.html](https://docs.python.org/3/library/os.html)*.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Shell Utilities Module***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The shell utilities module, `shutil`, provides high-level functions for working
    with files and folders, such as copying, moving, renaming, and deleting. Since
    it’s part of the Python standard library, you can load `shutil` simply by typing
    import shutil. You’ll see example uses for the module in this chapter’s code sections.
    Meanwhile, you can find the module’s documentation at *[https://docs.python.org/3.7/library/shutil.html](https://docs.python.org/3.7/library/shutil.html)*.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Video**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Brooks Clark recorded the color video of Jupiter used in this project on a windy
    night in Houston, Texas. It consists of a 101 MB *.mov* file with a runtime of
    about 16 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: The length of the video is intentionally short. Jupiter’s rotation period is
    about 10 hours, which means still photos may blur with exposure times of only
    a minute, and features you want to reinforce through stacking video frames can
    change positions, greatly complicating the process.
  prefs: []
  type: TYPE_NORMAL
- en: To convert the video frames to individual images, I used Free Studio, a freeware
    set of multimedia programs developed by DVDVideoSoft. The Free Video to JPG Converter
    tool permits the capture of images at constant time or frame intervals. I set
    the interval to sample frames across the full length of the video, to improve
    the odds of capturing some images when the air was still and the seeing good.
  prefs: []
  type: TYPE_NORMAL
- en: A few hundred images should be enough for stacking to show demonstrable improvement.
    In this case, I captured 256 frames.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the folder of images, named *video_frames*, online with the book’s
    resources at *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*.
    Download this folder and retain the name.
  prefs: []
  type: TYPE_NORMAL
- en: An example frame from the video, in grayscale, is shown in [Figure 15-2](ch15.xhtml#ch15fig2).
    Jupiter’s cloud bands are faint and fuzzy, the Great Red Spot isn’t apparent,
    and the image suffers from low contrast, a common side effect of magnification.
    Noise artifacts also give Jupiter a grainy appearance.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0330-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-2: Example frame from the video of Jupiter*'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to those issues, the wind shook the camera, and imprecise tracking
    caused the planet to drift laterally to the left-hand side of the frame. You can
    see an example of *lateral drift* in [Figure 15-3](ch15.xhtml#ch15fig3), in which
    I have overlaid five randomly chosen frames with the black background set to transparent.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0330-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: An example of shake and drift in the Jupiter video based on five
    randomly chosen frames*'
  prefs: []
  type: TYPE_NORMAL
- en: Movement isn’t necessarily a bad thing, because shifting the image around can
    smooth defects associated with the CCD sensor surface, dust on the lens or sensor,
    and so on. But the key assumption in image stacking is that the images perfectly
    align so that persistent features, like Jupiter’s cloud bands, reinforce each
    other as you average the images. For the signal-to-noise ratio to be high, the
    images must be registered.
  prefs: []
  type: TYPE_NORMAL
- en: '*Image registration* is the process of transforming data to the same coordinate
    system so that it can be compared and integrated. Registration is arguably the
    hardest part of image stacking. Astronomers typically use commercial software—such
    as RegiStax, RegiStar, Deep Sky Stacker, or CCDStack—to help them align and stack
    their astrophotos. You’ll get your hands dirty, however, and do this yourself
    using Python.'
  prefs: []
  type: TYPE_NORMAL
- en: '**The Strategy**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The steps required to stack the images are as follows (the first one has already
    been completed):'
  prefs: []
  type: TYPE_NORMAL
- en: Extract images from video recording.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Crop images around Jupiter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scale cropped images to the same size.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stack images into a single image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enhance and filter the final image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**The Code**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can incorporate all the steps into one program, but I chose to distribute
    them across three programs. This is because you generally want to stop and check
    results along the way, plus you may want to run later processes, such as enhancement,
    without having to completely rerun the whole workflow. The first program will
    crop and scale the images, the second will stack them, and the third will enhance
    them.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Cropping and Scaling Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: First, you need to register the images. For large, bright objects like the moon
    and Jupiter, one approach in astrophotography is to crop each image so that its
    four borders are tangent with the surface of the body. This removes most of the
    sky and mitigates any shake and drift issues. Scaling the cropped images will
    ensure they are all the same size and will smooth them slightly to reduce noise.
  prefs: []
  type: TYPE_NORMAL
- en: You can download *crop_n_scale_images.py* from *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*.
    Keep it in the directory that holds the folder of captured video frames.
  prefs: []
  type: TYPE_NORMAL
- en: '**Importing Modules and Defining the main() Function**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 15-2](ch15.xhtml#ch15list2) performs imports and defines the `main()`
    function that runs the *crop_n_scale_images.py* program.'
  prefs: []
  type: TYPE_NORMAL
- en: '*crop_n_scale_images.py,* part 1'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 15-2: Imports modules and defines the* main() *function*'
  prefs: []
  type: TYPE_NORMAL
- en: Start by importing both the operating system (`os`) and system (`sys`) ➊. The
    `os` import already includes an import of `sys`, but this feature may go away
    in the future, so it’s best to manually import `sys` yourself. The `shutil` module
    contains the shell utilities described earlier ➋. From the imaging library, you’ll
    use `Image` to load, crop, convert, and filter images; you’ll also use `ImageOps`
    to scale images ➌. Note you must use PIL, not `pillow`, in the `import` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Start the `main()` function by assigning the name of the starting folder to
    the `frames_folder` variable ➍. This folder contains all the original images captured
    from the video.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll store the cropped images in a new folder named *cropped*, but the shell
    utilities won’t create this folder if it already exists, so call the `del_folders()`
    function that you’ll write in a moment ➎. As written, this function won’t throw
    an error if the folder doesn’t exist, so it can be run safely at any time.
  prefs: []
  type: TYPE_NORMAL
- en: You should always work off a copy of original images, so use the `shutil.copytree()`
    method to copy the folder containing the originals to a new folder named *cropped*
    ➏. Now, switch to this folder ➐ and call the `crop_images()` function, which will
    crop and scale the images. Follow this with the `clean_folder()` function, which
    removes the original video frames that were copied into the *cropped* folder and
    are still hanging around ➑. Note that you use the parameter name when you pass
    the argument to the `clean_folder()` function, since this makes the purpose of
    the function more obvious.
  prefs: []
  type: TYPE_NORMAL
- en: Print `Done!` to let the user know when the program is finished.
  prefs: []
  type: TYPE_NORMAL
- en: '**Deleting and Cleaning Folders**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 15-3](ch15.xhtml#ch15list3) defines helper functions to delete files
    and folders in *crop_n_scale_images.py*. The `shutil` module will refuse to make
    a new folder if one with the same name already exists in the target directory.
    If you want to run the program more than once, you first have to remove or rename
    existing folders. The program will also rename images once they have been cropped,
    and you’ll want to delete the original images before you start stacking them.
    Since there will be hundreds of image files, these functions will automate an
    otherwise laborious task.'
  prefs: []
  type: TYPE_NORMAL
- en: '*crop_n_scale_images.py,* part 2'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 15-3: Defines functions to delete folders and files*'
  prefs: []
  type: TYPE_NORMAL
- en: Define a function called `del_folders()` for deleting folders ➊. The only argument
    will be the name of a folder you want to remove.
  prefs: []
  type: TYPE_NORMAL
- en: Next, list the contents of the folder ➋, then start looping through the contents
    ➌. If the function encounters an item that starts with the folder name and is
    also a directory ➍, use `shutil.rmtree()` to delete the folder ➎. As you’ll see
    in a moment, a different method is used to delete a folder than to delete a file.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Always be careful when using the* rmtree() *method, as it* permanently *deletes
    folders and their contents. You can wipe much of your system, lose important documents
    unrelated to Python projects, and break your computer!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now, define a helper function to “clean” a folder and pass it the name of files
    *that you don’t want to delete* ➏. This is a little counterintuitive at first,
    but since you only want to keep the last batch of images you’ve processed, you
    don’t have to worry about explicitly listing any other files in the folder. If
    the files don’t start with the prefix you provide, such as *cropped*, then they
    are automatically removed.
  prefs: []
  type: TYPE_NORMAL
- en: The process is similar to the last function. List the contents of the folder
    ➐ and start looping through the list. If the file doesn’t start with the prefix
    you provided ➑, use `os.remove()` to delete it ➒.
  prefs: []
  type: TYPE_NORMAL
- en: '**Cropping, Scaling, and Saving Images**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 15-4](ch15.xhtml#ch15list4) registers the frames captured from the
    video by fitting a box around Jupiter and cropping the image to the box ([Figure
    15-4](ch15.xhtml#ch15fig4)). This technique works well with bright images on a
    field of black (see “[Further Reading](ch15.xhtml#lev376)” on [page 343](ch15.xhtml#page_343)
    for another example).'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0334-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: Cropping the original video frame to Jupiter to align the images*'
  prefs: []
  type: TYPE_NORMAL
- en: By cropping the images tightly around Jupiter, you resolve all of the drift
    and shake issues.
  prefs: []
  type: TYPE_NORMAL
- en: Each cropped image is also scaled to a larger and consistent size and smoothed
    slightly to reduce noise. The cropped and scaled images will be kept in their
    own folder, which the `main()` function creates, later.
  prefs: []
  type: TYPE_NORMAL
- en: '*crop_n_scale_images.py,* part 3'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 15-4: Crops initial video frames to a box around Jupiter and rescales*'
  prefs: []
  type: TYPE_NORMAL
- en: The `crop_images()` function takes no argument ➊ but will ultimately work on
    a copy—named *cropped*—of the folder containing the original video frames. You
    made this copy in the `main()` function prior to calling this function.
  prefs: []
  type: TYPE_NORMAL
- en: Start the function by making a list of the contents of the current (*cropped*)
    folder ➋. The program will number each image sequentially, so use `enumerate()`
    with the `for` loop and set the `start` option to `1` ➌. If you haven’t used `enumerate()`
    before, it’s a handy built-in function that acts as an automatic counter; the
    count will be assigned to the `file_num` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Next, name a variable, `img`, to hold the image and use the `open()` method
    to open the file ➍.
  prefs: []
  type: TYPE_NORMAL
- en: To fit the borders of a bounding box to Jupiter, you need all the non-Jupiter
    parts of an image to be black `(0, 0, 0)`. Unfortunately, there are stray, noise-related,
    nonblack pixels beyond Jupiter, and the edge of the planet is diffuse and gradational.
    These issues result in nonuniform box shapes, as shown in [Figure 15-5](ch15.xhtml#ch15fig5).
    Fortunately, you can easily resolve these by converting the image to black and
    white. You can then use this converted image to determine the proper box dimensions
    for each color photo.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0335-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Irregularly sized cropped images due to problems defining the
    bounding box dimensions*'
  prefs: []
  type: TYPE_NORMAL
- en: To eliminate the noise effects that compromise the bounding-box technique, convert
    the loaded image to the “L” mode—consisting of 8-bit black and white pixels—and
    name the variable `gray`, for grayscale ➎. With this mode there is only one channel
    (versus the three channels for RGB color images), so you only need to decide on
    a single value when thresholding—that is, setting a limit above or below which
    an action occurs.
  prefs: []
  type: TYPE_NORMAL
- en: Assign a new variable, called `bw`, to hold a true black-and-white image ➏.
    Use the `point()` method, used to change pixel values, and a lambda function to
    set any value below 90 to black (`0`) and all other values to white (`255`). The
    threshold value was determined through trial and error. The `point()` method now
    returns a clean image for fitting the bounding box ([Figure 15-6](ch15.xhtml#ch15fig6)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0336-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Screen capture of one of the original video frames converted
    to pure black and white*'
  prefs: []
  type: TYPE_NORMAL
- en: Now, call the `Image` module’s `getbox()` method on `bw` ➐. This method prunes
    off black borders by fitting a bounding box to the nonzero regions of an image.
    It returns a tuple with the left, upper, right, and lower pixel coordinates of
    the box.
  prefs: []
  type: TYPE_NORMAL
- en: If you use `box` to crop the video frames, you get an image with borders tangent
    to Jupiter’s surface (see the middle image in [Figure 15-7](ch15.xhtml#ch15fig7)).
    This is what you want, but it’s not visually pleasing. So, add some black padding
    by assigning a new box variable, named `padded_box`, with its edges extended 20
    pixels in all four directions (see the rightmost image in [Figure 15-7](ch15.xhtml#ch15fig7)).
    Because the padding is consistent and applied to all images, it doesn’t compromise
    the results of cropping.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0336-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-7: Initial crop tangent to Jupiter’s surface (*box*) and final crop
    with padding (*padded_box*)*'
  prefs: []
  type: TYPE_NORMAL
- en: Continue by cropping each image with the `crop()` method ➑. This method takes
    `padded_box` as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: To scale the image, use the `ImageOps.fit()` method. This takes the image, a
    size as a pixel width-and-height tuple, a resampling method, a border (`0` = no
    border), and even cropping from the center, designated by the tuple `(0.5, 0.5)`.
    The `pillow` module has several algorithm choices for resizing an image, but I
    chose the popular *Lanczos* filter. Enlarging an image tends to reduce its sharpness,
    but Lanczos can produce *ringing artifacts* along strong edges; this helps increase
    *perceived* sharpness. This unintended edge enhancement can help the eye focus
    on features of interest, which are faint and blurry in the original video frames.
  prefs: []
  type: TYPE_NORMAL
- en: After scaling, assign a `file_name` variable. Each of the 256 cropped images
    will start with *cropped_* and end with the number of the image, which you pass
    to the replacement field of the `format()` method. End the function by saving
    the file ➒.
  prefs: []
  type: TYPE_NORMAL
- en: Back in the global scope, add the code that lets the program run as a module
    or in stand-alone mode.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*I save the files using JPEG format because it is universally readable, handles
    gradations in color well, and takes up very little memory. JPEG uses “lossy” compression,
    however, which causes a tiny bit of image deterioration each time a file is saved;
    you can adjust the degree of compression at the expense of storage size. In most
    cases, when working with astrophotographs, you’ll want to use one of the many
    lossless formats available, such as TIFF.*'
  prefs: []
  type: TYPE_NORMAL
- en: At this point in the workflow, you’ve cropped the original video frames down
    to a box around Jupiter; then you scaled the cropped images to a larger, consistent
    size ([Figure 15-8](ch15.xhtml#ch15fig8)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0337-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-8: Relative sizes of images after cropping and scaling*'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you write the code that stacks the cropped and scaled images.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Stacking Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *stack_images.py* code takes the images produced by the last program and
    averages them so that a single stacked image is produced. You can download it
    from the book’s resources at *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*.
    Keep it in the same folder as the *crop_n_scale_images.py* program.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 15-5](ch15.xhtml#ch15list5) imports modules, loads images, creates
    lists of color channels (red, blue, green), averages the channels, recombines
    the channels, and creates and saves the final stacked image. It’s simple enough
    that we won’t bother with a `main()` function.'
  prefs: []
  type: TYPE_NORMAL
- en: '*stack_images.py*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 15-5: Splits out and averages color channels, then recombines into
    a single image*'
  prefs: []
  type: TYPE_NORMAL
- en: Start by repeating some of the imports you used in the previous program ➊. Next,
    change the current directory to the *cropped* folder, which contains the cropped
    and scaled images of Jupiter ➋, and immediately make a list of the images in the
    folder using `os.listdir()`.
  prefs: []
  type: TYPE_NORMAL
- en: With `pillow`, you can manipulate individual pixels or groups of pixels, and
    you can do this for individual color channels, such as red, blue, and green. To
    demonstrate this, you’ll work on individual color channels to stack the images.
  prefs: []
  type: TYPE_NORMAL
- en: Create three empty lists to hold the RGB pixel data ➌, then start looping through
    the images list ➍. First, open the image. Then, get the width and height of the
    first image, in pixels, as a tuple. Remember, in the previous program, you scaled
    all the small cropped images to a larger size. You’ll need these dimensions later
    for creating the new stacked image, and `size` automatically retrieves this info
    for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now use the `getdata()` method to get the pixel data for the selected image
    ➎. Pass the method the index of the color channel you want: `0` for red, `1` for
    green, and `2` for blue. Append the results to a data list, as appropriate. The
    data from each image will form a separate list in the data lists.'
  prefs: []
  type: TYPE_NORMAL
- en: To average the values in each list, use list comprehension to sum the pixels
    in all the images and divide by the total number of images ➏. Note that you use
    `zip` with the splat (`*`) operator. Your `red_data` list, for example, is a list
    of lists, with each nested list representing one of the 256 image files. Using
    `zip` with `*` unpacks the contents of the lists so that the first pixel in image1
    is summed with the first pixel in image2, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: To merge the averaged color channels, use list comprehension with `zip` ➐. Next,
    create a new image, named `stacked`, using `Image.new()` ➑. Pass the method a
    color mode (`'RGB'`) and the `img_size` tuple containing the desired width and
    height of the image in pixels, which was obtained earlier from one of the cropped
    images.
  prefs: []
  type: TYPE_NORMAL
- en: Populate the new `stacked` image using the `putdata()` method and pass it the
    `merged_data` list ➒. This method copies data from a sequence object into an image,
    starting at the upper-left corner `(0, 0)`. Display the final image using the
    `show()` method. Finish by changing the folder to the parent directory and saving
    the image as a TIFF file named *jupiter_stacked.tif* ➓.
  prefs: []
  type: TYPE_NORMAL
- en: If you compare one of the original video frames to the final stacked image (*jupiter_stacked.tif*),
    as in [Figure 15-9](ch15.xhtml#ch15fig9), you’ll see a clear improvement in edge
    definition and the signal-to-noise ratio. This is best appreciated in color, so
    if you haven’t run the program, take the time to download *Figure 15-9.pdf* from
    the website. When the image is viewed in color, the benefits of the stacking include
    smoother, “creamier” white bands, better-defined red bands, and a more obvious
    Great Red Spot. There is still room for improvement, however, so next you’ll write
    a program to enhance the final stacked image.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0339-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-9: An original video frame compared to final stacked image (*jupiter_stacked.tif*)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If the Great Red Spot looks pinkish to you in the stacked image, that’s because
    it is! It fades from time to time, and many published pictures of Jupiter have
    exaggerated colors due to processing, so this subtle coloration gets lost. This
    is probably for the best, as “Great Pink Spot” just doesn’t have the same ring
    to it.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***The Enhancing Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You’ve successfully stacked all the video frames, but Jupiter is still crooked,
    and its features are faint. You can further improve the stacked image using filters,
    enhancers, and transforms found in `pillow`. As you enhance images, you get further
    and further from the “ground truth” raw data. For this reason, I chose to isolate
    the enhancement process in a separate program.
  prefs: []
  type: TYPE_NORMAL
- en: In general, the first steps after stacking are to enhance details, using high-pass
    filters or an unsharp mask algorithm, and then to fine-tune brightness, contrast,
    and color. The code will use `pillow`’s image enhancement capability to apply
    these steps—though in a different order. You can download the code as *enhance_image.py*
    from *[https://nostarch.com/impracticalpython/](https://nostarch.com/impracticalpython/)*.
    Keep it in the same folder as the previous Python programs.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The processing of astronomical images can be quite involved, and whole books
    have been written on the subject. Some of the standard steps have been omitted
    in this workflow. For instance, the original video was not calibrated, and distortion
    effects due to turbulence were not corrected. Advanced software, such as RegiStax
    or AviStack, can prevent blurring by warping individual images so that distorted
    features, like the edges of cloud bands, overlap properly in all images.*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 15-6](ch15.xhtml#ch15list6) imports `pillow` classes and opens, enhances,
    and saves the stacked image generated by the previous code. Because there are
    many possible options for enhancing images, I chose to modularize this program
    despite its small size.'
  prefs: []
  type: TYPE_NORMAL
- en: '*enhance_image.py*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 15-6: Opens an image, enhances it, and saves it using a new name*'
  prefs: []
  type: TYPE_NORMAL
- en: The import is familiar except for the last two ➊. These new modules, `ImageFilter`
    and `ImageEnhance`, contain predefined filters and classes that can be used to
    alter images with blurring, sharpening, brightening, smoothing, and more (see
    *[https://pillow.readthedocs.io/en/5.1.x/](https://pillow.readthedocs.io/en/5.1.x/)*
    for a full listing of what’s in each module).
  prefs: []
  type: TYPE_NORMAL
- en: Start by defining the `main()` function ➋. Assign the stacked image to a variable
    named `in_file`, then pass it to `Image.open()` to open the file ➌. Next, call
    an `enhance_image()` function and pass it the image variable ➍. Show the enhanced
    image and then save it as a TIFF file, which results in no deterioration in image
    quality.
  prefs: []
  type: TYPE_NORMAL
- en: Now, define an enhancement function, `enhance_image()`, that takes an image
    as an argument ➎. To paraphrase the `pillow` documentation, all enhancement classes
    implement a common interface containing a single method, `enhance(factor)`, that
    returns an enhanced image. The `factor` parameter is a floating-point value controlling
    the enhancement. A value of `1.0` returns a copy of the original; lower values
    diminish color, brightness, contrast, and so on; and higher values increase these
    qualities.
  prefs: []
  type: TYPE_NORMAL
- en: To change the brightness of an image, you first create an instance of the `ImageEnhance`
    module’s `Brightness` class, passing it the original image ➏. Mimic the `pillow`
    docs and name this object `enhancer`. To make the final, enhanced image, you call
    the object’s `enhance()` method and pass it the `factor` argument ➐. In this case,
    you decrease brightness by 0.25\. The `# 0.75` comment at the end of the line
    is a useful way to experiment with different factors. Use this comment to store
    values you like; that way, you can remember and restore them if other test values
    don’t yield pleasing results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Continue enhancing the image, moving to contrast ➑. If you don’t want to adjust
    the contrast manually, you can take a chance and use `pillow`’s automatic contrast
    method. First, import `ImageOps` from PIL. Then, replace the two lines starting
    with step ➑ with the single line: `img_enh = ImageOps.autocontrast(img_enh)`.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, punch up the color. This will help to make the Great Red Spot more visible.
  prefs: []
  type: TYPE_NORMAL
- en: No one wants to look at a tilted Jupiter, so transform the image by rotating
    it to a more “conventional” view, where the cloud bands are horizontal and the
    Great Red Spot is to the lower right. Call the `Image` module’s `rotate()` method
    on the image and pass it an angle, measured counterclockwise in degrees, and have
    it automatically expand the output image to make it large enough to hold the entire
    rotated image ➒.
  prefs: []
  type: TYPE_NORMAL
- en: Now, sharpen the image. Even on high-quality images, sharpening may be needed
    to ameliorate the interpolation effects of converting data, resizing and rotating
    images, and so on. Although some astrophotography resources recommend placing
    it first, in most image-processing workflows, it comes last. This is because it
    is dependent on the final size of the image (viewing distance), as well as the
    media being used. Sharpening can also increase noise artifacts and is a “lossy”
    operation that can remove data—things you don’t want to happen prior to other
    edits.
  prefs: []
  type: TYPE_NORMAL
- en: Sharpening is a little different from the previous enhancements, as you use
    the `ImageFilter` class. No intermediate step is needed; you can build the new
    image with a single line by calling the `filter()` method on the image object
    and passing it the predefined `SHARPEN` filter ➓. The `pillow` module has other
    filters that help define edges, such as `UnsharpMask` and `EDGE_ENHANCE`, but
    for this image, the results are indiscernible from `SHARPEN`.
  prefs: []
  type: TYPE_NORMAL
- en: Finish by returning the image and applying the code to run the program as a
    module or in stand-alone mode.
  prefs: []
  type: TYPE_NORMAL
- en: The final enhanced image is compared to a random video frame and the final stacked
    image in [Figure 15-10](ch15.xhtml#ch15fig10). All the images have been rotated
    for ease of comparison.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0342-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-10: A random video frame, the results of stacking 256 frames, and
    the final enhanced image*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see the improvement best when you view it in color. If you want to see
    a color version prior to running the program, view or download *Figure 15-10.pdf*
    from the website.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you’re familiar with* pillow*, you may be aware that you can use the* Image.blend()
    *method to stack images with only a few lines of code. To my eye, however, the
    resulting image is noticeably noisier than that obtained by breaking out and averaging
    the individual color channels, as you did with the* stack_images.py *program.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The final image in [Figure 15-10](ch15.xhtml#ch15fig10) will never win any awards
    or be featured in *Sky & Telescope* magazine, but the point was to take on a challenge.
    And the result is a marked improvement over a single image captured from the video.
    The colors are brighter, the cloud bands sharper, and the Great Red Spot better
    defined. You can also make out the turbulent zone downwind of the Great Red Spot
    (refer to [Figure 15-1](ch15.xhtml#ch15fig1)).
  prefs: []
  type: TYPE_NORMAL
- en: Despite starting with rough input, you were able to register the images, remove
    noise through stacking, and enhance the final image using filters and transforms.
    And all these steps were accomplished with the freely available `pillow` fork
    of the Python Imaging Library. You also gained experience with the Python `shutil`
    and `os` modules, which you used to manipulate files and folders.
  prefs: []
  type: TYPE_NORMAL
- en: For more advanced image processing, you can use OpenSource Computer Vision (OpenCV),
    which you implement by installing and importing the `cv2` and `NumPy` modules.
    Other options involve `matplotlib`, `SciPy`, and `NumPy`. As always with Python,
    there’s more than one way to skin a cat!
  prefs: []
  type: TYPE_NORMAL
- en: '**Further Reading**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Automate the Boring Stuff with Python: Practical Programming for Total Beginners*
    (No Starch Press, 2015) by Al Sweigart includes several useful chapters on working
    with files, folders, and `pillow`.'
  prefs: []
  type: TYPE_NORMAL
- en: Online resources for using Python with astronomy include Python for Astronomers
    (*[https://prappleizer.github.io/](https://prappleizer.github.io/)*) and Practical
    Python for Astronomers (*[https://python4astronomers.github.io/](https://python4astronomers.github.io/)*).
  prefs: []
  type: TYPE_NORMAL
- en: If you want to learn more about the OpenCV-Python library, you can find tutorials
    at *[https://docs.opencv.org/3.4.2/d0/de3/tutorial_py_intro.html](https://docs.opencv.org/3.4.2/d0/de3/tutorial_py_intro.html)*.
    Note that knowledge of `NumPy` is a prerequisite for the tutorials and for writing
    optimized OpenCV code. Alternatively, SimpleCV lets you get started with computer
    vision and image manipulation with a smaller learning curve than OpenCV but only
    works with Python 2.
  prefs: []
  type: TYPE_NORMAL
- en: '*Astrophotography* (Rocky Nook, 2014) by Thierry Legault is an indispensable
    resource for anyone interested in serious astrophotography. A comprehensive and
    readable reference, it covers all aspects of the subject, from equipment selection
    through image processing.'
  prefs: []
  type: TYPE_NORMAL
- en: “Aligning Sun Images Using Python” (LabJG, 2013), a blog by James Gilbert, contains
    code for cropping the sun using the bounding-box technique. It also includes a
    clever method for realigning rotated images of the sun using sunspots as registration
    points. You can find it at *[https://labjg.wordpress.com/2013/04/01/aligning-sun-images-using-python/](https://labjg.wordpress.com/2013/04/01/aligning-sun-images-using-python/)*.
  prefs: []
  type: TYPE_NORMAL
- en: A Google research team figured out how to use stacking to remove watermarks
    from images on stock photography websites and how the websites could better protect
    their property. You can read about it at *[https://research.googleblog.com/2017/08/making-visible-watermarks-more-effective.html](https://research.googleblog.com/2017/08/making-visible-watermarks-more-effective.html)*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Challenge Project: Vanishing Act**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Image-stacking techniques can do more than just remove noise—they can remove
    anything that moves at a photo site, including people. Adobe Photoshop, for example,
    has a stack script that makes nonstationary objects magically vanish. It relies
    on a statistical average known as the *median*, which is simply the “middle” value
    in a list of numbers arranged from smallest to largest. The process requires multiple
    photos—preferably taken with a tripod-mounted camera—so that the objects you want
    to remove change positions from one image to the next, while the background remains
    constant. You typically need 10 to 30 pictures taken about 20 seconds apart, or
    similarly spaced frames extracted from a video.
  prefs: []
  type: TYPE_NORMAL
- en: With the mean, you sum numbers and divide by the total. With the median, you
    sort numbers and choose the middle value. In [Figure 15-11](ch15.xhtml#ch15fig11),
    a row of five images is shown with the same pixel location outlined in each. In
    the fourth image, a blackbird has flown by and ruined the splendid white background.
    If you stack with the mean, the bird’s presence lingers. But do a median stack
    on the images—that is, sort the red, green, and blue channels and take the middle
    values—and you get the background value for each channel (`255`). No trace of
    the bird remains.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0344-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-11: Five white images with the same pixel highlighted and its RGB
    values displayed. Median-stacking removes the black pixel.*'
  prefs: []
  type: TYPE_NORMAL
- en: When you average using the median, spurious values get pushed to the ends of
    the list. This makes it easy to remove outliers, such as satellites or airplanes
    in astrophotos, so long as the number of images containing the outlier is less
    than half the number of images.
  prefs: []
  type: TYPE_NORMAL
- en: Armed with this knowledge, write an image-stacking program that will remove
    unwanted tourists from your vacation happy snaps. For testing, you can download
    the *moon_cropped* folder from the website, which contains five synthetic images
    of the moon, each “ruined” by a passing plane (see [Figure 15-12](ch15.xhtml#ch15fig12)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0345-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-12: Synthetic moon photos for testing the median averaging approach*'
  prefs: []
  type: TYPE_NORMAL
- en: Your final stacked image should contain no evidence of the plane ([Figure 15-13](ch15.xhtml#ch15fig13)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0345-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-13: Result of stacking the images in the* moon_cropped *folder using
    median averaging*'
  prefs: []
  type: TYPE_NORMAL
- en: As this is a challenge project, no solution is provided.
  prefs: []
  type: TYPE_NORMAL
