- en: '**15'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: IMPROVING YOUR ASTROPHOTOGRAPHY WITH PLANET STACKING**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: If you’ve ever looked through a telescope at Jupiter, Mars, or Saturn, you were
    probably a little disappointed. The planets appeared small and featureless. You
    wanted to zoom in and crank up the magnification, but it didn’t work. Anything
    bigger than about 200x magnification tends to be blurry.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: The problem is air turbulence, or what astronomers call *seeing*. Even on a
    clear night, the air is constantly in motion, with thermal updrafts and downdrafts
    that can easily blur the pinpoints of light that represent celestial objects.
    But with the commercialization of the *charge-coupled device (CCD)* in the 1980s,
    astronomers found a way to overcome the turbulence. Digital photography permits
    a technique known as *image stacking*, in which many photos—some good, some bad—are
    averaged together, or stacked, into a single image. With enough photos, the persistent,
    unchanging features (like a planet’s surface) dominate transient features (like
    a stray cloud). This allows astrophotographers to increase magnification limits,
    as well as compensate for less-than-optimal seeing conditions.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll use a third-party Python module called pillow to stack
    hundreds of images of Jupiter. The result will be a single image with a higher
    signal-to-noise ratio than any of the individual frames. You’ll also work with
    files in different folders than your Python code and manipulate both the files
    and folders using the Python operating system (os) and shell utilities (shutil)
    modules.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: '**Project #23: Stacking Jupiter**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Large, bright, and colorful, the gas giant Jupiter is a favorite target of astrophotographers.
    Even amateur telescopes can resolve its orange striping, caused by linear cloud
    bands, and the Great Red Spot, an oval-shaped storm so large it could swallow
    the Earth (see [Figure 15-1](ch15.xhtml#ch15fig1)).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0326-01.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-1: Jupiter as photographed by the Cassini spacecraft*'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Jupiter is a great subject for studying image stacking. Its linear cloud bands
    and Great Red Spot provide the eye with calibration points for judging improvements
    in edge definition and clarity, and its relatively large size makes it easy to
    detect noise.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Noise manifests itself as “graininess.” Each color band has its own artifacts,
    resulting in colored speckles across an image. The main sources of noise are the
    camera (electronic readout noise and thermal signal) and photon noise from the
    light itself, as a variable number of photons strike the sensor over time. Noise
    artifacts are fortunately random in nature and can be largely canceled out by
    stacking images.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '**THE OBJECTIVE**'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Write programs that crop, scale, stack, and enhance images to create a clearer
    photograph of Jupiter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '**The pillow Module**'
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To work with images, you’ll need a free third-party Python module called pillow.
    It’s the successor project to the Python Imaging Library (PIL), which was discontinued
    in 2011\. The pillow module “forked” the PIL repository and upgraded the code
    for Python 3.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: You can use pillow on Windows, macOS, and Linux, and it supports many image
    formats including PNG, JPEG, GIF, BMP, and TIFF. It offers standard image-manipulation
    procedures, such as altering individual pixels, masking, handling transparency,
    filtering and enhancing, and adding text. But the real strength of pillow is its
    ability to edit many images with ease.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Installing pillow is easy with the pip tool (for more about pip, see “[Manipulating
    Word Documents with python-docx](ch06.xhtml#lev136)” on [page 110](ch06.xhtml#page_110)).
    From the command line, enter pip install pillow.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Most major Linux distributions include pillow in packages that previously contained
    PIL, so you may already have pillow on your system. Regardless of your platform,
    if PIL is already installed, you’ll need to uninstall it before installing pillow.
    For more installation instructions, see *[http://pillow.readthedocs.io/en/latest/installation.html](http://pillow.readthedocs.io/en/latest/installation.html)*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '**Working with Files and Folders**'
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In all the previous projects in this book, you’ve kept supporting files and
    modules in the same folder as your Python code. This was handy for simple projects,
    but not very realistic for broad use, and it’s certainly not good when you’re
    dealing with the hundreds of image files you’ll generate in this project. Fortunately,
    Python ships with several modules that can help with this, like os and shutil.
    But first, I’ll briefly discuss directory paths.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '***Directory Paths***'
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The directory path is the address to a file or folder. It starts with a root
    directory, which is designated with a letter (such as *C:\*) in Windows, and a
    forward slash (*/*) in Unix-based systems. Additional drives in Windows are assigned
    a different letter than *C*, those in macOS are placed under */volume*, and those
    in Unix under */mnt* (for “mount”).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '*I use the Windows operating system for the examples in this chapter, but you
    can achieve the same result on macOS and other systems. And as is commonly done,
    I use the terms* directory *and* folder *interchangeably here.*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Pathnames appear differently depending on the operating system. Windows separates
    folders with a backslash (*\*), while macOS and Unix systems use a forward slash
    (*/*). Also, in Unix, folder and file names are case sensitive.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: If you’re writing your program in Windows and type in pathnames with backslashes,
    other platforms won’t recognize the paths. Fortunately, the os.path.join() method
    will automatically ensure your pathname is suitable for whatever operating system
    Python is running on. Let’s take a look at this, and other examples, in [Listing
    15-1](ch15.xhtml#ch15list1).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: ➊ >>> import os
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: ➋ >>> os.getcwd()
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '''C:\\Python35\\Lib\\idlelib'''
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: ➌ >>> os.chdir('C:\\Python35\\Python 3 Stuff')
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ >>> os.chdir('C:\\Python35\\Python 3 Stuff')
- en: '>>> os.getcwd()'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> os.getcwd()'
- en: '''C:\\Python35\\Python 3 Stuff'''
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '''C:\\Python35\\Python 3 Stuff'''
- en: ➍ >>> os.chdir(r'C:\Python35\Python 3 Stuff\Planet Stacking')
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ >>> os.chdir(r'C:\Python35\Python 3 Stuff\Planet Stacking')
- en: '>>> os.getcwd()'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> os.getcwd()'
- en: ➎ 'C:\\Python35\\Python 3 Stuff\\Planet Stacking'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ 'C:\\Python35\\Python 3 Stuff\\Planet Stacking'
- en: ➏ >>> os.path.join('Planet Stacking', 'stack_8', '8file262.jpg')
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: ➏ >>> os.path.join('Planet Stacking', 'stack_8', '8file262.jpg')
- en: '''Planet Stacking\\stack_8\\8file262.jpg'''
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '''Planet Stacking\\stack_8\\8file262.jpg'''
- en: ➐ >>> os.path.normpath('C:/Python35/Python 3 Stuff')
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: ➐ >>> os.path.normpath('C:/Python35/Python 3 Stuff')
- en: '''C:\\Python35\\Python 3 Stuff'''
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '''C:\\Python35\\Python 3 Stuff'''
- en: ➑ >>> os.chdir('C:/Python35')
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ➑ >>> os.chdir('C:/Python35')
- en: '>>> os.getcwd()'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> os.getcwd()'
- en: '''C:\\Python35'''
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '''C:\\Python35'''
- en: '*Listing 15-1: Working with Windows pathnames using the* os *module*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 15-1：使用* os *模块处理 Windows 路径名*'
- en: After importing the os module for access to operating system–dependent functionality
    ➊, get the *current working directory*, or *cwd* ➋. The cwd is assigned to a process
    when it starts up; that is, when you run a script from your shell, the cwd of
    the shell and the script will be the same. For a Python program, the cwd is the
    folder that contains the program. When you get the cwd, you’re shown the full
    path. Note that you must use extra backslashes in order to escape the backslash
    characters used as file separators.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入 os 模块以访问操作系统相关的功能 ➊ 后，获取*当前工作目录*，或 *cwd* ➋。cwd 在进程启动时会被分配；也就是说，当你从 shell
    运行脚本时，shell 和脚本的 cwd 会相同。对于 Python 程序，cwd 就是包含程序的文件夹。当你获取 cwd 时，会显示完整路径。注意，你必须使用额外的反斜杠来转义作为文件分隔符的反斜杠字符。
- en: Next, you change the cwd using the os.chdir() method ➌, passing it the full
    path in quotes, using double backslashes. Then you get the cwd again to see the
    new path.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用 os.chdir() 方法 ➌，传入带引号的完整路径，并使用双反斜杠来更改当前工作目录（cwd）。然后再次获取 cwd，以查看新的路径。
- en: If you don’t want to type the double backslash, you can enter an r before the
    pathname argument string to convert it to a *raw string* ➍. Raw strings use different
    rules for backslash escape sequences, but even a raw string can’t end in a single
    backslash. The path will still be displayed with double backslashes ➎.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想输入双反斜杠，可以在路径名参数字符串前加上 r，将其转换为*原始字符串* ➍。原始字符串使用不同的反斜杠转义规则，但即便是原始字符串，也不能以单个反斜杠结尾。路径仍然会显示为双反斜杠
    ➎。
- en: If you want your program to be compatible with all operating systems, use the
    os.path.join() method and pass it the folder names and filenames without a separator
    character ➏. The os.path methods are aware of the system you’re using and return
    the proper separators. This allows for platform-independent manipulation of filenames
    and folder names.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望你的程序兼容所有操作系统，可以使用 os.path.join() 方法，并将文件夹名和文件名传递给它，且不使用分隔符字符 ➏。os.path
    方法会根据你使用的系统返回正确的分隔符，这使得文件名和文件夹名可以在不同平台之间独立操作。
- en: The os.path.normpath() method corrects separators for the system you are using
    ➐. In the Windows example shown, incorrect Unix-type separators are replaced with
    backslashes. Native Windows also supports use of the forward slash and will automatically
    make the conversion ➑.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: os.path.normpath() 方法会根据你使用的系统纠正分隔符 ➐。以 Windows 示例为例，不正确的 Unix 类型分隔符会被替换为反斜杠。原生
    Windows 系统也支持使用正斜杠，并会自动进行转换 ➑。
- en: The full directory path—from the root down—is called the *absolute path*. You
    can use shortcuts, called *relative paths*, to make working with directories easier.
    Relative paths are interpreted from the perspective of the current working directory.
    Whereas absolute paths start with a forward slash or drive label, relative paths
    do not. In the following code snippet, you can change directories without entering
    an absolute path—Python is aware of the new location because it is *within* the
    cwd. Behind the scenes, the relative path is joined to the path leading to the
    cwd to make a complete absolute path.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的目录路径，从根目录开始，称为*绝对路径*。你可以使用称为*相对路径*的快捷方式，使得目录操作更加简便。相对路径是从当前工作目录的角度进行解析的。而绝对路径从正斜杠或驱动器标签开始，相对路径则不是。以下代码片段中，你可以在不输入绝对路径的情况下更改目录——Python
    会意识到新的位置，因为它*位于* cwd 之内。幕后，Python 会将相对路径与通向 cwd 的路径连接起来，形成一个完整的绝对路径。
- en: '>>> os.getcwd()'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> os.getcwd()'
- en: '''C:\\Python35\\Python 3 Stuff'''
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '''C:\\Python35\\Python 3 Stuff'''
- en: '>>> os.chdir(''Planet Stacking'')'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> os.chdir(''Planet Stacking'')'
- en: '>>> os.getcwd()'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> os.getcwd()'
- en: '''C:\\Python35\\Python 3 Stuff\\Planet Stacking'''
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '''C:\\Python35\\Python 3 Stuff\\Planet Stacking'''
- en: 'You can identify folders and save more typing with dot (.) and dot-dot (..).
    For example, in Windows, .\ refers to the cwd, and ..\ refers to the parent directory
    that holds the cwd. You can also use a dot to get the absolute path to your cwd:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过点（.）和点点（..）来识别文件夹并减少输入。例如，在Windows中，.\ 指代当前工作目录（cwd），而..\ 指代包含当前工作目录的父目录。你还可以使用点来获取当前工作目录的绝对路径：
- en: '>>> os.path.abspath(''.'')'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> os.path.abspath(''.'')'
- en: '''C:\\Python35\\Python 3 Stuff\\Planet Stacking\\for_book'''
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '''C:\\Python35\\Python 3 Stuff\\Planet Stacking\\for_book'''
- en: Dot folders can be used in Windows, macOS, and Linux. For more on the os module,
    see *[https://docs.python.org/3/library/os.html](https://docs.python.org/3/library/os.html)*.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 点文件夹可以在 Windows、macOS 和 Linux 中使用。有关 os 模块的更多信息，请参阅 *[https://docs.python.org/3/library/os.html](https://docs.python.org/3/library/os.html)*。
- en: '***The Shell Utilities Module***'
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Shell 工具模块***'
- en: The shell utilities module, shutil, provides high-level functions for working
    with files and folders, such as copying, moving, renaming, and deleting. Since
    it’s part of the Python standard library, you can load shutil simply by typing
    import shutil. You’ll see example uses for the module in this chapter’s code sections.
    Meanwhile, you can find the module’s documentation at *[https://docs.python.org/3.7/library/shutil.html](https://docs.python.org/3.7/library/shutil.html)*.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: shell 工具模块 shutil 提供了用于处理文件和文件夹的高级功能，如复制、移动、重命名和删除。由于它是 Python 标准库的一部分，你只需输入
    `import shutil` 就可以加载该模块。在本章的代码部分，你将看到该模块的示例用法。同时，你可以在 *[https://docs.python.org/3.7/library/shutil.html](https://docs.python.org/3.7/library/shutil.html)*
    查阅该模块的文档。
- en: '**The Video**'
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**视频**'
- en: Brooks Clark recorded the color video of Jupiter used in this project on a windy
    night in Houston, Texas. It consists of a 101 MB *.mov* file with a runtime of
    about 16 seconds.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Brooks Clark 在德克萨斯州休斯敦的一个有风的夜晚录制了本项目中使用的木星彩色视频。视频文件为 101 MB 的 *.mov* 文件，时长约
    16 秒。
- en: The length of the video is intentionally short. Jupiter’s rotation period is
    about 10 hours, which means still photos may blur with exposure times of only
    a minute, and features you want to reinforce through stacking video frames can
    change positions, greatly complicating the process.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 视频的长度故意设置得很短。木星的自转周期大约为 10 小时，这意味着在曝光时间仅为一分钟的情况下，静态照片可能会模糊，而你希望通过堆叠视频帧来增强的特征可能会发生位置变化，极大地增加了处理的复杂性。
- en: To convert the video frames to individual images, I used Free Studio, a freeware
    set of multimedia programs developed by DVDVideoSoft. The Free Video to JPG Converter
    tool permits the capture of images at constant time or frame intervals. I set
    the interval to sample frames across the full length of the video, to improve
    the odds of capturing some images when the air was still and the seeing good.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将视频帧转换为单独的图像，我使用了 Free Studio，这是一个由 DVDVideoSoft 开发的多媒体免费软件集。Free Video to
    JPG Converter 工具可以按固定时间或帧间隔捕捉图像。我将间隔设置为覆盖整个视频的帧，以提高在空气平静、能见度良好的时候捕捉到一些图像的概率。
- en: A few hundred images should be enough for stacking to show demonstrable improvement.
    In this case, I captured 256 frames.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 几百张图像应该足以通过堆叠显示出可见的改善。在这个例子中，我捕捉了 256 帧。
- en: You can find the folder of images, named *video_frames*, online with the book’s
    resources at *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*.
    Download this folder and retain the name.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在书籍的在线资源中找到名为 *video_frames* 的图像文件夹，网址为 *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*。下载此文件夹并保持文件夹名称不变。
- en: An example frame from the video, in grayscale, is shown in [Figure 15-2](ch15.xhtml#ch15fig2).
    Jupiter’s cloud bands are faint and fuzzy, the Great Red Spot isn’t apparent,
    and the image suffers from low contrast, a common side effect of magnification.
    Noise artifacts also give Jupiter a grainy appearance.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 来自视频的示例帧（灰度图）显示在[图 15-2](ch15.xhtml#ch15fig2)中。木星的云带模糊且淡薄，大红斑不明显，图像对比度低，这是放大常见的副作用。噪声伪影也使木星看起来颗粒感较强。
- en: '![image](../images/f0330-01.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0330-01.jpg)'
- en: '*Figure 15-2: Example frame from the video of Jupiter*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-2：来自木星视频的示例帧*'
- en: In addition to those issues, the wind shook the camera, and imprecise tracking
    caused the planet to drift laterally to the left-hand side of the frame. You can
    see an example of *lateral drift* in [Figure 15-3](ch15.xhtml#ch15fig3), in which
    I have overlaid five randomly chosen frames with the black background set to transparent.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些问题外，风还摇动了相机，不精确的跟踪导致行星向画面左侧漂移。你可以在[图 15-3](ch15.xhtml#ch15fig3)中看到 *横向漂移*
    的示例，其中我将五个随机选定的帧叠加，并将黑色背景设为透明。
- en: '![image](../images/f0330-02.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: An example of shake and drift in the Jupiter video based on five
    randomly chosen frames*'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Movement isn’t necessarily a bad thing, because shifting the image around can
    smooth defects associated with the CCD sensor surface, dust on the lens or sensor,
    and so on. But the key assumption in image stacking is that the images perfectly
    align so that persistent features, like Jupiter’s cloud bands, reinforce each
    other as you average the images. For the signal-to-noise ratio to be high, the
    images must be registered.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '*Image registration* is the process of transforming data to the same coordinate
    system so that it can be compared and integrated. Registration is arguably the
    hardest part of image stacking. Astronomers typically use commercial software—such
    as RegiStax, RegiStar, Deep Sky Stacker, or CCDStack—to help them align and stack
    their astrophotos. You’ll get your hands dirty, however, and do this yourself
    using Python.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '**The Strategy**'
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The steps required to stack the images are as follows (the first one has already
    been completed):'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Extract images from video recording.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Crop images around Jupiter.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scale cropped images to the same size.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stack images into a single image.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enhance and filter the final image.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**The Code**'
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can incorporate all the steps into one program, but I chose to distribute
    them across three programs. This is because you generally want to stop and check
    results along the way, plus you may want to run later processes, such as enhancement,
    without having to completely rerun the whole workflow. The first program will
    crop and scale the images, the second will stack them, and the third will enhance
    them.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '***The Cropping and Scaling Code***'
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: First, you need to register the images. For large, bright objects like the moon
    and Jupiter, one approach in astrophotography is to crop each image so that its
    four borders are tangent with the surface of the body. This removes most of the
    sky and mitigates any shake and drift issues. Scaling the cropped images will
    ensure they are all the same size and will smooth them slightly to reduce noise.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: You can download *crop_n_scale_images.py* from *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*.
    Keep it in the directory that holds the folder of captured video frames.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '**Importing Modules and Defining the main() Function**'
  id: totrans-87
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 15-2](ch15.xhtml#ch15list2) performs imports and defines the main()
    function that runs the *crop_n_scale_images.py* program.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '*crop_n_scale_images.py,* part 1'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: ➊ import os
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: import sys
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: ➋ import shutil
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: ➌ from PIL import Image, ImageOps
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'def main():'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '"""Get starting folder, copy folder, run crop function, & clean folder."""'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '# get name of folder in cwd with original video images'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: ➍ frames_folder = 'video_frames'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '# prepare files & folders'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: ➎ del_folders('cropped')
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: ➏ shutil.copytree(frames_folder, 'cropped')
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '# run cropping function'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: print("start cropping and scaling...")
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: ➐ os.chdir('cropped')
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: crop_images()
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: ➑ clean_folder(prefix_to_save='cropped')  # delete uncropped originals
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: print("Done! \n")
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 15-2: Imports modules and defines the* main() *function*'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Start by importing both the operating system (os) and system (sys) ➊. The os
    import already includes an import of sys, but this feature may go away in the
    future, so it’s best to manually import sys yourself. The shutil module contains
    the shell utilities described earlier ➋. From the imaging library, you’ll use
    Image to load, crop, convert, and filter images; you’ll also use ImageOps to scale
    images ➌. Note you must use PIL, not pillow, in the import statement.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Start the main() function by assigning the name of the starting folder to the
    frames_folder variable ➍. This folder contains all the original images captured
    from the video.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: You’ll store the cropped images in a new folder named *cropped*, but the shell
    utilities won’t create this folder if it already exists, so call the del_folders()
    function that you’ll write in a moment ➎. As written, this function won’t throw
    an error if the folder doesn’t exist, so it can be run safely at any time.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: You should always work off a copy of original images, so use the shutil.copytree()
    method to copy the folder containing the originals to a new folder named *cropped*
    ➏. Now, switch to this folder ➐ and call the crop_images() function, which will
    crop and scale the images. Follow this with the clean_folder() function, which
    removes the original video frames that were copied into the *cropped* folder and
    are still hanging around ➑. Note that you use the parameter name when you pass
    the argument to the clean_folder() function, since this makes the purpose of the
    function more obvious.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Print Done! to let the user know when the program is finished.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '**Deleting and Cleaning Folders**'
  id: totrans-113
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 15-3](ch15.xhtml#ch15list3) defines helper functions to delete files
    and folders in *crop_n_scale_images.py*. The shutil module will refuse to make
    a new folder if one with the same name already exists in the target directory.
    If you want to run the program more than once, you first have to remove or rename
    existing folders. The program will also rename images once they have been cropped,
    and you’ll want to delete the original images before you start stacking them.
    Since there will be hundreds of image files, these functions will automate an
    otherwise laborious task.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '*crop_n_scale_images.py,* part 2'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '➊ def del_folders(name):'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '"""If a folder with a named prefix exists in directory, delete it."""'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: ➋ contents = os.listdir()
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '➌ for item in contents:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '➍ if os.path.isdir(item) and item.startswith(name):'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: ➎ shutil.rmtree(item)
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '➏ def clean_folder(prefix_to_save):'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '"""Delete all files in folder except those with a named prefix."""'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: ➐ files = os.listdir()
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'for file in files:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '➑ if not file.startswith(prefix_to_save):'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: ➒ os.remove(file)
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 15-3: Defines functions to delete folders and files*'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Define a function called del_folders() for deleting folders ➊. The only argument
    will be the name of a folder you want to remove.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个名为 del_folders() 的函数，用于删除文件夹 ➊。唯一的参数将是你想删除的文件夹的名称。
- en: Next, list the contents of the folder ➋, then start looping through the contents
    ➌. If the function encounters an item that starts with the folder name and is
    also a directory ➍, use shutil.rmtree() to delete the folder ➎. As you’ll see
    in a moment, a different method is used to delete a folder than to delete a file.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，列出文件夹的内容 ➋，然后开始遍历内容 ➌。若函数遇到以文件夹名称开头且本身是目录的项目 ➍，则使用 shutil.rmtree() 删除该文件夹
    ➎。正如你稍后会看到的，删除文件夹与删除文件使用的是不同的方法。
- en: '**NOTE**'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Always be careful when using the* rmtree() *method, as it* permanently *deletes
    folders and their contents. You can wipe much of your system, lose important documents
    unrelated to Python projects, and break your computer!*'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用* rmtree() *方法时要小心，因为它* 永久 *删除文件夹及其内容。你可能会擦除系统中的大部分内容，丢失与 Python 项目无关的重要文档，甚至可能破坏你的电脑！*'
- en: Now, define a helper function to “clean” a folder and pass it the name of files
    *that you don’t want to delete* ➏. This is a little counterintuitive at first,
    but since you only want to keep the last batch of images you’ve processed, you
    don’t have to worry about explicitly listing any other files in the folder. If
    the files don’t start with the prefix you provide, such as *cropped*, then they
    are automatically removed.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，定义一个辅助函数来“清理”一个文件夹，并传入你*不想删除*的文件名 ➏。一开始这可能有点反直觉，但由于你只想保留最后一批处理过的图像，因此不需要明确列出文件夹中的任何其他文件。如果文件名没有以你提供的前缀（如
    *cropped*）开头，那么它们会被自动删除。
- en: The process is similar to the last function. List the contents of the folder
    ➐ and start looping through the list. If the file doesn’t start with the prefix
    you provided ➑, use os.remove() to delete it ➒.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程与上一个函数类似。列出文件夹的内容 ➐，然后开始循环遍历列表。如果文件名没有以你提供的前缀 ➑ 开头，使用 os.remove() 删除该文件
    ➒。
- en: '**Cropping, Scaling, and Saving Images**'
  id: totrans-135
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**裁剪、缩放和保存图像**'
- en: '[Listing 15-4](ch15.xhtml#ch15list4) registers the frames captured from the
    video by fitting a box around Jupiter and cropping the image to the box ([Figure
    15-4](ch15.xhtml#ch15fig4)). This technique works well with bright images on a
    field of black (see “[Further Reading](ch15.xhtml#lev376)” on [page 343](ch15.xhtml#page_343)
    for another example).'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 15-4](ch15.xhtml#ch15list4) 通过围绕木星拟合一个框并裁剪图像到该框来注册从视频中捕获的帧（[图 15-4](ch15.xhtml#ch15fig4)）。这种技术对于黑色背景上的亮图像非常有效（有关另一个示例，请参见[进一步阅读](ch15.xhtml#lev376)，第
    [343 页](ch15.xhtml#page_343)）。'
- en: '![image](../images/f0334-01.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0334-01.jpg)'
- en: '*Figure 15-4: Cropping the original video frame to Jupiter to align the images*'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-4：裁剪原始视频帧到木星，以对齐图像*'
- en: By cropping the images tightly around Jupiter, you resolve all of the drift
    and shake issues.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将图像紧密裁剪到木星周围，你解决了所有的漂移和抖动问题。
- en: Each cropped image is also scaled to a larger and consistent size and smoothed
    slightly to reduce noise. The cropped and scaled images will be kept in their
    own folder, which the main() function creates, later.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 每个裁剪后的图像还会被缩放到一个更大且一致的尺寸，并稍微平滑以减少噪点。裁剪并缩放后的图像将保存在它们自己的文件夹中，主函数 `main()` 会在稍后创建该文件夹。
- en: '*crop_n_scale_images.py,* part 3'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*crop_n_scale_images.py,* 第 3 部分'
- en: '➊ def crop_images():'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ def crop_images():'
- en: '"""Crop and scale images of a planet to box around planet."""'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '"""裁剪并缩放行星图像，使其围绕行星的框进行裁剪。"""'
- en: ➋ files = os.listdir()
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ files = os.listdir()
- en: '➌ for file_num, file in enumerate(files, start=1):'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '➌ for file_num, file in enumerate(files, start=1):'
- en: '➍ with Image.open(file) as img:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '➍ with Image.open(file) as img:'
- en: ➎ gray = img.convert('L')
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ gray = img.convert('L')
- en: '➏ bw = gray.point(lambda x: 0 if x < 90 else 255)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '➏ bw = gray.point(lambda x: 0 if x < 90 else 255)'
- en: ➐ box = bw.getbbox()
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ➐ box = bw.getbbox()
- en: padded_box = (box[0]-20, box[1]-20, box[2]+20, box[3]+20)
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: padded_box = (box[0]-20, box[1]-20, box[2]+20, box[3]+20)
- en: ➑ cropped = img.crop(padded_box)
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ➑ cropped = img.crop(padded_box)
- en: scaled = ImageOps.fit(cropped, (860, 860),
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: scaled = ImageOps.fit(cropped, (860, 860),
- en: Image.LANCZOS, 0, (0.5, 0.5))
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Image.LANCZOS, 0, (0.5, 0.5))
- en: file_name = 'cropped_{}.jpg'.format(file_num)
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: file_name = 'cropped_{}.jpg'.format(file_num)
- en: ➒ scaled.save(file_name, "JPEG")
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ➒ scaled.save(file_name, "JPEG")
- en: 'if __name__ == ''__main__'':'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: main()
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: main()
- en: '*Listing 15-4: Crops initial video frames to a box around Jupiter and rescales*'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 15-4：裁剪初始视频帧到木星周围的框并重新缩放*'
- en: The crop_images() function takes no argument ➊ but will ultimately work on a
    copy—named *cropped*—of the folder containing the original video frames. You made
    this copy in the main() function prior to calling this function.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: crop_images() 函数不接受任何参数 ➊，但最终会作用于包含原始视频帧的文件夹的副本——名为 *cropped*。你是在调用此函数之前，在 main()
    函数中创建了这个副本。
- en: Start the function by making a list of the contents of the current (*cropped*)
    folder ➋. The program will number each image sequentially, so use enumerate()
    with the for loop and set the start option to 1 ➌. If you haven’t used enumerate()
    before, it’s a handy built-in function that acts as an automatic counter; the
    count will be assigned to the file_num variable.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 通过列出当前（*裁剪过的*）文件夹内容 ➋ 来启动该函数。程序会依次为每张图像编号，因此请在 for 循环中使用 enumerate()，并将 start
    选项设置为 1 ➌。如果你之前没有使用过 enumerate()，它是一个非常实用的内置函数，可以充当自动计数器；计数值将被赋给 file_num 变量。
- en: Next, name a variable, img, to hold the image and use the open() method to open
    the file ➍.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，给一个变量命名为 img，用于保存图像，并使用 open() 方法打开该文件 ➍。
- en: To fit the borders of a bounding box to Jupiter, you need all the non-Jupiter
    parts of an image to be black (0, 0, 0). Unfortunately, there are stray, noise-related,
    nonblack pixels beyond Jupiter, and the edge of the planet is diffuse and gradational.
    These issues result in nonuniform box shapes, as shown in [Figure 15-5](ch15.xhtml#ch15fig5).
    Fortunately, you can easily resolve these by converting the image to black and
    white. You can then use this converted image to determine the proper box dimensions
    for each color photo.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让边界框适应木星的边缘，你需要确保图像中所有非木星部分都为黑色（0, 0, 0）。不幸的是，木星之外存在一些噪声导致的非黑色像素，并且行星的边缘是模糊渐变的。这些问题会导致不规则的边界框形状，如
    [图 15-5](ch15.xhtml#ch15fig5) 所示。幸运的是，你可以通过将图像转换为黑白图像轻松解决这些问题。然后，你可以使用转换后的图像来确定每张彩色照片的正确边框尺寸。
- en: '![image](../images/f0335-01.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0335-01.jpg)'
- en: '*Figure 15-5: Irregularly sized cropped images due to problems defining the
    bounding box dimensions*'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-5：由于无法正确定义边界框尺寸，裁剪后的图像大小不规则*'
- en: To eliminate the noise effects that compromise the bounding-box technique, convert
    the loaded image to the “L” mode—consisting of 8-bit black and white pixels—and
    name the variable gray, for grayscale ➎. With this mode there is only one channel
    (versus the three channels for RGB color images), so you only need to decide on
    a single value when thresholding—that is, setting a limit above or below which
    an action occurs.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了消除影响边界框技术的噪声效应，将加载的图像转换为“L”模式——该模式由 8 位黑白像素组成——并将变量命名为 gray，表示灰度 ➎。使用此模式时，图像只有一个通道（与
    RGB 彩色图像的三个通道不同），因此在进行阈值处理时，你只需要决定一个单一的值——即设置一个上限或下限，超出该范围就会触发某种操作。
- en: Assign a new variable, called bw, to hold a true black-and-white image ➏. Use
    the point() method, used to change pixel values, and a lambda function to set
    any value below 90 to black (0) and all other values to white (255). The threshold
    value was determined through trial and error. The point() method now returns a
    clean image for fitting the bounding box ([Figure 15-6](ch15.xhtml#ch15fig6)).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保存一张真实的黑白图像，给一个新变量命名为 bw ➏。使用 point() 方法（该方法用于更改像素值）和一个 lambda 函数，将小于 90 的像素值设置为黑色（0），将其他像素值设置为白色（255）。该阈值是通过反复试验得出的。现在，point()
    方法返回了一张干净的图像，用于拟合边界框（见 [图 15-6](ch15.xhtml#ch15fig6)）。
- en: '![image](../images/f0336-01.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0336-01.jpg)'
- en: '*Figure 15-6: Screen capture of one of the original video frames converted
    to pure black and white*'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-6：将原始视频帧之一转换为纯黑白的屏幕截图*'
- en: Now, call the Image module’s getbox() method on bw ➐. This method prunes off
    black borders by fitting a bounding box to the nonzero regions of an image. It
    returns a tuple with the left, upper, right, and lower pixel coordinates of the
    box.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，调用 Image 模块的 getbox() 方法在 bw 上 ➐。此方法通过为图像的非零区域拟合一个边界框来修剪掉黑色边框。它返回一个元组，其中包含框的左、上、右、下像素坐标。
- en: If you use box to crop the video frames, you get an image with borders tangent
    to Jupiter’s surface (see the middle image in [Figure 15-7](ch15.xhtml#ch15fig7)).
    This is what you want, but it’s not visually pleasing. So, add some black padding
    by assigning a new box variable, named padded_box, with its edges extended 20
    pixels in all four directions (see the rightmost image in [Figure 15-7](ch15.xhtml#ch15fig7)).
    Because the padding is consistent and applied to all images, it doesn’t compromise
    the results of cropping.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用框架来裁剪视频帧，你会得到一张边缘与木星表面相切的图像（见[图 15-7](ch15.xhtml#ch15fig7)中的中间图像）。这是你想要的效果，但视觉上并不太美观。因此，通过定义一个新的框架变量，命名为
    padded_box，并将其边缘在四个方向上扩展 20 像素，添加一些黑色填充（见[图 15-7](ch15.xhtml#ch15fig7)中的最右图像）。由于填充一致且应用于所有图像，它不会影响裁剪的结果。
- en: '![image](../images/f0336-02.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0336-02.jpg)'
- en: '*Figure 15-7: Initial crop tangent to Jupiter’s surface (*box*) and final crop
    with padding (*padded_box*)*'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-7：最初裁剪与木星表面相切（*box*）和最终带有填充的裁剪（*padded_box*）*'
- en: Continue by cropping each image with the crop() method ➑. This method takes
    padded_box as an argument.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 继续使用 crop() 方法裁剪每一张图像 ➑。此方法以 padded_box 作为参数。
- en: To scale the image, use the ImageOps.fit() method. This takes the image, a size
    as a pixel width-and-height tuple, a resampling method, a border (0 = no border),
    and even cropping from the center, designated by the tuple (0.5, 0.5). The pillow
    module has several algorithm choices for resizing an image, but I chose the popular
    *Lanczos* filter. Enlarging an image tends to reduce its sharpness, but Lanczos
    can produce *ringing artifacts* along strong edges; this helps increase *perceived*
    sharpness. This unintended edge enhancement can help the eye focus on features
    of interest, which are faint and blurry in the original video frames.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 要缩放图像，使用 ImageOps.fit() 方法。此方法接收图像、尺寸（像素宽度和高度元组）、重采样方法、边框（0 = 无边框），甚至是从中心裁剪，由元组（0.5，0.5）指定。Pillow
    模块提供了几种图像缩放算法供选择，但我选择了流行的 *Lanczos* 滤镜。放大图像往往会降低其清晰度，但 Lanczos 可以在强边缘产生 *振铃伪影*；这有助于提高
    *感知* 锐利度。这种意外的边缘增强有助于眼睛集中注意力于那些在原始视频帧中模糊且微弱的感兴趣特征上。
- en: After scaling, assign a file_name variable. Each of the 256 cropped images will
    start with *cropped_* and end with the number of the image, which you pass to
    the replacement field of the format() method. End the function by saving the file
    ➒.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 缩放后，定义一个 file_name 变量。每张裁剪后的图像将以 *cropped_* 开头，并以图像的编号结尾，你将该编号传递给 format() 方法的替换字段。最后，保存文件
    ➒。
- en: Back in the global scope, add the code that lets the program run as a module
    or in stand-alone mode.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在全局作用域中，添加使程序可以作为模块或独立模式运行的代码。
- en: '**NOTE**'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*I save the files using JPEG format because it is universally readable, handles
    gradations in color well, and takes up very little memory. JPEG uses “lossy” compression,
    however, which causes a tiny bit of image deterioration each time a file is saved;
    you can adjust the degree of compression at the expense of storage size. In most
    cases, when working with astrophotographs, you’ll want to use one of the many
    lossless formats available, such as TIFF.*'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '*我使用 JPEG 格式保存文件，因为它是通用的、能够很好地处理颜色渐变且占用的内存很少。然而，JPEG 使用的是“有损”压缩，每次保存文件时都会有轻微的图像退化；你可以调整压缩的程度，以换取存储空间的大小。在大多数情况下，当处理天文照片时，你会希望使用诸如
    TIFF 等多种无损格式之一。*'
- en: At this point in the workflow, you’ve cropped the original video frames down
    to a box around Jupiter; then you scaled the cropped images to a larger, consistent
    size ([Figure 15-8](ch15.xhtml#ch15fig8)).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在工作流的这一点上，你已经将原始视频帧裁剪成围绕木星的框架；然后你将裁剪后的图像缩放到更大且一致的尺寸（见[图 15-8](ch15.xhtml#ch15fig8)）。
- en: '![image](../images/f0337-01.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0337-01.jpg)'
- en: '*Figure 15-8: Relative sizes of images after cropping and scaling*'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-8：裁剪和缩放后图像的相对大小*'
- en: In the next section, you write the code that stacks the cropped and scaled images.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将编写堆叠裁剪和缩放图像的代码。
- en: '***The Stacking Code***'
  id: totrans-183
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***堆叠代码***'
- en: The *stack_images.py* code takes the images produced by the last program and
    averages them so that a single stacked image is produced. You can download it
    from the book’s resources at *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*.
    Keep it in the same folder as the *crop_n_scale_images.py* program.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '*stack_images.py* 代码会将上一个程序生成的图像进行平均处理，从而生成一张堆叠图像。你可以从本书的资源页面下载它，网址是 *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*。将它与
    *crop_n_scale_images.py* 程序保存在同一文件夹中。'
- en: '[Listing 15-5](ch15.xhtml#ch15list5) imports modules, loads images, creates
    lists of color channels (red, blue, green), averages the channels, recombines
    the channels, and creates and saves the final stacked image. It’s simple enough
    that we won’t bother with a main() function.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '*stack_images.py*'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: ➊ import os
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: from PIL import Image
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: print("\nstart stacking images...")
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '# list images in directory'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: ➋ os.chdir('cropped')
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: images = os.listdir()
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '# loop through images and extract RGB channels as separate lists'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: ➌ red_data = []
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: green_data = []
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: blue_data = []
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '➍ for image in images:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'with Image.open(image) as img:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: if image == images[0]:  # get size of 1st cropped image
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: img_size = img.size  # width-height tuple to use later
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: ➎ red_data.append(list(img.getdata(0)))
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: green_data.append(list(img.getdata(1)))
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: blue_data.append(list(img.getdata(2)))
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: ➏ ave_red = [round(sum(x) / len(red_data)) for x in zip(*red_data)]
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: ave_blue = [round(sum(x) / len(blue_data)) for x in zip(*blue_data)]
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: ave_green = [round(sum(x) / len(green_data)) for x in zip(*green_data)]
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: ➐ merged_data = [(x) for x in zip(ave_red, ave_green, ave_blue)]
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: ➑ stacked = Image.new('RGB', (img_size))
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: ➒ stacked.putdata(merged_data)
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: stacked.show()
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: ➓ os.chdir('..')
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: stacked.save('jupiter_stacked.tif', 'TIFF')
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 15-5: Splits out and averages color channels, then recombines into
    a single image*'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Start by repeating some of the imports you used in the previous program ➊. Next,
    change the current directory to the *cropped* folder, which contains the cropped
    and scaled images of Jupiter ➋, and immediately make a list of the images in the
    folder using os.listdir().
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: With pillow, you can manipulate individual pixels or groups of pixels, and you
    can do this for individual color channels, such as red, blue, and green. To demonstrate
    this, you’ll work on individual color channels to stack the images.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Create three empty lists to hold the RGB pixel data ➌, then start looping through
    the images list ➍. First, open the image. Then, get the width and height of the
    first image, in pixels, as a tuple. Remember, in the previous program, you scaled
    all the small cropped images to a larger size. You’ll need these dimensions later
    for creating the new stacked image, and size automatically retrieves this info
    for you.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'Now use the getdata() method to get the pixel data for the selected image ➎.
    Pass the method the index of the color channel you want: 0 for red, 1 for green,
    and 2 for blue. Append the results to a data list, as appropriate. The data from
    each image will form a separate list in the data lists.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: To average the values in each list, use list comprehension to sum the pixels
    in all the images and divide by the total number of images ➏. Note that you use
    zip with the splat (*) operator. Your red_data list, for example, is a list of
    lists, with each nested list representing one of the 256 image files. Using zip
    with * unpacks the contents of the lists so that the first pixel in image1 is
    summed with the first pixel in image2, and so on.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: To merge the averaged color channels, use list comprehension with zip ➐. Next,
    create a new image, named stacked, using Image.new() ➑. Pass the method a color
    mode ('RGB') and the img_size tuple containing the desired width and height of
    the image in pixels, which was obtained earlier from one of the cropped images.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Populate the new stacked image using the putdata() method and pass it the merged_data
    list ➒. This method copies data from a sequence object into an image, starting
    at the upper-left corner (0, 0). Display the final image using the show() method.
    Finish by changing the folder to the parent directory and saving the image as
    a TIFF file named *jupiter_stacked.tif* ➓.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: If you compare one of the original video frames to the final stacked image (*jupiter_stacked.tif*),
    as in [Figure 15-9](ch15.xhtml#ch15fig9), you’ll see a clear improvement in edge
    definition and the signal-to-noise ratio. This is best appreciated in color, so
    if you haven’t run the program, take the time to download *Figure 15-9.pdf* from
    the website. When the image is viewed in color, the benefits of the stacking include
    smoother, “creamier” white bands, better-defined red bands, and a more obvious
    Great Red Spot. There is still room for improvement, however, so next you’ll write
    a program to enhance the final stacked image.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0339-01.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-9: An original video frame compared to final stacked image (*jupiter_stacked.tif*)*'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '*If the Great Red Spot looks pinkish to you in the stacked image, that’s because
    it is! It fades from time to time, and many published pictures of Jupiter have
    exaggerated colors due to processing, so this subtle coloration gets lost. This
    is probably for the best, as “Great Pink Spot” just doesn’t have the same ring
    to it.*'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '***The Enhancing Code***'
  id: totrans-226
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You’ve successfully stacked all the video frames, but Jupiter is still crooked,
    and its features are faint. You can further improve the stacked image using filters,
    enhancers, and transforms found in pillow. As you enhance images, you get further
    and further from the “ground truth” raw data. For this reason, I chose to isolate
    the enhancement process in a separate program.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: In general, the first steps after stacking are to enhance details, using high-pass
    filters or an unsharp mask algorithm, and then to fine-tune brightness, contrast,
    and color. The code will use pillow’s image enhancement capability to apply these
    steps—though in a different order. You can download the code as *enhance_image.py*
    from *[https://nostarch.com/impracticalpython/](https://nostarch.com/impracticalpython/)*.
    Keep it in the same folder as the previous Python programs.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '*The processing of astronomical images can be quite involved, and whole books
    have been written on the subject. Some of the standard steps have been omitted
    in this workflow. For instance, the original video was not calibrated, and distortion
    effects due to turbulence were not corrected. Advanced software, such as RegiStax
    or AviStack, can prevent blurring by warping individual images so that distorted
    features, like the edges of cloud bands, overlap properly in all images.*'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 15-6](ch15.xhtml#ch15list6) imports pillow classes and opens, enhances,
    and saves the stacked image generated by the previous code. Because there are
    many possible options for enhancing images, I chose to modularize this program
    despite its small size.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '*enhance_image.py*'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: ➊ from PIL import Image, ImageFilter, ImageEnhance
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '➋ def main():'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '"""Get an image and enhance, show, and save it."""'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: ➌ in_file = 'jupiter_stacked.tif'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: img = Image.open(in_file)
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: ➍ img_enh = enhance_image(img)
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: img_enh.show()
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: img_enh.save('enhanced.tif', 'TIFF')
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '➎ def enhance_image(image):'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '"""Improve an image using pillow filters & transforms."""'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: ➏ enhancer = ImageEnhance.Brightness(image)
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: ➐ img_enh = enhancer.enhance(0.75)  # 0.75 looks good
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: ➑ enhancer = ImageEnhance.Contrast(img_enh)
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: img_enh = enhancer.enhance(1.6)
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: enhancer = ImageEnhance.Color(img_enh)
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: img_enh = enhancer.enhance(1.7)
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: ➒ img_enh = img_enh.rotate(angle=133, expand=True)
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: ➓ img_enh = img_enh.filter(ImageFilter.SHARPEN)
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: return img_enh
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: main()
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 15-6: Opens an image, enhances it, and saves it using a new name*'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: The import is familiar except for the last two ➊. These new modules, ImageFilter
    and ImageEnhance, contain predefined filters and classes that can be used to alter
    images with blurring, sharpening, brightening, smoothing, and more (see *[https://pillow.readthedocs.io/en/5.1.x/](https://pillow.readthedocs.io/en/5.1.x/)*
    for a full listing of what’s in each module).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Start by defining the main() function ➋. Assign the stacked image to a variable
    named in_file, then pass it to Image.open() to open the file ➌. Next, call an
    enhance_image() function and pass it the image variable ➍. Show the enhanced image
    and then save it as a TIFF file, which results in no deterioration in image quality.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Now, define an enhancement function, enhance_image(), that takes an image as
    an argument ➎. To paraphrase the pillow documentation, all enhancement classes
    implement a common interface containing a single method, enhance(factor), that
    returns an enhanced image. The factor parameter is a floating-point value controlling
    the enhancement. A value of 1.0 returns a copy of the original; lower values diminish
    color, brightness, contrast, and so on; and higher values increase these qualities.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: 'To change the brightness of an image, you first create an instance of the ImageEnhance
    module’s Brightness class, passing it the original image ➏. Mimic the pillow docs
    and name this object enhancer. To make the final, enhanced image, you call the
    object’s enhance() method and pass it the factor argument ➐. In this case, you
    decrease brightness by 0.25\. The # 0.75 comment at the end of the line is a useful
    way to experiment with different factors. Use this comment to store values you
    like; that way, you can remember and restore them if other test values don’t yield
    pleasing results.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: 'Continue enhancing the image, moving to contrast ➑. If you don’t want to adjust
    the contrast manually, you can take a chance and use pillow’s automatic contrast
    method. First, import ImageOps from PIL. Then, replace the two lines starting
    with step ➑ with the single line: img_enh = ImageOps.autocontrast(img_enh).'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Next, punch up the color. This will help to make the Great Red Spot more visible.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: No one wants to look at a tilted Jupiter, so transform the image by rotating
    it to a more “conventional” view, where the cloud bands are horizontal and the
    Great Red Spot is to the lower right. Call the Image module’s rotate() method
    on the image and pass it an angle, measured counterclockwise in degrees, and have
    it automatically expand the output image to make it large enough to hold the entire
    rotated image ➒.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Now, sharpen the image. Even on high-quality images, sharpening may be needed
    to ameliorate the interpolation effects of converting data, resizing and rotating
    images, and so on. Although some astrophotography resources recommend placing
    it first, in most image-processing workflows, it comes last. This is because it
    is dependent on the final size of the image (viewing distance), as well as the
    media being used. Sharpening can also increase noise artifacts and is a “lossy”
    operation that can remove data—things you don’t want to happen prior to other
    edits.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Sharpening is a little different from the previous enhancements, as you use
    the ImageFilter class. No intermediate step is needed; you can build the new image
    with a single line by calling the filter() method on the image object and passing
    it the predefined SHARPEN filter ➓. The pillow module has other filters that help
    define edges, such as UnsharpMask and EDGE_ENHANCE, but for this image, the results
    are indiscernible from SHARPEN.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Finish by returning the image and applying the code to run the program as a
    module or in stand-alone mode.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: The final enhanced image is compared to a random video frame and the final stacked
    image in [Figure 15-10](ch15.xhtml#ch15fig10). All the images have been rotated
    for ease of comparison.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0342-01.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-10: A random video frame, the results of stacking 256 frames, and
    the final enhanced image*'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: You can see the improvement best when you view it in color. If you want to see
    a color version prior to running the program, view or download *Figure 15-10.pdf*
    from the website.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '*If you’re familiar with* pillow*, you may be aware that you can use the* Image.blend()
    *method to stack images with only a few lines of code. To my eye, however, the
    resulting image is noticeably noisier than that obtained by breaking out and averaging
    the individual color channels, as you did with the* stack_images.py *program.*'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The final image in [Figure 15-10](ch15.xhtml#ch15fig10) will never win any awards
    or be featured in *Sky & Telescope* magazine, but the point was to take on a challenge.
    And the result is a marked improvement over a single image captured from the video.
    The colors are brighter, the cloud bands sharper, and the Great Red Spot better
    defined. You can also make out the turbulent zone downwind of the Great Red Spot
    (refer to [Figure 15-1](ch15.xhtml#ch15fig1)).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Despite starting with rough input, you were able to register the images, remove
    noise through stacking, and enhance the final image using filters and transforms.
    And all these steps were accomplished with the freely available pillow fork of
    the Python Imaging Library. You also gained experience with the Python shutil
    and os modules, which you used to manipulate files and folders.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: For more advanced image processing, you can use OpenSource Computer Vision (OpenCV),
    which you implement by installing and importing the cv2 and NumPy modules. Other
    options involve matplotlib, SciPy, and NumPy. As always with Python, there’s more
    than one way to skin a cat!
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '**Further Reading**'
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Automate the Boring Stuff with Python: Practical Programming for Total Beginners*
    (No Starch Press, 2015) by Al Sweigart includes several useful chapters on working
    with files, folders, and pillow.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: Online resources for using Python with astronomy include Python for Astronomers
    (*[https://prappleizer.github.io/](https://prappleizer.github.io/)*) and Practical
    Python for Astronomers (*[https://python4astronomers.github.io/](https://python4astronomers.github.io/)*).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: If you want to learn more about the OpenCV-Python library, you can find tutorials
    at *[https://docs.opencv.org/3.4.2/d0/de3/tutorial_py_intro.html](https://docs.opencv.org/3.4.2/d0/de3/tutorial_py_intro.html)*.
    Note that knowledge of NumPy is a prerequisite for the tutorials and for writing
    optimized OpenCV code. Alternatively, SimpleCV lets you get started with computer
    vision and image manipulation with a smaller learning curve than OpenCV but only
    works with Python 2.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '*Astrophotography* (Rocky Nook, 2014) by Thierry Legault is an indispensable
    resource for anyone interested in serious astrophotography. A comprehensive and
    readable reference, it covers all aspects of the subject, from equipment selection
    through image processing.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: “Aligning Sun Images Using Python” (LabJG, 2013), a blog by James Gilbert, contains
    code for cropping the sun using the bounding-box technique. It also includes a
    clever method for realigning rotated images of the sun using sunspots as registration
    points. You can find it at *[https://labjg.wordpress.com/2013/04/01/aligning-sun-images-using-python/](https://labjg.wordpress.com/2013/04/01/aligning-sun-images-using-python/)*.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: A Google research team figured out how to use stacking to remove watermarks
    from images on stock photography websites and how the websites could better protect
    their property. You can read about it at *[https://research.googleblog.com/2017/08/making-visible-watermarks-more-effective.html](https://research.googleblog.com/2017/08/making-visible-watermarks-more-effective.html)*.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '**Challenge Project: Vanishing Act**'
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Image-stacking techniques can do more than just remove noise—they can remove
    anything that moves at a photo site, including people. Adobe Photoshop, for example,
    has a stack script that makes nonstationary objects magically vanish. It relies
    on a statistical average known as the *median*, which is simply the “middle” value
    in a list of numbers arranged from smallest to largest. The process requires multiple
    photos—preferably taken with a tripod-mounted camera—so that the objects you want
    to remove change positions from one image to the next, while the background remains
    constant. You typically need 10 to 30 pictures taken about 20 seconds apart, or
    similarly spaced frames extracted from a video.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: With the mean, you sum numbers and divide by the total. With the median, you
    sort numbers and choose the middle value. In [Figure 15-11](ch15.xhtml#ch15fig11),
    a row of five images is shown with the same pixel location outlined in each. In
    the fourth image, a blackbird has flown by and ruined the splendid white background.
    If you stack with the mean, the bird’s presence lingers. But do a median stack
    on the images—that is, sort the red, green, and blue channels and take the middle
    values—and you get the background value for each channel (255). No trace of the
    bird remains.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0344-01.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-11: Five white images with the same pixel highlighted and its RGB
    values displayed. Median-stacking removes the black pixel.*'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: When you average using the median, spurious values get pushed to the ends of
    the list. This makes it easy to remove outliers, such as satellites or airplanes
    in astrophotos, so long as the number of images containing the outlier is less
    than half the number of images.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: Armed with this knowledge, write an image-stacking program that will remove
    unwanted tourists from your vacation happy snaps. For testing, you can download
    the *moon_cropped* folder from the website, which contains five synthetic images
    of the moon, each “ruined” by a passing plane (see [Figure 15-12](ch15.xhtml#ch15fig12)).
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0345-01.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-12: Synthetic moon photos for testing the median averaging approach*'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Your final stacked image should contain no evidence of the plane ([Figure 15-13](ch15.xhtml#ch15fig13)).
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0345-02.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-13: Result of stacking the images in the* moon_cropped *folder using
    median averaging*'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: As this is a challenge project, no solution is provided.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
