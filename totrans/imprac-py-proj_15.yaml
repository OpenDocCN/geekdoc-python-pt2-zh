- en: '**15'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**15'
- en: IMPROVING YOUR ASTROPHOTOGRAPHY WITH PLANET STACKING**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**通过行星堆叠提高你的天文摄影水平**'
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: If you’ve ever looked through a telescope at Jupiter, Mars, or Saturn, you were
    probably a little disappointed. The planets appeared small and featureless. You
    wanted to zoom in and crank up the magnification, but it didn’t work. Anything
    bigger than about 200x magnification tends to be blurry.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经通过望远镜观察过木星、火星或土星，你可能会有些失望。行星看起来很小，几乎没有什么细节。你想要放大并提高倍率，但它没有效果。大于200倍的放大倍率往往会变得模糊。
- en: The problem is air turbulence, or what astronomers call *seeing*. Even on a
    clear night, the air is constantly in motion, with thermal updrafts and downdrafts
    that can easily blur the pinpoints of light that represent celestial objects.
    But with the commercialization of the *charge-coupled device (CCD)* in the 1980s,
    astronomers found a way to overcome the turbulence. Digital photography permits
    a technique known as *image stacking*, in which many photos—some good, some bad—are
    averaged together, or stacked, into a single image. With enough photos, the persistent,
    unchanging features (like a planet’s surface) dominate transient features (like
    a stray cloud). This allows astrophotographers to increase magnification limits,
    as well as compensate for less-than-optimal seeing conditions.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于空气湍流，或者天文学家所说的*视像*。即使在晴朗的夜晚，空气也在不断运动，热气流的上升和下降很容易模糊代表天体的光点。然而，随着20世纪80年代*电荷耦合器件（CCD）*的商业化，天文学家找到了解决湍流的方法。数字摄影允许一种叫做*图像堆叠*的技术，其中许多照片——有些好，有些差——被平均或堆叠成一张单独的图像。通过足够多的照片，持久不变的特征（如行星表面）会主导瞬时特征（如流动的云层）。这使得天文摄影师能够提高放大限制，并补偿不理想的观测条件。
- en: In this chapter, you’ll use a third-party Python module called `pillow` to stack
    hundreds of images of Jupiter. The result will be a single image with a higher
    signal-to-noise ratio than any of the individual frames. You’ll also work with
    files in different folders than your Python code and manipulate both the files
    and folders using the Python operating system (`os`) and shell utilities (`shutil`)
    modules.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将使用一个名为`pillow`的第三方Python模块来堆叠数百张木星的图像。最终结果将是一个具有比任何单个图像更高信噪比的图像。你还将处理与Python代码所在不同文件夹中的文件，并使用Python的操作系统（`os`）和shell实用工具（`shutil`）模块来操作文件和文件夹。
- en: '**Project #23: Stacking Jupiter**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**项目#23：堆叠木星**'
- en: Large, bright, and colorful, the gas giant Jupiter is a favorite target of astrophotographers.
    Even amateur telescopes can resolve its orange striping, caused by linear cloud
    bands, and the Great Red Spot, an oval-shaped storm so large it could swallow
    the Earth (see [Figure 15-1](ch15.xhtml#ch15fig1)).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 木星是一颗大而明亮、色彩斑斓的气体巨行星，是天文摄影师的最爱目标。即使是业余望远镜也能看到它的橙色条纹，这些条纹是由线性云带形成的，还有大红斑，一个椭圆形的风暴，其大小足以吞没地球（见[图15-1](ch15.xhtml#ch15fig1)）。
- en: '![image](../images/f0326-01.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0326-01.jpg)'
- en: '*Figure 15-1: Jupiter as photographed by the Cassini spacecraft*'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*图15-1：卡西尼太空探测器拍摄的木星照片*'
- en: Jupiter is a great subject for studying image stacking. Its linear cloud bands
    and Great Red Spot provide the eye with calibration points for judging improvements
    in edge definition and clarity, and its relatively large size makes it easy to
    detect noise.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 木星是研究图像堆叠的绝佳对象。它的线性云带和大红斑为眼睛提供了校准点，用于判断边缘定义和清晰度的改进，而且它相对较大的尺寸使得噪声容易被察觉。
- en: Noise manifests itself as “graininess.” Each color band has its own artifacts,
    resulting in colored speckles across an image. The main sources of noise are the
    camera (electronic readout noise and thermal signal) and photon noise from the
    light itself, as a variable number of photons strike the sensor over time. Noise
    artifacts are fortunately random in nature and can be largely canceled out by
    stacking images.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 噪声表现为“颗粒感”。每个颜色带都有自己的伪影，导致图像上出现彩色斑点。噪声的主要来源是相机（电子读出噪声和热信号）以及来自光本身的光子噪声，因为随着时间的推移，光子以可变的数量撞击传感器。幸运的是，噪声伪影是随机的，可以通过堆叠图像大部分被消除。
- en: '**THE OBJECTIVE**'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标**'
- en: Write programs that crop, scale, stack, and enhance images to create a clearer
    photograph of Jupiter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 编写程序裁剪、缩放、堆叠并增强图像，以创建更清晰的木星照片。
- en: '**The pillow Module**'
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**pillow模块**'
- en: To work with images, you’ll need a free third-party Python module called `pillow`.
    It’s the successor project to the Python Imaging Library (PIL), which was discontinued
    in 2011\. The `pillow` module “forked” the PIL repository and upgraded the code
    for Python 3.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理图像，你需要一个免费的第三方 Python 模块，名为 `pillow`。它是 Python Imaging Library (PIL) 的继任项目，后者已于
    2011 年停用。`pillow` 模块是从 PIL 仓库“分支”出来的，并将代码升级到 Python 3。
- en: You can use `pillow` on Windows, macOS, and Linux, and it supports many image
    formats including PNG, JPEG, GIF, BMP, and TIFF. It offers standard image-manipulation
    procedures, such as altering individual pixels, masking, handling transparency,
    filtering and enhancing, and adding text. But the real strength of `pillow` is
    its ability to edit many images with ease.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Windows、macOS 和 Linux 上使用 `pillow`，它支持多种图像格式，包括 PNG、JPEG、GIF、BMP 和 TIFF。它提供了标准的图像处理功能，如改变单个像素、遮罩、处理透明度、过滤和增强以及添加文本。但
    `pillow` 的真正优势在于它能够轻松编辑大量图像。
- en: Installing `pillow` is easy with the pip tool (for more about pip, see “[Manipulating
    Word Documents with `python-docx`](ch06.xhtml#lev136)” on [page 110](ch06.xhtml#page_110)).
    From the command line, enter pip install pillow.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 pip 工具安装 `pillow` 非常简单（有关 pip 的更多信息，请参见 “[使用 `python-docx` 操作 Word 文档](ch06.xhtml#lev136)”
    第[110页](ch06.xhtml#page_110)）。在命令行中输入 pip install pillow 即可。
- en: Most major Linux distributions include `pillow` in packages that previously
    contained PIL, so you may already have `pillow` on your system. Regardless of
    your platform, if PIL is already installed, you’ll need to uninstall it before
    installing `pillow`. For more installation instructions, see *[http://pillow.readthedocs.io/en/latest/installation.html](http://pillow.readthedocs.io/en/latest/installation.html)*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数主要的 Linux 发行版将 `pillow` 包含在之前包含 PIL 的软件包中，因此你可能已经在系统上安装了 `pillow`。无论你使用什么平台，如果
    PIL 已经安装，你需要在安装 `pillow` 之前先卸载它。有关安装说明，请参见 *[http://pillow.readthedocs.io/en/latest/installation.html](http://pillow.readthedocs.io/en/latest/installation.html)*。
- en: '**Working with Files and Folders**'
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**处理文件和文件夹**'
- en: In all the previous projects in this book, you’ve kept supporting files and
    modules in the same folder as your Python code. This was handy for simple projects,
    but not very realistic for broad use, and it’s certainly not good when you’re
    dealing with the hundreds of image files you’ll generate in this project. Fortunately,
    Python ships with several modules that can help with this, like `os` and `shutil`.
    But first, I’ll briefly discuss directory paths.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书前面的所有项目中，你都将支持文件和模块与 Python 代码放在同一文件夹中。这对于简单项目来说很方便，但对于广泛使用来说不太现实，尤其是在你需要处理本项目中生成的数百个图像文件时。幸运的是，Python
    附带了几个可以帮助处理这个问题的模块，比如 `os` 和 `shutil`。但首先，我将简要讨论一下目录路径。
- en: '***Directory Paths***'
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***目录路径***'
- en: The directory path is the address to a file or folder. It starts with a root
    directory, which is designated with a letter (such as *C:\*) in Windows, and a
    forward slash (*/*) in Unix-based systems. Additional drives in Windows are assigned
    a different letter than *C*, those in macOS are placed under */volume*, and those
    in Unix under */mnt* (for “mount”).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 目录路径是指向文件或文件夹的地址。它以根目录开始，在 Windows 中根目录用字母（例如 *C:\*）表示，而在 Unix 系统中则用正斜杠 (*/*)
    表示。Windows 中的其他驱动器会被分配不同的字母，而 macOS 中的驱动器位于 */volume* 下，Unix 中的驱动器则位于 */mnt*（即“挂载”）。
- en: '**NOTE**'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*I use the Windows operating system for the examples in this chapter, but you
    can achieve the same result on macOS and other systems. And as is commonly done,
    I use the terms* directory *and* folder *interchangeably here.*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*在本章的示例中，我使用的是 Windows 操作系统，但你也可以在 macOS 和其他系统上实现相同的结果。正如常见的做法，我在这里将*目录*和*文件夹*互换使用。*'
- en: Pathnames appear differently depending on the operating system. Windows separates
    folders with a backslash (*\*), while macOS and Unix systems use a forward slash
    (*/*). Also, in Unix, folder and file names are case sensitive.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 路径名称的显示方式取决于操作系统。Windows 使用反斜杠 (*\*) 来分隔文件夹，而 macOS 和 Unix 系统使用正斜杠 (*/*)。此外，在
    Unix 系统中，文件夹和文件名是区分大小写的。
- en: If you’re writing your program in Windows and type in pathnames with backslashes,
    other platforms won’t recognize the paths. Fortunately, the `os.path.join()` method
    will automatically ensure your pathname is suitable for whatever operating system
    Python is running on. Let’s take a look at this, and other examples, in [Listing
    15-1](ch15.xhtml#ch15list1).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 Windows 上编写程序并输入带有反斜杠的路径名，其他平台将无法识别这些路径。幸运的是，`os.path.join()` 方法会自动确保你的路径名适用于
    Python 正在运行的操作系统。我们来看看这个以及其他示例，见 [Listing 15-1](ch15.xhtml#ch15list1)。
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 15-1: Working with Windows pathnames using the* os *module*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 15-1：使用* os *模块操作 Windows 路径名*'
- en: After importing the `os` module for access to operating system–dependent functionality
    ➊, get the *current working directory*, or *cwd* ➋. The cwd is assigned to a process
    when it starts up; that is, when you run a script from your shell, the cwd of
    the shell and the script will be the same. For a Python program, the cwd is the
    folder that contains the program. When you get the cwd, you’re shown the full
    path. Note that you must use extra backslashes in order to escape the backslash
    characters used as file separators.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 `os` 模块以访问操作系统相关功能 ➊ 后，获取 *当前工作目录*（*cwd*） ➋。cwd 在进程启动时被分配；也就是说，当你从 shell
    运行脚本时，shell 和脚本的 cwd 会是相同的。对于 Python 程序，cwd 是包含该程序的文件夹。当你获取 cwd 时，你会看到完整路径。请注意，你必须使用额外的反斜杠来转义作为文件分隔符使用的反斜杠字符。
- en: Next, you change the cwd using the `os.chdir()` method ➌, passing it the full
    path in quotes, using double backslashes. Then you get the cwd again to see the
    new path.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用 `os.chdir()` 方法 ➌ 更改 cwd，传递给它包含双反斜杠的完整路径。然后，再次获取 cwd，以查看新的路径。
- en: If you don’t want to type the double backslash, you can enter an r before the
    pathname argument string to convert it to a *raw string* ➍. Raw strings use different
    rules for backslash escape sequences, but even a raw string can’t end in a single
    backslash. The path will still be displayed with double backslashes ➎.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想输入双反斜杠，可以在路径名参数字符串前加一个 r，将其转换为 *原始字符串* ➍。原始字符串使用不同的规则来处理反斜杠转义序列，但即使是原始字符串也不能以单个反斜杠结尾。路径仍然会以双反斜杠显示
    ➎。
- en: If you want your program to be compatible with all operating systems, use the
    `os.path.join()` method and pass it the folder names and filenames without a separator
    character ➏. The `os.path` methods are aware of the system you’re using and return
    the proper separators. This allows for platform-independent manipulation of filenames
    and folder names.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望你的程序与所有操作系统兼容，请使用 `os.path.join()` 方法，并传递文件夹名和文件名，不需要分隔符字符 ➏。`os.path`
    方法会根据你使用的系统返回正确的分隔符。这使得文件名和文件夹名的操作不依赖于平台。
- en: The `os.path.normpath()` method corrects separators for the system you are using
    ➐. In the Windows example shown, incorrect Unix-type separators are replaced with
    backslashes. Native Windows also supports use of the forward slash and will automatically
    make the conversion ➑.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`os.path.normpath()` 方法会根据您使用的系统修正分隔符➐。在显示的 Windows 示例中，不正确的 Unix 类型分隔符会被反斜杠替代。原生
    Windows 也支持使用正斜杠，并会自动进行转换➑。'
- en: The full directory path—from the root down—is called the *absolute path*. You
    can use shortcuts, called *relative paths*, to make working with directories easier.
    Relative paths are interpreted from the perspective of the current working directory.
    Whereas absolute paths start with a forward slash or drive label, relative paths
    do not. In the following code snippet, you can change directories without entering
    an absolute path—Python is aware of the new location because it is *within* the
    cwd. Behind the scenes, the relative path is joined to the path leading to the
    cwd to make a complete absolute path.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的目录路径—从根目录开始—被称为 *绝对路径*。你可以使用快捷方式，称为 *相对路径*，使得操作目录更为简便。相对路径是从当前工作目录的角度进行解释的。绝对路径以正斜杠或驱动器标签开始，而相对路径则不以此开始。在下面的代码片段中，你可以在不输入绝对路径的情况下改变目录—Python
    能够识别新的位置，因为它是在 *cwd 内部*。在幕后，相对路径会与指向 cwd 的路径连接，从而生成一个完整的绝对路径。
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You can identify folders and save more typing with dot (`.`) and dot-dot (`..`).
    For example, in Windows, `.\` refers to the cwd, and `..\` refers to the parent
    directory that holds the cwd. You can also use a dot to get the absolute path
    to your cwd:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用点（`.`）和双点（`..`）来标识文件夹并减少输入。例如，在 Windows 中，`.\` 指代 cwd，`..\` 指代包含 cwd
    的父目录。你还可以使用点来获取 cwd 的绝对路径：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Dot folders can be used in Windows, macOS, and Linux. For more on the `os` module,
    see *[https://docs.python.org/3/library/os.html](https://docs.python.org/3/library/os.html)*.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 点文件夹可以在 Windows、macOS 和 Linux 中使用。有关 `os` 模块的更多信息，请参见 *[https://docs.python.org/3/library/os.html](https://docs.python.org/3/library/os.html)*。
- en: '***The Shell Utilities Module***'
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Shell 工具模块***'
- en: The shell utilities module, `shutil`, provides high-level functions for working
    with files and folders, such as copying, moving, renaming, and deleting. Since
    it’s part of the Python standard library, you can load `shutil` simply by typing
    import shutil. You’ll see example uses for the module in this chapter’s code sections.
    Meanwhile, you can find the module’s documentation at *[https://docs.python.org/3.7/library/shutil.html](https://docs.python.org/3.7/library/shutil.html)*.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`shutil`模块提供了用于处理文件和文件夹的高级功能，如复制、移动、重命名和删除。由于它是Python标准库的一部分，你可以通过输入import
    shutil来加载`shutil`。在本章的代码段中，你会看到该模块的示例用法。同时，你可以在*[https://docs.python.org/3.7/library/shutil.html](https://docs.python.org/3.7/library/shutil.html)*找到该模块的文档。'
- en: '**The Video**'
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**视频**'
- en: Brooks Clark recorded the color video of Jupiter used in this project on a windy
    night in Houston, Texas. It consists of a 101 MB *.mov* file with a runtime of
    about 16 seconds.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Brooks Clark在美国德克萨斯州休斯顿的一个有风的夜晚录制了用于此项目的木星彩色视频。该视频为101 MB的*.mov*文件，时长约为16秒。
- en: The length of the video is intentionally short. Jupiter’s rotation period is
    about 10 hours, which means still photos may blur with exposure times of only
    a minute, and features you want to reinforce through stacking video frames can
    change positions, greatly complicating the process.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 视频长度故意设得较短。木星的自转周期约为10小时，这意味着即使只有一分钟的曝光时间，静态照片也可能出现模糊，而你想通过堆叠视频帧来强化的特征可能会改变位置，极大地复杂化了这一过程。
- en: To convert the video frames to individual images, I used Free Studio, a freeware
    set of multimedia programs developed by DVDVideoSoft. The Free Video to JPG Converter
    tool permits the capture of images at constant time or frame intervals. I set
    the interval to sample frames across the full length of the video, to improve
    the odds of capturing some images when the air was still and the seeing good.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将视频帧转换为单独的图像，我使用了由DVDVideoSoft开发的免费多媒体程序集Free Studio。Free Video to JPG Converter工具允许在恒定时间或帧间隔下捕捉图像。我将间隔设置为跨越整个视频长度采样帧，以提高在空气平稳、可见度良好时捕捉到图像的机会。
- en: A few hundred images should be enough for stacking to show demonstrable improvement.
    In this case, I captured 256 frames.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 几百张图像应该足以进行堆叠并显示显著的改进。在这种情况下，我捕捉了256帧。
- en: You can find the folder of images, named *video_frames*, online with the book’s
    resources at *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*.
    Download this folder and retain the name.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在*[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*在线找到名为*video_frames*的图像文件夹，位于本书资源中。下载该文件夹并保留其名称。
- en: An example frame from the video, in grayscale, is shown in [Figure 15-2](ch15.xhtml#ch15fig2).
    Jupiter’s cloud bands are faint and fuzzy, the Great Red Spot isn’t apparent,
    and the image suffers from low contrast, a common side effect of magnification.
    Noise artifacts also give Jupiter a grainy appearance.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 视频中的一帧示例，采用灰度显示，见[图 15-2](ch15.xhtml#ch15fig2)。木星的云带模糊不清，大红斑不明显，且图像对比度较低，这是放大常见的副作用。噪点伪影还让木星呈现颗粒状外观。
- en: '![image](../images/f0330-01.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0330-01.jpg)'
- en: '*Figure 15-2: Example frame from the video of Jupiter*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-2：木星视频中的一帧示例*'
- en: In addition to those issues, the wind shook the camera, and imprecise tracking
    caused the planet to drift laterally to the left-hand side of the frame. You can
    see an example of *lateral drift* in [Figure 15-3](ch15.xhtml#ch15fig3), in which
    I have overlaid five randomly chosen frames with the black background set to transparent.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些问题，风还晃动了相机，不精确的追踪导致行星向左侧框架偏移。你可以在[图 15-3](ch15.xhtml#ch15fig3)中看到*横向漂移*的示例，我已将五个随机选择的帧叠加在一起，黑色背景设置为透明。
- en: '![image](../images/f0330-02.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0330-02.jpg)'
- en: '*Figure 15-3: An example of shake and drift in the Jupiter video based on five
    randomly chosen frames*'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-3：基于五个随机选择的帧，展示木星视频中的抖动和漂移示例*'
- en: Movement isn’t necessarily a bad thing, because shifting the image around can
    smooth defects associated with the CCD sensor surface, dust on the lens or sensor,
    and so on. But the key assumption in image stacking is that the images perfectly
    align so that persistent features, like Jupiter’s cloud bands, reinforce each
    other as you average the images. For the signal-to-noise ratio to be high, the
    images must be registered.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 移动未必是坏事，因为调整图像的位置可以平滑与CCD传感器表面、镜头或传感器上的灰尘等相关的缺陷。但图像叠加的关键假设是，图像必须完全对齐，以便像木星的云带这样的持久特征在平均图像时相互增强。为了获得高信噪比，图像必须经过配准。
- en: '*Image registration* is the process of transforming data to the same coordinate
    system so that it can be compared and integrated. Registration is arguably the
    hardest part of image stacking. Astronomers typically use commercial software—such
    as RegiStax, RegiStar, Deep Sky Stacker, or CCDStack—to help them align and stack
    their astrophotos. You’ll get your hands dirty, however, and do this yourself
    using Python.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*图像配准*是将数据转换到相同坐标系的过程，以便可以进行比较和整合。配准无疑是图像叠加中最难的部分。天文学家通常使用商业软件——如RegiStax、RegiStar、Deep
    Sky Stacker或CCDStack——来帮助他们对齐和叠加天文照片。然而，你将亲自动手，使用Python来完成这一过程。'
- en: '**The Strategy**'
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**策略**'
- en: 'The steps required to stack the images are as follows (the first one has already
    been completed):'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 叠加图像所需的步骤如下（第一个步骤已经完成）：
- en: Extract images from video recording.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从视频录制中提取图像。
- en: Crop images around Jupiter.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 裁剪围绕木星的图像。
- en: Scale cropped images to the same size.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将裁剪后的图像调整为相同的大小。
- en: Stack images into a single image.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将图像叠加成一张图像。
- en: Enhance and filter the final image.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 增强并过滤最终图像。
- en: '**The Code**'
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**代码**'
- en: You can incorporate all the steps into one program, but I chose to distribute
    them across three programs. This is because you generally want to stop and check
    results along the way, plus you may want to run later processes, such as enhancement,
    without having to completely rerun the whole workflow. The first program will
    crop and scale the images, the second will stack them, and the third will enhance
    them.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将所有步骤整合到一个程序中，但我选择将它们分布到三个程序中。这是因为你通常希望在过程中停下来检查结果，此外你可能还希望运行后续的处理步骤，比如增强，而不必完全重新运行整个工作流。第一个程序将裁剪和缩放图像，第二个程序将叠加图像，第三个程序将增强图像。
- en: '***The Cropping and Scaling Code***'
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***裁剪和缩放代码***'
- en: First, you need to register the images. For large, bright objects like the moon
    and Jupiter, one approach in astrophotography is to crop each image so that its
    four borders are tangent with the surface of the body. This removes most of the
    sky and mitigates any shake and drift issues. Scaling the cropped images will
    ensure they are all the same size and will smooth them slightly to reduce noise.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要对图像进行配准。对于像月亮和木星这样的大型明亮物体，天文摄影中的一种方法是裁剪每张图像，使其四个边界与天体的表面相切。这将去除大部分天空区域，并缓解任何抖动和漂移问题。对裁剪后的图像进行缩放，将确保它们的大小一致，并稍微平滑它们以减少噪声。
- en: You can download *crop_n_scale_images.py* from *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*.
    Keep it in the directory that holds the folder of captured video frames.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从 *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*
    下载 *crop_n_scale_images.py*。将其保存在包含捕获的视频帧文件夹的目录中。
- en: '**Importing Modules and Defining the main() Function**'
  id: totrans-67
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**导入模块并定义 main() 函数**'
- en: '[Listing 15-2](ch15.xhtml#ch15list2) performs imports and defines the `main()`
    function that runs the *crop_n_scale_images.py* program.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 15-2](ch15.xhtml#ch15list2)执行了模块导入并定义了运行 *crop_n_scale_images.py* 程序的 `main()`
    函数。'
- en: '*crop_n_scale_images.py,* part 1'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*crop_n_scale_images.py,* 第1部分'
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 15-2: Imports modules and defines the* main() *function*'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 15-2：导入模块并定义* main() *函数*'
- en: Start by importing both the operating system (`os`) and system (`sys`) ➊. The
    `os` import already includes an import of `sys`, but this feature may go away
    in the future, so it’s best to manually import `sys` yourself. The `shutil` module
    contains the shell utilities described earlier ➋. From the imaging library, you’ll
    use `Image` to load, crop, convert, and filter images; you’ll also use `ImageOps`
    to scale images ➌. Note you must use PIL, not `pillow`, in the `import` statement.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 首先导入操作系统（`os`）和系统（`sys`）模块 ➊。`os`模块已包含了对`sys`的导入，但这个功能可能在未来会取消，因此最好自己手动导入`sys`。`shutil`模块包含了前面描述的
    shell 实用工具 ➋。在图像库中，你将使用`Image`来加载、裁剪、转换和过滤图像；还将使用`ImageOps`来缩放图像 ➌。请注意，在`import`语句中必须使用
    PIL，而不是 `pillow`。
- en: Start the `main()` function by assigning the name of the starting folder to
    the `frames_folder` variable ➍. This folder contains all the original images captured
    from the video.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 启动 `main()` 函数，并将起始文件夹的名称赋值给 `frames_folder` 变量 ➍。该文件夹包含从视频中捕获的所有原始图片。
- en: You’ll store the cropped images in a new folder named *cropped*, but the shell
    utilities won’t create this folder if it already exists, so call the `del_folders()`
    function that you’ll write in a moment ➎. As written, this function won’t throw
    an error if the folder doesn’t exist, so it can be run safely at any time.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你将把裁剪后的图片存储在一个名为 *cropped* 的新文件夹中，但如果该文件夹已存在，shell 工具不会创建它，因此请调用稍后编写的 `del_folders()`
    函数 ➎。如上所述，如果文件夹不存在，该函数不会抛出错误，因此可以在任何时候安全运行。
- en: You should always work off a copy of original images, so use the `shutil.copytree()`
    method to copy the folder containing the originals to a new folder named *cropped*
    ➏. Now, switch to this folder ➐ and call the `crop_images()` function, which will
    crop and scale the images. Follow this with the `clean_folder()` function, which
    removes the original video frames that were copied into the *cropped* folder and
    are still hanging around ➑. Note that you use the parameter name when you pass
    the argument to the `clean_folder()` function, since this makes the purpose of
    the function more obvious.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该始终在原始图片的副本上进行操作，因此使用 `shutil.copytree()` 方法将包含原始图片的文件夹复制到一个名为 *cropped* 的新文件夹中
    ➏。现在，切换到此文件夹 ➐ 并调用 `crop_images()` 函数，该函数将裁剪并缩放图片。然后调用 `clean_folder()` 函数，它会删除仍然存在于
    *cropped* 文件夹中的原始视频帧 ➑。请注意，在将参数传递给 `clean_folder()` 函数时使用参数名，因为这使得函数的目的更加明确。
- en: Print `Done!` to let the user know when the program is finished.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 打印 `Done!` 以便在程序完成时通知用户。
- en: '**Deleting and Cleaning Folders**'
  id: totrans-77
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**删除和清理文件夹**'
- en: '[Listing 15-3](ch15.xhtml#ch15list3) defines helper functions to delete files
    and folders in *crop_n_scale_images.py*. The `shutil` module will refuse to make
    a new folder if one with the same name already exists in the target directory.
    If you want to run the program more than once, you first have to remove or rename
    existing folders. The program will also rename images once they have been cropped,
    and you’ll want to delete the original images before you start stacking them.
    Since there will be hundreds of image files, these functions will automate an
    otherwise laborious task.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 15-3](ch15.xhtml#ch15list3) 定义了用于删除文件和文件夹的辅助函数，这些函数位于 *crop_n_scale_images.py*
    中。`shutil` 模块如果目标目录中已经有一个同名的文件夹，将拒绝创建新的文件夹。如果你想多次运行该程序，首先必须删除或重命名现有的文件夹。程序还会在裁剪图片后重命名它们，在开始叠加这些图片之前，你需要删除原始图片。由于将会有数百个图像文件，这些函数将自动化本来繁琐的任务。'
- en: '*crop_n_scale_images.py,* part 2'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*crop_n_scale_images.py*，第二部分'
- en: '[PRE4]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 15-3: Defines functions to delete folders and files*'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 15-3：定义用于删除文件夹和文件的函数*'
- en: Define a function called `del_folders()` for deleting folders ➊. The only argument
    will be the name of a folder you want to remove.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个名为 `del_folders()` 的函数来删除文件夹 ➊。唯一的参数将是你想要删除的文件夹名称。
- en: Next, list the contents of the folder ➋, then start looping through the contents
    ➌. If the function encounters an item that starts with the folder name and is
    also a directory ➍, use `shutil.rmtree()` to delete the folder ➎. As you’ll see
    in a moment, a different method is used to delete a folder than to delete a file.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，列出文件夹的内容 ➋，然后开始循环遍历内容 ➌。若函数遇到一个以文件夹名称开头并且也是一个目录的项 ➍，则使用 `shutil.rmtree()`
    删除该文件夹 ➎。正如你稍后会看到的，删除文件夹与删除文件的方法是不同的。
- en: '**NOTE**'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Always be careful when using the* rmtree() *method, as it* permanently *deletes
    folders and their contents. You can wipe much of your system, lose important documents
    unrelated to Python projects, and break your computer!*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用* rmtree() *方法时要始终小心，因为它会* 永久 *删除文件夹及其内容。你可能会删除系统中的大部分内容，丢失与 Python 项目无关的重要文档，并可能破坏你的计算机！*'
- en: Now, define a helper function to “clean” a folder and pass it the name of files
    *that you don’t want to delete* ➏. This is a little counterintuitive at first,
    but since you only want to keep the last batch of images you’ve processed, you
    don’t have to worry about explicitly listing any other files in the folder. If
    the files don’t start with the prefix you provide, such as *cropped*, then they
    are automatically removed.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，定义一个辅助函数来“清理”文件夹，并传递一个*不想删除*的文件名 ➏。一开始这可能有点反直觉，但因为你只想保留最后一批已处理的图片，所以不必显式列出文件夹中的任何其他文件。如果文件名没有以你提供的前缀（例如
    *cropped*）开头，那么它们将被自动删除。
- en: The process is similar to the last function. List the contents of the folder
    ➐ and start looping through the list. If the file doesn’t start with the prefix
    you provided ➑, use `os.remove()` to delete it ➒.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程类似于上一个函数。列出文件夹内容 ➐，并开始遍历该列表。如果文件名没有以你提供的前缀开头 ➑，则使用`os.remove()`删除该文件 ➒。
- en: '**Cropping, Scaling, and Saving Images**'
  id: totrans-88
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**裁剪、缩放和保存图像**'
- en: '[Listing 15-4](ch15.xhtml#ch15list4) registers the frames captured from the
    video by fitting a box around Jupiter and cropping the image to the box ([Figure
    15-4](ch15.xhtml#ch15fig4)). This technique works well with bright images on a
    field of black (see “[Further Reading](ch15.xhtml#lev376)” on [page 343](ch15.xhtml#page_343)
    for another example).'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 15-4](ch15.xhtml#ch15list4) 通过在木星周围拟合一个框并裁剪图像来注册从视频中捕获的帧（见[图 15-4](ch15.xhtml#ch15fig4)）。这种技术在明亮的图像和黑色背景的场景中效果很好（另见[进一步阅读](ch15.xhtml#lev376)，在[第343页](ch15.xhtml#page_343)中有其他示例）。'
- en: '![image](../images/f0334-01.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0334-01.jpg)'
- en: '*Figure 15-4: Cropping the original video frame to Jupiter to align the images*'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-4: 将原始视频帧裁剪到木星周围以对齐图像*'
- en: By cropping the images tightly around Jupiter, you resolve all of the drift
    and shake issues.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将图像紧密裁剪在木星周围，你可以解决所有漂移和抖动问题。
- en: Each cropped image is also scaled to a larger and consistent size and smoothed
    slightly to reduce noise. The cropped and scaled images will be kept in their
    own folder, which the `main()` function creates, later.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 每个裁剪后的图像还会被缩放到更大且一致的大小，并稍微平滑以减少噪声。裁剪和缩放后的图像将保存在它们自己的文件夹中，这个文件夹将在之后由`main()`函数创建。
- en: '*crop_n_scale_images.py,* part 3'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*crop_n_scale_images.py,* 第三部分'
- en: '[PRE5]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 15-4: Crops initial video frames to a box around Jupiter and rescales*'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 15-4: 裁剪初始视频帧至围绕木星的框，并重新缩放*'
- en: The `crop_images()` function takes no argument ➊ but will ultimately work on
    a copy—named *cropped*—of the folder containing the original video frames. You
    made this copy in the `main()` function prior to calling this function.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`crop_images()`函数不接受任何参数 ➊，但最终将处理一个名为*cropped*的副本，该副本包含原始视频帧所在的文件夹。你在调用此函数之前已经在`main()`函数中创建了这个副本。'
- en: Start the function by making a list of the contents of the current (*cropped*)
    folder ➋. The program will number each image sequentially, so use `enumerate()`
    with the `for` loop and set the `start` option to `1` ➌. If you haven’t used `enumerate()`
    before, it’s a handy built-in function that acts as an automatic counter; the
    count will be assigned to the `file_num` variable.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 通过列出当前(*cropped*)文件夹的内容 ➋ 来开始该函数。程序会按顺序为每张图像编号，因此使用`enumerate()`与`for`循环，并将`start`选项设置为`1`
    ➌。如果你之前没有使用过`enumerate()`，它是一个非常方便的内建函数，作为自动计数器；计数值将被分配给`file_num`变量。
- en: Next, name a variable, `img`, to hold the image and use the `open()` method
    to open the file ➍.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，命名一个变量`img`来存放图像，并使用`open()`方法打开文件 ➍。
- en: To fit the borders of a bounding box to Jupiter, you need all the non-Jupiter
    parts of an image to be black `(0, 0, 0)`. Unfortunately, there are stray, noise-related,
    nonblack pixels beyond Jupiter, and the edge of the planet is diffuse and gradational.
    These issues result in nonuniform box shapes, as shown in [Figure 15-5](ch15.xhtml#ch15fig5).
    Fortunately, you can easily resolve these by converting the image to black and
    white. You can then use this converted image to determine the proper box dimensions
    for each color photo.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将边界框的边界适应木星，你需要将图像中所有非木星部分的像素设为黑色`(0, 0, 0)`。不幸的是，木星之外有一些噪声相关的黑色以外的像素，并且木星的边缘是模糊和渐变的。这些问题会导致边界框形状不规则，如[图
    15-5](ch15.xhtml#ch15fig5)所示。幸运的是，你可以通过将图像转换为黑白图像轻松解决这些问题。然后，你可以使用该转换后的图像来确定每张彩色照片的正确框尺寸。
- en: '![image](../images/f0335-01.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0335-01.jpg)'
- en: '*Figure 15-5: Irregularly sized cropped images due to problems defining the
    bounding box dimensions*'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-5: 由于定义边界框尺寸的问题，裁剪后的图像大小不规则*'
- en: To eliminate the noise effects that compromise the bounding-box technique, convert
    the loaded image to the “L” mode—consisting of 8-bit black and white pixels—and
    name the variable `gray`, for grayscale ➎. With this mode there is only one channel
    (versus the three channels for RGB color images), so you only need to decide on
    a single value when thresholding—that is, setting a limit above or below which
    an action occurs.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了消除破坏边界框技术的噪声影响，将加载的图像转换为“L”模式——由8位黑白像素组成——并将该变量命名为`gray`，表示灰度图 ➎。使用这种模式时，图像只有一个通道（与RGB彩色图像的三个通道不同），因此在进行阈值化时，你只需要决定一个单一的值——即设定一个阈值，超过或低于该值时触发某个操作。
- en: Assign a new variable, called `bw`, to hold a true black-and-white image ➏.
    Use the `point()` method, used to change pixel values, and a lambda function to
    set any value below 90 to black (`0`) and all other values to white (`255`). The
    threshold value was determined through trial and error. The `point()` method now
    returns a clean image for fitting the bounding box ([Figure 15-6](ch15.xhtml#ch15fig6)).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为一个新变量`bw`赋值，用来保存真正的黑白图像 ➏。使用`point()`方法（用于更改像素值）和一个lambda函数，将任何小于90的值设为黑色（`0`），其他所有值设为白色（`255`）。阈值是通过反复试验得出的。`point()`方法现在返回一个干净的图像，适合进行边界框的拟合（见[图
    15-6](ch15.xhtml#ch15fig6)）。
- en: '![image](../images/f0336-01.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0336-01.jpg)'
- en: '*Figure 15-6: Screen capture of one of the original video frames converted
    to pure black and white*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-6：将原始视频帧之一转换为纯黑白的屏幕截图*'
- en: Now, call the `Image` module’s `getbox()` method on `bw` ➐. This method prunes
    off black borders by fitting a bounding box to the nonzero regions of an image.
    It returns a tuple with the left, upper, right, and lower pixel coordinates of
    the box.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，调用`Image`模块的`getbox()`方法，作用于`bw` ➐。此方法通过将边界框拟合到图像的非零区域来修剪掉黑色边框。它返回一个元组，包含边框的左、上、右、下像素坐标。
- en: If you use `box` to crop the video frames, you get an image with borders tangent
    to Jupiter’s surface (see the middle image in [Figure 15-7](ch15.xhtml#ch15fig7)).
    This is what you want, but it’s not visually pleasing. So, add some black padding
    by assigning a new box variable, named `padded_box`, with its edges extended 20
    pixels in all four directions (see the rightmost image in [Figure 15-7](ch15.xhtml#ch15fig7)).
    Because the padding is consistent and applied to all images, it doesn’t compromise
    the results of cropping.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用`box`裁剪视频帧，会得到一个与木星表面相切的图像（见[图 15-7](ch15.xhtml#ch15fig7)中的中间图像）。这是你想要的效果，但视觉上不够美观。因此，通过赋值一个新的框变量`padded_box`，并将其四个方向的边缘都扩展20像素（见[图
    15-7](ch15.xhtml#ch15fig7)中的最右图像），为图像添加一些黑色填充。由于填充是一致的，并且应用于所有图像，它不会影响裁剪的结果。
- en: '![image](../images/f0336-02.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0336-02.jpg)'
- en: '*Figure 15-7: Initial crop tangent to Jupiter’s surface (*box*) and final crop
    with padding (*padded_box*)*'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-7：初始裁剪与木星表面相切（*box*）和带填充的最终裁剪（*padded_box*）*'
- en: Continue by cropping each image with the `crop()` method ➑. This method takes
    `padded_box` as an argument.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过`crop()`方法裁剪每张图像 ➑。此方法以`padded_box`作为参数。
- en: To scale the image, use the `ImageOps.fit()` method. This takes the image, a
    size as a pixel width-and-height tuple, a resampling method, a border (`0` = no
    border), and even cropping from the center, designated by the tuple `(0.5, 0.5)`.
    The `pillow` module has several algorithm choices for resizing an image, but I
    chose the popular *Lanczos* filter. Enlarging an image tends to reduce its sharpness,
    but Lanczos can produce *ringing artifacts* along strong edges; this helps increase
    *perceived* sharpness. This unintended edge enhancement can help the eye focus
    on features of interest, which are faint and blurry in the original video frames.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了缩放图像，使用`ImageOps.fit()`方法。此方法接受图像、一个像素宽度和高度的元组、一个重采样方法、一个边框（`0`表示无边框）以及甚至是从中心裁剪，中心由元组`(0.5,
    0.5)`指定。`pillow`模块提供了多种图像缩放算法，但我选择了流行的*Lanczos*滤镜。放大图像往往会降低其清晰度，但Lanczos可以在强边缘产生*振铃伪影*；这有助于增强*感知*清晰度。这种意外的边缘增强可以帮助眼睛集中注意力于那些在原始视频帧中模糊且微弱的特征。
- en: After scaling, assign a `file_name` variable. Each of the 256 cropped images
    will start with *cropped_* and end with the number of the image, which you pass
    to the replacement field of the `format()` method. End the function by saving
    the file ➒.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 缩放后，赋值一个`file_name`变量。每个被裁剪的256个图像文件名将以*cropped_*开头，并以图像编号结尾，图像编号会传递给`format()`方法的替换字段。最后，通过保存文件来结束函数
    ➒。
- en: Back in the global scope, add the code that lets the program run as a module
    or in stand-alone mode.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到全局作用域，添加让程序可以作为模块或独立运行的代码。
- en: '**NOTE**'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*I save the files using JPEG format because it is universally readable, handles
    gradations in color well, and takes up very little memory. JPEG uses “lossy” compression,
    however, which causes a tiny bit of image deterioration each time a file is saved;
    you can adjust the degree of compression at the expense of storage size. In most
    cases, when working with astrophotographs, you’ll want to use one of the many
    lossless formats available, such as TIFF.*'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*我使用 JPEG 格式保存文件，因为它是通用的、易于读取的，且能够很好地处理色彩渐变，内存占用也非常小。然而，JPEG 使用的是“有损”压缩，这意味着每次保存文件时，图像都会有一点微小的损失；你可以在存储空间的开销下调整压缩的程度。在大多数情况下，处理天文照片时，你会希望使用一种无损格式，例如
    TIFF。*'
- en: At this point in the workflow, you’ve cropped the original video frames down
    to a box around Jupiter; then you scaled the cropped images to a larger, consistent
    size ([Figure 15-8](ch15.xhtml#ch15fig8)).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在工作流程的这个阶段，你已经将原始视频帧裁剪成围绕木星的框框；然后你将裁剪后的图像缩放到更大且一致的尺寸（[图 15-8](ch15.xhtml#ch15fig8)）。
- en: '![image](../images/f0337-01.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0337-01.jpg)'
- en: '*Figure 15-8: Relative sizes of images after cropping and scaling*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-8：裁剪和缩放后图像的相对大小*'
- en: In the next section, you write the code that stacks the cropped and scaled images.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，你将编写代码来堆叠裁剪和缩放后的图像。
- en: '***The Stacking Code***'
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***堆叠代码***'
- en: The *stack_images.py* code takes the images produced by the last program and
    averages them so that a single stacked image is produced. You can download it
    from the book’s resources at *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*.
    Keep it in the same folder as the *crop_n_scale_images.py* program.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*stack_images.py* 代码将上一程序生成的图像进行平均，生成一张单一的堆叠图像。你可以从本书的资源网站下载该代码，地址是 *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*。请将其保存在与
    *crop_n_scale_images.py* 程序相同的文件夹中。'
- en: '[Listing 15-5](ch15.xhtml#ch15list5) imports modules, loads images, creates
    lists of color channels (red, blue, green), averages the channels, recombines
    the channels, and creates and saves the final stacked image. It’s simple enough
    that we won’t bother with a `main()` function.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 15-5](ch15.xhtml#ch15list5) 导入模块，加载图像，创建颜色通道（红色、蓝色、绿色）的列表，平均通道，重新合并通道，并创建并保存最终的堆叠图像。代码足够简单，因此我们不需要使用
    `main()` 函数。'
- en: '*stack_images.py*'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*stack_images.py*'
- en: '[PRE6]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 15-5: Splits out and averages color channels, then recombines into
    a single image*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 15-5：分离并平均颜色通道，然后重新合成成单一图像*'
- en: Start by repeating some of the imports you used in the previous program ➊. Next,
    change the current directory to the *cropped* folder, which contains the cropped
    and scaled images of Jupiter ➋, and immediately make a list of the images in the
    folder using `os.listdir()`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，重复使用在之前程序中用过的一些导入 ➊。接下来，将当前目录更改为 *cropped* 文件夹，该文件夹包含木星的裁剪和缩放图像 ➋，并立即使用 `os.listdir()`
    获取文件夹中的图像列表。
- en: With `pillow`, you can manipulate individual pixels or groups of pixels, and
    you can do this for individual color channels, such as red, blue, and green. To
    demonstrate this, you’ll work on individual color channels to stack the images.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `pillow`，你可以操作单个像素或像素组，并且可以针对单独的颜色通道（如红色、蓝色和绿色）进行操作。为了演示这一点，你将处理单独的颜色通道来堆叠图像。
- en: Create three empty lists to hold the RGB pixel data ➌, then start looping through
    the images list ➍. First, open the image. Then, get the width and height of the
    first image, in pixels, as a tuple. Remember, in the previous program, you scaled
    all the small cropped images to a larger size. You’ll need these dimensions later
    for creating the new stacked image, and `size` automatically retrieves this info
    for you.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 创建三个空列表来存储RGB像素数据 ➌，然后开始遍历图像列表 ➍。首先，打开图像。接着，获取第一张图像的宽度和高度，以像素为单位，作为一个元组。记住，在之前的程序中，你将所有的小裁剪图像缩放到了一个更大的尺寸。稍后你需要这些尺寸来创建新的堆叠图像，`size`
    会自动为你获取这些信息。
- en: 'Now use the `getdata()` method to get the pixel data for the selected image
    ➎. Pass the method the index of the color channel you want: `0` for red, `1` for
    green, and `2` for blue. Append the results to a data list, as appropriate. The
    data from each image will form a separate list in the data lists.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用 `getdata()` 方法获取选定图像的像素数据 ➎。传递方法颜色通道的索引：`0` 表示红色，`1` 表示绿色，`2` 表示蓝色。将结果适当地追加到数据列表中。每张图像的数据将形成数据列表中的一个单独列表。
- en: To average the values in each list, use list comprehension to sum the pixels
    in all the images and divide by the total number of images ➏. Note that you use
    `zip` with the splat (`*`) operator. Your `red_data` list, for example, is a list
    of lists, with each nested list representing one of the 256 image files. Using
    `zip` with `*` unpacks the contents of the lists so that the first pixel in image1
    is summed with the first pixel in image2, and so on.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要对每个列表中的值进行平均，可以使用列表推导将所有图像中的像素求和，并除以图像总数 ➏。注意，你使用了带有解包（`*`）操作符的`zip`。例如，`red_data`列表是一个列表的列表，每个嵌套列表代表一个256张图像文件中的数据。使用带有`*`的`zip`可以解包这些列表的内容，从而使图像1中的第一个像素与图像2中的第一个像素相加，依此类推。
- en: To merge the averaged color channels, use list comprehension with `zip` ➐. Next,
    create a new image, named `stacked`, using `Image.new()` ➑. Pass the method a
    color mode (`'RGB'`) and the `img_size` tuple containing the desired width and
    height of the image in pixels, which was obtained earlier from one of the cropped
    images.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要合并平均的颜色通道，使用带有`zip`的列表推导 ➐。接下来，使用`Image.new()` ➑创建一个新的图像，命名为`stacked`。将方法的颜色模式（`'RGB'`）和包含所需图像宽度和高度的`img_size`元组传递给它，这个元组之前是从其中一个裁剪过的图像中获得的。
- en: Populate the new `stacked` image using the `putdata()` method and pass it the
    `merged_data` list ➒. This method copies data from a sequence object into an image,
    starting at the upper-left corner `(0, 0)`. Display the final image using the
    `show()` method. Finish by changing the folder to the parent directory and saving
    the image as a TIFF file named *jupiter_stacked.tif* ➓.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`putdata()`方法填充新的`stacked`图像，并将`merged_data`列表传递给它 ➒。此方法将数据从一个序列对象复制到图像中，从左上角
    `(0, 0)` 开始。使用`show()`方法显示最终图像。最后，切换到父目录并将图像保存为名为*jupiter_stacked.tif*的TIFF文件
    ➓。
- en: If you compare one of the original video frames to the final stacked image (*jupiter_stacked.tif*),
    as in [Figure 15-9](ch15.xhtml#ch15fig9), you’ll see a clear improvement in edge
    definition and the signal-to-noise ratio. This is best appreciated in color, so
    if you haven’t run the program, take the time to download *Figure 15-9.pdf* from
    the website. When the image is viewed in color, the benefits of the stacking include
    smoother, “creamier” white bands, better-defined red bands, and a more obvious
    Great Red Spot. There is still room for improvement, however, so next you’ll write
    a program to enhance the final stacked image.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将其中一个原始视频帧与最终的叠加图像（*jupiter_stacked.tif*）进行比较，如[图 15-9](ch15.xhtml#ch15fig9)所示，你会看到边缘定义和信噪比的明显提升。这在颜色上最为明显，因此如果你还没有运行该程序，可以花点时间从网站上下载*Figure
    15-9.pdf*。当图像以彩色显示时，叠加的好处包括更平滑、像“奶油”般的白色条带，更清晰的红色条带，以及更明显的大红斑。然而，仍然有改进的空间，接下来你将编写一个程序来增强最终的叠加图像。
- en: '![image](../images/f0339-01.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0339-01.jpg)'
- en: '*Figure 15-9: An original video frame compared to final stacked image (*jupiter_stacked.tif*)*'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-9：一个原始视频帧与最终叠加图像（*jupiter_stacked.tif*）的对比*'
- en: '**NOTE**'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If the Great Red Spot looks pinkish to you in the stacked image, that’s because
    it is! It fades from time to time, and many published pictures of Jupiter have
    exaggerated colors due to processing, so this subtle coloration gets lost. This
    is probably for the best, as “Great Pink Spot” just doesn’t have the same ring
    to it.*'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果在叠加图像中大红斑看起来有些粉红，那是因为它确实是！它会时常褪色，许多公开的木星图片由于处理过程夸大了颜色，因此这种微妙的色调常常被忽略。或许这样更好，因为“伟大的粉红斑”听起来总不如“伟大的红斑”那么有气势。*'
- en: '***The Enhancing Code***'
  id: totrans-139
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***增强代码***'
- en: You’ve successfully stacked all the video frames, but Jupiter is still crooked,
    and its features are faint. You can further improve the stacked image using filters,
    enhancers, and transforms found in `pillow`. As you enhance images, you get further
    and further from the “ground truth” raw data. For this reason, I chose to isolate
    the enhancement process in a separate program.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经成功地叠加了所有视频帧，但木星仍然歪斜，且其特征较为模糊。你可以使用`pillow`中的滤镜、增强器和变换工具进一步改善叠加图像。随着图像的增强，你会越来越远离“真实”原始数据。出于这个原因，我选择将增强过程隔离到一个单独的程序中。
- en: In general, the first steps after stacking are to enhance details, using high-pass
    filters or an unsharp mask algorithm, and then to fine-tune brightness, contrast,
    and color. The code will use `pillow`’s image enhancement capability to apply
    these steps—though in a different order. You can download the code as *enhance_image.py*
    from *[https://nostarch.com/impracticalpython/](https://nostarch.com/impracticalpython/)*.
    Keep it in the same folder as the previous Python programs.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，堆叠后的第一步是增强细节，使用高通滤波器或锐化掩模算法，然后微调亮度、对比度和色彩。代码将利用 `pillow` 的图像增强功能来执行这些步骤——尽管顺序不同。你可以从
    *[https://nostarch.com/impracticalpython/](https://nostarch.com/impracticalpython/)*
    下载代码文件 *enhance_image.py*。将其与之前的 Python 程序保存在同一文件夹中。
- en: '**NOTE**'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The processing of astronomical images can be quite involved, and whole books
    have been written on the subject. Some of the standard steps have been omitted
    in this workflow. For instance, the original video was not calibrated, and distortion
    effects due to turbulence were not corrected. Advanced software, such as RegiStax
    or AviStack, can prevent blurring by warping individual images so that distorted
    features, like the edges of cloud bands, overlap properly in all images.*'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*天文图像的处理可能相当复杂，关于这一主题已经有整本书籍。这个工作流程中省略了一些标准步骤。例如，原始视频没有进行校准，且未纠正由于湍流造成的畸变效应。像
    RegiStax 或 AviStack 这样的高级软件可以通过扭曲单独的图像来防止模糊，从而确保像云带边缘这样的扭曲特征在所有图像中正确重叠。*'
- en: '[Listing 15-6](ch15.xhtml#ch15list6) imports `pillow` classes and opens, enhances,
    and saves the stacked image generated by the previous code. Because there are
    many possible options for enhancing images, I chose to modularize this program
    despite its small size.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 15-6](ch15.xhtml#ch15list6) 导入了 `pillow` 类，并打开、增强并保存了前面代码生成的堆叠图像。由于增强图像有很多可能的选项，尽管程序很小，我还是选择将其模块化。'
- en: '*enhance_image.py*'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*enhance_image.py*'
- en: '[PRE7]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 15-6: Opens an image, enhances it, and saves it using a new name*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 15-6：打开图像、增强它并使用新名称保存*'
- en: The import is familiar except for the last two ➊. These new modules, `ImageFilter`
    and `ImageEnhance`, contain predefined filters and classes that can be used to
    alter images with blurring, sharpening, brightening, smoothing, and more (see
    *[https://pillow.readthedocs.io/en/5.1.x/](https://pillow.readthedocs.io/en/5.1.x/)*
    for a full listing of what’s in each module).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 导入部分除了最后两个模块 ➊ 外，其他都很常见。这些新模块，`ImageFilter` 和 `ImageEnhance`，包含了预定义的滤镜和类，可以用来通过模糊、锐化、亮化、平滑等方式改变图像（查看
    *[https://pillow.readthedocs.io/en/5.1.x/](https://pillow.readthedocs.io/en/5.1.x/)*
    以查看每个模块中包含的完整列表）。
- en: Start by defining the `main()` function ➋. Assign the stacked image to a variable
    named `in_file`, then pass it to `Image.open()` to open the file ➌. Next, call
    an `enhance_image()` function and pass it the image variable ➍. Show the enhanced
    image and then save it as a TIFF file, which results in no deterioration in image
    quality.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 首先定义 `main()` 函数 ➋。将堆叠图像赋值给名为 `in_file` 的变量，然后传递给 `Image.open()` 打开该文件 ➌。接下来，调用
    `enhance_image()` 函数并传入图像变量 ➍。显示增强后的图像，然后将其保存为 TIFF 文件，这样图像质量不会退化。
- en: Now, define an enhancement function, `enhance_image()`, that takes an image
    as an argument ➎. To paraphrase the `pillow` documentation, all enhancement classes
    implement a common interface containing a single method, `enhance(factor)`, that
    returns an enhanced image. The `factor` parameter is a floating-point value controlling
    the enhancement. A value of `1.0` returns a copy of the original; lower values
    diminish color, brightness, contrast, and so on; and higher values increase these
    qualities.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，定义一个增强函数 `enhance_image()`，它将图像作为参数 ➎。用更简单的话来说，`pillow` 文档中提到，所有增强类都实现了一个公共接口，包含一个名为
    `enhance(factor)` 的方法，该方法返回增强后的图像。`factor` 参数是一个浮动值，用于控制增强的程度。值为 `1.0` 时返回原图；较低的值会减弱颜色、亮度、对比度等；较高的值则会增强这些特性。
- en: To change the brightness of an image, you first create an instance of the `ImageEnhance`
    module’s `Brightness` class, passing it the original image ➏. Mimic the `pillow`
    docs and name this object `enhancer`. To make the final, enhanced image, you call
    the object’s `enhance()` method and pass it the `factor` argument ➐. In this case,
    you decrease brightness by 0.25\. The `# 0.75` comment at the end of the line
    is a useful way to experiment with different factors. Use this comment to store
    values you like; that way, you can remember and restore them if other test values
    don’t yield pleasing results.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要改变图像的亮度，首先创建`ImageEnhance`模块中的`Brightness`类的实例，并传入原始图像 ➏。模仿`pillow`文档，将该对象命名为`enhancer`。为了得到最终的增强图像，你调用该对象的`enhance()`方法，并传入`factor`参数
    ➐。此时，你将亮度降低了0.25。行尾的`# 0.75`注释是一种有用的方式来尝试不同的系数。使用这个注释保存你喜欢的值，这样如果其他测试值没有得到令人满意的结果，你可以记住并恢复它们。
- en: 'Continue enhancing the image, moving to contrast ➑. If you don’t want to adjust
    the contrast manually, you can take a chance and use `pillow`’s automatic contrast
    method. First, import `ImageOps` from PIL. Then, replace the two lines starting
    with step ➑ with the single line: `img_enh = ImageOps.autocontrast(img_enh)`.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 继续增强图像，调整对比度到➑。如果你不想手动调整对比度，可以试试`pillow`的自动对比度方法。首先，从PIL导入`ImageOps`。然后，将以步骤➑开头的两行代码替换为一行：`img_enh
    = ImageOps.autocontrast(img_enh)`。
- en: Next, punch up the color. This will help to make the Great Red Spot more visible.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，增加颜色的饱和度。这将帮助让大红斑更加明显。
- en: No one wants to look at a tilted Jupiter, so transform the image by rotating
    it to a more “conventional” view, where the cloud bands are horizontal and the
    Great Red Spot is to the lower right. Call the `Image` module’s `rotate()` method
    on the image and pass it an angle, measured counterclockwise in degrees, and have
    it automatically expand the output image to make it large enough to hold the entire
    rotated image ➒.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 没有人愿意看一张倾斜的木星图像，所以将图像旋转到一个更“传统”的视角，其中云带水平，大红斑位于右下方。调用`Image`模块的`rotate()`方法，并传入一个角度，角度按逆时针方向计算（单位为度），并让它自动扩展输出图像，以确保整个旋转后的图像都能显示完整
    ➒。
- en: Now, sharpen the image. Even on high-quality images, sharpening may be needed
    to ameliorate the interpolation effects of converting data, resizing and rotating
    images, and so on. Although some astrophotography resources recommend placing
    it first, in most image-processing workflows, it comes last. This is because it
    is dependent on the final size of the image (viewing distance), as well as the
    media being used. Sharpening can also increase noise artifacts and is a “lossy”
    operation that can remove data—things you don’t want to happen prior to other
    edits.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，锐化图像。即使是在高质量的图像上，锐化可能也是必需的，以改善数据转换、调整大小、旋转图像等带来的插值效果。尽管一些天文摄影资源推荐将锐化操作放在前面，但在大多数图像处理工作流程中，锐化是最后一步。这是因为锐化依赖于图像的最终大小（观看距离）以及所使用的媒体。锐化还可能增加噪点伪影，并且是“有损”的操作，可能会删除数据——这通常不希望在进行其他编辑之前发生。
- en: Sharpening is a little different from the previous enhancements, as you use
    the `ImageFilter` class. No intermediate step is needed; you can build the new
    image with a single line by calling the `filter()` method on the image object
    and passing it the predefined `SHARPEN` filter ➓. The `pillow` module has other
    filters that help define edges, such as `UnsharpMask` and `EDGE_ENHANCE`, but
    for this image, the results are indiscernible from `SHARPEN`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 锐化与之前的增强操作略有不同，因为你需要使用`ImageFilter`类。无需中间步骤，你只需要通过调用图像对象的`filter()`方法，并传入预定义的`SHARPEN`滤镜
    ➓，就可以用一行代码创建新的图像。`pillow`模块还提供了其他有助于定义边缘的滤镜，如`UnsharpMask`和`EDGE_ENHANCE`，但对于这张图像，效果与`SHARPEN`几乎没有区别。
- en: Finish by returning the image and applying the code to run the program as a
    module or in stand-alone mode.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过返回图像并应用代码来运行程序，无论是作为模块还是独立模式。
- en: The final enhanced image is compared to a random video frame and the final stacked
    image in [Figure 15-10](ch15.xhtml#ch15fig10). All the images have been rotated
    for ease of comparison.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 最终增强后的图像与随机视频帧及最终堆叠图像进行比较，见[图 15-10](ch15.xhtml#ch15fig10)。所有图像都已旋转，以便于比较。
- en: '![image](../images/f0342-01.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0342-01.jpg)'
- en: '*Figure 15-10: A random video frame, the results of stacking 256 frames, and
    the final enhanced image*'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-10：一帧随机视频、堆叠256帧的结果以及最终增强图像*'
- en: You can see the improvement best when you view it in color. If you want to see
    a color version prior to running the program, view or download *Figure 15-10.pdf*
    from the website.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当你以彩色查看时，最能看到改进。如果你想在运行程序之前看到彩色版本，可以在网站上查看或下载 *Figure 15-10.pdf* 文件。
- en: '**NOTE**'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you’re familiar with* pillow*, you may be aware that you can use the* Image.blend()
    *method to stack images with only a few lines of code. To my eye, however, the
    resulting image is noticeably noisier than that obtained by breaking out and averaging
    the individual color channels, as you did with the* stack_images.py *program.*'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你熟悉* pillow*，你可能知道可以使用* Image.blend() *方法仅通过几行代码堆叠图像。然而，在我看来，结果图像的噪声明显比通过分离和平均各个颜色通道所得到的图像要高，就像你在*
    stack_images.py *程序中所做的那样。*'
- en: '**Summary**'
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: The final image in [Figure 15-10](ch15.xhtml#ch15fig10) will never win any awards
    or be featured in *Sky & Telescope* magazine, but the point was to take on a challenge.
    And the result is a marked improvement over a single image captured from the video.
    The colors are brighter, the cloud bands sharper, and the Great Red Spot better
    defined. You can also make out the turbulent zone downwind of the Great Red Spot
    (refer to [Figure 15-1](ch15.xhtml#ch15fig1)).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 15-10](ch15.xhtml#ch15fig10)中的最终图像不会赢得任何奖项，也不会出现在 *Sky & Telescope* 杂志上，但重点是接受挑战。而且，结果相较于从视频中捕获的单张图像有了显著改进。颜色更加鲜明，云带更加清晰，红斑区更加分明。你还可以看清红斑区下风处的动荡区（参见[图
    15-1](ch15.xhtml#ch15fig1)）。'
- en: Despite starting with rough input, you were able to register the images, remove
    noise through stacking, and enhance the final image using filters and transforms.
    And all these steps were accomplished with the freely available `pillow` fork
    of the Python Imaging Library. You also gained experience with the Python `shutil`
    and `os` modules, which you used to manipulate files and folders.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管开始时输入较为粗糙，但你成功地完成了图像配准、通过堆叠去除噪声，并使用滤镜和变换增强了最终图像。所有这些步骤都是使用 Python 图像库的免费分支
    `pillow` 完成的。你还通过使用 Python 的 `shutil` 和 `os` 模块获得了操作文件和文件夹的经验。
- en: For more advanced image processing, you can use OpenSource Computer Vision (OpenCV),
    which you implement by installing and importing the `cv2` and `NumPy` modules.
    Other options involve `matplotlib`, `SciPy`, and `NumPy`. As always with Python,
    there’s more than one way to skin a cat!
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更高级的图像处理，你可以使用开源计算机视觉库 OpenCV，通过安装和导入 `cv2` 和 `NumPy` 模块来实现。其他选项还包括 `matplotlib`、`SciPy`
    和 `NumPy`。就像使用 Python 时一样，处理问题总有不止一种方式！
- en: '**Further Reading**'
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**进一步阅读**'
- en: '*Automate the Boring Stuff with Python: Practical Programming for Total Beginners*
    (No Starch Press, 2015) by Al Sweigart includes several useful chapters on working
    with files, folders, and `pillow`.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*Python 自动化无聊的事情：完全初学者的实用编程*（No Starch Press，2015）由 Al Sweigart 编写，书中包含了多个关于文件、文件夹以及
    `pillow` 库的实用章节。'
- en: Online resources for using Python with astronomy include Python for Astronomers
    (*[https://prappleizer.github.io/](https://prappleizer.github.io/)*) and Practical
    Python for Astronomers (*[https://python4astronomers.github.io/](https://python4astronomers.github.io/)*).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Python 进行天文学研究的在线资源包括 Python for Astronomers (*[https://prappleizer.github.io/](https://prappleizer.github.io/)*）和
    Practical Python for Astronomers (*[https://python4astronomers.github.io/](https://python4astronomers.github.io/)*）。
- en: If you want to learn more about the OpenCV-Python library, you can find tutorials
    at *[https://docs.opencv.org/3.4.2/d0/de3/tutorial_py_intro.html](https://docs.opencv.org/3.4.2/d0/de3/tutorial_py_intro.html)*.
    Note that knowledge of `NumPy` is a prerequisite for the tutorials and for writing
    optimized OpenCV code. Alternatively, SimpleCV lets you get started with computer
    vision and image manipulation with a smaller learning curve than OpenCV but only
    works with Python 2.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于 OpenCV-Python 库的内容，可以查看教程 *[https://docs.opencv.org/3.4.2/d0/de3/tutorial_py_intro.html](https://docs.opencv.org/3.4.2/d0/de3/tutorial_py_intro.html)*。请注意，`NumPy`
    的知识是学习这些教程及编写优化 OpenCV 代码的前提。另一个选择是 SimpleCV，它可以帮助你更容易地入门计算机视觉和图像处理，且学习曲线比 OpenCV
    更平缓，但只支持 Python 2。
- en: '*Astrophotography* (Rocky Nook, 2014) by Thierry Legault is an indispensable
    resource for anyone interested in serious astrophotography. A comprehensive and
    readable reference, it covers all aspects of the subject, from equipment selection
    through image processing.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*天文摄影*（Rocky Nook，2014）由 Thierry Legault 编写，是任何有意从事严肃天文摄影的人的必备资源。这本书是一本全面且易读的参考书，涵盖了从设备选择到图像处理的各个方面。'
- en: “Aligning Sun Images Using Python” (LabJG, 2013), a blog by James Gilbert, contains
    code for cropping the sun using the bounding-box technique. It also includes a
    clever method for realigning rotated images of the sun using sunspots as registration
    points. You can find it at *[https://labjg.wordpress.com/2013/04/01/aligning-sun-images-using-python/](https://labjg.wordpress.com/2013/04/01/aligning-sun-images-using-python/)*.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: A Google research team figured out how to use stacking to remove watermarks
    from images on stock photography websites and how the websites could better protect
    their property. You can read about it at *[https://research.googleblog.com/2017/08/making-visible-watermarks-more-effective.html](https://research.googleblog.com/2017/08/making-visible-watermarks-more-effective.html)*.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '**Challenge Project: Vanishing Act**'
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Image-stacking techniques can do more than just remove noise—they can remove
    anything that moves at a photo site, including people. Adobe Photoshop, for example,
    has a stack script that makes nonstationary objects magically vanish. It relies
    on a statistical average known as the *median*, which is simply the “middle” value
    in a list of numbers arranged from smallest to largest. The process requires multiple
    photos—preferably taken with a tripod-mounted camera—so that the objects you want
    to remove change positions from one image to the next, while the background remains
    constant. You typically need 10 to 30 pictures taken about 20 seconds apart, or
    similarly spaced frames extracted from a video.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: With the mean, you sum numbers and divide by the total. With the median, you
    sort numbers and choose the middle value. In [Figure 15-11](ch15.xhtml#ch15fig11),
    a row of five images is shown with the same pixel location outlined in each. In
    the fourth image, a blackbird has flown by and ruined the splendid white background.
    If you stack with the mean, the bird’s presence lingers. But do a median stack
    on the images—that is, sort the red, green, and blue channels and take the middle
    values—and you get the background value for each channel (`255`). No trace of
    the bird remains.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0344-01.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-11: Five white images with the same pixel highlighted and its RGB
    values displayed. Median-stacking removes the black pixel.*'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: When you average using the median, spurious values get pushed to the ends of
    the list. This makes it easy to remove outliers, such as satellites or airplanes
    in astrophotos, so long as the number of images containing the outlier is less
    than half the number of images.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Armed with this knowledge, write an image-stacking program that will remove
    unwanted tourists from your vacation happy snaps. For testing, you can download
    the *moon_cropped* folder from the website, which contains five synthetic images
    of the moon, each “ruined” by a passing plane (see [Figure 15-12](ch15.xhtml#ch15fig12)).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0345-01.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-12: Synthetic moon photos for testing the median averaging approach*'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-12：用于测试中值平均法方法的合成月球照片*'
- en: Your final stacked image should contain no evidence of the plane ([Figure 15-13](ch15.xhtml#ch15fig13)).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 你最终的叠加图像应该没有飞机的痕迹（[图 15-13](ch15.xhtml#ch15fig13)）。
- en: '![image](../images/f0345-02.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0345-02.jpg)'
- en: '*Figure 15-13: Result of stacking the images in the* moon_cropped *folder using
    median averaging*'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-13：使用中值平均法叠加* moon_cropped *文件夹中的图像结果*'
- en: As this is a challenge project, no solution is provided.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个挑战项目，因此没有提供解决方案。
