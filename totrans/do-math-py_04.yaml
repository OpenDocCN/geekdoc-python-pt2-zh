- en: '**4**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Algebra and Symbolic Math with SymPy**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '![image](images/common-01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: The mathematical problems and solutions in our programs so far have all involved
    the manipulation of numbers. But there’s another way math is taught, learned,
    and practiced, and that’s in terms of symbols and the operations between them.
    Just think of all the *x*s and *y*s in a typical algebra problem. We refer to
    this type of math as *symbolic math*. I’m sure you remember those dreaded “factorize
    *x*³ + 3*x*² + 3*x* + 1” problems in your math class. Fear no more, for in this
    chapter, we learn how to write programs that can solve such problems and much
    more. To do so, we’ll use *SymPy*—a Python library that lets you write expressions
    containing symbols and perform operations on them. Because this is a third-party
    library, you’ll need to install it before you can use it in your programs. The
    installation instructions are described in [Appendix A](app01.html#app01).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: '**Defining Symbols and Symbolic Operations**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Symbols* form the building blocks of symbolic math. The term *symbol* is just
    a general name for the *x*s, *y*s, *a*s, and *b*s you use in equations and algebraic
    expressions. Creating and using symbols will let us do things differently than
    before. Consider the following statements:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here we create a label, `x`, to refer to the number 1\. Then, when we write
    the statement `x + x + 1`, it’s evaluated for us, and the result is 3\. What if
    you wanted the result in terms of the symbol *x*? That is, if instead of 3, you
    wanted Python to tell you that the result is 2*x* + 1? You couldn’t just write
    `x + x + 1` *without* the statement `x = 1` because Python wouldn’t know what
    `x` refers to.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: 'SymPy lets us write programs where we can express and evaluate mathematical
    expressions in terms of such symbols. To use a symbol in your program, you have
    to create an object of the `Symbol` class, like this:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'First, we import the `Symbol` class from the `sympy` library. Then, we create
    an object of this class passing `''x''` as a parameter. Note that this `''x''`
    is written as a string within quotes. We can now define expressions and equations
    in terms of this symbol. For example, here’s the earlier expression:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now the result is given in terms of the symbol *x*. In the statement `x = Symbol(''x'')`,
    the `x` on the left side is the Python label. This is the same kind of label we’ve
    used before, except this time it refers to the symbol *x* instead of a number—more
    specifically, a `Symbol` object representing the symbol `''x''`. This label doesn’t
    necessarily have to match the symbol either— we could have used a label like `a`
    or `var1` instead. So, it’s perfectly fine to write the preceding statements as
    follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Using a non-matching label can be confusing, however, so I would recommend choosing
    a label that’s the same letter as the symbol it refers to.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '**FINDING THE SYMBOL REPRESENTED BY A SYMBOL OBJECT**'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'For any `Symbol` object, its `name` attribute is a string that is the actual
    symbol it represents:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何 `Symbol` 对象，它的 `name` 属性是一个字符串，表示它所代表的实际符号：
- en: '[PRE4]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can use `.name` on a label to retrieve the symbol that it is storing.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在标签上使用 `.name` 来检索它所存储的符号。
- en: Just to be clear, the symbol you create has to be specified as a string. For
    example, you can’t create the symbol *x* using `x = Symbol(x)`—you must define
    it as `x = Symbol('x')`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了明确起见，你创建的符号必须作为字符串指定。例如，你不能通过 `x = Symbol(x)` 来创建符号 *x*——你必须像这样定义它：`x = Symbol('x')`。
- en: 'To define multiple symbols, you can either create separate `Symbol` objects
    or use the `symbols()` function to define them more concisely. Let’s say you wanted
    to use three symbols—*x*, *y*, and *z*—in your program. You could define them
    individually, as we did earlier:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义多个符号，你可以创建单独的 `Symbol` 对象，或者使用 `symbols()` 函数更简洁地定义它们。假设你想在程序中使用三个符号——*x*、*y*
    和 *z*。你可以像之前那样逐个定义它们：
- en: '[PRE5]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'But a shorter method would be to use the `symbols()` function to define all
    three at once:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 但一种更简洁的方法是使用 `symbols()` 函数一次性定义所有三个符号：
- en: '[PRE6]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: First, we import the `symbols()` function from SymPy. Then, we call it with
    the three symbols we want to create, written as a string with commas separating
    them. After this statement is executed, `x`, `y`, and `z` will refer to the three
    symbols `'x'`, `'y'`, and `'z'`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从 SymPy 导入 `symbols()` 函数。然后，调用该函数并传入我们想要创建的三个符号，符号名称用逗号分隔。在执行完这行代码后，`x`、`y`
    和 `z` 将分别代表符号 `'x'`、`'y'` 和 `'z'`。
- en: 'Once you’ve defined symbols, you can carry out basic mathematical operations
    on them, using the same operators you learned in [Chapter 1](ch01.html#ch01) (`+`,
    `-`, `/`, `*`, and `**`). For example, you might do the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你定义了符号，你可以对它们执行基本的数学运算，使用你在[第 1 章](ch01.html#ch01)中学到的相同运算符（`+`、`-`、`/`、`*`
    和 `**`）。例如，你可能会这样做：
- en: '[PRE7]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let’s see whether we can find the product of `x(x + x)`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看是否能够找到 `x(x + x)` 的积：
- en: '[PRE8]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'SymPy will automatically make these simple addition and multiplication calculations,
    but if we enter a more complex expression, it will remain unchanged. Let’s see
    what happens when we enter the expression `(x + 2)*(x + 3)`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy 会自动进行这些简单的加法和乘法运算，但如果我们输入更复杂的表达式，它将保持不变。让我们看看当我们输入表达式 `(x + 2)*(x + 3)`
    时会发生什么：
- en: '[PRE9]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You may have expected SymPy to multiply everything out and output `x**2 + 5*x
    + 6`. Instead, the expression was printed exactly how we entered it. SymPy automatically
    simplifies only the most basic of expressions and leaves it to the programmer
    to explicitly require simplification in cases such as the preceding one. If you
    want to multiply out the expression to get the expanded version, you’ll have to
    use the `expand()` function, which we’ll see in a moment.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能预期 SymPy 会将所有内容展开并输出 `x**2 + 5*x + 6`。然而，表达式被打印得完全和我们输入的一样。SymPy 只会自动简化最基本的表达式，像前面的例子这种情况，需要程序员显式要求简化。如果你想将表达式展开以获得扩展版本，你需要使用
    `expand()` 函数，稍后我们会看到如何使用它。
- en: '**Working with Expressions**'
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**处理表达式**'
- en: Now that we know how to define our own symbolic expressions, let’s learn more
    about using them in our programs.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何定义自己的符号表达式，接下来让我们了解如何在程序中使用它们。
- en: '***Factorizing and Expanding Expressions***'
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***因式分解与展开表达式***'
- en: 'The `factor()` function decomposes an expression into its factors, and the
    `expand()` function expands an expression, expressing it as a sum of individual
    terms. Let’s test out these functions with the basic algebraic identity *x*² –
    *y*² = (*x* + *y*)(*x* – *y*). The left side of the identity is the expanded version,
    and the right side depicts the corresponding factorization. Because we have two
    symbols in the identity, we’ll create two `Symbol` objects:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`factor()` 函数将表达式分解为它的因子，而 `expand()` 函数将表达式展开，表示为各个单独项的和。让我们用基本的代数恒等式 *x*²
    – *y*² = (*x* + *y*)(*x* – *y*) 来测试这些函数。恒等式的左边是展开后的版本，右边则是相应的因式分解。由于我们有两个符号，接下来我们会创建两个
    `Symbol` 对象：'
- en: '[PRE10]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, we import the `factor()` function and use it to convert the expanded
    version (on the left side of the identity) to the factored version (on the right
    side):'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们导入 `factor()` 函数，并用它将展开版本（恒等式左边）转换为因式分解版本（右边）：
- en: '[PRE11]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As expected, we get the factored version of the expression. Now let’s expand
    the factors to get back the original expanded version:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，我们得到了表达式的因式分解版本。现在让我们展开这些因子，恢复成原来的展开版本：
- en: '[PRE12]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We store the factorized expression in a new label, `factors`, and then call
    the `expand()` function with it. When we do this, we receive the original expression
    we started with. Let’s try it with the more complicated identity *x*³ + 3*x*²*y*
    + 3*xy*² + *y*³ = (*x* + *y*)³:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `factor()` function is able to factorize the expression, and then the `expand()`
    function expands the factorized expression to return to the original expression.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'If you try to factorize an expression for which there’s no possible factorization,
    the original expression is returned by the `factor()` function. For example, see
    the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Similarly, if you pass in an expression to `expand()` that can’t be expanded
    further, it returns the same expression.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '***Pretty Printing***'
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you want the expressions we’ve been working with to look a bit nicer when
    you print them, you can use the `pprint()` function. This function will print
    the expression in a way that more closely resembles how we’d normally write it
    on paper. For example, here’s an expression:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If we print it as we’ve been doing so far or use the `print()` function, this
    is how it looks:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, let’s use the `pprint()` function to print the preceding expression:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The expression now looks much cleaner—for example, instead of having a bunch
    of ugly asterisks, exponents appear above the rest of the numbers.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also change the order of the terms when you print an expression. Consider
    the expression 1 + 2*x* + 2*x*²:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The terms are arranged in the order of powers of *x*, from highest to lowest.
    If you want the expression in the opposite order, with the highest power of *x*
    last, you can make that happen with the `init_printing()` function, as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `init_printing()` function is first imported and called with the keyword
    argument `order='rev-lex'`. This indicates that we want SymPy to print the expressions
    so that they’re in *reverse lexicographical order*. In this case, the keyword
    argument tells Python to print the lower-power terms first.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '*Although we used the* `init_printing()` *function here to set the printed
    order of the expressions, this function can be used in many other ways to configure
    how an expression is printed. For more options and to learn more about printing
    in SymPy, see the documentation at* [http://docs.sympy.org/latest/tutorial/printing.html](http://docs.sympy.org/latest/tutorial/printing.html).'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Let’s apply what we’ve learned so far to implement a series printing program.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '**Printing a Series**'
  id: totrans-63
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Consider the following series:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '![image](images/e0099-01.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
- en: Let’s write a program that will ask a user to input a number, *n*, and print
    this series for that number. In the series, *x* is a symbol and *n* is an integer
    input by the program’s user. The *n*th term in this series is given by
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '![image](images/e0099-02.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
- en: 'We can print this series using the following program:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `print_series()` function accepts an integer, `n`, as a parameter that is
    the number of terms in the series that will be printed. Note that we convert the
    input to an integer using the `int()` function when calling the function at ➍.
    We then call the `init_printing()` function to set the series to print in reverse
    lexicographical order.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`print_series()` 函数接受一个整数 `n` 作为参数，这是将要打印的级数的项数。请注意，我们在调用该函数时，在 ➍ 处使用 `int()`
    函数将输入转换为整数。然后，我们调用 `init_printing()` 函数，将级数设置为按反向字典顺序打印。'
- en: 'At ➊, we create the label, `series`, and set its initial value as `x`. Then,
    we define a `for` loop that will iterate over the integers from 2 to `n` at ➋.
    Each time the loop iterates, it adds each term to `series` at ➌, as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊，我们创建标签 `series`，并将其初始值设置为 `x`。然后，在 ➋，我们定义一个 `for` 循环，循环遍历从 2 到 `n` 的整数。每次循环迭代时，都会将每一项加到
    `series` 中，具体如下：
- en: '[PRE21]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The value of `series` starts off as just plain `x`, but with each iteration,
    `x**i/i` gets added to the value of `series` until the series we want is completed.
    You can see SymPy addition put to good use here. Finally, the `pprint()` function
    is used to print the series.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`series` 的值开始时只是单纯的 `x`，但随着每次迭代，`x**i/i` 会被添加到 `series` 的值中，直到完成我们想要的级数。你可以看到SymPy加法在这里得到了很好的应用。最后，使用
    `pprint()` 函数打印出级数。'
- en: 'When you run the program, it asks you to input a number and then prints the
    series up to that term:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行程序时，它会提示你输入一个数字，然后打印出直到该项的级数：
- en: '[PRE22]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Try this out with a different number of terms every time. Next, we’ll see how
    to calculate the sum of this series for a certain value of *x*.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 每次尝试使用不同数量的项。接下来，我们将看到如何计算在特定值的*x*下，这个级数的和。
- en: '***Substituting in Values***'
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***替代数值***'
- en: 'Let’s see how we can use SymPy to plug values into an algebraic expression.
    This will let us calculate the value of the expression for certain values of the
    variables. Consider the mathematical expression *x*² + 2*xy* + *y*², which can
    be defined as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用SymPy将数值代入代数表达式中。这将使我们能够计算在特定变量值下的表达式值。考虑以下数学表达式 *x*² + 2*xy* + *y*²，它可以定义如下：
- en: '[PRE23]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If you want to evaluate this expression, you can substitute numbers in for
    the symbols using the `subs()` method:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要计算这个表达式，你可以使用 `subs()` 方法将数字替代符号：
- en: '[PRE24]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'First, we create a new label to refer to the expression at ➊, and then we call
    the `subs()` method. The argument to the `subs()` method is a Python *dictionary*,
    which contains the two symbol labels and the numerical values we want to substitute
    in for each symbol. Let’s check out the result:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个新的标签来引用 ➊ 处的表达式，然后调用 `subs()` 方法。`subs()` 方法的参数是一个Python *字典*，其中包含两个符号标签和我们想要替代每个符号的数值。让我们来看看结果：
- en: '[PRE25]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You can also express one symbol in terms of another and substitute accordingly,
    using the `subs()` method. For example, if you knew that *x* = 1 – *y*, here’s
    how you could evaluate the preceding expression:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以将一个符号表示为另一个符号，并根据需要进行替代，使用 `subs()` 方法。例如，如果你知道 *x* = 1 – *y*，你可以通过以下方式计算前面的表达式：
- en: '[PRE26]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '**PYTHON DICTIONARIES**'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**PYTHON 字典**'
- en: 'A dictionary is another type of data structure in Python (lists and tuples
    are other examples of data structures, which you’ve seen earlier). Dictionaries
    contain key-value pairs inside curly braces, where each key is matched up with
    a value, separated by a colon. In the preceding code listing, we entered the dictionary
    `{x:1, y:2}` as an argument to the `subs()` method. This dictionary has two key-value
    pairs—`x:1` and `y:2`, where `x` and `y` are the keys and `1` and `2` are the
    corresponding values. You can retrieve a value from a dictionary by entering its
    associated key in brackets, much as we would retrieve an element from a list using
    its index. For example, here we create a simple dictionary and then retrieve the
    value corresponding to `key1`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 字典是Python中的另一种数据结构（列表和元组是其他数据结构的例子，你之前见过）。字典包含键值对，放在大括号内，其中每个键与一个值匹配，并通过冒号分隔。在前面的代码示例中，我们将字典
    `{x:1, y:2}` 作为参数传递给 `subs()` 方法。这个字典包含两个键值对——`x:1` 和 `y:2`，其中 `x` 和 `y` 是键，`1`
    和 `2` 是相应的值。你可以通过在方括号中输入关联的键来从字典中检索一个值，就像我们通过索引从列表中检索元素一样。例如，在这里我们创建了一个简单的字典，然后检索与
    `key1` 相关联的值：
- en: '[PRE27]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: To learn more about dictionaries, see [Appendix B](app02.html#app02).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于字典的内容，请参见 [附录B](app02.html#app02)。
- en: 'If you want the result to be simplified further—for example, if there are terms
    that cancel each other out, we can use SymPy’s `simplify()` function, as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望进一步简化结果——例如，如果有些项可以互相抵消，我们可以使用 SymPy 的 `simplify()` 函数，方法如下：
- en: '[PRE28]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: At ➊, we create a new label, `expr_subs`, to refer to the result of substituting
    *x* = 1 – *y* in the expression. We then import the `simplify()` function from
    SymPy and call it at ➋. The result turns out to be 1 because the other terms of
    the expression cancel each other.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们创建了一个新标签 `expr_subs`，用来表示将 *x* = 1 – *y* 代入表达式后的结果。然后我们从 SymPy 导入 `simplify()`
    函数，并在 ➋ 处调用它。结果是 1，因为表达式中的其他项相互抵消了。
- en: Although there was a simplified version of the expression in the preceding example,
    you had to ask SymPy to simplify it using the `simplify()` function. Once again,
    this is because SymPy won’t do any simplification without being asked to.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在前面的示例中有一个简化版本的表达式，但你必须通过 `simplify()` 函数来请求 SymPy 对其进行简化。再一次，这是因为 SymPy 不会自动简化任何表达式，除非明确要求。
- en: The `simplify()` function can also simplify complicated expressions, such as
    those including logarithms and trigonometric functions, but we won’t get into
    that here.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`simplify()` 函数还可以简化复杂的表达式，例如包括对数和三角函数的表达式，但我们这里不会深入讨论。'
- en: '**Calculating the Value of a Series**'
  id: totrans-95
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**计算级数的值**'
- en: 'Let’s revisit the series-printing program. In addition to printing the series,
    we want our program to be able to find the value of the series for a particular
    value of *x*. That is, our program will now take two inputs from the user—the
    number of terms in the series and the value of *x* for which the value of the
    series will be calculated. Then, the program will output both the series and the
    sum. The following program extends the series printing program to include these
    enhancements:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新审视一下级数打印程序。除了打印级数之外，我们希望程序能够计算给定 *x* 值时，级数的和。也就是说，我们的程序现在将从用户那里接收两个输入——级数项数和要计算级数值的
    *x* 值。然后，程序将输出级数和级数的和。以下程序扩展了级数打印程序，加入了这些功能：
- en: '[PRE29]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `print_series()` function now takes an additional argument, `x_value`, which
    is the value of `x` for which the series should be evaluated. At ➊, we use the
    `subs()` method to perform the evaluation and the label `series_value` to refer
    to the result. In the next line, we display the result.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`print_series()` 函数现在需要一个额外的参数 `x_value`，它是我们用于计算级数的 *x* 值。在 ➊ 处，我们使用 `subs()`
    方法来执行评估，并用标签 `series_value` 来表示结果。在接下来的代码行中，我们显示该结果。'
- en: The additional input statement at ➋ asks the user to enter the value of `x`
    using the label `x_value` to refer to it. Before we call the `print_series()`
    function, we convert this value into its floating point equivalent using the `float()`
    function.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➋ 处新增的输入语句要求用户输入 `x` 的值，使用 `x_value` 标签来引用它。在调用 `print_series()` 函数之前，我们使用
    `float()` 函数将该值转换为浮动点数。
- en: 'If you execute the program now, it will ask you for the two inputs and print
    out the series and the series value:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在运行程序，它将要求你输入这两个参数，并打印出级数和级数值：
- en: '[PRE30]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In this sample run, we ask for five terms in the series, with `x` set to 1.2,
    and the program prints and evaluates the series.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例运行中，我们请求输入五项级数，其中 `x` 设置为 1.2，程序会打印并计算该级数。
- en: '***Converting Strings to Mathematical Expressions***'
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***将字符串转换为数学表达式***'
- en: 'So far, we’ve been writing out individual expressions each time we want to
    do something with them. However, what if you wanted to write a more general program
    that could manipulate any expression provided by the user? For that, we need a
    way to convert a user’s input, which is a string, into something we can perform
    mathematical operations on. SymPy’s `sympify()` function helps us do exactly that.
    The function is so called because it converts the string into a SymPy object that
    makes it possible to apply SymPy’s functions to the input. Let’s see an example:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们每次想要处理一个表达式时，都需要手动写出单独的表达式。但是，如果你想编写一个更通用的程序，能够处理用户提供的任何表达式呢？为此，我们需要一种方法，将用户输入的字符串转换为我们可以进行数学运算的形式。SymPy
    的 `sympify()` 函数正是用来完成这个任务的。之所以称为“sympify”，是因为它将字符串转换为一个 SymPy 对象，这样就可以对输入应用 SymPy
    的函数了。让我们看一个例子：
- en: '[PRE31]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We first import the `sympify()` function at ➊. We then use the `input()` function
    to ask for a mathematical expression as input, using the label `expr` to refer
    to it. Next, we call the `sympify()` function with `expr` as its argument at ➋
    and use the same label to refer to the converted expression.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在 ➊ 导入 `sympify()` 函数。然后，我们使用 `input()` 函数请求输入一个数学表达式，并使用标签 `expr` 来引用它。接下来，在
    ➋ 我们调用 `sympify()` 函数，并将 `expr` 作为参数传入，使用相同的标签引用转换后的表达式。
- en: 'You can perform various operations on this expression. For example, let’s try
    multiplying the expression by 2:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以对这个表达式执行各种操作。例如，让我们尝试将表达式乘以 2：
- en: '[PRE32]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'What happens when the user supplies an invalid expression? Let’s see:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户提供无效的表达式时会发生什么呢？我们来看一下：
- en: '[PRE33]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The last line tells us that `sympify()` isn’t able to convert the supplied
    input expression. Because this user didn’t add an operator between `2` and `x`,
    SymPy doesn’t understand what it means. Your program should expect such invalid
    input and print an error message if it comes up. Let’s see how we can do that
    by catching the `SympifyError` exception:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行告诉我们 `sympify()` 无法转换提供的输入表达式。由于这个用户没有在 `2` 和 `x` 之间加上运算符，SymPy 不明白它的意思。你的程序应该预期到这种无效输入，并在出现时打印错误信息。我们来看一下如何通过捕获
    `SympifyError` 异常来实现：
- en: '[PRE34]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The two changes in the preceding program are that we import the `SympifyError`
    exception class from the `sympy.core.sympify` module and call the `sympify()`
    function in a `try...except` block. Now if there’s a `SympifyError` exception,
    an error message is printed.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 前面程序的两个改动是，我们从 `sympy.core.sympify` 模块导入了 `SympifyError` 异常类，并在 `try...except`
    块中调用了 `sympify()` 函数。现在，如果出现 `SympifyError` 异常，就会打印错误信息。
- en: '**Expression Multiplier**'
  id: totrans-114
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**表达式乘法器**'
- en: 'Let’s apply the `sympify()` function to write a program that calculates the
    product of two expressions:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们应用 `sympify()` 函数编写一个程序来计算两个表达式的乘积：
- en: '[PRE35]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: At ➊ and ➋, we ask the user to enter the two expressions. Then, we convert them
    into a form understood by SymPy using the `sympify()` function in a `try...except`
    block. If the conversion succeeds (indicated by the `else` block), we call the
    `product()` function at ➌. In this function, we calculate the product of the two
    expressions and print it. Note how we use the `expand()` function to print the
    product so that all its terms are expressed as a sum of its constituent terms.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 和 ➋，我们要求用户输入两个表达式。然后，我们使用 `sympify()` 函数将其转换为 SymPy 可以理解的形式，并放在 `try...except`
    块中。如果转换成功（由 `else` 块指示），我们在 ➌ 调用 `product()` 函数。在这个函数中，我们计算两个表达式的乘积并打印出来。请注意，我们如何使用
    `expand()` 函数打印乘积，使得所有的项都作为其组成项的和来表示。
- en: 'Here’s a sample execution of the program:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是程序的示例执行：
- en: '[PRE36]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The last line displays the product of the two expressions. The input can also
    have more than one symbol in any of the expressions:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行显示了两个表达式的乘积。输入中也可以包含多个符号在任意一个表达式中：
- en: '[PRE37]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '**Solving Equations**'
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**求解方程**'
- en: 'SymPy’s `solve()` function can be used to find solutions to equations. When
    you input an expression with a symbol representing a variable, such as *x*, `solve()`
    calculates the value of that symbol. This function always makes its calculation
    by assuming the expression you enter is equal to zero—that is, it prints the value
    that, when substituted for the symbol, makes the entire expression equal zero.
    Let’s start with the simple equation *x* – 5 = 7\. If we want to use `solve()`
    to find the value of `x`, we first have to make one side of the equation equal
    zero (*x* – 5 – 7 = 0). Then, we’re ready to use `solve()`, as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy 的 `solve()` 函数可以用来求解方程。当你输入一个包含表示变量的符号（如 *x*）的表达式时，`solve()` 会计算该符号的值。此函数总是通过假设你输入的表达式等于零来进行计算——也就是说，它会输出当该符号被代入时，使整个表达式等于零的值。让我们从简单的方程
    *x* – 5 = 7 开始。如果我们想使用 `solve()` 来求解 `x` 的值，我们首先需要将方程的一边变为零（*x* – 5 – 7 = 0）。然后，我们就可以使用
    `solve()` 了，如下所示：
- en: '[PRE38]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: When we use `solve()`, it calculates the value of `'x'` as 12 because that’s
    the value that makes the expression (*x* – 5 – 7) equal to zero.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `solve()` 时，它计算出 `'x'` 的值为 12，因为这是使得表达式 (*x* – 5 – 7) 等于零的值。
- en: Note that the result 12 is returned in a list. An equation can have multiple
    solutions—for example, a quadratic equation has two solutions. In that case, the
    list will have all the solutions as its members. You can also ask the `solve()`
    function to return the result so that each member is dictionary instead. Each
    dictionary is composed of the symbol (variable name) and its value (the solution).
    This is especially useful when solving simultaneous equations where we have more
    than one variable to solve for because when the solution is returned as a dictionary,
    we know which solution corresponds to which variable.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，结果12以列表的形式返回。一个方程可以有多个解——例如，一个二次方程有两个解。在这种情况下，列表会包含所有解作为其成员。你还可以要求`solve()`函数返回结果，每个成员作为字典。每个字典由符号（变量名）及其值（解）组成。当求解联立方程时，这种方式特别有用，因为我们有多个变量需要求解，返回字典格式的解能够帮助我们知道每个解对应哪个变量。
- en: '***Solving Quadratic Equations***'
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***求解二次方程***'
- en: 'In [Chapter 1](ch01.html#ch01), we found the roots of the quadratic equation
    *ax*² + *bx* + *c* = 0 by writing the formulas for the two roots and then substituting
    the values of the constants *a*, *b*, and *c*. Now, we’ll learn how we can use
    SymPy’s `solve()` function to find the roots without needing to write out the
    formulas. Let’s see an example:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html#ch01)中，我们通过写出二次方程*ax*² + *bx* + *c* = 0的两根公式，并代入常数*a*、*b*和*c*的值来求解方程的根。现在，我们将学习如何使用SymPy的`solve()`函数来求解根，而无需写出公式。让我们看一个例子：
- en: '[PRE39]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `solve()` function is first imported at ➊. We then define a symbol, `x`,
    and an expression corresponding to the quadratic equation, `x**2 + 5*x + 4`, at
    ➋. Then, we call the `solve()` function with the preceding expression at ➌. The
    second argument to the `solve()` function (`dict=True`) specifies that we want
    the result to be returned as a list of Python dictionaries.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`solve()`函数首先在➊处被导入。然后，我们在➋处定义一个符号`x`，并编写与二次方程`x**2 + 5*x + 4`相对应的表达式。接着，在➌处调用`solve()`函数来解这个方程。传递给`solve()`函数的第二个参数（`dict=True`）指定我们希望结果以Python字典的列表形式返回。'
- en: Each solution in the returned list is a dictionary using the symbol as a key
    matched with its corresponding value. If the solution is empty, an empty list
    will be returned. The roots of the preceding equation are –4 and –1, as you can
    see at ➍.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 返回列表中的每个解都是一个字典，字典使用符号作为键，并与其对应的值匹配。如果解为空，将返回一个空列表。前面方程的根是-4和-1，如你在➍处看到的那样。
- en: We found out in the first chapter that the roots of the equation
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第一章中发现，方程的根是
- en: '*x*² + *x* + 1 = 0'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*x*² + *x* + 1 = 0'
- en: 'are complex numbers. Let’s attempt to find those using `solve()`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是复数。我们来尝试使用`solve()`求解它们：
- en: '[PRE40]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Both the roots are imaginary, as expected with the imaginary component indicated
    by the `I` symbol.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个根都是虚数，正如预期的那样，虚部由`I`符号表示。
- en: '***Solving for One Variable in Terms of Others***'
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***求解一个变量并表示为其他变量的函数***'
- en: 'In addition to finding the roots of equations, we can take advantage of symbolic
    math to use the `solve()` function to express one variable in an equation in terms
    of the others. Let’s take a look at finding the roots for the generic quadratic
    equation *ax*² + *bx* + *c* = 0\. To do so, we’ll define *x* and three additional
    symbols—*a*, *b*, and *c*, which correspond to the three constants:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 除了求解方程的根，我们还可以利用符号计算，使用`solve()`函数将方程中一个变量用其他变量表示。让我们来看一个求解通用二次方程*ax*² + *bx*
    + *c* = 0的例子。为此，我们将定义*x*和三个额外的符号——*a*、*b*和*c*，它们分别对应三个常数：
- en: '[PRE41]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Next, we write the expression corresponding to the equation and use the `solve()`
    function on it:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们编写与方程对应的表达式，并对其使用`solve()`函数：
- en: '[PRE42]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Here, we have to include an additional argument, `x`, to the `solve()` function.
    Because there’s more than one symbol in the equation, we need to tell `solve()`
    which symbol it should solve for, which is what we indicate by passing in `x`
    as the second argument. As we’d expect, `solve()` prints the quadratic formula:
    the generic formula for finding the value(s) of *x* in a polynomial expression.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们必须为`solve()`函数添加一个额外的参数`x`。因为方程中有多个符号，我们需要告诉`solve()`应解哪个符号，这就是为什么我们将`x`作为第二个参数传递给它。正如我们所预期的，`solve()`打印出了二次公式：用于求解多项式表达式中*x*值的通用公式。
- en: To be clear, when we use `solve()` on an equation with more than one symbol,
    we specify the symbol to solve for as the second argument (and now the third argument
    specifies how we want the results to be returned).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了明确，当我们对包含多个符号的方程使用`solve()`时，我们将要求解的符号作为第二个参数指定（而现在，第三个参数指定我们希望如何返回结果）。
- en: Next, let’s consider an example from physics. According to one of the equations
    of motion, the distance traveled by a body moving with a constant acceleration
    *a*, with an initial velocity *u*, in time *t*, is given by
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们考虑一个物理学中的例子。根据运动方程之一，物体在初速度*u*和恒定加速度*a*下，在时间*t*内所走的距离*s*可以表示为：
- en: '![image](images/e0107-01.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/e0107-01.jpg)'
- en: 'Given *u* and *a*, however, if you wanted to find the time required to travel
    a given distance, *s*, you’d have to first express *t* in terms of the other variables.
    Here’s how you could do that using SymPy’s `solve()` function:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，给定*u*和*a*，如果你想找出在给定距离*s*下所需的时间*t*，你必须首先将*t*表示为其他变量的函数。下面是如何使用SymPy的`solve()`函数来做到这一点：
- en: '[PRE43]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The result looks like this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下所示：
- en: '![image](images/f0107-01.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f0107-01.jpg)'
- en: Now that we have the expression for *t* (referred to by the label `t_expr`),
    we can use the `subs()` method to replace the values of *s*, *u*, and *a* to find
    the two possible values of *t*.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了*t*的表达式（由标签`t_expr`表示），可以使用`subs()`方法替换*s*、*u*和*a*的值，从而找到*t*的两个可能值。
- en: '***Solving a System of Linear Equations***'
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***求解线性方程组***'
- en: 'Consider the following two equations:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下两个方程：
- en: 2*x* + 3*y* = 6
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 2*x* + 3*y* = 6
- en: 3*x* + 2*y* = 12
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 3*x* + 2*y* = 12
- en: Say we want to find the pair of values (*x*, *y*) that satisfies both the equations.
    We can use the `solve()` function to find the solution for a system of equations
    like this one.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想找到满足这两个方程的值对(*x*, *y*)。我们可以使用`solve()`函数来求解像这样的方程组。
- en: 'First, we define the two symbols and create the two equations:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义这两个符号并创建这两个方程：
- en: '[PRE44]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The two equations are defined by the expressions `expr1` and `expr2`, respectively.
    Note how we’ve rearranged the expressions so they both equal zero (we moved the
    right side of the given equations to the left side). To find the solution, we
    call the `solve()` function with the two expressions forming a tuple:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个方程分别由`expr1`和`expr2`表示。注意我们是如何重新排列表达式，使它们都等于零（我们将给定方程的右边移到了左边）。为了找到解，我们调用`solve()`函数，并将这两个表达式组成一个元组：
- en: '[PRE45]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'As I mentioned earlier, getting the solution back as a dictionary is useful
    here. We can see that the value of `x` is 24/5 and the value of `y` is –6/5\.
    Let’s verify whether the solution we got really satisfies the equations. To do
    so, we’ll first create a label, `soln`, to refer to the solution we got and then
    use the `subs()` method to substitute the corresponding values of `x` and `y`
    in the two expressions:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，得到一个字典形式的解在这里是非常有用的。我们可以看到`x`的值是24/5，`y`的值是–6/5。让我们验证一下我们得到的解是否真的满足这些方程。为此，我们首先创建一个标签`soln`来表示我们得到的解，然后使用`subs()`方法将`x`和`y`的对应值代入两个表达式中：
- en: '[PRE46]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The result of substituting the values of `x` and `y` corresponding to the solution
    in the two expressions is zero.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 将`x`和`y`的值代入两个表达式中得到的结果是零。
- en: '**Plotting Using SymPy**'
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用SymPy绘图**'
- en: 'In [Chapter 2](ch02.html#ch02), we learned to make graphs where we explicitly
    specified the numbers we wanted to plot. For example, to plot the graph of the
    gravitational force against the distance between two bodies, you had to calculate
    the gravitational force for each distance value and supply the lists of distances
    and forces to matplotlib. With SymPy, on the other hand, you can just tell SymPy
    the equation of the line you want to plot, and the graph will be created for you.
    Let’s plot a line whose equation is given by *y* = 2*x* + 3:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第二章](ch02.html#ch02)中，我们学会了绘制图形，其中我们明确指定了要绘制的数字。例如，要绘制重力与两个物体之间距离的关系图，你需要为每个距离值计算重力，并将距离和重力的列表提供给matplotlib。而使用SymPy，你只需要告诉SymPy你想绘制的直线方程，图形就会为你创建出来。让我们绘制一个方程为*y*
    = 2*x* + 3的直线：
- en: '[PRE47]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: All we had to do was import `plot` and `Symbol` from `sympy.plotting`, create
    a symbol, `x`, and call the `plot()` function with the expression `2*x+3`. SymPy
    takes care of everything else and plots the graph of the function, as shown in
    [Figure 4-1](ch04.html#ch4fig1).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要导入`plot`和`Symbol`，创建一个符号`x`，然后调用`plot()`函数，并传入表达式`2*x+3`。SymPy会处理其余的工作，绘制出该函数的图形，如[图4-1](ch04.html#ch4fig1)所示。
- en: '![image](images/f04-01.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-1: Plot of the line* y = *2*x + *3*'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'The graph shows that a default range of *x* values was automatically chosen:
    –10 to 10\. You may notice that the graph window looks very similar to those you
    saw in [Chapters 2](ch02.html#ch02) and [3](ch03.html#ch03). That’s because SymPy
    uses matplotlib behind the scenes to draw the graphs. Also note that we didn’t
    have to call the `show()` function to show the graphs because this is done automatically
    by SymPy.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s say that you wanted to limit the values of `''x''` in the preceding
    graph to lie in the range –5 to 5 (instead of –10 to 10). You’d do that as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Here, a tuple consisting of the symbol, the lower bound, and the upper bound
    of the range—`(x, -5, 5)`—is specified as the second argument to the `plot()`
    function. Now, the graph displays only the values of *y* corresponding to the
    values of *x* between –5 and 5 (see [Figure 4-2](ch04.html#ch4fig2)).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '![image](images/f04-02.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Plot of the line* y = *2*x + *3 with the values of* x *restricted
    to the range –5 to 5*'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use other keyword arguments in the `plot()` function, such as `title`
    to enter a title or `xlabel` and `ylabel` to label the *x*-axis and the *y*-axis,
    respectively. The following `plot()` function specifies the preceding three keyword
    arguments (see the corresponding graph in [Figure 4-3](ch04.html#ch4fig3)):'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '![image](images/f04-03.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Plot of the line* y = *2*x + *3 with the range of* x *and other
    attributes specified*'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'The plot shown in [Figure 4-3](ch04.html#ch4fig3) now has a title and labels
    on the *x*-axis and the *y*-axis. You can specify a number of other keyword arguments
    to the `plot()` function to customize the behavior of the function as well as
    the graph itself. The `show` keyword argument allows us to specify whether we
    want the graph to be displayed. Passing `show=False` will cause the graph to not
    be displayed when you call the `plot()` function:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'You will see that no graph is shown. The label `p` refers to the plot that
    is created, so you can now call `p.show()` to display the graph. You can also
    save the graph as an image file using the `save()` method, as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This will save the plot to a file *line.png* in the current directory.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '***Plotting Expressions Input by the User***'
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The expression that you pass to the `plot()` function must be expressed in
    terms of *x* only. For example, earlier we plotted *y* = 2*x* + 3, which we entered
    to the plot function as simply 2*x* + 3\. If the expression were not originally
    in this form, we’d have to rewrite it. Of course, we could do this manually, outside
    the program. But what if you want to write a program that allows its users to
    graph any expression? If the user enters an expression in the form of 2*x* + 3*y*
    – 6, say, we have to first convert it. The `solve()` function will help us here.
    Let’s see an example:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: At ➊, we use the `sympify()` function to convert the input expression to a SymPy
    object. At ➋, we create a `Symbol` object to represent `'y'` so that we can tell
    SymPy which variable we want to solve the equation for. Then we solve the expression
    to find `y` in terms of `x` by specifying `y` as the second argument to the `solve()`
    function. At ➌, this returns the equation in terms of `x`, which is what we need
    for plotting.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that this final expression is stored in a list, so before we can use
    it, we’ll have to extract it from the list:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We create a label, `solutions`, to refer to the result returned by the `solve()`
    function, which is a list with only one item. Then, we extract that item at ➍.
    Now, we can call the `plot()` function to graph the expression. The next listing
    shows a full graph-drawing program:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Note that the preceding program includes a `try...except` block to check for
    invalid input, as we’ve done with `sympify()` earlier. When you run the program,
    it asks you to input an expression, and it will create the corresponding graph.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '***Plotting Multiple Functions***'
  id: totrans-193
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can enter multiple expressions when calling the SymPy `plot` function to
    plot more than one expression on the same graph. For example, the following code
    plots two lines at once (see [Figure 4-4](ch04.html#ch4fig4)):'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '![image](images/f04-04.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: Plotting two lines on the same graph*'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'This example brings out another difference between plotting in matplotlib and
    in SymPy. Here, using SymPy, both lines are the same color, whereas matplotlib
    would have automatically made the lines different colors. To set different colors
    for each line with SymPy, we’ll need to perform some extra steps, as shown in
    the following code, which also adds a legend to the graph:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: At ➊, we call the `plot()` function with the equations for the two lines but
    pass two additional keyword arguments—`legend` and `show`. By setting the legend
    argument to `True`, we add a legend to the graph, as we saw in [Chapter 2](ch02.html#ch02).
    Note, however, that the text that appears in the legend will match the expressions
    you plotted—you can’t specify any other text. We also set `show=False` because
    we want to set the color of the lines before we draw the graph. The statement
    at ➋, `p[0]`, refers to the first line, 2*x* + 3, and we set its attribute `line_color`
    to `'b'`, meaning that we want this line to be blue. Similarly, we set the color
    of the second plot to red using the string `'r'` ➌. Finally, we call the `show()`
    to display the graph (see [Figure 4-5](ch04.html#ch4fig5)).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '![image](images/f04-05.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: Plot of the two lines with each line drawn in a different color*'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: In addition to red and blue, you can plot the lines in green, cyan, magenta,
    yellow, black, and white (using the first letter of the color in each case).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '**What You Learned**'
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned the basics of symbolic math using SymPy. You learned
    about declaring symbols, constructing expressions using symbols and mathematical
    operators, solving equations, and plotting graphs. You will be learning more features
    of SymPy in later chapters.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '**Programming Challenges**'
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here are a few programming challenges that should help you further apply what
    you’ve learned. You can find sample solutions at *[http://www.nostarch.com/doingmathwithpython/](http://www.nostarch.com/doingmathwithpython/)*.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '***#1: Factor Finder***'
  id: totrans-208
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You learned about the `factor()` function, which prints the factors of an expression.
    Now that you know how your program can handle expressions input by a user, write
    a program that will ask the user to input an expression, calculate its factors,
    and print them. Your program should be able to handle invalid input by making
    use of exception handling.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '***#2: Graphical Equation Solver***'
  id: totrans-210
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Earlier, you learned how to write a program that prompts the user to input
    an expression such as 3*x* + 2*y* – 6 and create the corresponding graph. Write
    a program that asks the user for two expressions and then graphs them both, as
    follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Now, `expr1` and `expr2` will store the two expressions input by the user. You
    should convert both of these into SymPy objects using the `sympify()` step in
    a `try...except` block.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: All you need to do from here is plot these two expressions instead of one.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you’ve completed this, enhance your program to print the solution—the
    pair of *x* and *y* values that satisfies both equations. This will also be the
    spot where the two lines on the graph intersect. (Hint: Refer to how we used the
    `solve()` function earlier to find the solution of a system of two linear equations.)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '***#3: Summing a Series***'
  id: totrans-216
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We saw how to find the sum of a series in “[Printing a Series](ch04.html#ch04lev3sec01)”
    on [page 99](ch04.html#page_99). There, we manually added the terms of the series
    by looping over all the terms. Here’s a snippet from that program:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'SymPy’s `summation()` function can be directly used to find such summations.
    The following example prints the sum of the first five terms of the series we
    considered earlier:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We call the `summation()` function at ➊, with the first argument being the *n*th
    term of the series and the second argument being a tuple that states the range
    of *n*. We want the sum of the first five terms here, so the second argument is
    `(n, 1, 5)`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have the sum, you can use the `subs()` method to substitute a value
    for *x* to find the numerical value of the sum:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Your challenge is to write a program that’s capable of finding the sum of an
    arbitrary series when you supply the *n*th term of the series and the number of
    terms in it. Here’s an example of how the program would work:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: In this example, the *n*th term supplied is that of an *arithmetic progression*.
    Starting with `a` and `d` as the *common difference*, the number of terms up to
    which the sum is to be calculated is 3\. The sum turns out to be `3a + 3d`, which
    agrees with the known formula for the same.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '***#4: Solving Single-Variable Inequalities***'
  id: totrans-227
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You’ve seen how to solve an equation using SymPy’s `solve()` function. But SymPy
    is also capable of solving single-variable inequalities, such as *x* + 5 > 3 and
    sin*x* – 0.6 > 0\. That is, SymPy can solve relations besides equality, like >,
    <, and so on. For this challenge, create a function, `isolve()`, that will take
    any inequality, solve it, and then return the solution.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s learn about the SymPy functions that will help you implement this.
    The inequality-solving functions are available as three separate functions for
    polynomial, rational, and all other inequalities. We’ll need to pick the right
    function to solve various inequalities, or we’ll get an error.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: A *polynomial* is an algebraic expression consisting of a variable and coefficients
    and involving only the operations of addition, subtraction, and multiplication
    and only positive powers of the variable. An example of a polynomial inequality
    is *x*² + 4 < 0.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve a polynomial inequality, use the `solve_poly_inequality()` function:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: First, create the expression representing an inequality, –*x*² + 4 < 0, at ➊
    and refer to this expression with the label `ineq_obj`. Then, extract the left
    side of the inequality—that is, the algebraic expression –*x*² + 4—using the `lhs`
    attribute at ➋. Next, create a `Poly` object at ➌ to represent the polynomial
    we extracted at ➋. The second argument passed when creating the object is the
    symbol object that represents the variable, `x`. At ➍, extract the relational
    operator from the inequality object using the `rel` attribute. Finally, call the
    `solve_poly_inequality()` function with the polynomial object, `p`, and `rel`
    as the two arguments. The program returns the solution as a list of tuples, with
    each tuple representing a solution for the inequality as the lower limit and the
    upper limit of the range of numbers. For this inequality, the solution is all
    numbers less than –2 and all numbers greater than 2.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'A *rational expression* is an algebraic expression in which the numerator and
    denominator are both polynomials. Here’s an example of a rational inequality:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '![image](images/e0117-01.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
- en: 'For rational inequalities, use the `solve_rational_inequalities()` function:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Create an inequality object representing our example rational inequality at
    ➊ and then extract the rational expression using the `lhs` attribute. Separate
    out the numerator and the denominator into the labels `numer` and `denom` using
    the `as_numer_denom()` method at ➋, which returns a tuple with the numerator and
    denominator as the two members. Then, create two polynomial objects, `p1` and
    `p2`, representing the numerator and denominator, respectively. Retrieve the relational
    operator and call the `solve_rational_inequalities()` function, passing it the
    two polynomial objects—`p1` and `p2`—and the relational operator.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: The program returns the solution `(-oo, -2) U (1, oo)`, where `U` denotes that
    the solution is a *union* of the two *sets* of solutions consisting of all numbers
    less than –2 and all numbers greater than 1\. (We’ll learn about sets in [Chapter
    5](ch05.html#ch05).)
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, sin*x* – 0.6 > 0 is an example of an inequality that belongs to neither
    the polynomial nor rational expression categories. If you have such an inequality
    to solve, use the `solve_univariate_inequality()` function:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Create an inequality object representing the inequality `sin(x) – 0.6 > 0` and
    then call the `solve_univariate_inequality()` function with the first two arguments
    as the inequality object, `ineq_obj`, and the symbol object, `x`. The keyword
    argument `relational=False` specifies to the function that we want the solution
    to be returned as a *set*. The solution for this inequality turns out to be all
    numbers lying between the first and second members of the tuple the program returns.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '**Hints: Handy Functions**'
  id: totrans-243
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Now remember—your challenge is (1) to create a function, `isolve()`, that will
    take any inequality and (2) to choose one of the appropriate functions discussed
    in this section to solve it and return the solution. The following hints may be
    useful to implement this function.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'The `is_polynomial()` method can be used to check whether an expression is
    a polynomial or not:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The `is_rational_function()` can be used to check whether an expression is
    a rational expression:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The `sympify()` function can convert an inequality expressed as a string to
    an inequality object:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: When you run your program, it should ask the user to input an inequality expression
    and print back the solution.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
