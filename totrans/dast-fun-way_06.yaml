- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Tries and Adapting Data Structures
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Trie树与数据结构的调整
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: Binary search trees, while incredibly powerful, are only one way of using a
    tree structure to better organize data. Instead of splitting our data sets based
    on less-than or greater-than comparisons, we can optimize how the tree splits
    the data for the specific search problem at hand. In this chapter, for example,
    we tackle the problem of storing and searching strings in trees. Extending the
    binary search tree’s general branching approach to capture additional structure
    within the data enables us to search efficiently for target strings in a set of
    strings.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉搜索树虽然功能强大，但它只是使用树形结构更好地组织数据的一种方式。我们可以不再依赖“小于”或“大于”的比较，而是根据具体的搜索问题优化树的分裂方式。例如，在本章中，我们将解决在树中存储和搜索字符串的问题。通过扩展二叉搜索树的一般分支方法来捕捉数据中的额外结构，使我们能够在字符串集合中高效地搜索目标字符串。
- en: 'We begin by discussing how binary search trees can be directly applied to string
    data but have greater cost than other datatypes. Taking the sequential nature
    of strings into account, we’ll then adapt our search trees to store strings more
    efficiently. The result is a branching structure that may one day motivate the
    world’s most gloriously excessive filing cabinet: the trie (pronounced “try”).'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先讨论如何将二叉搜索树直接应用于字符串数据，但它比其他数据类型的成本更高。考虑到字符串的顺序特性，我们接着将调整我们的搜索树，以便更高效地存储字符串。最终，我们得到一种分支结构，可能有一天会激发出世界上最华丽的、过于奢华的文件柜：Trie树（发音为“try”）。
- en: Tries are data structures that branch on a *single* character of the string
    at each level. This splitting strategy greatly reduces the cost of comparisons
    at each node. Through this lens, we explore how foundational concepts of various
    algorithms and data structures can be adapted to a new type of problem.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Trie树是一种数据结构，在每一层基于字符串的*单个*字符进行分支。这种分割策略极大地减少了每个节点进行比较的成本。通过这个视角，我们探讨了各种算法和数据结构的基础概念是如何被调整以适应一种全新的问题类型。
- en: Binary Search Trees of Strings
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串的二叉搜索树
- en: When considering whether we can improve an algorithm, we should first understand
    the limitations of our current approach—otherwise, there’s no reason to build
    a more complex data structure. Therefore, before we dive into string-specific
    data structures, we’ll examine where binary search trees fall short when used
    to store strings. First, let’s see how binary search trees can be used for this
    search.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑我们是否能改进一个算法时，我们应该首先了解当前方法的局限性——否则，就没有理由构建更复杂的数据结构。因此，在深入讨论特定于字符串的数据结构之前，我们将检查二叉搜索树在存储字符串时存在的不足。首先，让我们看看二叉搜索树是如何用于这种搜索的。
- en: Strings in Trees
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 树中的字符串
- en: Binary search trees can store not just numbers but anything sortable, from shoes
    (sorted by size or smell) to zombie movies (sorted by box office revenue or scariness)
    to food items (sorted by price, spiciness, or likelihood to cause vomiting within
    the next 24 hours). Binary search trees are quite versatile that way. All we need
    is the ability to order the items.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉搜索树不仅可以存储数字，还可以存储任何可排序的事物，从鞋子（按大小或气味排序）到僵尸电影（按票房收入或恐怖程度排序），再到食物（按价格、辛辣程度或在接下来的24小时内引发呕吐的可能性排序）。从这个角度来看，二叉搜索树非常灵活。我们所需要的只是能够对这些项目进行排序的能力。
- en: To store strings in a binary search tree, we can sort elements in alphabetical
    order. For example, each node of the binary search tree in [Figure 6-1](#figure6-1)
    is a single string partitioning its subtree into strings that come before and
    after it in the dictionary. We reuse the greater than and less than notation from
    binary search trees, where X < Y indicates that string X comes before string Y
    in the alphabet.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要在二叉搜索树中存储字符串，我们可以按字母顺序对元素进行排序。例如，[图6-1](#figure6-1)中的每个二叉搜索树节点都是一个单独的字符串，它将其子树分割成字典中位于它之前和之后的字符串。我们复用了来自二叉搜索树的“大于”和“小于”符号，其中X
    < Y表示字符串X在字母表中排在字符串Y之前。
- en: '![The root node of this binary search tree is Laugh. Its left child is Feet,
    and its right child is Rock. Various subtrees are also organized alphabetically.
    ](image_fi/502604c06/f06001.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![这棵二叉搜索树的根节点是Laugh。它的左子节点是Feet，右子节点是Rock。各种子树也按照字母顺序进行组织。](image_fi/502604c06/f06001.png)'
- en: 'Figure 6-1: A binary search tree constructed with words'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-1：通过单词构建的二叉搜索树
- en: 'We search binary search trees of strings just as we did for numbers. For example,
    to find the string LIGHT in [Figure 6-1](#figure6-1), we begin at the root node.
    We then compare the target value to the node’s value, using alphabetical ordering,
    and progress down either the left or right branch:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们像对待数字一样搜索字符串的二叉搜索树。例如，为了在[图 6-1](#figure6-1)中找到字符串LIGHT，我们从根节点开始。然后，我们将目标值与节点值进行比较，使用字母顺序，并沿着左分支或右分支继续：
- en: 'LIGHT > LAUGH: We proceed down the right branch.'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: LIGHT > LAUGH：我们沿右分支继续搜索。
- en: 'LIGHT < ROCK: We proceed down the left branch.'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: LIGHT < ROCK：我们沿左分支继续搜索。
- en: 'LIGHT < MAIN: We proceed down the left branch.'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: LIGHT < MAIN：我们沿左分支继续搜索。
- en: 'LIGHT == LIGHT: We have found the target value and can terminate the search.'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: LIGHT == LIGHT：我们已经找到了目标值，可以终止搜索。
- en: In [Figure 6-2](#figure6-2), the shaded ovals indicate the 4 out of 12 nodes
    explored during the search.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 6-2](#figure6-2)中，阴影椭圆标示了搜索过程中探索的12个节点中的4个节点。
- en: '![Diagram marking the path of a search for the string LIGHT. The search moves
    down the tree from LAUGH to ROCK to MAIN to LIGHT. The nodes containing these
    strings are grayed out. ](image_fi/502604c06/f06002.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图示标记了搜索字符串LIGHT的路径。搜索从LAUGH到ROCK再到MAIN，最后到LIGHT。包含这些字符串的节点被灰色标出。](image_fi/502604c06/f06002.png)'
- en: 'Figure 6-2: The path of traversal when searching a binary search tree of strings
    for the string LIGHT'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-2：搜索字符串LIGHT时遍历二叉搜索树的路径
- en: At first glance, binary search trees seem to provide a simple, efficient mechanism
    for searching string data—no modification required. If our tree is balanced, the
    worst-case cost of the search will scale proportional to the logarithm of the
    number of entries. In [Figure 6-2](#figure6-2), we were able to limit our search
    to checking the target against only 4 out of 12 nodes.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始，二叉搜索树似乎提供了一种简单、高效的字符串数据搜索机制——无需修改。如果我们的树是平衡的，最坏情况下的搜索成本将与条目数量的对数成比例。在[图
    6-2](#figure6-2)中，我们能够将搜索限制为仅检查12个节点中的4个节点。
- en: However, we are forgetting one critical factor—the cost of each comparison.
    As we saw in Chapter 1, comparing two strings is more expensive than comparing
    a pair of numbers. In fact, in the worst case, the cost of the string comparison
    operation scales with the length of the strings themselves. Now the cost of our
    tree search depends on both the number of strings and their lengths, meaning we’ve
    added a new dimension of complexity.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们忽视了一个关键因素——每次比较的成本。正如我们在第一章中看到的，比较两个字符串比比较一对数字要更昂贵。事实上，在最坏情况下，字符串比较操作的成本与字符串的长度成正比。现在，我们的树形搜索成本不仅依赖于字符串的数量，还与它们的长度有关，这意味着我们增加了一个新的复杂度维度。
- en: 'To fix this problem and achieve even greater computational savings than provided
    by a binary search tree, we must take into account two important aspects of string
    data’s structure: the sequential ordering of strings and the limited number of
    letters or characters involved.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，并在二叉搜索树提供的基础上实现更大的计算节省，我们必须考虑字符串数据结构的两个重要方面：字符串的顺序性和涉及的字母或字符的数量有限性。
- en: The Cost of String Comparison
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串比较的成本
- en: So far, we have been ignoring two important pieces of information in our quest
    to search strings. The first is the sequential nature of string comparisons. To
    determine the alphabetical order of strings, we start at the first character in
    a string and sequentially compare characters until we find a difference. That
    one difference then determines the string’s relative order in the search tree—it
    doesn’t matter what the rest of the characters are.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在搜索字符串的过程中忽略了两个重要的信息。第一个是字符串比较的顺序性。为了确定字符串的字母顺序，我们从字符串的第一个字符开始，逐一比较字符，直到找到不同之处。这个不同之处决定了字符串在搜索树中的相对顺序——其余的字符不重要。
- en: 'In the example in [Figure 6-3](#figure6-3), ZOMBIE comes before ZOOM because
    of the characters in the third position: M comes before O. We don’t care about
    the relationship of remaining characters, BIE and M, and can ignore them.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 6-3](#figure6-3)中的例子中，ZOMBIE排在ZOOM之前，是因为在第三个位置的字符：M排在O之前。我们不关心剩余字符BIE和M之间的关系，可以忽略它们。
- en: '![A figure showing the comparison of the strings ZOOM and ZOMBIE. The first
    two characters are marked with an equal sign to show they are the same. The third
    is marked with a greater than sign to indicate that O comes after M. The final
    characters are grayed out to indicate they are ignored.](image_fi/502604c06/f06003.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![一张展示ZOOM和ZOMBIE两个字符串比较的图。前两个字符用等号标出，表示它们相同。第三个字符用大于号标出，表示O位于M之后。最后的字符则被灰色标出，表示它们被忽略。](image_fi/502604c06/f06003.png)'
- en: 'Figure 6-3: The comparison of two strings progresses character by character
    until the first nonmatching pair is found.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-3：两个字符串的比较按字符逐一进行，直到找到第一个不匹配的字符对。
- en: 'As we saw in Chapter 1, the sequential comparison required for strings in binary
    search trees is inherently more expensive than the comparison of two numbers.
    Even comparing the two relatively short strings in [Figure 6-3](#figure6-3) requires
    three separate comparisons: Z versus Z, O versus O, and O versus M. By the time
    we get to longer strings, such as our favorite movie quotes, the cost can become
    significant. The situation becomes even more dire when the strings have a high
    degree of overlap. Imagine a binary search tree that indexes our coffee collection
    by name. If we insert a few hundred coffees under the brand name “Jeremy’s Gourmet
    High Caffeine Experience,” we would need to compare quite a few characters to
    decide whether “Jeremy’s Gourmet High Caffeine Experience: Medium Roast” comes
    before or after “Jeremy’s Gourmet High Caffeine Experience: City Roast.” Our binary
    search tree algorithm pays that cost at each node.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '正如我们在第一章中所看到的，二叉搜索树中对字符串进行顺序比较的代价，本质上比比较两个数字更高。即使是比较[图6-3](#figure6-3)中那两个相对较短的字符串，也需要进行三次单独的比较：Z对Z，O对O，O对M。当我们处理更长的字符串时，比如我们最喜欢的电影台词，成本就可能变得很高。当字符串之间的重叠度较高时，情况会变得更加严峻。想象一下，一个按名称索引我们咖啡收藏的二叉搜索树。如果我们将几百种咖啡添加到品牌名为“Jeremy’s
    Gourmet High Caffeine Experience”下，我们就需要比较相当多的字符，才能判断“Jeremy’s Gourmet High Caffeine
    Experience: Medium Roast”是排在“Jeremy’s Gourmet High Caffeine Experience: City Roast”之前还是之后。我们的二叉搜索树算法在每个节点都会付出这一成本。'
- en: The second key piece of information we haven’t considered as we strive to improve
    search efficiency is that, in many languages, each position can only contain a
    small number of letters. English words use just 26 letters (ignoring capitalization).
    Even if we include numbers and other characters, the set of valid characters is
    limited in practice. This means that, at each position, we have a limited number
    of ways the string can proceed—a limited number of next steps. As we’ll see shortly,
    this insight allows us to define a partitioning function that creates multi-way
    splits over the next character in the string.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尚未考虑的第二个关键信息是，在许多语言中，每个位置只能包含少数几个字母。英文单词仅使用26个字母（忽略大小写）。即使我们包括数字和其他字符，实际有效字符的集合也是有限的。这意味着，在每个位置上，字符串的延续方式是有限的——下一步的选择有限。正如我们即将看到的，这一见解使我们能够定义一个划分函数，该函数可以根据字符串中的下一个字符进行多重分裂。
- en: We can combine these insights to build a data structure that operates similarly
    to comparing strings in the real world. The resulting data structure, a trie,
    is optimized to account for the additional structure in strings.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以结合这些见解构建一种数据结构，其操作方式类似于现实中比较字符串的方式。由此产生的数据结构是一个字典树，它经过优化，能够考虑到字符串中的附加结构。
- en: Tries
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试
- en: '*Tries* are tree-based data structures that partition strings along different
    branches based on their prefixes. Computer scientist René de la Briandais proposed
    the general approach behind tries as a method to improve file searching on computers
    with slow memory access, and Edward Fredkin, a computer scientist and physicist,
    proposed their name. Instead of partitioning the data into two sets at each node,
    we branch the tree based on the prefix so far (sequential comparisons). Further,
    we allow the tree to split into more than a measly two branches (limited number
    of characters). In fact, for English words, we can let the tree branch 26 ways
    at each node—one branch for each of the possible next letters. Each node in the
    trie thus represents a prefix so far.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典树*是一种基于树的数据结构，它根据字符串的前缀在不同的分支上进行划分。计算机科学家 René de la Briandais 提出了字典树的通用方法，用于改进计算机中内存访问速度较慢时的文件搜索，而计算机科学家兼物理学家
    Edward Fredkin 提出了它的名字。与其在每个节点将数据划分为两个集合，我们根据当前的前缀将树进行分支（顺序比较）。此外，我们允许树在每个节点上分裂成多个分支，而不仅仅是两个（有限字符数）。实际上，对于英文单词，我们可以在每个节点上让树分成26个分支——每个分支对应可能的下一个字母。因此，字典树中的每个节点都代表了到目前为止的前缀。'
- en: Like binary search trees, the trie starts at a root node, in this case representing
    the empty prefix. Each branch then defines the next character in the string. Naturally,
    this means each node can have more than two children, as shown in [Figure 6-4](#figure6-4).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于二叉搜索树，trie 也从根节点开始，在这种情况下表示空的前缀。每个分支接着定义字符串中的下一个字符。自然地，这意味着每个节点可以有超过两个子节点，如[图6-4](#figure6-4)所示。
- en: '![A trie node with branches to child node pointers for strings starting with
    A, B, C, and so forth.](image_fi/502604c06/f06004.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![一个 trie 节点，分支指向以 A、B、C 等字母开头的子节点。](image_fi/502604c06/f06004.png)'
- en: 'Figure 6-4: A trie node branches out on each possible character in the current
    position.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-4：trie 节点在当前字符位置上进行所有可能字符的分支。
- en: We can implement the branches of each trie node as using an array of pointers,
    with one array bin for each character. In some cases, we may be able to use representations
    more memory-efficient than arrays within our data structure. After all, even for
    English words, most non-trivial prefixes will have significantly fewer than 26
    valid options for the next letter. For now, however, we will stick with an array
    implementation for simplicity’s sake. The discussions and example implementations
    in this chapter also focus primarily on English words (26 letters and a 26-element
    array of children), though the algorithms apply to other character sets as well.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用指针数组来实现每个 trie 节点的分支，每个字符对应一个数组桶。在某些情况下，我们可能能够使用比数组更节省内存的表示方式。毕竟，即使是对于英语单词，大多数非平凡的前缀也会有显著少于26个有效选项来确定下一个字母。然而，出于简单性考虑，我们现在仍将使用数组实现。本章中的讨论和示例实现也主要集中在英语单词（26个字母和一个26元素的子节点数组）上，尽管这些算法同样适用于其他字符集。
- en: Think of a trie’s branching structure as the registration table of a major event.
    Upon showing up at the world’s premier conference on Coffee Analogies for Computer
    Science, we visit the registration table to get our own personalized packet of
    information and free conference goodie (hopefully a coffee mug). With a huge number
    of participants, the organizers split up the packets into manageable groups so
    as to prevent a single line from snaking around the convention center. Instead
    of creating a series of pairwise splits (such as “Does your last name come before
    or after Smith?”), the organizers divide attendees into 26 different lines according
    to the first letter of their last name. In a single step, the crush of attendees
    shrinks to 26 more manageable lines. A trie performs that spectacular many-way
    branching at every node.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 将 trie 的分支结构想象成一个大型活动的注册台。参加世界顶级的计算机科学咖啡类比大会时，我们会去注册台领取属于自己的个性化信息包和免费会议小礼品（希望是一个咖啡杯）。由于参与者众多，组织者将信息包分成可管理的小组，以防止排成一条长队绕到大会中心。在此，组织者没有采取一对一分割（比如“你的姓氏是在
    Smith 之前还是之后？”），而是根据参与者姓氏的首字母将与会者分成26条不同的队伍。通过这一步骤，拥挤的与会者数量被缩减为26个更易管理的队伍。trie
    在每个节点执行这种壮观的多路分支。
- en: As with a binary search tree, we do not need to create nodes for empty branches
    of the tree. [Figure 6-5](#figure6-5) shows an example of this structure, where
    the shaded letters represent empty branches of the trie. We do not create child
    nodes for those branches. Using the same terminology as for binary search trees,
    we call nodes with at least one child *internal nodes* and nodes without any children
    *leaf node**s*. As a result, although we have the potential to branch 26 times
    at each node (when using only English letters), our trie will be relatively sparse.
    Later nodes may only branch a small number of times.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 和二叉搜索树一样，我们不需要为树的空分支创建节点。[图6-5](#figure6-5)展示了这种结构的一个例子，其中阴影部分的字母表示 trie 的空分支。我们不会为这些分支创建子节点。使用与二叉搜索树相同的术语，我们将至少有一个子节点的节点称为*内部节点*，而没有任何子节点的节点称为*叶节点*。因此，尽管我们每个节点可能最多分支26次（当仅使用英语字母时），但我们的
    trie 会相对稀疏。后续节点可能只分支少数几次。
- en: '![The first three levels of a trie. Each node shows possible branches to children
    starting with A, B, or C. Certain characters are grayed out to indicate the absence
    of children in various branches.](image_fi/502604c06/f06005.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![trie 的前三个层级。每个节点展示了可能的分支，指向以 A、B 或 C 开头的子节点。某些字符被灰掉，表示在各个分支中缺少子节点。](image_fi/502604c06/f06005.png)'
- en: 'Figure 6-5: Tries only create nodes for non-empty branches of the tree, allowing
    the data structure to avoid wasting space on unused branches.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-5：Trie 只为非空分支创建节点，从而避免在未使用的分支上浪费空间。
- en: Unlike in binary search trees, not every node in a trie represents a valid entry.
    While every leaf node is a valid entry, some internal nodes might be prefixes
    along the route to a full string. For example, a trie containing the string COFFEE
    would include an intermediate node representing the prefix COFFE. Although this
    is the spelling the author often uses when he’s consumed too much coffee, it is
    not actually a valid word or entry. We don’t want our data structure to imply
    that COFFE is acceptable just because there is a node corresponding to that prefix.
    At other points, however, an internal node might be a completely valid entry.
    If a trie contains the strings CAT and CATALOG, the node for CAT will be internal,
    because it has at least one child that lies along the path to the node for CATALOG.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 与二叉搜索树不同，字典树中的每个节点并不都代表一个有效条目。虽然每个叶子节点都是有效条目，但一些内部节点可能只是通往完整字符串的前缀。例如，包含字符串COFFEE的字典树会有一个表示前缀COFFE的中间节点。尽管这是作者在喝了太多咖啡时经常使用的拼写方式，但它实际上并不是一个有效的单词或条目。我们不希望我们的数据结构暗示因为有一个与该前缀对应的节点，就意味着COFFE是可以接受的。然而，在其他情况下，内部节点可能是完全有效的条目。如果字典树包含字符串CAT和CATALOG，CAT的节点将是内部节点，因为它至少有一个子节点，位于通向CATALOG节点的路径上。
- en: 'To resolve this ambiguity, we store within the trie node an indicator of whether
    the current prefix represents a valid entry. This could be as simple as a Boolean
    `is_entry` that is `True` for any node corresponding to a valid entry and `False`
    otherwise:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个歧义，我们在字典树节点中存储一个指示器，表示当前前缀是否代表一个有效条目。这个指示器可以像一个简单的布尔值`is_entry`，对于任何对应有效条目的节点，其值为`True`，否则为`False`：
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this example, the node for COFFE would have `is_entry = False`, while the
    node for COFFEE would have `is_entry = True`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，COFFE的节点会有`is_entry = False`，而COFFEE的节点会有`is_entry = True`。
- en: Alternately, we could store something more useful in the trie node, such as
    the count of how many times a given entry has been inserted. Or, if we are tracking
    auxiliary data for each entry, such as a word’s definition or a list of hysterical
    puns, we could use the existence of this data as an indicator itself. Prefixes
    that do not represent valid entries can point to `null` or empty data structures.
    It may seem harsh, but only real words qualify for our best puns.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，我们可以在字典树节点中存储更有用的信息，比如记录某个条目被插入多少次。或者，如果我们正在跟踪每个条目的辅助数据，例如一个单词的定义或一系列滑稽的双关语，我们可以利用这些数据的存在本身作为一个指示器。那些不代表有效条目的前缀可以指向`null`或空的数据结构。这看起来可能有些严格，但只有真实的单词才能成为我们最佳的双关语。
- en: 'As with the binary search tree, we can clean up the trie’s interface by wrapping
    the root node in a trie object:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 与二叉搜索树一样，我们可以通过将根节点包装在字典树对象中来清理字典树的接口：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Unlike the binary search tree, our trie always has a (non-null) root. We create
    this root at the same time we create the trie data structure itself. Even for
    completely empty tries, we allocate a root node (with `is_entry = False`) that
    indicates the start of the string. Not only will the `Trie` data structure wrap
    the root node into a convenient container, but it will allow us to hide some additional
    bookkeeping needed for various operations.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 与二叉搜索树不同，我们的字典树总是有一个（非空）根节点。我们在创建字典树数据结构的同时也会创建这个根节点。即使是完全空的字典树，我们也会分配一个根节点（`is_entry
    = False`），它表示字符串的起始点。`Trie`数据结构不仅会将根节点封装成一个便捷的容器，还能让我们隐藏一些进行各种操作时所需的额外管理信息。
- en: One useful physical analogy for tries is an ultimate real-world filing system.
    Imagine a building that acts as storage system for detailed files on every topic
    in the world—a monument to efficient filing schemes. We partition the topics based
    on their first letter, like books of an encyclopedia, so our building has 26 stories.
    We reserve each floor of the building for each first letter, so the floors provide
    our first-level split. We then pack each floor with 26 rooms, one for each second
    letter of the topic. Each room would contain 26 filing cabinets that split for
    the third letter; each cabinet has 26 drawers (fourth letter), and 26 sections
    per drawer (fifth letter), and so on. At each level we are grouping together entries
    by their common prefixes. As long as we have high-speed elevators, we can find
    any topic relatively easily.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有用的物理类比是字典树的最终现实世界文件系统。假设有一栋大楼，它作为一个存储系统，存放着世界上每个话题的详细文件——这是一个高效归档系统的纪念碑。我们根据话题的第一个字母来划分这些话题，就像百科全书中的书籍一样，所以我们的楼宇有26层。我们为每个字母保留一层楼，这些楼层提供了我们的第一层划分。然后，每层楼有26个房间，每个房间代表话题的第二个字母。每个房间里有26个文件柜，按第三个字母来划分；每个文件柜有26个抽屉（第四个字母），每个抽屉有26个隔层（第五个字母），以此类推。在每一层，我们根据共同的前缀将条目分组。只要我们有高速电梯，我们就可以相对轻松地找到任何话题。
- en: Searching Tries
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查找字典树
- en: Searching tries is similar to searching binary search trees, in that we start
    at the top of the tree at the root node and progress downward, choosing branches
    that lead to the search target. In the case of a trie, however, we choose the
    branch that corresponds to the next letter in the string. We don’t need to compare
    full strings, or even the beginning of the prefix. That was done at previous nodes.
    We only need to consider the next character—a single comparison at each level.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 查找字典树与查找二叉搜索树类似，都是从树的顶部，即根节点开始，逐步向下，选择通向搜索目标的分支。然而，在字典树的情况下，我们选择与字符串中下一个字母对应的分支。我们不需要比较完整的字符串，甚至不需要比较前缀的开始部分。这些已经在之前的节点中完成了。我们只需考虑下一个字符——在每一层进行一次简单的比较。
- en: Returning to the filing building analogy, imagine searching for information
    on your favorite author. After arriving at the floor K, you face 26 rooms labeled
    A through Z that represent the prefixes KA through KZ. Your next step depends
    only on the second letter of the author’s name. You do not need to waste time
    even considering the first letter again—that was already done on the elevator.
    Every room on this floor starts with K. You confidently head toward the room labeled
    U.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 回到文件楼宇的类比，假设你正在搜索关于你最喜欢的作者的信息。到达K楼后，你面前有26个标有A到Z的房间，它们代表着前缀KA到KZ。你接下来的步骤只取决于作者名字的第二个字母。你不需要浪费时间再次考虑第一个字母——那已经在电梯里完成了。这个楼层的每个房间都以K开头。你自信地朝着标有U的房间走去。
- en: One complication with implementing this approach in code is that the comparisons
    we perform change at each level of the search. At the first level, we check the
    first character for a match—but at the second level, we need to check the second
    character. Our search no longer compares the entire target against the value at
    the node. We need additional information, the placement of the character that
    we are checking for at this level. We can track this additional state by passing
    the index to check into our recursive search function and incrementing it with
    each level of recursion.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这种方法的一个复杂之处在于我们在每一层的比较方式都会发生变化。在第一层，我们检查第一个字符是否匹配——但在第二层，我们需要检查第二个字符。我们的搜索不再将整个目标与节点的值进行比较。我们需要额外的信息，即在这一层我们正在检查的字符的位置。我们可以通过将要检查的索引传递给递归搜索函数，并在每一层递归时递增它，来跟踪这一额外的状态。
- en: 'The trie wrapper allows us to hide both the reference to the root node and
    the initial counter required by the recursive function, simplifying the code seen
    by the trie’s users:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 字典树封装器允许我们隐藏根节点的引用和递归函数所需的初始计数器，从而简化字典树用户看到的代码：
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This wrapper guarantees that subsequent search function is called with a non-null
    node and the correct initial index.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这个封装器确保后续的搜索函数在调用时传递一个非空节点和正确的初始索引。
- en: 'The code for recursively searching a trie is a bit more complex than the code
    for searching a binary search tree, because we must deal with target values of
    different lengths:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 递归查找字典树的代码比查找二叉搜索树的代码要复杂一些，因为我们必须处理不同长度的目标值：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This code starts by checking the length of the target string against the current
    depth in order to determine whether the target should be located at this level
    ❶. If the index is equal to the length of the string (and thus one *past* the
    last character in the string), the code then checks whether the current node is
    itself a valid entry. This check is particularly necessary when the search terminates
    at an internal node, since we need to confirm that this node represents a valid
    entry in its own right, not just the prefix of another entry.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码首先通过检查目标字符串的长度与当前深度进行比较，以确定目标是否应位于此层级 ❶。如果索引等于字符串的长度（即超出了字符串的最后一个字符），代码会检查当前节点是否本身是一个有效条目。当搜索在一个内部节点终止时，这一检查尤为必要，因为我们需要确认该节点是否表示一个有效条目，而不仅仅是另一个条目的前缀。
- en: If the code has not reached the end of the target string, it continues the search
    by examining the next character in our target ❷. We can define a helper function
    to map the character to the correct index in the array ❸. The code then checks
    whether the corresponding child exists ❹. If there isn’t a corresponding child,
    the code returns `null`, confident that `target` is not in the trie. If there
    is a corresponding child, the code follows that branch.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码尚未到达目标字符串的末尾，它将继续通过检查目标中的下一个字符来进行搜索 ❷。我们可以定义一个辅助函数，将字符映射到数组中的正确索引 ❸。然后，代码检查是否存在相应的子节点
    ❹。如果没有相应的子节点，代码返回 `null`，确定 `target` 不在字典树中。如果存在相应的子节点，代码则沿着该分支继续。
- en: For an example of this search procedure, consider a trie of exclamations like
    YIKES and ZOUNDS from a recent episode of our favorite Saturday morning cartoon,
    as in [Figure 6-6](#figure6-6). We can record auxiliary data such as the frequency
    of the word and who said it, allowing us to correct people’s references at parties.
    After all, what’s the use of data structures if they don’t help us win pedantic
    arguments?
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以最近一集我们最喜欢的周六早晨卡通节目中的感叹词 YIKES 和 ZOUNDS 为例，如[图 6-6](#figure6-6)所示，考虑一下这种搜索过程。我们可以记录辅助数据，例如该词的频率以及谁说的，这样我们就能在聚会中纠正他人的引用。毕竟，如果数据结构不能帮助我们在啰嗦的争论中获胜，那它们还有什么用呢？
- en: '![A trie that includes the strings EGADS, YIKES, YIP, YIPPEE, ZONK, and ZOUNDS.](image_fi/502604c06/f06006.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![一个字典树，包含字符串 EGADS、YIKES、YIP、YIPPEE、ZONK 和 ZOUNDS。](image_fi/502604c06/f06006.png)'
- en: 'Figure 6-6: A trie constructed from cartoon phrases'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-6：由卡通短语构建的字典树
- en: To check whether this week’s episode contained our all-time favorite cartoon
    word, ZONK, we can simply search the trie. We start at the top of the trie and
    take the corresponding branches for each character, as shown in [Figure 6-7](#figure6-7).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查本周的剧集是否包含我们最喜欢的卡通词汇 ZONK，我们可以直接搜索字典树。从字典树的顶部开始，按每个字符选择相应的分支，如[图 6-7](#figure6-7)所示。
- en: '![The trie from Figure 6‐6 with the following nodes highlighted: root, Z, ZO,
    ZON, and ZONK. The highlighted nodes show the path from the root to the node containing
    ZONK.](image_fi/502604c06/f06007.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图 6-6 中的字典树，突出显示以下节点：根节点、Z、ZO、ZON 和 ZONK。突出显示的节点显示了从根节点到包含 ZONK 的节点的路径。](image_fi/502604c06/f06007.png)'
- en: 'Figure 6-7: A search of the trie of cartoon phrases for ZONK. The shaded nodes
    indicate the path taken during the search.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-7：对卡通短语字典树进行 ZONK 搜索的过程。阴影节点表示搜索过程中经过的路径。
- en: Since tries include only nodes that have data, we can determine whether a string
    is not in the trie by watching for dead ends. For example, we know ZIPPY did not
    occur in the episode because we hit a dead end after the prefix Z. There is no
    branch for the prefix ZI. If some know-it-all proclaims that their favorite line
    contained the exclamation ZIPPY, we can prove them wrong with a simple search.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 由于字典树仅包含有数据的节点，我们可以通过观察死胡同来确定某个字符串是否不在字典树中。例如，我们知道 ZIPPY 并没有出现在剧集中，因为我们在前缀 Z
    后遇到了死胡同。前缀 ZI 没有分支。如果某个自以为是的专家声称他们最喜欢的台词中包含感叹词 ZIPPY，我们可以通过简单的搜索证明他们是错的。
- en: At first glance, it may appear that adding a large number of internal nodes
    increases the cost of searching. However, this new structure actually improves
    our search enormously. At each character in our target string, we perform a single
    lookup in the current node, checking for an existing child for that character,
    then proceed to the appropriate child node; thus, the number of lookups and comparisons
    scales with the length of our target string. Unlike a binary search tree, the
    number of comparisons for a successful trie search is independent of the number
    of strings stored in the trie. We could fill the trie with an entire dictionary
    and still only need to visit six nodes to check for the string EGADS.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，似乎添加大量的内部节点增加了搜索的成本。然而，这种新结构实际上大大提高了搜索效率。在我们目标字符串的每个字符处，我们只需在当前节点进行一次查找，检查该字符是否有现有的子节点，然后继续访问合适的子节点；因此，查找和比较的次数与目标字符串的长度成正比。与二叉搜索树不同，成功的trie搜索比较次数与trie中存储的字符串数量无关。即使我们将整个词典填充进trie，我们仍然只需要访问六个节点来检查字符串EGADS。
- en: Of course, as with everything in computer science, this efficiency does not
    come for free. We pay a significant cost in memory usage. Instead of storing one
    node for each string and pointers to two children, we now store one node for each
    character in the string and a large number of pointers to potential children.
    Overlapping prefixes help reduce the memory cost per string. If multiple entries
    share the same prefix, such as ZO for ZOUNDS and ZONK in [Figure 6-6](#figure6-6),
    those entries share nodes for those initial overlapping characters.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，和计算机科学中的一切一样，这种效率并非无代价。我们在内存使用上付出了显著的代价。我们不再为每个字符串存储一个节点和指向两个子节点的指针，而是为字符串中的每个字符存储一个节点，并存储大量指向潜在子节点的指针。重叠的前缀有助于减少每个字符串的内存开销。如果多个条目共享相同的前缀，例如在[图6-6](#figure6-6)中，ZOUNDS和ZONK共享前缀ZO，那么这些条目会共享这些初始重叠字符的节点。
- en: Adding and Removing Nodes
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加和删除节点
- en: Like binary search trees, tries are dynamic data structures that adapt as we
    add or remove nodes, allowing them to accurately represent the data as it changes.
    Adding a string to a trie works much like adding data to a binary search tree.
    We progress down the tree as though searching for the string. Once we hit a dead
    end, we can create a subtree below that node to capture the remaining characters
    in that string. Unlike insertions in binary search trees, we may add multiple
    new internal nodes while inserting a single entry.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 像二叉搜索树一样，trie是动态数据结构，随着节点的添加或删除会自动调整，能够准确表示数据的变化。向trie中添加字符串的过程与向二叉搜索树添加数据类似。我们沿着树向下遍历，就像是在搜索字符串一样。一旦遇到死胡同，我们就可以在该节点下创建一个子树来存储该字符串剩余的字符。与二叉搜索树的插入不同，在插入单个条目时，我们可能会添加多个新的内部节点。
- en: 'The top-level `Trie` function sets up the insertion by calling the recursive
    search function with the (non-null) root node and the correct initial depth:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 顶层的`Trie`函数通过调用递归搜索函数，并传入（非空的）根节点和正确的初始深度来设置插入操作：
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We don’t need to treat the creation of the root node as a special case, as we
    allocate an initial root node during the creation of the trie itself.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要将根节点的创建视为特殊情况，因为在创建trie时，我们会分配一个初始的根节点。
- en: 'The code for insertion is similar to that of the search function:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 插入的代码与搜索函数类似：
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This code starts by checking the current position against the length of the
    inserted string ❶. When it has hit the end of the string, it marks the current
    node as a valid entry. Depending on the use case, the code might also need to
    update the node’s auxiliary data. Where the code has not yet hit the end of the
    string, it looks up the next character and checks whether the corresponding child
    exists ❷. If not, the code creates a new child node. Then it recursively proceeds
    to call `TrieNodeInsert` on the correct child node (❸ or ❹).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码首先通过检查当前的位置与插入字符串的长度进行比较❶。当到达字符串末尾时，它会将当前节点标记为有效条目。根据使用场景，代码可能还需要更新节点的辅助数据。若代码还未到达字符串末尾，它会查找下一个字符并检查是否存在相应的子节点❷。如果不存在，代码会创建一个新的子节点。然后，它会递归调用`TrieNodeInsert`来处理正确的子节点（❸或❹）。
- en: 'For example, if we wanted to add the string EEK to our list of cartoon exclamations,
    we would add two nodes: an internal node for the prefix EE and a leaf node for
    the full string EEK. [Figure 6-8](#figure6-8) illustrates this addition, with
    shaded nodes indicating the trie nodes created during the insertion.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想将字符串 EEK 添加到我们的卡通感叹词列表中，我们将添加两个节点：一个用于前缀 EE 的内部节点和一个用于完整字符串 EEK 的叶节点。[图
    6-8](#figure6-8) 演示了这个添加过程，带阴影的节点表示在插入过程中创建的 trie 节点。
- en: 'Removing nodes follows a similar process, but in reverse: starting at the node
    for the final character, we progress up the tree, deleting nodes that we no longer
    need. We stop deleting nodes once we hit an internal node that either has at least
    one non-empty child branch, thus representing a valid prefix for other strings
    in the trie, or is itself a string stored in the tree and thus represents a valid
    leaf node in its own right.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 删除节点遵循类似的过程，但顺序相反：从最后一个字符的节点开始，我们向上遍历树，删除不再需要的节点。我们停止删除节点，一旦遇到一个内部节点，该节点要么至少有一个非空子分支，从而表示
    trie 中其他字符串的有效前缀，要么本身就是树中存储的字符串，表示一个有效的叶节点。
- en: 'As with search and insertion, we start with the wrapper code that starts the
    deletion at the root node and with the correct index:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 与搜索和插入类似，我们从包装器代码开始，在根节点处启动删除操作，并使用正确的索引：
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The function does not return a value.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数不返回任何值。
- en: The code for removing nodes builds on the code for search and insertion, initially
    walking down the tree until it reaches the entry to delete. As it returns back
    up the trie, additional logic prunes empty branches. The code returns a Boolean
    value indicating whether or not the current node can safely be deleted, allowing
    the parent node to prune the branch.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 删除节点的代码基于搜索和插入的代码，最初会沿着树向下遍历，直到找到要删除的条目。当它返回到 trie 时，附加的逻辑会修剪空的分支。代码返回一个布尔值，指示当前节点是否可以安全删除，从而允许父节点修剪该分支。
- en: '![The trie from Figure 6‐6 with nodes added to store the strings EE and EEK.
    The additional nodes are in a branch below the node for the prefix E.](image_fi/502604c06/f06008.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图 6-6 中的 trie，已添加节点来存储字符串 EE 和 EEK。新增节点位于 E 前缀节点下的分支中。](image_fi/502604c06/f06008.png)'
- en: 'Figure 6-8: The addition of EEK to the trie of cartoon phrases. The new nodes
    are shaded.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-8：将 EEK 添加到卡通短语的 trie 中。新增的节点已加阴影。
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This code starts by comparing the length of the deleted string to the current
    level and changing the value of `is_entry` if the current node is being removed
    ❶. Otherwise, the algorithm recursively progresses down the tree, using the same
    logic as both our search and insertion functions ❷. It looks up the next character,
    finds the corresponding node, checks whether the node exists, and, if so, recursively
    descends to that node. If the node doesn’t exist, the target string is not in
    the trie, and the code will not continue downward. The code then deletes empty
    branches from the parent node. Each `TrieNodeDelete` call returns a Boolean to
    indicate whether it is safe to delete the corresponding node. If `TrieNodeDelete`
    returns `True`, then the parent immediately deletes the child node ❸.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码首先通过比较删除字符串的长度与当前层级，若当前节点正在被删除，则更改 `is_entry` 的值 ❶。否则，算法会递归地沿树向下遍历，使用与我们搜索和插入函数相同的逻辑
    ❷。它查找下一个字符，找到相应的节点，检查节点是否存在，如果存在，则递归下降到该节点。如果节点不存在，则目标字符串不在 trie 中，代码将停止向下继续。然后，代码从父节点删除空的分支。每次调用
    `TrieNodeDelete` 都会返回一个布尔值，指示是否可以安全删除对应的节点。如果 `TrieNodeDelete` 返回 `True`，则父节点会立即删除该子节点
    ❸。
- en: The function ends with logic to determine whether it is safe for the parent
    to delete the current node. It returns `False` if `is_entry == True` ❹, indicating
    a valid entry, or if the current node has at least one non-null child ❺. It performs
    this last check using a `FOR` loop to iterate through each child and check whether
    it is `null`. If any child is not `null`, the code immediately returns `False`
    because it is a necessary internal node. Note that the code returns `False` in
    cases where the target string is not in the trie, because the code never sets
    `is_entry` to `False` for any node and thus there are no new pruning opportunities.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的最后通过逻辑判断父节点是否可以删除当前节点。如果`is_entry == True` ❹，即表示是有效条目，或者当前节点至少有一个非空子节点 ❺，则返回`False`。它通过一个`FOR`循环来遍历每个子节点并检查其是否为`null`。如果有任何子节点不是`null`，代码会立即返回`False`，因为它是一个必要的内部节点。请注意，代码会在目标字符串不在
    trie 中时返回`False`，因为代码从未将`is_entry`设置为`False`，因此不会出现新的修剪机会。
- en: Consider removing the string YIPPEE from our example trie. If the trie also
    contains the word YIP as an entry, we’d delete all nodes following the one for
    YIP as shown in [Figure 6-9](#figure6-9). The node for YIPPEE itself is marked
    safe to delete because it is a leaf and `is_entry` was marked `False` as part
    of the deletion. When the function returns to the node for YIPPE, it immediately
    deletes its only child (branch E). The node for YIPPE is now a leaf with `is_entry
    == False` and can be deleted by its parent. The process continues up the tree
    until we hit the node for YIP, which has `is_entry == True`, because the string
    YIP is in the trie.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑从我们的示例字典树中删除字符串YIPPEE。如果字典树中也包含单词YIP作为条目，我们将删除从YIP开始的所有后续节点，如[图6-9](#figure6-9)所示。YIPPEE节点本身被标记为安全删除，因为它是一个叶节点，并且`is_entry`已被标记为`False`，作为删除过程的一部分。当函数返回到YIPPE节点时，它立即删除其唯一子节点（分支E）。此时，YIPPE节点变成一个叶节点，`is_entry
    == False`，可以由其父节点删除。该过程会继续向上遍历树，直到我们到达YIP节点，它的`is_entry == True`，因为字符串YIP存在于字典树中。
- en: Since deletion requires making a round trip from the root to a single leaf,
    the cost is again proportional to the length of the target string. As with search
    and insertion, cost is independent of the overall numbers of strings stored in
    the trie.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 由于删除操作需要从根节点到单个叶节点的往返，成本再次与目标字符串的长度成正比。与搜索和插入操作一样，删除操作的成本与字典树中存储的字符串总数无关。
- en: '![The Trie from Figure 6‐8 with the nodes YIPP, YIPPE, and YIPPEE marked with
    grayed‐out, dashed lines to indicate their deletion.](image_fi/502604c06/f06009.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图6-8中的字典树，标有YIPP、YIPPE和YIPPEE节点，用虚线和灰色标出，表示它们已被删除。](image_fi/502604c06/f06009.png)'
- en: 'Figure 6-9: Deletion of the string YIPPEE from the trie of cartoon phrases
    that also contains the string YIP. The deleted nodes have dashed lines and are
    grayed out.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-9：从包含字符串YIP的卡通短语的字典树中删除字符串YIPPEE。被删除的节点用虚线标出，并且灰色显示。
- en: Why This Matters
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么这很重要
- en: 'We can now see how tries solve the problem with binary search trees that we
    posed earlier on: the cost of their search depends on both the number and length
    of words. In the brief examples in this chapter, tries do not provide much of
    an advantage. In fact, the overhead from additional branches may make them less
    efficient than binary search trees or sorted lists. However, tries become more
    and more cost-effective as we add more and more strings and the number of strings
    with similar prefixes increases. There are two reasons for this: first, the cost
    of a lookup in a trie scales independent of the number of entries, and second,
    string comparisons themselves can be expensive. In a binary search tree, these
    two factors compound, as we pay the cost of comparing two strings at each of the
    nodes.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以看到字典树如何解决我们之前提出的二叉搜索树问题：它们的搜索成本既取决于单词的数量，也取决于单词的长度。在本章的简短示例中，字典树并没有提供太大的优势。实际上，额外的分支开销可能使它们比二叉搜索树或排序列表效率更低。然而，当我们添加越来越多的字符串，并且具有相似前缀的字符串数量增加时，字典树变得越来越具有成本效益。这有两个原因：首先，字典树中的查找成本与条目的数量无关；其次，字符串比较本身可能很昂贵。在二叉搜索树中，这两个因素相互叠加，因为我们在每个节点都需要比较两个字符串，从而增加了成本。
- en: In the real world, for example, we might use a trie inside a word processor
    to track the words in a dictionary. Auxiliary data at each node might include
    the definition or common misspellings. As the user types and edits, the program
    can efficiently check whether each word is in the dictionary and highlight it
    if otherwise. This program greatly benefits from the shared prefixes and limited
    number of characters in a natural language.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，例如，我们可能会在文字处理器中使用字典树来跟踪字典中的单词。每个节点的辅助数据可能包括定义或常见拼写错误。当用户输入和编辑时，程序可以高效地检查每个单词是否在字典中，如果不在，则高亮显示。该程序极大地受益于自然语言中共享的前缀和有限的字符数量。
- en: If we are composing an in-depth essay on the history of encyclopedias, for example,
    we do not want to pay excessive cost comparing *encyclopedia* to the neighboring
    words *encyclopedias*, *encyclopedic*, *encyclopedist*, and so forth. Remember
    that, as shown in [Figure 6-10](#figure6-10), the algorithm to compare the alphabetical
    ordering of two strings consists of iterating over those strings, comparing each
    character. Although the program stops once it finds a differing character, the
    cost of comparing similar prefixes adds up. Within an active word processor document,
    we might need to modify the set of words constantly. Each insertion or edit will
    require a lookup in our data structure.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们正在撰写一篇关于百科全书历史的深入文章，我们不希望在比较*encyclopedia*与相邻的单词*encyclopedias*、*encyclopedic*、*encyclopedist*时付出过高的成本。记住，正如[图6-10](#figure6-10)所示，比较两个字符串的字母顺序的算法是通过遍历字符串，逐个比较字符。尽管程序一旦找到不同的字符就会停止，但比较相似前缀的成本是累积的。在一个活跃的文字处理文档中，我们可能需要不断修改词汇集。每次插入或编辑都需要在我们的数据结构中进行查找。
- en: '![A string comparison between the words encyclopedic and encyclopedias. The
    first 11 characters are marked as equal.](image_fi/502604c06/f06010.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![比较单词“encyclopedic”和“encyclopedias”的字符串。前11个字符被标记为相同。](image_fi/502604c06/f06010.png)'
- en: 'Figure 6-10: An example of an expensive string comparison'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-10：一个昂贵的字符串比较示例
- en: An even better use for a trie might be a data structure that tracks structured
    labels—such as serial numbers, model numbers, or SKU codes—that are often formatted
    as short alphanumeric strings. For example, we could create a simple trie to store
    product registration information indexed by serial number. Even allowing for billions
    of products sold, the cost of all operations scales linearly with the length of
    the serial number. If our serial numbers contain structure, such as a prefix representing
    the device’s model, we can realize further savings by limiting the branching factor
    at initial nodes (since many strings will use the same prefix). Auxiliary data
    could include information about where or when the device was purchased.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的应用场景可能是用来跟踪结构化标签的数据结构——例如序列号、型号或SKU码——这些通常格式化为简短的字母数字字符串。例如，我们可以创建一个简单的Trie来存储按序列号索引的产品注册信息。即使销售了数十亿个产品，所有操作的成本也与序列号的长度成线性关系。如果我们的序列号包含结构，比如表示设备型号的前缀，我们可以通过限制初始节点的分支因子来进一步节省开销（因为许多字符串会使用相同的前缀）。辅助数据可能包括设备购买的时间或地点信息。
- en: 'More importantly than any particular application, tries demonstrate how we
    can use further structure within the data to optimize the cost of operations.
    We adapted the branching structure of binary search trees to use the sequential
    nature of strings. This improvement once again illustrates a core theme of this
    book: we can often use the structure inherent in data to improve algorithmic efficiency.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 比任何具体应用更重要的是，Trie展示了如何在数据中使用更多结构来优化操作成本。我们将二叉搜索树的分支结构改编为使用字符串的顺序特性。这一改进再次体现了本书的一个核心主题：我们可以通过利用数据中固有的结构来提高算法效率。
