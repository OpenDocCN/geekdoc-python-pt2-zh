<html><head></head><body>
<h2 class="h2" id="ch11"><span epub:type="pagebreak" id="page_287"/><span class="big">11</span><br/>ANIMATIONS, SIMULATIONS, AND THE TIME LOOP</h2>&#13;
<div class="image1"><img src="../images/common01.jpg" alt="Image"/></div>&#13;
<p class="noindent">The same way vector images visualize static problems, animations help us build visual intuition for dynamic problems. A single image can show us only how things are at a specific point in time. When the properties of a system change over time, we’ll need an animation to get the complete story.</p>&#13;
<p class="indent">Much like a static analysis presents a system in a moment, a <em>simulation</em> presents the evolution of a system over time. Animations are a good way of presenting the results of this evolution. There are two good reasons for engineers to simulate dynamic systems: it’s a great exercise to solidify your understanding of these systems, and it’s quite fun.</p>&#13;
<p class="indent">In this chapter, we’ll start exploring the engaging world of animations, starting with a few definitions. We’ll then learn how to make drawings move across the canvas. We’ll use Tkinter’s canvas and, more importantly, our <span class="literal">CanvasDrawing</span> wrapper class.</p>&#13;
<h3 class="h3" id="ch00lev1sec65"><span epub:type="pagebreak" id="page_288"/><strong>Defining Terms</strong></h3>&#13;
<p class="noindent">Let’s define a few of the terms we’ll be using in this section.</p>&#13;
<h4 class="h4" id="ch00lev2sec125"><strong><em>What Is an Animation?</em></strong></h4>&#13;
<p class="noindent">An <em>animation</em> is the sensation of motion generated by a rapid succession of images. Because the computer draws these images to the screen extremely quickly, our eyes perceive motion.</p>&#13;
<p class="indent">We’ll make animations by drawing something to the canvas, clearing it, and then drawing something else. Each drawing, which remains on the screen for a fraction of a second, is called a <em>frame</em>.</p>&#13;
<p class="indent">Take, for example, <a href="ch11.xhtml#ch11fig1">Figure 11-1</a>, which depicts each frame of an animation: a triangle moving right.</p>&#13;
<div class="image"><img src="../images/11fig01.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch11fig1"><em>Figure 11-1: The animation frames of a triangle</em></p>&#13;
<p class="indent">Each of the four frames in the animation has the triangle in a slightly different position. If we draw them on the canvas, one after the other, clearing the previous drawing, the triangle will appear to move.</p>&#13;
<p class="indent">Simple, isn’t it? We’ll build our first animation in this chapter soon, but first let’s define the terms <em>system</em> and <em>simulation</em>, as they’ll appear frequently in our discussion.</p>&#13;
<h4 class="h4" id="ch00lev2sec126"><strong><em>What Is a System?</em></strong></h4>&#13;
<p class="noindent">The word <em>system</em>, in our context, refers to whatever we’re drawing to the canvas in an animation. It consists of a group of objects subject to some physical laws and interacting with one another. We’ll use these laws to derive a mathematical model, often in the form of a system of differential equations. We’ll resolve these equations using numerical methods, which yield the values that describe the system at discrete points in time. These values might be the system’s position or velocity.</p>&#13;
<p class="indent">Now let’s take a look at an example of a system and derive its equation. Let’s suppose we have a body with mass <em>m</em> subject to an external force that is a function of time, <img class="inline" src="../images/ftvictorit.jpg" alt="Image"/>. <a href="ch11.xhtml#ch11fig2">Figure 11-2</a> depicts a <em>free body diagram</em>. There, you can see the external force and its weight force applied, where <img class="inline" src="../images/gvictorit.jpg" alt="Image"/> is gravity’s acceleration vector.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_289"/><img class="inline" src="../images/11fig02.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch11fig2"><em>Figure 11-2: A mass subject to external force</em></p>&#13;
<p class="indent">Using Newton’s second law and denoting the position vector of the body by <img class="inline" src="../images/pvictorit.jpg" alt="Image"/>, we get the following:</p>&#13;
<div class="equationc"><img src="../images/f0289-01.jpg" alt="Image"/></div>&#13;
<p class="noindent">Solving for the acceleration <img class="inline" src="../images/pcapvictorit.jpg" alt="Image"/>,</p>&#13;
<div class="equationc"><img src="../images/f0289-02.jpg" alt="Image"/></div>&#13;
<p class="indent">The previous vector equation can be broken down into its two scalar components:</p>&#13;
<div class="equationc"><img src="../images/f0289-03.jpg" alt="Image"/></div>&#13;
<p class="indent">These two equations express the acceleration of the body function of time. To simulate this simple system, we’d need to obtain a new value for the acceleration, velocity, and position of the body for each frame of the animation. We’ll see what this means in a minute.</p>&#13;
<h4 class="h4" id="ch00lev2sec127"><strong><em>What Is a Simulation?</em></strong></h4>&#13;
<p class="noindent">A <em>simulation</em> is the study of the evolution of a system whose behavior is mathematically described. Simulations harness the computation power of modern central processing units (CPUs) to understand how a given system would behave under real conditions.</p>&#13;
<p class="indent">Computer simulations are in general cheaper and simpler to set up than real-world experiments, so they’re used to study and predict the behavior of many engineering designs.</p>&#13;
<p class="indent">Take the system whose equations we derived in the previous section. Given an expression of the external force with respect to time like</p>&#13;
<div class="equationc"><img src="../images/f0289-04.jpg" alt="Image"/></div>&#13;
<p class="noindent">and the mass for the body is said to be <em>m</em> = 5kg, the acceleration equations become the following.<span epub:type="pagebreak" id="page_290"/></p>&#13;
<div class="equationc"><img src="../images/f0290-01.jpg" alt="Image"/></div>&#13;
<p class="indent">These scalar equations give us the acceleration components for the body at every moment in time. Since the equations are simple, we can integrate them to obtain the expression of the velocity components,</p>&#13;
<div class="equationc"><img src="../images/f0290-02.jpg" alt="Image"/></div>&#13;
<p class="noindent">where <em>Ẋ</em><sub>0</sub> and <em>Ẏ</em><sub>0</sub> are the components of the initial velocity: the velocity at time <em>t</em> = 0. We know the velocity of the mass for every moment in time. If we want to animate the movement of the mass, we need an expression for the position, which we can obtain by integrating the velocity equations,</p>&#13;
<div class="equationc"><img src="../images/f0290-03.jpg" alt="Image"/></div>&#13;
<p class="noindent">where <em>X</em><sub>0</sub> and <em>Y</em><sub>0</sub> are the initial position components for the mass. We can now create an animation to understand how the body moves under the effect of the external force by simply creating a sequence of time values, obtaining the position for each of them, and then drawing a rectangle to the screen at that position.</p>&#13;
<p class="indent">The <em>differential equations</em> relating how the acceleration of the system varies with respect to time for this example were straightforward, which allowed us to obtain an analytic solution using integration. We usually don’t get an analytic solution for the system under simulation, so we tend to resort to numerical methods.</p>&#13;
<p class="indent">The <em>analytic solution</em> is the exact solution, whereas a <em>numerical solution</em> is obtained using computer algorithms that look for an approximation of the solution. A common numerical method, although not the most precise, is <em>Euler’s method</em>.</p>&#13;
<p class="indent">Drawing the simulation in real time means we need to solve the equations as often as we draw frames. For example, if we want to simulate at a rate of 50 frames per second (fps), then we need to both draw the frames and solve the equations 50 times per second.</p>&#13;
<p class="indent">At 50 fps, the time between frames is 20 milliseconds. Taking into account the fact that your computer requires some of those milliseconds to redraw the screen with the current frame, we’re left with little time for the math.</p>&#13;
<p class="indent">Simulations can also be computed ahead of time and later played back. This way solving the equations can take as long as required; the animation takes place only when all frames are ready.</p>&#13;
<p class="indent">Video game engines use real-time simulations as they need to simulate the world around the player as they interact with it, something that can’t be determined ahead of time. These engines tend to trade accuracy for speed; their results are not physically accurate but look realistic to the naked eye.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_291"/>Complex engineering systems require an ahead-of-time simulation since the governing equations for these problems are complex and require a much more exact solution.</p>&#13;
<h3 class="h3" id="ch00lev1sec66"><strong>What Is the Time Loop?</strong></h3>&#13;
<p class="noindent">Real-time simulations happen inside a loop, which we’ll refer to as the <em>time loop</em> or <em>main loop</em>. This loop executes as many times per second as frames are drawn to the screen. Here’s some pseudocode showing what a time loop might look like:</p>&#13;
<pre>while current_time &lt; end_time:&#13;
    solve_system_equations()&#13;
    draw_system()&#13;
    sleep(time_delta - time_taken)&#13;
    current_time += time_delta</pre>&#13;
<p class="indent">To make the animations look smooth, we want a steady frame rate. This means the drawing phase of the simulation should take place at evenly spaced points in time. (While not strictly necessary, there are techniques to adapt the frame rate to the processor and GPU’s throughput, but we won’t be getting that advanced in this book.)</p>&#13;
<p class="indent">The time elapsed between consecutive frames is referred to as the <em>time delta</em>, or <em>δt</em>; it’s inversely proportional to the frame rate (fps) and typically measured in seconds or milliseconds: <img class="inline" src="../images/f00291-p1.jpg" alt="Image"/>. As a consequence, everything happening in our time loop should take less than a single time delta to complete.</p>&#13;
<p class="indent">The first step in the loop is solving the equations to figure out how the system has evolved during the elapsed time delta. Then, we draw the system’s new configuration to the screen. We need to measure the time taken so far in the loop and store the result in the <span class="literal">time_taken</span> variable.</p>&#13;
<p class="indent">At this point, the program is paused or put to sleep until an entire time delta has elapsed. The time we sleep can be figured out by subtracting <span class="literal">time</span> <span class="literal">_taken</span> from <span class="literal">time_delta</span>. The last step before ending the loop is to advance the current time by a time delta; the loop then starts over again. <a href="ch11.xhtml#ch11fig3">Figure 11-3</a> shows the time line with the events in the time loop drawn.</p>&#13;
<div class="image"><img src="../images/11fig03.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch11fig3"><em>Figure 11-3: The time loop events</em></p>&#13;
<p class="indent">Now that we have those definitions out of the way, let’s implement a time loop and start animating.</p>&#13;
<h3 class="h3" id="ch00lev1sec67"><strong>Our First Animation</strong></h3>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_292"/>At the beginning of the chapter, we explained how we can achieve the sensation of motion by drawing something many times per second. The time loop is in charge of keeping these drawings at a steady rate. Let’s implement our first time loop.</p>&#13;
<h4 class="h4" id="ch00lev2sec128"><strong><em>Setup</em></strong></h4>&#13;
<p class="noindent">We’ll start by creating a new file where we can experiment. In the <em>simulation</em> package, create a new file and name it <em>hello_motion.py</em>. Enter the code in <a href="ch11.xhtml#ch11lis1">Listing 11-1</a>.</p>&#13;
<pre>  import time&#13;
  from tkinter import Tk, Canvas&#13;
&#13;
  tk = Tk()&#13;
  tk.title("Hello Motion")&#13;
&#13;
  canvas = Canvas(tk, width=600, height=600)&#13;
  canvas.grid(row=0, column=0)&#13;
&#13;
  frame_rate_s = 1.0 / 30.0&#13;
  frame_count = 1&#13;
  max_frames = 100&#13;
&#13;
&#13;
  def update_system():&#13;
      pass&#13;
&#13;
&#13;
  def redraw():&#13;
      pass&#13;
&#13;
&#13;
<span class="ent">➊</span> while frame_count &lt;= max_frames:&#13;
       update_start = time.time()&#13;
<span class="ent">➋</span> update_system()&#13;
    <span class="ent">➌</span> redraw()&#13;
    <span class="ent">➍</span> tk.update()&#13;
       update_end = time.time()&#13;
&#13;
    <span class="ent">➎</span> elapsed_s = update_end - update_start&#13;
       remaining_time_s = frame_rate_s - elapsed_s&#13;
&#13;
       if remaining_time_s &gt; 0:&#13;
        <span class="ent">➏</span> time.sleep(remaining_time_s)&#13;
      <span epub:type="pagebreak" id="page_293"/>frame_count += 1&#13;
&#13;
  tk.mainloop()</pre>&#13;
<p class="caption"><a id="ch11lis1"/><em>Listing 11-1: The hello_motion.py file</em></p>&#13;
<p class="indent">In the code in <a href="ch11.xhtml#ch11lis1">Listing 11-1</a>, we start by creating a 600 × 600–pixel canvas and adding it to the grid of the main window. Then we initialize some variables: <span class="literal">frame_rate_s</span> holds the time between two consecutive frames, in seconds; <span class="literal">frame_count</span> is the count of how many frames have already been drawn; and <span class="literal">max_frames</span> is the number of total frames we’ll draw.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Note that the variables storing time-related quantities include information in their name about the unit they use. The</em> <span class="literal">s</span> <em>in</em> <span class="literal">frame_rate_s</span> <em>or</em> <span class="literal">elapsed_s</span> <em>indicates seconds. It’s good practice to do this, as it helps the developer understand what units the code is working with without needing to read comments or pick through all the code. When you spend many hours a day coding, these small details end up saving you a lot of time and frustration.</em></p>&#13;
</div>&#13;
<p class="indent">Then comes the time loop <span class="ent">➊</span>, which executes <span class="literal">max_frames</span> times at a rate of <span class="literal">frame_rate_s</span>, at least in principle (as you’ll see in a minute). Note that we chose to limit the simulation using a maximum number of frames, but we could also limit it by time, that is, keep running the loop until a given amount of time has elapsed, just like we did in the pseudocode shown earlier. Both approaches work fine.</p>&#13;
<p class="indent">In the loop we start by storing the current time in <span class="literal">update_start</span>. After the updates to the system and the drawing have taken place, we store the time again, this time in <span class="literal">update_end</span>. The time elapsed is then computed by subtracting <span class="literal">update_start</span> from <span class="literal">update_end</span> and stored in <span class="literal">elapsed_s</span> <span class="ent">➎</span>. We use this quantity to calculate how long the loop needs to sleep to keep the frame rate steady, subtracting <span class="literal">elapsed_s</span> from <span class="literal">frame_rate_s</span>. That amount is stored in <span class="literal">remaining_time_s</span>, and if it’s greater than zero, we sleep the loop <span class="ent">➏</span>.</p>&#13;
<p class="indent">If <span class="literal">remaining_time_s</span> is less than zero, the loop took longer than the frame rate, meaning it can’t keep up with the rhythm we imposed on it. If this happens often, the time loop will become unsteady, and animations may look chunky, in which case it’s better to simply reduce the frame rate.</p>&#13;
<p class="indent">The magic happens (or will happen, to be more precise) in <span class="literal">update</span> <span class="literal">_system</span> <span class="ent">➋</span> and <span class="literal">redraw</span> <span class="ent">➌</span>, which we call in the loop to update and redraw the system. Here’s where we’ll soon be writing our drawing code. The <span class="literal">pass</span> statement is used in Python as a placeholder: it doesn’t do anything, but it allows us to have, for example, a valid function body.</p>&#13;
<p class="indent">There’s also a call to <span class="literal">update</span> from main window <span class="literal">tk</span> <span class="ent">➍</span>, which tells Tkinter to run the main loop until all pending events have been processed. This is necessary to force Tkinter to look for the events that may trigger changes in the user interface widgets, including our canvas.</p>&#13;
<p class="indent">You can run the file now; you’ll see an empty window apparently doing nothing, but it’s actually running the loop <span class="literal">max_frames</span> times.</p>&#13;
<h4 class="h4" id="ch00lev2sec129"><span epub:type="pagebreak" id="page_294"/><strong><em>Adding a Frame Count Label</em></strong></h4>&#13;
<p class="noindent">Let’s add a label under the canvas to let us know the current frame being drawn to the canvas and the total number of frames. We can update its value in <span class="literal">update</span>. First, add <span class="literal">Label</span> to the <span class="literal">tkinter</span> imports:</p>&#13;
<pre>from tkinter import Tk, Canvas, StringVar, <span class="codestrong1">Label</span></pre>&#13;
<p class="noindent">Then, under the definition of the <span class="literal">canvas</span>, add the <span class="literal">label</span> (<a href="ch11.xhtml#ch11lis2">Listing 11-2</a>).</p>&#13;
<pre>label = StringVar()&#13;
label.set('Frame ? of ?')&#13;
Label(tk, textvariable=label).grid(row=1, column=0)</pre>&#13;
<p class="caption"><a id="ch11lis2"/><em>Listing 11-2: Adding a <span class="codeitalic1">label</span> to the window</em></p>&#13;
<p class="noindent">Finally, update the label’s text in <span class="literal">update</span> by setting the value of its text variable, <span class="literal">label</span> (<a href="ch11.xhtml#ch11lis3">Listing 11-3</a>).</p>&#13;
<pre>def update():&#13;
    label.set(f'Frame {frame_count} of {max_frames}')</pre>&#13;
<p class="caption"><a id="ch11lis3"/><em>Listing 11-3: Updating the label’s text</em></p>&#13;
<p class="indent">Try to run the file now. The canvas is still blank, but the label below it now displays the current frame. Your program should look like <a href="ch11.xhtml#ch11fig4">Figure 11-4</a>: a blank window with a frame count going from 1 to 100.</p>&#13;
<div class="image"><img src="../images/11fig04.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch11fig4"><em>Figure 11-4: The frame count label</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_295"/>Just for reference, your code at this stage should look like <a href="ch11.xhtml#ch11lis4">Listing 11-4</a>.</p>&#13;
<pre>import time&#13;
from tkinter import Tk, Canvas, StringVar, Label&#13;
&#13;
tk = Tk()&#13;
tk.title("Hello Motion")&#13;
&#13;
canvas = Canvas(tk, width=600, height=600)&#13;
canvas.grid(row=0, column=0)&#13;
&#13;
label = StringVar()&#13;
label.set('Frame ? of ?')&#13;
Label(tk, textvariable=label).grid(row=1, column=0)&#13;
&#13;
frame_rate_s = 1.0 / 30.0&#13;
frame_count = 1&#13;
max_frames = 100&#13;
&#13;
&#13;
def update_system():&#13;
    pass&#13;
&#13;
&#13;
def redraw():&#13;
    label.set(f'Frame {frame_count} of {max_frames}')&#13;
&#13;
&#13;
while frame_count &lt;= max_frames:&#13;
    update_start = time.time()&#13;
    update_system()&#13;
    redraw()&#13;
    tk.update()&#13;
    update_end = time.time()&#13;
&#13;
    elapsed_s = update_end - update_start&#13;
    remaining_time_s = frame_rate_s - elapsed_s&#13;
&#13;
    if remaining_time_s &gt; 0:&#13;
        time.sleep(remaining_time_s)&#13;
&#13;
    frame_count += 1&#13;
&#13;
tk.mainloop()</pre>&#13;
<p class="caption"><a id="ch11lis4"/><em>Listing 11-4: Hello canvas with label</em></p>&#13;
<p class="indent">To have anything drawn on the canvas, we need to have a system. Let’s first take a look at how to add and update a system to our simulation.</p>&#13;
<h4 class="h4" id="ch00lev2sec130"><span epub:type="pagebreak" id="page_296"/><strong><em>Updating the System</em></strong></h4>&#13;
<p class="noindent">For this example, we’ll keep it simple and draw a circle whose center is always at the center of the canvas, point (300, 300). Its radius will grow, starting with a value of zero. When the radius grows larger than the canvas and is no longer visible, we’ll set it back to zero. This will generate a psychedelic tunnel-like effect.</p>&#13;
<p class="indent">We can represent our “system” with an instance of our <span class="literal">Circle</span> class. Since we’ll be drawing the circle to the canvas, let’s also create an instance of <span class="literal">Canvas</span> <span class="literal">Drawing</span>, using an identity affine transformation. Under the definition of variables <span class="literal">frame_rate_s</span>, <span class="literal">frame_count</span>, and <span class="literal">max_frames</span>, add the following:</p>&#13;
<pre>transform = AffineTransform(sx=1, sy=1, tx=0, ty=0, shx=0, shy=0)&#13;
drawing = CanvasDrawing(canvas, transform)&#13;
circle = Circle(Point(300, 300), 0)</pre>&#13;
<p class="noindent">Don’t forget to include the needed imports:</p>&#13;
<pre>from geom2d import Point, Circle, AffineTransform&#13;
from graphic.simulation.draw import CanvasDrawing</pre>&#13;
<p class="indent">We need to update the value of the radius every frame in <span class="literal">update_system</span> so that when <span class="literal">redraw</span> does its thing, the circle gets drawn with the updated value for the radius. In <span class="literal">update_system</span>, enter the code in <a href="ch11.xhtml#ch11lis5">Listing 11-5</a>.</p>&#13;
<pre>def update_system():&#13;
    circle.radius = (circle.radius + 15) % 450&#13;
    tk.update()</pre>&#13;
<p class="caption"><a id="ch11lis5"/><em>Listing 11-5: Updating the circle’s radius</em></p>&#13;
<p class="indent">The value for the radius is updated by adding 15 to the current value. Using the modulo operator (<span class="literal">%</span>), whenever the radius becomes greater than 450, the value wraps around and goes back to zero.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Quick reminder: the modulo operator</em> <span class="literal">%</span> <em>returns the remainder of dividing its two operands. For instance,</em> <span class="literal">5</span> <span class="literal">%</span> <span class="literal">3</span> <em>yields</em> <span class="literal">2</span>.</p>&#13;
</div>&#13;
<p class="indent">You’ve probably realized that we mutated the circle’s radius property instead of creating a new circle with the value for the new radius; it’s the first time in the book we mutate the properties of our geometric primitives. The reason is that, for simulations, maintaining the throughput of the loop is crucial, and creating a new instance of the system for each frame would have a high performance impact.</p>&#13;
<p class="indent">We now have the system defined in each of the frames: a circle whose center point is kept centered in the window while the radius gradually increases in size. Let’s draw it to the screen!</p>&#13;
<h4 class="h4" id="ch00lev2sec131"><span epub:type="pagebreak" id="page_297"/><strong><em>Creating Motion</em></strong></h4>&#13;
<p class="noindent">To create the effect of motion, the canvas has to be cleared and the system redrawn in each and every frame. Before <span class="literal">redraw</span> is invoked in the main loop, <span class="literal">update_system</span> has already updated the circle. In <span class="literal">redraw</span>, we simply need to clear whatever is drawn on the canvas and draw the circle again. Update <span class="literal">redraw</span> using the code in <a href="ch11.xhtml#ch11lis6">Listing 11-6</a>.</p>&#13;
<pre>def redraw():&#13;
    label.set(f'Frame {frame_count} of {max_frames}')&#13;
    drawing.clear_drawing()&#13;
    drawing.draw_circle(circle, 50)</pre>&#13;
<p class="caption"><a id="ch11lis6"/><em>Listing 11-6: Redrawing the circle every frame</em></p>&#13;
<p class="indent">You’ve probably been waiting for this grand moment for the whole chapter, so go ahead and execute the file. You should see a circle growing in size until it disappears from the screen and then starting over again.</p>&#13;
<p class="indent">Just for your reference, at this point, your <em>hello_motion.py</em> code should look like <a href="ch11.xhtml#ch11lis7">Listing 11-7</a>.</p>&#13;
<pre>import time&#13;
from tkinter import Tk, Canvas, StringVar, Label&#13;
&#13;
from geom2d import Point, AffineTransform, Circle&#13;
from graphic.simulation import CanvasDrawing&#13;
&#13;
tk = Tk()&#13;
tk.title("Hello Motion")&#13;
&#13;
canvas = Canvas(tk, width=600, height=600)&#13;
canvas.grid(row=0, column=0)&#13;
&#13;
label = StringVar()&#13;
label.set('Frame ? of ?')&#13;
Label(tk, textvariable=label).grid(row=1, column=0)&#13;
&#13;
frame_rate_s = 1.0 / 30.0&#13;
frame_count = 1&#13;
max_frames = 100&#13;
&#13;
transform = AffineTransform(sx=1, sy=1, tx=0, ty=0, shx=0, shy=0)&#13;
drawing = CanvasDrawing(canvas, transform)&#13;
circle = Circle(Point(300, 300), 0)&#13;
&#13;
&#13;
def update_system():&#13;
    circle.radius = (circle.radius + 15) % 450&#13;
    tk.update()&#13;
&#13;
&#13;
<span epub:type="pagebreak" id="page_298"/>def redraw():&#13;
    label.set(f'Frame {frame_count} of {max_frames}')&#13;
    drawing.clear_drawing()&#13;
    drawing.draw_circle(circle, 50)&#13;
&#13;
&#13;
while frame_count &lt;= max_frames:&#13;
    update_start = time.time()&#13;
    update_system()&#13;
    redraw()&#13;
    tk.update()&#13;
    update_end = time.time()&#13;
&#13;
    elapsed_s = update_end - update_start&#13;
    remaining_time_s = frame_rate_s - elapsed_s&#13;
&#13;
    if remaining_time_s &gt; 0:&#13;
        time.sleep(remaining_time_s)&#13;
&#13;
    frame_count += 1&#13;
&#13;
tk.mainloop()</pre>&#13;
<p class="caption"><a id="ch11lis7"/><em>Listing 11-7: Resulting simulation</em></p>&#13;
<p class="indent">Note that before drawing anything, the <span class="literal">redraw</span> function clears the canvas. Can you guess what would happen if we forgot to do so? Comment that line out and run the simulation.</p>&#13;
<pre>def redraw():&#13;
    label.set(f'Frame {frame_count} of {max_frames}')&#13;
    <span class="codestrong1"># drawing.clear_drawing()</span>&#13;
    drawing.draw_circle(circle, 50)</pre>&#13;
<p class="indent">All circles drawn should remain on the canvas, as you see in <a href="ch11.xhtml#ch11fig5">Figure 11-5</a>.</p>&#13;
<p class="indent">We’ve drawn our first animation on the canvas, and it looks fantastic. If we were to write another, though, we’d have to copy and paste the code for the main loop. To avoid this needless duplication, let’s move the main loop code into a function that can be easily reused.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_299"/><img src="../images/11fig05.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch11fig5"><em>Figure 11-5: What it’d look like if we forgot to clean the canvas</em></p>&#13;
<h3 class="h3" id="ch00lev1sec68"><strong>Abstracting the Main Loop Function</strong></h3>&#13;
<p class="noindent">The main loop we just wrote had a fair amount of logic that will be the same for all simulations. Copying and pasting this code over and over again would not only be bad practice, but if we found an improvement or wanted to make a change to our implementation, we’d need to edit the code of all our simulations. We don’t want to duplicate knowledge: we should define the logic for a main simulation loop in just one place.</p>&#13;
<p class="indent">To implement a generic version of the main loop, we need to do an abstraction exercise. Let’s ask ourselves the following questions regarding the implementation of the main loop: Is there something that’s never going to change in it, and is there anything simulation-specific? The <span class="literal">while</span> loop, the order of the operations inside of it, and the time calculations are the same for every simulation. Conversely, there are three pieces of logic that vary from simulation to simulation, namely, the decision that keeps the loop running, the updating, and the drawing.</p>&#13;
<p class="indent">If we encapsulate those in functions that the simulations implement, they can be passed to our main loop abstraction. The main loop we implement only needs to care about the timing, that is, trying to keep the frame rate stable.</p>&#13;
<p class="indent">Create a new file named <em>loop.py</em> in the <em>simulation</em> package. Enter the code in <a href="ch11.xhtml#ch11lis8">Listing 11-8</a>.<span epub:type="pagebreak" id="page_300"/></p>&#13;
<pre>import time&#13;
&#13;
&#13;
def main_loop(&#13;
        update_fn,&#13;
        redraw_fn,&#13;
        should_continue_fn,&#13;
        frame_rate_s=0.03&#13;
):&#13;
    frame = 1&#13;
    time_s = 0&#13;
    last_elapsed_s = frame_rate_s&#13;
&#13;
 <span class="ent">➊</span> while should_continue_fn(frame, time_s):&#13;
        update_start = time.time()&#13;
     <span class="ent">➋</span> update_fn(last_elapsed_s, time_s, frame)&#13;
     <span class="ent">➌</span> redraw_fn()&#13;
        update_end = time.time()&#13;
&#13;
        elapsed_s = update_end - update_start&#13;
        remaining_time_s = frame_rate_s - elapsed_s&#13;
&#13;
        if remaining_time_s &gt; 0:&#13;
            time.sleep(remaining_time_s)&#13;
            last_elapsed_s = frame_rate_s&#13;
        else:&#13;
            last_elapsed_s = elapsed_s&#13;
&#13;
&#13;
        frame += 1&#13;
        time_s += last_elapsed_s</pre>&#13;
<p class="caption"><a id="ch11lis8"/><em>Listing 11-8: Simulation’s main loop function</em></p>&#13;
<p class="indent">The first thing you should notice is that three of the arguments to the <span class="literal">main_loop</span> function are also functions: <span class="literal">update_fn</span>, <span class="literal">redraw_fn</span>, and <span class="literal">should_continue</span> <span class="literal">_fn</span>. These functions contain the logic that’s simulation-specific, so our main loop simply needs to call them as needed.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Passing functions as arguments to other functions was covered in <a href="ch01.xhtml#ch01">Chapter 1</a>, on <a href="ch02.xhtml#ch00lev2sec20">page 27</a>. You may want to refer to this section for a quick refresher.</em></p>&#13;
</div>&#13;
<p class="indent">The <span class="literal">main_loop</span> function starts by declaring three variables: <span class="literal">frame</span>, which holds the current frame index; <span class="literal">time_s</span>, which holds the total time elapsed; and <span class="literal">last_elapsed_s</span>, which holds the number of seconds it took the last frame to complete. The condition to keep the loop running is now delegated to the <span class="literal">should_continue_fn</span> function <span class="ent">➊</span>. The loop will continue as long as this function returns true. It accepts two arguments: the frame count and the total time elapsed in seconds. If you recall, most of our simulations will be <span epub:type="pagebreak" id="page_301"/>limited by one of these values, so we pass them to the function so that it has the information required to decide whether the loop should keep running.</p>&#13;
<p class="indent">Next, the <span class="literal">update_fn</span> function <span class="ent">➋</span> updates the system under simulation and the user interface. This function receives three parameters: the time elapsed since the last frame, <span class="literal">last_elapsed_s</span>; the total elapsed time for the simulation, <span class="literal">time_s</span>; and the current frame number, <span class="literal">frame</span>. As we’ll see later in the book, when we introduce physics to our simulations, the amount of time elapsed since the last frame is an important piece of data. Lastly comes <span class="literal">redraw_fn</span> <span class="ent">➌</span>, which draws the system to the screen.</p>&#13;
<p class="indent">Thanks to our abstraction of the simulation’s main loop, we won’t need to write this logic anymore. Let’s try to refactor our simulation from the previous section using this definition of the main loop.</p>&#13;
<h3 class="h3" id="ch00lev1sec69"><strong>Refactoring Our Simulation</strong></h3>&#13;
<p class="noindent">Now that we’ve created an abstraction of the main loop, let’s take a look at how our simulation could be refactored to include the main loop function.</p>&#13;
<p class="indent">Create a new file named <em>hello_motion_refactor.py</em> and enter the code from <a href="ch11.xhtml#ch11lis9">Listing 11-9</a>. You may want to copy and paste the first lines from <em>hello_motion.py</em>, those that define the UI. Note that to make the code a bit shorter, I’ve removed the frame count label from the UI.</p>&#13;
<pre>from tkinter import Tk, Canvas&#13;
&#13;
from geom2d import Point, Circle, AffineTransform&#13;
from graphic.simulation.draw import CanvasDrawing&#13;
from graphic.simulation.loop import main_loop&#13;
&#13;
tk = Tk()&#13;
tk.title("Hello Motion")&#13;
&#13;
canvas = Canvas(tk, width=600, height=600)&#13;
canvas.grid(row=0, column=0)&#13;
&#13;
max_frames = 100&#13;
&#13;
transform = AffineTransform(sx=1, sy=1, tx=0, ty=0, shx=0, shy=0)&#13;
drawing = CanvasDrawing(canvas, transform)&#13;
circle = Circle(Point(300, 300), 0)&#13;
&#13;
&#13;
def update_system(time_delta_s, time_s, frame):&#13;
    circle.radius = (circle.radius + 15) % 450&#13;
    tk.update()&#13;
&#13;
&#13;
def redraw():&#13;
    drawing.clear_drawing()&#13;
    <span epub:type="pagebreak" id="page_302"/>drawing.draw_circle(circle, 50)&#13;
&#13;
&#13;
def should_continue(frame, time_s):&#13;
    return frame &lt;= max_frames&#13;
&#13;
&#13;
main_loop(update_system, redraw, should_continue)&#13;
tk.mainloop()</pre>&#13;
<p class="caption"><a id="ch11lis9"/><em>Listing 11-9: Refactored version of hello_motion.py</em></p>&#13;
<p class="indent">If we go toward the end of the code, we find the call to <span class="literal">main_loop</span>. We’re passing in the functions that we previously defined, with the sole difference being that now those functions must declare the proper parameters to match the functions <span class="literal">main_loop</span> expects.</p>&#13;
<p class="indent">This code is much simpler to follow. All the logic to keep a steady frame rate has been moved away to its own function, so we can focus our attention on the simulation itself without needing to deal with those details. Let’s now take some time to play with some of the parameters of the simulation and understand how they affect the final result.</p>&#13;
<h4 class="h4" id="ch00lev2sec132"><strong><em>Playing with the Circle Divisions</em></strong></h4>&#13;
<p class="noindent">Remember that the <span class="literal">CanvasDrawing</span> class includes an affine transformation as part of its state, and every geometric primitive gets transformed by it before being drawn. Remember also that this is the reason a circle is converted to a generic polygon using a number of divisions high enough to approximate the circumference. The transformation happens in the drawing command; hence, the number of divisions has to be passed in, or else the default of 30 is used.</p>&#13;
<p class="indent">Going back to function <span class="literal">redraw</span> from <a href="ch11.xhtml#ch11lis9">Listing 11-9</a>,</p>&#13;
<pre>def redraw():&#13;
    drawing.clear_drawing()&#13;
    drawing.draw_circle(circle, 50)</pre>&#13;
<p class="noindent">you can see we used 50 divisions, but we could have used any other number. Let’s try with 10, for example:</p>&#13;
<pre>def redraw():&#13;
    drawing.clear_drawing()&#13;
    <span class="codestrong1">drawing.draw_circle(circle, 10)</span></pre>&#13;
<p class="indent">Rerun the file. Can you see the difference? What about if you try with 6 divisions? <a href="ch11.xhtml#ch11fig6">Figure 11-6</a> shows the simulation using 50, 10, and 6 divisions for the circle.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_303"/><img src="../images/11fig06.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch11fig6"><em>Figure 11-6: Circles drawn using 50, 10, and 6 divisions</em></p>&#13;
<p class="indent">After this interesting experiment we can clearly see the influence of the divisions used to approximate a circle. Let’s now experiment with the affine transformation used to transform the geometric primitives before they’re drawn to the canvas.</p>&#13;
<h4 class="h4" id="ch00lev2sec133"><strong><em>Playing with the Affine Transformation</em></strong></h4>&#13;
<p class="noindent">The affine transformation applied to the drawing in our simulation is an identity transformation: it keeps points exactly where they are. But we could use this transformation to do something different, such as invert the y-axis so that it points upward, for example. Go back to <em>hello_motion_refactor.py</em> and locate the line where the transformation is defined:</p>&#13;
<pre>transform = AffineTransform(sx=1, sy=1, tx=0, ty=0, shx=0, shy=0)</pre>&#13;
<p class="noindent">Then, edit it so that it inverts the y-axis:</p>&#13;
<pre>transform = AffineTransform(&#13;
    sx=1, <span class="codestrong1">sy=-1</span>, tx=0, ty=0, shx=0, shy=0&#13;
)</pre>&#13;
<p class="noindent">Run the simulation again. What do you see? Just a little rim coming from the top of the canvas, right? What’s happening is that we inverted the y-axis, but the origin of coordinates is still in the upper-left corner; thus, the circle we’re trying to draw is outside the window, as depicted by <a href="ch11.xhtml#ch11fig7">Figure 11-7</a>.</p>&#13;
<div class="image"><img src="../images/11fig07.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch11fig7"><em>Figure 11-7: Simulation with the y-axis inverted</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_304"/>We can easily fix this problem by translating the origin of the coordinates all the way down to the lower-left corner of the canvas. Since the canvas height is 600 pixels, we can set the transformation to be as follows:</p>&#13;
<pre>transform = AffineTransform(&#13;
    sx=1, sy=-1, tx=0, <span class="codestrong1">ty=600</span>, shx=0, shy=0&#13;
)</pre>&#13;
<p class="noindent">It may surprise you that the value for the vertical translation is 600 and not – 600, but remember that in the original system of coordinates, the y direction points downward, and this affine transformation refers to that system.</p>&#13;
<p class="indent">If you prefer, it may be easier to understand the process of obtaining that transformation by concatenating two simpler ones, the first moving the origin downward 600 pixels and the second flipping the y-axis,</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">t1 = AffineTransform(sx=1, sy=1, tx=0, ty=-600, shx=0, shy=0)</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">t2 = AffineTransform(sx=1, sy=-1, tx=0, ty=0, shx=0, shy=0)</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">t1.then(t2).__dict__</span>&#13;
{'sx': 1, 'sy': -1, 'tx': 0, 'ty': 600, 'shx': 0, 'shy': 0}</pre>&#13;
<p class="noindent">which yields the same transformation, as you can see.</p>&#13;
<p class="indent">Now, let’s add some shear in the horizontal direction to see how the circle gets deformed. Try the following values for the transformation,</p>&#13;
<pre>transform = AffineTransform(&#13;
    sx=1, sy=-1, <span class="codestrong1">tx=150</span>, ty=600, <span class="codestrong1">shx=-0.5</span>, shy=0&#13;
)</pre>&#13;
<p class="noindent">and run the simulation again. You should see a shape similar to that in <a href="ch11.xhtml#ch11fig8">Figure 11-8</a>.</p>&#13;
<div class="image"><img src="../images/11fig08.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch11fig8"><em>Figure 11-8: A circle drawn using a horizontal shear</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_305"/>Now it’s your turn to play with the values and see whether you can build a better intuition for how the animations, drawings, and transformations are working. You’ve created something beautiful from scratch, so take your time to experiment with it. Try to change the circle primitive using a triangle or a rectangle. You can update the geometric primitive by moving it instead of changing its size. Play around with the affine transformation values and try to reason about how the drawing should look before you actually run the simulation. Use this exercise to reinforce your affine transformation intuition.</p>&#13;
<h3 class="h3" id="ch00lev1sec70"><strong>Cleaning Up the Module</strong></h3>&#13;
<p class="noindent">Let’s do two small refactors to the module to clean it up a bit. First, create a new folder in the <em>simulation</em> package and name it <em>examples</em>. We’ll use it to house all the files that are not part of the simulation and drawing logic, but rather examples we wrote in this chapter. So, basically, move all the files except for <em>draw.py</em> and <em>loop.py</em> there. Your folder structure in <em>simulation</em> should look like this:</p>&#13;
<p class="pre2">    simulation<br/>      |- examples<br/>      |    |- hello_canvas.py<br/>      |    |- hello_motion.py<br/>      |    |- ...<br/>      |<br/>      |- __init__.py<br/>      |- draw.py<br/>      |- loop.py</p>&#13;
<p class="indent">The second thing we want to do is add both the <span class="literal">CanvasDrawing</span> class and the <span class="literal">main_loop</span> function to the default exports of the <em>simulation</em> package. Open file <em>__init__.py</em> in <em>simulation</em> and add the following imports:</p>&#13;
<pre>from .draw import CanvasDrawing&#13;
from .loop import main_loop</pre>&#13;
<p class="indent">That’s it! From now on we’ll be able to import both using a shorter syntax.</p>&#13;
<h3 class="h3" id="ch00lev1sec71"><strong>Summary</strong></h3>&#13;
<p class="noindent">In this chapter, we learned about the time loop. The time loop keeps executing while a condition is met, and its main job is to keep the frame rate steady. In this loop two things take place: the updating of the system under simulation and the redrawing of the screen. Those operations are timed so that when they’re done, we know how much more time remains to complete a cycle.</p>&#13;
<p class="indent">Because the time loop will appear in all of our simulations, we decided to implement it as a function. This function gets passed other functions: <span epub:type="pagebreak" id="page_306"/>one that updates the system, another that draws it to the screen, and a last one that decides whether the simulation is over or not.</p>&#13;
<p class="indent">In the next chapter, we’ll use this time loop function to animate affine transformations.</p>&#13;
</body></html>