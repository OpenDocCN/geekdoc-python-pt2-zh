<html><head></head><body>
<p class="calibre1">Lists work in a similar way:</p>
<p class="calibre1">&gt;&gt;&gt; myList = [10, 20, 30, 40]</p>
<p class="calibre1">&gt;&gt;&gt; print(type(myList))</p>
<p class="calibre1">&lt;class 'list'&gt; </p>
<p class="calibre1">All lists are instances of the list class, which has many methods includ-</p>
<p class="calibre1">ing myList.append(), myList.count(), myList.index(), and so on. </p>
<p class="calibre1">When you write a class, you are defining a new data type. Your code </p>
<p class="calibre1">provides the details by defining what data it maintains and what operations </p>
<p class="calibre1">it can perform. After creating an instance of your class and assigning it to </p>
<p class="calibre1">a variable, you can use the type() built-in function to determine the class </p>
<p class="calibre1">used to create it, just like with a built-in data type. Here we instantiate a </p>
<p class="calibre1">LightSwitch object and print out its data type: </p>
<p class="calibre1">&gt;&gt;&gt; oLightSwitch = LightSwitch()</p>
<p class="calibre1">&gt;&gt;&gt; print(type(oLightSwitch))</p>
<p class="calibre1">&lt;class 'LightSwitch'&gt; </p>
<p class="calibre1"><b class="calibre3">32</b>   Chapter 2</p>
<p class="calibre1"><a id="p62"/>Just like with Python’s built-in data types, we can then use the variable oLightSwitch to call the methods available in the oLightSwitch class. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Definition of an Object</b></i></p>
<p class="calibre1">To summarize this section, I’ll give my formal definition of an  <i class="calibre4">object</i>. </p>
<p class="calibre1"/>
<p class="calibre1"><b class="calibre3">object</b> </p>
<p class="calibre1">Data, plus code that acts on that data, over time . </p>
<p class="calibre1">A class defines what an object will look like when you instantiate one. </p>
<p class="calibre1">An object is a set of instance variables and the code of the methods in the </p>
<p class="calibre1">class from which the object was instantiated. Any number of objects can </p>
<p class="calibre1">be instantiated from a class, and each has its own set of instance variables. </p>
<p class="calibre1">When you call a method of an object, the method runs and uses the set of </p>
<p class="calibre1">instance variables in that object. </p>
<p class="calibre1"><b class="calibre3">Building a Slightly More Complicated Class</b></p>
<p class="calibre1">Let’s build on the concepts introduced so far and work through a second, </p>
<p class="calibre1">slightly more complicated example in which we’ll make a dimmer switch </p>
<p class="calibre1">class. A dimmer switch has an on/off switch, but it also has a multiposition </p>
<p class="calibre1">slider that affects the brightness of the light. </p>
<p class="calibre1">The slider can move through a range of brightness values. To make </p>
<p class="calibre1">things straightforward, our dimmer digital slider has 11 positions, from 0 </p>
<p class="calibre1">(completely off) through 10 (completely on). To raise or lower the bright-</p>
<p class="calibre1">ness of the bulb to the maximum extent, you must move the slider through </p>
<p class="calibre1">every possible setting. </p>
<p class="calibre1">This DimmerSwitch class has more functionality than our LightSwitch class </p>
<p class="calibre1">and needs to remember more data:</p>
<p class="calibre1">•  The switch state (on or off)</p>
<p class="calibre1">•  Brightness level (0 to 10)</p>
<p class="calibre1">And here are the behaviors a DimmerSwitch object can perform:</p>
<p class="calibre1">•  Turn on</p>
<p class="calibre1">•  Turn off</p>
<p class="calibre1">•  Raise level</p>
<p class="calibre1">•  Lower level</p>
<p class="calibre1">•  Show (for debugging)</p>
<p class="calibre1">The DimmerSwitch class uses the standard template shown earlier in </p>
<p class="calibre1">Listing 2-2: it starts with a class statement and a first method named  </p>
<p class="calibre1">__init__(), then defines a number of additional methods, one for each of </p>
<p class="calibre1">the behaviors listed. The full code for this class is presented in Listing 2-5. </p>
<p class="calibre1">Modeling Physical Objects with Object-Oriented Programming   <b class="calibre3">33</b></p>
<p class="calibre1"><a id="p63"/><b class="calibre3">File: DimmerSwitch.py</b></p>
<p class="calibre1"># DimmerSwitch class</p>
<p class="calibre1">class DimmerSwitch():</p>
<p class="calibre1">def __init__(self):</p>
<p class="calibre1">self.switchIsOn = False</p>
<p class="calibre1">self.brightness = 0</p>
<p class="calibre1">def turnOn(self):</p>
<p class="calibre1">self.switchIsOn = True</p>
<p class="calibre1">def turnOff(self):</p>
<p class="calibre1">self.switchIsOn = False</p>
<p class="calibre1">def raiseLevel(self):</p>
<p class="calibre1">if self.brightness &lt; 10:</p>
<p class="calibre1">self.brightness = self.brightness + 1</p>
<p class="calibre1">def lowerLevel(self):</p>
<p class="calibre1">if self.brightness &gt; 0:</p>
<p class="calibre1">self.brightness = self.brightness - 1</p>
<p class="calibre1"># Extra method for debugging</p>
<p class="calibre1">def show(self):</p>
<p class="calibre1">print(Switch is on?', self.switchIsOn)</p>
<p class="calibre1">print('Brightness is:', self.brightness)</p>
<p class="calibre1"> <i class="calibre4">Listing 2-5: The slightly more complicated DimmerSwitch class</i></p>
<p class="calibre1">In this __init__() method we have two instance variables: the famil-</p>
<p class="calibre1">iar self.switchIsOn and a new one, self.brightness, which remembers the </p>
<p class="calibre1">brightness level. We assign starting values to both instance variables. All </p>
<p class="calibre1">other methods can access the current value of each of these. In addition </p>
<p class="calibre1">to turnOn() and turnOff(), we include two new methods for this class:  </p>
<p class="calibre1">raiseLevel() and lowerLevel(), which do exactly what their names imply. </p>
<p class="calibre1">The show() method is used during development and debugging and just </p>
<p class="calibre1">prints the current values of the instance variables. </p>
<p class="calibre1">The main code in Listing 2-6 tests our class by creating a DimmerSwitch </p>
<p class="calibre1">object (oDimmer), then calling the various methods. </p>
<p class="calibre1"><b class="calibre3">File: OO_DimmerSwitch_with_Test_Code.py</b></p>
<p class="calibre1"># DimmerSwitch class with test code</p>
<p class="calibre1">class DimmerSwitch():</p>
<p class="calibre1">--- snipped code of DimmerSwitch class, as in Listing 2-5 ---</p>
<p class="calibre1"># Main code</p>
<p class="calibre1">oDimmer = DimmerSwitch()</p>
<p class="calibre1"># Turn switch on, and raise the level 5 times</p>
<p class="calibre1"><b class="calibre3">34</b>   Chapter 2</p>
<p class="calibre1"><a id="p64"/>oDimmer.turnOn()</p>
<p class="calibre1">oDimmer.raiseLevel()</p>
<p class="calibre1">oDimmer.raiseLevel()</p>
<p class="calibre1">oDimmer.raiseLevel()</p>
<p class="calibre1">oDimmer.raiseLevel()</p>
<p class="calibre1">oDimmer.raiseLevel()</p>
<p class="calibre1">oDimmer.show()</p>
<p class="calibre1"># Lower the level 2 times, and turn switch off</p>
<p class="calibre1">oDimmer.lowerLevel()</p>
<p class="calibre1">oDimmer.lowerLevel()</p>
<p class="calibre1">oDimmer.turnOff()</p>
<p class="calibre1">oDimmer.show()</p>
<p class="calibre1"># Turn switch on, and raise the level 3 times</p>
<p class="calibre1">oDimmer.turnOn()</p>
<p class="calibre1">oDimmer.raiseLevel()</p>
<p class="calibre1">oDimmer.raiseLevel()</p>
<p class="calibre1">oDimmer.raiseLevel()</p>
<p class="calibre1">oDimmer.show()</p>
<p class="calibre1"> <i class="calibre4">Listing 2-6: DimmerSwitch class with test code</i></p>
<p class="calibre1">When we run this code, the resulting output is:</p>
<p class="calibre1">Switch is on? True</p>
<p class="calibre1">Brightness is: 5</p>
<p class="calibre1">Switch is on? False</p>
<p class="calibre1">Brightness is: 3</p>
<p class="calibre1">Switch is on? True</p>
<p class="calibre1">Brightness is: 6</p>
<p class="calibre1">The main code creates the oDimmer object, then makes calls to the vari-</p>
<p class="calibre1">ous methods. Each time we call the show() method, the on/off state and the </p>
<p class="calibre1">brightness level are printed. The key thing to remember here is that oDimmer </p>
<p class="calibre1">represents an object. It allows access to all methods in the class from which </p>
<p class="calibre1">it was instantiated (the DimmerSwitch class),  <i class="calibre4">and</i> it has a set of all instance variables defined in the class (self.switchIsOn and self.brightness). Again, </p>
<p class="calibre1">instance variables maintain their values between calls to methods of an </p>
<p class="calibre1">object, so the self.brightness instance variable is incremented by 1 for each </p>
<p class="calibre1">call to oDimmer.raiseLevel(). </p>
<p class="calibre1"><b class="calibre3">Representing a More Complicated Physical Object as a Class</b></p>
<p class="calibre1">Let’s consider a more complicated physical object: a television. With this </p>
<p class="calibre1">more complicated example, we’ll take a closer look at how arguments work </p>
<p class="calibre1">in classes. </p>
<p class="calibre1">A television requires much more data than a light switch to represent </p>
<p class="calibre1">its state, and it has more behaviors. To create a TV class, we must consider </p>
<p class="calibre1">how a user would typically use a TV and what the TV would have to remem-</p>
<p class="calibre1">ber. Let’s look at some of the important buttons on a typical TV remote </p>
<p class="calibre1">(Figure 2-4). </p>
<p class="calibre1">Modeling Physical Objects with Object-Oriented Programming   <b class="calibre3">35</b></p>
<p class="calibre1"><a id="p65"/>Power</p>
<p class="calibre1">Volume</p>
<p class="calibre1">Channel</p>
<p class="calibre1">Mute</p>
<p class="calibre1">Get Info</p>
<p class="calibre1">1</p>
<p class="calibre1">2</p>
<p class="calibre1">3</p>
<p class="calibre1">4</p>
<p class="calibre1">5</p>
<p class="calibre1">6</p>
<p class="calibre1">7</p>
<p class="calibre1">8</p>
<p class="calibre1">9</p>
<p class="calibre1">0</p>
<p class="calibre1"> <i class="calibre4">Figure 2-4: A simplified TV remote</i></p>
<p class="calibre1">From this, we can determine that to keep track of its state, a TV class </p>
<p class="calibre1">would have to maintain the following data:</p>
<p class="calibre1">•  Power state (on or off)</p>
<p class="calibre1">•  Mute state (is it muted?)</p>
<p class="calibre1">•  List of channels available</p>
<p class="calibre1">•  Current channel setting</p>
<p class="calibre1">•  Current volume setting</p>
<p class="calibre1">•  Range of volume levels available </p>
<p class="calibre1">And the actions that the TV must provide include:</p>
<p class="calibre1">•  Turn the power on and off</p>
<p class="calibre1">•  Raise and lower the volume</p>
<p class="calibre1">•  Change the channel up and down</p>
<p class="calibre1">•  Mute and unmute the sound</p>
<p class="calibre1">•  Get information about the current settings</p>
<p class="calibre1">•  Go to a specified channel</p>
<p class="calibre1"><b class="calibre3">36</b>   Chapter 2</p>
<p class="calibre1"><a id="p66"/>The code for our TV class is shown in Listing 2-7. We include the __init__() method for initialization, followed by a method for each of the behaviors. </p>
<p class="calibre1"><b class="calibre3">File: TV.py</b></p>
<p class="calibre1"># TV class</p>
<p class="calibre1">class TV():</p>
<p class="calibre1">def __init__(self): 1</p>
<p class="calibre1">self.isOn = False</p>
<p class="calibre1">self.isMuted = False</p>
<p class="calibre1"># Some default list of channels</p>
<p class="calibre1">self.channelList = [2, 4, 5, 7, 9, 11, 20, 36, 44, 54, 65]  </p>
<p class="calibre1">self.nChannels = len(self.channelList)</p>
<p class="calibre1">self.channelIndex = 0</p>
<p class="calibre1">self.VOLUME_MINIMUM = 0   # constant</p>
<p class="calibre1">self.VOLUME_MAXIMUM = 10  # constant</p>
<p class="calibre1">self.volume = self.VOLUME_MAXIMUM //   # integer divide </p>
<p class="calibre1">def power(self): 2</p>
<p class="calibre1">self.isOn = not self.isOn   # toggle</p>
<p class="calibre1">def volumeUp(self):</p>
<p class="calibre1">if not self.isOn:</p>
<p class="calibre1">return</p>
<p class="calibre1">if self.isMuted:</p>
<p class="calibre1">self.isMuted = False  # changing the volume while muted unmutes the sound</p>
<p class="calibre1">if self.volume &lt; self.VOLUME_MAXIMUM:</p>
<p class="calibre1">self.volume = self.volume + 1</p>
<p class="calibre1">def volumeDown(self):</p>
<p class="calibre1">if not self.isOn:</p>
<p class="calibre1">return</p>
<p class="calibre1">if self.isMuted:</p>
<p class="calibre1">self.isMuted = False  # changing the volume while muted unmutes the sound</p>
<p class="calibre1">if self.volume &gt; self.VOLUME_MINIMUM:</p>
<p class="calibre1">self.volume = self.volume - 1</p>
<p class="calibre1">def channelUp(self): 3</p>
<p class="calibre1">if not self.isOn:</p>
<p class="calibre1">return</p>
<p class="calibre1">self.channelIndex = self.channelIndex + 1</p>
<p class="calibre1">if self.channelIndex &gt; self.nChannels:</p>
<p class="calibre1">self.channelIndex = 0  # wrap around to the first channel</p>
<p class="calibre1">def channelDown(self): 4</p>
<p class="calibre1">if not self.isOn:</p>
<p class="calibre1">return</p>
<p class="calibre1">self.channelIndex = self.channelIndex - 1</p>
<p class="calibre1">if self.channelIndex &lt; 0:</p>
<p class="calibre1">self.channelIndex = self.nChannels - 1  # wrap around to the top channel</p>
<p class="calibre1">def mute(self): 5</p>
<p class="calibre1">if not self.isOn:</p>
<p class="calibre1">Modeling Physical Objects with Object-Oriented Programming   <b class="calibre3">37</b></p>
<p class="calibre1"><a id="p67"/>            return</p>
<p class="calibre1">self.isMuted = not self.isMuted</p>
<p class="calibre1">def setChannel(self, newChannel):</p>
<p class="calibre1">if newChannel in self.channelList:</p>
<p class="calibre1">self.channelIndex = self.channelList.index(newChannel)</p>
<p class="calibre1"># if the newChannel is not in our list of channels, don't do anything</p>
<p class="calibre1">def showInfo(self): 6</p>
<p class="calibre1">print()</p>
<p class="calibre1">print('TV Status:')</p>
<p class="calibre1">if self.isOn:</p>
<p class="calibre1">print('    TV is: On')</p>
<p class="calibre1">print('    Channel is:', self.channelList[self.channelIndex])</p>
<p class="calibre1">if self.isMuted:</p>
<p class="calibre1">print('    Volume is:', self.volume, '(sound is muted)')</p>
<p class="calibre1">else:</p>
<p class="calibre1">print('    Volume is:', self.volume)</p>
<p class="calibre1">else:</p>
<p class="calibre1">print('    TV is: Off')</p>
<p class="calibre1"> <i class="calibre4">Listing 2-7: The TV class with many instance variables and methods</i></p>
<p class="calibre1">The __init__() method 1 creates all the instance variables used in all the </p>
<p class="calibre1">methods and assigns reasonable starting values to each. Technically, you can </p>
<p class="calibre1">create an instance variable inside any method; however, it is a good program-</p>
<p class="calibre1">ming practice to define all instance variables in the __init__() method. This </p>
<p class="calibre1">avoids the risk of an error when attempting to use an instance variable in a </p>
<p class="calibre1">method before it’s been defined. </p>
<p class="calibre1">The power() method 2 represents what happens when you push the </p>
<p class="calibre1">power button on a remote. If the TV is off, pushing the power button turns </p>
<p class="calibre1">it on; if the TV is on, pushing the power button turns it off. To code this </p>
<p class="calibre1">behavior I’ve used a  <i class="calibre4">toggle</i>,  <i class="calibre4"><b class="calibre3"> </b></i> which is a Boolean that’s used to represent one of two states and can easily be switched between them. With this toggle, the </p>
<p class="calibre1">not operator switches the self.isOn variable from True to False, or from False </p>
<p class="calibre1">to True. The mute() method code 5 does a similar thing, with the self.muted </p>
<p class="calibre1">variable toggling between muted and not-muted, but first has to check that </p>
<p class="calibre1">the TV is on. If the TV is off, calling the mute() method has no effect. </p>
<p class="calibre1">One interesting thing to note is that we don’t really keep track of </p>
<p class="calibre1">the current channel. Instead, we keep track of the  <i class="calibre4">index</i> of the current </p>
<p class="calibre1">channel, which allows us to get the current channel at any time by using </p>
<p class="calibre1">self.channelList[self.channelIndex]. </p>
<p class="calibre1">The channelUp() 3 and channelDown() 4 methods basically increment and </p>
<p class="calibre1">decrement the channel index, but there is also some clever code in them to </p>
<p class="calibre1">allow for wrap-around. If you’re currently at the last index in the channel list </p>
<p class="calibre1">and the user asks to go to the next channel up, the TV goes to the first chan-</p>
<p class="calibre1">nel in the list. If you’re at the first index in the channel list and the user asks to go the next channel down, the TV goes to the last channel in the list. </p>
<p class="calibre1">The showInfo() method 6 prints out the current status of the TV based </p>
<p class="calibre1">on the values of the instance variables (on/off, current channel, current </p>
<p class="calibre1">volume setting, and mute setting). </p>
<p class="calibre1"><b class="calibre3">38</b>   Chapter 2</p>
<p class="calibre1"><a id="p68"/>In Listing 2-8, we’ll create a TV object and call methods of that object. </p>
<p class="calibre1"><b class="calibre3">File: OO_TV_with_Test_Code.py</b></p>
<p class="calibre1"># TV class with test code</p>
<p class="calibre1">--- snipped code of TV class, as in Listing 2-7 ---</p>
<p class="calibre1"># Main code</p>
<p class="calibre1">oTV = TV()  # create the TV object</p>
<p class="calibre1"># Turn the TV on and show the status</p>
<p class="calibre1">oTV.power()</p>
<p class="calibre1">oTV.showInfo()</p>
<p class="calibre1"># Change the channel up twice, raise the volume twice, show status</p>
<p class="calibre1">oTV.channelUp()</p>
<p class="calibre1">oTV.channelUp()</p>
<p class="calibre1">oTV.volumeUp()</p>
<p class="calibre1">oTV.volumeUp()</p>
<p class="calibre1">oTV.showInfo()</p>
<p class="calibre1"># Turn the TV off, show status, turn the TV on, show status</p>
<p class="calibre1">oTV.power()</p>
<p class="calibre1">oTV.showInfo()</p>
<p class="calibre1">oTV.power()</p>
<p class="calibre1">oTV.showInfo()</p>
<p class="calibre1"># Lower the volume, mute the sound, show status</p>
<p class="calibre1">oTV.volumeDown()</p>
<p class="calibre1">oTV.mute()</p>
<p class="calibre1">oTV.showInfo()</p>
<p class="calibre1"># Change the channel to 11, mute the sound, show status</p>
<p class="calibre1">oTV.setChannel(11)</p>
<p class="calibre1">oTV.mute()</p>
<p class="calibre1">oTV.showInfo()</p>
<p class="calibre1"> <i class="calibre4">Listing 2-8: TV class with test code</i></p>
<p class="calibre1">When we run this code, here is what we get as output:</p>
<p class="calibre1">TV Status:</p>
<p class="calibre1">TV is: On</p>
<p class="calibre1">Channel is: 2</p>
<p class="calibre1">Volume is: 5</p>
<p class="calibre1">TV Status:</p>
<p class="calibre1">TV is: On</p>
<p class="calibre1">Channel is: 5</p>
<p class="calibre1">Volume is: 7</p>
<p class="calibre1">TV Status:</p>
<p class="calibre1">TV is: Off</p>
<p class="calibre1">Modeling Physical Objects with Object-Oriented Programming   <b class="calibre3">39</b></p>
<p class="calibre1"><a id="p69"/>TV Status:</p>
<p class="calibre1">TV is: On</p>
<p class="calibre1">Channel is: 5</p>
<p class="calibre1">Volume is: 7</p>
<p class="calibre1">TV Status:</p>
<p class="calibre1">TV is: On</p>
<p class="calibre1">Channel is: 5</p>
<p class="calibre1">Volume is: 6 (sound is muted)</p>
<p class="calibre1">TV Status:</p>
<p class="calibre1">TV is: On</p>
<p class="calibre1">Channel is: 11</p>
<p class="calibre1">Volume is: 6</p>
<p class="calibre1">All of the methods are working correctly, and we get the expected </p>
<p class="calibre1">output. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Passing Arguments to a Method</b></i></p>
<p class="calibre1">When calling any function, the number of arguments must match the num-</p>
<p class="calibre1">ber of parameters listed in the matching def statement:</p>
<p class="calibre1">def myFunction(param1, param2, param3):</p>
<p class="calibre1"># body of function</p>
<p class="calibre1"># call to a function:</p>
<p class="calibre1">myFunction(argument1, argument2, argument3)</p>
<p class="calibre1">The same rule applies with methods and method calls. However, you </p>
<p class="calibre1">may notice that whenever we make a call to a method, it appears that we are </p>
<p class="calibre1">specifying one less argument than the number of parameters. For example, </p>
<p class="calibre1">the definition of the power() method in our TV class looks like this:</p>
<p class="calibre1">def power(self):</p>
<p class="calibre1">This implies that the power() method is expecting one value to be </p>
<p class="calibre1">passed in and whatever is passed in will be assigned to the variable self. Yet </p>
<p class="calibre1">when we started by turning on the TV in Listing 2-8, we made this call:</p>
<p class="calibre1">oTV.power()</p>
<p class="calibre1">When we make the call, we don’t explicitly pass anything inside the </p>
<p class="calibre1">parentheses. </p>
<p class="calibre1">This may seem even stranger in the case of the setChannel() method. </p>
<p class="calibre1">The method is written to accept two parameters:</p>
<p class="calibre1">def setchannel(self, newchannel):</p>
<p class="calibre1">if newChannel in self.channelList:</p>
<p class="calibre1">self.channelIndex = self.channelList.index(newChannel)</p>
<p class="calibre1"><b class="calibre3">40</b>   Chapter 2</p>
<p class="calibre1"><a id="p70"/>But we called setChannel() like this:</p>
<p class="calibre1">oTV.setChannel(11)</p>
<p class="calibre1">It appears that only one value is being passed in. </p>
<p class="calibre1">You might expect Python to generate an error here, due to a mismatch </p>
<p class="calibre1">in the number of arguments (one) and the number of parameters (two). In </p>
<p class="calibre1">practice, Python is doing a bit of behind-the-scenes work to make the syntax </p>
<p class="calibre1">easier to follow. </p>
<p class="calibre1">Let’s examine this. Earlier, I said that to make a call to a method of an </p>
<p class="calibre1">object, you use the following generic syntax:</p>
<p class="calibre1"> <i class="calibre4">&lt;object&gt; </i>.  <i class="calibre4">&lt;method&gt; </i>( <i class="calibre4">&lt;any arguments&gt; </i>)</p>
<p class="calibre1">Python takes the &lt;object&gt; you specify in the call and rearranges it to </p>
<p class="calibre1">become the first argument. Any values in the parentheses of the method </p>
<p class="calibre1">call are considered the subsequent argument(s). Thus, Python makes it </p>
<p class="calibre1">appear that you wrote this instead:</p>
<p class="calibre1"> <i class="calibre4">&lt;method of object&gt; </i>( <i class="calibre4">&lt;object&gt; </i>,  <i class="calibre4">&lt;any arguments&gt; </i>) Figure 2-5 shows how this works in our example code, again using the </p>
<p class="calibre1">setChannel() method of the TV class. </p>
<p class="calibre1"># Method in the TV class</p>
<p class="calibre1"><b class="calibre3">def setChannel(self, newChannel):</b></p>
<p class="calibre1"><b class="calibre3">  …</b></p>
<p class="calibre1">#Call</p>
<p class="calibre1"><b class="calibre3">oTV.setChannel(</b></p>
<p class="calibre1"><b class="calibre3">V</b></p>
<p class="calibre1"><b class="calibre3">11)</b></p>
<p class="calibre1"> <i class="calibre4">Figure 2-5: Cal ing a method</i></p>
<p class="calibre1">Although it looks like we’re only providing one argument here (for </p>
<p class="calibre1">newChannel), there are really two arguments passed in—oTV and 11—and the </p>
<p class="calibre1">method provides two parameters to receive these values (self and newChannel, </p>
<p class="calibre1">respectively). Python rearranges the arguments for us when the call is </p>
<p class="calibre1">made. This may seem odd at first, but it will become second nature very </p>
<p class="calibre1">quickly. Writing the call with the object first makes it much easier for a </p>
<p class="calibre1">programmer to see which object is being acted on. </p>
<p class="calibre1">This is a subtle but important feature. Remember that the object (in </p>
<p class="calibre1">this case, oTV) keeps the current settings of all of its instance variables. </p>
<p class="calibre1">Passing the object as the first argument allows the method to run with the </p>
<p class="calibre1">values of the instance variables of that object. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Multiple Instances</b></i></p>
<p class="calibre1">Every method is written with self as the first parameter, so the self variable </p>
<p class="calibre1">receives the object used in each call. This has a major implication: it allows </p>
<p class="calibre1">Modeling Physical Objects with Object-Oriented Programming   <b class="calibre3">41</b></p>
<p class="calibre1"><a id="p71"/>any method within a class to work with  <i class="calibre4">different</i> objects. I’ll explain how this works using an example. </p>
<p class="calibre1">In Listing 2-9, we’ll create two TV objects and save them in two variables, </p>
<p class="calibre1">oTV1 and oTV2. Each TV object has a volume setting, a channel list, a channel </p>
<p class="calibre1">setting, and so on. We’ll make calls to a number of different methods of </p>
<p class="calibre1">the different objects. At the end, we’ll call the showInfo() method on each TV </p>
<p class="calibre1">object to see the resulting settings. </p>
<p class="calibre1"><b class="calibre3">File: OO_TV_TwoInstances.py</b></p>
<p class="calibre1"># Two TV objects with calls to their methods</p>
<p class="calibre1">class TV():</p>
<p class="calibre1">--- snipped code of TV class, as in Listing 2-7 ---</p>
<p class="calibre1"># Main code</p>
<p class="calibre1">oTV1 = TV()  # create one TV object</p>
<p class="calibre1">oTV2 = TV()  # create another TV object</p>
<p class="calibre1"># Turn both TVs on </p>
<p class="calibre1">oTV1.power()</p>
<p class="calibre1">oTV2.power()</p>
<p class="calibre1"># Raise the volume of TV1</p>
<p class="calibre1">oTV1.volumeUp()</p>
<p class="calibre1">oTV1.volumeUp()</p>
<p class="calibre1"># Raise the volume of TV2</p>
<p class="calibre1">oTV2.volumeUp()</p>
<p class="calibre1">oTV2.volumeUp()</p>
<p class="calibre1">oTV2.volumeUp()</p>
<p class="calibre1">oTV2.volumeUp()</p>
<p class="calibre1">oTV2.volumeUp()</p>
<p class="calibre1"># Change TV2's channel, then mute it</p>
<p class="calibre1">oTV2.setChannel(44)</p>
<p class="calibre1">oTV2.mute()</p>
<p class="calibre1"># Now display both TVs</p>
<p class="calibre1">oTV1.showInfo()</p>
<p class="calibre1">oTV2.showInfo()</p>
<p class="calibre1"> <i class="calibre4">Listing 2-9: Creating two instances of the TV class and cal ing methods of each</i> If we run this code, it will generate the following output:</p>
<p class="calibre1">Status of TV:</p>
<p class="calibre1">TV is: On</p>
<p class="calibre1">Channel is: 2</p>
<p class="calibre1">Volume is: 7</p>
<p class="calibre1">Status of TV:</p>
<p class="calibre1">TV is: On</p>
<p class="calibre1">Channel is: 44</p>
<p class="calibre1">Volume is: 10 (sound is muted)</p>
<p class="calibre1"><b class="calibre3">42</b>   Chapter 2</p>
<p class="calibre1"><a id="p72"/>Each TV object maintains its own set of the instance variables defined in the class. This way, each TV object’s instance variables can be manipulated </p>
<p class="calibre1">independently of those of any other TV object. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Initialization Parameters</b></i></p>
<p class="calibre1">The ability to pass arguments to method calls also works when instantiat-</p>
<p class="calibre1">ing an object. So far, when we’ve created our objects, we’ve always set their </p>
<p class="calibre1">instance variables to constant values. However, you’ll often want to create </p>
<p class="calibre1">different instances with different starting values. For example, imagine we </p>
<p class="calibre1">want to instantiate different TVs and identify them using their brand name </p>
<p class="calibre1">and location. This way, we can differentiate between a Samsung television </p>
<p class="calibre1">in the family room and a Sony television in the bedroom. Constant values </p>
<p class="calibre1">would not work for us in this situation. </p>
<p class="calibre1">To initialize an object with different values, we add parameters to the </p>
<p class="calibre1">definition of the __init__() method, like this:</p>
<p class="calibre1"># TV class</p>
<p class="calibre1">class TV():</p>
<p class="calibre1">def __init__(self, brand, location):  # pass in a brand and location for the TV</p>
<p class="calibre1">self.brand = brand</p>
<p class="calibre1">self.location = location</p>
<p class="calibre1">--- snipped remaining initialization of TV --- </p>
<p class="calibre1">... </p>
<p class="calibre1">In all methods, parameters are local variables, so they literally go away </p>
<p class="calibre1">when the method ends.  For example, in the __init__() method of the TV </p>
<p class="calibre1">class shown here, brand and location are local variables that will disappear </p>
<p class="calibre1">when the method ends. However, we often want to save values that are </p>
<p class="calibre1">passed in via parameters to use them in other methods. </p>
<p class="calibre1">In order to allow an object to remember initial values, the standard </p>
<p class="calibre1">approach is to store any values passed in into instance variables.  Since </p>
<p class="calibre1">instance variables have object scope, they can be used in other methods in </p>
<p class="calibre1">the class. The Python convention is that the name of the instance variable </p>
<p class="calibre1">should be the same as the parameter name, but prefixed with self and a </p>
<p class="calibre1">period:</p>
<p class="calibre1">def __init__(self, someVariableName):</p>
<p class="calibre1">self.someVariableName = someVariableName</p>
<p class="calibre1">In the TV class, the line after the def statement tells Python to take the </p>
<p class="calibre1">value of the brand parameter and assign it to an instance variable named </p>
<p class="calibre1">self.brand. The next line does the same thing with the location parameter </p>
<p class="calibre1">and the instance variable self.location.  After these assignments, we can use </p>
<p class="calibre1">self.brand and self.location in other methods. </p>
<p class="calibre1">Modeling Physical Objects with Object-Oriented Programming   <b class="calibre3">43</b></p>
<p class="calibre1"><a id="p73"/>Using this approach, we can create multiple objects from the same class but start each off with different data. So, we can create our two TV objects </p>
<p class="calibre1">like this:</p>
<p class="calibre1">oTV1 = TV('Samsung', 'Family room')</p>
<p class="calibre1">oTV2 = TV('Sony', 'Bedroom')</p>
<p class="calibre1">When executing the first line, Python first allocates space for a TV </p>
<p class="calibre1">object. Then it rearranges the arguments as discussed in the previous sec-</p>
<p class="calibre1">tion and calls the __init__() method of the TV class with three arguments: </p>
<p class="calibre1">the newly allocated oTV1 object, the brand, and the location. </p>
<p class="calibre1">When initializing the oTV1 object, self.brand is set to the string 'Samsung' </p>
<p class="calibre1">and self.location is set to the string 'Family room'.  When initializing oTV2, </p>
<p class="calibre1">its self.brand is set to the string 'Sony', and its self.location gets set to the </p>
<p class="calibre1">string 'Bedroom'. </p>
<p class="calibre1">We can modify the showInfo() method to report the name and location </p>
<p class="calibre1">of the TV. </p>
<p class="calibre1"><b class="calibre3">File: OO_TV_TwoInstances_with_Init_Params.py</b></p>
<p class="calibre1">def showInfo(self):</p>
<p class="calibre1">print()</p>
<p class="calibre1">print('Status of TV:', self.brand)</p>
<p class="calibre1">print('    Location:', self.location)</p>
<p class="calibre1">if self.isOn:</p>
<p class="calibre1">... </p>
<p class="calibre1">And we’ll see this as output:</p>
<p class="calibre1">Status of TV: Sony</p>
<p class="calibre1">Location: Family room</p>
<p class="calibre1">TV is: On</p>
<p class="calibre1">Channel is: 2</p>
<p class="calibre1">Volume is: 7</p>
<p class="calibre1">Status of TV: Samsung</p>
<p class="calibre1">Location: Bedroom</p>
<p class="calibre1">TV is: On</p>
<p class="calibre1">Channel is: 44</p>
<p class="calibre1">Volume is: 10 (sound is muted)</p>
<p class="calibre1">We made the same method calls as in the previous example in </p>
<p class="calibre1">Listing 2-9. The difference is that each TV object is now initialized with a </p>
<p class="calibre1">brand and a location, and you can now see that information printed in </p>
<p class="calibre1">response to each call to the modified showInfo() method. </p>
<p class="calibre1"><b class="calibre3">44</b>   Chapter 2</p>
<p class="calibre1"><a id="p74"/><b class="calibre3">Classes in Use</b></p>
<p class="calibre1">Using everything we’ve learned in this chapter, we can now create classes </p>
<p class="calibre1">and build multiple independent instances from those classes. Here are a </p>
<p class="calibre1">few examples of how we might use this: </p>
<p class="calibre1">•  Say we wanted to model a student in a course. We could have a Student </p>
<p class="calibre1">class that has instance variables for name, emailAddress, currentGrade, and </p>
<p class="calibre1">so on. Each Student object we create from this class would have its own </p>
<p class="calibre1">set of these instance variables, and the values given to the instance vari-</p>
<p class="calibre1">ables would be different for each student. </p>
<p class="calibre1">•  Consider a game where we have multiple players. A player could be </p>
<p class="calibre1">modeled by a Player class with instance variables for name, points, health, </p>
<p class="calibre1">location, and so on. Each player would have the same capabilities, but </p>
<p class="calibre1">the methods could work differently based on the different values in the </p>
<p class="calibre1">instance variables. </p>
<p class="calibre1">•  Imagine an address book. We could create a Person class with instance </p>
<p class="calibre1">variables for name, address, phoneNumber, and birthday. We could create </p>
<p class="calibre1">as many objects from the Person class as we want, one for each person </p>
<p class="calibre1">we know. The instance variables in each Person object would contain </p>
<p class="calibre1">different values. We could then write code to search through all the </p>
<p class="calibre1">Person objects and retrieve information about the one or ones we are </p>
<p class="calibre1">looking for. </p>
<p class="calibre1">In future chapters, I will explore this concept of instantiating multiple </p>
<p class="calibre1">objects from a single class and give you tools to help manage a collection of </p>
<p class="calibre1">objects. </p>
<p class="calibre1"><b class="calibre3">OOP as a Solution</b></p>
<p class="calibre1">Toward the end o<a href="index_split_000.html#p32">f Chapter 1, I m</a>entioned three problems that are inherent in procedural coding. Hopefully, after working through the examples </p>
<p class="calibre1">in this chapter, you can see how object-oriented programming solves all of </p>
<p class="calibre1">those problems:</p>
<p class="calibre1">1.  A well-written class can be easily reused in many different programs. </p>
<p class="calibre1">Classes do not need to access global data. Instead, objects provide code </p>
<p class="calibre1">and data at the same level. </p>
<p class="calibre1">2.  Object-oriented programming can greatly reduce the number of global </p>
<p class="calibre1">variables required, because a class provides a framework in which data </p>
<p class="calibre1">and code that acts on the data exist in one grouping. This also tends to </p>
<p class="calibre1">make code easier to debug. </p>
<p class="calibre1">3.  Objects created from a class only have access to their own data—their </p>
<p class="calibre1">set of the instance variables in the class. Even when you have multiple </p>
<p class="calibre1">objects created from the same class, they do not have access to each </p>
<p class="calibre1">other’s data. </p>
<p class="calibre1">Modeling Physical Objects with Object-Oriented Programming   <b class="calibre3">45</b></p>
<p class="calibre1"><a id="p75"/><b class="calibre3">Summary</b></p>
<p class="calibre1">In this chapter, I provided an introduction to object-oriented program-</p>
<p class="calibre1">ming by demonstrating the relationship between a class and an object. The </p>
<p class="calibre1">class defines the shape and capabilities of an object. An object is a single </p>
<p class="calibre1">instance of a class that has its own set of all the data defined in the instance </p>
<p class="calibre1">variables of the class. Each piece of data you want an object to contain is </p>
<p class="calibre1">stored in an instance variable, which has object scope, meaning that it is </p>
<p class="calibre1">available within all methods defined in the class. All objects created from </p>
<p class="calibre1">the same class get their own set of all the instance variables, and because </p>
<p class="calibre1">these may contain different values, calling the methods on different objects </p>
<p class="calibre1">can result in different behavior. </p>
<p class="calibre1">I showed how you create an object from a class, typically through an </p>
<p class="calibre1">assignment statement. After instantiating an object, you can use it to make </p>
<p class="calibre1">calls to any method defined in the class of that object. I also showed how </p>
<p class="calibre1">you can instantiate multiple objects from the same class. </p>
<p class="calibre1">In this chapter, the demonstration classes implemented physical objects </p>
<p class="calibre1">(light switches, TVs). This is a good way to start understanding the con-</p>
<p class="calibre1">cepts of a class and an object. However, in future chapters, I will introduce </p>
<p class="calibre1">objects that do not represent physical objects. </p>
<p class="calibre1"><b class="calibre3">46</b>   Chapter 2</p>
<p class="calibre1"><a id="p76"/><b class="calibre3">3</b></p>
<p class="calibre1"><b class="calibre3">M E N T A L   M O D E L S   O F   O B J E C T S </b></p>
<p class="calibre1"><b class="calibre3">A N D   T H E   M E A N I N G   O F   “ S E L F ” </b></p>
<p class="calibre1">Hopefully the new concepts and terminol-</p>
<p class="calibre1">ogy I’ve introduced so far are starting to </p>
<p class="calibre1">make sense. Some people new to OOP have </p>
<p class="calibre1">trouble envisioning what an object is and how </p>
<p class="calibre1">the methods of an object work with its instance vari-</p>
<p class="calibre1">ables. The specifics are fairly complex, so it can be </p>
<p class="calibre1">helpful to develop a mental model of how objects and </p>
<p class="calibre1">classes operate. </p>
<p class="calibre1">In this chapter, I’ll present two mental models of OOP. Right up front, </p>
<p class="calibre1">I want to be clear that neither of these models is an exact representation </p>
<p class="calibre1">of how objects work in Python. Instead, these models are intended to give </p>
<p class="calibre1">you a way to think about what an object looks like and what happens when </p>
<p class="calibre1">you call a method. This chapter will also go into more detail about self and </p>
<p class="calibre1">show how it is used to make methods work with multiple objects instanti-</p>
<p class="calibre1">ated from the same class. Throughout the rest of the book, you’ll gain a </p>
<p class="calibre1">much deeper insight into objects and classes. </p>
<p class="calibre1"><a id="p77"/><b class="calibre3">Revisiting the DimmerSwitch Class</b></p>
<p class="calibre1">In the following examples, we’ll continue with the DimmerSwitch class from </p>
<p class="calibre1"><a href="index_split_000.html#p50">Chapter 2 (</a>Listing 2-5). The DimmerSwitch class already has two instance variables: self.isOn and self.brightness. The only modification we’ll make is to </p>
<p class="calibre1">add a self.label instance variable so each object we create can be identified </p>
<p class="calibre1">easily in the output when we run our program. These variables are created </p>
<p class="calibre1">and assigned initial values in the __init__() method. They are then accessed </p>
<p class="calibre1">or modified in the five other methods of the class. </p>
<p class="calibre1">Listing 3-1 provides some test code to create three DimmerSwitch objects </p>
<p class="calibre1">from the DimmerSwitch class, which we’ll use in our mental models. I’ll call </p>
<p class="calibre1">various methods for each of the DimmerSwitch objects. </p>
<p class="calibre1"><b class="calibre3">File: OO_DimmerSwitch_Model1.py</b></p>
<p class="calibre1"># Create first DimmerSwitch, turn it on, and raise the level twice</p>
<p class="calibre1">oDimmer1 = DimmerSwitch('Dimmer1')</p>
<p class="calibre1">oDimmer1.turnOn()</p>
<p class="calibre1">oDimmer1.raiseLevel()</p>
<p class="calibre1">oDimmer1.raiseLevel()</p>
<p class="calibre1"># Create second DimmerSwitch, turn it on, and raise the level 3 times</p>
<p class="calibre1">oDimmer2 = DimmerSwitch('Dimmer2')</p>
<p class="calibre1">oDimmer2.turnOn()</p>
<p class="calibre1">oDimmer2.raiseLevel()</p>
<p class="calibre1">oDimmer2.raiseLevel()</p>
<p class="calibre1">oDimmer2.raiseLevel()</p>
<p class="calibre1"># Create third DimmerSwitch, using the default settings</p>
<p class="calibre1">oDimmer3 = DimmerSwitch('Dimmer3')</p>
<p class="calibre1"># Ask each switch to show itself</p>
<p class="calibre1">oDimmer1.show()</p>
<p class="calibre1">oDimmer2.show()</p>
<p class="calibre1">oDimmer3.show()</p>
<p class="calibre1"> <i class="calibre4">Listing 3-1: Creating three DimmerSwitch objects and cal ing various methods on each</i> When run with our DimmerSwitch class, this code gives the following </p>
<p class="calibre1">output:</p>
<p class="calibre1">Label: Dimmer1</p>
<p class="calibre1">Light is on? True</p>
<p class="calibre1">Brightness is: 2</p>
<p class="calibre1">Label: Dimmer2</p>
<p class="calibre1">Light is on? True</p>
<p class="calibre1">Brightness is: 3</p>
<p class="calibre1">Label: Dimmer3</p>
<p class="calibre1">Light is on? False</p>
<p class="calibre1">Brightness is: 0</p>
<p class="calibre1"><b class="calibre3">48</b>   Chapter 3</p>
<p class="calibre1"><a id="p78"/>This is exactly what you would expect. Each DimmerSwitch object is independent of any other DimmerSwitch objects, and each object contains and </p>
<p class="calibre1">modifies its own instance variables. </p>
<p class="calibre1"><b class="calibre3">High-Level Mental Model #1</b></p>
<p class="calibre1">In this first model, you can think of each object as a self-contained unit that </p>
<p class="calibre1">contains a data type, a set of the instance variables defined in the class, and </p>
<p class="calibre1">a copy of all the methods defined in the class (Figure 3-1). </p>
<p class="calibre1">oDimmer1</p>
<p class="calibre1">oDimmer2</p>
<p class="calibre1">oDimmer3</p>
<p class="calibre1">Type:</p>
<p class="calibre1">Type:</p>
<p class="calibre1">Type:</p>
<p class="calibre1">DimmerSwitch</p>
<p class="calibre1">DimmerSwitch</p>
<p class="calibre1">DimmerSwitch</p>
<p class="calibre1">Data:</p>
<p class="calibre1">Data:</p>
<p class="calibre1">Data:</p>
<p class="calibre1">label: Dimmer1</p>
<p class="calibre1">label: Dimmer2</p>
<p class="calibre1">label: Dimmer3</p>
<p class="calibre1">isOn: True</p>
<p class="calibre1">isOn: True</p>
<p class="calibre1">isOn: False</p>
<p class="calibre1">brightness: 2</p>
<p class="calibre1">brightness: 3</p>
<p class="calibre1">brightness: 0</p>
<p class="calibre1">Methods:</p>
<p class="calibre1">Methods:</p>
<p class="calibre1">Methods:</p>
<p class="calibre1">_init_()</p>
<p class="calibre1">_init_()</p>
<p class="calibre1">_init_()</p>
<p class="calibre1">turnOn()</p>
<p class="calibre1">turnOn()</p>
<p class="calibre1">turnOn()</p>
<p class="calibre1">turnOff()</p>
<p class="calibre1">turnOff()</p>
<p class="calibre1">turnOff()</p>
<p class="calibre1">raiseLevel()</p>
<p class="calibre1">raiseLevel()</p>
<p class="calibre1">raiseLevel()</p>
<p class="calibre1">lowerLevel()</p>
<p class="calibre1">lowerLevel()</p>
<p class="calibre1">lowerLevel()</p>
<p class="calibre1">show()</p>
<p class="calibre1">show()</p>
<p class="calibre1">show()</p>
<p class="calibre1"> <i class="calibre4">Figure 3-1: In mental model #1 each object is a unit that has a type, data, </i></p>
<p class="calibre1"> <i class="calibre4">and methods. </i></p>
<p class="calibre1">The data and methods of each object are packaged together. The </p>
<p class="calibre1">scope of an instance variable is defined as all the methods in the class, </p>
<p class="calibre1">so all methods have access to the instance variables associated with that </p>
<p class="calibre1">object. </p>
<p class="calibre1">If this mental model makes the concepts clear, then you’re in good </p>
<p class="calibre1">shape. While this is  <i class="calibre4">not</i> the way objects are actually implemented, it’s a perfectly reasonable way to  <i class="calibre4">think about</i> how an object’s instance variables and methods work together. </p>
<p class="calibre1"><b class="calibre3">A Deeper Mental Model #2</b></p>
<p class="calibre1">This second model explores objects at a lower level and will explain more </p>
<p class="calibre1">about what an object is. </p>
<p class="calibre1">Every time you instantiate an object, you get back a value from Python. </p>
<p class="calibre1">We typically store the returned value in a variable that refers to the object. </p>
<p class="calibre1">In Listing 3-2, we create three DimmerSwitch objects. After creating each one, </p>
<p class="calibre1">we’ll add code to inspect the result by printing out the type and value of </p>
<p class="calibre1">each variable. </p>
<p class="calibre1">Mental Models of Objects and the Meaning of “self” <b class="calibre3">49</b></p>
<p class="calibre1"><a id="p79"/><b class="calibre3">File: OO_DimmerSwitch_Model2_Instantiation.py</b></p>
<p class="calibre1"># Create three DimmerSwitch objects</p>
<p class="calibre1">oDimmer1 = DimmerSwitch('Dimmer1')</p>
<p class="calibre1">print(type(oDimmer1))</p>
<p class="calibre1">print(oDimmer1)</p>
<p class="calibre1">print()</p>
<p class="calibre1">oDimmer2 = DimmerSwitch('Dimmer2')</p>
<p class="calibre1">print(type(oDimmer2))</p>
<p class="calibre1">print(oDimmer2)</p>
<p class="calibre1">print()</p>
<p class="calibre1">oDimmer3 = DimmerSwitch('Dimmer3')</p>
<p class="calibre1">print(type(oDimmer3))</p>
<p class="calibre1">print(oDimmer3)</p>
<p class="calibre1">print()</p>
<p class="calibre1"> <i class="calibre4">Listing 3-2: Creating three DimmerSwitch objects and printing the type and value of each</i> Here is the output:</p>
<p class="calibre1">&lt;class '__main__.DimmerSwitch'&gt; </p>
<p class="calibre1">&lt;__main__.DimmerSwitch object at 0x7ffe503b32e0&gt; </p>
<p class="calibre1">&lt;class '__main__.DimmerSwitch'&gt; </p>
<p class="calibre1">&lt;__main__.DimmerSwitch object at 0x7ffe503b3970&gt; </p>
<p class="calibre1">&lt;class '__main__.DimmerSwitch'&gt; </p>
<p class="calibre1">&lt;__main__.DimmerSwitch object at 0x7ffe503b39d0&gt; </p>
<p class="calibre1">The first line in each grouping tells us the data type. Instead of a built-in </p>
<p class="calibre1">type like integer or float, we see that all three objects are of the programmer-</p>
<p class="calibre1">defined DimmerSwitch type. (The __main__ indicates that the DimmerSwitch code </p>
<p class="calibre1">was found inside our single Python file, not imported from any other file.) </p>
<p class="calibre1">The second line of each grouping contains a string of characters. Each </p>
<p class="calibre1">string represents a location in the memory of the computer. The memory </p>
<p class="calibre1">location is where all the data associated with each object can be found. </p>
<p class="calibre1">Notice each object is in a different location in memory. If you run this code </p>
<p class="calibre1">on your computer, you will most likely get different values, but the actual </p>
<p class="calibre1">values do not matter to understanding the concept. </p>
<p class="calibre1">All DimmerSwitch objects report the same type: class DimmerSwitch. The </p>
<p class="calibre1">extremely important takeaway is that the objects all refer to the code of the </p>
<p class="calibre1">same class, which really only exists in one place. When your program starts </p>
<p class="calibre1">running, Python reads through all the class definitions and remembers the </p>
<p class="calibre1">locations of all the classes and their methods. </p>
<p class="calibre1">The Python Tutor websit<a href="http://PythonTutor.com">e ( <i class="calibre4">http://PythonTutor.com</i>) p</a>rovides some useful tools that can help you to visualize the execution of small programs by allowing you to step through each line of your code. Figure 3-2 is a screenshot from </p>
<p class="calibre1">running the DimmerSwitch class and test code through the visualization tool, </p>
<p class="calibre1">stopping execution before instantiating the first DimmerSwitch object. </p>
<p class="calibre1">In this screenshot, you can see that Python remembers the location </p>
<p class="calibre1">of the DimmerSwitch class and all of its methods. While classes can contain </p>
<p class="calibre1">hundreds or even thousands of lines of code, no object actually gets a copy </p>
<p class="calibre1">of the class’s code. Having only one copy of the code is very important, as </p>
<p class="calibre1">it keeps the size of OOP programs small. When you instantiate an object, </p>
<p class="calibre1"><b class="calibre3">50</b>   Chapter 3</p>
<p class="calibre1"><a id="p80"/><img src="index-80_1.png" alt="Image 14" class="calibre2"/></p>
<p class="calibre1"><img src="index-80_2.png" alt="Image 15" class="calibre2"/></p>
<p class="calibre1">Python allocates enough memory for each object to represent its own set </p>
<p class="calibre1">of the instance variables defined in the class. In general, instantiating an </p>
<p class="calibre1">object from a class is memory-efficient. </p>
<p class="calibre1"> <i class="calibre4">Figure 3-2: Python remembers all classes and all methods in each class. </i></p>
<p class="calibre1">The screenshot in Figure 3-3 shows the result of running all the test </p>
<p class="calibre1">code in Listing 3-2. </p>
<p class="calibre1"> <i class="calibre4">Figure 3-3: Running Listing 3-2 demonstrates that objects do not include code, in accordance with mental model #2. </i></p>
<p class="calibre1">Mental Models of Objects and the Meaning of “self” <b class="calibre3">51</b></p>
<p class="calibre1"><a id="p81"/>This matches our second mental model. On the right side of this </p>
<p class="calibre1">screenshot, the code for the DimmerSwitch class appears only once. Each </p>
<p class="calibre1">object knows the class it was instantiated from and contains its own set of </p>
<p class="calibre1">the instance variables defined in the class. </p>
<p class="calibre1"><b class="calibre3">N O T E </b> <i class="calibre4"> </i></p>
<p class="calibre1"> <i class="calibre4">While the following is an implementation detail, it may help to further your understanding of objects. Internally, all instance variables of an object are kept as name/</i></p>
<p class="calibre1"> <i class="calibre4">value pairs in a Python dictionary. You can inspect all the instance variables in an</i> <i class="calibre4">object by calling the built-in vars() function on any object. For example, in the test</i> <i class="calibre4">code from Listing 3-2, if you want to see the internal representation of the instance</i> <i class="calibre4">variables, you can add this line at the end:</i></p>
<p class="calibre1">print('oDimmer1 variables:', vars(oDimmer1))</p>
<p class="calibre1"> <i class="calibre4">When you run it, you’ll see this output:</i></p>
<p class="calibre1">oDimmer1 variables: {'label': 'Dimmer1', 'isOn': True, 'brightness': 2}</p>
<p class="calibre1"><b class="calibre3">What Is the Meaning of “self”? </b></p>
<p class="calibre1">Philosophers have struggled with this question for centuries, so it would be </p>
<p class="calibre1">rather pretentious of me to try to explain it in just a few pages. In Python, </p>
<p class="calibre1">however, the variable named self does have a highly specialized and clear </p>
<p class="calibre1">meaning. In this section, I’ll show how self is given a value and how the </p>
<p class="calibre1">code of the methods in a class work with the instance variables of any object </p>
<p class="calibre1">instantiated from the class. </p>
<p class="calibre1"><b class="calibre3">N O T E </b> <i class="calibre4"> </i></p>
<p class="calibre1"> <i class="calibre4">The variable name self is not a keyword in Python but is used by convention—any</i> <i class="calibre4">other name could be used and the code would work fine. However, using self is a</i> <i class="calibre4">universally accepted practice in Python, and I will use it throughout this book. If you</i> <i class="calibre4">want your code to be understood by other Python programmers, use the name self as</i> <i class="calibre4">the first parameter in all methods of a class. (Other OOP languages have the same</i> <i class="calibre4">concept but use other names, such as this or me.)</i></p>
<p class="calibre1">Suppose you write a class named SomeClass, then create an object from </p>
<p class="calibre1">that class, like this:</p>
<p class="calibre1">oSomeObject = SomeClass( <i class="calibre4">&lt;optional arguments&gt; </i>)</p>
<p class="calibre1">The object oSomeObject contains a set of all the instance variables </p>
<p class="calibre1">defined in the class. Every method of the SomeClass class has a definition </p>
<p class="calibre1">that looks like this:</p>
<p class="calibre1">def someMethod(self,  <i class="calibre4">&lt;any other parameters&gt; </i>):</p>
<p class="calibre1">And here is the general form of a call to such a method:</p>
<p class="calibre1">oSomeObject.someMethod( <i class="calibre4">&lt;any other arguments&gt; </i>)</p>
<p class="calibre1"><b class="calibre3">52</b>   Chapter 3</p>
<p class="calibre1"><a id="p82"/>As we know, Python rearranges the arguments in a call to a method, so that the object is passed in as the first argument. That value is received in the </p>
<p class="calibre1">first parameter of the method and is put into the variable self (Figure 3-4). </p>
<p class="calibre1">def someMethod(self,  <i class="calibre4">&lt;any other parameters&gt; </i>):</p>
<p class="calibre1">oSomeObject.someMethod( <i class="calibre4">&lt;any other arguments&gt; </i>)</p>
<p class="calibre1"> <i class="calibre4">Figure 3-4: How Python rearranges arguments in a call to a method</i></p>
<p class="calibre1">Therefore, whenever a method is called, self will be set to the object </p>
<p class="calibre1">in the call. This means that the code of a method can operate on the </p>
<p class="calibre1">instance variables of  <i class="calibre4">any </i> object instantiated from the class. It does so </p>
<p class="calibre1">using the form:</p>
<p class="calibre1">self.  <i class="calibre4">&lt;instanceVariableName&gt; </i></p>
<p class="calibre1">This essentially says to use the object referred to by self and access </p>
<p class="calibre1">the instance variable specified by &lt;  <i class="calibre4">instanceVariableName</i>&gt;. Since every method uses self as the first parameter, every method in a class uses this </p>
<p class="calibre1">same approach. </p>
<p class="calibre1">To illustrate this concept, let’s use the DimmerSwitch class. In the follow-</p>
<p class="calibre1">ing example, we’ll instantiate two DimmerSwitch objects, then walk through </p>
<p class="calibre1">what happens when we raise the brightness level of these objects by calling </p>
<p class="calibre1">the raiseLevel() method with each. </p>
<p class="calibre1">The code of the method we’re calling is:</p>
<p class="calibre1">def raiseLevel(self):</p>
<p class="calibre1">if self.brightness &lt; 10:</p>
<p class="calibre1">self.brightness = self.brightness + 1</p>
<p class="calibre1">Listing 3-3 shows some example test code for two DimmerSwitch objects. </p>
<p class="calibre1"><b class="calibre3">File: OO_DimmerSwitch_Model2_Method_Cal s.py</b></p>
<p class="calibre1"># Create two DimmerSwitch objects </p>
<p class="calibre1">oDimmer1 = DimmerSwitch('Dimmer1')</p>
<p class="calibre1">oDimmer2 = DimmerSwitch('Dimmer2')</p>
<p class="calibre1"># Tell oDimmer1 to raise its level</p>
<p class="calibre1">oDimmer1.raiseLevel()</p>
<p class="calibre1"># Tell oDimmer2 to raise its level</p>
<p class="calibre1">oDimmer2.raiseLevel()</p>
<p class="calibre1"> <i class="calibre4">Listing 3-3: Cal ing the same method on different DimmerSwitch objects</i></p>
<p class="calibre1">Mental Models of Objects and the Meaning of “self” <b class="calibre3">53</b></p>
<p class="calibre1"><a id="p83"/><img src="index-83_1.png" alt="Image 16" class="calibre2"/></p>
<p class="calibre1">In this listing, we first instantiate two DimmerSwitch objects. Then we have </p>
<p class="calibre1">two calls to the raiseLevel() method: first we call it with oDimmer1, then we </p>
<p class="calibre1">call the same method using oDimmer2. </p>
<p class="calibre1">Figure 3-5 shows the result of running the test code in Listing 3-3 </p>
<p class="calibre1">in Python Tutor, with execution stopped while making the first call to </p>
<p class="calibre1">raiseLevel(). </p>
<p class="calibre1"> <i class="calibre4">Figure 3-5: The program in Listing 3-3 stopped in call to oDimmer1.raiseLevel()</i> Notice that self and oDimmer1 refer to the same object. When the </p>
<p class="calibre1">method executes and uses any self.&lt;  <i class="calibre4">instanceVariable</i>&gt;, it will use oDimmer1’s instance variables. Therefore, when this method runs, self.brightness refers </p>
<p class="calibre1">to the brightness instance variable in oDimmer1. </p>
<p class="calibre1">If we continue to execute the test code in Listing 3-3, we get to the sec-</p>
<p class="calibre1">ond call to raiseLevel() with oDimmer2. In Figure 3-6, I’ve stopped execution </p>
<p class="calibre1">inside this method call. </p>
<p class="calibre1">Notice that this time, self refers to the same object as oDimmer2. Now, </p>
<p class="calibre1">self.brightness refers to the brightness instance variable of oDimmer2. </p>
<p class="calibre1">No matter what object we use or which method we call, the value of </p>
<p class="calibre1">the object is assigned to the variable self in the called method. You should </p>
<p class="calibre1">think of self as meaning the current object—the object that the method </p>
<p class="calibre1">was called with. Whenever a method executes, it uses the set of instance </p>
<p class="calibre1">variables for the object specified in the call. </p>
<p class="calibre1"><b class="calibre3">54</b>   Chapter 3</p>
<p class="calibre1"><a id="p84"/><img src="index-84_1.png" alt="Image 17" class="calibre2"/></p>
<p class="calibre1"> <i class="calibre4">Figure 3-6: The program in Listing 3-3 stopped in call to oDimmer2.raiseLevel()</i> <b class="calibre3">Summary</b></p>
<p class="calibre1">In this chapter, I presented two different ways of thinking about objects. </p>
<p class="calibre1">These mental models should help in developing a basic understanding of </p>
<p class="calibre1">what happens when you instantiate multiple instances of an object from a </p>
<p class="calibre1">class. </p>
<p class="calibre1">The first model showed how you can think of an object as having a set </p>
<p class="calibre1">of all the instance variables and all the methods of a class wrapped up in a </p>
<p class="calibre1">nice bundle. </p>
<p class="calibre1">The second model went into much greater detail about the implementa-</p>
<p class="calibre1">tion, explaining that the code of a class exists only in one place. An impor-</p>
<p class="calibre1">tant takeaway is that creating new objects from a class is space-efficient. </p>
<p class="calibre1">When you create a new instance of an object, Python allocates memory to </p>
<p class="calibre1">represent the instance variables defined in the class. No duplicates of the </p>
<p class="calibre1">class’s code are made or required. </p>
<p class="calibre1">The key to how methods work with multiple objects is that the first </p>
<p class="calibre1">parameter of all methods, self, is always set to the object used in a call to </p>
<p class="calibre1">that method. With this approach, every method uses the instance variables </p>
<p class="calibre1">for the current object. </p>
<p class="calibre1">Mental Models of Objects and the Meaning of “self” <b class="calibre3">55</b></p>
<p class="calibre1"><a id="p85"/>
<a id="p86"/><b class="calibre3">4</b></p>
<p class="calibre1"><b class="calibre3">M A N A G I N G   M U L T I P L E   O B J E C T S</b></p>
<p class="calibre1">This chapter will show you techniques for </p>
<p class="calibre1">managing any number of objects instanti-</p>
<p class="calibre1">ated from the same class. I’ll first go through </p>
<p class="calibre1">an OOP implementation of the bank account </p>
<p class="calibre1">example from <a href="index_split_000.html#p32">Chapter 1. T</a>he OOP approach allows </p>
<p class="calibre1">the data and code of an account to be at the same </p>
<p class="calibre1">level, eliminating the need to depend on global data. </p>
<p class="calibre1">Then, I’ll split the program into main code that </p>
<p class="calibre1">provides a top-level menu and a separate Bank object </p>
<p class="calibre1">that manages accounts, in addition to any number of </p>
<p class="calibre1">Account objects. We’ll also discuss a better way of han-</p>
<p class="calibre1">dling errors using exceptions. </p>
<p class="calibre1"><a id="p87"/><b class="calibre3">Bank Account Class</b></p>
<p class="calibre1">Our bank account class will need, at a minimum, a name, password, </p>
<p class="calibre1">and balance as its data. For behaviors, the user must be able to create an </p>
<p class="calibre1">account, deposit and withdraw money, and check their balance. </p>
<p class="calibre1">We’ll define and initialize the variables for the name, password, and </p>
<p class="calibre1">balance, and build methods to implement each of the operations. We </p>
<p class="calibre1">should then be able to instantiate any number of Account objects. Like the </p>
<p class="calibre1">initial class fro<a href="index_split_000.html#p32">m Chapter 1, t</a>his is a simplified Account class that only uses integers for the balance and keeps the password in cleartext. While you </p>
<p class="calibre1">wouldn’t use simplifications like these in a real banking application, they </p>
<p class="calibre1">will allow us to concentrate on the OOP aspects involved. </p>
<p class="calibre1">The new code for the Account class is presented in Listing 4-1. </p>
<p class="calibre1"><b class="calibre3">File: Account.py</b></p>
<p class="calibre1"># Account class</p>
<p class="calibre1">class Account():</p>
<p class="calibre1">1 def __init__(self, name, balance, password):</p>
<p class="calibre1">self.name = name</p>
<p class="calibre1">self.balance = int(balance)</p>
<p class="calibre1">self.password = password</p>
<p class="calibre1"/>
<p class="calibre1">2 def deposit(self, amountToDeposit, password):</p>
<p class="calibre1">if password != self.password:</p>
<p class="calibre1">print('Sorry, incorrect password')</p>
<p class="calibre1">return None</p>
<p class="calibre1">if amountToDeposit &lt; 0:</p>
<p class="calibre1">print('You cannot deposit a negative amount')</p>
<p class="calibre1">return None</p>
<p class="calibre1">self.balance = self.balance + amountToDeposit</p>
<p class="calibre1">return self.balance</p>
<p class="calibre1"/>
<p class="calibre1">3 def withdraw(self, amountToWithdraw, password):</p>
<p class="calibre1">if password != self.password:</p>
<p class="calibre1">print('Incorrect password for this account')</p>
<p class="calibre1">return None</p>
<p class="calibre1">if amountToWithdraw &lt; 0:</p>
<p class="calibre1">print('You cannot withdraw a negative amount')</p>
<p class="calibre1">return None</p>
<p class="calibre1">if amountToWithdraw &gt; self.balance:</p>
<p class="calibre1">print('You cannot withdraw more than you have in your account')</p>
<p class="calibre1">return None</p>
<p class="calibre1">self.balance = self.balance - amountToWithdraw</p>
<p class="calibre1">return self.balance</p>
<p class="calibre1"><b class="calibre3">58</b>   Chapter 4</p>
<p class="calibre1"><a id="p88"/> 4 def getBalance(self, password):</p>
<p class="calibre1">if password != self.password:</p>
<p class="calibre1">print('Sorry, incorrect password')</p>
<p class="calibre1">return None</p>
<p class="calibre1">return self.balance</p>
<p class="calibre1"># Added for debugging</p>
<p class="calibre1">5 def show(self):</p>
<p class="calibre1">print('       Name:', self.name)</p>
<p class="calibre1">print('       Balance:', self.balance)</p>
<p class="calibre1">print('       Password:', self.password)</p>
<p class="calibre1">print()</p>
<p class="calibre1"> <i class="calibre4">Listing 4-1: A minimal Account class </i></p>
<p class="calibre1"><b class="calibre3">N O T E </b> <i class="calibre4"> </i></p>
<p class="calibre1"> <i class="calibre4">The error handling in Listing 4-1 is very simple. If we find an error condition, we</i> <i class="calibre4">print an error message and return a special value of None. Later in the chapter, I will</i> <i class="calibre4">show a better way of handling errors. </i></p>
<p class="calibre1">Notice how these methods manipulate and remember data. Data is </p>
<p class="calibre1">passed into each method through parameters, which are local variables that </p>
<p class="calibre1">only exist while the method is running. Data is remembered in instance </p>
<p class="calibre1">variables, which have object scope and therefore remember their values </p>
<p class="calibre1">across calls to different methods. </p>
<p class="calibre1">First we have the __init__() method 1, with three parameters. When </p>
<p class="calibre1">an object is created from this class, three pieces of data are required: name, </p>
<p class="calibre1">balance, and password. The instantiation might look like this:</p>
<p class="calibre1">oAccount = Account('Joe Schmoe', 1000, 'magic')</p>
<p class="calibre1">When we instantiate the object, the values of the three arguments are </p>
<p class="calibre1">passed into the __init__() method, which in turn assigns these values to the </p>
<p class="calibre1">similarly named instance variables: self.name, self.balance, and self.password. </p>
<p class="calibre1">We’ll access these instance variables in the other methods. </p>
<p class="calibre1">The deposit() method 2 lets the user make a deposit into an account. </p>
<p class="calibre1">After instantiating an Account object and saving it in oAccount, we could call </p>
<p class="calibre1">the deposit() method like this:</p>
<p class="calibre1">newBalance = oAccount.deposit(500, 'magic')</p>
<p class="calibre1">This call says to deposit $500 and gives the password “magic”. The </p>
<p class="calibre1">method performs two validity checks on the deposit request. The first </p>
<p class="calibre1">ensures that the password is correct by testing the password provided in the </p>
<p class="calibre1">call against the password set when the Account object was created. This is a </p>
<p class="calibre1">good example of how the original password saved in the instance variable </p>
<p class="calibre1">self.password is used. The second validity check makes sure we aren’t depos-</p>
<p class="calibre1">iting a negative amount (which would actually be a withdrawal). </p>
<p class="calibre1">If either of those tests fails, for now we return the special value None </p>
<p class="calibre1">to show that some error occurred. If both tests pass, we increment the </p>
<p class="calibre1">instance variable self.balance by the amount of the deposit. Because the </p>
<p class="calibre1">Managing Multiple Objects   <b class="calibre3">59</b></p>
<p class="calibre1"><a id="p89"/>balance is stored in self.balance, it is remembered and is available for future calls. Finally, we return the new balance. </p>
<p class="calibre1">The withdraw() method 3 works in a very similar way and would be </p>
<p class="calibre1">called like this:</p>
<p class="calibre1">oAccount.withdraw(250, 'magic')</p>
<p class="calibre1">The withdraw() method checks that we’ve supplied the proper password </p>
<p class="calibre1">by verifying it against the instance variable self.password. It also checks that </p>
<p class="calibre1">we’re not asking to withdraw a negative amount or more than we have in the </p>
<p class="calibre1">account, using the instance variable self.balance. Once those tests pass, the </p>
<p class="calibre1">method decrements self.balance by the amount to withdraw. It returns the </p>
<p class="calibre1">resulting balance. </p>
<p class="calibre1">To check the balance 4, we only need to supply the proper password </p>
<p class="calibre1">for the account:</p>
<p class="calibre1">currentBalance = oAccount.getBalance('magic')</p>
<p class="calibre1">If the password supplied matches the one saved in the instance variable </p>
<p class="calibre1">self.password, the method returns the value in self.balance. </p>
<p class="calibre1">Finally, for debugging, we added a show() method 5 to display the </p>
<p class="calibre1">current values of self.name, self.balance, and self.password saved for the </p>
<p class="calibre1">account. </p>
<p class="calibre1">The Account class is our first example of representing something that </p>
<p class="calibre1">is not a physical object. A bank account is not something that you can see, </p>
<p class="calibre1">feel, or touch. However, it fits perfectly into the world of computer objects </p>
<p class="calibre1">because it has data (name, balance, password) and actions that work on </p>
<p class="calibre1">that data (create, deposit, withdraw, get balance, show). </p>
<p class="calibre1"><b class="calibre3">Importing Class Code</b></p>
<p class="calibre1">There are two ways to use a class you’ve built in your own code. As we’ve </p>
<p class="calibre1">seen in previous chapters, the simplest way is to place all the code of the </p>
<p class="calibre1">class directly in the main Python source file. But doing so makes it difficult </p>
<p class="calibre1">to reuse a class. </p>
<p class="calibre1">A second approach is to place the code of the class in a file by itself </p>
<p class="calibre1">and import it into a program that uses it. We’ve placed all the code for our </p>
<p class="calibre1">Account class in  <i class="calibre4">Account.py</i>, but if we try to run  <i class="calibre4">Account.py</i> by itself, nothing happens, because it’s just the definition of a class. To use our class code, we </p>
<p class="calibre1">must instantiate one or more objects and make calls to the object’s meth-</p>
<p class="calibre1">ods. As our classes become larger and more complicated, saving each of </p>
<p class="calibre1">them as a separate file is the preferred way to work with them. </p>
<p class="calibre1">To use our Account class, we must build another  <i class="calibre4">.py</i> file and import the </p>
<p class="calibre1">code from  <i class="calibre4">Account.py</i>, as we do with other built-in packages like random and time. Often, Python programmers name the main program that imports </p>
<p class="calibre1">other class files  <i class="calibre4">main.py</i> or  <i class="calibre4">Main_&lt;SomeName&gt;.py</i>. We must then ensure that  <i class="calibre4">Account.py</i> and the main program file are in the same folder. At the </p>
<p class="calibre1"><b class="calibre3">60</b>   Chapter 4</p>
<p class="calibre1"><a id="p90"/>beginning of the main program, we bring in the Account code by starting with an import statement (notice that we leave off the  <i class="calibre4">*.py</i> file extension): from Account import *</p>
<p class="calibre1">Using the import statement with an asterisk (*) brings in the entire con-</p>
<p class="calibre1">tents of the imported file. An imported file can contain multiple classes. In </p>
<p class="calibre1">this case, where possible, you should specify the specific class or classes that </p>
<p class="calibre1">you want to import, rather than importing the whole file. Here’s the syntax </p>
<p class="calibre1">for importing particular classes:</p>
<p class="calibre1">from  <i class="calibre4">&lt;ExternalFile&gt; </i> import  <i class="calibre4">&lt;ClassName1&gt;, &lt;ClassName2&gt;, ... </i></p>
<p class="calibre1">There are two benefits to importing class code:</p>
<p class="calibre1">1.  The module is reusable, so if we want to use  <i class="calibre4">Account.py</i> in some other </p>
<p class="calibre1">project, we just need to make a copy of the file and place it into that </p>
<p class="calibre1">project’s folder. Reusing code in this way is a staple of object-oriented </p>
<p class="calibre1">programming. </p>
<p class="calibre1">2.  If your class code is included in the main program, every time you run </p>
<p class="calibre1">the program, Python compiles all the code in your class (translates it </p>
<p class="calibre1">into a lower-level language that is more easily runnable on your com-</p>
<p class="calibre1">puter), even if you have not made any changes to the class. </p>
<p class="calibre1">However, when you run your main program with your class code </p>
<p class="calibre1">imported, Python optimizes the compile step without you having to </p>
<p class="calibre1">do anything. It creates a folder named  <i class="calibre4">__pycache__</i> in the project folder, </p>
<p class="calibre1">then compiles the code in your class file and saves the compiled code </p>
<p class="calibre1">in the  <i class="calibre4">__pycache__</i> folder with a variant of the original Python filename. </p>
<p class="calibre1">For example, for the  <i class="calibre4">Account.py </i> file, Python will create a file using the </p>
<p class="calibre1">name  <i class="calibre4">Account.cpython-39.pyc</i> (or similar, based on the version of Python </p>
<p class="calibre1">you are using). The  <i class="calibre4">.pyc</i> extension stands for  <i class="calibre4">Python Compiled</i>. Python only recompiles your class file if the source of the class file changes. If </p>
<p class="calibre1">the source of your  <i class="calibre4">Account.py</i> has not changed, Python knows it doesn't </p>
<p class="calibre1">need to recompile it and can more efficiently use the  <i class="calibre4">.pyc</i> version of the </p>
<p class="calibre1">file instead. </p>
<p class="calibre1"><b class="calibre3">Creating Some Test Code</b></p>
<p class="calibre1">We’ll test our new class with four main programs. The first will create Account </p>
<p class="calibre1">objects using separately named variables. The second stores the objects in a </p>
<p class="calibre1">list, while the third stores the account numbers and objects in a dictionary. </p>
<p class="calibre1">Finally, the fourth version will split the functionality so we have a main pro-</p>
<p class="calibre1">gram that responds to the user and a Bank object that manages the different </p>
<p class="calibre1">accounts. </p>
<p class="calibre1">In each example, the main program imports  <i class="calibre4">Account.py</i>. Your project </p>
<p class="calibre1">folder should contain the main program and the  <i class="calibre4">Account.py</i> file. In the </p>
<p class="calibre1">Managing Multiple Objects   <b class="calibre3">61</b></p>
<p class="calibre1"><a id="p91"/>following discussion, the different versions of the main program will be named  <i class="calibre4">Main_Bank_VersionX.py</i>, where  <i class="calibre4">X</i> represents the version number <i class="calibre4">. </i></p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Creating Multiple Accounts</b></i></p>
<p class="calibre1">In this first version, we’ll create two example accounts and populate them </p>
<p class="calibre1">with viable data for testing. We’ll save each account in an explicitly named </p>
<p class="calibre1">variable representing the object. </p>
<p class="calibre1"><b class="calibre3">File: BankOOP1_IndividualVariables/Main_Bank_Version1.py</b></p>
<p class="calibre1"># Test program using accounts</p>
<p class="calibre1"># Version 1, using explicit variables for each Account object</p>
<p class="calibre1"># Bring in all the code from the Account class file</p>
<p class="calibre1">from Account import *</p>
<p class="calibre1"># Create two accounts</p>
<p class="calibre1">1 oJoesAccount = Account('Joe', 100, 'JoesPassword')</p>
<p class="calibre1">print("Created an account for Joe")</p>
<p class="calibre1">2 oMarysAccount = Account('Mary', 12345, 'MarysPassword')</p>
<p class="calibre1">print("Created an account for Mary")</p>
<p class="calibre1">3 oJoesAccount.show()</p>
<p class="calibre1">oMarysAccount.show()</p>
<p class="calibre1">print()</p>
<p class="calibre1"># Call some methods on the different accounts</p>
<p class="calibre1">print('Calling methods of the two accounts ...')</p>
<p class="calibre1">4 oJoesAccount.deposit(50, 'JoesPassword')</p>
<p class="calibre1">oMarysAccount.withdraw(345, 'MarysPassword')</p>
<p class="calibre1">oMarysAccount.deposit(100, 'MarysPassword')</p>
<p class="calibre1"># Show the accounts</p>
<p class="calibre1">oJoesAccount.show()</p>
<p class="calibre1">oMarysAccount.show()</p>
<p class="calibre1"> <i class="calibre4">Listing 4-2: A main program to test the Account class </i></p>
<p class="calibre1">We create an account for Joe 1 and an account for Mary 2, and we </p>
<p class="calibre1">store the results into two Account objects. We then call the show() method for </p>
<p class="calibre1">the accounts to demonstrate that they were created correctly 3. Joe depos-</p>
<p class="calibre1">its $50. Mary makes a withdrawal of $345 and then deposits $100 4. If we </p>
<p class="calibre1">run the program now, this will be our output:</p>
<p class="calibre1">Created an account for Joe</p>
<p class="calibre1">Created an account for Mary</p>
<p class="calibre1">Name: Joe</p>
<p class="calibre1">Balance: 100</p>
<p class="calibre1">Password: JoesPassword</p>
<p class="calibre1">Name: Mary</p>
<p class="calibre1"><b class="calibre3">62</b>   Chapter 4</p>
<p class="calibre1"><a id="p92"/>       Balance: 12345</p>
<p class="calibre1">Password: MarysPassword</p>
<p class="calibre1">Calling methods of the two accounts ... </p>
<p class="calibre1">Name: Joe</p>
<p class="calibre1">Balance: 150</p>
<p class="calibre1">Password: JoesPassword</p>
<p class="calibre1">Name: Mary</p>
<p class="calibre1">Balance: 12100</p>
<p class="calibre1">Password: MarysPassword</p>
<p class="calibre1">Now we’ll extend the test program to create a third account interac-</p>
<p class="calibre1">tively by asking for some input from the user. Listing 4-3 shows the code </p>
<p class="calibre1">for this. </p>
<p class="calibre1"># Create another account with information from the user</p>
<p class="calibre1">print()</p>
<p class="calibre1">userName = input('What is the name for the new user account? ') 1 </p>
<p class="calibre1">userBalance = input('What is the starting balance for this account? ')</p>
<p class="calibre1">userBalance = int(userBalance)</p>
<p class="calibre1">userPassword = input('What is the password you want to use for this account? ')</p>
<p class="calibre1">oNewAccount = Account(userName, userBalance, userPassword) 2</p>
<p class="calibre1"># Show the newly created user account</p>
<p class="calibre1">oNewAccount.show() 3</p>
<p class="calibre1"># Let's deposit 100 into the new account</p>
<p class="calibre1">oNewAccount.deposit(100, userPassword) 4</p>
<p class="calibre1">usersBalance = oNewAccount.getBalance(userPassword)</p>
<p class="calibre1">print()</p>
<p class="calibre1">print('After depositing 100, the user's balance is:', usersBalance)</p>
<p class="calibre1"># Show the new account</p>
<p class="calibre1">oNewAccount.show()</p>
<p class="calibre1"> <i class="calibre4">Listing 4-3: An extension of the test program to create an account on the fly </i></p>
<p class="calibre1">This test code asks the user for a name, a starting balance, and a pass-</p>
<p class="calibre1">word 1. It uses these values to create a new account, and we store the newly </p>
<p class="calibre1">created object in the variable oNewAccount 2. We then call the show() method </p>
<p class="calibre1">on the new object 3. We deposit $100 into the account and retrieve the new </p>
<p class="calibre1">balance by calling the getBalance() method 4. When we run the full pro-</p>
<p class="calibre1">gram, we get the output from Listing 4-2, as well as the following output:</p>
<p class="calibre1">What is the name for the new user account? Irv</p>
<p class="calibre1">What is the starting balance for this account? 777</p>
<p class="calibre1">What is the password you want to use for this account? IrvsPassword</p>
<p class="calibre1">Name: Irv</p>
<p class="calibre1">Balance: 777</p>
<p class="calibre1">Password: IrvsPassword</p>
<p class="calibre1">After depositing 100, the user's balance is: 877</p>
<p class="calibre1">Managing Multiple Objects   <b class="calibre3">63</b></p>
<p class="calibre1"><a id="p93"/>       Name: Irv</p>
<p class="calibre1">Balance: 877</p>
<p class="calibre1">Password: IrvsPassword</p>
<p class="calibre1">The key thing to notice here is that each Account object maintains its </p>
<p class="calibre1">own set of instance variables. Each object (oJoesAccount, oMarysAccount, and </p>
<p class="calibre1">oNewAccount) is a global variable that contains a collection of three instance </p>
<p class="calibre1">variables. If we were to expand our definition of the Account class to include </p>
<p class="calibre1">information such as address, telephone number, and date of birth, each </p>
<p class="calibre1">object would get a set of these additional instance variables. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Multiple Account Objects in a List</b></i></p>
<p class="calibre1">Representing each account in a separate global variable works, but this is not </p>
<p class="calibre1">a good approach when we need to handle a large number of objects. A bank </p>
<p class="calibre1">would need a way to handle an arbitrary number of accounts. Whenever we </p>
<p class="calibre1">need an arbitrary number of pieces of data, a list is the typical solution. </p>
<p class="calibre1">In this version of the test code, we’ll start with an empty list of Account </p>
<p class="calibre1">objects. Every time a user opens an account, we’ll instantiate an Account </p>
<p class="calibre1">object and append the resulting object onto our list. The account number </p>
<p class="calibre1">for any given account will be the index of the account in the list, starting </p>
<p class="calibre1">with 0. Again, we’ll start by creating a test account for Joe and one for Mary, </p>
<p class="calibre1">as shown in Listing 4-4. </p>
<p class="calibre1"><b class="calibre3">File: BankOOP2_ListOfAccountObjects/Main_Bank_Version2.py</b></p>
<p class="calibre1"># Test program using accounts</p>
<p class="calibre1"># Version 2, using a list of accounts</p>
<p class="calibre1"># Bring in all the code from the Account class file</p>
<p class="calibre1">from Account import *</p>
<p class="calibre1"># Start off with an empty list of accounts</p>
<p class="calibre1">accountsList = [ ] 1 </p>
<p class="calibre1"># Create two accounts</p>
<p class="calibre1">oAccount = Account('Joe', 100, 'JoesPassword') 2</p>
<p class="calibre1">accountsList.append(oAccount)</p>
<p class="calibre1">print("Joe's account number is 0")</p>
<p class="calibre1">oAccount = Account('Mary', 12345, 'MarysPassword') 3</p>
<p class="calibre1">accountsList.append(oAccount)</p>
<p class="calibre1">print("Mary's account number is 1")</p>
<p class="calibre1">accountsList[0].show() 4</p>
<p class="calibre1">accountsList[1].show()</p>
<p class="calibre1">print()</p>
<p class="calibre1"># Call some methods on the different accounts</p>
<p class="calibre1">print('Calling methods of the two accounts ...')</p>
<p class="calibre1">accountsList[0].deposit(50, 'JoesPassword') 5</p>
<p class="calibre1">accountsList[1].withdraw(345, 'MarysPassword') 6</p>
<p class="calibre1"><b class="calibre3">64</b>   Chapter 4</p>
<p class="calibre1"><a id="p94"/>accountsList[1].deposit(100, 'MarysPassword') 7</p>
<p class="calibre1"># Show the accounts</p>
<p class="calibre1">accountsList[0].show() 8</p>
<p class="calibre1">accountsList[1].show()</p>
<p class="calibre1"># Create another account with information from the user</p>
<p class="calibre1">print()</p>
<p class="calibre1">userName = input('What is the name for the new user account? ')</p>
<p class="calibre1">userBalance = input('What is the starting balance for this account? ')</p>
<p class="calibre1">userBalance = int(userBalance)</p>
<p class="calibre1">userPassword = input('What is the password you want to use for this account? ')</p>
<p class="calibre1">oAccount = Account(userName, userBalance, userPassword)</p>
<p class="calibre1">accountsList.append(oAccount)  # append to list of accounts</p>
<p class="calibre1"># Show the newly created user account</p>
<p class="calibre1">print('Created new account, account number is 2')</p>
<p class="calibre1">accountsList[2].show()</p>
<p class="calibre1"># Let's deposit 100 into the new account</p>
<p class="calibre1">accountsList[2].deposit(100, userPassword)</p>
<p class="calibre1">usersBalance = accountsList[2].getBalance(userPassword)</p>
<p class="calibre1">print()</p>
<p class="calibre1">print('After depositing 100, the user's balance is:', usersBalance)</p>
<p class="calibre1"># Show the new account</p>
<p class="calibre1">accountsList[2].show()</p>
<p class="calibre1"> <i class="calibre4">Listing 4-4: Modified test code to store objects in a list </i></p>
<p class="calibre1">We start by creating an empty list of accounts 1. We create an account </p>
<p class="calibre1">for Joe, store the returned value into the variable oAccount, and immediately </p>
<p class="calibre1">append that object onto our list of accounts 2. Since this is the first account </p>
<p class="calibre1">in the list, Joe’s account number is 0. Like at a real bank, any time that Joe </p>
<p class="calibre1">wants to do any transactions with his account, he supplies his account num-</p>
<p class="calibre1">ber. We use his account number to show the balance of his account 4, make </p>
<p class="calibre1">a deposit 5, then show the balance again 8. We also create an account for </p>
<p class="calibre1">Mary with account number 1 3 and perform some test operations on her </p>
<p class="calibre1">account at 6 and 7. </p>
<p class="calibre1">The results are identical to the test code from Listing 4-3. However, </p>
<p class="calibre1">there is one highly significant difference between the two test programs: </p>
<p class="calibre1">now there is only the single global variable accountsList. Each account has a </p>
<p class="calibre1">unique account number, which we use to access a specific account. We have </p>
<p class="calibre1">taken an important step in reducing the number of global variables. </p>
<p class="calibre1">Another important thing to note here is that we made some fairly major </p>
<p class="calibre1">changes to the main program, but we did not touch anything in the Account </p>
<p class="calibre1">class file. OOP often allows you to hide details at different levels. If we assume </p>
<p class="calibre1">that the code of the Account class takes care of details related to an individual </p>
<p class="calibre1">account, we can concentrate on ways to make the main code better. </p>
<p class="calibre1">Notice also that we’re using the variable oAccount as a  <i class="calibre4">temporary</i> variable. </p>
<p class="calibre1">That is, whenever we create a new Account object, we are assigning the result </p>
<p class="calibre1">to the variable oAccount. Right after doing that, we append oAccount to our </p>
<p class="calibre1">Managing Multiple Objects   <b class="calibre3">65</b></p>
<p class="calibre1"><a id="p95"/>list of accounts. We never use the variable oAccount in calls to any method of a specific Account object. That way, we can reuse the variable oAccount to </p>
<p class="calibre1">receive the value of the next account that is created. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Multiple Objects with Unique Identifiers</b></i></p>
<p class="calibre1">The Account objects must be individually identifiable so each user can make </p>
<p class="calibre1">deposits and withdrawals and get the balance of their specific account. </p>
<p class="calibre1">Using a list for our bank accounts works, but there’s a serious flaw. Imagine </p>
<p class="calibre1">we have five accounts, numbered 0, 1, 2, 3, and 4. If the person who owns </p>
<p class="calibre1">account 2 decides to close their account, we’d likely use a standard pop() </p>
<p class="calibre1">operation on the list to delete account 2. This would cause a domino effect: </p>
<p class="calibre1">the account that was in position 3 is now in position 2, and the account that </p>
<p class="calibre1">was in position 4 is now in position 3. However, the users of these accounts </p>
<p class="calibre1">still have their original account numbers, 3 and 4. As a result, the customer </p>
<p class="calibre1">who owns account 3 will now get the information for the previous account </p>
<p class="calibre1">4, and account number 4 is now an invalid index. </p>
<p class="calibre1">To handle large numbers of objects with unique identifiers, we generally </p>
<p class="calibre1">use a dictionary. Unlike a list, a dictionary will allow us to delete accounts </p>
<p class="calibre1">without altering the account numbers associated with them. We build each </p>
<p class="calibre1">key/value pair with an account number as the key and an Account object as the </p>
<p class="calibre1">value. That way, if we need to eliminate a given account, no other account is </p>
<p class="calibre1">affected. A dictionary of accounts would look like this:</p>
<p class="calibre1">{0 :  <i class="calibre4">&lt;object for account 0&gt; </i>, 1 :  <i class="calibre4">&lt;object for account 1&gt; </i>, ... }</p>
<p class="calibre1">We can then easily get the associated Account object and call a method </p>
<p class="calibre1">like this:</p>
<p class="calibre1">oAccount = accountsDict[accountNumber]</p>
<p class="calibre1">oAccount.someMethodCall()</p>
<p class="calibre1">Alternatively, we could use the accountNumber directly to make a call to a </p>
<p class="calibre1">method of an individual Account:</p>
<p class="calibre1">accountsDict[accountNumber].someMethodCall()</p>
<p class="calibre1">Listing 4-5 shows the test code using a dictionary of Account objects. </p>
<p class="calibre1">Again, while we’re making many changes to our test code, we’re not chang-</p>
<p class="calibre1">ing a single line in the Account class. In our test code, rather than using </p>
<p class="calibre1">hardcoded account numbers, we add a counter, nextAccountNumber, that we’ll </p>
<p class="calibre1">increment after creating a new Account. </p>
<p class="calibre1"><b class="calibre3">File: BankOOP3_DictionaryOfAccountObjects/Main_Bank_Version3.py</b></p>
<p class="calibre1"># Test program using accounts</p>
<p class="calibre1"># Version 3, using a dictionary of accounts</p>
<p class="calibre1"># Bring in all the code from the Account class file</p>
<p class="calibre1">from Account import *</p>
<p class="calibre1"><b class="calibre3">66</b>   Chapter 4</p>
<p class="calibre1"><a id="p96"/>accountsDict = {} 1 </p>
<p class="calibre1">nextAccountNumber = 0 2 </p>
<p class="calibre1"># Create two accounts:</p>
<p class="calibre1">oAccount = Account('Joe', 100, 'JoesPassword')</p>
<p class="calibre1">joesAccountNumber = nextAccountNumber</p>
<p class="calibre1">accountsDict[joesAccountNumber] = oAccount 3 </p>
<p class="calibre1">print('Account number for Joe is:', joesAccountNumber)</p>
<p class="calibre1">nextAccountNumber = nextAccountNumber + 1 4</p>
<p class="calibre1">oAccount = Account('Mary', 12345, 'MarysPassword')</p>
<p class="calibre1">marysAccountNumber = nextAccountNumber</p>
<p class="calibre1">accountsDict[marysAccountNumber] = oAccount 5</p>
<p class="calibre1">print('Account number for Mary is:', marysAccountNumber)</p>
<p class="calibre1">nextAccountNumber = nextAccountNumber + 1</p>
<p class="calibre1">accountsDict[joesAccountNumber].show()</p>
<p class="calibre1">accountsDict[marysAccountNumber].show()</p>
<p class="calibre1">print()</p>
<p class="calibre1"># Call some methods on the different accounts</p>
<p class="calibre1">print('Calling methods of the two accounts ...')</p>
<p class="calibre1">accountsDict[joesAccountNumber].deposit(50, 'JoesPassword')</p>
<p class="calibre1">accountsDict[marysAccountNumber].withdraw(345, 'MarysPassword')</p>
<p class="calibre1">accountsDict[marysAccountNumber].deposit(100, 'MarysPassword')</p>
<p class="calibre1"># Show the accounts</p>
<p class="calibre1">accountsDict[joesAccountNumber].show()</p>
<p class="calibre1">accountsDict[marysAccountNumber].show()</p>
<p class="calibre1"># Create another account with information from the user</p>
<p class="calibre1">print()</p>
<p class="calibre1">userName = input('What is the name for the new user account? ')</p>
<p class="calibre1">userBalance = input('What is the starting balance for this account? ')</p>
<p class="calibre1">userBalance = int(userBalance)</p>
<p class="calibre1">userPassword = input('What is the password you want to use for this account? ')</p>
<p class="calibre1">oAccount = Account(userName, userBalance, userPassword)</p>
<p class="calibre1">newAccountNumber = nextAccountNumber</p>
<p class="calibre1">accountsDict[newAccountNumber] = oAccount</p>
<p class="calibre1">print('Account number for new account is:', newAccountNumber)</p>
<p class="calibre1">nextAccountNumber = nextAccountNumber + 1</p>
<p class="calibre1"># Show the newly created user account</p>
<p class="calibre1">accountsDict[newAccountNumber].show()</p>
<p class="calibre1"># Let's deposit 100 into the new account</p>
<p class="calibre1">accountsDict[newAccountNumber].deposit(100, userPassword)</p>
<p class="calibre1">usersBalance = accountsDict[newAccountNumber].getBalance(userPassword)</p>
<p class="calibre1">print()</p>
<p class="calibre1">print('After depositing 100, the user's balance is:', usersBalance)</p>
<p class="calibre1"># Show the new account</p>
<p class="calibre1">accountsDict[newAccountNumber].show()</p>
<p class="calibre1"> <i class="calibre4">Listing 4-5: Modified test code to store account numbers and objects in a dictionary</i> Managing Multiple Objects   <b class="calibre3">67</b></p>
<p class="calibre1"><a id="p97"/>Running this code yields results almost identical to those of the previous examples. We start with an empty dictionary of accounts 1, and initial-</p>
<p class="calibre1">ize our nextAccountNumber variable to 0 2. Every time we instantiate a new </p>
<p class="calibre1">account, we add a new entry into the dictionary of accounts using the cur-</p>
<p class="calibre1">rent value of nextAccountNumber as a key and the Account object as the value 3. </p>
<p class="calibre1">We do this for each customer, as you can see for Mary 5. Every time we </p>
<p class="calibre1">create a new account, we increment nextAccountNumber to prepare for the next </p>
<p class="calibre1">account 4. With account numbers as keys in a dictionary, if a customer </p>
<p class="calibre1">closes their account, we can eliminate that key and value from the diction-</p>
<p class="calibre1">ary without affecting any other accounts. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Building an Interactive Menu</b></i></p>
<p class="calibre1">With our Account class working correctly, we’ll make the main code interac-</p>
<p class="calibre1">tive by asking the user to tell us what operation they would like to do: get </p>
<p class="calibre1">the balance, make a deposit, make a withdrawal, or open a new account. In </p>
<p class="calibre1">response, our main code will gather the needed information from the user, </p>
<p class="calibre1">starting with their account number, and call the appropriate method of the </p>
<p class="calibre1">user’s Account object. </p>
<p class="calibre1">As a shortcut, we will again prepopulate two accounts, one for Joe and </p>
<p class="calibre1">one for Mary. Listing 4-6 shows our expanded main code, which uses a dic-</p>
<p class="calibre1">tionary to keep track of all the accounts. I’ve omitted the code that creates </p>
<p class="calibre1">the accounts for Joe and Mary and adds those to the dictionary of accounts </p>
<p class="calibre1">for brevity, as it’s the same as in Listing 4-5. </p>
<p class="calibre1"><b class="calibre3">File: BankOOP4_InteractiveMenu/Main_Bank_Version4.py</b></p>
<p class="calibre1"># Interactive test program creating a dictionary of accounts</p>
<p class="calibre1"># Version 4, with an interactive menu</p>
<p class="calibre1">from Account import *</p>
<p class="calibre1">accountsDict = {}</p>
<p class="calibre1">nextAccountNumber = 0</p>
<p class="calibre1">--- snip creating accounts, adding them to dictionary ---</p>
<p class="calibre1">while True:</p>
<p class="calibre1">print()</p>
<p class="calibre1">print('Press b to get the balance')</p>
<p class="calibre1">print('Press d to make a deposit')</p>
<p class="calibre1">print('Press o to open a new account')</p>
<p class="calibre1">print('Press w to make a withdrawal')</p>
<p class="calibre1">print('Press s to show all accounts')</p>
<p class="calibre1">print('Press q to quit')</p>
<p class="calibre1">print()</p>
<p class="calibre1">action = input('What do you want to do? ') 1</p>
<p class="calibre1">action = action.lower()</p>
<p class="calibre1">action = action[0]  # grab the first letter</p>
<p class="calibre1"><b class="calibre3">68</b>   Chapter 4</p>
<p class="calibre1"><a id="p98"/>    print()</p>
<p class="calibre1"/>
<p class="calibre1">if action == 'b':</p>
<p class="calibre1">print('*** Get Balance ***')</p>
<p class="calibre1">userAccountNumber = input('Please enter your account number: ')</p>
<p class="calibre1">userAccountNumber = int(userAccountNumber)</p>
<p class="calibre1">userAccountPassword = input('Please enter the password: ')</p>
<p class="calibre1">oAccount = accountsDict[userAccountNumber]</p>
<p class="calibre1">theBalance = oAccount.getBalance(userAccountPassword)</p>
<p class="calibre1">if theBalance is not None:</p>
<p class="calibre1">print('Your balance is:', theBalance)</p>
<p class="calibre1">elif action == 'd': 2</p>
<p class="calibre1">print('*** Deposit ***')</p>
<p class="calibre1">userAccountNumber = input('Please enter the account number: ') 3 </p>
<p class="calibre1">userAccountNumber = int(userAccountNumber)</p>
<p class="calibre1">userDepositAmount = input('Please enter amount to deposit: ')</p>
<p class="calibre1">userDepositAmount = int(userDepositAmount)</p>
<p class="calibre1">userPassword = input('Please enter the password: ')</p>
<p class="calibre1">oAccount = accountsDict[userAccountNumber] 4</p>
<p class="calibre1">theBalance = oAccount.deposit(userDepositAmount, userPassword) 5</p>
<p class="calibre1">if theBalance is not None:</p>
<p class="calibre1">print('Your new balance is:', theBalance)</p>
<p class="calibre1"/>
<p class="calibre1">elif action == 'o':</p>
<p class="calibre1">print('*** Open Account ***')</p>
<p class="calibre1">userName = input('What is the name for the new user account? ')</p>
<p class="calibre1">userStartingAmount = input('What is the starting balance for this account? ')</p>
<p class="calibre1">userStartingAmount = int(userStartingAmount)</p>
<p class="calibre1">userPassword = input('What is the password you want to use for this account? ')</p>
<p class="calibre1">oAccount = Account(userName, userStartingAmount, userPassword)</p>
<p class="calibre1">accountsDict[nextAccountNumber] = oAccount</p>
<p class="calibre1">print('Your new account number is:', nextAccountNumber)</p>
<p class="calibre1">nextAccountNumber = nextAccountNumber + 1</p>
<p class="calibre1">print()</p>
<p class="calibre1">elif action == 's':</p>
<p class="calibre1">print('Show:')</p>
<p class="calibre1">for userAccountNumber in accountsDict:</p>
<p class="calibre1">oAccount = accountsDict[userAccountNumber]</p>
<p class="calibre1">print('    Account number:', userAccountNumber)       </p>
<p class="calibre1">oAccount.show()</p>
<p class="calibre1">elif action == 'q':</p>
<p class="calibre1">break</p>
<p class="calibre1">elif action == 'w':</p>
<p class="calibre1">print('*** Withdraw ***')</p>
<p class="calibre1">userAccountNumber = input('Please enter your account number: ')</p>
<p class="calibre1">userAccountNumber = int(userAccountNumber)</p>
<p class="calibre1">userWithdrawalAmount = input('Please enter the amount to withdraw: ')</p>
<p class="calibre1">userWithdrawalAmount = int(userWithdrawalAmount)</p>
<p class="calibre1">userPassword = input('Please enter the password: ')</p>
<p class="calibre1">oAccount = accountsDict[userAccountNumber]</p>
<p class="calibre1">theBalance = oAccount.withdraw(userWithdrawalAmount, userPassword)</p>
<p class="calibre1">Managing Multiple Objects   <b class="calibre3">69</b></p>
<p class="calibre1"><a id="p99"/>        if theBalance is not None:</p>
<p class="calibre1">print('Withdrew:', userWithdrawalAmount)</p>
<p class="calibre1">print('Your new balance is:', theBalance)</p>
<p class="calibre1">else:</p>
<p class="calibre1">print('Sorry, that was not a valid action. Please try again.')</p>
<p class="calibre1">print('Done')</p>
<p class="calibre1"> <i class="calibre4">Listing 4-6: Adding an interactive menu</i></p>
<p class="calibre1">In this version, we present the user with a menu of options. When the user </p>
<p class="calibre1">selects an action 1, the code asks questions about the intended transaction </p>
<p class="calibre1">to gather all the information we need to make the call to the user’s account. </p>
<p class="calibre1">For example, if the user wants to make a deposit 2, the program asks for the </p>
<p class="calibre1">account number, the amount to deposit, and the password for the account 3. </p>
<p class="calibre1">We use the account number as a key into the dictionary of Account objects </p>
<p class="calibre1">to get the appropriate Account object 4. With that object, we then call the </p>
<p class="calibre1">deposit() method, passing in the amount to deposit and the user’s password 5. </p>
<p class="calibre1">Once again, we have modified code at the main code level, and left our </p>
<p class="calibre1">Account class untouched. </p>
<p class="calibre1"><b class="calibre3">Creating an Object Manager Object</b></p>
<p class="calibre1">The code in Listing 4-6 is actually doing two different things. The program </p>
<p class="calibre1">first provides a simple menu interface. Then, when an action is chosen, it </p>
<p class="calibre1">collects data and makes a call to a method of an Account object. Rather than </p>
<p class="calibre1">having one large main program that does two different tasks, we can split </p>
<p class="calibre1">this code into two smaller logical units, each with a clearly defined role. </p>
<p class="calibre1">The menuing system becomes the main code that decides what action to </p>
<p class="calibre1">take, and the rest of the code deals with the things a bank actually does. </p>
<p class="calibre1">The bank can be modeled as an object that manages other (account) </p>
<p class="calibre1">objects, known as an  <i class="calibre4">object manager object</i>. </p>
<p class="calibre1"><b class="calibre3">object manag </b> <b class="calibre3">er   </b>An object that maintains a list or dictionary of managed objects (typical y of a single <b class="calibre3">object </b>class) and cal s methods of those objects . </p>
<p class="calibre1">This split can be made easily and logically: we take all the code related </p>
<p class="calibre1">to the bank and put it into a new Bank class. Then, at the beginning of the </p>
<p class="calibre1">main program, we instantiate a single Bank object from the new Bank class. </p>
<p class="calibre1">The Bank class will manage a list or dictionary of Account objects. In this </p>
<p class="calibre1">way, the Bank object will be the only code that communicates directly with </p>
<p class="calibre1">Account objects (Figure 4-1). </p>
<p class="calibre1">To create this hierarchy, we need some main code that handles the </p>
<p class="calibre1">highest-level menuing system. In response to a choice of action, the main code </p>
<p class="calibre1">will call a method of the Bank object (for example, deposit() or withdraw()). The </p>
<p class="calibre1">Bank object will gather the information it needs (account number, password, </p>
<p class="calibre1">amount to deposit or withdraw), reach into its dictionary of accounts to find </p>
<p class="calibre1"><b class="calibre3">70</b>   Chapter 4</p>
<p class="calibre1"><a id="p100"/>the matching user account, and call the appropriate method for that user’s account. </p>
<p class="calibre1">Main code</p>
<p class="calibre1">Bank object</p>
<p class="calibre1">Account</p>
<p class="calibre1">Account</p>
<p class="calibre1">Account</p>
<p class="calibre1">object</p>
<p class="calibre1">object</p>
<p class="calibre1">object</p>
<p class="calibre1">…</p>
<p class="calibre1">Account</p>
<p class="calibre1">object</p>
<p class="calibre1"> <i class="calibre4">Figure 4-1: The main code manages a Bank object, which manages  </i></p>
<p class="calibre1"> <i class="calibre4">many Account objects. </i></p>
<p class="calibre1">There are three layers in this division of labor:</p>
<p class="calibre1">1.  The main code that creates and talks to a single Bank object</p>
<p class="calibre1">2. The </p>
<p class="calibre1">Bank object that manages a dictionary of Account objects and calls </p>
<p class="calibre1">methods of those objects</p>
<p class="calibre1">3. The </p>
<p class="calibre1">Account objects themselves</p>
<p class="calibre1">With this approach, we only have a single global variable, the Bank </p>
<p class="calibre1">object. In fact, the main code has no idea that Account objects even exist. </p>
<p class="calibre1">Conversely, each Account object has no clue (and does not care) what the </p>
<p class="calibre1">top-level user interface of the program is. The Bank object receives messages </p>
<p class="calibre1">from the main code and communicates with the appropriate Account object. </p>
<p class="calibre1">The key advantage of this approach is that we have broken down a </p>
<p class="calibre1">much larger program into smaller subprograms: in this case, the main code </p>
<p class="calibre1">and two classes. This makes it much easier to program each piece, since </p>
<p class="calibre1">the scope of work is smaller and the responsibilities are clearer for each. </p>
<p class="calibre1">Further, having only a single global variable ensures that lower-level code </p>
<p class="calibre1">will not accidentally affect data at the global level. </p>
<p class="calibre1">In computer literature, the construct shown in Figure 4-1 is often </p>
<p class="calibre1">known as  <i class="calibre4">composition</i> or  <i class="calibre4">object composition</i>. </p>
<p class="calibre1"><b class="calibre3">composition</b> </p>
<p class="calibre1">A logical structure in which one object manages one or more other objects</p>
<p class="calibre1">You can think of one object as being made up of other objects. An </p>
<p class="calibre1">example is that a car object is made up of an engine object, a steering wheel </p>
<p class="calibre1">object, some number of door objects, four wheel and tire objects, and so </p>
<p class="calibre1">on. The discussion often centers around the relationships between objects. </p>
<p class="calibre1">In this example, one would say that a car “has a” steering wheel, an engine, </p>
<p class="calibre1">some number of doors, and so on. Therefore, the car object is a composite </p>
<p class="calibre1">of other objects. </p>
<p class="calibre1">Managing Multiple Objects   <b class="calibre3">71</b></p>
<p class="calibre1"><a id="p101"/>We’ll have three separate files. The main code lives in its own file. </p>
<p class="calibre1">It imports the code of our new  <i class="calibre4">Bank.py</i> file that contains the Bank class </p>
<p class="calibre1">(Listing 4-7). The Bank class imports the code of the  <i class="calibre4">Account.py</i> file and </p>
<p class="calibre1">uses it to instantiate Account objects as needed. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Building the Object Manager Object</b></i></p>
<p class="calibre1">Listing 4-7 shows the code of the new Bank class, which is an object manager </p>
<p class="calibre1">object. </p>
<p class="calibre1"><b class="calibre3">File: BankOOP5_SeparateBankClass/Bank.py</b></p>
<p class="calibre1"># Bank that manages a dictionary of Account objects</p>
<p class="calibre1">from Account import *</p>
<p class="calibre1">class Bank():</p>
<p class="calibre1">def __init__(self):</p>
<p class="calibre1">self.accountsDict = {} 1</p>
<p class="calibre1">self.nextAccountNumber = 0</p>
<p class="calibre1">def createAccount(self, theName, theStartingAmount, thePassword): 2</p>
<p class="calibre1">oAccount = Account(theName, theStartingAmount, thePassword)</p>
<p class="calibre1">newAccountNumber = self.nextAccountNumber</p>
<p class="calibre1">self.accountsDict[newAccountNumber] = oAccount</p>
<p class="calibre1"># Increment to prepare for next account to be created</p>
<p class="calibre1">self.nextAccountNumber = self.nextAccountNumber + 1</p>
<p class="calibre1">return newAccountNumber</p>
<p class="calibre1">def openAccount(self): 3</p>
<p class="calibre1">print('*** Open Account ***')</p>
<p class="calibre1">userName = input('What is the name for the new user account? ')</p>
<p class="calibre1">userStartingAmount = input('What is the starting balance for this account? ')</p>
<p class="calibre1">userStartingAmount = int(userStartingAmount)</p>
<p class="calibre1">userPassword = input('What is the password you want to use for this account? ')</p>
<p class="calibre1">userAccountNumber = self.createAccount(userName, userStartingAmount, userPassword) 4</p>
<p class="calibre1">print('Your new account number is:', userAccountNumber)</p>
<p class="calibre1">print()</p>
<p class="calibre1">def closeAccount(self): 5</p>
<p class="calibre1">print('*** Close Account ***')</p>
<p class="calibre1">userAccountNumber = input('What is your account number? ')</p>
<p class="calibre1">userAccountNumber = int(userAccountNumber)</p>
<p class="calibre1">userPassword = input('What is your password? ')</p>
<p class="calibre1">oAccount = self.accountsDict[userAccountNumber]</p>
<p class="calibre1">theBalance = oAccount.getBalance(userPassword)</p>
<p class="calibre1">if theBalance is not None:</p>
<p class="calibre1">print('You had', theBalance, 'in your account, which is being returned to you.')</p>
<p class="calibre1"># Remove user's account from the dictionary of accounts</p>
<p class="calibre1">del self.accountsDict[userAccountNumber]</p>
<p class="calibre1">print('Your account is now closed.')</p>
<p class="calibre1"><b class="calibre3">72</b>   Chapter 4</p>
<p class="calibre1"><a id="p102"/>    def balance(self):</p>
<p class="calibre1">print('*** Get Balance ***')</p>
<p class="calibre1">userAccountNumber = input('Please enter your account number: ')</p>
<p class="calibre1">userAccountNumber = int(userAccountNumber)</p>
<p class="calibre1">userAccountPassword = input('Please enter the password: ')</p>
<p class="calibre1">oAccount = self.accountsDict[userAccountNumber]</p>
<p class="calibre1">theBalance = oAccount.getBalance(userAccountPassword)</p>
<p class="calibre1">if theBalance is not None:</p>
<p class="calibre1">print('Your balance is:', theBalance)</p>
<p class="calibre1">def deposit(self):</p>
<p class="calibre1">print('*** Deposit ***')</p>
<p class="calibre1">accountNum = input('Please enter the account number: ')</p>
<p class="calibre1">accountNum = int(accountNum)</p>
<p class="calibre1">depositAmount = input('Please enter amount to deposit: ')</p>
<p class="calibre1">depositAmount = int(depositAmount)</p>
<p class="calibre1">userAccountPassword = input('Please enter the password: ')</p>
<p class="calibre1">oAccount = self.accountsDict[accountNum]        </p>
<p class="calibre1">theBalance = oAccount.deposit(depositAmount, userAccountPassword)</p>
<p class="calibre1">if theBalance is not None:</p>
<p class="calibre1">print('Your new balance is:', theBalance)</p>
<p class="calibre1">def show(self):</p>
<p class="calibre1">print('*** Show ***')</p>
<p class="calibre1">for userAccountNumber in self.accountsDict:</p>
<p class="calibre1">oAccount = self.accountsDict[userAccountNumber]</p>
<p class="calibre1">print('    Account:', userAccountNumber)</p>
<p class="calibre1">oAccount.show()</p>
<p class="calibre1">def withdraw(self):</p>
<p class="calibre1">print('*** Withdraw ***')</p>
<p class="calibre1">userAccountNumber = input('Please enter your account number: ')</p>
<p class="calibre1">userAccountNumber = int(userAccountNumber)</p>
<p class="calibre1">userAmount = input('Please enter the amount to withdraw: ')</p>
<p class="calibre1">userAmount = int(userAmount)</p>
<p class="calibre1">userAccountPassword = input('Please enter the password: ')</p>
<p class="calibre1">oAccount = self.accountsDict[userAccountNumber]</p>
<p class="calibre1">theBalance = oAccount.withdraw(userAmount, userAccountPassword)</p>
<p class="calibre1">if theBalance is not None: </p>
<p class="calibre1">print('Withdrew:', userAmount)</p>
<p class="calibre1">print('Your new balance is:', theBalance)</p>
<p class="calibre1"> <i class="calibre4">Listing 4-7: The Bank class with separate methods for different bank operations</i> I’ll focus on the most important things to notice in the Bank class. </p>
<p class="calibre1">First, in its __init__() method, Bank initializes two variables: self.accountsDict </p>
<p class="calibre1">and self.nextAccountNumber 1. The prefix self. designates these as instance vari-</p>
<p class="calibre1">ables, meaning the Bank class can refer to these variables in any of its methods. </p>
<p class="calibre1">Second, there are two methods for creating an account: createAccount() </p>
<p class="calibre1">and openAccount(). The createAccount() method instantiates a new account 2 </p>
<p class="calibre1">with the user’s name, a starting amount, and a password passed in for the </p>
<p class="calibre1">new account. The openAccount() method asks the user questions to obtain </p>
<p class="calibre1">these three pieces of information 3 and calls the createAccount() method </p>
<p class="calibre1">within the same class. </p>
<p class="calibre1">Managing Multiple Objects   <b class="calibre3">73</b></p>
<p class="calibre1"><a id="p103"/>Having one method call another method in the same class is common. </p>
<p class="calibre1">But the called method doesn’t know whether it was called from inside or </p>
<p class="calibre1">outside the class; it only knows that the first argument is the object on </p>
<p class="calibre1">which it should run. Therefore, the call to the method must start with self., </p>
<p class="calibre1">because self always refers to the current object. Generically, to call from </p>
<p class="calibre1">one method to another method in the same class we need to write:</p>
<p class="calibre1">def myMethod(self,  <i class="calibre4">&lt;other optional parameters&gt; </i>):</p>
<p class="calibre1">... </p>
<p class="calibre1">self.methodInSameClass( <i class="calibre4">&lt;any needed arguments&gt; </i>)</p>
<p class="calibre1">After collecting information from the user for openAccount(), we have </p>
<p class="calibre1">this line 4:</p>
<p class="calibre1">userAccountNumber = self.createAccount(userName, userStartingAmount, userPassword)</p>
<p class="calibre1">Here, openAccount() calls createAccount() from the same class to cre-</p>
<p class="calibre1">ate the account. The createAccount() method runs, instantiates an Account </p>
<p class="calibre1">object, and returns an account number to openAccount(), which returns that </p>
<p class="calibre1">account number back to the user. </p>
<p class="calibre1">Finally, the new method closeAccount() allows the user to close an </p>
<p class="calibre1">existing account 5. This is an extra piece of functionality we’ll offer from </p>
<p class="calibre1">our main code. </p>
<p class="calibre1">Our Bank class represents an abstract view of a bank rather than the </p>
<p class="calibre1">physical brick-and-mortar object. This is another good example of a class </p>
<p class="calibre1">that does not represent a physical structure. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Main Code That Creates an Object Manager Object</b></i></p>
<p class="calibre1">The main code that creates and makes calls to the Bank object is shown in </p>
<p class="calibre1">Listing 4-8. </p>
<p class="calibre1"><b class="calibre3">File: BankOOP5_SeparateBankClass/Main_Bank_Version5.py</b></p>
<p class="calibre1"># Main program for controlling a Bank made up of Accounts</p>
<p class="calibre1"># Bring in all the code of the Bank class</p>
<p class="calibre1">from Bank import *</p>
<p class="calibre1"># Create an instance of the Bank</p>
<p class="calibre1">oBank = Bank()</p>
<p class="calibre1"># Main code</p>
<p class="calibre1"># Create two test accounts</p>
<p class="calibre1">joesAccountNumber = oBank.createAccount('Joe', 100, 'JoesPassword')</p>
<p class="calibre1">print("Joe's account number is:", joesAccountNumber)</p>
<p class="calibre1">marysAccountNumber = oBank.createAccount('Mary', 12345, 'MarysPassword')</p>
<p class="calibre1">print("Mary's account number is:", marysAccountNumber)</p>
<p class="calibre1">while True:</p>
<p class="calibre1">print()</p>
<p class="calibre1"><b class="calibre3">74</b>   Chapter 4</p>
<p class="calibre1"><a id="p104"/>    print('To get an account balance, press b')</p>
<p class="calibre1">print('To close an account, press c')</p>
<p class="calibre1">print('To make a deposit, press d')</p>
<p class="calibre1">print('To open a new account, press o')</p>
<p class="calibre1">print('To quit, press q')</p>
<p class="calibre1">print('To show all accounts, press s')</p>
<p class="calibre1">print('To make a withdrawal, press w ')</p>
<p class="calibre1">print()</p>
<p class="calibre1">1 action = input('What do you want to do? ')</p>
<p class="calibre1">action = action.lower()</p>
<p class="calibre1">action = action[0]  # grab the first letter</p>
<p class="calibre1">print()</p>
<p class="calibre1"/>
<p class="calibre1">2 if action == 'b':</p>
<p class="calibre1">oBank.balance()</p>
<p class="calibre1">3 elif action == 'c':</p>
<p class="calibre1">oBank.closeAccount()</p>
<p class="calibre1">elif action == 'd':</p>
<p class="calibre1">oBank.deposit()</p>
<p class="calibre1"/>
<p class="calibre1">elif action == 'o':</p>
<p class="calibre1">oBank.openAccount()</p>
<p class="calibre1">elif action == 's':</p>
<p class="calibre1">oBank.show()</p>
<p class="calibre1">elif action == 'q':</p>
<p class="calibre1">break</p>
<p class="calibre1">elif action == 'w':</p>
<p class="calibre1">oBank.withdraw()</p>
<p class="calibre1">else:</p>
<p class="calibre1">print('Sorry, that was not a valid action. Please try again.')</p>
<p class="calibre1"/>
<p class="calibre1">print('Done')</p>
<p class="calibre1"> <i class="calibre4">Listing 4-8: The main code that creates a Bank object and makes cal s to it</i></p>
<p class="calibre1">Notice how the code in Listing 4-8 presents the top-level menuing sys-</p>
<p class="calibre1">tem. It asks the user for an action 1, then calls an appropriate method in </p>
<p class="calibre1">the Bank object to do the work 2. You could easily extend the Bank object </p>
<p class="calibre1">to handle some additional queries, like asking for the bank’s hours, or </p>
<p class="calibre1">address, or phone number. That data could simply be kept as additional </p>
<p class="calibre1">instance variables inside the Bank object. The Bank would answer those ques-</p>
<p class="calibre1">tions without needing to communicate with any Account object. </p>
<p class="calibre1">When a close request is made 3, the main code calls the closeAccount() </p>
<p class="calibre1">method of the Bank object to close the account. The Bank object removes the </p>
<p class="calibre1">specific account from its dictionary of accounts using a line like this:</p>
<p class="calibre1">del self.accountsDict[userAccountNumber]</p>
<p class="calibre1">Managing Multiple Objects   <b class="calibre3">75</b></p>
<p class="calibre1"><a id="p105"/>Recall that our definition of an object is data, plus code that acts on that data, over time. The ability to delete an object demonstrates the third </p>
<p class="calibre1">part of our definition of an object. We can create an object (in this case an </p>
<p class="calibre1">Account object) whenever we want, not just when a program starts. In this </p>
<p class="calibre1">program, we create a new Account object whenever a user decides to open an </p>
<p class="calibre1">account. Our code can use that object by calling its methods. We can also </p>
<p class="calibre1">delete an object at any time, in this case, when a user chooses to close their </p>
<p class="calibre1">account. This is an example of how an object (like an Account object) has a </p>
<p class="calibre1">life span, from whenever it is created it to whenever it is deleted. </p>
<p class="calibre1"><b class="calibre3">Better Error Handling with Exceptions</b></p>
<p class="calibre1">So far in our Account class, if a method detects an error (for example, if the </p>
<p class="calibre1">user deposits a negative amount, enters an incorrect password, withdraws a </p>
<p class="calibre1">negative amount, and so on) our placeholder solution is to return None as a </p>
<p class="calibre1">signal that something went wrong. In this section, we’ll discuss a better way </p>
<p class="calibre1">of handling errors by using try/except blocks and raising exceptions. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">try and except</b></i></p>
<p class="calibre1">When a runtime error or abnormal condition occurs in a function or </p>
<p class="calibre1">method from the Python Standard Library, that function or method sig-</p>
<p class="calibre1">nals the error by raising an exception (sometimes referred to as  <i class="calibre4">throwing</i> or <i class="calibre4">generating</i> an exception). We can detect and react to exceptions using the </p>
<p class="calibre1">try/except construct. Here is the general form:</p>
<p class="calibre1">try:   </p>
<p class="calibre1"># some code that may cause an error (raise an exception)</p>
<p class="calibre1">except  <i class="calibre4">&lt;some exception name&gt; </i>:  # if an exception happens</p>
<p class="calibre1"># some code to handle the exception</p>
<p class="calibre1">If the code inside the try block works correctly and does not generate </p>
<p class="calibre1">an exception, the except clause is skipped, and execution continues after </p>
<p class="calibre1">the except block. However, if the code in the try block results in an excep-</p>
<p class="calibre1">tion, control is passed to the except statement. If the exception matches the </p>
<p class="calibre1">exception (or one of multiple exceptions) listed in the except statement, </p>
<p class="calibre1">control is transferred to the code of the except clause. This is often referred </p>
<p class="calibre1">to as  <i class="calibre4">catching</i> the exception. That indented block typically contains code to report and/or recover from the error. </p>
<p class="calibre1">Here is a simple example where we ask for a number from the user and </p>
<p class="calibre1">attempt to convert it to an integer:</p>
<p class="calibre1">age = input('Please enter your age: ')</p>
<p class="calibre1">try:  # attempt to convert to integer</p>
<p class="calibre1">age = int(age)</p>
<p class="calibre1">except ValueError:  # if an exception is raised trying to convert</p>
<p class="calibre1">print('Sorry, that was not a valid number')</p>
<p class="calibre1"><b class="calibre3">76</b>   Chapter 4</p>
<p class="calibre1"><a id="p106"/>Calls to the Python Standard Library can generate standard exceptions such as TypeError, ValueError, NameError, ZeroDivisionError, and so on. In this </p>
<p class="calibre1">example, if the user enters letters or a floating-point number, the built-in </p>
<p class="calibre1">int() function raises a ValueError exception, and control is transferred to the </p>
<p class="calibre1">code in the except block. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">The raise Statement and Custom Exceptions</b></i></p>
<p class="calibre1">If your code detects a runtime error condition, you can use the raise state-</p>
<p class="calibre1">ment to signal an exception. There are many forms of the raise statement, </p>
<p class="calibre1">but the standard approach is to use this syntax:</p>
<p class="calibre1">raise  <i class="calibre4">&lt;ExceptionName&gt; </i>('  <i class="calibre4">&lt;Any string to describe the error&gt; </i>') For the  <i class="calibre4">&lt;ExceptionName&gt; </i>, you have three options. First, if there is a standard exception that matches the error you have detected (TypeError, </p>
<p class="calibre1">ValueError, NameError, ZeroDivisionError, and so on), it’s fine to use that. You </p>
<p class="calibre1">can also add your own description string:</p>
<p class="calibre1">raise ValueError('You need to specify an integer')</p>
<p class="calibre1">Second, you can use the generic Exception exception:</p>
<p class="calibre1">raise Exception('The amount cannot be a floating-point number')</p>
<p class="calibre1">However, this is generally frowned upon because the standard practice </p>
<p class="calibre1">is to write except statements to look for exceptions by name, and this does </p>
<p class="calibre1">not provide a specific name. </p>
<p class="calibre1">A third choice, and perhaps the best, is to create your own custom </p>
<p class="calibre1">exception. This is easy to do, but involves a technique called inheritance </p>
<p class="calibre1">(which we will discuss at length i<a href="index_split_004.html#p240">n Chapter 10)</a>. Here is all you need to create your own exception:</p>
<p class="calibre1"># Define a custom exception</p>
<p class="calibre1">class  <i class="calibre4">&lt;CustomExceptionName&gt; </i>(Exception):</p>
<p class="calibre1">pass</p>
<p class="calibre1">You supply a unique name for your exception. You can then raise your </p>
<p class="calibre1">custom exception in your code. Creating your own exceptions means you </p>
<p class="calibre1">can explicitly check for these exceptions by name in a higher level of your </p>
<p class="calibre1">code. In the next section, we’ll rewrite the code of our bank example so </p>
<p class="calibre1">that we raise a custom exception in our Bank and Account classes and check </p>
<p class="calibre1">for and report the error in the main code. The main code will report the </p>
<p class="calibre1">error but allow the program to continue running. </p>
<p class="calibre1">In the typical case, the raise statement causes the current function or </p>
<p class="calibre1">method to exit and transfers control back to the caller. If the caller contains </p>
<p class="calibre1">an except clause that catches the exception, execution continues inside that </p>
<p class="calibre1">except clause. Otherwise, that function or method exits. This process is </p>
<p class="calibre1">Managing Multiple Objects   <b class="calibre3">77</b></p>
<p class="calibre1"><a id="p107"/>repeated until an except clause catches the exception. Control is transferred back through the sequence of calls, and if no except clause catches the </p>
<p class="calibre1">exception, the program quits and Python displays the error. </p>
<p class="calibre1"><b class="calibre3">Using Exceptions in Our Bank Program</b></p>
<p class="calibre1">We can now rewrite all three levels of our program (main, Bank, and Account) </p>
<p class="calibre1">to signal errors with raise statements and to handle errors using try/except </p>
<p class="calibre1">blocks. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Account Class with Exceptions</b></i></p>
<p class="calibre1">Listing 4-9 is a new version of the Account class rewritten to use exceptions </p>
<p class="calibre1">and optimized so that no code is repeated. We start by defining a custom </p>
<p class="calibre1">AbortTransaction exception, which will be raised if we discover some error </p>
<p class="calibre1">while a user is attempting to do a transaction in our bank. </p>
<p class="calibre1"><b class="calibre3">File: BankOOP6_UsingExceptions/Account.py (modified to work with upcoming Bank.py)</b></p>
<p class="calibre1"># Account class</p>
<p class="calibre1"># Errors indicated by "raise" statements</p>
<p class="calibre1"># Define a custom exception</p>
<p class="calibre1">class AbortTransaction(Exception): 1</p>
<p class="calibre1">'''raise this exception to abort a bank transaction''' </p>
<p class="calibre1">pass</p>
<p class="calibre1">class Account():</p>
<p class="calibre1">def __init__(self, name, balance, password):</p>
<p class="calibre1">self.name = name</p>
<p class="calibre1">self.balance = self.validateAmount(balance) 2</p>
<p class="calibre1">self.password = password</p>
<p class="calibre1">def validateAmount(self, amount):</p>
<p class="calibre1">try:</p>
<p class="calibre1">amount = int(amount)</p>
<p class="calibre1">except ValueError:</p>
<p class="calibre1">raise AbortTransaction('Amount must be an integer') 3</p>
<p class="calibre1">if amount &lt;= 0:</p>
<p class="calibre1">raise AbortTransaction('Amount must be positive') 4</p>
<p class="calibre1">return amount</p>
<p class="calibre1">def checkPasswordMatch(self, password): 5</p>
<p class="calibre1">if password != self.password:</p>
<p class="calibre1">raise AbortTransaction('Incorrect password for this account')</p>
<p class="calibre1">def deposit(self, amountToDeposit): 6</p>
<p class="calibre1">amountToDeposit = self.validateAmount(amountToDeposit)</p>
<p class="calibre1">self.balance = self.balance + amountToDeposit</p>
<p class="calibre1">return self.balance</p>
<p class="calibre1">def getBalance(self):</p>
<p class="calibre1"><b class="calibre3">78</b>   Chapter 4</p>
<p class="calibre1"><a id="p108"/>        return self.balance</p>
<p class="calibre1"/>
<p class="calibre1">def withdraw(self, amountToWithdraw): 7</p>
<p class="calibre1">amountToWithdraw = self.validateAmount(amountToWithdraw)</p>
<p class="calibre1">if amountToWithdraw &gt; self.balance:</p>
<p class="calibre1">raise AbortTransaction('You cannot withdraw more than you have in your account')</p>
<p class="calibre1">self.balance = self.balance - amountToWithdraw</p>
<p class="calibre1">return self.balance</p>
<p class="calibre1"># Added for debugging</p>
<p class="calibre1">def show(self):</p>
<p class="calibre1">print('       Name:', self.name)</p>
<p class="calibre1">print('       Balance:', self.balance)</p>
<p class="calibre1">print('       Password:', self.password)</p>
<p class="calibre1"> <i class="calibre4">Listing 4-9: A modified Account class that raises exceptions </i></p>
<p class="calibre1">We start by defining our custom AbortTransaction exception 1 so we can </p>
<p class="calibre1">use it in this class and in other code that imports this class. </p>
<p class="calibre1">In the __init__() method of the Account class, we ensure that the amount </p>
<p class="calibre1">provided as the starting balance is valid by calling validateAmount() 2. This </p>
<p class="calibre1">method uses a try/except block to ensure that the starting amount can </p>
<p class="calibre1">successfully be converted to an integer. If the call to int() fails, it raises a </p>
<p class="calibre1">ValueError exception, which is caught in the except clause. Rather than just </p>
<p class="calibre1">allowing the generic ValueError to be returned to the caller, the code of </p>
<p class="calibre1">this except block 3 executes a raise statement, raising our AbortTransaction </p>
<p class="calibre1">exception, and includes a more meaningful error message string. If the con-</p>
<p class="calibre1">version to an integer succeeds, we perform another test. If the user gave a </p>
<p class="calibre1">negative amount, we also raise the AbortTransaction exception 4, but with a </p>
<p class="calibre1">different error message string. </p>
<p class="calibre1">The checkPasswordMatch() method 5 is called by methods in the Bank </p>
<p class="calibre1">object to check if the password supplied by the user matches the password </p>
<p class="calibre1">saved in the Account. If not, we execute another raise statement with the </p>
<p class="calibre1">same exception, but we supply a more descriptive error message string. </p>
<p class="calibre1">This allows the code of deposit() 6 and withdraw() 7 to be simplified, </p>
<p class="calibre1">because these methods assume that the amount has been validated and </p>
<p class="calibre1">the password verified before they are invoked. There is an additional check </p>
<p class="calibre1">in withdraw() to ensure that the user is not trying to withdraw more money </p>
<p class="calibre1">than is in the account; if so, we raise the AbortTransaction exception with an </p>
<p class="calibre1">appropriate description. </p>
<p class="calibre1">Since there is no code in this class to handle an AbortTransaction excep-</p>
<p class="calibre1">tion, any time one is raised, control is passed back to the caller. If the caller </p>
<p class="calibre1">has no code to handle the exception, then control is passed back to the pre-</p>
<p class="calibre1">vious caller, and so on up the stack of calls. As we’ll see, our main code will </p>
<p class="calibre1">handle this exception. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Optimized Bank Class  </b></i></p>
<p class="calibre1">The full Bank class code is available for download. In Listing 4-10 I show </p>
<p class="calibre1">some sample methods that demonstrate try/except techniques with calls to </p>
<p class="calibre1">methods in the previously updated Account class. </p>
<p class="calibre1">Managing Multiple Objects   <b class="calibre3">79</b></p>
<p class="calibre1"><a id="p109"/><b class="calibre3">File: BankOOP6_UsingExceptions/Bank.py (modified to work with previous Account.py)</b></p>
<p class="calibre1"># Bank that manages a dictionary of Account objects</p>
<p class="calibre1">from Account import *</p>
<p class="calibre1">class Bank():</p>
<p class="calibre1">def __init__(self, hours, address, phone): 1</p>
<p class="calibre1">self.accountsDict = {}</p>
<p class="calibre1">self.nextAccountNumber = 0</p>
<p class="calibre1">self.hours = hours</p>
<p class="calibre1">self.address = address</p>
<p class="calibre1">self.phone = phone</p>
<p class="calibre1">def askForValidAccountNumber(self): 2</p>
<p class="calibre1">accountNumber = input('What is your account number? ')</p>
<p class="calibre1">try: 3</p>
<p class="calibre1">accountNumber = int(accountNumber)</p>
<p class="calibre1">except ValueError:</p>
<p class="calibre1">raise AbortTransaction('The account number must be an integer')</p>
<p class="calibre1">if accountNumber not in self.accountsDict:</p>
<p class="calibre1">raise AbortTransaction('There is no account ' + str(accountNumber))</p>
<p class="calibre1">return accountNumber</p>
<p class="calibre1">def getUsersAccount(self): 4 </p>
<p class="calibre1">accountNumber = self.askForValidAccountNumber()</p>
<p class="calibre1">oAccount = self.accountsDict[accountNumber]</p>
<p class="calibre1">self.askForValidPassword(oAccount)</p>
<p class="calibre1">return oAccount</p>
<p class="calibre1">--- snipped additional methods ---</p>
<p class="calibre1">def deposit(self): 5</p>
<p class="calibre1">print('*** Deposit ***')</p>
<p class="calibre1">oAccount = self.getUsersAccount()</p>
<p class="calibre1">depositAmount = input('Please enter amount to deposit: ')</p>
<p class="calibre1">theBalance = oAccount.deposit(depositAmount)</p>
<p class="calibre1">print('Deposited:', depositAmount)</p>
<p class="calibre1">print('Your new balance is:', theBalance)</p>
<p class="calibre1">def withdraw(self): 6</p>
<p class="calibre1">print('*** Withdraw ***')</p>
<p class="calibre1">oAccount = self.getUsersAccount()</p>
<p class="calibre1">userAmount = input('Please enter the amount to withdraw: ')</p>
<p class="calibre1">theBalance = oAccount.withdraw(userAmount)</p>
<p class="calibre1">print('Withdrew:', userAmount)</p>
<p class="calibre1">print('Your new balance is:', theBalance)</p>
<p class="calibre1">def getInfo(self): 7</p>
<p class="calibre1">print('Hours:', self.hours)</p>
<p class="calibre1">print('Address:', self.address)</p>
<p class="calibre1">print('Phone:', self.phone)</p>
<p class="calibre1">print('We currently have', len(self.accountsDict), 'account(s) open.')</p>
<p class="calibre1"><b class="calibre3">80</b>   Chapter 4</p>
<p class="calibre1"><a id="p110"/>    # Special method for Bank administrator only</p>
<p class="calibre1">def show(self):</p>
<p class="calibre1">print('*** Show ***')</p>
<p class="calibre1">print('(This would typically require an admin password)')</p>
<p class="calibre1">for userAccountNumber in self.accountsDict:</p>
<p class="calibre1">oAccount = self.accountsDict[userAccountNumber]</p>
<p class="calibre1">print('Account:', userAccountNumber)</p>
<p class="calibre1">oAccount.show()</p>
<p class="calibre1">print()</p>
<p class="calibre1"> <i class="calibre4">Listing 4-10: The modified Bank class </i></p>
<p class="calibre1">The Bank class starts with the __init__() method 1 that saves all relevant </p>
<p class="calibre1">information in instance variables. </p>
<p class="calibre1">The new askForValidAccountNumber()2 method is called from a number </p>
<p class="calibre1">of other methods to ask the user for an account number and attempts to </p>
<p class="calibre1">verify the given number. First it has a try/except block 3 to ensure that </p>
<p class="calibre1">the number is an integer. If it isn’t, the except block detects the error as a </p>
<p class="calibre1">ValueError exception but reports the error more clearly by raising a custom </p>
<p class="calibre1">AbortTransaction exception  with a descriptive message. Next, it checks to </p>
<p class="calibre1">ensure that the given account number is one that the bank knows about. If </p>
<p class="calibre1">not, it also raises an AbortTransaction exception, but it gives a different error </p>
<p class="calibre1">message string. </p>
<p class="calibre1">The new getUsersAccount() method 4 first calls the previous askForValid </p>
<p class="calibre1">AccountNumber(), then uses the account number to find the appropriate Account </p>
<p class="calibre1">object. Notice that there is no try/except in this method. If an exception </p>
<p class="calibre1">is raised in askForValidAccountNumber() (or in a lower level), this method will </p>
<p class="calibre1">immediately return to its caller. </p>
<p class="calibre1">The deposit() 5 and withdraw() 6 methods call getUsersAccount() in the </p>
<p class="calibre1">same class. Similarly, if their call to getUsersAccount() raises an exception, </p>
<p class="calibre1">the method will exit and pass the exception up the chain to the caller. If all </p>
<p class="calibre1">tests pass, the code of deposit() and withdraw() calls similarly named meth-</p>
<p class="calibre1">ods in the specified Account object to perform the actual transaction. </p>
<p class="calibre1">The getInfo() 7 method reports information about the bank (hours, </p>
<p class="calibre1">address, phone) and doesn’t access any individual account. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Main Code That Handles Exceptions</b></i></p>
<p class="calibre1">Listing 4-11 shows the updated main code, rewritten to handle a custom </p>
<p class="calibre1">exception. This is where any errors that occur are reported to the user. </p>
<p class="calibre1"><b class="calibre3">File: BankOOP6_UsingException/Main_Bank_Version6.py</b></p>
<p class="calibre1"># Main program for controlling a Bank made up of Accounts</p>
<p class="calibre1">from Bank import *</p>
<p class="calibre1"/>
<p class="calibre1"># Create an instance of the Bank</p>
<p class="calibre1">1 oBank = Bank('9 to 5', '123 Main Street, Anytown, USA', '(650) 555-1212')</p>
<p class="calibre1"># Main code</p>
<p class="calibre1">Managing Multiple Objects   <b class="calibre3">81</b></p>
<p class="calibre1"><a id="p111"/>2 while True:</p>
<p class="calibre1">print()</p>
<p class="calibre1">print('To get an account balance, press b')</p>
<p class="calibre1">print('To close an account, press c')</p>
<p class="calibre1">print('To make a deposit, press d')</p>
<p class="calibre1">print('To get bank information, press i')</p>
<p class="calibre1">print('To open a new account, press o')</p>
<p class="calibre1">print('To quit, press q')</p>
<p class="calibre1">print('To show all accounts, press s')</p>
<p class="calibre1">print('To make a withdrawal, press w')</p>
<p class="calibre1">print()</p>
<p class="calibre1">action = input('What do you want to do? ')</p>
<p class="calibre1">action = action.lower()</p>
<p class="calibre1">action = action[0]  # grab the first letter</p>
<p class="calibre1">print()</p>
<p class="calibre1">3 try:</p>
<p class="calibre1">if action == 'b':</p>
<p class="calibre1">oBank.balance()</p>
<p class="calibre1">elif action == 'c':</p>
<p class="calibre1">oBank.closeAccount()</p>
<p class="calibre1">elif action == 'd':</p>
<p class="calibre1">oBank.deposit()</p>
<p class="calibre1">elif action == 'i':</p>
<p class="calibre1">oBank.getInfo()</p>
<p class="calibre1">elif action == 'o':</p>
<p class="calibre1">oBank.openAccount()</p>
<p class="calibre1">elif action == 'q':</p>
<p class="calibre1">break</p>
<p class="calibre1">elif action == 's':</p>
<p class="calibre1">oBank.show()</p>
<p class="calibre1">elif action == 'w':</p>
<p class="calibre1">oBank.withdraw()</p>
<p class="calibre1">4 except AbortTransaction as error:</p>
<p class="calibre1"># Print out the text of the error message</p>
<p class="calibre1">print(error)</p>
<p class="calibre1"/>
<p class="calibre1">print('Done')</p>
<p class="calibre1"> <i class="calibre4">Listing 4-11: The main code that handles errors with try/except </i></p>
<p class="calibre1">The main code starts by creating a single Bank object 1. Then, in a loop, </p>
<p class="calibre1">it presents a top-level menu to the user and asks them what action they wish </p>
<p class="calibre1">to perform 2. It calls an appropriate method for each command. </p>
<p class="calibre1">The important thing in this listing is that we have added a try block </p>
<p class="calibre1">around all the calls to methods with the oBank object 3. That way, if any </p>
</body></html>