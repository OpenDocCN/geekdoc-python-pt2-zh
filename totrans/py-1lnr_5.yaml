- en: '**5'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**5**'
- en: REGULAR EXPRESSIONS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**正则表达式**'
- en: '![Image](Images/comm-1.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/comm-1.jpg)'
- en: Are you an office worker, student, software developer, manager, blogger, researcher,
    author, copywriter, teacher, or self-employed freelancer? Most likely, you’re
    spending many hours in front of your computer, day after day. Improving your daily
    productivity—only by a small fraction of a percentage—will mean a gain of thousands,
    if not tens of thousands, of dollars of productivity and hundreds of hours of
    additional free time over the years.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你是办公室职员、学生、软件开发者、经理、博主、研究员、作家、文案、教师，还是自由职业者？很可能，你每天都在电脑前度过许多小时。如果能稍微提高你的日常工作效率，哪怕只是一个小小的百分比，也能带来数千甚至数万美元的生产力提升，以及数百小时的额外空闲时间。
- en: 'This chapter shows you an undervalued technique that helps master coders be
    more efficient when working with textual data: using regular expressions. This
    chapter shows you 10 ways of using regular expressions to solve everyday problems
    with less effort, time, and energy. Study this chapter about regular expressions
    carefully—it’ll be worth your time!'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向你展示了一种被低估的技术，帮助高级程序员在处理文本数据时更高效：使用正则表达式。本章将展示10种使用正则表达式来解决日常问题的方法，这些方法能节省你大量的时间、精力和工作量。仔细学习本章内容——它会是值得你投入的时间！
- en: '**Finding Basic Textual Patterns in Strings**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**在字符串中查找基本文本模式**'
- en: This section introduces regular expressions using the `re` module and its important
    `re.findall()` function. I’ll start by explaining several basic regular expressions.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了使用`re`模块和其重要的`re.findall()`函数的正则表达式。我将从解释几个基本的正则表达式开始。
- en: '***The Basics***'
  id: totrans-7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基础知识***'
- en: A *regular expression* (*regex*, for short) formally describes a search *pattern*
    that you can use to match sections of text. The simple example in [Figure 5-1](#ch05fig01)
    shows a search of Shakespeare’s text *Romeo and Juliet* for the pattern `Juliet`.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*正则表达式*（简称*regex*）正式描述了一个搜索*模式*，你可以用它来匹配文本的某些部分。[图5-1](#ch05fig01)中的简单示例展示了如何在莎士比亚的《罗密欧与朱丽叶》文本中搜索`Juliet`模式。'
- en: '![images](Images/fig5-1.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![images](Images/fig5-1.jpg)'
- en: '*Figure 5-1: Searching Shakespeare’s* Romeo and Juliet *for the pattern `Juliet`*'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-1：在莎士比亚的《罗密欧与朱丽叶》中搜索模式`Juliet`*'
- en: '[Figure 5-1](#ch05fig01) shows that the most basic regular expression is a
    simple string pattern. The string `''Juliet''` is a perfectly valid regular expression.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5-1](#ch05fig01)展示了最基础的正则表达式是一个简单的字符串模式。字符串`''Juliet''`就是一个完全有效的正则表达式。'
- en: Regular expressions are incredibly powerful, and can do much more than regular
    text search, but they’re built using only a handful of basic commands. Learn these
    basic commands and you’ll be able to understand and write complex regular expressions.
    In this section, we’ll focus on the three most important regex commands that extend
    the functionality of simple search of string patterns in a given text.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式功能强大，能够做的不仅仅是常规的文本搜索，但它们仅由少数几个基本命令构建。掌握这些基本命令，你就能理解并编写复杂的正则表达式。在本节中，我们将重点介绍三条最重要的正则表达式命令，它们扩展了在给定文本中简单字符串模式搜索的功能。
- en: '**The Dot Regex**'
  id: totrans-13
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**点号正则表达式**'
- en: 'First, you need to know how to match an arbitrary character by using the *dot
    regex*, the `.` character. The dot regex matches any character (including whitespace
    characters). You can use it to indicate that you don’t care which character matches,
    as long as *exactly one* matches:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要知道如何使用*点号正则表达式*（`.`字符）来匹配任意字符。点号正则表达式可以匹配任何字符（包括空白字符）。你可以使用它来表示你不在乎匹配的是什么字符，只要*恰好匹配一个*字符即可：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This example uses the `findall()` method of the `re` module. The first argument
    is the regex itself: you search for any string pattern starting with the character
    `''b''`, followed by three arbitrary characters, `...` , followed by the character
    `''k''`. This regex `b...k` matches the word `''block''` but also `''boook''`,
    `''b erk''`, and `''bloek''`. The second parameter to `findall()` is the `text`
    you’re searching. The string variable `text` contains three matching patterns,
    as you can see in the output of the `print` statement.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例使用了`re`模块的`findall()`方法。第一个参数是正则表达式本身：你搜索的是任何以字符`'b'`开头、接着三个任意字符`...`、最后是字符`'k'`的字符串模式。这个正则表达式`b...k`匹配单词`'block'`，但也匹配`'boook'`、`'b
    erk'`和`'bloek'`。`findall()`的第二个参数是你要搜索的`text`文本。字符串变量`text`包含了三个匹配模式，正如你在`print`语句的输出中看到的那样。
- en: '**The Asterisk Regex**'
  id: totrans-17
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**星号正则表达式**'
- en: 'Second, say you want to match text that begins and ends with the character
    `''y''` and an arbitrary number of characters in between. How do you accomplish
    this? You can do by this using the *asterisk regex*, the `*` character. Unlike
    the dot regex, the asterisk regex can’t stand on its own; it modifies the meaning
    of another regex. Consider the following example:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，假设你想匹配以字符`'y'`开头并以字符`'y'`结尾，中间包含任意数量字符的文本。如何实现这一点？你可以使用*星号正则表达式*，即`*`字符。与点号正则表达式不同，星号正则表达式不能单独使用；它需要修饰另一个正则表达式。考虑以下例子：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The asterisk operator applies to the regex immediately in front of it. In this
    example, the regex pattern starts with the character `''``y``''`, followed by
    an arbitrary number of characters, `.*`, followed by the character `''``y``''`.
    As you can see, the word `''cryptography''` contains one such instance of this
    pattern: `''yptography''`.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 星号操作符应用于紧接其前面的正则表达式。在这个例子中，正则表达式模式以字符`'y'`开头，后跟任意数量的字符`.*`，然后是字符`'y'`。正如你所看到的，单词`'cryptography'`包含了这样一个模式的实例：`'yptography'`。
- en: You may wonder why this code doesn’t find the long substring between `'originally``'`
    and `'cryptography'`, which should also match the regex pattern `y.*y`. The reason
    is simply that the dot operator matches any character except the newline character.
    The string stored in the variable `text` is a multiline string with three new
    lines. You can also use the asterisk operator in combination with any other regex.
    For example, you can use the regex `abc*` to match the strings `'ab'`, `'abc'`,
    `'abcc'`, and `'abccdc'`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，为什么这段代码没有找到`'originally'`和`'cryptography'`之间的长子串，尽管这个子串也应该匹配正则表达式`y.*y`。原因很简单，因为点号操作符匹配除了换行符以外的任何字符。变量`text`中存储的字符串是一个多行字符串，包含三行换行符。你也可以将星号操作符与其他任何正则表达式结合使用。例如，你可以使用正则表达式`abc*`来匹配字符串`'ab'`、`'abc'`、`'abcc'`和`'abccdc'`。
- en: '**The Zero-or-one Regex**'
  id: totrans-22
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**零次或一次正则表达式**'
- en: 'Third, you need to know how to match zero or one characters by using the *zero-or-one
    regex*, the `?` character. Just like the asterisk operator, the question mark
    modifies another regex, as you can see in the following example:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，你需要知道如何使用*零次或一次正则表达式*（`?`字符）来匹配零个或一个字符。就像星号操作符一样，问号修饰另一个正则表达式，正如以下例子所示：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The zero-or-one regex, `?`, applies to the regex immediately in front of it.
    In our case, this is the character `s`. The zero-or-one regex says that the pattern
    it modifies is optional.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 零次或一次正则表达式`?`应用于紧接其前面的正则表达式。在我们的例子中，这个正则表达式是字符`s`。零次或一次正则表达式表示它修饰的模式是可选的。
- en: 'There is another use of the question mark in Python’s `re` package, but it
    has nothing to do with the zero-or-one regex: the question mark can be combined
    with the asterisk operator, `*?`, to allow for *nongreedy* pattern matching. For
    example, if you use the regex `.*?`, Python searches for a minimal number of arbitrary
    characters. In contrast, if you use the asterisk operator `*` without the question
    mark, it *greedily* matches as many characters as possible.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python的`re`包中，问号还有另一种用法，但与零次或一次正则表达式无关：问号可以与星号操作符`*?`结合使用，从而实现*非贪婪*模式匹配。例如，如果你使用正则表达式`.*?`，Python将搜索最小数量的任意字符。相反，如果你使用没有问号的星号操作符`*`，它会*贪婪*地匹配尽可能多的字符。
- en: 'Let’s look at an example. When searching the HTML string `''<div>hello world</div>''`
    by using the regex `<.*>`, it matches the whole string `''<div>hello world</div>''`
    rather than only the prefix `''<div>''`. If you want only the prefix, you can
    use the nongreedy regex `<.*?>`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子。当使用正则表达式`<.*>`搜索HTML字符串`'<div>hello world</div>'`时，它会匹配整个字符串`'<div>hello
    world</div>'`，而不是仅仅匹配前缀`'<div>'`。如果你只想匹配前缀，可以使用非贪婪正则表达式`<.*?>`：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Equipped with these three tools—the dot regex `.`, the asterisk regex `*`, and
    the zero-or-one regex `?`—you’re now able to comprehend the next one-liner solution.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 配备了这三种工具——点号正则表达式`.`、星号正则表达式`*`和零次或一次正则表达式`?`——你现在可以理解下一个单行解决方案。
- en: '***The Code***'
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: Our input is a string, and our goal is to use a nongreedy approach to find all
    patterns that start with the character `'p'`, end with the character `'r'`, and
    have at least one occurrence of the character `'e'` (and, possibly, an arbitrary
    number of other characters) in between!
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的输入是一个字符串，我们的目标是使用非贪婪的方法，找到所有以字符`'p'`开头、以字符`'r'`结尾，并且在其中至少包含一次字符`'e'`（并可能包含任意数量的其他字符）的模式！
- en: These types of text queries occur quite frequently—especially in companies that
    focus on text processing, speech recognition, or machine translation (such as
    search engines, social networks, or video platforms). Take a look at [Listing
    5-1](#list5-1).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型的文本查询非常常见——尤其是在专注于文本处理、语音识别或机器翻译的公司中（如搜索引擎、社交网络或视频平台）。请查看[清单 5-1](#list5-1)。
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 5-1: One-liner solution to search for specific phrases (nongreedy)*'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-1：搜索特定短语的单行解决方案（非贪婪模式）*'
- en: This code prints a list of all matching phrases in the `text`. What are they?
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码会打印出 `text` 中所有匹配的短语。它们是什么？
- en: '***How It Works***'
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***工作原理***'
- en: 'The regex search query is `p.*?e.*?r`. Let’s break this down. You’re looking
    for a phrase that starts with the character `''p''` and ends with the character
    `''r''`. Between those two characters, you require one occurrence of the character
    `''e''`. Apart from that, you allow an arbitrary number of characters (whitespace
    or not). However, you match in a nongreedy manner by using `.*?`, which means
    Python will search for a minimal number of arbitrary characters. Here’s the solution:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式搜索查询是`p.*?e.*?r`。让我们来分解一下。你在寻找一个以字符 `'p'` 开头并以字符 `'r'` 结尾的短语。在这两个字符之间，你需要至少出现一次字符
    `'e'`。除此之外，你允许任意数量的字符（无论是否有空格）。然而，你通过使用`.*?`以非贪婪的方式进行匹配，这意味着 Python 将搜索尽可能少的任意字符。以下是解决方案：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Compare this solution with the one you’d get when using the greedy regex `p.*e.*r`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个解决方案与使用贪婪正则表达式 `p.*e.*r` 时得到的结果进行比较：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The first greedy asterisk operator `.*` matches almost the whole string before
    it terminates.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个贪婪星号操作符 `.*` 匹配几乎整个字符串，直到它终止。
- en: '**Writing Your First Web Scraper with Regular Expressions**'
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用正则表达式编写你的第一个网页抓取器**'
- en: 'In the previous section, you learned about the most powerful way to find arbitrary
    text patterns in strings: regular expressions. This section will further motivate
    your use of regular expressions and develop your knowledge with a practical example.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你学习了在字符串中查找任意文本模式的最强大方法：正则表达式。本节将进一步激发你使用正则表达式的动力，并通过一个实际的例子来拓展你的知识。
- en: '***The Basics***'
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基础知识***'
- en: Suppose you’re working as a freelance software developer. Your client is a fintech
    startup that needs to stay updated about the latest developments in cryptocurrency.
    They hire you to write a web scraper that regularly pulls the HTML source code
    of news websites and searches it for words starting with `'crypto'` (for example,
    `'cryptocurrency'`, `'crypto-bot'`, `'crypto-crash'`, and so on).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在作为自由职业的软件开发者工作。你的客户是一家金融科技初创公司，需要及时了解加密货币的最新发展。他们雇佣你编写一个网页抓取器，定期获取新闻网站的
    HTML 源代码，并在其中搜索以 `'crypto'` 开头的词汇（例如，`'cryptocurrency'`、`'crypto-bot'`、`'crypto-crash'`
    等等）。
- en: 'Your first attempt is the following code snippet:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你第一次尝试的代码片段如下：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The method `urlopen()` (from the module `urllib.request`) pulls the HTML source
    code from the specified URL. Because the result is a byte array, you have to first
    convert it to a string by using the `decode()` method. Then you use the string
    method `find()` to return the position of the first occurrence of the searched
    string. With slicing (see [Chapter 2](ch02.xhtml#ch02)), you carve out a substring
    that returns the immediate environment of the position. The result is the following
    string:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 方法`urlopen()`（来自模块`urllib.request`）从指定的 URL 获取 HTML 源代码。由于结果是字节数组，因此你必须先使用`decode()`方法将其转换为字符串。然后，你使用字符串方法`find()`返回搜索字符串第一次出现的位置。通过切片（请参见[第
    2 章](ch02.xhtml#ch02)），你提取出一个子字符串，返回该位置的即时环境。结果是以下字符串：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Aw. That looks bad. As it turns out, the search phrase is ambiguous—most words
    containing `'crypto'` are semantically unrelated to *cryptocurrencies*. Your web
    scraper generates *false positives* (it finds string results that you originally
    didn’t mean to find). So how can you fix it?
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，这看起来不太好。事实证明，搜索短语是模糊的——包含 `'crypto'` 的大多数单词在语义上与*加密货币*无关。你的网页抓取器生成了*假阳性*（它找到了你原本并不想找到的字符串结果）。那么你该如何解决呢？
- en: 'Luckily, you’ve just read this Python book, so the answer is obvious: regular
    expressions! Your idea to remove false positives is to search for occurrences
    in which the word `''crypto''` is followed by up to 30 arbitrary characters, followed
    by the word `coin`. Roughly speaking, the search query is `crypto +` *`<up to
    30 arbitrary characters>`* `+ coin`. Consider the following two examples:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，你刚读完这本 Python 书，所以答案显而易见：正则表达式！你消除假阳性的方法是查找 `'crypto'` 后跟最多 30 个任意字符，接着是
    `coin` 的情况。大致来说，搜索查询是 `crypto +` *`<最多 30 个任意字符>`* `+ coin`。考虑以下两个示例：
- en: '`''``crypto-bot that is trading Bitcoin''`—yes'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''``加密机器人正在交易比特币''`—是的'
- en: '`''``cryptographic encryption methods that can be cracked easily with quantum
    computers``''`—no'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''``加密加密方法，可以轻松被量子计算机破解``''`—不'
- en: 'So how to solve this problem of allowing up to 30 arbitrary characters between
    two strings? This goes beyond a simple string search. You can’t enumerate every
    exact string pattern—a virtually infinite number of matches is allowed. For example,
    the search pattern must match all of the following: `''cryptoxxxcoin''`, `''crypto
    coin''`, `''crypto bitcoin''`, `''crypto is a` `currency``. Bitcoin''`, and all
    other character combinations with up to 30 characters between the two strings.
    Even if you had only 26 characters in the alphabet, the number of strings that
    would theoretically match our requirement exceeds 26[30] = 2,813,198,901,284,745,919,258,621,029,615,971,520,741,376\.
    In the following, you’ll learn how to search a text for a regex pattern that corresponds
    to a large number of possible string patterns.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 那么如何解决这个问题，使得两个字符串之间允许最多 30 个任意字符呢？这超出了简单的字符串搜索。你不能列举出每个精确的字符串模式——允许的匹配是几乎无限的。例如，搜索模式必须匹配以下所有情况：`'cryptoxxxcoin'`，`'crypto
    coin'`，`'crypto bitcoin'`，`'crypto is a` `currency``。比特币'`，以及其他所有在两个字符串之间最多有 30
    个字符的字符组合。即使只有 26 个字母表中的字符，理论上符合我们要求的字符串数量也超过 26[30] = 2,813,198,901,284,745,919,258,621,029,615,971,520,741,376。在接下来的内容中，你将学习如何搜索一个文本，找到与大量可能的字符串模式对应的正则表达式模式。
- en: '***The Code***'
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: Here, given a string, you will find occurrences in which the string `'crypto'`
    is followed by up to 30 arbitrary characters, followed by the string `'coin'`.
    Let’s first look at [Listing 5-2](#list5-2) before discussing how the code solves
    the problem.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，给定一个字符串，你将查找 `'crypto'` 后跟最多 30 个任意字符，接着是 `'coin'` 的情况。让我们先看一下 [清单 5-2](#list5-2)，然后再讨论代码如何解决这个问题。
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 5-2: One-liner solution to find text snippets in the form `crypto``(some
    text)``coin`*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-2：查找形如 `crypto``(some text)``coin` 的文本片段的一行解决方案*'
- en: This code searches two string variables, `text_1` and `text_2`. Does the search
    query (pattern) match them?
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码搜索了两个字符串变量 `text_1` 和 `text_2`。搜索查询（模式）是否匹配它们？
- en: '***How It Works***'
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***工作原理***'
- en: 'First, you import the standard module for regular expressions in Python, called
    `re`. The important stuff happens in the one-liner where you compile the search
    query `crypto(.{1,30})coin`. This is the query that you can use to search various
    strings. You use the following special regex characters. Read them from top to
    bottom and you’ll understand the meaning of the pattern in [Listing 5-2](#list5-2):'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你导入 Python 中的标准正则表达式模块 `re`。重要的部分发生在这一行代码中，你编译了搜索查询 `crypto(.{1,30})coin`。这是你可以用来搜索各种字符串的查询。你使用了以下特殊的正则表达式字符。按照从上到下的顺序阅读，你就能理解
    [清单 5-2](#list5-2) 中模式的含义：
- en: '`()` matches whatever regex is inside.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`()` 匹配括号内的内容。'
- en: '`.`  matches an arbitrary character.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.` 匹配任意字符。'
- en: '`{1,30}` matches between 1 and 30 occurrences of the *previous* regex.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{1,30}` 匹配前面正则表达式的 1 到 30 次出现。'
- en: '`(.{1,30})` matches between 1 and 30 arbitrary characters.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(.{1,30})` 匹配 1 到 30 个任意字符。'
- en: '`crypto(.{1,30})coin` matches the regex consisting of three parts: the word
    `''``crypto``''`, an arbitrary sequence with 1 to 30 chars, followed by the word
    `''``coin``''`.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`crypto(.{1,30})coin` 匹配由三部分组成的正则表达式：单词 `''``crypto``''`，接着是一个长度为 1 到 30 个字符的任意序列，最后是单词
    `''``coin``''`。'
- en: 'We say that the pattern is *compiled* because Python creates a pattern object
    that can be reused in multiple locations—much as a compiled program can be executed
    multiple times. Now, you call the function `match()` on our compiled pattern and
    the text to be searched. This leads to the following result:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称该模式为*编译过的*，因为 Python 会创建一个模式对象，可以在多个位置重用——就像编译后的程序可以多次执行一样。现在，你可以对我们的编译模式和要搜索的文本调用
    `match()` 函数。这将得到以下结果：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The string variable `text_1` matches the pattern (indicated by the resulting
    match object), but `text_2` doesn’t (indicated by the result `None`). Although
    the textual representation of the first matching object doesn’t look pretty, it
    gives a clear hint that the given string `'crypto-bot that is trading Bitcoin'`
    matches the regular expression.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串变量`text_1`匹配模式（通过结果匹配对象指示），但`text_2`不匹配（通过结果`None`指示）。尽管第一个匹配对象的文本表示看起来不太美观，但它清楚地表明字符串`'crypto-bot
    that is trading Bitcoin'`与正则表达式匹配。
- en: '**Analyzing Hyperlinks of HTML Documents**'
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**分析 HTML 文档中的超链接**'
- en: In the preceding section, you learned how to search a string for a large number
    of patterns by using the regex pattern `.{x,y}`. This section goes further, introducing
    many more regular expressions.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你学习了如何使用正则表达式模式`.{x,y}`来搜索一个字符串中的大量模式。本节将进一步讲解，引入更多的正则表达式。
- en: '***The Basics***'
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基础知识***'
- en: Knowing more regular expressions will help you solve real-world problems quickly
    and concisely. So what are the most important regular expressions? Study the following
    list carefully because we’ll use all of them in this chapter. Just view the ones
    you’ve already seen as a small repetition exercise.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 学会更多正则表达式将帮助你快速简洁地解决实际问题。那么，最重要的正则表达式有哪些呢？仔细研究下面的列表，因为我们将在本章中使用所有这些正则表达式。你可以把已经学过的当作一个小复习。
- en: The dot regex `.` matches an arbitrary character.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点号正则表达式`.`匹配任意字符。
- en: The asterisk regex *`<pattern>`*`*` matches an arbitrary number of the regex
    *`<pattern>`*. Note that this includes zero matching instances.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 星号正则表达式*`<pattern>`*`*`匹配任意多个*`<pattern>`*的正则表达式。注意，这包括零次匹配。
- en: The at-least-one regex *`<pattern>`*`+` can match an arbitrary number of *`<pattern>`*
    but must match at least one instance.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少匹配一个的正则表达式*`<pattern>`*`+`可以匹配任意多个*`<pattern>`*，但必须至少匹配一个实例。
- en: The zero-or-one regex *`<pattern>`*`?` matches either zero or one instances
    of *`<pattern>`*.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 零次或一次匹配的正则表达式*`<pattern>`*`?`匹配零次或一次*`<pattern>`*的实例。
- en: The nongreedy asterisk regex `*?` matches as few arbitrary characters as possible
    to match the overall regex.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非贪婪星号正则表达式`*?`会尽可能匹配少量的任意字符，以匹配整个正则表达式。
- en: The regex *`<pattern>`*`{m}` matches exactly `m` copies of *`<pattern>`*.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正则表达式*`<pattern>`*`{m}`精确匹配`m`个*`<pattern>`*的副本。
- en: The regex *`<pattern>`*`{m,n}` matches between `m` and `n` copies of *`<pattern>`*.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正则表达式*`<pattern>`*`{m,n}`匹配`m`到`n`个*`<pattern>`*的副本。
- en: The regex *`<pattern_1>`*`|`*`<pattern_2>`* matches either *`<pattern_1>`* or
    *`<pattern_2>`*.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正则表达式*`<pattern_1>`*`|`*`<pattern_2>`*匹配*`<pattern_1>`*或*`<pattern_2>`*。
- en: The regex *`<pattern_1><pattern_2>`* matches *`<pattern_1>`* and then *`<pattern_2>`*.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正则表达式*`<pattern_1><pattern_2>`*先匹配*`<pattern_1>`*，然后匹配*`<pattern_2>`*。
- en: The regex `(`*`<pattern>`*`)` matches *`<pattern>`*. The parentheses group regular
    expressions so you can control the order of execution (for example, `(`*`<pattern_1><pattern_2>`*`)|`*`<pattern_3>`*
    is different from *`<pattern_1>`* `(`*`<pattern_2>`*`|`*`<pattern_3>`*`)`. The
    parentheses regex also creates a matching group, as you’ll see later in the section.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正则表达式`(`*`<pattern>`*`)`匹配*`<pattern>`*。括号用于将正则表达式分组，从而控制执行顺序（例如，`(`*`<pattern_1><pattern_2>`*`)`|`*`<pattern_3>`*与*`<pattern_1>`*`(`*`<pattern_2>`*`|`*`<pattern_3>`*`)`是不同的）。括号正则表达式还会创建一个匹配组，稍后你将在本节中看到。
- en: Let’s consider a short example. Say you create the regex `b?(.a)*`. Which patterns
    will the regex match? The regex matches all patterns starting with zero or one
    `b` and an arbitrary number of two-character-sequences ending in the character
    `'a'`. Hence, the strings `'bcacaca'`, `'cadaea'`, `''` (the empty string), and
    `'aaaaaa'` would all match the regex.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个简短的示例。假设你创建了正则表达式`b?(.a)*`。这个正则表达式会匹配哪些模式呢？这个正则表达式会匹配所有以零个或一个`b`开头，并且后面跟有任意多个以字符`'a'`结尾的两字符序列。因此，字符串`'bcacaca'`、`'cadaea'`、`''`（空字符串）和`'aaaaaa'`都会匹配这个正则表达式。
- en: 'Before diving into the next one-liner, let’s quickly discuss when to use which
    *regex function*. The three most important regex functions are `re.match()`, `re.search()`,
    and `re.findall()`. You’ve already seen two of them, but let’s study them more
    thoroughly in this example:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解下一个一行代码之前，让我们快速讨论一下什么时候使用哪个*正则表达式函数*。三个最重要的正则表达式函数是`re.match()`、`re.search()`和`re.findall()`。你已经见过其中的两个，但让我们在这个例子中更深入地学习它们：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: All three functions take the regex and the string to be searched as an input.
    The `match()` and `search()` functions return a match object (or `None` if the
    regex did not match anything). The match object stores the position of the match
    and more advanced meta-information. The function `match()` does not find the regex
    in the string (it returns `None`). Why? Because the function looks for the pattern
    only *at the beginning* of the string. The function `search()` searches for the
    first occurrence of the regex *anywhere* in the string. Therefore, it finds the
    match `"Christmas has come and gone and I didn't"`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个函数都接受正则表达式和要搜索的字符串作为输入。`match()`和`search()`函数返回一个匹配对象（如果正则表达式没有匹配到任何内容，则返回`None`）。匹配对象存储了匹配位置以及更多高级的元信息。`match()`函数不会在字符串中找到正则表达式（它返回`None`）。为什么？因为这个函数只会在字符串的*开始*部分查找模式。`search()`函数会在字符串的*任何位置*查找正则表达式的第一个匹配项。因此，它找到了匹配项`"Christmas
    has come and gone and I didn't"`。
- en: 'The `findall()` function has the most intuitive output, but it’s also the least
    useful for further processing. The result of `findall()` is a sequence of strings
    rather than a match object—so it doesn’t give us information about the precise
    location of the match. That said, `findall()` has its uses: in contrast to the
    `match()` and `search()` methods, the function `findall()` retrieves *all* matched
    patterns, which is useful when you want to quantify how often a word appears in
    a text (for example, the string `''Juliet''` in the text `''Romeo and Juliet''`
    or the string `''crypto''` in an article about cryptocurrency).'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`findall()`函数的输出最为直观，但也最不适合进一步处理。`findall()`的结果是一个字符串序列，而不是一个匹配对象——因此它不会给我们匹配位置的精确信息。话虽如此，`findall()`还是有它的用途：与`match()`和`search()`方法不同，`findall()`函数会提取*所有*匹配的模式，这在你想统计一个词在文本中出现的频率时非常有用（例如，字符串`''Juliet''`在文本`''Romeo
    and Juliet''`中，或者字符串`''crypto''`在关于加密货币的文章中）。'
- en: '***The Code***'
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: 'Say your company asks you to create a small web bot that crawls web pages and
    checks whether they contain links to the domain *finxter.com*. They also ask you
    to make sure the hyperlink descriptions contain the strings `''test''` or `''puzzle''`.
    In HTML, hyperlinks are enclosed in an `<a></a>` tag environment. The hyperlink
    itself is defined as the value of the `href` attribute. So more precisely, the
    goal is to solve the following problem, depicted in [Listing 5-3](#list5-3): given
    a string, find all hyperlinks that point to the domain *finxter.com* and contain
    the strings `''test''` or `''puzzle''` in the link description.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的公司要求你创建一个小型的网页爬虫，它可以爬取网页并检查其中是否包含指向域名*finxter.com*的链接。同时，他们还要求你确保超链接的描述中包含字符串`'test'`或`'puzzle'`。在HTML中，超链接被包含在`<a></a>`标签环境中。超链接本身由`href`属性的值定义。所以更准确地说，目标是解决以下问题，见[清单
    5-3](#list5-3)：给定一个字符串，找出所有指向域名*finxter.com*并且在链接描述中包含`'test'`或`'puzzle'`的超链接。
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 5-3: One-liner solution to analyze web page links*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-3：分析网页链接的单行解决方案*'
- en: This code finds two occurrences of the regular expression. Which ones?
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码查找正则表达式的两个匹配项。是哪两个？
- en: '***How It Works***'
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***它是如何工作的***'
- en: The data consists of a simple HTML web page (stored as a multiline string) containing
    a list of hyperlinks (the tag environment `<a href="">`*`link text`*`</a>`). The
    one-liner solution uses the function `re.findall()` to check the regular expression
    `(<a.*?finxter.*?(test|puzzle).*?>)`. This way, the regular expression returns
    all occurrences in the tag environment `<a. . .>` with the following restrictions.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 数据由一个简单的HTML网页（存储为多行字符串）组成，里面包含了一些超链接（标签环境`<a href="">`*`链接文本`*`</a>`）。这个单行解决方案使用了`re.findall()`函数来检查正则表达式`(<a.*?finxter.*?(test|puzzle).*?>)`。通过这种方式，正则表达式返回所有在标签环境`<a.
    . .>`中的匹配项，且有以下限制。
- en: After the opening tag, you match an arbitrary number of characters (nongreedily,
    to prevent the regex from “chewing up” multiple HTML tag environments), followed
    by the string `'finxter'`. Next, you match an arbitrary number of characters (nongreedily),
    followed by one occurrence of either the string `'test'` or the string `'puzzle'`.
    Again, you match an arbitrary number of characters (nongreedily), followed by
    the closing tag. This way, you find all hyperlink tags that contain the respective
    strings. Note that this regex also matches tags where the strings `'test'` or
    `'puzzle'` occur within the link itself. Please also note that you use only nongreedy
    asterisk operators `'.*?'` to ensure that you always search for minimal matches
    rather than matching—for example, a very long string enclosed in multiple nested
    tag environments.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在开头标签后，你匹配任意数量的字符（非贪婪地，防止正则表达式“吞噬”多个 HTML 标签环境），然后是字符串 `'finxter'`。接下来，你匹配任意数量的字符（非贪婪地），然后是
    `'test'` 或 `'puzzle'` 中的一个字符串。接着，你再次匹配任意数量的字符（非贪婪地），然后是闭合标签。这样，你就能找到所有包含这些字符串的超链接标签。请注意，这个正则表达式还匹配那些在链接本身中包含
    `'test'` 或 `'puzzle'` 的标签。还要注意，你只使用了非贪婪的星号运算符 `'.*?'`，以确保总是查找最小的匹配，而不是匹配一个被多个嵌套标签环境包围的非常长的字符串。
- en: 'The result of the one-liner is the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 单行代码的结果如下：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Two hyperlinks match our regular expression: the result of the one-liner is
    a list with two elements. However, each element is a tuple of strings rather than
    a simple string. This is different from the results of `findall()`, which we’ve
    discussed in previous code snippets. What’s the reason for this behavior? The
    return type is a list of tuples—with one tuple value for each *matching group*
    enclosed in `()`. For instance, the regex `(test|puzzle)` uses the parentheses
    notation to create a matching group. If you use matching groups in your regex,
    the function `re.findall()` will add one tuple value for every matched group.
    The tuple value is the substring that matches this particular group. For example,
    in our case, the substring `''puzzle''` matches the group `(test|puzzle)`. Let’s
    dive more deeply into the topic of matching groups to clarify this concept.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个超链接匹配我们的正则表达式：单行代码的结果是一个包含两个元素的列表。然而，每个元素是一个字符串元组，而不是一个简单的字符串。这与我们之前在代码片段中讨论的
    `findall()` 方法的结果不同。为什么会这样呢？返回类型是一个元组列表——每个匹配的*匹配组*被 `()` 包围。比如，正则表达式 `(test|puzzle)`
    使用括号表示法来创建一个匹配组。如果你在正则表达式中使用了匹配组，`re.findall()` 函数会为每个匹配的组添加一个元组值。这个元组值是匹配该组的子字符串。例如，在我们的例子中，子字符串
    `'puzzle'` 匹配了组 `(test|puzzle)`。让我们深入探讨匹配组的概念，以更清楚地理解这一点。
- en: '**Extracting Dollars from a String**'
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**从字符串中提取美元金额**'
- en: This one-liner shows you another practical application of regular expressions.
    Here, you’re working as a financial analyst. As your company considers acquiring
    another company, you’re assigned to read the other company’s reports. You’re particularly
    interested in all dollar figures. Now, you could scan the whole document manually,
    but the work is tedious, and you don’t want to spend your best hours of the day
    doing tedious work. So you decide to write a small Python script. But what’s the
    best way of doing it?
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码展示了正则表达式的另一个实际应用。在这里，你作为一名财务分析师工作。你的公司正在考虑收购另一家公司，你被分配去阅读另一家公司的报告。你特别关注所有的美元金额。现在，你可以手动扫描整篇文档，但这项工作非常繁琐，而且你不想把一天中最好的时间花在这些琐事上。所以你决定编写一个小的
    Python 脚本。但最好的做法是什么呢？
- en: '***The Basics***'
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基础知识***'
- en: Fortunately, you’ve read this regex tutorial, so instead of wasting a lot of
    time writing your own lengthy, error-prone Python parser, you go for the clean
    solution with regular expressions—a wise choice. But before you dive into the
    problem, let’s discuss three more regex concepts.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，你已经阅读了这篇正则表达式教程，因此，你无需浪费大量时间编写自己冗长且易出错的 Python 解析器，而是选择了通过正则表达式实现干净的解决方案——这是一个明智的选择。但在深入问题之前，让我们讨论三个正则表达式的概念。
- en: First, sooner or later you want to match a special character that’s also used
    as a special character by the regex language. In this case, you need to use the
    prefix `\` to *escape* the meaning of the special character. For example, to match
    the parenthesis character `'('`, which is normally used for regex groups, you
    need to escape it with the regex `\(`. This way, the regex character `'('` loses
    its special meaning.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，迟早你会想匹配一个特殊字符，而这个字符在正则表达式语言中也有特殊意义。在这种情况下，你需要使用前缀 `\` 来*转义*该特殊字符的含义。例如，为了匹配括号字符
    `'('`（它通常用于正则表达式中的分组），你需要使用正则表达式 `\(` 来转义它。这样，正则表达式字符 `'('` 就失去了其特殊含义。
- en: 'Second, the square bracket environment `[ ]` allows you to define a range of
    specific characters to be matched. For example, the regex `[0-9]` matches one
    of the following characters: `''0''`, `''1''`, `''2''`, . . . , `''9''`. Another
    example is the regex `[a-e]`, which matches one of the following characters: `''a''`,
    `''b''`, `''c''`, `''d''`, `''e''`.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，方括号环境 `[ ]` 允许你定义一组特定的字符范围。例如，正则表达式 `[0-9]` 匹配以下字符之一：`'0'`、`'1'`、`'2'`、...、`'9'`。另一个例子是正则表达式
    `[a-e]`，它匹配以下字符之一：`'a'`、`'b'`、`'c'`、`'d'`、`'e'`。
- en: 'Third, as we discussed in the previous one-liner section, the parentheses regex
    `(`*`<pattern>`*`)` indicates a *group*. Every regex can have one or multiple
    groups. When using the `re.findall()` function on a regex with groups, only the
    matched groups are returned as a tuple of strings—one for each group—rather than
    the whole matched string. For example, the regex `hello(world)` called on the
    string `''helloworld''` would match the whole string but return only the matched
    group `world`. On the other hand, when using two nested groups in the regex `(hello(world))`,
    the result of the `re.findall()` function would be a tuple of all matched groups
    `(''helloworld'', ''world'')`. Study the following code to understand nested groups
    completely:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，正如我们在前面的单行解决方案部分讨论的那样，括号正则表达式 `(`*`<pattern>`*`)` 表示一个*分组*。每个正则表达式可以有一个或多个分组。当在带有分组的正则表达式上使用
    `re.findall()` 函数时，返回的仅是匹配的分组，作为一个字符串元组—每个分组对应一个字符串—而不是整个匹配的字符串。例如，正则表达式 `hello(world)`
    应用于字符串 `'helloworld'` 时，匹配的是整个字符串，但返回的仅是匹配的分组 `world`。另一方面，当正则表达式 `(hello(world))`
    包含两个嵌套分组时，`re.findall()` 函数的结果将是所有匹配分组的元组 `('helloworld', 'world')`。请研究以下代码，彻底理解嵌套分组：
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, you know everything you need to know to understand the following code snippet.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经掌握了理解以下代码片段所需的所有知识。
- en: '***The Code***'
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: 'To recap, you want to investigate all monetary numbers from a given company
    report. Specifically, your goal is to solve the following problem: given a string,
    find a list of all occurrences of dollar amounts with optional decimal values.
    The following example strings are valid matches: $10, $10., or $10.00021\. How
    can you achieve this efficiently in a single line of code? Take a look at [Listing
    5-4](#list5-4).'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，你需要从给定的公司报告中调查所有货币金额。具体来说，你的目标是解决以下问题：给定一个字符串，查找所有包含美元金额的匹配项，金额中可能包含小数部分。以下示例字符串是有效匹配项：$10、$10.
    或 $10.00021。如何在一行代码中高效地实现这一点？请查看[清单 5-4](#list5-4)。
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 5-4: One-liner solution to find all dollar amounts in a text*'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-4：查找文本中所有美元金额的一行解决方案*'
- en: 'Take a guess: what’s the output of this code snippet?'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 猜猜看：这段代码的输出是什么？
- en: '***How It Works***'
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***工作原理***'
- en: The report contains four dollar values in various formats. The goal is to develop
    a regex that matches all of them. You design the regex `(\$[0-9]+(.[0-9]*)?)`
    that matches the following patterns. First, it matches the dollar sign `$` (you
    escape it because it’s a special regex character). Second, it matches a number
    with an arbitrary number of digits between 0 and 9 (but at least one digit). Third,
    it matches an arbitrary number of decimal values after the (escaped) dot character
    `'.'` (this last match is optional as indicated by the zero-or-one regex `?`).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 该报告包含四个不同格式的美元金额。目标是开发一个正则表达式来匹配它们。你设计了正则表达式 `(\$[0-9]+(.[0-9]*)?)`，它可以匹配以下模式。首先，它匹配美元符号
    `$`（因为它是正则表达式的特殊字符，所以需要进行转义）。其次，它匹配一个由任意数量的数字（0 到 9）组成的数字（但至少有一个数字）。第三，它匹配一个可选的小数部分，即点字符
    `'.'` 后的任意数量的小数值（这个匹配是可选的，正如零或一个正则表达式 `?` 所示）。
- en: 'On top of that, you use list comprehension to extract only the first tuple
    value of all three resulting matches. Again, the default result of the `re.findall()`
    function is a list of tuples, with one tuple for each successful match and one
    tuple value for each group within the match:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你使用列表推导式仅提取所有三个匹配结果中的第一个元组值。再次强调，`re.findall()`函数的默认结果是一个元组列表，每个成功匹配一个元组，每个匹配组中有一个元组值：
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You’re interested in only the global group—the first value in the tuple. You
    filter out the other values by using list comprehension and get the following
    result:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你只对全局组—元组中的第一个值感兴趣。你通过使用列表推导式过滤掉其他值，并获得如下结果：
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: It’s worth noting again that implementing even a simple parser without the powerful
    capabilities of regular expressions would be difficult and error-prone!
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 值得再次强调的是，即使是实现一个简单的解析器，如果没有正则表达式的强大功能，也会变得非常困难且容易出错！
- en: '**Finding Nonsecure HTTP URLs**'
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**查找不安全的HTTP URL**'
- en: This one-liner shows you how to solve one of those small, time-intensive problems
    that web developers often run into. Say you own a programming blog and you’ve
    just moved your website from the unsecure protocol `http` to the (more) secure
    protocol `https`. However, your old articles still point to the old URLs. How
    can you find all occurrences of the old URLs?
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个单行代码展示了如何解决Web开发人员常遇到的一些小而耗时的问题。假设你拥有一个编程博客，你刚刚将网站从不安全的`http`协议迁移到更安全的`https`协议。然而，你的旧文章仍然指向旧的URL。你如何找到所有出现旧URL的地方？
- en: '***The Basics***'
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基础知识***'
- en: 'In the preceding section, you learned how to use square bracket notation to
    specify an arbitrary range of characters. For example, the regular expression
    `[0-9]` matches a single-digit number with a value from 0 to 9\. However, the
    square bracket notation is more powerful than that. You can use an arbitrary combination
    of characters within the square brackets to specify exactly which characters match—and
    which don’t. For example, the regular expression `[0-3a-c]+` matches the strings
    `''01110''` and `''01c22a''` but not the strings `''443''` and `''00cd''`. You
    can also specify a fixed set of characters *not* to match by using the symbol
    `^`: the regular expression `[^0-3a-c]+` matches the strings `''4444d``''` and
    `''Python''` but not the strings `''001''` and `''01c22a''`.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你学习了如何使用方括号符号来指定一个任意范围的字符。例如，正则表达式`[0-9]`匹配一个单一的数字，范围从0到9。然而，方括号符号比这更强大。你可以在方括号内使用任意字符组合，精确地指定哪些字符匹配，哪些不匹配。例如，正则表达式`[0-3a-c]+`匹配字符串`'01110'`和`'01c22a'`，但不匹配`'443'`和`'00cd'`。你还可以通过使用符号`^`来指定一个不匹配的固定字符集：正则表达式`[^0-3a-c]+`匹配字符串`'4444d'`和`'Python'`，但不匹配`'001'`和`'01c22a'`。
- en: '***The Code***'
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: Here our input is a (multiline) string, and our aim is to find all occurrences
    of valid URLs that start with the prefix *http://*. However, don’t consider invalid
    URLs without a top-level domain (there has to be at least one . in the found URL).
    Take a look at [Listing 5-5](#list5-5).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们的输入是一个（多行）字符串，我们的目标是查找所有以前缀*http://*开头的有效URL。然而，不要考虑没有顶级域名的无效URL（找到的URL中必须至少有一个点号）。请看[Listing
    5-5](#list5-5)。
- en: '[PRE18]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 5-5: One-liner solution to find valid* http:// *URLs*'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 5-5: 查找有效的* http:// *URL 的单行解决方案*'
- en: Again, try to come up with the output the code will produce before looking up
    the correct output that follows.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 再次尝试在查看正确输出之前，预测代码会产生什么样的输出。
- en: '***How It Works***'
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***工作原理***'
- en: 'In the regular expression, you analyze a given multiline string (potentially
    an old blog article) to find all URLs that start with the string prefix `http://`.
    The regular expression expects a positive number of (lowercase) characters, numbers,
    underscores, hyphens, or dots (`[a-z0-9_\-\.]+`). Note that you need to escape
    the hyphen (`\-`) because it normally indicates a range within the square brackets.
    Similarly, you need to escape the dot (`\.`) because you actually want to match
    the dot and not an arbitrary character. This results in the following output:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在正则表达式中，你分析一个给定的多行字符串（可能是一个旧的博客文章），以查找所有以`http://`为前缀的URL。正则表达式期望出现一个或多个（小写字母）字符、数字、下划线、连字符或点号（`[a-z0-9_\-\.]+`）。注意，你需要转义连字符（`\-`），因为它通常表示方括号中的范围。同样，你需要转义点号（`\.`），因为你实际上是想匹配点号而不是任意字符。最终得到如下输出：
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Four valid URLs may need to be moved to the more secure HTTPS protocol.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 四个有效的URL可能需要迁移到更安全的HTTPS协议。
- en: At this point, you’ve already mastered the most important features of regular
    expressions. But there’s a level of deep understanding that you’ll reach only
    by practicing and studying a lot of examples—and regular expressions are no exception.
    Let’s study a few more practical examples of how regular expressions can make
    your life easier.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经掌握了正则表达式中最重要的特性。但要达到更深的理解，你需要通过练习和学习大量示例——正则表达式也不例外。让我们再学习几个实际的示例，看看正则表达式如何让你的生活更轻松。
- en: '**Validating the Time Format of User Input, Part 1**'
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**验证用户输入的时间格式，第一部分**'
- en: Let’s learn to check the correctness of user-input formatting. Say you write
    a web application that calculates health statistics based on the sleep duration
    of your users. Your users enter the time they went to bed and the time they wake
    up. An example for a correct time format is `12:45`, but because web bots are
    spamming your user input fields, a lot of “dirty” data is causing unnecessary
    processing overhead on your servers. To address this issue, you write a time-format
    checker that determines whether the input is worth processing further with your
    backend application. With regular expressions, writing the code takes only a few
    minutes.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习如何检查用户输入格式的正确性。假设你编写了一个基于用户睡眠时间计算健康统计数据的web应用程序。用户输入他们入睡和醒来的时间。一个正确的时间格式示例如`12:45`，但由于网络机器人正在垃圾填充你的用户输入字段，许多“脏”数据导致了服务器的不必要处理开销。为了解决这个问题，你编写了一个时间格式检查器，用于确定输入是否值得进一步在后台应用程序中处理。使用正则表达式，编写代码只需几分钟。
- en: '***The Basics***'
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基础知识***'
- en: In the previous few sections, you’ve learned about the `re.search()`, `re.match()`,
    and `re.findall()` functions. These are not the only regex functions. In this
    section, you’ll use `re.fullmatch(`*`regex, string`*`)`, which checks whether
    the `regex` matches the *full* `string` as the name suggests.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的几个章节中，你已经学习了`re.search()`、`re.match()`和`re.findall()`函数。这些并不是唯一的正则表达式函数。在本节中，你将使用`re.fullmatch(`*`regex,
    string`*`)`，它会检查`regex`是否完全匹配`string`，正如其名称所示。
- en: 'Furthermore, you’ll use the regex syntax *`pattern`*`{`*`m,n`*`}` that matches
    between *`m`* and *`n`* instances of the regex *`pattern`*, but no more and no
    less. Note that it attempts to match the maximal number of occurrences of *`pattern`*.
    Here’s an example:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你将使用正则表达式语法*`pattern`*`{`*`m,n`*`}`，它匹配正则表达式*`pattern`*的*m*到*n*个实例，但不多也不少。注意，它会尽量匹配*`pattern`*的最大出现次数。以下是一个示例：
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Using the bracket notation, the code doesn’t match substrings with fewer than
    three and more than five `'x'` characters.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用括号符号，代码不匹配少于三个或多于五个`'x'`字符的子字符串。
- en: '***The Code***'
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: Our goal is to write a function `input_ok` that takes a string argument and
    checks whether it has the (time) format *`XX`*`:`*`XX`*, where *`X`* is a number
    from 0 to 9; see [Listing 5-6](#list5-6). Note that, for now, you accept semantically
    wrong time formats such as 12:86, but the next one-liner section tackles this
    more advanced problem.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是编写一个函数`input_ok`，它接受一个字符串参数并检查它是否具有（时间）格式*`XX`*`:`*`XX`*，其中*`X`*是0到9之间的数字；参见[清单5-6](#list5-6)。请注意，目前你接受像12:86这样的语义错误时间格式，但接下来的单行代码将解决这个更复杂的问题。
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 5-6: One-liner solution to check whether a given user input matches
    the general time format* XX*:*XX'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单5-6：检查给定用户输入是否符合通用时间格式的单行解决方案* XX*:*XX'
- en: Before you move on, try to determine the results of the six function calls in
    this code.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，尝试确定代码中六个函数调用的结果。
- en: '***How It Works***'
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***工作原理***'
- en: The data consists of six input strings as received by the frontend of your web
    application. Are they correctly formatted? To check this, you create the function
    `input_ok` by using a lambda expression with one input argument `x` and a Boolean
    output. You use the function `fullmatch(`*`regex`*`, x)` and attempt to match
    the input argument `x` by using our time-formatting regex. If you couldn’t match
    it, the result takes the value `None` and the Boolean output becomes `False`.
    Otherwise, the Boolean output is `True`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 数据由六个输入字符串组成，这些字符串是通过你的网站前端接收到的。它们的格式正确吗？为了检查这一点，你创建了函数`input_ok`，该函数使用一个输入参数`x`和一个布尔输出的lambda表达式。你使用`fullmatch(`*`regex`*`,
    x)`函数，尝试使用我们的时间格式正则表达式匹配输入参数`x`。如果匹配失败，结果将为`None`，布尔输出为`False`。否则，布尔输出为`True`。
- en: 'The regex is simple: `[0-9]{2}:[0-9]{2}`. This pattern matches two leading
    numbers from 0 to 9, followed by the colon`:`, followed by two trailing numbers
    from 0 to 9\. Thus, the result of [Listing 5-6](#list5-6) is the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式很简单：`[0-9]{2}:[0-9]{2}`。这个模式匹配两个从0到9的数字，后面跟着冒号`:`，然后再跟着两个从0到9的数字。因此，[列表5-6](#list5-6)的结果如下：
- en: '[PRE22]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The function `input_ok` correctly identifies the correct formats of the time
    `inputs`. In this one-liner, you’ve learned how highly practical tasks—that would
    otherwise take multiple lines of code and more effort—can be finished successfully
    in a few seconds with the right tool set.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`input_ok`函数正确地识别了时间`输入`的正确格式。在这一行代码中，你学习了如何通过合适的工具集，在短短几秒钟内完成那些本来需要多行代码和更多努力的高度实用的任务。'
- en: '**Validating Time Format of User Input, Part 2**'
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**验证用户输入的时间格式，第二部分**'
- en: 'In this section, you’ll dive deeper into validating the time format of user
    inputs to solve the problem of the previous section: invalid time inputs such
    as `99:99` should not be considered valid matches.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，你将深入探讨验证用户输入的时间格式，以解决上一节的问题：无效的时间输入，如`99:99`，不应被视为有效匹配。
- en: '***The Basics***'
  id: totrans-154
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基础***'
- en: 'A useful strategy to solve problems is to address them hierarchically. First,
    strip down the problem to its core and solve the easier variant. Then, refine
    the solution to match your specific (and more complicated) problem. This section
    refines the previous solution in an important way: it doesn’t allow invalid time
    inputs such as `99:99` or `28:66`. Hence, the problem is more specific (and more
    complicated), but you can reuse parts of our old solution.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 解决问题的一个有用策略是分层处理问题。首先，简化问题，解决其中较简单的变体。然后，再精炼解决方案以适应你特定（且更复杂）的问题。本节通过一个重要的方式精炼了之前的解决方案：它不允许无效的时间输入，比如`99:99`或`28:66`。因此，问题变得更加具体（且更复杂），但你可以重用我们旧解决方案的部分内容。
- en: '***The Code***'
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: Our goal is to write a function `input_ok` that takes a string argument and
    checks whether it has the (time) format *`XX`*`:`*`XX`*, where *`X`* is a number
    between 0 and 9; see [Listing 5-7](#list5-7). Additionally, the given time must
    be a valid time format in the 24-hour time ranging from 00:00 to 23:59.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是编写一个`input_ok`函数，它接受一个字符串参数并检查它是否符合（时间）格式*`XX`*`:`*`XX`*，其中*`X`*是0到9之间的数字；参见[列表5-7](#list5-7)。此外，给定的时间必须是24小时制的有效时间格式，范围从00:00到23:59。
- en: '[PRE23]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 5-7: One-liner solution to check whether a given user input matches
    the general time format `XX:XX` and is valid in the 24-hour time*'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表5-7：单行解决方案，检查给定的用户输入是否符合通用时间格式`XX:XX`并在24小时制时间中有效*'
- en: This code prints six lines. What are they?
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码打印了六行。它们是什么？
- en: '***How It Works***'
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***工作原理***'
- en: 'As mentioned in the introduction of this section, you can reuse the solution
    of the previous one-liner to solve this problem easily. The code stays the same—you
    modified only the regular expression `([01][0-9]|2[0-3]):[0-5][0-9]`. The first
    part `([01][0-9]|2[0-3])` is a group that matches all possible hours of the day.
    You use the or operator `|` to differentiate hours 00 to 19 on the one hand, and
    hours 20 to 23 on the other hand. The second part `[0-5][0-9]` matches the minutes
    of the day from 00 to 59\. The result is, therefore, as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如本节引言所述，你可以重用之前那行代码的解决方案，轻松解决这个问题。代码保持不变——你只是修改了正则表达式`([01][0-9]|2[0-3]):[0-5][0-9]`。第一部分`([01][0-9]|2[0-3])`是一个分组，匹配一天中所有可能的小时。你使用了或操作符`|`来区分00到19小时和20到23小时。第二部分`[0-5][0-9]`匹配一天中的分钟，从00到59。因此，结果如下：
- en: '[PRE24]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note that the sixth line of the output indicates that the time `99:99` is no
    longer considered a valid user input. This one-liner shows how to use regular
    expressions to check whether the user input matches the semantic requirements
    of your application.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，输出的第六行表示时间`99:99`不再被视为有效的用户输入。这个单行代码展示了如何使用正则表达式检查用户输入是否符合应用程序的语义要求。
- en: '**Duplicate Detection in Strings**'
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字符串中的重复检测**'
- en: 'This one-liner introduces an exciting capability of regular expressions: reusing
    parts you’ve already matched later in the same regex. This powerful extension
    allows you to solve a new set of problems, including detecting strings with duplicated
    characters.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行代码引入了正则表达式的一个令人兴奋的功能：在同一个正则表达式中重用你已经匹配过的部分。这一强大的扩展功能让你能够解决一系列新问题，包括检测含有重复字符的字符串。
- en: '***The Basics***'
  id: totrans-167
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基础***'
- en: This time, you’re working as a computer linguistics researcher analyzing how
    certain word usages change over time. You use published books to classify and
    track word usage. Your professor asks you to analyze whether there’s a trend toward
    a more frequent use of duplicate characters in words. For example, the word `'hello'`
    contains the duplicate character `'l'`, while the word `'spoon'` contains the
    duplicate character `'o'`. However, the word `'mama``'` would not be counted as
    a word with a duplicate character `'a'`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，你作为计算机语言学研究员，正在分析某些单词用法如何随着时间的推移而变化。你使用已发布的书籍来分类和跟踪单词的使用情况。你的教授要求你分析单词中是否有更多的重复字符使用趋势。例如，单词
    `'hello'` 包含重复字符 `'l'`，而单词 `'spoon'` 包含重复字符 `'o'`。然而，单词 `'mama'` 不会被视为包含重复字符 `'a'`
    的单词。
- en: The naive solution to this problem is to enumerate all possible duplicate characters
    `'aa'`, `'bb'`, `'cc'`, `'dd'`, . . . , `'zz'` and combine them in an either-or
    regex. This solution is tedious and not easily generalized. What if your professor
    changes their mind and asks you to check for repeat characters with up to one
    character in between (for example, the string `'mama'` would now be a match)?
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的简单方法是列举所有可能的重复字符 `'aa'`、`'bb'`、`'cc'`、`'dd'`，...，`'zz'`，并将它们结合成一个或的正则表达式。这种方法繁琐且难以泛化。如果你的教授改变主意，要求你检查两个字符之间最多隔一个字符的重复字符（例如，字符串
    `'mama'` 现在就能匹配）呢？
- en: 'No problem: there’s a simple, clean, and effective solution if you know the
    regex feature of named groups. You’ve already learned about groups that are enclosed
    in parentheses `(...)`. As the name suggests, a *named group* is just a group
    with a name. For instance, you can define a named group around the pattern `...`
    with the name `name` by using the syntax `(?P<name>...)`. After you define a named
    group, you can use it anywhere in your regular expression with the syntax `(?P=name)`.
    Consider the following example:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 没问题：如果你了解正则表达式中命名分组的功能，就有一个简单、清晰且有效的解决方案。你已经学习过被括号 `(...)` 包围的分组。如其名所示，*命名分组*就是一个带有名称的分组。例如，你可以通过使用语法
    `(?P<name>...)` 将模式 `...` 定义为名为 `name` 的命名分组。在定义了命名分组后，你可以在正则表达式的任何地方使用它，语法是 `(?P=name)`。考虑以下示例：
- en: '[PRE25]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the code, you search for substrings that are enclosed in either single or
    double quotes. To accomplish that, you first match the opening quote by using
    the regex `['"]` (you escape the single quote, `\`’, to avoid Python wrongly assuming
    that the single quote indicates the end of the string). Then, you use the same
    group to match the closing quote of the same character (either a single or double
    quote).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，你会搜索被单引号或双引号包围的子字符串。为此，首先通过正则表达式 `['"]` 匹配开头的引号（你需要转义单引号 `\`'`，以防止 Python
    错误地认为单引号表示字符串的结束）。然后，你使用相同的分组来匹配与之对应的闭合引号（无论是单引号还是双引号）。
- en: Before diving into the code, note that you can match arbitrary whitespaces with
    the regex `\s`. Also, you can match characters that are *not* in a set `Y` by
    using the syntax `[^Y]`. That’s everything you need to know to solve our problem.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入代码之前，注意你可以使用正则表达式 `\s` 来匹配任意空白字符。此外，使用语法 `[^Y]` 你可以匹配不在集合 `Y` 中的字符。这就是解决问题所需了解的全部内容。
- en: '***The Code***'
  id: totrans-174
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: 'Consider the problem illustrated in [Listing 5-8](#list5-8): given a text,
    find all words that contain duplicate characters. A *word* in this case is defined
    as any series of non-whitespace characters separated by an arbitrary number of
    whitespace characters.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑[列表 5-8](#list5-8)中说明的问题：给定一段文本，找出所有包含重复字符的单词。在这种情况下，*单词*被定义为任何由非空白字符组成的字符串，这些字符之间由任意数量的空白字符分隔。
- en: '[PRE26]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Listing 5-8: One-liner solution to find all duplicate characters*'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-8：一行代码解决方案查找所有重复字符*'
- en: What are the words with duplicate characters found in this code?
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，找到哪些单词包含重复字符？
- en: '***How It Works***'
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***工作原理***'
- en: The regex `(?P<x>[^\s])` defines a new group with the name `x`. The group consists
    of only a single arbitrary character that is not the whitespace character. The
    regex `(?P=x)` immediately follows the named group `x`. It simply matches the
    same character matched by the group `x`. You’ve found the duplicate characters!
    However, the goal is not to find duplicate characters, but words with duplicate
    characters. So you match an arbitrary number of non-whitespace characters `[^\s]*`
    before and after the duplicate characters.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式`(?P<x>[^\s])`定义了一个名为`x`的新分组。该分组仅由一个不是空格字符的任意字符组成。正则表达式`(?P=x)`紧随其后，匹配与`x`分组匹配的相同字符。你已经找到了重复字符！然而，目标不是查找重复字符，而是查找具有重复字符的单词。所以你在重复字符前后匹配任意数量的非空格字符`[^\s]*`。
- en: 'The output of [Listing 5-8](#list5-8) is the following:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5-8](#list5-8)的输出如下：'
- en: '[PRE27]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The regex finds all words with duplicate characters in the text. Note that there
    are two groups in the regex of [Listing 5-8](#list5-8), so every element returned
    by the `re.findall()` function consists of a tuple of matched groups. You’ve already
    seen this behavior in previous sections.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式会查找文本中所有具有重复字符的单词。请注意，在[列表 5-8](#list5-8)中的正则表达式有两个分组，因此`re.findall()`函数返回的每个元素都是一个匹配分组的元组。你在前面的章节中已经看过这种行为。
- en: 'In this section, you’ve enhanced your regex tool set with one powerful tool:
    named groups. In combination with two minor regex features of matching arbitrary
    whitespace characters with `\s` and defining a set of characters that are not
    matched with the operator `[^...]`, you’ve made serious progress toward Python
    regex proficiency.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，你增强了你的正则表达式工具集，增加了一个强大的工具：命名分组。结合使用`\s`匹配任意空格字符和`[^...]`操作符定义不匹配的字符集这两个小的正则表达式特性，你已经在Python正则表达式的掌握上取得了实质性的进展。
- en: '**Detecting Word Repetitions**'
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**检测词汇重复**'
- en: In the preceding section, you learned about named groups. The goal of this section
    is to show you more advanced ways of using this powerful feature.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你学习了命名分组。本节的目标是向你展示更多使用这个强大特性的高级方法。
- en: '***The Basics***'
  id: totrans-187
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基础知识***'
- en: While working as a researcher over the last few years, I spent most of my time
    writing, reading, and editing research papers. When editing my research papers,
    a colleague used to complain that I was using the same words repeatedly (and too
    closely in the text). Wouldn’t it be useful to have a tool that checks your writing
    programmatically?
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几年里，我作为一名研究人员，花费大部分时间写作、阅读和编辑研究论文。在编辑我的研究论文时，一位同事常常抱怨我反复使用相同的词汇（并且在文中使用得太密集）。如果有一个工具能够以编程方式检查你的写作，岂不是很有用？
- en: '***The Code***'
  id: totrans-189
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: You’re given a string consisting of lowercase, whitespace-separated words, without
    special characters. Find a matching substring where the first and the last word
    are the same (repetition) and in-between are at most 10 words. See [Listing 5-9](#list5-9).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个由小写字母和空格分隔的单词组成的字符串，没有特殊字符。找出一个匹配的子字符串，其中第一个和最后一个单词相同（重复），并且中间最多有10个单词。参见[列表
    5-9](#list5-9)。
- en: '[PRE28]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*Listing 5-9: One-liner solution to find word repetitions*'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-9：查找词汇重复的单行解决方案*'
- en: Does this code find word repetitions?
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码能找到词汇重复吗？
- en: '***How It Works***'
  id: totrans-194
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***工作原理***'
- en: 'Again, you assume that a given `text` consists of only whitespace-separated,
    lowercase words. Now, you search the `text` by using a regular expression. It
    might look complex at first, but let’s break it down piece by piece:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 再次假设给定的`text`仅由空格分隔的小写字母单词组成。现在，你通过正则表达式来搜索`text`。乍一看可能有点复杂，但让我们逐步分析：
- en: '[PRE29]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You start with a single whitespace character. This is important to ensure that
    you start with a whole word (and not with a suffix of a word). Then, you match
    a named group `x` that consists of a positive number of lowercase characters from
    `'``a'` to `'z'`, followed by a positive number of whitespaces ➊.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 你从一个空格字符开始。这一点很重要，确保你从一个完整的单词开始（而不是单词的后缀）。接着，匹配一个名为`x`的分组，`x`由一个正数个小写字母字符（从`'a'`到`'z'`）组成，后面跟着一个正数个空格字符
    ➊。
- en: You proceed with 0 to 10 words, where each word consists of a positive number
    of lowercase characters from `'a'` to `'z'`, followed by a positive number of
    whitespaces ➋.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你继续匹配0到10个单词，每个单词由一个正数个小写字母字符（从`'a'`到`'z'`）组成，后面跟着一个正数个空格字符 ➋。
- en: You finish with the named group `x`, followed by a whitespace character to ensure
    that the last match is a whole word (and not only a prefix of a word) ➌.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 你以命名分组`x`结束，后面跟一个空格字符，确保最后的匹配是一个完整的单词（而不是单词的前缀） ➌。
- en: 'The following is the output of the code snippet:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是代码片段的输出：
- en: '[PRE30]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You found a matching substring that may (or may not) be considered as bad style.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你发现了一个匹配的子字符串，它可能（也可能不）被认为是不好的样式。
- en: In this one-liner, you stripped down the problem of finding duplicate words
    to its core and solved this easier variant. Note that in practice, you’d have
    to include more complicated cases such as special characters, a mix of lowercase
    and uppercase characters, numbers, and so on. Alternatively, you could do some
    preprocessing to bring the text into the desired form of lowercase, whitespace-separated
    words, without special characters.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个单行代码中，你将查找重复单词的问题简化到了核心，并解决了这个更简单的变种。请注意，实际上你需要考虑更复杂的情况，例如特殊字符、小写字母和大写字母的混合、数字等。或者，你也可以做一些预处理，将文本转换为期望的形式，例如小写字母、空格分隔的单词，没有特殊字符。
- en: '**EXERCISE 5-1**'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 5-1**'
- en: Write a Python script that allows for more special characters, such as characters
    to structure your sentences (period, colon, comma).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个 Python 脚本，允许使用更多特殊字符，例如用于结构化句子的字符（句号、冒号、逗号）。
- en: '**Modifying Regex Patterns in a Multiline String**'
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**在多行字符串中修改正则表达式模式**'
- en: In the final regex one-liner, you’ll learn how to modify a text rather than
    matching only parts of it.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后的正则表达式单行中，你将学习如何修改文本，而不仅仅是匹配其中的一部分。
- en: '***The Basics***'
  id: totrans-208
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基础知识***'
- en: To replace all occurrences of a certain `regex` pattern with a new string `replacement`
    in a given `text`, use the regex function `re.sub(regex,` `replacement``,` `text)`.
    This way, you can quickly edit large text bases without a lot of manual labor.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 要将某个正则表达式 `regex` 模式的所有出现替换为新字符串 `replacement`，可以使用正则表达式函数 `re.sub(regex, replacement,
    text)`。通过这种方式，你可以快速编辑大规模文本数据，而无需进行大量的手动操作。
- en: In the previous sections, you learned how to match patterns that occur in the
    text. But what if you don’t want to match a certain pattern if another pattern
    occurs? The *negative lookahead* regex pattern `A(?!X)` matches a regex `A` if
    the regex `X` does not match afterward. For example, the regex `not (?!good)`
    would match the string `'this is not great'` but would not match the string `'this
    is not good'`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你学习了如何匹配文本中出现的模式。但是如果你不想在某个模式出现时匹配另一个模式该怎么办？*负向前瞻*正则表达式 `A(?!X)` 会匹配正则表达式
    `A`，前提是后面不跟着正则表达式 `X`。例如，正则表达式 `not (?!good)` 会匹配字符串 `'this is not great'`，但不会匹配字符串
    `'this is not good'`。
- en: '***The Code***'
  id: totrans-211
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: Our data is a string, and our task is to replace all occurrences of `Alice Wonderland`
    with `'Alice Doe'`, but not to replace occurrences of `'Alice Wonderland'` (enclosed
    in single quotes). See [Listing 5-10](#list5-10).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据是一个字符串，我们的任务是将所有出现的 `Alice Wonderland` 替换为 `'Alice Doe'`，但不替换那些被单引号包围的
    `'Alice Wonderland'`。参见 [清单 5-10](#list5-10)。
- en: '[PRE31]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '*Listing 5-10: One-liner solution to replace patterns in a text*'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-10：替换文本中模式的单行解决方案*'
- en: This code prints the updated text. What is it?
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码会打印更新后的文本。它是什么？
- en: '***How It Works***'
  id: totrans-216
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***原理***'
- en: 'You replace all occurrences of `Alice Wonderland` with `Alice Doe`, but not
    the ones that end with the single quote `''`. You do this by using a negative
    lookahead. Note that you check only whether the closing quote exists. For example,
    a string *with* an opening quote but *without* a closing quote would match, and
    you’d simply replace it. This may not be desired in general, but it leads to the
    desired behavior in our example string:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 你将所有的 `Alice Wonderland` 替换为 `Alice Doe`，但不包括那些以单引号 `'` 结尾的。你通过使用负向前瞻来实现这一点。请注意，你只检查闭合引号是否存在。例如，包含开引号但没有闭引号的字符串会匹配，你可以简单地替换它。这在一般情况下可能不是期望的行为，但在我们的示例字符串中，它能达到预期效果：
- en: '[PRE32]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You can see that the original name of `'Alice Wonderland'` is left unchanged
    when enclosed in single quotes—which was the goal of this code snippet.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，原始的 `'Alice Wonderland'` 在被单引号包围时保持不变——这正是这段代码的目标。
- en: '**Summary**'
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: This chapter covered a lot of ground. You’ve learned about regular expressions,
    which you can use to match patterns in a given string. In particular, you’ve learned
    about the functions `re.compile()`, `re.match()`, `re.search()`, `re.findall()`,
    and `re.sub()`. Together, they cover a high percentage of regular expression use
    cases. You can pick up other functions as you apply regular expressions in practice.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 本章内容涵盖了许多内容。你学习了正则表达式，可以用它来匹配给定字符串中的模式。特别是，你学习了 `re.compile()`、`re.match()`、`re.search()`、`re.findall()`
    和 `re.sub()` 等函数。它们共同涵盖了正则表达式的绝大多数应用场景。你可以在实际使用正则表达式时，学习其他函数。
- en: You’ve also learned about various basic regular expressions that you can combine
    (and recombine) in order to create more advanced regular expressions. You’ve learned
    about whitespaces, escaped characters, greedy/nongreedy operators, character sets
    (and negative characters sets), grouping and named groups, and negative lookaheads.
    And finally, you’ve learned that it’s often better to solve a simplified variant
    of the original problem than trying to generalize too early.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 你还学习了各种基本的正则表达式，可以组合（并重新组合）以创建更高级的正则表达式。你已经了解了空白字符，转义字符，贪婪/非贪婪操作符，字符集（和负字符集），分组和命名分组，以及负向先行断言。最后，你已经了解到，解决原始问题的简化变体往往比过早泛化更好。
- en: The only thing left is to apply your new regex skill in practice. A good way
    of getting used to regular expressions is to start using them in your favorite
    text editor. Most advanced text and code editors (including Notepad++) ship with
    powerful regular expression functionality. Also, consider regular expressions
    when working with textual data (for example when writing emails, blog articles,
    books, and code). Regular expressions will make your life easier and save you
    many hours of tedious work.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一剩下的就是把你新学的正则表达式技能应用到实践中。熟悉正则表达式的一个好方法是开始在你喜爱的文本编辑器中使用它们。大多数高级文本和代码编辑器（包括Notepad++）都配备了强大的正则表达式功能。此外，在处理文本数据时（例如写电子邮件、博客文章、书籍和代码时），考虑使用正则表达式。正则表达式将让你的生活更轻松，节省许多繁琐工作时间。
- en: 'In the next chapter, we’ll dive into the supreme discipline of coding: algorithms.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨编程的至高纪律：算法。
