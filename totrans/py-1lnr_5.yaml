- en: '**5'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**5**'
- en: REGULAR EXPRESSIONS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**正则表达式**'
- en: '![Image](Images/comm-1.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/comm-1.jpg)'
- en: Are you an office worker, student, software developer, manager, blogger, researcher,
    author, copywriter, teacher, or self-employed freelancer? Most likely, you’re
    spending many hours in front of your computer, day after day. Improving your daily
    productivity—only by a small fraction of a percentage—will mean a gain of thousands,
    if not tens of thousands, of dollars of productivity and hundreds of hours of
    additional free time over the years.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你是办公室职员、学生、软件开发者、经理、博主、研究员、作家、文案、教师，还是自由职业者？很可能，你每天都在电脑前度过许多小时。如果能稍微提高你的日常工作效率，哪怕只是一个小小的百分比，也能带来数千甚至数万美元的生产力提升，以及数百小时的额外空闲时间。
- en: 'This chapter shows you an undervalued technique that helps master coders be
    more efficient when working with textual data: using regular expressions. This
    chapter shows you 10 ways of using regular expressions to solve everyday problems
    with less effort, time, and energy. Study this chapter about regular expressions
    carefully—it’ll be worth your time!'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向你展示了一种被低估的技术，帮助高级程序员在处理文本数据时更高效：使用正则表达式。本章将展示10种使用正则表达式来解决日常问题的方法，这些方法能节省你大量的时间、精力和工作量。仔细学习本章内容——它会是值得你投入的时间！
- en: '**Finding Basic Textual Patterns in Strings**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**在字符串中查找基本文本模式**'
- en: This section introduces regular expressions using the `re` module and its important
    `re.findall()` function. I’ll start by explaining several basic regular expressions.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了使用`re`模块和其重要的`re.findall()`函数的正则表达式。我将从解释几个基本的正则表达式开始。
- en: '***The Basics***'
  id: totrans-7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基础知识***'
- en: A *regular expression* (*regex*, for short) formally describes a search *pattern*
    that you can use to match sections of text. The simple example in [Figure 5-1](#ch05fig01)
    shows a search of Shakespeare’s text *Romeo and Juliet* for the pattern `Juliet`.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*正则表达式*（简称*regex*）正式描述了一个搜索*模式*，你可以用它来匹配文本的某些部分。[图5-1](#ch05fig01)中的简单示例展示了如何在莎士比亚的《罗密欧与朱丽叶》文本中搜索`Juliet`模式。'
- en: '![images](Images/fig5-1.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![images](Images/fig5-1.jpg)'
- en: '*Figure 5-1: Searching Shakespeare’s* Romeo and Juliet *for the pattern `Juliet`*'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-1：在莎士比亚的《罗密欧与朱丽叶》中搜索模式`Juliet`*'
- en: '[Figure 5-1](#ch05fig01) shows that the most basic regular expression is a
    simple string pattern. The string `''Juliet''` is a perfectly valid regular expression.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5-1](#ch05fig01)展示了最基础的正则表达式是一个简单的字符串模式。字符串`''Juliet''`就是一个完全有效的正则表达式。'
- en: Regular expressions are incredibly powerful, and can do much more than regular
    text search, but they’re built using only a handful of basic commands. Learn these
    basic commands and you’ll be able to understand and write complex regular expressions.
    In this section, we’ll focus on the three most important regex commands that extend
    the functionality of simple search of string patterns in a given text.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式功能强大，能够做的不仅仅是常规的文本搜索，但它们仅由少数几个基本命令构建。掌握这些基本命令，你就能理解并编写复杂的正则表达式。在本节中，我们将重点介绍三条最重要的正则表达式命令，它们扩展了在给定文本中简单字符串模式搜索的功能。
- en: '**The Dot Regex**'
  id: totrans-13
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**点号正则表达式**'
- en: 'First, you need to know how to match an arbitrary character by using the *dot
    regex*, the `.` character. The dot regex matches any character (including whitespace
    characters). You can use it to indicate that you don’t care which character matches,
    as long as *exactly one* matches:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要知道如何使用*点号正则表达式*（`.`字符）来匹配任意字符。点号正则表达式可以匹配任何字符（包括空白字符）。你可以使用它来表示你不在乎匹配的是什么字符，只要*恰好匹配一个*字符即可：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This example uses the `findall()` method of the `re` module. The first argument
    is the regex itself: you search for any string pattern starting with the character
    `''b''`, followed by three arbitrary characters, `...` , followed by the character
    `''k''`. This regex `b...k` matches the word `''block''` but also `''boook''`,
    `''b erk''`, and `''bloek''`. The second parameter to `findall()` is the `text`
    you’re searching. The string variable `text` contains three matching patterns,
    as you can see in the output of the `print` statement.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例使用了`re`模块的`findall()`方法。第一个参数是正则表达式本身：你搜索的是任何以字符`'b'`开头、接着三个任意字符`...`、最后是字符`'k'`的字符串模式。这个正则表达式`b...k`匹配单词`'block'`，但也匹配`'boook'`、`'b
    erk'`和`'bloek'`。`findall()`的第二个参数是你要搜索的`text`文本。字符串变量`text`包含了三个匹配模式，正如你在`print`语句的输出中看到的那样。
- en: '**The Asterisk Regex**'
  id: totrans-17
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**星号正则表达式**'
- en: 'Second, say you want to match text that begins and ends with the character
    `''y''` and an arbitrary number of characters in between. How do you accomplish
    this? You can do by this using the *asterisk regex*, the `*` character. Unlike
    the dot regex, the asterisk regex can’t stand on its own; it modifies the meaning
    of another regex. Consider the following example:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The asterisk operator applies to the regex immediately in front of it. In this
    example, the regex pattern starts with the character `''``y``''`, followed by
    an arbitrary number of characters, `.*`, followed by the character `''``y``''`.
    As you can see, the word `''cryptography''` contains one such instance of this
    pattern: `''yptography''`.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: You may wonder why this code doesn’t find the long substring between `'originally``'`
    and `'cryptography'`, which should also match the regex pattern `y.*y`. The reason
    is simply that the dot operator matches any character except the newline character.
    The string stored in the variable `text` is a multiline string with three new
    lines. You can also use the asterisk operator in combination with any other regex.
    For example, you can use the regex `abc*` to match the strings `'ab'`, `'abc'`,
    `'abcc'`, and `'abccdc'`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '**The Zero-or-one Regex**'
  id: totrans-22
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Third, you need to know how to match zero or one characters by using the *zero-or-one
    regex*, the `?` character. Just like the asterisk operator, the question mark
    modifies another regex, as you can see in the following example:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The zero-or-one regex, `?`, applies to the regex immediately in front of it.
    In our case, this is the character `s`. The zero-or-one regex says that the pattern
    it modifies is optional.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'There is another use of the question mark in Python’s `re` package, but it
    has nothing to do with the zero-or-one regex: the question mark can be combined
    with the asterisk operator, `*?`, to allow for *nongreedy* pattern matching. For
    example, if you use the regex `.*?`, Python searches for a minimal number of arbitrary
    characters. In contrast, if you use the asterisk operator `*` without the question
    mark, it *greedily* matches as many characters as possible.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example. When searching the HTML string `''<div>hello world</div>''`
    by using the regex `<.*>`, it matches the whole string `''<div>hello world</div>''`
    rather than only the prefix `''<div>''`. If you want only the prefix, you can
    use the nongreedy regex `<.*?>`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Equipped with these three tools—the dot regex `.`, the asterisk regex `*`, and
    the zero-or-one regex `?`—you’re now able to comprehend the next one-liner solution.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Our input is a string, and our goal is to use a nongreedy approach to find all
    patterns that start with the character `'p'`, end with the character `'r'`, and
    have at least one occurrence of the character `'e'` (and, possibly, an arbitrary
    number of other characters) in between!
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: These types of text queries occur quite frequently—especially in companies that
    focus on text processing, speech recognition, or machine translation (such as
    search engines, social networks, or video platforms). Take a look at [Listing
    5-1](#list5-1).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型的文本查询非常常见——尤其是在专注于文本处理、语音识别或机器翻译的公司中（如搜索引擎、社交网络或视频平台）。请查看[清单 5-1](#list5-1)。
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 5-1: One-liner solution to search for specific phrases (nongreedy)*'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-1：搜索特定短语的单行解决方案（非贪婪模式）*'
- en: This code prints a list of all matching phrases in the `text`. What are they?
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码会打印出 `text` 中所有匹配的短语。它们是什么？
- en: '***How It Works***'
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***工作原理***'
- en: 'The regex search query is `p.*?e.*?r`. Let’s break this down. You’re looking
    for a phrase that starts with the character `''p''` and ends with the character
    `''r''`. Between those two characters, you require one occurrence of the character
    `''e''`. Apart from that, you allow an arbitrary number of characters (whitespace
    or not). However, you match in a nongreedy manner by using `.*?`, which means
    Python will search for a minimal number of arbitrary characters. Here’s the solution:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式搜索查询是`p.*?e.*?r`。让我们来分解一下。你在寻找一个以字符 `'p'` 开头并以字符 `'r'` 结尾的短语。在这两个字符之间，你需要至少出现一次字符
    `'e'`。除此之外，你允许任意数量的字符（无论是否有空格）。然而，你通过使用`.*?`以非贪婪的方式进行匹配，这意味着 Python 将搜索尽可能少的任意字符。以下是解决方案：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Compare this solution with the one you’d get when using the greedy regex `p.*e.*r`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个解决方案与使用贪婪正则表达式 `p.*e.*r` 时得到的结果进行比较：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The first greedy asterisk operator `.*` matches almost the whole string before
    it terminates.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个贪婪星号操作符 `.*` 匹配几乎整个字符串，直到它终止。
- en: '**Writing Your First Web Scraper with Regular Expressions**'
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用正则表达式编写你的第一个网页抓取器**'
- en: 'In the previous section, you learned about the most powerful way to find arbitrary
    text patterns in strings: regular expressions. This section will further motivate
    your use of regular expressions and develop your knowledge with a practical example.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你学习了在字符串中查找任意文本模式的最强大方法：正则表达式。本节将进一步激发你使用正则表达式的动力，并通过一个实际的例子来拓展你的知识。
- en: '***The Basics***'
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基础知识***'
- en: Suppose you’re working as a freelance software developer. Your client is a fintech
    startup that needs to stay updated about the latest developments in cryptocurrency.
    They hire you to write a web scraper that regularly pulls the HTML source code
    of news websites and searches it for words starting with `'crypto'` (for example,
    `'cryptocurrency'`, `'crypto-bot'`, `'crypto-crash'`, and so on).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在作为自由职业的软件开发者工作。你的客户是一家金融科技初创公司，需要及时了解加密货币的最新发展。他们雇佣你编写一个网页抓取器，定期获取新闻网站的
    HTML 源代码，并在其中搜索以 `'crypto'` 开头的词汇（例如，`'cryptocurrency'`、`'crypto-bot'`、`'crypto-crash'`
    等等）。
- en: 'Your first attempt is the following code snippet:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你第一次尝试的代码片段如下：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The method `urlopen()` (from the module `urllib.request`) pulls the HTML source
    code from the specified URL. Because the result is a byte array, you have to first
    convert it to a string by using the `decode()` method. Then you use the string
    method `find()` to return the position of the first occurrence of the searched
    string. With slicing (see [Chapter 2](ch02.xhtml#ch02)), you carve out a substring
    that returns the immediate environment of the position. The result is the following
    string:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 方法`urlopen()`（来自模块`urllib.request`）从指定的 URL 获取 HTML 源代码。由于结果是字节数组，因此你必须先使用`decode()`方法将其转换为字符串。然后，你使用字符串方法`find()`返回搜索字符串第一次出现的位置。通过切片（请参见[第
    2 章](ch02.xhtml#ch02)），你提取出一个子字符串，返回该位置的即时环境。结果是以下字符串：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Aw. That looks bad. As it turns out, the search phrase is ambiguous—most words
    containing `'crypto'` are semantically unrelated to *cryptocurrencies*. Your web
    scraper generates *false positives* (it finds string results that you originally
    didn’t mean to find). So how can you fix it?
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，这看起来不太好。事实证明，搜索短语是模糊的——包含 `'crypto'` 的大多数单词在语义上与*加密货币*无关。你的网页抓取器生成了*假阳性*（它找到了你原本并不想找到的字符串结果）。那么你该如何解决呢？
- en: 'Luckily, you’ve just read this Python book, so the answer is obvious: regular
    expressions! Your idea to remove false positives is to search for occurrences
    in which the word `''crypto''` is followed by up to 30 arbitrary characters, followed
    by the word `coin`. Roughly speaking, the search query is `crypto +` *`<up to
    30 arbitrary characters>`* `+ coin`. Consider the following two examples:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '`''``crypto-bot that is trading Bitcoin''`—yes'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''``cryptographic encryption methods that can be cracked easily with quantum
    computers``''`—no'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So how to solve this problem of allowing up to 30 arbitrary characters between
    two strings? This goes beyond a simple string search. You can’t enumerate every
    exact string pattern—a virtually infinite number of matches is allowed. For example,
    the search pattern must match all of the following: `''cryptoxxxcoin''`, `''crypto
    coin''`, `''crypto bitcoin''`, `''crypto is a` `currency``. Bitcoin''`, and all
    other character combinations with up to 30 characters between the two strings.
    Even if you had only 26 characters in the alphabet, the number of strings that
    would theoretically match our requirement exceeds 26[30] = 2,813,198,901,284,745,919,258,621,029,615,971,520,741,376\.
    In the following, you’ll learn how to search a text for a regex pattern that corresponds
    to a large number of possible string patterns.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Here, given a string, you will find occurrences in which the string `'crypto'`
    is followed by up to 30 arbitrary characters, followed by the string `'coin'`.
    Let’s first look at [Listing 5-2](#list5-2) before discussing how the code solves
    the problem.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 5-2: One-liner solution to find text snippets in the form `crypto``(some
    text)``coin`*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: This code searches two string variables, `text_1` and `text_2`. Does the search
    query (pattern) match them?
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First, you import the standard module for regular expressions in Python, called
    `re`. The important stuff happens in the one-liner where you compile the search
    query `crypto(.{1,30})coin`. This is the query that you can use to search various
    strings. You use the following special regex characters. Read them from top to
    bottom and you’ll understand the meaning of the pattern in [Listing 5-2](#list5-2):'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '`()` matches whatever regex is inside.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.`  matches an arbitrary character.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{1,30}` matches between 1 and 30 occurrences of the *previous* regex.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(.{1,30})` matches between 1 and 30 arbitrary characters.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`crypto(.{1,30})coin` matches the regex consisting of three parts: the word
    `''``crypto``''`, an arbitrary sequence with 1 to 30 chars, followed by the word
    `''``coin``''`.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We say that the pattern is *compiled* because Python creates a pattern object
    that can be reused in multiple locations—much as a compiled program can be executed
    multiple times. Now, you call the function `match()` on our compiled pattern and
    the text to be searched. This leads to the following result:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The string variable `text_1` matches the pattern (indicated by the resulting
    match object), but `text_2` doesn’t (indicated by the result `None`). Although
    the textual representation of the first matching object doesn’t look pretty, it
    gives a clear hint that the given string `'crypto-bot that is trading Bitcoin'`
    matches the regular expression.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '**Analyzing Hyperlinks of HTML Documents**'
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the preceding section, you learned how to search a string for a large number
    of patterns by using the regex pattern `.{x,y}`. This section goes further, introducing
    many more regular expressions.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '***The Basics***'
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Knowing more regular expressions will help you solve real-world problems quickly
    and concisely. So what are the most important regular expressions? Study the following
    list carefully because we’ll use all of them in this chapter. Just view the ones
    you’ve already seen as a small repetition exercise.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: The dot regex `.` matches an arbitrary character.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The asterisk regex *`<pattern>`*`*` matches an arbitrary number of the regex
    *`<pattern>`*. Note that this includes zero matching instances.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The at-least-one regex *`<pattern>`*`+` can match an arbitrary number of *`<pattern>`*
    but must match at least one instance.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The zero-or-one regex *`<pattern>`*`?` matches either zero or one instances
    of *`<pattern>`*.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The nongreedy asterisk regex `*?` matches as few arbitrary characters as possible
    to match the overall regex.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The regex *`<pattern>`*`{m}` matches exactly `m` copies of *`<pattern>`*.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The regex *`<pattern>`*`{m,n}` matches between `m` and `n` copies of *`<pattern>`*.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The regex *`<pattern_1>`*`|`*`<pattern_2>`* matches either *`<pattern_1>`* or
    *`<pattern_2>`*.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The regex *`<pattern_1><pattern_2>`* matches *`<pattern_1>`* and then *`<pattern_2>`*.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The regex `(`*`<pattern>`*`)` matches *`<pattern>`*. The parentheses group regular
    expressions so you can control the order of execution (for example, `(`*`<pattern_1><pattern_2>`*`)|`*`<pattern_3>`*
    is different from *`<pattern_1>`* `(`*`<pattern_2>`*`|`*`<pattern_3>`*`)`. The
    parentheses regex also creates a matching group, as you’ll see later in the section.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s consider a short example. Say you create the regex `b?(.a)*`. Which patterns
    will the regex match? The regex matches all patterns starting with zero or one
    `b` and an arbitrary number of two-character-sequences ending in the character
    `'a'`. Hence, the strings `'bcacaca'`, `'cadaea'`, `''` (the empty string), and
    `'aaaaaa'` would all match the regex.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 'Before diving into the next one-liner, let’s quickly discuss when to use which
    *regex function*. The three most important regex functions are `re.match()`, `re.search()`,
    and `re.findall()`. You’ve already seen two of them, but let’s study them more
    thoroughly in this example:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: All three functions take the regex and the string to be searched as an input.
    The `match()` and `search()` functions return a match object (or `None` if the
    regex did not match anything). The match object stores the position of the match
    and more advanced meta-information. The function `match()` does not find the regex
    in the string (it returns `None`). Why? Because the function looks for the pattern
    only *at the beginning* of the string. The function `search()` searches for the
    first occurrence of the regex *anywhere* in the string. Therefore, it finds the
    match `"Christmas has come and gone and I didn't"`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'The `findall()` function has the most intuitive output, but it’s also the least
    useful for further processing. The result of `findall()` is a sequence of strings
    rather than a match object—so it doesn’t give us information about the precise
    location of the match. That said, `findall()` has its uses: in contrast to the
    `match()` and `search()` methods, the function `findall()` retrieves *all* matched
    patterns, which is useful when you want to quantify how often a word appears in
    a text (for example, the string `''Juliet''` in the text `''Romeo and Juliet''`
    or the string `''crypto''` in an article about cryptocurrency).'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say your company asks you to create a small web bot that crawls web pages and
    checks whether they contain links to the domain *finxter.com*. They also ask you
    to make sure the hyperlink descriptions contain the strings `''test''` or `''puzzle''`.
    In HTML, hyperlinks are enclosed in an `<a></a>` tag environment. The hyperlink
    itself is defined as the value of the `href` attribute. So more precisely, the
    goal is to solve the following problem, depicted in [Listing 5-3](#list5-3): given
    a string, find all hyperlinks that point to the domain *finxter.com* and contain
    the strings `''test''` or `''puzzle''` in the link description.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 5-3: One-liner solution to analyze web page links*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: This code finds two occurrences of the regular expression. Which ones?
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The data consists of a simple HTML web page (stored as a multiline string) containing
    a list of hyperlinks (the tag environment `<a href="">`*`link text`*`</a>`). The
    one-liner solution uses the function `re.findall()` to check the regular expression
    `(<a.*?finxter.*?(test|puzzle).*?>)`. This way, the regular expression returns
    all occurrences in the tag environment `<a. . .>` with the following restrictions.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: After the opening tag, you match an arbitrary number of characters (nongreedily,
    to prevent the regex from “chewing up” multiple HTML tag environments), followed
    by the string `'finxter'`. Next, you match an arbitrary number of characters (nongreedily),
    followed by one occurrence of either the string `'test'` or the string `'puzzle'`.
    Again, you match an arbitrary number of characters (nongreedily), followed by
    the closing tag. This way, you find all hyperlink tags that contain the respective
    strings. Note that this regex also matches tags where the strings `'test'` or
    `'puzzle'` occur within the link itself. Please also note that you use only nongreedy
    asterisk operators `'.*?'` to ensure that you always search for minimal matches
    rather than matching—for example, a very long string enclosed in multiple nested
    tag environments.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在开头标签后，你匹配任意数量的字符（非贪婪地，防止正则表达式“吞噬”多个 HTML 标签环境），然后是字符串 `'finxter'`。接下来，你匹配任意数量的字符（非贪婪地），然后是
    `'test'` 或 `'puzzle'` 中的一个字符串。接着，你再次匹配任意数量的字符（非贪婪地），然后是闭合标签。这样，你就能找到所有包含这些字符串的超链接标签。请注意，这个正则表达式还匹配那些在链接本身中包含
    `'test'` 或 `'puzzle'` 的标签。还要注意，你只使用了非贪婪的星号运算符 `'.*?'`，以确保总是查找最小的匹配，而不是匹配一个被多个嵌套标签环境包围的非常长的字符串。
- en: 'The result of the one-liner is the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 单行代码的结果如下：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Two hyperlinks match our regular expression: the result of the one-liner is
    a list with two elements. However, each element is a tuple of strings rather than
    a simple string. This is different from the results of `findall()`, which we’ve
    discussed in previous code snippets. What’s the reason for this behavior? The
    return type is a list of tuples—with one tuple value for each *matching group*
    enclosed in `()`. For instance, the regex `(test|puzzle)` uses the parentheses
    notation to create a matching group. If you use matching groups in your regex,
    the function `re.findall()` will add one tuple value for every matched group.
    The tuple value is the substring that matches this particular group. For example,
    in our case, the substring `''puzzle''` matches the group `(test|puzzle)`. Let’s
    dive more deeply into the topic of matching groups to clarify this concept.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个超链接匹配我们的正则表达式：单行代码的结果是一个包含两个元素的列表。然而，每个元素是一个字符串元组，而不是一个简单的字符串。这与我们之前在代码片段中讨论的
    `findall()` 方法的结果不同。为什么会这样呢？返回类型是一个元组列表——每个匹配的*匹配组*被 `()` 包围。比如，正则表达式 `(test|puzzle)`
    使用括号表示法来创建一个匹配组。如果你在正则表达式中使用了匹配组，`re.findall()` 函数会为每个匹配的组添加一个元组值。这个元组值是匹配该组的子字符串。例如，在我们的例子中，子字符串
    `'puzzle'` 匹配了组 `(test|puzzle)`。让我们深入探讨匹配组的概念，以更清楚地理解这一点。
- en: '**Extracting Dollars from a String**'
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**从字符串中提取美元金额**'
- en: This one-liner shows you another practical application of regular expressions.
    Here, you’re working as a financial analyst. As your company considers acquiring
    another company, you’re assigned to read the other company’s reports. You’re particularly
    interested in all dollar figures. Now, you could scan the whole document manually,
    but the work is tedious, and you don’t want to spend your best hours of the day
    doing tedious work. So you decide to write a small Python script. But what’s the
    best way of doing it?
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码展示了正则表达式的另一个实际应用。在这里，你作为一名财务分析师工作。你的公司正在考虑收购另一家公司，你被分配去阅读另一家公司的报告。你特别关注所有的美元金额。现在，你可以手动扫描整篇文档，但这项工作非常繁琐，而且你不想把一天中最好的时间花在这些琐事上。所以你决定编写一个小的
    Python 脚本。但最好的做法是什么呢？
- en: '***The Basics***'
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基础知识***'
- en: Fortunately, you’ve read this regex tutorial, so instead of wasting a lot of
    time writing your own lengthy, error-prone Python parser, you go for the clean
    solution with regular expressions—a wise choice. But before you dive into the
    problem, let’s discuss three more regex concepts.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，你已经阅读了这篇正则表达式教程，因此，你无需浪费大量时间编写自己冗长且易出错的 Python 解析器，而是选择了通过正则表达式实现干净的解决方案——这是一个明智的选择。但在深入问题之前，让我们讨论三个正则表达式的概念。
- en: First, sooner or later you want to match a special character that’s also used
    as a special character by the regex language. In this case, you need to use the
    prefix `\` to *escape* the meaning of the special character. For example, to match
    the parenthesis character `'('`, which is normally used for regex groups, you
    need to escape it with the regex `\(`. This way, the regex character `'('` loses
    its special meaning.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, the square bracket environment `[ ]` allows you to define a range of
    specific characters to be matched. For example, the regex `[0-9]` matches one
    of the following characters: `''0''`, `''1''`, `''2''`, . . . , `''9''`. Another
    example is the regex `[a-e]`, which matches one of the following characters: `''a''`,
    `''b''`, `''c''`, `''d''`, `''e''`.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'Third, as we discussed in the previous one-liner section, the parentheses regex
    `(`*`<pattern>`*`)` indicates a *group*. Every regex can have one or multiple
    groups. When using the `re.findall()` function on a regex with groups, only the
    matched groups are returned as a tuple of strings—one for each group—rather than
    the whole matched string. For example, the regex `hello(world)` called on the
    string `''helloworld''` would match the whole string but return only the matched
    group `world`. On the other hand, when using two nested groups in the regex `(hello(world))`,
    the result of the `re.findall()` function would be a tuple of all matched groups
    `(''helloworld'', ''world'')`. Study the following code to understand nested groups
    completely:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, you know everything you need to know to understand the following code snippet.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To recap, you want to investigate all monetary numbers from a given company
    report. Specifically, your goal is to solve the following problem: given a string,
    find a list of all occurrences of dollar amounts with optional decimal values.
    The following example strings are valid matches: $10, $10., or $10.00021\. How
    can you achieve this efficiently in a single line of code? Take a look at [Listing
    5-4](#list5-4).'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 5-4: One-liner solution to find all dollar amounts in a text*'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a guess: what’s the output of this code snippet?'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The report contains four dollar values in various formats. The goal is to develop
    a regex that matches all of them. You design the regex `(\$[0-9]+(.[0-9]*)?)`
    that matches the following patterns. First, it matches the dollar sign `$` (you
    escape it because it’s a special regex character). Second, it matches a number
    with an arbitrary number of digits between 0 and 9 (but at least one digit). Third,
    it matches an arbitrary number of decimal values after the (escaped) dot character
    `'.'` (this last match is optional as indicated by the zero-or-one regex `?`).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'On top of that, you use list comprehension to extract only the first tuple
    value of all three resulting matches. Again, the default result of the `re.findall()`
    function is a list of tuples, with one tuple for each successful match and one
    tuple value for each group within the match:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You’re interested in only the global group—the first value in the tuple. You
    filter out the other values by using list comprehension and get the following
    result:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: It’s worth noting again that implementing even a simple parser without the powerful
    capabilities of regular expressions would be difficult and error-prone!
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '**Finding Nonsecure HTTP URLs**'
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This one-liner shows you how to solve one of those small, time-intensive problems
    that web developers often run into. Say you own a programming blog and you’ve
    just moved your website from the unsecure protocol `http` to the (more) secure
    protocol `https`. However, your old articles still point to the old URLs. How
    can you find all occurrences of the old URLs?
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '***The Basics***'
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In the preceding section, you learned how to use square bracket notation to
    specify an arbitrary range of characters. For example, the regular expression
    `[0-9]` matches a single-digit number with a value from 0 to 9\. However, the
    square bracket notation is more powerful than that. You can use an arbitrary combination
    of characters within the square brackets to specify exactly which characters match—and
    which don’t. For example, the regular expression `[0-3a-c]+` matches the strings
    `''01110''` and `''01c22a''` but not the strings `''443''` and `''00cd''`. You
    can also specify a fixed set of characters *not* to match by using the symbol
    `^`: the regular expression `[^0-3a-c]+` matches the strings `''4444d``''` and
    `''Python''` but not the strings `''001''` and `''01c22a''`.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Here our input is a (multiline) string, and our aim is to find all occurrences
    of valid URLs that start with the prefix *http://*. However, don’t consider invalid
    URLs without a top-level domain (there has to be at least one . in the found URL).
    Take a look at [Listing 5-5](#list5-5).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 5-5: One-liner solution to find valid* http:// *URLs*'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Again, try to come up with the output the code will produce before looking up
    the correct output that follows.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In the regular expression, you analyze a given multiline string (potentially
    an old blog article) to find all URLs that start with the string prefix `http://`.
    The regular expression expects a positive number of (lowercase) characters, numbers,
    underscores, hyphens, or dots (`[a-z0-9_\-\.]+`). Note that you need to escape
    the hyphen (`\-`) because it normally indicates a range within the square brackets.
    Similarly, you need to escape the dot (`\.`) because you actually want to match
    the dot and not an arbitrary character. This results in the following output:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Four valid URLs may need to be moved to the more secure HTTPS protocol.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you’ve already mastered the most important features of regular
    expressions. But there’s a level of deep understanding that you’ll reach only
    by practicing and studying a lot of examples—and regular expressions are no exception.
    Let’s study a few more practical examples of how regular expressions can make
    your life easier.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '**Validating the Time Format of User Input, Part 1**'
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s learn to check the correctness of user-input formatting. Say you write
    a web application that calculates health statistics based on the sleep duration
    of your users. Your users enter the time they went to bed and the time they wake
    up. An example for a correct time format is `12:45`, but because web bots are
    spamming your user input fields, a lot of “dirty” data is causing unnecessary
    processing overhead on your servers. To address this issue, you write a time-format
    checker that determines whether the input is worth processing further with your
    backend application. With regular expressions, writing the code takes only a few
    minutes.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '***The Basics***'
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the previous few sections, you’ve learned about the `re.search()`, `re.match()`,
    and `re.findall()` functions. These are not the only regex functions. In this
    section, you’ll use `re.fullmatch(`*`regex, string`*`)`, which checks whether
    the `regex` matches the *full* `string` as the name suggests.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, you’ll use the regex syntax *`pattern`*`{`*`m,n`*`}` that matches
    between *`m`* and *`n`* instances of the regex *`pattern`*, but no more and no
    less. Note that it attempts to match the maximal number of occurrences of *`pattern`*.
    Here’s an example:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Using the bracket notation, the code doesn’t match substrings with fewer than
    three and more than five `'x'` characters.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Our goal is to write a function `input_ok` that takes a string argument and
    checks whether it has the (time) format *`XX`*`:`*`XX`*, where *`X`* is a number
    from 0 to 9; see [Listing 5-6](#list5-6). Note that, for now, you accept semantically
    wrong time formats such as 12:86, but the next one-liner section tackles this
    more advanced problem.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 5-6: One-liner solution to check whether a given user input matches
    the general time format* XX*:*XX'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Before you move on, try to determine the results of the six function calls in
    this code.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The data consists of six input strings as received by the frontend of your web
    application. Are they correctly formatted? To check this, you create the function
    `input_ok` by using a lambda expression with one input argument `x` and a Boolean
    output. You use the function `fullmatch(`*`regex`*`, x)` and attempt to match
    the input argument `x` by using our time-formatting regex. If you couldn’t match
    it, the result takes the value `None` and the Boolean output becomes `False`.
    Otherwise, the Boolean output is `True`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'The regex is simple: `[0-9]{2}:[0-9]{2}`. This pattern matches two leading
    numbers from 0 to 9, followed by the colon`:`, followed by two trailing numbers
    from 0 to 9\. Thus, the result of [Listing 5-6](#list5-6) is the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The function `input_ok` correctly identifies the correct formats of the time
    `inputs`. In this one-liner, you’ve learned how highly practical tasks—that would
    otherwise take multiple lines of code and more effort—can be finished successfully
    in a few seconds with the right tool set.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '**Validating Time Format of User Input, Part 2**'
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section, you’ll dive deeper into validating the time format of user
    inputs to solve the problem of the previous section: invalid time inputs such
    as `99:99` should not be considered valid matches.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '***The Basics***'
  id: totrans-154
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A useful strategy to solve problems is to address them hierarchically. First,
    strip down the problem to its core and solve the easier variant. Then, refine
    the solution to match your specific (and more complicated) problem. This section
    refines the previous solution in an important way: it doesn’t allow invalid time
    inputs such as `99:99` or `28:66`. Hence, the problem is more specific (and more
    complicated), but you can reuse parts of our old solution.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Our goal is to write a function `input_ok` that takes a string argument and
    checks whether it has the (time) format *`XX`*`:`*`XX`*, where *`X`* is a number
    between 0 and 9; see [Listing 5-7](#list5-7). Additionally, the given time must
    be a valid time format in the 24-hour time ranging from 00:00 to 23:59.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 5-7: One-liner solution to check whether a given user input matches
    the general time format `XX:XX` and is valid in the 24-hour time*'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: This code prints six lines. What are they?
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As mentioned in the introduction of this section, you can reuse the solution
    of the previous one-liner to solve this problem easily. The code stays the same—you
    modified only the regular expression `([01][0-9]|2[0-3]):[0-5][0-9]`. The first
    part `([01][0-9]|2[0-3])` is a group that matches all possible hours of the day.
    You use the or operator `|` to differentiate hours 00 to 19 on the one hand, and
    hours 20 to 23 on the other hand. The second part `[0-5][0-9]` matches the minutes
    of the day from 00 to 59\. The result is, therefore, as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note that the sixth line of the output indicates that the time `99:99` is no
    longer considered a valid user input. This one-liner shows how to use regular
    expressions to check whether the user input matches the semantic requirements
    of your application.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '**Duplicate Detection in Strings**'
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This one-liner introduces an exciting capability of regular expressions: reusing
    parts you’ve already matched later in the same regex. This powerful extension
    allows you to solve a new set of problems, including detecting strings with duplicated
    characters.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '***The Basics***'
  id: totrans-167
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This time, you’re working as a computer linguistics researcher analyzing how
    certain word usages change over time. You use published books to classify and
    track word usage. Your professor asks you to analyze whether there’s a trend toward
    a more frequent use of duplicate characters in words. For example, the word `'hello'`
    contains the duplicate character `'l'`, while the word `'spoon'` contains the
    duplicate character `'o'`. However, the word `'mama``'` would not be counted as
    a word with a duplicate character `'a'`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: The naive solution to this problem is to enumerate all possible duplicate characters
    `'aa'`, `'bb'`, `'cc'`, `'dd'`, . . . , `'zz'` and combine them in an either-or
    regex. This solution is tedious and not easily generalized. What if your professor
    changes their mind and asks you to check for repeat characters with up to one
    character in between (for example, the string `'mama'` would now be a match)?
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'No problem: there’s a simple, clean, and effective solution if you know the
    regex feature of named groups. You’ve already learned about groups that are enclosed
    in parentheses `(...)`. As the name suggests, a *named group* is just a group
    with a name. For instance, you can define a named group around the pattern `...`
    with the name `name` by using the syntax `(?P<name>...)`. After you define a named
    group, you can use it anywhere in your regular expression with the syntax `(?P=name)`.
    Consider the following example:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the code, you search for substrings that are enclosed in either single or
    double quotes. To accomplish that, you first match the opening quote by using
    the regex `['"]` (you escape the single quote, `\`’, to avoid Python wrongly assuming
    that the single quote indicates the end of the string). Then, you use the same
    group to match the closing quote of the same character (either a single or double
    quote).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Before diving into the code, note that you can match arbitrary whitespaces with
    the regex `\s`. Also, you can match characters that are *not* in a set `Y` by
    using the syntax `[^Y]`. That’s everything you need to know to solve our problem.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  id: totrans-174
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Consider the problem illustrated in [Listing 5-8](#list5-8): given a text,
    find all words that contain duplicate characters. A *word* in this case is defined
    as any series of non-whitespace characters separated by an arbitrary number of
    whitespace characters.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Listing 5-8: One-liner solution to find all duplicate characters*'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: What are the words with duplicate characters found in this code?
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The regex `(?P<x>[^\s])` defines a new group with the name `x`. The group consists
    of only a single arbitrary character that is not the whitespace character. The
    regex `(?P=x)` immediately follows the named group `x`. It simply matches the
    same character matched by the group `x`. You’ve found the duplicate characters!
    However, the goal is not to find duplicate characters, but words with duplicate
    characters. So you match an arbitrary number of non-whitespace characters `[^\s]*`
    before and after the duplicate characters.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of [Listing 5-8](#list5-8) is the following:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The regex finds all words with duplicate characters in the text. Note that there
    are two groups in the regex of [Listing 5-8](#list5-8), so every element returned
    by the `re.findall()` function consists of a tuple of matched groups. You’ve already
    seen this behavior in previous sections.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, you’ve enhanced your regex tool set with one powerful tool:
    named groups. In combination with two minor regex features of matching arbitrary
    whitespace characters with `\s` and defining a set of characters that are not
    matched with the operator `[^...]`, you’ve made serious progress toward Python
    regex proficiency.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '**Detecting Word Repetitions**'
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the preceding section, you learned about named groups. The goal of this section
    is to show you more advanced ways of using this powerful feature.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '***The Basics***'
  id: totrans-187
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: While working as a researcher over the last few years, I spent most of my time
    writing, reading, and editing research papers. When editing my research papers,
    a colleague used to complain that I was using the same words repeatedly (and too
    closely in the text). Wouldn’t it be useful to have a tool that checks your writing
    programmatically?
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  id: totrans-189
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You’re given a string consisting of lowercase, whitespace-separated words, without
    special characters. Find a matching substring where the first and the last word
    are the same (repetition) and in-between are at most 10 words. See [Listing 5-9](#list5-9).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*Listing 5-9: One-liner solution to find word repetitions*'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Does this code find word repetitions?
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  id: totrans-194
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Again, you assume that a given `text` consists of only whitespace-separated,
    lowercase words. Now, you search the `text` by using a regular expression. It
    might look complex at first, but let’s break it down piece by piece:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You start with a single whitespace character. This is important to ensure that
    you start with a whole word (and not with a suffix of a word). Then, you match
    a named group `x` that consists of a positive number of lowercase characters from
    `'``a'` to `'z'`, followed by a positive number of whitespaces ➊.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: You proceed with 0 to 10 words, where each word consists of a positive number
    of lowercase characters from `'a'` to `'z'`, followed by a positive number of
    whitespaces ➋.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: You finish with the named group `x`, followed by a whitespace character to ensure
    that the last match is a whole word (and not only a prefix of a word) ➌.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the output of the code snippet:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You found a matching substring that may (or may not) be considered as bad style.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: In this one-liner, you stripped down the problem of finding duplicate words
    to its core and solved this easier variant. Note that in practice, you’d have
    to include more complicated cases such as special characters, a mix of lowercase
    and uppercase characters, numbers, and so on. Alternatively, you could do some
    preprocessing to bring the text into the desired form of lowercase, whitespace-separated
    words, without special characters.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '**EXERCISE 5-1**'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Write a Python script that allows for more special characters, such as characters
    to structure your sentences (period, colon, comma).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '**Modifying Regex Patterns in a Multiline String**'
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the final regex one-liner, you’ll learn how to modify a text rather than
    matching only parts of it.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '***The Basics***'
  id: totrans-208
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To replace all occurrences of a certain `regex` pattern with a new string `replacement`
    in a given `text`, use the regex function `re.sub(regex,` `replacement``,` `text)`.
    This way, you can quickly edit large text bases without a lot of manual labor.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: In the previous sections, you learned how to match patterns that occur in the
    text. But what if you don’t want to match a certain pattern if another pattern
    occurs? The *negative lookahead* regex pattern `A(?!X)` matches a regex `A` if
    the regex `X` does not match afterward. For example, the regex `not (?!good)`
    would match the string `'this is not great'` but would not match the string `'this
    is not good'`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  id: totrans-211
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Our data is a string, and our task is to replace all occurrences of `Alice Wonderland`
    with `'Alice Doe'`, but not to replace occurrences of `'Alice Wonderland'` (enclosed
    in single quotes). See [Listing 5-10](#list5-10).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '*Listing 5-10: One-liner solution to replace patterns in a text*'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: This code prints the updated text. What is it?
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  id: totrans-216
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You replace all occurrences of `Alice Wonderland` with `Alice Doe`, but not
    the ones that end with the single quote `''`. You do this by using a negative
    lookahead. Note that you check only whether the closing quote exists. For example,
    a string *with* an opening quote but *without* a closing quote would match, and
    you’d simply replace it. This may not be desired in general, but it leads to the
    desired behavior in our example string:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You can see that the original name of `'Alice Wonderland'` is left unchanged
    when enclosed in single quotes—which was the goal of this code snippet.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter covered a lot of ground. You’ve learned about regular expressions,
    which you can use to match patterns in a given string. In particular, you’ve learned
    about the functions `re.compile()`, `re.match()`, `re.search()`, `re.findall()`,
    and `re.sub()`. Together, they cover a high percentage of regular expression use
    cases. You can pick up other functions as you apply regular expressions in practice.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: You’ve also learned about various basic regular expressions that you can combine
    (and recombine) in order to create more advanced regular expressions. You’ve learned
    about whitespaces, escaped characters, greedy/nongreedy operators, character sets
    (and negative characters sets), grouping and named groups, and negative lookaheads.
    And finally, you’ve learned that it’s often better to solve a simplified variant
    of the original problem than trying to generalize too early.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: The only thing left is to apply your new regex skill in practice. A good way
    of getting used to regular expressions is to start using them in your favorite
    text editor. Most advanced text and code editors (including Notepad++) ship with
    powerful regular expression functionality. Also, consider regular expressions
    when working with textual data (for example when writing emails, blog articles,
    books, and code). Regular expressions will make your life easier and save you
    many hours of tedious work.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we’ll dive into the supreme discipline of coding: algorithms.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
