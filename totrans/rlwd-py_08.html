<html><head></head><body>
<h2 class="h2" id="ch08"><span epub:type="pagebreak" id="page_177"/><span class="big">8</span><br/>DETECTING DISTANT EXOPLANETS</h2>&#13;
<div class="image1"><img src="../images/common.jpg" alt="Image"/></div>&#13;
<p class="noindent">Extrasolar planets, called exoplanets for short, are planets that orbit alien suns. By the end of 2019, more than 4,000 exoplanets had been discovered. That’s an average of 150 per year since the first confirmed discovery in 1992! These days, finding a faraway planet seems as easy as catching a cold, yet it took almost all human history—up to 1930—to discover the eight planets, plus Pluto, that make up our own solar system.</p>&#13;
<p class="indent">Astronomers detected the first exoplanets by observing gravitationally induced wobble in the motion of stars. Today, they rely mainly on the slight dimming of a star’s light as the exoplanet passes between the star and Earth. And with powerful next-generation devices like the James Webb Space Telescope, they’ll directly image exoplanets and learn about their rotation, seasons, weather, vegetation, and more.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_178"/>In this chapter, you’ll use OpenCV and <span class="literal">matplotlib</span> to simulate an exoplanet passing before its sun. You’ll record the resulting light curve and then use it to detect the planet and estimate its diameter. Then, you’ll simulate how an exoplanet might look to the James Webb Space Telescope. In the “Practice Project” sections, you’ll investigate unusual light curves that may represent enormous alien megastructures designed to harness a star’s energy.</p>&#13;
<h3 class="h3" id="ch00lev1sec61"><strong>Transit Photometry</strong></h3>&#13;
<p class="noindent">In astronomy, a <em>transit</em> occurs when a relatively small celestial body passes directly between the disc of a larger body and an observer. When the small body moves across the face of the larger body, the larger body dims slightly. The best-known transits are those of Mercury and Venus against our own sun (<a href="ch08.xhtml#ch08fig1">Figure 8-1</a>).</p>&#13;
<div class="image"><img src="../images/fig08_01.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch08fig1"/>Figure 8-1: Clouds and Venus (the black dot) passing before the sun in June 2012</p>&#13;
<p class="indent">With today’s technology, astronomers can detect the subtle dimming of a faraway star’s light during a transit event. The technique, called <em>transit photometry</em>, outputs a plot of a star’s brightness over time (<a href="ch08.xhtml#ch08fig2">Figure 8-2</a>).</p>&#13;
<div class="image"><img src="../images/fig08_02.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch08fig2"/>Figure 8-2: The transit photometry technique for detecting exoplanets</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_179"/>In <a href="ch08.xhtml#ch08fig2">Figure 8-2</a>, the dots on the light curve graph represent measurements of the light given off by a star. When a planet is not positioned over the star <span class="ent">➊</span>, the measured brightness is at a maximum. (We’ll ignore light reflected off the exoplanet as it goes through its phases, which would very slightly increase the apparent brightness of the star). As the leading edge of a planet moves onto the disc <span class="ent">➋</span>, the emitted light progressively dims, forming a ramp in the light curve. When the entire planet is visible against the disc <span class="ent">➌</span>, the light curve flattens, and it remains flat until the planet begins exiting the far side of the disc. This creates another ramp <span class="ent">➍</span>, which rises until the planet passes completely off the disc <span class="ent">➎</span>. At that point, the light curve flattens at its maximum value, as the star is no longer obscured.</p>&#13;
<p class="indent">Because the amount of light blocked during a transit is proportional to the size of the planet’s disc, you can calculate the radius of the planet using the following formula:</p>&#13;
<div class="image1"><img src="../images/equ_page_179_01.jpg" alt="Image"/></div>&#13;
<p class="noindent">where <em>R</em><sub>p</sub> is the planet’s radius and <em>R</em><sub><em>s</em></sub> is the star’s radius. Astronomers determine the star’s radius using its distance, brightness, and color, which relates to its temperature. <em>Depth</em> refers to the total change in brightness during the transit (<a href="ch08.xhtml#ch08fig3">Figure 8-3</a>).</p>&#13;
<div class="image"><img src="../images/fig08_03.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch08fig3"/>Figure 8-3: Depth represents the total change in brightness observed in a light curve.</p>&#13;
<p class="indent">Of course, these calculations assume that the whole exoplanet, not just part of it, moved over the face of the star. The latter may occur if the exoplanet skims either the top or bottom of the star (from our point of view). We’ll look at this case in “Experimenting with Transit Photometry” on <a href="ch08.xhtml#page_182">page 182</a>.</p>&#13;
<h3 class="h3ab" id="ch00lev1sec62"><strong>Project #11: Simulating an Exoplanet Transit</strong></h3>&#13;
<p class="noindent">Before I flew to Idaho to photograph the Great American Eclipse of 2017, I did my homework. The totality event, when the moon completely covered the sun, lasted only 2 minutes and 10 seconds. That left no time for experimenting, testing, or figuring things out on the fly. To successfully capture <span epub:type="pagebreak" id="page_180"/>images of the penumbra, umbra, solar flares, and diamond ring effect (<a href="ch08.xhtml#ch08fig4">Figure 8-4</a>), I had to know exactly what equipment to take, what camera settings to use, and when these events would occur.</p>&#13;
<div class="image"><img src="../images/fig08_04.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch08fig4"/>Figure 8-4: Diamond ring effect at the end of totality, 2017 solar eclipse</p>&#13;
<p class="indent">In a similar fashion, computer simulations prepare you for making observations of the natural world. They help you understand what to expect, when to expect it, and how to calibrate your instruments. In this project, you’ll create a simulation of an exoplanet transit event. You can run this simulation with different planet sizes to understand the impact of a transit’s size on the light curve. Later, you’ll use this simulation to evaluate light curves related to asteroid fields and possible alien megastructures.</p>&#13;
<div class="sidebar96">&#13;
<p class="Problem-Head">THE OBJECTIVE</p>&#13;
<p class="Body-Problem">Write a Python program that simulates an exoplanet transit, plots the resulting light curve, and calculates the radius of the exoplanet.</p>&#13;
</div>&#13;
<h4 class="h4" id="ch00lev2sec40"><strong><em>The Strategy</em></strong></h4>&#13;
<p class="noindent">To generate a light curve, you need to be able to measure changes in brightness. You can do this by performing mathematical operations on pixels, such as finding mean, minimum, and maximum values, with OpenCV.</p>&#13;
<p class="indent">Instead of using an image of a real transit and star, you’ll draw circles on a black rectangle, just as you drew rectangles on the Mars map in the previous chapter. To plot the light curve, you can use <span class="literal">matplotlib</span>, Python’s main plotting library. You installed <span class="literal">matplotlib</span> in “Installing NumPy and Other Scientific Packages with pip” on <a href="ch01.xhtml#page_8">page 8</a> and began using it to make graphs in <a href="ch02.xhtml">Chapter 2</a>.</p>&#13;
<h4 class="h4" id="ch00lev2sec41"><span epub:type="pagebreak" id="page_181"/><strong><em>The Transit Code</em></strong></h4>&#13;
<p class="noindent">The <em>transit.py</em> program uses OpenCV to generate a visual simulation of an exoplanet transiting a star, plots the resulting light curve with <span class="literal">matplotlib</span>, and estimates the size of the planet using the planetary radius equation from <a href="ch08.xhtml#page_179">page 179</a>. You can enter the code yourself or download it from <em><a href="https://nostarch.com/real-world-python/">https://nostarch.com/real-world-python/</a></em>.</p>&#13;
<h5 class="h5"><strong>Importing Modules and Assigning Constants</strong></h5>&#13;
<p class="noindent"><a href="ch08.xhtml#ch08list1">Listing 8-1</a> imports modules and assigns constants representing user input.</p>&#13;
<pre><span class="codeitalic1">transit.py</span>, part 1&#13;
import math&#13;
import numpy as np&#13;
import cv2 as cv&#13;
import matplotlib.pyplot as plt&#13;
&#13;
IMG_HT = 400&#13;
IMG_WIDTH = 500&#13;
BLACK_IMG = np.zeros((IMG_HT, IMG_WIDTH, 1), dtype='uint8') &#13;
STAR_RADIUS = 165&#13;
EXO_RADIUS = 7&#13;
EXO_DX = 3&#13;
EXO_START_X = 40&#13;
EXO_START_Y = 230&#13;
NUM_FRAMES = 145</pre>&#13;
<p class="listing"><a id="ch08list1"/>Listing 8-1: Importing modules and assigning constants</p>&#13;
<p class="indent">Import the <span class="literal">math</span> module for the planetary radius equation, <span class="literal">NumPy</span> for calculating the brightness of the image, OpenCV for drawing the simulation, and <span class="literal">matplotlib</span> for plotting the light curve. Then start assigning constants that will represent user-input values.</p>&#13;
<p class="indent">Start with a height and width for the simulation window. The window will be a black, rectangular image built using the <span class="literal">np.zeros()</span> method, which returns an array of a given shape and type filled with zeros.</p>&#13;
<p class="indent">Recall that OpenCV images are <span class="literal">NumPy</span> arrays and items in the arrays must have the same type. The <span class="literal">uint8</span> data type represents an unsigned integer from 0 to 255. You can find a useful listing of other data types and their descriptions at <em><a href="https://numpy.org/devdocs/user/basics.types.html">https://numpy.org/devdocs/user/basics.types.html</a></em>.</p>&#13;
<p class="indent">Next, assign radius values, in pixels, for the star and exoplanet. OpenCV will use these constants when it draws circles representing them.</p>&#13;
<p class="indent">The exoplanet will move across the face of the star, so you need to define how quickly it will move. The <span class="literal">EXO_DX</span> constant will increment the exoplanet’s <em>x</em> position by three pixels with each programming loop, causing the exoplanet to move left to right.</p>&#13;
<p class="indent">Assign two constants to set the exoplanet’s starting position. Then assign a <span class="literal">NUM_FRAMES</span> constant to control the number of simulation updates. Although you can calculate this number (<span class="literal">IMG_WIDTH/EXO_DX</span>), assigning it lets you fine-tune the duration of the simulation.</p>&#13;
<h5 class="h5"><strong>Defining the main() Function</strong></h5>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_182"/><a href="ch08.xhtml#ch08list2">Listing 8-2</a> defines the <span class="literal">main()</span> function used to run the program. Although you can define <span class="literal">main()</span> anywhere, placing it at the start lets it serve as a summary for the whole program, thus giving context to the functions defined later. As part of <span class="literal">main()</span>, you’ll calculate the exoplanet’s radius, nesting the equation within the call to the <span class="literal">print()</span> function.</p>&#13;
<pre><span class="codeitalic1">transit.py</span>, part 2&#13;
def main():&#13;
    intensity_samples = record_transit(EXO_START_X, EXO_START_Y)  &#13;
    relative_brightness = calc_rel_brightness(intensity_samples)&#13;
    print('\nestimated exoplanet radius = {:.2f}\n'&#13;
          .format(STAR_RADIUS * math.sqrt(max(relative_brightness)&#13;
                                          - min(relative_brightness))))&#13;
    plot_light_curve(relative_brightness)</pre>&#13;
<p class="listing"><a id="ch08list2"/>Listing 8-2: Defining the <span class="codeitalic">main()</span> function</p>&#13;
<p class="indent">After defining the <span class="literal">main()</span> function, name a variable <span class="literal">intensity_samples</span> and call the <span class="literal">record_transit()</span> function. <em>Intensity</em> refers to the amount of light, represented by the numerical value of a pixel. The <span class="literal">record_transit()</span> function draws the simulation to the screen, measures its intensity, appends the measurement to a list called <span class="literal">intensity_samples</span>, and returns the list. It needs the starting point (<em>x</em>, <em>y</em>) coordinates for the exoplanet. Pass it the starting constants <span class="literal">EXO_START_X</span> and <span class="literal">EXO_START_Y</span>, which will place the planet in a position similar to <span class="ent">➊</span> in <a href="ch08.xhtml#ch08fig2">Figure 8-2</a>. Note that if you increase the exoplanet’s radius significantly, you may need to move the starting point farther to the left (negative values are acceptable).</p>&#13;
<p class="indent">Next, name a variable <span class="literal">relative_brightness</span> and call the <span class="literal">calc_rel_brightness()</span> function. As its name suggests, this function calculates <em>relative</em> brightness, which is the measured intensity divided by the maximum recorded intensity. It takes the list of intensity measurements as an argument, converts the measurements to relative brightness, and returns the new list.</p>&#13;
<p class="indent">You’ll use the list of relative brightness values to calculate the radius of the exoplanet, in pixels, using the equation from <a href="ch08.xhtml#page_179">page 179</a>. You can perform the calculation as part of the <span class="literal">print()</span> function. Use the <span class="literal">{:.2f}</span> format to report the answer to two decimal points.</p>&#13;
<p class="indent">End the <span class="literal">main()</span> function by calling the function to plot the light curve. Pass it the <span class="literal">relative_brightness</span> list.</p>&#13;
<h5 class="h5"><strong>Recording the Transit</strong></h5>&#13;
<p class="noindent"><a href="ch08.xhtml#ch08list3">Listing 8-3</a> defines a function to simulate and record the transit event. It draws the star and exoplanet on a black rectangular image and then moves the exoplanet. It also calculates and displays the average intensity of the image with each move, appends the intensity to a list, and returns the list at the end.<span epub:type="pagebreak" id="page_183"/></p>&#13;
<pre><span class="codeitalic1">transit.py</span>, part 3&#13;
def record_transit(exo_x, exo_y):&#13;
    """Draw planet transiting star and return list of intensity changes."""&#13;
    intensity_samples = []&#13;
    for _ in range(NUM_FRAMES):&#13;
        temp_img = BLACK_IMG.copy()&#13;
        cv.circle(temp_img, (int(IMG_WIDTH / 2), int(IMG_HT / 2)),&#13;
                  STAR_RADIUS, 255, -1)&#13;
     <span class="ent">➊</span> cv.circle(temp_img, (exo_x, exo_y), EXO_RADIUS, 0, -1)&#13;
        intensity = temp_img.mean()&#13;
        cv.putText(temp_img, 'Mean Intensity = {}'.format(intensity), (5, 390),&#13;
                   cv.FONT_HERSHEY_PLAIN, 1, 255)&#13;
        cv.imshow('Transit', temp_img)&#13;
        cv.waitKey(30)&#13;
     <span class="ent">➋</span> intensity_samples.append(intensity)&#13;
        exo_x += EXO_DX&#13;
    return intensity_samples</pre>&#13;
<p class="listing"><a id="ch08list3"/>Listing 8-3: Drawing the simulation, calculating the image intensity, and returning it as a list</p>&#13;
<p class="indent">The <span class="literal">record_transit()</span> function takes a pair of (<em>x</em>, <em>y</em>) coordinates as arguments. These represent the starting point for the exoplanet or, more specifically, the pixel to use as the center of the first circle drawn in the simulation. It should not overlap with the star’s circle, which will be centered in the image.</p>&#13;
<p class="indent">Next, create an empty list to hold the intensity measurements. Then start a <span class="literal">for</span> loop that uses the <span class="literal">NUM_FRAMES</span> constant to repeat the simulation a certain number of times. The simulation should last slightly longer than it takes for the exoplanet to exit the face of the star. That way, you get a full light curve that includes post-transit measurements.</p>&#13;
<p class="indent">Drawings and text placed on an image with OpenCV become part of that image. Consequently, you need to replace the previous image with each loop by copying the original <span class="literal">BLACK_IMG</span> to a local variable called <span class="literal">temp_img</span>.</p>&#13;
<p class="indent">Now you can draw the star by using the OpenCV <span class="literal">circle()</span> method. Pass it the temporary image, the (<em>x</em>, <em>y</em>) coordinates for the center of the circle that correspond to the center of the image, the <span class="literal">STAR_RADIUS</span> constant, a fill color of white, and a line thickness. Using a negative number for thickness fills the circle with color.</p>&#13;
<p class="indent">Draw the exoplanet circle next. Use the <span class="literal">exo_x</span> and <span class="literal">exo_y</span> coordinates as its starting point, the <span class="literal">EXO_RADIUS</span> constant as its size, and a black fill color <span class="ent">➊</span>.</p>&#13;
<p class="indent">At this point, you should record the intensity of the image. Since the pixels already represent intensity, all you need to do is take the mean of the image. The number of measurements you take is dependent on the <span class="literal">EXO_DX</span> constant. The larger this value, the faster the exoplanet will move, and the fewer times you will record the mean intensity.</p>&#13;
<p class="indent">Display the intensity reading on the image using OpenCV’s <span class="literal">putText()</span> method. Pass it the temporary image, a text string that includes the measurement, the (<em>x</em>, <em>y</em>) coordinates for the bottom-left corner of the text string, a font, a text size, and a color.</p>&#13;
<p class="indent">Now, name the window <span class="literal">Transit</span> and display it using OpenCV’s <span class="literal">imshow()</span> method. <a href="ch08.xhtml#ch08fig5">Figure 8-5</a> shows a loop iteration.</p>&#13;
<div class="image"><img src="../images/fig08_05.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch08fig5"/>Figure 8-5: The exoplanet transiting the star</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_184"/>After showing the image, use the OpenCV <span class="literal">waitKey()</span> method to update it every 30 milliseconds. The lower the number passed to <span class="literal">waitKey()</span>, the faster the exoplanet will move across the star.</p>&#13;
<p class="indent">Append the intensity measurement to the <span class="literal">intensity_samples</span> list and then advance the exoplanet circle by incrementing its <span class="literal">exo_x</span> value by the <span class="literal">EXO_DX</span> constant <span class="ent">➋</span>. Finish the function by returning the list of mean intensity measurements.</p>&#13;
<h5 class="h5"><strong>Calculating Relative Brightness and Plotting the Light Curve</strong></h5>&#13;
<p class="noindent"><a href="ch08.xhtml#ch08list4">Listing 8-4</a> defines functions to calculate the relative brightness of each intensity sample and display the light curve graph. It then calls the <span class="literal">main()</span> function if the program is not being used as a module in another program.</p>&#13;
<pre><span class="codeitalic1">transit.py</span>, part 4 &#13;
   def calc_rel_brightness(intensity_samples):&#13;
       """Return list of relative brightness from list of intensity values."""&#13;
       rel_brightness = []&#13;
       max_brightness = max(intensity_samples)&#13;
       for intensity in intensity_samples:&#13;
          rel_brightness.append(intensity / max_brightness)&#13;
       return rel_brightness&#13;
&#13;
<span class="ent">➊</span> def plot_light_curve(rel_brightness):&#13;
       """Plot changes in relative brightness vs. time."""&#13;
       plt.plot(rel_brightness, color='red', linestyle='dashed',&#13;
               linewidth=2, label='Relative Brightness')&#13;
       plt.legend(loc='upper center')&#13;
       plt.title('Relative Brightness vs. Time')&#13;
       plt.show()&#13;
&#13;
<span class="ent">➋</span> if __name__ == '__main__':&#13;
      main()</pre>&#13;
<p class="listing"><a id="ch08list4"/>Listing 8-4: Calculating relative brightness, plotting the light curve, and calling <span class="literal">main()</span></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_185"/>Light curves display the <em>relative</em> brightness over time so that an un-obscured star has a value of 1.0 and a totally eclipsed star has a value of 0.0. To convert the mean intensity measurements to relative values, define the <span class="literal">calc_rel_brightness()</span> function, which takes a list of mean intensity measurements as an argument.</p>&#13;
<p class="indent">Within the function, start an empty list to hold the converted values and then use Python’s built-in <span class="literal">max()</span> function to find the maximum value in the <span class="literal">intensity_samples</span> list. To get relative brightness, loop through the items in this list and divide them by the maximum value. Append the result to the <span class="literal">rel_brightness</span> list as you go. End the function by returning the new list.</p>&#13;
<p class="indent">Define a second function to plot the light curve and pass it the <span class="literal">rel_brightness</span> list <span class="ent">➊</span>. Use the <span class="literal">matplotlib</span> <span class="literal">plot()</span> method and pass it the list, a line color, a line style, a line width, and a label for the plot legend. Add the legend and plot title and then show the plot. You should see the chart in <a href="ch08.xhtml#ch08fig6">Figure 8-6</a>.</p>&#13;
<div class="image"><img src="../images/fig08_06.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch08fig6"/>Figure 8-6: Example light curve plot from <span class="normal">transit.py</span></p>&#13;
<p class="indent">The brightness variation on the plot might seem extreme at first glance, but if you look closely at the <em>y</em>-axis, you’ll see that the exoplanet diminished the star’s brightness by only 0.175 percent! To see how this looks on a plot of the star’s absolute brightness (<a href="ch08.xhtml#ch08fig7">Figure 8-7</a>), add the following line just before <span class="literal">plt.show()</span>:</p>&#13;
<pre>plt.ylim(0, 1.2)</pre>&#13;
<p class="indent">The deflection in the light curve caused by the transit is subtle but detectable. Still, you don’t want to go blind squinting at a light curve, so continue to let <span class="literal">matplotlib</span> automatically fit the <em>y</em>-axis as in <a href="ch08.xhtml#ch08fig6">Figure 8-6</a>.</p>&#13;
<p class="indent">Finish the program by calling the <span class="literal">main()</span> function <span class="ent">➋</span>. In addition to the light curve, you should see the estimated radius of the exoplanet in the shell.</p>&#13;
<pre>estimated exoplanet radius = 6.89</pre>&#13;
<p class="indent">That’s all there is to it. With fewer than 50 lines of Python code, you’ve developed a means of discovering exoplanets!<span epub:type="pagebreak" id="page_186"/></p>&#13;
<div class="image"><img src="../images/fig08_07.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch08fig7"/>Figure 8-7: Light curve from <a href="ch08.xhtml#ch08fig6">Figure 8-6</a> with rescaled <span class="codeitalic">y</span>-axis</p>&#13;
<h4 class="h4" id="ch00lev2sec42"><strong><em>Experimenting with Transit Photometry</em></strong></h4>&#13;
<p class="noindent">Now that you have a working simulation, you can use it to model the behavior of transits, allowing you to better analyze real-life observations you’ll make in the future. One approach would be to run a lot of possible cases and produce an “atlas” of expected exoplanet responses. Researchers could use this atlas to help them interpret actual light curves.</p>&#13;
<p class="indent">For example, what if the plane of an exoplanet’s orbit is tilted with respect to Earth so that the exoplanet only partly crosses the star during transit? Would researchers be able to detect its position from its light curve signature, or would it just look like a smaller exoplanet doing a complete transit?</p>&#13;
<p class="indent">If you run the simulation with an exoplanet radius of 7 and let it skim the base of the star, you should get a U-shaped curve (<a href="ch08.xhtml#ch08fig8">Figure 8-8</a>).</p>&#13;
<div class="image"><img src="../images/fig08_08.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch08fig8"/>Figure 8-8: Light curve for an exoplanet with a radius of 7 that only partly crosses its star</p>&#13;
<p class="indent">If you run the simulation again with an exoplanet radius of 5 and let the exoplanet pass fully over the face of the star, you get the graph in <a href="ch08.xhtml#ch08fig9">Figure 8-9</a>.</p>&#13;
<div class="image"><img src="../images/fig08_09.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch08fig9"/>Figure 8-9: Light curve for an exoplanet with a radius of 5 that fully crosses its star</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_187"/>When an exoplanet skims the side of a star, never fully passing over it, the overlapping area changes constantly, generating the U-shaped curve in <a href="ch08.xhtml#ch08fig8">Figure 8-8</a>. If the entire exoplanet passes over the face of the star, the base of the curve is flatter, as in <a href="ch08.xhtml#ch08fig9">Figure 8-9</a>. And because you never see the planet’s full disc against the star in a partial transit, you have no way to measure its true size. Thus, size estimates should be taken with a grain of salt if your light curve lacks a flattish bottom.</p>&#13;
<p class="indent">If you run a range of exoplanet sizes, you’ll see that the light curve changes in predictable ways. As size increases, the curve deepens, with longer ramps on either side, because a larger fraction of the star’s brightness is diminished (<a href="ch08.xhtml#ch08fig10">Figures 8-10</a> and <a href="ch08.xhtml#ch08fig11">8-11</a>).</p>&#13;
<div class="image"><img src="../images/fig08_10.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch08fig10"/>Figure 8-10: Light curve for <span class="literal">EXO_RADIUS = 28</span></p>&#13;
<div class="image"><img src="../images/fig08_11.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch08fig11"/>Figure 8-11: Light curve for <span class="literal">EXO_RADIUS = 145</span></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_188"/>Because exoplanets are circular objects with smooth edges, they should produce light curves with smooth ramps that continuously increase or decrease. This is important knowledge, as astronomers have recorded decidedly bumpy curves when looking for exoplanets. In the “Practice Project” sections at the end of the chapter, you’ll use your program to explore oddly shaped light curves that might be explained by extraterrestrial engineering!</p>&#13;
<h3 class="h3ab" id="ch00lev1sec63"><strong>Project #12: Imaging Exoplanets</strong></h3>&#13;
<p class="noindent">By 2025, three powerful telescopes—two on Earth and one in space—will use infrared and visible light to directly image Earth-sized exoplanets. In the best-case scenario, the exoplanet will show up as a single saturated pixel with some bleed into the surrounding pixels, but that’s enough to tell whether the planet rotates, has continents and seas, experiences weather and seasons, and could support life as we know it!</p>&#13;
<p class="indent">In this project, you’ll simulate the process of analyzing an image taken from those telescopes. You’ll use Earth as a stand-in for a distant exoplanet. This way, you can easily relate known features, such as continents and oceans, to what you see in a single pixel. You’ll focus on the color composition and intensity of reflected light and make inferences about the exoplanet’s atmosphere, surface features, and rotation.</p>&#13;
<div class="sidebar96">&#13;
<p class="Problem-Head">THE OBJECTIVE</p>&#13;
<p class="Body-Problem">Write a Python program that pixelates images of Earth and plots the intensity of the red, green, and blue color channels.</p>&#13;
</div>&#13;
<h4 class="h4" id="ch00lev2sec43"><strong><em>The Strategy</em></strong></h4>&#13;
<p class="noindent">To demonstrate that you can capture different surface features and cloud formations with a single saturated pixel, you need only two images: one of the western hemisphere and one of the eastern. Conveniently, NASA has already photographed both hemispheres of Earth from space (<a href="ch08.xhtml#ch08fig12">Figure 8-12</a>).</p>&#13;
<div class="image"><img src="../images/fig08_12.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch08fig12"/>Figure 8-12: Images of the western and eastern hemispheres</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_189"/>The size of these images is 474×474 pixels, a resolution far too high for a future exoplanet image, where the exoplanet is expected to occupy 9 pixels, with only the center pixel fully covered by the planet (<a href="ch08.xhtml#ch08fig13">Figure 8-13</a>).</p>&#13;
<div class="image"><img src="../images/fig08_13.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch08fig13"/>Figure 8-13: The <span class="normal">earth_west.png</span> and <span class="normal">earth_east.png</span> images overlaid with a 9-pixel grid</p>&#13;
<p class="indent">You’ll need to degrade the Earth images by mapping them into a 3×3 array. Since OpenCV uses <span class="literal">NumPy</span>, this will be easy to do. To detect changes in the exoplanet’s surface, you’ll need to extract the dominant colors (blue, green, and red). OpenCV will let you average these color channels. Then you can display the results with <span class="literal">matplotlib</span>.</p>&#13;
<h4 class="h4" id="ch00lev2sec44"><strong><em>The Pixelator Code</em></strong></h4>&#13;
<p class="noindent">The <em>pixelator.py</em> program loads the two images of Earth, resizes them to 3×3 pixels, and then resizes them again to 300×300 pixels. These final images are just for visualization; they have the same color information as the 3×3 images. The program then averages the color channels in both resized images and plots the results as pie charts that you can compare. You can download the code and two images (<em>earth_west.png</em> and <em>earth_east.png</em>) from the book’s website. Keep them in the same folder and don’t rename the images.</p>&#13;
<h5 class="h5"><strong>Importing Modules and Downscaling Images</strong></h5>&#13;
<p class="noindent"><a href="ch08.xhtml#ch08list5">Listing 8-5</a> imports modules for plotting and image processing and then loads and degrades two images of Earth. It first reduces each to 9 pixels in a 3×3 array. It then enlarges the decimated images to 300×300 pixels so they are large enough to see and posts them to the screen.</p>&#13;
<pre><span class="codeitalic1">pixelator.py</span>, part 1&#13;
import numpy as np&#13;
import cv2 as cv&#13;
from matplotlib import pyplot as plt&#13;
&#13;
files = ['earth_west.png', 'earth_east.png']&#13;
&#13;
for file in files:&#13;
    <span epub:type="pagebreak" id="page_190"/>img_ini = cv.imread(file)&#13;
    pixelated = cv.resize(img_ini, (3, 3), interpolation=cv.INTER_AREA)&#13;
    img = cv.resize(pixelated, (300, 300), interpolation=cv.INTER_AREA)&#13;
    cv.imshow('Pixelated {}'.format(file), img)&#13;
    cv.waitKey(2000)</pre>&#13;
<p class="listing"><a id="ch08list5"/>Listing 8-5: Importing modules and loading, degrading, and showing images</p>&#13;
<p class="indent">Import <span class="literal">NumPy</span> and OpenCV to work with the images and use <span class="literal">matplotlib</span> to plot their color components as pie charts. Then start a list of filenames containing the two images of Earth.</p>&#13;
<p class="indent">Now start looping through the files in the list and use OpenCV to load them as <span class="literal">NumPy</span> arrays. Recall that OpenCV loads color images by default, so you don’t need to add an argument for this.</p>&#13;
<p class="indent">Your goal is to reduce the image of Earth into a single saturated pixel surrounded by partially saturated pixels. To degrade the images from their original 474×474 size to 3×3, use OpenCV’s <span class="literal">resize()</span> method. First, name the new image <em>pixelated</em> and pass the method the current image, the new width and height in pixels, and an interpolation method. <em>Interpolation</em> occurs when you resize an image and use known data to estimate values at unknown points. The OpenCV documentation recommends the <span class="literal">INTER_AREA</span> interpolation method for shrinking images (see the geometric image transformations at <em><a href="https://docs.opencv.org/4.3.0/da/d54/group__imgproc__transform.html">https://docs.opencv.org/4.3.0/da/d54/group__imgproc__transform.html</a></em>).</p>&#13;
<p class="indent">At this point, you have a tiny image that’s too small to visualize, so resize it again to 300×300 so you can check the results. Use either <span class="literal">INTER_NEAREST</span> or <span class="literal">INTER_AREA</span> as the interpolation method, as these will preserve the pixel boundaries.</p>&#13;
<p class="indent">Show the image (<a href="ch08.xhtml#ch08fig14">Figure 8-14</a>) and delay the program for two seconds using <span class="literal">waitKey()</span>.</p>&#13;
<div class="image"><img src="../images/fig08_14.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch08fig14"/>Figure 8-14: Grayscale view of the pixelated color images</p>&#13;
<p class="indent">Note that you can’t restore the images to their original state by resizing them to 474×474. Once you average the pixel values down to a 3×3 matrix, all the detailed information is lost forever.</p>&#13;
<h5 class="h5"><span epub:type="pagebreak" id="page_191"/><strong>Averaging the Color Channels and Making the Pie Charts</strong></h5>&#13;
<p class="noindent">Still in the <span class="literal">for</span> loop, <a href="ch08.xhtml#ch08list6">Listing 8-6</a> makes and displays pie charts of the blue, green, and red color components of each pixelated image. You can compare these to make inferences about the planet’s weather, landmasses, rotation, and so on.</p>&#13;
<pre><span class="codeitalic1">pixelator.py</span>, part 2 &#13;
   b, g, r = cv.split(pixelated)&#13;
   color_aves = []&#13;
   for array in (b, g, r):&#13;
       color_aves.append(np.average(array))&#13;
&#13;
   labels = 'Blue', 'Green', 'Red'&#13;
   colors = ['blue', 'green', 'red']    &#13;
   fig, ax = plt.subplots(figsize=(3.5, 3.3))  # size in inches&#13;
<span class="ent">➊</span> _, _, autotexts = ax.pie(color_aves,&#13;
                            labels=labels,&#13;
                            autopct='%1.1f%%',&#13;
                            colors=colors)&#13;
   for autotext in autotexts:&#13;
       autotext.set_color('white')&#13;
   plt.title('{}\n'.format(file))&#13;
    &#13;
plt.show()</pre>&#13;
<p class="listing"><a id="ch08list6"/>Listing 8-6: Splitting out and averaging color channels and making a pie chart of colors</p>&#13;
<p class="indent">Use OpenCV’s <span class="literal">split()</span> method to break out the blue, green, and red color channels in the pixelated image and unpack the results into <span class="literal">b</span>, <span class="literal">g</span>, and <span class="literal">r</span> variables. These are arrays, and if you call <span class="literal">print(b)</span>, you should see this output:</p>&#13;
<pre>[[ 49  93  22]&#13;
 [124 108  65]&#13;
 [ 52 118  41]]</pre>&#13;
<p class="indent">Each number represents a pixel—specifically, the pixel’s blue value—in the 3×3 pixelated image. To average the arrays, first make an empty list to hold the averages and then loop through the arrays and call the <span class="literal">NumPy</span> average method, appending the results to the list.</p>&#13;
<p class="indent">Now you’re ready to make pie charts of the color averages in each pixelated image. Start by assigning color names to a variable named <span class="literal">labels</span>, which you’ll use to annotate the pie wedges. Next, specify the colors you want to use in the pie chart. These will override the <span class="literal">matplotlib</span> default choices. To make the chart, use the <span class="literal">fig</span>, <span class="literal">ax</span> naming convention for figure and axis, call the <span class="literal">subplots()</span> method, and pass it a figure size in inches.</p>&#13;
<p class="indent">Because the colors will vary only slightly between images, you’ll want to post the percentage of each color in its pie wedge so you can easily see whether there’s a difference between them. Unfortunately, the <span class="literal">matplotlib</span> default is to use black text that can be hard to see against a dark background. To fix this, call the <span class="literal">ax.pie()</span> method for making pie charts and use its <span epub:type="pagebreak" id="page_192"/><span class="literal">autotexts</span> list <span class="ent">➊</span>. The method returns three lists, one concerning the pie wedges, one concerning the labels, and one for numeric labels, called <em>autotexts</em>. You need only the last one, so treat the first two as unused variables by assigning them to an underscore symbol.</p>&#13;
<p class="indent">Pass <span class="literal">ax.pie()</span> the list of color averages and the list of labels and set its <span class="literal">autopct</span> parameter to show numbers to one decimal place. If this parameter is set to <span class="literal">None</span>, the <span class="literal">autotexts</span> list will not be returned. Finish the arguments by passing the list of colors to use for the pie wedges.</p>&#13;
<p class="indent">The <span class="literal">autotexts</span> list for the first image looks like this:</p>&#13;
<pre>[Text(0.1832684031431146, 0.5713253822554821, '40.1%'), Text(-0.5646237442340427,&#13;
-0.20297789891298565, '30.7%'), Text(0.36574010704848686, -0.47564080364930983, '29.1%')</pre>&#13;
<p class="indent">Each <span class="literal">Text</span> object has (<em>x</em>, <em>y</em>) coordinates and a percent value as a text string. These will still post in black, so you need to loop through the objects and change the color to <span class="literal">white</span> using their <span class="literal">set_color()</span> method. Now all you need to do is set the chart title to the filename and show the plots (<a href="ch08.xhtml#ch08fig15">Figure 8-15</a>).</p>&#13;
<div class="image"><img src="../images/fig08_15.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch08fig15"/>Figure 8-15: The pie charts produced by <span class="normal">pixelator.py</span></p>&#13;
<p class="indent">Although the pie charts are similar, the differences are meaningful. If you compare the original color images, you’ll see that the <em>earth_west.png</em> photograph includes more ocean and should produce a larger blue wedge.</p>&#13;
<h5 class="h5"><strong>Plotting a Single Pixel</strong></h5>&#13;
<p class="noindent">The charts in <a href="ch08.xhtml#ch08fig15">Figure 8-15</a> are for the whole image, which includes a sampling of black space. For an uncontaminated sample, you could use the single saturated pixel at the center of each image, as shown in <a href="ch08.xhtml#ch08list7">Listing 8-7</a>. <span epub:type="pagebreak" id="page_193"/>This code represents an edited copy of <em>pixelator.py</em>, with the lines that change annotated. You can find a digital copy in the <em>Chapter_8</em> folder as <em>pixelator_saturated_only.py</em>.</p>&#13;
<pre><span class="codeitalic1">pixelator_saturated_only.py</span>&#13;
import cv2 as cv&#13;
from matplotlib import pyplot as plt&#13;
&#13;
files = ['earth_west.png', 'earth_east.png']&#13;
&#13;
# Downscale image to 3x3 pixels.&#13;
for file in files:&#13;
    img_ini = cv.imread(file)&#13;
    pixelated = cv.resize(img_ini, (3, 3), interpolation=cv.INTER_AREA)&#13;
    img = cv.resize(pixelated, (300, 300), interpolation=cv.INTER_NEAREST)&#13;
    cv.imshow('Pixelated {}'.format(file), img)&#13;
    cv.waitKey(2000)&#13;
&#13;
 <span class="ent">➊</span> color_values = pixelated[1, 1]  # Selects center pixel.&#13;
&#13;
    # Make pie charts.&#13;
    labels = 'Blue', 'Green', 'Red'&#13;
    colors = ['blue', 'green', 'red']    &#13;
    fig, ax = plt.subplots(figsize=(3.5, 3.3))  # Size in inches.&#13;
&#13;
 <span class="ent">➋</span> _, _, autotexts = ax.pie(color_values,&#13;
                             labels=labels,&#13;
                             autopct='%1.1f%%',&#13;
                             colors=colors)&#13;
    for autotext in autotexts:&#13;
        autotext.set_color('white')&#13;
 <span class="ent">➌</span> plt.title('{} Saturated Center Pixel \n'.format(file))&#13;
    &#13;
plt.show()</pre>&#13;
<p class="listing"><a id="ch08list7"/>Listing 8-7: Plotting pie charts for the colors in the center pixel of the pixelated image</p>&#13;
<p class="indent">The four lines of code in <a href="ch08.xhtml#ch08list6">Listing 8-6</a> that split the image and averaged the color channels can be replaced with one line <span class="ent">➊</span>. The <span class="literal">pixelated</span> variable is a <span class="literal">NumPy</span> array, and <span class="literal">[1, 1]</span> represents row 1, column 1 in the array. Remember that Python starts counting at 0, so these values correspond to the center of a 3×3 array. If you print the <span class="literal">color_values</span> variable, you’ll see another array.</p>&#13;
<pre>[108 109 109]</pre>&#13;
<p class="indent">These are the blue, green, and red color channel values for the center pixel, and you can pass them directly to <span class="literal">matplotlib</span> <span class="ent">➋</span>. For clarity, change the plot title so it indicates that you’re analyzing the center pixel only <span class="ent">➌</span>. <a href="ch08.xhtml#ch08fig16">Figure 8-16</a> shows the resulting plots.</p>&#13;
<div class="image"><img src="../images/fig08_16.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch08fig16"/>Figure 8-16: The single-pixel pie charts produced by <span class="normal">pixelator_saturated_only.py</span></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_194"/>The color differences between the western and eastern hemispheres in <a href="ch08.xhtml#ch08fig15">Figures 8-15</a> and <a href="ch08.xhtml#ch08fig16">8-16</a> are subtle, but you know they’re real because you <em>forward modeled</em> the response. That is, you produced the result from actual observations, so you know the result is meaningful, repeatable, and unique.</p>&#13;
<p class="indent">In a real exoplanet survey, you’d want to take as many images as possible. If similar intensity and color patterns persist over time, then you can rule out stochastic effects such as weather. If the color patterns change predictably over long time periods, you may be seeing the effect of seasons, such as the presence of white polar caps in the winter and the spread of green vegetation in the spring and summer.</p>&#13;
<p class="indent"> If measurements repeat periodically over relatively short time spans, you can infer that the planet is rotating on its axis. In the “Practice Project” sections at the end of the chapter, you’ll get a chance to calculate the length of an exoplanet’s day.</p>&#13;
<h3 class="h3" id="ch00lev1sec64"><strong>Summary</strong></h3>&#13;
<p class="noindent">In this chapter, you used OpenCV, <span class="literal">NumPy</span>, and <span class="literal">matplotlib</span> to create images and measure their properties. You also resized images to different resolutions and plotted image intensity and color channel information. With short and simple Python programs, you simulated important methods that astronomers use to discover and study distant exoplanets.</p>&#13;
<h3 class="h3" id="ch00lev1sec65"><strong>Further Reading</strong></h3>&#13;
<p class="noindent"><em>How to Search for Exoplanets</em>, by the Planetary Society (<em><a href="https://www.planetary.org/">https://www.planetary.org/</a></em>), is a good overview of the techniques used to search for exoplanets, including the strengths and weaknesses of each method.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_195"/>“Transit Light Curve Tutorial,” by Andrew Vanderburg, explains the basics of the transit photometry method and provides links to Kepler Space Observatory transit data. You can find it at <em><a href="https://www.cfa.harvard.edu/~avanderb/tutorial/tutorial.html">https://www.cfa.harvard.edu/~avanderb/tutorial/tutorial.html</a></em>.</p>&#13;
<p class="indent">“NASA Wants to Photograph the Surface of an Exoplanet” (Wired, 2020), by Daniel Oberhaus, describes the effort to turn the sun into a giant camera lens for studying exoplanets.</p>&#13;
<p class="indent">“Dyson Spheres: How Advanced Alien Civilizations Would Conquer the Galaxy” (<a href="http://Space.com">Space.com</a>, 2014), by Karl Tate, is an infographic on how an advanced civilization could capture the power of a star using vast arrays of solar panels.</p>&#13;
<p class="indent"><em>Ringworld</em> (Ballantine Books, 1970), by Larry Niven, is one of the classic novels of science fiction. It tells the story of a mission to a massive abandoned alien construct—the Ringworld—that encircles an alien star.</p>&#13;
<h3 class="h3" id="ch00lev1sec66"><strong>Practice Project: Detecting Alien Megastructures</strong></h3>&#13;
<p class="noindent">In 2015, citizen scientists working on data from the Kepler space telescope noticed something odd about Tabby’s Star, located in the constellation Cygnus. The star’s light curve, recorded in 2013, exhibited irregular changes in brightness that were far too large to be caused by a planet (<a href="ch08.xhtml#ch08fig17">Figure 8-17</a>).</p>&#13;
<div class="image"><img src="../images/fig08_17.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch08fig17"/>Figure 8-17: Light curve for Tabby’s Star, measured by the Kepler Space Observatory</p>&#13;
<p class="indent">Besides the dramatic drop in brightness, the light curve was asymmetrical and included weird bumps that aren’t seen in typical planetary transits. Proposed explanations posited that the light curve was caused by the consumption of a planet by the star, the transit of a cloud of disintegrating comets, a large ringed planet trailed by swarms of asteroids, or an <em>alien megastructure</em>.</p>&#13;
<p class="indent">Scientists speculated that an artificial structure of this size was most likely an attempt by an alien civilization to collect energy from its sun. Both science literature and science fiction describe these staggeringly large solar panel projects. Examples include Dyson swarms, Dyson spheres, ringworlds, and Pokrovsky shells (<a href="ch08.xhtml#ch08fig18">Figure 8-18</a>).</p>&#13;
<div class="image"><img src="../images/fig08_18.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch08fig18"/>Figure 8-18: Pokrovsky shell system of rings around a star designed to intercept the star’s radiation</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_196"/>In this practice project, use the <em>transit.py</em> program to approximate the shape and depth of the Tabby’s Star light curve. Replace the circular exoplanet used in the program with other simple geometric shapes. You don’t need to match the curve exactly; just capture key features such as the asymmetry, the “bump” seen around February 28, and the large drop in brightness.</p>&#13;
<p class="indent">You can find my attempt, <em>practice_tabbys_star.py</em>, in the <em>Chapter_8</em>  folder, downloadable from the book’s website at <em><a href="https://nostarch.com/real-world-python/">https://nostarch.com/real-world-python/</a>,</em> and in the appendix. It produces the light curve shown in <a href="ch08.xhtml#ch08fig19">Figure 8-19</a>.</p>&#13;
<div class="image"><img src="../images/fig08_19.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch08fig19"/>Figure 8-19: Light curve produced by <span class="normal">practice_tabbys_star.py</span></p>&#13;
<p class="indent">We now know that whatever is orbiting Tabby’s Star allows some wavelengths of light to pass, so it can’t be a solid object. Based on this behavior and the wavelengths it absorbed, scientists believe dust is responsible for the weird shape of the star’s light curve. Other stars, however, like HD 139139 in the constellation Libra, have bizarre light curves that remain unexplained at the time of this writing.</p>&#13;
<h3 class="h3" id="ch00lev1sec67"><strong>Practice Project: Detecting Asteroid Transits</strong></h3>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_197"/>Asteroid fields may be responsible for some bumpy and asymmetrical light curves. These belts of debris often originate from planetary collisions or the creation of a solar system, like the Trojan asteroids in Jupiter’s orbit (<a href="ch08.xhtml#ch08fig20">Figure 8-20</a>). You can find an interesting animation of the Trojan asteroids on the web page “Lucy: The First Mission to the Trojan Asteroids” at <em><a href="https://www.nasa.gov/">https://www.nasa.gov/</a></em>.</p>&#13;
<div class="image"><img src="../images/fig08_20.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch08fig20"/>Figure 8-20: More than one million Trojan asteroids share Jupiter’s orbit.</p>&#13;
<p class="indent">Modify the <em>transit.py</em>  program so that it randomly creates asteroids with radii between 1 and 3, weighted heavily toward 1. Allow the user to input the number of asteroids. Don’t bother calculating the exoplanet radius, since the calculation assumes you’re dealing with a single spherical object, which you’re not. Experiment with the number of asteroids, the size of the asteroids, and the spread (the <em>x</em>-range and <em>y</em>-range in which the asteroids exist) to see the impact on the light curve. <a href="ch08.xhtml#ch08fig21">Figure 8-21</a> shows one such example.</p>&#13;
<div class="image"><img src="../images/fig08_21.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch08fig21"/>Figure 8-21: Irregular, asymmetrical light curve produced by a randomly generated asteroid field</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_198"/>You can find a solution, <em>practice_asteroids.py</em>, in the appendix and on the book’s web page. This program uses object-oriented programming (OOP) to simplify the management of multiple asteroids.</p>&#13;
<h3 class="h3" id="ch00lev1sec68"><strong>Practice Project: Incorporating Limb Darkening</strong></h3>&#13;
<p class="noindent">The <em>photosphere</em> is the luminous outer layer of a star that radiates light and heat. Because the temperature of the photosphere falls as the distance from the star’s center increases, the edges of a star’s disk are cooler and therefore appear dimmer than the center of the star (<a href="ch08.xhtml#ch08fig22">Figure 8-22</a>). This effect is known as <em>limb darkening</em>.</p>&#13;
<div class="image"><img src="../images/fig08_22.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch08fig22"/>Figure 8-22: Limb darkening and sunspots on the sun</p>&#13;
<p class="indent">Rewrite the <em>transit.py</em> program so that it addresses limb darkening. Rather than draw the star, use the image <em>limb_darkening.png</em>  in the <em>Chapter_8</em> folder, downloadable from the book’s website.</p>&#13;
<p class="indent">Limb darkening will affect the light curves produced by planetary transits. Compared to the theoretical curves you produced in Project 11, they will appear less boxy, with rounder, softer edges and a curved bottom (<a href="ch08.xhtml#ch08fig23">Figure 8-23</a>).</p>&#13;
<div class="image"><img src="../images/fig08_23.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch08fig23"/>Figure 8-23: The effect of limb darkening on a light curve</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_199"/>Use your modified program to revisit “Experimenting with Transit Photometry” on <a href="ch08.xhtml#page_186">page 186</a>, where you analyzed the light curves produced by partial transits. You should see that, compared to partial transits, full transits still produce broader dips with flattish bottoms (<a href="ch08.xhtml#ch08fig24">Figure 8-24</a>).</p>&#13;
<div class="image"><img src="../images/fig08_24.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch08fig24"/>Figure 8-24: Limb-darkened light curves for full and partial transits (R = exoplanet radius)</p>&#13;
<p class="indent">If the full transit of a small planet occurs near the edge of a star, limb darkening may make it difficult to distinguish from the partial transit of a larger planet. You can see this in <a href="ch08.xhtml#ch08fig25">Figure 8-25</a>, where arrows denote the location of the planets.</p>&#13;
<div class="image"><img src="../images/fig08_25.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch08fig25"/>Figure 8-25: Partial transit of planet with a radius of 8 pixels versus full transit of planet with a radius of 5 pixels</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_200"/>Astronomers have many tools for extracting information entangled in a light curve. By recording multiple transit events, they can determine an exoplanet’s orbital parameters, such as the distance between the planet and the star. They can use subtle inflections in the light curve to tease out the amount of time the planet is fully over the surface of the star. They can estimate the theoretical amount of limb darkening, and they can use modeling, as you’re doing here, to bring it all together and test their assumptions against actual observations.</p>&#13;
<p class="indent">You can find a solution, <em>practice_limb_darkening.py</em>, in the appendix and in the <em>Chapter_8</em> folder downloadable from the book’s website.</p>&#13;
<h3 class="h3" id="ch00lev1sec69"><strong>Practice Project: Detecting Starspots</strong></h3>&#13;
<p class="noindent">Sunspots—called <em>starspots</em> on alien suns—are regions of reduced surface temperature caused by variations in the star’s magnetic field. Starspots can darken the face of stars and do interesting things to light curves. In <a href="ch08.xhtml#ch08fig26">Figure 8-26</a>, an exoplanet passes over a starspot, causing a “bump” in the light curve.</p>&#13;
<div class="image"><img src="../images/fig08_26.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch08fig26"/>Figure 8-26: An exoplanet (arrow, left image) passing over a starspot produces a bump in the light curve.</p>&#13;
<p class="indent">To experiment with starspots, use the <em>practice_limb_darkening.py</em> code from the previous practice project and edit it so that an exoplanet roughly the same size as the starspots passes over them during its transit. To reproduce <a href="ch08.xhtml#ch08fig26">Figure 8-26</a>, use <span class="literal">EXO_RADIUS = 4</span>, <span class="literal">EXO_DX = 3</span>, and <span class="literal">EXO_START_Y = 205</span>.</p>&#13;
<h3 class="h3" id="ch00lev1sec70"><strong>Practice Project: Detecting an Alien Armada</strong></h3>&#13;
<p class="noindent">The hyper-evolved beavers of exoplanet BR549 have been as busy as, well, beavers. They’ve amassed an armada of colossal colony ships that are now loaded and ready to leave orbit. Thanks to some exoplanet detection of their own, they’ve decided to abandon their chewed-out homeworld for the lush green forests of Earth!</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_201"/>Write a Python program that simulates multiple spaceships transiting a star. Give the ships different sizes, shapes, and speeds (such as those in <a href="ch08.xhtml#ch08fig27">Figure 8-27</a>).</p>&#13;
<div class="image"><img src="../images/fig08_27.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch08fig27"/>Figure 8-27: An armada of alien colony ships preparing to invade Earth</p>&#13;
<p class="indent">Compare the resultant light curves to those from Tabby’s Star (<a href="ch08.xhtml#ch08fig17">Figure 8-17</a>) and the asteroids practice project. Do the ships produce distinctive curves, or can you get similar patterns from asteroid swarms, starspots, or other natural phenomena?</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_202"/>You can find a solution, <em>practice_alien_armada.py</em>, in the appendix and in the <em>Chapter_8</em>  folder, downloadable from the book’s website.</p>&#13;
<h3 class="h3" id="ch00lev1sec71"><strong>Practice Project: Detecting a Planet with a Moon</strong></h3>&#13;
<p class="noindent">What kind of light curve would an exoplanet with an orbiting moon produce? Write a Python program that simulates a small exomoon orbiting a larger exoplanet and calculate the resulting light curve. You can find a solution, <em>practice_planet_moon.py</em>, in the appendix and on the book’s website.</p>&#13;
<h3 class="h3" id="ch00lev1sec72"><strong>Practice Project: Measuring the Length of an Exoplanet’s Day</strong></h3>&#13;
<p class="noindent">Your astronomer boss has given you 34 images of an exoplanet designated BR549. The images were taken an hour apart. Write a Python program that loads the images in order, measures the intensity of each image, and plots the measurements as a single light curve (<a href="ch08.xhtml#ch08fig28">Figure 8-28</a>). Use the curve to determine the length of a day on BR549.</p>&#13;
<div class="image"><img src="../images/fig08_28.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch08fig28"/>Figure 8-28: Composite light curve for 34 images of exoplanet BR549</p>&#13;
<p class="indent">You can find a solution, <em>practice_length_of_day.py,</em> in the appendix. The digital version of the code, along with the folder of images (<em>br549_pixelated</em>), are in the <em>Chapter_8</em>  folder downloadable from the book’s website.</p>&#13;
<h3 class="h3" id="ch00lev1sec73"><strong>Challenge Project: Generating a Dynamic Light Curve</strong></h3>&#13;
<p class="noindent">Rewrite <em>transit.py</em> so that the light curve dynamically updates as the simulation runs, rather than just appearing at the end.</p>&#13;
</body></html>