- en: '10'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '10'
- en: Using tkinter for Better Graphics
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 tkinter 创建更好的图形
- en: '![Image](Images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/common.jpg)'
- en: The problem with using a turtle to draw is . . . that . . . turtles . . . are
    . . . really . . . slow. Even when a turtle is going at top speed, it’s still
    not very fast. While this isn’t really an issue for turtles, it is for computer
    graphics.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 turtle 来绘图的问题是……海龟……真的……很慢。即使海龟以最快速度移动，它仍然不算快。虽然这对海龟来说不是问题，但对计算机图形来说却是个问题。
- en: 'Computer graphics usually need to move fast. If you play games on a game console
    or computer, think for a moment about the graphics you see on the screen. Two-dimensional
    (2D) graphics are flat: the characters generally move only up and down or left
    and right, as in many Nintendo and phone games. In pseudo-three-dimensional (3D)
    games—ones that are almost 3D—images look a little more real, but the characters
    generally move only in relation to a flat plane (this is also known as *isometric
    graphics*). Finally, we have 3D games, with graphics that attempt to mimic reality.
    Whether games use 2D, pseudo-3D, or 3D graphics, all have one thing in common:
    the need to draw on the computer screen very quickly.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机图形通常需要快速移动。如果你在游戏机或电脑上玩游戏，想一想屏幕上显示的图形。二维（2D）图形是平面的：角色通常只上下或左右移动，像许多任天堂和手机游戏那样。在伪三维（3D）游戏中——即接近三维的游戏——图像看起来更加真实，但角色通常只在一个平面上移动（这也被称为*等距图形*）。最后，我们有了3D游戏，它们的图形试图模拟现实。无论游戏使用2D、伪3D还是3D图形，它们都有一个共同点：需要在计算机屏幕上非常快速地绘图。
- en: '![Image](Images/f0136-01.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/f0136-01.jpg)'
- en: 'If you’ve never tried to create your own animation, try this simple project:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从未尝试过创建自己的动画，尝试这个简单的项目：
- en: Get a blank pad of paper, and in the bottom corner of the first page, draw something
    (perhaps a stick figure).
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拿一张空白纸，在第一页的底角画一些东西（可能是一个火柴人）。
- en: On the corner of the next page, draw the same stick figure, but move its leg
    slightly.
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一页的角落画出相同的火柴人，但稍微移动它的腿。
- en: On the next page, draw the stick figure again, with the leg moved a little more.
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一页上，再次绘制火柴人，并稍微移动一下它的腿。
- en: Gradually go through each page, drawing a modified stick figure on the bottom
    corner.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 逐页进行，在每页的底角画一个修改过的火柴人。
- en: When you’re finished, flip quickly through the pages, and you should see your
    stick figure moving. This is the basic method used with all animation, whether
    cartoons or video games. An image is drawn, and then drawn again with a slight
    change to create the illusion of movement. To make an image look like it is moving,
    you need to display each *frame*—or piece of the animation—very quickly.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，迅速翻阅页面，你应该能看到火柴人动起来了。这是所有动画的基本方法，无论是卡通还是视频游戏。先绘制一个图像，然后在图像上进行微小的改变，再次绘制它，以创造运动的错觉。要让图像看起来像是移动，你需要非常快速地显示每个*帧*——或动画的每一部分。
- en: Python offers different ways to create graphics. In addition to the turtle module,
    you can use *external* modules (which you need to install separately), as well
    as the tkinter module, which you should already have in your standard Python installation.
    The tkinter module can be used to create full applications, like a simple word
    processor, as well as drawings. In this chapter, we’ll explore using tkinter to
    create graphics.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Python 提供了多种创建图形的方式。除了 turtle 模块外，你还可以使用*外部*模块（需要单独安装），以及 tkinter 模块，这个模块你应该已经在标准的
    Python 安装中拥有。tkinter 模块不仅可以用于创建完整的应用程序，比如一个简单的文字处理器，还可以用于绘制图形。在本章中，我们将探索如何使用 tkinter
    创建图形。
- en: Creating a Clickable Button
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个可点击的按钮
- en: 'For our first example, we’ll use the tkinter module to create a basic application
    with a button. Enter this code:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个示例中，我们将使用 tkinter 模块来创建一个带按钮的基本应用程序。请输入以下代码：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'On the first line, we import the contents of the tkinter module. The from *module-name*
    import * line allows us to use the contents of a module without using its name.
    In contrast, when using import turtle in previous examples, we needed to include
    the module name to access its contents, like so:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我们导入 tkinter 模块的内容。`from *module-name* import *` 语句允许我们使用模块的内容，而无需使用模块名。相比之下，当我们在之前的示例中使用
    `import turtle` 时，我们需要包含模块名称才能访问其内容，像这样：
- en: '![Image](Images/f0137-01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/f0137-01.jpg)'
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When we use import *, we don’t need to call turtle.Turtle, as we did in [Chapters
    4](ch04.xhtml#ch04) and [9](ch09.xhtml#ch09). This is most useful when you’re
    using modules with a lot of classes and functions, because it reduces the amount
    you need to type:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `import *` 时，我们不需要像在 [第 4 章](ch04.xhtml#ch04) 和 [第 9 章](ch09.xhtml#ch09)
    中那样调用 `turtle.Turtle`。当你使用包含大量类和函数的模块时，这非常有用，因为它减少了你需要输入的内容：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: On the next line in our button example, we create a variable containing an object
    of the class Tk with tk = Tk(), just like we create a Turtle object for the turtle.
    The tk object creates a basic window to which we can then add other things, such
    as buttons, input boxes, or a canvas to draw on. This is the main class provided
    by the tkinter module; without creating an object of the Tk class, you won’t be
    able to do any graphics or animations.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的按钮示例中的下一行，我们创建了一个包含 Tk 类对象的变量 `tk = Tk()`，就像我们为海龟创建 `Turtle` 对象一样。`tk` 对象创建了一个基本窗口，我们可以在这个窗口中添加其他内容，如按钮、输入框或绘图画布。这是
    tkinter 模块提供的主类；如果不创建 Tk 类的对象，就无法进行图形或动画操作。
- en: On the third line, we create a button with btn = Button, and pass the tk variable
    as the first parameter and “click me” as the text the button will display with
    text=’click me’. Although we’ve added this button to the window, it won’t be displayed
    until you enter the line btn.pack(), which tells the button to appear. It also
    lines everything up correctly on the screen if there are other buttons or objects
    to display. The result should be something like [Figure 10-1](ch10.xhtml#ch10fig01).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三行，我们创建了一个按钮 `btn = Button`，并将 `tk` 变量作为第一个参数传入，同时使用 `text='click me'` 设置按钮显示的文字。虽然我们已经将这个按钮添加到窗口中，但直到你输入
    `btn.pack()` 这一行代码，按钮才会显示出来，这行代码告诉按钮显示出来。如果窗口中有其他按钮或对象需要显示，它还会正确地将所有元素排列到屏幕上。结果应该类似于
    [图 10-1](ch10.xhtml#ch10fig01)。
- en: '![Image](Images/10fig01.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/10fig01.jpg)'
- en: '*Figure 10-1: A tkinter application with a single button*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-1：一个带有单个按钮的 tkinter 应用程序*'
- en: Right now, the Click Me button doesn’t do much. You can click it all day, but
    nothing will happen until we change the code a bit. (Be sure to close the window
    you created earlier!)
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，"Click Me" 按钮没有什么功能。你可以整天点击它，但直到我们稍微修改代码，它才会有所动作。（记得关闭你之前创建的窗口！）
- en: 'First, we create a function to print some text:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个函数来打印一些文本：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then we modify our example to use this new function:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们修改示例，使用这个新函数：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We’ve made only a slight change to the previous version of this code, adding
    the command parameter, which tells Python to use the hello function when the button
    is clicked.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只对之前版本的代码进行了轻微修改，添加了 `command` 参数，告诉 Python 在点击按钮时使用 `hello` 函数。
- en: Now when you click the button, you’ll see “hello there” written to the Python
    Shell. This will appear each time the button is clicked. In [Figure 10-2](ch10.xhtml#ch10fig02),
    I’ve clicked the button five times.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你点击按钮时，你将看到 "hello there" 被打印到 Python Shell 中。每次点击按钮时，这个消息都会出现。在 [图 10-2](ch10.xhtml#ch10fig02)
    中，我点击了按钮五次。
- en: '![Image](Images/10fig02.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/10fig02.jpg)'
- en: '*Figure 10-2: Clicking the button*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-2：点击按钮*'
- en: This is the first time we’ve used named parameters in any of our code examples,
    so let’s talk about them a bit before continuing with our drawing.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们第一次在代码示例中使用命名参数，在继续绘制之前，我们先简单讨论一下它们。
- en: Using Named Parameters
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用命名参数
- en: '*Named parameters* are just like normal parameters, but rather than using the
    specific order of the values provided to a function to determine which value belongs
    to which parameter (the first value is the first parameter, the second value is
    the second parameter, and so on), we explicitly name the values so they can appear
    in any order.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*命名参数* 就像普通参数一样，只不过我们不再使用传入函数的值的特定顺序来确定哪个值属于哪个参数（第一个值是第一个参数，第二个值是第二个参数，依此类推），而是明确给值命名，这样它们就可以按任意顺序出现。'
- en: Sometimes functions have a lot of parameters, and we may not always need to
    provide a value for every one. With named parameters, we can provide values for
    only the parameters we need to give values.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，函数可能有很多参数，我们不一定需要为每个参数提供值。使用命名参数，我们只需要为需要的参数提供值。
- en: 'For example, suppose we have a person function that takes two parameters, width
    and height:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一个名为 `person` 的函数，它接受两个参数：宽度和高度：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Normally, we might call this function like so:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们可能这样调用这个函数：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Using named parameters, we could call this function and specify the parameter
    name with each value:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命名参数，我们可以调用这个函数并为每个值指定参数名称：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Named parameters will become particularly useful as we do more with the tkinter
    module.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 命名参数在我们深入使用 tkinter 模块时将特别有用。
- en: Creating a Canvas for Drawing
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建绘图画布
- en: 'Buttons are nice tools, but they’re not particularly useful when we want to
    draw things on the screen. When it’s time to draw, we need a different component:
    a canvas object, which is an object of the Canvas class (provided by the tkinter
    module).'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮是很好的工具，但在我们想要在屏幕上绘图时，它们并不特别有用。当需要绘制时，我们需要一个不同的组件：画布对象，它是 Canvas 类的一个对象（由 tkinter
    模块提供）。
- en: 'When creating a canvas, we pass the width and height (in pixels) of the canvas
    to Python. Otherwise, the code is similar to the button code. For example:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 创建画布时，我们需要将画布的宽度和高度（以像素为单位）传递给 Python。否则，代码与按钮代码相似。例如：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As with the button example, a window will appear when you enter tk = Tk(). On
    the last line, we pack the canvas with canvas.pack(), which applies the changes
    to the size of the canvas (a width of 500 pixels and a height of 500 pixels, as
    specified in the third line of code).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 与按钮示例一样，当你输入 `tk = Tk()` 时，会弹出一个窗口。在最后一行，我们用 `canvas.pack()` 来打包画布，这会应用画布的大小变化（宽度为
    500 像素，高度为 500 像素，如代码第三行所指定）。
- en: Also like the button example, the pack function tells the canvas to display
    itself in the correct position within the window. If pack isn’t called, nothing
    will display properly.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 同样像按钮示例一样，`pack` 函数告诉画布在窗口中以正确的位置显示自己。如果不调用 `pack`，画布将无法正确显示。
- en: '![Image](Images/f0140-01.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/f0140-01.jpg)'
- en: Drawing Lines
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绘制线条
- en: To draw a line on the canvas, we use pixel coordinates. *Coordinates* determine
    the positions of pixels on a surface. On a tkinter canvas, coordinates describe
    how far across the canvas (from left to right) and how far down the canvas (top
    to bottom) to place the pixel.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要在画布上绘制一条线，我们使用像素坐标。*坐标* 决定了像素在表面上的位置。在 tkinter 画布中，坐标描述了将像素放置到画布上的水平距离（从左到右）和垂直距离（从上到下）。
- en: For example, because our canvas is 500 pixels wide by 500 pixels high, the coordinates
    of the bottom-right corner of the screen are (500, 500). To draw the line shown
    in [Figure 10-3](ch10.xhtml#ch10fig03), we would use the starting coordinates
    (0, 0) and ending coordinates (500, 500).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，因为我们的画布宽度是 500 像素，高度是 500 像素，所以屏幕右下角的坐标是 (500, 500)。要绘制 [图 10-3](ch10.xhtml#ch10fig03)
    中显示的那条线，我们将使用起始坐标 (0, 0) 和结束坐标 (500, 500)。
- en: '![Image](Images/10fig03.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/10fig03.jpg)'
- en: '*Figure 10-3: Drawing a diagonal line with tkinter*'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-3：使用 tkinter 绘制对角线*'
- en: 'We specify the coordinates by using the create_line function, as shown here:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用 `create_line` 函数来指定坐标，如下所示：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The create_line function returns 1, which is an identifier; we’ll learn more
    about that later. If we had done the same thing with the turtle module, we would’ve
    needed the following this code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`create_line` 函数返回 1，这是一个标识符；我们稍后会详细了解。如果我们使用 turtle 模块做同样的事，我们就需要以下代码：'
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this code, the canvas is 500 pixels wide and 500 high, so the turtle appears
    at position 250, 250 (in the middle of the canvas). If we use the function t.goto(-250,
    250), we’re moving left 250 and up 250 pixels to the top left of the screen. When
    we call t.goto(500, -500), we’re then moving right 500 pixels and down 500 pixels
    to the bottom-right corner.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，画布宽 500 像素，高 500 像素，所以 turtle 出现的位置是 250, 250（画布的中间）。如果我们使用 `t.goto(-250,
    250)`，我们将向左移动 250 像素并向上移动 250 像素到屏幕的左上角。当我们调用 `t.goto(500, -500)` 时，我们则向右移动 500
    像素并向下移动 500 像素到右下角。
- en: So we can see that the tkinter code is already an improvement. It’s slightly
    shorter and simpler. Now let’s look at some of the functions available on the
    canvas object that we can use to create more interesting drawings.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们可以看到 tkinter 代码已经有所改进。它稍微简短且更简单了。现在让我们来看看 canvas 对象上可以使用的一些函数，这些函数能帮助我们绘制更有趣的图形。
- en: Drawing Boxes
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绘制框
- en: With the turtle module, we drew a box by moving forward, turning, moving forward,
    turning again, and so on. Eventually, we were able to draw a rectangular or square
    box by changing how far we moved forward.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 turtle 模块，我们通过前进、转弯、前进、再转弯等方式绘制了一个框。最终，我们通过改变前进的距离，能够画出矩形或正方形框。
- en: 'The tkinter module makes it a lot easier to draw a square or rectangle. All
    you need to know are the coordinates for the corners. Try the following example
    (you can close the other windows now):'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: tkinter 模块使得绘制正方形或矩形变得更加容易。你只需要知道角落的坐标。试试以下示例（你现在可以关闭其他窗口）：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this code, we use tkinter to create a canvas that is 400 pixels wide by 400
    pixels high, and we then draw a square in the top-left corner of the window, like
    [Figure 10-4](ch10.xhtml#ch10fig04).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们使用tkinter创建一个宽400像素、高400像素的画布，然后在窗口的左上角绘制一个正方形，像[图 10-4](ch10.xhtml#ch10fig04)那样。
- en: '![Image](Images/10fig04.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/10fig04.jpg)'
- en: '*Figure 10-4: Drawing a box*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-4：绘制一个框*'
- en: 'The parameters we pass to canvas.create_rectangle in the last line of the code
    are the coordinates for the top-left and bottom-right corners of the square. We
    provide these coordinates as the distance from the left-hand side of the canvas
    and the distance from the top of the canvas. In this case, the first two coordinates
    (the top-left corner) are 10 pixels across from the left and 10 pixels down from
    the top—those are the first numbers: 10, 10. The bottom-right corner of the square
    is 50 pixels across from the left and 50 pixels down from the top—the second numbers:
    50, 50.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在代码的最后一行传递给canvas.create_rectangle的参数是正方形的左上角和右下角的坐标。我们提供这些坐标作为距离画布左边和顶部的距离。在这种情况下，第一个坐标（左上角）是距离左边10像素，距离顶部10像素——这就是前两个数字：10，10。正方形的右下角距离左边50像素，距离顶部50像素——这就是第二组数字：50，50。
- en: 'We’ll refer to these two sets of coordinates as *x1*, *y1* and *x2*, *y2*.
    To draw a rectangle, we can increase the distance of the second corner from the
    side of the canvas (increasing the value of the *x2* parameter), like this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这两个坐标点分别称为*x1*，*y1* 和 *x2*，*y2*。要绘制一个矩形，我们可以增加第二个角点距离画布边缘的距离（增大*x2*参数的值），像这样：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this example, the top-left coordinates of the rectangle (its position on
    the screen) are (10, 10), and the bottom-right coordinates are (300, 50). The
    result is a rectangle that is the same height as our original square (40 pixels)
    but much wider.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，矩形的左上角坐标（它在屏幕上的位置）是（10，10），右下角坐标是（300，50）。结果是一个矩形，它的高度和原始正方形一样（40像素），但宽度大得多。
- en: '![Image](Images/10fig05.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/10fig05.jpg)'
- en: '*Figure 10-5: A wide rectangle*'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-5：一个宽的矩形*'
- en: 'We can also draw a rectangle by increasing the distance of the second corner
    from the top of the canvas (increasing the value of the *y2* parameter), like
    this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过增加第二个角点距离画布顶部的距离（增大*y2*参数的值）来绘制一个矩形，像这样：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In this call to the create_rectangle function, we’re telling tkinter to:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用create_rectangle函数时，我们告诉tkinter：
- en: Go 10 pixels across the canvas (from the top left).
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在画布上横向移动10像素（从左上角开始）。
- en: Go 10 pixels down the canvas. This is the starting corner of the rectangle.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在画布上向下移动10像素。这是矩形的起始角。
- en: Draw the rectangle across to 50 pixels.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将矩形绘制到50像素处。
- en: Draw down to 300 pixels.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制到底部300像素处。
- en: The end result should look something like [Figure 10-6](ch10.xhtml#ch10fig06).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果应该类似于[图 10-6](ch10.xhtml#ch10fig06)。
- en: '![Image](Images/10fig06.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/10fig06.jpg)'
- en: '*Figure 10-6: A tall rectangle*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-6：一个高的矩形*'
- en: Drawing a Lot of Rectangles
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绘制大量矩形
- en: Let’s try filling the canvas with different-sized rectangles by importing the
    random module and then creating a function that uses a random number for the coordinates
    at the top-left and bottom-right corners of the rectangle.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试通过导入random模块并创建一个函数，使用一个随机数来确定矩形左上角和右下角的坐标，从而填充画布，绘制不同大小的矩形。
- en: We’ll use the randrange function provided by the random module. When we give
    this function a number, it returns a random integer between 0 and the number we
    give it. For example, calling randrange(10) returns a number between 0 and 9,
    randrange(100) returns a number between 0 and 99, and so on.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用random模块提供的randrange函数。当我们给这个函数一个数字时，它会返回一个介于0和我们给定数字之间的随机整数。例如，调用randrange(10)会返回一个0到9之间的数字，调用randrange(100)会返回一个0到99之间的数字，依此类推。
- en: 'To use randrange in a function, create a new window by selecting **File ▸ New
    File**, and enter the following code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要在函数中使用randrange，首先通过选择**文件 ▸ 新建文件**来创建一个新窗口，并输入以下代码：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We first define our (random_rectangle) function as taking two parameters: width
    and height. Next, we create variables for the top-left corner of the rectangle
    by using the randrange function, passing the width and the height as parameters
    with x1 = random .randrange(width) and y1 = random.randrange(height), respectively.
    With the second line of this function, we’re saying, “Create a variable called
    x1 and set its value to a random number between 0 and the value in the parameter
    width.”'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将(random_rectangle)函数定义为接受两个参数：宽度和高度。接着，我们通过使用randrange函数来创建矩形的左上角坐标变量，传入宽度和高度作为参数，分别为x1
    = random.randrange(width)和y1 = random.randrange(height)。在函数的第二行，我们的意思是：“创建一个名为x1的变量，并将其值设为0到参数宽度之间的随机数。”
- en: The next two lines create variables for the bottom-right corner of the rectangle,
    taking into account the top-left coordinates (either x1 or y1) and adding a random
    number to those values. The third line of the function is effectively saying,
    “Create the variable x2 by adding a random number to the value we already calculated
    for x1.”
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两行代码为矩形的右下角创建变量，考虑到左上角的坐标（x1或y1），并为这些值添加一个随机数。函数的第三行实际上是在说：“通过将一个随机数加到我们已经计算的x1值上，创建变量x2。”
- en: Finally, with canvas.create_rectangle, we use the variables x1, y1, x2, and
    y2 to draw the rectangle on the canvas.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用canvas.create_rectangle时，我们利用x1、y1、x2和y2这些变量在画布上绘制矩形。
- en: 'To try our random_rectangle function, we’ll pass it the width and height of
    the canvas. Add the following code below the function you’ve just entered:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尝试我们的random_rectangle函数，我们将传入画布的宽度和高度。在你刚刚输入的函数下面添加以下代码：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Save the code you’ve entered (select **File ▸ Save** and enter a filename such
    as *randomrect.py*), and then select **Run ▸ Run Module**.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 保存你输入的代码（选择**文件 ▸ 保存**并输入文件名，例如*randomrect.py*），然后选择**运行 ▸ 运行模块**。
- en: '**NOTE**'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Our random_rectangle function can draw a rectangle off the side or bottom
    of the canvas. That’s because the top-left corner of the rectangle can be anywhere
    on the canvas (even in the bottom right-hand corner), and it doesn’t cause any
    errors to draw past the width or height of the canvas.*'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们的random_rectangle函数可以在画布的边缘或底部绘制矩形。这是因为矩形的左上角可以位于画布的任何位置（甚至是右下角），而且即使绘制超出画布的宽度或高度也不会导致错误。*'
- en: 'Once you’ve seen the function working, fill the screen with rectangles by creating
    a loop to call random_rectangle a number of times. Let’s try a for loop of 100
    random rectangles. Add the following code, save your work, and try running it
    again:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你看到函数正常工作，可以通过创建一个循环来多次调用random_rectangle，填满屏幕上的矩形。让我们尝试用一个for循环生成100个随机矩形。添加以下代码，保存你的工作，然后再次运行：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This code produces a bit of a mess, but it’s kind of modern art ([Figure 10-7](ch10.xhtml#ch10fig07)).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码虽然有点混乱，但它算是一种现代艺术（[图 10-7](ch10.xhtml#ch10fig07)）。
- en: '![Image](Images/10fig07.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/10fig07.jpg)'
- en: '*Figure 10-7: Modern art with tkinter*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-7：使用tkinter的现代艺术*'
- en: Setting the Color
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置颜色
- en: 'Let’s add interest to our graphics with color. We’ll change the random_rectangle
    function to pass in a color for the rectangle as an additional parameter (fill_color).
    Enter this code in a new window, and when you save, call the file *colorrect.py*:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过颜色为我们的图形增加一些趣味。我们将修改random_rectangle函数，传递一个矩形的颜色作为额外的参数（fill_color）。在新窗口中输入此代码，并保存时将文件命名为*colorrect.py*：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The create_rectangle function now takes a parameter, fill_color, which specifies
    the color to use when drawing the rectangle.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: create_rectangle函数现在接受一个fill_color参数，用来指定绘制矩形时使用的颜色。
- en: 'We can pass named colors into the function like this to create a bunch of uniquely
    colored rectangles. If you try this example, consider copying and pasting, after
    you enter the first line, to save on typing. To do so, select the text to copy,
    press CTRL-C to copy it, click a blank line, and press CTRL-V to paste. Add this
    code to *colorrect.py*, just below the function:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这样将命名的颜色传递给函数，以创建一堆独特颜色的矩形。如果你尝试这个例子，考虑在输入第一行后复制并粘贴，以节省输入时间。方法是选择要复制的文本，按CTRL-C复制，点击一个空白行，然后按CTRL-V粘贴。将此代码添加到*colorrect.py*文件中，紧接着在函数下面：
- en: '![Image](Images/f0148-01.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/f0148-01.jpg)'
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Many of these named colors will display the color you expect to see, but others
    may produce an error message (depending on whether you’re using Windows, macOS,
    or Linux). But what about a custom color that isn’t exactly the same as a named
    color? Recall in [Chapter 9](ch09.xhtml#ch09) that we set the color of the turtle’s
    pen by using percentages of the colors red, green, and blue. Setting the amount
    of each primary color (red, green, and blue) to use in a color combination with
    tkinter is slightly more complicated, but we’ll work through it.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命名的颜色中的许多将显示你预期的颜色，但其他颜色可能会产生错误信息（这取决于你使用的是Windows、macOS还是Linux）。但是，如果是一个自定义颜色，且与命名颜色不完全相同呢？回想一下在[第9章](ch09.xhtml#ch09)，我们通过使用红色、绿色和蓝色的百分比设置了海龟笔的颜色。使用tkinter设置颜色组合中每种原色的量稍微复杂一点，但我们将一步步解决这个问题。
- en: 'When working with the turtle module, we created gold using 90 percent red,
    75 percent green, and no blue. In tkinter, we can create the same gold color by
    using this line:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用turtle模块时，我们通过使用90%的红色、75%的绿色和没有蓝色来创建金色。在tkinter中，我们可以通过以下代码创建相同的金色：
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The hash mark (#) before the value ffd800 tells Python we’re providing a *hexadecimal*
    number. Hexadecimal is a way of representing numbers that is common in computer
    programming. It uses a base of 16 (0 through 9, then A through F) rather than
    decimal, which has a base of 10 (0 through 9). If you haven’t learned about bases
    in mathematics, just know that you can convert a normal decimal number to hexadecimal
    using a *format placeholder* in a string: {:x} (see “Embedding Values in Strings”
    on [page 29](ch03.xhtml#ch03lev1sec4)). For example, to convert the decimal number
    15 to hexadecimal, you could do this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 值ffd800前面的井号（#）告诉Python我们提供的是一个*十六进制*数字。十六进制是一种在计算机编程中常用的数字表示方式，它使用16为基数（0到9，然后是A到F），而十进制的基数是10（0到9）。如果你没有学过数学中的进制知识，只需要知道你可以通过字符串中的*格式占位符*将普通的十进制数转换为十六进制：{:x}（参见[第29页](ch03.xhtml#ch03lev1sec4)的“在字符串中嵌入值”）。例如，要将十进制数15转换为十六进制，你可以这样做：
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This is an f-string with a special format modifier (that’s :x) that tells Python
    to convert the number to hexadecimal.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个f-string，带有一个特殊的格式修饰符（即:x），告诉Python将数字转换为十六进制。
- en: 'To make sure our number has at least two digits, we can change the format placeholder
    slightly, to this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们的数字至少有两位，我们可以稍微修改格式占位符，改为：
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This time we have a slightly different format modifier (02x) that says we want
    hexadecimal conversion, but with two digits (using 0 for any missing digit).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们使用了一个稍微不同的格式修饰符（02x），它表示我们想要十六进制转换，但保留两位数字（对于任何缺少的数字，使用0）。
- en: 'The tkinter module provides an easy way to get hexadecimal color values. Try
    running the following code in IDLE:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: tkinter模块提供了一种获取十六进制颜色值的简便方法。尝试在IDLE中运行以下代码：
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This code displays a color chooser, shown in [Figure 10-8](ch10.xhtml#ch10fig08).
    Note that you have to explicitly import the colorchooser module because it’s not
    automatically available in Python when you use from tkinter import *.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码显示了一个颜色选择器，如[图10-8](ch10.xhtml#ch10fig08)所示。请注意，你必须显式导入colorchooser模块，因为在使用`from
    tkinter import *`时，它不会自动提供。
- en: '![Image](Images/10fig08.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/10fig08.jpg)'
- en: '*Figure 10-8: The tkinter color chooser (which may look different on your OS)*'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-8：tkinter颜色选择器（在你的操作系统上可能看起来不同）*'
- en: 'When you select a color and click **OK**, a tuple will be displayed. This tuple
    contains another tuple with three numbers and a string:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当你选择一个颜色并点击**确定**时，一个元组将会显示出来。这个元组包含另一个包含三个数字和一个字符串的元组：
- en: '[PRE23]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The three numbers represent the amounts of red, green, and blue. In tkinter,
    the amount of each primary color to use in a color combination is represented
    by a number between 0 and 255 (which is different from using a percentage for
    each primary color with the turtle module). The string in the tuple contains the
    hexadecimal version of those three numbers.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个数字代表红色、绿色和蓝色的量。在tkinter中，颜色组合中每种原色的使用量由0到255之间的数字表示（这与turtle模块中为每种原色使用百分比不同）。元组中的字符串包含这三个数字的十六进制版本。
- en: You can either copy and paste the string value to use it, or store the tuple
    as a variable and use the index position of the hexadecimal value.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以直接复制并粘贴字符串值来使用它，或者将元组存储为变量并使用十六进制值的索引位置。
- en: 'Let’s use the random_rectangle function to see how this works, by replacing
    all the random_rectangle calls at the bottom of *colorrect.py* with the following
    code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`random_rectangle`函数来看看这个是如何工作的，方法是用以下代码替换*colorrect.py*底部所有的`random_rectangle`调用：
- en: '[PRE24]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You can see the result in [Figure 10-9](ch10.xhtml#ch10fig09).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [图 10-9](ch10.xhtml#ch10fig09) 中看到结果。
- en: '![Image](Images/10fig09.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/10fig09.jpg)'
- en: '*Figure 10-9: Drawing a purple rectangle*'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-9：绘制一个紫色矩形*'
- en: Drawing Arcs
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绘制弧形
- en: 'An *arc* is a segment of the circumference of a circle or curve. To draw an
    arc with tkinter, you need to draw it inside a rectangle by using the create_arc
    function with code like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*弧形*是圆周或曲线的一部分。要使用 tkinter 绘制弧形，你需要在一个矩形内绘制它，使用 create_arc 函数，代码如下：'
- en: '[PRE25]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '![Image](Images/10fig10.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/10fig10.jpg)'
- en: '*Figure 10-10: Drawing an arc*'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-10：绘制弧形*'
- en: '**NOTE**'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you’ve closed all the tkinter windows or restarted IDLE, make sure to reimport
    tkinter and then re-create the canvas with this code:*'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你已经关闭了所有 tkinter 窗口或重启了 IDLE，请确保重新导入 tkinter，并使用以下代码重新创建画布：*'
- en: '[PRE26]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This code places the top-left corner of the rectangle that will contain the
    arc at the coordinates (10, 10), which is 10 pixels across and 10 pixels down,
    and its bottom-right corner at coordinates (200, 100), or 200 pixels across and
    100 pixels down. The next parameter, extent, is used to specify the degrees of
    the angle of the arc. Recall from [Chapter 4](ch04.xhtml#ch04) that degrees are
    a way of measuring the distance to travel around a circle. [Figure 10-11](ch10.xhtml#ch10fig11)
    shows examples of two arcs, where we travel 90 degrees and 270 degrees around
    a circle.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将包含弧形的矩形的左上角放置在坐标 (10, 10) 处，即向右 10 像素，向下 10 像素，右下角放置在坐标 (200, 100) 处，即向右
    200 像素，向下 100 像素。下一个参数 extent 用来指定弧形的角度。回想一下 [第 4 章](ch04.xhtml#ch04)，度数是测量沿圆周行驶距离的一种方式。[图
    10-11](ch10.xhtml#ch10fig11) 显示了两个弧形的示例，其中我们分别沿圆周行驶了 90 度和 270 度。
- en: '![Image](Images/10fig11.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/10fig11.jpg)'
- en: '*Figure 10-11: 90- and 270- degree arcs*'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-11：90度和270度弧形*'
- en: 'The following code draws several different arcs down the page so you can see
    what happens when we use different degrees with the create_arc function:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码会沿页面绘制几个不同的弧形，让你看到使用 create_arc 函数时不同角度的效果：
- en: '[PRE27]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The result is shown in [Figure 10-12](ch10.xhtml#ch10fig12).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如 [图 10-12](ch10.xhtml#ch10fig12) 所示。
- en: '![Image](Images/10fig12.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/10fig12.jpg)'
- en: '*Figure 10-12: Multiple arcs*'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-12：多个弧形*'
- en: '**NOTE**'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*We use 359 degrees in the final circle, rather than 360, because tkinter considers
    360 to be the same as 0 degrees, and would draw nothing.*'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们在最后的圆形中使用 359 度，而不是 360 度，因为 tkinter 认为 360 度等同于 0 度，且不会绘制任何内容。*'
- en: 'The style parameter is the type of arc you want to draw. There are two other
    types of arc: chord and pieslice. A *chord* is almost the same as the arc we have
    already drawn, except the two ends are joined together with a single straight
    line. A *pieslice* is exactly what it sounds like—as if you cut a segment out
    of a pizza or a pie.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 样式参数是你想要绘制的弧形类型。还有两种其他类型的弧形：弦和切片。*弦*与我们已经绘制的弧形几乎相同，只是两端通过一条直线连接在一起。*切片*顾名思义，就像你从披萨或馅饼中切下了一块。
- en: Drawing Polygons
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绘制多边形
- en: A *polygon* is any shape with three or more sides. There are regularly shaped
    polygons—like triangles, squares, rectangles, pentagons, hexagons, and so on—as
    well as *irregular* polygons with uneven edges, many more sides, and odd shapes.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*多边形*是任何具有三条或更多边的形状。常见的规则多边形有三角形、正方形、矩形、五边形、六边形等，也有*不规则*多边形，它们的边缘不均匀，边数较多，形状奇特。'
- en: 'When drawing polygons with tkinter, you need to provide coordinates for each
    point of the polygon. We can draw a triangle with the following code:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 tkinter 绘制多边形时，你需要为每个顶点提供坐标。我们可以使用以下代码绘制一个三角形：
- en: '[PRE28]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This example draws a triangle by starting with the *x* and *y* coordinates (10,
    10), then moving across to (100, 10), and finishing at (100, 110). We set the
    fill color to nothing (an empty string), so the triangle won’t be colored in,
    and the outline is set to ’black’, so it will be drawn with a black line. It should
    look like [Figure 10-13](ch10.xhtml#ch10fig13).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例通过从 *x* 和 *y* 坐标 (10, 10) 开始绘制一个三角形，然后移动到 (100, 10)，最后结束于 (100, 110)。我们将填充颜色设置为空（一个空字符串），因此三角形不会填充颜色，轮廓颜色设置为‘黑色’，所以它会用黑色线条绘制。它应该看起来像
    [图 10-13](ch10.xhtml#ch10fig13)。
- en: '![Image](Images/10fig13.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/10fig13.jpg)'
- en: '*Figure 10-13: Drawing a triangle*'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-13：绘制三角形*'
- en: 'We can add an irregular polygon by using this code:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码添加一个不规则的多边形：
- en: '[PRE29]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This code begins with the coordinates (200, 10), moves to (240, 30), then to
    (120, 100), and finally to (140, 120). The tkinter module automatically joins
    the line back to the first coordinate. The result is shown in [Figure 10-14](ch10.xhtml#ch10fig14).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码从坐标(200, 10)开始，移动到(240, 30)，然后到(120, 100)，最后到(140, 120)。tkinter模块会自动将线条连接回第一个坐标。结果如[图10-14](ch10.xhtml#ch10fig14)所示。
- en: '![Image](Images/10fig14.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/10fig14.jpg)'
- en: '*Figure 10-14: Irregular polygon*'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-14：不规则多边形*'
- en: Displaying Text
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 显示文本
- en: 'In addition to drawing shapes, you can also write on the canvas by using the
    create_text function. This function takes only two coordinates—the *x* and *y*
    positions of the text—along with a named parameter for the text to display. In
    the following code, we create our canvas as before and then display a sentence
    positioned at the coordinates (150, 100). Save this code as *text.py*:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 除了绘制形状，你还可以使用create_text函数在画布上书写文本。该函数仅接受两个坐标——文本的*x*和*y*位置——以及一个显示文本的命名参数。在以下代码中，我们像之前一样创建了画布，然后在坐标(150,
    100)处显示一行文本。将此代码保存为*text.py*：
- en: '[PRE30]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The create_text function can take other useful parameters, such as a text fill
    color. In the following code, we call the create _text function with coordinates
    (130, 120), the text we want to display, and a red fill color:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: create_text函数可以接受其他有用的参数，例如文本填充颜色。在以下代码中，我们调用create_text函数，指定坐标(130, 120)、要显示的文本和红色填充颜色：
- en: '[PRE31]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You can also specify the *font*, or the typeface used for the displayed text,
    as a tuple with the font name and the size of the text. For example, the tuple
    for the *Times* font of size 20 is (''Times'', 20). In the following code, we
    display text using the *Times* font set at size 15, the *Helvetica* font at size
    20, and the *Courier* font at sizes 22 and then 30:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以指定*font*，即显示文本时使用的字体，作为一个包含字体名称和文本大小的元组。例如，*Times*字体大小为20时，元组为('Times',
    20)。在以下代码中，我们使用*Times*字体（大小为15）、*Helvetica*字体（大小为20）以及*Courier*字体（大小为22和30）显示文本：
- en: '![Image](Images/f0156-01.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/f0156-01.jpg)'
- en: '[PRE32]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[Figure 10-15](ch10.xhtml#ch10fig15) shows the result of these functions using
    the three specified fonts at five different sizes.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '[图10-15](ch10.xhtml#ch10fig15)显示了使用三种指定字体和五种不同大小后的结果。'
- en: '![Image](Images/10fig15.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/10fig15.jpg)'
- en: '*Figure 10-15: Drawing text with tkinter*'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-15：使用tkinter绘制文本*'
- en: Displaying Images
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 显示图像
- en: To display an image on a canvas by using tkinter, first load the image and then
    use the create_image function on the canvas object. Any image you load must be
    in a folder (or directory) that’s accessible to Python.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要在画布上显示图像，可以先加载图像，然后使用create_image函数在画布对象上显示该图像。你加载的任何图像都必须位于Python可以访问的文件夹（或目录）中。
- en: The best place to put images is in your home folder. On Windows this is *c:**\**Users**\**<your
    username>*; on macOS, */Users/<your username>*; and on Ubuntu or Raspberry Pi,
    */home/<your* *username>*. [Figure 10-16](ch10.xhtml#ch10fig16) shows a home folder
    on Windows.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 放置图像的最佳位置是你的主文件夹。在Windows中，这是*c:**\**Users**\**<your username>*；在macOS中，是*/Users/<your
    username>*；在Ubuntu或Raspberry Pi中，是*/home/<your* *username>*。 [图10-16](ch10.xhtml#ch10fig16)显示了Windows上的主文件夹。
- en: '![Image](Images/10fig16.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/10fig16.jpg)'
- en: '*Figure 10-16: Home folder on Windows*'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-16：Windows上的“主文件夹”*'
- en: '**NOTE**'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*With tkinter, you can load only GIF images—image files with the extension*
    .gif. *You can display other types of images, such as PNG* (.png) *and JPG* (.jpg),
    *but you’ll need to use a different module such as Pillow, the Python Imaging
    Library (found at* [https://python-pillow.org](https://python-pillow.org)*). If
    you don’t have a GIF to use, try opening a photo and then saving it as a GIF.
    On Windows you can do this quite easily with the Paint app—but there are plenty
    of other ways to convert images to the GIF format.*'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用tkinter，你只能加载GIF图像—扩展名为*.gif*的图像文件。*你可以显示其他类型的图像，例如PNG* (.png) *和JPG* (.jpg)，*但你需要使用其他模块，如Pillow（Python图像库，网址为*
    [https://python-pillow.org](https://python-pillow.org)*）。如果你没有GIF图像可以使用，试着打开一张照片，然后将其保存为GIF格式。在Windows上，你可以通过“画图”应用程序轻松完成这项操作——当然，也有很多其他方式可以将图像转换为GIF格式。*'
- en: We can display an image called *test.gif* as follows.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以如下显示名为*test.gif*的图像。
- en: '[PRE33]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the first four lines, we set up the canvas as with the previous examples.
    In the fifth line, the image is loaded into the my_image variable. We create PhotoImage
    with the filename *c:\\* *Users\\jason\\test.gif*. We need to use two backslashes
    (*\\*) in a Windows filename, because backslash is a special character in a Python
    string (used for something called an escape character—for example, *\t* is the
    escape character representing a tab, *\n* is the escape character representing
    a newline, which we used back in [Chapter 7](ch07.xhtml#ch07)), and two backslashes
    are simply a way of saying, “I don’t want to use an escape character here—I want
    a single backslash.”
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在前四行中，我们像之前的示例一样设置了画布。在第五行，图像被加载到 my_image 变量中。我们用文件名 *c:\\* *Users\\jason\\test.gif*
    创建了 PhotoImage。我们需要在 Windows 文件名中使用两个反斜杠（*\\*），因为反斜杠在 Python 字符串中是一个特殊字符（用于表示转义字符——例如，*\\t*
    是表示制表符的转义字符，*\\n* 是表示换行符的转义字符，这在[第 7 章](ch07.xhtml#ch07)中我们也使用过），而两个反斜杠只是为了表示“不想在这里使用转义字符——我要使用单个反斜杠”。
- en: 'If you saved your image to the desktop, you should create the PhotoImage with
    that folder, like this:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将图像保存在桌面上，你应该像这样在那个文件夹中创建 PhotoImage：
- en: '[PRE34]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Once the image has been loaded into the variable, canvas .create_image(0, 0,
    anchor=NW, image=my_image) displays it using the create_image function. The coordinates
    (0, 0) are where the image will be displayed, and anchor=NW (with NW standing
    for *northwest*) tells the function to use the top-left edge of the image as the
    starting point when drawing; otherwise, it will use the center of the image as
    the starting point by default. The final named parameter, image, points at the
    variable for the loaded image. Your screen should look similar to [Figure 10-17](ch10.xhtml#ch10fig17).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦图像被加载到变量中，canvas.create_image(0, 0, anchor=NW, image=my_image) 就会使用 create_image
    函数显示它。坐标 (0, 0) 是图像显示的位置，而 anchor=NW（其中 NW 代表*西北*）告诉函数在绘制时使用图像的左上角作为起始点；否则，它默认使用图像的中心作为起始点。最后一个命名参数
    image 指向已加载图像的变量。你的屏幕应该类似于[图 10-17](ch10.xhtml#ch10fig17)。
- en: '![Image](Images/10fig17.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/10fig17.jpg)'
- en: '*Figure 10-17: Displaying an image*'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-17：显示图像*'
- en: Creating Basic Animation
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建基础动画
- en: We’ve covered how to create static pictures that don’t move. Now, we’ll turn
    our attention to creating animation.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了如何创建不动的静态图像。现在，我们将转向创建动画。
- en: 'Animation is not necessarily a specialty of the tkinter module, but it can
    handle the basics. For example, we can create a filled triangle and then make
    it move across the screen by using this code:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 动画不一定是 tkinter 模块的专长，但它能处理基本的动画。例如，我们可以创建一个填充的三角形，然后通过使用以下代码使其在屏幕上移动：
- en: '[PRE35]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: When you run this code, the triangle will start moving across the screen to
    the end of its path, as in [Figure 10-18](ch10.xhtml#ch10fig18).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这段代码时，三角形将开始沿着屏幕移动，直到它的路径终点，如[图 10-18](ch10.xhtml#ch10fig18)所示。
- en: '![Image](Images/10fig18.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/10fig18.jpg)'
- en: '*Figure 10-18: Moving triangle*'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-18：移动三角形*'
- en: As before, we’ve used the first three lines after importing tkinter to do the
    basic setup to display a canvas. We create the triangle with the call to the canvas.create_polygon(10,
    10, 10, 60, 50, 35) function.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前一样，在导入 tkinter 后，我们使用前三行代码完成基本的画布显示设置。我们通过调用 canvas.create_polygon(10, 10,
    10, 60, 50, 35) 函数创建三角形。
- en: '**NOTE**'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*When you enter this line, a number will be printed to the screen. This is
    an identifier for the polygon. We can use it to refer to the shape later, as described
    in the following example.*'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '*当你进入这一行时，屏幕上会打印出一个数字。这是多边形的标识符。我们可以用它来在后续中引用这个形状，如下面的示例所示。*'
- en: Next, we create a simple for loop to count from 1 to 61, beginning with for
    x in range(1, 61).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个简单的 for 循环，从 1 计数到 61，代码为 for x in range(1, 61)。
- en: The block of code inside the loop moves the triangle across the screen. The
    canvas.move function will move any drawn object by adding values to its x and
    y coordinates. For example, with canvas.move(1, 5, 0), we move the object with
    ID 1 (the identifier for the triangle—see the preceding Note) 5 pixels across
    and 0 pixels down. To move it back again, we could use the function call canvas.move(1,
    -5, 0).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 循环中的这段代码将三角形移动到屏幕上。canvas.move 函数通过将值添加到对象的 x 和 y 坐标来移动任何绘制的对象。例如，使用 canvas.move(1,
    5, 0)，我们将 ID 为 1 的对象（三角形的标识符——见前述说明）向右移动 5 像素，向下移动 0 像素。为了将其移回去，我们可以使用函数调用 canvas.move(1,
    -5, 0)。
- en: '![Image](Images/f0160-01.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/f0160-01.jpg)'
- en: The tk.update() function forces tkinter to update the screen (redraw it). If
    we didn’t use update, tkinter would wait until the loop finished before moving
    the triangle, which means you would see it jump to the last position, rather than
    move smoothly across the canvas. The final line of the loop, time.sleep(0.05),
    tells Python to sleep for one-twentieth of a second (0.05 seconds) before continuing.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: tk.update()函数强制tkinter更新屏幕（重新绘制）。如果我们不使用update，tkinter会等到循环完成后再移动三角形，这意味着你会看到它跳到最后的位置，而不是平滑地在画布上移动。循环的最后一行，time.sleep(0.05)，告诉Python在继续之前暂停二十分之一秒（0.05秒）。
- en: 'To make the triangle move diagonally down the screen, we can modify this code
    by calling move(1, 5, 5). Close the canvas and create a new file (**File ▸ New
    File**) for the following code:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 要让三角形在屏幕上斜着向下移动，我们可以通过调用move(1, 5, 5)来修改这段代码。关闭画布并创建一个新文件（**文件 ▸ 新建文件**）来输入以下代码：
- en: '[PRE36]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This code differs from the original in two ways:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与原始代码有两个不同之处：
- en: We made the height of the canvas 400, rather than 200, with canvas = Canvas(tk,
    width=400, height=400).
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将画布的高度改为400，而不是200，代码为canvas = Canvas(tk, width=400, height=400)。
- en: We added 5 to the triangle’s *x* and *y* coordinates with canvas.move(1, 5,
    5).
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过canvas.move(1, 5, 5)将三角形的* x *和* y *坐标各增加了5。
- en: '[Figure 10-19](ch10.xhtml#ch10fig19) shows the triangle’s position at the end
    of the loop, after you save your code and run it.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10-19](ch10.xhtml#ch10fig19)展示了循环结束时三角形的位置，在你保存代码并运行后。'
- en: '![Image](Images/10fig19.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/10fig19.jpg)'
- en: '*Figure 10-19: The triangle moved to the bottom of the screen.*'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-19：三角形移动到屏幕底部。*'
- en: 'To move the triangle diagonally back up the screen to its starting position,
    use (-5, -5). Add this code to the bottom of the file:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 要将三角形斜着向上移回到起始位置，可以使用(-5, -5)。将以下代码添加到文件的底部：
- en: '[PRE37]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: After you run this code, the triangle will move back to where it started.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这段代码后，三角形将返回到它开始的位置。
- en: Making an Object React to Something
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 让对象对某些事件做出反应
- en: We can make the triangle react when someone presses a key by using *event bindings*.
    *Events* are things that occur while a program is running, such as someone moving
    the mouse, pressing a key, or closing a window. You can tell tkinter to watch
    for these events and then do something in response.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用*事件绑定*让三角形对按键做出反应。*事件*是在程序运行时发生的事情，比如有人移动鼠标、按下键盘或关闭窗口。你可以告诉tkinter监视这些事件，然后做出响应。
- en: To begin *handling* events (making Python do something when an event occurs),
    we first create a function. The binding part comes when we tell tkinter that a
    particular function is bound (or associated) to a specific event. In other words,
    it will be automatically called by tkinter to handle that event.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始*处理*事件（让Python在事件发生时做出反应），我们首先创建一个函数。绑定的部分是我们告诉tkinter某个特定的函数绑定（或关联）到一个特定事件。换句话说，它将由tkinter自动调用来处理该事件。
- en: 'For example, to make the triangle move when we press ENTER, we can define this
    function:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要让三角形在按下ENTER时移动，我们可以定义这个函数：
- en: '[PRE38]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The function takes a single parameter (event), which tkinter uses to send information
    to the function about the event. We tell tkinter that this function should be
    used for a particular event by using the bind_all function on the canvas. The
    full code now looks like this—let’s type it into a new file in IDLE and save it
    as *movingtriangle.py* before we run it:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受一个参数（event），tkinter用它来将有关事件的信息发送给函数。我们通过在画布上使用bind_all函数来告诉tkinter此函数应当处理特定的事件。完整的代码现在如下——我们在IDLE中新建文件并保存为*movingtriangle.py*，然后运行它：
- en: '[PRE39]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The first parameter in this function describes the event that we want tkinter
    to watch for. In this case, it’s called <KeyPress-Return>, which is a press of
    the ENTER or RETURN key. We tell tkinter that the movetriangle function should
    be called whenever this KeyPress event occurs. Run this code, click the canvas
    with your mouse, and then try pressing ENTER on your keyboard.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的第一个参数描述了我们希望tkinter监视的事件。在这种情况下，它被称为<KeyPress-Return>，即按下ENTER或RETURN键。我们告诉tkinter每当发生这个KeyPress事件时，就应该调用movetriangle函数。运行这段代码，点击画布，然后按下键盘上的ENTER键。
- en: '![Image](Images/f0163-01.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0163-01.jpg)'
- en: 'Let’s try changing the direction of the triangle depending on different key
    presses, such as the arrow keys. We first need to change the movetriangle function
    to the following:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试着根据不同的按键改变三角形的移动方向，比如方向键。首先我们需要将movetriangle函数改为以下内容：
- en: '[PRE40]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The event object passed to movetriangle contains several variables. One of these
    variables, keysym (for *key symbol*), is a string that holds the value of the
    actual key pressed. The line if event .keysym == ’Up’ says that if the keysym
    variable contains the string ’Up’, we should call canvas.move with the parameters
    (1, 0, –3), as we do in the following line. If keysym contains ’Down’, as in elif
    event.keysym == ’Down’, we call it with the parameters (1, 0, 3), and so on.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 `movetriangle` 的事件对象包含多个变量。其中一个变量是 `keysym`（表示 *键符号*），它是一个字符串，保存了实际按下的键的值。`if
    event.keysym == 'Up'` 这一行表示，如果 `keysym` 变量包含字符串 "Up"，我们应该调用 `canvas.move`，并传入参数
    (1, 0, –3)，正如下面的代码所示。如果 `keysym` 包含 "Down"，如 `elif event.keysym == 'Down'`，我们就调用带参数
    (1, 0, 3) 的函数，以此类推。
- en: 'Remember: The first parameter is the identifying number for the shape drawn
    on the canvas, the second is the value to add to the *x* (horizontal) coordinate,
    and the third is the value to add to the *y* (vertical) coordinate.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 记住：第一个参数是画布上绘制形状的标识编号，第二个是添加到 *x*（水平）坐标的值，第三个是添加到 *y*（垂直）坐标的值。
- en: 'We then tell tkinter that the movetriangle function will be used to handle
    events from four different keys (up, down, left, and right). The following shows
    how the *movingtriangle.py* code should look now:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们告诉 tkinter，`movetriangle` 函数将用于处理来自四个不同键（上、下、左、右）的事件。以下是现在 *movingtriangle.py*
    代码的样子：
- en: '[PRE41]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: On the first line of the movetriangle function, we check whether the keysym
    variable contains ’Up’ ➊. If it does, we move the triangle upward using the move
    function with the parameters 1, 0, {3 ➋. The first parameter is the identifier
    of the triangle, the second is the amount to move to the right (we don’t want
    to move horizontally, so the value is 0), and the third is the amount to move
    downward (–3 pixels).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `movetriangle` 函数的第一行，我们检查 `keysym` 变量是否包含 "Up" ➊。如果包含，我们使用 `move` 函数将三角形向上移动，参数为
    1、0、{3 ➋。第一个参数是三角形的标识符，第二个是向右移动的量（我们不希望水平移动，因此值为 0），第三个是向下移动的量（–3 像素）。
- en: We then check whether keysym contains ’Down’ ➌; if so, we move the triangle
    down (3 pixels) ➍. The final check is whether the value is ’Left’; if so, we move
    the triangle left (–3 pixels). If none of the values are matched, the final else
    ➎ moves the triangle right ➏.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们检查 `keysym` 是否包含 "Down" ➌；如果是的话，我们将三角形向下移动（3 像素） ➍。最后的检查是判断值是否为 "Left"；如果是的话，我们将三角形向左移动（–3
    像素）。如果没有任何值匹配，最终的 `else` ➎ 将三角形向右移动 ➏。
- en: Now the triangle should move in the direction of the pressed arrow key.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，三角形应该会根据按下的箭头键的方向移动。
- en: More Ways to Use the Identifier
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用标识符的更多方法
- en: 'Whenever we use a create_function from the canvas, such as create_polygon or
    create_rectangle, an identifier is returned. This identifying number can be used
    with other canvas functions, as we did earlier with the move function:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们使用画布的 `create_function`，例如 `create_polygon` 或 `create_rectangle`，都会返回一个标识符。这个标识符可以与其他画布函数一起使用，就像我们之前使用
    `move` 函数一样：
- en: '[PRE42]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The problem with this example is that create_polygon won’t always return 1\.
    For example, if you’ve created other shapes, it might return 2, 3, or even 100
    (depending on the number of shapes you’ve created). If we change the code to store
    the value returned as a variable, and then use the variable (rather than just
    referring to the number 1), the code will work no matter what number is returned.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子的问题在于，`create_polygon` 不会总是返回 1。例如，如果你创建了其他形状，它可能返回 2、3，甚至 100（取决于你创建了多少个形状）。如果我们改变代码，将返回的值存储为一个变量，然后使用该变量（而不是仅仅引用数字
    1），那么无论返回什么数字，代码都会正常工作。
- en: '[PRE43]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The move function allows us to move objects around the screen by using their
    identifier. But other canvas functions can also change something we’ve drawn.
    For example, the itemconfig function can change some parameters of a shape, such
    as its fill and outline colors.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`move` 函数允许我们通过标识符在屏幕上移动对象。但其他画布函数也可以改变我们绘制的东西。例如，`itemconfig` 函数可以更改形状的一些参数，如填充色和轮廓色。'
- en: 'Say we create a red triangle:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们创建了一个红色的三角形：
- en: '[PRE44]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We can change the triangle to another color with itemconfig and use the identifier
    as the first parameter. The following code says, “Change the fill color of the
    object identified by the number in variable mytriangle to blue”:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过 `itemconfig` 改变三角形的颜色，并使用标识符作为第一个参数。以下代码表示“将变量 `mytriangle` 中标识的对象的填充颜色改为蓝色”：
- en: '[PRE45]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We could also give the triangle a different-colored outline, again using the
    identifier as the first parameter:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以给三角形添加不同颜色的轮廓，同样使用标识符作为第一个参数：
- en: '[PRE46]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Later, we’ll learn how to make other changes to a drawing, like hiding it and
    making it visible again. You’ll find the ability to change your drawings useful
    when we start writing games in the next chapter.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后我们将学习如何对图形进行其他修改，比如隐藏图形并再次显示它。当我们开始编写游戏时，改变图形的能力将非常有用。
- en: '![Image](Images/f0166-01.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/f0166-01.jpg)'
- en: What You Learned
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你学到了什么
- en: In this chapter, you used the tkinter module to draw simple geometric shapes
    on a canvas, display images, and perform basic animation. You learned how event
    bindings can make drawings react to someone pressing a key, which will be helpful
    once we start programming a game. You learned how tkinter’s create functions return
    an identifying number, which can be used to modify shapes after they’ve been drawn,
    such as to move them around on the screen or change their color.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你使用了 tkinter 模块在画布上绘制简单的几何图形、显示图像并执行基本的动画。你学会了事件绑定如何使图形响应键盘按键，这对于我们接下来编写游戏时非常有用。你还学会了
    tkinter 的创建函数如何返回一个标识编号，可以用来修改已绘制的图形，比如移动它们或更改它们的颜色。
- en: Programming Puzzles
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编程难题
- en: Try the following to further explore the tkinter module and basic animation.
    Visit *[http://python-for-kids.com](http://python-for-kids.com)* to download the
    solutions.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试以下内容，进一步探索 tkinter 模块和基础动画。访问 *[http://python-for-kids.com](http://python-for-kids.com)*
    下载解决方案。
- en: '#1: Fill the Screen with Triangles'
  id: totrans-252
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '#1: 填满屏幕的三角形'
- en: Create a program using tkinter to fill the screen with triangles. Then change
    the code to fill the screen with different-colored (filled) triangles instead.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 tkinter 创建一个程序，填满屏幕的三角形。然后将代码修改为用不同颜色的（填充的）三角形来填满屏幕。
- en: '#2: The Moving Triangle'
  id: totrans-254
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '#2: 移动的三角形'
- en: Modify the code for the moving triangle (“Creating Basic Animation” on [page
    159](ch10.xhtml#ch10lev1sec12)) to make it move across the screen to the right,
    then down, then back to the left, and then back to its starting position.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 修改移动三角形的代码（见[第159页](ch10.xhtml#ch10lev1sec12)中的“创建基础动画”）使其在屏幕上向右移动，然后向下，再向左，最后回到起始位置。
- en: '#3: The Moving Photo'
  id: totrans-256
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '#3: 移动的照片'
- en: Try displaying a photo of yourself on the canvas. Make sure it’s a GIF image!
    Can you make it move across the screen?
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在画布上显示你的照片。确保它是一个 GIF 图像！你能让它在屏幕上移动吗？
- en: '#4: Fill the Screen with Photos'
  id: totrans-258
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '#4: 填满屏幕的照片'
- en: Take the photo you used in the previous puzzle, and shrink it down small.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 拿着你在前一个谜题中使用的照片，将它缩小。
- en: On macOS, you can use Preview to resize an image (choose **Tools ▸ Adjust Size**,
    and enter a new width and height. Then, click **File ▸ Export** to save with a
    new filename).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在 macOS 上，你可以使用预览来调整图像大小（选择 **工具 ▸ 调整大小**，输入新的宽度和高度。然后，点击 **文件 ▸ 导出** 保存为新文件名）。
- en: On Windows, you can use Paint (click the **Resize** button, choose a horizontal
    and vertical size, then **File ▸ Save As** to save with a new filename).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，你可以使用画图（点击 **调整大小** 按钮，选择水平和垂直尺寸，然后 **文件 ▸ 另存为** 保存为新文件名）。
- en: In Ubuntu and Raspberry Pi, you’ll need a program called GIMP (jump ahead to
    [page 203](ch13.xhtml#ch13fig02) in [Chapter 13](ch13.xhtml#ch13) if you don’t
    have this installed)—select **Image** ▸ **Scale Image** in GIMP, and then **File
    ▸ Export As** to save it with a new filename.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ubuntu 和 Raspberry Pi 上，你需要一个叫做 GIMP 的程序（如果你没有安装，请跳到[第13章](ch13.xhtml#ch13)中的[第203页](ch13.xhtml#ch13fig02)）——在
    GIMP 中选择 **图像** ▸ **缩放图像**，然后选择 **文件 ▸ 另存为** 来保存为新文件名。
- en: Import the time module and then use the sleep function (try with time.sleep(0.5))
    to make the photos appear more slowly.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 导入时间模块，然后使用 sleep 函数（尝试使用 time.sleep(0.5)）让照片出现得更慢。
