<html><head></head><body>
<h2 class="h2" id="ch18"><span epub:type="pagebreak" id="page_493"/><span class="big">18</span><br/>PRODUCING AN SVG IMAGE AND TEXT FILE</h2>&#13;
<div class="image1"><img src="../images/common01.jpg" alt="Image"/></div>&#13;
<p class="noindent">When we solve one of our truss structures, we construct a new model with the solution values. If we want to explore the stress on each bar or the displacement of each node, we need to produce some kind of output with this information. Diagrams are one good way of displaying the information that results from engineering calculations, but we may also want a text file with the detailed values.</p>&#13;
<p class="indent">In this chapter, we’ll write a module for our structural analysis application that produces both a vector image with all the relevant pieces of data in the solution, and a simpler textual representation of the structure solution.</p>&#13;
<h3 class="h3" id="ch00lev1sec109"><span epub:type="pagebreak" id="page_494"/><strong>Setup</strong></h3>&#13;
<p class="noindent">Let’s add a new package in <em>structures</em> named <em>out</em>; this package will contain all the solution output code. Your <em>structures</em> package directory should now look like this:</p>&#13;
<p class="pre2">    structures<br/>      |- generation<br/>      |- model<br/>      |- out<br/>      |- parse<br/>      |- solution<br/>      |- tests</p>&#13;
<p class="indent">We’ll start by implementing the function that produces an SVG image from the structure solution. Let’s create a new Python file named <em>svg.py</em> and another one named <em>config.json</em> that’ll contain the configuration for the drawing. Your <em>out</em> directory should now contain the following files:</p>&#13;
<p class="pre2">    structures<br/>      |- out<br/>           |- __init__.py<br/>           |- config.json<br/>           |- svg.py</p>&#13;
<p class="noindent">As usual, don’t forget to include an <em>__init__.py</em> file if you didn’t use the IDE.</p>&#13;
<h3 class="h3" id="ch00lev1sec110"><strong>From Structure Solution to SVG</strong></h3>&#13;
<p class="noindent">When our output code is finished, it should produce diagrams like the one in <a href="ch18.xhtml#ch18fig1">Figure 18-1</a>. Although you can’t see it in the print version of the book, the compression bars are red, and the tension bars are green. The external forces are yellow, and we’re using purple for the reactions.</p>&#13;
<div class="image"><img src="../images/18fig01.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch18fig1"><em>Figure 18-1: Truss result diagram</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_495"/>This image was generated using the code we’re going to write together in the rest of this chapter.</p>&#13;
<h4 class="h4" id="ch00lev2sec194"><strong><em>The Configuration File</em></strong></h4>&#13;
<p class="noindent">Once your code is ready and working, you may want to play with the diagram’s colors and sizes to get a result you find satisfying. We want to have the liberty of changing these colors without needing to read through our code, so we’ll move them to a separate configuration file, like we’ve already done in <a href="ch09.xhtml#ch09">Chapter 9</a> and <a href="ch12.xhtml#ch12">Chapter 12</a>. In fact, any parameter we want to tweak can be placed in the configuration file. We’ll include things such as the radius of the nodes, their stroke width, and the margin of the image in the configuration, among others.</p>&#13;
<p class="indent"><a href="ch18.xhtml#ch18fig2">Figure 18-2</a> illustrates some of the properties we want to be configurable and the values we’ll assign them. Colors are represented using hexadecimal values prefixed with a <span class="literal">#</span>.</p>&#13;
<div class="image"><img src="../images/18fig02.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch18fig2"><em>Figure 18-2: Output configuration values</em></p>&#13;
<p class="indent">Open the <em>config.json</em> file we just created and enter the configuration values in <a href="ch18.xhtml#ch18lis1">Listing 18-1</a>.</p>&#13;
<pre>{&#13;
    "sizes": {&#13;
        "margin": 170,&#13;
        "node_radius": 5,&#13;
        "stroke": 4,&#13;
        "arrow": 14&#13;
    },&#13;
    "colors": {&#13;
        "node_stroke": "#354595",&#13;
        "back": "#FFFFFF",&#13;
        "traction": "#005005",&#13;
        "compression": "#BB2727",&#13;
        "original": "#D5DBF8",&#13;
        "load": "#FFC046",&#13;
        "reaction": "#4A0072"&#13;
    },&#13;
    "font": {&#13;
        "family": "sans-serif",&#13;
        <span epub:type="pagebreak" id="page_496"/>"size": 14&#13;
    }&#13;
}</pre>&#13;
<p class="caption"><a id="ch18lis1"/><em>Listing 18-1: The default configuration for our output image</em></p>&#13;
<p class="indent">These configuration values are the defaults we’ll use when no others are given. Feel free to personalize your app’s diagrams using different colors, sizes, or text font.</p>&#13;
<p class="indent">To do this, we need a way of reading the configuration JSON file into our main <em>svg.py</em> script. Let’s write a function to do this. In <em>svg.py</em>, enter the code in <a href="ch18.xhtml#ch18lis2">Listing 18-2</a>.</p>&#13;
<pre>import json&#13;
&#13;
import pkg_resources as res&#13;
&#13;
&#13;
def __read_config():&#13;
    config = res.resource_string(__name__, 'config.json')&#13;
    return json.loads(config)</pre>&#13;
<p class="caption"><a id="ch18lis2"/><em>Listing 18-2: Reading the configuration JSON file</em></p>&#13;
<p class="indent">The <span class="literal">__read_config</span> function uses <span class="literal">resource_string</span> from the <span class="literal">pkg_resources</span> package (from Python’s standard library) to load our <em>config.json</em> file into a string. Then, we use <span class="literal">json.loads</span> to parse the string into a dictionary. We’ll use this function later.</p>&#13;
<p class="indent">Let’s now see how we can allow the user to pass some parameters to the application; these will modify how the resulting diagram is drawn.</p>&#13;
<h4 class="h4" id="ch00lev2sec195"><strong><em>The Settings</em></strong></h4>&#13;
<p class="noindent">We have the configuration, which contains values that determine how the diagram will look. These values are defined by the application, and users don’t need to worry about them. We allow users to pass a configuration dictionary to the application with values that override the default configuration.</p>&#13;
<p class="indent">Apart from the configuration, there are some other values our application needs to draw the solution diagram for a given structure. These values include the scales used to draw the geometry and loads, for example. We can’t guess these beforehand, so we need the user to provide them to the application.</p>&#13;
<p class="indent">Let’s call these one-time values <em>settings</em>. We’ll pass our function a settings dictionary, but these settings won’t have default values because there are no sensible defaults we can use here; they completely depend on the structure being computed and what the user wants the result to look like. Does the user want to exaggerate the deformations? Or do they want to see the deformations without a scale to get an idea of what the deformed structure actually looks like? We can’t guess this ourselves, and thus, we’ll let the user of the app decide on these values.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_497"/>We’ve included all the settings we want to make available to the user in <a href="ch18.xhtml#ch18tab1">Table 18-1</a>.</p>&#13;
<p class="tabcap" id="ch18tab1"><strong>Table 18-1:</strong> Output Settings</p>&#13;
<table class="all">&#13;
<tbody><tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Name</strong></p>&#13;
</td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Type</strong></p>&#13;
</td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Purpose</strong></p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">scale</span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="taba">Number</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="taba">Changes the scale of the resulting drawing</p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">disp_scale</span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="taba">Number</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="taba">Changes the scale of the node displacements</p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">load_scale</span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="taba">Number</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="taba">Changes the scale of load representation</p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h1aa"><p class="taba"><span class="literal">no_draw_original</span></p>&#13;
</td>&#13;
<td style="vertical-align: top;" class="table-h1aa"><p class="taba">Boolean</p>&#13;
</td>&#13;
<td style="vertical-align: top;" class="table-h1aa"><p class="taba">Specifies whether to draw the original geometry</p>&#13;
</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Let’s write a function to validate that the dictionary contains values for all these settings. In your <em>svg.py</em> file, enter the function in <a href="ch18.xhtml#ch18lis3">Listing 18-3</a>.</p>&#13;
<pre><span class="codeitalic1">--snip--</span>&#13;
&#13;
__expected_settings = (&#13;
    # scale applied to the diagram&#13;
    'scale',&#13;
    # scale applied to the node displacements&#13;
    'disp_scale',&#13;
    # scale applied to the load vectors&#13;
    'load_scale',&#13;
    # boolean to decide whether to draw the original geometry&#13;
    'no_draw_original'&#13;
)&#13;
&#13;
&#13;
def __validate_settings(settings):&#13;
    for setting in __expected_settings:&#13;
        if setting not in settings:&#13;
            raise ValueError(f'"{setting}" missing in settings')</pre>&#13;
<p class="caption"><a id="ch18lis3"/><em>Listing 18-3: Validating the <span class="codeitalic1">settings</span> dictionary</em></p>&#13;
<p class="indent">This <span class="literal">__validate_settings</span> function ensures all the expected settings are in the <span class="literal">settings</span> dictionary. If any of the functions are not, we raise an error with a message for the user. Let’s now write the function to produce the SVG image.</p>&#13;
<h4 class="h4" id="ch00lev2sec196"><strong><em>The Solution Drawing Function</em></strong></h4>&#13;
<p class="noindent">In the <em>svg.py</em> file, before the <span class="literal">__read_config</span> function, enter the code in <a href="ch18.xhtml#ch18lis4">Listing 18-4</a>.</p>&#13;
<pre>import json&#13;
&#13;
import pkg_resources as res&#13;
&#13;
<span epub:type="pagebreak" id="page_498"/><span class="codestrong1">from geom2d import AffineTransform</span>&#13;
<span class="codestrong1">from graphic import svg</span>&#13;
<span class="codestrong1">from structures.solution.structure import StructureSolution</span>&#13;
&#13;
&#13;
def structure_solution_to_svg(&#13;
        result: StructureSolution,&#13;
        settings,&#13;
        _config=None,&#13;
):&#13;
    __validate_settings(settings)&#13;
    default_config = __read_config()&#13;
&#13;
 <span class="ent">➊</span> config = {**default_config, **(_config or {})}&#13;
&#13;
 <span class="ent">➋</span> viewbox = result.bounds_rect(&#13;
        config['sizes']['margin'],&#13;
        settings.scale&#13;
    )&#13;
    transform = AffineTransform(sx=1, sy=-1, tx=0, ty=0)&#13;
&#13;
 <span class="ent">➌</span> return svg.svg_content(&#13;
        size=viewbox.size,&#13;
        primitives=[],&#13;
        viewbox_rect=viewbox,&#13;
        transform=transform&#13;
&#13;
   )&#13;
&#13;
&#13;
<span class="codeitalic1">--snip--</span></pre>&#13;
<p class="caption"><a id="ch18lis4"/><em>Listing 18-4: Structure solution to SVG function</em></p>&#13;
<p class="indent">We define the <span class="literal">structure_solution_to_svg</span> function, but it doesn’t draw anything yet; it just produces an empty SVG image. The function receives three parameters: the structure solution (a <span class="literal">StructureSolution</span> class instance), the <span class="literal">settings</span> dictionary, and the configuration dictionary. The configuration dictionary is optional, so we give it a default value of <span class="literal">None</span>.</p>&#13;
<p class="indent">In the function, we first validate the passed-in settings using the function we wrote in the previous section. If the validation fails, we raise an error and halt execution of the function.</p>&#13;
<p class="indent">Next, we load the default configuration using the <span class="literal">__read_config</span> function.</p>&#13;
<p class="indent">The next step is merging the passed-in configuration dictionary with the default one <span class="ent">➊</span>. The dictionaries are merged using Python’s dictionary unpacking operator: <span class="literal">**</span>. If <span class="literal">a</span> and <span class="literal">b</span> are dictionaries, using <span class="literal">{**a, **b}</span> will create a new dictionary containing all the entries from <span class="literal">a</span> and <span class="literal">b</span>. If there’s a key that’s in both dictionaries, the version in <span class="literal">b</span>, the second dictionary, is kept. Therefore, in our usage, if a configuration value is given by the user, this overrides <span epub:type="pagebreak" id="page_499"/>the default one. We store the merged configuration dictionary in the <span class="literal">config</span> variable.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The dictionary unpacking operator was added in Python version 3.5. You can read more about it in PEP-448:</em> <a href="https://www.python.org/dev/peps/pep-0448">https://www.python.org/dev/peps/pep-0448</a><em>. PEP stands for “Python Enhancement Proposal.” These are the documents the Python community writes to propose new features for the language, among others.</em></p>&#13;
</div>&#13;
<p class="indent">Next, we compute the viewbox for the SVG image using the structure solution’s bounding rectangle <span class="ent">➋</span>. If you recall, the <span class="literal">StructureSolution</span> <span class="literal">bounds_rect</span> method’s first parameter is the margin for the bounds, and the second is the scale. We take the value for the margin from the configuration and the scale from the settings.</p>&#13;
<p class="indent">We then create an affine transformation that we’ll use to flip the image’s y-axis so that it points up.</p>&#13;
<p class="indent">Lastly, we create and return the SVG image using <span class="literal">svg_content</span> from our <span class="literal">svg</span> package <span class="ent">➌</span>. The size of the image is given by the <span class="literal">viewbox</span> size; the list of primitives is empty at the moment. In the next sections, we’ll fill this list with the SVG primitives that represent the nodes, bars, and loads. First, though, let’s look at captions.</p>&#13;
<h4 class="h4" id="ch00lev2sec197"><strong><em>Captions</em></strong></h4>&#13;
<p class="noindent">We’re going to use captions in a few places: to note the bars’ stresses, to number the nodes, and to give forces coordinates. Positioning these captions is going to be a bit tricky since we’ll want to rotate them so they align with the element they caption, as you can see in <a href="ch18.xhtml#ch18fig3">Figure 18-3</a>.</p>&#13;
<div class="image"><img src="../images/18fig03.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch18fig3"><em>Figure 18-3: Captions in our diagram</em></p>&#13;
<p class="indent">Furthermore, since we applied an affine transformation to the SVG image that flips the y-axis, the captions we add will also be flipped, and if we don’t undo that flip, they’ll be impossible to read. We’ll correct this by scaling the caption so that its y-axis is flipped back.</p>&#13;
<p class="indent">Create a new Python file in <em>structures/out</em> named <em>captions_svg.py</em>. Your <em>out</em> directory should look like the following:</p>&#13;
<p class="pre2">    out<br/>      |- __init__.py<br/>      |- captions_svg.py<br/>      |- svg.py</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_500"/>In this new file, enter the code in <a href="ch18.xhtml#ch18lis5">Listing 18-5</a>.</p>&#13;
<pre>from geom2d import Point, Vector, make_rotation, make_scale&#13;
from graphic import svg&#13;
from graphic.svg import attributes&#13;
&#13;
&#13;
def caption_to_svg(&#13;
        caption: str,&#13;
        position: Point,&#13;
        angle: float,&#13;
        color: str,&#13;
        config&#13;
):&#13;
 <span class="ent">➊</span> font = config['font']['family']&#13;
    size = config['font']['size']&#13;
&#13;
    rotation = make_rotation(angle, position)&#13;
    scale = make_scale(1, -1, position)&#13;
 <span class="ent">➋</span> transform = rotation.then(scale)&#13;
&#13;
 <span class="ent">➌</span> return svg.text(&#13;
        caption,&#13;
        position,&#13;
        Vector(0, 0),&#13;
        [&#13;
            attributes.fill_color(color),&#13;
            attributes.affine_transform(transform),&#13;
            attributes.font_family(font),&#13;
            attributes.font_size(size)&#13;
        ]&#13;
    )</pre>&#13;
<p class="caption"><a id="ch18lis5"/><em>Listing 18-5: From captions to SVG</em></p>&#13;
<p class="indent">We implement a function named <span class="literal">caption_to_svg</span>. This function has five parameters: the caption’s text, a point at which the caption is located, the angle it’s rotated, the color, and the configuration dictionary.</p>&#13;
<p class="indent">We’ll extract the font family and size from the configuration dictionary. The first two lines save these values into the <span class="literal">font</span> and <span class="literal">size</span> variables, respectively <span class="ent">➊</span>.</p>&#13;
<p class="indent">The next thing we do is compute an affine transformation that scales and rotates the caption. We first generate the rotation with the <span class="literal">make_rotation</span> function and then the scaling with the <span class="literal">make_scale</span> function; lastly, these are combined into a single transformation <span class="ent">➋</span>. Note how both transformations are done with respect to the caption’s position point (see <a href="ch18.xhtml#ch18fig4">Figure 18-4</a>). This is key. If we scaled and rotated the caption around the global origin (the ⟨0, 0⟩ point), it would appear somewhere unexpected in the drawing.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_501"/><img src="../images/18fig04.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch18fig4"><em>Figure 18-4: Caption rotation</em></p>&#13;
<p class="indent">Lastly, we create the SVG text element using the <span class="literal">svg.text</span> function, passing it the caption, the center point, a zero displacement vector, and a list of attributes <span class="ent">➌</span>. In the attributes we include the fill color, the transformation, the font family, and the font size.</p>&#13;
<h4 class="h4" id="ch00lev2sec198"><strong><em>The Bars</em></strong></h4>&#13;
<p class="noindent">Let’s now work on producing the SVG code to draw the original and deformed bar geometries. Bars are straight lines, so representing them won’t be too complicated. In the <em>out</em> directory, create a new file named <em>bar_svg.py</em>. Your <em>out</em> directory should look like the following:</p>&#13;
<p class="pre2">    out<br/>      |- __init__.py<br/>      |- bar_svg.py<br/>      |- captions_svg.py<br/>      |- svg.py</p>&#13;
<p class="indent">As we know, both the original and deformed bar geometries are straight lines. We’ll start by writing a helper function to generate the SVG segments that represent bars, both in their original and deformed states. In the file, enter the code in <a href="ch18.xhtml#ch18lis6">Listing 18-6</a>.</p>&#13;
<pre>from math import sqrt&#13;
&#13;
from graphic import svg&#13;
from graphic.svg import attributes&#13;
&#13;
&#13;
def __bar_svg(geometry, color, cross_section):&#13;
 <span class="ent">➊</span> section_height = sqrt(cross_section)&#13;
 <span class="ent">➋</span> return svg.segment(&#13;
        geometry,&#13;
        [&#13;
            attributes.stroke_color(color),&#13;
            attributes.stroke_width(section_height)&#13;
        ]&#13;
    )</pre>&#13;
<p class="caption"><a id="ch18lis6"/><em>Listing 18-6: Single bar to SVG</em></p>&#13;
<p class="indent">We’ve written the <span class="literal">__bar_svg</span> function to generate an SVG segment using the passed-in <span class="literal">geometry</span>, which should be an instance of our <span class="literal">Segment</span> class; we’ve also passed in the color to use and the cross section of the bar.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_502"/>Why do we need the cross-section value? We’ll use a line thickness that roughly represents the cross section of the bar so that bars with a larger cross section are drawn with a thicker line. <a href="ch18.xhtml#ch18fig5">Figure 18-5</a> shows our approximation: we’re computing the line thickness as if it was the side of a square cross section.</p>&#13;
<div class="image"><img src="../images/18fig05.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch18fig5"><em>Figure 18-5: Calculating line thickness from the cross section</em></p>&#13;
<p class="indent">In the <span class="literal">section_height</span> variable, we store the height of the bar as if its section was square <span class="ent">➊</span>. This value is computed from the square root of the bar’s cross section.</p>&#13;
<p class="indent">Lastly, we return an SVG segment using the passed-in geometry and adding two attributes: the stroke color and the line thickness we’ve computed <span class="ent">➋</span>.</p>&#13;
<p class="indent">Let’s continue and write the first version of the <span class="literal">bars_to_svg</span> function. In your file and before the <span class="literal">__bar_svg</span> function we just wrote, enter the code in <a href="ch18.xhtml#ch18lis7">Listing 18-7</a>.</p>&#13;
<pre>from math import sqrt&#13;
&#13;
from graphic import svg&#13;
from graphic.svg import attributes&#13;
<span class="codestrong1">from structures.solution.bar import StrBarSolution</span>&#13;
&#13;
&#13;
def bars_to_svg(bars: [StrBarSolution], settings, config):&#13;
    should_draw_original = not settings.no_draw_original&#13;
 <span class="ent">➊</span> original, final, stresses = [], [], []&#13;
&#13;
    for bar in bars:&#13;
     <span class="ent">➋</span> if should_draw_original:&#13;
            original.append(original_bar_to_svg(bar))&#13;
     <span class="ent">➌</span> final.append(bar_to_svg(bar))&#13;
     <span class="ent">➍</span> stresses.append(bar_stress_to_svg(bar))&#13;
&#13;
    # Ordering is important to preserve z-depth&#13;
 <span class="ent">➎</span> return original + final + stresses&#13;
&#13;
&#13;
def __bar_svg(geometry, color, cross_section):&#13;
    <span class="codeitalic1">--snip--</span></pre>&#13;
<p class="caption"><a id="ch18lis7"/><em>Listing 18-7: Bar to SVG</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_503"/>In this listing, we merely outline the main algorithm to generate SVG primitives representing the bars. There are three functions that do most of the work, but we haven’t written them yet: <span class="literal">original_bar_to_svg</span>, <span class="literal">bar_to_svg</span>, and <span class="literal">bar_stress_to_svg</span>. We’ll write these shortly.</p>&#13;
<p class="indent">Our <span class="literal">bars_to_svg</span> function first saves the negated value of the <span class="literal">no_draw</span> <span class="literal">_original</span> setting in the <span class="literal">should_draw_original</span> variable. If <span class="literal">should_draw_original</span> is <span class="literal">true</span>, our function will also include the segments representing the original bars.</p>&#13;
<p class="indent">Next, we declare three empty lists: <span class="literal">original</span>, <span class="literal">final</span>, and <span class="literal">stresses</span> <span class="ent">➊</span>. The first one, <span class="literal">original</span>, stores the segments that represent the original bars; the second one, <span class="literal">final</span>, contains the final or solution bars; and the last list, <span class="literal">stresses</span>, stores the stress captions. We’ll put all the SVG primitives we generate in these lists.</p>&#13;
<p class="indent">We then iterate through the bars. For each one, if <span class="literal">should_draw_original</span> is <span class="literal">true</span>, we append the result of <span class="literal">original_bar_to_svg</span> to the <span class="literal">original</span> list <span class="ent">➋</span>; <span class="literal">original_bar_to_svg</span> is a function we haven’t written yet that generates the SVG segment for the original bar. We append the SVG representing the solution bar to the <span class="literal">final</span> list <span class="ent">➌</span> and the stress caption to <span class="literal">stresses</span> <span class="ent">➍</span>.</p>&#13;
<p class="indent">After the loop, the three lists are filled with the SVG primitives that represent the bars of the original and solution structures. We concatenate and return those lists <span class="ent">➎</span>. As noted by the comment in the code, the order here is important: the elements that appear last in the list will be drawn on top of the rest. We want the original bars to be behind the solution bars; thus, they need to appear first in the list. You can imagine these bars as being distributed by layers, as depicted in <a href="ch18.xhtml#ch18fig6">Figure 18-6</a>.</p>&#13;
<div class="image"><img src="../images/18fig06.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch18fig6"><em>Figure 18-6: Drawing the bar SVGs in layers</em></p>&#13;
<p class="indent">Let’s write the three functions we used to generate the SVG primitives.</p>&#13;
<h5 class="h5" id="ch00lev3sec97"><strong>Drawing the Original Bars</strong></h5>&#13;
<p class="noindent">For these functions, we’re going to use a technique we explored in the “Functions Inside Other Functions” section on <a href="ch02.xhtml#ch00lev2sec21">page 28</a>. We’ll define them as internal functions inside the <span class="literal">bars_to_svg</span> function so they gain access to the parameters passed to <span class="literal">bars_to_svg</span>. This spares us from having to pass around the <span class="literal">settings</span> and <span class="literal">config</span> dictionaries. The resulting internal functions will have a shorter parameter list, which makes them simpler. As the functions <span epub:type="pagebreak" id="page_504"/>are effectively kept private in <span class="literal">bars_to_svg</span>, only the host function has access to them.</p>&#13;
<p class="indent">Let’s write the <span class="literal">original_bar_to_svg</span> function first. In your file, enter the missing code in <a href="ch18.xhtml#ch18lis8">Listing 18-8</a>.</p>&#13;
<pre>from math import sqrt&#13;
&#13;
from graphic import svg&#13;
<span epub:type="pagebreak" id="page_505"/>from graphic.svg import attributes&#13;
from structures.solution.bar import StrBarSolution&#13;
&#13;
&#13;
def bars_to_svg(bars: [StrBarSolution], settings, config):&#13;
    <span class="codestrong1">def original_bar_to_svg(_bar: StrBarSolution):</span>&#13;
     <span class="ent">➊</span> <span class="codestrong1">color = config['colors']['original']</span>&#13;
     <span class="ent">➋</span> <span class="codestrong1">return __bar_svg(</span>&#13;
            <span class="codestrong1">_bar.original_geometry,</span>&#13;
            <span class="codestrong1">color,</span>&#13;
            <span class="codestrong1">_bar.cross_section</span>&#13;
        <span class="codestrong1">)</span>&#13;
&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
    # Ordering is important to preserve z-depth&#13;
    return original + final + stresses&#13;
&#13;
&#13;
def __bar_svg(geometry, color, cross_section):&#13;
    <span class="codeitalic1">--snip--</span></pre>&#13;
<p class="caption"><a id="ch18lis8"/><em>Listing 18-8: Original (nonsolution) bar to SVG</em></p>&#13;
<p class="indent">We’ve written the <span class="literal">original_bar_to_svg</span> function inside the <span class="literal">bars_to_svg</span> function, at the beginning of it. This function requires only one argument: a bar from the solution structure (of type <span class="literal">StrBarSolution</span>), which contains the original bar inside its <span class="literal">original_geometry</span> attribute.</p>&#13;
<p class="indent">First, we extract the color for the original bar from the configuration dictionary <span class="ent">➊</span>. Then, we return the result of calling the <span class="literal">__bar_svg</span> function with the original bar’s geometry, the color, and the bar’s cross section <span class="ent">➋</span>.</p>&#13;
<h5 class="h5" id="ch00lev3sec98"><span epub:type="pagebreak" id="page_506"/><strong>Drawing the Solution Bars</strong></h5>&#13;
<p class="noindent">Now let’s write the code to draw the solution bars. These will have a different color depending on if their stress is compressive or tensile. In the <span class="literal">bars_to_svg</span> function, after the <span class="literal">original_bar_to_svg</span> function we just wrote, enter the missing code in <a href="ch18.xhtml#ch18lis9">Listing 18-9</a>.</p>&#13;
<pre>from math import sqrt&#13;
&#13;
from graphic import svg&#13;
from graphic.svg import attributes&#13;
from structures.solution.bar import StrBarSolution&#13;
&#13;
&#13;
def bars_to_svg(bars: [StrBarSolution], settings, config):&#13;
    def original_bar_to_svg(_bar: StrBarSolution):&#13;
        <span class="codeitalic1">--snip--</span>&#13;
&#13;
    <span class="codestrong1">def bar_to_svg(_bar: StrBarSolution):</span>&#13;
        <span class="codestrong1">return __bar_svg(</span>&#13;
         <span class="ent">➊</span> <span class="codestrong1">_bar.final_geometry_scaling_displacement(</span>&#13;
                <span class="codestrong1">settings.disp_scale</span>&#13;
            <span class="codestrong1">),</span>&#13;
         <span class="ent">➋</span> <span class="codestrong1">bar_color(_bar),</span>&#13;
         <span class="ent">➌</span> <span class="codestrong1">_bar.cross_section</span>&#13;
        <span class="codestrong1">)</span>&#13;
&#13;
    <span class="codestrong1">def bar_color(_bar: StrBarSolution):</span>&#13;
        <span class="codestrong1">if _bar.stress &gt;= 0:</span>&#13;
            <span class="codestrong1">return config['colors']['traction']</span>&#13;
        <span class="codestrong1">else:</span>&#13;
            <span class="codestrong1">return config['colors']['compression']</span>&#13;
&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
    # Ordering is important to preserve z-depth&#13;
    return original + final + stresses&#13;
&#13;
&#13;
def __bar_svg(geometry, color, cross_section):&#13;
    <span class="codeitalic1">--snip--</span></pre>&#13;
<p class="caption"><a id="ch18lis9"/><em>Listing 18-9: Solution bar to SVG</em></p>&#13;
<p class="indent">The <span class="literal">bar_to_svg</span> function returns the result of calling <span class="literal">__bar_svg</span> with the displaced bar as first argument, computed using the <span class="literal">final_geometry_scaling</span> <span class="literal">_displacement</span> method we implemented in the <span class="literal">StrBarSolution</span> class <span class="ent">➊</span>. The second argument is the color, which we compute using another function that we implemented later in the code: <span class="literal">bar_color</span> <span class="ent">➋</span>. The third and last argument is the bar’s cross section <span class="ent">➌</span>.</p>&#13;
<p class="indent">The <span class="literal">bar_color</span> function returns the correct color from the configuration dictionary depending on the sign of the bar’s stress. Note, once again, how we don’t need the <span class="literal">config</span> dictionary to be passed to this function. We already have access to it because we are inside the <span class="literal">bars_to_svg</span> function.</p>&#13;
<h5 class="h5" id="ch00lev3sec99"><strong>Drawing the Stress Captions</strong></h5>&#13;
<p class="noindent">Lastly, we need to draw the stress captions. These are a bit tricky to position inside the drawing, but we solved the hardest part earlier in the <span class="literal">caption_to_svg</span> function.</p>&#13;
<p class="indent">Enter the missing code in <a href="ch18.xhtml#ch18lis10">Listing 18-10</a>.</p>&#13;
<pre>from math import sqrt&#13;
&#13;
<span class="codestrong1">from geom2d import Vector</span>&#13;
from graphic import svg&#13;
from graphic.svg import attributes&#13;
from structures.solution.bar import StrBarSolution&#13;
<span class="codestrong1">from .captions_svg import caption_to_svg</span>&#13;
&#13;
<span class="codestrong1">__I_VERSOR = Vector(1, 0)</span>&#13;
<span class="codestrong1">__STRESS_DISP = 10</span>&#13;
<span class="codestrong1">__DECIMAL_POS = 4</span>&#13;
&#13;
&#13;
def bars_to_svg(bars: [StrBarSolution], settings, config):&#13;
    def original_bar_to_svg(_bar: StrBarSolution):&#13;
        <span class="codeitalic1">--snip--</span>&#13;
&#13;
    def bar_to_svg(_bar: StrBarSolution):&#13;
        <span class="codeitalic1">--snip--</span>&#13;
&#13;
    <span class="codestrong1">def bar_stress_to_svg(_bar: StrBarSolution):</span>&#13;
     <span class="ent">➊</span> <span class="codestrong1">geometry = _bar.final_geometry_scaling_displacement(</span>&#13;
           <span class="codestrong1">settings.disp_scale</span>&#13;
        <span class="codestrong1">)</span>&#13;
     <span class="codestrong1">normal = geometry.normal_versor</span>&#13;
     <span class="ent">➋</span> <span class="codestrong1">position = geometry.middle.displaced(normal, __STRESS_DISP)</span>&#13;
     <span class="ent">➌</span> <span class="codestrong1">angle = geometry.direction_versor.angle_to(__I_VERSOR)</span>&#13;
&#13;
     <span class="ent">➍</span> <span class="codestrong1">return caption_to_svg(</span>&#13;
           <span class="codestrong1">f'</span>σ <span class="codestrong1">= {round(_bar.stress, __DECIMAL_POS)}',</span>&#13;
           <span class="codestrong1">position,</span>&#13;
           <span class="codestrong1">angle,</span>&#13;
           <span class="codestrong1">bar_color(_bar),</span>&#13;
           <span class="codestrong1">config</span>&#13;
        <span class="codestrong1">)</span>&#13;
&#13;
   def bar_color(_bar: StrBarSolution):&#13;
       <span class="codeitalic1">--snip--</span>&#13;
&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
    # Ordering is important to preserve z-depth&#13;
    <span epub:type="pagebreak" id="page_507"/>return original + final + stresses&#13;
&#13;
&#13;
def __bar_svg(geometry, color, cross_section):&#13;
    <span class="codeitalic1">--snip--</span></pre>&#13;
<p class="caption"><a id="ch18lis10"/><em>Listing 18-10: Bar stress to SVG</em></p>&#13;
<p class="indent">We import <span class="literal">Vector</span> from <em>geom2d</em> and the <span class="literal">caption_to_svg</span> function we implemented earlier in this chapter. Then, we declare three constants:</p>&#13;
<ul>&#13;
<li class="noindent"><span class="literal">__I_VERSOR</span> is the <em>î</em>&#13;
 versor to represent the horizontal direction.</li>&#13;
<li class="noindent"><span class="literal">__STRESS_DISP</span> is the distance we use to separate the caption from&#13;
 the bar’s geometry.</li>&#13;
<li class="noindent"><span class="literal">__DECIMAL_POS</span> is the number of decimals we use to format the&#13;
 stress values.</li>&#13;
</ul>&#13;
<p class="indent">Then comes the implementation of the <span class="literal">bar_stress_to_svg</span> function. The first thing we want to do in this function is compute the geometry of the bar we’re adding a caption to, with exactly the same scale as the drawing itself <span class="ent">➊</span>. We want our caption to be aligned with the drawing of the bar; thus, we need its geometry as a reference.</p>&#13;
<p class="indent">Next, we compute the bar’s geometry normal versor; we need this direction to compute the caption’s position. Then, we compute the caption’s origin point, called <span class="literal">position</span>, by displacing the bar’s middle point in the direction of the normal versor an amount equal to <span class="literal">__STRESS_DISP</span> <span class="ent">➋</span>. <a href="ch18.xhtml#ch18fig7">Figure 18-7</a> illustrates this.</p>&#13;
<div class="image"><img src="../images/18fig07.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch18fig7"><em>Figure 18-7: Positioning the bar caption</em></p>&#13;
<p class="indent">We also need the bar’s angle with the <em>î</em> versor <span class="ent">➌</span>; this is the angle we’ll rotate the caption to align it with the bar.</p>&#13;
<p class="indent">Now that we have the center point and the rotation angle, we simply need to return the result of calling the <span class="literal">caption_to_svg</span> function with these values as arguments <span class="ent">➍</span>. For the caption’s text, we use the Greek letter <em>σ</em> (sigma), which is typically used to refer to mechanical stresses, followed by the bar’s stress value rounded to four decimals.</p>&#13;
<p class="indent">Lastly, note that the label color is the same as the bar, and thus we get it from the <span class="literal">bar_color</span> function.</p>&#13;
<h5 class="h5" id="ch00lev3sec100"><span epub:type="pagebreak" id="page_508"/><strong>The Result</strong></h5>&#13;
<p class="noindent">After all the code we’ve written, your <em>bar_svg.py</em> file should look like <a href="ch18.xhtml#ch18lis11">Listing 18-11</a>.</p>&#13;
<pre>from math import sqrt&#13;
&#13;
from geom2d import Vector&#13;
from graphic import svg&#13;
from graphic.svg import attributes&#13;
from structures.solution.bar import StrBarSolution&#13;
from .captions_svg import caption_to_svg&#13;
&#13;
__I_VERSOR = Vector(1, 0)&#13;
__STRESS_DISP = 10&#13;
__DECIMAL_POS = 4&#13;
&#13;
&#13;
def bars_to_svg(bars: [StrBarSolution], settings, config):&#13;
    def original_bar_to_svg(_bar: StrBarSolution):&#13;
        color = config['colors']['original']&#13;
        return __bar_svg(&#13;
            _bar.original_geometry,&#13;
            color,&#13;
            _bar.cross_section&#13;
        )&#13;
&#13;
    def bar_to_svg(_bar: StrBarSolution):&#13;
        return __bar_svg(&#13;
            _bar.final_geometry_scaling_displacement(&#13;
                settings.disp_scale&#13;
            ),&#13;
            bar_color(_bar),&#13;
            _bar.cross_section&#13;
        )&#13;
&#13;
    def bar_stress_to_svg(_bar: StrBarSolution):&#13;
        geometry = _bar.final_geometry_scaling_displacement(&#13;
            settings.disp_scale&#13;
        )&#13;
        normal = geometry.normal_versor&#13;
        position = geometry.middle.displaced(normal, __STRESS_DISP)&#13;
        angle = geometry.direction_versor.angle_to(__I_VERSOR)&#13;
&#13;
        return caption_to_svg(&#13;
            f  ' = {round(_bar.stress, __DECIMAL_POS)}',&#13;
            position,&#13;
            angle,&#13;
            bar_color(_bar),&#13;
            <span epub:type="pagebreak" id="page_509"/>config&#13;
        )&#13;
&#13;
    def bar_color(_bar: StrBarSolution):&#13;
        if _bar.stress &gt;= 0:&#13;
            return config['colors']['traction']&#13;
        else:&#13;
            return config['colors']['compression']&#13;
&#13;
    should_draw_original = not settings.no_draw_original&#13;
    original, final, stresses = [], [], []&#13;
&#13;
    for bar in bars:&#13;
        if should_draw_original:&#13;
            original.append(original_bar_to_svg(bar))&#13;
        final.append(bar_to_svg(bar))&#13;
        stresses.append(bar_stress_to_svg(bar))&#13;
&#13;
    # Ordering is important to preserve z-depth&#13;
    return original + final + stresses&#13;
&#13;
&#13;
def __bar_svg(geometry, color, cross_section):&#13;
    section_height = sqrt(cross_section)&#13;
    return svg.segment(&#13;
        geometry,&#13;
        [&#13;
            attributes.stroke_color(color),&#13;
            attributes.stroke_width(section_height)&#13;
        ]&#13;
    )</pre>&#13;
<p class="caption"><a id="ch18lis11"/><em>Listing 18-11: Bar to SVG result</em></p>&#13;
<p class="indent">Make sure your code looks the same as <a href="ch18.xhtml#ch18lis11">Listing 18-11</a>, because we won’t be writing unit tests in this chapter. Covering our SVG generation functions with tests would be a great idea; there is quite a bit of logic here. But to keep the chapter a reasonable length, we won’t be doing it.</p>&#13;
<p class="indent">Now it’s time for the nodes.</p>&#13;
<h4 class="h4" id="ch00lev2sec199"><strong><em>The Nodes</em></strong></h4>&#13;
<p class="noindent">In the <em>out</em> directory, create a new file named <em>node_svg.py</em>:</p>&#13;
<p class="pre2">    out<br/>      |- __init__.py<br/>      |- bar_svg.py<br/>      |- captions_svg.py<br/>      |- node_svg.py<br/>      <span epub:type="pagebreak" id="page_510"/>|- svg.py</p>&#13;
<p class="indent">In this file, enter the code in <a href="ch18.xhtml#ch18lis12">Listing 18-12</a>.</p>&#13;
<pre>from geom2d import Circle, Vector&#13;
from graphic import svg&#13;
from graphic.svg import attributes&#13;
from structures.solution.node import StrNodeSolution&#13;
from .captions_svg import caption_to_svg&#13;
&#13;
&#13;
def nodes_to_svg(nodes: [StrNodeSolution], settings, config):&#13;
 <span class="ent">➊</span> def node_to_svg(node: StrNodeSolution):&#13;
        radius = config['sizes']['node_radius']&#13;
        stroke_size = config['sizes']['stroke']&#13;
        stroke_color = config['colors']['node_stroke']&#13;
        fill_color = config['colors']['back']&#13;
&#13;
     <span class="ent">➋</span> position = node.displaced_pos_scaled(settings.disp_scale)&#13;
     <span class="ent">➌</span> caption_pos = position.displaced(Vector(radius, radius))&#13;
&#13;
        return svg.group([&#13;
         <span class="ent">➍</span> svg.circle(&#13;
                Circle(position, radius),&#13;
                [&#13;
                    attributes.stroke_width(stroke_size),&#13;
                    attributes.stroke_color(stroke_color),&#13;
                    attributes.fill_color(fill_color)&#13;
                ]&#13;
            ),&#13;
         <span class="ent">➎</span> caption_to_svg(&#13;
                f'{node.id}', caption_pos, 0, stroke_color, config&#13;
&#13;
            )&#13;
        ])&#13;
&#13;
 <span class="ent">➏</span> return [&#13;
        node_to_svg(node)&#13;
        for node in nodes&#13;
    ]</pre>&#13;
<p class="caption"><a id="ch18lis12"/><em>Listing 18-12: Node to SVG</em></p>&#13;
<p class="indent">We first import a few things—make sure you get them all. Then, we define the <span class="literal">nodes_to_svg</span> function with the list of <span class="literal">StrNodeSolution</span> instances and the <span class="literal">settings</span> and <span class="literal">config</span> dictionaries as input parameters. This function maps each node in the <span class="literal">nodes</span> list to its SVG representation, which is obtained by calling an internal function: <span class="literal">node_to_svg</span> <span class="ent">➏</span>. The mapping is done using a list comprehension.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_511"/>The <span class="literal">node_to_svg</span> internal function operates on a single node, and it has access to the host function parameters <span class="ent">➊</span>. The first thing it does is save some configuration parameters in variables.</p>&#13;
<p class="indent">Next, we compute the displaced position of the node <span class="ent">➋</span> and the position for the caption, which will be the node’s ID <span class="ent">➌</span>. The caption’s position is obtained by displacing the node’s position an amount equal to its radius both horizontally and vertically. <a href="ch18.xhtml#ch18fig8">Figure 18-8</a> illustrates this.</p>&#13;
<div class="image"><img src="../images/18fig08.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch18fig8"><em>Figure 18-8: Node caption positioning</em></p>&#13;
<p class="indent">The <span class="literal">node_to_svg</span> function returns an SVG group consisting of a circle representing the node itself <span class="ent">➍</span> and the caption <span class="ent">➎</span>.</p>&#13;
<p class="indent">Our nodes are ready! Let’s add their external reaction forces.</p>&#13;
<h4 class="h4" id="ch00lev2sec200"><strong><em>The Node Reactions</em></strong></h4>&#13;
<p class="noindent">We’ll also include the reaction forces of the externally constrained nodes in our SVG diagram. We’ll represent these as arrows with a caption, similar to <a href="ch18.xhtml#ch18fig9">Figure 18-9</a>.</p>&#13;
<div class="image"><img src="../images/18fig09.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch18fig9"><em>Figure 18-9: Node reaction</em></p>&#13;
<p class="indent">Since we’ll draw external loads and reactions the same way, let’s write a function that draws a <span class="literal">Vector</span> geometric primitive as an arrow with a caption; that way we can use it for both cases.</p>&#13;
<h5 class="h5" id="ch00lev3sec101"><strong>Drawing Vectors</strong></h5>&#13;
<p class="noindent">In the <em>out</em> directory, create a new file named <em>vector_svg.py</em>. Your <em>out</em> directory should look like the following:</p>&#13;
<p class="pre2">    out<br/>      |- __init__.py<br/>      |- bar_svg.py<br/>      |- captions_svg.py<br/>      |- node_svg.py<br/>      |- svg.py<br/>      |- vector_svg.py</p>&#13;
<p class="noindent">In this file, enter the code in <a href="ch18.xhtml#ch18lis13">Listing 18-13</a>.<span epub:type="pagebreak" id="page_512"/></p>&#13;
<pre>from geom2d import Point, Vector, Segment&#13;
from graphic import svg&#13;
from graphic.svg import attributes&#13;
from .captions_svg import caption_to_svg&#13;
&#13;
__I_VERSOR = Vector(1, 0)&#13;
__CAPTION_DISP = 10&#13;
__DECIMAL_POS = 2&#13;
&#13;
&#13;
def vector_to_svg(&#13;
        position: Point,&#13;
        vector: Vector,&#13;
        scale: float,&#13;
        color: str,&#13;
        config&#13;
):&#13;
 <span class="ent">➊</span> segment = Segment(&#13;
        position.displaced(vector, -scale),&#13;
        position&#13;
    )&#13;
 <span class="ent">➋</span> caption_origin = segment.start.displaced(&#13;
        segment.normal_versor,&#13;
        __CAPTION_DISP&#13;
    )&#13;
&#13;
    def svg_arrow():&#13;
        pass&#13;
&#13;
    def svg_caption():&#13;
        pass&#13;
&#13;
 <span class="ent">➌</span> return svg.group([&#13;
        svg_arrow(),&#13;
        svg_caption()&#13;
    ])</pre>&#13;
<p class="caption"><a id="ch18lis13"/><em>Listing 18-13: Vector to SVG</em></p>&#13;
<p class="indent">We define three constants:</p>&#13;
<ul>&#13;
<li class="noindent"><span class="literal">__I_VERSOR</span> is used to compute an angle with the horizontal&#13;
 direction.</li>&#13;
<li class="noindent"><span class="literal">__CAPTION_DISP</span> is the separation between the vector’s baseline and&#13;
 the caption.</li>&#13;
<li class="noindent"><span class="literal">__DECIMAL_POS</span> formats the vector coordinates using a fixed number&#13;
 of decimals.</li>&#13;
</ul>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_513"/>Then comes the <span class="literal">vector_to_svg</span> function, which has the following arguments:</p>&#13;
<ul>&#13;
<li class="noindent"><span class="literal">position</span> is the vector’s base point.</li>&#13;
<li class="noindent"><span class="literal">vector</span> is the vector itself.</li>&#13;
<li class="noindent"><span class="literal">scale</span> is applied to the vector to shorten or lengthen it.</li>&#13;
<li class="noindent"><span class="literal">color</span> is the stroke and font colors.</li>&#13;
<li class="noindent"><span class="literal">config</span> is the configuration dictionary.</li>&#13;
</ul>&#13;
<p class="indent">In the function, we create a segment to represent the vector’s baseline <span class="ent">➊</span>. The start point for the segment is the passed-in position displaced by the vector (also passed as an argument to the function) and using a scale of <span class="literal">-scale</span>. We want the vector’s arrow located at the <span class="literal">origin</span> point; thus, the end point for the segment is in the opposite direction of the vector. You can see this configuration of the vector segment points illustrated in <a href="ch18.xhtml#ch18fig10">Figure 18-10</a>.</p>&#13;
<div class="image"><img src="../images/18fig10.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch18fig10"><em>Figure 18-10: Vector segment end points</em></p>&#13;
<p class="indent">We also compute the caption’s origin point using the segment’s start point displaced in the normal direction of the segment’s direction <span class="ent">➋</span> (see <a href="ch18.xhtml#ch18fig11">Figure 18-11</a>).</p>&#13;
<div class="image"><img src="../images/18fig11.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch18fig11"><em>Figure 18-11: Node reaction caption’s position</em></p>&#13;
<p class="indent">Then there are two functions we haven’t implemented yet: <span class="literal">svg_arrow</span> and <span class="literal">svg_caption</span>. These are the functions that will draw the arrow and the caption. We’ll get to them shortly.</p>&#13;
<p class="indent">Lastly, we return an SVG group consisting of the results of the <span class="literal">svg_arrow</span> and <span class="literal">svg_caption</span> functions <span class="ent">➌</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_514"/>Let’s implement the two missing functions. Enter the missing code in <a href="ch18.xhtml#ch18lis14">Listing 18-14</a>.</p>&#13;
<pre><span class="codeitalic1">--snip--</span>&#13;
&#13;
&#13;
def vector_to_svg(&#13;
        position: Point,&#13;
        vector: Vector,&#13;
        scale: float,&#13;
        color: str,&#13;
        config&#13;
):&#13;
    segment = Segment(&#13;
        position.displaced(vector, -scale),&#13;
        position&#13;
    )&#13;
    caption_origin = segment.start.displaced(&#13;
        segment.normal_versor,&#13;
        __CAPTION_DISP&#13;
    )&#13;
&#13;
    def svg_arrow():&#13;
        <span class="codestrong1">width = config['sizes']['stroke']</span>&#13;
        <span class="codestrong1">arrow_size = config['sizes']['arrow']</span>&#13;
&#13;
     <span class="ent">➊</span> <span class="codestrong1">return svg.arrow(</span>&#13;
            <span class="codestrong1">segment,</span>&#13;
            <span class="codestrong1">arrow_size,</span>&#13;
            <span class="codestrong1">arrow_size,</span>&#13;
            <span class="codestrong1">[</span>&#13;
                <span class="codestrong1">attributes.stroke_color(color),</span>&#13;
                <span class="codestrong1">attributes.stroke_width(width),</span>&#13;
                <span class="codestrong1">attributes.fill_color('none')</span>&#13;
            <span class="codestrong1">]</span>&#13;
        <span class="codestrong1">)</span>&#13;
&#13;
    def svg_caption():&#13;
     <span class="ent">➋</span> <span class="codestrong1">return caption_to_svg(</span>&#13;
           <span class="codestrong1">vector.to_formatted_str(__DECIMAL_POS),</span>&#13;
           <span class="codestrong1">caption_origin,</span>&#13;
           <span class="codestrong1">vector.angle_to(__I_VERSOR),</span>&#13;
           <span class="codestrong1">color,</span>&#13;
           <span class="codestrong1">config</span>&#13;
        <span class="codestrong1">)</span>&#13;
&#13;
    return svg.group([&#13;
        svg_arrow(),&#13;
        <span epub:type="pagebreak" id="page_515"/>svg_caption()&#13;
    ])</pre>&#13;
<p class="caption"><a id="ch18lis14"/><em>Listing 18-14: Vector to SVG</em></p>&#13;
<p class="indent">The <span class="literal">svg_arrow</span> function first saves the <span class="literal">width</span> and <span class="literal">arrow_size</span> configuration values inside variables. Then it returns our SVG arrow primitive, passing it the segment, the <span class="literal">arrow_size</span> for both the arrow width and length, and the list of attributes including the stroke color and width <span class="ent">➊</span>. Recall that our <span class="literal">svg.arrow</span> function draws the arrow located at the segment’s end point.</p>&#13;
<p class="indent">The <span class="literal">svg_caption</span> function returns the result of calling the <span class="literal">svg_caption</span> function with the caption string, origin point, rotation angle, color, and configuration dictionary <span class="ent">➋</span>. The caption with the right format is computed using our <span class="literal">Vector</span> class’s <span class="literal">to_formatted_str</span> method. This method isn’t implemented yet, so let’s write it to create a string with the vector components and norm.</p>&#13;
<p class="indent">Open the <em>geom2d/vector.py</em> file and enter the code in <a href="ch18.xhtml#ch18lis15">Listing 18-15</a>.</p>&#13;
<pre>class Vector:&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
    def to_formatted_str(self, decimals: int):&#13;
        u = round(self.u, decimals)&#13;
        v = round(self.v, decimals)&#13;
        norm = round(self.norm, decimals)&#13;
&#13;
        return f'({u}, {v}) with norm {norm}'</pre>&#13;
<p class="caption"><a id="ch18lis15"/><em>Listing 18-15: Vector to formatted string</em></p>&#13;
<p class="indent">We’ll also need a similar method in the <span class="literal">Point</span> class to format the position of the nodes in the text representation of the solution. Open <em>geom2d/point.py</em> and enter the code in <a href="ch18.xhtml#ch18lis16">Listing 18-16</a>.</p>&#13;
<pre>class Point:&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
    def to_formatted_str(self, decimals: int):&#13;
        x = round(self.x, decimals)&#13;
        y = round(self.y, decimals)&#13;
&#13;
        return f'({x}, {y})'</pre>&#13;
<p class="caption"><a id="ch18lis16"/><em>Listing 18-16: Point to formatted string</em></p>&#13;
<p class="indent">Now that we’ve implemented a way of drawing vectors with a caption for their coordinates, let’s use our implementation to display the node reactions.</p>&#13;
<h5 class="h5" id="ch00lev3sec102"><span epub:type="pagebreak" id="page_516"/><strong>Drawing the Reaction Forces</strong></h5>&#13;
<p class="noindent">In the <em>out</em> directory, create a new file named <em>reaction_svg.py</em>. Your <em>out</em> directory should look like the following:</p>&#13;
<p class="pre2">    out<br/>      |- __init__.py<br/>      |- bar_svg.py<br/>      |- captions_svg.py<br/>      |- node_svg.py<br/>      |- reaction_svg.py<br/>      |- svg.py<br/>      |- vector_svg.py</p>&#13;
<p class="noindent">In this newly created file, enter the code in <a href="ch18.xhtml#ch18lis17">Listing 18-17</a>.</p>&#13;
<pre>from structures.solution.node import StrNodeSolution&#13;
from structures.solution.structure import StructureSolution&#13;
from .vector_svg import vector_to_svg&#13;
&#13;
&#13;
def node_reactions_to_svg(&#13;
        solution: StructureSolution,&#13;
        settings,&#13;
        config&#13;
):&#13;
    def reaction_svg(node: StrNodeSolution):&#13;
     <span class="ent">➊</span> position = node.displaced_pos_scaled(settings.disp_scale)&#13;
     <span class="ent">➋</span> reaction = solution.reaction_for_node(node)&#13;
     <span class="ent">➌</span> return vector_to_svg(&#13;
            position=position,&#13;
            vector=reaction,&#13;
            scale=settings.load_scale,&#13;
            color=config['colors']['reaction'],&#13;
            config=config&#13;
        )&#13;
&#13;
 <span class="ent">➍</span> return [&#13;
        reaction_svg(node)&#13;
        for node in solution.nodes&#13;
        if node.is_constrained&#13;
    ]</pre>&#13;
<p class="caption"><a id="ch18lis17"/><em>Listing 18-17: Node reactions to SVG</em></p>&#13;
<p class="indent">In this file, we define <span class="literal">node_reactions_to_svg</span>. Each externally constrained node in the structure solution is mapped to its SVG reaction using a list comprehension <span class="ent">➍</span>.</p>&#13;
<p class="indent">We’re using an inner function to produce the SVG representation of each solution node: <span class="literal">reaction_svg</span>. This function first obtains the displaced <span epub:type="pagebreak" id="page_517"/>position of the resulting node (with <span class="literal">disp_scale</span> applied) <span class="ent">➊</span>. Then it asks the solution structure for the reaction in the node <span class="ent">➋</span>. With these pieces of information, we can create the SVG representation of the reaction vector using the <span class="literal">vector_to_svg</span> function <span class="ent">➌</span>.</p>&#13;
<h4 class="h4" id="ch00lev2sec201"><strong><em>The Loads</em></strong></h4>&#13;
<p class="noindent">The last things we want to draw in the result image are the loads applied to the structure.</p>&#13;
<p class="indent">In the <em>out</em> directory, create a new file named <em>load_svg.py</em>. Your <em>out</em> directory should look like the following:</p>&#13;
<p class="pre2">    out<br/>      |- __init__.py<br/>      |- bar_svg.py<br/>      |- captions_svg.py<br/>      |- load_svg.py<br/>      |- node_svg.py<br/>      |- reaction_svg.py<br/>      |- svg.py<br/>      |- vector_svg.py</p>&#13;
<p class="noindent">In <em>load_svg.py</em>, enter the code in <a href="ch18.xhtml#ch18lis18">Listing 18-18</a>.</p>&#13;
<pre>from geom2d import Vector, Point&#13;
from graphic import svg&#13;
from structures.solution.node import StrNodeSolution&#13;
from .vector_svg import vector_to_svg&#13;
&#13;
&#13;
def loads_to_svg(nodes: [StrNodeSolution], settings, config):&#13;
    def svg_node_loads(node: StrNodeSolution):&#13;
     <span class="ent">➊</span> position = node.displaced_pos_scaled(settings.disp_scale)&#13;
     <span class="ent">➋</span> return svg.group(&#13;
            [&#13;
                svg_load(position, load)&#13;
                for load in node.loads&#13;
            ]&#13;
        )&#13;
&#13;
    def svg_load(position: Point, load: Vector):&#13;
     <span class="ent">➌</span> return vector_to_svg(&#13;
            position=position,&#13;
            vector=load,&#13;
            scale=settings.load_scale,&#13;
            color=config['colors']['load'],&#13;
            config=config&#13;
        )&#13;
&#13;
 <span epub:type="pagebreak" id="page_518"/><span class="ent">➍</span> return [&#13;
        svg_node_loads(node)&#13;
        for node in nodes&#13;
        if node.is_loaded&#13;
    ]</pre>&#13;
<p class="caption"><a id="ch18lis18"/><em>Listing 18-18: Loads to SVG</em></p>&#13;
<p class="indent">In this file, we define a function, <span class="literal">loads_to_svg</span>, receiving three arguments: the <span class="literal">StrNodeSolution</span> list and the <span class="literal">settings</span> and <span class="literal">config</span> dictionaries. The function relies on two inner functions: <span class="literal">svg_node_loads</span> and <span class="literal">svg_load</span>. We use a list comprehension to map each node that has external loads in the passed-in <span class="literal">nodes</span> list to its SVG representation <span class="ent">➍</span>. We use the <span class="literal">is_loaded</span> property of each node to filter the nodes that are externally loaded.</p>&#13;
<p class="indent">The <span class="literal">svg_node_loads</span> internal function first gets the displaced position of the solution node <span class="ent">➊</span> and then returns an SVG group of all the loads in the node <span class="ent">➋</span>. Each load is mapped to an SVG vector using the second internal function: <span class="literal">svg_load</span>.</p>&#13;
<p class="indent">The <span class="literal">svg_load</span> function is straightforward: it simply calls the <span class="literal">vector_to_svg</span> function passing the appropriate parameters <span class="ent">➌</span>.</p>&#13;
<p class="indent">With this, we have all of our SVG generation code ready! We just need to put it all together, and we can finally start drawing structure solutions.</p>&#13;
<h4 class="h4" id="ch00lev2sec202"><strong><em>Putting It All Together</em></strong></h4>&#13;
<p class="noindent">Let’s now open the <em>svg.py</em> file and add the functions we’ve written into the <span class="literal">structure_solution_to_svg</span> function. Enter the missing code, following <a href="ch18.xhtml#ch18lis19">Listing 18-19</a>.</p>&#13;
<pre>  import json&#13;
&#13;
  import pkg_resources as res&#13;
&#13;
  from geom2d import AffineTransform&#13;
  from graphic import svg&#13;
  from structures.solution.structure import StructureSolution&#13;
<span class="ent">➊</span> <span class="codestrong1">from .bar_svg import bars_to_svg</span>&#13;
  <span class="codestrong1">from .load_svg import loads_to_svg</span>&#13;
  <span class="codestrong1">from .node_svg import nodes_to_svg</span>&#13;
  <span class="codestrong1">from .reaction_svg import node_reactions_to_svg</span>&#13;
&#13;
&#13;
  def structure_solution_to_svg(&#13;
          result: StructureSolution,&#13;
          settings,&#13;
          _config=None,&#13;
  ):&#13;
      __validate_settings(settings)&#13;
      default_config = __read_config()&#13;
      <span epub:type="pagebreak" id="page_519"/>config = {**default_config, **(_config or {})}&#13;
&#13;
      viewbox = result.bounds_rect(&#13;
          config['sizes']['margin'],&#13;
          settings.scale&#13;
      )&#13;
      transform = AffineTransform(sx=1, sy=-1, tx=0, ty=0)&#13;
&#13;
    <span class="ent">➋</span> <span class="codestrong1">svg_bars = bars_to_svg(result.bars, settings, config)</span>&#13;
       <span class="codestrong1">svg_nodes = nodes_to_svg(result.nodes, settings, config)</span>&#13;
       <span class="codestrong1">svg_react = node_reactions_to_svg(result, settings, config)</span>&#13;
       <span class="codestrong1">svg_loads = loads_to_svg(result.nodes, settings, config)</span>&#13;
&#13;
       return svg.svg_content(&#13;
           size=viewbox.size,&#13;
        <span class="ent">➌</span> primitives=<span class="codestrong1">svg_bars + svg_nodes + svg_react + svg_loads,</span>&#13;
           viewbox_rect=viewbox,&#13;
           transform=transform&#13;
&#13;
      )&#13;
&#13;
&#13;
<span class="codeitalic1">--snip--</span></pre>&#13;
<p class="caption"><a id="ch18lis19"/><em>Listing 18-19: Structure solution to SVG</em></p>&#13;
<p class="indent">First, we import the <span class="literal">bars_to_svg</span>, <span class="literal">loads_to_svg</span>, <span class="literal">nodes_to_svg</span>, and <span class="literal">node</span> <span class="literal">_reactions_to_svg</span> functions <span class="ent">➊</span>.</p>&#13;
<p class="indent">Then, inside <span class="literal">structure_solution_to_svg</span>, we call each of the functions to generate the corresponding SVG code <span class="ent">➋</span>. The results are stored in <span class="literal">svg_bars</span>, <span class="literal">svg_nodes</span>, <span class="literal">svg_react</span>, and <span class="literal">svg_loads</span>. These are concatenated in one list that we pass to the <span class="literal">svg_content</span> function <span class="ent">➌</span>. The order is important: the SVG primitives toward the end of the list will appear in front of those at the beginning of it.</p>&#13;
<h4 class="h4" id="ch00lev2sec203"><strong><em>The Final Result</em></strong></h4>&#13;
<p class="noindent">If you’ve followed along, your <em>svg.py</em> file should be similar to <a href="ch18.xhtml#ch18lis20">Listing 18-20</a>.</p>&#13;
<pre>import json&#13;
&#13;
import pkg_resources as res&#13;
&#13;
from geom2d import AffineTransform&#13;
from graphic import svg&#13;
from structures.solution.structure import StructureSolution&#13;
from .bar_svg import bars_to_svg&#13;
from .load_svg import loads_to_svg&#13;
from .node_svg import nodes_to_svg&#13;
<span epub:type="pagebreak" id="page_520"/>from .reaction_svg import node_reactions_to_svg&#13;
&#13;
&#13;
def structure_solution_to_svg(&#13;
        result: StructureSolution,&#13;
        settings,&#13;
        _config=None,&#13;
):&#13;
    __validate_settings(settings)&#13;
    default_config = __read_config()&#13;
&#13;
    config = {**default_config, **(_config or {})}&#13;
&#13;
    viewbox = result.bounds_rect(&#13;
        config['sizes']['margin'],&#13;
        settings.scale&#13;
    )&#13;
    transform = AffineTransform(sx=1, sy=-1, tx=0, ty=0)&#13;
&#13;
    svg_bars = bars_to_svg(result.bars, settings, config)&#13;
    svg_nodes = nodes_to_svg(result.nodes, settings, config)&#13;
    svg_react = node_reactions_to_svg(result, settings, config)&#13;
    svg_loads = loads_to_svg(result.nodes, settings, config)&#13;
&#13;
    return svg.svg_content(&#13;
        size=viewbox.size,&#13;
        primitives=svg_bars + svg_nodes + svg_react + svg_loads,&#13;
        viewbox_rect=viewbox,&#13;
        transform=transform&#13;
    )&#13;
&#13;
&#13;
<span epub:type="pagebreak" id="page_521"/>def __read_config():&#13;
    config = res.resource_string(__name__, 'config.json')&#13;
    return json.loads(config)&#13;
&#13;
&#13;
__expected_settings = (&#13;
    # scale applied to the diagram&#13;
    'scale',&#13;
    # scale applied to the node displacements&#13;
    'disp_scale',&#13;
    # scale applied to the load vectors&#13;
    'load_scale',&#13;
    # boolean to decide whether to draw the original geometry&#13;
    'no_draw_original'&#13;
)&#13;
&#13;
&#13;
def __validate_settings(settings):&#13;
    for setting in __expected_settings:&#13;
        if setting not in settings:&#13;
            raise ValueError(f'"{setting}" missing in settings')</pre>&#13;
<p class="caption"><a id="ch18lis20"/><em>Listing 18-20: Structure solution to SVG</em></p>&#13;
<p class="indent">We have everything that we need, but before we put it to work in the next chapter, let’s also prepare a textual representation of the solution.</p>&#13;
<h3 class="h3" id="ch00lev1sec111"><strong>From Structure Solution to Text</strong></h3>&#13;
<p class="noindent">A visual diagram helps us understand the structural deformations; because we color the bars depending on the stress they’re subject to, it’s also a good way to see which bars are compressed and which are stretched. At the same time, it may be simpler to study the numeric results in a text format, and we may want to have them do some other calculations. The formats are complementary, and our structural analysis program will output both.</p>&#13;
<p class="indent">We will write the displacement of each node in a text file using the following format:</p>&#13;
<pre>NODE 25&#13;
    original position: (1400.0, 150.0)&#13;
    displacement: (0.1133, -0.933) with norm 0.9398&#13;
    displaced position: (1400.1133, 149.067)</pre>&#13;
<p class="noindent">If the node has external constraints, we want to check its reactions as well. In this case, we can include one last line:</p>&#13;
<pre>NODE 1&#13;
    original position: (0.0, 0.0)&#13;
    displacement: (0.0, 0.0) with norm 0.0&#13;
    displaced position: (0.0, 0.0)&#13;
    reaction: (-283.6981, 9906.9764) with norm 9911.0376</pre>&#13;
<p class="noindent">The bars will follow this format:</p>&#13;
<pre>[mathescape=true]&#13;
BAR 8 (25 → 9) : ⊕ TENSION&#13;
    Δ<span class="codeitalic1">l</span> (elongation) = 0.0026&#13;
    ϵ  (strain)     = 1.045e-05&#13;
    σ  (stress)     = 209.0219</pre>&#13;
<p class="indent">Let’s write a function that generates this plaintext representation of a structure solution.</p>&#13;
<h4 class="h4" id="ch00lev2sec204"><span epub:type="pagebreak" id="page_522"/><strong><em>Structure Solution’s String</em></strong></h4>&#13;
<p class="noindent">Before we write the function that generates the plaintext representation, let’s write a useful helper function that takes a list of strings and returns a single string with all those strings concatenated by a “newline” character.</p>&#13;
<p class="indent">We want to define each of the result values as a string of its own, but the function we’ll implement returns one and only one string, which is then written into a file.</p>&#13;
<p class="indent">Let’s create a new file for this helper function. In your <em>utils</em> package, create a new Python file named <em>strings.py</em>. This package should now have the following contents:</p>&#13;
<p class="pre2">    utils<br/>      |- __init__.py<br/>      |- lists.py<br/>      |- pairs.py<br/>      |- strings.py</p>&#13;
<p class="indent">In this <em>strings.py</em> file, enter the function in <a href="ch18.xhtml#ch18lis21">Listing 18-21</a>.</p>&#13;
<pre>def list_to_string(strings: [str]) -&gt; str:&#13;
    return '\n'.join(strings)</pre>&#13;
<p class="caption"><a id="ch18lis21"/><em>Listing 18-21: List to string</em></p>&#13;
<p class="indent">This <span class="literal">list_to_string</span> function maps a list of strings into a single string where each entry is separated from the next using the ’<span class="literal">\n</span>’ (newline) character.</p>&#13;
<p class="indent">Let’s now outline the text output function’s logic. First, create a new <em>text.py</em> file inside the <em>structures/out</em> package, which now should have the following files:</p>&#13;
<p class="pre2">    out<br/>      |- __init__.py<br/>      |- bar_svg.py<br/>      |- captions_svg.py<br/>      |- load_svg.py<br/>      |- node_svg.py<br/>      |- reaction_svg.py<br/>      |- svg.py<br/>      |- text.py<br/>      |- vector_svg.py</p>&#13;
<p class="noindent">In this <em>text.py</em> file, enter the code in <a href="ch18.xhtml#ch18lis22">Listing 18-22</a>.</p>&#13;
<pre>  from structures.solution.bar import StrBarSolution&#13;
  from structures.solution.node import StrNodeSolution&#13;
  from structures.solution.structure import StructureSolution&#13;
  from utils.strings import list_to_string&#13;
&#13;
<span class="ent">➊</span> __DECIMAL_POS = 4&#13;
  <span epub:type="pagebreak" id="page_523"/>__SEPARATION = ['------------------------------------------', '\n']&#13;
&#13;
&#13;
  def structure_solution_to_string(result: StructureSolution):&#13;
   <span class="ent">➋</span> nodes_text = __nodes_to_string(result)&#13;
   <span class="ent">➌</span> bars_text = __bars_to_string(result.bars)&#13;
   <span class="ent">➍</span> return list_to_string(nodes_text + __SEPARATION + bars_text)&#13;
&#13;
&#13;
  def __nodes_to_string(result: StructureSolution):&#13;
      pass&#13;
&#13;
&#13;
  def __node_to_string(&#13;
          result: StructureSolution,&#13;
          node: StrNodeSolution&#13;
  ):&#13;
      pass&#13;
&#13;
&#13;
  def __bars_to_string(bars: [StrBarSolution]):&#13;
      pass&#13;
&#13;
&#13;
  def __bar_to_string(bar: StrBarSolution):&#13;
      pass</pre>&#13;
<p class="caption"><a id="ch18lis22"/><em>Listing 18-22: Structure solution to text</em></p>&#13;
<p class="indent">In this listing, we import the <span class="literal">StrBarSolution</span>, <span class="literal">StrNodeSolution</span>, and <span class="literal">Structure</span> <span class="literal">Solution</span> classes, as well as the <span class="literal">list_to_string</span> function. We define two constants, one to specify the number of decimal positions we want to use to format the resulting values, <span class="literal">__DECIMAL_POS</span> <span class="ent">➊</span>, and a separation string list, <span class="literal">__SEPARATION</span>, which we use to separate the different sections in the result string.</p>&#13;
<p class="indent">Then comes the main function, <span class="literal">structure_solution_to_string</span>. This function receives only one parameter: the structure solution. It uses two private functions: one to convert the string representation of the nodes <span class="ent">➋</span> and another to convert the bars <span class="ent">➌</span>. The results are stored as list strings in the <span class="literal">nodes_text</span> and <span class="literal">bars_text</span> variables. These lists are concatenated with the <span class="literal">__SEPARATION</span> strings in the middle and passed to <span class="literal">list_to_string</span> <span class="ent">➍</span>.</p>&#13;
<p class="indent">After this main function, we define the rest of the private functions, but they’ve yet to be implemented. Let’s do that now.</p>&#13;
<h4 class="h4" id="ch00lev2sec205"><strong><em>The Nodes</em></strong></h4>&#13;
<p class="noindent">Let’s start with the nodes. Fill the <span class="literal">__nodes_to_string</span> and <span class="literal">__node_to_string</span> functions with the code in <a href="ch18.xhtml#ch18lis23">Listing 18-23</a>.<span epub:type="pagebreak" id="page_524"/></p>&#13;
<pre><span class="codeitalic1">--snip--</span>&#13;
&#13;
&#13;
def __nodes_to_string(result: StructureSolution):&#13;
    return [&#13;
     <span class="ent">➊</span> __node_to_string(result, node)&#13;
        for node in result.nodes&#13;
    ]&#13;
&#13;
&#13;
def __node_to_string(&#13;
        result: StructureSolution,&#13;
        node: StrNodeSolution&#13;
):&#13;
 <span class="ent">➋</span> orig_pos = node.original_pos.to_formatted_str(__DECIMAL_POS)&#13;
    displacement = node.global_disp.to_formatted_str(__DECIMAL_POS)&#13;
    disp_pos = node.displaced_pos.to_formatted_str(__DECIMAL_POS)&#13;
&#13;
 <span class="ent">➌</span> strings = [&#13;
        f'NODE {node.id}',&#13;
        f'\toriginal position: {orig_pos}',&#13;
        f'\tdisplacement: {displacement}',&#13;
        f'\tdisplaced position: {disp_pos}'&#13;
    ]&#13;
&#13;
 <span class="ent">➍</span> if node.is_constrained:&#13;
        react = result.reaction_for_node(node)&#13;
        react_str = react.to_formatted_str(__DECIMAL_POS)&#13;
        strings.append(f'\treaction: {react_str}')&#13;
&#13;
 <span class="ent">➎</span> return list_to_string(strings) + '\n'&#13;
&#13;
&#13;
<span class="codeitalic1">--snip--</span></pre>&#13;
<p class="caption"><a id="ch18lis23"/><em>Listing 18-23: Nodes to text</em></p>&#13;
<p class="indent">The first function, <span class="literal">__nodes_to_string</span>, uses a list comprehension to map each node in the result to its textual representation, for which it uses the <span class="literal">__node_to_string</span> function <span class="ent">➊</span>. This function requires not only the node but also the entire structure object as parameters. Recall that the reaction force of a node is computed by the structure solution instances, not by the nodes themselves.</p>&#13;
<p class="indent">The <span class="literal">__node_to_string</span> function first obtains the formatted strings for the node’s original position <span class="ent">➋</span>, the global displacement vector, and the displaced position. We use the <span class="literal">to_formatted_str</span> method from the <span class="literal">Point</span> and <span class="literal">Vector</span> classes to handle the point coordinates formatting.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_525"/>Next, we declare a list, <span class="literal">strings</span> <span class="ent">➌</span>, where we place the strings we just obtained. Note that, except for the first one, which serves as header, the strings all start with the tab (<span class="literal">\t</span>) character. With this, we achieve the nice formatting we defined earlier:</p>&#13;
<pre>NODE 2&#13;
    original position: (200.0, 0.0)&#13;
    displacement: (0.0063, -0.1828) with norm 0.1829&#13;
    displaced position: (200.0063, -0.1828)</pre>&#13;
<p class="indent">Next, we generate the reaction force string if the node is externally constrained <span class="ent">➍</span>. For this, we first use the structure solution class to compute the reaction for the given node, then format it using the <span class="literal">to_formatted_str</span> method, and lastly append it to the <span class="literal">strings</span> list.</p>&#13;
<p class="indent">The last step is to convert the obtained string list into a single string using the helper <span class="literal">list_to_string</span> function with a newline character appended to the end <span class="ent">➎</span>.</p>&#13;
<h4 class="h4" id="ch00lev2sec206"><strong><em>The Bars</em></strong></h4>&#13;
<p class="noindent">Let’s now fill in the functions for the bars. We’ll use some UTF-8 characters to make the text a bit more visual. These characters are optional; you can decide not to add them in your code and just go with the labels. If you decide to use them, we’ll explain how to do this in the section “The Unicode Characters” on <a href="ch01.xhtml#page_18">page 18</a>.</p>&#13;
<p class="indent">Enter the code in <a href="ch18.xhtml#ch18lis24">Listing 18-24</a>.</p>&#13;
<pre><span class="codeitalic1">--snip--</span>&#13;
&#13;
&#13;
def __bars_to_string(bars: [StrBarSolution]):&#13;
 <span class="ent">➊</span> return [__bar_to_string(bar) for bar in bars]&#13;
&#13;
&#13;
def __bar_to_string(bar: StrBarSolution):&#13;
 <span class="ent">➋</span> nodes_str = f'{bar.start_node.id} → {bar.end_node.id}'&#13;
    type_str = '⊕ TENSION' if bar.stress &gt;= 0 else '⊖ COMPRESSION'&#13;
    elongation = round(bar.elongation, __DECIMAL_POS)&#13;
    strain = '{:.3e}'.format(bar.strain)&#13;
    stress = round(bar.stress, __DECIMAL_POS)&#13;
&#13;
 <span class="ent">➌</span> return list_to_string([&#13;
        f'BAR {bar.id} ({nodes_str}) : {type_str}',&#13;
        f'\tΔ<span class="codeitalic1">l</span> (elongation) = {elongation}',&#13;
        f'\tϵ  (strain)     = {strain}',&#13;
        f'\tσ  (stress)     = {stress}\n'&#13;
    ])</pre>&#13;
<p class="caption"><a id="ch18lis24"/><em>Listing 18-24: Bars to text</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_526"/>The <span class="literal">__bars_to_string</span> function uses a list comprehension to map each bar in the list to its textual representation <span class="ent">➊</span>. This text is produced by the second function, <span class="literal">__bar_to_string</span>.</p>&#13;
<p class="indent">In <span class="literal">__bar_to_string</span>, we first prepare some strings <span class="ent">➋</span> that we later return concatenated using the <span class="literal">list_to_string</span> function <span class="ent">➌</span> and <span class="literal">nodes_str</span> indicates the bar’s node IDs, with a → character separating them.</p>&#13;
<p class="indent">The <span class="literal">type_str</span> indicates whether the bar is in traction or compression, depending on the sign of the bar’s stress. We’re using the ⊕ symbol to decorate the <span class="literal">TENSION</span> text and ⊖ for the <span class="literal">COMPRESSION</span> text. This detail makes the result stand out more to the eye.</p>&#13;
<p class="indent">Then comes the <span class="literal">elongation</span>, <span class="literal">strain</span>, and <span class="literal">stress</span> strings. These are the bar’s result values formatted to have <span class="literal">__DECIMAL_POS</span> decimal positions. Here <span class="literal">strain</span> is the exception; instead of rounding it, we want to use scientific notation with three decimal positions (’<span class="literal">{:.3e}</span>’). The strain is usually a small value, orders of magnitude smaller than the stress, so if we try to round it to, say, four decimal positions, the result will still be zero: <span class="literal">0.0000$</span>. Using the ’<span class="literal">{:.3e}</span>’ format, we’ll get things like <span class="literal">1.259e–05</span> instead.</p>&#13;
<p class="indent">When formatting values in our engineering applications, we have to be aware of the orders of magnitude. A wrongly formatted value, where the precision required is lost, renders the app useless.</p>&#13;
<h4 class="h4" id="ch00lev2sec207"><strong><em>The Unicode Characters</em></strong></h4>&#13;
<p class="noindent">The icons we’re using in the code, →, <em>Δ</em>, <em>ϵ</em>, ⊕, and ⊖, are all Unicode characters. Every operating system has a way of inserting these characters. If you do a quick Google search, you should be able to find how to access them in your OS. For instance, macOS uses the CMD-CTRL-spacebar key combination to open the symbols dialog, which is how I inserted those in the code.</p>&#13;
<p class="indent">You may also insert these characters using their code in a Python string like so:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">'\u2295 is a Unicode symbol'</span>&#13;
'⊕ is a Unicode symbol'</pre>&#13;
<p class="indent">If you opt for this alternative, you’ll need to replace the characters in the listings with their code. <a href="ch18.xhtml#ch18tab2">Table 18-2</a> shows the characters we’ve used and their Unicode code.</p>&#13;
<p class="tabcap" id="ch18tab2"><strong>Table 18-2:</strong> Unicode Characters</p>&#13;
<table class="all">&#13;
<tbody><tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Character</strong></p>&#13;
</td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Unicode</strong></p>&#13;
</td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Usage</strong></p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba">⊕</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">\u2295</span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="taba">Tension stress</p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba">⊖</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">\u2296</span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="taba">Compression stress</p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba">→</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">\u279c</span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="taba">Separates the node IDs of a bar (1 →2)</p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba"><em>Δ</em></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">\u0394</span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="taba">Length increment (<em>Δl</em>)</p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba"><em>ϵ</em></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">\u03f5</span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="taba">Strain</p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h1aa"><p class="taba"><em>σ</em></p>&#13;
</td>&#13;
<td style="vertical-align: top;" class="table-h1aa"><p class="taba"><span class="literal">\u03c3</span></p>&#13;
</td>&#13;
<td style="vertical-align: top;" class="table-h1aa"><p class="taba">Stress</p>&#13;
</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h4 class="h4" id="ch00lev2sec208"><span epub:type="pagebreak" id="page_527"/><strong><em>Putting It All Together</em></strong></h4>&#13;
<p class="noindent">If you’ve followed along, your result should look like <a href="ch18.xhtml#ch18lis25">Listing 18-25</a>.</p>&#13;
<pre>from structures.solution.bar import StrBarSolution&#13;
from structures.solution.node import StrNodeSolution&#13;
from structures.solution.structure import StructureSolution&#13;
from utils.strings import list_to_string&#13;
&#13;
__DECIMAL_POS = 4&#13;
__SEPARATION = ['------------------------------------------', '\n']&#13;
&#13;
&#13;
def structure_solution_to_string(result: StructureSolution):&#13;
    nodes_text = __nodes_to_string(result)&#13;
    bars_text = __bars_to_string(result.bars)&#13;
    return list_to_string(nodes_text + __SEPARATION + bars_text)&#13;
&#13;
&#13;
def __nodes_to_string(result: StructureSolution):&#13;
    return [&#13;
        __node_to_string(result, node)&#13;
        for node in result.nodes&#13;
    ]&#13;
&#13;
&#13;
def __node_to_string(&#13;
        result: StructureSolution,&#13;
        node: StrNodeSolution&#13;
):&#13;
    orig_pos = node.original_pos.to_formatted_str(__DECIMAL_POS)&#13;
    displacement = node.global_disp.to_formatted_str(__DECIMAL_POS)&#13;
    disp_pos = node.displaced_pos.to_formatted_str(__DECIMAL_POS)&#13;
&#13;
    strings = [&#13;
        f'NODE {node.id}',&#13;
        f'\toriginal position: {orig_pos}',&#13;
        f'\tdisplacement: {displacement}',&#13;
        f'\tdisplaced position: {disp_pos}'&#13;
    ]&#13;
&#13;
    if node.is_constrained:&#13;
        react = result.reaction_for_node(node)&#13;
        react_str = react.to_formatted_str(__DECIMAL_POS)&#13;
        strings.append(f'\treaction: {react_str}')&#13;
&#13;
    return list_to_string(strings) + '\n'&#13;
&#13;
&#13;
<span epub:type="pagebreak" id="page_528"/>def __bars_to_string(bars: [StrBarSolution]):&#13;
    return [__bar_to_string(bar) for bar in bars]&#13;
&#13;
&#13;
def __bar_to_string(bar: StrBarSolution):&#13;
    nodes_str = f'{bar.start_node.id} → {bar.end_node.id}'&#13;
    type_str = '⊕ TENSION' if bar.stress &gt;= 0 else '⊖ COMPRESSION'&#13;
    elongation = round(bar.elongation, __DECIMAL_POS)&#13;
    strain = '{:.3e}'.format(bar.strain)&#13;
    stress = round(bar.stress, __DECIMAL_POS)&#13;
&#13;
    return list_to_string([&#13;
        f'BAR {bar.id} ({nodes_str}) : {type_str}',&#13;
        f'\tΔ<span class="codeitalic1">l</span> (elongation) = {elongation}',&#13;
        f'\tϵ  (strain)     = {strain}',&#13;
        f'\tσ  (stress)     = {stress}\n'&#13;
    ])</pre>&#13;
<p class="caption"><a id="ch18lis25"/><em>Listing 18-25: Structure solution to text</em></p>&#13;
<p class="indent">In less than 70 lines of code we’ve written a function capable of generating a text representation of the structure solution model.</p>&#13;
<h3 class="h3" id="ch00lev1sec112"><strong>Summary</strong></h3>&#13;
<p class="noindent">In this chapter, we implemented the code that creates vector diagrams representing the structure solution model. We split the resulting drawing process into chunks to make the code more manageable, and then we put it all together in the <em>svg.py</em> file, specifically, in the <span class="literal">structure_solution_to_svg</span> function.</p>&#13;
<p class="indent">We then implemented a function, <span class="literal">structure_solution_to_string</span>, that produces a plaintext representation of the structure solution.</p>&#13;
<p class="indent">Now we have everything we need to put our application together. In the final chapter, we’ll do just that.</p>&#13;
</body></html>