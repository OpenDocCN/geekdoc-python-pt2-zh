["```py\ndef identity(f):\n    return f\n```", "```py\n@identity\ndef foo():\n    return 'bar'\n```", "```py\ndef foo():\n    return 'bar'\nfoo = identity(foo)\n```", "```py\n_functions = {}\ndef register(f):\n    global _functions\n    _functions[f.__name__] = f\n    return f\n@register\ndef foo():\n    return 'bar'\n```", "```py\nclass Store(object):\n    def get_food(self, username, food):\n        if username != 'admin':\n            raise Exception(\"This user is not allowed to get food\")\n        return self.storage.get(food)\n\n    def put_food(self, username, food):\n        if username != 'admin':\n            raise Exception(\"This user is not allowed to put food\")\n        self.storage.put(food)\n```", "```py\n➊ def check_is_admin(username):\n    if username != 'admin':\n        raise Exception(\"This user is not allowed to get or put food\")\n\nclass Store(object):\n    def get_food(self, username, food):\n        check_is_admin(username)\n        return self.storage.get(food)\n\n    def put_food(self, username, food):\n        check_is_admin(username)\n        self.storage.put(food)\n```", "```py\ndef check_is_admin(f):\n ➊ def wrapper(*args, **kwargs):\n        if kwargs.get('username') != 'admin':\n            raise Exception(\"This user is not allowed to get or put food\")\n        return f(*args, **kwargs) return wrapper\n\nclass Store(object):\n    @check_is_admin\n    def get_food(self, username, food):\n        return self.storage.get(food)\n\n    @check_is_admin\n    def put_food(self, username, food):\n        self.storage.put(food)\n```", "```py\ndef check_user_is_not(username):\n    def user_check_decorator(f):\n        def wrapper(*args, **kwargs):\n            if kwargs.get('username') == username:\n                raise Exception(\"This user is not allowed to get food\")\n            return f(*args, **kwargs)\n        return wrapper\n    return user_check_decorator\n\nclass Store(object):\n    @check_user_is_not(\"admin\")\n    @check_user_is_not(\"user123\")\n    def get_food(self, username, food):\n        return self.storage.get(food)\n```", "```py\nclass Store(object):\n    def get_food(self, username, food):\n        return self.storage.get(food)\n\nStore.get_food = check_user_is_not(\"user123\")(Store.get_food)\nStore.get_food = check_user_is_not(\"admin\")(Store.get_food)\n```", "```py\nimport uuid\n\ndef set_class_name_and_id(klass):\n    klass.name = str(klass)\n    klass.random_id = uuid.uuid4()\n    return klass\n\n@set_class_name_and_id\nclass SomeClass(object):\n    pass\n```", "```py\n>>> SomeClass.name\n\"<class '__main__.SomeClass'>\"\n>>> SomeClass.random_id\nUUID('d244dc42-f0ca-451c-9670-732dc32417cd')\n```", "```py\nclass CountCalls(object):\n    def __init__(self, f):\n        self.f = f\n        self.called = 0 def __call__(self, *args, **kwargs):\n        self.called += 1\n        return self.f(*args, **kwargs)\n\n@CountCalls\ndef print_hello():\n    print(\"hello\")\n```", "```py\n>>> print_hello.called\n0\n>>> print_hello()\nhello\n>>> print_hello.called\n1\n```", "```py\n>>> def is_admin(f):\n...     def wrapper(*args, **kwargs):\n...         if kwargs.get('username') != 'admin':\n...             raise Exception(\"This user is not allowed to get food\")\n...         return f(*args, **kwargs)\n...     return wrapper\n...\n>>> def foobar(username=\"someone\"):\n...     \"\"\"Do crazy stuff.\"\"\"\n...     pass\n...\n>>> foobar.func_doc\n'Do crazy stuff.'\n>>> foobar.__name__\n'foobar'\n>>> @is_admin\n... def foobar(username=\"someone\"):\n...     \"\"\"Do crazy stuff.\"\"\"\n...     pass\n...\n>>> foobar.__doc__\n>>> foobar.__name__\n'wrapper'\n```", "```py\nWRAPPER_ASSIGNMENTS = ('__module__', '__name__', '__qualname__', '__doc__',\n                       '__annotations__')\nWRAPPER_UPDATES = ('__dict__',)\ndef update_wrapper(wrapper,\n                   wrapped,\n                   assigned = WRAPPER_ASSIGNMENTS,\n                   updated = WRAPPER_UPDATES):\n    for attr in assigned:\n        try:\n            value = getattr(wrapped, attr)\n        except AttributeError:\n            pass\n        else:\n            setattr(wrapper, attr, value)\n    for attr in updated:\n        getattr(wrapper, attr).update(getattr(wrapped, attr, {}))\n    # Issue #17482: set __wrapped__ last so we don't inadvertently copy it\n    # from the wrapped function when updating __dict__\n    wrapper.__wrapped__ = wrapped\n    # Return the wrapper so this can be used as a decorator via partial()\n    return wrapper\n```", "```py\n>>> def foobar(username=\"someone\"):\n...     \"\"\"Do crazy stuff.\"\"\"\n...     pass\n...\n>>> foobar = functools.update_wrapper(is_admin, foobar)\n>>> foobar.__name__\n'foobar'\n>>> foobar.__doc__\n'Do crazy stuff.'\n```", "```py\nimport functools\n\ndef check_is_admin(f):\n    @functools.wraps(f)\n    def wrapper(*args, **kwargs):\n        if kwargs.get('username') != 'admin':\n            raise Exception(\"This user is not allowed to get food\")\n        return f(*args, **kwargs)\n    return wrapper\n\nclass Store(object):\n    @check_is_admin\n    def get_food(self, username, food):\n        \"\"\"Get food from storage.\"\"\"\n        return self.storage.get(food)\n```", "```py\nimport functools\nimport inspect\n\ndef check_is_admin(f):\n    @functools.wraps(f)\n    def wrapper(*args, **kwargs):\n        func_args = inspect.getcallargs(f, *args, **kwargs)\n        if func_args.get('username') != 'admin':\n            raise Exception(\"This user is not allowed to get food\")\n        return f(*args, **kwargs)\n    return wrapper @check_is_admin\ndef get_food(username, type='chocolate'):\n    return type + \" nom nom nom!\"\n```", "```py\n>>> class Pizza(object):\n...     def __init__(self, size):\n...         self.size = size\n...     def get_size(self):\n...         return self.size\n...\n>>> Pizza.get_size\n<function Pizza.get_size at 0x7fdbfd1a8b90>\n```", "```py\n>>> Pizza.get_size()\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: get_size() missing 1 required positional argument: 'self'\n```", "```py\n>>> Pizza.get_size(Pizza(42))\n42\n```", "```py\n>>> Pizza(42).get_size\n<bound method Pizza.get_size of <__main__.Pizza object at 0x7f3138827910>>\n>>> Pizza(42).get_size()\n42\n```", "```py\n>>> m = Pizza(42).get_size\n>>> m()\n42\n```", "```py\n>>> m = Pizza(42).get_size\n>>> m.__self__\n<__main__.Pizza object at 0x7f3138827910>\n>>> m == m.__self__.get_size\nTrue\n```", "```py\nclass Pizza(object):\n    @staticmethod\n    def mix_ingredients(x, y):\n        return x + y\n\n    def cook(self):\n        return self.mix_ingredients(self.cheese, self.vegetables)\n```", "```py\n>>> Pizza().cook is Pizza().cook\nFalse\n>>> Pizza().mix_ingredients is Pizza.mix_ingredients\nTrue\n>>> Pizza().mix_ingredients is Pizza().mix_ingredients\nTrue\n```", "```py\n>>> class Pizza(object):\n...     radius = 42\n...     @classmethod\n...     def get_radius(cls):\n...         return cls.radius\n...\n>>> Pizza.get_radius\n<bound method type.get_radius of <class '__main__.Pizza'>>\n>>> Pizza().get_radius\n<bound method type.get_radius of <class '__main__.Pizza'>>\n>>> Pizza.get_radius is Pizza().get_radius\nTrue\n>>> Pizza.get_radius()\n42\n```", "```py\nclass Pizza(object):\n    def __init__(self, ingredients):\n        self.ingredients = ingredients\n\n    @classmethod\n    def from_fridge(cls, fridge):\n        return cls(fridge.get_cheese() + fridge.get_vegetables())\n```", "```py\nclass Pizza(object):\n    @staticmethod\n    def get_radius():\n        raise NotImplementedError\n```", "```py\n>>> Pizza()\n<__main__.Pizza object at 0x7fb747353d90>\n>>> Pizza().get_radius()\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  File \"<stdin>\", line 3, in get_radius\nNotImplementedError\n```", "```py\nimport abc\n\nclass BasePizza(object, metaclass=abc.ABCMeta):\n\n    @abc.abstractmethod\n    def get_radius(self):\n         \"\"\"Method that should do something.\"\"\"\n```", "```py\n>>> BasePizza()\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: Can't instantiate abstract class BasePizza with abstract methods\nget_radius\n```", "```py\nimport abc\n\nclass BasePizza(object, metaclass=abc.ABCMeta):\n\n    @abc.abstractmethod\n    def get_ingredients(self):\n         \"\"\"Returns the ingredient list.\"\"\"\n\nclass Calzone(BasePizza):\n    def get_ingredients(self, with_egg=False):\n        egg = Egg() if with_egg else None\n        return self.ingredients + [egg]\n```", "```py\nimport abc\n\nclass BasePizza(object, metaclass=abc.ABCMeta):\n\n    @abc.abstractmethod\n    def get_ingredients(self):\n         \"\"\"Returns the ingredient list.\"\"\"\n\nclass DietPizza(BasePizza):\n    @staticmethod\n    def get_ingredients():\n        return None\n```", "```py\nimport abc\n\nclass BasePizza(object, metaclass=abc.ABCMeta):\n\n    ingredients = ['cheese']\n\n    @classmethod\n    @abc.abstractmethod\n    def get_ingredients(cls):\n         \"\"\"Returns the ingredient list.\"\"\"\n         return cls.ingredients\n```", "```py\nimport abc\n\nclass BasePizza(object, metaclass=abc.ABCMeta):\n\n    default_ingredients = ['cheese']\n\n    @classmethod\n    @abc.abstractmethod\n    def get_ingredients(cls):\n         \"\"\"Returns the default ingredient list.\"\"\"\n         return cls.default_ingredients\n\nclass DietPizza(BasePizza):\n    def get_ingredients(self):\n        return [Egg()] + super(DietPizza, self).get_ingredients()\n```", "```py\n>>> def parent():\n...     return object\n...\n>>> class A(parent()):\n...     pass\n...\n>>> A.mro()\n[<class '__main__.A'>, <type 'object'>]\n```", "```py\n>>> class A(object):\n...     bar = 42\n...     def foo(self):\n...             pass\n...\n>>> class B(object):\n...     bar = 0\n...\n>>> class C(A, B):\n...     xyz = 'abc'\n...\n>>> C.mro()\n[<class '__main__.C'>, <class '__main__.A'>, <class '__main__.B'>, <type 'object'>]\n>>> super(C, C()).bar\n42\n>>> super(C, C()).foo\n<bound method C.foo of <__main__.C object at 0x7f0299255a90>>\n>>> super(B).__self__ >>> super(B, B()).__self__\n<__main__.B object at 0x1096717f0>\n```", "```py\n>>> super(C)\n<super: <class 'C'>, NULL>\n```", "```py\n>>> super(C).foo\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nAttributeError: 'super' object has no attribute 'foo'\n>>> super(C).bar\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nAttributeError: 'super' object has no attribute 'bar'\n>>> super(C).xyz\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nAttributeError: 'super' object has no attribute 'xyz'\n```", "```py\n>>> class D(C):\n...     sup = super(C)\n...\n>>> D().sup\n<super: <class 'C'>, <D object>>\n>>> D().sup.foo\n<bound method D.foo of <__main__.D object at 0x7f0299255bd0>>\n>>> D().sup.bar\n42\n```", "```py\nclass B(A):\n      def foo(self):\n          super().foo()\n```"]