<html><head></head><body>
<h2 class="h2" id="ch07"><span epub:type="pagebreak" id="page_99"/><strong><span class="big">7</span></strong><br/><strong>METHODS AND DECORATORS</strong></h2>&#13;
<div class="image1"><img alt="image" src="../images/common01.jpg"/></div>&#13;
<p class="noindent">Python’s decorators are a handy way to modify functions. Decorators were first introduced in Python 2.2, with the <span class="literal">classmethod()</span> and <span class="literal">staticmethod()</span> decorators, but were overhauled to become more flexible and readable. Along with these two original decorators, Python now provides a few right out of the box and supports the simple creation of custom decorators. But it seems as though most developers do not understand how they work behind the scenes.</p>&#13;
<p class="indent">This chapter aims to change that—we’ll cover what a decorator is and how to use it, as well as how to create your own decorators. Then we’ll look at using decorators to create static, class, and abstract methods and take a close look at the <span class="literal">super()</span> function, which allows you to place implementable code inside an abstract method.</p>&#13;
<h3 class="h3" id="lev1sec34"><span epub:type="pagebreak" id="page_100"/><strong>Decorators and When to Use Them</strong></h3>&#13;
<p class="noindent">A <em>decorator</em> is a function that takes another function as an argument and replaces it with a new, modified function. The primary use case for decorators is in factoring common code that needs to be called before, after, or around multiple functions. If you’ve ever written Emacs Lisp code, you may have used the <span class="literal">defadvice</span> decorator, which allows you to define code called around a function. If you’ve used method combinations in the Common Lisp Object System (CLOS), Python decorators follow the same concepts. We’ll look at some simple decorator definitions, and then we’ll examine some common situations in which you’d use decorators.</p>&#13;
<h4 class="h4" id="lev2sec34"><strong><em>Creating Decorators</em></strong></h4>&#13;
<p class="noindent">The odds are good that you’ve already used decorators to make your own wrapper functions. The dullest possible decorator, and the simplest example, is the <span class="literal">identity()</span> function, which does nothing except return the original function. Here is its definition:</p>&#13;
<p class="programs">def identity(f):<br/>    return f</p>&#13;
<p class="indent">You would then use your decorator like this:</p>&#13;
<p class="programs">@identity<br/>def foo():<br/>    return 'bar'</p>&#13;
<p class="indent">You enter the name of the decorator preceded by an <span class="literal">@</span> symbol and then enter the function you want to use it on. This is the same as writing the following:</p>&#13;
<p class="programs">def foo():<br/>    return 'bar'<br/>foo = identity(foo)</p>&#13;
<p class="indent">This decorator is useless, but it works. Let’s look at another, more useful example in <a href="ch07.xhtml#ch7list1">Listing 7-1</a>.</p>&#13;
<p class="programs">_functions = {}<br/>def register(f):<br/>    global _functions<br/>    _functions[f.__name__] = f<br/>    return f<br/>@register<br/>def foo():<br/>    return 'bar'</p>&#13;
<p class="listing1"><a id="ch7list1"/><em>Listing 7-1: A decorator to organize functions in a dictionary</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_101"/>In <a href="ch07.xhtml#ch7list1">Listing 7-1</a>, the <span class="literal">register</span> decorator stores the decorated function name into a dictionary. The <span class="literal">_functions</span> dictionary can then be used and accessed using the function name to retrieve a function: <span class="literal">_functions['foo']</span> points to the <span class="literal">foo()</span> function.</p>&#13;
<p class="indent">In the following sections, I will explain how to write your own decorators. Then I’ll cover how the built-in decorators provided by Python work and explain how (and when) to use them.</p>&#13;
<h4 class="h4" id="lev2sec35"><strong><em>Writing Decorators</em></strong></h4>&#13;
<p class="noindent">As mentioned, decorators are often used when refactoring repeated code around functions. Consider the following set of functions that need to check whether the username they receive as an argument is the admin or not and, if the user is not an admin, raise an exception:</p>&#13;
<p class="programs">class Store(object):<br/>    def get_food(self, username, food):<br/>        if username != 'admin':<br/>            raise Exception("This user is not allowed to get food")<br/>        return self.storage.get(food)<br/><br/>    def put_food(self, username, food):<br/>        if username != 'admin':<br/>            raise Exception("This user is not allowed to put food")<br/>        self.storage.put(food)</p>&#13;
<p class="indent">We can see there’s some repeated code here. The obvious first step to making this code more efficient is to factor the code that checks for admin status:</p>&#13;
<p class="programs"><span class="ent">➊</span> def check_is_admin(username):<br/>    if username != 'admin':<br/>        raise Exception("This user is not allowed to get or put food")<br/><br/>class Store(object):<br/>    def get_food(self, username, food):<br/>        check_is_admin(username)<br/>        return self.storage.get(food)<br/><br/>    def put_food(self, username, food):<br/>        check_is_admin(username)<br/>        self.storage.put(food)</p>&#13;
<p class="indent">We’ve moved the checking code into its own function <span class="ent">➊</span>. Now our code looks a bit cleaner, but we can do even better if we use a decorator, as shown in <a href="ch07.xhtml#ch7list2">Listing 7-2</a>.</p>&#13;
<p class="programs">def check_is_admin(f):<br/> <span class="ent">➊</span> def wrapper(*args, **kwargs):<br/>        if kwargs.get('username') != 'admin':<br/>            raise Exception("This user is not allowed to get or put food")<br/>        return f(*args, **kwargs)<span epub:type="pagebreak" id="page_102"/><br/>    return wrapper<br/><br/>class Store(object):<br/>    @check_is_admin<br/>    def get_food(self, username, food):<br/>        return self.storage.get(food)<br/><br/>    @check_is_admin<br/>    def put_food(self, username, food):<br/>        self.storage.put(food)</p>&#13;
<p class="listing1"><a id="ch7list2"/><em>Listing 7-2: Adding a decorator to the factored code</em></p>&#13;
<p class="indent">We define our <span class="literal">check_is_admin</span> decorator <span class="ent">➊</span> and then call it whenever we need to check for access rights. The decorator inspects the arguments passed to the function using the <span class="literal">kwargs</span> variable and retrieves the <span class="literal">username</span> argument, performing the username check before calling the actual function. Using decorators like this makes it easier to manage common functionality. To anyone with much Python experience, this is probably old hat, but what you might not realize is that this naive approach to implementing decorators has some major drawbacks.</p>&#13;
<h4 class="h4" id="lev2sec36"><strong><em>Stacking Decorators</em></strong></h4>&#13;
<p class="noindent">You can also use several decorators on top of a single function or method, as shown in <a href="ch07.xhtml#ch7list3">Listing 7-3</a>.</p>&#13;
<p class="programs">def check_user_is_not(username):<br/>    def user_check_decorator(f):<br/>        def wrapper(*args, **kwargs):<br/>            if kwargs.get('username') == username:<br/>                raise Exception("This user is not allowed to get food")<br/>            return f(*args, **kwargs)<br/>        return wrapper<br/>    return user_check_decorator<br/><br/>class Store(object):<br/>    @check_user_is_not("admin")<br/>    @check_user_is_not("user123")<br/>    def get_food(self, username, food):<br/>        return self.storage.get(food)</p>&#13;
<p class="listing1"><a id="ch7list3"/><em>Listing 7-3: Using more than one decorator with a single function</em></p>&#13;
<p class="indent">Here, <span class="literal">check_user_is_not()</span> is a factory function for our decorator <span class="literal">user_check_decorator()</span>. It creates a function decorator that depends on the <span class="literal">username</span> variable and then returns that variable. The function <span class="literal">user_check_decorator()</span> will serve as a function decorator for <span class="literal">get_food()</span>.</p>&#13;
<p class="indent">The function <span class="literal">get_food()</span> gets decorated twice using <span class="literal">check_user_is_not()</span>. The question here is which username should be checked first—<span class="literal">admin</span> or <span class="literal">user123</span>? The answer is in the following code, where I translated <a href="ch07.xhtml#ch7list3">Listing 7-3</a> into equivalent code without using a decorator.</p>&#13;
<p class="programs"><span epub:type="pagebreak" id="page_103"/>class Store(object):<br/>    def get_food(self, username, food):<br/>        return self.storage.get(food)<br/><br/>Store.get_food = check_user_is_not("user123")(Store.get_food)<br/>Store.get_food = check_user_is_not("admin")(Store.get_food)</p>&#13;
<p class="indent">The decorator list is applied from top to bottom, so the decorators closest to the <span class="literal">def</span> keyword will be applied first and executed last. In the example above, the program will check for <span class="literal">admin</span> first and then for <span class="literal">user123</span>.</p>&#13;
<h4 class="h4" id="lev2sec37"><strong><em>Writing Class Decorators</em></strong></h4>&#13;
<p class="noindent">It’s also possible to implement class decorators, though these are less often used in the wild. <em>Class decorators</em> work in the same way as function decorators, but they act on classes rather than functions. The following is an example of a class decorator that sets attributes for two classes:</p>&#13;
<p class="programs">import uuid<br/><br/>def set_class_name_and_id(klass):<br/>    klass.name = str(klass)<br/>    klass.random_id = uuid.uuid4()<br/>    return klass<br/><br/>@set_class_name_and_id<br/>class SomeClass(object):<br/>    pass</p>&#13;
<p class="indent">When the class is loaded and defined, it will set the <span class="literal">name</span> and <span class="literal">random_id</span> attributes, like so:</p>&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">SomeClass.name</span><br/>"&lt;class '__main__.SomeClass'&gt;"<br/>&gt;&gt;&gt; <span class="codestrong1">SomeClass.random_id</span><br/>UUID('d244dc42-f0ca-451c-9670-732dc32417cd')</p>&#13;
<p class="indent">As with function decorators, this can be handy for factorizing common code that manipulates classes.</p>&#13;
<p class="indent">Another possible use for class decorators is to wrap a function or class with classes. For example, class decorators are often used for wrapping a function that’s storing a state. The following example wraps the <span class="literal">print()</span> function to check how many times it has been called in a session:</p>&#13;
<p class="programs">class CountCalls(object):<br/>    def __init__(self, f):<br/>        self.f = f<br/>        self.called = 0<span epub:type="pagebreak" id="page_104"/><br/>    def __call__(self, *args, **kwargs):<br/>        self.called += 1<br/>        return self.f(*args, **kwargs)<br/><br/>@CountCalls<br/>def print_hello():<br/>    print("hello")</p>&#13;
<p class="indent">We can then use this to check how many times the function <span class="literal">print_hello()</span> has been called:</p>&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">print_hello.called</span><br/>0<br/>&gt;&gt;&gt; <span class="codestrong1">print_hello()</span><br/>hello<br/>&gt;&gt;&gt; <span class="codestrong1">print_hello.called</span><br/>1</p>&#13;
<h5 class="h5"><strong>Retrieving Original Attributes with the update_wrapper Decorator</strong></h5>&#13;
<p class="noindent">As mentioned, a decorator replaces the original function with a new one built on the fly. However, this new function lacks many of the attributes of the original function, such as its docstring and its name. <a href="ch07.xhtml#ch7list4">Listing 7-4</a> shows how the function <span class="literal">foobar()</span> loses its docstring and its name attribute once it is decorated with the <span class="literal">is_admin</span> decorator.</p>&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">def is_admin(f):</span><br/>...     <span class="codestrong1">def wrapper(*args, **kwargs):</span><br/>...         <span class="codestrong1">if kwargs.get('username') != 'admin':</span><br/>...             <span class="codestrong1">raise Exception("This user is not allowed to get food")</span><br/>...         <span class="codestrong1">return f(*args, **kwargs)</span><br/>...     <span class="codestrong1">return wrapper</span><br/>...<br/>&gt;&gt;&gt; <span class="codestrong1">def foobar(username="someone"):</span><br/>...     <span class="codestrong1">"""Do crazy stuff."""</span><br/>...     <span class="codestrong1">pass</span><br/>...<br/>&gt;&gt;&gt; <span class="codestrong1">foobar.func_doc</span><br/>'Do crazy stuff.'<br/>&gt;&gt;&gt; <span class="codestrong1">foobar.__name__</span><br/>'foobar'<br/>&gt;&gt;&gt; <span class="codestrong1">@is_admin</span><br/>... <span class="codestrong1">def foobar(username="someone"):</span><br/>...     <span class="codestrong1">"""Do crazy stuff."""</span><br/>...     <span class="codestrong1">pass</span><br/>...<br/>&gt;&gt;&gt; <span class="codestrong1">foobar.__doc__</span><br/>&gt;&gt;&gt; <span class="codestrong1">foobar.__name__</span><br/>'wrapper'</p>&#13;
<p class="listing1"><a id="ch7list4"/><em>Listing 7-4: A decorated function loses its docstring and name attributes.</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_105"/>Not having the correct docstring and name attribute for a function can be problematic in various situations, such as when generating the source code documentation.</p>&#13;
<p class="indent">Fortunately, the <span class="literal">functools</span> module in the Python Standard Library solves this problem with the <span class="literal">update_wrapper()</span> function, which copies the attributes from the original function that were lost to the wrapper itself. The source code of <span class="literal">update_wrapper()</span> is shown in <a href="ch07.xhtml#ch7list5">Listing 7-5</a>.</p>&#13;
<p class="programs">WRAPPER_ASSIGNMENTS = ('__module__', '__name__', '__qualname__', '__doc__',<br/>                       '__annotations__')<br/>WRAPPER_UPDATES = ('__dict__',)<br/>def update_wrapper(wrapper,<br/>                   wrapped,<br/>                   assigned = WRAPPER_ASSIGNMENTS,<br/>                   updated = WRAPPER_UPDATES):<br/>    for attr in assigned:<br/>        try:<br/>            value = getattr(wrapped, attr)<br/>        except AttributeError:<br/>            pass<br/>        else:<br/>            setattr(wrapper, attr, value)<br/>    for attr in updated:<br/>        getattr(wrapper, attr).update(getattr(wrapped, attr, {}))<br/>    # Issue #17482: set __wrapped__ last so we don't inadvertently copy it<br/>    # from the wrapped function when updating __dict__<br/>    wrapper.__wrapped__ = wrapped<br/>    # Return the wrapper so this can be used as a decorator via partial()<br/>    return wrapper</p>&#13;
<p class="listing1"><a id="ch7list5"/><em>Listing 7-5: The <span class="codeitalic">update_wrapper()</span> source code</em></p>&#13;
<p class="indent">In <a href="ch07.xhtml#ch7list5">Listing 7-5</a>, the <span class="literal">update_wrapper()</span> source code highlights which attributes are worth saving when wrapping a function with a decorator. By default, the <span class="literal">__name__</span> attribute, <span class="literal">__doc__</span> attribute, and some other attributes are copied. You can also personalize which attributes of a function are copied to the decorated function. When we use <span class="literal">update_wrapper()</span> to rewrite our example from <a href="ch07.xhtml#ch7list4">Listing 7-4</a>, things are much nicer:</p>&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">def foobar(username="someone"):</span><br/>...     <span class="codestrong1">"""Do crazy stuff."""</span><br/>...     <span class="codestrong1">pass</span><br/>...<br/>&gt;&gt;&gt; <span class="codestrong1">foobar = functools.update_wrapper(is_admin, foobar)</span><br/>&gt;&gt;&gt; <span class="codestrong1">foobar.__name__</span><br/>'foobar'<br/>&gt;&gt;&gt; <span class="codestrong1">foobar.__doc__</span><br/>'Do crazy stuff.'</p>&#13;
<p class="indent">Now the <span class="literal">foobar()</span> function has the correct name and docstring even when decorated by <span class="literal">is_admin</span>.</p>&#13;
<h5 class="h5"><span epub:type="pagebreak" id="page_106"/><strong>wraps: A Decorator for Decorators</strong></h5>&#13;
<p class="noindent">It can get tedious to use <span class="literal">update_wrapper()</span> manually when creating decorators, so <span class="literal">functools</span> provides a decorator for decorators called <span class="literal">wraps</span>. <a href="ch07.xhtml#ch7list6">Listing 7-6</a> shows the <span class="literal">wraps</span> decorator in use.</p>&#13;
<p class="programs">import functools<br/><br/>def check_is_admin(f):<br/>    @functools.wraps(f)<br/>    def wrapper(*args, **kwargs):<br/>        if kwargs.get('username') != 'admin':<br/>            raise Exception("This user is not allowed to get food")<br/>        return f(*args, **kwargs)<br/>    return wrapper<br/><br/>class Store(object):<br/>    @check_is_admin<br/>    def get_food(self, username, food):<br/>        """Get food from storage."""<br/>        return self.storage.get(food)</p>&#13;
<p class="listing1"><a id="ch7list6"/><em>Listing 7-6: Updating our decorator with <span class="codeitalic">wraps</span> from <span class="codeitalic">functools</span></em></p>&#13;
<p class="indent">With <span class="literal">functools.wrap</span>, the decorator function <span class="literal">check_is_admin()</span> that returns the <span class="literal">wrapper()</span> function takes care of copying the docstring, name function, and other information from the function <span class="literal">f</span> passed as argument. Thus, the decorated function (<span class="literal">get_food()</span>, in this case) still sees its unchanged signature.</p>&#13;
<h5 class="h5"><strong>Extracting Relevant Information with inspect</strong></h5>&#13;
<p class="noindent">In our examples so far, we have assumed that the decorated function will always have a <span class="literal">username</span> passed to it as a keyword argument, but that might not be the case. It might instead have a bunch of information from which we need to extract the username to check. With this in mind, we’ll build a smarter version of our decorator that can look at the decorated function’s arguments and pull out what it needs.</p>&#13;
<p class="indent">For this, Python has the <span class="literal">inspect</span> module, which allows us to retrieve a function’s signature and operate on it, as shown in <a href="ch07.xhtml#ch7list7">Listing 7-7</a>.</p>&#13;
<p class="programs">import functools<br/>import inspect<br/><br/>def check_is_admin(f):<br/>    @functools.wraps(f)<br/>    def wrapper(*args, **kwargs):<br/>        func_args = inspect.getcallargs(f, *args, **kwargs)<br/>        if func_args.get('username') != 'admin':<br/>            raise Exception("This user is not allowed to get food")<br/>        return f(*args, **kwargs)<br/>    return wrapper<span epub:type="pagebreak" id="page_107"/><br/>@check_is_admin<br/>def get_food(username, type='chocolate'):<br/>    return type + " nom nom nom!"</p>&#13;
<p class="listing1"><a id="ch7list7"/><em>Listing 7-7: Using tools from the <span class="codeitalic">inspect</span> module to extract information</em></p>&#13;
<p class="indent">The function that does the heavy lifting here is <span class="literal">inspect.getcallargs()</span>, which returns a dictionary containing the names and values of the arguments as key-value pairs. In our example, this function returns <span class="literal">{'username': 'admin','type': 'chocolate'}</span>. That means that our decorator does not have to check whether the <span class="literal">username</span> parameter is a positional or a keyword argument; all the decorator has to do is look for <span class="literal">username</span> in the dictionary.</p>&#13;
<p class="indent">Using <span class="literal">functools.wraps</span> and the <span class="literal">inspect</span> module, you should be able to write any custom decorator that you would ever need. However, do not abuse the <span class="literal">inspect</span> module: while being able to guess what the function will accept as an argument sounds handy, this capability can be fragile, breaking easily when function signatures change. Decorators are a terrific way to implement the <em>Don’t Repeat Yourself</em> mantra so cherished by developers.</p>&#13;
<h3 class="h3" id="lev1sec35"><strong>How Methods Work in Python</strong></h3>&#13;
<p class="noindent">Methods are pretty simple to use and understand, and you’ve likely just used them correctly without delving in much deeper than you needed to. But to understand what certain decorators do, you need to know how methods work behind the scenes.</p>&#13;
<p class="indent">A <em>method</em> is a function that is stored as a class attribute. Let’s have a look at what happens when we try to access such an attribute directly:</p>&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">class Pizza(object):</span><br/>...     <span class="codestrong1">def __init__(self, size):</span><br/>...         <span class="codestrong1">self.size = size</span><br/>...     <span class="codestrong1">def get_size(self):</span><br/>...         <span class="codestrong1">return self.size</span><br/>...<br/>&gt;&gt;&gt; <span class="codestrong1">Pizza.get_size</span><br/>&lt;function Pizza.get_size at 0x7fdbfd1a8b90&gt;</p>&#13;
<p class="indent">We are told that <span class="literal">get_size()</span> is a function—but why is that? The reason is that at this stage, <span class="literal">get_size()</span> is not tied to any particular object. Therefore, it is treated as a normal function. Python will raise an error if we try to call it directly, like so:</p>&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">Pizza.get_size()</span><br/>Traceback (most recent call last):<br/>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br/>TypeError: get_size() missing 1 required positional argument: 'self'</p>&#13;
<p class="indent">Python complains that we have not provided the necessary <span class="literal">self</span> argument. Indeed, as it is not bound to any object, the <span class="literal">self</span> argument cannot be set automatically. However, we are able to use the <span class="literal">get_size()</span> function not <span epub:type="pagebreak" id="page_108"/>only by passing an arbitrary instance of the class to the method if we want to but also by passing <em>any</em> object, as long as it has the properties that the method expects to find. Here’s an example:</p>&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">Pizza.get_size(Pizza(42))</span><br/>42</p>&#13;
<p class="indent">This call works, just as promised. It is, however, not very convenient: we have to refer to the class every time we want to call one of its methods.</p>&#13;
<p class="indent">So Python goes the extra mile for us by binding a class’s methods to its instances. In other words, we can access <span class="literal">get_size()</span> from any <span class="literal">Pizza</span> instance, and, better still, Python will automatically pass the object itself to the method’s <span class="literal">self</span> parameter, like so:</p>&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">Pizza(42).get_size</span><br/>&lt;bound method Pizza.get_size of &lt;__main__.Pizza object at 0x7f3138827910&gt;&gt;<br/>&gt;&gt;&gt; <span class="codestrong1">Pizza(42).get_size()</span><br/>42</p>&#13;
<p class="indent">As expected, we do not have to provide any argument to <span class="literal">get_size()</span>, since it’s a bound method: its <span class="literal">self</span> argument is automatically set to our <span class="literal">Pizza</span> instance. Here is an even clearer example:</p>&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">m = Pizza(42).get_size</span><br/>&gt;&gt;&gt; <span class="codestrong1">m()</span><br/>42</p>&#13;
<p class="indent">As long as you have a reference to the bound method, you do not even have to keep a reference to your <span class="literal">Pizza</span> object. Moreover, if you have a reference to a method but you want to find out which object it is bound to, you can just check the method’s <span class="literal">__self__</span> property, like so:</p>&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">m = Pizza(42).get_size</span><br/>&gt;&gt;&gt; <span class="codestrong1">m.__self__</span><br/>&lt;__main__.Pizza object at 0x7f3138827910&gt;<br/>&gt;&gt;&gt; <span class="codestrong1">m == m.__self__.get_size</span><br/>True</p>&#13;
<p class="indent">Obviously, we still have a reference to our object, and we can find it if we want.</p>&#13;
<h3 class="h3" id="lev1sec36"><strong>Static Methods</strong></h3>&#13;
<p class="noindent"><em>Static methods</em> belong to a class, rather than an instance of a class, so they don’t actually operate on or affect class instances. Instead, a static method operates on the parameters it takes. Static methods are generally used to create utility functions, because they do not depend on the state of the class or its objects.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_109"/>For example, in <a href="ch07.xhtml#ch7list8">Listing 7-8</a>, the static <span class="literal">mix_ingredients()</span> method belongs to the <span class="literal">Pizza</span> class but could actually be used to mix ingredients for any other food.</p>&#13;
<p class="programs">class Pizza(object):<br/>    @staticmethod<br/>    def mix_ingredients(x, y):<br/>        return x + y<br/><br/>    def cook(self):<br/>        return self.mix_ingredients(self.cheese, self.vegetables)</p>&#13;
<p class="listing1"><a id="ch7list8"/><em>Listing 7-8: Creating a static method as part of a class</em></p>&#13;
<p class="indent">You could write <span class="literal">mix_ingredients()</span> as a non-static method if you wanted to, but it would take a <span class="literal">self</span> argument that would never actually be used. Using the <span class="literal">@staticmethod</span> decorator gives us several things.</p>&#13;
<p class="indent">The first is speed: Python does not have to instantiate a bound method for each <span class="literal">Pizza</span> object we create. Bound methods are objects, too, and creating them has a CPU and memory cost—even if it’s low. Using a static method lets us avoid that, like so:</p>&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">Pizza().cook is Pizza().cook</span><br/>False<br/>&gt;&gt;&gt; <span class="codestrong1">Pizza().mix_ingredients is Pizza.mix_ingredients</span><br/>True<br/>&gt;&gt;&gt; <span class="codestrong1">Pizza().mix_ingredients is Pizza().mix_ingredients</span><br/>True</p>&#13;
<p class="indent">Second, static methods improve the readability of the code. When we see <span class="literal">@staticmethod</span>, we know that the method does not depend on the state of the object.</p>&#13;
<p class="indent">Third, static methods can be overridden in subclasses. If instead of a static method, we used a <span class="literal">mix_ingredients()</span> function defined at the top level of our module, a class inheriting from <span class="literal">Pizza</span> wouldn’t be able to change the way we mix ingredients for our pizza without overriding the <span class="literal">cook()</span> method itself. With static methods, the subclasses can override the method for their own purposes.</p>&#13;
<p class="indent">Unfortunately, Python is not always able to detect for itself whether a method is static or not—I call that a defect of the language design. One possible approach is to add a check that detects such pattern and emits a warning using <span class="literal">flake8</span>. We will look into how to do this in “Extending <span class="literal">flake8</span> with AST Checks” on <a href="ch09.xhtml#page_140">page 140</a>.</p>&#13;
<h3 class="h3" id="lev1sec37"><strong>Class Methods</strong></h3>&#13;
<p class="noindent"><em>Class methods</em> are bound to a class rather than its instances. That means that those methods cannot access the state of the object but only the state and methods of the class. <a href="ch07.xhtml#ch7list9">Listing 7-9</a> shows how to write a class method.</p>&#13;
<p class="programs"><span epub:type="pagebreak" id="page_110"/>&gt;&gt;&gt; <span class="codestrong1">class Pizza(object):</span><br/>...     <span class="codestrong1">radius = 42</span><br/>...     <span class="codestrong1">@classmethod</span><br/>...     <span class="codestrong1">def get_radius(cls):</span><br/>...         <span class="codestrong1">return cls.radius</span><br/>...<br/>&gt;&gt;&gt; <span class="codestrong1">Pizza.get_radius</span><br/>&lt;bound method type.get_radius of &lt;class '__main__.Pizza'&gt;&gt;<br/>&gt;&gt;&gt; <span class="codestrong1">Pizza().get_radius</span><br/>&lt;bound method type.get_radius of &lt;class '__main__.Pizza'&gt;&gt;<br/>&gt;&gt;&gt; <span class="codestrong1">Pizza.get_radius is Pizza().get_radius</span><br/>True<br/>&gt;&gt;&gt; <span class="codestrong1">Pizza.get_radius()</span><br/>42</p>&#13;
<p class="listing1"><a id="ch7list9"/><em>Listing 7-9: Binding a class method to its class</em></p>&#13;
<p class="indent">As you can see, there are various ways to access the <span class="literal">get_radius()</span> class method, but however you choose to access it, the method is always bound to the class it is attached to. Also, its first argument must be the class itself. Remember: classes are objects too!</p>&#13;
<p class="indent">Class methods are principally useful for creating <em>factory methods</em>, which instantiate objects using a different signature than <span class="literal">__init__</span>:</p>&#13;
<p class="programs">class Pizza(object):<br/>    def __init__(self, ingredients):<br/>        self.ingredients = ingredients<br/><br/>    @classmethod<br/>    def from_fridge(cls, fridge):<br/>        return cls(fridge.get_cheese() + fridge.get_vegetables())</p>&#13;
<p class="indent">If we used a <span class="literal">@staticmethod</span> here instead of a <span class="literal">@classmethod</span>, we would have to hardcode the <span class="literal">Pizza</span> class name in our method, making any class inheriting from <span class="literal">Pizza</span> unable to use our factory for its own purposes. In this case, however, we provide a <span class="literal">from_fridge()</span> factory method that we can pass a <span class="literal">Fridge</span> object to. If we call this method with something like <span class="literal">Pizza.from_fridge(myfridge)</span>, it returns a brand-new <span class="literal">Pizza</span> with ingredients taken from what’s available in <span class="literal">myfridge</span>.</p>&#13;
<p class="indent">Any time you write a method that cares only about the class of the object and not about the object’s state, it should be declared as a class method.</p>&#13;
<h3 class="h3" id="lev1sec38"><strong>Abstract Methods</strong></h3>&#13;
<p class="noindent">An <em>abstract method</em> is defined in an abstract base class that may not itself provide any implementation. When a class has an abstract method, it cannot be instantiated. As a consequence, an <em>abstract class</em> (defined as a class that <span epub:type="pagebreak" id="page_111"/>has at least one abstract method) must be used as a parent class by another class. This subclass will be in charge of implementing the abstract method, making it possible to instantiate the parent class.</p>&#13;
<p class="indent">We can use abstract base classes to make clear the relationships between other, connected classes derived from the base class but make the abstract base class itself impossible to instantiate. By using abstract base classes, you can ensure the classes derived from the base class implement particular methods from the base class, or an exception will be raised. The following example shows the simplest way to write an abstract method in Python:</p>&#13;
<p class="programs">class Pizza(object):<br/>    @staticmethod<br/>    def get_radius():<br/>        raise NotImplementedError</p>&#13;
<p class="indent">With this definition, any class inheriting from <span class="literal">Pizza</span> must implement and override the <span class="literal">get_radius()</span> method; otherwise, calling the method raises the exception shown here. This is handy for making sure that each subclass of <span class="literal">Pizza</span> implements its own way of computing and returning its radius.</p>&#13;
<p class="indent">This way of implementing abstract methods has a drawback: if you write a class that inherits from <span class="literal">Pizza</span> but forget to implement <span class="literal">get_radius()</span>, the error is raised only if you try to use that method at runtime. Here’s an example:</p>&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">Pizza()</span><br/>&lt;__main__.Pizza object at 0x7fb747353d90&gt;<br/>&gt;&gt;&gt; <span class="codestrong1">Pizza().get_radius()</span><br/>Traceback (most recent call last):<br/>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br/>  File "&lt;stdin&gt;", line 3, in get_radius<br/>NotImplementedError</p>&#13;
<p class="indent">As <span class="literal">Pizza</span> is directly instantiable, there’s no way to prevent this from happening. One way to make sure you get an early warning about forgetting to implement and override the method, or trying to instantiate an object with abstract methods, is to use Python’s built-in <span class="literal">abc</span> (abstract base classes) module instead, like so:</p>&#13;
<p class="programs">import abc<br/><br/>class BasePizza(object, metaclass=abc.ABCMeta):<br/><br/>    @abc.abstractmethod<br/>    def get_radius(self):<br/>         """Method that should do something."""</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_112"/>The <span class="literal">abc</span> module provides a set of decorators to use on top of methods that will be defined as abstracts and a metaclass to enable this. When you use <span class="literal">abc</span> and its special <span class="literal">metaclass</span>, as shown above, instantiating a <span class="literal">BasePizza</span> or a class inheriting from it that doesn’t override <span class="literal">get_radius()</span> causes a <span class="literal">TypeError</span>:</p>&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">BasePizza()</span><br/>Traceback (most recent call last):<br/>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br/>TypeError: Can't instantiate abstract class BasePizza with abstract methods<br/>get_radius</p>&#13;
<p class="indent">We try to instantiate the abstract <span class="literal">BasePizza</span> class and are immediately told it can’t be done!</p>&#13;
<p class="indent">While using abstract methods doesn’t guarantee that the method is implemented by the user, this decorator helps you catch the error earlier. This is especially handy when you are providing interfaces that must be implemented by other developers; it’s a good documentation hint.</p>&#13;
<h3 class="h3" id="lev1sec39"><strong>Mixing Static, Class, and Abstract Methods</strong></h3>&#13;
<p class="noindent">Each of these decorators is useful on its own, but the time may come when you’ll have to use them together.</p>&#13;
<p class="indent">For example, you could define a factory method as a class method while forcing the implementation to be made in a subclass. In that case, you’d need to have a class method defined as both an abstract method and a class method. This section gives some tips that will help you with that.</p>&#13;
<p class="indent">First, an abstract method’s prototype is not set in stone. When you implement the method, there is nothing stopping you from extending the argument list as you see fit. <a href="ch07.xhtml#ch7list10">Listing 7-10</a> is an example of code in which a subclass extends the signature of the abstract method of its parent.</p>&#13;
<p class="programs">import abc<br/><br/>class BasePizza(object, metaclass=abc.ABCMeta):<br/><br/>    @abc.abstractmethod<br/>    def get_ingredients(self):<br/>         """Returns the ingredient list."""<br/><br/>class Calzone(BasePizza):<br/>    def get_ingredients(self, with_egg=False):<br/>        egg = Egg() if with_egg else None<br/>        return self.ingredients + [egg]</p>&#13;
<p class="listing1"><a id="ch7list10"/><em>Listing 7-10: Using a subclass to extend the signature of the abstract method of its parent</em></p>&#13;
<p class="indent">We define the <span class="literal">Calzone</span> subclass to inherit from the <span class="literal">BasePizza</span> class. We can define the <span class="literal">Calzone</span> subclass’s methods any way we like, as long as they support <span epub:type="pagebreak" id="page_113"/>the interface we define in <span class="literal">BasePizza</span>. This includes implementing the methods as either class or static methods. The following code defines an abstract <span class="literal">get_ingredients()</span> method in the base class and a static <span class="literal">get_ingredients()</span> method in the <span class="literal">DietPizza</span> subclass:</p>&#13;
<p class="programs">import abc<br/><br/>class BasePizza(object, metaclass=abc.ABCMeta):<br/><br/>    @abc.abstractmethod<br/>    def get_ingredients(self):<br/>         """Returns the ingredient list."""<br/><br/>class DietPizza(BasePizza):<br/>    @staticmethod<br/>    def get_ingredients():<br/>        return None</p>&#13;
<p class="indent">Even though our static <span class="literal">get_ingredients()</span> method doesn’t return a result based on the object’s state, it supports our abstract <span class="literal">BasePizza</span> class’s interface, so it’s still valid.</p>&#13;
<p class="indent">It is also possible to use the <span class="literal">@staticmethod</span> and <span class="literal">@classmethod</span> decorators on top of <span class="literal">@abstractmethod</span> in order to indicate that a method is, for example, both static and abstract, as shown in <a href="ch07.xhtml#ch7list11">Listing 7-11</a>.</p>&#13;
<p class="programs">import abc<br/><br/>class BasePizza(object, metaclass=abc.ABCMeta):<br/><br/>    ingredients = ['cheese']<br/><br/>    @classmethod<br/>    @abc.abstractmethod<br/>    def get_ingredients(cls):<br/>         """Returns the ingredient list."""<br/>         return cls.ingredients</p>&#13;
<p class="listing1"><a id="ch7list11"/><em>Listing 7-11: Using a class method decorator with abstract methods</em></p>&#13;
<p class="indent">The abstract method <span class="literal">get_ingredients()</span> needs to be implemented by a subclass, but it’s also a class method, meaning the first argument it will receive will be a class (not an object).</p>&#13;
<p class="indent">Note that by defining <span class="literal">get_ingredients()</span> as a class method in <span class="literal">BasePizza</span> like this, you are not forcing any subclasses to define <span class="literal">get_ingredients()</span> as a class method—it could be a regular method. The same would apply if we had defined it as a static method: there’s no way to force subclasses to implement abstract methods as a specific kind of method. As we have seen, you can change the signature of an abstract method when implementing it in a subclass in any way you like.</p>&#13;
<h4 class="h4" id="lev2sec38"><span epub:type="pagebreak" id="page_114"/><strong><em>Putting Implementations in Abstract Methods</em></strong></h4>&#13;
<p class="noindent">Hold the phone: in <a href="ch07.xhtml#ch7list12">Listing 7-12</a>, we have an implementation <em>in</em> an abstract method. Can we <em>do</em> that? The answer is yes. Python does not have a problem with it! You can put code in your abstract methods and call it using <span class="literal">super()</span>, as demonstrated in <a href="ch07.xhtml#ch7list12">Listing 7-12</a>.</p>&#13;
<p class="programs">import abc<br/><br/>class BasePizza(object, metaclass=abc.ABCMeta):<br/><br/>    default_ingredients = ['cheese']<br/><br/>    @classmethod<br/>    @abc.abstractmethod<br/>    def get_ingredients(cls):<br/>         """Returns the default ingredient list."""<br/>         return cls.default_ingredients<br/><br/>class DietPizza(BasePizza):<br/>    def get_ingredients(self):<br/>        return [Egg()] + super(DietPizza, self).get_ingredients()</p>&#13;
<p class="listing1"><a id="ch7list12"/><em>Listing 7-12: Using an implementation in an abstract method</em></p>&#13;
<p class="indent">In this example, every <span class="literal">Pizza</span> you make that inherits from <span class="literal">BasePizza</span> has to override the <span class="literal">get_ingredients()</span> method, but every <span class="literal">Pizza</span> also has access to the base class’s default mechanism for getting the ingredients list. This mechanism is especially useful when providing an interface to implement while also providing base code that might be useful to all inheriting classes.</p>&#13;
<h4 class="h4" id="lev2sec39"><strong><em>The Truth About super</em></strong></h4>&#13;
<p class="noindent">Python has always allowed developers to use both single and multiple inheritances to extend their classes, but even today, many developers do not seem to understand how these mechanisms, and the <span class="literal">super()</span> method that is associated with them, work. To fully understand your code, you need to understand the trade-offs.</p>&#13;
<p class="indent">Multiple inheritances are used in many places, particularly in code involving a mixin pattern. A <em>mixin</em> is a class that inherits from two or more other classes, combining their features.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Many of the pros and cons of single and multiple inheritances, composition, or even duck typing are out of scope for this book, so we won’t cover everything here. If you are not familiar with these notions, I suggest you read about them to form your own opinions.</em></p>&#13;
</div>&#13;
<p class="indent">As you should know by now, classes are objects in Python. The construct used to create a class is a special statement that you should be well familiar with: <span class="literal"><span class="codeitalic">class classname</span>(<span class="codeitalic">expression of inheritance</span>)</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_115"/>The code in parentheses is a Python expression that returns the list of class objects to be used as the class’s parents. Ordinarily, you would specify them directly, but you could also write something like this to specify the list of parent objects:</p>&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">def parent():</span><br/>...     <span class="codestrong1">return object</span><br/>...<br/>&gt;&gt;&gt; <span class="codestrong1">class A(parent()):</span><br/>...     <span class="codestrong1">pass</span><br/>...<br/>&gt;&gt;&gt; <span class="codestrong1">A.mro()</span><br/>[&lt;class '__main__.A'&gt;, &lt;type 'object'&gt;]</p>&#13;
<p class="indent">This code works as expected: we declare class <span class="literal">A</span> with <span class="literal">object</span> as its parent class. The class method <span class="literal">mro()</span> returns the <em>method resolution order</em> used to resolve attributes—it defines how the next method to call is found via the tree of inheritance between classes. The current MRO system was first implemented in Python 2.3, and its internal workings are described in the Python 2.3 release notes. It defines how the system browses the tree of inheritance between classes to find the method to call.</p>&#13;
<p class="indent">We already saw that the canonical way to call a method in a parent class is to use the <span class="literal">super()</span> function, but what you probably don’t know is that <span class="literal">super()</span> is actually a constructor and you instantiate a <span class="literal">super</span> object each time you call it. It takes either one or two arguments: the first argument is a class, and the second, optional argument is either a subclass or an instance of the first argument.</p>&#13;
<p class="indent">The object returned by the constructor functions as a proxy for the parent classes of the first argument. It has its own <span class="literal">__getattribute__</span> method that iterates over the classes in the MRO list and returns the first matching attribute it finds. The <span class="literal">__getattribute__</span> method is called when an attribute of the <span class="literal">super()</span> object is retrieved, as shown in <a href="ch07.xhtml#ch7list13">Listing 7-13</a>.</p>&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">class A(object):</span><br/>...     <span class="codestrong1">bar = 42</span><br/>...     <span class="codestrong1">def foo(self):</span><br/>...             <span class="codestrong1">pass</span><br/>...<br/>&gt;&gt;&gt; <span class="codestrong1">class B(object):</span><br/>...     <span class="codestrong1">bar = 0</span><br/>...<br/>&gt;&gt;&gt; <span class="codestrong1">class C(A, B):</span><br/>...     <span class="codestrong1">xyz = 'abc'</span><br/>...<br/>&gt;&gt;&gt; <span class="codestrong1">C.mro()</span><br/>[&lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class '__main__.B'&gt;, &lt;type 'object'&gt;]<br/>&gt;&gt;&gt; <span class="codestrong1">super(C, C()).bar</span><br/>42<br/>&gt;&gt;&gt; <span class="codestrong1">super(C, C()).foo</span><br/>&lt;bound method C.foo of &lt;__main__.C object at 0x7f0299255a90&gt;&gt;<br/>&gt;&gt;&gt; <span class="codestrong1">super(B).__self__</span><span epub:type="pagebreak" id="page_116"/><br/>&gt;&gt;&gt; <span class="codestrong1">super(B, B()).__self__</span><br/>&lt;__main__.B object at 0x1096717f0&gt;</p>&#13;
<p class="listing1"><a id="ch7list13"/><em>Listing 7-13: The <span class="codeitalic">super()</span> function is a constructor that instantiates a <span class="codeitalic">super</span> object.</em></p>&#13;
<p class="indent">When requesting an attribute of the <span class="literal">super</span> object of an instance of <span class="literal">C</span>, the <span class="literal">__getattribute__</span> method of the <span class="literal">super()</span> object walks through the MRO list and returns the attribute from the first class it finds that has the <span class="literal">super</span> attribute.</p>&#13;
<p class="indent">In <a href="ch07.xhtml#ch7list13">Listing 7-13</a>, we called <span class="literal">super()</span> with two arguments, meaning we used a <em>bound</em> <span class="literal">super</span> object. If we call <span class="literal">super()</span> with only one argument, it returns an <em>unbound</em> <span class="literal">super</span> object instead:</p>&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">super(C)</span><br/>&lt;super: &lt;class 'C'&gt;, NULL&gt;</p>&#13;
<p class="indent">Since no instance has been provided as the second argument, the <span class="literal">super</span> object cannot be bound to any instance. Therefore, you cannot use this unbound object to access class attributes. If you try, you’ll get the following errors:</p>&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">super(C).foo</span><br/>Traceback (most recent call last):<br/>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br/>AttributeError: 'super' object has no attribute 'foo'<br/>&gt;&gt;&gt; <span class="codestrong1">super(C).bar</span><br/>Traceback (most recent call last):<br/>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br/>AttributeError: 'super' object has no attribute 'bar'<br/>&gt;&gt;&gt; <span class="codestrong1">super(C).xyz</span><br/>Traceback (most recent call last):<br/>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br/>AttributeError: 'super' object has no attribute 'xyz'</p>&#13;
<p class="indent">At first glance, it might seem like this unbound kind of <span class="literal">super</span> object is useless, but actually the way the <span class="literal">super</span> class implements the descriptor protocol <span class="literal">__get__</span> makes unbound <span class="literal">super</span> objects useful as class attributes:</p>&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">class D(C):</span><br/>...     <span class="codestrong1">sup = super(C)</span><br/>...<br/>&gt;&gt;&gt; <span class="codestrong1">D().sup</span><br/>&lt;super: &lt;class 'C'&gt;, &lt;D object&gt;&gt;<br/>&gt;&gt;&gt; <span class="codestrong1">D().sup.foo</span><br/>&lt;bound method D.foo of &lt;__main__.D object at 0x7f0299255bd0&gt;&gt;<br/>&gt;&gt;&gt; <span class="codestrong1">D().sup.bar</span><br/>42</p>&#13;
<p class="indent">The unbound <span class="literal">super</span> object’s <span class="literal">__get__</span> method is called using the instance <span class="literal">super(C).__get__(D())</span> and the attribute name <span class="literal">'foo'</span> as arguments, allowing it to find and resolve <span class="literal">foo</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><span epub:type="pagebreak" id="page_117"/><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Even if you’ve never heard of the descriptor protocol, it’s likely you’ve used it through the <span class="codeitalic">@property</span> decorator without knowing it. The <span class="roman">descriptor protocol</span> is the mechanism in Python that allows an object stored as an attribute to return something other than itself. This protocol is not covered in this book, but you can find out more about it in the Python data model documentation.</em></p>&#13;
</div>&#13;
<p class="indent">There are plenty of situations in which using <span class="literal">super()</span> can be tricky, such as when handling different method signatures along the inheritance chain. Unfortunately, there’s no silver bullet for all occasions. The best precaution is to use tricks such as having all your methods accept their arguments using <span class="literal">*args, **kwargs</span>.</p>&#13;
<p class="indent">Since Python 3, <span class="literal">super()</span> has picked up a bit of magic: it can now be called from within a method without any arguments. When no arguments are passed to <span class="literal">super()</span>, it automatically searches the stack frame for arguments:</p>&#13;
<p class="programs">class B(A):<br/>      def foo(self):<br/>          super().foo()</p>&#13;
<p class="indent">The standard way of accessing parent attributes in subclasses is <span class="literal">super()</span>, and you should always use it. It allows cooperative calls of parent methods without any surprises, such as parent methods not being called or being called twice when multiple inheritances are used.</p>&#13;
<h3 class="h3" id="lev1sec40"><strong>Summary</strong></h3>&#13;
<p class="noindent">Equipped with what you learned in this chapter, you should be unbeatable on everything that concerns methods definition in Python. Decorators are essential when it comes to code factorization, and proper use of the built-in decorators provided by Python can vastly improve the neatness of your Python code. Abstract classes are especially useful when providing an API to other developers and services.</p>&#13;
<p class="indent">Class inheritance is not often fully understood, and having an overview of the internal machinery of the language is a good way to fully apprehend how this works. There should be no secrets left on this topic for you now!</p>&#13;
</body></html>