- en: '**14'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**14'
- en: MAPPING MARS WITH THE MARS ORBITER**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 用*火星轨道探测器*绘制火星地图**
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: The *Mars Orbiter* space probe has been successfully injected into Martian orbit,
    but all is not well. The orbit is highly elliptical, and the project’s mapping
    objectives require a low-altitude circular orbit. Fortunately, there’s just enough
    propellant on board to correct things, assuming the eggheads at Mission Control
    have the patience and skill to pull it off!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*火星轨道探测器*已经成功进入火星轨道，但情况并不理想。轨道非常椭圆，而该项目的地图绘制目标要求低高度的圆形轨道。幸运的是，探测器上有足够的推进剂来进行轨道修正，前提是任务控制中心的专家们有耐心和技能来完成这项工作！'
- en: In this chapter, you’ll design and build a game based on this scenario. You’ll
    use pygame again (for an overview of pygame, see “[A Slice of pygame](ch13.xhtml#lev296)”
    on [page 267](ch13.xhtml#page_267)), and you’ll do your part to advance STEM (science,
    technology, engineering, and mathematics) education by making the game real enough
    to teach players the fundamentals of orbital mechanics.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你将基于这个情景设计和构建一个游戏。你将再次使用pygame（关于pygame的概述，请参阅[《pygame概述》](ch13.xhtml#lev296)，见[第267页](ch13.xhtml#page_267)），并通过使游戏足够逼真来推动STEM（科学、技术、工程和数学）教育，教会玩家轨道力学的基础。
- en: '**NOTE**'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Although they share the same name, the* Mars Orbiter *space probe in the game
    bears no direct relationship to the* Mars Orbiter Mission *launched by the* Indian
    Space Research Organization (ISRO) *in 2014\. The game probe is patterned after
    the* Mars Global Surveyor*, launched by NASA in 1996.*'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*尽管它们共享相同的名称，游戏中的*火星轨道探测器*与2014年由*印度空间研究组织（ISRO）*发射的*火星轨道任务*没有直接关系。游戏中的探测器是仿照1996年由NASA发射的*火星全球勘测者*设计的。*'
- en: '**Astrodynamics for Gamers**'
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**游戏中的天体动力学**'
- en: Because you’ll want your game to be as realistic as possible, a quick review
    of some of the basic science underlying spaceflight is in order. This will be
    short, sweet, and tailored to game development and play.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你希望你的游戏尽可能逼真，所以有必要快速回顾一下航天飞行的基本科学。这将简短、精炼，并且与游戏开发和游戏玩法密切相关。
- en: '***The Law of Universal Gravity***'
  id: totrans-9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***万有引力定律***'
- en: 'The theory of gravity states that massive objects—like stars and planets—warp
    both space and time around them, similar to how a heavy bowling ball placed on
    a mattress causes a depression that is sudden and sharp near the ball but quickly
    levels off. This behavior is captured mathematically by Isaac Newton’s law of
    universal gravitation:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 万有引力理论认为，像恒星和行星这样的大质量物体会扭曲它们周围的时空，类似于将一个沉重的保龄球放在床垫上，床垫会在球附近产生一个突然而深的凹陷，但凹陷会迅速平坦化。这种行为由艾萨克·牛顿的万有引力定律数学化描述：
- en: '![image](../images/f0286-01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0286-01.jpg)'
- en: where *F* is the force of gravity, *m*[1] is the mass of object 1, *m*[2] is
    the mass of object 2, *d* is the distance between objects, and *G* is the gravitational
    constant (6.674 × 10^(–11) *N* · *m*² · kg^(–2)).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*F*是引力，*m*[1]是物体1的质量，*m*[2]是物体2的质量，*d*是物体之间的距离，*G*是引力常数（6.674 × 10^(–11) *N*
    · *m*² · kg^(–2)）。
- en: Two objects pull on each other according to the product of their masses divided
    by the square of the distance between them. So, gravity is much stronger when
    objects are close together, like the deep bowing of the mattress just beneath
    the bowling ball. To illustrate, a 220-pound (100 kg) man would weigh over half
    a pound less on top of Mt. Everest than he would at sea level, where he would
    be 8,848 m closer to the center of Earth. (This assumes the mass of the planet
    is 5.98 × 10^(24) kg and sea level is 6.37 × 10⁶ m from the center.)
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 两个物体会根据它们的质量乘积与它们之间距离的平方之比相互作用。因此，当物体靠得很近时，引力会更强，就像保龄球下方床垫的深凹。举个例子，一个220磅（100公斤）的人在珠穆朗玛峰上的体重比在海平面时轻半磅多，因为他距离地球中心近了8,848米。（假设地球的质量为5.98
    × 10^(24)公斤，海平面距离地球中心为6.37 × 10⁶米。）
- en: Today, we generally think of gravity as a *field*—like the mattress in the bowling
    ball analogy—rather than as Newton’s point of attraction. This field is still
    defined with Newton’s law and results in *acceleration*, usually expressed in
    m/sec².
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，我们通常将引力视为一个*场*—就像保龄球床垫类比中的床垫—而不是牛顿的吸引点。这个场仍然用牛顿定律定义，并导致*加速度*，通常以米/秒²表示。
- en: 'According to Newton’s second law of motion, force is equal to mass × acceleration.
    You can calculate the force exerted by object 1 (*m*[1]) on object 2 (*m*[2])
    by rewriting the gravitational equation as:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 根据牛顿的第二运动定律，力等于质量×加速度。你可以通过将引力方程改写为以下形式，来计算物体1（*m*[1]）对物体2（*m*[2]）施加的力：
- en: '![image](../images/f0286-02.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0286-02.jpg)'
- en: where *a* = acceleration, *G* is the gravitational constant, *m*[1] is the mass
    of one of the objects, and *d* is the distance between objects. The direction
    of force is from object 2 toward the center of mass of object 1 (*m*[1]).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *a* = 加速度，*G* 是引力常数，*m*[1] 是其中一个物体的质量，*d* 是物体之间的距离。力的方向是从物体 2 指向物体 1 的质心（*m*[1]）。
- en: The pull of very small objects on large ones is generally ignored. For example,
    the force exerted by a 1,000 kg satellite on Mars is about 1.6 × 10^(–21) times
    smaller than the force exerted by Mars on the satellite! Thus, you can safely
    ignore the satellite’s mass in your simulation.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 小物体对大物体的引力通常被忽略。例如，一个质量为 1000 千克的卫星对火星施加的引力约为火星对卫星施加引力的 1.6 × 10^(–21) 倍！因此，在你的模拟中，你可以安全地忽略卫星的质量。
- en: '**NOTE**'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*As a simplification in this project, distance is calculated from the center
    points of objects. In real life, an orbiting satellite would experience subtle
    changes in gravitational acceleration due to changes in a planet’s shape, topography,
    crustal density, and so on. According to the* Encyclopedia Britannica*, these
    changes cause gravitational acceleration at Earth’s surface to vary by about 0.5
    percent.*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*作为本项目的简化，距离是从物体的质心计算的。在现实中，绕行卫星会由于行星的形状、地形、地壳密度等变化而经历微妙的引力加速度变化。根据* 《大英百科全书》*，这些变化导致地球表面的引力加速度变化约为
    0.5%。*'
- en: '***Kepler’s Laws of Planetary Motion***'
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***开普勒行星运动定律***'
- en: In 1609, astronomer Johann Kepler discovered that planetary orbits are ellipses,
    allowing him to explain and predict the motion of the planets. He also found that
    a line segment drawn between the sun and an orbiting planet sweeps out equal areas
    in equal time intervals. This idea, known as Kepler’s second law of planetary
    motion, is demonstrated in [Figure 14-1](ch14.xhtml#ch14fig1), where a planet
    is shown at different points in its orbit.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 1609 年，天文学家约翰·开普勒发现行星的轨道是椭圆形的，这使他能够解释和预测行星的运动。他还发现，太阳与绕行行星之间画出的线段在相等的时间间隔内扫过相等的面积。这一观点被称为开普勒行星运动第二定律，示意图在
    [图 14-1](ch14.xhtml#ch14fig1) 中展示，其中展示了行星在其轨道上的不同位置。
- en: '![image](../images/f0287-01.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0287-01.jpg)'
- en: '*Figure 14-1: Kepler’s second law of planetary motion: orbital speed increases
    as planets near the sun.*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-1：开普勒行星运动第二定律：行星靠近太阳时轨道速度增加。*'
- en: This law applies to all celestial bodies, and it means that an orbiting object
    speeds up as it gets close to the body it is orbiting and slows down as it travels
    farther away.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这一定律适用于所有天体，这意味着当绕行一个天体时，物体会在接近该天体时加速，而在远离时减速。
- en: '***Orbital Mechanics***'
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***轨道力学***'
- en: Orbiting is basically free-falling forever. You’re falling into the core of
    a planet’s gravity well—located at its literal core—but your tangential velocity
    is fast enough that you keep missing the planet (see [Figure 14-2](ch14.xhtml#ch14fig2)).
    As long as you balance your momentum with the force of gravity, the orbit will
    never end.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 绕行基本上是永远自由下落。你正在掉入一个行星的引力井——位于它的核心——但是你的切向速度足够快，以至于你不断错过行星（参见 [图 14-2](ch14.xhtml#ch14fig2)）。只要你平衡好你的动量和引力，轨道将永远不会结束。
- en: '![image](../images/f0288-01.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0288-01.jpg)'
- en: '*Figure 14-2: Orbit is achieved when a spacecraft’s velocity keeps it “free-falling”
    around a celestial body.*'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-2：当航天器的速度使其“自由下落”绕行天体时，便达成了轨道。*'
- en: Some counterintuitive things can happen when you orbit a planet in the vacuum
    of space. With no friction or wind resistance, spacecraft can behave in unexpected
    ways.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在太空的真空中绕行一个行星时，有些反直觉的现象可能发生。由于没有摩擦或风阻，航天器可能会表现出意想不到的方式。
- en: '**Flying Backward**'
  id: totrans-31
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**向后飞行**'
- en: If you’ve ever watched an episode of *Star Trek*, you’ve probably noticed how
    the orbiting *Enterprise* seems to steer its way around planets, like a car going
    around a track. This is certainly possible to do—and definitely looks cool—but
    it requires the expenditure of precious fuel. If there’s no need to continuously
    point a specific part of a spacecraft at a planet, then the nose of the spacecraft
    will always point in the same direction throughout its orbit. As a result, there
    will be times in each orbit when it appears to fly backward (see [Figure 14-3](ch14.xhtml#ch14fig3)).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0288-02.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-3: Spacecraft retain the same attitude in orbit unless forced to
    do otherwise.*'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: You can blame this on Newton and his law of inertia, which states that an object
    at rest stays at rest and an object in motion stays in motion with the same speed
    and in the same direction unless acted upon by an unbalanced force.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '**Raising and Lowering Orbits**'
  id: totrans-36
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Brakes don’t work in space, there’s no friction, and inertia takes itself very
    seriously. To lower a spacecraft’s orbit, you have to fire thrusters to reduce
    its velocity so that it falls farther into a planet’s gravity well. To accomplish
    this, you have to *retrograde* your spacecraft so that its nose faces away from
    the present velocity vector—a fancy way of saying you have to fly tail-first.
    This assumes, of course, that the main thrusters are at the back of the spacecraft.
    Conversely, if you want to raise the orbit, you have to *prograde* the spacecraft,
    so that its nose will be pointed in the direction you are traveling. These two
    concepts are shown in [Figure 14-4](ch14.xhtml#ch14fig4).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0289-01.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-4: Prograde and retrograde are defined by the orientation of a spacecraft’s
    nose with respect to the direction it is traveling around the body it is orbiting.*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '**Taking the Inside Track**'
  id: totrans-40
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you’re chasing another spacecraft in orbit, do you speed up or slow down
    to catch it? According to Kepler’s second law, you slow down. This will lower
    your orbit, resulting in a faster orbital velocity. Just as in horse racing, you
    want to take the inside track.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: On the left side of [Figure 14-5](ch14.xhtml#ch14fig5), two space shuttles are
    side by side in essentially the same orbit, traveling at the same velocity.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0289-02.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-5: The orbital paradox: slow down to speed up!*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: The shuttle closest to the planet rotates 180 degrees and does a retrograde
    thrust to slow its immediate velocity. The outer shuttle performs a prograde thrust
    that increases its immediate velocity. They simultaneously stop thrusting, and
    the inner shuttle drops to a lower orbit while the outer shuttle transfers to
    a higher orbit. After an hour or so, the inner shuttle is traveling much faster,
    due to its closer proximity to the planet, and is well on its way to catch and
    lap the outer shuttle.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '**Circularizing an Elliptical Orbit**'
  id: totrans-46
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You can make highly elliptical orbits circular by applying engine impulses at
    either the *apoapsis* or *periapsis*, depending on the situation. The apoapsis
    (called the *apogee* if the object is orbiting Earth) is the highest point in
    an elliptical orbit—the point where the object is the farthest away from the body
    it is orbiting ([Figure 14-6](ch14.xhtml#ch14fig6)). The periapsis (*perigee*
    if the object’s orbiting Earth) is the point lowest in an orbit.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在*远地点*或*近地点*施加发动机脉冲，将高度椭圆轨道转为圆形轨道，这取决于具体情况。远地点（如果物体绕地球运行，则称为*远地点*）是椭圆轨道中最高的点——即物体距离其轨道中心最远的点（见[图14-6](ch14.xhtml#ch14fig6)）。近地点（如果物体绕地球运行，则称为*近地点*）是轨道中最低的点。
- en: '![image](../images/f0290-01.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0290-01.jpg)'
- en: '*Figure 14-6: Location of the apoapsis and periapsis in an elliptical orbit*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-6：椭圆轨道中远地点和近地点的位置*'
- en: To raise the periapsis, the spacecraft performs a prograde thrust at the apoapsis
    (see the left-hand side of [Figure 14-7](ch14.xhtml#ch14fig7)). To lower the orbit
    while circularizing, the spacecraft must perform a retrograde thrust at the periapsis
    (see the right-hand side of [Figure 14-7](ch14.xhtml#ch14fig7)).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要升高近地点，宇航器在远地点执行顺行推力（参见[图14-7](ch14.xhtml#ch14fig7)左侧）。为了在环形化的同时降低轨道，宇航器必须在近地点执行逆行推力（参见[图14-7](ch14.xhtml#ch14fig7)右侧）。
- en: A somewhat counterintuitive part of this maneuver is that the initial orbit—that’s
    the orbit that would have been—and the final, or actual, orbit will coincide at
    the point the engine impulse was applied.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作中一个有些反直觉的部分是，初始轨道——即原本会存在的轨道——与最终轨道（实际轨道）会在发动机脉冲施加的点相交。
- en: '![image](../images/f0290-02.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0290-02.jpg)'
- en: '*Figure 14-7: Circularizing and raising an orbit at apoapsis (left) and circularizing
    and lowering an orbit at periapsis (right)*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-7：在远地点升高并环形化轨道（左）与在近地点降低并环形化轨道（右）*'
- en: '**Raising and Lowering Orbits with the Hohmann Transfer**'
  id: totrans-54
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用霍曼转移轨道升高和降低轨道**'
- en: A *Hohmann transfer orbit* uses an elliptical orbit to switch between two circular
    orbits in the same plane (see [Figure 14-8](ch14.xhtml#ch14fig8)). The orbit can
    be either raised or lowered. The maneuver is relatively slow, but it consumes
    the least possible amount of fuel.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*霍曼转移轨道*使用椭圆轨道在同一平面内切换两个圆形轨道（见[图14-8](ch14.xhtml#ch14fig8)）。轨道可以升高或降低。该操作相对较慢，但消耗的燃料最少。'
- en: To change to an orbit with both a different periapsis *and* apoapsis, a spacecraft
    requires two engine impulses. One impulse moves the spacecraft onto the transfer
    orbit, and another moves it onto the final, destination orbit. When raising an
    orbit, the spacecraft applies the change in velocity in the direction of motion,
    and when lowering an orbit, it applies the change of velocity opposite to the
    direction of motion. The velocity changes have to occur at opposite sides of the
    orbit, as shown in [Figure 14-8](ch14.xhtml#ch14fig8). Without the second thrust,
    the orbits will still intersect at the point of the first thrust, as shown on
    the right side of [Figure 14-7](ch14.xhtml#ch14fig7).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要改变一个轨道，使其具有不同的近地点*和*远地点，宇航器需要两次发动机脉冲。一脉冲将宇航器推入转移轨道，另一脉冲则将其推入最终的目的轨道。当升高轨道时，宇航器将在运动方向上施加速度变化；而当降低轨道时，速度变化则是施加在与运动方向相反的方向上。速度变化必须发生在轨道的对侧，如[图14-8](ch14.xhtml#ch14fig8)所示。如果没有第二次推力，轨道仍会在第一次推力点相交，如[图14-7](ch14.xhtml#ch14fig7)右侧所示。
- en: '![image](../images/f0291-01.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0291-01.jpg)'
- en: '*Figure 14-8: Transferring to a lower circular orbit with the Hohmann transfer
    technique*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-8：使用霍曼转移技术转移至较低的圆形轨道*'
- en: '**Raising and Lowering Orbits with the One-Tangent Burn**'
  id: totrans-59
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用单切线燃烧升高和降低轨道**'
- en: The *One-Tangent Burn* technique transfers a spacecraft between orbits faster
    but less efficiently than a Hohmann transfer. A *burn* is just another term for
    thrust or impulse. As with the Hohmann transfer, orbits can be either raised or
    lowered.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*单切线燃烧*技术比霍曼转移轨道更快速，但效率较低，用于在轨道之间快速转换。*燃烧*只是推力或脉冲的另一种术语。与霍曼转移轨道相同，轨道可以升高或降低。'
- en: The maneuver requires two engine impulses, the first tangential to the orbit
    and the second nontangential (see [Figure 14-9](ch14.xhtml#ch14fig9)). If the
    initial orbit is circular, as in the figure, then all points along it represent
    both the apoapsis and the periapsis, and the spacecraft can apply its first burn
    at any time.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0291-02.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Transferring to a higher circular orbit with the One-Tangent
    Burn*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Just as with the Hohmann transfer, a prograde burn raises the orbit, and a retrograde
    burn lowers it. If the orbit is elliptical, the first burn would be a prograde
    burn at the apoapsis to raise the orbit, or a retrograde burn at periapsis to
    lower it.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '**Executing a Spiral Orbit with the Spiral Transfer**'
  id: totrans-65
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A *spiral transfer* uses a continuous, low-thrust burn to change the size of
    an orbit. In gameplay, you can simulate this using retrograde or prograde burns
    that are short and regularly spaced, like those shown in [Figure 14-10](ch14.xhtml#ch14fig10).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0292-01.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Executing a spiral orbit using short retrograde burns at regular
    intervals*'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: To lower an orbit, all the burns must be retrograde; to raise an orbit, the
    spacecraft uses prograde burns.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '**Executing Synchronous Orbits**'
  id: totrans-70
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In a *synchronous orbit*, a spacecraft takes the same amount of time to make
    one revolution around a planet as it takes the planet to make one rotation around
    its axis. If a synchronous orbit is parallel to the equator, with no orbital inclination,
    it is a *stationary* orbit; to an observer on the orbited body, the satellite
    appears motionless in a fixed position in the sky. Communications satellites commonly
    use *geostationary* orbits, which have an altitude of 22,236 miles around Earth.
    A similar orbit would be called *aerostationary* around Mars and *selenostationary*
    around the moon.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '**Project #22: The Mars Orbiter Game**'
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In real life, a series of equations is used to precisely execute orbital maneuvers.
    In gameplay, you’ll use your intuition, patience, and reflexes! You’ll also need
    to fly by instruments to a certain extent, using mainly the spacecraft’s altitude
    readout and a measure of the orbit’s circularity.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '**THE OBJECTIVE**'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Use pygame to build an arcade game that teaches the fundamentals of orbital
    mechanics. The game’s goal is to nudge a satellite into a circular mapping orbit
    without running out of fuel or burning up in the atmosphere.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '**The Strategy**'
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Start the design phase with a game sketch, as you did in [Chapter 13](ch13.xhtml#ch13).
    This sketch should capture all of the salient points of the game, like how it
    will look, how it will sound, how things will move, and how the game will communicate
    with the player ([Figure 14-11](ch14.xhtml#ch14fig11)).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0293-01.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Sketch of the main gameplay of the Mars Orbiter game*'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'The sketch in [Figure 14-11](ch14.xhtml#ch14fig11) describes the main gameplay.
    You’ll need a separate sketch to describe the win-lose conditions. For the main
    gameplay, the key points are:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 14-11](ch14.xhtml#ch14fig11)中的示意图描述了主要的游戏玩法。你需要一个单独的示意图来描述胜负条件。对于主要的游戏玩法，关键点是：'
- en: '**The viewpoint is Mission Control.** The game screen should resemble a monitor
    at Mission Control from which the player can operate the errant space probe.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视角是任务控制中心。** 游戏画面应该像任务控制中心的显示器，玩家可以通过它操作出轨的太空探测器。'
- en: '**Mars is at front and center.** Everybody loves the Red Planet, so it will
    occupy the center of the jet-black screen.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**火星位于屏幕的正中央。** 大家都喜欢红色星球，所以它将占据漆黑屏幕的中央位置。'
- en: '**Mars is animated.** The Martian globe will slowly rotate around its axis
    and cast a shadow. The satellite will dim appreciably when it passes through this
    shadow.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**火星是动态的。** 火星的地球仪会缓慢围绕其轴旋转并投下阴影。卫星在经过阴影时会明显变暗。'
- en: '**The satellite’s initial orbit is chosen at random.** The satellite will appear
    at startup with a randomized—but constrained—orientation and velocity. On rare
    occasions, this may result in an instant game loss. That’s still better than real
    missions, which fail 47 percent of the time!'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**卫星的初始轨道是随机选择的。** 卫星在启动时会以随机但受限制的方位和速度出现。偶尔，这可能会导致即时的游戏失败。但这比实际任务要好，因为实际任务有47%的失败率！'
- en: '**There’s no need to prograde or retrograde the satellite.** Constantly rotating
    the space probe before firing its thrusters greatly diminishes gameplay. Assume
    that attitudinal thrusters are arrayed around the fuselage and use the arrow keys
    to choose which thrusters to fire.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不需要调整卫星的轨道方向。** 在发射推进器之前不断旋转太空探测器会极大地减少游戏的趣味性。假设姿态推进器围绕机身排列，玩家可以使用箭头键选择要发射的推进器。'
- en: '**Firing thrusters causes an audible hiss.** Despite the fact that there’s
    no sound in space, give the player the satisfaction of hearing a nice hiss whenever
    they fire the thrusters.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发射推进器会产生可听的嘶嘶声。** 尽管太空中没有声音，但每当玩家发射推进器时，会给玩家带来听到嘶嘶声的满足感。'
- en: '**The satellite dish always points toward Mars.** The satellite will slowly
    and automatically rotate so that its remote-sensing dish is always aimed at Mars.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**卫星的天线始终指向火星。** 卫星会缓慢自动旋转，使其遥感天线始终指向火星。'
- en: '**The satellite’s orbital path is visible.** A thin white line will trail out
    from behind the satellite and persist until the player clears it by pressing the
    space bar.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**卫星的轨道路径是可见的。** 一条细白线将从卫星后方延伸出来，并在玩家按下空格键清除之前持续显示。'
- en: '**The data readouts are placed at the top of the screen.** You will display
    information useful for gameplay in boxes at the top of the window. Key data are
    the space probe’s velocity, altitude, fuel, and orbital eccentricity (a measure
    of the orbit’s circularity).'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据读数位于屏幕顶部。** 你将把对游戏玩法有用的信息显示在屏幕顶部的框中。关键信息包括太空探测器的速度、海拔、高度和轨道偏心率（即轨道的圆形度度量）。'
- en: '**A short introduction is shown at startup.** Text introducing the game will
    appear at the center of the screen when the game starts and stay up for about
    15 seconds. The text will not disrupt gameplay, so the player can start manipulating
    the satellite immediately.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**启动时会显示简短的介绍。** 游戏开始时，屏幕中央会显示介绍文本，持续约15秒。该文本不会干扰游戏玩法，玩家可以立即开始操控卫星。'
- en: '**Win conditions and key controls are shown in permanent legends.** Critical
    information, like mission objectives and control keys, will be displayed permanently
    in the lower-left and -right corners of the screen.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**胜利条件和关键控制显示在永久的图例中。** 关键信息，如任务目标和控制键，将永久显示在屏幕的左下角和右下角。'
- en: The game sketch in [Figure 14-12](ch14.xhtml#ch14fig12) describes what happens
    in success and failure cases. The player needs a reward when they win and an interesting
    outcome when they lose.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 14-12](ch14.xhtml#ch14fig12)中的游戏示意图描述了成功和失败的情况。玩家在获胜时需要奖励，而在失败时则需要一个有趣的结果。'
- en: '![image](../images/f0295-01.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0295-01.jpg)'
- en: '*Figure 14-12: Game sketch of winning versus losing outcomes in the Mars Orbiter
    game*'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-12：火星探测器游戏中胜利与失败结果的游戏示意图*'
- en: 'For winning and losing outcomes, the key points are:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 胜利和失败的结果中，关键点是：
- en: '**Change the satellite image for crash and burn.** If the satellite’s altitude
    drops below 68 miles, it burns up in the atmosphere. The moving satellite image
    will be replaced with a glowing red version that sticks to the side of Mars; this
    is similar to something you might see on a real Mission Control display.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The satellite is lost in space if it runs out of fuel.** Although unrealistic,
    have the satellite fly off the screen and into the depths of space if it runs
    out of fuel. This really rubs the player’s nose in it!'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Win conditions unlock a prize.** If the satellite achieves a circular orbit
    within the target altitude range, new text will urge the player to press the M
    key.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pressing M changes the Mars image.** When the M key is unlocked, pressing
    it causes the Mars image to change to a rainbow image where cool colors represent
    areas of high soil moisture and warm colors represent drier areas.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For gameplay, the size of the satellite and its orbital speed won’t be realistic,
    but the overall behavior will be correct. You should be able to correctly execute
    all of the orbital maneuvers described in “[Astrodynamics for Gamers](ch14.xhtml#lev315)”
    on [page 286](ch14.xhtml#page_286).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '**Game Assets**'
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The assets you’ll need for the Mars Orbiter game are two satellite images, two
    planet images, and a sound file. You can prepare these together at the start of
    the process or build them when you need them. The latter approach lets you take
    episodic breaks from coding, which some people prefer.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Finding good, copyright-free graphics and sound files can be a challenge. You
    can find suitable assets online—either for free or for a fee—but it’s best to
    make your own whenever possible. This lets you avoid any legal issues down the
    road.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: The sprites (2D icons or images) I used for this project are shown in [Figure
    14-13](ch14.xhtml#ch14fig13). You need a satellite, a red “burned” version of
    the satellite, a view of Mars with a polar cap centered, and the same view with
    a colorful overlay that will represent mapped soil-moisture gradations. I found
    the satellite sprite at the free icon site AHA-SOFT (*[http://www.aha-soft.com/](http://www.aha-soft.com/)*)
    and then copied and recolored it to make the crashed version. Both of the Mars
    sprites are NASA images modified for the game.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0296-01.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The satellite, crashed satellite, Mars, and Mars overlay images
    used as game sprites*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: I made a sound file for when the satellite is firing its thrusters using the
    white noise generator in the open source program Audacity. You can download a
    free copy of Audacity at *[https://www.audacityteam.org/](https://www.audacityteam.org/)*.
    I saved the file in *Ogg Vorbis* format, an open source standard audio compression
    format that is free and works well with Python and pygame. You can use other formats,
    like MP3 and WAV, with pygame, but some have documented problems or have proprietary
    components that can raise legal issues if you try to commercialize your game.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: You can download these files from this book’s website at *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*
    as *satellite.png*, *satellite_crash_40x33.png*, *mars.png*, *mars_water.png*,
    and *thrust_audio.ogg*. Download them, preserving the filenames, into the same
    folder as the code.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '**The Code**'
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Figure 14-14](ch14.xhtml#ch14fig14) is an example of the final game screen
    you’ll be building. You can refer back to this figure to get an idea of what the
    code is doing.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0297-01.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-14: Example startup game screen for the final version of* mars_orbiter.py'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: You can download the complete program (*mars_orbiter.py*) at *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '***Importing and Building a Color Table***'
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 14-1](ch14.xhtml#ch14list1) imports the required modules and builds
    a color table.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '*mars_orbiter.py,* part 1'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: ➊ import os
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: import math
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: import random
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: import pygame as pg
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: ➋ WHITE = (255, 255, 255)
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: BLACK = (0, 0, 0)
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: RED = (255, 0, 0)
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: GREEN = (0, 255, 0)
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: LT_BLUE = (173, 216, 230)
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 14-1: Imports modules and builds a color table*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: First, import the operating system, designated by os ➊. The game will launch
    in full-screen mode, but the player will have the option of escaping out of full
    screen. This module will let you control the location of the game window after
    the player presses ESC.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: You’ll use the math module for gravity and trigonometric calculations and random
    to start the satellite off with a random position and velocity. Import pygame
    as you did in [Chapter 13](ch13.xhtml#ch13), using pg, rather than pygame, to
    reduce typing.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Finish by building an RGB color table ➋ as you did in [Chapter 13](ch13.xhtml#ch13).
    This lets you type in color names, rather than RGB-value tuples, when you need
    to assign one of these colors.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '***Defining the Satellite Class Initialization Method***'
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 14-2](ch14.xhtml#ch14list2) defines the Satellite class and its initialization
    method, which you’ll use to instantiate a satellite object in the game. Since
    this method definition is long, it’s split over two listings.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '*mars_orbiter.py,* part 2'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '➊ class Satellite(pg.sprite.Sprite):'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '"""Satellite object that rotates to face planet & crashes & burns."""'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '➋ def __init__(self, background):'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: ➌ super().__init__()
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: ➍ self.background = background
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: ➎ self.image_sat = pg.image.load("satellite.png").convert()
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: self.image_crash = pg.image.load("satellite_crash_40x33.png").convert()
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: ➏ self.image = self.image_sat
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: ➐ self.rect = self.image.get_rect()
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: ➑ self.image.set_colorkey(BLACK)  # sets transparent color
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 14-2: Defines the first part of the* Satellite *class initialization
    method*'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Define a class for a Satellite object ➊; if you need a refresher on object-oriented
    programming, read [Chapter 11](ch11.xhtml#ch11). Pass it the pygame Sprite class,
    as objects instantiated from the Satellite class will be sprites. As described
    in [Chapter 13](ch13.xhtml#ch13), Sprite is a built-in class that serves as a
    template for making sprites. Your new class will inherit features that your sprites
    will need from this base class. These include important attributes like rect and
    image, which you’ll deal with shortly.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Next, define the __init__() method for the Satellite object ➋ and pass it self,
    which—by convention—is a special name within a class definition that refers to
    the current object. You also need to pass the method a background object. The
    satellite’s path will be drawn on this object.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Inside the __init_() method, immediately invoke the initialization method for
    the built-in Sprite class using super ➌. This will initialize the sprite and establish
    the rect and image attributes it needs. With super, you don’t need to refer to
    the base class (Sprite) explicitly. For more on super, see [Listing 11-5](ch11.xhtml#ch11list5)
    on [page 229](ch11.xhtml#page_229) or visit the docs at *[https://docs.python.org/3/library/functions.html?highlight=super#super](https://docs.python.org/3/library/functions.html?highlight=super#super)*.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Next, assign the background to self as an object attribute ➍. Then use pygame’s
    image.load() method to load your two satellite images—one operational and one
    crashed—and in the same step, run the convert() method on them ➎. This converts
    the object into a graphic format that pygame can use efficiently once the game
    loop starts. Without this step, the game may slow noticeably as the png format
    is converted, on the fly, 30 or more times per second.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: You’ll use only one of the satellite images at a time, depending on whether
    or not the player burned up in the atmosphere, so use a generic self.image attribute
    to hold the loaded and converted image ➏. The unburned satellite image will be
    the default image; it will be replaced with the red crashed image if the satellite
    object gets too close to Mars.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Now, get the rectangle information for the image ➐. Remember that pygame places
    the sprites on rectangular surface objects, and it needs to know the dimensions
    and location of these rectangles as the game runs.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, make the black parts of the satellite image invisible ➑. The satellite
    icon is on a field of black (see [Figure 14-13](ch14.xhtml#ch14fig13)), and you
    want the crashed-and-burned image to plot partially over Mars, so use the BLACK
    constant with the image object’s colorkey() method in order to make the icon’s
    background transparent. Otherwise, you’ll see a black box with a red satellite
    overlapping the Red Planet. Note that if you want to type in the RGB equivalent
    for black, you need to enter it as a tuple: (0, 0, 0).'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '***Setting the Satellite’s Initial Position, Speed, Fuel, and Sound***'
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 14-3](ch14.xhtml#ch14list3) completes the definition of the Satellite
    class initialization method. The satellite object’s initial position and velocity
    are chosen at random from a limited range of choices; the orientation of the remote-sensing
    dish is initialized, the fuel tank topped off, and sound effects added.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '*mars_orbiter.py,* part 3'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: ➊ self.x = random.randrange(315, 425)
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: self.y = random.randrange(70, 180)
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: ➋ self.dx = random.choice([-3, 3])
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: ➌ self.dy = 0
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: ➍ self.heading = 0  # initializes dish orientation
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: ➎ self.fuel = 100
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: self.mass = 1
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: self.distance = 0  # initializes distance between satellite & planet
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: ➏ self.thrust = pg.mixer.Sound('thrust_audio.ogg')
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: ➐ self.thrust.set_volume(0.07)  # valid values are 0-1
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 14-3: Completes the* Satellite *class initialization method by initializing
    parameters*'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: When the game starts, the satellite will appear at a random point near the top
    of the screen. You’ll choose the exact location from a range of x- and y-values
    ➊.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also choose the satellite’s velocity at random, but it will be slow enough
    that the satellite can’t escape from orbit. Randomly set the velocity to either
    –3 or 3\. Negative values result in a counterclockwise orbit, and vice versa.
    Use the delta-x (dx) attribute only ➋ and let gravity take care of dy. As discussed
    in [Chapter 13](ch13.xhtml#ch13), pygame moves sprites around the screen using
    incremental changes in the x-location (called delta-x or *dx*) and incremental
    changes in the y-location (called delta-y or *dy*). These vector components are
    calculated and added to the sprite’s current position (self.x, self.y) with each
    game loop.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Next, set the dy attribute to 0 ➌. Later, the gravity() method will establish
    an initial dy value when it accelerates the newly instantiated satellite downscreen
    toward the planet.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Assign an attribute for the satellite’s heading ➍. The remote-sensing dish,
    which will read soil moisture on the planet’s surface, should always point toward
    Mars, and if you remember from [Figure 14-3](ch14.xhtml#ch14fig3), this won’t
    occur unless you overcome inertia. You’ll use a method to actually rotate the
    satellite, so for now, just initialize the heading attribute with 0.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Now, top off the fuel tank with 100 units of fuel ➎. If you want to relate this
    to real life, it would probably represent 100 kilograms of hydrazine, similar
    to what was used in the *Magellan* probe that mapped Venus.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Next, set the object’s mass to 1. This basically means you’ll just use the mass
    of Mars in the gravity equation, because you multiply the masses of two objects
    together. As stated earlier, the pull of the satellite on Mars is inconsequential,
    so you don’t need to calculate it. The satellite’s mass attribute is included
    for completeness and as a placeholder in case you want to experiment with different
    values later.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: The following distance attribute stores the distance between the satellite and
    the body it is orbiting. The actual value will be calculated by a method you’ll
    define later.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: It’s time to add sound effects. You’ll initialize pygame’s sound mixer in the
    main() function, but for now, name a thrust attribute for the thrusting sound
    effect ➏. Pass the mixer’s Sound class the short clip of white noise in Ogg Vorbis
    format (*.ogg*). Finally, set the playback volume, using values between 0 and
    1 ➐. You may need to calibrate this to your PC. Ideally, you want a value that
    every player will be able to at least *hear* and then fine-tune with their own
    computer’s volume control.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '***Firing Thrusters and Checking for Player Input***'
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 14-4](ch14.xhtml#ch14list4) defines the thruster() and check_keys()
    methods of the Satellite class. The first determines the actions taken if one
    of the satellite’s thrusters is fired. The second checks whether a player has
    interacted with the thrusters by pressing an arrow key.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '*mars_orbiter.py,* part 4'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '➊ def thruster(self, dx, dy):'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '"""Execute actions associated with firing thrusters."""'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: ➋ self.dx += dx
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: self.dy += dy
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: ➌ self.fuel -= 2
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: ➍ self.thrust.play()
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '➎ def check_keys(self):'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '"""Check if user presses arrow keys & call thruster() method."""'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: ➏ keys = pg.key.get_pressed()
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '# fire thrusters'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '➐ if keys[pg.K_RIGHT]:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: ➑ self.thruster(dx=0.05, dy=0)
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'elif keys[pg.K_LEFT]:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: self.thruster(dx=-0.05, dy=0)
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'elif keys[pg.K_UP]:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: self.thruster(dx=0, dy=-0.05)
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'elif keys[pg.K_DOWN]:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: self.thruster(dx=0, dy=0.05)
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 14-4: Defines the* thruster() *and* check_keys() *methods for the*
    Satellite *class*'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: The thruster() method takes self, dx, and dy as arguments ➊. The last two arguments,
    which can be positive or negative, are immediately added to the satellite’s self.dx
    and self.dy velocity components ➋. Next, the fuel level is decreased by two units
    ➌. Altering this value is one way to make the game either harder or easier. Finish
    by calling the play() method on the thrust audio attribute to make the hissing
    sound ➍. Note that, instead of *returning* values, OOP methods *update* existing
    object attributes.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: The check_keys() method takes self as an argument ➎. First you use the pygame
    key module to determine whether the player has pressed a key ➏. The get_pressed()
    method returns a tuple of Boolean values—1 for True and 0 for False—that represent
    the current state of each key on the keyboard. True means a key has been pressed.
    You can index this tuple by using the key constants. You can find a list of all
    the keyboard constants at *[https://www.pygame.org/docs/ref/key.html](https://www.pygame.org/docs/ref/key.html)*.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: For example, the right arrow key is K_RIGHT. If this key has been pressed ➐,
    call the thruster() method and pass it dx and dy values ➑. In pygame, x-values
    increase toward the right of the screen, and y-values increase toward the bottom
    of the screen. So, if the user presses the left arrow key, subtract from dx; likewise,
    if the up arrow is pressed, decrement the dy value. The right arrow will increase
    dx, and the down arrow will increase dy. Readouts at the top of the screen will
    help the player relate the satellite’s movements to the underlying dx and dy values
    (see [Figure 14-14](ch14.xhtml#ch14fig14)).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '***Locating the Satellite***'
  id: totrans-198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Still in the Satellite class, [Listing 14-5](ch14.xhtml#ch14list5) defines the
    locate() method. This method calculates the distance of the satellite from the
    planet and determines the heading for pointing the dish at the planet. You’ll
    use the distance attribute later when calculating the force of gravity and the
    *eccentricity* of the orbit. Eccentricity is a measurement of the deviation of
    an orbit from a perfect circle.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '*mars_orbiter.py,* part 5'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '➊ def locate(self, planet):'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '"""Calculate distance & heading to planet."""'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: ➋ px, py = planet.x, planet.y
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: ➌ dist_x = self.x - px
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: dist_y = self.y - py
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '# get direction to planet to point dish'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: ➍ planet_dir_radians = math.atan2(dist_x, dist_y)
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: ➎ self.heading = planet_dir_radians * 180 / math.pi
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: ➏ self.heading -= 90  # sprite is traveling tail-first
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: ➐ self.distance = math.hypot(dist_x, dist_y)
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 14-5: Defines the* locate() *method for the* Satellite *class*'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: To locate the satellite, you need to pass the locate() method the satellite
    (self) and planet objects ➊. First, determine the distance between the objects
    in x-y space. Get the planet’s x- and y-attributes ➋; then subtract them from
    the satellite’s x- and y-attributes ➌.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Now, use these new distance variables to calculate the angle between the satellite’s
    heading and the planet so you can rotate the satellite dish toward the planet.
    The math module uses radians, so assign a local variable called planet_dir_radians
    to hold the direction in radians and pass dist_x and dist_y to the math.atan2()
    function to calculate the arc tangent ➍. Since pygame uses degrees (sigh), convert
    the angle from radians to degrees using the standard formula; alternatively, you
    could use math to do this, but sometimes it’s good to see the man behind the curtain
    ➎. This should be a sharable attribute of the satellite object, so name it self.heading.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: In pygame, the front of a sprite is to the east by default, which means the
    satellite sprite is orbiting tail-first (see the satellite icon in [Figure 14-13](ch14.xhtml#ch14fig13)).
    To get the dish to point toward Mars, you need to subtract 90 degrees from the
    heading, because negative angles result in *clockwise* rotation in pygame ➏. This
    maneuver will use none of the player’s fuel allotment.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Finally, get the Euclidian distance between the satellite and Mars by using
    the math module to calculate the hypotenuse from the x- and y-components ➐. You
    should make this an attribute of the satellite object since you will use it later
    in other functions.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '*In real life, there are multiple ways to keep the dish of a satellite pointed
    toward a planet without expending large amounts of fuel. Techniques include slowly
    tumbling or spinning the satellite, making the dish end heavier than the opposite
    end, using magnetic torque, or using internal flywheels—also known as reaction
    wheels or momentum wheels. Flywheels use electric motors that can be powered by
    solar panels, eliminating the need for heavy and toxic liquid propellant.*'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '***Rotating the Satellite and Drawing Its Orbit***'
  id: totrans-218
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 14-6](ch14.xhtml#ch14list6) continues the Satellite class by defining
    methods for rotating the satellite dish toward the planet and drawing a path behind
    it. Later, in the main() function, you’ll add code that lets the player erase
    and restart the path by pressing the space bar.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '*mars_orbiter.py,* part 6'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '➊ def rotate(self):'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '"""Rotate satellite using degrees so dish faces planet."""'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: ➋ self.image = pg.transform.rotate(self.image_sat, self.heading)
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: ➌ self.rect = self.image.get_rect()
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '➍ def path(self):'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '"""Update satellite’s position & draw line to trace orbital path."""'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: ➎ last_center = (self.x, self.y)
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: ➏ self.x += self.dx
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: self.y += self.dy
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: ➐ pg.draw.line(self.background, WHITE, last_center, (self.x, self.y))
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 14-6: Defines the* rotate() *and* path() *methods of the* Satellite
    *class*'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: The rotate() method will use the heading attribute, which you calculate in the
    locate() method, to turn the satellite dish toward Mars. Pass self to rotate()
    ➊, which means rotate() will automatically take the name of the satellite object
    as an argument when it is called later.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Now, rotate the satellite image using pygame’s transform.rotate() method ➋.
    Pass it the original image followed by the heading attribute; assign these to
    the self.image attribute so you don’t degrade the original master image. You’ll
    need to transform the image with each game loop, and transforming an image rapidly
    degrades it. So always keep a master image and work off a new copy every time
    you do a transformation.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: End the function by getting the transformed image’s rect object ➌.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Next, define a method called path() and pass it self ➍. This will draw a line
    marking the satellite’s path, and since you need two points to draw a line, assign
    a variable to record the satellite’s center location as a tuple prior to moving
    it ➎. Then increment the x- and y-locations with the dx and dy attributes ➏. Finish
    by using pygame’s draw.line() method to define the line ➐. This method needs a
    drawing object, so pass it the background attribute, followed by the line color
    and the previous and current x-y location tuples.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '***Updating the Satellite Object***'
  id: totrans-236
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 14-7](ch14.xhtml#ch14list7) updates the satellite object and completes
    the class definition. Sprite objects almost always have an update() method that
    is called once per frame as the game runs. Anything that happens to the sprite,
    such as movement, color changes, user interactions, and so on, is included in
    this method. To keep them from becoming too cluttered, update() methods mostly
    call other methods.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '*mars_orbiter.py,* part 7'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '➊ def update(self):'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '"""Update satellite object during game."""'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: ➋ self.check_keys()
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: ➌ self.rotate()
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: ➍ self.path()
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: ➎ self.rect.center = (self.x, self.y)
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '# change image to fiery red if in atmosphere'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '➏ if self.dx == 0 and self.dy == 0:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: self.image = self.image_crash
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: self.image.set_colorkey(BLACK)
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 14-7: Defines the* update() *method for the* Satellite *class*'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Start by defining the update() method and passing it the object, or self ➊.
    Next, call the methods that you defined earlier. The first of these checks for
    player interactions made through the keyboard ➋. The second rotates the satellite
    object so that the dish keeps pointing toward the planet ➌. The final method updates
    the satellite’s x-y location and draws a path behind it so you can visualize the
    orbit ➍.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: The program needs to keep track of the satellite sprite’s location as it orbits
    Mars, so assign a rect.center attribute and set it to the satellite’s current
    x-y location ➎.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: The final bit of code changes the satellite image in the event the player crashes
    and burns in the atmosphere ➏. The top of the Martian atmosphere is about 68 miles
    above its *surface*. For reasons I’ll explain later, assume that an altitude value
    of 68—which is measured in pixels from the *center* of the planet—equates to the
    top of the atmosphere. If the satellite dips below this altitude during gameplay,
    the main() function will set its velocity—represented by dx and dy—to 0. Check
    that these values are both 0, and if so, change the image to image_crash and set
    its background to transparent (as you did previously for the main satellite image).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '***Defining the Planet Class Initialization Method***'
  id: totrans-253
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 14-8](ch14.xhtml#ch14list8) defines the Planet class, which you’ll
    use to instantiate a planet object.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '*mars_orbiter.py,* part 8'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '➊ class Planet(pg.sprite.Sprite):'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '"""Planet object that rotates & projects gravity field."""'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '➋ def __init__(self):'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: super().__init__()
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: ➌ self.image_mars = pg.image.load("mars.png").convert()
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: self.image_water = pg.image.load("mars_water.png").convert()
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: ➍ self.image_copy = pg.transform.scale(self.image_mars, (100, 100))
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: ➎ self.image_copy.set_colorkey(BLACK)
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: ➏ self.rect = self.image_copy.get_rect()
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: self.image = self.image_copy
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: ➐ self.mass = 2000
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: ➑ self.x = 400
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: self.y = 320
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: self.rect.center = (self.x, self.y)
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: ➒ self.angle = math.degrees(0)
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: self.rotate_by = math.degrees(0.01)
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 14-8: Begins definition of the* Planet *class*'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: You are probably very familiar with the initial steps to creating the Planet
    class by now. First, you name the class with a capital letter, then pass it the
    Sprite class so it will conveniently inherit features from this built-in pygame
    class ➊. Next, you define an __init__(), or initialization, method for your planet
    object ➋. Then you call the super() initialization method, as you did for the
    Satellite class.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Load the images as attributes and convert them to pygame’s graphic format at
    the same time ➌. You need both the normal Mars image and the one for mapped soil
    moisture. You were able to use the satellite sprite at its native size, but the
    Mars image is too large. Scale the image to 100 pixels × 100 pixels ➍ and assign
    the scaled image to a new attribute so repeated transformations won’t degrade
    the master image.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: Now, set the transformed image’s transparent color to black, as you did earlier
    with the satellite image ➎. Sprites in pygame are all “mounted” on rectangular
    surfaces, and if you don’t make black invisible, the corners of the planet surface
    may overlap and cover the white-colored orbital path drawn by the satellite (see
    [Figure 14-15](ch14.xhtml#ch14fig15)).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0305-01.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-15: Corners of Mars* rect *covering orbital path*'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: As always, get the sprite’s rect object ➏. There’s another transformation to
    come, so copy the image attribute again and assign it the logical name of self.image.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: To apply the force of gravity, the planet needs mass, so name a mass attribute
    and assign it a value of 2000 ➐. Earlier, you assigned the satellite a mass of
    1; this means that Mars is only 2,000 times as massive as a satellite! That’s
    okay, because you aren’t working in real-world units, and the time and distance
    scales differ from reality. If you scale distances so that the satellite is only
    a few hundred pixels from Mars, you have to scale gravity as well. Despite this,
    the satellite will still behave realistically with respect to gravity.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: The planet’s mass value was determined through experimentation. To scale the
    force of gravity, you can either change this mass value or use the gravitational
    constant (G) variable later.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: Set the planet object’s x and y attributes to the center point of the screen—you’ll
    use a screen size of 800 × 645 in the main() function—and assign these values
    to the rect object’s center ➑.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Finally, assign the attributes you’ll need to slowly rotate Mars about its axis
    ➒. You’ll use the same transform.rotate() method you used to turn the satellite,
    so you need to create an angle attribute. Then, use a rotate_by attribute to assign
    the increment—in degrees—by which this rotation angle changes with each game loop.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '***Rotating the Planet***'
  id: totrans-283
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 14-9](ch14.xhtml#ch14list9) continues the Planet class by defining
    its rotate() method. This method rotates the planet around its axis, making small
    changes with each game loop.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '*mars_orbiter.py,* part 9'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '➊ def rotate(self):'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '"""Rotate the planet image with each game loop."""'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: ➋ last_center = self.rect.center
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: ➌ self.image = pg.transform.rotate(self.image_copy, self.angle)
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: self.rect = self.image.get_rect()
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: ➍ self.rect.center = last_center
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: ➎ self.angle += self.rotate_by
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 14-9: Defines a method to rotate the planet around its axis*'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: The rotate() method also takes the object as an argument ➊. As the square Mars
    image is rotating, the bounding rectangle object (rect) remains stationary and
    must expand to accommodate the new configuration (see [Figure 14-16](ch14.xhtml#ch14fig16)).
    This change in size can affect the center point of the rect, so assign a last_center
    variable and set it to the planet’s current center point ➋. If you don’t do this,
    Mars will wobble around its axis as the game runs.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0306-01.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-16: The bounding rectangle changes size to accommodate rotating
    images.*'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: Next, rotate the copied image using pygame’s transform.rotate() method and assign
    it to the self.image attribute ➌; you need to pass the method the copied image
    and the angle attribute. Immediately after rotating, reset the image’s rect attribute
    and move its center location back to last_center in order to mitigate any shifting
    of rect that occurred during rotation ➍.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: When the planet object is instantiated, the angle attribute will start at 0
    degrees, then increase by 0.1—assigned in the rotate_by attribute—with each frame
    ➎.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '***Defining the gravity() and update() Methods***'
  id: totrans-299
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 14-10](ch14.xhtml#ch14list10) completes the Planet class by defining
    the gravity() and update() methods. In [Chapter 13](ch13.xhtml#ch13), you treated
    gravity as a constant applied in the y-direction. The method applied here is slightly
    more sophisticated, because it takes into account the distance between two objects.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '*mars_orbiter.py,* part 10'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '➊ def gravity(self, satellite):'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '"""Calculate impact of gravity on satellite."""'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: ➋ G = 1.0  # gravitational constant for game
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: ➌ dist_x = self.x - satellite.x
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: dist_y = self.y - satellite.y
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: distance = math.hypot(dist_x, dist_y)
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '# normalize to a unit vector'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: ➍ dist_x /= distance
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: dist_y /= distance
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '# apply gravity (dx & dy represent pixels/frame)'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: ➎ force = G * (satellite.mass * self.mass) / (math.pow(distance, 2))
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: ➏ satellite.dx += (dist_x * force)
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: satellite.dy += (dist_y * force)
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '➐ def update(self):'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '"""Call the rotate method."""'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: self.rotate()
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 14-10: Defines the* gravity() *and* update() *methods of the* Planet
    *class*'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: Define the gravity() method and pass it self and the satellite object ➊. You’re
    still in the Planet class, so self here represents Mars.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: Start by naming a local variable G; an uppercase G is the *universal gravitational
    constant*, also known as the *constant of proportionality* ➋. In real life, this
    is a very small, empirically derived number, which is basically a conversion number
    to get all the units to work out correctly. You’re not using real-world units
    in the game, so set this to 1; this way, it won’t have an impact on the gravity
    equation. During game development, you can tweak this constant up or down to fine-tune
    the force of gravity and its effect on orbiting objects.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: You need to know how far apart the two objects are, so get their distance in
    the x-direction and the y-direction ➌. Then, use the math module’s hypot() method
    to get the Euclidian distance. This will represent the *r* in the gravity equation.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: Since you’re going to directly address the *magnitude* of the distance between
    the satellite and Mars in the gravity equation, all you need from the distance
    vector is *direction*. So, divide dist_x and dist_y by distance to “normalize”
    the vector to a unit vector with a magnitude of 1 ➍. You are basically dividing
    the length of each side of a right triangle by its hypotenuse. This preserves
    the vector’s direction, represented by the relative differences in dist_x and
    dist_y, but sets its magnitude to 1. Note that if you don’t perform this normalization
    step, the results will be unrealistic but interesting (see [Figure 14-17](ch14.xhtml#ch14fig17)).
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0308-01.jpg)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-17: “Spirograph” orbit resulting from use of an unnormalized distance
    vector*'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: Calculate the force of gravity using Newton’s equation, which I described in
    “[The Law of Universal Gravity](ch14.xhtml#lev316)” on [page 286](ch14.xhtml#page_286)
    ➎. Finish by multiplying the normalized distances by force—to calculate by how
    much acceleration changes velocity in each step—and add these amounts to the satellite
    object’s dx and dy attributes ➏.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: Note that you don’t assign most of these variables as attributes of self. These
    just represent intermediate steps within a method that don’t need to be shared
    with other methods, and you can treat them as you would local variables in procedural
    programming.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: Finally, define a method that will be called every game loop to update the planet
    object ➐. Use it to call the rotate() method.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '***Calculating Eccentricity***'
  id: totrans-328
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You’re through defining classes. Now it’s time to define some functions that
    will help with running the game. [Listing 14-11](ch14.xhtml#ch14list11) defines
    a function to calculate the eccentricity of the satellite’s orbit. The player
    will need to achieve a circular orbit within a certain altitude range, and this
    function will provide the measurement of circularity.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '*mars_orbiter.py,* part 11'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '➊ def calc_eccentricity(dist_list):'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '"""Calculate & return eccentricity from list of radii."""'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: ➋ apoapsis = max(dist_list)
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: periapsis = min(dist_list)
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: ➌ eccentricity = (apoapsis - periapsis) / (apoapsis + periapsis)
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: return eccentricity
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '*[Listing 14-11](ch14.xhtml#ch14list11): Defines a function to measure orbital
    eccentricity*'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: Define the calc_eccentricity() function and pass it a list of distances ➊. In
    the main() function, you’ll append the sat.distance attribute—which records the
    satellite’s altitude—to this list during every game loop. To calculate eccentricity,
    you need to know both the apoapsis and periapsis of the orbit. Get these by finding
    the maximum and minimum values in this list ➋. Then, calculate eccentricity ➌.
    Later, in the main() function, you’ll display this number to eight decimal places,
    just to look cool and precise in the readout.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: Note that circular orbits will have the same value for both apoapsis and periapsis,
    and so the calculation will yield 0 for a perfect circle. End the function by
    returning the eccentricity variable.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '***Defining Functions to Make Labels***'
  id: totrans-340
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The game will need a fair amount of text for instructions and telemetry readouts.
    Displaying this text one string at a time can result in a lot of code redundancy,
    so [Listing 14-12](ch14.xhtml#ch14list12) will define two functions—one to post
    instructions and another for the streams of velocity, altitude, fuel, and eccentricity
    data you’ll need to share with the player.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '*mars_orbiter.py,* part 12'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '➊ def instruct_label(screen, text, color, x, y):'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '"""Take screen, list of strings, color, & origin & render text to screen."""'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: ➋ instruct_font = pg.font.SysFont(None, 25)
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: ➌ line_spacing = 22
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '➍ for index, line in enumerate(text):'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: label = instruct_font.render(line, True, color, BLACK)
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: screen.blit(label, (x, y + index * line_spacing))
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '➎ def box_label(screen, text, dimensions):'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '"""Make fixed-size label from screen, text & left, top, width, height."""'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: readout_font = pg.font.SysFont(None, 27)
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: ➏ base = pg.Rect(dimensions)
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: ➐ pg.draw.rect(screen, WHITE, base, 0)
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: ➑ label = readout_font.render(text, True, BLACK)
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: ➒ label_rect = label.get_rect(center=base.center)
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: ➓ screen.blit(label, label_rect)
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 14-12: Defines functions to make instruction and readout labels*'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: Define a function called instruct_label() for displaying instructions on the
    game screen ➊. Pass it the screen, a list containing the text, a text color, and
    the coordinates for the upper-left corner of the pygame surface object that will
    hold the text.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: Next, tell pygame which font to use ➋. The arguments for the font.SysFont()
    method are the typeface and size. Using None for the typeface invokes pygame’s
    built-in default font, which should work on multiple platforms. Note that the
    method accepts both None and 'None'.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: The introduction and instruction text will take up multiple lines (see the example
    in [Figure 14-14](ch14.xhtml#ch14fig14)). You’ll need to specify the line spacing,
    in pixels, between the text strings, so assign a variable for this and set it
    to 22 ➌.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: Now, start looping through the list of text strings ➍. Use enumerate() to get
    an index, which you’ll use with the line_spacing variable to post the strings
    in the correct locations. The text will need to be placed on a surface. Name this
    surface label, pass the font.render() method the line of text you want to display,
    set antialiasing to True for smoother text, color the text, and set the background
    color to black. Finish by blitting the surface to the screen. Pass the method
    the label variable and the upper-left-corner coordinates, with y defined as y
    + index * line_spacing.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: Next, define a function called box_label() for the data readout labels that
    will appear as gauges at the top of the screen (see [Figure 14-18](ch14.xhtml#ch14fig18))
    ➎. Parameters for this function are the screen, some text, and a tuple containing
    the dimensions of the rectangular surface that will form the gauge.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0310-01.jpg)'
  id: totrans-364
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-18: Readout labels at the top of the game window (header label above
    and data label below)*'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: The surfaces made by the instruct_label() function will automatically change
    size to accommodate the amount of text being displayed. This works fine for static
    displays, but the readout data will change constantly, causing your gauges to
    expand and shrink as they adjust to fit the text inside them. To mitigate this,
    you’ll use a stand-alone rect object of a specified size to form a base for your
    text object.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: Start the function by setting the font, as you did in ➋. Assign a variable called
    base to a pygame rect object; use the dimensions argument for the size ➏. This
    argument lets you precisely place the position of the box by specifying the left
    and top coordinates of the rectangle, followed by its width and height. The resulting
    rectangle should be wide enough to handle the longest possible readout the game
    will produce for the data type being displayed.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: Now, draw the base using the draw_rect() method ➐. The arguments are the drawing
    surface, a fill color, the name of the rect, and a width of 0, which fills the
    rectangle rather than drawing a border. You’ll post your text object on top of
    this white rectangle.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: Repeat the code that renders the text ➑, then get the rect for the label ➒.
    Note that in the get_rect() method there’s a parameter that sets the center equal
    to the center of base. This lets you place the text label on top of the white
    base rectangle. Finally, blit to the screen, specifying the source and destination
    rects ➓.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '***Mapping Soil Moisture***'
  id: totrans-370
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 14-13](ch14.xhtml#ch14list13) defines functions that allow the player
    to “map” Mars if the game’s winning conditions have been met. When the player
    presses the M key, these functions will be called by the main() function, and
    the planet’s image will be replaced with a colorful overlay we’ll pretend represents
    soil moisture content. When the player releases the key, the normal view of Mars
    will return. The key checks will also be performed in the main() function.'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '*mars_orbiter.py,* part 13'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '➊ def mapping_on(planet):'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: '"""Show soil moisture image of planet."""'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: ➋ last_center = planet.rect.center
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: ➌ planet.image_copy = pg.transform.scale(planet.image_water, (100, 100))
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: ➍ planet.image_copy.set_colorkey(BLACK)
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: planet.rect = planet.image_copy.get_rect()
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: planet.rect.center = last_center
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: '➎ def mapping_off(planet):'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '"""Restore normal planet image."""'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: ➏ planet.image_copy = pg.transform.scale(planet.image_mars, (100, 100))
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: planet.image_copy.set_colorkey(BLACK)
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 14-13: Defines functions to let the player make a soil moisture map
    of Mars*'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: Start by defining a function that takes as an argument the planet object ➊.
    Start by assigning a last_center variable as you did in [Listing 14-9](ch14.xhtml#ch14list9);
    this will be used to keep the planet from wobbling on its axis ➋.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: Next, scale the water image of Mars to the same size as the normal image and
    assign this to the planet’s image_copy attribute, because transformations degrade
    an image if used repeatedly ➌. Set the image’s background to transparent ➍, get
    its rect, and set the center of the rect equal to the last_center variable; that
    way Mars will stay put at the center of the screen.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: Now, define another function for when the player stops actively mapping Mars
    ➎. It also takes the planet object as an argument. All you need to do is reset
    the planet image to the original version ➏. Because you’re still using the image_copy
    attribute, you don’t need to get the rect again, but you do need to set the transparent
    color.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: '***Casting a Shadow***'
  id: totrans-388
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 14-14](ch14.xhtml#ch14list14) defines a function that gives Mars a
    “dark side” and casts a shadow behind the planet. The shadow will be a black,
    semitransparent rectangle with its right edge coincident with the center of the
    planet sprite (see [Figure 14-19](ch14.xhtml#ch14fig19)). This assumes the sun
    is to the right of the screen and that it is either the vernal or autumnal equinox
    on Mars.'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0312-01.jpg)'
  id: totrans-390
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-19: Shadow rectangle in semitransparent white (left) and final semitransparent
    black (right)*'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '*mars_orbiter.py,* part 14'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: '➊ def cast_shadow(screen):'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '"""Add optional terminator & shadow behind planet to screen."""'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: ➋ shadow = pg.Surface((400, 100), flags=pg.SRCALPHA)  # tuple is w,h
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: ➌ shadow.fill((0, 0, 0, 210))  # last number sets transparency
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: screen.blit(shadow, (0, 270))  # tuple is top left coordinates
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 14-14: Defines a function to give Mars a dark side and let it cast
    a shadow*'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: The cast_shadow() function takes the screen object as an argument ➊. Assign
    a 400 pixel × 100 pixel pygame surface to an object named shadow ➋. Use pygame’s
    SRCALPHA flag—for “source alpha”—to indicate you will use per pixel alpha (transparency).
    Fill the object with black and set alpha—represented by the last number—to 210
    ➌. Alpha is part of the RGBA color system and has valid values of 0 through 255,
    so this is very dark but not completely opaque. Finally, blit the surface to the
    screen, along with the coordinates for its top-left corner. To turn off the shadow,
    just comment out the function call in main() or set the alpha value to 0.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: '***Defining the main() Function***'
  id: totrans-400
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 14-15](ch14.xhtml#ch14list15) begins the definition of the main()
    function that runs the game. The pygame package and the sound mixer are initialized,
    the game screen is set up, and instructions for the player are stored as lists.'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: '*mars_orbiter.py,* part 15'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: 'def main():'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '"""Set up labels & instructions, create objects & run the game loop."""'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: ➊ pg.init()  # initialize pygame
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: '# set up display:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: ➋ os.environ['SDL_VIDEO_WINDOW_POS'] = '700, 100'  # set game window origin
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: ➌ screen = pg.display.set_mode((800, 645), pg.FULLSCREEN)
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: ➍ pg.display.set_caption("Mars Orbiter")
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: ➎ background = pg.Surface(screen.get_size())
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: ➏ pg.mixer.init()  # for sound effects
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: ➐ intro_text = [
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: ''' The Mars Orbiter experienced an error during Orbit insertion.'','
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: ''' Use thrusters to correct to a circular mapping orbit without'','
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: ''' running out of propellant or burning up in the atmosphere.'''
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: instruct_text1 = [
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: '''Orbital altitude must be within 69-120 miles'','
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: '''Orbital Eccentricity must be < 0.05'','
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: '''Avoid top of atmosphere at 68 miles'''
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: instruct_text2 = [
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: '''Left Arrow = Decrease Dx'','
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: '''Right Arrow = Increase Dx'','
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: '''Up Arrow = Decrease Dy'','
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: '''Down Arrow = Increase Dy'','
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: '''Space Bar = Clear Path'','
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: '''Escape = Exit Full Screen'''
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 14-15: Starts the* main() *function by initializing* pygame *and the
    sound mixer and by setting up the game screen and instructions*'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: Start the main() function by initializing pygame ➊. Then, use the os module’s
    environ() method to assign the coordinates of the upper-left corner of the game
    window ➋. This step is not strictly necessary, but I wanted to demonstrate that
    you have control over where windows appear on the desktop.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: Next, assign a variable to hold the screen object and set the display mode to
    full screen ➌. Use the tuple (800, 645) to specify the screen size to use if the
    player escapes from full-screen mode.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: Now use pygame’s display.set_caption() method to name the game window “Mars
    Orbiter” ➍. Then, use pygame’s Surface class to create a background object for
    the game that’s the same size as the screen ➎.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: Initialize pygame’s sound mixer so you can play the thruster sound effect ➏.
    You defined this sound earlier in the satellite’s initialization method.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: The game will start with a short introduction that will vanish after 15 seconds.
    Permanent legends describing keyboard controls and win conditions occupy the bottom
    corners of the screen. Enter the text for these as lists ➐. Later, you will pass
    these lists to the instruct_label() function you wrote in [Listing 14-12](ch14.xhtml#ch14list12).
    Each item in the list, delineated by a comma, will appear as a separate line in
    the game window (see [Figure 14-19](ch14.xhtml#ch14fig19)).
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: '***Instantiating Objects, Setting Up Orbit Verification, Mapping, and Timekeeping***'
  id: totrans-436
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 14-16](ch14.xhtml#ch14list16), still in the main() function, instantiates
    the planet and satellite objects, assigns some useful variables for determining
    orbital eccentricity, prepares the game clock within the function, and assigns
    a variable to track the state of the mapping functionality.'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: '*mars_orbiter.py,* part 16'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: '# instantiate planet and satellite objects'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: ➊ planet = Planet()
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: ➋ planet_sprite = pg.sprite.Group(planet)
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: ➌ sat = Satellite(background)
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: ➍ sat_sprite = pg.sprite.Group(sat)
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: '# for circular orbit verification'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: ➎ dist_list = []
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: ➏ eccentricity = 1
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: ➐ eccentricity_calc_interval = 5  # optimized for 120 mile altitude
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: '# time keeping'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: ➑ clock = pg.time.Clock()
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: fps = 30
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: tick_count = 0
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: '# for soil moisture mapping functionality'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: ➒ mapping_enabled = False
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 14-16: Instantiates objects and assigns useful variables in* main()'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: Continue the main() function by creating a planet object from the Planet class
    ➊, then place it in a sprite group ➋. Remember from [Chapter 13](ch13.xhtml#ch13)
    that pygame manages sprites using containers called *groups*.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: Next, instantiate a satellite object, passing the Satellite class’s initialization
    method the background object ➌. The satellite needs the background for drawing
    its path.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: After creating the satellite, put it in its own sprite group ➍. You should generally
    keep radically different sprite types in their own containers. This makes it easy
    to manage things like display order and collision handling.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: Now, assign some variables to help with calculating eccentricity. Start an empty
    list to hold the distance values calculated in each game loop ➎, then assign an
    eccentricity variable a placeholder value of 1 ➏, indicating a noncircular starting
    orbit.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: You’ll want to update the eccentricity variable regularly to evaluate any changes
    the player makes to the orbit. Remember, you need the orbit’s apoapsis and periapsis
    to calculate eccentricity, and for large, elliptical orbits, it may take a while
    to actually sample these. The good news is that you only need to consider “winning”
    orbits between 69 and 120 miles. So, you can optimize the sampling rate for orbits
    below 120 miles, which generally take the satellite sprite less than 6 seconds
    to complete. Use 5 seconds and assign this value to an eccentricity_calc_interval
    variable ➐. This means that, for orbits with altitudes above 120 miles, the calculated
    eccentricity may not be technically correct, but it will be good enough considering
    the orbit doesn’t satisfy the winning conditions at that altitude.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: Address timekeeping next. Use a clock variable to hold pygame’s game clock,
    which will control the speed of the game in frames per second ➑. Each frame will
    represent one tick of the clock. Assign a variable named fps a value of 30, which
    means the game will update 30 times per second. Next, assign a tick_count variable
    that you’ll use to determine when to clear the introduction text and when to call
    the calc_eccentricity() function.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: Finish the section by naming a variable to enable the mapping functionality
    and set it to False ➒. If the player achieves the winning conditions, you’ll change
    this to True.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: '***Starting the Game Loop and Playing Sounds***'
  id: totrans-462
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 14-17](ch14.xhtml#ch14list17), still in the main() function, starts
    the game clock and while loop, also referred to as the *game loop*. It also receives
    events, such as a player firing thrusters using the arrow keys. If the player
    fires the thrusters, the Ogg Vorbis audio file plays, and the player hears a satisfying
    hiss.'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: '*mars_orbiter.py,* part 17'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: ➊ running = True
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: 'while running:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: ➋ clock.tick(fps)
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: tick_count += 1
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: ➌ dist_list.append(sat.distance)
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: '# get keyboard input'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: '➍ for event in pg.event.get():'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: ➎ if event.type == pg.QUIT:  # close window
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: running = False
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: '➏ elif event.type == pg.KEYDOWN and event.key == pg.K_ESCAPE:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: screen = pg.display.set_mode((800, 645))  # exit full screen
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: '➐ elif event.type == pg.KEYDOWN and event.key == pg.K_SPACE:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: background.fill(BLACK)  # clear path
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: '➑ elif event.type == pg.KEYUP:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: ➒ sat.thrust.stop()  # stop sound
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: mapping_off(planet)  # turn off moisture map view
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: '➓ elif mapping_enabled:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: 'if event.type == pg.KEYDOWN and event.key == pg.K_m:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: mapping_on(planet)
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 14-17: Starts the game loop, gets events, and plays sounds in* main()'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: First assign a running variable for use with the while loop that runs the game
    ➊, then start the loop. Set the game speed using the clock’s tick() method and
    pass it the fps variable you named in the previous listing ➋. If the game feels
    slow to you, set the speed to 40 fps. For each loop—or frame—increment the clock-based
    counter by 1.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: Next, append the satellite object’s sat.distance value to dist_list ➌. This
    is the distance between the satellite and the planet, calculated each game loop
    by the satellite’s locate() method.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: Now, gather player input made through the keyboard ➍. As described in the previous
    chapter, pygame records every user interaction—called an *event*—in an event buffer.
    The event.get() method creates a list of these events that you can evaluate, in
    this case, with if statements. Start by checking if the player closed the window
    to quit the game ➎. If this is True, set running to False to end the game loop.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: If the player presses ESC, they are exiting full-screen mode, so reset the screen
    size to 800 × 645 pixels using the display.set_mode() method that you called at
    the start of main() ➏. If the player presses the space bar, fill the background
    with black, which will erase the white orbital path of the satellite ➐.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: When the player presses an arrow key, the satellite object plays the hissing
    sound, but nothing in its check_keys() method tells it to stop. So, pass pygame
    any KEYUP events ➑; when pygame reads that the player has released the arrow key,
    call the stop() method on thrust to stop the sound from playing ➒.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: To map Mars, the player will have to hold down the M key, so use the same KEYUP
    event to call the mapping_off() function. This will reset the planet image to
    its normal, nonmapped state.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: Finally, check whether the mapping_enabled variable is True, meaning the player
    has achieved the winning conditions and is ready to map Mars ➓. If they press
    the M key, call the mapping_on() function to show the soil moisture overlay in
    place of the normal view of the planet.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: '***Applying Gravity, Calculating Eccentricity, and Handling Failure***'
  id: totrans-492
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 14-18](ch14.xhtml#ch14list18) continues the while loop of the main()
    function by exerting a gravity force on the satellite and then calculating the
    eccentricity of its orbit. The eccentricity value will determine whether the orbit
    is circular or not, one of the game’s winning conditions. The listing also blits
    the background and responds to the fail conditions of running out of fuel or burning
    up in the atmosphere.'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: '*mars_orbiter.py,* part 18'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: '# get heading & distance to planet & apply gravity'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: ➊ sat.locate(planet)
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: planet.gravity(sat)
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: '# calculate orbital eccentricity'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: '➋ if tick_count % (eccentricity_calc_interval * fps) == 0:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: eccentricity = calc_eccentricity(dist_list)
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: ➌ dist_list = []
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: '# re-blit background for drawing command - prevents clearing path'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: ➍ screen.blit(background, (0, 0))
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: '# Fuel/Altitude fail conditions'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: '➎ if sat.fuel <= 0:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: ➏ instruct_label(screen, ['Fuel Depleted!'], RED, 340, 195)
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: sat.fuel = 0
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: sat.dx = 2
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: '➐ elif sat.distance <= 68:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: instruct_label(screen, ['Atmospheric Entry!'], RED, 320, 195)
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: sat.dx = 0
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: sat.dy = 0
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 14-18: Applies gravity, calculates eccentricity, and addresses fail
    conditions*'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: Call the satellite’s locate() method and pass it the planet object as an argument
    ➊. This method computes the heading and distance to Mars, which you use to point
    the dish, calculate orbital eccentricity, and apply gravity. Then, to apply the
    force of gravity, call the planet’s gravity() method and pass it the satellite
    object.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: If the modulus of the tick_count and the eccentricity_calc_interval * fps is
    0 ➋, call the function that calculates eccentricity and pass it the dist_list
    variable. Then, reset the dist_list variable to 0 to restart the distance sampling
    ➌.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: Next, call the screen’s blit() method and pass it the background and coordinates
    for the upper-left corner ➍. The placement of this statement matters. For example,
    if you move it after the code that updates the sprites, you won’t see the satellite
    or Mars on the game screen.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: Now, handle the case where the player runs out of fuel before achieving a circular
    orbit. First, get the current fuel level from the satellite object’s fuel attribute
    ➎. If the level is at or below 0, use the instruct_label() function to announce
    that the fuel is spent ➏, then set the satellite’s dx attribute to 2. This will
    cause the satellite sprite to quickly fly off the screen and into the depths of
    space, with the altitude readout getting larger and larger. Though unrealistic,
    this ensures the player knows they have failed!
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: The last failure case is when the player burns up in the atmosphere. If the
    satellite’s distance attribute is less than or equal to 68 ➐, make a label near
    the center of the screen that lets the player know they have entered the atmosphere
    and then set the satellite’s velocity attributes equal to 0. This will cause gravity
    to lock the sprite against the planet ([Figure 14-20](ch14.xhtml#ch14fig20)).
    Also, when dx and dy are 0, the satellite’s update() method ([Listing 14-7](ch14.xhtml#ch14list7))
    will switch the satellite’s image to the red “crashed” version.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0317-01.jpg)'
  id: totrans-519
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-20: Satellite in crash configuration*'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: The altitude parameter is a bit of a cheat, as altitude equates to the distance
    attribute, which is measured from the *centers* of the planet and satellite sprites,
    rather than from the *surface* of the planet to the satellite. It all comes down
    to scale. Planetary atmospheres are very thin veneers—at the scale of the game,
    the Martian atmosphere would be less than 2 pixels thick! As the game is designed,
    when the tip of the satellite dish scrapes the planet, the satellite will burn
    up, but since the size of the satellite sprite is unrealistically large, the sprite’s
    68-mile center point must be pushed farther out.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: '***Rewarding Success and Updating and Drawing Sprites***'
  id: totrans-522
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 14-19](ch14.xhtml#ch14list19), still in the while loop of the main()
    function, rewards the winning player by enabling functionality that lets them
    map the moisture content in the Martian soil. In real life, this might be accomplished
    with radar or microwave resonators, which can remotely measure moisture in bare
    soil down to a depth of a few inches. The listing also updates the planet and
    satellite sprites and draws them to the screen.'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: '*mars_orbiter.py,* part 19'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: '# enable mapping functionality'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: '➊ if eccentricity < 0.05 and sat.distance >= 69 and sat.distance <= 120:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: ➋ map_instruct = ['Press & hold M to map soil moisture']
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: instruct_label(screen, map_instruct, LT_BLUE, 250, 175)
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: ➌ mapping_enabled = True
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: mapping_enabled = False
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: ➍ planet_sprite.update()
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: ➎ planet_sprite.draw(screen)
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: sat_sprite.update()
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: sat_sprite.draw(screen)
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 14-19: Enables mapping functionality and updates sprites in the game
    loop*'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: If the orbit is circular and meets the altitude requirements ➊, display a message
    instructing the player to press the M key to map soil moisture ➋. Put the text
    in brackets, as the instruct_label() function expects a list. Make the text color
    light blue and place it near the center of the screen.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: Next, set the mapping_enabled variable to True ➌; otherwise, if the orbit strays
    outside of the target parameters, set it to False.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: Finish by calling the planet sprite’s update() method, through the sprite group
    ➍, then actually draw it to the screen ➎. The argument for the draw() method is
    the screen, the object on which to draw the sprites. Repeat these steps for the
    satellite sprite.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: '***Displaying Instructions and Telemetry and Casting a Shadow***'
  id: totrans-540
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 14-20](ch14.xhtml#ch14list20) completes the while loop and the main()
    function by displaying instructions, data readouts, and the planet’s shadow. The
    game introduction text will be shown only for a short time at startup.'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: '*mars_orbiter.py,* part 20'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: '# display intro text for 15 seconds'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: ➊ if pg.time.get_ticks() <= 15000:  # time in milliseconds
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
- en: instruct_label(screen, intro_text, GREEN, 145, 100)
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: '# display telemetry and instructions'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: ➋ box_label(screen, 'Dx', (70, 20, 75, 20))
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: box_label(screen, 'Dy', (150, 20, 80, 20))
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: box_label(screen, 'Altitude', (240, 20, 160, 20))
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: box_label(screen, 'Fuel', (410, 20, 160, 20))
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: box_label(screen, 'Eccentricity', (580, 20, 150, 20))
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: ➌ box_label(screen, '{:.1f}'.format(sat.dx), (70, 50, 75, 20))
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: box_label(screen, '{:.1f}'.format(sat.dy), (150, 50, 80, 20))
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: box_label(screen, '{:.1f}'.format(sat.distance), (240, 50, 160, 20))
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
- en: box_label(screen, '{}'.format(sat.fuel), (410, 50, 160, 20))
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: box_label(screen, '{:.8f}'.format(eccentricity), (580, 50, 150, 20))
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: ➍ instruct_label(screen, instruct_text1, WHITE, 10, 575)
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
- en: instruct_label(screen, instruct_text2, WHITE, 570, 510)
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: '# add terminator & border'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
- en: ➎ cast_shadow(screen)
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
- en: ➏ pg.draw.rect(screen, WHITE, (1, 1, 798, 643), 1)
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: ➐ pg.display.flip()
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: '➑ if __name__ == "__main__":'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: main()
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 14-20: Displays text and planet’s shadow and calls the* main() *function*'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
- en: The text summarizing the game should hover near the middle of the screen just
    long enough to be read, then vanish. Control this using an if statement and the
    pygame tick.get_ticks() method, which returns the number of milliseconds that
    have elapsed since the game started. If fewer than 15 seconds have passed, use
    the instruct_label() function to display the list of text strings from [Listing
    14-15](ch14.xhtml#ch14list15) in green.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
- en: Next, make the gauges for the data readouts, starting with the header boxes.
    Use the box_label() function and call it for each of the five readout gauges ➋.
    Repeat this for the data readouts ➌. Note that you can use the string format method
    when you pass the function the text.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: Use the instruct_label() function to place the instructions made in [Listing
    14-15](ch14.xhtml#ch14list15) in the bottom corners of the screen ➍. Feel free
    to change the text color if you want to distinguish between those that describe
    the winning conditions and those that define the key functions.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: Now, call the function that displays the planet’s shadow ➎ and then, as a finishing
    touch, add a border using pygame’s draw.rect() method ➏. Pass it the screen object,
    the border color, the corner coordinates, and a line width.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
- en: Finish the main() function and its game loop by flipping the display ➐. As described
    in the preceding chapter, the flip() method blits everything from the screen object
    to the visual display.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
- en: Finally, call main() in the global space, using the standard syntax for running
    it stand-alone or as a module ➑.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  id: totrans-572
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you used pygame to build a 2D, arcade-style game with image
    sprites, sound effects, and keyboard game controls. You also created a fun, heuristic
    method for learning orbital mechanics. All of the techniques shown in “[Astrodynamics
    for Gamers](ch14.xhtml#lev315)” on [page 286](ch14.xhtml#page_286) should work
    in the game. In the following section, “Challenge Projects,” you can continue
    to improve both the game and the player experience.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
- en: '**Challenge Projects**'
  id: totrans-574
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Make the Mars Orbiter game your own by improving it and adding new challenges
    based on the following suggestions. As always, no solutions are provided to challenge
    projects.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
- en: '***Game Title Screen***'
  id: totrans-576
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Copy and edit the *mars_orbiter.py* program so that a title screen appears for
    a short time before the main game screen. Have the title screen display a NASA-type
    mission patch, like the one for the *Mars Global Surveyor* ([Figure 14-21](ch14.xhtml#ch14fig21)),
    but make it unique to the Mars Orbiter in the game. You can see some other NASA
    patches, in color, at *[https://space.jpl.nasa.gov/art/patches.html](https://space.jpl.nasa.gov/art/patches.html)*.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0320-01.jpg)'
  id: totrans-578
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-21:* Mars Global Surveyor *mission patch*'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
- en: '***Smart Gauges***'
  id: totrans-580
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Copy and edit the *mars_orbiter.py* program so that the altitude and eccentricity
    readouts use either a red background or red text color when their values are outside
    of the target ranges. But be careful: a circular eccentricity value should stay
    red until the altitude value is in range!'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
- en: '***Radio Blackout***'
  id: totrans-582
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Copy and edit the *mars_orbiter.py* program so that keyboard controls are locked
    when the satellite is within the shadow rectangle.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
- en: '***Scoring***'
  id: totrans-584
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Copy and edit the *mars_orbiter.py* program so that it scores the player and
    keeps the best results in a displayable high-scores list. Highest scores go to
    those achieving the lowest allowable orbit while using the least amount of fuel
    in the least amount of time. For example, the fuel component of the score could
    be the amount of remaining fuel; for the orbit component, the maximum allowable
    altitude (120) minus the altitude of the circular orbit; and for the time component,
    the inverse of the time taken to achieve the circular orbit multiplied by 1,000\.
    Add the three components together for the final score.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
- en: '***Strategy Guide***'
  id: totrans-586
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Copy and edit the *mars_orbiter.py* program so it includes a pop-up strategy
    guide, or help file, by incorporating some of the figures in “[Astrodynamics for
    Gamers](ch14.xhtml#lev315)” on [page 286](ch14.xhtml#page_286). For example, add
    a line to the instructions telling the player to press and hold the H key for
    help. This could bring up and cycle through the images of different orbital maneuvers,
    such as the Hohmann transfer or the One-Tangent Burn. Be sure to include comments
    on the strengths and weaknesses of each technique and pause the game while the
    guide is open.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
- en: '***Aerobraking***'
  id: totrans-588
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Aerobraking is a fuel-saving technique that uses atmospheric friction to slow
    down a spacecraft ([Figure 14-22](ch14.xhtml#ch14fig22)). Copy and edit the *mars_orbiter.py*
    program to include aerobraking. In the main() function, set the lowest winning
    altitude to 70 miles and the lowest safe altitude to 60 miles. If the satellite’s
    altitude is between 60 and 70 miles, reduce its velocity by a small amount.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0321-01.jpg)'
  id: totrans-590
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-22: Circularizing an orbit using the atmosphere in place of a retrograde
    burn*'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 14-23](ch14.xhtml#ch14fig23) is an example of using aerobraking in
    the game to circularize an elliptical orbit. The top of the atmosphere was set
    at 80 miles. Aerobraking serves the same purpose as a retrograde burn at periapsis,
    but you have to be cautious and patient and raise the orbit out of the atmosphere
    before it becomes circular.'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0322-01.jpg)'
  id: totrans-593
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-23: Circularizing an orbit using aerobraking. Note the low fuel
    consumption.*'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
- en: NASA used a similar technique to move the *Mars Global Surveyor* from its elliptical
    capture orbit to its final mapping orbit. This process took many months to accomplish,
    because they needed to protect the spacecraft from overheating in the atmosphere.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
- en: '***Intruder Alert!***'
  id: totrans-596
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Copy and edit the *mars_orbiter.py* program so that a new planet object is instantiated
    and flies across the screen, disrupting the satellite’s orbit with its gravity.
    Make a new sprite to represent a comet or asteroid and launch it at random intervals
    (but not *too* often!). Don’t apply Mars’s gravity() method to the object so that
    it doesn’t enter Martian orbit, but apply the new object’s gravity() method to
    the satellite. Play with the new object’s mass so that it noticeably perturbs
    the satellite’s orbit from 100 or so pixels away. Allow the object to pass Mars
    or the satellite without colliding.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
- en: '***Over the Top***'
  id: totrans-598
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Mars Orbiter currently uses an *equatorial* orbit. This is for easy coding,
    since you only need to rotate a single Mars image. But true mapping orbits use
    polar orbits—oriented perpendicular to equatorial orbits—and pass over the planet’s
    poles ([Figure 14-24](ch14.xhtml#ch14fig24)). As the planet rotates beneath the
    orbit, the satellite can map its entire surface. With equatorial orbits, high
    latitudes are essentially unmappable due to curvature of the planet’s surface
    (see the dashed line in [Figure 14-24](ch14.xhtml#ch14fig24)).
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0323-01.jpg)'
  id: totrans-600
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-24: Polar versus equatorial orbits; notional north and south mapping
    limits for an equatorial orbit are represented by the dashed line.*'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
- en: Copy and edit the *mars_orbiter.py* program so that the satellite follows a
    polar orbit. All this involves is changing the Mars image. But you can’t use a
    single top-down image anymore; the view will need to be perpendicular to the planet’s
    axis of rotation. For a video example, see *[https://youtu.be/IP2SDbhFbXk](https://youtu.be/IP2SDbhFbXk)*;
    for an animated gif of Mars, see *[http://gph.is/2caBKKS](http://gph.is/2caBKKS)*.
    You can’t use animated gifs directly in pygame, but you can split out and use
    the individual frames. Tools for splitting out frames can be found online, and
    in the next chapter, you’ll use one of these products to extract images from a
    video.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
