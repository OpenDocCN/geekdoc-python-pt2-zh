- en: '**14'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MAPPING MARS WITH THE MARS ORBITER**
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The *Mars Orbiter* space probe has been successfully injected into Martian orbit,
    but all is not well. The orbit is highly elliptical, and the project’s mapping
    objectives require a low-altitude circular orbit. Fortunately, there’s just enough
    propellant on board to correct things, assuming the eggheads at Mission Control
    have the patience and skill to pull it off!
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll design and build a game based on this scenario. You’ll
    use `pygame` again (for an overview of `pygame`, see “[A Slice of `pygame`](ch13.xhtml#lev296)”
    on [page 267](ch13.xhtml#page_267)), and you’ll do your part to advance STEM (science,
    technology, engineering, and mathematics) education by making the game real enough
    to teach players the fundamentals of orbital mechanics.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Although they share the same name, the* Mars Orbiter *space probe in the game
    bears no direct relationship to the* Mars Orbiter Mission *launched by the* Indian
    Space Research Organization (ISRO) *in 2014\. The game probe is patterned after
    the* Mars Global Surveyor*, launched by NASA in 1996.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Astrodynamics for Gamers**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because you’ll want your game to be as realistic as possible, a quick review
    of some of the basic science underlying spaceflight is in order. This will be
    short, sweet, and tailored to game development and play.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Law of Universal Gravity***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The theory of gravity states that massive objects—like stars and planets—warp
    both space and time around them, similar to how a heavy bowling ball placed on
    a mattress causes a depression that is sudden and sharp near the ball but quickly
    levels off. This behavior is captured mathematically by Isaac Newton’s law of
    universal gravitation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0286-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: where *F* is the force of gravity, *m*[1] is the mass of object 1, *m*[2] is
    the mass of object 2, *d* is the distance between objects, and *G* is the gravitational
    constant (6.674 × 10^(–11) *N* · *m*² · kg^(–2)).
  prefs: []
  type: TYPE_NORMAL
- en: Two objects pull on each other according to the product of their masses divided
    by the square of the distance between them. So, gravity is much stronger when
    objects are close together, like the deep bowing of the mattress just beneath
    the bowling ball. To illustrate, a 220-pound (100 kg) man would weigh over half
    a pound less on top of Mt. Everest than he would at sea level, where he would
    be 8,848 m closer to the center of Earth. (This assumes the mass of the planet
    is 5.98 × 10^(24) kg and sea level is 6.37 × 10⁶ m from the center.)
  prefs: []
  type: TYPE_NORMAL
- en: Today, we generally think of gravity as a *field*—like the mattress in the bowling
    ball analogy—rather than as Newton’s point of attraction. This field is still
    defined with Newton’s law and results in *acceleration*, usually expressed in
    m/sec².
  prefs: []
  type: TYPE_NORMAL
- en: 'According to Newton’s second law of motion, force is equal to mass × acceleration.
    You can calculate the force exerted by object 1 (*m*[1]) on object 2 (*m*[2])
    by rewriting the gravitational equation as:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0286-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: where *a* = acceleration, *G* is the gravitational constant, *m*[1] is the mass
    of one of the objects, and *d* is the distance between objects. The direction
    of force is from object 2 toward the center of mass of object 1 (*m*[1]).
  prefs: []
  type: TYPE_NORMAL
- en: The pull of very small objects on large ones is generally ignored. For example,
    the force exerted by a 1,000 kg satellite on Mars is about 1.6 × 10^(–21) times
    smaller than the force exerted by Mars on the satellite! Thus, you can safely
    ignore the satellite’s mass in your simulation.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*As a simplification in this project, distance is calculated from the center
    points of objects. In real life, an orbiting satellite would experience subtle
    changes in gravitational acceleration due to changes in a planet’s shape, topography,
    crustal density, and so on. According to the* Encyclopedia Britannica*, these
    changes cause gravitational acceleration at Earth’s surface to vary by about 0.5
    percent.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Kepler’s Laws of Planetary Motion***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In 1609, astronomer Johann Kepler discovered that planetary orbits are ellipses,
    allowing him to explain and predict the motion of the planets. He also found that
    a line segment drawn between the sun and an orbiting planet sweeps out equal areas
    in equal time intervals. This idea, known as Kepler’s second law of planetary
    motion, is demonstrated in [Figure 14-1](ch14.xhtml#ch14fig1), where a planet
    is shown at different points in its orbit.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0287-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-1: Kepler’s second law of planetary motion: orbital speed increases
    as planets near the sun.*'
  prefs: []
  type: TYPE_NORMAL
- en: This law applies to all celestial bodies, and it means that an orbiting object
    speeds up as it gets close to the body it is orbiting and slows down as it travels
    farther away.
  prefs: []
  type: TYPE_NORMAL
- en: '***Orbital Mechanics***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Orbiting is basically free-falling forever. You’re falling into the core of
    a planet’s gravity well—located at its literal core—but your tangential velocity
    is fast enough that you keep missing the planet (see [Figure 14-2](ch14.xhtml#ch14fig2)).
    As long as you balance your momentum with the force of gravity, the orbit will
    never end.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0288-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-2: Orbit is achieved when a spacecraft’s velocity keeps it “free-falling”
    around a celestial body.*'
  prefs: []
  type: TYPE_NORMAL
- en: Some counterintuitive things can happen when you orbit a planet in the vacuum
    of space. With no friction or wind resistance, spacecraft can behave in unexpected
    ways.
  prefs: []
  type: TYPE_NORMAL
- en: '**Flying Backward**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you’ve ever watched an episode of *Star Trek*, you’ve probably noticed how
    the orbiting *Enterprise* seems to steer its way around planets, like a car going
    around a track. This is certainly possible to do—and definitely looks cool—but
    it requires the expenditure of precious fuel. If there’s no need to continuously
    point a specific part of a spacecraft at a planet, then the nose of the spacecraft
    will always point in the same direction throughout its orbit. As a result, there
    will be times in each orbit when it appears to fly backward (see [Figure 14-3](ch14.xhtml#ch14fig3)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0288-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-3: Spacecraft retain the same attitude in orbit unless forced to
    do otherwise.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can blame this on Newton and his law of inertia, which states that an object
    at rest stays at rest and an object in motion stays in motion with the same speed
    and in the same direction unless acted upon by an unbalanced force.
  prefs: []
  type: TYPE_NORMAL
- en: '**Raising and Lowering Orbits**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Brakes don’t work in space, there’s no friction, and inertia takes itself very
    seriously. To lower a spacecraft’s orbit, you have to fire thrusters to reduce
    its velocity so that it falls farther into a planet’s gravity well. To accomplish
    this, you have to *retrograde* your spacecraft so that its nose faces away from
    the present velocity vector—a fancy way of saying you have to fly tail-first.
    This assumes, of course, that the main thrusters are at the back of the spacecraft.
    Conversely, if you want to raise the orbit, you have to *prograde* the spacecraft,
    so that its nose will be pointed in the direction you are traveling. These two
    concepts are shown in [Figure 14-4](ch14.xhtml#ch14fig4).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0289-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-4: Prograde and retrograde are defined by the orientation of a spacecraft’s
    nose with respect to the direction it is traveling around the body it is orbiting.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Taking the Inside Track**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you’re chasing another spacecraft in orbit, do you speed up or slow down
    to catch it? According to Kepler’s second law, you slow down. This will lower
    your orbit, resulting in a faster orbital velocity. Just as in horse racing, you
    want to take the inside track.
  prefs: []
  type: TYPE_NORMAL
- en: On the left side of [Figure 14-5](ch14.xhtml#ch14fig5), two space shuttles are
    side by side in essentially the same orbit, traveling at the same velocity.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0289-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-5: The orbital paradox: slow down to speed up!*'
  prefs: []
  type: TYPE_NORMAL
- en: The shuttle closest to the planet rotates 180 degrees and does a retrograde
    thrust to slow its immediate velocity. The outer shuttle performs a prograde thrust
    that increases its immediate velocity. They simultaneously stop thrusting, and
    the inner shuttle drops to a lower orbit while the outer shuttle transfers to
    a higher orbit. After an hour or so, the inner shuttle is traveling much faster,
    due to its closer proximity to the planet, and is well on its way to catch and
    lap the outer shuttle.
  prefs: []
  type: TYPE_NORMAL
- en: '**Circularizing an Elliptical Orbit**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You can make highly elliptical orbits circular by applying engine impulses at
    either the *apoapsis* or *periapsis*, depending on the situation. The apoapsis
    (called the *apogee* if the object is orbiting Earth) is the highest point in
    an elliptical orbit—the point where the object is the farthest away from the body
    it is orbiting ([Figure 14-6](ch14.xhtml#ch14fig6)). The periapsis (*perigee*
    if the object’s orbiting Earth) is the point lowest in an orbit.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0290-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-6: Location of the apoapsis and periapsis in an elliptical orbit*'
  prefs: []
  type: TYPE_NORMAL
- en: To raise the periapsis, the spacecraft performs a prograde thrust at the apoapsis
    (see the left-hand side of [Figure 14-7](ch14.xhtml#ch14fig7)). To lower the orbit
    while circularizing, the spacecraft must perform a retrograde thrust at the periapsis
    (see the right-hand side of [Figure 14-7](ch14.xhtml#ch14fig7)).
  prefs: []
  type: TYPE_NORMAL
- en: A somewhat counterintuitive part of this maneuver is that the initial orbit—that’s
    the orbit that would have been—and the final, or actual, orbit will coincide at
    the point the engine impulse was applied.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0290-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-7: Circularizing and raising an orbit at apoapsis (left) and circularizing
    and lowering an orbit at periapsis (right)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Raising and Lowering Orbits with the Hohmann Transfer**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A *Hohmann transfer orbit* uses an elliptical orbit to switch between two circular
    orbits in the same plane (see [Figure 14-8](ch14.xhtml#ch14fig8)). The orbit can
    be either raised or lowered. The maneuver is relatively slow, but it consumes
    the least possible amount of fuel.
  prefs: []
  type: TYPE_NORMAL
- en: To change to an orbit with both a different periapsis *and* apoapsis, a spacecraft
    requires two engine impulses. One impulse moves the spacecraft onto the transfer
    orbit, and another moves it onto the final, destination orbit. When raising an
    orbit, the spacecraft applies the change in velocity in the direction of motion,
    and when lowering an orbit, it applies the change of velocity opposite to the
    direction of motion. The velocity changes have to occur at opposite sides of the
    orbit, as shown in [Figure 14-8](ch14.xhtml#ch14fig8). Without the second thrust,
    the orbits will still intersect at the point of the first thrust, as shown on
    the right side of [Figure 14-7](ch14.xhtml#ch14fig7).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0291-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: Transferring to a lower circular orbit with the Hohmann transfer
    technique*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Raising and Lowering Orbits with the One-Tangent Burn**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The *One-Tangent Burn* technique transfers a spacecraft between orbits faster
    but less efficiently than a Hohmann transfer. A *burn* is just another term for
    thrust or impulse. As with the Hohmann transfer, orbits can be either raised or
    lowered.
  prefs: []
  type: TYPE_NORMAL
- en: The maneuver requires two engine impulses, the first tangential to the orbit
    and the second nontangential (see [Figure 14-9](ch14.xhtml#ch14fig9)). If the
    initial orbit is circular, as in the figure, then all points along it represent
    both the apoapsis and the periapsis, and the spacecraft can apply its first burn
    at any time.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0291-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Transferring to a higher circular orbit with the One-Tangent
    Burn*'
  prefs: []
  type: TYPE_NORMAL
- en: Just as with the Hohmann transfer, a prograde burn raises the orbit, and a retrograde
    burn lowers it. If the orbit is elliptical, the first burn would be a prograde
    burn at the apoapsis to raise the orbit, or a retrograde burn at periapsis to
    lower it.
  prefs: []
  type: TYPE_NORMAL
- en: '**Executing a Spiral Orbit with the Spiral Transfer**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A *spiral transfer* uses a continuous, low-thrust burn to change the size of
    an orbit. In gameplay, you can simulate this using retrograde or prograde burns
    that are short and regularly spaced, like those shown in [Figure 14-10](ch14.xhtml#ch14fig10).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0292-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Executing a spiral orbit using short retrograde burns at regular
    intervals*'
  prefs: []
  type: TYPE_NORMAL
- en: To lower an orbit, all the burns must be retrograde; to raise an orbit, the
    spacecraft uses prograde burns.
  prefs: []
  type: TYPE_NORMAL
- en: '**Executing Synchronous Orbits**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In a *synchronous orbit*, a spacecraft takes the same amount of time to make
    one revolution around a planet as it takes the planet to make one rotation around
    its axis. If a synchronous orbit is parallel to the equator, with no orbital inclination,
    it is a *stationary* orbit; to an observer on the orbited body, the satellite
    appears motionless in a fixed position in the sky. Communications satellites commonly
    use *geostationary* orbits, which have an altitude of 22,236 miles around Earth.
    A similar orbit would be called *aerostationary* around Mars and *selenostationary*
    around the moon.
  prefs: []
  type: TYPE_NORMAL
- en: '**Project #22: The Mars Orbiter Game**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In real life, a series of equations is used to precisely execute orbital maneuvers.
    In gameplay, you’ll use your intuition, patience, and reflexes! You’ll also need
    to fly by instruments to a certain extent, using mainly the spacecraft’s altitude
    readout and a measure of the orbit’s circularity.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE OBJECTIVE**'
  prefs: []
  type: TYPE_NORMAL
- en: Use `pygame` to build an arcade game that teaches the fundamentals of orbital
    mechanics. The game’s goal is to nudge a satellite into a circular mapping orbit
    without running out of fuel or burning up in the atmosphere.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Strategy**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Start the design phase with a game sketch, as you did in [Chapter 13](ch13.xhtml#ch13).
    This sketch should capture all of the salient points of the game, like how it
    will look, how it will sound, how things will move, and how the game will communicate
    with the player ([Figure 14-11](ch14.xhtml#ch14fig11)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0293-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Sketch of the main gameplay of the Mars Orbiter game*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The sketch in [Figure 14-11](ch14.xhtml#ch14fig11) describes the main gameplay.
    You’ll need a separate sketch to describe the win-lose conditions. For the main
    gameplay, the key points are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The viewpoint is Mission Control.** The game screen should resemble a monitor
    at Mission Control from which the player can operate the errant space probe.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mars is at front and center.** Everybody loves the Red Planet, so it will
    occupy the center of the jet-black screen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mars is animated.** The Martian globe will slowly rotate around its axis
    and cast a shadow. The satellite will dim appreciably when it passes through this
    shadow.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The satellite’s initial orbit is chosen at random.** The satellite will appear
    at startup with a randomized—but constrained—orientation and velocity. On rare
    occasions, this may result in an instant game loss. That’s still better than real
    missions, which fail 47 percent of the time!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**There’s no need to prograde or retrograde the satellite.** Constantly rotating
    the space probe before firing its thrusters greatly diminishes gameplay. Assume
    that attitudinal thrusters are arrayed around the fuselage and use the arrow keys
    to choose which thrusters to fire.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Firing thrusters causes an audible hiss.** Despite the fact that there’s
    no sound in space, give the player the satisfaction of hearing a nice hiss whenever
    they fire the thrusters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The satellite dish always points toward Mars.** The satellite will slowly
    and automatically rotate so that its remote-sensing dish is always aimed at Mars.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The satellite’s orbital path is visible.** A thin white line will trail out
    from behind the satellite and persist until the player clears it by pressing the
    space bar.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The data readouts are placed at the top of the screen.** You will display
    information useful for gameplay in boxes at the top of the window. Key data are
    the space probe’s velocity, altitude, fuel, and orbital eccentricity (a measure
    of the orbit’s circularity).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A short introduction is shown at startup.** Text introducing the game will
    appear at the center of the screen when the game starts and stay up for about
    15 seconds. The text will not disrupt gameplay, so the player can start manipulating
    the satellite immediately.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Win conditions and key controls are shown in permanent legends.** Critical
    information, like mission objectives and control keys, will be displayed permanently
    in the lower-left and -right corners of the screen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The game sketch in [Figure 14-12](ch14.xhtml#ch14fig12) describes what happens
    in success and failure cases. The player needs a reward when they win and an interesting
    outcome when they lose.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0295-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Game sketch of winning versus losing outcomes in the Mars Orbiter
    game*'
  prefs: []
  type: TYPE_NORMAL
- en: 'For winning and losing outcomes, the key points are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Change the satellite image for crash and burn.** If the satellite’s altitude
    drops below 68 miles, it burns up in the atmosphere. The moving satellite image
    will be replaced with a glowing red version that sticks to the side of Mars; this
    is similar to something you might see on a real Mission Control display.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The satellite is lost in space if it runs out of fuel.** Although unrealistic,
    have the satellite fly off the screen and into the depths of space if it runs
    out of fuel. This really rubs the player’s nose in it!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Win conditions unlock a prize.** If the satellite achieves a circular orbit
    within the target altitude range, new text will urge the player to press the M
    key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pressing M changes the Mars image.** When the M key is unlocked, pressing
    it causes the Mars image to change to a rainbow image where cool colors represent
    areas of high soil moisture and warm colors represent drier areas.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For gameplay, the size of the satellite and its orbital speed won’t be realistic,
    but the overall behavior will be correct. You should be able to correctly execute
    all of the orbital maneuvers described in “[Astrodynamics for Gamers](ch14.xhtml#lev315)”
    on [page 286](ch14.xhtml#page_286).
  prefs: []
  type: TYPE_NORMAL
- en: '**Game Assets**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The assets you’ll need for the Mars Orbiter game are two satellite images, two
    planet images, and a sound file. You can prepare these together at the start of
    the process or build them when you need them. The latter approach lets you take
    episodic breaks from coding, which some people prefer.
  prefs: []
  type: TYPE_NORMAL
- en: Finding good, copyright-free graphics and sound files can be a challenge. You
    can find suitable assets online—either for free or for a fee—but it’s best to
    make your own whenever possible. This lets you avoid any legal issues down the
    road.
  prefs: []
  type: TYPE_NORMAL
- en: The sprites (2D icons or images) I used for this project are shown in [Figure
    14-13](ch14.xhtml#ch14fig13). You need a satellite, a red “burned” version of
    the satellite, a view of Mars with a polar cap centered, and the same view with
    a colorful overlay that will represent mapped soil-moisture gradations. I found
    the satellite sprite at the free icon site AHA-SOFT (*[http://www.aha-soft.com/](http://www.aha-soft.com/)*)
    and then copied and recolored it to make the crashed version. Both of the Mars
    sprites are NASA images modified for the game.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0296-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The satellite, crashed satellite, Mars, and Mars overlay images
    used as game sprites*'
  prefs: []
  type: TYPE_NORMAL
- en: I made a sound file for when the satellite is firing its thrusters using the
    white noise generator in the open source program Audacity. You can download a
    free copy of Audacity at *[https://www.audacityteam.org/](https://www.audacityteam.org/)*.
    I saved the file in *Ogg Vorbis* format, an open source standard audio compression
    format that is free and works well with Python and `pygame`. You can use other
    formats, like MP3 and WAV, with `pygame`, but some have documented problems or
    have proprietary components that can raise legal issues if you try to commercialize
    your game.
  prefs: []
  type: TYPE_NORMAL
- en: You can download these files from this book’s website at *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*
    as *satellite.png*, *satellite_crash_40x33.png*, *mars.png*, *mars_water.png*,
    and *thrust_audio.ogg*. Download them, preserving the filenames, into the same
    folder as the code.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Code**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Figure 14-14](ch14.xhtml#ch14fig14) is an example of the final game screen
    you’ll be building. You can refer back to this figure to get an idea of what the
    code is doing.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0297-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-14: Example startup game screen for the final version of* mars_orbiter.py'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the complete program (*mars_orbiter.py*) at *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*.
  prefs: []
  type: TYPE_NORMAL
- en: '***Importing and Building a Color Table***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 14-1](ch14.xhtml#ch14list1) imports the required modules and builds
    a color table.'
  prefs: []
  type: TYPE_NORMAL
- en: '*mars_orbiter.py,* part 1'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-1: Imports modules and builds a color table*'
  prefs: []
  type: TYPE_NORMAL
- en: First, import the operating system, designated by `os` ➊. The game will launch
    in full-screen mode, but the player will have the option of escaping out of full
    screen. This module will let you control the location of the game window after
    the player presses ESC.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll use the `math` module for gravity and trigonometric calculations and
    `random` to start the satellite off with a random position and velocity. Import
    `pygame` as you did in [Chapter 13](ch13.xhtml#ch13), using `pg`, rather than
    `pygame`, to reduce typing.
  prefs: []
  type: TYPE_NORMAL
- en: Finish by building an RGB color table ➋ as you did in [Chapter 13](ch13.xhtml#ch13).
    This lets you type in color names, rather than RGB-value tuples, when you need
    to assign one of these colors.
  prefs: []
  type: TYPE_NORMAL
- en: '***Defining the Satellite Class Initialization Method***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 14-2](ch14.xhtml#ch14list2) defines the `Satellite` class and its
    initialization method, which you’ll use to instantiate a satellite object in the
    game. Since this method definition is long, it’s split over two listings.'
  prefs: []
  type: TYPE_NORMAL
- en: '*mars_orbiter.py,* part 2'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-2: Defines the first part of the* Satellite *class initialization
    method*'
  prefs: []
  type: TYPE_NORMAL
- en: Define a class for a `Satellite` object ➊; if you need a refresher on object-oriented
    programming, read [Chapter 11](ch11.xhtml#ch11). Pass it the `pygame` `Sprite`
    class, as objects instantiated from the `Satellite` class will be sprites. As
    described in [Chapter 13](ch13.xhtml#ch13), `Sprite` is a built-in class that
    serves as a template for making sprites. Your new class will inherit features
    that your sprites will need from this base class. These include important attributes
    like `rect` and `image`, which you’ll deal with shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Next, define the `__init__()` method for the `Satellite` object ➋ and pass it
    `self`, which—by convention—is a special name within a class definition that refers
    to the current object. You also need to pass the method a `background` object.
    The satellite’s path will be drawn on this object.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `__init_()` method, immediately invoke the initialization method
    for the built-in `Sprite` class using `super` ➌. This will initialize the sprite
    and establish the `rect` and `image` attributes it needs. With `super`, you don’t
    need to refer to the base class (`Sprite`) explicitly. For more on `super`, see
    [Listing 11-5](ch11.xhtml#ch11list5) on [page 229](ch11.xhtml#page_229) or visit
    the docs at *[https://docs.python.org/3/library/functions.html?highlight=super#super](https://docs.python.org/3/library/functions.html?highlight=super#super)*.
  prefs: []
  type: TYPE_NORMAL
- en: Next, assign the `background` to `self` as an object attribute ➍. Then use `pygame`’s
    `image.load()` method to load your two satellite images—one operational and one
    crashed—and in the same step, run the `convert()` method on them ➎. This converts
    the object into a graphic format that `pygame` can use efficiently once the game
    loop starts. Without this step, the game may slow noticeably as the `png` format
    is converted, on the fly, 30 or more times per second.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll use only one of the satellite images at a time, depending on whether
    or not the player burned up in the atmosphere, so use a generic `self.image` attribute
    to hold the loaded and converted image ➏. The unburned satellite image will be
    the default image; it will be replaced with the red crashed image if the satellite
    object gets too close to Mars.
  prefs: []
  type: TYPE_NORMAL
- en: Now, get the rectangle information for the image ➐. Remember that `pygame` places
    the sprites on rectangular surface objects, and it needs to know the dimensions
    and location of these rectangles as the game runs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, make the black parts of the satellite image invisible ➑. The satellite
    icon is on a field of black (see [Figure 14-13](ch14.xhtml#ch14fig13)), and you
    want the crashed-and-burned image to plot partially over Mars, so use the `BLACK`
    constant with the image object’s `colorkey()` method in order to make the icon’s
    background transparent. Otherwise, you’ll see a black box with a red satellite
    overlapping the Red Planet. Note that if you want to type in the RGB equivalent
    for black, you need to enter it as a tuple: `(0, 0, 0)`.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Setting the Satellite’s Initial Position, Speed, Fuel, and Sound***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 14-3](ch14.xhtml#ch14list3) completes the definition of the `Satellite`
    class initialization method. The satellite object’s initial position and velocity
    are chosen at random from a limited range of choices; the orientation of the remote-sensing
    dish is initialized, the fuel tank topped off, and sound effects added.'
  prefs: []
  type: TYPE_NORMAL
- en: '*mars_orbiter.py,* part 3'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-3: Completes the* Satellite *class initialization method by initializing
    parameters*'
  prefs: []
  type: TYPE_NORMAL
- en: When the game starts, the satellite will appear at a random point near the top
    of the screen. You’ll choose the exact location from a range of x- and y-values
    ➊.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also choose the satellite’s velocity at random, but it will be slow enough
    that the satellite can’t escape from orbit. Randomly set the velocity to either
    –3 or 3\. Negative values result in a counterclockwise orbit, and vice versa.
    Use the delta-x (`dx`) attribute only ➋ and let gravity take care of `dy`. As
    discussed in [Chapter 13](ch13.xhtml#ch13), `pygame` moves sprites around the
    screen using incremental changes in the x-location (called delta-x or *dx*) and
    incremental changes in the y-location (called delta-y or *dy*). These vector components
    are calculated and added to the sprite’s current position (`self.x`, `self.y`)
    with each game loop.
  prefs: []
  type: TYPE_NORMAL
- en: Next, set the `dy` attribute to `0` ➌. Later, the `gravity()` method will establish
    an initial `dy` value when it accelerates the newly instantiated satellite downscreen
    toward the planet.
  prefs: []
  type: TYPE_NORMAL
- en: Assign an attribute for the satellite’s heading ➍. The remote-sensing dish,
    which will read soil moisture on the planet’s surface, should always point toward
    Mars, and if you remember from [Figure 14-3](ch14.xhtml#ch14fig3), this won’t
    occur unless you overcome inertia. You’ll use a method to actually rotate the
    satellite, so for now, just initialize the `heading` attribute with `0`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, top off the fuel tank with 100 units of fuel ➎. If you want to relate this
    to real life, it would probably represent 100 kilograms of hydrazine, similar
    to what was used in the *Magellan* probe that mapped Venus.
  prefs: []
  type: TYPE_NORMAL
- en: Next, set the object’s mass to `1`. This basically means you’ll just use the
    mass of Mars in the gravity equation, because you multiply the masses of two objects
    together. As stated earlier, the pull of the satellite on Mars is inconsequential,
    so you don’t need to calculate it. The satellite’s `mass` attribute is included
    for completeness and as a placeholder in case you want to experiment with different
    values later.
  prefs: []
  type: TYPE_NORMAL
- en: The following `distance` attribute stores the distance between the satellite
    and the body it is orbiting. The actual value will be calculated by a method you’ll
    define later.
  prefs: []
  type: TYPE_NORMAL
- en: It’s time to add sound effects. You’ll initialize `pygame`’s sound mixer in
    the `main()` function, but for now, name a `thrust` attribute for the thrusting
    sound effect ➏. Pass the mixer’s `Sound` class the short clip of white noise in
    Ogg Vorbis format (*.ogg*). Finally, set the playback volume, using values between
    0 and 1 ➐. You may need to calibrate this to your PC. Ideally, you want a value
    that every player will be able to at least *hear* and then fine-tune with their
    own computer’s volume control.
  prefs: []
  type: TYPE_NORMAL
- en: '***Firing Thrusters and Checking for Player Input***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 14-4](ch14.xhtml#ch14list4) defines the `thruster()` and `check_keys()`
    methods of the `Satellite` class. The first determines the actions taken if one
    of the satellite’s thrusters is fired. The second checks whether a player has
    interacted with the thrusters by pressing an arrow key.'
  prefs: []
  type: TYPE_NORMAL
- en: '*mars_orbiter.py,* part 4'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-4: Defines the* thruster() *and* check_keys() *methods for the*
    Satellite *class*'
  prefs: []
  type: TYPE_NORMAL
- en: The `thruster()` method takes `self`, `dx`, and `dy` as arguments ➊. The last
    two arguments, which can be positive or negative, are immediately added to the
    satellite’s `self.dx` and `self.dy` velocity components ➋. Next, the fuel level
    is decreased by two units ➌. Altering this value is one way to make the game either
    harder or easier. Finish by calling the `play()` method on the `thrust` audio
    attribute to make the hissing sound ➍. Note that, instead of *returning* values,
    OOP methods *update* existing object attributes.
  prefs: []
  type: TYPE_NORMAL
- en: The `check_keys()` method takes `self` as an argument ➎. First you use the `pygame`
    `key` module to determine whether the player has pressed a key ➏. The `get_pressed()`
    method returns a tuple of Boolean values—`1` for `True` and `0` for `False`—that
    represent the current state of each key on the keyboard. `True` means a key has
    been pressed. You can index this tuple by using the key constants. You can find
    a list of all the keyboard constants at *[https://www.pygame.org/docs/ref/key.html](https://www.pygame.org/docs/ref/key.html)*.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the right arrow key is `K_RIGHT`. If this key has been pressed
    ➐, call the `thruster()` method and pass it `dx` and `dy` values ➑. In `pygame`,
    x-values increase toward the right of the screen, and y-values increase toward
    the bottom of the screen. So, if the user presses the left arrow key, subtract
    from `dx`; likewise, if the up arrow is pressed, decrement the `dy` value. The
    right arrow will increase `dx`, and the down arrow will increase `dy`. Readouts
    at the top of the screen will help the player relate the satellite’s movements
    to the underlying `dx` and `dy` values (see [Figure 14-14](ch14.xhtml#ch14fig14)).
  prefs: []
  type: TYPE_NORMAL
- en: '***Locating the Satellite***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Still in the `Satellite` class, [Listing 14-5](ch14.xhtml#ch14list5) defines
    the `locate()` method. This method calculates the distance of the satellite from
    the planet and determines the heading for pointing the dish at the planet. You’ll
    use the distance attribute later when calculating the force of gravity and the
    *eccentricity* of the orbit. Eccentricity is a measurement of the deviation of
    an orbit from a perfect circle.
  prefs: []
  type: TYPE_NORMAL
- en: '*mars_orbiter.py,* part 5'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-5: Defines the* locate() *method for the* Satellite *class*'
  prefs: []
  type: TYPE_NORMAL
- en: To locate the satellite, you need to pass the `locate()` method the `satellite`
    (`self`) and `planet` objects ➊. First, determine the distance between the objects
    in x-y space. Get the planet’s x- and y-attributes ➋; then subtract them from
    the satellite’s x- and y-attributes ➌.
  prefs: []
  type: TYPE_NORMAL
- en: Now, use these new distance variables to calculate the angle between the satellite’s
    heading and the planet so you can rotate the satellite dish toward the planet.
    The `math` module uses radians, so assign a local variable called `planet_dir_radians`
    to hold the direction in radians and pass `dist_x` and `dist_y` to the `math.atan2()`
    function to calculate the arc tangent ➍. Since `pygame` uses degrees (sigh), convert
    the angle from radians to degrees using the standard formula; alternatively, you
    could use `math` to do this, but sometimes it’s good to see the man behind the
    curtain ➎. This should be a sharable attribute of the satellite object, so name
    it `self.heading`.
  prefs: []
  type: TYPE_NORMAL
- en: In `pygame`, the front of a sprite is to the east by default, which means the
    satellite sprite is orbiting tail-first (see the satellite icon in [Figure 14-13](ch14.xhtml#ch14fig13)).
    To get the dish to point toward Mars, you need to subtract 90 degrees from the
    heading, because negative angles result in *clockwise* rotation in `pygame` ➏.
    This maneuver will use none of the player’s fuel allotment.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, get the Euclidian distance between the satellite and Mars by using
    the `math` module to calculate the hypotenuse from the x- and y-components ➐.
    You should make this an attribute of the satellite object since you will use it
    later in other functions.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In real life, there are multiple ways to keep the dish of a satellite pointed
    toward a planet without expending large amounts of fuel. Techniques include slowly
    tumbling or spinning the satellite, making the dish end heavier than the opposite
    end, using magnetic torque, or using internal flywheels—also known as reaction
    wheels or momentum wheels. Flywheels use electric motors that can be powered by
    solar panels, eliminating the need for heavy and toxic liquid propellant.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Rotating the Satellite and Drawing Its Orbit***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 14-6](ch14.xhtml#ch14list6) continues the `Satellite` class by defining
    methods for rotating the satellite dish toward the planet and drawing a path behind
    it. Later, in the `main()` function, you’ll add code that lets the player erase
    and restart the path by pressing the space bar.'
  prefs: []
  type: TYPE_NORMAL
- en: '*mars_orbiter.py,* part 6'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-6: Defines the* rotate() *and* path() *methods of the* Satellite
    *class*'
  prefs: []
  type: TYPE_NORMAL
- en: The `rotate()` method will use the `heading` attribute, which you calculate
    in the `locate()` method, to turn the satellite dish toward Mars. Pass `self`
    to `rotate()` ➊, which means `rotate()` will automatically take the name of the
    satellite object as an argument when it is called later.
  prefs: []
  type: TYPE_NORMAL
- en: Now, rotate the satellite image using `pygame`’s `transform.rotate()` method
    ➋. Pass it the original image followed by the `heading` attribute; assign these
    to the `self.image` attribute so you don’t degrade the original master image.
    You’ll need to transform the image with each game loop, and transforming an image
    rapidly degrades it. So always keep a master image and work off a new copy every
    time you do a transformation.
  prefs: []
  type: TYPE_NORMAL
- en: End the function by getting the transformed image’s `rect` object ➌.
  prefs: []
  type: TYPE_NORMAL
- en: Next, define a method called `path()` and pass it `self` ➍. This will draw a
    line marking the satellite’s path, and since you need two points to draw a line,
    assign a variable to record the satellite’s center location as a tuple prior to
    moving it ➎. Then increment the x- and y-locations with the `dx` and `dy` attributes
    ➏. Finish by using `pygame`’s `draw.line()` method to define the line ➐. This
    method needs a drawing object, so pass it the `background` attribute, followed
    by the line color and the previous and current x-y location tuples.
  prefs: []
  type: TYPE_NORMAL
- en: '***Updating the Satellite Object***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 14-7](ch14.xhtml#ch14list7) updates the satellite object and completes
    the class definition. Sprite objects almost always have an `update()` method that
    is called once per frame as the game runs. Anything that happens to the sprite,
    such as movement, color changes, user interactions, and so on, is included in
    this method. To keep them from becoming too cluttered, `update()` methods mostly
    call other methods.'
  prefs: []
  type: TYPE_NORMAL
- en: '*mars_orbiter.py,* part 7'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-7: Defines the* update() *method for the* Satellite *class*'
  prefs: []
  type: TYPE_NORMAL
- en: Start by defining the `update()` method and passing it the object, or `self`
    ➊. Next, call the methods that you defined earlier. The first of these checks
    for player interactions made through the keyboard ➋. The second rotates the satellite
    object so that the dish keeps pointing toward the planet ➌. The final method updates
    the satellite’s x-y location and draws a path behind it so you can visualize the
    orbit ➍.
  prefs: []
  type: TYPE_NORMAL
- en: The program needs to keep track of the satellite sprite’s location as it orbits
    Mars, so assign a `rect.center` attribute and set it to the satellite’s current
    x-y location ➎.
  prefs: []
  type: TYPE_NORMAL
- en: The final bit of code changes the satellite image in the event the player crashes
    and burns in the atmosphere ➏. The top of the Martian atmosphere is about 68 miles
    above its *surface*. For reasons I’ll explain later, assume that an altitude value
    of 68—which is measured in pixels from the *center* of the planet—equates to the
    top of the atmosphere. If the satellite dips below this altitude during gameplay,
    the `main()` function will set its velocity—represented by `dx` and `dy`—to `0`.
    Check that these values are both `0`, and if so, change the image to `image_crash`
    and set its background to transparent (as you did previously for the main satellite
    image).
  prefs: []
  type: TYPE_NORMAL
- en: '***Defining the Planet Class Initialization Method***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 14-8](ch14.xhtml#ch14list8) defines the `Planet` class, which you’ll
    use to instantiate a `planet` object.'
  prefs: []
  type: TYPE_NORMAL
- en: '*mars_orbiter.py,* part 8'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-8: Begins definition of the* Planet *class*'
  prefs: []
  type: TYPE_NORMAL
- en: You are probably very familiar with the initial steps to creating the `Planet`
    class by now. First, you name the class with a capital letter, then pass it the
    `Sprite` class so it will conveniently inherit features from this built-in `pygame`
    class ➊. Next, you define an `__init__()`, or initialization, method for your
    `planet` object ➋. Then you call the `super()` initialization method, as you did
    for the `Satellite` class.
  prefs: []
  type: TYPE_NORMAL
- en: Load the images as attributes and convert them to `pygame`’s graphic format
    at the same time ➌. You need both the normal Mars image and the one for mapped
    soil moisture. You were able to use the satellite sprite at its native size, but
    the Mars image is too large. Scale the image to 100 pixels × 100 pixels ➍ and
    assign the scaled image to a new attribute so repeated transformations won’t degrade
    the master image.
  prefs: []
  type: TYPE_NORMAL
- en: Now, set the transformed image’s transparent color to black, as you did earlier
    with the satellite image ➎. Sprites in `pygame` are all “mounted” on rectangular
    surfaces, and if you don’t make black invisible, the corners of the planet surface
    may overlap and cover the white-colored orbital path drawn by the satellite (see
    [Figure 14-15](ch14.xhtml#ch14fig15)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0305-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-15: Corners of Mars* rect *covering orbital path*'
  prefs: []
  type: TYPE_NORMAL
- en: As always, get the sprite’s `rect` object ➏. There’s another transformation
    to come, so copy the image attribute again and assign it the logical name of `self.image`.
  prefs: []
  type: TYPE_NORMAL
- en: To apply the force of gravity, the planet needs mass, so name a `mass` attribute
    and assign it a value of `2000` ➐. Earlier, you assigned the satellite a mass
    of `1`; this means that Mars is only 2,000 times as massive as a satellite! That’s
    okay, because you aren’t working in real-world units, and the time and distance
    scales differ from reality. If you scale distances so that the satellite is only
    a few hundred pixels from Mars, you have to scale gravity as well. Despite this,
    the satellite will still behave realistically with respect to gravity.
  prefs: []
  type: TYPE_NORMAL
- en: The planet’s mass value was determined through experimentation. To scale the
    force of gravity, you can either change this mass value or use the gravitational
    constant (`G`) variable later.
  prefs: []
  type: TYPE_NORMAL
- en: Set the `planet` object’s `x` and `y` attributes to the center point of the
    screen—you’ll use a screen size of 800 × 645 in the `main()` function—and assign
    these values to the `rect` object’s center ➑.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, assign the attributes you’ll need to slowly rotate Mars about its axis
    ➒. You’ll use the same `transform.rotate()` method you used to turn the satellite,
    so you need to create an `angle` attribute. Then, use a `rotate_by` attribute
    to assign the increment—in degrees—by which this rotation angle changes with each
    game loop.
  prefs: []
  type: TYPE_NORMAL
- en: '***Rotating the Planet***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 14-9](ch14.xhtml#ch14list9) continues the `Planet` class by defining
    its `rotate()` method. This method rotates the planet around its axis, making
    small changes with each game loop.'
  prefs: []
  type: TYPE_NORMAL
- en: '*mars_orbiter.py,* part 9'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-9: Defines a method to rotate the planet around its axis*'
  prefs: []
  type: TYPE_NORMAL
- en: The `rotate()` method also takes the object as an argument ➊. As the square
    Mars image is rotating, the bounding rectangle object (`rect`) remains stationary
    and must expand to accommodate the new configuration (see [Figure 14-16](ch14.xhtml#ch14fig16)).
    This change in size can affect the center point of the `rect`, so assign a `last_center`
    variable and set it to the planet’s current center point ➋. If you don’t do this,
    Mars will wobble around its axis as the game runs.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0306-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-16: The bounding rectangle changes size to accommodate rotating
    images.*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, rotate the copied image using `pygame`’s `transform.rotate()` method and
    assign it to the `self.image` attribute ➌; you need to pass the method the copied
    image and the `angle` attribute. Immediately after rotating, reset the image’s
    `rect` attribute and move its center location back to `last_center` in order to
    mitigate any shifting of `rect` that occurred during rotation ➍.
  prefs: []
  type: TYPE_NORMAL
- en: When the `planet` object is instantiated, the angle attribute will start at
    0 degrees, then increase by 0.1—assigned in the `rotate_by` attribute—with each
    frame ➎.
  prefs: []
  type: TYPE_NORMAL
- en: '***Defining the gravity() and update() Methods***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 14-10](ch14.xhtml#ch14list10) completes the `Planet` class by defining
    the `gravity()` and `update()` methods. In [Chapter 13](ch13.xhtml#ch13), you
    treated gravity as a constant applied in the y-direction. The method applied here
    is slightly more sophisticated, because it takes into account the distance between
    two objects.'
  prefs: []
  type: TYPE_NORMAL
- en: '*mars_orbiter.py,* part 10'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-10: Defines the* gravity() *and* update() *methods of the* Planet
    *class*'
  prefs: []
  type: TYPE_NORMAL
- en: Define the `gravity()` method and pass it `self` and the satellite object ➊.
    You’re still in the `Planet` class, so `self` here represents Mars.
  prefs: []
  type: TYPE_NORMAL
- en: Start by naming a local variable `G`; an uppercase G is the *universal gravitational
    constant*, also known as the *constant of proportionality* ➋. In real life, this
    is a very small, empirically derived number, which is basically a conversion number
    to get all the units to work out correctly. You’re not using real-world units
    in the game, so set this to `1`; this way, it won’t have an impact on the gravity
    equation. During game development, you can tweak this constant up or down to fine-tune
    the force of gravity and its effect on orbiting objects.
  prefs: []
  type: TYPE_NORMAL
- en: You need to know how far apart the two objects are, so get their distance in
    the x-direction and the y-direction ➌. Then, use the `math` module’s `hypot()`
    method to get the Euclidian distance. This will represent the *r* in the gravity
    equation.
  prefs: []
  type: TYPE_NORMAL
- en: Since you’re going to directly address the *magnitude* of the distance between
    the satellite and Mars in the gravity equation, all you need from the distance
    vector is *direction*. So, divide `dist_x` and `dist_y` by `distance` to “normalize”
    the vector to a unit vector with a magnitude of `1` ➍. You are basically dividing
    the length of each side of a right triangle by its hypotenuse. This preserves
    the vector’s direction, represented by the relative differences in `dist_x` and
    `dist_y`, but sets its magnitude to `1`. Note that if you don’t perform this normalization
    step, the results will be unrealistic but interesting (see [Figure 14-17](ch14.xhtml#ch14fig17)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0308-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-17: “Spirograph” orbit resulting from use of an unnormalized distance
    vector*'
  prefs: []
  type: TYPE_NORMAL
- en: Calculate the force of gravity using Newton’s equation, which I described in
    “[The Law of Universal Gravity](ch14.xhtml#lev316)” on [page 286](ch14.xhtml#page_286)
    ➎. Finish by multiplying the normalized distances by `force`—to calculate by how
    much acceleration changes velocity in each step—and add these amounts to the satellite
    object’s `dx` and `dy` attributes ➏.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you don’t assign most of these variables as attributes of `self`.
    These just represent intermediate steps within a method that don’t need to be
    shared with other methods, and you can treat them as you would local variables
    in procedural programming.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, define a method that will be called every game loop to update the `planet`
    object ➐. Use it to call the `rotate()` method.
  prefs: []
  type: TYPE_NORMAL
- en: '***Calculating Eccentricity***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You’re through defining classes. Now it’s time to define some functions that
    will help with running the game. [Listing 14-11](ch14.xhtml#ch14list11) defines
    a function to calculate the eccentricity of the satellite’s orbit. The player
    will need to achieve a circular orbit within a certain altitude range, and this
    function will provide the measurement of circularity.
  prefs: []
  type: TYPE_NORMAL
- en: '*mars_orbiter.py,* part 11'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '*[Listing 14-11](ch14.xhtml#ch14list11): Defines a function to measure orbital
    eccentricity*'
  prefs: []
  type: TYPE_NORMAL
- en: Define the `calc_eccentricity()` function and pass it a list of distances ➊.
    In the `main()` function, you’ll append the `sat.distance` attribute—which records
    the satellite’s altitude—to this list during every game loop. To calculate eccentricity,
    you need to know both the apoapsis and periapsis of the orbit. Get these by finding
    the maximum and minimum values in this list ➋. Then, calculate `eccentricity`
    ➌. Later, in the `main()` function, you’ll display this number to eight decimal
    places, just to look cool and precise in the readout.
  prefs: []
  type: TYPE_NORMAL
- en: Note that circular orbits will have the same value for both apoapsis and periapsis,
    and so the calculation will yield `0` for a perfect circle. End the function by
    returning the `eccentricity` variable.
  prefs: []
  type: TYPE_NORMAL
- en: '***Defining Functions to Make Labels***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The game will need a fair amount of text for instructions and telemetry readouts.
    Displaying this text one string at a time can result in a lot of code redundancy,
    so [Listing 14-12](ch14.xhtml#ch14list12) will define two functions—one to post
    instructions and another for the streams of velocity, altitude, fuel, and eccentricity
    data you’ll need to share with the player.
  prefs: []
  type: TYPE_NORMAL
- en: '*mars_orbiter.py,* part 12'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-12: Defines functions to make instruction and readout labels*'
  prefs: []
  type: TYPE_NORMAL
- en: Define a function called `instruct_label()` for displaying instructions on the
    game screen ➊. Pass it the screen, a list containing the text, a text color, and
    the coordinates for the upper-left corner of the `pygame` `surface` object that
    will hold the text.
  prefs: []
  type: TYPE_NORMAL
- en: Next, tell `pygame` which font to use ➋. The arguments for the `font.SysFont()`
    method are the typeface and size. Using `None` for the typeface invokes `pygame`’s
    built-in default font, which should work on multiple platforms. Note that the
    method accepts both `None` and `'None'`.
  prefs: []
  type: TYPE_NORMAL
- en: The introduction and instruction text will take up multiple lines (see the example
    in [Figure 14-14](ch14.xhtml#ch14fig14)). You’ll need to specify the line spacing,
    in pixels, between the text strings, so assign a variable for this and set it
    to `22` ➌.
  prefs: []
  type: TYPE_NORMAL
- en: Now, start looping through the list of text strings ➍. Use `enumerate()` to
    get an index, which you’ll use with the `line_spacing` variable to post the strings
    in the correct locations. The text will need to be placed on a surface. Name this
    surface `label`, pass the `font.render()` method the line of text you want to
    display, set antialiasing to `True` for smoother text, color the text, and set
    the background color to black. Finish by blitting the surface to the screen. Pass
    the method the `label` variable and the upper-left-corner coordinates, with `y`
    defined as `y + index * line_spacing`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, define a function called `box_label()` for the data readout labels that
    will appear as gauges at the top of the screen (see [Figure 14-18](ch14.xhtml#ch14fig18))
    ➎. Parameters for this function are the screen, some text, and a tuple containing
    the dimensions of the rectangular surface that will form the gauge.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0310-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-18: Readout labels at the top of the game window (header label above
    and data label below)*'
  prefs: []
  type: TYPE_NORMAL
- en: The surfaces made by the `instruct_label()` function will automatically change
    size to accommodate the amount of text being displayed. This works fine for static
    displays, but the readout data will change constantly, causing your gauges to
    expand and shrink as they adjust to fit the text inside them. To mitigate this,
    you’ll use a stand-alone `rect` object of a specified size to form a base for
    your text object.
  prefs: []
  type: TYPE_NORMAL
- en: Start the function by setting the font, as you did in ➋. Assign a variable called
    `base` to a `pygame` `rect` object; use the `dimensions` argument for the size
    ➏. This argument lets you precisely place the position of the box by specifying
    the left and top coordinates of the rectangle, followed by its width and height.
    The resulting rectangle should be wide enough to handle the longest possible readout
    the game will produce for the data type being displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Now, draw the `base` using the `draw_rect()` method ➐. The arguments are the
    drawing surface, a fill color, the name of the `rect`, and a width of `0`, which
    fills the rectangle rather than drawing a border. You’ll post your text object
    on top of this white rectangle.
  prefs: []
  type: TYPE_NORMAL
- en: Repeat the code that renders the text ➑, then get the `rect` for the `label`
    ➒. Note that in the `get_rect()` method there’s a parameter that sets the center
    equal to the center of `base`. This lets you place the text label on top of the
    white base rectangle. Finally, blit to the screen, specifying the source and destination
    rects ➓.
  prefs: []
  type: TYPE_NORMAL
- en: '***Mapping Soil Moisture***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 14-13](ch14.xhtml#ch14list13) defines functions that allow the player
    to “map” Mars if the game’s winning conditions have been met. When the player
    presses the M key, these functions will be called by the `main()` function, and
    the planet’s image will be replaced with a colorful overlay we’ll pretend represents
    soil moisture content. When the player releases the key, the normal view of Mars
    will return. The key checks will also be performed in the `main()` function.'
  prefs: []
  type: TYPE_NORMAL
- en: '*mars_orbiter.py,* part 13'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-13: Defines functions to let the player make a soil moisture map
    of Mars*'
  prefs: []
  type: TYPE_NORMAL
- en: Start by defining a function that takes as an argument the `planet` object ➊.
    Start by assigning a `last_center` variable as you did in [Listing 14-9](ch14.xhtml#ch14list9);
    this will be used to keep the planet from wobbling on its axis ➋.
  prefs: []
  type: TYPE_NORMAL
- en: Next, scale the water image of Mars to the same size as the normal image and
    assign this to the planet’s `image_copy` attribute, because transformations degrade
    an image if used repeatedly ➌. Set the image’s background to transparent ➍, get
    its `rect`, and set the center of the `rect` equal to the `last_center` variable;
    that way Mars will stay put at the center of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Now, define another function for when the player stops actively mapping Mars
    ➎. It also takes the `planet` object as an argument. All you need to do is reset
    the planet image to the original version ➏. Because you’re still using the `image_copy`
    attribute, you don’t need to get the `rect` again, but you do need to set the
    transparent color.
  prefs: []
  type: TYPE_NORMAL
- en: '***Casting a Shadow***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 14-14](ch14.xhtml#ch14list14) defines a function that gives Mars a
    “dark side” and casts a shadow behind the planet. The shadow will be a black,
    semitransparent rectangle with its right edge coincident with the center of the
    planet sprite (see [Figure 14-19](ch14.xhtml#ch14fig19)). This assumes the sun
    is to the right of the screen and that it is either the vernal or autumnal equinox
    on Mars.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0312-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-19: Shadow rectangle in semitransparent white (left) and final semitransparent
    black (right)*'
  prefs: []
  type: TYPE_NORMAL
- en: '*mars_orbiter.py,* part 14'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-14: Defines a function to give Mars a dark side and let it cast
    a shadow*'
  prefs: []
  type: TYPE_NORMAL
- en: The `cast_shadow()` function takes the `screen` object as an argument ➊. Assign
    a 400 pixel × 100 pixel `pygame` surface to an object named `shadow` ➋. Use `pygame`’s
    `SRCALPHA` flag—for “source alpha”—to indicate you will use per pixel alpha (transparency).
    Fill the object with black and set alpha—represented by the last number—to `210`
    ➌. Alpha is part of the RGBA color system and has valid values of 0 through 255,
    so this is very dark but not completely opaque. Finally, blit the surface to the
    screen, along with the coordinates for its top-left corner. To turn off the shadow,
    just comment out the function call in `main()` or set the alpha value to `0`.
  prefs: []
  type: TYPE_NORMAL
- en: '***Defining the main() Function***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 14-15](ch14.xhtml#ch14list15) begins the definition of the `main()`
    function that runs the game. The `pygame` package and the sound mixer are initialized,
    the game screen is set up, and instructions for the player are stored as lists.'
  prefs: []
  type: TYPE_NORMAL
- en: '*mars_orbiter.py,* part 15'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-15: Starts the* main() *function by initializing* pygame *and the
    sound mixer and by setting up the game screen and instructions*'
  prefs: []
  type: TYPE_NORMAL
- en: Start the `main()` function by initializing `pygame` ➊. Then, use the `os` module’s
    `environ()` method to assign the coordinates of the upper-left corner of the game
    window ➋. This step is not strictly necessary, but I wanted to demonstrate that
    you have control over where windows appear on the desktop.
  prefs: []
  type: TYPE_NORMAL
- en: Next, assign a variable to hold the `screen` object and set the display mode
    to full screen ➌. Use the tuple `(800, 645)` to specify the screen size to use
    if the player escapes from full-screen mode.
  prefs: []
  type: TYPE_NORMAL
- en: Now use `pygame`’s `display.set_caption()` method to name the game window “Mars
    Orbiter” ➍. Then, use `pygame`’s `Surface` class to create a background object
    for the game that’s the same size as the screen ➎.
  prefs: []
  type: TYPE_NORMAL
- en: Initialize `pygame`’s sound mixer so you can play the thruster sound effect
    ➏. You defined this sound earlier in the satellite’s initialization method.
  prefs: []
  type: TYPE_NORMAL
- en: The game will start with a short introduction that will vanish after 15 seconds.
    Permanent legends describing keyboard controls and win conditions occupy the bottom
    corners of the screen. Enter the text for these as lists ➐. Later, you will pass
    these lists to the `instruct_label()` function you wrote in [Listing 14-12](ch14.xhtml#ch14list12).
    Each item in the list, delineated by a comma, will appear as a separate line in
    the game window (see [Figure 14-19](ch14.xhtml#ch14fig19)).
  prefs: []
  type: TYPE_NORMAL
- en: '***Instantiating Objects, Setting Up Orbit Verification, Mapping, and Timekeeping***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 14-16](ch14.xhtml#ch14list16), still in the `main()` function, instantiates
    the `planet` and `satellite` objects, assigns some useful variables for determining
    orbital eccentricity, prepares the game clock within the function, and assigns
    a variable to track the state of the mapping functionality.'
  prefs: []
  type: TYPE_NORMAL
- en: '*mars_orbiter.py,* part 16'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-16: Instantiates objects and assigns useful variables in* main()'
  prefs: []
  type: TYPE_NORMAL
- en: Continue the `main()` function by creating a `planet` object from the `Planet`
    class ➊, then place it in a sprite group ➋. Remember from [Chapter 13](ch13.xhtml#ch13)
    that `pygame` manages sprites using containers called *groups*.
  prefs: []
  type: TYPE_NORMAL
- en: Next, instantiate a satellite object, passing the `Satellite` class’s initialization
    method the `background` object ➌. The satellite needs the `background` for drawing
    its path.
  prefs: []
  type: TYPE_NORMAL
- en: After creating the satellite, put it in its own sprite group ➍. You should generally
    keep radically different sprite types in their own containers. This makes it easy
    to manage things like display order and collision handling.
  prefs: []
  type: TYPE_NORMAL
- en: Now, assign some variables to help with calculating eccentricity. Start an empty
    list to hold the distance values calculated in each game loop ➎, then assign an
    `eccentricity` variable a placeholder value of `1` ➏, indicating a noncircular
    starting orbit.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll want to update the `eccentricity` variable regularly to evaluate any
    changes the player makes to the orbit. Remember, you need the orbit’s apoapsis
    and periapsis to calculate eccentricity, and for large, elliptical orbits, it
    may take a while to actually sample these. The good news is that you only need
    to consider “winning” orbits between 69 and 120 miles. So, you can optimize the
    sampling rate for orbits below 120 miles, which generally take the satellite sprite
    less than 6 seconds to complete. Use 5 seconds and assign this value to an `eccentricity_calc_interval`
    variable ➐. This means that, for orbits with altitudes above 120 miles, the calculated
    eccentricity may not be technically correct, but it will be good enough considering
    the orbit doesn’t satisfy the winning conditions at that altitude.
  prefs: []
  type: TYPE_NORMAL
- en: Address timekeeping next. Use a `clock` variable to hold `pygame`’s game clock,
    which will control the speed of the game in frames per second ➑. Each frame will
    represent one tick of the clock. Assign a variable named `fps` a value of `30`,
    which means the game will update 30 times per second. Next, assign a `tick_count`
    variable that you’ll use to determine when to clear the introduction text and
    when to call the `calc_eccentricity()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Finish the section by naming a variable to enable the mapping functionality
    and set it to `False` ➒. If the player achieves the winning conditions, you’ll
    change this to `True`.
  prefs: []
  type: TYPE_NORMAL
- en: '***Starting the Game Loop and Playing Sounds***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 14-17](ch14.xhtml#ch14list17), still in the `main()` function, starts
    the game clock and `while` loop, also referred to as the *game loop*. It also
    receives events, such as a player firing thrusters using the arrow keys. If the
    player fires the thrusters, the Ogg Vorbis audio file plays, and the player hears
    a satisfying hiss.'
  prefs: []
  type: TYPE_NORMAL
- en: '*mars_orbiter.py,* part 17'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-17: Starts the game loop, gets events, and plays sounds in* main()'
  prefs: []
  type: TYPE_NORMAL
- en: First assign a `running` variable for use with the `while` loop that runs the
    game ➊, then start the loop. Set the game speed using the clock’s `tick()` method
    and pass it the `fps` variable you named in the previous listing ➋. If the game
    feels slow to you, set the speed to 40 fps. For each loop—or frame—increment the
    clock-based counter by 1.
  prefs: []
  type: TYPE_NORMAL
- en: Next, append the satellite object’s `sat.distance` value to `dist_list` ➌. This
    is the distance between the satellite and the planet, calculated each game loop
    by the satellite’s `locate()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Now, gather player input made through the keyboard ➍. As described in the previous
    chapter, `pygame` records every user interaction—called an *event*—in an event
    buffer. The `event.get()` method creates a list of these events that you can evaluate,
    in this case, with `if` statements. Start by checking if the player closed the
    window to quit the game ➎. If this is `True`, set running to `False` to end the
    game loop.
  prefs: []
  type: TYPE_NORMAL
- en: If the player presses ESC, they are exiting full-screen mode, so reset the screen
    size to 800 × 645 pixels using the `display.set_mode()` method that you called
    at the start of `main()` ➏. If the player presses the space bar, fill the background
    with black, which will erase the white orbital path of the satellite ➐.
  prefs: []
  type: TYPE_NORMAL
- en: When the player presses an arrow key, the satellite object plays the hissing
    sound, but nothing in its `check_keys()` method tells it to stop. So, pass `pygame`
    any `KEYUP` events ➑; when `pygame` reads that the player has released the arrow
    key, call the `stop()` method on `thrust` to stop the sound from playing ➒.
  prefs: []
  type: TYPE_NORMAL
- en: To map Mars, the player will have to hold down the M key, so use the same `KEYUP`
    event to call the `mapping_off()` function. This will reset the planet image to
    its normal, nonmapped state.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, check whether the `mapping_enabled` variable is `True`, meaning the
    player has achieved the winning conditions and is ready to map Mars ➓. If they
    press the M key, call the `mapping_on()` function to show the soil moisture overlay
    in place of the normal view of the planet.
  prefs: []
  type: TYPE_NORMAL
- en: '***Applying Gravity, Calculating Eccentricity, and Handling Failure***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 14-18](ch14.xhtml#ch14list18) continues the `while` loop of the `main()`
    function by exerting a gravity force on the satellite and then calculating the
    eccentricity of its orbit. The eccentricity value will determine whether the orbit
    is circular or not, one of the game’s winning conditions. The listing also blits
    the background and responds to the fail conditions of running out of fuel or burning
    up in the atmosphere.'
  prefs: []
  type: TYPE_NORMAL
- en: '*mars_orbiter.py,* part 18'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-18: Applies gravity, calculates eccentricity, and addresses fail
    conditions*'
  prefs: []
  type: TYPE_NORMAL
- en: Call the satellite’s `locate()` method and pass it the `planet` object as an
    argument ➊. This method computes the heading and distance to Mars, which you use
    to point the dish, calculate orbital eccentricity, and apply gravity. Then, to
    apply the force of gravity, call the planet’s `gravity()` method and pass it the
    satellite object.
  prefs: []
  type: TYPE_NORMAL
- en: If the modulus of the `tick_count` and the `eccentricity_calc_interval` `*`
    `fps` is `0` ➋, call the function that calculates eccentricity and pass it the
    `dist_list` variable. Then, reset the `dist_list` variable to `0` to restart the
    distance sampling ➌.
  prefs: []
  type: TYPE_NORMAL
- en: Next, call the screen’s `blit()` method and pass it the background and coordinates
    for the upper-left corner ➍. The placement of this statement matters. For example,
    if you move it after the code that updates the sprites, you won’t see the satellite
    or Mars on the game screen.
  prefs: []
  type: TYPE_NORMAL
- en: Now, handle the case where the player runs out of fuel before achieving a circular
    orbit. First, get the current fuel level from the satellite object’s `fuel` attribute
    ➎. If the level is at or below `0`, use the `instruct_label()` function to announce
    that the fuel is spent ➏, then set the satellite’s `dx` attribute to `2`. This
    will cause the satellite sprite to quickly fly off the screen and into the depths
    of space, with the altitude readout getting larger and larger. Though unrealistic,
    this ensures the player knows they have failed!
  prefs: []
  type: TYPE_NORMAL
- en: The last failure case is when the player burns up in the atmosphere. If the
    satellite’s `distance` attribute is less than or equal to `68` ➐, make a label
    near the center of the screen that lets the player know they have entered the
    atmosphere and then set the satellite’s velocity attributes equal to `0`. This
    will cause gravity to lock the sprite against the planet ([Figure 14-20](ch14.xhtml#ch14fig20)).
    Also, when `dx` and `dy` are `0`, the satellite’s `update()` method ([Listing
    14-7](ch14.xhtml#ch14list7)) will switch the satellite’s image to the red “crashed”
    version.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0317-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-20: Satellite in crash configuration*'
  prefs: []
  type: TYPE_NORMAL
- en: The altitude parameter is a bit of a cheat, as altitude equates to the `distance`
    attribute, which is measured from the *centers* of the planet and satellite sprites,
    rather than from the *surface* of the planet to the satellite. It all comes down
    to scale. Planetary atmospheres are very thin veneers—at the scale of the game,
    the Martian atmosphere would be less than 2 pixels thick! As the game is designed,
    when the tip of the satellite dish scrapes the planet, the satellite will burn
    up, but since the size of the satellite sprite is unrealistically large, the sprite’s
    68-mile center point must be pushed farther out.
  prefs: []
  type: TYPE_NORMAL
- en: '***Rewarding Success and Updating and Drawing Sprites***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 14-19](ch14.xhtml#ch14list19), still in the `while` loop of the `main()`
    function, rewards the winning player by enabling functionality that lets them
    map the moisture content in the Martian soil. In real life, this might be accomplished
    with radar or microwave resonators, which can remotely measure moisture in bare
    soil down to a depth of a few inches. The listing also updates the planet and
    satellite sprites and draws them to the screen.'
  prefs: []
  type: TYPE_NORMAL
- en: '*mars_orbiter.py,* part 19'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-19: Enables mapping functionality and updates sprites in the game
    loop*'
  prefs: []
  type: TYPE_NORMAL
- en: If the orbit is circular and meets the altitude requirements ➊, display a message
    instructing the player to press the M key to map soil moisture ➋. Put the text
    in brackets, as the `instruct_label()` function expects a list. Make the text
    color light blue and place it near the center of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Next, set the `mapping_enabled` variable to `True` ➌; otherwise, if the orbit
    strays outside of the target parameters, set it to `False`.
  prefs: []
  type: TYPE_NORMAL
- en: Finish by calling the planet sprite’s `update()` method, through the sprite
    group ➍, then actually draw it to the screen ➎. The argument for the `draw()`
    method is the `screen`, the object on which to draw the sprites. Repeat these
    steps for the satellite sprite.
  prefs: []
  type: TYPE_NORMAL
- en: '***Displaying Instructions and Telemetry and Casting a Shadow***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 14-20](ch14.xhtml#ch14list20) completes the `while` loop and the `main()`
    function by displaying instructions, data readouts, and the planet’s shadow. The
    game introduction text will be shown only for a short time at startup.'
  prefs: []
  type: TYPE_NORMAL
- en: '*mars_orbiter.py,* part 20'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-20: Displays text and planet’s shadow and calls the* main() *function*'
  prefs: []
  type: TYPE_NORMAL
- en: The text summarizing the game should hover near the middle of the screen just
    long enough to be read, then vanish. Control this using an `if` statement and
    the `pygame` `tick.get_ticks()` method, which returns the number of milliseconds
    that have elapsed since the game started. If fewer than 15 seconds have passed,
    use the `instruct_label()` function to display the list of text strings from [Listing
    14-15](ch14.xhtml#ch14list15) in green.
  prefs: []
  type: TYPE_NORMAL
- en: Next, make the gauges for the data readouts, starting with the header boxes.
    Use the `box_label()` function and call it for each of the five readout gauges
    ➋. Repeat this for the data readouts ➌. Note that you can use the string format
    method when you pass the function the text.
  prefs: []
  type: TYPE_NORMAL
- en: Use the `instruct_label()` function to place the instructions made in [Listing
    14-15](ch14.xhtml#ch14list15) in the bottom corners of the screen ➍. Feel free
    to change the text color if you want to distinguish between those that describe
    the winning conditions and those that define the key functions.
  prefs: []
  type: TYPE_NORMAL
- en: Now, call the function that displays the planet’s shadow ➎ and then, as a finishing
    touch, add a border using `pygame`’s `draw.rect()` method ➏. Pass it the `screen`
    object, the border color, the corner coordinates, and a line width.
  prefs: []
  type: TYPE_NORMAL
- en: Finish the `main()` function and its game loop by flipping the display ➐. As
    described in the preceding chapter, the `flip()` method blits everything from
    the screen object to the visual display.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, call `main()` in the global space, using the standard syntax for running
    it stand-alone or as a module ➑.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you used `pygame` to build a 2D, arcade-style game with image
    sprites, sound effects, and keyboard game controls. You also created a fun, heuristic
    method for learning orbital mechanics. All of the techniques shown in “[Astrodynamics
    for Gamers](ch14.xhtml#lev315)” on [page 286](ch14.xhtml#page_286) should work
    in the game. In the following section, “Challenge Projects,” you can continue
    to improve both the game and the player experience.
  prefs: []
  type: TYPE_NORMAL
- en: '**Challenge Projects**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Make the Mars Orbiter game your own by improving it and adding new challenges
    based on the following suggestions. As always, no solutions are provided to challenge
    projects.
  prefs: []
  type: TYPE_NORMAL
- en: '***Game Title Screen***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Copy and edit the *mars_orbiter.py* program so that a title screen appears for
    a short time before the main game screen. Have the title screen display a NASA-type
    mission patch, like the one for the *Mars Global Surveyor* ([Figure 14-21](ch14.xhtml#ch14fig21)),
    but make it unique to the Mars Orbiter in the game. You can see some other NASA
    patches, in color, at *[https://space.jpl.nasa.gov/art/patches.html](https://space.jpl.nasa.gov/art/patches.html)*.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0320-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-21:* Mars Global Surveyor *mission patch*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Smart Gauges***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Copy and edit the *mars_orbiter.py* program so that the altitude and eccentricity
    readouts use either a red background or red text color when their values are outside
    of the target ranges. But be careful: a circular eccentricity value should stay
    red until the altitude value is in range!'
  prefs: []
  type: TYPE_NORMAL
- en: '***Radio Blackout***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Copy and edit the *mars_orbiter.py* program so that keyboard controls are locked
    when the satellite is within the `shadow` rectangle.
  prefs: []
  type: TYPE_NORMAL
- en: '***Scoring***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Copy and edit the *mars_orbiter.py* program so that it scores the player and
    keeps the best results in a displayable high-scores list. Highest scores go to
    those achieving the lowest allowable orbit while using the least amount of fuel
    in the least amount of time. For example, the fuel component of the score could
    be the amount of remaining fuel; for the orbit component, the maximum allowable
    altitude (120) minus the altitude of the circular orbit; and for the time component,
    the inverse of the time taken to achieve the circular orbit multiplied by 1,000\.
    Add the three components together for the final score.
  prefs: []
  type: TYPE_NORMAL
- en: '***Strategy Guide***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Copy and edit the *mars_orbiter.py* program so it includes a pop-up strategy
    guide, or help file, by incorporating some of the figures in “[Astrodynamics for
    Gamers](ch14.xhtml#lev315)” on [page 286](ch14.xhtml#page_286). For example, add
    a line to the instructions telling the player to press and hold the H key for
    help. This could bring up and cycle through the images of different orbital maneuvers,
    such as the Hohmann transfer or the One-Tangent Burn. Be sure to include comments
    on the strengths and weaknesses of each technique and pause the game while the
    guide is open.
  prefs: []
  type: TYPE_NORMAL
- en: '***Aerobraking***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Aerobraking is a fuel-saving technique that uses atmospheric friction to slow
    down a spacecraft ([Figure 14-22](ch14.xhtml#ch14fig22)). Copy and edit the *mars_orbiter.py*
    program to include aerobraking. In the `main()` function, set the lowest winning
    altitude to 70 miles and the lowest safe altitude to 60 miles. If the satellite’s
    altitude is between 60 and 70 miles, reduce its velocity by a small amount.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0321-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-22: Circularizing an orbit using the atmosphere in place of a retrograde
    burn*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 14-23](ch14.xhtml#ch14fig23) is an example of using aerobraking in
    the game to circularize an elliptical orbit. The top of the atmosphere was set
    at 80 miles. Aerobraking serves the same purpose as a retrograde burn at periapsis,
    but you have to be cautious and patient and raise the orbit out of the atmosphere
    before it becomes circular.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0322-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-23: Circularizing an orbit using aerobraking. Note the low fuel
    consumption.*'
  prefs: []
  type: TYPE_NORMAL
- en: NASA used a similar technique to move the *Mars Global Surveyor* from its elliptical
    capture orbit to its final mapping orbit. This process took many months to accomplish,
    because they needed to protect the spacecraft from overheating in the atmosphere.
  prefs: []
  type: TYPE_NORMAL
- en: '***Intruder Alert!***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Copy and edit the *mars_orbiter.py* program so that a new `planet` object is
    instantiated and flies across the screen, disrupting the satellite’s orbit with
    its gravity. Make a new sprite to represent a comet or asteroid and launch it
    at random intervals (but not *too* often!). Don’t apply Mars’s `gravity()` method
    to the object so that it doesn’t enter Martian orbit, but apply the new object’s
    `gravity()` method to the satellite. Play with the new object’s mass so that it
    noticeably perturbs the satellite’s orbit from 100 or so pixels away. Allow the
    object to pass Mars or the satellite without colliding.
  prefs: []
  type: TYPE_NORMAL
- en: '***Over the Top***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Mars Orbiter currently uses an *equatorial* orbit. This is for easy coding,
    since you only need to rotate a single Mars image. But true mapping orbits use
    polar orbits—oriented perpendicular to equatorial orbits—and pass over the planet’s
    poles ([Figure 14-24](ch14.xhtml#ch14fig24)). As the planet rotates beneath the
    orbit, the satellite can map its entire surface. With equatorial orbits, high
    latitudes are essentially unmappable due to curvature of the planet’s surface
    (see the dashed line in [Figure 14-24](ch14.xhtml#ch14fig24)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0323-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-24: Polar versus equatorial orbits; notional north and south mapping
    limits for an equatorial orbit are represented by the dashed line.*'
  prefs: []
  type: TYPE_NORMAL
- en: Copy and edit the *mars_orbiter.py* program so that the satellite follows a
    polar orbit. All this involves is changing the Mars image. But you can’t use a
    single top-down image anymore; the view will need to be perpendicular to the planet’s
    axis of rotation. For a video example, see *[https://youtu.be/IP2SDbhFbXk](https://youtu.be/IP2SDbhFbXk)*;
    for an animated gif of Mars, see *[http://gph.is/2caBKKS](http://gph.is/2caBKKS)*.
    You can’t use animated gifs directly in `pygame`, but you can split out and use
    the individual frames. Tools for splitting out frames can be found online, and
    in the next chapter, you’ll use one of these products to extract images from a
    video.
  prefs: []
  type: TYPE_NORMAL
