<html><head></head><body>
<h2 class="h2" id="ch06"><span epub:type="pagebreak" id="page_131"/><span class="big">6</span><br/>POLYGONS</h2>&#13;
<div class="image1"><img src="../images/common01.jpg" alt="Image"/></div>&#13;
<p class="noindent">Our next primitive, polygons, builds on points and segments. Polygons can be used to describe colliding geometries, portions of the screen that need redrawing, body boundaries, and much more. It turns out these primitives are extremely useful when it comes to processing images, as you can use them to figure out whether different parts of the image overlap. In dynamics simulations, they help determine when two bodies collide. In user interfaces for graphic-intensive applications, you can use simple polygons to easily figure out whether the user’s mouse is over an entity that may be selected.</p>&#13;
<p class="indent">In this chapter, we’ll be implementing three primitives: generic polygons, described by their vertices; circles, defined by a center point and a radius; and rectangles, defined by an origin point, a width, and a height. Because it may be more convenient in some applications to work only with generic polygons, both the circle and the rectangle will implement a method to convert themselves into a generic polygon. We’ll also write a few other algorithms, including one that determines whether a polygon overlaps with <span epub:type="pagebreak" id="page_132"/>another of its class and one that tests whether a polygon contains a given point.</p>&#13;
<h3 class="h3" id="ch00lev1sec39"><strong>Polygon Class</strong></h3>&#13;
<p class="noindent">A <em>polygon</em> is a two-dimensional figure defined by a sequence of a minimum of three ordered and noncoincident vertices connected to form a closed <em>polygonal chain</em>. Each connection is a segment going from one vertex to the next one, where the last vertex is connected back to the first. Given vertices [<em>V</em><sub>1</sub>, <em>V</em><sub>2</sub>, …, <em>V</em><sub><em>n</em></sub>], each of the segments defined as [(<em>V</em><sub>1</sub> → <em>V</em><sub>2</sub>),(<em>V</em><sub>2</sub> → <em>V</em><sub>3</sub>), …, (<em>V</em><sub><em>n</em></sub> → <em>V</em><sub>1</sub>)] is called a <em>side</em> (see <a href="ch06.xhtml#ch6fig1">Figure 6-1</a>).</p>&#13;
<div class="image"><img src="../images/06fig01.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch6fig1"><em>Figure 6-1: A polygon defined by its vertices</em></p>&#13;
<p class="indent">At this point, your <em>geom2d</em> package should look like this:</p>&#13;
<p class="pre2">    Mechanics<br/>      |- geom2d<br/>      |    |- __init__.py<br/>      |    |- line.py<br/>      |    |- line_test.py<br/>      |    |- nums.py<br/>      |    |- point.py<br/>      |    |- point_test.py<br/>      |    |- segment.py<br/>      |    |- segment_test.py<br/>      |    |- vector.py<br/>      |    |- vector_test.py<br/>      |    |- vectors.py</p>&#13;
<p class="indent">Let’s create a class to represent polygons defined by their vertices as a sequence of points (instances of class <span class="literal">Point</span>). Create a new file inside the package <em>geom2d</em>, name it <em>polygon.py</em>, and enter the code from <a href="ch06.xhtml#ch6lis1">Listing 6-1</a>.</p>&#13;
<pre>from geom2d.point import Point&#13;
&#13;
&#13;
class Polygon:&#13;
    def __init__(self, vertices: [Point]):&#13;
        if len(vertices) &lt; 3:&#13;
            raise ValueError('Need 3 or more vertices')&#13;
&#13;
        <span epub:type="pagebreak" id="page_133"/>self.vertices = vertices</pre>&#13;
<p class="caption"><a id="ch6lis1"/><em>Listing 6-1: <span class="codeitalic1">Polygon</span> initialization</em></p>&#13;
<p class="indent">First we import <span class="literal">Point</span> from <span class="literal">geom2d.point</span>. Then we define class <span class="literal">Polygon</span> with an initializer that accepts a sequence of points ordered according to the polygonal chain; connected vertices should be adjacent in the sequence. If the list contains fewer than three points, we raise an exception of type <span class="literal">ValueError</span>. Remember the fail fast strategy? We want to fail as soon as we detect something that doesn’t make sense and may cause trouble, such as a polygon with fewer than three vertices.</p>&#13;
<div class="note">&#13;
<p class="notet"><span class="notes"><strong>NOTE</strong></span></p>&#13;
<p class="notep"><em>According to Python’s documentation, a</em> <span class="literal">ValueError</span> <em>should be raised when “an operation or function receives an argument that has the right type but an inappropriate value, and the situation is not described by a more precise exception.”</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch00lev2sec66"><strong><em>Sides</em></strong></h4>&#13;
<p class="noindent">A <em>side</em> is a segment going from one vertex to the next in a polygon’s sequence of vertices. The sides of a polygon together make up its <em>perimeter</em>. To close the polygonal chain, the last vertex needs to connect with the first. Generating the sides of a polygon thus requires pairing up a sequence of vertices. This sounds like a generic operation we could use for any sequence of objects, not just vertices, so we want to implement it in its own module.</p>&#13;
<p class="indent">For the sections that follow, you’ll need a good understanding of Python’s list comprehensions. You can refer to “List Comprehensions” on <a href="ch02.xhtml#ch00lev2sec23">page 35</a> for a refresher.</p>&#13;
<h5 class="h5" id="ch00lev3sec36"><strong>Pairing Vertices</strong></h5>&#13;
<p class="noindent">Given a list of items (of whatever type),</p>&#13;
<p class="pre2">    [A, B, C]</p>&#13;
<p class="noindent">the pairing algorithm should create a new list where each item is a tuple of the original item at that position paired up with the next, including a pair of the last element with the first, as follows:</p>&#13;
<p class="pre2">    [(A, B), (B, C), (C, A)]</p>&#13;
<p class="indent">Let’s write this code in a new package inside our Python project. Create a new package at the same level as <em>geom2d</em> and name it <em>utils</em>. In this package we’ll keep small pieces of generic logic that are potentially reusable by the rest of our project modules. Your project’s folder structure should look like the following:</p>&#13;
<p class="pre2">        Mechanics<br/>          |- geom2d<br/>          |    |- __init__.py<br/>          |    |- line.py<br/>          <span epub:type="pagebreak" id="page_134"/>|    | ...<br/>          |- utils<br/>          |    |- __init__.py</p>&#13;
<p class="indent">Many software projects end up having a <em>utils</em> package or module where all kinds of unrelated algorithms are bundled together. Although convenient, this practice is ultimately doomed and hinders the project’s maintainability. A <em>utils</em> package is for pieces of code that aren’t big enough to be promoted to their own package but are still reused by many other parts inside the project. When related code inside <em>utils</em> starts to grow, you’re better off moving it to its own dedicated package. For example, if our pairing logic started to specialize, covering lots of different cases and types of collections, we would move it to a new package called <em>pairs</em>. That’s not the case here, so we’ll keep it simple.</p>&#13;
<p class="indent">In the package create a new file named <em>pairs.py</em> and include the function in <a href="ch06.xhtml#ch6lis2">Listing 6-2</a>.</p>&#13;
<pre>def make_round_pairs(sequence):&#13;
    length = len(sequence)&#13;
    return [&#13;
     <span class="ent">➊</span> (sequence[i], sequence[(i + 1) % length])&#13;
     <span class="ent">➋</span> for i in range(length)&#13;
    ]</pre>&#13;
<p class="caption"><a id="ch6lis2"/><em>Listing 6-2: Pairing up list elements</em></p>&#13;
<p class="indent">The function uses a <em>list comprehension</em> to create a new list from a range of values, starting from <span class="literal">0</span> and going all the way to <span class="literal">length</span> <span class="ent">➋</span>. For each value it creates a tuple with two items <span class="ent">➊</span>: the element at index <span class="literal">i</span> from the original list and the next one at <span class="literal">i + 1</span>. When we reach index <span class="literal">i = length</span>, <span class="literal">i + 1</span> would be out of bounds in <span class="literal">sequence</span>, so we want to wrap around and go back to index <span class="literal">0</span> so that the last and first elements are also paired up. We do this with the <span class="literal">modulo</span> operator (<span class="literal">%</span>), which returns the remainder when you divide one number by another. The neat thing is that <em>n</em> % <em>m</em> returns <em>n</em> for every <em>n</em> &lt; <em>m</em>, and it returns 0 for <em>n</em> = <em>m</em>.</p>&#13;
<p class="indent">To better understand modulo, try this in the shell:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">[n % 4 for n in range(5)]</span>&#13;
[0, 1, 2, 3, 0]</pre>&#13;
<p class="noindent">See how for <em>n</em> = 4 the result is 0, but for all other values the result is <em>n</em> itself? Try to increase the <span class="literal">range</span> parameter:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">[n % 4 for n in range(7)]</span>&#13;
[0, 1, 2, 3, 0, 1, 2]</pre>&#13;
<p class="noindent">Numbers in a modulo 4 operation never go beyond 3. Once that number is reached, the next one wraps around to 0 again.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><span epub:type="pagebreak" id="page_135"/><em>If you want to know more about this “wrapping around” phenomenon resulting from the modulo operator, search for</em> modular arithmetic<em>. It’s widely used in modern cryptography and has some really interesting properties.</em></p>&#13;
</div>&#13;
<p class="indent">We’re now ready to implement the method that will generate the sides for our <span class="literal">Polygon</span> class.</p>&#13;
<h5 class="h5" id="ch00lev3sec37"><strong>Generating Sides</strong></h5>&#13;
<p class="noindent">Once vertices are properly paired, writing the code to generate the sides is simple: we just need to create a <span class="literal">Segment</span> instance per pair of vertices. To compute them, first add the following imports in your file <em>polygon.py</em>:</p>&#13;
<pre>from geom2d.segment import Segment&#13;
from utils.pairs import make_round_pairs</pre>&#13;
<p class="noindent">Then, enter the method in <a href="ch06.xhtml#ch6lis3">Listing 6-3</a>.</p>&#13;
<pre>from geom2d.point import Point&#13;
<span class="codestrong1">from geom2d.segment import Segment</span>&#13;
<span class="codestrong1">from utils.pairs import make_round_pairs</span>&#13;
&#13;
&#13;
class Polygon:&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
    def sides(self):&#13;
        vertex_pairs = make_round_pairs(self.vertices)&#13;
        return [&#13;
            Segment(pair[0], pair[1])&#13;
            for pair in vertex_pairs&#13;
        ]</pre>&#13;
<p class="caption"><a id="ch6lis3"/><em>Listing 6-3: Computing polygon sides</em></p>&#13;
<p class="indent">Using the <span class="literal">make_round_pairs</span> function, we pair vertices up such that each tuple in <span class="literal">vertex_pairs</span> contains the start and end points of a segment. Then, using a list comprehension, each of these tuples is mapped into a segment.</p>&#13;
<h5 class="h5" id="ch00lev3sec38"><strong>Testing Sides</strong></h5>&#13;
<p class="noindent">Let’s create a unit test for the <span class="literal">sides</span> attribute. Create a new file named <em>polygon_test.py</em> inside the package <em>geom2d</em> and enter the code for class <span class="literal">TestPolygon</span> (<a href="ch06.xhtml#ch6lis4">Listing 6-4</a>).</p>&#13;
<pre>import unittest&#13;
&#13;
from geom2d.point import Point&#13;
from geom2d.polygon import Polygon&#13;
from geom2d.segment import Segment&#13;
&#13;
&#13;
<span epub:type="pagebreak" id="page_136"/>class TestPolygon(unittest.TestCase):&#13;
    vertices = [&#13;
        Point(0, 0),&#13;
        Point(30, 0),&#13;
        Point(0, 30),&#13;
    ]&#13;
    polygon = Polygon(vertices)&#13;
&#13;
    def test_sides(self):&#13;
        expected = [&#13;
            Segment(self.vertices[0], self.vertices[1]),&#13;
            Segment(self.vertices[1], self.vertices[2]),&#13;
            Segment(self.vertices[2], self.vertices[0])&#13;
        ]&#13;
        actual = self.polygon.sides()&#13;
        self.assertEqual(expected, actual)</pre>&#13;
<p class="caption"><a id="ch6lis4"/><em>Listing 6-4: Testing sides of a polygon</em></p>&#13;
<p class="indent">Inside the test class we create a list of vertices—(0, 0), (30, 0), and (0, 30)—that make a triangle. We use these points as vertices for the creation of the test subject: <span class="literal">polygon</span>. <a href="ch06.xhtml#ch6fig2">Figure 6-2</a> illustrates the polygon. To ensure the sides are properly computed, we construct the list of expected sides using the original vertices properly paired up.</p>&#13;
<div class="image"><img src="../images/06fig02.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch6fig2"><em>Figure 6-2: The polygon used in the test</em></p>&#13;
<p class="indent">Since we overloaded the <em>==</em> operator in the <span class="literal">Segment</span> class (by implementing the special method <span class="literal">__eq__</span>), the equality comparison will work as intended. If we hadn’t done so, the equality assertion would consider segments different even if bounded by the same end points, and thus the test would fail.</p>&#13;
<p class="indent">Run the test using the following command to make sure it succeeds.</p>&#13;
<pre>$ <span class="codestrong1">python3 -m unittest geom2d/polygon_test.py</span></pre>&#13;
<p class="indent">If everything went well, you should get this output:</p>&#13;
<pre>Ran 1 tests in 0.000s&#13;
&#13;
OK</pre>&#13;
<h4 class="h4" id="ch00lev2sec67"><span epub:type="pagebreak" id="page_137"/><strong><em>Centroid</em></strong></h4>&#13;
<p class="noindent">A noteworthy point in a polygon is its <em>centroid</em>, the arithmetic mean of the position of all vertices. Assuming <em>n</em> is the number of vertices, the <em>centroid</em> can be expressed using <a href="ch06.xhtml#ch06eqa01">Equation 6.1</a>.</p>&#13;
<div class="equationc" id="ch06eqa01"><img src="../images/06eqa01.jpg" alt="Image"/></div>&#13;
<p class="noindent">Here, <em>x</em><sub><em>i</em></sub> and <em>y</em><sub><em>i</em></sub> are the coordinates of vertex <em>i</em>.</p>&#13;
<h5 class="h5" id="ch00lev3sec39"><strong>Implementing the Centroid</strong></h5>&#13;
<p class="noindent">Let’s implement the <span class="literal">centroid</span> property. To do so, we first need to import the following at the top of our <span class="literal">Polygon</span> class:</p>&#13;
<pre>import operator&#13;
from functools import reduce</pre>&#13;
<p class="noindent">Once imported, add the code in <a href="ch06.xhtml#ch6lis5">Listing 6-5</a> beneath the <span class="literal">sides</span> method.</p>&#13;
<pre><span class="codestrong1">import operator</span>&#13;
<span class="codestrong1">from functools import reduce</span>&#13;
&#13;
from geom2d.point import Point&#13;
from geom2d.segment import Segment&#13;
from utils.pairs import make_round_pairs&#13;
&#13;
&#13;
class Polygon:&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
    @property&#13;
    def centroid(self):&#13;
     <span class="ent">➊</span> vtx_count = len(self.vertices)&#13;
     <span class="ent">➋</span> vtx_sum = reduce(operator.add, self.vertices)&#13;
     <span class="ent">➌</span> return Point(&#13;
           vtx_sum.x / vtx_count,&#13;
           vtx_sum.y / vtx_count&#13;
       )</pre>&#13;
<p class="caption"><a id="ch6lis5"/><em>Listing 6-5: Calculating a centroid of a polygon</em></p>&#13;
<p class="indent">We first store the length of the list of vertices in the variable <span class="literal">vtx_count</span> <span class="ent">➊</span>. Then, we reduce the list of vertices by summing them into a resulting point called <span class="literal">vtx_sum</span> <span class="ent">➋</span>. You may want to read “Filter, Map, and Reduce” on <a href="ch02.xhtml#ch00lev2sec22">page 29</a> to review the <span class="literal">reduce</span> function and how we use <span class="literal">operator</span>. Note that the operator <span class="literal">operator.add</span> works for the <span class="literal">reduce</span> function because our <span class="literal">Point</span> class overloads the + operator.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_138"/>The last thing we do is construct the resulting point by dividing each of the projections of <span class="literal">vtx_sum</span> by <span class="literal">vtx_count</span> <span class="ent">➌</span>.</p>&#13;
<h5 class="h5" id="ch00lev3sec40"><strong>Testing the Centroid</strong></h5>&#13;
<p class="noindent">Let’s write a unit test to make sure the centroid is properly computed. In your file <em>polygon_test.py</em> enter the code in <a href="ch06.xhtml#ch6lis6">Listing 6-6</a>.</p>&#13;
<pre>class TestPolygon(unittest.TestCase):&#13;
   <span class="codeitalic1">--snip--</span>&#13;
&#13;
   def test_centroid(self):&#13;
       expected = Point(10, 10)&#13;
       actual = self.polygon.centroid&#13;
       self.assertEqual(expected, actual)</pre>&#13;
<p class="caption"><a id="ch6lis6"/><em>Listing 6-6: Testing the centroid center of a polygon</em></p>&#13;
<p class="indent">Using <a href="ch06.xhtml#ch06eqa01">Equation 6.1</a>, we can calculate the centroid by hand to see where the projections in (10, 10) come from. Knowing that the vertices of our polygon test subject are (0, 0), (30, 0), and (0, 30), we have this:</p>&#13;
<div class="equationc"><img src="../images/f0138-01.jpg" alt="Image"/></div>&#13;
<p class="noindent">You can inspect this visually in <a href="ch06.xhtml#ch6fig3">Figure 6-3</a>.</p>&#13;
<div class="image"><img src="../images/06fig03.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch6fig3"><em>Figure 6-3: The test polygon’s centroid</em></p>&#13;
<p class="indent">Run all tests in file <em>polygon_test.py</em> to make sure everything is working as expected. To run them from the shell, you can use the following:</p>&#13;
<pre>$ <span class="codestrong1">python3 -m unittest geom2d/polygon_test.py</span></pre>&#13;
<p class="indent">If both tests pass, you should get the following output:</p>&#13;
<pre>Ran 2 tests in 0.000s&#13;
&#13;
OK</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_139"/>Let’s try one thing before moving on. Remember that to compute the centroid we reduced the list of vertices like so,</p>&#13;
<pre>vtx_sum = reduce(operator.add, self.vertices)</pre>&#13;
<p class="indent">We said that this reduction using the <span class="literal">operator.add</span> works because our <span class="literal">Point</span> class overloads the + operator? Let’s see what would have happened if we hadn’t overloaded this operator. Open <em>point.py</em> and comment out the <span class="literal">__add__</span> method:</p>&#13;
<pre>class Point:&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
    # def __add__(self, other):&#13;
    #     return Point(&#13;
    #         self.x + other.x,&#13;
    #         self.y + other.y&#13;
    #     )</pre>&#13;
<p class="indent">Run the tests again. This time you’ll see an error in the shell:</p>&#13;
<pre>======================================================&#13;
ERROR: test_centroid (geom2d.polygon_test.TestPolygon)&#13;
------------------------------------------------------&#13;
Traceback (most recent call last):&#13;
  <span class="codeitalic1">--snip--</span>&#13;
    vtx_sum = reduce(operator.add, self.vertices)&#13;
TypeError: unsupported operand type(s) for +: 'Point' and 'Point'&#13;
&#13;
-------------------------------------------------------&#13;
Ran 2 tests in 0.020s</pre>&#13;
<p class="indent">The <span class="literal">TypeError</span> with its message (<span class="literal">unsupported</span> <span class="literal">operand</span> <span class="literal">type(s)...</span>) is very descriptive about what the error is. Two <span class="literal">Point</span> instances cannot be added if they don’t implement the <span class="literal">__add__</span> method. Uncomment the <span class="literal">__add__</span> method we commented for the experiment and rerun the tests just to make sure it’s all back to how it was.</p>&#13;
<h4 class="h4" id="ch00lev2sec68"><strong><em>Contains Point</em></strong></h4>&#13;
<p class="noindent">Now comes an interesting problem: How do we determine whether a given point is inside a polygon? A widely used procedure is the <em>ray casting algorithm</em>, which counts how many sides of the polygon are intersected by a ray going through the point in any direction. <span epub:type="pagebreak" id="page_140"/>An even number of intersections (including zero) means the point is outside of the polygon, whereas an odd number means the point is inside. Take a look at <a href="ch06.xhtml#ch6fig4">Figure 6-4</a>.</p>&#13;
<p class="indent">The drawing on the left depicts a complex polygon and a point <em>P</em> outside of it. Every ray cast from that point in any direction intersects zero or an even number of sides. The case on the right depicts the point <em>P</em> inside the polygon. This time, the ray always intersects an odd number of sides.</p>&#13;
<div class="image"><img src="../images/06fig04.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch6fig4"><em>Figure 6-4: The ray casting algorithm</em></p>&#13;
<p class="indent">Another commonly used algorithm, and the one we’ll be using, is the <em>winding number algorithm</em>. This algorithm works by summing angles between vectors that go from the point under test to the vertices of the polygon. This is how it works. To know whether a point <em>P</em> is inside a polygon with vertices <em>V</em><sub>1</sub>, <em>V</em><sub>2</sub>, …, <em>V</em><sub><em>n</em></sub>, our algorithm looks like this:</p>&#13;
<ol>&#13;
<li class="noindent">Create a vector going from <em>P</em>  to each of the vertices:&#13;
<p class="noindent5"><img class="inline" src="../images/f00140-p1.jpg" alt="Image"/>: Vector from <em>P</em> to vertex <em>V</em><sub>1</sub></p>&#13;
<p class="noindent5"><img class="inline" src="../images/f00140-p2.jpg" alt="Image"/>: Vector from <em>P</em> to vertex <em>V</em><sub>2</sub></p>&#13;
<p class="noindent5">. . .</p>&#13;
<p class="noindent5"><img class="inline" src="../images/f00140-p3.jpg" alt="Image"/>: Vector from <em>P</em> to vertex <em>V</em><sub><em>n</em></sub></p></li>&#13;
<li class="noindent">Compute the angle from each vector <img class="inline" src="../images/rivictorit.jpg" alt="Image"/> to the next <img class="inline" src="../images/riplus1victorit.jpg" alt="Image"/>,  wrapping around and computing the angle between the last vector and the  first:&#13;
<p class="noindent5"><img class="inline" src="../images/f00140-p4.jpg" alt="Image"/>: Angle from <img class="inline" src="../images/r1victorit.jpg" alt="Image"/> to <img class="inline" src="../images/r2victorit.jpg" alt="Image"/></p>&#13;
<p class="noindent5"><img class="inline" src="../images/f00140-p5.jpg" alt="Image"/>: Angle from <img class="inline" src="../images/r2victorit.jpg" alt="Image"/> to <img class="inline" src="../images/r3victorit.jpg" alt="Image"/></p>&#13;
<p class="noindent5">. . .</p>&#13;
<p class="noindent5"><img class="inline" src="../images/f00140-p6.jpg" alt="Image"/>: Angle from <img class="inline" src="../images/rnvictorit.jpg" alt="Image"/> to <img class="inline" src="../images/r1victorit.jpg" alt="Image"/></p></li>&#13;
<li class="noindent">Sum all angles computed in the previous step.</li>&#13;
<li class="noindent">The point <em>P</em>  is inside the polygon if the angle is  2<em>π</em>,  outside if 0.</li>&#13;
</ol>&#13;
<p class="noindent">Take a look at <a href="ch06.xhtml#ch6fig5">Figure 6-5</a> to better understand how this algorithm works. It’s easy to see how the sum of angles is 2<em>π</em> in the case where the point is inside the polygon.</p>&#13;
<p class="indent">Although we could just as well implement the <em>ray casting algorithm</em>, I chose the <em>winding number algorithm</em> because it makes good use of three key functions we’ve created in this book: the <span class="literal">make_vector_between</span> factory function, <span class="literal">make_round_pairs</span>, and the <span class="literal">angle_to</span> method from the <span class="literal">Vector</span> class. Let’s implement it.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_141"/><img src="../images/06fig05.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch6fig5"><em>Figure 6-5: Testing whether a polygon contains a point</em></p>&#13;
<h5 class="h5" id="ch00lev3sec41"><strong>Implementing the Winding Number Algorithm</strong></h5>&#13;
<p class="noindent">There are a few modules we need to import. Your imports at the top of file <em>polygon.py</em> should look like this:</p>&#13;
<pre>import math&#13;
import operator&#13;
from functools import reduce&#13;
&#13;
from geom2d.nums import are_close_enough&#13;
from geom2d.point import Point&#13;
from geom2d.vectors import make_vector_between&#13;
from geom2d.segment import Segment&#13;
from utils.pairs import make_round_pairs</pre>&#13;
<p class="indent">Once you’ve imported everything, enter the code in <a href="ch06.xhtml#ch6lis7">Listing 6-7</a> as a new method for the <span class="literal">Polygon</span> class.</p>&#13;
<pre><span class="codestrong1">import math</span>&#13;
import operator&#13;
from functools import reduce&#13;
&#13;
<span class="codestrong1">from geom2d.nums import are_close_enough</span>&#13;
from geom2d.point import Point&#13;
<span class="codestrong1">from geom2d.vectors import make_vector_between</span>&#13;
from geom2d.segment import Segment&#13;
from utils.pairs import make_round_pairs&#13;
&#13;
class Polygon:&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
   def contains_point(self, point: Point):&#13;
    <span class="ent">➊</span> vecs = [make_vector_between(point, vertex)&#13;
                <span epub:type="pagebreak" id="page_142"/>for vertex in self.vertices]&#13;
    <span class="ent">➋</span> paired_vecs = make_round_pairs(vecs)&#13;
    <span class="ent">➌</span> angle_sum = reduce(&#13;
           operator.add,&#13;
        <span class="ent">➍</span> [v1.angle_to(v2) for v1, v2 in paired_vecs]&#13;
       )&#13;
&#13;
    <span class="ent">➎</span> return are_close_enough(angle_sum, 2 * math.pi)</pre>&#13;
<p class="caption"><a id="ch6lis7"/><em>Listing 6-7: Polygon <span class="codeitalic1">contains_point</span> algorithm</em></p>&#13;
<p class="indent">We first compute the list of <img class="inline" src="../images/rvictorit.jpg" alt="Image"/> vectors <span class="ent">➊</span> using a list comprehension, which maps each of the vertices of the polygon into a vector going from <span class="literal">point</span> to the vertex. Then, using <span class="literal">make_round_pairs</span>, we pair the vectors and store the result in <span class="literal">paired_vecs</span> <span class="ent">➋</span>.</p>&#13;
<p class="indent">We map paired vectors to the angle each pair forms using another list comprehension <span class="ent">➍</span>. We reduce the resulting list by adding together each of the computed angles <span class="ent">➌</span>, and finally, we check whether the computed angle sum (<span class="literal">angle_sum</span>) is close enough to 2<em>π</em> <span class="ent">➎</span>, in which case the point is inside the polygon. We’ll consider any other value of the angle to mean the point is outside the polygon.</p>&#13;
<h5 class="h5" id="ch00lev3sec42"><strong>Testing contains_point</strong></h5>&#13;
<p class="noindent">Let’s make sure this algorithm works by adding two unit tests in file <em>polygon_test.py</em> (see <a href="ch06.xhtml#ch6lis8">Listing 6-8</a>).</p>&#13;
<pre>class TestPolygon(unittest.TestCase):&#13;
   <span class="codeitalic1">--snip--</span>&#13;
&#13;
   def test_doesnt_contain_point(self):&#13;
       point = Point(15, 20)&#13;
       self.assertFalse(self.polygon.contains_point(point))&#13;
&#13;
   def test_contains_point(self):&#13;
       point = Point(15, 10)&#13;
       self.assertTrue(self.polygon.contains_point(point))</pre>&#13;
<p class="caption"><a id="ch6lis8"/><em>Listing 6-8: Testing whether the polygon contains <span class="codeitalic1">point</span></em></p>&#13;
<p class="indent">You can run the tests using the green play button in the IDE or from the shell:</p>&#13;
<pre>$ <span class="codestrong1">python3 -m unittest geom2d/polygon_test.py</span></pre>&#13;
<p class="indent">In the first test, we take a point we know is outside the triangular polygon and assert that it’s actually outside. The second test asserts the point (15, 10) is inside the triangle.</p>&#13;
<h5 class="h5" id="ch00lev3sec43"><span epub:type="pagebreak" id="page_143"/><strong>Testing an Edge Case</strong></h5>&#13;
<p class="noindent">Let’s try one more test, just to see what happens. What about vertices of the polygon? Are they considered to be inside or outside the polygon? This is what we know as an <em>edge case</em>, a situation that requires special treatment in our code.</p>&#13;
<p class="indent">Enter the innocent-looking test in <a href="ch06.xhtml#ch6lis9">Listing 6-9</a> and run all the tests in file <em>rect_test.py</em>.</p>&#13;
<pre>class TestPolygon(unittest.TestCase):&#13;
   <span class="codeitalic1">--snip--</span>&#13;
&#13;
   def test_contains_vertex(self):&#13;
       self.assertTrue(&#13;
           self.polygon.contains_point(self.vertices[0])&#13;
       )</pre>&#13;
<p class="caption"><a id="ch6lis9"/><em>Listing 6-9: Proposed test of whether a polygon contains one of its vertices</em></p>&#13;
<p class="noindent">The output from running the test is as follows:</p>&#13;
<pre>Error&#13;
Traceback (most recent call last):&#13;
  <span class="codeitalic1">--snip--</span>&#13;
  File ".../geom2d/polygon.py", line 36, in &lt;listcomp&gt;&#13;
    [v1.angle_to(v2) for v1, v2 in paired_vecs]&#13;
  File ".../geom2d/vector.py", line 69, in angle_to&#13;
    value = self.angle_value_to(other)&#13;
  File ".../geom2d/vector.py", line 66, in angle_value_to&#13;
    return math.acos(dot_product / norm_product)&#13;
ZeroDivisionError: float division by zero</pre>&#13;
<p class="noindent">Oops! We must have done something wrong. Can you guess what by reading the traceback? Starting from the last line we find the originator: <span class="literal">ZeroDivisionError</span>. Apparently we attempted to divide by zero in method <span class="literal">angle_value_to</span>. To be specific, we did so in this line:</p>&#13;
<pre>return math.acos(dot_product / norm_product)</pre>&#13;
<p class="noindent">This means <span class="literal">norm_product</span> was zero; hence, the norm of at least one of the vectors used to compute the angle had a length of 0. Going a bit up in the traceback we find the line where the angle method was being used before the error happened:</p>&#13;
<pre>[v1.angle_to(v2) for v1, v2 in paired_vecs]</pre>&#13;
<p class="noindent">So, it appears that when we attempted to compute the angle between two of the vectors, one of them had a length of 0. The vector going from point <em>P</em>, this time a vertex of the polygon, to itself is obviously a zero vector.</p>&#13;
<p class="indent">To handle this particular edge case, we can consider vertices to be inside the polygon as a convention. At the beginning of method <span class="literal">contains_point</span>, <span epub:type="pagebreak" id="page_144"/>let’s check whether the point passed as an argument is a vertex of the polygon, in which case we simply return <span class="literal">True</span>. Modify the method to accommodate this new condition (<a href="ch06.xhtml#ch6lis10">Listing 6-10</a>).</p>&#13;
<pre>class Polygon:&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
    def contains_point(self, point: Point):&#13;
        <span class="codestrong1">if point in self.vertices:</span>&#13;
            <span class="codestrong1">return True</span>&#13;
&#13;
        vecs = [make_vector_between(point, vertex)&#13;
                for vertex in self.vertices]&#13;
        paired_vecs = make_round_pairs(vecs)&#13;
        angle_sum = reduce(&#13;
            operator.add,&#13;
            [v1.angle_to(v2) for v1, v2 in paired_vecs]&#13;
        )&#13;
&#13;
        return are_close_enough(angle_sum, 2 * math.pi)</pre>&#13;
<p class="caption"><a id="ch6lis10"/><em>Listing 6-10: Corrected algorithm to check whether a point is inside a polygon</em></p>&#13;
<p class="indent">As you see, dealing with edge cases requires individualized pieces of code. Run all the tests to make sure they all succeed now:</p>&#13;
<pre>$ <span class="codestrong1">python3 -m unittest geom2d/polygon_test.py</span></pre>&#13;
<p class="noindent">The output this time should be as follows:</p>&#13;
<pre>Ran 5 tests in 0.001s&#13;
&#13;
OK</pre>&#13;
<h4 class="h4" id="ch00lev2sec69"><strong><em>Polygon Factory</em></strong></h4>&#13;
<p class="noindent">In practice, we commonly need to construct polygons from a list of numbers representing the coordinates of its vertices. This is done, for example, when reading a polygon from a text file, which we’ll see in <a href="ch12.xhtml#ch12">Chapter 12</a>. To do this, we first need to pair up the numbers and map them into instances of <span class="literal">Point</span>.</p>&#13;
<p class="indent">For instance, the list</p>&#13;
<pre>[0, 0, 50, 0, 0, 50]</pre>&#13;
<p class="noindent">could be used to define the three vertices of a triangle:</p>&#13;
<pre>[(0, 0), (50, 0), (0, 50)]</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_145"/>Let’s implement a factory function to create polygons given a sequence of floating-point numbers. Create a new file named <em>polygons.py</em>. Our project’s structure currently looks like this:</p>&#13;
<p class="pre2">    Mechanics<br/>      |- geom2d<br/>      |    |- __init__.py<br/>      |    |- line.py<br/>      |    |- line_test.py<br/>      |    |- nums.py<br/>      |    |- point.py<br/>      |    |- point_test.py<br/>      |    |- polygon.py<br/>      |    |- polygon_test.py<br/>      |    |- polygons.py<br/>      |    |- segment.py<br/>      |    |- segment_test.py<br/>      |    |- vector.py<br/>      |    |- vector_test.py<br/>      |    |- vectors.py<br/>      |- utils<br/>      |    |- __init__.py<br/>      |    |- pairs.py</p>&#13;
<p class="indent">Inside the new file, enter the code in <a href="ch06.xhtml#ch6lis11">Listing 6-11</a>.</p>&#13;
<pre>from geom2d import Point, Polygon&#13;
&#13;
&#13;
def make_polygon_from_coords(coords: [float]):&#13;
    if len(coords) % 2 != 0:&#13;
        raise ValueError('Need an even number of coordinates')&#13;
&#13;
    indices = range(0, len(coords), 2)&#13;
    return Polygon(&#13;
        [Point(coords[i], coords[i + 1]) for i in indices]&#13;
    )</pre>&#13;
<p class="caption"><a id="ch6lis11"/><em>Listing 6-11: Polygon factory function</em></p>&#13;
<p class="indent">The function <span class="literal">make_polygon_from_coords</span> takes in a list of coordinates and first checks that there are an even number of them (otherwise, they can’t be paired up). If the length of the list of coordinates is divisible by 2 with a remainder of 0, we have an even number of coordinates.</p>&#13;
<p class="indent">If the number of coordinates is found to be uneven, we raise a <span class="literal">ValueError</span>. If not, we then construct a list of the indices at which we’ll find the x-coordinate of the vertices in the <span class="literal">coords</span> list. We achieve this with a range going from <span class="literal">0</span> to <span class="literal">len(coords)</span> (noninclusive) with a step of <span class="literal">2</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_146"/>To better understand how we’re doing this, try the following in Python’s shell:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">list(range(0, 10, 2))</span>&#13;
[0, 2, 4, 6, 8]</pre>&#13;
<p class="noindent">With these indices we can easily obtain a list of vertices using a list comprehension. Recall that Python’s <span class="literal">range</span> function returns a half-open interval that doesn’t include the upper bound, which is why we didn’t get the number 10 in the resulting list. The list comprehension maps each index to an instance of <span class="literal">Point</span> class. We create the polygon passing this list to its constructor. As you can see from the code, the x-coordinate is the number from the input list at each index <span class="literal">i</span>, whereas the y-coordinate is the number to the right of it, that is, <span class="literal">i + 1</span>.</p>&#13;
<p class="indent">With that out of the way, let’s take a look at how to compare polygons for equality.</p>&#13;
<h4 class="h4" id="ch00lev2sec70"><strong><em>Polygon Equality</em></strong></h4>&#13;
<p class="noindent">To make sure we can check whether polygons are equal, let’s implement the <span class="literal">__eq__</span> method inside the <span class="literal">Polygon</span> class (see <a href="ch06.xhtml#ch6lis12">Listing 6-12</a>).</p>&#13;
<pre>class Polygon:&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
    def __eq__(self, other):&#13;
        if self is other:&#13;
            return True&#13;
&#13;
        if not isinstance(other, Polygon):&#13;
            return False&#13;
&#13;
        return self.vertices == other.vertices</pre>&#13;
<p class="caption"><a id="ch6lis12"/><em>Listing 6-12: Polygon equality</em></p>&#13;
<p class="indent">We first check whether the passed-in <span class="literal">other</span> is the same instance as <span class="literal">self</span>, in which case we return <span class="literal">True</span>. Second, if <span class="literal">other</span> is not an instance of <span class="literal">Polygon</span>, there’s not much we can compare; we already know the equality is impossible.</p>&#13;
<p class="indent">Since <span class="literal">Point</span> already implements the <span class="literal">__eq__</span> method, we just need to compare the list of vertices from both polygons if the two previous checks haven’t returned anything yet. Python will check whether both lists contain the same vertices in the same order. Lists are ordered collections; thus, ordering is important when checking for equality. Try the following experiment in the shell:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">l1 = [1, 2, 3]</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">l2 = [3, 2, 1]</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">l3 = [3, 2, 1]</span>&#13;
<span epub:type="pagebreak" id="page_147"/>&gt;&gt;&gt; <span class="codestrong1">l1 == l2</span>&#13;
False&#13;
&#13;
&gt;&gt;&gt; <span class="codestrong1">l2 == l3</span>&#13;
true</pre>&#13;
<p class="indent">Even though <span class="literal">l1</span> and <span class="literal">l2</span> contain the same numbers, they are considered different by Python as they appear in a different order (don’t forget that order matters for lists and tuples). By contrast, <span class="literal">l2</span> and <span class="literal">l3</span> do contain the numbers in the same order and hence are considered equal. Polygons are made of an ordered collection of vertices: different orderings of the same set of vertices would result in unequal polygons. This is the reason why we used a list, which is a collection where the order is a key factor.</p>&#13;
<p class="indent">If you followed along, your <em>polygon.py</em> file should look like <a href="ch06.xhtml#ch6lis13">Listing 6-13</a>.</p>&#13;
<pre>import math&#13;
import operator&#13;
from functools import reduce&#13;
&#13;
from geom2d.nums import are_close_enough&#13;
from geom2d.point import Point&#13;
from geom2d.vectors import make_vector_between&#13;
from geom2d.segment import Segment&#13;
from utils.pairs import make_round_pairs&#13;
&#13;
&#13;
class Polygon:&#13;
    def __init__(self, vertices: [Point]):&#13;
        if len(vertices) &lt; 3:&#13;
            raise ValueError('Need 3 or more vertices')&#13;
        self.vertices = vertices&#13;
&#13;
    def sides(self):&#13;
        vertex_pairs = make_round_pairs(self.vertices)&#13;
        return [Segment(pair[0], pair[1]) for pair in vertex_pairs]&#13;
&#13;
    @property&#13;
    def centroid(self):&#13;
        vtx_count = len(self.vertices)&#13;
        vtx_sum = reduce(operator.add, self.vertices)&#13;
        return Point(&#13;
            vtx_sum.x / vtx_count,&#13;
            vtx_sum.y / vtx_count&#13;
        )&#13;
&#13;
    def contains_point(self, point: Point):&#13;
        if point in self.vertices:&#13;
            return True&#13;
&#13;
        <span epub:type="pagebreak" id="page_148"/>vecs = [make_vector_between(point, vertex)&#13;
                for vertex in self.vertices]&#13;
        paired_vecs = make_round_pairs(vecs)&#13;
        angle_sum = reduce(&#13;
            operator.add,&#13;
            [v1.angle_to(v2) for v1, v2 in paired_vecs]&#13;
        )&#13;
&#13;
        return are_close_enough(angle_sum, 2 * math.pi)&#13;
&#13;
    def __eq__(self, other):&#13;
        if self is other:&#13;
            return True&#13;
&#13;
        if not isinstance(other, Polygon):&#13;
            return False&#13;
&#13;
        return self.vertices == other.vertices</pre>&#13;
<p class="caption"><a id="ch6lis13"/><em>Listing 6-13: <span class="codeitalic1">Polygon</span> class</em></p>&#13;
<p class="indent">Now let’s take a look at circles.</p>&#13;
<h3 class="h3" id="ch00lev1sec40"><strong>Circle Class</strong></h3>&#13;
<p class="noindent">A <em>circle</em> is the set of all points in the plane a given distance (the <em>radius</em>) from a single point called the <em>center</em>. A circle is therefore defined by the position of its center <em>C</em> and the value of its radius <em>r</em> (see <a href="ch06.xhtml#ch6fig6">Figure 6-6</a>).</p>&#13;
<div class="image"><img src="../images/06fig06.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch6fig6"><em>Figure 6-6: A circle defined by a center point <em>C</em> and radius <em>r</em></em></p>&#13;
<p class="indent">As you may remember from high school, the area of a circle is calculated as follows:</p>&#13;
<p class="noindentc"><em>A = π ⋅ r</em><sup>2</sup></p>&#13;
<p class="noindent">And a circle’s circumference is calculated as follows:</p>&#13;
<p class="noindentc"><em>l</em><sub>c</sub> = 2π ⋅ <em>r</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_149"/>Create a new file named <em>circle.py</em> in the package <em>geom2d</em>. In the file, enter the code in <a href="ch06.xhtml#ch6lis14">Listing 6-14</a>.</p>&#13;
<pre>import math&#13;
&#13;
from geom2d.point import Point&#13;
&#13;
&#13;
class Circle:&#13;
    def __init__(self, center: Point, radius: float):&#13;
        self.center = center&#13;
        self.radius = radius&#13;
&#13;
    @property&#13;
    def area(self):&#13;
        return math.pi * self.radius ** 2&#13;
&#13;
    @property&#13;
    def circumference(self):&#13;
        return 2 * math.pi * self.radius</pre>&#13;
<p class="caption"><a id="ch6lis14"/><em>Listing 6-14: <span class="codeitalic1">Circle</span> class initialization</em></p>&#13;
<p class="indent">Great! We now have a class to represent circles with the properties <span class="literal">center</span> and <span class="literal">radius</span>. We’ve also defined properties named <span class="literal">area</span> and <span class="literal">circumference</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>To keep the length of the chapter reasonable, we won’t include any more unit testing sections. The accompanying code does include unit tests, and I encourage you to come up with them yourself.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch00lev2sec71"><strong><em>Contains Point</em></strong></h4>&#13;
<p class="noindent">Testing whether a point <em>P</em> was inside a generic polygon required a few steps, but in the case of a circle, the logic is extremely simple. We compute the distance from the center <em>C</em> to point <em>P</em>: <em>d</em>(<em>C,P</em>). If this distance is smaller than the radius, <em>d</em>(<em>C,P</em>) &lt; <em>r</em>, the point is inside the circle. For values of <em>d</em>(<em>C,P</em>) greater than <em>r</em>, the point is farther from the center than the radius and thus outside the circle. Inside <span class="literal">Circle</span>, enter the code in <a href="ch06.xhtml#ch6lis15">Listing 6-15</a>.</p>&#13;
<pre>class Circle:&#13;
   <span class="codeitalic1">--snip--</span>&#13;
&#13;
   def contains_point(self, point: Point):&#13;
       return point.distance_to(self.center) &lt; self.radius</pre>&#13;
<p class="caption"><a id="ch6lis15"/><em>Listing 6-15: Checking whether a circle contains a point</em></p>&#13;
<p class="indent">Can you come up with test cases to ensure method <span class="literal">contains_point</span> is bug free?</p>&#13;
<h4 class="h4" id="ch00lev2sec72"><span epub:type="pagebreak" id="page_150"/><strong><em>Circle to Polygon</em></strong></h4>&#13;
<p class="noindent">In <a href="ch07.xhtml#ch07">Chapter 7</a> we’ll be transforming a polygon’s geometry by rotating, scaling, and skewing it. After such transformations, circles may not be circles anymore, and the mathematical representation for the result can become complex.</p>&#13;
<p class="indent">Because accounting for all possible shapes using a specific geometry class would be arduous, and because our generic polygons work the same no matter their shape, why not try approximating the circle using a polygon with enough sides?</p>&#13;
<p class="indent">To convert a circle to a polygon, a number of divisions have to be chosen, say <em>n</em>. The entire 2<em>π</em> angle is divided into <em>n</em> subangles <em>θ</em> = 2<em>π</em>/<em>n</em>. Starting at angle 0 and incrementing it by <em>θ</em> each time, we can compute <em>n</em> points in the circumference, which will then become the vertices of a polygon inscribed in the circle. We can compute a vertex <em>V</em> at a given angle <em>α</em> using <a href="ch06.xhtml#ch06eqa02">Equation 6.2</a>,</p>&#13;
<div class="equationc" id="ch06eqa02"><img src="../images/06eqa02.jpg" alt="Image"/></div>&#13;
<p class="noindent">where <em>C</em> is the center of the circle and <em>r</em> is the radius. <a href="ch06.xhtml#ch6fig7">Figure 6-7</a> shows the result of choosing <em>n</em> = 8, which converts the circle into an octagon with vertices <em>V</em><sub>1</sub>, <em>V</em><sub>2</sub>, …, <em>V</em><sub>8</sub>.</p>&#13;
<div class="image"><img src="../images/06fig07.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch6fig7"><em>Figure 6-7: Converting a circle to a polygon</em></p>&#13;
<p class="indent">Also note how for small numbers of <em>n</em> the resulting polygon poorly approximates the circle. In <a href="ch06.xhtml#ch6fig8">Figure 6-8</a>, for example, <em>n</em> was chosen to be 3, 4, and 5, respectively. As you can see, the inscribed polygons only look remotely like the circles they approximate. We’ll typically choose <em>n</em> values ranging from 30 to 200 to yield an acceptable result.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_151"/><img src="../images/06fig08.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch6fig8"><em>Figure 6-8: Number of divisions when converting a circle to a polygon</em></p>&#13;
<p class="indent">Inside <span class="literal">Circle</span>, implement <span class="literal">to_polygon</span> as in <a href="ch06.xhtml#ch6lis16">Listing 6-16</a>.</p>&#13;
<pre>import math&#13;
&#13;
from geom2d.point import Point&#13;
<span class="codestrong1">from geom2d.polygon import Polygon</span>&#13;
&#13;
&#13;
class Circle:&#13;
   <span class="codeitalic1">--snip--</span>&#13;
&#13;
   def to_polygon(self, divisions: int):&#13;
    <span class="ent">➊</span> angle_delta = 2 * math.pi / divisions&#13;
      return Polygon(&#13;
       <span class="ent">➋</span> [self.__point_at_angle(angle_delta * i)&#13;
          for i in range(divisions)]&#13;
    )&#13;
&#13;
   def __point_at_angle(self, angle: float):&#13;
    <span class="ent">➌</span> return Point(&#13;
          self.center.x + self.radius * math.cos(angle),&#13;
          self.center.y + self.radius * math.sin(angle)&#13;
      )</pre>&#13;
<p class="caption"><a id="ch6lis16"/><em>Listing 6-16: Creating a polygon from a circle</em></p>&#13;
<p class="indent">This time we divided the algorithm in two: the main logic handled by <span class="literal">to_polygon</span> and a private method <span class="literal">__point_at_angle</span>, which, given an angle, returns the point in the circumference at that angle <span class="ent">➌</span>. Such a point is computed according to <a href="ch06.xhtml#ch06eqa02">Equation 6.2</a>.</p>&#13;
<p class="indent">The <span class="literal">to_polygon</span> method first computes the angle delta (or angle increment) for the given number of divisions <span class="ent">➊</span>. Then, using a list comprehension, it maps each integer number in the range [0,<em>n</em>) to a point in the circumference at incremental angles <span class="ent">➋</span>. This list of points is passed as the vertices for the initialization of a polygon. Note how we convert the range [0, <em>n</em>) into an angle by multiplying the current number in the range by the angle increment.</p>&#13;
<h4 class="h4" id="ch00lev2sec73"><span epub:type="pagebreak" id="page_152"/><strong><em>Equality and String Representation</em></strong></h4>&#13;
<p class="noindent">Let’s implement equality comparison and string representation methods in our <span class="literal">Circle</span> class. Enter the code in <a href="ch06.xhtml#ch6lis17">Listing 6-17</a>.</p>&#13;
<pre>import math&#13;
&#13;
<span class="codestrong1">from geom2d.nums import are_close_enough</span>&#13;
from geom2d.point import Point&#13;
from geom2d.polygon import Polygon&#13;
&#13;
&#13;
class Circle:&#13;
   <span class="codeitalic1">--snip--</span>&#13;
&#13;
   def __eq__(self, other):&#13;
       if self is other:&#13;
            return True&#13;
&#13;
        if not isinstance(other, Circle):&#13;
            return False&#13;
&#13;
       return self.center == other.center \&#13;
              and are_close_enough(self.radius, other.radius)&#13;
&#13;
   def __str__(self):&#13;
       return f'circle c = {self.center}, r = {self.radius}'</pre>&#13;
<p class="caption"><a id="ch6lis17"/><em>Listing 6-17: Circle equality and string representation</em></p>&#13;
<p class="indent">If you followed along, your <em>circle.py</em> file should look like <a href="ch06.xhtml#ch6lis18">Listing 6-18</a>.</p>&#13;
<pre>import math&#13;
&#13;
from geom2d.nums import are_close_enough&#13;
from geom2d.point import Point&#13;
from geom2d.polygon import Polygon&#13;
&#13;
&#13;
class Circle:&#13;
    def __init__(self, center: Point, radius: float):&#13;
        self.center = center&#13;
        self.radius = radius&#13;
&#13;
    @property&#13;
    def area(self):&#13;
        return math.pi * self.radius ** 2&#13;
&#13;
    @property&#13;
    def circumference(self):&#13;
        <span epub:type="pagebreak" id="page_153"/>return 2 * math.pi * self.radius&#13;
&#13;
    def contains_point(self, point: Point):&#13;
        return point.distance_to(self.center) &lt; self.radius&#13;
&#13;
    def to_polygon(self, divisions: int):&#13;
        angle_delta = 2 * math.pi / divisions&#13;
        return Polygon(&#13;
            [self.__point_at_angle(angle_delta * i)&#13;
             for i in range(divisions)]&#13;
        )&#13;
&#13;
    def __point_at_angle(self, angle: float):&#13;
        return Point(&#13;
            self.center.x + self.radius * math.cos(angle),&#13;
            self.center.y + self.radius * math.sin(angle)&#13;
        )&#13;
&#13;
    def __eq__(self, other):&#13;
        if self is other:&#13;
            return True&#13;
&#13;
        if not isinstance(other, Circle):&#13;
            return False&#13;
&#13;
        return self.center == other.center \&#13;
               and are_close_enough(self.radius, other.radius)&#13;
&#13;
    def __str__(self):&#13;
        return f'circle c = {self.center}, r = {self.radius}'</pre>&#13;
<p class="caption"><a id="ch6lis18"/><em>Listing 6-18: The <span class="codeitalic1">Circle</span> class</em></p>&#13;
<h4 class="h4" id="ch00lev2sec74"><strong><em>Circle Factories</em></strong></h4>&#13;
<p class="noindent">We’ll typically construct circles from a center point and a radius, but there are a few more ways we can construct them. In this section, we’ll look at one such case: generating a circle out of three points. We’ll do this mostly for fun, but it also gives a sense of how powerful the geometrical primitives we’re building are.</p>&#13;
<p class="indent">So, say we’re given three non-collinear points, namely, <em>A</em>, <em>B</em>, and <em>C</em>. As you can see in <a href="ch06.xhtml#ch6fig9">Figure 6-9</a>, you can find a circle such that it passes through all three points.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_154"/><img src="../images/06fig09.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch6fig9"><em>Figure 6-9: Defining a circle with three points</em></p>&#13;
<p class="indent">To solve the problem, we need to find the center and radius, but the latter is straightforward since if we know where the center is, the distance of any of the three points to it yields the radius. So, the problem boils down to finding the center of a circle passing through the given points. Here’s one way we can find it:</p>&#13;
<ol>&#13;
<li class="noindent">Compute the segment going from <em>A</em>  to <em>B</em>; let’s call it <em>seg</em><sub>1</sub>.</li>&#13;
<li class="noindent">Compute the segment going from <em>B</em>  to <em>C</em>;  let’s call it <em>seg</em><sub>2</sub>.</li>&#13;
<li class="noindent">Find the intersection between bisectors of <em>seg</em><sub>1</sub> and <em>seg</em><sub>2</sub>.</li>&#13;
</ol>&#13;
<p class="indent">The intersection point <em>O</em> is the center of the circle (see <a href="ch06.xhtml#ch6fig10">Figure 6-10</a>). And, as previously stated, finding the radius of the circle is as simple as measuring the distance between <em>O</em> and <em>A</em>, <em>B</em>, or <em>C</em>.</p>&#13;
<div class="image"><img src="../images/06fig10.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch6fig10"><em>Figure 6-10: The center and radius of a circle defined by three points</em></p>&#13;
<p class="indent">We’re ready to implement the logic. Create a new file in the <em>geom2d</em> package and name it <em>circles.py</em>. In the file, enter the code in <a href="ch06.xhtml#ch6lis19">Listing 6-19</a>.</p>&#13;
<pre>from geom2d import Point&#13;
from geom2d.circle import Circle&#13;
from geom2d.segment import Segment&#13;
&#13;
def make_circle_from_points(a: Point, b: Point, c: Point):&#13;
    chord_one_bisec = Segment(a, b).bisector&#13;
    chord_two_bisec = Segment(b, c).bisector&#13;
    center = chord_one_bisec.intersection_with(chord_two_bisec)&#13;
    radius = center.distance_to(a)&#13;
&#13;
    <span epub:type="pagebreak" id="page_155"/>return Circle(center, radius)</pre>&#13;
<p class="caption"><a id="ch6lis19"/><em>Listing 6-19: Circle from three points</em></p>&#13;
<div class="note">&#13;
<p class="notet"><span class="notes"><strong>NOTE</strong></span></p>&#13;
<p class="notep"><em>Recall that the chord of a circle is a segment whose endpoints lie on the circumference and cut across the circle.</em></p>&#13;
</div>&#13;
<p class="indent">If you were asked to simplify the function, could you? Each line tells you exactly what it’s doing; you can read the lines one by one and match them with the description of the algorithm. Self-explanatory code that clearly states its intent is commonly referred to as <em>clean code</em>, which is such a celebrated concept in the software industry that there are several books devoted to the topic. Two of my all-time favorites include [6] and [1], which I recommend you also read if you want to write truly readable code.</p>&#13;
<h3 class="h3" id="ch00lev1sec41"><strong>Rect Class</strong></h3>&#13;
<p class="noindent">The last geometric primitive we’ll implement in this chapter is a rectangle, but it’s not any sort of rectangle—it’s the kind whose sides are always horizontal and vertical. Rotated rectangles can be represented using the <span class="literal">Polygon</span> primitive from earlier in the chapter. The reason behind this seemingly restrictive rule has to do with what this primitive is typically used for.</p>&#13;
<p class="indent">Rectangles like this are often used in two-dimensional graphic applications for things like the following:</p>&#13;
<ul>&#13;
<li class="noindent">Representing a portion of the screen that needs to be redrawn</li>&#13;
<li class="noindent">Determining the position on the screen where something needs to be  drawn</li>&#13;
<li class="noindent">Determining the size of the geometry that has to be drawn</li>&#13;
<li class="noindent">Testing whether two objects are likely to collide</li>&#13;
<li class="noindent">Testing whether the mouse cursor is over a region of the screen</li>&#13;
</ul>&#13;
<p class="indent">A <em>rectangle</em> can be defined by a point (called the <em>origin</em>) and a size, which in turn has two properties: width and height (see <a href="ch06.xhtml#ch6fig11">Figure 6-11</a>). By convention, the origin point will be located at the bottom-left corner of the rectangle, assuming a coordinate system with an y-axis that points upward.</p>&#13;
<div class="image"><img src="../images/06fig11.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch6fig11"><em>Figure 6-11: A rectangle defined by an origin point <em>O</em>, width <em>w</em>, and height <em>h</em></em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_156"/>Let’s start with a class to represent sizes. Inside package <em>geom2d</em>, create a new file named <em>size.py</em> including the definition in <a href="ch06.xhtml#ch6lis20">Listing 6-20</a>.</p>&#13;
<pre>from geom2d.nums import are_close_enough&#13;
&#13;
&#13;
class Size:&#13;
    def __init__(self, width: float, height: float):&#13;
        self.width = width&#13;
        self.height = height&#13;
&#13;
    def __eq__(self, other):&#13;
        if self is other:&#13;
            return True&#13;
&#13;
        if not isinstance(other, Size):&#13;
            return False&#13;
&#13;
        return are_close_enough(self.width, other.width) \&#13;
               and are_close_enough(self.height, other.height)</pre>&#13;
<p class="caption"><a id="ch6lis20"/><em>Listing 6-20: The <span class="codeitalic1">Size</span> class</em></p>&#13;
<p class="indent">Using this representation of a size, let’s create the initial definition of <span class="literal">Rect</span>. Create a new file named <em>rect.py</em> and enter the code in <a href="ch06.xhtml#ch6lis21">Listing 6-21</a>.</p>&#13;
<pre>from geom2d.point import Point&#13;
from geom2d.size import Size&#13;
&#13;
&#13;
class Rect:&#13;
    def __init__(self, origin: Point, size: Size):&#13;
        self.origin = origin&#13;
        self.size = size&#13;
&#13;
    @property&#13;
    def left(self):&#13;
        return self.origin.x&#13;
&#13;
    @property&#13;
    def right(self):&#13;
        return self.origin.x + self.size.width&#13;
&#13;
    @property&#13;
    def bottom(self):&#13;
        return self.origin.y&#13;
&#13;
    @property&#13;
    def top(self):&#13;
        <span epub:type="pagebreak" id="page_157"/>return self.origin.y + self.size.height&#13;
&#13;
    @property&#13;
    def area(self):&#13;
        return self.size.width * self.size.height&#13;
&#13;
    @property&#13;
    def perimeter(self):&#13;
        return 2 * self.size.width + 2 * self.size.height</pre>&#13;
<p class="caption"><a id="ch6lis21"/><em>Listing 6-21: The <span class="codeitalic1">Rect</span> class</em></p>&#13;
<p class="indent">The class stores a <span class="literal">Point</span> instance for the origin point and a <span class="literal">Size</span> instance encoding its width and length. We defined some interesting properties in the class, namely:</p>&#13;
<div class="bqparan">&#13;
<p class="noindentin"><span class="codestrong">left</span>    The x-coordinate of the left-most side of the rectangle</p>&#13;
<p class="noindentin"><span class="codestrong">right</span>    The x-coordinate of the right-most side of the rectangle</p>&#13;
<p class="noindentin"><span class="codestrong">bottom</span>    The y-coordinate of the bottom-most side of the rectangle</p>&#13;
<p class="noindentin"><span class="codestrong">top</span>    The y-coordinate of the top-most side of the rectangle</p>&#13;
<p class="noindentin"><span class="codestrong">area</span>    The area of the rectangle</p>&#13;
<p class="noindentin"><span class="codestrong">perimeter</span>    The perimeter of the rectangle</p>&#13;
</div>&#13;
<p class="indent">Let’s create one of our rectangles in the shell:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">from geom2d.point import Point</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">from geom2d.size import Size</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">from geom2d.rect import Rect</span>&#13;
&#13;
&gt;&gt;&gt; <span class="codestrong1">origin = Point(10, 20)</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">size = Size(100, 150)</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">rect = Rect(origin, size)</span></pre>&#13;
<p class="noindent">And let’s inspect some of its properties:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">rect.right</span>&#13;
110&#13;
&#13;
&gt;&gt;&gt; <span class="codestrong1">rect.area</span>&#13;
15000&#13;
&#13;
&gt;&gt;&gt; <span class="codestrong1">rect.perimeter</span>&#13;
500</pre>&#13;
<h4 class="h4" id="ch00lev2sec75"><span epub:type="pagebreak" id="page_158"/><strong><em>Contains Point</em></strong></h4>&#13;
<p class="noindent">The next logical step is implementing a method to test whether a point is inside the rectangle. To test whether a point <em>P</em> lies inside a rectangle, we’ll use the following two conditions:</p>&#13;
<div class="equationc"><img src="../images/f00158-p1.jpg" alt="Image"/></div>&#13;
<p class="indent">Thanks to the attributes we added to the class, this is a piece of cake (see <a href="ch06.xhtml#ch6lis22">Listing 6-22</a>).</p>&#13;
<pre>class Rect:&#13;
   <span class="codeitalic1">--snip--</span>&#13;
&#13;
   def contains_point(self, point: Point):&#13;
       return self.left &lt; point.x &lt; self.right \&#13;
              and self.bottom &lt; point.y &lt; self.top</pre>&#13;
<p class="caption"><a id="ch6lis22"/><em>Listing 6-22: Testing whether a rectangle contains a point</em></p>&#13;
<p class="indent">Notice Python’s beautiful syntax for compound inequalities,</p>&#13;
<pre>left &lt; point.x &lt; right</pre>&#13;
<p class="noindent">which in most other languages would have to be expressed as two different conditions:</p>&#13;
<pre>left &lt; point.x &amp;&amp; point.x &lt; right</pre>&#13;
<h4 class="h4" id="ch00lev2sec76"><strong><em>Intersections</em></strong></h4>&#13;
<p class="noindent">Suppose we have two rectangles and we want to know if they overlap. Since <span class="literal">Rect</span> represents rectangles with sides that are always horizontal and vertical, the problem simplifies a lot. Testing whether two <span class="literal">Rect</span>s overlap is the same as testing whether their projections in both the x- and y-axes overlap. By <em>projections</em>, we mean the shadows they cast on the axis lines. Each shadow is an interval starting in the position of the value of the rectangle’s origin, with a length that’s either its width or its height (see <a href="ch06.xhtml#ch6fig12">Figure 6-12</a>).</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_159"/><img src="../images/06fig12.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch6fig12"><em>Figure 6-12: Projections of a rectangle</em></p>&#13;
<p class="indent">For example, the shadow in the horizontal axis of <a href="ch06.xhtml#ch6fig12">Figure 6-12</a> can be represented as the following interval,</p>&#13;
<p class="noindentc">(<em>O</em><sub>x</sub>, <em>O</em><sub>x</sub> + <em>w</em>)</p>&#13;
<p class="noindent">where <em>O</em> is the origin point and <em>w</em> is the width of the rectangle. Similarly, the vertical shadow or projection would be:</p>&#13;
<p class="noindentc">(<em>O</em><sub>y</sub>, <em>O</em><sub>y</sub> + <em>h</em>)</p>&#13;
<p class="noindent">where <em>h</em> is the height this time. Note that the result of <em>O</em><sub><em>x</em></sub> + <em>w</em> is exactly the <span class="literal">right</span> property as we’ve defined it in our <span class="literal">Rect</span> class, and <em>O</em><sub><em>y</em></sub> + <em>h</em> is <span class="literal">top</span>.</p>&#13;
<p class="indent"><a href="ch06.xhtml#ch6fig13">Figure 6-13</a> depicts two rectangles whose vertical projections overlap but whose horizontal projections don’t. Thus, the rectangles don’t overlap.</p>&#13;
<div class="image"><img src="../images/06fig13.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch6fig13"><em>Figure 6-13: Two nonintersecting rectangles</em></p>&#13;
<p class="indent"><a href="ch06.xhtml#ch6fig14">Figure 6-14</a>, on the other hand, depicts two rectangles with vertical and horizontal projections that overlap. As you can see, this layout does generate an overlapping region, shaded in gray. We can observe that overlapping rectangles always result in rectangular overlapping regions.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_160"/><img src="../images/06fig14.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch6fig14"><em>Figure 6-14: Two intersecting rectangles</em></p>&#13;
<p class="indent">Using the nomenclature from the previous figures, we can numerically define the condition using <em>open intervals</em>, intervals where the end points are excluded. Two rectangles overlap if</p>&#13;
<div class="equationc"><img src="../images/f0160-01.jpg" alt="Image"/></div>&#13;
<p class="indent">where ∩ is the intersection binary operator.</p>&#13;
<h5 class="h5" id="ch00lev3sec44"><strong>Open Intervals</strong></h5>&#13;
<p class="noindent">Now that we’ve reduced the problem to computing the intersection between intervals, let’s create a new class <span class="literal">OpenInterval</span> to implement this logic. Note that writing the implementation of the algorithm to find the intersection between two intervals inside the <span class="literal">Rect</span> class would be conceptually wrong. Each class must only contain logic related to its domain of knowledge, and it seems obvious that interval intersection is not specifically about rectangles. A rectangle should know nothing about how the intersection of two intervals is performed; it’s not part of its domain of knowledge. If it needs to compute one, like in our case, it should delegate it to the subject’s expert: <span class="literal">OpenRange</span>.</p>&#13;
<p class="indent">If you respect this simple guideline, your code will be much easier to reason about and extend. Every piece of knowledge in your code should live exactly where it’s supposed to, and only there. One of the worst enemies of software is <em>knowledge duplication</em>, a phenomenon where one piece of knowledge (call it an algorithm if you prefer) is written in more than one place. When the core of such logic needs to change, you need to remember to change it everywhere. Trust me when I say this problem is much worse than it sounds.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Most authors use the phrase</em> duplication of code<em>, but I prefer to call it</em> duplication of knowledge<em>. The choice of words is intentional as I’ve noticed some developers tend to misinterpret the concept, probably because the word</em> code <em>is quite generic. It’s the knowledge expressed by the code that should not be duplicated.</em></p>&#13;
</div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_161"/>Create a new file named <em>open_interval.py</em> in <em>geom2d</em>, and inside, define the <span class="literal">OpenInterval</span> class as in <a href="ch06.xhtml#ch6lis23">Listing 6-23</a>.</p>&#13;
<pre>class OpenInterval:&#13;
    def __init__(self, start: float, end: float):&#13;
        if start &gt; end:&#13;
            raise ValueError('start should be smaller than end')&#13;
        self.start = start&#13;
        self.end = end&#13;
&#13;
    @property&#13;
    def length(self):&#13;
     <span class="ent">➊</span> return self.end - self.start&#13;
&#13;
    def contains(self, value):&#13;
     <span class="ent">➋</span> return self.start &lt; value &lt; self.end</pre>&#13;
<p class="caption"><a id="ch6lis23"/><em>Listing 6-23: The <span class="codeitalic">OpenInterval</span> class</em></p>&#13;
<p class="indent">An <span class="literal">OpenInterval</span> is created with <span class="literal">start</span> and <span class="literal">end</span> properties. We make sure that <span class="literal">start</span> is smaller than <span class="literal">end</span>; otherwise, we raise a <span class="literal">ValueError</span> exception. Recall our failing fast convention; we don’t want an ill-constructed interval lying around. Next, we define the length of the interval as a property <span class="ent">➊</span> and a method to test whether a given value is inside the range <span class="ent">➋</span>.</p>&#13;
<p class="indent">Let’s now include two more methods: one for checking whether intervals overlap and another one for actually computing the resulting overlap (see <a href="ch06.xhtml#ch6lis24">Listing 6-24</a>).</p>&#13;
<pre><span class="codestrong1">from geom2d.nums import are_close_enough</span>&#13;
&#13;
&#13;
class OpenInterval:&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
    def overlaps_interval(self, other):&#13;
     <span class="ent">➊</span> if are_close_enough(self.start, other.start) and \&#13;
               are_close_enough(self.end, other.end):&#13;
           return True&#13;
&#13;
     <span class="ent">➋</span> return self.contains(other.start) \&#13;
               or self.contains(other.end) \&#13;
               or other.contains(self.start) \&#13;
               or other.contains(self.end)&#13;
&#13;
    def compute_overlap_with(self, other):&#13;
     <span class="ent">➌</span> if not self.overlaps_interval(other):&#13;
            return None&#13;
&#13;
     <span class="ent">➍</span> return OpenInterval(&#13;
            <span epub:type="pagebreak" id="page_162"/>max(self.start, other.start),&#13;
            min(self.end, other.end)&#13;
        )</pre>&#13;
<p class="caption"><a id="ch6lis24"/><em>Listing 6-24: Open interval overlapping</em></p>&#13;
<p class="indent">The first method, <span class="literal">overlaps_interval</span>, returns a <span class="literal">boolean</span> that will be <span class="literal">True</span> if the interval overlaps with <span class="literal">other</span> passed as an argument. To do this, we first check whether the two intervals have the same start and end values <span class="ent">➊</span>, in which case we return <span class="literal">True</span>. Then we check whether any of the four ends is contained in the other interval <span class="ent">➋</span>. If you’re confused by this piece of logic, take a pen and some paper and draw every possible combination of two overlapping intervals (I’ve done this for you in <a href="ch06.xhtml#ch6fig15">Figure 6-15</a>, excluding the case where the two intervals have the same start and end values).</p>&#13;
<div class="image"><img src="../images/06fig15.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch6fig15"><em>Figure 6-15: The possible cases for interval positions</em></p>&#13;
<p class="indent">The second method, <span class="literal">compute_overlap_with</span>, starts by making sure there’s actually an overlap, returning <span class="literal">None</span> if there isn’t <span class="ent">➌</span>. The overlap is simply a new interval where the start is the maximum between both start values, and the end is the minimum between the two end values <span class="ent">➍</span>.</p>&#13;
<p class="indent">I encourage you to write unit tests for this overlapping logic. It’s a wonderful opportunity to develop your testing skills. There are a bunch of combinations of overlapping intervals; try to cover them all.</p>&#13;
<h5 class="h5" id="ch00lev3sec45"><strong>Computing Intersections</strong></h5>&#13;
<p class="noindent">With the help of <span class="literal">OpenInterval</span>, rectangle intersections become simple to solve. Go back to <em>rect.py</em> and import the <span class="literal">OpenInterval</span> class:</p>&#13;
<pre>from geom2d.open_interval import OpenInterval</pre>&#13;
<p class="indent">Now, underneath the <span class="literal">contains_point</span> method, enter the code from <a href="ch06.xhtml#ch6lis25">Listing 6-25</a>.</p>&#13;
<pre><span class="codestrong1">from geom2d.open_interval import OpenInterval</span>&#13;
from geom2d.point import Point&#13;
from geom2d.size import Size&#13;
&#13;
&#13;
class Rect:&#13;
    <span epub:type="pagebreak" id="page_163"/><span class="codeitalic1">--snip--</span>&#13;
&#13;
    def intersection_with(self, other):&#13;
     <span class="ent">➊</span> h_overlap = self.__horizontal_overlap_with(other)&#13;
        if h_overlap is None:&#13;
            return None&#13;
&#13;
     <span class="ent">➋</span> v_overlap = self.__vertical_overlap_with(other)&#13;
        if v_overlap is None:&#13;
            return None&#13;
&#13;
     <span class="ent">➌</span> return Rect(&#13;
            Point(h_overlap.start, v_overlap.start),&#13;
            Size(h_overlap.length, v_overlap.length)&#13;
       )</pre>&#13;
<p class="caption"><a id="ch6lis25"/><em>Listing 6-25: Intersection between two rectangles</em></p>&#13;
<p class="indent">There are two private helper methods that compute both the horizontal and vertical overlaps; we’ll take a look at those in a moment. The method first computes the horizontal overlap between <span class="literal">self</span> and <span class="literal">other</span> <span class="ent">➊</span>. If it finds it to be <span class="literal">None</span>, there’s no horizontal overlap; therefore, the rectangles don’t intersect. <span class="literal">None</span> is returned. The same procedure goes for the vertical overlap <span class="ent">➋</span>. Only if both are not <span class="literal">None</span>, which means we found both horizontal and vertical projections overlapping, will we reach the last <span class="literal">return</span> where the resulting rectangle is computed <span class="ent">➌</span>. How do we go about finding the origin and size of such a rectangle? It’s easy: the origin coordinates are the start values from both horizontal and vertical overlap intervals, the width is the length of the horizontal overlap, and the height is the length of the vertical overlap.</p>&#13;
<p class="indent">So, the only missing part is the implementation of the private methods that finds the horizontal and vertical interval overlaps, if they exist. The code for that is in <a href="ch06.xhtml#ch6lis26">Listing 6-26</a>.</p>&#13;
<pre>class Rect:&#13;
   <span class="codeitalic1">--snip--</span>&#13;
&#13;
   def __horizontal_overlap_with(self, other):&#13;
       self_interval = OpenInterval(self.left, self.right)&#13;
       other_interval = OpenInterval(other.left, other.right)&#13;
&#13;
       return self_interval.compute_overlap_with(other_interval)&#13;
&#13;
   def __vertical_overlap_with(self, other):&#13;
       self_interval = OpenInterval(self.bottom, self.top)&#13;
       other_interval = OpenInterval(other.bottom, other.top)&#13;
&#13;
       return self_interval.compute_overlap_with(other_interval)</pre>&#13;
<p class="caption"><a id="ch6lis26"/><em>Listing 6-26: Intersection private methods</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_164"/>Let’s now take a look at how to build a generic polygon based on the rectangle.</p>&#13;
<h4 class="h4" id="ch00lev2sec77"><strong><em>Convert to Polygon</em></strong></h4>&#13;
<p class="noindent">As with circles, applying an affine transformation to a rectangle may result in some nonrectangular shape. In fact, after a generic affine transformation, a rectangle gets transformed into a parallelogram, as depicted in <a href="ch06.xhtml#ch6fig16">Figure 6-16</a>, and these shapes can’t be described by our <span class="literal">Rect</span> class.</p>&#13;
<div class="image"><img src="../images/06fig16.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch6fig16"><em>Figure 6-16: A rectangle after an affine transformation</em></p>&#13;
<p class="indent">Implementing a method to create a polygon from a rectangle is straightforward, as the vertices of such polygons are the four corners of the rectangle. In <span class="literal">Rect</span> class, add the method in <a href="ch06.xhtml#ch6lis27">Listing 6-27</a>. Don’t forget to import the <span class="literal">Polygon</span> class.</p>&#13;
<pre>from geom2d.open_interval import OpenInterval&#13;
from geom2d.point import Point&#13;
<span class="codestrong1">from geom2d.polygon import Polygon</span>&#13;
from geom2d.size import Size&#13;
&#13;
&#13;
class Rect:&#13;
   <span class="codeitalic1">--snip--</span>&#13;
&#13;
   def to_polygon(self):&#13;
       return Polygon([&#13;
           self.origin,&#13;
           Point(self.right, self.bottom),&#13;
           Point(self.right, self.top),&#13;
           Point(self.left, self.top)&#13;
       ])</pre>&#13;
<p class="caption"><a id="ch6lis27"/><em>Listing 6-27: Creating a polygon from a rectangle</em></p>&#13;
<p class="indent">Needless to say, vertices should be given in order, clockwise or counterclockwise, but respecting the order nevertheless. It’s really easy to mess up <span epub:type="pagebreak" id="page_165"/>the order of vertices and end up with crossing sides. To make sure this never happens, we should write a test, which is left for you as an exercise.</p>&#13;
<h4 class="h4" id="ch00lev2sec78"><strong><em>Equality</em></strong></h4>&#13;
<p class="noindent">You’re already an expert at implementing <span class="literal">__eq__</span> methods, aren’t you? <a href="ch06.xhtml#ch6lis28">Listing 6-28</a> shows the code for it.</p>&#13;
<pre>class Rect:&#13;
   <span class="codeitalic1">--snip--</span>&#13;
&#13;
    def __eq__(self, other):&#13;
        if self is other:&#13;
            return True&#13;
&#13;
        if not isinstance(other, Rect):&#13;
            return False&#13;
&#13;
        return self.origin == other.origin \&#13;
               and self.size == other.size</pre>&#13;
<p class="caption"><a id="ch6lis28"/><em>Listing 6-28: Rectangle equality</em></p>&#13;
<p class="indent">The only thing to note is that we were able to directly compare sizes using <span class="literal">==</span> because we also implemented <span class="literal">__eq__</span> on class <span class="literal">Size</span>.</p>&#13;
<p class="indent">Note that implementing <span class="literal">__\textit{eq}__</span> in <em>Rect</em> like <span class="literal">are_close_enough(self.size.width,other.size.width) ...</span> would not be ideal. Remember the law of Demeter? That knowledge belongs to class <em>Size</em> and should be implemented there and only there.</p>&#13;
<p class="indent">For reference, <a href="ch06.xhtml#ch6lis29">Listing 6-29</a> shows how your <em>rect.py</em> file should look.</p>&#13;
<pre>from geom2d.open_interval import OpenInterval&#13;
from geom2d.point import Point&#13;
from geom2d.polygon import Polygon&#13;
from geom2d.size import Size&#13;
&#13;
&#13;
class Rect:&#13;
&#13;
    def __init__(self, origin: Point, size: Size):&#13;
        self.origin = origin&#13;
        self.size = size&#13;
&#13;
    @property&#13;
    def left(self):&#13;
        return self.origin.x&#13;
&#13;
    @property&#13;
    def right(self):&#13;
        return self.origin.x + self.size.width&#13;
&#13;
    @property&#13;
    def bottom(self):&#13;
        return self.origin.y&#13;
&#13;
    @property&#13;
    def top(self):&#13;
        <span epub:type="pagebreak" id="page_166"/>return self.origin.y + self.size.height&#13;
&#13;
    @property&#13;
    def area(self):&#13;
        return self.size.width * self.size.height&#13;
&#13;
    @property&#13;
    def perimeter(self):&#13;
        return 2 * self.size.width + 2 * self.size.height&#13;
&#13;
    def contains_point(self, point: Point):&#13;
        return self.left &lt; point.x &lt; self.right \&#13;
               and self.bottom &lt; point.y &lt; self.top&#13;
&#13;
    def intersection_with(self, other):&#13;
        h_overlap = self.__horizontal_overlap_with(other)&#13;
        if h_overlap is None:&#13;
            return None&#13;
&#13;
        v_overlap = self.__vertical_overlap_with(other)&#13;
        if v_overlap is None:&#13;
            return None&#13;
&#13;
        return Rect(&#13;
            Point(h_overlap.start, v_overlap.start),&#13;
            Size(h_overlap.length, v_overlap.length)&#13;
        )&#13;
&#13;
    def __horizontal_overlap_with(self, other):&#13;
        self_interval = OpenInterval(self.left, self.right)&#13;
        other_interval = OpenInterval(other.left, other.right)&#13;
&#13;
        return self_interval.compute_overlap_with(other_interval)&#13;
&#13;
    def __vertical_overlap_with(self, other):&#13;
        self_interval = OpenInterval(self.bottom, self.top)&#13;
        other_interval = OpenInterval(other.bottom, other.top)&#13;
&#13;
        return self_interval.compute_overlap_with(other_interval)&#13;
&#13;
    <span epub:type="pagebreak" id="page_167"/>def to_polygon(self):&#13;
        return Polygon([&#13;
            self.origin,&#13;
            Point(self.right, self.bottom),&#13;
            Point(self.right, self.top),&#13;
            Point(self.left, self.top)&#13;
        ])&#13;
&#13;
    def __eq__(self, other):&#13;
        if self is other:&#13;
            return True&#13;
&#13;
        if not isinstance(other, Rect):&#13;
            return False&#13;
&#13;
        return self.origin == other.origin \&#13;
               and self.size == other.size</pre>&#13;
<p class="caption"><a id="ch6lis29"/><em>Listing 6-29: The <span class="codeitalic1">Rect</span> implementation</em></p>&#13;
<h4 class="h4" id="ch00lev2sec79"><strong><em>Rectangle Factories</em></strong></h4>&#13;
<p class="noindent">We’ll often use rectangles to approximate the outside bounds of a set of geometries. In future chapters of the book, for example, we’ll be generating diagrams as part of the solution for mechanics problems. To fit the diagrams inside an image of the right size, we’ll create a rectangle that can contain everything. To do this, we’ll create a factory function that returns a rectangle that contains a given list of points.</p>&#13;
<p class="indent">For example, if we’re given the list of points [<em>A, B, C, D, E</em>], the rectangle will look like the left illustration from <a href="ch06.xhtml#ch6fig17">Figure 6-17</a>. We’ll also need another factory function that does something similar but also adds some margin to the rectangle.</p>&#13;
<div class="image"><img src="../images/06fig17.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch6fig17"><em>Figure 6-17: A rectangle containing points</em></p>&#13;
<p class="indent">Inside package <em>geom2d</em>, create a new file and name it <em>rects.py</em>. Add the first factory function (in <a href="ch06.xhtml#ch6lis30">Listing 6-30</a>).</p>&#13;
<pre>from geom2d.point import Point&#13;
from geom2d.rect import Rect&#13;
from geom2d.size import Size&#13;
&#13;
&#13;
<span epub:type="pagebreak" id="page_168"/>def make_rect_containing(points: [Point]):&#13;
 <span class="ent">➊</span> if not points:&#13;
        raise ValueError('Expected at least one point')&#13;
&#13;
    first_point = points[0]&#13;
 <span class="ent">➋</span> min_x, max_x = first_point.x, first_point.x&#13;
 <span class="ent">➌</span> min_y, max_y = first_point.y, first_point.y&#13;
&#13;
    for point in points[1:]:&#13;
     <span class="ent">➍</span> min_x, max_x = min(min_x, point.x), max(max_x, point.x)&#13;
     <span class="ent">➎</span> min_y, max_y = min(min_y, point.y), max(max_y, point.y)&#13;
&#13;
 <span class="ent">➏</span> return Rect(&#13;
        Point(min_x, min_y),&#13;
        Size(max_x - min_x, max_y - min_x)&#13;
    )</pre>&#13;
<p class="caption"><a id="ch6lis30"/><em>Listing 6-30: Creating a rectangle containing a list of points</em></p>&#13;
<p class="indent">The first step is checking that the list <span class="literal">points</span> contains at least one point <span class="ent">➊</span>. You may be surprised about the syntax; the trick here is that Python evaluates empty lists as <span class="literal">False</span> in boolean contexts. In fact, that’s a Pythonic idiom used to check whether a list is empty.</p>&#13;
<p class="indent">Next, we need to look for the bounds of the rectangle: the minimum and maximum x and y projections. Four variables store those values <span class="ent">➋ ➌</span> initialized with the coordinates of the first point in the list. Then we iterate through all points except for this first one, as it was already used to initialize the aforementioned variables. To avoid passing through the first point, we slice the <span class="literal">points</span> list starting at index 1 and going all the way to the end of the list: <span class="literal">points[1:]</span>. (You can refer to “Lists” on <a href="ch01.xhtml#ch00lev2sec15">page 15</a> for a refresher on slicing lists.) For each point, the minimum and maximum x <span class="ent">➍</span> and y <span class="ent">➎</span> projections are compared to the values currently stored.</p>&#13;
<p class="indent">Once we have these four values, we construct the resulting rectangle <span class="ent">➏</span> using the minimum x and y projections for the origin and the difference between each maximum and minimum for the size.</p>&#13;
<p class="indent">Let’s now implement a similar function with the addition of a margin around the points. After <span class="literal">make_rect_containing</span>, enter the code in <a href="ch06.xhtml#ch6lis31">Listing 6-31</a>.</p>&#13;
<pre><span class="codeitalic1">--snip--</span>&#13;
&#13;
def make_rect_containing_with_margin(points: [Point], margin: float):&#13;
 <span class="ent">➊</span> rect = make_rect_containing(points)&#13;
    return Rect(&#13;
     <span class="ent">➋</span> Point(&#13;
            rect.origin.x - margin,&#13;
            rect.origin.y - margin&#13;
        ),&#13;
     <span class="ent">➌</span> Size(&#13;
            <span epub:type="pagebreak" id="page_169"/>2 * margin + rect.size.width,&#13;
            2 * margin + rect.size.height&#13;
        )&#13;
    )</pre>&#13;
<p class="caption"><a id="ch6lis31"/><em>Listing 6-31: Creating a rectangle containing a list of points and a given margin</em></p>&#13;
<p class="indent">This function starts with a rectangle computed by the previous function <span class="ent">➊</span>. The new rectangle is then computed by displacing <span class="literal">rect</span>’s origin by the width of the margin to the left and downward <span class="ent">➋</span> and increasing the size by two times the width of the margin <span class="ent">➌</span>. Recall that the margin is added to the left and to the right, which is why we add it twice to the width—the same goes for the height.</p>&#13;
<p class="indent">There’s one last way we may want to build a rectangle: using its center and size. The implementation is straightforward, as you can see in <a href="#ch6lis32">Listing 6-32</a>.</p>&#13;
<pre><span class="codeitalic1">--snip--</span>&#13;
&#13;
def make_rect_centered(center: Point, width: float, height: float):&#13;
    origin = Point(&#13;
        center.x - width / 2,&#13;
        center.y - height / 2&#13;
    )&#13;
    return Rect(origin, Size(width, height))</pre>&#13;
<p class="caption"><a id="ch6lis32"/><em>Listing 6-32: Creating a rectangle given its center and size</em></p>&#13;
<p class="indent">With these three factory methods we have convenient ways of creating rectangles. We’ll be using these in further chapters, so we want to make sure they yield the expected rectangle with some automated unit tests. I’ll leave this as an exercise for you. You’ll find the tests I wrote in <em>rects_test.py</em> in the source code accompanying the book.</p>&#13;
<h3 class="h3" id="ch00lev1sec42"><strong>Summary</strong></h3>&#13;
<p class="noindent">We started the chapter implementing a generic polygon, described by a sequence of at least three vertices. We wrote an algorithm to pair sequences of objects such that the last and first elements are also paired up and used this logic to generate the sides of the polygon. We also implemented the winding number algorithm to check whether the polygon contains a point.</p>&#13;
<p class="indent">The second geometric primitive we created in this chapter was the circle. As you saw, checking whether a point is inside a circle was much simpler to implement than in the case of generic polygons. We came up with a way of constructing a generic polygon that approximates the geometry of the circle using a given number of divisions or sides. We’ll make use of this method in the next chapter.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_170"/>Lastly, we implemented a rectangle. To compute intersection between rectangles, we needed a way of figuring out the overlap between two intervals; thus, we created an abstraction of an open interval to handle this logic.</p>&#13;
<p class="indent">Our geometry library is almost complete. We have all the primitives that we need for the book; the only thing missing is a way of transforming them, which is the topic of the next chapter.</p>&#13;
</body></html>