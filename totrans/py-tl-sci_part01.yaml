- en: '**PART I'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SETTING UP YOUR SCIENTIFIC CODING ENVIRONMENT**
  prefs: []
  type: TYPE_NORMAL
- en: In [Part I](part01.xhtml#part01), you’ll create a scientific coding environment
    to build upon for years to come. You’ll start by installing *Anaconda*, a distribution
    of Python that works on Windows, macOS, and Linux and provides access to the science
    libraries we’ll use in this book. You’ll then learn to use the conda package and
    environment manager to keep your projects organized and up to date. After that,
    you’ll familiarize yourself with the popular coding tools Jupyter Qt console,
    Spyder, Jupyter Notebook, and JupyterLab.
  prefs: []
  type: TYPE_NORMAL
- en: These coding tools help you write code, run code, and review the output, and
    are summarized in [Table I-1](part01.xhtml#ch0itab1). If you’re unsure of the
    meaning of any of the terminology in the table, see the “Terminology” sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table I-1:** Coding Tool Summaries'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/part01_table1fig1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Jupyter Qt console lets you execute commands inside windows called IPython
    interpreters and immediately displays the results. You can use this console to
    interact with and visualize data. It’s also great for learning Python.
  prefs: []
  type: TYPE_NORMAL
- en: The famous Jupyter Notebook is a web application that allows you to create and
    share documents that contain live code, equations, visualizations, and narrative
    text. It’s a wildly popular tool for data science that lets you do everything
    from exploring and cleaning data to producing polished and interactive reports,
    presentations, and dashboards. Using the cloud-based *JupyterHub*, you can serve
    Jupyter notebooks to multiple users such as a class of students or a scientific
    research group.
  prefs: []
  type: TYPE_NORMAL
- en: Spyder and JupyterLab are *integrated development environments (IDEs)*. An IDE
    is an application that provides programmers with a set of tools for software development.
    For example, an IDE might include tools for debugging software and timing how
    long the code, or parts of the code, take to run. IDEs are built to work with
    specific application platforms and remove barriers involved in the development
    life cycle. They are generally used for more heavy-duty programming than is normally
    done in consoles or notebooks. *JupyterLab*, the next-generation user interface
    for Anaconda’s Project Jupyter, combines the classic Jupyter Notebook with a user
    interface that offers an IDE-like experience. It will someday replace Jupyter
    Notebook.
  prefs: []
  type: TYPE_NORMAL
- en: These coding tools are products of *Interactive Python (IPython)*, a command
    shell used for interactive computing. (A *command shell* exposes the operating
    system’s services to a program or human user.) IPython is still evolving, and
    in 2015 the project split so that the language-agnostic parts, such as the notebook
    format, Qt console, web applications, message protocol, and so on, were put in
    the Jupyter project.
  prefs: []
  type: TYPE_NORMAL
- en: The name *Jupyter* references the Julia, Python, and R languages, though the
    project supports more than 40 languages. After the split, some terms changed.
    Most notably, IPython Notebook became Jupyter Notebook. There is also some overlap
    in the functionality of IPython products. This can cause confusion, especially
    given the volume of online articles and tutorials that reference the old terminology.
    If you’re interested in the history of IPython and Jupyter Notebook, check out
    the datacamp blog post “IPython or Jupyter?” at *[https://www.datacamp.com/community/blog/ipython-jupyter/](https://www.datacamp.com/community/blog/ipython-jupyter/)*.
  prefs: []
  type: TYPE_NORMAL
- en: '**TERMINOLOGY**'
  prefs: []
  type: TYPE_NORMAL
- en: The following are some important terms that we’ll be using in [Part I](part01.xhtml#part01).
  prefs: []
  type: TYPE_NORMAL
- en: '**Debugging**'
  prefs: []
  type: TYPE_NORMAL
- en: A multistep process for finding, isolating, and resolving problems that prevent
    proper program operation, known as *bugs*. Debugging is usually performed with
    a program called, appropriately, a *debugger*. Debuggers run the problem program
    under controlled conditions in a step-by-step mode to track its operations. This
    typically involves running or halting the program at specific points, skipping
    over certain parts, displaying memory content, showing the position of errors
    that cause the program to crash, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '**Extensible**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Extensibility* is a principle used in software engineering and systems design
    that indicates whether a tool provides for future growth. JupyterLab, for example,
    is designed as an extensible environment. JupyterLab *extensions* are add-ons
    that provide new interactive features to the JupyterLab interface. For instance,
    *JupyterLab LaTeX* is an extension that lets you live-edit LaTeX documents, *JupyterLab
    Plotly* is an extension for rendering Plotly charts, and *JupyterLab System Monitor*
    lets you monitor your own resource usage, such as memory and CPU time. You can
    even write custom plug-ins for your own projects.'
  prefs: []
  type: TYPE_NORMAL
- en: '**IDE**'
  prefs: []
  type: TYPE_NORMAL
- en: An IDE is a coding tool that integrates other specialized utilities into a single
    programming environment. Among these specialized tools are a text editor, a debugger,
    functions for autocompleting code, functions for highlighting mistakes, file managers,
    project managers, a performance profiler, a deployment tool, a compiler, and so
    on. By combining common software-writing tools into a single application, IDEs
    increase programmer productivity and make it easier to manage big projects with
    lots of interrelated scripts. The downside is that IDEs can be *heavy*, meaning
    they can take up a lot of system resources. They can also be a bit intense for
    beginners and those who need to write only relatively simple scripts.
  prefs: []
  type: TYPE_NORMAL
- en: '**Introspection**'
  prefs: []
  type: TYPE_NORMAL
- en: The ability to determine the type of an object and check its properties at runtime.
    In Python, an *object* is a code feature that has attributes and methods; you’ll
    learn more about these in [Chapter 13](ch13.xhtml). Code introspection dynamically
    examines these objects and provides information about them. When introspection
    is available, hovering the cursor over an object in your code will launch a pop-up
    window listing the type of object as well as useful tips about using it.
  prefs: []
  type: TYPE_NORMAL
- en: '**Kernel**'
  prefs: []
  type: TYPE_NORMAL
- en: The computational engine at the core of an operating system. It is always resident
    in memory, which means that the operating system is not permitted to swap it out
    to a storage device. The kernel manages disks, tasks, and memory and acts as a
    bridge between applications and the data processing performed at the hardware
    level.
  prefs: []
  type: TYPE_NORMAL
- en: '**Profiling**'
  prefs: []
  type: TYPE_NORMAL
- en: An analysis that measures the amount of time or memory required for a program,
    or a program’s components, to run. Profiling information can optimize code and
    improve its performance. IDEs, such as Spyder, come with profiling tools built
    in.
  prefs: []
  type: TYPE_NORMAL
- en: '**Qt**'
  prefs: []
  type: TYPE_NORMAL
- en: Pronounced *cute*, this is a widget (“Windows gadget”) toolkit for creating
    graphical user interfaces and cross-platform applications that run on Windows,
    macOS, Linux, and Android.
  prefs: []
  type: TYPE_NORMAL
- en: '**Terminal**'
  prefs: []
  type: TYPE_NORMAL
- en: In modern usage, *terminal* refers to a *terminal emulator* rather than actual
    hardware such as a monitor and keyboard. Emulators provide a text-based interface
    at which to enter commands and may also be referred to as a *command line interface
    (CLI)*, *command prompt*, *console*, or *shell*. The major operating systems all
    come with some type of terminal. Windows includes the Command Prompt executable,
    *cmd.exe*, for running Disk Operating System (DOS) commands and to connect to
    other servers. macOS ships with the aptly named *Terminal*, which you can use
    to run Unix commands within the operating system or to access other machines using
    the Zsh or Z shell. Unix normally includes a program called *xterm*, which can
    run *Bash* or other Unix shells.
  prefs: []
  type: TYPE_NORMAL
- en: Terminals are not very user friendly, but they allow access to information and
    software that sometimes is available only on a central computer, such as a File
    Transfer Protocol (FTP) server. Manipulating thousands of files and folders in
    the operating system is also easier in a terminal than in a graphics window. You
    can automate and expedite workflows on your computer, saving you time and aggravation.
    Additionally, you can run Python programs from a terminal as well as a lot of
    Anaconda operations (as an alternative to performing them with the Anaconda Navigator
    GUI). Best of all, knowing how to use a terminal will greatly impress your colleagues.
  prefs: []
  type: TYPE_NORMAL
- en: After you finish [Chapter 4](ch04.xhtml) in [Part I](part01.xhtml#part01), you
    can proceed to [Part II](part02.xhtml#part02), “A Python Primer,” for an introduction
    to Python programming. If you’re comfortable with Python, complete [Part I](part01.xhtml#part01)
    and go straight to [Part III](part03.xhtml#part03), “The Anaconda Ecosystem,”
    to learn more about the essential packages for scientific computing.
  prefs: []
  type: TYPE_NORMAL
