["```py\n\"\"\"Turn a word into its Pig Latin equivalent.\"\"\"\nimport sys\n\nVOWELS = 'aeiouy'\n\nwhile True:\n    word = input(\"Type a word and get its Pig Latin translation: \")\n\n    if word[0] in VOWELS:\n        pig_Latin = word + 'way'\n    else:\n        pig_Latin = word[1:] + word[0] + 'ay'\n    print()\n    print(\"{}\".format(pig_Latin), file=sys.stderr)\n\n    try_again = input(\"\\n\\nTry again? (Press Enter else n to stop)\\n \")\n    if try_again.lower() == \"n\":\n        sys.exit()\n```", "```py\n\"\"\"Map letters from string into dictionary & print bar chart of frequency.\"\"\"\nimport sys\nimport pprint\nfrom collections import defaultdict\n\n# Note: text should be a short phrase for bars to fit in IDLE window\ntext = 'Like the castle in its corner in a medieval game, I foresee terrible \\\ntrouble and I stay here just the same.'\n\nALPHABET = 'abcdefghijklmnopqrstuvwxyz'\n\n# defaultdict module lets you build dictionary keys on the fly!\nmapped = defaultdict(list)\nfor character in text:\n    character = character.lower()\n    if character in ALPHABET:\n        mapped[character].append(character)\n\n# pprint lets you print stacked output\nprint(\"\\nYou may need to stretch console window if text wrapping occurs.\\n\")\nprint(\"text = \", end='')\nprint(\"{}\\n\".format(text), file=sys.stderr)\npprint.pprint(mapped, width=110)\n```", "```py\n\"\"\"Remove single-letter words from list if not 'a' or 'i'.\"\"\"\n\nword_list = ['a', 'nurses', 'i', 'stack', 'b', 'c', 'cat']\n\nword_list_clean = []\n\npermissible = ('a', 'i')\n\nfor word in word_list:\n\n    if len(word) > 1:\n\n        word_list_clean.append(word)\n\n    elif len(word) == 1 and word in permissible:\n\n        word_list_clean.append(word)\n\n    else:\n\n        continue\n\nprint(\"{}\".format(word_list_clean))\n```", "```py\n\"\"\"Generate letter pairs in Voldemort & find their frequency in a dictionary.\n\nRequires load_dictionary.py module to load an English dictionary file.\n\n\"\"\"\nimport re\nfrom collections import defaultdict\nfrom itertools import permutations\nimport load_dictionary\n\nword_list = load_dictionary.load('2of4brif.txt')\n\nname = 'Voldemort'  #(tmvoordle)\nname = name.lower()\n\n# generate unique letter pairs from name\ndigrams = set()\nperms = {''.join(i) for i in permutations(name)}\nfor perm in perms:\n    for i in range(0, len(perm) - 1):\n        digrams.add(perm[i] + perm[i + 1])\nprint(*sorted(digrams), sep='\\n')\nprint(\"\\nNumber of digrams = {}\\n\".format(len(digrams)))\n\n# use regular expressions to find repeating digrams in a word\nmapped = defaultdict(int)\nfor word in word_list:\n    word = word.lower()\n    for digram in digrams:\n        for m in re.finditer(digram, word):\n            mapped[digram] += 1\n\nprint(\"digram frequency count:\")\ncount = 0\nfor k in sorted(mapped):\n    print(\"{} {}\".format(k, mapped[k]))\n```", "```py\n\"\"\"Load ciphertext & use fraction of ETAOIN present to classify cipher type.\"\"\"\nimport sys\nfrom collections import Counter\n\n# set arbitrary cutoff fraction of 6 most common letters in English\n# ciphertext with target fraction or greater = transposition cipher\nCUTOFF = 0.5\n\n# load ciphertext\ndef load(filename):\n    \"\"\"Open text file and return list.\"\"\"\n    with open(filename) as f:\n        return f.read().strip()\n\ntry:\n    ciphertext = load('cipher_a.txt')\nexcept IOError as e:\n    print(\"{}. Terminating program.\".format(e),\n          file=sys.stderr)\n    sys.exit(1)\n\n# count 6 most common letters in ciphertext\nsix_most_frequent = Counter(ciphertext.lower()).most_common(6)\nprint(\"\\nSix most-frequently-used letters in English = ETAOIN\")\nprint('\\nSix most frequent letters in ciphertext =')\nprint(*six_most_frequent, sep='\\n')\n\n# convert list of tuples to set of letters for comparison\ncipher_top_6 = {i[0] for i in six_most_frequent}\n\nTARGET = 'etaoin'\ncount = 0\nfor letter in TARGET:\n    if letter in cipher_top_6:\n        count += 1\n\nif count/len(TARGET) >= CUTOFF:\n    print(\"\\nThis ciphertext most-likely produced by a TRANSPOSITION cipher\")\nelse:\n    print(\"This ciphertext most-likely produced by a SUBSTITUTION cipher\")\n```", "```py\n\"\"\"Input cipher key string, get user input on route direction as dict value.\"\"\"\ncol_order = \"\"\"1 3 4 2\"\"\"\nkey = dict()\ncols = [int(i) for i in col_order.split()]\nfor col in cols:\n    while True:\n        key[col] = input(\"Direction to read Column {} (u = up, d = down): \"\n                         .format(col).lower())\n        if key[col] == 'u' or key[col] == 'd':\n            break\n        else:\n            print(\"Input should be 'u' or 'd'\")\n\n    print(\"{}, {}\".format(col, key[col]))\n```", "```py\n\"\"\"For a total number of columns, find all unique column arrangements.\n\nBuilds a list of lists containing all possible unique arrangements of\nindividual column numbers, including negative values for route direction\n(read up column vs. down).\n\nInput:\n-total number of columns\n\nReturns:\n-list of lists of unique column orders, including negative values for\nroute cipher encryption direction\n\n\"\"\"\nimport math\nfrom itertools import permutations, product\n\n#------BEGIN INPUT-----------------------------------------------------------\n\n# Input total number of columns:\nnum_cols = 4\n\n#------DO NOT EDIT BELOW THIS LINE--------------------------------------------\n\n# generate listing of individual column numbers\ncolumns = [x for x in range(1, num_cols+1)]\nprint(\"columns = {}\".format(columns))\n\n# build list of lists of column number combinations\n# itertools product computes the Cartesian product of input iterables\ndef perms(columns):\n    \"\"\"Take number of columns integer & generate pos & neg permutations.\"\"\"\n    results = []\n    for perm in permutations(columns):\n        for signs in product([-1, 1], repeat=len(columns)):\n            results.append([i*sign for i, sign in zip(perm, signs)])\n    return results\n\ncol_combos = perms(columns)\nprint(*col_combos, sep=\"\\n\")  # comment-out for num_cols > 4!\nprint(\"Factorial of num_cols without negatives = {}\"\n      .format(math.factorial(num_cols)))\nprint(\"Number of column combinations = {}\".format(len(col_combos)))\n```", "```py\n\"\"\"Brute-force hack a Union route cipher (route_cipher_hacker.py).\n\nDesigned for whole-word transposition ciphers with variable rows & columns.\nAssumes encryption began at either top or bottom of a column.\nPossible keys auto-generated based on number of columns & rows input.\nKey indicates the order to read columns and the direction to traverse.\nNegative column numbers mean start at bottom and read up.\nPositive column numbers means start at top & read down.\n\nExample below is for 4x4 matrix with key -1 2 -3 4.\nNote \"0\" is not allowed.\nArrows show encryption route; for negative key values read UP.\n\n  1   2   3   4\n___ ___ ___ ___\n| ^ | | | ^ | | | MESSAGE IS WRITTEN\n|_|_|_v_|_|_|_v_|\n| ^ | | | ^ | | | ACROSS EACH ROW\n|_|_|_v_|_|_|_v_|\n| ^ | | | ^ | | | IN THIS MANNER\n|_|_|_v_|_|_|_v_|\n| ^ | | | ^ | | | LAST ROW IS FILLED WITH DUMMY WORDS\n|_|_|_v_|_|_|_v_|\nSTART        END\n\nRequired inputs - a text message, # of columns, # of rows, key string\nRequires custom-made \"perms\" module to generate keys\nPrints off key used and translated plaintext\n\"\"\"\nimport sys\nimport perms\n\n#==============================================================================\n# USER INPUT:\n\n# the string to be decrypted (type or paste between triple-quotes):\nciphertext = \"\"\"REST TRANSPORT YOU GODWIN VILLAGE ROANOKE WITH ARE YOUR IS JUST\nSUPPLIES FREE SNOW HEADING TO GONE TO SOUTH FILLER\n\"\"\"\n\n# the number of columns believed to be in the transposition matrix:\nCOLS = 4\n\n# the number of rows believed to be in the transposition matrix:\nROWS = 5\n\n# END OF USER INPUT - DO NOT EDIT BELOW THIS LINE!\n#==============================================================================\n\ndef main():\n    \"\"\"Turn ciphertext into list, call validation & decryption functions.\"\"\"\n    cipherlist = list(ciphertext.split())\n    validate_col_row(cipherlist)\n    decrypt(cipherlist)\n\ndef validate_col_row(cipherlist):\n    \"\"\"Check that input columns & rows are valid vs. message length.\"\"\"\n    factors = []\n    len_cipher = len(cipherlist)\n    for i in range(2, len_cipher):  # range excludes 1-column ciphers\n        if len_cipher % i == 0:\n            factors.append(i)\n    print(\"\\nLength of cipher = {}\".format(len_cipher))\n    print(\"Acceptable column/row values include: {}\".format(factors))\n    print()\n    if ROWS * COLS != len_cipher:\n        print(\"\\nError - Input columns & rows not factors of length \"\n              \"of cipher. Terminating program.\", file=sys.stderr)\n        sys.exit(1)\n\ndef decrypt(cipherlist):\n    \"\"\"Turn columns into items in list of lists & decrypt ciphertext.\"\"\"\n    col_combos = perms.perms(COLS)\n    for key in col_combos:\n        translation_matrix = [None] * COLS\n        plaintext = ''\n        start = 0\n        stop = ROWS\n        for k in key:\n            if k < 0: # reading bottom-to-top of column\n                col_items = cipherlist[start:stop]\n            elif k > 0: # reading top-to-bottom of columnn\n                col_items = list((reversed(cipherlist[start:stop])))\n            translation_matrix[abs(k) - 1] = col_items\n            start += ROWS\n            stop += ROWS\n        # loop through nested lists popping off last item to a new list:\n        for i in range(ROWS):\n            for matrix_col in translation_matrix:\n                word = str(matrix_col.pop())\n                plaintext += word + ' '\n        print(\"\\nusing key = {}\".format(key))\n        print(\"translated = {}\".format(plaintext))\n    print(\"\\nnumber of keys = {}\".format(len(col_combos)))\n\nif __name__ == '__main__':\n    main()\n```", "```py\n\"\"\"For a total number of columns, find all unique column arrangements.\n\nBuilds a list of lists containing all possible unique arrangements of\nindividual column numbers including negative values for route direction\n\nInput:\n-total number of columns\n\nReturns:\n-list of lists of unique column orders including negative values for\nroute cipher encryption direction\n\n\"\"\"\nfrom itertools import permutations, product\n\n# build list of lists of column number combinations\n# itertools product computes the Cartesian product of input iterables\ndef perms(num_cols):\n    \"\"\"Take number of columns integer & generate pos & neg permutations.\"\"\"\n    results = []\n    columns = [x for x in range(1, num_cols+1)]\n    for perm in permutations(columns):\n        for signs in product([-1, 1], repeat=len(columns)):\n            results.append([i*sign for i, sign in zip(perm, signs)])\n    return results\n```", "```py\n\"\"\"Hide a null cipher within a list of names using a variable pattern.\"\"\"\nimport load_dictionary\n\n# write a short message and use no punctuation or numbers!\nmessage = \"Give your word and we rise\"\nmessage = \"\".join(message.split())\n\n# open name file\nnames = load_dictionary.load('supporters.txt')\n\nname_list = []\n\n# start list with null word not used in cipher\nname_list.append(names[0])\n\n# add letter of null cipher to 2nd letter of name, then 3rd, then repeat\ncount = 1\nfor letter in message:\n    for name in names:\n        if len(name) > 2 and name not in name_list:\n            if count % 2 == 0 and name[2].lower() == letter.lower():\n                name_list.append(name)\n                count += 1\n                break\n            elif count % 2 != 0 and name[1].lower() == letter.lower():\n                name_list.append(name)\n                count += 1\n                break\n\n# add two null words early in message to throw off cryptanalysts\nname_list.insert(3, 'Stuart')\nname_list.insert(6, 'Jacob')\n\n# display cover letter and list with null cipher\nprint(\"\"\"\nYour Royal Highness: \\n\nIt is with the greatest pleasure I present the list of noble families who\nhave undertaken to support your cause and petition the usurper for the\nrelease of your Majesty from the current tragical circumstances.\n\"\"\")\n\nprint(*name_list, sep='\\n')\n```", "```py\n\"\"\"Solve a null cipher based on every nth letter in every nth word.\"\"\"\nimport sys\n\ndef load_text(file):\n    \"\"\"Load a text file as a string.\"\"\"\n    with open(file) as f:\n        return f.read().strip()\n\n# load & process message:\nfilename = input(\"\\nEnter full filename for message to translate: \")\ntry:\n    loaded_message = load_text(filename)\nexcept IOError as e:\n    print(\"{}. Terminating program.\".format(e), file=sys.stderr)\n    sys.exit(1)\n\n# check loaded message & # of lines\nprint(\"\\nORIGINAL MESSAGE = {}\\n\".format(loaded_message))\n\n# convert message to list and get length\nmessage = loaded_message.split()\nend = len(message)\n\n# get user input on interval to check\nincrement = int(input(\"Input max word & letter position to \\\n                      check (e.g., every 1 of 1, 2 of 2, etc.): \"))\nprint()\n\n# find letters at designated intervals\nfor i in range(1, increment + 1):\n    print(\"\\nUsing increment letter {} of word {}\".format(i, i))\n    print()\n    count = i - 1\n    location = i - 1\n    for index, word in enumerate(message):\n        if index == count:\n            if location < len(word):\n                print(\"letter = {}\".format(word[location]))\n                count += i\n            else:\n                print(\"Interval doesn't work\", file=sys.stderr)\n```", "```py\n\"\"\"Add code to check blank lines in fake message vs lines in real message.\"\"\"\nimport sys\nimport docx\nfrom docx.shared import RGBColor, Pt\n\n# get text from fake message & make each line a list item\nfake_text = docx.Document('fakeMessage.docx')\nfake_list = []\nfor paragraph in fake_text.paragraphs:\n    fake_list.append(paragraph.text)\n\n# get text from real message & make each line a list item\nreal_text = docx.Document('realMessageChallenge.docx')\nreal_list = []\nfor paragraph in real_text.paragraphs:\n    if len(paragraph.text) != 0:  # remove blank lines\n        real_list.append(paragraph.text)\n\n# define function to check available hiding space:\ndef line_limit(fake, real):\n    \"\"\"Compare number of blank lines in fake vs lines in real and\n    warn user if there are not enough blanks to hold real message.\n\n    NOTE:  need to import 'sys'\n\n    \"\"\"\n    num_blanks = 0\n    num_real = 0\n    for line in fake:\n        if line == '':\n            num_blanks += 1\n    num_real = len(real)\n    diff = num_real - num_blanks\n    print(\"\\nNumber of blank lines in fake message = {}\".format(num_blanks))\n    print(\"Number of lines in real message = {}\\n\".format(num_real))\n    if num_real > num_blanks:\n        print(\"Fake message needs {} more blank lines.\"\n              .format(diff), file=sys.stderr)\n        sys.exit()\n\nline_limit(fake_list, real_list)\n\n# load template that sets style, font, margins, etc.\ndoc = docx.Document('template.docx')\n\n# add letterhead\ndoc.add_heading('Morland Holmes', 0)\nsubtitle = doc.add_heading('Global Consulting & Negotiations', 1)\nsubtitle.alignment = 1\ndoc.add_heading('', 1)\ndoc.add_paragraph('December 17, 2015')\ndoc.add_paragraph('')\n\ndef set_spacing(paragraph):\n    \"\"\"Use docx to set line spacing between paragraphs.\"\"\"\n    paragraph_format = paragraph.paragraph_format\n    paragraph_format.space_before = Pt(0)\n    paragraph_format.space_after = Pt(0)\n\nlength_real = len(real_list)\ncount_real = 0  # index of current line in real (hidden) message\n\n# interleave real and fake message lines\nfor line in fake_list:\n    if count_real < length_real and line == \"\":\n        paragraph = doc.add_paragraph(real_list[count_real])\n        paragraph_index = len(doc.paragraphs) - 1\n\n        # set real message color to white\n        run = doc.paragraphs[paragraph_index].runs[0]\n        font = run.font\n        font.color.rgb = RGBColor(255, 255, 255)  # make it red to test\n        count_real += 1\n\n    else:\n        paragraph = doc.add_paragraph(line)\n\n    set_spacing(paragraph)\n\ndoc.save('ciphertext_message_letterhead.docx')\n\nprint(\"Done\"))\n```", "```py\n\"\"\"Load a dictionary file, pick random words, run syllable-counting module.\"\"\"\nimport sys\nimport random\nfrom count_syllables import count_syllables\n\ndef load(file):\n    \"\"\"Open a text file & return list of lowercase strings.\"\"\"\n    with open(file) as in_file:\n        loaded_txt = in_file.read().strip().split('\\n')\n        loaded_txt = [x.lower() for x in loaded_txt]\n        return loaded_txt\ntry:\n    word_list = load('2of4brif.txt')\nexcept IOError as e:\n    print(\"{}\\nError opening file. Terminating program.\".format(e),\n          file=sys.stderr)\n    sys.exit(1)\n\ntest_data = []\nnum_words = 100\ntest_data.extend(random.sample(word_list, num_words))\n\nfor word in test_data:\n    try:\n        num_syllables = count_syllables(word)\n        print(word, num_syllables, end='\\n')\n    except KeyError:\n        print(word, end='')\n        print(\" not found\", file=sys.stderr)\n```", "```py\n\"\"\"Use spiral formula to build galaxy display.\"\"\"\nimport math\nfrom random import randint\nimport tkinter\n\nroot = tkinter.Tk()\nroot.title(\"Galaxy BR549\")\nc = tkinter.Canvas(root, width=1000, height=800, bg='black')\nc.grid()\nc.configure(scrollregion=(-500, -400, 500, 400))\noval_size = 0\n\n# build spiral arms\nnum_spiral_stars = 500\nangle = 3.5\ncore_diameter = 120\nspiral_stars = []\nfor i in range(num_spiral_stars):\n    theta = i * angle\n    r = math.sqrt(i) / math.sqrt(num_spiral_stars)\n    spiral_stars.append((r * math.cos(theta), r * math.sin(theta)))\nfor x, y in spiral_stars:\n    x = x * 350 + randint(-5, 3)\n    y = y * 350 + randint(-5, 3)\n    oval_size = randint(1, 3)\n    c.create_oval(x-oval_size, y-oval_size, x+oval_size, y+oval_size,\n                  fill='white', outline='')\n\n# build wisps\nwisps = []\nfor i in range(2000):\n    theta = i * angle\n    # divide by num_spiral_stars for better dust lanes\n    r = math.sqrt(i) / math.sqrt(num_spiral_stars)\n    spiral_stars.append((r * math.cos(theta), r * math.sin(theta)))\nfor x, y in spiral_stars:\n    x = x * 330 + randint(-15, 10)\n    y = y * 330 + randint(-15, 10)\n    h = math.sqrt(x**2 + y**2)\n    if h < 350:\n        wisps.append((x, y))\n        c.create_oval(x-1, y-1, x+1, y+1, fill='white', outline='')\n\n# build galactic core\ncore = []\nfor i in range(900):\n    x = randint(-core_diameter, core_diameter)\n    y = randint(-core_diameter, core_diameter)\n    h = math.sqrt(x**2 + y**2)\n    if h < core_diameter - 70:\n        core.append((x, y))\n        oval_size = randint(2, 4)\n        c.create_oval(x-oval_size, y-oval_size, x+oval_size, y+oval_size,\n                      fill='white', outline='')\n    elif h < core_diameter:\n        core.append((x, y))\n        oval_size = randint(0, 2)\n        c.create_oval(x-oval_size, y-oval_size, x+oval_size, y+oval_size,\n                      fill='white', outline='')\n\nroot.mainloop()\n```", "```py\n\"\"\"Build 2-D model of galaxy, post expansion rings for galactic empire.\"\"\"\nimport tkinter as tk\nimport time\nfrom random import randint, uniform, random\nimport math\n\n#=============================================================================\n# MAIN INPUT\n\n# location of galactic empire homeworld on map:\nHOMEWORLD_LOC = (0, 0)\n\n# maximum number of years to simulate:\nMAX_YEARS = 10000000\n\n# average expansion velocity as fraction of speed of light:\nSPEED = 0.005\n\n# scale units\nUNIT = 200\n\n#======================================================================\n\n# set up display canvas\nroot = tk.Tk()\nroot.title(\"Milky Way galaxy\")\nc = tk.Canvas(root, width=1000, height=800, bg='black')\nc.grid()\nc.configure(scrollregion=(-500, -400, 500, 400))\n\n# actual Milky Way dimensions (light-years)\nDISC_RADIUS = 50000\n\ndisc_radius_scaled = round(DISC_RADIUS/UNIT)\n\ndef polar_coordinates():\n    \"\"\"Generate uniform random x,y point within a disc for 2-D display.\"\"\"\n    r = random()\n    theta = uniform(0, 2 * math.pi)\n    x = round(math.sqrt(r) * math.cos(theta) * disc_radius_scaled)\n    y = round(math.sqrt(r) * math.sin(theta) * disc_radius_scaled)\n    return x, y\n\ndef spirals(b, r, rot_fac, fuz_fac, arm):\n    \"\"\"Build spiral arms for tkinter display using Logarithmic spiral formula.\n\n    b = arbitrary constant in logarithmic spiral equation\n    r = scaled galactic disc radius\n    rot_fac = rotation factor\n    fuz_fac = random shift in star position in arm, applied to 'fuzz' variable\n    arm = spiral arm (0 = main arm, 1 = trailing stars)\n    \"\"\"\n    spiral_stars = []\n    fuzz = int(0.030 * abs(r))  # randomly shift star locations\n    theta_max_degrees = 520\n    for i in range(theta_max_degrees):  # range(0, 700, 2) for no black hole\n        theta = math.radians(i)\n        x = r * math.exp(b*theta) * math.cos(theta + math.pi * rot_fac)\\\n            + randint(-fuzz, fuzz) * fuz_fac\n        y = r * math.exp(b*theta) * math.sin(theta + math.pi * rot_fac)\\\n            + randint(-fuzz, fuzz) * fuz_fac\n        spiral_stars.append((x, y))\n    for x, y in spiral_stars:\n        if arm == 0 and int(x % 2) == 0:\n            c.create_oval(x-2, y-2, x+2, y+2, fill='white', outline='')\n        elif arm == 0 and int(x % 2) != 0:\n            c.create_oval(x-1, y-1, x+1, y+1, fill='white', outline='')\n        elif arm == 1:\n            c.create_oval(x, y, x, y, fill='white', outline='')\n\ndef star_haze(scalar):\n    \"\"\"Randomly distribute faint tkinter stars in galactic disc.\n    disc_radius_scaled = galactic disc radius scaled to radio bubble diameter\n    scalar = multiplier to vary number of stars posted\n    \"\"\"\n    for i in range(0, disc_radius_scaled * scalar):\n        x, y = polar_coordinates()\n        c.create_text(x, y, fill='white', font=('Helvetica', '7'), text='.')\n\ndef model_expansion():\n    \"\"\"Model empire expansion from homeworld with concentric rings.\"\"\"\n    r = 0 # radius from homeworld\n    text_y_loc = -290\n    x, y = HOMEWORLD_LOC\n    c.create_oval(x-5, y-5, x+5, y+5, fill='red')\n    increment = round(MAX_YEARS / 10)# year interval to post circles\n    c.create_text(-475, -350, anchor='w', fill='red', text='Increment = {:,}'\n                  .format(increment))\n    c.create_text(-475, -325, anchor='w', fill='red',\n                  text='Velocity as fraction of Light = {:,}'.format(SPEED))\n\n    for years in range(increment, MAX_YEARS + 1, increment):\n        time.sleep(0.5) # delay before posting new expansion circle\n        traveled = SPEED * increment / UNIT\n        r = r + traveled\n        c.create_oval(x-r, y-r, x+r, y+r, fill='', outline='red', width='2')\n        c.create_text(-475, text_y_loc, anchor='w', fill='red',\n                      text='Years = {:,}'.format(years))\n        text_y_loc += 20\n        # update canvas for new circle; no longer need mainloop()\n        c.update_idletasks()\n        c.update()\n\ndef main():\n    \"\"\"Generate galaxy display, model empire expansion, run mainloop.\"\"\"\n    spirals(b=-0.3, r=disc_radius_scaled, rot_fac=2, fuz_fac=1.5, arm=0)\n    spirals(b=-0.3, r=disc_radius_scaled, rot_fac=1.91, fuz_fac=1.5, arm=1)\n    spirals(b=-0.3, r=-disc_radius_scaled, rot_fac=2, fuz_fac=1.5, arm=0)\n    spirals(b=-0.3, r=-disc_radius_scaled, rot_fac=-2.09, fuz_fac=1.5, arm=1)\n    spirals(b=-0.3, r=-disc_radius_scaled, rot_fac=0.5, fuz_fac=1.5, arm=0)\n    spirals(b=-0.3, r=-disc_radius_scaled, rot_fac=0.4, fuz_fac=1.5, arm=1)\n    spirals(b=-0.3, r=-disc_radius_scaled, rot_fac=-0.5, fuz_fac=1.5, arm=0)\n    spirals(b=-0.3, r=-disc_radius_scaled, rot_fac=-0.6, fuz_fac=1.5, arm=1)\n    star_haze(scalar=9)\n\n    model_expansion()\n\n    # run tkinter loop\n    root.mainloop()\n\nif __name__ == '__main__':\n    main()\n```", "```py\n\"\"\"Calculate probability of detecting 32 LY-diameter radio bubble given 15.6 M\nrandomly distributed civilizations in the galaxy.\"\"\"\nimport math\nfrom random import uniform, random\nfrom collections import Counter\n\n# length units in light-years\nDISC_RADIUS = 50000\nDISC_HEIGHT = 1000\nNUM_CIVS = 15600000\nDETECTION_RADIUS = 16\n\ndef random_polar_coordinates_xyz():\n    \"\"\"Generate uniform random xyz point within a 3D disc.\"\"\"\n    r = random()\n    theta = uniform(0, 2 * math.pi)\n    x = round(math.sqrt(r) * math.cos(theta) * DISC_RADIUS, 3)\n    y = round(math.sqrt(r) * math.sin(theta) * DISC_RADIUS, 3)\n    z = round(uniform(0, DISC_HEIGHT), 3)\n    return x, y, z\n\ndef rounded(n, base):\n    \"\"\"Round a number to the nearest number designated by base parameter.\"\"\"\n    return int(round(n/base) * base)\n\ndef distribute_civs():\n    \"\"\"Distribute xyz locations in galactic disc model and return list.\"\"\"\n    civ_locs = []\n    while len(civ_locs) < NUM_CIVS:\n        loc = random_polar_coordinates_xyz()\n        civ_locs.append(loc)\n    return civ_locs\n\ndef round_civ_locs(civ_locs):\n    \"\"\"Round xyz locations and return list of rounded locations.\"\"\"\n    # convert radius to cubic dimensions:\n    detect_distance = round((4 / 3 * math.pi * DETECTION_RADIUS**3)**(1/3))\n    print(\"\\ndetection radius = {} LY\".format(DETECTION_RADIUS))\n    print(\"cubic detection distance = {} LY\".format(detect_distance))\n\n    # round civilization xyz to detection distance\n    civ_locs_rounded = []\n\n    for x, y, z in civ_locs:\n        i = rounded(x, detect_distance)\n        j = rounded(y, detect_distance)\n        k = rounded(z, detect_distance)\n        civ_locs_rounded.append((i, j, k))\n\n    return civ_locs_rounded\n\ndef calc_prob_of_detection(civ_locs_rounded):\n    \"\"\"Count locations and calculate probability of duplicate values.\"\"\"\n    overlap_count = Counter(civ_locs_rounded)\n    overlap_rollup = Counter(overlap_count.values())\n    num_single_civs = overlap_rollup[1]\n    prob = 1 - (num_single_civs / NUM_CIVS)\n\n    return overlap_rollup, prob\n\ndef main():\n    \"\"\"Call functions and print results.\"\"\"\n    civ_locs = distribute_civs()\n    civ_locs_rounded = round_civ_locs(civ_locs)\n    overlap_rollup, detection_prob = calc_prob_of_detection(civ_locs_rounded)\n    print(\"length pre-rounded civ_locs = {}\".format(len(civ_locs)))\n    print(\"length of rounded civ_locs_rounded = {}\".format(len(civ_locs_rounded)))\n    print(\"overlap_rollup = {}\\n\".format(overlap_rollup))\n    print(\"probability of detection = {0:.3f}\".format(detection_prob))\n\n    # QC step to check rounding\n    print(\"\\nFirst 3 locations pre- and post-rounding:\\n\")\n    for i in range(3):\n        print(\"pre-round: {}\".format(civ_locs[i]))\n        print(\"post-round: {} \\n\".format(civ_locs_rounded[i]))\n\nif __name__ == '__main__':\n    main()\n```", "```py\n\"\"\"Calculate probability of a shared birthday per x number of people.\"\"\"\nimport random\n\nmax_people = 50\nnum_runs = 2000\n\nprint(\"\\nProbability of at least 2 people having the same birthday:\\n\")\n\nfor people in range(2, max_people + 1):\n    found_shared = 0\n    for run in range(num_runs):\n        bdays = []\n        for i in range(0, people):\n            bday = random.randrange(0, 365)  # ignore leap years\n            bdays.append(bday)\n        set_of_bdays = set(bdays)\n        if len(set_of_bdays) < len(bdays):\n            found_shared += 1\n    prob = found_shared/num_runs\n    print(\"Number people = {} Prob = {:.4f}\".format(people, prob))\n\nprint(\"\"\"\nAccording to the Birthday Paradox, if there are 23 people in a room,\nthere's a 50% chance that 2 of them will share the same birthday.\n\"\"\")\n```", "```py\nimport sys\nimport math\nimport random\nimport pygame as pg\n\npg.init()  # initialize pygame\n\n# define color table\nBLACK = (0, 0, 0)\nWHITE = (255, 255, 255)\nLT_GRAY = (180, 180, 180)\nGRAY = (120, 120, 120)\nDK_GRAY = (80, 80, 80)\n\nclass Particle(pg.sprite.Sprite):\n    \"\"\"Builds ejecta particles for volcano simulation.\"\"\"\n\n    gases_colors = {'SO2': LT_GRAY, 'CO2': GRAY, 'H2S': DK_GRAY, 'H2O': WHITE}\n\n    VENT_LOCATION_XY = (320, 300)\n    IO_SURFACE_Y = 308\n    GRAVITY = 0.5  # pixels-per-frame\n    VELOCITY_SO2 = 8  # pixels-per-frame\n\n    # scalars (SO2 atomic weight/particle atomic weight) used for velocity\n    vel_scalar = {'SO2': 1, 'CO2': 1.45, 'H2S': 1.9, 'H2O': 3.6}\n\n    def __init__(self, screen, background):\n        super().__init__()\n        self.screen = screen\n        self.background = background\n        self.image = pg.Surface((4, 4))\n        self.rect = self.image.get_rect()\n        self.gas = 'SO2'\n        self.color = ''\n        self.vel = Particle.VELOCITY_SO2 * Particle.vel_scalar[self.gas]\n        self.x, self.y = Particle.VENT_LOCATION_XY\n        self.vector()\n\n    def vector(self):\n        \"\"\"Calculate particle vector at launch.\"\"\"\n        angles = [65, 55, 45, 35, 25]  # 90 is vertical\n        orient = random.choice(angles)\n        if orient == 45:\n            self.color = WHITE\n        else:\n            self.color = GRAY\n        radians = math.radians(orient)\n        self.dx = self.vel * math.cos(radians)\n        self.dy = -self.vel * math.sin(radians)  # negative as y increases down\n\n    def update(self):\n        \"\"\"Apply gravity, draw path, and handle boundary conditions.\"\"\"\n        self.dy += Particle.GRAVITY\n        pg.draw.line(self.background, self.color, (self.x, self.y),\n                     (self.x + self.dx, self.y + self.dy))\n        self.x += self.dx\n        self.y += self.dy\n        if self.x < 0 or self.x > self.screen.get_width():\n            self.kill()\n        if self.y < 0 or self.y > Particle.IO_SURFACE_Y:\n            self.kill()\n\ndef main():\n    \"\"\"Set up and run game screen and loop.\"\"\"\n    screen = pg.display.set_mode((639, 360))\n    pg.display.set_caption(\"Io Volcano Simulator\")\n    background = pg.image.load(\"tvashtar_plume.gif\")\n\n    # Set up color-coded legend\n    legend_font = pg.font.SysFont('None', 26)\n    text = legend_font.render('White = 45 degrees', True, WHITE, BLACK)\n\n    particles = pg.sprite.Group()\n\n    clock = pg.time.Clock()\n\n    while True:\n        clock.tick(25)\n        particles.add(Particle(screen, background))\n        for event in pg.event.get():\n            if event.type == pg.QUIT:\n                pg.quit()\n                sys.exit()\n\n        screen.blit(background, (0, 0))\n        screen.blit(text, (320, 170))\n\n        particles.update()\n        particles.draw(screen)\n\n        pg.display.flip()\n\nif __name__ == \"__main__\":\n    main()\n```", "```py\n\"\"\"Manipulate vote counts so that final results conform to Benford's law.\"\"\"\n\n# example below is for Trump vs. Clinton, Illinois, 2016 Presidental Election\n\ndef load_data(filename):\n    \"\"\"Open a text file of numbers & turn contents into a list of integers.\"\"\"\n    with open(filename) as f:\n        lines = f.read().strip().split('\\n')\n        return [int(i) for i in lines]  # turn strings to integers\n\ndef steal_votes(opponent_votes, candidate_votes, scalar):\n    \"\"\"Use scalar to reduce one vote count & increase another, return as lists.\n\n    Arguments:\n    opponent_votes – votes to steal from\n    candidate_votes - votes to increase by stolen amount\n    scalar - fractional percentage, < 1, used to reduce votes\n\n    Returns:\n    list of changed opponent votes\n    list of changed candidate votes\n\n    \"\"\"\n    new_opponent_votes = []\n    new_candidate_votes = []\n    for opp_vote, can_vote in zip(opponent_votes, candidate_votes):\n        new_opp_vote = round(opp_vote * scalar)\n        new_opponent_votes.append(new_opp_vote)\n        stolen_votes = opp_vote - new_opp_vote\n        new_can_vote = can_vote + stolen_votes\n        new_candidate_votes.append(new_can_vote)\n    return new_opponent_votes, new_candidate_votes\n\ndef main():\n    \"\"\"Run the program.\n\n    Load data, set target winning vote count, call functions, display\n    results as table, write new combined vote total as text file to\n    use as input for Benford's law analysis.\n\n    \"\"\"\n    # load vote data\n    c_votes = load_data('Clinton_votes_Illinois.txt')\n    j_votes = load_data('Johnson_votes_Illinois.txt')\n    s_votes = load_data('Stein_votes_Illinois.txt')\n    t_votes = load_data('Trump_votes_Illinois.txt')\n\n    total_votes = sum(c_votes + j_votes + s_votes + t_votes)\n\n    # assume Trump amasses a plurality of the vote with 49%\n    t_target = round(total_votes * 0.49)\n    print(\"\\nTrump winning target = {:,} votes\".format(t_target))\n\n    # calculate extra votes needed for Trump victory\n    extra_votes_needed = abs(t_target - sum(t_votes))\n    print(\"extra votes needed = {:,}\".format(extra_votes_needed))\n\n    # calculate scalar needed to generate extra votes\n    scalar = 1 - (extra_votes_needed / sum(c_votes + j_votes + s_votes))\n    print(\"scalar = {:.3}\".format(scalar))\n    print()\n\n    # flip vote counts based on scalar & build new combined list of votes\n    fake_counts = []\n    new_c_votes, new_t_votes = steal_votes(c_votes, t_votes, scalar)\n    fake_counts.extend(new_c_votes)\n    new_j_votes, new_t_votes = steal_votes(j_votes, new_t_votes, scalar)\n    fake_counts.extend(new_j_votes)\n    new_s_votes, new_t_votes = steal_votes(s_votes, new_t_votes, scalar)\n    fake_counts.extend(new_s_votes)\n    fake_counts.extend(new_t_votes)  # add last as has been changing up til now\n\n    # compare old and new vote counts & totals in tabular form\n    # switch-out \"Trump\" and \"Clinton\" as necessary\n    for i in range(0, len(t_votes)):\n        print(\"old Trump: {} \\t new Trump: {} \\t old Clinton: {} \\t \" \\\n              \"new Clinton: {}\".\n              format(t_votes[i], new_t_votes[i], c_votes[i], new_c_votes[i]))\n        print(\"-\" * 95)\n    print(\"TOTALS:\")\n    print(\"old Trump: {:,} \\t new Trump: {:,} \\t old Clinton: {:,}  \" \\\n          \"new Clinton: {:,}\".format(sum(t_votes), sum(new_t_votes),\n                                     sum(c_votes), sum(new_c_votes)))\n\n    # write out a text file to use as input to benford.py program\n    # this program will check conformance of faked votes to Benford's law\n    with open('fake_Illinois_counts.txt', 'w') as f:\n        for count in fake_counts:\n            f.write(\"{}\\n\".format(count))\n\nif __name__ == '__main__':\n    main()\n```"]