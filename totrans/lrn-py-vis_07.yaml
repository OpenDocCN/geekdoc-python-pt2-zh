- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Working with Lists and Reading Data
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 操作列表和读取数据
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: When you need to work with multiple values, you can group them into a single
    variable by using a Python list. The *list* data type stores any number of items
    in collections you can manage and manipulate dynamically and efficiently. For
    example, you could create a list to store the titles of your favorite movies and
    use built-in methods to insert new favorites, reorder the rankings, or display
    only titles ranked between 30 and 40.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要处理多个值时，可以通过使用 Python 列表将它们分组到一个变量中。*列表*数据类型可以存储任意数量的项，并能高效、动态地管理和操作这些项。例如，你可以创建一个列表来存储你最喜欢的电影标题，并使用内建的方法插入新电影、重新排序排名或仅显示排名在
    30 到 40 之间的标题。
- en: In this chapter, you’ll learn to create and manipulate lists, and then you’ll
    combine them with loops to access and perform actions with each item. In keeping
    with this book’s visual theme, you’ll generate graphical representations of list
    data, including a chart that displays brightness and RGB mixtures for a list of
    colors and another that plots the bestselling video games of all time. You’ll
    see how to adjust list values to affect visual output, observing how the charts
    adapt to changing data.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何创建和操作列表，然后将其与循环结合，访问并对每个项执行操作。为了配合本书的视觉主题，你将生成列表数据的图形表示，包括显示亮度和 RGB
    混合的颜色列表图表，以及展示史上畅销视频游戏的图表。你将看到如何调整列表值以影响视觉输出，并观察图表如何根据数据变化进行调整。
- en: You’ll also learn how to read in data from text files and how text-based formats
    differ from other file formats. You’ll move your Python list data into CSV-formatted
    text files and load it in when your sketch runs, allowing you to prepare data
    with other tools, such as spreadsheets.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你还将学习如何从文本文件中读取数据，以及文本格式与其他文件格式的区别。你将把 Python 列表数据转储到 CSV 格式的文本文件中，并在草图运行时加载它，这样你就可以使用其他工具（如电子表格）准备数据。
- en: Introducing Lists
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引入列表
- en: Lists hold multiple values that are related or belong together. For example,
    consider programming a video game in which players wander about collecting various
    objects—keys, weapons, armor upgrades, and so forth—to advance to a new level.
    Your game needs to track those items, which you can store in an inventory list.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 列表包含多个相关或属于同一组的值。例如，考虑编写一个视频游戏，在游戏中玩家四处游走，收集各种物品——钥匙、武器、盔甲升级等等——以便晋级到新的一关。你的游戏需要跟踪这些物品，这些物品可以存储在一个库存列表中。
- en: 'To denote a list, use square brackets and separate each element with a comma.
    As an example, here’s a simple list for some game items:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要表示一个列表，可以使用方括号并用逗号分隔每个元素。例如，以下是一些游戏物品的简单列表：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This list contains five strings and is assigned to a variable named `inventory`.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表包含五个字符串，并被分配给一个名为`inventory`的变量。
- en: Performing repetitive operations on collections of items is a common programming
    challenge. Suppose you want to display a grid with all the objects a player has
    collected ([Figure 7-1](#figure7-1)). You can write a `loop` statement to access
    each item in the inventory and draw it in a cell. If the size of the list changes—because
    the player has added or dropped items—the loop will adapt, so you can write the
    code once and then have the program fill the appropriate number of cells to depict
    the inventory items.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对物品集合执行重复操作是常见的编程挑战。假设你想显示一个包含玩家已收集物品的网格（[图 7-1](#figure7-1)）。你可以编写一个`loop`语句来访问库存中的每个物品，并将其绘制在一个单元格中。如果列表的大小发生变化——因为玩家添加或丢弃了物品——循环会自动适应，因此你只需编写一次代码，程序就会填充适当数量的单元格来表示库存物品。
- en: '![f07001](image_fi/500969c07/f07001.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![f07001](image_fi/500969c07/f07001.png)'
- en: 'Figure 7-1: A player inventory from the game *Minetest*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-1：来自游戏*Minetest*的玩家库存
- en: 'In Python, a single list can contain any mix of data types and duplicate values.
    For example, this top-score entry stores multiple types of data:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，单个列表可以包含任何混合的数据类型和重复值。例如，这个最高分条目存储了多种数据类型：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The player name `LEO` is a string, and the high score is an integer.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家名称`LEO`是一个字符串，而高分是一个整数。
- en: Lists can include as many elements as you want, and you can even define an empty
    list by using just a pair of square brackets with nothing within them, which is
    useful if you intend to add items while your program is running.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 列表可以包含任意数量的元素，甚至可以通过使用一对空方括号（中间没有任何内容）来定义一个空列表，这在你打算在程序运行时添加物品时非常有用。
- en: 'Lists are ordered, and ordering is significant in many situations—for example,
    in this sequence of rainbow colors:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 列表是有序的，在许多情况下，顺序很重要——例如，在这个彩虹颜色的顺序中：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When defining a list, you can write it across multiple lines, as shown here,
    to make your code easier to read and edit. Python also permits an optional trailing
    comma after the last element. Having this extra comma can help when you want to
    add or shuffle list values; just be careful not to forget a comma where necessary.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义列表时，你可以将它跨越多行书写，如下所示，这样可以让代码更容易阅读和编辑。Python 还允许在最后一个元素后添加一个可选的尾随逗号。这个额外的逗号有助于你在需要添加或调整列表值时，不小心忘记加逗号的情况。
- en: Creating and Accessing Lists
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建和访问列表
- en: 'To familiarize yourself with defining, accessing, and modifying lists, create
    a new sketch. Save it as *rainbow_list* and add the following code:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了熟悉如何定义、访问和修改列表，创建一个新的草图。将其保存为 *rainbow_list* 并添加以下代码：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'For now, this rainbow is missing a few colors, and the sequence is incorrect,
    so you’ll use various list operations to add and shuffle colors as you progress
    through this section. First, run the code to verify the following console output:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个彩虹缺少了一些颜色，且顺序不正确，因此在你继续进行本节时，将使用各种列表操作来添加和调整颜色。首先，运行代码以验证以下控制台输出：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Printing the `rainbow` variable displays all three values, complete with square
    brackets and commas.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 打印 `rainbow` 变量会显示所有三个值，并且带有方括号和逗号。
- en: 'In many instances, you’ll want to retrieve an individual element instead of
    a whole list. To display a given color, specify its position, or *index*, in square
    brackets. Note that Python list indices start at 0, so to print the first element,
    enter the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，你可能希望检索单个元素，而不是整个列表。要显示指定颜色，请在方括号中指定它的位置或 *索引*。请注意，Python 列表的索引从 0 开始，因此要打印第一个元素，输入以下内容：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Run the sketch to confirm that the console displays `blue`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 运行草图以确认控制台显示 `blue`。
- en: 'The second element, `orange`, has an index of `1`, and the last element in
    this list, `yellow`, has an index of `2`. To print items 1 and 2, enter the following
    (note that throughout this chapter, the comments alongside the `print` lines indicate
    what should appear in your console):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个元素 `orange` 的索引是 `1`，这个列表中的最后一个元素 `yellow` 的索引是 `2`。要打印项目 1 和 2，请输入以下内容（请注意，在本章中，`print`
    语句旁边的注释会指出在控制台中应该出现的内容）：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This syntax may remind you of slice notation from working with strings in Chapter
    3, and it should, because it works the same way. Just as with slice notation,
    use `-1` to access the last element of the list, and extract a subset of elements
    by using a range defined with a colon. Try the following code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法可能让你想起第3章处理字符串时使用的切片符号，应该会因为它的工作方式相同而产生这种联想。就像使用切片符号一样，使用`-1`可以访问列表的最后一个元素，并通过使用冒号定义的范围来提取子集元素。试试以下代码：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If you specify any index beyond the bounds of the list, such as `rainbow[3]`
    or higher, Processing will display an `IndexError` message.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你指定了超出列表范围的任何索引，比如 `rainbow[3]` 或更高，Processing 会显示 `IndexError` 错误信息。
- en: Modifying Lists
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改列表
- en: Lists can be dynamic in behavior, changing while your program runs. You can
    overwrite any element with a new value and use different list methods to insert
    new elements or remove existing ones. For a game inventory, you might replace
    a weapon if a player finds a more powerful one, and add or remove elements as
    the player trades items.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 列表在行为上是动态的，可以在程序运行时发生变化。你可以用新值覆盖任何元素，并使用不同的列表方法插入新元素或删除现有元素。例如，在游戏物品栏中，如果玩家找到了更强大的武器，可以替换掉原有的武器，并随着玩家交易物品来添加或移除元素。
- en: 'Returning to the rainbow example, you need to replace blue with red as the
    first color in the `rainbow` list. To modify an existing list element, reassign
    it a new value as you would any other variable, but with lists, you need to specify
    the element index in square brackets. Add the following line to the end of your
    *rainbow_list* sketch:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 回到彩虹示例，你需要将蓝色替换为红色，使其成为 `rainbow` 列表中的第一个颜色。要修改现有的列表元素，可以像操作其他变量一样重新赋值，但在列表中，你需要使用方括号指定元素的索引。将以下行添加到
    *rainbow_list* 草图的末尾：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `red` string now replaces `blue`, overwriting it as the first item in the
    list. Printing the `rainbow` list should confirm this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`red` 字符串现在替换了 `blue`，覆盖了它，成为列表中的第一个项目。打印 `rainbow` 列表应确认这一点：'
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Blue is no longer in the `rainbow` list.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝色不再出现在 `rainbow` 列表中。
- en: Let’s look at several of the most useful list methods, along with code to add
    to your working sketch. Each example builds on the code before it, so work through
    all of them sequentially, entering the lines as you progress.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下几个最有用的列表方法，并附上可以添加到工作草图中的代码。每个示例都建立在之前的代码之上，因此按顺序逐一完成它们，在前进的过程中输入这些行。
- en: The append() Method
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`append()`方法'
- en: 'The `append()` method adds an element to the very end of a list, whatever its
    length. Add blue to the end of the `rainbow` list:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`append()`方法将一个元素添加到列表的末尾，无论列表的长度是多少。将蓝色添加到`rainbow`列表的末尾：'
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that the comments after the `print()` function in these examples contain
    only the sequence of colors; when you actually print the list, the console will
    display `['red', ...,'blue']` with all of the brackets and quotation marks.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这些示例中，`print()`函数后的注释仅包含颜色的顺序；当你实际打印列表时，控制台将显示`['red', ...,'blue']`，包括所有的方括号和引号。
- en: The extend() Method
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`extend()`方法'
- en: 'To add all the elements in one list to the end of another, use the `extend()`
    method:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要将一个列表中的所有元素添加到另一个列表的末尾，可以使用`extend()`方法：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `colors` list, which contains indigo and violet, is now added to the original
    `rainbow` list.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 包含靛蓝和紫罗兰色的`colors`列表现在被添加到原始的`rainbow`列表中。
- en: The index() Method
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`index()`方法'
- en: 'The `index()` method returns the index (the position in the list as an integer)
    for any element that matches the argument provided. If there are multiple matches,
    this method detects the first instance. Use an argument of `''yellow''` to test
    this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`index()`方法返回与提供的参数匹配的元素的索引（该元素在列表中的位置，作为整数）。如果有多个匹配项，该方法会返回第一个实例。使用`''yellow''`作为参数来测试这一点：'
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Try different color arguments. If no matching value exists, Processing displays
    a `ValueError` message.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试不同的颜色参数。如果没有匹配的值，Processing会显示一个`ValueError`错误消息。
- en: The insert() Method
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`insert()`方法'
- en: 'The `insert()` method accepts two arguments: the first is the index at which
    to insert the element; the second is the value. Insert `green` into the middle
    of the list with an index argument of `3`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`insert()`方法接受两个参数：第一个是插入元素的索引；第二个是要插入的值。将`green`插入到列表的中间，索引参数为`3`：'
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Green is now in the position that blue used to occupy, shifting blue one index
    higher along with every color to the right of it.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在绿色位于原本蓝色的位置，将蓝色和它右边的所有颜色都向后移动了一个索引。
- en: The pop() Method
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`pop()`方法'
- en: 'The `pop()` method accepts a single argument: the index of an element to remove.
    The “popped” value is returned should you need to use it for another operation.
    Pop indigo from the list and assign it to a variable named `i`; then print `i`
    and `rainbow` to confirm that your console output matches the comments shown here:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`pop()`方法接受一个参数：要移除的元素的索引。如果需要，可以使用被“弹出”的值进行其他操作。将靛蓝从列表中弹出并赋值给名为`i`的变量；然后打印`i`和`rainbow`，以确认控制台输出与这里的注释一致：'
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If you aren’t concerned with using the popped value, remove the `i =` part.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不关心使用被弹出的值，可以去掉`i =`部分。
- en: 'Now, use `pop()` with no argument to remove the last item in the list:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用没有参数的`pop()`方法移除列表中的最后一个元素：
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The console output should confirm that violet is removed from the list.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台输出应该确认紫罗兰色已从列表中移除。
- en: The remove() Method
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`remove()`方法'
- en: 'The `remove()` method removes the first element with a value that matches the
    argument provided. Re-add indigo and violet by using the `extend()` method, and
    then remove indigo with the `remove()` method:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`remove()`方法移除第一个值与提供的参数匹配的元素。通过使用`extend()`方法重新添加靛蓝和紫罗兰色，然后使用`remove()`方法移除靛蓝：'
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: After extending the list, `rainbow` is back to a seven-color list. After the
    `remove` line, the list is down to six colors again, with no indigo.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在扩展列表后，`rainbow`恢复为七色列表。在执行`remove`行后，列表又变成了六个颜色，没有靛蓝色。
- en: Python provides other list methods, but these should suffice for you to start
    manipulating lists. Any decent Python reference or internet search should cover
    the rest. For example, if you want to reorder list elements, look up the `reverse()`
    and alphanumerical `sort()` methods. The Processing reference also includes several
    list methods, which are standard Python (as opposed to Processing) features, and
    they are functional in any Python environment.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了其他列表方法，但这些方法足够让你开始操作列表。任何合适的Python参考资料或网络搜索应该能覆盖其余的内容。例如，如果你想重新排序列表元素，可以查找`reverse()`和按字母数字顺序的`sort()`方法。Processing参考资料还包括几个列表方法，它们是标准的Python（而非Processing）特性，并且在任何Python环境中都可以使用。
- en: Combining Loops and Lists
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结合循环和列表
- en: You can program loops to work on lists, potentially saving countless lines of
    manual instruction. As an example, say you want to create a *Breakout*-style game
    ([Figure 7-2](#figure7-2)). In this type of game, the player controls the paddle
    at the bottom of the screen with the goal of bouncing the ball upward to destroy
    all the bricks. You could create a list to store the bricks so that when the player
    hits a brick with the ball, that brick would be removed from the list. In some
    levels, you could have additional bricks appear during play, which would mean
    you’d need to insert new list elements.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以编程使用循环处理列表，这样可以节省无数的手动指令行。例如，假设你想创建一个*Breakout*风格的游戏（[图7-2](#figure7-2)）。在这种类型的游戏中，玩家控制屏幕底部的挡板，目标是将球弹向上方摧毁所有砖块。你可以创建一个列表来存储砖块，当玩家用球击中砖块时，该砖块将从列表中移除。在某些关卡中，你可能希望在游戏过程中出现额外的砖块，这意味着你需要插入新的列表元素。
- en: '![f07002](image_fi/500969c07/f07002.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![f07002](image_fi/500969c07/f07002.png)'
- en: 'Figure 7-2: *LBreakout2*, an open source *Breakout* clone'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图7-2：*LBreakout2*，一个开源的*Breakout*克隆游戏
- en: You’ve likely played a variant of this game and are probably aware that, upon
    destruction, certain bricks drop power-ups. You also know that the bricks come
    in different colors, and that some may be invisible but solid, while others may
    take multiple hits to destroy. You can program all of those additional properties
    by using lists of lists. Lists can contain other lists, which, in turn, can contain
    further nested lists (see “Creating Lists of Lists” on page 144).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经玩过这种游戏的变种，并且可能知道，在砖块被摧毁时，某些砖块会掉落能量道具。你还知道砖块有不同的颜色，有些可能是不可见但坚固的，而有些可能需要多次击打才能摧毁。你可以通过使用列表的列表来编程这些附加属性。列表可以包含其他列表，而这些列表又可以包含进一步嵌套的列表（请参见第144页的“创建列表的列表”）。
- en: 'If your list is named `bricks` and contains the fills for 60 bricks, rendering
    each brick would require at least as many lines of code as you have elements.
    For instance, you might use the following code to draw each brick with a `rect()`
    function:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的列表名为`bricks`，并包含60个砖块的填充色，那么渲染每个砖块至少需要和元素个数一样多的代码行。例如，你可以使用以下代码使用`rect()`函数绘制每个砖块：
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Notice that every brick rendered requires a `fill()` and `rect()` function.
    Even if you remove the comments, that’s 120 lines (60 × 2) of code to draw the
    complete list. This is hardly efficient, nor can the code handle a list that might
    fluctuate in length.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，每个渲染的砖块都需要`fill()`和`rect()`函数。即使你删除了注释，这也意味着要绘制完整的列表，你需要120行（60 × 2）的代码。这并不高效，也无法处理可能长度变化的列表。
- en: Drawing Shapes by Using a List of Color Values
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用颜色值列表绘制图形
- en: 'For this exercise, you’ll draw a rainbow-colored sequence of bands from a list
    of hexadecimal values, beginning with a single band using a `fill()` and `rect()`
    function. You’ll then adapt the code to use a loop that draws the entire list.
    To begin, add the following code to your *rainbow_list* sketch:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个练习，你将从一个十六进制值的列表中绘制一条彩虹色带，首先使用`fill()`和`rect()`函数绘制一条单一的色带。然后，你将调整代码，使用循环绘制整个列表。首先，将以下代码添加到你的*rainbow_list*草图中：
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Up until this point, the sketch has relied exclusively on the console for output.
    This code begins by defining a display window size, no stroke, and a background
    color. The `bands` list holds hexadecimal values for a six-color rainbow with
    comments to identify each color value. The first (red) band is drawn using `translate()`,
    `fill()`, and `rect()` functions. Run the sketch. The result should be a single,
    horizontal red band on a blue background ([Figure 7-3](#figure7-3)).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，草图完全依赖于控制台输出。此代码首先定义了显示窗口的大小，关闭了描边，并设置了背景颜色。`bands`列表包含六种颜色的十六进制值，并附有注释以标识每种颜色值。第一条（红色）色带使用`translate()`、`fill()`和`rect()`函数绘制。运行草图，结果应该是在蓝色背景上绘制一条单一的横向红色色带（[图7-3](#figure7-3)）。
- en: '![f07003](image_fi/500969c07/f07003.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![f07003](image_fi/500969c07/f07003.png)'
- en: 'Figure 7-3: The result of running the sketch is a single red band.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图7-3：运行草图的结果是一条单一的红色色带。
- en: You’ve drawn the first band in the list, and the next step is to adapt the code
    to use a `for` loop that draws all six bands.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经绘制了列表中的第一条色带，下一步是调整代码，使用`for`循环来绘制所有六条色带。
- en: 'When you combine a `for` loop with a list, Python assigns each successive list
    value to the loop variable, using the length of the list to determine the number
    of iterations required. To make your program draw every band in the `bands` list,
    comment out the existing `fill()` and `rect()` functions, and then add a loop
    that draws the complete rainbow for you:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将 `for` 循环与列表结合时，Python 会将每个连续的列表值赋给循环变量，并使用列表的长度来决定所需的迭代次数。为了让你的程序绘制 `bands`
    列表中的每个彩带，注释掉现有的 `fill()` 和 `rect()` 函数，然后添加一个循环来为你绘制完整的彩虹：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this instance, the code is easier to understand if you name the loop variable
    `band` 1 instead of something like `i`. The `band` variable is equal to `'#FF0000'`
    on the first iteration, `'#FF9900'` on the second, and so forth. A `translate()`
    function moves the coordinate system down the height of a band 2. With each iteration,
    Processing applies the next fill in the list and draws a new rectangle below the
    last one. The result is a stack of six rainbow-colored bands that span the width
    of the display window ([Figure 7-4](#figure7-4)). Note that the green band will
    be brighter on a computer screen than it is in a printed book. Standard printing
    inks (cyan, magenta, yellow, and key/black—CMYK) cannot replicate the intensity
    of the shades of green on a digital display.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果你将循环变量命名为 `band` 而不是像 `i` 这样的名称，代码会更易于理解。第一次迭代时，`band` 变量等于 `'#FF0000'`，第二次是
    `'#FF9900'`，依此类推。`translate()` 函数将坐标系沿带的高度移动。每次迭代时，Processing 会应用列表中的下一个填充色，并在上一个矩形下方绘制一个新矩形。结果是在显示窗口的宽度上堆叠六个彩虹色的带子（见[图
    7-4](#figure7-4)）。请注意，绿色带子在电脑屏幕上会比在印刷书籍中的显示更亮。标准印刷墨水（青色、品红、黄色和黑色—CMYK）无法复制数字显示器上绿色的色调强度。
- en: '![f07004](image_fi/500969c07/f07004.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![f07004](image_fi/500969c07/f07004.png)'
- en: 'Figure 7-4: A rainbow sequence of six color bands'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-4：六种彩带的彩虹序列
- en: In this example, Python retrieves each element in the list, so you don’t need
    to specify any index values. In the next section, you’ll use the `enumerate()`
    function to retrieve the index for each element as well as the value.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，Python 会检索列表中的每个元素，因此你无需指定任何索引值。在下一节中，你将使用 `enumerate()` 函数来获取每个元素的索引和值。
- en: Looping with enumerate()
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 enumerate() 进行循环
- en: For some looping tasks, you need each element’s index and value. For instance,
    say you have an ordered list of your favorite movies and want to print each title
    alongside its rank (the index). You can do so with the `enumerate()` function.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些循环任务，你需要每个元素的索引和值。例如，假设你有一个你最喜欢的电影的有序列表，并且想要打印每个电影标题及其排名（索引）。你可以使用 `enumerate()`
    函数来实现。
- en: 'To use the `enumerate()` function to get the index of each color band in your
    rainbow, provide two variable names between the `for` and `in`. These two variables
    will hold your index and a corresponding value, respectively, for any iteration.
    Modify the code in your *rainbow_list* sketch:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `enumerate()` 函数获取彩虹中每个彩带的索引，在 `for` 和 `in` 之间提供两个变量名。这两个变量将分别存储索引和值，供每次迭代使用。修改你在
    *rainbow_list* 示例中的代码：
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `i` and `band` variables represent the index and fill value, respectively
    1. The extra `fill` and the two `text` lines below it draw index numbers over
    each rectangle 2.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`i` 和 `band` 变量分别表示索引和值。额外的 `fill` 和下面的两行 `text` 会在每个矩形上绘制索引数字。'
- en: Run the sketch. You should now see a white number in each band ([Figure 7-5](#figure7-5)),
    although the 2 doesn’t show up particularly well over the yellow.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 运行示例代码。现在你应该能在每个彩带中看到一个白色数字（见[图 7-5](#figure7-5)），尽管 2 在黄色上不是特别明显。
- en: '![f07005](image_fi/500969c07/f07005.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![f07005](image_fi/500969c07/f07005.png)'
- en: 'Figure 7-5: A numbered sequence of rainbow bands'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-5：带编号的彩虹带序列
- en: Use an `enumerate()` function wherever you need to work with list indices or
    keep count of loop iterations. For any other loop operations on lists, a plain
    `for` loop should suffice.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在需要操作列表索引或跟踪循环迭代次数时，使用 `enumerate()` 函数。如果是其他对列表的循环操作，普通的 `for` 循环就足够了。
- en: Creating Lists of Lists
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建列表的列表
- en: Although the concept of having lists within lists may seem complicated, appropriately
    nested lists make complex datasets easier to manage. In this practical data visualization
    task, you’ll create a variation of a bar chart. This chart will measure the relative
    brightness of six colors. [Figure 7-6](#figure7-6) shows a simplified representation
    of what you’re working toward. Notice that yellow, the brightest color, has the
    longest bar.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管列表内嵌列表的概念看起来可能很复杂，但适当嵌套的列表使复杂的数据集更容易管理。在这个实际的数据可视化任务中，你将创建一个条形图的变体。这个图表将测量六种颜色的相对亮度。[图
    7-6](#figure7-6) 显示了你正在努力达到的简化表示。注意，黄色是最亮的颜色，因此它的条形最长。
- en: '![f07006](image_fi/500969c07/f07006.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![f07006](image_fi/500969c07/f07006.png)'
- en: 'Figure 7-6: A simplified, outlined representation of the bar chart'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-6：条形图的简化轮廓表示
- en: The final chart will include color, and the bars will be further divided into
    segments of red, green, and blue to represent the RGB mixture of each color (more
    on this later).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的图表将包括颜色，条形会进一步分为红色、绿色和蓝色的几个部分，以表示每种颜色的RGB混合（稍后会详细介绍）。
- en: 'The first step in creating the bar chart is to start a new sketch and save
    it as *lists_of_lists*. Add the following setup code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 创建条形图的第一步是启动一个新的草图并将其保存为 *lists_of_lists*。添加以下设置代码：
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `h` variable defines the bar height, and the `translate()` function defines
    the upper left corner. The visual result should appear as a vertical bar; this
    represents a total number of six bands ([Figure 7-7](#figure7-7)). The height
    of the bar represents a single integer value: 6\. If `bands` were equal to 7,
    the rectangle that defines the bar would extend beyond the bottom of the display
    window.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`h` 变量定义了条形的高度，`translate()` 函数定义了左上角的位置。视觉效果应显示为垂直条形；这表示六个带状图（[图 7-7](#figure7-7)）。条形的高度表示一个整数值：6。如果
    `bands` 等于7，则定义条形的矩形将延伸超出显示窗口的底部。'
- en: '![f07007](image_fi/500969c07/f07007.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![f07007](image_fi/500969c07/f07007.png)'
- en: 'Figure 7-7: A bar 6 × 50 pixels tall'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-7：一个 6 × 50 像素高的条形
- en: 'The next step is to split the existing bar into six segments, which will later
    form the horizontal bars. Add a new `bands1` list of rainbow colors to the end
    of your sketch, along with a loop that draws a rectangle using each color:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将现有的条形分成六个部分，这些部分稍后将形成水平条形。在草图的末尾添加一个新的 `bands1` 彩虹颜色列表，并加入一个循环，使用每种颜色绘制一个矩形：
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This `bands1` list contains a series of six hexadecimal color values. These
    define the fills for each segment. The `for` loop draws the rainbow-colored segments
    in a column arrangement that conceals the first bar ([Figure 7-8](#figure7-8)).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `bands1` 列表包含六个十六进制颜色值。这些值定义了每个部分的填充颜色。`for` 循环以列的方式绘制彩虹色的部分，覆盖了第一个条形（[图
    7-8](#figure7-8)）。
- en: '![f07008](image_fi/500969c07/f07008.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![f07008](image_fi/500969c07/f07008.png)'
- en: 'Figure 7-8: Rainbow-colored rectangles placed over the original bar'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-8：彩虹色矩形覆盖在原始条形上
- en: The next step is to extend each block of color toward the right to form horizontal
    bars. The width of each bar will be determined by the brightness of its respective
    color. To calculate brightness, add together the red, green, and blue values that
    make up any color. For example, consider white. It’s the brightest “color” on
    your screen; it’s represented in hexadecimal as `#FFFFFF`, and if converted to
    percentages, expressed as 100 percent red, 100 percent green, and 100 percent
    blue. That’s an overall brightness of 300 percent, or if you prefer to average
    it out, it’s 300 ÷ 3 = 100 percent bright.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将每个颜色块向右延伸，形成水平条形。每个条形的宽度将由其各自颜色的亮度决定。计算亮度的方法是将构成任何颜色的红色、绿色和蓝色值相加。例如，考虑白色。它是屏幕上最亮的“颜色”；在十六进制中表示为`#FFFFFF`，如果转换为百分比表示，则为100%红色、100%绿色和100%蓝色。总体亮度为300%，或者如果你想取平均值，则为300
    ÷ 3 = 100%的亮度。
- en: 'To manage the colors as RGB percentages, you’ll need an integer value for each
    R/G/B primary, as opposed to a single hexadecimal string value. Add a new `bands2`
    list to the end of your code, wherein each element contains a list of three integers
    representing the red/green/blue mix of each color:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了按RGB百分比管理颜色，你需要为每个R/G/B主色提供一个整数值，而不是一个十六进制字符串值。将一个新的 `bands2` 列表添加到代码的末尾，每个元素包含一个包含三整数的列表，表示每种颜色的红色/绿色/蓝色混合：
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To access any list element within another list element directly, include a
    second pair of square brackets. For example, to retrieve the percentage of green
    in the second (orange) band, enter the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要直接访问另一个列表元素中的列表元素，请包含第二对方括号。例如，要检索第二个（橙色）条带中的绿色百分比，请输入以下内容：
- en: '[PRE24]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this case, the green value is 60, which you can confirm in the console.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，绿色值为60，你可以在控制台中确认这一点。
- en: 'To work with the percentages in the `bands2` list, set `colorMode()` to use
    RGB values between 0 and 100\. To draw the bars, reset and translate the coordinate
    system, and then add a loop that draws rectangles filled in with various shades
    of gray:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理`bands2`列表中的百分比，请将`colorMode()`设置为使用0到100之间的RGB值。为了绘制条形图，重置并转换坐标系统，然后添加一个循环来绘制填充不同灰度的矩形：
- en: '[PRE25]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: With each iteration, `band` is assigned the next list of RGB percentage values
    1. These values are added together 2, averaged to calculate a brightness value
    3, and the bar fill is set to a shade of gray using equal quantities of red/green/blue
    based on this average 4. The brightness value also determines the width of the
    bar 5. Run the sketch to view the result ([Figure 7-9](#figure7-9)).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 每次迭代时，`band`被赋予RGB百分比值列表。然后，这些值被相加、计算平均值以得到亮度值，条形图的填充色被设置为基于该平均值的红、绿、蓝等量的灰度色。亮度值还决定了条形图的宽度。运行草图查看结果（[图
    7-9](#figure7-9)）。
- en: 'Oddly, the green bar (fourth from the top) is indicated as equivalent in brightness
    to the red (top) bar. Recall also that the green is even brighter on your screen
    than in print. The math is correct, but the human eye has a greater number of
    green receptors, making us more sensitive to green light, so the green band appears
    brighter. There are ways to compensate for this mathematically. If you’d like
    to test it out, you can multiply the `r`, `g`, `b` variables using the following
    values:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 奇怪的是，绿色条形图（从上数第四个）被指示为与红色（顶部）条形图亮度相当。还记得绿色在你的屏幕上比在打印上更亮。数学计算是正确的，但人眼对绿色光的敏感度更高，因为我们拥有更多的绿色光感受器，因此绿色条形图看起来更亮。可以通过数学方式来补偿这一点。如果你想测试，可以使用以下值乘以`r`、`g`、`b`变量：
- en: '[PRE26]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '![f07009](image_fi/500969c07/f07009.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![f07009](image_fi/500969c07/f07009.png)'
- en: 'Figure 7-9: The widths of each bar represent the relative brightness of each
    color.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-9：每个条形图的宽度代表每种颜色的相对亮度。
- en: Now, the yellow bar (third from the top) is the only bar wider/brighter than
    the green one. For this task, however, I want to work with the averaging formula,
    so remove any multipliers to revert to the averaged values.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，黄色条（从上数第三个）是唯一一个比绿色条更宽/更亮的条形图。然而，对于这个任务，我想使用平均公式，因此请移除任何乘数，恢复为平均值。
- en: 'Next, adapt the existing loop so that each bar indicates the different quantities
    of primary color that make up its fill:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，调整现有的循环，使得每个条形图显示构成其填充的主要颜色的不同数量：
- en: '[PRE27]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `rect()` functions form horizontal bars containing up to three segments
    each. The size and fill of each segment are governed by how much red 1, green
    2, and blue 3 the color band contains. Even with the `colorMode()` set to `RGB`,
    Processing can still interpret fill arguments in quotes as hexadecimal.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`rect()`函数形成包含最多三个段的水平条形图。每个段的大小和填充由颜色条带包含的红色、绿色和蓝色量决定。即使`colorMode()`设置为`RGB`，Processing仍然可以将带引号的填充参数解释为十六进制值。'
- en: Run the sketch to view the result ([Figure 7-10](#figure7-10)). Red, the top
    bar, is mixed using nothing but red. Violet, the bottom bar, is predominantly
    blue, but also contains some red and a little green.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 运行草图查看结果（[图 7-10](#figure7-10)）。红色条形图位于顶部，完全由红色混合而成。紫色条形图位于底部，主要是蓝色，但也包含一些红色和一点绿色。
- en: '![f07010](image_fi/500969c07/f07010.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![f07010](image_fi/500969c07/f07010.png)'
- en: 'Figure 7-10: Each bar displays its proportion of RGB primaries.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-10：每个条形图显示其RGB主色的比例。
- en: 'If you show the chart to others, they likely will have no idea what color each
    bar represents, so adding labels will help elucidate matters. Add a label element
    to each band:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你向别人展示图表，他们可能完全不知道每个条形图代表什么颜色，因此添加标签将有助于阐明问题。为每个条带添加一个标签元素：
- en: '[PRE28]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then, add some lines to your loop to draw each label:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在循环中添加一些行来绘制每个标签：
- en: '[PRE29]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This sets the text fill to white, right-aligns it, and writes a color label
    alongside the bar. Run the code to view the result ([Figure 7-11](#figure7-11)).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这将文本填充设置为白色，右对齐，并在条形图旁边写下颜色标签。运行代码查看结果（[图 7-11](#figure7-11)）。
- en: '![f07011](image_fi/500969c07/f07011.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![f07011](image_fi/500969c07/f07011.png)'
- en: 'Figure 7-11: Completed graph with labels'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-11：带标签的完整图表
- en: Many lists work just fine with a single dimension, such as shopping lists. You
    can think of two-dimensional lists as grids or tables, which makes them useful
    for plotting 2D graphics. Three-dimensional and other higher-dimensional lists
    have their places, but before employing such a structure, consider whether adding
    another position to your two-dimensional list may be more sensible.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 许多列表只需一维即可正常工作，例如购物清单。你可以将二维列表看作是网格或表格，这使得它们对于绘制二维图形非常有用。三维及其他高维列表也有其用途，但在使用这种结构之前，请考虑是否将二维列表添加另一个位置会更加合理。
- en: 'Challenge #7: Breakout Level'
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '挑战 #7：Breakout关卡'
- en: In this challenge, you’ll recreate a *Breakout* level. The setup code will include
    a three-dimensional list. Working with such a list requires a nested loop—that
    is, a loop inside another loop.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个挑战中，你将重新创建一个*Breakout*关卡。设置代码将包括一个三维列表。处理这样的列表需要使用嵌套循环——也就是一个循环嵌套在另一个循环内。
- en: The result should look like [Figure 7-12](#figure7-12). Note that you’re not
    creating a playable game with working inputs; it’s more like a screenshot grabbed
    during play.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应该类似于[图 7-12](#figure7-12)。请注意，你并没有创建一个可以玩耍的游戏，带有有效的输入；它更像是在游戏进行中抓取的一张截图。
- en: 'Create a new sketch and save it as *breakout_level*. Add the following code
    to draw the ball and paddle:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新草图，并将其保存为*breakout_level*。添加以下代码来绘制球和挡板：
- en: '[PRE30]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '![f07012](image_fi/500969c07/f07012.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![f07012](image_fi/500969c07/f07012.png)'
- en: 'Figure 7-12: Completed *Breakout* task'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-12：完成的*Breakout*任务
- en: This code should render an empty black stage with the white ball and paddle,
    but no bricks yet.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码应该会渲染出一个空的黑色舞台，白色的球和挡板，但还没有砖块。
- en: 'Now add the data for the bricks. To save time, copy and paste the code from
    my GitHub repository:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，添加砖块的数据。为了节省时间，复制并粘贴我在GitHub仓库中的代码：
- en: Open your browser and go to [https://github.com/tabreturn/processing.py-book/.](https://github.com/tabreturn/processing.py-book/.)
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开浏览器，访问[https://github.com/tabreturn/processing.py-book/.](https://github.com/tabreturn/processing.py-book/.)
- en: Navigate to *chapter-07-working_with_lists_and_reading_data*.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到*chapter-07-working_with_lists_and_reading_data*。
- en: Locate and open the *bricks.txt* file.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位并打开*bricks.txt*文件。
- en: Copy and paste the contents of *bricks.txt* into your sketch.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将*bricks.txt*的内容复制并粘贴到你的草图中。
- en: 'Here’s the code if you’d prefer to type it in:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更愿意手动输入，以下是代码：
- en: '[PRE31]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: To make this more readable, I’ve entered the `bricks` list in a way that reflects
    the visual positioning of each brick. In the following order, each brick has a
    fill color and hit count (indicating the number of hits required to destroy it).
    I represent each missing brick by using an empty list.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让这更易读，我以一种反映每个砖块视觉位置的方式输入了`bricks`列表。按照以下顺序，每个砖块都有一个填充颜色和击中计数（表示摧毁它所需的击中次数）。我用空列表表示每个缺失的砖块。
- en: 'Take the first brick as an example: `[r,1]`. This brick has a fill of red and
    requires one (remaining) hit to destroy. You can infer the column and row positions
    from the lists in which the brick resides; in this case, it’s row 0, column 0\.
    Add two `print()` statements to confirm this information:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 以第一个砖块为例：[r,1]。这个砖块的填充颜色是红色，需要一次（剩余的）击中才能摧毁。你可以从包含该砖块的列表中推断出列和行的位置；在这种情况下，它位于第0行，第0列。添加两个`print()`语句来确认这些信息：
- en: '[PRE32]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'These `print` lines display the first element in `bricks`, a list of the four
    bricks that make up row 0 1, and the first brick in row 0 2. If you want to retrieve
    the color of the first brick, enter the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这些`print`语句显示了`bricks`中的第一个元素，它是构成第0行第1列的四个砖块中的第一个，以及第0行第2列的第一个砖块。如果你想检索第一个砖块的颜色，可以输入以下内容：
- en: '[PRE33]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note that the color variable `r` holds a hexadecimal value, so what you see
    in the console is the hexadecimal value for red.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，颜色变量`r`包含一个十六进制值，因此在控制台中显示的是红色的十六进制值。
- en: 'As I mentioned previously, you’ll need to employ a nested loop for this task.
    The following lines will help you get started:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前所提到的，你需要为此任务使用嵌套循环。以下几行代码将帮助你开始：
- en: '[PRE34]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `bw` variable defines a brick width based on fitting four columns into the
    display window; `bh` calculates the brick height. The outer `for` loops through
    the rows; the inner `for` loops through the bricks within each row. The `col`
    and `brick` variables hold the column number and brick, respectively. You use
    the `len()` function to determine whether this brick is a placeholder (an empty
    list). A `brick` with a length of 0 is equivalent to `False`, and Python skips
    the `x = col * bw` line. The `x` variable will hold the x-coordinate to draw each
    brick. Complete the task to match the result shown in [Figure 7-12](#figure7-12).
    Note that the bricks located roughly in the center have a hit count of `2` and
    must include a shine effect. If you need help, you can access the code at [https://github.com/tabreturn/processing.py-book/tree/master/chapter-07-working_with_lists_and_reading_data/breakout_level/](https://github.com/tabreturn/processing.py-book/tree/master/chapter-07-working_with_lists_and_reading_data/breakout_level/).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`bw` 变量定义了基于将四列排列到显示窗口中的砖块宽度；`bh` 计算砖块高度。外部的 `for` 循环遍历行，内部的 `for` 循环遍历每一行中的砖块。`col`
    和 `brick` 变量分别表示列号和砖块。你可以使用 `len()` 函数来判断这个砖块是否是占位符（即一个空列表）。长度为 0 的 `brick` 相当于
    `False`，此时 Python 会跳过 `x = col * bw` 这一行。`x` 变量将保存绘制每个砖块的 x 坐标。完成任务，以匹配 [图 7-12](#figure7-12)
    中显示的结果。请注意，大致位于中心的砖块的命中次数为 `2`，并且必须包括光泽效果。如果需要帮助，可以访问 [https://github.com/tabreturn/processing.py-book/tree/master/chapter-07-working_with_lists_and_reading_data/breakout_level/](https://github.com/tabreturn/processing.py-book/tree/master/chapter-07-working_with_lists_and_reading_data/breakout_level/)
    获取代码。'
- en: In the next section, you’ll learn how to work with data from external files,
    and you’ll use list techniques with Processing functions that read in the contents
    of text files.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，你将学习如何处理来自外部文件的数据，并且你将使用列表技巧结合 Processing 函数来读取文本文件的内容。
- en: Reading Data
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取数据
- en: Python—and by extension, Processing—can handle many types of file data. For
    instance, you could use Processing to create a game that incorporates various
    audio and video files, storing these multimedia assets in your *data* subfolder.
    You’ve loaded image data from PNG files into your Processing sketches in previous
    chapters; this section focuses on loading data stored in text-based files.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Python——以及 Processing——能够处理多种类型的文件数据。例如，你可以使用 Processing 创建一个包含各种音频和视频文件的游戏，并将这些多媒体资源存储在
    *data* 子文件夹中。你之前在章节中已经从 PNG 文件加载了图像数据到 Processing 草图中；这一部分将重点讲解如何加载存储在基于文本文件中的数据。
- en: You’ve also worked with values stored in lists, but using Python’s list syntax
    to retype data from other sources can be tedious, especially for large and swappable
    datasets. An alternative is to manage and prepare data outside Processing by using
    something like a spreadsheet, save it in a text-based format, and then read in
    the file contents when you run your sketch. To understand what separates text-based
    files from other files, and how you might use them to store data, let’s start
    with a brief introduction to file formats.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你也曾处理过存储在列表中的值，但使用 Python 的列表语法将来自其他源的数据重新输入可能会很繁琐，尤其是对于大规模和可交换的数据集。一个替代方案是通过使用像电子表格这样的工具，在
    Processing 之外管理和准备数据，将其保存为基于文本的格式，然后在运行草图时读取文件内容。为了理解什么是基于文本的文件与其他文件的区别，以及如何使用它们来存储数据，我们先简要介绍一下文件格式。
- en: File Formats
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件格式
- en: A *file format* is a standardized means of encoding information for storage
    on a digital medium. Many formats exist, and each is interpreted differently.
    For example, applications are encoded in *executable formats*, such as Android
    Package Kit (APK) files for Android or executable (EXE) files for Windows. Some
    *multimedia formats* include MPEG-1/2 Audio Layer III (MP3) for music or JPG for
    images.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '*文件格式* 是一种标准化的编码信息的方式，用于在数字介质上存储数据。有许多不同的格式，每种格式的解读方式都不同。例如，应用程序以 *可执行格式* 编码，比如
    Android 的 APK 文件或 Windows 的 EXE 文件。一些 *多媒体格式* 包括用于音乐的 MPEG-1/2 音频层 III（MP3）或用于图像的
    JPG。'
- en: You can identify a file’s format by its *file extension*. File extensions typically
    comprise three letters, always preceded by a dot, and tacked onto the end of a
    filename. To simplify user interaction, many operating systems hide file extensions,
    but if you dig around in your Windows File Explorer or Mac Finder settings, you
    can make your file manager show the extensions. Your system relies on these file
    extensions to open files with the appropriate app and to display icons or generate
    thumbnails ([Figure 7-13](#figure7-13)).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '![f07013](image_fi/500969c07/f07013.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-13: A file manager in icon view with file extensions revealed'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'When you remove or rename a file extension, this association is lost. Perhaps
    you’ve tried to open an MP3 file in a text editor and gotten a bunch of garbled
    characters, something like this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Text editors are designed for editing text-encoded files; therefore, they attempt
    to interpret the audio data as characters. Although you might be able to spot
    some intelligible metadata in there somewhere, it’s 99 percent gobbledygook. If
    you open this same file with iTunes, Windows Media Player, or VLC, you’ll hear
    music.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Some file formats are text based, which means you can open them in any text
    or code editor and make some sense of the content. To clarify, by *text based*,
    I mean *plaintext*, not a Microsoft Word document with fonts of varying colors
    and sizes in bold and italic. You may be wondering why people even use plaintext,
    but it’s appropriate for simple to-do lists and writing just about any programming
    language, Python included. For instance, Processing files are plaintext, albeit
    with a *.pyde* file extension.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: CSV
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Comma-separated values (CSV)* files, which have the *.csv* extension, provide
    a simple approach to formatting plaintext data. You’ll download a CSV that contains
    a track list of Pink Floyd’s album *The Dark Side of the Moon*.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'Each line of a CSV file is one entry, and each entry consists of one or more
    fields separated by commas. Here’s an abridged track listing of *The Dark Side
    of the Moon* in CSV format:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The first line of this file contains the field headings, and the following lines
    provide the details of each track. Your spreadsheet software (Microsoft Excel,
    LibreOffice Calc, or similar) will associate itself with any files bearing the
    *.csv* extension. Opening any CSV file in a spreadsheet displays the information
    in the typical row-and-column arrangement ([Figure 7-14](#figure7-14)). This is
    useful for preparing CSV data, but be aware that none of the styling (cell sizes,
    font colors, and so on) is retained once you save back to CSV.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '![f07014](image_fi/500969c07/f07014.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-14: The full *playlist.csv* file open in LibreOffice Calc'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll now write code that loads the track-list data from a CSV file. Create
    a new sketch named *csv* with a *data* subfolder and complete the following steps:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Open your browser and go to [https://github.com/tabreturn/processing.py-book/](https://github.com/tabreturn/processing.py-book/).
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to *chapter-07-working_with_lists_and_reading_data*.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download the *data.zip* file.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extract the ZIP archive, and move *playlist.csv* to the sketch *data* subfolder.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Processing provides the `loadStrings()` function to read in text-based files.
    It accepts a single argument (a path) that points to your text file and returns
    the contents as a list of strings, each element representing a line of text. Add
    the following code to test the function:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The *playlist.csv* data is assigned to a list named `csv`. Each `csv` element
    holds a line of text representing a single track. The `for` loop prints each entry
    on a new line in the console:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `loadStrings()` function cannot distinguish between different plaintext
    formats; this could be a bestselling novel or the latest stock market figures.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'To interpret the CSV data, use the `split()` method to break each line into
    further lists. In this case, you’re splitting each entry so you can extract the
    number and title of each track; you don’t need the file location, creator, or
    album. The `split()` method works by using a delimiter argument of your preference.
    In this case, you’ll use a comma. Amend your `for` loop code like this:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: By adding `[1:]`, the `for` loop skips the first item in the `csv` list 1 to
    avoid printing the field headings. With each iteration, the `split()` method assigns
    a new list to the `track` variable 2. The elements `tracks[4]` and `track[1]`
    hold the entry track number and title, respectively.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the sketch to confirm that the console displays a list of 10 numbered tracks:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: If you want to write text to a file, look up the `saveStrings()` function in
    the online Processing reference; it’s effectively an inverse `loadStrings()`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Formatting plaintext data in CSV files is a good way to avoid having to manage
    your data in the Processing editor. The beauty of CSV lies in its simplicity,
    but it isn’t great for dealing with hierarchically structured data. In Chapter
    8, you’ll learn about other text-based formats (XML and JSON).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'Challenge #8: Games Sales Chart'
  id: totrans-205
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this final challenge, you’ll generate a bar chart of the bestselling video
    games of all time. [Figure 7-15](#figure7-15) presents the final result (left)
    along with a zoomed-in version to provide more detail (right).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '![f07015](image_fi/500969c07/f07015.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-15: Completed chart (left) and chart detail (right)'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: The data has been sourced from a Wikipedia article titled “List of best-selling
    video games” ([https://en.wikipedia.org/wiki/List_of_best-selling_video_games](https://en.wikipedia.org/wiki/List_of_best-selling_video_games))
    and converted from an HTML table to a tab-separated file. The rankings likely
    have shuffled since this book was published, but that doesn’t matter for the purpose
    of this exercise.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: You’ll read in the sales data by using a `loadStrings()` function, and then
    plot the chart by using the techniques you’ve learned in this chapter. Create
    a new sketch named *game_sales_chart* with a *data* subfolder. In the preceding
    exercise, you downloaded a *data.zip* file, which also contains a *list_of_best-selling_video_games.tsv*
    file; place this in the sketch *data* subfolder.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'This file uses tab-separated values, hence the *.tsv* file extension. I used
    tabs because it’s highly unlikely that any game titles or studio/publisher names
    will contain tab characters, but there may be commas that could interfere with
    a `split('','')` style approach. You may want to open the TSV file in your preferred
    spreadsheet application to inspect the values. There are 50 games in all, ordered
    with the bestselling game at the top. If you use a text editor to open the file,
    you should see something like this:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: A single, invisible tab character separates each field. Note that tab sizes
    may vary among editors and will not always form visually aligned columns, so the
    file may look a little different, depending on the editor you use.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'Add basic setup code to your sketch that will define the display window size
    and background color, as well as read in the TSV data:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: A list named `tsv` holds the game sales entries. None of the graphic elements
    have strokes, so I’ve included a `noStroke()` line.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll need to perform calculations to scale the bars relative to the display
    window. Although the sales figures appear to be numbers, Processing treats them
    as text. Recall that you cannot perform mathematical operations on string data.
    Fortunately, there’s an easy fix. The `int()` and `float()` functions convert
    various data types to integer and floating-point values, respectively. Here’s
    an example:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `split()` method must create a list from the first entry (Minecraft) using
    a tab character as a delimiter; to specify a tab, use `'\t'` as an argument. The
    variable `sales1` is equal to the value at index 2, the Sales column. Despite
    looking like a number, this value is a string, so the `print` line wraps `sales1`
    with an `int()` function to convert it to an integer before adding 1 to it.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Now, complete the chart as shown in [Figure 7-15](#figure7-15). It’s probably
    best to start with a loop that prints each entry. Then, get the labels to display
    before creating the bars. Once you have the labels, create plain white bars of
    the correct width, and finish it off with the rainbow sequence effect. If you
    need help, you can access the solution at [https://github.com/tabreturn/processing.py-book/tree/master/chapter-07-working_with_lists_and_reading_data/game_sales_chart/](https://github.com/tabreturn/processing.py-book/tree/master/chapter-07-working_with_lists_and_reading_data/game_sales_chart/).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you learned about Python’s suite of methods for various list
    operations, how to manage collections of items using lists, and how lists are
    particularly powerful when combined with loops. You also learned to harness nested
    lists in order to manage more complex data and practiced a few data visualization
    techniques.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学习了 Python 提供的一系列用于执行各种列表操作的方法，如何使用列表管理项目集合，以及在与循环结合使用时，列表的强大功能。你还学会了如何利用嵌套列表来管理更复杂的数据，并练习了一些数据可视化技巧。
- en: In addition, you saw how to work with data stored in plaintext formats, like
    CSV and TSV, allowing you to read in values from external files when you run a
    sketch. This means you don’t need to manage values in the Processing editor, making
    it easier to swap out datasets.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你已经学习了如何处理存储在纯文本格式中的数据，如 CSV 和 TSV，这使得在运行草图时能够从外部文件读取数值。这意味着你不需要在 Processing
    编辑器中管理数值，从而使得更换数据集变得更加容易。
- en: The next chapter moves on to dictionaries, which are similar to lists in that
    they store collections of items. With dictionaries, however, you access values
    by using a word instead of an index. Once again, you’ll create novel data visualizations
    with your new skills.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍字典，它们与列表类似，都用于存储项目集合。不过，字典通过使用词语而非索引来访问数值。你将再次利用新技能创建独特的数据可视化。
