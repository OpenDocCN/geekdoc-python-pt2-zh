- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with Lists and Reading Data
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: When you need to work with multiple values, you can group them into a single
    variable by using a Python list. The *list* data type stores any number of items
    in collections you can manage and manipulate dynamically and efficiently. For
    example, you could create a list to store the titles of your favorite movies and
    use built-in methods to insert new favorites, reorder the rankings, or display
    only titles ranked between 30 and 40.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll learn to create and manipulate lists, and then you’ll
    combine them with loops to access and perform actions with each item. In keeping
    with this book’s visual theme, you’ll generate graphical representations of list
    data, including a chart that displays brightness and RGB mixtures for a list of
    colors and another that plots the bestselling video games of all time. You’ll
    see how to adjust list values to affect visual output, observing how the charts
    adapt to changing data.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also learn how to read in data from text files and how text-based formats
    differ from other file formats. You’ll move your Python list data into CSV-formatted
    text files and load it in when your sketch runs, allowing you to prepare data
    with other tools, such as spreadsheets.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lists hold multiple values that are related or belong together. For example,
    consider programming a video game in which players wander about collecting various
    objects—keys, weapons, armor upgrades, and so forth—to advance to a new level.
    Your game needs to track those items, which you can store in an inventory list.
  prefs: []
  type: TYPE_NORMAL
- en: 'To denote a list, use square brackets and separate each element with a comma.
    As an example, here’s a simple list for some game items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This list contains five strings and is assigned to a variable named `inventory`.
  prefs: []
  type: TYPE_NORMAL
- en: Performing repetitive operations on collections of items is a common programming
    challenge. Suppose you want to display a grid with all the objects a player has
    collected ([Figure 7-1](#figure7-1)). You can write a `loop` statement to access
    each item in the inventory and draw it in a cell. If the size of the list changes—because
    the player has added or dropped items—the loop will adapt, so you can write the
    code once and then have the program fill the appropriate number of cells to depict
    the inventory items.
  prefs: []
  type: TYPE_NORMAL
- en: '![f07001](image_fi/500969c07/f07001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-1: A player inventory from the game *Minetest*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, a single list can contain any mix of data types and duplicate values.
    For example, this top-score entry stores multiple types of data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The player name `LEO` is a string, and the high score is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: Lists can include as many elements as you want, and you can even define an empty
    list by using just a pair of square brackets with nothing within them, which is
    useful if you intend to add items while your program is running.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lists are ordered, and ordering is significant in many situations—for example,
    in this sequence of rainbow colors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: When defining a list, you can write it across multiple lines, as shown here,
    to make your code easier to read and edit. Python also permits an optional trailing
    comma after the last element. Having this extra comma can help when you want to
    add or shuffle list values; just be careful not to forget a comma where necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and Accessing Lists
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To familiarize yourself with defining, accessing, and modifying lists, create
    a new sketch. Save it as *rainbow_list* and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'For now, this rainbow is missing a few colors, and the sequence is incorrect,
    so you’ll use various list operations to add and shuffle colors as you progress
    through this section. First, run the code to verify the following console output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Printing the `rainbow` variable displays all three values, complete with square
    brackets and commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'In many instances, you’ll want to retrieve an individual element instead of
    a whole list. To display a given color, specify its position, or *index*, in square
    brackets. Note that Python list indices start at 0, so to print the first element,
    enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Run the sketch to confirm that the console displays `blue`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second element, `orange`, has an index of `1`, and the last element in
    this list, `yellow`, has an index of `2`. To print items 1 and 2, enter the following
    (note that throughout this chapter, the comments alongside the `print` lines indicate
    what should appear in your console):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This syntax may remind you of slice notation from working with strings in Chapter
    3, and it should, because it works the same way. Just as with slice notation,
    use `-1` to access the last element of the list, and extract a subset of elements
    by using a range defined with a colon. Try the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If you specify any index beyond the bounds of the list, such as `rainbow[3]`
    or higher, Processing will display an `IndexError` message.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying Lists
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Lists can be dynamic in behavior, changing while your program runs. You can
    overwrite any element with a new value and use different list methods to insert
    new elements or remove existing ones. For a game inventory, you might replace
    a weapon if a player finds a more powerful one, and add or remove elements as
    the player trades items.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returning to the rainbow example, you need to replace blue with red as the
    first color in the `rainbow` list. To modify an existing list element, reassign
    it a new value as you would any other variable, but with lists, you need to specify
    the element index in square brackets. Add the following line to the end of your
    *rainbow_list* sketch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `red` string now replaces `blue`, overwriting it as the first item in the
    list. Printing the `rainbow` list should confirm this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Blue is no longer in the `rainbow` list.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at several of the most useful list methods, along with code to add
    to your working sketch. Each example builds on the code before it, so work through
    all of them sequentially, entering the lines as you progress.
  prefs: []
  type: TYPE_NORMAL
- en: The append() Method
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `append()` method adds an element to the very end of a list, whatever its
    length. Add blue to the end of the `rainbow` list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note that the comments after the `print()` function in these examples contain
    only the sequence of colors; when you actually print the list, the console will
    display `['red', ...,'blue']` with all of the brackets and quotation marks.
  prefs: []
  type: TYPE_NORMAL
- en: The extend() Method
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To add all the elements in one list to the end of another, use the `extend()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `colors` list, which contains indigo and violet, is now added to the original
    `rainbow` list.
  prefs: []
  type: TYPE_NORMAL
- en: The index() Method
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `index()` method returns the index (the position in the list as an integer)
    for any element that matches the argument provided. If there are multiple matches,
    this method detects the first instance. Use an argument of `''yellow''` to test
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Try different color arguments. If no matching value exists, Processing displays
    a `ValueError` message.
  prefs: []
  type: TYPE_NORMAL
- en: The insert() Method
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `insert()` method accepts two arguments: the first is the index at which
    to insert the element; the second is the value. Insert `green` into the middle
    of the list with an index argument of `3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Green is now in the position that blue used to occupy, shifting blue one index
    higher along with every color to the right of it.
  prefs: []
  type: TYPE_NORMAL
- en: The pop() Method
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `pop()` method accepts a single argument: the index of an element to remove.
    The “popped” value is returned should you need to use it for another operation.
    Pop indigo from the list and assign it to a variable named `i`; then print `i`
    and `rainbow` to confirm that your console output matches the comments shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If you aren’t concerned with using the popped value, remove the `i =` part.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, use `pop()` with no argument to remove the last item in the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The console output should confirm that violet is removed from the list.
  prefs: []
  type: TYPE_NORMAL
- en: The remove() Method
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `remove()` method removes the first element with a value that matches the
    argument provided. Re-add indigo and violet by using the `extend()` method, and
    then remove indigo with the `remove()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: After extending the list, `rainbow` is back to a seven-color list. After the
    `remove` line, the list is down to six colors again, with no indigo.
  prefs: []
  type: TYPE_NORMAL
- en: Python provides other list methods, but these should suffice for you to start
    manipulating lists. Any decent Python reference or internet search should cover
    the rest. For example, if you want to reorder list elements, look up the `reverse()`
    and alphanumerical `sort()` methods. The Processing reference also includes several
    list methods, which are standard Python (as opposed to Processing) features, and
    they are functional in any Python environment.
  prefs: []
  type: TYPE_NORMAL
- en: Combining Loops and Lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can program loops to work on lists, potentially saving countless lines of
    manual instruction. As an example, say you want to create a *Breakout*-style game
    ([Figure 7-2](#figure7-2)). In this type of game, the player controls the paddle
    at the bottom of the screen with the goal of bouncing the ball upward to destroy
    all the bricks. You could create a list to store the bricks so that when the player
    hits a brick with the ball, that brick would be removed from the list. In some
    levels, you could have additional bricks appear during play, which would mean
    you’d need to insert new list elements.
  prefs: []
  type: TYPE_NORMAL
- en: '![f07002](image_fi/500969c07/f07002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-2: *LBreakout2*, an open source *Breakout* clone'
  prefs: []
  type: TYPE_NORMAL
- en: You’ve likely played a variant of this game and are probably aware that, upon
    destruction, certain bricks drop power-ups. You also know that the bricks come
    in different colors, and that some may be invisible but solid, while others may
    take multiple hits to destroy. You can program all of those additional properties
    by using lists of lists. Lists can contain other lists, which, in turn, can contain
    further nested lists (see “Creating Lists of Lists” on page 144).
  prefs: []
  type: TYPE_NORMAL
- en: 'If your list is named `bricks` and contains the fills for 60 bricks, rendering
    each brick would require at least as many lines of code as you have elements.
    For instance, you might use the following code to draw each brick with a `rect()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Notice that every brick rendered requires a `fill()` and `rect()` function.
    Even if you remove the comments, that’s 120 lines (60 × 2) of code to draw the
    complete list. This is hardly efficient, nor can the code handle a list that might
    fluctuate in length.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing Shapes by Using a List of Color Values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For this exercise, you’ll draw a rainbow-colored sequence of bands from a list
    of hexadecimal values, beginning with a single band using a `fill()` and `rect()`
    function. You’ll then adapt the code to use a loop that draws the entire list.
    To begin, add the following code to your *rainbow_list* sketch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Up until this point, the sketch has relied exclusively on the console for output.
    This code begins by defining a display window size, no stroke, and a background
    color. The `bands` list holds hexadecimal values for a six-color rainbow with
    comments to identify each color value. The first (red) band is drawn using `translate()`,
    `fill()`, and `rect()` functions. Run the sketch. The result should be a single,
    horizontal red band on a blue background ([Figure 7-3](#figure7-3)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f07003](image_fi/500969c07/f07003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-3: The result of running the sketch is a single red band.'
  prefs: []
  type: TYPE_NORMAL
- en: You’ve drawn the first band in the list, and the next step is to adapt the code
    to use a `for` loop that draws all six bands.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you combine a `for` loop with a list, Python assigns each successive list
    value to the loop variable, using the length of the list to determine the number
    of iterations required. To make your program draw every band in the `bands` list,
    comment out the existing `fill()` and `rect()` functions, and then add a loop
    that draws the complete rainbow for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In this instance, the code is easier to understand if you name the loop variable
    `band` 1 instead of something like `i`. The `band` variable is equal to `'#FF0000'`
    on the first iteration, `'#FF9900'` on the second, and so forth. A `translate()`
    function moves the coordinate system down the height of a band 2. With each iteration,
    Processing applies the next fill in the list and draws a new rectangle below the
    last one. The result is a stack of six rainbow-colored bands that span the width
    of the display window ([Figure 7-4](#figure7-4)). Note that the green band will
    be brighter on a computer screen than it is in a printed book. Standard printing
    inks (cyan, magenta, yellow, and key/black—CMYK) cannot replicate the intensity
    of the shades of green on a digital display.
  prefs: []
  type: TYPE_NORMAL
- en: '![f07004](image_fi/500969c07/f07004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-4: A rainbow sequence of six color bands'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, Python retrieves each element in the list, so you don’t need
    to specify any index values. In the next section, you’ll use the `enumerate()`
    function to retrieve the index for each element as well as the value.
  prefs: []
  type: TYPE_NORMAL
- en: Looping with enumerate()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For some looping tasks, you need each element’s index and value. For instance,
    say you have an ordered list of your favorite movies and want to print each title
    alongside its rank (the index). You can do so with the `enumerate()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the `enumerate()` function to get the index of each color band in your
    rainbow, provide two variable names between the `for` and `in`. These two variables
    will hold your index and a corresponding value, respectively, for any iteration.
    Modify the code in your *rainbow_list* sketch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `i` and `band` variables represent the index and fill value, respectively
    1. The extra `fill` and the two `text` lines below it draw index numbers over
    each rectangle 2.
  prefs: []
  type: TYPE_NORMAL
- en: Run the sketch. You should now see a white number in each band ([Figure 7-5](#figure7-5)),
    although the 2 doesn’t show up particularly well over the yellow.
  prefs: []
  type: TYPE_NORMAL
- en: '![f07005](image_fi/500969c07/f07005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-5: A numbered sequence of rainbow bands'
  prefs: []
  type: TYPE_NORMAL
- en: Use an `enumerate()` function wherever you need to work with list indices or
    keep count of loop iterations. For any other loop operations on lists, a plain
    `for` loop should suffice.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Lists of Lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although the concept of having lists within lists may seem complicated, appropriately
    nested lists make complex datasets easier to manage. In this practical data visualization
    task, you’ll create a variation of a bar chart. This chart will measure the relative
    brightness of six colors. [Figure 7-6](#figure7-6) shows a simplified representation
    of what you’re working toward. Notice that yellow, the brightest color, has the
    longest bar.
  prefs: []
  type: TYPE_NORMAL
- en: '![f07006](image_fi/500969c07/f07006.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-6: A simplified, outlined representation of the bar chart'
  prefs: []
  type: TYPE_NORMAL
- en: The final chart will include color, and the bars will be further divided into
    segments of red, green, and blue to represent the RGB mixture of each color (more
    on this later).
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step in creating the bar chart is to start a new sketch and save
    it as *lists_of_lists*. Add the following setup code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `h` variable defines the bar height, and the `translate()` function defines
    the upper left corner. The visual result should appear as a vertical bar; this
    represents a total number of six bands ([Figure 7-7](#figure7-7)). The height
    of the bar represents a single integer value: 6\. If `bands` were equal to 7,
    the rectangle that defines the bar would extend beyond the bottom of the display
    window.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f07007](image_fi/500969c07/f07007.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-7: A bar 6 × 50 pixels tall'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to split the existing bar into six segments, which will later
    form the horizontal bars. Add a new `bands1` list of rainbow colors to the end
    of your sketch, along with a loop that draws a rectangle using each color:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This `bands1` list contains a series of six hexadecimal color values. These
    define the fills for each segment. The `for` loop draws the rainbow-colored segments
    in a column arrangement that conceals the first bar ([Figure 7-8](#figure7-8)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f07008](image_fi/500969c07/f07008.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-8: Rainbow-colored rectangles placed over the original bar'
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to extend each block of color toward the right to form horizontal
    bars. The width of each bar will be determined by the brightness of its respective
    color. To calculate brightness, add together the red, green, and blue values that
    make up any color. For example, consider white. It’s the brightest “color” on
    your screen; it’s represented in hexadecimal as `#FFFFFF`, and if converted to
    percentages, expressed as 100 percent red, 100 percent green, and 100 percent
    blue. That’s an overall brightness of 300 percent, or if you prefer to average
    it out, it’s 300 ÷ 3 = 100 percent bright.
  prefs: []
  type: TYPE_NORMAL
- en: 'To manage the colors as RGB percentages, you’ll need an integer value for each
    R/G/B primary, as opposed to a single hexadecimal string value. Add a new `bands2`
    list to the end of your code, wherein each element contains a list of three integers
    representing the red/green/blue mix of each color:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'To access any list element within another list element directly, include a
    second pair of square brackets. For example, to retrieve the percentage of green
    in the second (orange) band, enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the green value is 60, which you can confirm in the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'To work with the percentages in the `bands2` list, set `colorMode()` to use
    RGB values between 0 and 100\. To draw the bars, reset and translate the coordinate
    system, and then add a loop that draws rectangles filled in with various shades
    of gray:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: With each iteration, `band` is assigned the next list of RGB percentage values
    1. These values are added together 2, averaged to calculate a brightness value
    3, and the bar fill is set to a shade of gray using equal quantities of red/green/blue
    based on this average 4. The brightness value also determines the width of the
    bar 5. Run the sketch to view the result ([Figure 7-9](#figure7-9)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Oddly, the green bar (fourth from the top) is indicated as equivalent in brightness
    to the red (top) bar. Recall also that the green is even brighter on your screen
    than in print. The math is correct, but the human eye has a greater number of
    green receptors, making us more sensitive to green light, so the green band appears
    brighter. There are ways to compensate for this mathematically. If you’d like
    to test it out, you can multiply the `r`, `g`, `b` variables using the following
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '![f07009](image_fi/500969c07/f07009.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-9: The widths of each bar represent the relative brightness of each
    color.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, the yellow bar (third from the top) is the only bar wider/brighter than
    the green one. For this task, however, I want to work with the averaging formula,
    so remove any multipliers to revert to the averaged values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, adapt the existing loop so that each bar indicates the different quantities
    of primary color that make up its fill:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `rect()` functions form horizontal bars containing up to three segments
    each. The size and fill of each segment are governed by how much red 1, green
    2, and blue 3 the color band contains. Even with the `colorMode()` set to `RGB`,
    Processing can still interpret fill arguments in quotes as hexadecimal.
  prefs: []
  type: TYPE_NORMAL
- en: Run the sketch to view the result ([Figure 7-10](#figure7-10)). Red, the top
    bar, is mixed using nothing but red. Violet, the bottom bar, is predominantly
    blue, but also contains some red and a little green.
  prefs: []
  type: TYPE_NORMAL
- en: '![f07010](image_fi/500969c07/f07010.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-10: Each bar displays its proportion of RGB primaries.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you show the chart to others, they likely will have no idea what color each
    bar represents, so adding labels will help elucidate matters. Add a label element
    to each band:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add some lines to your loop to draw each label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This sets the text fill to white, right-aligns it, and writes a color label
    alongside the bar. Run the code to view the result ([Figure 7-11](#figure7-11)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f07011](image_fi/500969c07/f07011.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-11: Completed graph with labels'
  prefs: []
  type: TYPE_NORMAL
- en: Many lists work just fine with a single dimension, such as shopping lists. You
    can think of two-dimensional lists as grids or tables, which makes them useful
    for plotting 2D graphics. Three-dimensional and other higher-dimensional lists
    have their places, but before employing such a structure, consider whether adding
    another position to your two-dimensional list may be more sensible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Challenge #7: Breakout Level'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this challenge, you’ll recreate a *Breakout* level. The setup code will include
    a three-dimensional list. Working with such a list requires a nested loop—that
    is, a loop inside another loop.
  prefs: []
  type: TYPE_NORMAL
- en: The result should look like [Figure 7-12](#figure7-12). Note that you’re not
    creating a playable game with working inputs; it’s more like a screenshot grabbed
    during play.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new sketch and save it as *breakout_level*. Add the following code
    to draw the ball and paddle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '![f07012](image_fi/500969c07/f07012.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-12: Completed *Breakout* task'
  prefs: []
  type: TYPE_NORMAL
- en: This code should render an empty black stage with the white ball and paddle,
    but no bricks yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the data for the bricks. To save time, copy and paste the code from
    my GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: Open your browser and go to [https://github.com/tabreturn/processing.py-book/.](https://github.com/tabreturn/processing.py-book/.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to *chapter-07-working_with_lists_and_reading_data*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Locate and open the *bricks.txt* file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy and paste the contents of *bricks.txt* into your sketch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here’s the code if you’d prefer to type it in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: To make this more readable, I’ve entered the `bricks` list in a way that reflects
    the visual positioning of each brick. In the following order, each brick has a
    fill color and hit count (indicating the number of hits required to destroy it).
    I represent each missing brick by using an empty list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take the first brick as an example: `[r,1]`. This brick has a fill of red and
    requires one (remaining) hit to destroy. You can infer the column and row positions
    from the lists in which the brick resides; in this case, it’s row 0, column 0\.
    Add two `print()` statements to confirm this information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'These `print` lines display the first element in `bricks`, a list of the four
    bricks that make up row 0 1, and the first brick in row 0 2. If you want to retrieve
    the color of the first brick, enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Note that the color variable `r` holds a hexadecimal value, so what you see
    in the console is the hexadecimal value for red.
  prefs: []
  type: TYPE_NORMAL
- en: 'As I mentioned previously, you’ll need to employ a nested loop for this task.
    The following lines will help you get started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `bw` variable defines a brick width based on fitting four columns into the
    display window; `bh` calculates the brick height. The outer `for` loops through
    the rows; the inner `for` loops through the bricks within each row. The `col`
    and `brick` variables hold the column number and brick, respectively. You use
    the `len()` function to determine whether this brick is a placeholder (an empty
    list). A `brick` with a length of 0 is equivalent to `False`, and Python skips
    the `x = col * bw` line. The `x` variable will hold the x-coordinate to draw each
    brick. Complete the task to match the result shown in [Figure 7-12](#figure7-12).
    Note that the bricks located roughly in the center have a hit count of `2` and
    must include a shine effect. If you need help, you can access the code at [https://github.com/tabreturn/processing.py-book/tree/master/chapter-07-working_with_lists_and_reading_data/breakout_level/](https://github.com/tabreturn/processing.py-book/tree/master/chapter-07-working_with_lists_and_reading_data/breakout_level/).
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you’ll learn how to work with data from external files,
    and you’ll use list techniques with Processing functions that read in the contents
    of text files.
  prefs: []
  type: TYPE_NORMAL
- en: Reading Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python—and by extension, Processing—can handle many types of file data. For
    instance, you could use Processing to create a game that incorporates various
    audio and video files, storing these multimedia assets in your *data* subfolder.
    You’ve loaded image data from PNG files into your Processing sketches in previous
    chapters; this section focuses on loading data stored in text-based files.
  prefs: []
  type: TYPE_NORMAL
- en: You’ve also worked with values stored in lists, but using Python’s list syntax
    to retype data from other sources can be tedious, especially for large and swappable
    datasets. An alternative is to manage and prepare data outside Processing by using
    something like a spreadsheet, save it in a text-based format, and then read in
    the file contents when you run your sketch. To understand what separates text-based
    files from other files, and how you might use them to store data, let’s start
    with a brief introduction to file formats.
  prefs: []
  type: TYPE_NORMAL
- en: File Formats
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *file format* is a standardized means of encoding information for storage
    on a digital medium. Many formats exist, and each is interpreted differently.
    For example, applications are encoded in *executable formats*, such as Android
    Package Kit (APK) files for Android or executable (EXE) files for Windows. Some
    *multimedia formats* include MPEG-1/2 Audio Layer III (MP3) for music or JPG for
    images.
  prefs: []
  type: TYPE_NORMAL
- en: You can identify a file’s format by its *file extension*. File extensions typically
    comprise three letters, always preceded by a dot, and tacked onto the end of a
    filename. To simplify user interaction, many operating systems hide file extensions,
    but if you dig around in your Windows File Explorer or Mac Finder settings, you
    can make your file manager show the extensions. Your system relies on these file
    extensions to open files with the appropriate app and to display icons or generate
    thumbnails ([Figure 7-13](#figure7-13)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f07013](image_fi/500969c07/f07013.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-13: A file manager in icon view with file extensions revealed'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you remove or rename a file extension, this association is lost. Perhaps
    you’ve tried to open an MP3 file in a text editor and gotten a bunch of garbled
    characters, something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Text editors are designed for editing text-encoded files; therefore, they attempt
    to interpret the audio data as characters. Although you might be able to spot
    some intelligible metadata in there somewhere, it’s 99 percent gobbledygook. If
    you open this same file with iTunes, Windows Media Player, or VLC, you’ll hear
    music.
  prefs: []
  type: TYPE_NORMAL
- en: Some file formats are text based, which means you can open them in any text
    or code editor and make some sense of the content. To clarify, by *text based*,
    I mean *plaintext*, not a Microsoft Word document with fonts of varying colors
    and sizes in bold and italic. You may be wondering why people even use plaintext,
    but it’s appropriate for simple to-do lists and writing just about any programming
    language, Python included. For instance, Processing files are plaintext, albeit
    with a *.pyde* file extension.
  prefs: []
  type: TYPE_NORMAL
- en: CSV
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Comma-separated values (CSV)* files, which have the *.csv* extension, provide
    a simple approach to formatting plaintext data. You’ll download a CSV that contains
    a track list of Pink Floyd’s album *The Dark Side of the Moon*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each line of a CSV file is one entry, and each entry consists of one or more
    fields separated by commas. Here’s an abridged track listing of *The Dark Side
    of the Moon* in CSV format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The first line of this file contains the field headings, and the following lines
    provide the details of each track. Your spreadsheet software (Microsoft Excel,
    LibreOffice Calc, or similar) will associate itself with any files bearing the
    *.csv* extension. Opening any CSV file in a spreadsheet displays the information
    in the typical row-and-column arrangement ([Figure 7-14](#figure7-14)). This is
    useful for preparing CSV data, but be aware that none of the styling (cell sizes,
    font colors, and so on) is retained once you save back to CSV.
  prefs: []
  type: TYPE_NORMAL
- en: '![f07014](image_fi/500969c07/f07014.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-14: The full *playlist.csv* file open in LibreOffice Calc'
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll now write code that loads the track-list data from a CSV file. Create
    a new sketch named *csv* with a *data* subfolder and complete the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open your browser and go to [https://github.com/tabreturn/processing.py-book/](https://github.com/tabreturn/processing.py-book/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to *chapter-07-working_with_lists_and_reading_data*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download the *data.zip* file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extract the ZIP archive, and move *playlist.csv* to the sketch *data* subfolder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Processing provides the `loadStrings()` function to read in text-based files.
    It accepts a single argument (a path) that points to your text file and returns
    the contents as a list of strings, each element representing a line of text. Add
    the following code to test the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The *playlist.csv* data is assigned to a list named `csv`. Each `csv` element
    holds a line of text representing a single track. The `for` loop prints each entry
    on a new line in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The `loadStrings()` function cannot distinguish between different plaintext
    formats; this could be a bestselling novel or the latest stock market figures.
  prefs: []
  type: TYPE_NORMAL
- en: 'To interpret the CSV data, use the `split()` method to break each line into
    further lists. In this case, you’re splitting each entry so you can extract the
    number and title of each track; you don’t need the file location, creator, or
    album. The `split()` method works by using a delimiter argument of your preference.
    In this case, you’ll use a comma. Amend your `for` loop code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: By adding `[1:]`, the `for` loop skips the first item in the `csv` list 1 to
    avoid printing the field headings. With each iteration, the `split()` method assigns
    a new list to the `track` variable 2. The elements `tracks[4]` and `track[1]`
    hold the entry track number and title, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the sketch to confirm that the console displays a list of 10 numbered tracks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: If you want to write text to a file, look up the `saveStrings()` function in
    the online Processing reference; it’s effectively an inverse `loadStrings()`.
  prefs: []
  type: TYPE_NORMAL
- en: Formatting plaintext data in CSV files is a good way to avoid having to manage
    your data in the Processing editor. The beauty of CSV lies in its simplicity,
    but it isn’t great for dealing with hierarchically structured data. In Chapter
    8, you’ll learn about other text-based formats (XML and JSON).
  prefs: []
  type: TYPE_NORMAL
- en: 'Challenge #8: Games Sales Chart'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this final challenge, you’ll generate a bar chart of the bestselling video
    games of all time. [Figure 7-15](#figure7-15) presents the final result (left)
    along with a zoomed-in version to provide more detail (right).
  prefs: []
  type: TYPE_NORMAL
- en: '![f07015](image_fi/500969c07/f07015.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-15: Completed chart (left) and chart detail (right)'
  prefs: []
  type: TYPE_NORMAL
- en: The data has been sourced from a Wikipedia article titled “List of best-selling
    video games” ([https://en.wikipedia.org/wiki/List_of_best-selling_video_games](https://en.wikipedia.org/wiki/List_of_best-selling_video_games))
    and converted from an HTML table to a tab-separated file. The rankings likely
    have shuffled since this book was published, but that doesn’t matter for the purpose
    of this exercise.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll read in the sales data by using a `loadStrings()` function, and then
    plot the chart by using the techniques you’ve learned in this chapter. Create
    a new sketch named *game_sales_chart* with a *data* subfolder. In the preceding
    exercise, you downloaded a *data.zip* file, which also contains a *list_of_best-selling_video_games.tsv*
    file; place this in the sketch *data* subfolder.
  prefs: []
  type: TYPE_NORMAL
- en: 'This file uses tab-separated values, hence the *.tsv* file extension. I used
    tabs because it’s highly unlikely that any game titles or studio/publisher names
    will contain tab characters, but there may be commas that could interfere with
    a `split('','')` style approach. You may want to open the TSV file in your preferred
    spreadsheet application to inspect the values. There are 50 games in all, ordered
    with the bestselling game at the top. If you use a text editor to open the file,
    you should see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: A single, invisible tab character separates each field. Note that tab sizes
    may vary among editors and will not always form visually aligned columns, so the
    file may look a little different, depending on the editor you use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add basic setup code to your sketch that will define the display window size
    and background color, as well as read in the TSV data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: A list named `tsv` holds the game sales entries. None of the graphic elements
    have strokes, so I’ve included a `noStroke()` line.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll need to perform calculations to scale the bars relative to the display
    window. Although the sales figures appear to be numbers, Processing treats them
    as text. Recall that you cannot perform mathematical operations on string data.
    Fortunately, there’s an easy fix. The `int()` and `float()` functions convert
    various data types to integer and floating-point values, respectively. Here’s
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The `split()` method must create a list from the first entry (Minecraft) using
    a tab character as a delimiter; to specify a tab, use `'\t'` as an argument. The
    variable `sales1` is equal to the value at index 2, the Sales column. Despite
    looking like a number, this value is a string, so the `print` line wraps `sales1`
    with an `int()` function to convert it to an integer before adding 1 to it.
  prefs: []
  type: TYPE_NORMAL
- en: Now, complete the chart as shown in [Figure 7-15](#figure7-15). It’s probably
    best to start with a loop that prints each entry. Then, get the labels to display
    before creating the bars. Once you have the labels, create plain white bars of
    the correct width, and finish it off with the rainbow sequence effect. If you
    need help, you can access the solution at [https://github.com/tabreturn/processing.py-book/tree/master/chapter-07-working_with_lists_and_reading_data/game_sales_chart/](https://github.com/tabreturn/processing.py-book/tree/master/chapter-07-working_with_lists_and_reading_data/game_sales_chart/).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you learned about Python’s suite of methods for various list
    operations, how to manage collections of items using lists, and how lists are
    particularly powerful when combined with loops. You also learned to harness nested
    lists in order to manage more complex data and practiced a few data visualization
    techniques.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, you saw how to work with data stored in plaintext formats, like
    CSV and TSV, allowing you to read in values from external files when you run a
    sketch. This means you don’t need to manage values in the Processing editor, making
    it easier to swap out datasets.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter moves on to dictionaries, which are similar to lists in that
    they store collections of items. With dictionaries, however, you access values
    by using a word instead of an index. Once again, you’ll create novel data visualizations
    with your new skills.
  prefs: []
  type: TYPE_NORMAL
