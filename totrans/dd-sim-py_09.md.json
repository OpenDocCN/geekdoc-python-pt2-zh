["```py\nclass SecretAgent:\n```", "```py\nclass SecretAgent(object):\n```", "```py\nclass SecretAgent:\n\n    def __init__(self, codename):\n        self.codename = codename\n        self._secrets = []\n```", "```py\nfrom secret_agent import SecretAgent\nmouse = SecretAgent(\"Mouse\")\narmadillo = SecretAgent(\"Armadillo\")\nfox = SecretAgent(\"Fox\")\n```", "```py\n def __new__(cls, *args, **kwargs):\n        return super().__new__(cls, *args, **kwargs)\n```", "```py\n def __del__(self):\n        print(f\"Agent {self.codename} has been disavowed!\")\n```", "```py\nfrom secret_agent import SecretAgent\nweasel = SecretAgent(\"Weasel\")\ndel weasel\n```", "```py\nAgent Weasel has been disavowed!\n```", "```py\nclass SecretAgent:\n    def __init__(self, codename):\n        self.codename = codename\n        self._secrets = []\n```", "```py\nclass SecretAgent:\n\n    **_codeword = \"\"**\n\n    def __init__(self, codename):\n        self.codename = codename\n        self._secrets = []\n```", "```py\n❶ SecretAgent._codeword = \"Parmesan\"\nprint(armadillo._codeword)  # prints \"Parmesan\"\nprint(mouse._codeword)      # prints \"Parmesan\"\n\n❷ mouse._codeword = \"Cheese\"\nprint(mouse._codeword)      # prints \"Cheese\"\nprint(armadillo._codeword)  # prints \"Parmesan\"\n```", "```py\nclass Message:\n\n    def __init__(self):\n        self.__format = \"UTF-8\"\n```", "```py\nmsg = Message()\nprint(msg.__format)  # AttributeError\n```", "```py\nprint(msg._Message__format)\n```", "```py\n def remember(self, secret):\n        self._secrets.append(secret)\n```", "```py\nmouse.remember((\"42.864025, -72.568511\"))\n```", "```py\n @classmethod\n    def inform(cls, codeword):\n        cls._codeword = codeword\n```", "```py\nSecretAgent.inform(\"The goose honks at midnight.\")\nprint(mouse._codeword)  # prints \"The goose honks at midnight.\"\n\nfox.inform(\"The duck quacks at midnight.\")\nprint(mouse._codeword)  # prints \"The duck quacks at midnight.\"\n```", "```py\n @staticmethod\n    def inquire(question):\n        print(\"I know nothing.\")\n```", "```py\nclass SecretAgent:\n\n    _codeword = None\n\n    def __init__(self, codename):\n        self.codename = codename\n        self._secrets = []\n\n    def __del__(self):\n        print(f\"Agent {self.codename} has been disavowed!\")\n\n    def remember(self, secret):\n        self._secrets.append(secret)\n\n @classmethod\n    def inform(cls, codeword):\n        cls._codeword = codeword\n\n    @staticmethod\n    def inquire(question):\n        print(\"I know nothing.\")\n```", "```py\n @classmethod\n    def _encrypt(cls, message, *, decrypt=False):\n        code = sum(ord(c) for c in cls._codeword)\n        if decrypt:\n            code = -code\n        return ''.join(chr(ord(m) + code) for m in message)\n```", "```py\n def _getsecret(self):\n        return self._secrets[-1] if self._secrets else None\n```", "```py\n def _setsecret(self, value):\n        self._secrets.append(self._encrypt(value))\n```", "```py\n def _delsecret(self):\n        self._secrets = []\n```", "```py\n secret = property(fget=_getsecret, fset=_setsecret, fdel=_delsecret)\n```", "```py\nmouse = SecretAgent(\"Mouse\")\nmouse.inform(\"Parmesano\")\n\nprint(mouse.secret)     # prints \"None\"\nmouse.secret = \"12345 Main Street\"\nprint(mouse.secret)     # prints \"ϗϘϙϚϛφϳЇЏДφϹКИЋЋК\"\nmouse.secret = \"555-1234\"\nprint(mouse.secret)     # prints \"ϛϛϛϓϗϘϙϚ\"\n\nprint(mouse._secrets)   # prints two values\ndel mouse.secret\nprint(mouse._secrets)   # prints empty list\n```", "```py\n def _setsecret(self, value):\n        self._secrets.append(self._encrypt(value))\n\n    def _delsecret(self):\n        self._secrets = []\n\n    secret = property( ❶ fset=_setsecret, fdel=_delsecret)\n```", "```py\nmouse = SecretAgent(\"Mouse\")\nmouse.inform(\"Parmesano\")\n\nmouse.secret = \"12345 Main Street\"\nmouse.secret = \"555-1234\"\n\nprint(mouse.secret)  # AttributeError\n```", "```py\n secret = property**()**\n```", "```py\n **@secret.getter**\n    def **secret**(self):\n        return self._secrets[-1] if self._secrets else None\n```", "```py\n **@secret.setter**\n    def **secret**(self, value):\n        self._secrets.append(self._encrypt(value))\n```", "```py\n **@secret.deleter**\n    def **secret**(self):\n        self._secrets = []\n```", "```py\n **@property**\n    def secret(self):\n        return self._secrets[-1] if self._secrets else None\n\n    @secret.setter\n    def secret(self, value):\n        self._secrets.append(self._encrypt(value))\n\n @secret.deleter\n    def secret(self):\n        self._secrets = [] \n```", "```py\n ❶ secret = property()\n\n    @secret.setter\n    def secret(self, value):\n        self._secrets.append(self._encrypt(value))\n\n    @secret.deleter\n    def secret(self):\n        self._secrets = []\n```", "```py\nimport math\nclass GlobalCoordinates:\n\n    def __init__(self, *, latitude, longitude):\n\n        self._lat_deg = latitude[0]\n        self._lat_min = latitude[1]\n        self._lat_sec = latitude[2]\n        self._lat_dir = latitude[3]\n\n        self._lon_deg = longitude[0]\n        self._lon_min = longitude[1]\n        self._lon_sec = longitude[2]\n        self._lon_dir = longitude[3]\n\n    @staticmethod\n    def degrees_from_decimal(dec, *, lat):\n        if lat:\n            direction = \"S\" if dec < 0 else \"N\"\n        else:\n            direction = \"W\" if dec < 0 else \"E\"\n        dec = abs(dec)\n        degrees = int(dec)\n dec -= degrees\n        minutes = int(dec * 60)\n        dec -= minutes / 60\n        seconds = round(dec * 3600, 1)\n        return (degrees, minutes, seconds, direction)\n\n    @staticmethod\n    def decimal_from_degrees(degrees, minutes, seconds, direction):\n        dec = degrees + minutes/60 + seconds/3600\n        if direction == \"S\" or direction == \"W\":\n            dec = -dec\n        return round(dec, 6)\n\n    @property\n    def latitude(self):\n        return self.decimal_from_degrees(\n            self._lat_deg, self._lat_min, self._lat_sec, self._lat_dir\n        )\n\n    @property\n    def longitude(self):\n        return self.decimal_from_degrees(\n            self._lon_deg, self._lon_min, self._lon_sec, self._lon_dir\n        )\n```", "```py\nfrom global_coordinates import GlobalCoordinates\nnsp = GlobalCoordinates(latitude=(37, 46, 32.6, \"N\"),\n                        longitude=(122, 24, 39.4, \"W\"))\nprint(repr(nsp))\n```", "```py\n<__main__.GlobalCoordinates object at 0x7f61b0c4c7b8>\n```", "```py\n def __repr__(self):\n        return (\n            f\"<GlobalCoordinates \"\n            f\"lat={self._lat_deg}°{self._lat_min}'\"\n            f\"{self._lat_sec}\\\"{self._lat_dir}  \"\n            f\"lon={self._lon_deg}°{self._lon_min}'\"\n            f\"{self._lon_sec}\\\"{self._lon_dir}>\"\n        )\n```", "```py\n<GlobalCoordinates lat=37°46'32.6\"N  lon=122°24'39.4\"W>\n```", "```py\n def __str__(self):\n        return (\n            f\"{self._lat_deg}°{self._lat_min}'\"\n            f\"{self._lat_sec}\\\"{self._lat_dir} \"\n f\"{self._lon_deg}°{self._lon_min}'\"\n            f\"{self._lon_sec}\\\"{self._lon_dir}\"\n        )\n```", "```py\nprint(f\"No Starch Press's offices are at {nsp}\")\n```", "```py\nNo Starch Press's offices are at 37°46'32.6\"N 122°24'39.4\"W\n```", "```py\n def __hash__(self):\n        return hash((\n            self._lat_deg, self._lat_min, self._lat_sec, self._lat_dir,\n            self._lon_deg, self._lon_min, self._lon_sec, self._lon_dir\n        ))\n```", "```py\n def __eq__(self, other):\n        if not ❶ isinstance(other, GlobalCoordinates):\n            return ❷ NotImplemented\n\n        return (\n            self._lat_deg == other._lat_deg\n            and self._lat_min == other._lat_min\n            and self._lat_sec == other._lat_sec\n            and self._lat_dir == other._lat_dir\n            and self._lon_deg == other._lon_deg\n            and self._lon_min == other._lon_min\n            and self._lon_sec == other._lon_sec\n            and self._lon_dir == other._lon_dir\n        )\n```", "```py`Be careful with this reflection, however! If you want to support comparing objects of different types, you should define both special methods in the pair.    In my particular example, there’s no clear logic for less than or greater than on two `GlobalCoordinates`, so I’m not defining any of those four special methods. Since I don’t define them, calls to any of them will return `NotImplemented`.    ### Binary Operator Support    Special methods will also let you add support for *binary operators*—operators with two operands—to your class. If any of the methods are undefined, they will default to returning `NotImplemented`, which, in the context of an expression, will usually cause an error to be raised.    With `GlobalCoordinates`, I’ll only implement the subtraction operator (`-`) via the `__sub__()` method:    ```", "```py    Listing 7-37: *global_coordinates.py:6*    As with comparison special methods, binary-operator special methods require two parameters: `self` and `other`. In my case, it’s logical for these operands to be `GlobalCoordinates` class instances; if `other` is of a different type, I return `NotImplemented`. Otherwise, I perform the math and return a tuple representing the difference between latitudes and longitudes in decimal degrees.    Because I’m only supporting subtraction of two `GlobalCoordinates` instances, I’m done. However, if I were supporting subtracting some other type, I’d have to also implement `__rsub__()`, which is the reflection of `__sub__()`. The expression `a - b` calls `a.__sub__(b)`, but if that returns `NotImplemented`, then Python tries to call `b.__rsub__(a)` behind the scenes. Because `a - b` is not the same as `b - a`, I must define those two methods separately; `b.__rsub__(a)` should return the value of `a - b`.    A third method, `__isub__()`, corresponds to the subtraction-augmented assignment operator (`-=`). If this method is undefined, that operator will fall back on the `__sub__()` and `__rsub__()` functions (`a -= b` becomes `a = a - b`), so you’d only need to define `__isub__()` if you needed some special behavior.    All 13 binary operators, as well as `divmod()`, rely on the same three sorts of special methods, although there is no augmented assignment for `divmod()`. For your reference, [Table 7-1](#table7-1) outlines them all.      Table 7-1: Operator Special Methods       | **Operator** | **Method** | **Reflected method** | **Augmented method** | | --- | --- | --- | --- | | Addition (`+`) | `__add__()` | `__radd__()` | `__iadd__()` | | Subtraction (`-`) | `__sub__()` | `__rsub__()` | `__isub__()` | | Multiplication (`*`) | `__mul__()` | `__rmul__()` | `__imul__()` | | Matrix multiplication (`@`) | `__matmul__()` | `__rmatmul__()` | `__imatmul__()` | | Division (`/`) | `__truediv__()` | `__rtruediv__()` | `__itruediv__()` | | Floor division (`//`) | `__floordiv__()` | `__rfloordiv__()` | `__ifloordiv__()` | | Modulo (`%`) | `__mod__()` | `__mod__()` | `__imod__()` | | `divmod()` | `__divmod__()` | `__rdivmod__()` | N/A | | Power/exponent (`**`) | `__pow__()` | `__rpow__()` | `__ipow()__` | | Left shift (`<<`) | `__lshift__()` | `__rlshift__()` | `__ilshift__()` | | Right shift (`>>`) | `__rshift__()` | `__rrshift__()` | `__irshift__()` | | Logical AND (`and`) | `__and__()` | `__rand__()` | `__iand__()` | | Logical OR (`or`) | `__or__()` | `__ror__()` | `__ior__()` | | Logical XOR (`xor`) | `__xor__()` | `__rxor__()` | `__ixor__()` |    ### Unary Operator Support    You can also add support for unary operators—those with only one operand. Unary-operator special methods accept one parameter: `self`. As before, all three default to returning `NotImplemented` if undefined.    In the case of my `GlobalCoordinates`, I’d like to override the invert operator (`~`) to return a `GlobalCoordinates` instance that is the opposite position on the globe, in terms of both latitude and longitude:    ```", "```py    Listing 7-38: *global_coordinates.py:7*    Not much new there; I’m creating and returning a new instance of `GlobalCoordinates` from the negated current latitude and longitude.    The unary operators and their special methods are as follows:    1.  `__abs__()` handles the absolute value `abs()` operation function. 2.  `__invert__()` handles the invert/binary flip `~` operator. 3.  `__neg__()` handles the negative-sign operator `-`. 4.  `__pos__()` handles the positive-sign operator `+`.    ### Making Callable    The last of the special methods I’ll cover in this chapter concerns making an instance *callable*, meaning the instance can be treated like a function. This special method, `__call__()`, can accept any number of arguments and return anything.    To wrap up my example, I’ll write a `__call__()` method that, when passed another `GlobalCoordinate` instance, will return the distance between the two in degrees, minutes, and seconds. This is a rather contrived example without obvious usage, however, and I wouldn’t have made `GlobalCoordinates` callable in real life. This merely completes my example:    ```", "```py    Listing 7-39: *global_coordinates.py:8*    Remember, `__call__()` can be written to accept any parameters you want. In my case, I accept another `GlobalCoordinate` class instance on `other` ❶. Then, I calculate the distance between the two points in kilometers and return that result as a float ❷.    Now, I can use any class instance of `GlobalCoordinate` in the same manner as a function:    ```", "```py    Listing 7-40: *global_coordinates_usage.py:3*    I define two instances of `GlobalCoordinate`, and then I calculate the distance between them by passing one instance to the other and storing the result. Indeed, the distance from No Starch Press’s offices to those of the Python Software Foundation is about 852 kilometers (529 miles).    ### More Special Methods: Looking Ahead    There are several more special methods, but I’ll cover those in chapters where their functionality is relevant. Be on the lookout for special methods relating to *iterables* (Chapter 9), *context managers* (Chapter 11), and *async* (Chapter 16). You can also refer to Appendix A for a complete list of special methods.    ## Class Decorators    Classes support *decorators*, much like functions do. Class decorators wrap the instantiation of the class, allowing you to intervene in any number of ways: adding attributes, initializing another class containing an instance of the one being decorated, or performing some behavior immediately on the new object.    To demonstrate this, I need to set up for a decently believable example. I’ll create a class for `CoffeeRecipe` that contains the recipe for a particular coffee shop menu item. I’ll also create a separate class for a `CoffeeOrder`, which is a single person’s coffee order:    ```", "```py    Listing 7-41: *coffee_order_decorator.py:1*    By this point, you can probably figure out what’s going on here.    Next, I’m opening a drive-thru coffee shack that only does to-go orders, so I don’t want to have to specify each order as to go manually.    Instead of writing a whole new `CoffeeOrder` class, I can define a class decorator that allows me to specify that all orders are to go (or not) up front:    ```", "```py    Listing 7-42: *coffee_order_decorator.py:2*    This decorator accepts the additional argument `to_go`, so I have to wrap the decorator itself in another function, creating a double closure ❶. The decorator is returned from the outermost function ❹, but the decorator’s effective name will always come from the outermost function name. This pattern works with all decorators, not just class decorators.    The decorator, itself, will look pretty familiar, if you recall Chapter 6. After initializing an instance of the wrapped class ❷, I immediately use that instance to initialize a `CoffeeOrder` instance, which I return in a tuple with the `CoffeeShackRecipe` instance ❸.    I can now create a new `CoffeeShackRecipe` that inherits from `CoffeeRecipe` and adds nothing new, and then I can apply the decorator to make it always make orders to go:    ```", "```py    Listing 7-43: *coffee_order_decorator.py:3*    The only reason I created this new class is to extend it with the `@auto_order` decorator, without losing the ability to create `CoffeeRecipe` instances when I want them.    In the usage, you see that I can now specify a `CoffeeShackRecipe` as I would a `CoffeeRecipe`, but the `CoffeeShackRecipe` instance will return both a `CoffeeOrder` instance and a `CoffeeShackRecipe` instance. I call `brew()` on the `CoffeeOrder`. Neat trick, no?    ## Structural Pattern Matching with Objects    Structural pattern matching, which was added in Python 3.10, supports matching objects in patterns by their attributes.    For example, I might have a class that represents a pizza, and I might want to perform structural pattern matching based on attributes in a given `Pizza` object:    ```", "```py    Listing 7-44: *pattern_match_object.py:1a*    In each pattern, I specify the object that I’m expecting the subject `order` to be—in this case, `Pizza`—and then I list the attributes of that object and the expected values thereof. For example, if `order.first` is `\"pepperoni\"` and `order.second` is `\"mushroom\"`, then I print `\"ANSI standard pizza\"`.    In the second case, you’ll see I don’t even need to specify an expected value for each attribute. If `order.first` is `\"pineapple\"`, then the message `\"Is this even pizza?\"` will be displayed, regardless of the second value. (However, I like pineapple on pizza! Sorry, not sorry.)    Capture patterns can come into play here, too. If the second topping is `\"cheese\"`, but the first is something else, I want to capture the first topping as `first`, so I can use the value in the case suite:    ```", "```py    Listing 7-45: *pattern_match_object.py:1b*    Here, if the value of `order.second` is `\"cheese\"`, then the value of `order.first` is captured as `first`, which I use in the message.    I’ll also use capture patterns to create a fallback case here:    ```", "```py    Listing 7-46: *pattern_match_object.py:1c*    Here, if none of the preceding patterns match, then I capture both `order.first` and `order.second` and use them to compose a generic message about the pizza.    This works well if you don’t mind typing out the names of the attributes. However, there are times when this feels redundant. For example, if you have a `Point` class that represents a point in three-dimensional space, it would feel a bit tedious to spell out *x*, *y*, and *z* every time:    ```", "```py    Listing 7-47: *point.py:1a*    That pattern feels pretty long for something, especially when most people would expect to specify a point in 3D space as *x, y, z*.    Instead of writing out the attributes every time, I can define the special `__match_args__` class attribute, which specifies how a pattern’s values map positionally to the object’s attributes:    ```", "```py    Listing 7-48: *point.py:1b*    I define `__match_args__` as a tuple of strings representing the attributes I want to map to positional values in pattern matching on the object. That is, the first positional value in the pattern maps to `x_pos`, the second maps to `y_pos`, and so on. Now, I can shorten my patterns by omitting the names of the attributes.    ## Functional Meets Object Oriented    As I’ve mentioned, functional and object-oriented programming can fit together very well. Here are the functional programming rules for methods (adapted slightly from the function rules in Chapter 6):    1.  Every method should do one specific thing. 2.  A method’s implementation should never affect other methods, nor should it affect the behavior of the rest of the program. 3.  Avoid side effects! A method should only directly mutate attributes belonging to its class, and only when that behavior is an expected part of the method’s purpose. 4.  In general, methods shouldn’t have (or be affected by) state, other than the attributes belonging to its class. Providing the same input should always yield the same output, unless the method’s expected behavior dictates otherwise.    To summarize all that in another way, the only state that methods should have is the attributes of their class or instance, and only when relying on that state is essential to the purpose of the method.    Don’t hesitate to use functional patterns in the context of object-oriented programming. Treat an instance like you would any other variable. Attributes should only be modified by their instance’s or class’s methods, called via the dot operator:    ```", "```py    When an object is passed to a function, it should not be mutated (no side effects):    ```", "```py    If you combine the rules of functional and object-oriented programming, your code will be much easier to maintain.    ## When to Use Classes    Unlike with class-centric languages such as Java and C#, it is not always necessary to write classes in Python. An important part of object-oriented programming in Python is to know when to use classes and when *not* to.    ### Classes Aren’t Modules    You shouldn’t use a class where a module will be sufficient. Python modules already allow you to organize variables and functions by purpose or category, so you don’t need to use classes in the same manner.    The purpose of a class is to bundle data with the methods responsible for accessing and modifying that data. Thus, your decision on whether to make a class should be based on the data. Do the attributes make sense as a cohesive object? Let the word *attribute* be the hint: is the data descriptive of the thing your object is attempting to represent?    Also, you should ensure that any methods included in the class directly relate to the attributes. In other words, think of methods as things the object can *do*. Any method that doesn’t fit this criteria doesn’t belong in the class.    Similarly, beware of how you structure classes. A `House` has a kitchen sink, but the attributes and methods relating to the kitchen sink belong in their own `KitchenSink` class, and an *instance* of said class belongs in the house. (This is a compositional relationship between the two classes.)    ### Single Responsibility    One of the essential rules in object-oriented programming is the *single-responsibility principle*. Just like a function, a class should have a single, well-defined responsibility. A function *does* something, while a class *is* something.    Avoid writing *god classes*, which try to do many different things in one class. Not only are these bug prone and difficult to maintain, but they also make for a very confusing code structure.    ### Sharing State    Class attributes and class methods allow you to write *static classes*, which provide one of the preferred ways to share state across multiple modules in your program. Static classes are cleaner and more predictable than global variables, and they are easier to write, maintain, and debug than the singleton design pattern. (And if you’ve never heard of singletons, all the better for you.)    The single-responsibility principle still applies here. For example, a static class containing current user preferences might make sense, but the current user profile shouldn’t be thrown into that same class.    ### Are Objects Right for You?    Just because you *can* write your entire program with classes and objects doesn’t mean you *should*.    Instead, you should reserve classes and objects for what they’re best at: *encapsulation*. Remember:    1.  Modules organize things by purpose and category. 2.  Functions perform tasks with provided data (arguments) and return values. 3.  Collections store cohesive sets of data, which are accessed predictably (see Chapter 9). 4.  Classes define objects, which contain attributes and related behaviors (methods).    Take the time to select the right tools for the job. When you do this, you’ll find that classes and objects complement modules, functions (and functional programming), and collections.    ## Wrapping Up    Depending on the language you come from, classes and objects are probably either your bread and butter or things you seldom use, if at all. In Python, you can’t get away from objects—everything is one, after all—but you do get to decide what role classes will play in your code.    In any case, whether you follow more traditional object-oriented programming techniques or favor a functional approach, Python classes provide a reliable way of organizing data. Properties make it possible to write getters and setters that look the same as accessing an ordinary attribute. Special methods even make it possible to create whole new data types that work with all of Python’s language features.    Objectively speaking, Python is one classy language.```"]