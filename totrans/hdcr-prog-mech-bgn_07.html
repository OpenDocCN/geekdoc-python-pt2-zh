<html><head></head><body>
<h2 class="h2" id="ch05"><span epub:type="pagebreak" id="page_101"/><span class="big">5</span><br/>LINES AND SEGMENTS</h2>&#13;
<div class="image1"><img src="../images/common01.jpg" alt="Image"/></div>&#13;
<p class="noindent">A point and a direction describe an infinite, straight line, with no start or end. Two distinct points bound a segment, which has a finite length but contains infinite points. In this chapter, we’ll focus on these two primitives, line segments and lines. We’ll implement both with the help of the points and vectors we implemented in the previous chapter.</p>&#13;
<p class="indent">We’ll also spend some time understanding and implementing two algorithms: one that computes the closest point to a segment, and another that computes segment intersections. These algorithms use some vital concepts from geometry that will serve as the foundation for more complex problems. We’ll take our time implementing these operations to make sure we understand them, so get your Python IDE ready and grab a pen and paper—it’ll be helpful to sketch some diagrams the old-school way.</p>&#13;
<h3 class="h3" id="ch00lev1sec35"><strong>Segment Class</strong></h3>&#13;
<p class="noindent">Between any two points in the plane exists a unique <em>segment</em>, a straight line with finite length containing infinite points. <a href="ch05.xhtml#ch5fig1">Figure 5-1</a> depicts a segment between two points: <em>S</em> and <em>E</em>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_102"/><img src="../images/05fig01.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch5fig1"><em>Figure 5-1: Segment defined between the points <span class="normal">S</span> and <span class="normal">E</span></em></p>&#13;
<p class="indent">Let’s start by creating a class named <span class="literal">Segment</span> with two attributes: a start point <em>S</em> and an end point <em>E</em>. This is how our project’s structure looks so far:</p>&#13;
<p class="pre2">    Mechanics<br/>      |- geom2d<br/>      |    |- __init__.py<br/>      |    |- nums.py<br/>      |    |- point.py<br/>      |    |- point_test.py<br/>      |    |- vector.py<br/>      |    |- vector_test.py<br/>      |    |- vectors.py</p>&#13;
<p class="indent">Right-click the <em>geom2d</em> package, select <strong>New</strong> ▸ <strong>Python File</strong>, name it <em>segment</em>, and click <strong>OK</strong>. PyCharm adds the <em>.py</em> extension for you, but if you’re using another IDE, you may need to add it yourself. In the file, enter the class as it’s written in <a href="ch05.xhtml#ch5lis1">Listing 5-1</a>.</p>&#13;
<pre>from geom2d.point import Point&#13;
&#13;
&#13;
class Segment:&#13;
    def __init__(self, start: Point, end: Point):&#13;
        self.start = start&#13;
        self.end = end</pre>&#13;
<p class="caption"><a id="ch5lis1"/><em>Listing 5-1: <span class="codeitalic1">Segment</span> initialization</em></p>&#13;
<p class="indent">We start by importing the <span class="literal">Point</span> class from the <em>geom2d.point</em> module. Then, we define the <span class="literal">Segment</span> class with an initializer that accepts two points: <span class="literal">start</span> and <span class="literal">end</span>. These are stored in corresponding attributes.</p>&#13;
<p class="indent">Note that we are typing the parameters; more specifically, we’re saying they must be of type <span class="literal">Point</span>. These are the <em>type hints</em> we saw in <a href="ch02.xhtml#ch02">Chapter 2</a>, mostly for the IDE to give us some context help. If the IDE knows both <span class="literal">start</span> and <span class="literal">end</span> are objects from <span class="literal">Point</span>, it’ll detect if we’re trying to use any attribute the class doesn’t implement. But it’s important to realize this won’t prevent us from passing the wrong argument type at runtime. In fact, if you try the following in the console:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">from geom2d.segment import Segment</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">s = Segment("foo", "bar")</span>&#13;
&#13;
<span epub:type="pagebreak" id="page_103"/>&gt;&gt;&gt; <span class="codestrong1">s.start</span>&#13;
'foo'</pre>&#13;
<p class="noindent">you should see that Python allowed us to pass strings instead of <span class="literal">Point</span>s without complaining, as type hints are ignored by Python’s interpreter at runtime.</p>&#13;
<h4 class="h4" id="ch00lev2sec58"><strong><em>The Segment’s Direction</em></strong></h4>&#13;
<p class="noindent">An important property of a segment is its <em>direction</em>, defined as a vector going from its start point <em>S</em> to its end point <em>E</em>. If we call it <img class="inline" src="../images/dvictorit.jpg" alt="Image"/>, we can compute it using <a href="ch05.xhtml#ch05eqa01">Equation 5.1</a>.</p>&#13;
<div class="equationc" id="ch05eqa01"><img src="../images/05eqa01.jpg" alt="Image"/></div>&#13;
<p class="indent">The normalization of the direction vector yields the direction versor, also commonly used in many operations with segments. The <em>direction vector</em> is a vector with the same length as the segment and parallel to it, with a direction going from its start point toward the end point. The <em>direction versor</em> is the normalized version of the direction vector, that is, a vector with the same direction but with unitary length.</p>&#13;
<p class="indent">The direction versor <img class="inline" src="../images/dcapit.jpg" alt="Image"/>, given the segment with a length of <em>l</em>, is then as shown in <a href="ch05.xhtml#ch05eqa02">Equation 5.2</a>.</p>&#13;
<div class="equationc" id="ch05eqa02"><img src="../images/05eqa02.jpg" alt="Image"/></div>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Most of the time when we say</em> segment’s direction<em>, we’ll mean</em> direction versor <img class="inline" src="../images/dcapit.jpg" alt="Image"/><em>, but we’ll also sometimes use that phrase to refer to the</em> direction vector <img class="inline" src="../images/dvictorit.jpg" alt="Image"/><em>. If that’s the case, we’ll explicitly note it. So, if nothing is said, assume by direction we mean the direction versor.</em></p>&#13;
</div>&#13;
<p class="indent">Let’s implement both as properties of the class. Enter the code in <a href="ch05.xhtml#ch5lis2">Listing 5-2</a> in your <em>segment.py</em> file.</p>&#13;
<pre>from geom2d.point import Point&#13;
from geom2d.vectors import make_vector_between, make_versor_between&#13;
&#13;
&#13;
class Segment:&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
    @property&#13;
    def direction_vector(self):&#13;
        return make_vector_between(self.start, self.end)&#13;
&#13;
    @property&#13;
    def direction_versor(self):&#13;
        <span epub:type="pagebreak" id="page_104"/>return make_versor_between(self.start, self.end)</pre>&#13;
<p class="caption"><a id="ch5lis2"/><em>Listing 5-2: Calculating a segment’s direction vector and versor</em></p>&#13;
<p class="indent">Since we’re using the <span class="literal">make_vector_between</span> and <span class="literal">make_versor_between</span> factory functions we defined in <em>vectors.py</em>, these two attributes are straightforward to implement. We simply make a vector or versor between our start and end points.</p>&#13;
<p class="indent">Now, as important as the direction of the segment is, it’s just as important that we know the direction perpendicular to it. We might use this perpendicular direction, for instance, to compute the velocity direction of a particle colliding against a straight line, which may represent a wall or the ground, such as the case in <a href="ch05.xhtml#ch5fig2">Figure 5-2</a>.</p>&#13;
<div class="image"><img src="../images/05fig02.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch5fig2"><em>Figure 5-2: Computing the collision angle using the normal direction</em></p>&#13;
<p class="indent">Rotating the direction versor <img class="inline" src="../images/dcapit.jpg" alt="Image"/> <em>π</em>/4 radians (90<sup>°</sup>) yields the segment’s <em>normal versor</em>. Computing this versor is quite simple using <span class="literal">Vector</span>’s <span class="literal">perpendicular</span> attribute. Enter the new property in <a href="ch05.xhtml#ch5lis3">Listing 5-3</a> in the <span class="literal">Segment</span> class.</p>&#13;
<pre>class Segment:&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
    @property&#13;
    def normal_versor(self):&#13;
        return self.direction_versor.perpendicular()</pre>&#13;
<p class="caption"><a id="ch5lis3"/><em>Listing 5-3: Computing a vector perpendicular to the segment’s direction</em></p>&#13;
<p class="indent">This new property we have added works by chaining two attributes: <span class="literal">direction_versor</span> and <span class="literal">perpendicular</span>. We first call <span class="literal">self</span>’s <span class="literal">direction_versor</span> to obtain the segment’s direction versor. The result is an instance of <span class="literal">Vector</span>, upon which we call the <span class="literal">perpendicular</span> method, which returns a versor perpendicular to the segment’s direction.</p>&#13;
<p class="indent">We could have stored the direction versor in a new variable and then called the <span class="literal">perpendicular</span> method on that variable:</p>&#13;
<pre>def normal_versor(self):&#13;
    d = self.direction_versor&#13;
    return d.perpendicular()</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_105"/>In this case, the <span class="literal">d</span> variable doesn’t add readability to the code, and since we use it only once, we can chain both methods and return the result. You’ll see this pattern used often in our code.</p>&#13;
<p class="indent">You can see a visual representation of the concepts we just implemented in <a href="ch05.xhtml#ch5fig3">Figure 5-3</a>. The segment on the left shows the direction vector <img class="inline" src="../images/dvictorit.jpg" alt="Image"/>, with its origin at <em>S</em> (the start point) and tip at <em>E</em> (the end point). The segment on the right shows the normalized version <img class="inline" src="../images/dcapit.jpg" alt="Image"/> of the direction vector and its perpendicular counterpart <img class="inline" src="../images/ncapit.jpg" alt="Image"/>, the direction and normal versors, respectively.</p>&#13;
<div class="image"><img src="../images/05fig03.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch5fig3"><em>Figure 5-3: Segment direction vector (left) and direction and normal versors (right)</em></p>&#13;
<p class="indent">We’ll skip writing unit tests in this section, but that doesn’t mean you shouldn’t do them. From here on out, I won’t write tests for every method we do, just some chosen ones, so we can keep focus and get through the content. But it’s a great exercise for you to write unit tests for these untested methods. You can refer to the tests in the <em>Mechanics</em> project accompanying the book.</p>&#13;
<h4 class="h4" id="ch00lev2sec59"><strong><em>The Segment’s Length</em></strong></h4>&#13;
<p class="noindent">Another important property of a segment is its <em>length</em>, or the distance between its end points.</p>&#13;
<h5 class="h5" id="ch00lev3sec26"><strong>Calculating Length</strong></h5>&#13;
<p class="noindent">There are at least two ways we can compute the length of the segment: we can either compute the distance between points <em>S</em> and <em>E</em> or compute the length of the direction vector <img class="inline" src="../images/dvictorit.jpg" alt="Image"/>.</p>&#13;
<p class="indent">We’ll use the first one, which is shown in <a href="ch05.xhtml#ch5lis4">Listing 5-4</a>, but if you prefer, you can implement the second one. The result should be the same.</p>&#13;
<pre>class Segment:&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
    @property&#13;
    def length(self):&#13;
        return self.start.distance_to(self.end)</pre>&#13;
<p class="caption"><a id="ch5lis4"/><em>Listing 5-4: Calculating the length of a segment</em></p>&#13;
<p class="indent">Note again that using our previously implemented methods makes this calculation a breeze. Your <em>segment.py</em> file should look like <a href="ch05.xhtml#ch5lis5">Listing 5-5</a> at this point.<span epub:type="pagebreak" id="page_106"/></p>&#13;
<pre>from geom2d.point import Point&#13;
from geom2d.vectors import make_vector_between, make_versor_between&#13;
&#13;
&#13;
class Segment:&#13;
    def __init__(self, start: Point, end: Point):&#13;
        self.start = start&#13;
        self.end = end&#13;
&#13;
    @property&#13;
    def direction_vector(self):&#13;
        return make_vector_between(self.start, self.end)&#13;
&#13;
    @property&#13;
    def direction_versor(self):&#13;
        return make_versor_between(self.start, self.end)&#13;
&#13;
    @property&#13;
    def normal_versor(self):&#13;
        return self.direction_versor.perpendicular()&#13;
&#13;
    @property&#13;
    def length(self):&#13;
        return self.start.distance_to(self.end)</pre>&#13;
<p class="caption"><a id="ch5lis5"/><em>Listing 5-5: <span class="codeitalic1">Segment</span> class</em></p>&#13;
<p class="indent">Let’s test the method we just wrote.</p>&#13;
<h5 class="h5" id="ch00lev3sec27"><strong>Unit Testing Length</strong></h5>&#13;
<p class="noindent">To make sure we made no mistakes implementing the <span class="literal">length</span> property, let’s write a unit test. Start by creating a new test file. Right-click the <em>geom2d</em> package, select <strong>New</strong> ▸ <strong>Python File</strong>, name it <em>segment_test.py</em>, and click <strong>OK</strong>. Then enter the code in <a href="ch05.xhtml#ch5lis6">Listing 5-6</a>.</p>&#13;
<pre>import math&#13;
import unittest&#13;
&#13;
from geom2d.point import Point&#13;
from geom2d.segment import Segment&#13;
&#13;
&#13;
class TestSegment(unittest.TestCase):&#13;
&#13;
    start = Point(400, 0)&#13;
    end = Point(0, 400)&#13;
    segment = Segment(start, end)&#13;
&#13;
    <span epub:type="pagebreak" id="page_107"/>def test_length(self):&#13;
        expected = 400 * math.sqrt(2)&#13;
        actual = self.segment.length&#13;
        self.assertAlmostEqual(expected, actual)</pre>&#13;
<p class="caption"><a id="ch5lis6"/><em>Listing 5-6: Testing a segment’s <span class="codeitalic1">length</span> property</em></p>&#13;
<p class="indent">We import the <em>unittest</em> and <em>math</em> modules and the <span class="literal">Segment</span> and <span class="literal">Point</span> classes. Then, we define two points: <span class="literal">start</span> at (400, 0) and <span class="literal">end</span> at (0, 400). Using these points, we create <span class="literal">segment</span>, which is our test subject. Following Rule 1 for good unit tests, a test should fail for one and only one reason, our expected result is expressed directly as <img class="inline" src="../images/f00107-p1.jpg" alt="Image"/>, which comes from <img class="inline" src="../images/f00107-p2.jpg" alt="Image"/>. The temptation here would be to write the following:</p>&#13;
<pre>expected = self.start.distance_to(self.end)</pre>&#13;
<p class="noindent">However, that would violate Rule 1, as the test could fail for more than one reason. Moreover, in this case, both the expected and actual values would be computed using the same method: <span class="literal">distance_to</span>. This breaks the test’s independence from the code it’s supposed to test.</p>&#13;
<p class="indent">Run the test by clicking the green play button to the left of the <span class="literal">TestSegment</span> class definition and selecting <strong>Run ‘Unittests for segment’</strong>. You can run it from the console like so:</p>&#13;
<pre>$ <span class="codestrong1">python3 -m unittest geom2d/segment_test.py</span></pre>&#13;
<p class="indent">It may seem silly to test the <span class="literal">distance</span> property because the only thing it does is call the <span class="literal">distance_to</span> method, which has already been tested. Even with such simple implementations we could have made mistakes such as, for example, trying to compute the distance using the same point twice:</p>&#13;
<pre>self.start.distance_to(self.start)</pre>&#13;
<p class="noindent">As you probably know from your own experience, we developers make mistakes like this more often than not.</p>&#13;
<h4 class="h4" id="ch00lev2sec60"><strong><em>The t Parameter and Middle Points</em></strong></h4>&#13;
<p class="noindent">We said earlier that there are an infinite number of points between the endpoints <em>E</em> and <em>S</em> of a segment. How do we go about obtaining them? It’s common to use a parameter with values going from 0 to 1 (inclusive) to obtain every point along the segment. We’ll call this parameter <em>t</em> and define it as done in <a href="ch05.xhtml#ch05eqa03">Equation 5.3</a>.</p>&#13;
<div class="equationc" id="ch05eqa03"><img src="../images/05eqa03.jpg" alt="Image"/></div>&#13;
<p class="indent">All points between the segment’s <span class="literal">start</span> and <span class="literal">end</span> points can be obtained by varying the value of <em>t</em>. For <em>t</em> = 0, we get exactly the segment’s start point <em>S</em>. Similarly, for <em>t</em> = 1, we get the end point <em>E</em>. To compute any middle point <em>P</em> given a value of <em>t</em>, we can use <a href="ch05.xhtml#ch05eqa04">Equation 5.4</a>.</p>&#13;
<div class="equationc" id="ch05eqa04"><span epub:type="pagebreak" id="page_108"/><img src="../images/05eqa04.jpg" alt="Image"/></div>&#13;
<p class="indent">By realizing that the vector in the previous expression is exactly the direction vector as defined in <a href="ch05.xhtml#ch05eqa01">Equation 5.1</a>, we can simplify the expression as in <a href="ch05.xhtml#ch05eqa05">Equation 5.5</a>.</p>&#13;
<div class="equationc" id="ch05eqa05"><img src="../images/05eqa05.jpg" alt="Image"/></div>&#13;
<p class="indent">We can easily implement <a href="ch05.xhtml#ch05eqa05">Equation 5.5</a> using <span class="literal">Point</span>’s <span class="literal">displaced</span> method. Enter the method <span class="literal">point_at</span> in <a href="ch05.xhtml#ch5lis7">Listing 5-7</a> into your <span class="literal">Segment</span> class file (<em>segment.py</em>).</p>&#13;
<pre>class Segment:&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
   def point_at(self, t: float):&#13;
      return self.start.displaced(self.direction_vector, t)</pre>&#13;
<p class="caption"><a id="ch5lis7"/><em>Listing 5-7: Obtaining a point from a segment using parameter <span class="normal">t</span></em></p>&#13;
<p class="indent">By displacing the start point by the direction vector <em>t</em> times (with 0.0 ≤ <em>t</em> ≤ 1.0), we obtain any point on the segment. Let’s implement a property that directly yields the middle point of the segment, that is, the point for <em>t</em> = 0.5 (see <a href="ch05.xhtml#ch5fig4">Figure 5-4</a>).</p>&#13;
<div class="image"><img src="../images/05fig04.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch5fig4"><em>Figure 5-4: A segment’s middle point</em></p>&#13;
<p class="indent">This is a special point we’ll be computing often, so we want a convenient way of obtaining it. Enter the code in <a href="ch05.xhtml#ch5lis8">Listing 5-8</a>).</p>&#13;
<pre>class Segment:&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
    @property&#13;
   def middle(self):&#13;
       return self.point_at(0.5)</pre>&#13;
<p class="caption"><a id="ch5lis8"/><em>Listing 5-8: Segment’s middle point</em></p>&#13;
<h5 class="h5" id="ch00lev3sec28"><strong>Validating t Values</strong></h5>&#13;
<p class="noindent">You may have realized that in <span class="literal">point_at</span>, we don’t check that the passed-in <em>t</em> value is inside the expected range given by <a href="ch05.xhtml#ch05eqa03">Equation 5.3</a>. We can pass it a wrong value for <em>t</em>, and it works without complaining, yielding points that are out of the segment. For instance, if we passed it a value of <em>t</em> = 1.5, we’d obtain the point depicted in <a href="ch05.xhtml#ch5fig5">Figure 5-5</a>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_109"/><img src="../images/05fig05.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch5fig5"><em>Figure 5-5: Point out of the segment for <span class="normal">t</span> = 1.5</em></p>&#13;
<p class="indent">Without validating the <em>t</em> value, this method silently fails by returning a point that the user may be tricked into thinking lies between the segment end points. By <em>silently fail</em>, we mean that the result is conceptually wrong, but the method happily computes it for us without any kind of warning or complaint that there may be some kind of error.</p>&#13;
<p class="indent">Robust software <em>fails fast</em>, meaning that as soon as an erroneous condition is detected, the program panics and quits, if possible with a message giving comprehensive information about the error.</p>&#13;
<p class="indent">This may sound scary, but it helps a lot. Imagine we allow users to pass a wrong value of <em>t</em> to our <span class="literal">point_at(t)</span> method. Now say that the user without noticing passes in a <em>t</em> like 739928393839. . . You can imagine the point obtained from this value is quite far from the segment that is supposed to contain it. Such a value wouldn’t crash our program, and it would continue to execute. We may not notice that we’ve gotten such a value until some calculation several minutes later, when everything fails. Debugging all of what happened before we found the error could take hours (or maybe days, depending on the complexity of the code and how far the error spread). It’d be much simpler if we could detect the wrong value right away. Perhaps we could tell the user something like this:</p>&#13;
<pre>Oops! We were expecting the value of 't' to be in the  range [0, 1],&#13;
but you gave us a value of '739928393839'.</pre>&#13;
<p class="indent">This message is crystal clear. It’s telling the user the program had to quit because of an error. This error could have gotten worse had the program continued to execute. The nice thing is the user gets the chance to analyze where the wrong value came from and take action to prevent it from happening again.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Here we’re using the word</em> user <em>to reference anyone using our code, not the end user of the applications we write. This includes yourself, as you’ll be the user of your own code quite often.</em></p>&#13;
</div>&#13;
<p class="indent">Since there’s going to be a bunch of functionality defined for the <em>t</em> parameter, we’d better create a module for it. At this point, your project’s structure should look like this:</p>&#13;
<p class="pre2">    Mechanics<br/>      |- geom2d<br/>      |    |- __init__.py<br/>      |    |- nums.py<br/>      <span epub:type="pagebreak" id="page_110"/>|    |- point.py<br/>      |    |- point_test.py<br/>      |    |- segment.py<br/>      |    |- segment_test.py<br/>      |    |- vector.py<br/>      |    |- vector_test.py<br/>      |    |- vectors.py</p>&#13;
<p class="indent">Create a new file inside the <em>geom2d</em> package named <em>tparam.py</em>. Inside it, enter the code from <a href="ch05.xhtml#ch5lis9">Listing 5-9</a>.</p>&#13;
<pre>MIN = 0.0&#13;
MIDDLE = 0.5&#13;
MAX = 1.0&#13;
&#13;
&#13;
def make(value: float):&#13;
    if value &lt; MIN:&#13;
        return MIN&#13;
&#13;
    if value &gt; MAX:&#13;
        return MAX&#13;
&#13;
    return value&#13;
&#13;
&#13;
def ensure_valid(t):&#13;
    if not is_valid(t):&#13;
        raise TParamError(t)&#13;
&#13;
&#13;
def is_valid(t):&#13;
    return False if t &lt; MIN or t &gt; MAX else True&#13;
&#13;
&#13;
class TParamError(Exception):&#13;
    def __init__(self, t):&#13;
        self.t = t&#13;
&#13;
    def __str__(self):&#13;
        return f'Expected t to be in [0, 1] but was {self.t}'</pre>&#13;
<p class="caption"><a id="ch5lis9"/><em>Listing 5-9: Validating parameter <span class="normal">t</span> values</em></p>&#13;
<p class="indent">We start by defining three useful constants. There’s <span class="literal">MIN</span>, the minimum value <em>t</em> can take. There’s <span class="literal">MIDDLE</span>, the value of (<span class="literal">MIN</span> + <span class="literal">MAX</span>) / 2. Finally, there’s <span class="literal">MAX</span>, the maximum value <em>t</em> can take.</p>&#13;
<p class="indent">These values are going to be used a lot, so instead of writing <em>magic numbers</em> (numbers that appear hard-coded without explanation about their <span epub:type="pagebreak" id="page_111"/>nature) everywhere, we’ve given them a name to understand what they refer to.</p>&#13;
<p class="indent">Once we’ve defined the values, we define the function <span class="literal">make</span> to create a parameter with a valid value. Then comes the function <span class="literal">ensure_valid</span>, which checks that <em>t</em> is not less or greater than the range limits using another method: <span class="literal">is_valid</span>. If <em>t</em> has a value outside the valid range, an exception is raised. <span class="literal">TParam</span> <span class="literal">Error</span> is an implementation of Python’s <span class="literal">Exception</span>. This is a user-defined exception we provide with a nice formatted message. In the initializer for <span class="literal">TParam</span> <span class="literal">Error</span>, we pass the offending <em>t</em> value, and in the special method <span class="literal">__str__</span>, we return the actual message. Recall that a class may define the <span class="literal">__str__</span> method to provide a textual (string) representation of the instance when it’s called.</p>&#13;
<p class="indent">To see how it prints the message, try the following in the console:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">from geom2d import tparam</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">tparam.ensure_valid(10.5)</span>&#13;
Traceback (most recent call last):&#13;
  <span class="codeitalic1">--snip--</span>&#13;
geom2d.tparam.TParamError: Expected t to be in [0, 1] but was 10.5</pre>&#13;
<p class="noindent">The error message is nice and clear:</p>&#13;
<pre>Expected t to be in [0, 1] but was 10.5</pre>&#13;
<p class="indent">Let’s use this validation in the <span class="literal">point_at</span> method from the <span class="literal">Segment</span> class. First, import the module in your <em>segment.py</em> file:</p>&#13;
<pre>from geom2d import tparam</pre>&#13;
<p class="indent">Go back to <em>segment.py</em> and refactor <span class="literal">point_at(t)</span> to include the validation, as in <a href="ch05.xhtml#ch5lis10">Listing 5-10</a>.</p>&#13;
<pre>def point_at(self, t: float):&#13;
    tparam.ensure_valid(t)&#13;
    return self.start.displaced(self.direction_vector, t)</pre>&#13;
<p class="caption"><a id="ch5lis10"/><em>Listing 5-10: Validating values of <span class="normal">t</span> in segment’s <span class="codeitalic1">point_at</span> method</em></p>&#13;
<p class="indent">Then refactor the <span class="literal">middle</span> property to remove the 0.5 magic number as shown in <a href="ch05.xhtml#ch5lis11">Listing 5-11</a>.</p>&#13;
<pre>@property&#13;
def middle(self):&#13;
    return self.point_at(tparam.MIDDLE)</pre>&#13;
<p class="caption"><a id="ch5lis11"/><em>Listing 5-11: Removing the magic number from our middle point computation</em></p>&#13;
<p class="indent">If you followed along, your <em>segment.py</em> file should look like <a href="ch05.xhtml#ch5lis12">Listing 5-12</a>.</p>&#13;
<pre>from geom2d import tparam&#13;
from geom2d.point import Point&#13;
from geom2d.vectors import make_vector_between, make_versor_between&#13;
&#13;
&#13;
<span epub:type="pagebreak" id="page_112"/>class Segment:&#13;
    def __init__(self, start: Point, end: Point):&#13;
        self.start = start&#13;
        self.end = end&#13;
&#13;
    @property&#13;
    def direction_vector(self):&#13;
        return make_vector_between(self.start, self.end)&#13;
&#13;
    @property&#13;
    def direction_versor(self):&#13;
        return make_versor_between(self.start, self.end)&#13;
&#13;
    @property&#13;
    def normal_versor(self):&#13;
        return self.direction_versor.perpendicular()&#13;
&#13;
    @property&#13;
    def length(self):&#13;
        return self.start.distance_to(self.end)&#13;
&#13;
    def point_at(self, t: float):&#13;
        tparam.ensure_valid(t)&#13;
        return self.start.displaced(self.direction_vector, t)&#13;
&#13;
    @property&#13;
    def middle(self):&#13;
        return self.point_at(tparam.MIDDLE)</pre>&#13;
<p class="caption"><a id="ch5lis12"/><em>Listing 5-12: The <span class="codeitalic1">Segment</span> class</em></p>&#13;
<p class="indent">With our <span class="literal">Segment</span> class complete, let’s write some tests.</p>&#13;
<h5 class="h5" id="ch00lev3sec29"><strong>Unit Testing Segment Points</strong></h5>&#13;
<p class="noindent">Since we’ll use <span class="literal">point_at</span> as part of more complex computations, we really want to make sure it works, so let’s start with a test to assert that if it passes a wrong value of <em>t</em>, an exception is actually raised. This gives us the opportunity to learn a new assertion method: <span class="literal">assertRaises</span>.</p>&#13;
<p class="indent">In the file <em>segment_test.py</em>, start by importing the <em>tparam</em> module:</p>&#13;
<pre>from geom2d import tparam</pre>&#13;
<p class="noindent">Then write the test in <a href="ch05.xhtml#ch5lis13">Listing 5-13</a>.</p>&#13;
<pre>class TestSegment(unittest.TestCase):&#13;
&#13;
    start = Point(400, 0)&#13;
    end = Point(0, 400)&#13;
    <span epub:type="pagebreak" id="page_113"/>segment = Segment(start, end)&#13;
&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
    def test_point_at_wrong_t(self):&#13;
        self.assertRaises(&#13;
         <span class="ent">➊</span> tparam.TParamError,&#13;
         <span class="ent">➋</span> self.segment.point_at,&#13;
         <span class="ent">➌</span> 56.7&#13;
        )</pre>&#13;
<p class="caption"><a id="ch5lis13"/><em>Listing 5-13: Testing wrong values of <span class="codeitalic1">t</span></em></p>&#13;
<p class="indent">This assertion is a bit more complex than the ones we’ve seen so far. We are passing it three arguments. First is the expected exception to be raised (<span class="literal">TParamError</span>) <span class="ent">➊</span>. Second, we pass the method that is expected to raise the exception <span class="ent">➋</span>. Last, we pass the arguments to be passed into the previous method (<span class="literal">point_at</span> in this case) as comma-separated arguments <span class="ent">➌</span>.</p>&#13;
<p class="indent">The assertion can be read as follows:</p>&#13;
<p class="pre2">assert that method 'point_at' from instance 'self.segment'<br/>raises an exception of type 'tparam.TParamError'<br/>when called with arguments '56.7'</p>&#13;
<p class="indent">If <span class="literal">point_at</span> accepted more than one argument, you would include them as arguments of <span class="literal">assertRaises</span>. Now, let’s include the two test cases from <a href="ch05.xhtml#ch5lis14">Listing 5-14</a>.</p>&#13;
<pre>class TestSegment(unittest.TestCase):&#13;
&#13;
    start = Point(400, 0)&#13;
    end = Point(0, 400)&#13;
    segment = Segment(start, end)&#13;
&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
    def test_point_at(self):&#13;
        t = tparam.make(0.25)&#13;
        expected = Point(300, 100)&#13;
        actual = self.segment.point_at(t)&#13;
        self.assertEqual(expected, actual)&#13;
&#13;
    def test_middle_point(self):&#13;
        expected = Point(200, 200)&#13;
        actual = self.segment.middle&#13;
        self.assertEqual(expected, actual)</pre>&#13;
<p class="caption"><a id="ch5lis14"/><em>Listing 5-14: Testing the <span class="codeitalic1">point_at</span> method</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_114"/>In the first test case, we ensure that a middle point for a valid <em>t</em> value, 0.25 in this case, yields the expected point. Using <a href="ch05.xhtml#ch05eqa04">Equation 5.4</a>, this point can be computed as follows:</p>&#13;
<div class="equationc"><img src="../images/f0114-01.jpg" alt="Image"/></div>&#13;
<p class="indent">The second test is for the <span class="literal">middle</span> attribute, which computes the point at <em>t</em> = 0.5. Take a pen and some paper and make sure point (200, 200) is right in our test. Then run all the tests in the <em>segment_test.py</em> file to make sure all of them pass. You can do this from the console as follows:</p>&#13;
<pre>$  <span class="codestrong1">python3 -m unittest geom2d/segment_test.py</span></pre>&#13;
<h4 class="h4" id="ch00lev2sec61"><strong><em>Closest Point</em></strong></h4>&#13;
<p class="noindent">Now suppose we want to know what the segment’s point is that is closest to an outside point. If the outside point is not aligned with the segment, that is, a line perpendicular to the segment going through the point doesn’t intersect with the segment, then the closest point has to be one of the two end points: <em>S</em> or <em>E</em>. If, on the other hand, the point is aligned with the segment, the intersection between the perpendicular line and the segment itself yields the closest point. <a href="ch05.xhtml#ch5fig6">Figure 5-6</a> illustrates this.</p>&#13;
<div class="image"><img src="../images/05fig06.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch5fig6"><em>Figure 5-6: A segment’s closest points</em></p>&#13;
<p class="indent">In the figure, point <em>S</em> ≡ <em>A′</em> is the closest point to <em>A</em>, point <em>E</em> ≡ <em>B′</em> is the closest point to <em>B</em>, and <em>C′</em> is the closest point to <em>C</em>. Let’s see how we can implement this procedure.</p>&#13;
<h5 class="h5" id="ch00lev3sec30"><strong>The Algorithm</strong></h5>&#13;
<p class="noindent">With the help of the method <span class="literal">projection_over</span> from <a href="ch04.xhtml#ch04">Chapter 4</a>, we can find the closest point easily. We’ll use <em>P</em> as the external point, <em>l</em> as the length of the segment, and the various points, segments, and vectors in <a href="ch05.xhtml#ch5fig7">Figure 5-7</a>.</p>&#13;
<div class="image"><img src="../images/05fig07.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch5fig7"><em>Figure 5-7: Auxiliary vectors for the algorithm that computes a segment’s closest point</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_115"/>The algorithm is as follows:</p>&#13;
<ol>&#13;
<li class="noindent">Compute a vector <img class="inline" src="../images/vvictorit.jpg" alt="Image"/> going from segment’s <em>S</em>  to external point <em>P</em>.</li>&#13;
<li class="noindent">Compute the projection of <img class="inline" src="../images/vvictorit.jpg" alt="Image"/>  over the segment’s direction versor, <img class="inline" src="../images/dcapit.jpg" alt="Image"/>.</li>&#13;
<li class="noindent">Depending on the value of the projection, call it <em>v</em><sub><em>s</em></sub>.  The closest point <em>P′</em>  can be calculated using <a href="ch05.xhtml#ch05eqa06">Equation 5.6</a>.</li>&#13;
</ol>&#13;
<div class="equationc" id="ch05eqa06"><img src="../images/05eqa06.jpg" alt="Image"/></div>&#13;
<p class="indent">If the value of the projection <em>v</em><sub><em>s</em></sub> is negative, the projection lies outside the segment on <em>S</em>’s side; hence, the closest point is <em>S</em>. For numbers greater than <em>l</em>, the projection over the segment’s direction is longer than the segment itself. Thus, the result is the end point <em>E</em>. For any value of <em>v</em><sub><em>s</em></sub> in the closed range [0,<em>l</em>], we obtain the point by displacing <em>S</em> in the direction of <img class="inline" src="../images/dcapit.jpg" alt="Image"/> <em>v</em><sub><em>s</em></sub> times. <a href="ch05.xhtml#ch5fig7">Figure 5-7</a> depicts this last case where the external point <em>P</em> is aligned with the segment.</p>&#13;
<p class="indent">The code for this operation is in <a href="ch05.xhtml#ch5lis15">Listing 5-15</a>.</p>&#13;
<pre>class Segment:&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
   def closest_point_to(self, p: Point):&#13;
       v = make_vector_between(self.start, p)&#13;
       d = self.direction_versor&#13;
       vs = v.projection_over(d)&#13;
&#13;
       if vs &lt; 0:&#13;
           return self.start&#13;
&#13;
       if vs &gt; self.length:&#13;
           return self.end&#13;
&#13;
       return self.start.displaced(d, vs)</pre>&#13;
<p class="caption"><a id="ch5lis15"/><em>Listing 5-15: Closest point to a segment</em></p>&#13;
<p class="indent">We start by computing vector <img class="inline" src="../images/vvictorit.jpg" alt="Image"/>. We then get <em>v</em><sub><em>s</em></sub>: the projection of <img class="inline" src="../images/vvictorit.jpg" alt="Image"/> over the segment’s direction versor <img class="inline" src="../images/dcapit.jpg" alt="Image"/>. If <em>v</em><sub><em>s</em></sub> is smaller than zero, we return the start point. If greater than the length of the segment, we return the end point; otherwise, we compute the displacement of the start point that yields the resulting point on the segment.</p>&#13;
<h5 class="h5" id="ch00lev3sec31"><strong>Unit Testing Closest Points</strong></h5>&#13;
<p class="noindent">Let’s test the three different cases defined earlier, namely, <em>v</em><sub><em>s</em></sub> &lt; 0, <em>v</em><sub><em>s</em></sub> &gt; <em>l</em>, and 0 &lt; <em>v</em><sub><em>s</em></sub> &lt; <em>l</em>. <a href="ch05.xhtml#ch5lis16">Listing 5-16</a> shows the code for the tests.<span epub:type="pagebreak" id="page_116"/></p>&#13;
<pre>class TestSegment(unittest.TestCase):&#13;
&#13;
    start = Point(400, 0)&#13;
    end = Point(0, 400)&#13;
    segment = Segment(start, end)&#13;
&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
    def test_closest_point_is_start(self):&#13;
        p = Point(500, 20)&#13;
        expected = self.start&#13;
        actual = self.segment.closest_point_to(p)&#13;
        self.assertEqual(expected, actual)&#13;
&#13;
    def test_closest_point_is_end(self):&#13;
        p = Point(20, 500)&#13;
        expected = self.end&#13;
        actual = self.segment.closest_point_to(p)&#13;
        self.assertEqual(expected, actual)&#13;
&#13;
    def test_closest_point_is_middle(self):&#13;
        p = Point(250, 250)&#13;
        expected = Point(200, 200)&#13;
        actual = self.segment.closest_point_to(p)&#13;
        self.assertEqual(expected, actual)</pre>&#13;
<p class="caption"><a id="ch5lis16"/><em>Listing 5-16: Testing a segment’s closest point</em></p>&#13;
<p class="indent">To better understand the tests, it may be a good exercise to draw the segment and each of the external points by hand to see whether you can figure out why the expected results have the values they have. Your drawing should look similar to <a href="ch05.xhtml#ch5fig8">Figure 5-8</a>. Furthermore, trying to solve the three cases by hand will presumably give you some insight into the algorithm.</p>&#13;
<div class="image"><img src="../images/05fig08.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch5fig8"><em>Figure 5-8: The segment’s closest points and their test cases</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_117"/>Don’t forget to run all tests and make sure they all succeed. You can do this from the console as follows:</p>&#13;
<pre>$ <span class="codestrong1">python3 -m unittest geom2d/segment_test.py</span></pre>&#13;
<h4 class="h4" id="ch00lev2sec62"><strong><em>Distance to a Point</em></strong></h4>&#13;
<p class="noindent">Now that we know the closest point in the segment to an external point, we can easily compute the distance between it and the segment. Enter the method in <a href="ch05.xhtml#ch5lis17">Listing 5-17</a>.</p>&#13;
<pre>class Segment:&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
   def distance_to(self, p: Point):&#13;
       return p.distance_to(&#13;
           self.closest_point_to(p)&#13;
       )</pre>&#13;
<p class="caption"><a id="ch5lis17"/><em>Listing 5-17: Computing the distance from a point to the segment</em></p>&#13;
<p class="indent">As you can see in the code, the distance between the segment and any given external point is the distance between the point and that in the segment that is closest to it. Simple, isn’t it?</p>&#13;
<h4 class="h4" id="ch00lev2sec63"><strong><em>Segment Intersections</em></strong></h4>&#13;
<p class="noindent">Now we get to the fun stuff. How do we test whether two segments intersect? If they do intersect, how do we compute the intersection point? Consider the cases from <a href="ch05.xhtml#ch5fig9">Figure 5-9</a>.</p>&#13;
<div class="image"><img src="../images/05fig09.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch5fig9"><em>Figure 5-9: Possible segment intersection cases</em></p>&#13;
<p class="indent">The two cases from the left column have no intersection, but there is a difference between them. In the first case, the direction vectors of the segments are parallel (<img class="inline" src="../images/d1victorit.jpg" alt="Image"/> × <img class="inline" src="../images/d2victorit.jpg" alt="Image"/> = 0). Thus, it’s easy to know there will be no intersection. In the other case, if instead of segments we had infinite lines, there <span epub:type="pagebreak" id="page_118"/>would be an intersection point. It might be far from where the segments are, but there’d be one nonetheless. As we’ll see in the following equations, we’ll have to compute the intersection point as if we were working with lines and then ensure the point lies inside both segments.</p>&#13;
<p class="indent">In the upper-right case, the two segments overlap; hence, there is more than one intersection point—an infinite number, to be precise. For our analysis we’ll define two possible cases: segments either have an intersection point or don’t intersect at all (we won’t be considering the upper-right case). We’ll forget about the overlapping case since we won’t be needing it for our applications, and we want simplified code.</p>&#13;
<h5 class="h5" id="ch00lev3sec32"><strong>Overlapping Segments</strong></h5>&#13;
<p class="noindent">If we were to include the case where the segments overlap, the return object for the intersection function could be either a <span class="literal">Point</span> or a <span class="literal">Segment</span>. A function that returns different object types is hard to work with. Once we have the result, we’d need to check what type of object we got and act accordingly. This could look as follows:</p>&#13;
<pre>result = seg_a.intersection_with(seg_b)&#13;
&#13;
if type(result) is Point:&#13;
    # intersection is a point&#13;
elif type(result) is Segment:&#13;
    # intersection is a segment&#13;
else:&#13;
    # no intersection</pre>&#13;
<p class="indent">But this code is messy. There are better ways of handling this logic, but we won’t get into it, as for us there will be either an intersection point or no intersection at all. That will make our code simpler and easier to work with.</p>&#13;
<p class="indent">Let’s take a look at the algorithm.</p>&#13;
<h5 class="h5" id="ch00lev3sec33"><strong>The Algorithm</strong></h5>&#13;
<p class="noindent">Let’s find the intersection point of a case like the one in the lower right of <a href="ch05.xhtml#ch5fig9">Figure 5-9</a>. Say we have two segments:</p>&#13;
<ul>&#13;
<li class="noindent">Segment 1 with start point <em>S</em><sub>1</sub> and end point <em>E</em><sub>1</sub></li>&#13;
<li class="noindent">Segment 2 with start point <em>S</em><sub>2</sub> and end point <em>E</em><sub>2</sub></li>&#13;
</ul>&#13;
<p class="noindent">We can compute every point in segment 1, let’s call it <em>P</em><sub>1</sub>, using the following expression,</p>&#13;
<div class="equationc"><img src="../images/f0118-01.jpg" alt="Image"/></div>&#13;
<p class="noindent">where <em>t</em><sub>1</sub> is the parameter that goes from 0 to 1 and <img class="inline" src="../images/d1victorit.jpg" alt="Image"/> is the direction vector (not versor) for the segment. Similarly, here is segment 2:</p>&#13;
<div class="equationc"><img src="../images/f0118-02.jpg" alt="Image"/></div>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_119"/>To find the intersection point, we have to look for a pair of values <em>t</em><sub>1</sub> and <em>t</em><sub>2</sub> such that <em>P</em><sub>1</sub>(<em>t</em><sub>1</sub>) = <em>P</em><sub>2</sub>(<em>t</em><sub>2</sub>):</p>&#13;
<div class="equationc"><img src="../images/f0119-01.jpg" alt="Image"/></div>&#13;
<p class="noindent">If both segments intersect, plugging those <em>t</em> parameter values in their respective segment expressions should result in the same point, the intersection point <em>P</em>. Let’s rewrite the expression in its vector form:</p>&#13;
<div class="equationc"><img src="../images/f0119-02.jpg" alt="Image"/></div>&#13;
<p class="noindent">We can use this form to obtain a scalar system of two equations and two unknowns, <em>t</em><sub>1</sub> and <em>t</em><sub>2</sub>:</p>&#13;
<div class="equationc"><img src="../images/f0119-03.jpg" alt="Image"/></div>&#13;
<p class="noindent">I’ll spare you the details and give you the result, though it may be a good exercise to solve the system yourself for <em>t</em><sub>1</sub> and <em>t</em><sub>2</sub>. The final expressions for the <em>t</em> parameters are as shown in <a href="ch05.xhtml#ch05eqa07">Equations 5.7</a> and <a href="ch05.xhtml#ch05eqa08">5.8</a>.</p>&#13;
<div class="equationc" id="ch05eqa07"><img src="../images/05eqa07.jpg" alt="Image"/></div>&#13;
<div class="equationc" id="ch05eqa08"><img src="../images/05eqa08.jpg" alt="Image"/></div>&#13;
<p class="indent">Here, Δ<em>S</em><sub><em>x</em></sub> = <em>S</em><sub>2<em>x</em></sub> <em>– S</em><sub>1<em>x</em></sub>, Δ<em>S</em><sub><em>y</em></sub> = <em>S</em><sub>2<em>y</em></sub> <em>– S</em><sub>1<em>y</em></sub>, and <img class="inline" src="../images/f00119-p1.jpg" alt="Image"/>. Note that these formulas would yield <em>∞</em> if the segments were parallel <img class="inline" src="../images/f00119-p2.jpg" alt="Image"/>. We can’t attempt a division by zero; that would raise an exception in our Python code, so we’ll need to detect this case before we try to compute the values of <em>t</em><sub>1</sub> and <em>t</em><sub>2</sub>.</p>&#13;
<p class="indent">With these two values computed for the case where segments were not parallel, we have two possible outcomes:</p>&#13;
<ul>&#13;
<li class="noindent">Values <em>t</em><sub>1</sub>  and <em>t</em><sub>2</sub>  are both inside range [0, 1].  The intersection point belongs to both segments.</li>&#13;
<li class="noindent">One or both of <em>t</em><sub>1</sub>  and <em>t</em><sub>2</sub>  are outside range [0, 1]. The intersection point is outside of at least one of the segments.</li>&#13;
</ul>&#13;
<p class="indent">Now we’re ready to implement the logic in an algorithm. In your <em>segment.py</em> file, implement the <span class="literal">intersection_with</span> method as shown in <a href="ch05.xhtml#ch5lis18">Listing 5-18</a>.</p>&#13;
<pre>class Segment:&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
    def intersection_with(self, other):&#13;
        d1, d2 = self.direction_vector, other.direction_vector&#13;
&#13;
        <span epub:type="pagebreak" id="page_120"/>if d1.is_parallel_to(d2):&#13;
            return None&#13;
&#13;
        cross_prod = d1.cross(d2)&#13;
        delta = other.start - self.start&#13;
        t1 = (delta.u * d2.v - delta.v * d2.u) / cross_prod&#13;
        t2 = (delta.u * d1.v - delta.v * d1.u) / cross_prod&#13;
&#13;
        if tparam.is_valid(t1) and tparam.is_valid(t2):&#13;
            return self.point_at(t1)&#13;
        else:&#13;
            return None</pre>&#13;
<p class="caption"><a id="ch5lis18"/><em>Listing 5-18: Intersection between two segments</em></p>&#13;
<p class="indent">We start by storing both segments’ direction vectors in the variables <span class="literal">d1</span> and <span class="literal">d2</span> using Python’s multiple assignment. With the multiple assignment, several values can be assigned to variables at once. Then we check whether the directions are parallel, in which case we return <span class="literal">None</span>. If we find the segments aren’t parallel, we compute <img class="inline" src="../images/f00120-p1.jpg" alt="Image"/> and Δ<em>S</em> and store them in the variables <span class="literal">cross_prod</span> and <span class="literal">delta</span>. With the help of these values, we then compute <em>t</em><sub>1</sub> and <em>t</em><sub>2</sub>. If these values are inside their valid range, we then return the resulting intersection point by calling <span class="literal">point_at</span> on the current <span class="literal">Segment</span> object (<span class="literal">self</span>). Make sure you understand that we could have computed <em>P</em> using <em>t</em><sub>2</sub> and called <span class="literal">point_at</span> on <span class="literal">other</span>. The result would’ve been the same.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Similarly to other languages such as Java or C# with</em> <span class="literal">null</span><em>, one should use</em> <span class="literal">None</span> <em>judiciously. Use it for cases where having an empty-like value is a perfectly valid outcome. For instance, in our</em> <span class="literal">intersection_with</span> <em>method,</em> <span class="literal">None</span> <em>represents the case where there exists no intersection point.</em></p>&#13;
</div>&#13;
<h5 class="h5" id="ch00lev3sec34"><strong>Unit Testing Segment Intersections</strong></h5>&#13;
<p class="noindent">As we advance with the book material and our code becomes more complex, testing these code fragments will become more involved. The method we just wrote for computing intersection between segments has a couple of branches or paths the execution can take. With the objective of being as exhaustive as possible with our unit tests, let’s compile every case we want covered (see <a href="ch05.xhtml#ch5tab1">Table 5-1</a>).</p>&#13;
<p class="tabcap" id="ch5tab1"><strong>Table 5-1:</strong> Segment Intersection Algorithm Outcomes</p>&#13;
<table class="all">&#13;
<tbody><tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Segment Directions</strong></p>&#13;
</td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="taba">t<sub>1</sub></p>&#13;
</td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="taba">t<sub>2</sub></p>&#13;
</td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Intersection Result</strong></p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba"><img class="inline" src="../images/f00120-p2.jpg" alt="Image"/></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="taba">—</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="taba">—</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">None</span></p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba"><img class="inline" src="../images/f00120-p3.jpg" alt="Image"/></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="taba">Out of range</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="taba">Out of range</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">None</span></p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba"><img class="inline" src="../images/f00120-p3.jpg" alt="Image"/></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="taba">In range</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="taba">Out of range</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">None</span></p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba"><img class="inline" src="../images/f00120-p3.jpg" alt="Image"/></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="taba">Out of range</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="taba">In range</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">None</span></p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-hs1"><p class="taba"><img class="inline" src="../images/f00120-p3.jpg" alt="Image"/></p>&#13;
</td>&#13;
<td style="vertical-align: top;" class="table-hs1"><p class="taba">In range</p>&#13;
</td>&#13;
<td style="vertical-align: top;" class="table-hs1"><p class="taba">In range</p>&#13;
</td>&#13;
<td style="vertical-align: top;" class="table-hs1"><p class="taba"><img class="inline" src="../images/f00120-p4.jpg" alt="Image"/></p>&#13;
</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_121"/>We’ll be writing unit tests for the first and last cases from <a href="ch05.xhtml#ch5tab1">Table 5-1</a>; I’ll leave the other three as an exercise for you. In file <em>segment_test.py</em>, include the tests in <a href="ch05.xhtml#ch5lis19">Listing 5-19</a> in the <span class="literal">TestSegment</span>class.</p>&#13;
<pre>class TestSegment(unittest.TestCase):&#13;
&#13;
    start = Point(400, 0)&#13;
    end = Point(0, 400)&#13;
    segment = Segment(start, end)&#13;
&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
    def test_parallel_segments_no_intersection(self):&#13;
        other = Segment(Point(200, 0), Point(0, 200))&#13;
        actual = self.segment.intersection_with(other)&#13;
        self.assertIsNone(actual)&#13;
&#13;
    def test_segments_intersection(self):&#13;
        other = Segment(Point(0, 0), Point(400, 400))&#13;
        expected = Point(200, 200)&#13;
        actual = self.segment.intersection_with(other)&#13;
        self.assertEqual(expected, actual)</pre>&#13;
<p class="caption"><a id="ch5lis19"/><em>Listing 5-19: Testing segment intersections</em></p>&#13;
<p class="indent">So, in the first test, we construct a parallel segment and assert that the intersection between the two is <span class="literal">None</span> with the assertion <span class="literal">assertIsNone</span>, which checks that the passed-in value is <span class="literal">None</span>. In the second, we construct a segment perpendicular to the first one that intersects it at (200, 200) and assert we get that point as the result. You can run all the tests in the file from the IDE by clicking the green play button or from the console as follows:</p>&#13;
<pre>$ <span class="codestrong1">python3 -m unittest geom2d/segment_test.py</span></pre>&#13;
<p class="indent">Can you come up with the segments needed for the other three cases?</p>&#13;
<h4 class="h4" id="ch00lev2sec64"><strong><em>Equality and String Representation</em></strong></h4>&#13;
<p class="noindent">Just as we did with the <span class="literal">Point</span> and <span class="literal">Vector</span> classes, we want to overload the <span class="literal">==</span> operator so that Python understands two segments with equal start and end points as logically equal, and we want to implement a <span class="literal">__str__</span> method so we can get a nice string representation of the segment. Enter the code in <a href="ch05.xhtml#ch5lis20">Listing 5-20</a> in the <em>segment.py</em> file.</p>&#13;
<pre>class Segment:&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
   def __eq__(self, other):&#13;
       if self is other:&#13;
           return True&#13;
&#13;
       <span epub:type="pagebreak" id="page_122"/>if not isinstance(other, Segment):&#13;
           return False&#13;
&#13;
       return self.start == other.start \&#13;
              and self.end == other.end&#13;
&#13;
   def __str__(self):&#13;
       return f'segment from {self.start} to {self.end}'</pre>&#13;
<p class="caption"><a id="ch5lis20"/><em>Listing 5-20: Equality of segments and string representation</em></p>&#13;
<p class="indent">We’ll add one last property once we’ve developed the <span class="literal">Line</span> class. If you followed along, your <span class="literal">Segment</span> class should look similar to <a href="ch05.xhtml#ch5lis21">Listing 5-21</a>.</p>&#13;
<pre>from geom2d import tparam&#13;
from geom2d.point import Point&#13;
from geom2d.vectors import make_vector_between, make_versor_between&#13;
&#13;
&#13;
class Segment:&#13;
    def __init__(self, start: Point, end: Point):&#13;
        self.start = start&#13;
        self.end = end&#13;
&#13;
    @property&#13;
    def direction_vector(self):&#13;
        return make_vector_between(self.start, self.end)&#13;
&#13;
    @property&#13;
    def direction_versor(self):&#13;
        return make_versor_between(self.start, self.end)&#13;
&#13;
    @property&#13;
    def normal_versor(self):&#13;
        return self.direction_versor.perpendicular()&#13;
&#13;
    @property&#13;
    def length(self):&#13;
        return self.start.distance_to(self.end)&#13;
&#13;
    def point_at(self, t: float):&#13;
        tparam.ensure_valid(t)&#13;
        return self.start.displaced(self.direction_vector, t)&#13;
&#13;
    @property&#13;
    def middle(self):&#13;
        return self.point_at(tparam.MIDDLE)&#13;
&#13;
    <span epub:type="pagebreak" id="page_123"/>def closest_point_to(self, p: Point):&#13;
        v = make_vector_between(self.start, p)&#13;
        d = self.direction_versor&#13;
        vs = v.projection_over(d)&#13;
&#13;
        if vs &lt; 0:&#13;
            return self.start&#13;
&#13;
        if vs &gt; self.length:&#13;
            return self.end&#13;
&#13;
        return self.start.displaced(d, vs)&#13;
&#13;
    def distance_to(self, p: Point):&#13;
        return p.distance_to(&#13;
            self.closest_point_to(p)&#13;
        )&#13;
&#13;
    def intersection_with(self, other):&#13;
        d1, d2 = self.direction_vector, other.direction_vector&#13;
&#13;
        if d1.is_parallel_to(d2):&#13;
            return None&#13;
&#13;
        cross_prod = d1.cross(d2)&#13;
        delta = other.start - self.start&#13;
        t1 = (delta.u * d2.v - delta.v * d2.u) / cross_prod&#13;
        t2 = (delta.u * d1.v - delta.v * d1.u) / cross_prod&#13;
&#13;
        if tparam.is_valid(t1) and tparam.is_valid(t2):&#13;
            return self.point_at(t1)&#13;
        else:&#13;
            return None&#13;
&#13;
    def __eq__(self, other):&#13;
        if self is other:&#13;
            return True&#13;
&#13;
        if not isinstance(other, Segment):&#13;
            return False&#13;
&#13;
        return self.start == other.start \&#13;
               and self.end == other.end&#13;
&#13;
    def __str__(self):&#13;
        return f'segment from {self.start} to {self.end}'</pre>&#13;
<p class="caption"><a id="ch5lis21"/><em>Listing 5-21: The <span class="codeitalic1">Segment</span> class</em></p>&#13;
<h3 class="h3" id="ch00lev1sec36"><span epub:type="pagebreak" id="page_124"/><strong>Line Class</strong></h3>&#13;
<p class="noindent">An infinite line can be described by a base point <em>B</em> and a direction vector <img class="inline" src="../images/dvictorit.jpg" alt="Image"/>, like that in <a href="ch05.xhtml#ch5fig10">Figure 5-10</a>.</p>&#13;
<div class="image"><img src="../images/05fig10.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch5fig10"><em>Figure 5-10: A line with a base point B and direction vector <img class="inline" src="../images/dvictor_normal.jpg" alt="Image"/></em></p>&#13;
<p class="indent">Lines are useful helper primitives; with them we can build more complex geometries and operations. One common usage of lines, for example, is finding where two nonparallel directions intersect. You’ll see in the next chapter how operations such as constructing a circle out of three points are effortless using line intersections.</p>&#13;
<p class="indent">Let’s create a new <span class="literal">Line</span> class with these two properties: a base point and a direction. In the <em>geom2d</em> package, add a new file named <em>line.py</em> and enter the code in <a href="ch05.xhtml#ch5lis22">Listing 5-22</a>.</p>&#13;
<pre>from geom2d.point import Point&#13;
from geom2d.vector import Vector&#13;
&#13;
&#13;
class Line:&#13;
    def __init__(self, base: Point, direction: Vector):&#13;
        self.base = base&#13;
        self.direction = direction</pre>&#13;
<p class="caption"><a id="ch5lis22"/><em>Listing 5-22: Line initialization</em></p>&#13;
<p class="indent">The initializer sets our properties <span class="literal">base</span> and <span class="literal">direction</span> based on the values passed into their corresponding arguments. Like before, we’ve typed the <span class="literal">base</span> and <span class="literal">direction</span> arguments so our IDE can warn us of any potential errors.</p>&#13;
<p class="indent">Let’s now provide two methods that check whether a line is parallel or perpendicular to another line (<a href="ch05.xhtml#ch5lis23">Listing 5-23</a>).</p>&#13;
<pre>class Line:&#13;
   <span class="codeitalic1">--snip--</span>&#13;
&#13;
   def is_parallel_to(self, other):&#13;
       return self.direction.is_parallel_to(other.direction)&#13;
&#13;
   def is_perpendicular_to(self, other):&#13;
       return self.direction.is_perpendicular_to(other.direction)</pre>&#13;
<p class="caption"><a id="ch5lis23"/><em>Listing 5-23: Checking whether lines are parallel or perpendicular</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_125"/>We didn’t implement these methods for <span class="literal">Segment</span>, because our concern was with the segment’s infinite points and how they’re located in the plane; here, on the other hand, we’re working with directions. Working with directions requires knowledge of their relative positioning; Are they parallel? Are they perpendicular?</p>&#13;
<p class="indent">With lines, the question is usually about how they are positioned with respect to other lines; with segments, the question is usually about how they are positioned themselves.</p>&#13;
<p class="indent">To check whether two lines are parallel, we could simply access their <span class="literal">direction</span> properties and use their methods like so:</p>&#13;
<pre>d1 = line_one.direction&#13;
d2 = line_two.direction&#13;
d1.is_parallel_to(d2)</pre>&#13;
<p class="indent">This is definitely possible, but it’s not considered good practice. There is a guideline commonly known as the <em>principle of least knowledge</em> or <em>law of Demeter</em>, which states that “you should only talk to your immediate friends.” In this case, as we are working with lines, lines are our immediate friends. The <span class="literal">Line</span> properties base point and direction vector are not our immediate friends; thus, we shouldn’t ask them for stuff. If we need something from them, we have to ask our immediate friend, the <span class="literal">Line</span> holding such properties, to do it for us.</p>&#13;
<p class="indent">So, here’s how we should check whether two lines are parallel or perpendicular:</p>&#13;
<pre>line_one.is_parallel_to(line_two)</pre>&#13;
<p class="indent">Let’s also include two more methods to create new lines that are perpendicular or parallel to an existing line and that go through a point. In your file, enter the code in <a href="ch05.xhtml#ch5lis24">Listing 5-24</a>.</p>&#13;
<pre>from geom2d.point import Point&#13;
from geom2d.vector import Vector&#13;
&#13;
&#13;
class Line:&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
    def perpendicular_through(self, point: Point):&#13;
        return Line(point, self.direction.perpendicular())&#13;
&#13;
    def parallel_through(self, point: Point):&#13;
        return Line(point, self.direction)</pre>&#13;
<p class="caption"><a id="ch5lis24"/><em>Listing 5-24: Creating perpendicular and parallel lines</em></p>&#13;
<p class="indent">The method <span class="literal">perpendicular_through</span> receives <span class="literal">point</span> as an argument and returns a new line, which uses that base point and direction vector <span epub:type="pagebreak" id="page_126"/>perpendicular to the original line. Similarly, <span class="literal">parallel_through</span> constructs a new line with the given base point but using the same direction vector as the original line.</p>&#13;
<h4 class="h4" id="ch00lev2sec65"><strong><em>Line Intersections</em></strong></h4>&#13;
<p class="noindent">A general algorithm to compute the intersection between two segments was explained in depth earlier in the chapter. The algorithm was based on the start point and direction vector of segments but can be extended to work with lines by using the base point of the line instead of the start point of the segment. The nice thing is that in the case of lines, parameters <em>t</em><sub>1</sub> and <em>t</em><sub>2</sub> are not bounded to range [0, 1]; they can go from <em>– ∞</em> to <em>∞</em>.</p>&#13;
<p class="indent">If we rewrite <a href="ch05.xhtml#ch05eqa07">Equations 5.7</a> and <a href="ch05.xhtml#ch05eqa08">5.8</a> for lines, we get <a href="ch05.xhtml#ch05eqa09">Equations 5.9</a> and <a href="ch05.xhtml#ch05eqa10">5.10</a>.</p>&#13;
<div class="equationc" id="ch05eqa09"><img src="../images/05eqa09.jpg" alt="Image"/></div>&#13;
<div class="equationc" id="ch05eqa10"><img src="../images/05eqa10.jpg" alt="Image"/></div>&#13;
<p class="indent">In this case, Δ<em>B</em><sub><em>x</em></sub> = <em>B</em><sub>2<em>x</em></sub> <em>– B</em><sub>1<em>x</em></sub>, and Δ<em>B</em><sub><em>y</em></sub> = <em>B</em><sub>2<em>y</em></sub> <em>– B</em><sub>1<em>y</em></sub>. For these formulas to yield the correct values, recall that <img class="inline" src="../images/f00119-p1.jpg" alt="Image"/>. Since the <em>t</em> values are not bounded anymore, there’s no need to compute both <em>t</em><sub>1</sub> and <em>t</em><sub>2</sub> and check whether they fall into the range [0, 1]. Computing one of them will suffice in getting the resulting intersection point. Let’s choose <a href="ch05.xhtml#ch05eqa09">Equation 5.9</a> to compute <em>t</em><sub>1</sub>. With <em>t</em><sub>1</sub>, we can determine the actual intersection point as follows:</p>&#13;
<div class="equationc"><img src="../images/f00126-p1.jpg" alt="Image"/></div>&#13;
<p class="indent">Implement method <span class="literal">intersection_with</span> in your <span class="literal">Line</span> class as in <a href="ch05.xhtml#ch5lis25">Listing 5-25</a>.</p>&#13;
<pre>from geom2d.point import Point&#13;
from geom2d.vector import Vector&#13;
<span class="codestrong1">from geom2d.vectors import make_vector_between</span>&#13;
&#13;
&#13;
class Line:&#13;
   <span class="codeitalic1">--snip--</span>&#13;
&#13;
   def intersection_with(self, other):&#13;
       if self.is_parallel_to(other):&#13;
           return None&#13;
&#13;
       d1, d2 = self.direction, other.direction&#13;
       cross_prod = d1.cross(d2)&#13;
       delta = make_vector_between(self.base, other.base)&#13;
       t1 = (delta.u * d2.v - delta.v * d2.u) / cross_prod&#13;
&#13;
       return self.base.displaced(d1, t1)</pre>&#13;
<p class="caption"><a id="ch5lis25"/><em>Listing 5-25: Calculating the intersection between two lines</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_127"/>The code looks similar to the algorithm in <span class="literal">Segment</span>, but it’s a bit simpler. To check for parallelism, we use the <span class="literal">self</span> method instead of using the directions. As we implemented <span class="literal">is_parallel_to</span> on the <span class="literal">Line</span> class, it makes sense to use it (and it helps the code read even better!).</p>&#13;
<h5 class="h5" id="ch00lev3sec35"><strong>Unit Testing Line Intersections</strong></h5>&#13;
<p class="noindent">Let’s make sure our tweaked algorithm works. Create a new file <em>line_test.py</em> and enter the test for the <span class="literal">Line</span> class in <a href="ch05.xhtml#ch5lis26">Listing 5-26</a>.</p>&#13;
<pre>import unittest&#13;
&#13;
from geom2d.line import Line&#13;
from geom2d.point import Point&#13;
from geom2d.vector import Vector&#13;
&#13;
&#13;
class TestLine(unittest.TestCase):&#13;
&#13;
    def test_parallel_lines_no_intersection(self):&#13;
        l1 = Line(Point(0, 0), Vector(1, 1))&#13;
        l2 = Line(Point(10, 10), Vector(1, 1))&#13;
        self.assertIsNone(l1.intersection_with(l2))&#13;
&#13;
    def test_lines_intersection(self):&#13;
        l1 = Line(Point(50, 0), Vector(0, 1))&#13;
        l2 = Line(Point(0, 30), Vector(1, 0))&#13;
        actual = l1.intersection_with(l2)&#13;
        expected = Point(50, 30)&#13;
        self.assertEqual(expected, actual)</pre>&#13;
<p class="caption"><a id="ch5lis26"/><em>Listing 5-26: Testing line intersections</em></p>&#13;
<p class="indent">In the first test, <span class="literal">test_parallel_lines_no_intersection</span>, we create two parallel lines with different base points but the same direction vectors. We then assert <span class="literal">intersection_with</span> returns <span class="literal">None</span>. The second test, <span class="literal">test_lines_intersection</span>, creates two lines, the first of which is vertical at <em>x</em> = 50 and the second horizontal at <em>y</em> = 30; hence, the intersection point is (50, 30).</p>&#13;
<p class="indent">Run the tests by clicking the green play button beside the class definition. You should see this in the console:</p>&#13;
<pre>Ran 2 tests in 0.001s&#13;
&#13;
OK&#13;
&#13;
Process finished with exit code 0</pre>&#13;
<p class="indent">You can also run the tests from the console:</p>&#13;
<pre>$  <span class="codestrong1">python3 -m unittest geom2d/line_test.py</span></pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_128"/><a href="ch05.xhtml#ch5lis27">Listing 5-27</a> contains all the code we wrote for the <span class="literal">Line</span> class.</p>&#13;
<pre>from geom2d.point import Point&#13;
from geom2d.vector import Vector&#13;
from geom2d.vectors import make_vector_between&#13;
&#13;
&#13;
class Line:&#13;
    def __init__(self, base: Point, direction: Vector):&#13;
        self.base = base&#13;
        self.direction = direction&#13;
&#13;
    def is_parallel_to(self, other):&#13;
        return self.direction.is_parallel_to(other.direction)&#13;
&#13;
    def is_perpendicular_to(self, other):&#13;
        return self.direction.is_perpendicular_to(other.direction)&#13;
&#13;
    def perpendicular_through(self, point: Point):&#13;
        return Line(point, self.direction.perpendicular())&#13;
&#13;
    def parallel_through(self, point: Point):&#13;
        return Line(point, self.direction)&#13;
&#13;
    def intersection_with(self, other):&#13;
        if self.is_parallel_to(other):&#13;
            return None&#13;
&#13;
        d1, d2 = self.direction, other.direction&#13;
        cross_prod = d1.cross(d2)&#13;
        delta = make_vector_between(self.base, other.base)&#13;
        t1 = (delta.u * d2.v - delta.v * d2.u) / cross_prod&#13;
&#13;
        return self.base.displaced(d1, t1)</pre>&#13;
<p class="caption"><a id="ch5lis27"/><em>Listing 5-27: The <span class="codeitalic1">Line</span> class</em></p>&#13;
<h3 class="h3" id="ch00lev1sec37"><strong>Segment’s Bisector</strong></h3>&#13;
<p class="noindent">Now that we have both segments and lines, we can implement a new attribute in <span class="literal">Segment</span>: its <em>bisector</em>. This attribute is the line going through the segment’s middle point <em>M</em> that’s perpendicular to it. <a href="ch05.xhtml#ch5fig11">Figure 5-11</a> illustrates this concept.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_129"/><img src="../images/05fig11.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch5fig11"><em>Figure 5-11: A segment’s bisector</em></p>&#13;
<p class="indent">Computing a bisector line for a segment is simple since we already have access to the segment’s middle point and normal versor (don’t forget to import the <span class="literal">Line</span> class), as shown in <a href="ch05.xhtml#ch5lis28">Listing 5-28</a>.</p>&#13;
<pre>from geom2d import tparam&#13;
<span class="codestrong1">from geom2d.line import Line</span>&#13;
from geom2d.point import Point&#13;
from geom2d.vectors import make_vector_between, make_versor_between&#13;
&#13;
&#13;
class Segment:&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
    @property&#13;
   def bisector(self):&#13;
       return Line(self.middle, self.normal_versor)</pre>&#13;
<p class="caption"><a id="ch5lis28"/><em>Listing 5-28: Segment’s bisector</em></p>&#13;
<p class="indent">In the next chapter, we’ll be using the bisectors of segments to create a circle passing through three points—a common way of obtaining circles in CAD software. In <a href="part03.xhtml#part03">Part III</a> of the book, we’ll create a program that computes a circle passing through three points and draws a beautiful image with captions indicating its center and radius.</p>&#13;
<h3 class="h3" id="ch00lev1sec38"><strong>Summary</strong></h3>&#13;
<p class="noindent">In this chapter, we used the <span class="literal">Point</span> and <span class="literal">Vector</span> classes to create two new primitives: <span class="literal">Segment</span> and <span class="literal">Line</span>. Both have a defined direction, and both represent a set of infinite aligned points, but segments are bounded between two points, whereas lines have no ends.</p>&#13;
<p class="indent">We also implemented a way of obtaining the infinite points in <span class="literal">Segment</span> using a parameter <em>t</em> that is defined in the range [0, 1]. There was no need to do the same for <span class="literal">Line</span>, as we’re not usually interested in what points make it up.</p>&#13;
<p class="indent">We then created two algorithms: we included a method in the <span class="literal">Segment</span> class that looks for its closest point to an external point. Although we didn’t implement it in <span class="literal">Line</span>, we could have done so. We used this method to compute the distance from a point to a segment. We also implemented an algorithm to compute intersections between two segments and two lines. These <span epub:type="pagebreak" id="page_130"/>intersections result in a point or the value <span class="literal">None</span> returned. Lastly, we used the <span class="literal">Line</span> class to represent the bisector of a segment.</p>&#13;
<p class="indent">These linear primitives are going to prove invaluable for building more complex ones called polygons, the topic of our next chapter.</p>&#13;
</body></html>