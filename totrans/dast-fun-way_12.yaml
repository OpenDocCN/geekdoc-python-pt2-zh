- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: B-trees
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: B树
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: Chapter 11 showed how the cost of memory access can vary across mediums. In
    this chapter, we’ll discuss how this problem extends beyond accessing individual
    values to the cost of accessing new blocks of data, introducing a new data structure
    to handle this situation.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 第11章展示了内存访问成本如何在不同介质之间有所不同。在本章中，我们将讨论这个问题如何超越访问单个值的成本，延伸到访问新数据块的成本，并引入一种新的数据结构来处理这种情况。
- en: Computer science is full of instances where accessing data within a block is
    cheap, but retrieving a new block is comparatively expensive. A computer might
    read an entire block of information, known as a *page*, from the hard drive and
    store it in memory. In the days of floppy disk–based video games, you might see
    a message directing you to “Insert disk 5 of 7” or wait while the game loaded
    the next chunk of data from a CD. Similarly, online applications might download
    coherent blocks of data from a server across the internet, allowing you to start
    watching a video before you’ve downloaded the entire thing.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机科学中有很多实例，其中访问块内的数据是廉价的，但检索新块却相对昂贵。计算机可能会从硬盘读取整个信息块，称为*页面*，并将其存储在内存中。在软盘时代的电子游戏中，你可能会看到一条消息，指示你“插入第5张磁盘（共7张）”，或者等待游戏从CD中加载下一块数据。类似地，在线应用程序可能会从互联网服务器下载一致的数据块，使你可以在未下载完整个视频的情况下开始观看。
- en: This chapter covers the *B-tree*, a self-balancing tree-based data structure
    that computer scientists Rudolf Bayer and Edward McCreight designed to account
    for the cost of retrieving new blocks of data. B-trees store multiple pieces of
    data in a single node, allowing us to pay the expensive retrieval cost exactly
    once to extract all those values. Once the node is in local memory, we can quickly
    access the values within it. The tradeoff is additional complexity when dealing
    with the nodes.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了*B树*，一种自平衡的基于树的数据结构，由计算机科学家鲁道夫·贝尔（Rudolf Bayer）和爱德华·麦克雷（Edward McCreight）设计，用于应对检索新数据块的成本。B树将多个数据项存储在单个节点中，使我们只需为提取所有这些值支付一次昂贵的检索成本。一旦节点进入本地内存，我们可以迅速访问其中的值。其权衡是，在处理节点时增加了额外的复杂性。
- en: In the computational domain, we may run into this problem when trying to index
    a massive data set. Consider the index for a literally astronomical data set that
    contains pointers to images of every star, galaxy, nebula, comet, asteroid, and
    other celestial body ever observed. The data set is still larger than the index,
    but the index itself might need to reside across many blocks of slow storage.
    B-trees provide an inventive way of combining the indexing and keys while minimizing
    retrieval costs.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算领域，我们在尝试为庞大的数据集建立索引时，可能会遇到这个问题。考虑一下一个字面上天文数字般的数据集的索引，它包含指向每颗星星、星系、星云、彗星、小行星和其他天体图像的指针。数据集仍然比索引大，但索引本身可能需要分布在多个慢速存储块中。B树提供了一种创新的方法来结合索引和键，同时最小化检索成本。
- en: B-trees are also one example of how to define trees’ operations in such a way
    that they don’t become horribly imbalanced. As we will see later in the chapter,
    the B-tree always remains perfectly balanced with all the leaf nodes at exactly
    the same depth.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: B树也是如何定义树的操作，以确保它们不会变得极度不平衡的一个例子。正如我们稍后将在本章中看到的，B树始终保持完全平衡，所有叶节点都在相同的深度上。
- en: B-tree Structure
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: B树结构
- en: B-trees apply the multi-way branching structure that we saw in tries or quadtrees
    to storing individual keys. Practically, this means that they allow internal nodes
    many more than two branches, so they’re practically bristling with pointers. They
    also need to store more than a single key in each node. B-tree nodes are packed
    with keys, allowing them to both track multi-way partitions and, more importantly,
    maximize the amount of data we can retrieve by fetching a single node.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: B树采用我们在字典树或四叉树中看到的多路分支结构来存储单个键。实际上，这意味着它们允许内部节点有超过两个的分支，因此它们实际上充满了指针。它们还需要在每个节点中存储多个键。B树节点充满了键，使它们既能跟踪多路分区，又能最大限度地提高通过提取单个节点来检索数据的效率。
- en: We see the benefit of packing multiple items into a node in the everyday context
    of online shipping. We pay a cost for every box shipped, and these costs can add
    up quickly if we are shipping many small boxes. This is the equivalent of retrieving
    many small tree nodes from expensive storage. If we pack several items into the
    same box, however, we can reduce the cost by shipping them together. Similarly,
    B-trees reduce the cost of retrieving multiple keys by retrieving a block of them
    together.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在日常的在线购物场景中看到将多个物品打包进一个节点的好处。每个包裹的运输都会产生一定费用，如果我们发送许多小包裹，费用会迅速累积。这就相当于从昂贵的存储中检索多个小的树节点。但是，如果我们将多个物品放进同一个包裹，就可以通过一起运输来降低费用。同样，B树通过将多个键一起检索来减少检索成本。
- en: Formally, we define the size of B-tree node with a size parameter *k*, which
    provides bounds on how many elements a non-root node can store. All non-root nodes
    store between *k* and 2*k* keys in sorted order. The root node is more flexible
    and is allowed to contain between 0 and 2*k* keys. Like a binary search tree,
    internal nodes use the values of these keys to define the ranges for the branches.
    Internal nodes store pointers for each possible split point, before and after
    each key in the node, allowing for between *k* + 1 and 2*k* + 1 children for all
    internal nodes except the root node, which can have between 0 to 2*k* + 1 children.
    These split points are conceptually the same as what we do in a binary search
    tree—they divide the space into keys that come before the split and keys that
    come after.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在形式上，我们定义B树节点的大小参数为*k*，它提供了非根节点可以存储的元素数量的界限。所有非根节点存储介于*k*与2*k*之间的排序键。根节点更加灵活，允许包含介于0到2*k*之间的键。像二叉搜索树一样，内部节点使用这些键的值来定义分支的范围。内部节点为每个可能的分割点存储指针，分割点位于节点中每个键的前后，从而使得除根节点外的所有内部节点可以拥有介于*k*
    + 1和2*k* + 1之间的子节点，而根节点可以有介于0到2*k* + 1之间的子节点。这些分割点的概念与我们在二叉搜索树中做的事情相同——它们将空间划分为分割点前后的键。
- en: '[Figure 12-1](#figure12-1) shows an example of this structure. The node with
    keys 12, 31, and 45 defines four separate partitions: keys that come before 12,
    keys after 12 but before 31, keys after 31 but before 45, and keys after 45\.
    The subtree containing 13, 17, and 26 is defined by two split points in the parent
    node. All the keys in that node must be greater than 12 since their node’s child
    pointer is to the right of key 12\. Similarly, the keys must all be less than
    31 since the pointer is to the left of key 31.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[图12-1](#figure12-1)展示了这种结构的一个例子。包含键12、31和45的节点定义了四个不同的区间：在12之前的键、在12和31之间的键、在31和45之间的键、以及在45之后的键。包含13、17和26的子树由父节点中的两个分割点定义。该节点中的所有键都必须大于12，因为它们的子节点指针指向键12的右边。同样，所有的键都必须小于31，因为指针指向键31的左边。'
- en: '![The example B‐tree has 3 layers. The top node has a single key (51) and pointers
    to 2 children. The left child has keys 12, 31, and 45 and pointers to 4 children,
    one of which is a subtree containing 13, 17, 26.](image_fi/502604c12/f12001.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![该示例B树有3层。顶部节点有一个键（51）和指向2个子节点的指针。左子节点有键12、31和45，并且指向4个子节点，其中一个是包含13、17、26的子树。](image_fi/502604c12/f12001.png)'
- en: 'Figure 12-1: An example B-tree'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-1：一个B树示例
- en: Picture this structure in the context of indexing the vast collection at the
    Comprehensive Museum of Fun and Informative Collectibles. In an attempt to allow
    a dynamic collection, we store the index entry to each item on a small paper card
    with the name, a brief description, and the location in our massive collectibles
    warehouse. We can fit nine hundred cards into a single binder, so, for our collection
    of a hundred million items, we need over a hundred thousand binders to store the
    entire index.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 设想这个结构应用于“全面有趣且富有信息的收藏品博物馆”的索引系统。为了实现动态的收藏，我们将每个物品的索引条目存储在一张小纸卡上，卡片上有物品名称、简短描述和在我们庞大收藏品仓库中的位置。我们可以将九百张卡片放入一个文件夹中，因此，对于我们一亿件物品的收藏，至少需要十万个文件夹来存储整个索引。
- en: While we would like to store the entire index locally, we simply lack enough
    space in our office. Once we have requisitioned and retrieved a binder containing
    a slice of the index, we can browse through its entries relatively easily. However,
    asking for each new volume involves a trip to the archives and a requisition form.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们希望将整个索引本地存储，但我们的办公室空间实在不足。一旦我们申请并取回了一个包含索引片段的文件夹，我们可以相对轻松地浏览其条目。然而，每次申请新的文件夹都需要前往档案馆并填写申请表。
- en: In this organization scheme, each index card corresponds to a single entry in
    the B-tree where the name string is the key. The binders correspond to B-tree
    nodes, each with 900 pockets and thus holding a maximum of 900 keys. The entries
    within the binder are in sorted order, allowing us to search for a key with a
    linear scan or binary search. In addition, we keep one more piece of data in each
    of the binder’s pockets, a pointer to the binder containing entries between the
    current index card’s key and the key of the previous index card. As shown in [Figure
    12-2](#figure12-2), if we are looking for the target “Caffeine Unlimited Coffee
    Mug,” we would first scan past “Caffeine Ten Coffee Mug," which comes before our
    target in alphabetical order, and then hit “Jeremy’s Gourmet High-Caffeine Experience,”
    which comes after the target. At this point, we have passed the potential location
    for our target key and know that we need to search the binder before the current
    entry.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种组织方案中，每张索引卡对应 B 树中的一个条目，其中名称字符串是键。绑定器对应于 B 树节点，每个节点有 900 个口袋，因此最多可容纳 900
    个键。绑定器中的条目按排序顺序排列，使我们可以通过线性扫描或二分查找来搜索键。此外，我们在每个绑定器的口袋中存储一个额外的数据项，即指向另一个绑定器的指针，该绑定器包含当前索引卡的键和前一张索引卡的键之间的条目。如
    [图 12-2](#figure12-2) 所示，如果我们正在寻找目标“Caffeine Unlimited 咖啡杯”，我们首先会扫描经过“Caffeine
    Ten 咖啡杯”，它在字母顺序上排在目标之前，然后会遇到“Jeremy’s Gourmet High-Caffeine Experience”，它排在目标之后。此时，我们已经越过了目标键的潜在位置，并知道需要搜索当前条目前的绑定器。
- en: '![Three entries from our collectibles index: Caffeine Ten Coffee Mug, Jeremy’s
    Gourmet High‐Caffeine Experience Coffee Mug, and Morning Zap Brand Coffee Mug
    . Each entry has two pointers, an item pointer and a binder pointer. The binder
    pointer for Jeremy’s Gourmet High‐Caffeine Experience Coffee Mug is shown as an
    arrow.](image_fi/502604c12/f12002.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![我们的收藏品索引中的三项条目：Caffeine Ten 咖啡杯、Jeremy''s Gourmet High‐Caffeine Experience
    咖啡杯和 Morning Zap Brand 咖啡杯。每个条目都有两个指针，一个项目指针和一个绑定指针。Jeremy''s Gourmet High‐Caffeine
    Experience 咖啡杯的绑定指针显示为箭头。](image_fi/502604c12/f12002.png)'
- en: 'Figure 12-2: The binder pointer in our index cards indicates which binder to
    use to continue our search.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-2：我们索引卡中的绑定指针指示应使用哪个绑定器来继续搜索。
- en: We store a single additional pointer at the very back of the binder that points
    to another binder containing only keys that come after the last key in the current
    binder. In total, our binder can contain up to 900 keys (with their pointers to
    the associated collectibles) and 901 pointers to other binders.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在绑定器的最末尾存储一个额外的指针，该指针指向另一个绑定器，包含当前绑定器中最后一个键之后的所有键。总的来说，我们的绑定器最多可以包含 900 个键（以及它们指向相关收藏品的指针）和
    901 个指向其他绑定器的指针。
- en: 'As with the other tree-based data structures, we define B-tree structure using
    both a top-level composite data structure and a node-specific data structure:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他基于树的数据结构一样，我们通过一个顶级复合数据结构和一个节点特定数据结构来定义 B 树结构：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this data structure and the examples below, we store and retrieve individual
    keys to keep the code simple. As with the other data structures we have introduced,
    in most cases it will be useful to store a composite data structure with both
    the key and a pointer to the key’s data, such as with the item pointers in [Figure
    12-2](#figure12-2).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在此数据结构和以下示例中，我们存储和检索单个键以保持代码简洁。与我们之前介绍的其他数据结构一样，在大多数情况下，存储一个包含键和指向该键数据的指针的复合数据结构（例如
    [图 12-2](#figure12-2) 中的项目指针）会更有用。
- en: One complication of the B-tree structure is that we store the keys and children
    in two differently sized arrays. This means that we need to define how a key at
    index *i* maps to its adjacent child pointers. For any given index *i*, we can
    access the key at *keys*[*i*], but we also need to be able to access the node
    pointers before and after that key. We define the pointers such that the value
    of all keys in or below *children*[*i*] are less than *keys*[*i*] and greater
    than *keys*[*i* *−* 1] (if *i* > 0), as shown in [Figure 12-3](#figure12-3).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: B 树结构的一个复杂之处在于，我们将键和子节点存储在两个不同大小的数组中。这意味着我们需要定义如何将索引 *i* 处的键映射到其相邻的子节点指针。对于任何给定的索引
    *i*，我们可以访问 *keys*[*i*] 处的键，但我们还需要能够访问该键之前和之后的节点指针。我们定义指针，使得 *children*[*i*] 处的所有键值都小于
    *keys*[*i*]，并且大于 *keys*[*i* *−* 1]（如果 *i* > 0），如 [图 12-3](#figure12-3) 所示。
- en: '![The keys array contains 12, 31, and 45\. The children array has 4 pointers:
    keys less than 12, keys less than 31 and greater than 12, keys less than 45 and
    greater than 31, and keys greater than 45.](image_fi/502604c12/f12003.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![键数组包含12、31和45。子数组有4个指针：小于12的键、小于31但大于12的键、小于45但大于31的键，以及大于45的键。](image_fi/502604c12/f12003.png)'
- en: 'Figure 12-3: A mapping from the entries in the keys array to the corresponding
    elements in the children array'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-3：键数组条目与子数组对应元素的映射
- en: By definition, B-trees are balanced data structures. Every leaf node is exactly
    the same depth from the root. In a later section, we’ll show how this structure
    is maintained by updating nodes as we insert and delete new keys.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义，B树是平衡的数据结构。每个叶子节点距离根节点的深度完全相同。在后面的章节中，我们将展示如何通过更新节点来保持这一结构，以便在插入和删除新键时进行维护。
- en: Searching B-trees
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 搜索B树
- en: 'We search the B-tree using the same general procedure that we use for all tree-based
    data structures: we start at the top of the tree and work our way down until we
    find the key of interest. The main difference between the B-tree and a binary
    search tree is that we might need to check more than one key per node. We scan
    along the keys in each node until we either find the target key or find a key
    with a value larger than our target. In the latter case, if we are at an internal
    node, we drop down to the appropriate child and continue the search, as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用与所有基于树的数据结构相同的一般程序来搜索B树：从树的顶部开始，逐层向下查找，直到找到感兴趣的键。B树与二叉搜索树的主要区别在于，我们可能需要每个节点检查多个键。我们在每个节点中沿着键进行扫描，直到找到目标键或找到一个值大于目标键的键。在后一种情况下，如果我们处于内部节点，则会下降到适当的子节点并继续搜索，具体如下：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The code for this search starts by scanning through the keys stored at the current
    node using a `WHILE` loop ❶. The loop continues until it hits the end of the key
    list (`i == node.size`) or hits a key larger than the target (`target < node.keys[i]`).
    The code checks whether it has found a matching key in the current node, and,
    if so, returns that key ❷. While the example code uses a linear scan to search
    the node for the purpose of simplicity in this example, we could also use binary
    search for better efficiency.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这段搜索代码首先通过使用`WHILE`循环 ❶扫描当前节点中存储的键。循环会持续直到遇到键列表的末尾（`i == node.size`）或遇到比目标值大的键（`target
    < node.keys[i]`）。代码检查是否在当前节点中找到了匹配的键，如果找到了，就返回该键 ❷。虽然示例代码使用线性扫描来搜索节点以简化示例，但我们也可以使用二分搜索来提高效率。
- en: If the code does not find a match in the current node and the current node is
    a leaf, there is no match in the tree, and the code returns `null` ❸. Otherwise,
    the code recursively explores the correct child node. It can access the correct
    child directly with the loop iterator `i` ❹, because the loop stops when either
    `i` represents the last child or `key[i] > target`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码在当前节点中没有找到匹配项且当前节点是叶子节点，则树中没有匹配项，代码返回`null` ❸。否则，代码会递归地探索正确的子节点。由于循环停止的条件是`i`表示最后一个子节点或`key[i]
    > target`，它可以通过循环迭代器`i`直接访问正确的子节点 ❹。
- en: 'Consider the example of searching the B-tree shown earlier in [Figure 12-1](#figure12-1)
    for key 17\. In the root node, we check the first key (51) and see that it is
    greater than 17, so we drop down a level using the first child pointer. At the
    next level, we check two keys: 12 is less than our target, so we proceed past
    it; 31 is greater than our target, so we drop down to the child node whose keys
    come before 31 using the second child pointer. This process continues at the leaf
    node. [Figure 12-4](#figure12-4) illustrates this search, indicating with gray
    the array bins we have accessed and compared.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑之前在[图12-1](#figure12-1)中展示的B树搜索键17的示例。在根节点，我们检查第一个键（51），发现它大于17，因此使用第一个子节点指针下降一级。在下一层，我们检查两个键：12小于目标键，因此继续跳过它；31大于目标键，因此通过第二个子节点指针下降到键值小于31的子节点。这个过程在叶子节点继续进行。[图12-4](#figure12-4)展示了这一搜索过程，用灰色标示出我们已访问并比较过的数组单元。
- en: '![The search of the B‐tree visits the key 51 in the top node, 12 and 31 in
    the second‐level child, and 13 and 17 in the third‐level child.](image_fi/502604c12/f12004.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![B树的搜索访问了顶级节点中的键51、第二级子节点中的键12和31，以及第三级子节点中的键13和17。](image_fi/502604c12/f12004.png)'
- en: 'Figure 12-4: An example search of a B-tree. The shaded cells are the ones checked
    by the algorithm.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-4：B树的搜索示例。被阴影标记的单元格是算法检查过的单元格。
- en: 'We should consider how searching the keys within a node impacts the runtime:
    instead of dropping down to the next level after a single comparison, we might
    now have to perform multiple comparisons per node. This is an acceptable tradeoff
    for two reasons. First, remember the B-tree is optimized to reduce the number
    of nodes fetched. In comparison, the data accesses within a node are expected
    to be relatively cheap because they are happening in local memory and do not require
    us to fetch another block of data from the expensive storage. Second, and equally
    important, the branching structure of the B-tree still provides ample opportunities
    for pruning. Each comparison still eliminates entire subtrees. And, like the current
    node, each skipped node may contain up to 2*k* keys and 2*k* + 1 children.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该考虑搜索节点内的密钥如何影响运行时：与在单次比较后下移到下一层不同，我们现在可能需要在每个节点执行多个比较。这是一个可接受的权衡，原因有二。首先，记住
    B 树是为了减少提取节点的数量而优化的。相比之下，节点内的数据访问预计是相对便宜的，因为它们发生在本地内存中，并不需要我们从昂贵的存储中提取另一个数据块。其次，同样重要的是，B
    树的分支结构仍然提供了足够的修剪机会。每次比较仍然会消除整个子树。而且，与当前节点一样，每个被跳过的节点最多可以包含 2*k* 个密钥和 2*k* + 1
    个子节点。
- en: 'Returning to our collectibles example, consider a search for a particular collectible.
    We start at the root binder. Since the keys are stored in alphabetical order,
    we can rapidly skim down the rows until we find our desired key or pass where
    it should be. If we don’t see our desired key, we know it isn’t in this binder.
    We mumble a few choice words about the unfairness of finite storage space and
    note the first key we encounter that comes after our target key has an item pointer
    reading “Binder #300.” We mumble a few more complaints and ask the archivist for
    binder #300.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '回到我们的收藏品示例，考虑查找某个特定的收藏品。我们从根目录文件夹开始。由于密钥按字母顺序存储，我们可以快速地扫过行，直到找到我们想要的密钥，或者经过它应该在的位置。如果我们没有看到目标密钥，我们就知道它不在这个文件夹里。我们嘟囔着对有限存储空间的不满，并注意到我们遇到的第一个紧跟目标密钥的密钥指针显示为“文件夹
    #300”。我们又嘟囔了几句抱怨，并请求档案管理员提供文件夹 #300。'
- en: 'Let’s contrast this storage approach with what happens if we instead store
    all our index cards in sorted order. Binder #1 contains the first set of cards
    *Aa* through *Ab*, binder #2 contains *Ac* through *Ad*, and so forth. This could
    work well for a static data set. We could perform a binary search over the binders,
    requesting the middle binder in our current range each time and limiting ourselves
    to a logarithmic number of requests. However, this approach begins to break down
    as we add or remove cards. Binders become overfull, requiring us to shift cards
    from one binder to the next. Updates to our collection might require cascading
    updates to many binders as cards must be shifted over. In the worst case, if we
    pack our binders full, we could end up needing to access every binder in our index.
    As we will see next, B-trees structures facilitate dynamic changes to the data
    set.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们将这种存储方法与如果我们将所有索引卡按排序顺序存储时的情况进行对比。文件夹 #1 包含从 *Aa* 到 *Ab* 的第一组卡片，文件夹 #2 包含
    *Ac* 到 *Ad* 的卡片，以此类推。这对于静态数据集可能效果很好。我们可以对文件夹执行二分查找，每次请求当前范围内的中间文件夹，并将请求限制在对数数量的请求内。然而，随着我们添加或删除卡片，这种方法开始出现问题。文件夹变得过满，要求我们将卡片从一个文件夹转移到下一个文件夹。我们的收藏更新可能需要对许多文件夹进行级联更新，因为卡片必须被转移。最坏的情况下，如果我们将文件夹装得满满的，我们可能需要访问索引中的每个文件夹。正如我们接下来会看到的，B
    树结构有助于数据集的动态变化。'
- en: Adding Keys
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加密钥
- en: Adding keys to a B-tree is more complex than adding to the tree-based data structures
    we’ve previously considered. In this case, we need to keep the structure balanced
    and limit the number of keys stored in each node (between *k* and 2*k*). There
    are two approaches for handling full nodes. First, we could split as we proceed
    down the tree, making sure we never call insertion on a full node. Second, we
    can temporarily insert into a full node (allowing it to be overfull) and then
    split it on the way back up. We’ll explore the later approach, which results in
    a two-stage algorithm for inserting new keys.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 向 B 树中添加密钥比向我们之前考虑的基于树的数据结构中添加密钥更为复杂。在这种情况下，我们需要保持结构的平衡，并限制每个节点中存储的密钥数量（在*k*到2*k*之间）。有两种方法可以处理满节点。首先，我们可以在树的过程中进行分裂，确保我们永远不会在满节点上调用插入操作。其次，我们可以暂时插入到一个满节点中（允许它过满），然后在回溯时对其进行分裂。我们将探讨后者方法，它产生了一种两阶段算法来插入新密钥。
- en: To perform insertions, we first proceed down the tree, searching for the position
    to insert the new key. Second, we return back up the tree, splitting nodes that
    have become overfull. Each split increases the branching factor of a node, but
    not necessarily the height. In fact, the only time we increase the height of the
    tree is when we split the root node itself. Because we only increase the height
    by splitting the root node (adding a depth of 1 to every leaf simultaneously),
    we can guarantee that the tree always remains balanced.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 执行插入时，我们首先沿着树向下，寻找插入新键的位置。其次，我们沿树向上返回，拆分那些已满的节点。每次拆分都会增加节点的分支因子，但不一定增加树的高度。事实上，只有在拆分根节点时，树的高度才会增加，因为我们通过拆分根节点（同时将每个叶子深度增加1）来增加高度，因此我们可以保证树始终保持平衡。
- en: The Addition Algorithm
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加法算法
- en: During the first stage of the algorithm, we recursively descend the tree, searching
    for the correct location to insert the new key. If we find a matching key along
    the way, we can update that key’s data. Otherwise, we proceed down to a leaf node,
    where we insert the key into our array.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在算法的第一阶段，我们递归地下降树，寻找插入新键的正确位置。如果在此过程中找到匹配的键，我们可以更新该键的数据。否则，我们继续向下直到叶子节点，在那里我们将键插入到数组中。
- en: We start off by defining a simple helper function `BTreeNodeAddKey` to insert
    a key into a non-full node. For convenience, we also take a pointer to a child
    node (representing the child *after* the new key) so that we can reuse this function
    when splitting nodes. If we are at a leaf node, which doesn’t store pointers to
    children, this `next_child` pointer is ignored.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义一个简单的辅助函数`BTreeNodeAddKey`，用于向一个未满的节点插入键。为了方便起见，我们还传入一个指向子节点的指针（表示新键之后的子节点），这样我们就可以在拆分节点时重用该函数。如果我们当前在叶子节点中（叶子节点不存储指向子节点的指针），则忽略这个`next_child`指针。
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The code starts at the *end* of the `keys` array (index `node.size – 1`) and
    proceeds toward index 0 using a `WHILE` loop ❶. At each step, it checks whether
    the new key should be inserted here and, if not, shifts the current element of
    both `keys` and `children` back one space. The loop terminates when it has gone
    one step past the correct location, which might be the start of the array. Once
    we have found the correct location for the new key, we have already moved that
    and the following elements out of the way. We can directly insert the new key
    and child ❷. The code finishes by adjusting the size of the node to account for
    the insertion ❸.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 代码从`keys`数组的*末尾*（索引`node.size – 1`）开始，使用`WHILE`循环向索引0方向推进❶。每一步，它检查新键是否应当插入此处，如果不插入，则将`keys`和`children`数组中的当前元素都向后移动一个位置。循环在移动超过正确位置（可能是数组的起始位置）时终止。一旦找到新键的正确位置，我们已经将新键和后续元素移开了位置。我们可以直接插入新键和子元素❷。代码最后通过调整节点的大小来处理插入❸。
- en: Here we may gasp in dismay at the cost of linearly shifting down items in the
    array to make room for our new element, as shown in [Figure 12-5](#figure12-5).
    This is everything we warned about in Chapter 3. But remember, we are trading
    off these (bounded) linear costs to minimize node accesses. We are willing to
    put up with the hassle of moving down the cards within our binder to minimize
    future requisitions to other binders.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可能会因需要线性地将数组中的元素向下移动以为新元素腾出空间而感到失望，如[图12-5](#figure12-5)所示。这就是我们在第三章中提到的所有问题。但请记住，我们是在用这些（有限的）线性成本来最小化节点访问。我们愿意忍受将卡片从文件夹中移开的麻烦，以最小化以后向其他文件夹请求数据的次数。
- en: '![An array for four spots. The key 26 is inserted into the second spot in the
    array, and the following two keys 31 and 45 are each shifted back one position.](image_fi/502604c12/f12005.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![一个包含四个位置的数组。键值26被插入到数组的第二个位置，随后两个键值31和45分别被向后移动一个位置。](image_fi/502604c12/f12005.png)'
- en: 'Figure 12-5: Shifting the elements over to insert 26 in `BTreeNodeAddKey`'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-5：在`BTreeNodeAddKey`中移动元素以插入26
- en: 'We require a few more helper functions to handle the case where a node fills
    up. Remember that we are restricted to at most 2*k* elements per node—any more
    than that means we need to split the node. First, we start with a simple accessor
    function `BTreeNodeIsOverFull`, which returns a Boolean indicating whether the
    node contains more than 2*k* items:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一些额外的辅助函数来处理节点已满的情况。请记住，我们每个节点最多只能包含2*k*个元素——超过这个数量就需要拆分节点。首先，我们定义一个简单的访问器函数`BTreeNodeIsOverFull`，该函数返回一个布尔值，指示节点是否包含超过2*k*个元素：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is equivalent to checking if we have used up all the pockets in our binder.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当于检查我们是否已经用完了文件夹中的所有口袋。
- en: We also add a second helper `BTreeNodeSplit`, which takes a node and the index
    of a child and splits that child. Everything before that index is retained in
    the original child. Everything after that index is cleared from the child and
    added to a newly created sibling node. The key at the index itself is cleared
    from the child and added to the current (parent) node.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了一个第二个辅助函数`BTreeNodeSplit`，该函数接收一个节点和一个子节点的索引，并分裂该子节点。该索引之前的所有内容保留在原始子节点中。该索引之后的所有内容从子节点中清除并添加到新创建的兄弟节点中。索引处的键从子节点中清除并添加到当前（父级）节点中。
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The code for `BTreeNodeSplit` starts by looking up the node to split (`old_child`)
    and creating a new (empty) sibling node (`new_child`) ❶. This node will be at
    the same level as the child to split, so we copy over the value of `is_leaf`.
    Next the code determines what index and key to use as a split point for `old_child`
    ❷. The code then uses a `WHILE` loop to copy everything after `split_index` from
    both the `keys` and `children` in `old_child` to the corresponding arrays in `new_child`
    ❸. The code uses a pair of indices to capture the index of the old location (`old_index`)
    and the corresponding new location (`new_index`). At the same time, the code removes
    the elements from `old_child`’s arrays by setting the entries to `null`. Because
    the `children` array is one element longer, we need to copy that last element
    separately ❹. Finally, we remove the key at `split_index` ❺, add both `split_key`
    and the new child pointer to the current node ❻, and set both the children’s sizes
    ❼.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`BTreeNodeSplit`的代码首先查找需要分裂的节点（`old_child`），并创建一个新的（空的）兄弟节点（`new_child`）❶。该节点将与要分裂的子节点位于同一层级，因此我们复制`is_leaf`的值。接下来，代码确定用于`old_child`的分裂点的索引和值❷。然后，代码使用`WHILE`循环将`old_child`中`split_index`之后的所有内容从`keys`和`children`复制到`new_child`中的相应数组❸。代码使用一对索引来捕获旧位置的索引（`old_index`）和相应的新位置（`new_index`）。与此同时，代码通过将条目设置为`null`来从`old_child`的数组中删除这些元素。由于`children`数组比原来长一个元素，我们需要单独复制最后一个元素❹。最后，我们删除`split_index`处的键❺，将`split_key`和新的子节点指针添加到当前节点❻，并设置两个子节点的大小❼。'
- en: Let’s view this operation in the context of our collectibles storage index as
    shown in [Figure 12-6](#figure12-6). When a binder reaches capacity, we repartition
    its contents into two binders. First, we buy a new empty binder. This sibling
    will store approximately half the contents of the overfull binder. Second, we
    carefully relocate the back half of the overfull binder’s contents into the new
    binder, preserving the sorted ordering. Third, we remove the single index card
    whose key lies between the keys in each binder and insert it in the parent binder
    in order to indicate the divide between the two child binders. The previously
    overfull child binder will contain cards whose keys come before this split, and
    the new binder will contain cards whose keys come after this split.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在[图12-6](#figure12-6)所示的收藏品存储索引的上下文中查看这个操作。当一个文件夹达到容量时，我们将其内容重新分配到两个文件夹中。首先，我们购买一个新的空文件夹。这个兄弟文件夹将存储约一半的超满文件夹内容。其次，我们小心地将超满文件夹的后半部分内容移动到新的文件夹中，同时保持已排序的顺序。第三，我们移除包含每个文件夹之间键的单个索引卡片，并将其插入到父级文件夹中，以指示两个子文件夹之间的划分。之前超满的子文件夹将包含键小于此分割的卡片，而新的文件夹将包含键大于此分割的卡片。
- en: '![A row  with three entries: Caffeine Ten Coffee Mug, Jeremy’s Gourmet High‐Caffeine
    Experience Coffee Mug, and Morning Zap Brand Coffee Mug. An arrow indicates that
    the card on the left (and all preceding cards) stays in the binder. A second arrow
    indicates the middle card goes to the parent binder. A third arrow indicates that
    the card on the right and all following cards goes to the new binder.](image_fi/502604c12/f12006.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![一排有三个条目的卡片：Caffeine Ten Coffee Mug、Jeremy’s Gourmet High‐Caffeine Experience
    Coffee Mug和Morning Zap Brand Coffee Mug。箭头表示左侧的卡片（以及所有之前的卡片）保留在文件夹中。第二个箭头表示中间的卡片移到父级文件夹中。第三个箭头表示右侧的卡片和所有后续的卡片将移到新的文件夹中。](image_fi/502604c12/f12006.png)'
- en: 'Figure 12-6: We repartition the binder by splitting it on the key of the middle
    card.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-6：我们通过在中间卡片的键上进行分割来重新分配文件夹。
- en: Given these helpers, we can now define an insertion function that performs the
    recursive search and the subsequent addition. We perform the addition at the leaf
    node. As the recursion returns up the tree, we check whether the recently accessed
    child node is full and thus needs to be split.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些辅助函数，我们现在可以定义一个插入函数，该函数执行递归搜索和随后的添加。我们在叶节点执行添加操作。随着递归从树中返回，我们检查最近访问的子节点是否已满，因此需要分裂。
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The code starts by finding the correct location for `key` in the `keys` array
    ❶. The `WHILE` loop iterates through the array until it hits the end of the key
    list (`i == node.size`) or hits a key that is larger than the target (`key < node.keys[i]`).
    If the code finds an exact match, it updates any data for this key and returns
    ❷. Otherwise, it needs to insert new data.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先通过查找`keys`数组中`key`的正确位置来开始 ❶。`WHILE`循环遍历数组，直到到达键列表的末尾（`i == node.size`）或遇到一个比目标键大的键（`key
    < node.keys[i]`）。如果代码找到精确匹配，它会更新该键的数据并返回 ❷。否则，它需要插入新数据。
- en: If the key is being inserted into a leaf, the code uses the `BTreeNodeAddKey`
    function ❸, which shifts the array elements over and adds the new key to the correct
    location. If the key is being inserted into an internal node, the index `i` provides
    the pointer of the correct child for insertion. The code recursively inserts into
    that child ❹, then checks whether it broke the properties of a B-tree (specifically
    the size of nodes falling between *k* and 2*k*) with the insertion ❺.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果密钥被插入到叶子节点中，代码会使用`BTreeNodeAddKey`函数 ❸，该函数会移动数组元素并将新密钥插入到正确的位置。如果密钥被插入到内部节点中，索引`i`提供了插入的正确子节点指针。代码会递归地将密钥插入到该子节点
    ❹，然后检查插入操作是否破坏了B树的性质（特别是节点的大小是否在*k*和2*k*之间） ❺。
- en: The code breaks the B-tree property if it inserts too many elements into a node.
    We can use our helper function `BTreeNodeIsOverFull` to check if the recently
    modified node has too many elements. The code conducts this check from the parent
    node, so we can keep the logic of repairing the B-tree simple. It uses `BTreeNodeSplit`
    to split the overfull child into two nodes ❻. In the process of this insertion,
    we might break the current node when inserting the new separating key, but that’s
    okay; we’ll take care of it when we return to this node’s parent.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码在一个节点中插入太多元素，它就会破坏B树的性质。我们可以使用辅助函数`BTreeNodeIsOverFull`来检查最近修改的节点是否包含过多元素。代码从父节点开始进行这个检查，因此我们可以保持修复B树的逻辑简单。它使用`BTreeNodeSplit`将过满的子节点拆分为两个节点
    ❻。在这个插入过程中，我们可能会在插入新的分隔键时破坏当前节点，但没关系；我们会在返回到该节点的父节点时处理它。
- en: We use a little extra storage in order to simplify the code. The code allows
    a node to temporarily overfill, storing 2*k* + 1 keys and 2*k* + 2 children while
    waiting for its parent node to call `BTreeNodeSplit`. We can create this buffer
    by simply allocating large enough arrays for the keys and children.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了稍微多一点的存储空间，以简化代码。代码允许一个节点暂时过满，存储2*k* + 1个键和2*k* + 2个子节点，同时等待其父节点调用`BTreeNodeSplit`。我们可以通过简单地为键和子节点分配足够大的数组来创建这个缓冲区。
- en: We can think of the first phase of the code as receiving a new coffee mug for
    our collection. We create an index card for the mug and insert it into our indexing
    binders. We start at the root binder and search for the location to put the card.
    During our search, we follow the appropriate pointers to child binders. Once we
    end up at a leaf binder, with no children indicated on the index cards, we add
    the new card there. We check whether the binder is now (over)full and, if it is,
    start repartitioning its contents. Afterward, we return the binders to storage
    in the reverse order that we requisitioned them. If we just split a binder and
    thus transferred a new card to its parent, we also check whether we need to split
    the parent binder. This process continues until we’ve returned to the root binder.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将代码的第一阶段看作是为我们的收藏添加一个新的咖啡杯。我们为这个咖啡杯创建一个索引卡，并将其插入到我们的索引文件夹中。我们从根文件夹开始，寻找插入卡片的位置。在搜索过程中，我们跟随适当的指针进入子文件夹。一旦到达叶子文件夹，且索引卡上没有标明的子文件夹，我们就将新卡片添加到这里。我们检查文件夹是否已满，如果已满，则开始重新分配其内容。之后，我们将文件夹按请求的顺序反向返回存储。如果我们刚刚拆分了一个文件夹并将新卡片转移到其父文件夹中，我们还需要检查是否需要拆分父文件夹。这个过程会一直继续，直到我们返回到根文件夹。
- en: 'We need to define one additional special case for the root node. Remember that
    splitting the root node is the only way we are allowed to increase the height
    of the tree. We need to define a wrapper function to do exactly that. Luckily,
    we can reuse our previous helper functions:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为根节点定义一个额外的特殊情况。请记住，拆分根节点是唯一允许我们增加树的高度的方法。我们需要定义一个包装函数来完成这个操作。幸运的是，我们可以重用之前的辅助函数：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The code starts by inserting the `key` into the root node using `BTreeNodeInsert`
    ❶. This function recursively descends the tree, finds the correct location to
    insert the new key, and returns through the levels fixing the broken B-tree property
    at all but the root node. Then the code checks if the root node has too many elements
    by using `BTreeNodeIsOverFull` on the root node ❷. If the root node has too many
    elements, the code adds a level to the tree by creating a new empty root node
    ❸, assigning the old root to be the first child of the new root ❹, splitting this
    (overfull) child ❺, and updating the tree’s root ❻. After a split, the new root
    node will contain exactly one key and two children.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 代码开始时通过`BTreeNodeInsert` ❶将`key`插入根节点。此函数递归地遍历树，找到正确的位置插入新键，并通过各层返回，修复除了根节点之外的所有节点的B树性质。然后，代码通过对根节点使用`BTreeNodeIsOverFull`
    ❷检查根节点是否有太多元素。如果根节点的元素太多，代码会通过创建一个新的空根节点来为树添加一层 ❸，并将旧根节点指定为新根的第一个子节点 ❹，分裂这个（过满的）子节点
    ❺，并更新树的根 ❻。分裂后，新根节点将包含一个键和两个子节点。
- en: In the process of inserting a key, we complete a single round trip from the
    root node to a leaf node and back. The number of nodes we need to access (and
    modify) is thus proportional to the depth of the tree. Since our B-tree always
    remains balanced, with all leaf nodes at the same depth, and the branching factor
    of all non-root, internal nodes is at least *k* + 1, the node retrievals scales
    logarithmically in *N*. The total work also includes linear operations within
    the node, such as copying or shifting keys, so the total work required scales
    proportional to *k* × log[*k*](*N*).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在插入键的过程中，我们完成了一次从根节点到叶节点再返回的单一往返。我们需要访问（并修改）的节点数量与树的深度成正比。由于我们的B树始终保持平衡，所有叶节点都处于相同的深度，并且所有非根内部节点的分支因子至少为*k*
    + 1，因此节点的检索在*N*中呈对数增长。总的工作量还包括节点内部的线性操作，比如复制或移动键，因此所需的总工作量与*k* × log[*k*](*N*)成正比。
- en: Examples of Adding Keys
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加键的示例
- en: Let’s consider a few examples to better understand the functions we just covered.
    First, take the simplest case, shown in [Figure 12-7](#figure12-7), of adding
    a key to leaf node that will not be overfull. Suppose *k* = 2, where our non-root
    nodes can contain between 2 and 2*k* = 4 items. If we add the key 30 to the subtree
    in [Figure 12-7](#figure12-7)(a), we simply proceed down to the leaf node and
    add the new key in the correct part of the array with the `BTreeNodeAddKey` helper
    function. Since the leaf has four elements, we do not need to split it. We get
    the subtree shown in [Figure 12-7](#figure12-7)(b).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑几个例子，以更好地理解我们刚才介绍的功能。首先，拿最简单的情况来讲解，如[图 12-7](#figure12-7)所示，在一个不会过满的叶节点中添加键。假设*k*
    = 2，即我们的非根节点可以包含2到2*k* = 4个项目。如果我们将键30添加到[图 12-7](#figure12-7)(a)中的子树，我们只需向下遍历到叶节点，并使用`BTreeNodeAddKey`辅助函数将新键添加到数组的正确位置。由于叶节点已有四个元素，我们不需要对其进行分裂。我们得到如[图
    12-7](#figure12-7)(b)所示的子树。
- en: '![Figure A shows a subtree with one internal node and four leaf nodes. The
    second leaf node has keys 13, 17, and 26\. Figure B shows the same tree but with
    the key 30 added to the end of the second child node. That node now has keys 13,
    17, 26, and 30.](image_fi/502604c12/f12007.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图 A 显示了一个包含一个内部节点和四个叶节点的子树。第二个叶节点包含键 13、17 和 26。图 B 显示了相同的树，但在第二个子节点的末尾添加了键
    30。该节点现在包含键 13、17、26 和 30。](image_fi/502604c12/f12007.png)'
- en: 'Figure 12-7: Inserting the key 30 into a non-full B-tree leaf (a) results in
    a leaf node with four elements (b).'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-7：将键 30 插入一个非满的 B 树叶节点（a）会导致一个包含四个元素的叶节点（b）。
- en: The logic becomes more complex as we fill up nodes. Consider the example shown
    in [Figure 12-8](#figure12-8)(a) of adding the key 29 to the same tree. After
    inserting the new key in [Figure 12-8](#figure12-8)(b), the leaf node is overfull.
    We handle this by identifying the split point of the overfull node (key = 26)
    and promoting that to the parent node. We then use the helper function `BTreeNodeSplit`
    to divide the leaf into two siblings as shown in [Figure 12-8](#figure12-8)(c).
    If the promotion of the middle element fills up the internal node, we need to
    split that as well.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们逐渐填充节点，逻辑变得更加复杂。考虑在[图 12-8](#figure12-8)(a)中将键29添加到同一棵树的示例。在[图 12-8](#figure12-8)(b)中插入新键后，叶节点变得过满。我们通过确定过满节点的分割点（键
    = 26）并将其提升到父节点来处理这个问题。然后，我们使用辅助函数`BTreeNodeSplit`将叶节点分成两个兄弟节点，如[图 12-8](#figure12-8)(c)所示。如果中间元素的提升使得内部节点也变得满了，我们还需要分裂它。
- en: '![Figure A shows a subtree with one internal node and four leaf nodes. The
    second leaf node has keys 13, 17, 26, and 30\. In figure B, the key 29 has been
    added to the second child, and the node is overfull with keys 13, 17, 26, 29,
    and 30\. In Figure C, the second child has been split into two nodes (13, 17)
    and (29, 30), and the key 26 has been promoted to its parent.](image_fi/502604c12/f12008.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图A展示了一个子树，其中有一个内部节点和四个叶子节点。第二个叶子节点包含键值13、17、26和30。在图B中，键值29已添加到第二个子节点中，导致节点过满，包含键值13、17、26、29和30。在图C中，第二个子节点已分裂为两个节点（13、17）和（29、30），并且键值26已被提升到父节点。](image_fi/502604c12/f12008.png)'
- en: 'Figure 12-8: Inserting the key 29 into an already-full leaf node (a) gives
    the leaf too many elements (b). We must split the overfull leaf to restore the
    B-tree conditions (c).'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-8：将键值29插入已满的叶子节点（a）会使叶子节点的元素过多（b）。我们必须将过满的叶子节点分裂，以恢复B树的条件（c）。
- en: Finally, consider what happens if our splits propagate all the way back to the
    root node. Suppose that, after an insertion, the root node itself overfills as
    shown in [Figure 12-9](#figure12-9)(a). We solve this problem in [Figure 12-9](#figure12-9)(b)
    by splitting the root node and creating a new level for the tree. The new root
    node contains exactly one element, the middle key of the previous root node. Note
    that, unlike all the other nodes, the root node is allowed to have less than *k*
    items. In fact, every time we split the root node, we create a new root with exactly
    one item.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，考虑一下如果我们的分裂传播到根节点会发生什么情况。假设在插入之后，根节点本身过满，如[图12-9](#figure12-9)(a)所示。我们在[图12-9](#figure12-9)(b)中通过分裂根节点并为树创建一个新层次来解决这个问题。新的根节点只包含一个元素，即原根节点的中间键值。请注意，与所有其他节点不同，根节点可以包含少于*k*个元素。实际上，每次我们分裂根节点时，都会创建一个只包含一个元素的新根节点。
- en: As the examples in this section show, the modifications to the B-tree are limited
    to only those nodes explored during the initial search for the insertion location.
    Since we do not need to update or repair other branches, the total number of modified
    nodes is limited by the depth of the tree and thus scales proportional to log[*k*](*N*).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如本节中的示例所示，对B树的修改仅限于在初始查找插入位置时探索过的那些节点。由于我们不需要更新或修复其他分支，因此修改的节点总数由树的深度限制，从而与log[*k*](*N*)成比例地扩展。
- en: '![Figure A shows a B‐tree with an overfull root node containing the keys 12,
    31, 51, 61, and  86\. The root node has five children, which are all leaves. Figure
    B shows the resulting tree after the split, with a new root node with key 51 and
    two children. The root''s left child contains keys 12 and 31\. The root’s right
    child contains keys 61 and 86\. The tree has the same five leaves.](image_fi/502604c12/f12009.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图A展示了一个根节点过满的B树，其中包含键值12、31、51、61和86。根节点有五个子节点，且都是叶子节点。图B展示了分裂后的树形结构，新的根节点的键值为51，并且有两个子节点。根节点的左子节点包含键值12和31，右子节点包含键值61和86。树的五个叶子节点保持不变。](image_fi/502604c12/f12009.png)'
- en: 'Figure 12-9: When the root node of a B-tree becomes overfull (a), we split
    it into two siblings and promote the middle element to the new root node (b).'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-9：当B树的根节点过满时（a），我们将其分裂成两个兄弟节点，并将中间的元素提升为新的根节点（b）。
- en: Removing Keys
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除键值
- en: Removing keys follows a similar approach to adding keys. We again need to keep
    the structure balanced and limit the number of keys stored in each node (between
    *k* and 2*k*). This results in a multi-stage algorithm for deleting keys. First,
    we proceed down the tree as though we were searching for the key. Once we find
    it, we delete the key. Finally, we return back up the tree checking for and fixing
    nodes with too few keys. Since we never remove a node except an empty root node
    (decreasing the depth of all the leaves by one), we again guarantee that the tree
    always remains balanced.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 删除键值的方法与添加键值类似。我们同样需要保持结构平衡，并限制每个节点中存储的键值数量（在*k*和2*k*之间）。这导致了一个多阶段的删除算法。首先，我们沿着树向下查找，仿佛我们在查找该键值。一旦找到该键值，我们删除它。最后，我们向上返回树并检查并修复那些键值过少的节点。由于我们从不删除节点，除了空的根节点（它会使所有叶子节点的深度减少一），我们再次保证树始终保持平衡。
- en: Fixing Under-full Nodes
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修复过少的节点
- en: 'When we remove keys from a B-tree, we run the risk of nodes dropping below
    the minimum of *k* keys. We can check this condition with a simple helper function:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从B树中删除键值时，存在节点键值少于*k*的风险。我们可以通过一个简单的辅助函数来检查这一条件：
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Depending on the structure of the B-tree, there are two different approaches
    we may need to use to fix an under-full node, both of which I’ll discuss in this
    section. Each approach relies on augmenting the node’s keys with keys from an
    adjacent sibling. In the first case, we directly merge two small sibling nodes
    into a single node. In the second case, we transfer a key from a larger sibling
    to the under-full node. Which function we use depends on how many keys in total
    the two siblings have. Both of these helper functions are called from the parent
    node with the index for the key that separates the adjacent sibling nodes.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 根据B树的结构，我们可能需要使用两种不同的方法来修复节点不足的情况，我将在本节中讨论这两种方法。每种方法都依赖于从相邻的兄弟节点中增加键来扩展当前节点。在第一种情况下，我们直接将两个小的兄弟节点合并成一个节点。在第二种情况下，我们将一个较大兄弟节点的键转移到不足的节点中。我们使用哪种方法取决于两个兄弟节点的总键数。以上这两个辅助函数都从父节点调用，且需要提供分隔相邻兄弟节点的索引。
- en: The merge operation takes two adjacent sibling nodes, along with the key separating
    them, and concatenates them into a single large child node. As such, it requires
    that the combined number of keys in the two siblings be *less* than 2*k* so that
    the new child is guaranteed to be valid. [Figure 12-10](#figure12-10) shows this
    procedure, with [Figure 12-10](#figure12-10)(a) depicting a subtree before the
    merge operation, where the middle child has a single key. [Figure 12-10](#figure12-10)(b)
    shows the same subtree after the merge.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 合并操作接收两个相邻的兄弟节点以及分隔它们的键，并将它们连接成一个大的子节点。因此，它要求这两个兄弟节点中键的总数必须*小于*2*k*，以确保新的子节点是有效的。[图12-10](#figure12-10)展示了这一过程，其中[图12-10](#figure12-10)(a)显示了合并操作前的子树，中间的子节点只有一个键。[图12-10](#figure12-10)(b)显示了合并后的子树。
- en: '![Figure A shows a node with three leaves and a single internal node. The internal
    node has keys 26 and 31\. The middle leaf has only a single key 29, and the right‐most
    leaf has two keys 32 and 42\. Figure B shows a node with two leaves. The internal
    node now has a single key, 26\. The right‐most node now has keys 29, 31, 32, and
    42.](image_fi/502604c12/f12010.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图A显示了一个具有三个叶子节点和一个内部节点的节点。内部节点有26和31两个键。中间的叶子节点只有一个键29，最右边的叶子节点有两个键32和42。图B显示了一个具有两个叶子节点的节点。内部节点现在只有一个键26。最右边的节点现在有键29、31、32和42。](image_fi/502604c12/f12010.png)'
- en: 'Figure 12-10: The merge operation on B-tree nodes'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-10：B树节点的合并操作
- en: '[Listing 12-1](#listing12-1) shows the code for merging two adjacent siblings.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单12-1](#listing12-1)展示了合并两个相邻兄弟节点的代码。'
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 12-1: Code for merging two child nodes'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 清单12-1：合并两个子节点的代码
- en: The code appends the keys from the right child and the separating key from the
    parent onto the left child. It starts by retrieving both child nodes, which we
    call `childL` and `childR` for left and right respectively ❶. By definition, any
    key in `childL` is less than the separating key, and any key in `childR` is greater
    than the separating key. The code then appends the separating key from the parent
    and the first child pointer from the right child to the end of the left child
    ❷. It uses a `WHILE` loop to copy the remaining keys and pointers from the right
    child ❸. It also updates the left child’s size. At this point, it has successfully
    created the merged node out of the two children. The merged child’s pointer is
    stored in `node.children[index]`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 代码将右子节点的键和父节点的分隔键追加到左子节点上。首先，它通过获取两个子节点来开始操作，我们分别称之为`childL`和`childR`，代表左子节点和右子节点❶。根据定义，`childL`中的任何键都小于分隔键，`childR`中的任何键都大于分隔键。接着，代码将父节点的分隔键和右子节点的第一个子指针追加到左子节点的末尾❷。它使用`WHILE`循环复制右子节点剩余的键和指针❸。同时，更新左子节点的大小。此时，已成功地将两个子节点合并成一个新的节点。合并后的子节点指针存储在`node.children[index]`中。
- en: The code finishes by cleaning up the parent node ❹. It removes the previous
    separating key and the pointer to the right child by shifting the subsequent keys
    and pointers over, setting the final bins to `null`, and updating the current
    node’s size.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 代码最后通过清理父节点来结束操作❹。它通过将后续的键和指针向前移动，删除之前的分隔键和指向右子节点的指针，将最终的空位设置为`null`，并更新当前节点的大小。
- en: In the process of merging two nodes, we are taking a key from their parent.
    This could leave the parent node with less than *k* keys, and our repairs would
    need to continue at the next higher level of the tree.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在合并两个节点的过程中，我们从它们的父节点获取一个键。这可能会导致父节点的键数量少于*k*，因此我们需要在树的下一个更高层次进行修复。
- en: This process is directly analogous to merging binders in our storage indexing
    example. If an index binder contains too few keys, it is a waste of space and
    requisition time. We wouldn’t want to requisition a binder with a single index
    card. Merging binders consists of taking the cards from one child binder, along
    with the separating card from the parent binder, and putting them in the other
    child binder in the correct order. Since we have already requisitioned the parent
    and one child (and thus have them in local memory), we can do this merge quickly
    with only a single additional requisition for the other child.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程直接类似于我们在存储索引示例中合并文件夹的操作。如果一个索引文件夹包含的键太少，它将浪费空间并占用请求时间。我们不想请求一个只有一张索引卡的文件夹。合并文件夹的过程是将一个子文件夹中的卡片和父文件夹中的分隔卡一同取出，并按正确的顺序放入另一个子文件夹中。由于我们已经请求了父文件夹和一个子文件夹（因此它们已经在本地内存中），我们可以通过仅对另一个子文件夹进行一次额外的请求，快速完成合并操作。
- en: The second approach to fixing an under-full node is to shift one of the keys
    (and potentially children) from its adjacent sibling. This works only when the
    sibling can afford to lose a key and thus applies to cases where the combined
    number of keys of the siblings must be at least 2*k*. While we could merge and
    optimally resplit the adjacent siblings, for illustrative purposes we use a simpler
    approach of transferring only one key. Since we only ever remove a single key
    from a node during deletion or the merge operation, transferring a single key
    is sufficient to fix our under-full node.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 修复不足节点的第二种方法是将一个键（及可能的子节点）从其相邻的兄弟节点移动过来。这种方法只有在兄弟节点能够失去一个键时才有效，因此适用于兄弟节点的键总数至少为
    2*k* 的情况。虽然我们可以合并并最优地重新分配相邻兄弟节点，但为了说明问题，我们使用一种更简单的方法，只转移一个键。由于在删除或合并操作期间我们只会从节点中删除一个键，转移一个键就足以修复我们的不足节点。
- en: However, as shown in [Figure 12-11](#figure12-11), we can’t just take a key
    from one child and give it to the other. The separating key in the parent node
    enforces the bounds of the split. Instead, we do a two-stage transfer. First,
    we transfer the current separating key from the parent to the under-full node.
    Second, we replace the separating key in the parent node with a key from the other
    sibling.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如[图 12-11](#figure12-11)所示，我们不能简单地从一个子节点取出一个键并给另一个子节点。父节点中的分隔键限制了拆分的范围。因此，我们进行两阶段的转移。首先，我们将当前的分隔键从父节点转移到不足节点。然后，我们用另一个兄弟节点中的一个键替换父节点中的分隔键。
- en: '![Figure A shows a node with three leaves and one internal node. The internal
    node has keys 26 and 31\. The middle leaf has only a single key 29, and the right‐most
    leaf has three keys 32, 42, and 45\. Figure B shows the same subtree. The internal
    node now has keys 26 and 32\. The middle leaf now has two keys 29 and 31, and
    the right‐most node has two keys 42 and 45.](image_fi/502604c12/f12011.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图 A 显示一个有三个叶子节点和一个内部节点的节点。内部节点包含键 26 和 31。中间叶子节点只有一个键 29，而最右边的叶子节点有三个键 32、42
    和 45。图 B 显示相同的子树。内部节点现在包含键 26 和 32。中间叶子节点现在有两个键 29 和 31，而最右边的节点有两个键 42 和 45。](image_fi/502604c12/f12011.png)'
- en: 'Figure 12-11: The transfer left operation on B-tree nodes'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-11：B树节点上的左转移操作
- en: 'As shown in [Listing 12-2](#listing12-2), we break the code into two helper
    functions, one to transfer a key from the right child to the left child and one
    to transfer the other way. The code to transfer a key from the right child to
    the left child transfers two keys: one from the right child to the parent and
    one from the parent to the left child.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如[清单 12-2](#listing12-2)所示，我们将代码拆分成两个辅助函数，一个用于将键从右子文件夹转移到左子文件夹，另一个用于反向转移。将键从右子文件夹转移到左子文件夹的代码会转移两个键：一个从右子文件夹转移到父文件夹，另一个从父文件夹转移到左子文件夹。
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 12-2: Code for transferring a key and child pointer to an under-full
    node from its right-hand sibling'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 12-2：将键和子指针从其右侧兄弟节点转移到不足节点的代码
- en: The code starts by retrieving the two adjacent siblings and the separating key
    ❶. It moves the first key from the right-hand child to replace the previous separating
    key ❷. It adds the previous separating key from the parent (`middle_key`) and
    the first child pointer from the right-hand child to the end of the arrays in
    the left-hand child ❸. Both the left-hand child and parent are now updated. The
    code then cleans up the right-hand child. It uses a `WHILE` loop to shift over
    the remaining elements ❹, marks the now empty spots as `null` ❺, and adjusts the
    size ❻.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先通过检索两个相邻的兄弟节点和分隔键 ❶ 开始。它将第一个键从右侧子节点移到替换先前的分隔键 ❷。然后将来自父节点的先前分隔键（`middle_key`）和右侧子节点的第一个子节点指针添加到左侧子节点数组的末尾
    ❸。此时，左侧子节点和父节点都已更新。接下来，代码清理右侧子节点。它使用 `WHILE` 循环将剩余的元素移到一边 ❹，将现在空的槽标记为 `null` ❺，并调整大小
    ❻。
- en: 'The code for transferring a key from the left child to the right child is similar
    to that shown in [Listing 12-3](#listing12-3). The two-key transfer works in the
    opposite direction: one from the left child to the parent and one from the parent
    to the right child.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 从左子节点向右子节点传输键的代码与 [示例 12-3](#listing12-3) 中展示的类似。两键传输的方向相反：一个从左子节点到父节点，另一个从父节点到右子节点。
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 12-3: Code for transferring a key and child pointer to an under-full
    node from its left-hand sibling'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 12-3：将键和子节点指针从其左兄弟传输到欠满节点的代码
- en: The code again starts by retrieving the two adjacent siblings and the separating
    key ❶. The code then shifts over the keys and children in the right-hand node
    to make room for the new addition ❷. It appends the previous separating key from
    the parent (`middle_key`) and the last child pointer from the left child to the
    *beginning* of the right-hand node ❸, increasing its size by 1\. The code then
    moves the last key in the left-hand child to replace the separating key in the
    parent ❹. The code completes by cleaning up the left-hand child by marking the
    now empty entries `null` and updating the size ❺.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 代码再次通过检索两个相邻的兄弟节点和分隔键 ❶ 开始。然后，代码将右侧节点中的键和子节点移动，以为新的元素腾出空间 ❷。它将来自父节点的先前分隔键（`middle_key`）和来自左子节点的最后一个子节点指针添加到右侧节点的*开始*位置
    ❸，并将其大小增加 1。接下来，代码将左侧子节点中的最后一个键移动到父节点中的分隔键位置 ❹。代码最后通过将现在空的条目标记为 `null` 来清理左侧子节点，并更新大小
    ❺。
- en: Unlike the merge operation, neither transfer operation reduces the number of
    keys in the parent. Thus, we do not need to perform repairs at higher levels of
    the tree. The physical corollary of these transfer operations is requesting a
    sibling storage binder and shifting two index cards between the two children and
    the parent. We take the intermediate card (that falls between the range of the
    two binders) from the parent and add it to the less full child binder. We replace
    this card in the parent with the appropriate one from the child that has more
    cards.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 与合并操作不同，传输操作不会减少父节点中的键数量。因此，我们不需要在树的更高层级执行修复操作。这些传输操作的物理对应是请求一个兄弟存储绑定器，并在两个子节点和父节点之间移动两张索引卡。我们从父节点取出介于两个绑定器之间的中间卡片，并将其添加到较不满的子节点绑定器中。我们用来自拥有更多卡片的子节点的适当卡片替换父节点中的这张卡片。
- en: 'We can encapsulate all three of these repair functions as well as the logic
    to choose them into a helper function that takes in the current node and the index
    of the under-full child:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这三种修复功能以及选择它们的逻辑封装成一个辅助函数，该函数接受当前节点和欠满子节点的索引：
- en: '[PRE11]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: To know which repair strategy to employ, the code needs to find an adjacent
    sibling and check the two children’s total number of keys. Here, for illustrative
    purposes, we use a simplistic strategy of always using the next child (`child
    + 1`) as the sibling unless we are repairing the last child in the array ❶. If
    we are repairing the last child in the array, we use the previous child for its
    sibling. The code checks the total count of keys in these two child nodes ❷. If
    the number of keys is small enough (under 2*k*), it merges those nodes with the
    `BTreeNodeMerge` function ❸. Otherwise, if the nodes have 2*k* or more keys, the
    code uses either `BTreeNodeTransferLeft` or `BTreeNodeTransferRight` to move a
    single key to the smaller node ❹.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了知道使用哪种修复策略，代码需要找到一个相邻的兄弟节点，并检查这两个子节点的总键数。在这里，为了说明，我们使用一种简单的策略，总是使用下一个子节点（`child
    + 1`）作为兄弟节点，除非我们正在修复数组中的最后一个子节点❶。如果我们正在修复数组中的最后一个子节点，则使用前一个子节点作为其兄弟节点。代码检查这两个子节点中键的总数❷。如果键的数量足够小（小于2*k*），则将这两个节点与`BTreeNodeMerge`函数合并❸。否则，如果节点的键数为2*k*或更多，代码使用`BTreeNodeTransferLeft`或`BTreeNodeTransferRight`将一个键移动到较小的节点❹。
- en: Finding the Minimum Value Key
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查找最小值键
- en: We use one more helper function as part of the deletion operation—code to find
    and return the minimum key at or below a given node. This code, in [Listing 12-4](#listing12-4),
    can also be useful in its own right, such as for computing the bounds of the keys
    in the B-tree.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在删除操作中使用了一个额外的辅助函数——用于查找并返回给定节点下或以下的最小键的代码。此代码在[清单12-4](#listing12-4)中，也可以单独使用，例如计算B树中键的范围。
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 12-4: Code to find the minimum key at or below a given node'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 清单12-4：查找给定节点下或以下的最小键的代码
- en: The code consists of three possible conditions. If the node is empty, the code
    returns `null` to indicate that there is no minimum key there ❶. This should occur
    only in an empty root node, as all other nodes will have at least *k* keys. If
    the node is a non-empty leaf, the code returns the first (and thus minimum) key
    in the node’s array ❷. Finally, if the node is internal, the code recursively
    checks the first child ❸.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 代码包含三种可能的情况。如果节点为空，代码返回`null`，表示那里没有最小键❶。这应该只发生在空的根节点中，因为所有其他节点至少会有*k*个键。如果节点是一个非空的叶子节点，代码返回节点数组中的第一个（即最小的）键❷。最后，如果节点是内部节点，代码递归检查第一个子节点❸。
- en: The Removal Algorithm
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除算法
- en: We start the description of the deletion algorithm with the top-level wrapper
    function. This function is relatively simple. It calls the recursive deletion
    function using the tree’s root node.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从顶层的包装函数开始描述删除算法。这个函数相对简单，它通过使用树的根节点调用递归删除函数。
- en: '[PRE13]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Just as we added a level only when we split the node, we remove a level from
    the tree only when the root node becomes empty. If the B-tree is not completely
    empty, the empty root node will still have a single valid child in array position
    0\. We use this child to replace the former root node.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在拆分节点时只添加一个级别一样，只有当根节点变为空时，才会从树中移除一个级别。如果B树不完全为空，空的根节点仍然会在数组位置0处有一个有效的子节点。我们使用这个子节点来替代原来的根节点。
- en: The core deletion algorithm recursively descends the tree, searching for the
    key to delete. Since we might reduce the number of keys below the required *k*,
    we need to know check whether the modified child is now under-full and, if so,
    repair it.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 核心删除算法递归地下降树，寻找要删除的键。由于我们可能会将键的数量减少到低于所需的*k*，因此需要检查修改后的子节点是否现在已不足满，如果是，则进行修复。
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The code starts by searching for the key to delete in the current node by scanning
    across the array of keys ❶. If there is a matching key in this node, the `WHILE`
    loop terminates such that `i` is the index matching the key.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 代码通过扫描键数组来开始在当前节点中查找要删除的键❶。如果在此节点中找到匹配的键，`WHILE`循环终止，`i`将是匹配键的索引。
- en: The code then considers the leaf case. If the node is a leaf and the key is
    found, the code deletes it by shifting over the keys ❷. The code also sets the
    last element to `null` and updates the size. The code doesn’t need to change the
    child pointers because they are not set for leaf nodes. If the node is a leaf
    and the key is not found, then the code simply returns.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然后代码考虑叶子节点的情况。如果节点是叶子节点并且找到了键，代码通过移动键来删除它❷。代码还将最后一个元素设置为`null`并更新大小。由于叶子节点没有设置子指针，代码不需要更改子指针。如果节点是叶子节点但未找到键，代码则直接返回。
- en: 'The code next handles the case of internal nodes. There are two cases to consider:
    the key is in the node, or it is not. If the code finds the key in the internal
    node, it replaces the key with the key that immediately *follows* the target key
    in sorted order ❸. The code finds this subsequent key using `BTreeNodeFindMin`
    from [Listing 12-4](#listing12-4), called on the child node immediately after
    the target key. The code deletes this following key from the child’s subtree by
    calling `BTreeNodeDelete` ❹. The code then checks whether the child node is under-full
    and, if so, fixes it.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，代码处理内部节点的情况。需要考虑两种情况：键在节点中，或者不在。如果代码在内部节点中找到了键，它会用在排序顺序中紧随目标键之后的键替换该键 ❸。代码通过调用`BTreeNodeFindMin`，从[Listing
    12-4](#listing12-4)中获取在目标键之后紧跟的子节点的最小键。代码然后通过调用`BTreeNodeDelete` ❹来从子树中删除这个紧随的键。接着，代码会检查子节点是否欠满，如果是，进行修复。
- en: If the target key is not in an internal node, then the code recursively calls
    `BTreeNodeDelete` on the appropriate child ❺. Again, it needs to check whether
    that child node is now under-full and, if so, fix it.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目标键不在内部节点中，那么代码会递归地在相应的子节点上调用`BTreeNodeDelete` ❺。再次需要检查该子节点是否现在是欠满的，如果是，进行修复。
- en: As with insertion, our goal is to limit the number of nodes retrieved during
    this operation. Deletion will make at most a single pass from the root node to
    a leaf. Even if we delete from an internal node, the subsequent replacement and
    deletion operations still only continue the trek to a single leaf. We pay one
    additional requisition whenever we repair a node to retrieve the under-full node’s
    sibling.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 与插入类似，我们的目标是限制在此操作中检索的节点数量。删除操作最多会从根节点到叶子节点进行一次遍历。即使我们从内部节点中删除，随后的替换和删除操作仍然只会继续遍历到一个单独的叶子节点。每当我们修复一个节点并检索欠满节点的兄弟节点时，我们就需要额外执行一次请求。
- en: Examples of Removing Keys
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除键的示例
- en: Let’s look at a few examples of the removals that we just covered. First, take
    the simplest case, shown in [Figure 12-12](#figure12-12), of removing a key from
    a leaf node with more than *k* + 1 keys. Suppose *k* = 2, where our non-root nodes
    can contain between 2 and 2*k* = 4 items. If we remove key 5 from the subtree
    in [Figure 12-12](#figure12-12)(a), we simply proceed down to the leaf node and
    remove the key in the array. Since the resulting leaf has three elements, we do
    not need to repair it. We get the subtree shown in [Figure 12-12](#figure12-12)(b).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看几个刚才讨论过的删除例子。首先，考虑最简单的情况，展示在[Figure 12-12](#figure12-12)中，即从包含超过*k* + 1个键的叶子节点中删除键。假设*k*
    = 2，我们的非根节点可以包含2到2*k* = 4个元素。如果我们从[Figure 12-12](#figure12-12)(a)中的子树中移除键5，我们只需继续向下到叶子节点并移除数组中的该键。由于结果叶子节点包含三个元素，我们无需修复它。我们得到[Figure
    12-12](#figure12-12)(b)所示的子树。
- en: '![Figure A shows a subtree with one internal node and five leaf nodes. The
    first leaf has keys 1, 3, 5, and 6\. Figure B shows the same tree as Figure A
    with the key 5 deleted from the middle of the first leaf node. The node now contains
    keys 1, 3, and 6.](image_fi/502604c12/f12012.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图A显示一个包含一个内部节点和五个叶节点的子树。第一个叶节点包含键1、3、5和6。图B显示与图A相同的树，键5已从第一个叶节点的中间删除。现在该节点包含键1、3和6。](image_fi/502604c12/f12012.png)'
- en: 'Figure 12-12: Deleting the key 5 from a B-tree leaf (a) results in a leaf node
    with three elements (b).'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-12：从B树叶节点中删除键5（a）结果是一个包含三个元素的叶节点（b）。
- en: Next, we consider the case of removing a key from an internal node without needing
    repairs as shown in [Figure 12-13](#figure12-13). If we remove key 45 from the
    subtree in [Figure 12-13](#figure12-13)(a), we find that key in an internal node.
    To remove it, we replace it with the next key in order, which is 47\. Since the
    resulting nodes all have at least two elements, we do not need to perform any
    repairs. We get the subtree shown in [Figure 12-13](#figure12-13)(b).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们考虑在不需要修复的情况下，从内部节点中移除一个键的情况，如[Figure 12-13](#figure12-13)所示。如果我们从[Figure
    12-13](#figure12-13)(a)中的子树中移除键45，我们发现该键在一个内部节点中。为了移除它，我们用排序顺序中的下一个键替换它，即47。由于结果节点至少有两个元素，因此我们不需要进行任何修复。我们得到[Figure
    12-13](#figure12-13)(b)中所示的子树。
- en: '![Figure A shows a subtree with one internal node and five leaf nodes. The
    internal node contains keys 12, 26, 31, and 45\. The fifth (right‐most) leaf contains
    keys 47, 48, and 49\. Figure B shows the same tree as Figure A with the key 45
    deleted from the internal node. The key 47, which previously resided in the right‐most
    node in Figure A, replaces the key 45\. The fifth leaf node has keys 48 and 49.](image_fi/502604c12/f12013.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图 A 显示了一个子树，其中包含一个内部节点和五个叶子节点。内部节点包含键 12、26、31 和 45。第五个（最右边的）叶子节点包含键 47、48
    和 49。图 B 显示了与图 A 相同的树，但删除了内部节点中的键 45。原本位于图 A 中最右边节点的键 47 替代了键 45。第五个叶子节点现在包含键
    48 和 49。](image_fi/502604c12/f12013.png)'
- en: 'Figure 12-13: Deleting the key 45 from an internal B-tree node (a) results
    in taking a key from one of the children (b).'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-13：从内部 B 树节点中删除键 45（a）会导致从子节点中获取一个键（b）。
- en: 'Finally, we consider the different cases where removing a key requires us to
    repair an under-full node. [Figure 12-14](#figure12-14) shows a case where we
    can merge two nodes. We start by deleting the key 32 in [Figure 12-14](#figure12-14)(a).
    [Figure 12-14](#figure12-14)(b) shows the keys that we use for the merge operation:
    the keys in the under-full node, the keys in its right-hand adjacent sibling,
    and the key in the parent separating the two. [Figure 12-14](#figure12-14)(c)
    shows the repaired tree. The new child node has four keys, and the previous parent
    has three.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们考虑删除键时需要修复不足元素节点的不同情况。[图 12-14](#figure12-14)展示了一个可以合并两个节点的情况。我们从删除 [图
    12-14](#figure12-14)(a) 中的键 32 开始。[图 12-14](#figure12-14)(b) 显示了我们用于合并操作的键：不足节点中的键、其右侧相邻兄弟节点中的键，以及父节点中分隔这两个节点的键。[图
    12-14](#figure12-14)(c) 显示了修复后的树。新的子节点包含四个键，原父节点包含三个键。
- en: '![Figure A shows a subtree with one internal node and five leaf nodes. The
    internal node contains keys 12, 26, 31, and 45\. The fourth leaf contains keys
    32 and 42\. The fifth leaf contains keys 47 and 48\. In Figure A, the key 32 is
    removed from a leaf node, leaving a single key 42\. Figure B shows a dashed line
    around the right‐most two children and the separating key 45\. Figure C shows
    the final tree with the merged child. The internal node now has four children
    and contains the keys 12, 26, and 31\. The right‐most leaf node has keys 42, 45,
    47, and 48.](image_fi/502604c12/f12014.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图 A 显示了一个子树，其中包含一个内部节点和五个叶子节点。内部节点包含键 12、26、31 和 45。第四个叶子节点包含键 32 和 42。第五个叶子节点包含键
    47 和 48。在图 A 中，键 32 从一个叶子节点中删除，留下了一个键 42。图 B 显示了右边两个子节点和分隔键 45 的虚线。图 C 显示了最终的树，合并后的子节点包含了四个子节点，内部节点包含键
    12、26 和 31。最右边的叶子节点现在包含键 42、45、47 和 48。](image_fi/502604c12/f12014.png)'
- en: 'Figure 12-14: Deleting the key 32 from an almost empty node (a) gives the leaf
    too few elements (b). We must merge with an adjacent sibling to restore the B-tree
    conditions (c).'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-14：从几乎为空的节点中删除键 32（a）会使叶子节点的元素过少（b）。我们必须与相邻的兄弟节点合并，以恢复 B 树的条件（c）。
- en: '[Figure 12-15](#figure12-15) shows a case where we can transfer a key from
    a larger sibling node. We start by deleting the key 32 in [Figure 12-15](#figure12-15)(a).
    [Figure 12-15](#figure12-15)(b) shows the keys that we use to restore balance:
    the keys in the under-full node, the keys in its right-hand adjacent sibling,
    and the key in the parent separating the two. [Figure 12-15](#figure12-15)(c)
    shows which keys will move and where. The repaired tree is shown in [Figure 12-15](#figure12-15)(d).'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 12-15](#figure12-15)展示了一个可以从更大的兄弟节点转移键的情况。我们从删除 [图 12-15](#figure12-15)(a)
    中的键 32 开始。[图 12-15](#figure12-15)(b) 显示了我们用来恢复平衡的键：不足节点中的键、其右侧相邻兄弟节点中的键，以及父节点中分隔这两个节点的键。[图
    12-15](#figure12-15)(c) 显示了哪些键将被移动以及移动到哪里。修复后的树显示在 [图 12-15](#figure12-15)(d)
    中。'
- en: '![Figure A shows a subtree with one internal node and five leaf nodes. The
    internal node contains keys 12, 26, 31, and 45\. The fourth leaf contains keys
    32 and 42\. The fifth leaf contains keys 47, 48, and 49\. In Figure A, the key
    32 is removed from a leaf node, leaving a single key 42\. Figure B shows a dashed
    line around the right‐most two children and the separating key 45\. Figure C includes
    arrows showing the key 47 from the right‐most child will move into the parent
    and key 45 from the parent will move to the under‐full child. The final tree is
    shown in Figure D. The internal node has four children and contains the keys 12,
    26, 31, and 47\. The fourth leaf node contains keys 42 and 45\. The fifth leaf
    node contains keys 48 and 49.](image_fi/502604c12/f12015.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图 A 显示了一个子树，包含一个内部节点和五个叶子节点。内部节点包含键 12、26、31 和 45。第四个叶子节点包含键 32 和 42。第五个叶子节点包含键
    47、48 和 49。在图 A 中，键 32 被从叶子节点中删除，剩下单一的键 42。图 B 显示了一条虚线，围绕着最右侧的两个子节点和分隔键 45。图 C
    包括箭头，表明最右侧子节点的键 47 将移入父节点，而父节点的键 45 将移至不足的子节点。最终的树结构显示在图 D 中。内部节点有四个子节点，并包含键 12、26、31
    和 47。第四个叶子节点包含键 42 和 45。第五个叶子节点包含键 48 和 49。](image_fi/502604c12/f12015.png)'
- en: 'Figure 12-15: Deleting the key 32 from an almost empty node (a) gives the leaf
    too few elements (b). We can repair this by taking a key from an adjacent sibling
    (c) to restore the B-tree conditions (d).'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-15：从几乎为空的节点中删除键 32（a）导致叶子节点元素过少（b）。我们可以通过从相邻的兄弟节点（c）获取一个键来修复这一问题，以恢复 B
    树的条件（d）。
- en: Finally, [Figure 12-16](#figure12-16) shows a case where we remove a level from
    the tree by merging the only two children below the root. [Figure 12-16](#figure12-16)(b)
    shows that after the merge, we are left with an empty root node. Its one key has
    been moved to the merged node. We repair this in [Figure 12-16](#figure12-16)(c)
    by removing the old root node and promoting that node’s single child to be the
    new root node.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，[图 12-16](#figure12-16)展示了通过合并根节点下唯一的两个子节点来删除树中的一个层级的情况。[图 12-16](#figure12-16)(b)显示，合并后，根节点为空，其唯一的键已被移至合并后的节点。我们在[图
    12-16](#figure12-16)(c)中通过删除旧根节点，并将该节点的唯一子节点提升为新的根节点来修复此问题。
- en: Unlike addition, where the modifications to the B-tree are limited to only those
    nodes explored during the initial search for the insertion location, deletion
    can modify nodes in other branches. Both merging nodes and transferring keys use
    a sibling node at the same level. However, the total number of nodes modified
    is still limited by the depth of the tree. At most, we access one sibling node
    per level, and the number of nodes accessed scales logarithmically with *N*.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 与插入操作不同，删除操作可能会修改其他分支的节点。在插入过程中，B 树的修改仅限于初次搜索插入位置时访问的节点，而删除操作则可能修改其他分支的节点。合并节点和转移键值都使用同一级别的兄弟节点。然而，被修改的节点总数仍然受树的深度限制。最多，我们每一层只能访问一个兄弟节点，访问的节点数随
    *N* 的对数增长。
- en: '![In Figure A, the root node has the key 51 and has two children with keys
    12 and 31 in the left node and key 61 in the right node. Figure B shows the result
    of the merge operation. The root is empty and has a single child with keys 12,
    31, 51, and 61\. Figure C shows the final tree where the old root node has been
    removed. The new root is the node with keys 12, 31, 51, and 61.](image_fi/502604c12/f12016.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![在图 A 中，根节点有键 51，并且有两个子节点，左子节点包含键 12 和 31，右子节点包含键 61。图 B 显示了合并操作的结果，根节点为空，只有一个子节点，包含键
    12、31、51 和 61。图 C 显示了最终的树结构，其中旧根节点已被移除，新的根节点是包含键 12、31、51 和 61 的节点。](image_fi/502604c12/f12016.png)'
- en: 'Figure 12-16: Merging the only two children under the root node (a) results
    in an empty root (b). We repair this by promoting the root node’s only child to
    be the new root (c).'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-16：合并根节点下唯一的两个子节点（a）导致根节点为空（b）。我们通过将根节点的唯一子节点提升为新的根节点（c）来修复这一问题。
- en: Why This Matters
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么这很重要
- en: B-trees illustrate a few important concepts. First, they show how we can adapt
    the behavior of previous data structures to handle cases where memory accesses
    between nodes are more expensive than accesses within a node. B-trees combine
    indexing and storage in such a way as minimize the number of accesses we need.
    This is critical for large data sets that might keep information on a disk or
    an external server. By enforcing a minimum of *k* keys for each non-root node,
    we ensure a branching factor of at least *k* + 1 at each node and thus flatten
    out the overall data structure. This helps limit the overall depth of the tree
    and thus the number of retrievals needed for search, insertion, or deletion. We
    also guarantee that each non-root node always remains at least half-full, meaning
    that we do not waste time retrieving nodes with only a few elements (except possibly
    the root).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: B树展示了几个重要的概念。首先，它们展示了如何调整先前数据结构的行为，以处理节点间内存访问比节点内访问更昂贵的情况。B树以某种方式将索引和存储结合起来，从而最小化所需的访问次数。这对于可能将信息存储在磁盘或外部服务器上的大数据集至关重要。通过强制每个非根节点至少有
    *k* 个键，我们确保每个节点的分支因子至少为 *k* + 1，从而将整个数据结构“扁平化”。这有助于限制树的整体深度，从而减少搜索、插入或删除所需的检索次数。我们还保证每个非根节点始终保持至少半满，这意味着我们不会浪费时间去检索只有少量元素的节点（除了可能是根节点的情况）。
- en: It is useful to contrast the B-tree’s approach with a more specialized indexing
    scheme for our collectibles. We could develop a data structure that initially
    splits on category. The top-level index maps the collectible’s category, such
    as coffee-related collectibles, to a binder for that specific category. Each category’s
    binder then maps to all the subcategories, such as coffee mugs or coffee posters.
    And so forth. This is also a valid approach that builds off the branching structures
    we have seen throughout this book. The tradeoff becomes one of generalizability
    versus efficiency. In many cases, we can further optimize a data structure to
    a particular task at hand but lose the ability to apply it to other problems.
    In some cases, this tradeoff might be worth it. In others, it might not. Compared
    to a categorical focused indexing scheme, B-trees provide a more general approach
    that can work for any sortable set of keys.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 将B树的方式与我们收藏品的更专门化索引方案进行对比是有用的。我们可以开发一个数据结构，最初按类别进行划分。顶级索引将收藏品的类别（例如与咖啡相关的收藏品）映射到该特定类别的文件夹。每个类别的文件夹再映射到所有子类别，如咖啡杯或咖啡海报，依此类推。这也是一种有效的方法，建立在本书中看到的分支结构的基础上。其权衡在于通用性与效率。在许多情况下，我们可以将数据结构进一步优化以适应当前任务，但这可能会失去将其应用于其他问题的能力。在某些情况下，这种权衡可能是值得的，但在其他情况下则可能不值得。与聚焦于类别的索引方案相比，B树提供了一种更为通用的方法，适用于任何可排序的键集。
- en: The second concept B-trees illustrate is a second level of dynamism within the
    data structure itself. The B-tree constantly rearranges its structure to adapt
    to the distribution of data it stores and thus remain balanced. As we saw in Chapter
    5, we lose the advantages of the tree-based structure if our tree becomes highly
    unbalanced. B-trees programmatically prevent this through a combination of bounds
    on the number of keys in each node (*k* to 2*k*) and a guarantee that all leaf
    nodes have exactly the same depth. They adapt to “bad” distributions of input
    data by rebalancing—fixing nodes with too many or too few items. While there are
    a wide range of other balancing strategies for trees, B-trees provide a simple
    and clear example of how we can use additional structure (in this case, multiple
    keys per node) to avoid worst-case scenarios.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: B树展示的第二个概念是数据结构本身的第二级动态性。B树会不断调整其结构，以适应存储的数据分布，从而保持平衡。正如我们在第五章看到的那样，如果树变得高度不平衡，我们就会失去基于树的结构所带来的优势。B树通过限制每个节点中键的数量（*k*
    到 2*k*）以及确保所有叶子节点具有完全相同的深度来程序化地防止这一问题。它们通过重新平衡来适应“不良”数据分布——修正那些包含过多或过少项目的节点。虽然树的平衡策略有很多种，B树提供了一个简单明了的例子，展示了我们如何通过添加额外的结构（在这种情况下，每个节点多个键）来避免最坏情况的发生。
