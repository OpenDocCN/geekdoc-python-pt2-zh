- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: B-trees
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: B树
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: Chapter 11 showed how the cost of memory access can vary across mediums. In
    this chapter, we’ll discuss how this problem extends beyond accessing individual
    values to the cost of accessing new blocks of data, introducing a new data structure
    to handle this situation.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 第11章展示了内存访问成本如何在不同介质之间变化。在本章中，我们将讨论这个问题如何从访问单个值扩展到访问新数据块的成本，并介绍一种新的数据结构来处理这一情况。
- en: Computer science is full of instances where accessing data within a block is
    cheap, but retrieving a new block is comparatively expensive. A computer might
    read an entire block of information, known as a *page*, from the hard drive and
    store it in memory. In the days of floppy disk–based video games, you might see
    a message directing you to “Insert disk 5 of 7” or wait while the game loaded
    the next chunk of data from a CD. Similarly, online applications might download
    coherent blocks of data from a server across the internet, allowing you to start
    watching a video before you’ve downloaded the entire thing.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机科学中有许多例子表明，访问块内的数据成本较低，但检索新块的数据相对昂贵。例如，计算机可能会从硬盘中读取整块信息，称为 *页面*，并将其存储到内存中。在软盘视频游戏时代，你可能会看到一个提示，要求你“插入第5张磁盘中的第7张”，或者在游戏加载下一块数据时等待类似的提示。类似地，在线应用程序可能会从服务器通过互联网下载一致的数据块，让你在下载完整视频之前就能开始观看。
- en: This chapter covers the *B-tree*, a self-balancing tree-based data structure
    that computer scientists Rudolf Bayer and Edward McCreight designed to account
    for the cost of retrieving new blocks of data. B-trees store multiple pieces of
    data in a single node, allowing us to pay the expensive retrieval cost exactly
    once to extract all those values. Once the node is in local memory, we can quickly
    access the values within it. The tradeoff is additional complexity when dealing
    with the nodes.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了 *B树*，这是一种自平衡的基于树的数据结构，由计算机科学家鲁道夫·拜尔（Rudolf Bayer）和爱德华·麦克雷特（Edward McCreight）设计，用来考虑检索新数据块的成本。B树将多个数据存储在单个节点中，使我们可以一次性支付昂贵的检索费用以提取所有这些值。一旦节点被加载到本地内存中，我们就可以快速访问其中的值。其折衷是处理节点时的额外复杂性。
- en: In the computational domain, we may run into this problem when trying to index
    a massive data set. Consider the index for a literally astronomical data set that
    contains pointers to images of every star, galaxy, nebula, comet, asteroid, and
    other celestial body ever observed. The data set is still larger than the index,
    but the index itself might need to reside across many blocks of slow storage.
    B-trees provide an inventive way of combining the indexing and keys while minimizing
    retrieval costs.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算领域，我们可能会遇到这个问题，尤其是在尝试索引庞大数据集时。考虑一个字面上天文数字大小的数据集的索引，其中包含指向每颗恒星、星系、星云、彗星、小行星以及其他天体图像的指针。该数据集仍然大于索引本身，但索引可能需要跨越许多较慢存储块。B树提供了一种创新的方式，将索引和键结合起来，同时最小化检索成本。
- en: B-trees are also one example of how to define trees’ operations in such a way
    that they don’t become horribly imbalanced. As we will see later in the chapter,
    the B-tree always remains perfectly balanced with all the leaf nodes at exactly
    the same depth.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: B树也是如何定义树的操作，确保它们不会变得极度不平衡的一个例子。正如我们在本章后面将看到的，B树始终保持完美的平衡，所有叶节点的深度完全相同。
- en: B-tree Structure
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: B树结构
- en: B-trees apply the multi-way branching structure that we saw in tries or quadtrees
    to storing individual keys. Practically, this means that they allow internal nodes
    many more than two branches, so they’re practically bristling with pointers. They
    also need to store more than a single key in each node. B-tree nodes are packed
    with keys, allowing them to both track multi-way partitions and, more importantly,
    maximize the amount of data we can retrieve by fetching a single node.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: B树采用我们在字典树（tries）或四叉树（quadtrees）中看到的多路分支结构来存储单个键。实际上，这意味着它们允许内部节点拥有超过两个分支，因此它们几乎充满了指针。它们还需要在每个节点中存储多个键。B树节点包含多个键，这不仅可以追踪多路分区，而且更重要的是，最大化我们通过提取单个节点所能检索到的数据量。
- en: We see the benefit of packing multiple items into a node in the everyday context
    of online shipping. We pay a cost for every box shipped, and these costs can add
    up quickly if we are shipping many small boxes. This is the equivalent of retrieving
    many small tree nodes from expensive storage. If we pack several items into the
    same box, however, we can reduce the cost by shipping them together. Similarly,
    B-trees reduce the cost of retrieving multiple keys by retrieving a block of them
    together.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在日常在线配送的场景中看到将多个项目打包到一个节点中的好处。每个盒子都有运费，我们运送很多小盒子时，这些费用可能会迅速增加。这相当于从昂贵的存储中检索许多小的树节点。如果我们将几个项目放在同一个盒子里，我们就可以通过一起运输来降低费用。同样，B
    树通过一起检索一个块中的多个键来减少检索的成本。
- en: Formally, we define the size of B-tree node with a size parameter *k*, which
    provides bounds on how many elements a non-root node can store. All non-root nodes
    store between *k* and 2*k* keys in sorted order. The root node is more flexible
    and is allowed to contain between 0 and 2*k* keys. Like a binary search tree,
    internal nodes use the values of these keys to define the ranges for the branches.
    Internal nodes store pointers for each possible split point, before and after
    each key in the node, allowing for between *k* + 1 and 2*k* + 1 children for all
    internal nodes except the root node, which can have between 0 to 2*k* + 1 children.
    These split points are conceptually the same as what we do in a binary search
    tree—they divide the space into keys that come before the split and keys that
    come after.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 从形式上讲，我们用一个大小参数 *k* 来定义 B 树节点的大小，该参数提供了非根节点可以存储的元素数量的界限。所有非根节点存储排序后的 *k* 到 2*k*
    个键。根节点更加灵活，允许包含 0 到 2*k* 个键。像二叉搜索树一样，内部节点使用这些键的值来定义分支的范围。内部节点为每个可能的分裂点存储指针，在节点中的每个键之前和之后，都可以有
    *k* + 1 到 2*k* + 1 个子节点，除了根节点，它可以有 0 到 2*k* + 1 个子节点。这些分裂点在概念上与二叉搜索树中的分裂点相同——它们将空间划分为分裂点之前的键和分裂点之后的键。
- en: '[Figure 12-1](#figure12-1) shows an example of this structure. The node with
    keys 12, 31, and 45 defines four separate partitions: keys that come before 12,
    keys after 12 but before 31, keys after 31 but before 45, and keys after 45\.
    The subtree containing 13, 17, and 26 is defined by two split points in the parent
    node. All the keys in that node must be greater than 12 since their node’s child
    pointer is to the right of key 12\. Similarly, the keys must all be less than
    31 since the pointer is to the left of key 31.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 12-1](#figure12-1)展示了该结构的一个示例。包含键 12、31 和 45 的节点定义了四个独立的分区：小于 12 的键、介于 12
    和 31 之间的键、介于 31 和 45 之间的键，以及大于 45 的键。包含 13、17 和 26 的子树通过父节点中的两个分裂点定义。该节点中的所有键必须大于
    12，因为它们的子指针指向键 12 的右侧。同样，所有键必须小于 31，因为它们的指针指向键 31 的左侧。'
- en: '![The example B‐tree has 3 layers. The top node has a single key (51) and pointers
    to 2 children. The left child has keys 12, 31, and 45 and pointers to 4 children,
    one of which is a subtree containing 13, 17, 26.](image_fi/502604c12/f12001.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![示例 B 树有 3 层。顶部节点有一个键（51）和指向 2 个子节点的指针。左侧子节点有键 12、31 和 45，并指向 4 个子节点，其中一个是包含
    13、17、26 的子树。](image_fi/502604c12/f12001.png)'
- en: 'Figure 12-1: An example B-tree'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-1：一个示例 B 树
- en: Picture this structure in the context of indexing the vast collection at the
    Comprehensive Museum of Fun and Informative Collectibles. In an attempt to allow
    a dynamic collection, we store the index entry to each item on a small paper card
    with the name, a brief description, and the location in our massive collectibles
    warehouse. We can fit nine hundred cards into a single binder, so, for our collection
    of a hundred million items, we need over a hundred thousand binders to store the
    entire index.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个结构放在“综合趣味与信息收藏博物馆”庞大藏品的索引情境中来考虑。在允许动态更新藏品的尝试下，我们将每个项目的索引条目存储在一张小纸卡上，卡上写有项目名称、简短描述和在我们庞大收藏仓库中的位置。每个文件夹可以容纳九百张卡片，因此对于我们一亿个项目的收藏，我们需要超过十万个文件夹来存储整个索引。
- en: While we would like to store the entire index locally, we simply lack enough
    space in our office. Once we have requisitioned and retrieved a binder containing
    a slice of the index, we can browse through its entries relatively easily. However,
    asking for each new volume involves a trip to the archives and a requisition form.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们希望将整个索引存储在本地，但我们办公室的空间实在不足。一旦我们请求并取回包含索引部分的文件夹，我们就可以相对容易地浏览其中的条目。然而，每次请求新卷都需要前往档案室并填写请求表。
- en: In this organization scheme, each index card corresponds to a single entry in
    the B-tree where the name string is the key. The binders correspond to B-tree
    nodes, each with 900 pockets and thus holding a maximum of 900 keys. The entries
    within the binder are in sorted order, allowing us to search for a key with a
    linear scan or binary search. In addition, we keep one more piece of data in each
    of the binder’s pockets, a pointer to the binder containing entries between the
    current index card’s key and the key of the previous index card. As shown in [Figure
    12-2](#figure12-2), if we are looking for the target “Caffeine Unlimited Coffee
    Mug,” we would first scan past “Caffeine Ten Coffee Mug," which comes before our
    target in alphabetical order, and then hit “Jeremy’s Gourmet High-Caffeine Experience,”
    which comes after the target. At this point, we have passed the potential location
    for our target key and know that we need to search the binder before the current
    entry.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个组织方案中，每张索引卡对应B树中的一个条目，其中名称字符串是键。绑定器对应B树节点，每个节点有900个插槽，因此最多可以容纳900个键。绑定器中的条目是排序好的，这使得我们可以通过线性扫描或二分查找来搜索键。此外，我们在每个绑定器的插槽中还保存一个数据，即指向包含当前索引卡的键和前一张索引卡的键之间条目的绑定器指针。如[图12-2](#figure12-2)所示，如果我们要查找目标“Caffeine
    Unlimited Coffee Mug”，我们会首先扫描“Caffeine Ten Coffee Mug”，它在字母顺序上排在目标之前，然后扫描“Jeremy’s
    Gourmet High-Caffeine Experience”，它排在目标之后。此时，我们已经越过了目标键的潜在位置，知道需要在当前条目之前的绑定器中进行搜索。
- en: '![Three entries from our collectibles index: Caffeine Ten Coffee Mug, Jeremy’s
    Gourmet High‐Caffeine Experience Coffee Mug, and Morning Zap Brand Coffee Mug
    . Each entry has two pointers, an item pointer and a binder pointer. The binder
    pointer for Jeremy’s Gourmet High‐Caffeine Experience Coffee Mug is shown as an
    arrow.](image_fi/502604c12/f12002.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![我们的收藏品索引中的三项条目：Caffeine Ten咖啡杯、Jeremy’s Gourmet High‐Caffeine Experience咖啡杯和Morning
    Zap品牌咖啡杯。每个条目都有两个指针，一个是物品指针，一个是绑定指针。Jeremy’s Gourmet High‐Caffeine Experience咖啡杯的绑定指针显示为一个箭头。](image_fi/502604c12/f12002.png)'
- en: 'Figure 12-2: The binder pointer in our index cards indicates which binder to
    use to continue our search.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-2：我们索引卡中的绑定指针指示继续搜索时要使用哪个绑定器。
- en: We store a single additional pointer at the very back of the binder that points
    to another binder containing only keys that come after the last key in the current
    binder. In total, our binder can contain up to 900 keys (with their pointers to
    the associated collectibles) and 901 pointers to other binders.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在绑定器的最末尾存储一个额外的指针，该指针指向另一个绑定器，包含所有在当前绑定器中最后一个键之后的键。总之，我们的绑定器最多可以包含900个键（以及指向相关收藏品的指针）和901个指向其他绑定器的指针。
- en: 'As with the other tree-based data structures, we define B-tree structure using
    both a top-level composite data structure and a node-specific data structure:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他基于树的数据结构一样，我们使用顶层复合数据结构和节点特定数据结构来定义B树结构：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this data structure and the examples below, we store and retrieve individual
    keys to keep the code simple. As with the other data structures we have introduced,
    in most cases it will be useful to store a composite data structure with both
    the key and a pointer to the key’s data, such as with the item pointers in [Figure
    12-2](#figure12-2).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个数据结构和下面的示例中，我们存储和检索单个键，以保持代码简单。与我们介绍的其他数据结构一样，在大多数情况下，存储一个复合数据结构，其中既包含键又包含指向键数据的指针会更有用，就像[图12-2](#figure12-2)中的物品指针一样。
- en: One complication of the B-tree structure is that we store the keys and children
    in two differently sized arrays. This means that we need to define how a key at
    index *i* maps to its adjacent child pointers. For any given index *i*, we can
    access the key at *keys*[*i*], but we also need to be able to access the node
    pointers before and after that key. We define the pointers such that the value
    of all keys in or below *children*[*i*] are less than *keys*[*i*] and greater
    than *keys*[*i* *−* 1] (if *i* > 0), as shown in [Figure 12-3](#figure12-3).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: B树结构的一个复杂性在于我们将键和子节点存储在两个不同大小的数组中。这意味着我们需要定义键在索引*i*时如何映射到其相邻的子节点指针。对于任何给定的索引*i*，我们可以访问*keys*[*i*]中的键，但我们还需要能够访问该键之前和之后的节点指针。我们定义指针的方式是，*children*[*i*]中的所有键值都小于*keys*[*i*]，并且大于*keys*[*i*
    − 1]（如果*i* > 0），如[图12-3](#figure12-3)所示。
- en: '![The keys array contains 12, 31, and 45\. The children array has 4 pointers:
    keys less than 12, keys less than 31 and greater than 12, keys less than 45 and
    greater than 31, and keys greater than 45.](image_fi/502604c12/f12003.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![键数组包含 12、31 和 45。子数组有 4 个指针：小于 12 的键，小于 31 且大于 12 的键，小于 45 且大于 31 的键，以及大于
    45 的键。](image_fi/502604c12/f12003.png)'
- en: 'Figure 12-3: A mapping from the entries in the keys array to the corresponding
    elements in the children array'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-3：将键数组中的条目映射到子数组中相应的元素
- en: By definition, B-trees are balanced data structures. Every leaf node is exactly
    the same depth from the root. In a later section, we’ll show how this structure
    is maintained by updating nodes as we insert and delete new keys.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义，B树是平衡的数据结构。每个叶子节点与根节点的深度相同。在后面的章节中，我们将展示如何通过插入和删除新键来更新节点，从而保持这种结构。
- en: Searching B-trees
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 搜索 B 树
- en: 'We search the B-tree using the same general procedure that we use for all tree-based
    data structures: we start at the top of the tree and work our way down until we
    find the key of interest. The main difference between the B-tree and a binary
    search tree is that we might need to check more than one key per node. We scan
    along the keys in each node until we either find the target key or find a key
    with a value larger than our target. In the latter case, if we are at an internal
    node, we drop down to the appropriate child and continue the search, as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同的通用程序来搜索 B 树，正如我们对所有基于树的数据结构所采用的做法：我们从树的顶部开始，逐层向下，直到找到我们感兴趣的键。B树与二叉搜索树的主要区别在于，我们可能需要检查每个节点中的多个键。我们沿着每个节点中的键扫描，直到找到目标键或发现某个键值大于目标值。在后一种情况下，如果我们在内部节点上，我们会下移到适当的子节点，并继续搜索，如下所示：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The code for this search starts by scanning through the keys stored at the current
    node using a `WHILE` loop ❶. The loop continues until it hits the end of the key
    list (`i == node.size`) or hits a key larger than the target (`target < node.keys[i]`).
    The code checks whether it has found a matching key in the current node, and,
    if so, returns that key ❷. While the example code uses a linear scan to search
    the node for the purpose of simplicity in this example, we could also use binary
    search for better efficiency.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 该搜索的代码通过使用`WHILE`循环 ❶扫描当前节点中存储的键开始。该循环一直持续，直到它到达键列表的末尾（`i == node.size`）或遇到一个比目标值大的键（`target
    < node.keys[i]`）。代码检查是否在当前节点中找到匹配的键，如果找到，则返回该键 ❷。虽然示例代码为了简化演示使用了线性扫描来搜索节点，但我们也可以使用二分搜索来提高效率。
- en: If the code does not find a match in the current node and the current node is
    a leaf, there is no match in the tree, and the code returns `null` ❸. Otherwise,
    the code recursively explores the correct child node. It can access the correct
    child directly with the loop iterator `i` ❹, because the loop stops when either
    `i` represents the last child or `key[i] > target`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码在当前节点中没有找到匹配项且当前节点是叶子节点，则表示树中没有匹配项，代码返回`null` ❸。否则，代码会递归地探索正确的子节点。它可以直接通过循环迭代器
    `i` ❹访问正确的子节点，因为当 `i` 表示最后一个子节点或 `key[i] > target` 时，循环会停止。
- en: 'Consider the example of searching the B-tree shown earlier in [Figure 12-1](#figure12-1)
    for key 17\. In the root node, we check the first key (51) and see that it is
    greater than 17, so we drop down a level using the first child pointer. At the
    next level, we check two keys: 12 is less than our target, so we proceed past
    it; 31 is greater than our target, so we drop down to the child node whose keys
    come before 31 using the second child pointer. This process continues at the leaf
    node. [Figure 12-4](#figure12-4) illustrates this search, indicating with gray
    the array bins we have accessed and compared.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑在[图 12-1](#figure12-1)中展示的B树中搜索键 17 的例子。在根节点中，我们检查第一个键（51），并发现它大于 17，因此我们通过第一个子指针下移一级。在下一级，我们检查两个键：12
    小于目标值，因此我们跳过它；31 大于目标值，因此我们通过第二个子指针下移到一个子节点，该子节点的键值小于 31。这个过程一直持续到叶子节点。[图 12-4](#figure12-4)展示了这一搜索过程，图中用灰色标出了我们访问和比较的数组区间。
- en: '![The search of the B‐tree visits the key 51 in the top node, 12 and 31 in
    the second‐level child, and 13 and 17 in the third‐level child.](image_fi/502604c12/f12004.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![B树的搜索访问了顶级节点中的键 51、第二级子节点中的键 12 和 31，以及第三级子节点中的键 13 和 17。](image_fi/502604c12/f12004.png)'
- en: 'Figure 12-4: An example search of a B-tree. The shaded cells are the ones checked
    by the algorithm.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-4：B树的一个搜索示例。阴影单元格是算法检查过的单元。
- en: 'We should consider how searching the keys within a node impacts the runtime:
    instead of dropping down to the next level after a single comparison, we might
    now have to perform multiple comparisons per node. This is an acceptable tradeoff
    for two reasons. First, remember the B-tree is optimized to reduce the number
    of nodes fetched. In comparison, the data accesses within a node are expected
    to be relatively cheap because they are happening in local memory and do not require
    us to fetch another block of data from the expensive storage. Second, and equally
    important, the branching structure of the B-tree still provides ample opportunities
    for pruning. Each comparison still eliminates entire subtrees. And, like the current
    node, each skipped node may contain up to 2*k* keys and 2*k* + 1 children.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该考虑在节点内搜索键值对运行时的影响：与单次比较后直接进入下一级不同，现在可能需要在每个节点上执行多个比较。这是一个可以接受的权衡，原因有二。首先，记住B树是经过优化的，目的是减少访问的节点数量。相比之下，节点内部的数据访问预期是相对廉价的，因为它们发生在本地内存中，并不需要我们从昂贵的存储中获取另一个数据块。其次，同样重要的是，B树的分支结构仍然提供了大量的剪枝机会。每次比较依然可以排除整个子树。而且，像当前节点一样，每个被跳过的节点最多可能包含2*k*个键值和2*k*
    + 1个子节点。
- en: 'Returning to our collectibles example, consider a search for a particular collectible.
    We start at the root binder. Since the keys are stored in alphabetical order,
    we can rapidly skim down the rows until we find our desired key or pass where
    it should be. If we don’t see our desired key, we know it isn’t in this binder.
    We mumble a few choice words about the unfairness of finite storage space and
    note the first key we encounter that comes after our target key has an item pointer
    reading “Binder #300.” We mumble a few more complaints and ask the archivist for
    binder #300.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的收藏品示例，考虑搜索某个特定的收藏品。我们从根文件夹开始。由于键值是按字母顺序存储的，我们可以迅速浏览行，直到找到我们想要的键值，或者经过它应在的位置。如果我们没有看到目标键值，我们就知道它不在这个文件夹中。我们会抱怨一番有限存储空间的不公平，并注意到我们遇到的第一个比目标键值大的键值，它的项目指针指向“文件夹#300”。我们会继续抱怨几句，然后向档案管理员索要文件夹#300。
- en: 'Let’s contrast this storage approach with what happens if we instead store
    all our index cards in sorted order. Binder #1 contains the first set of cards
    *Aa* through *Ab*, binder #2 contains *Ac* through *Ad*, and so forth. This could
    work well for a static data set. We could perform a binary search over the binders,
    requesting the middle binder in our current range each time and limiting ourselves
    to a logarithmic number of requests. However, this approach begins to break down
    as we add or remove cards. Binders become overfull, requiring us to shift cards
    from one binder to the next. Updates to our collection might require cascading
    updates to many binders as cards must be shifted over. In the worst case, if we
    pack our binders full, we could end up needing to access every binder in our index.
    As we will see next, B-trees structures facilitate dynamic changes to the data
    set.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这种存储方式与将所有索引卡片按排序顺序存储的情况进行对比。文件夹#1包含从*Aa*到*Ab*的第一组卡片，文件夹#2包含*Ac*到*Ad*，依此类推。这对于静态数据集来说可能效果不错。我们可以对文件夹进行二分查找，每次请求当前范围内的中间文件夹，并将请求次数限制在对数级别。然而，随着卡片的增删，这种方式开始崩溃。文件夹变得过满，要求我们将卡片从一个文件夹移动到另一个文件夹。更新集合时可能需要级联更新多个文件夹，因为卡片必须被移位。在最坏的情况下，如果我们将文件夹装得满满的，我们可能需要访问索引中的每个文件夹。正如我们接下来所看到的，B树结构有助于数据集的动态变化。
- en: Adding Keys
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加键值
- en: Adding keys to a B-tree is more complex than adding to the tree-based data structures
    we’ve previously considered. In this case, we need to keep the structure balanced
    and limit the number of keys stored in each node (between *k* and 2*k*). There
    are two approaches for handling full nodes. First, we could split as we proceed
    down the tree, making sure we never call insertion on a full node. Second, we
    can temporarily insert into a full node (allowing it to be overfull) and then
    split it on the way back up. We’ll explore the later approach, which results in
    a two-stage algorithm for inserting new keys.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 向B树添加键值比我们之前考虑的基于树的其他数据结构要复杂。在这种情况下，我们需要保持结构平衡，并限制每个节点中存储的键值数量（介于*k*和2*k*之间）。处理满节点有两种方法。第一，我们可以在树的过程中分裂，确保我们永远不会在满节点上执行插入操作。第二，我们可以暂时将键值插入到满节点中（允许其超载），然后在返回的过程中进行分裂。我们将探讨后一种方法，它导致了一个两阶段的算法来插入新键值。
- en: To perform insertions, we first proceed down the tree, searching for the position
    to insert the new key. Second, we return back up the tree, splitting nodes that
    have become overfull. Each split increases the branching factor of a node, but
    not necessarily the height. In fact, the only time we increase the height of the
    tree is when we split the root node itself. Because we only increase the height
    by splitting the root node (adding a depth of 1 to every leaf simultaneously),
    we can guarantee that the tree always remains balanced.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行插入操作，我们首先沿着树向下搜索，寻找插入新键的位置。然后，我们返回到树的上方，拆分已经溢出的节点。每一次拆分都会增加节点的分支因子，但不一定增加树的高度。事实上，只有在拆分根节点时，我们才会增加树的高度。因为我们只是通过拆分根节点来增加树的高度（同时为每个叶子节点增加一个深度），我们可以保证树始终保持平衡。
- en: The Addition Algorithm
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加算法
- en: During the first stage of the algorithm, we recursively descend the tree, searching
    for the correct location to insert the new key. If we find a matching key along
    the way, we can update that key’s data. Otherwise, we proceed down to a leaf node,
    where we insert the key into our array.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在算法的第一阶段，我们递归地向下遍历树，寻找插入新键的正确位置。如果在过程中找到匹配的键，我们可以更新该键的数据。否则，我们继续向下到达叶节点，在那里我们将键插入到数组中。
- en: We start off by defining a simple helper function `BTreeNodeAddKey` to insert
    a key into a non-full node. For convenience, we also take a pointer to a child
    node (representing the child *after* the new key) so that we can reuse this function
    when splitting nodes. If we are at a leaf node, which doesn’t store pointers to
    children, this `next_child` pointer is ignored.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义一个简单的辅助函数`BTreeNodeAddKey`，用于将一个键插入到一个非满的节点中。为了方便起见，我们还传递一个指向子节点的指针（表示新键*之后*的子节点），这样我们可以在拆分节点时重用这个函数。如果我们位于一个叶节点，该节点不存储指向子节点的指针，那么`next_child`指针将被忽略。
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The code starts at the *end* of the `keys` array (index `node.size – 1`) and
    proceeds toward index 0 using a `WHILE` loop ❶. At each step, it checks whether
    the new key should be inserted here and, if not, shifts the current element of
    both `keys` and `children` back one space. The loop terminates when it has gone
    one step past the correct location, which might be the start of the array. Once
    we have found the correct location for the new key, we have already moved that
    and the following elements out of the way. We can directly insert the new key
    and child ❷. The code finishes by adjusting the size of the node to account for
    the insertion ❸.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 代码从`keys`数组的*末尾*（索引`node.size – 1`）开始，并通过`WHILE`循环 ❶向索引0方向推进。在每一步中，代码会检查新键是否应该插入当前位置，如果不应该，就将`keys`和`children`数组中的当前元素向后移动一个位置。循环在超过正确位置一步时终止，这个位置可能是数组的起始位置。一旦找到新键的正确插入位置，已经移动了新键和后续元素的位置。我们可以直接插入新键和子节点
    ❷。代码最后通过调整节点的大小来考虑插入 ❸。
- en: Here we may gasp in dismay at the cost of linearly shifting down items in the
    array to make room for our new element, as shown in [Figure 12-5](#figure12-5).
    This is everything we warned about in Chapter 3. But remember, we are trading
    off these (bounded) linear costs to minimize node accesses. We are willing to
    put up with the hassle of moving down the cards within our binder to minimize
    future requisitions to other binders.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可能会对在数组中线性地移动项以腾出位置来插入新元素的成本感到惊讶，如[图12-5](#figure12-5)所示。这正是我们在第3章中提到的所有问题。但请记住，我们正在权衡这些（有限的）线性成本，以尽量减少对节点的访问。我们愿意忍受将卡片移到活页夹中的麻烦，以最小化未来对其他活页夹的需求。
- en: '![An array for four spots. The key 26 is inserted into the second spot in the
    array, and the following two keys 31 and 45 are each shifted back one position.](image_fi/502604c12/f12005.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![一个包含四个位置的数组。键26被插入到数组的第二个位置，随后两个键31和45分别向后移一个位置。](image_fi/502604c12/f12005.png)'
- en: 'Figure 12-5: Shifting the elements over to insert 26 in `BTreeNodeAddKey`'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-5：在`BTreeNodeAddKey`中将元素移位以插入26
- en: 'We require a few more helper functions to handle the case where a node fills
    up. Remember that we are restricted to at most 2*k* elements per node—any more
    than that means we need to split the node. First, we start with a simple accessor
    function `BTreeNodeIsOverFull`, which returns a Boolean indicating whether the
    node contains more than 2*k* items:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一些额外的辅助函数来处理节点填满的情况。请记住，我们每个节点最多只能包含2*k*个元素——超过这个数量就需要拆分节点。首先，我们从一个简单的访问器函数`BTreeNodeIsOverFull`开始，该函数返回一个布尔值，表示节点是否包含超过2*k*个元素：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is equivalent to checking if we have used up all the pockets in our binder.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当于检查我们是否已经用完了活页夹中的所有口袋。
- en: We also add a second helper `BTreeNodeSplit`, which takes a node and the index
    of a child and splits that child. Everything before that index is retained in
    the original child. Everything after that index is cleared from the child and
    added to a newly created sibling node. The key at the index itself is cleared
    from the child and added to the current (parent) node.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了第二个辅助函数 `BTreeNodeSplit`，它接收一个节点和一个子节点的索引，并拆分该子节点。该索引之前的内容保留在原子节点中，索引之后的内容从子节点中清除，并添加到新创建的兄弟节点中。位于该索引处的关键字会从子节点中清除并添加到当前（父）节点中。
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The code for `BTreeNodeSplit` starts by looking up the node to split (`old_child`)
    and creating a new (empty) sibling node (`new_child`) ❶. This node will be at
    the same level as the child to split, so we copy over the value of `is_leaf`.
    Next the code determines what index and key to use as a split point for `old_child`
    ❷. The code then uses a `WHILE` loop to copy everything after `split_index` from
    both the `keys` and `children` in `old_child` to the corresponding arrays in `new_child`
    ❸. The code uses a pair of indices to capture the index of the old location (`old_index`)
    and the corresponding new location (`new_index`). At the same time, the code removes
    the elements from `old_child`’s arrays by setting the entries to `null`. Because
    the `children` array is one element longer, we need to copy that last element
    separately ❹. Finally, we remove the key at `split_index` ❺, add both `split_key`
    and the new child pointer to the current node ❻, and set both the children’s sizes
    ❼.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`BTreeNodeSplit`的代码首先查找要拆分的节点（`old_child`）并创建一个新的（空的）兄弟节点（`new_child`）❶。该节点将与要拆分的子节点处于同一级别，因此我们将
    `is_leaf` 的值复制过去。接下来，代码确定用于拆分点的索引和关键字❷。然后，代码使用 `WHILE` 循环将 `old_child` 中 `split_index`
    之后的内容从 `keys` 和 `children` 数组复制到 `new_child` 中的相应数组❸。代码使用一对索引来捕获旧位置的索引（`old_index`）和相应的新位置（`new_index`）。同时，代码通过将条目设置为
    `null` 来从 `old_child` 的数组中删除元素。由于 `children` 数组多了一个元素，我们需要单独复制最后一个元素❹。最后，我们删除
    `split_index` 处的关键字❺，将 `split_key` 和新的子节点指针添加到当前节点❻，并设置两个子节点的大小❼。'
- en: Let’s view this operation in the context of our collectibles storage index as
    shown in [Figure 12-6](#figure12-6). When a binder reaches capacity, we repartition
    its contents into two binders. First, we buy a new empty binder. This sibling
    will store approximately half the contents of the overfull binder. Second, we
    carefully relocate the back half of the overfull binder’s contents into the new
    binder, preserving the sorted ordering. Third, we remove the single index card
    whose key lies between the keys in each binder and insert it in the parent binder
    in order to indicate the divide between the two child binders. The previously
    overfull child binder will contain cards whose keys come before this split, and
    the new binder will contain cards whose keys come after this split.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的收藏品存储索引的上下文中查看这个操作，如[图 12-6](#figure12-6)所示。当文件夹达到容量时，我们将其内容重新划分为两个文件夹。首先，我们购买一个新的空文件夹。这个兄弟文件夹将存储大约一半的超满文件夹内容。其次，我们小心地将超满文件夹后半部分的内容迁移到新文件夹中，并保持排序顺序。第三，我们移除唯一的索引卡片，该卡片的关键字位于两个文件夹的关键字之间，并将其插入到父文件夹中，以指示两个子文件夹之间的分割。之前超满的子文件夹将包含关键字在此分割之前的卡片，而新文件夹将包含关键字在此分割之后的卡片。
- en: '![A row  with three entries: Caffeine Ten Coffee Mug, Jeremy’s Gourmet High‐Caffeine
    Experience Coffee Mug, and Morning Zap Brand Coffee Mug. An arrow indicates that
    the card on the left (and all preceding cards) stays in the binder. A second arrow
    indicates the middle card goes to the parent binder. A third arrow indicates that
    the card on the right and all following cards goes to the new binder.](image_fi/502604c12/f12006.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![一排有三个条目的商品：Caffeine Ten 咖啡杯、Jeremy’s Gourmet 高咖啡因体验咖啡杯和 Morning Zap 品牌咖啡杯。箭头指示左边的卡片（以及所有之前的卡片）保留在文件夹中。第二个箭头指示中间的卡片进入父文件夹。第三个箭头指示右边的卡片和所有后续卡片进入新的文件夹。](image_fi/502604c12/f12006.png)'
- en: 'Figure 12-6: We repartition the binder by splitting it on the key of the middle
    card.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-6：我们通过在中间卡片的关键字上拆分来重新划分文件夹。
- en: Given these helpers, we can now define an insertion function that performs the
    recursive search and the subsequent addition. We perform the addition at the leaf
    node. As the recursion returns up the tree, we check whether the recently accessed
    child node is full and thus needs to be split.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 给定这些辅助函数，我们现在可以定义一个插入函数，该函数执行递归查找和随后的添加操作。我们在叶节点进行添加。当递归返回到树的上层时，我们检查最近访问的子节点是否已满，因此需要进行拆分。
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The code starts by finding the correct location for `key` in the `keys` array
    ❶. The `WHILE` loop iterates through the array until it hits the end of the key
    list (`i == node.size`) or hits a key that is larger than the target (`key < node.keys[i]`).
    If the code finds an exact match, it updates any data for this key and returns
    ❷. Otherwise, it needs to insert new data.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先找到`key`在`keys`数组中的正确位置 ❶。`WHILE` 循环会遍历数组，直到它到达键列表的末尾（`i == node.size`）或遇到一个大于目标的键（`key
    < node.keys[i]`）。如果代码找到了完全匹配，它会更新该键的任何数据并返回 ❷。否则，它需要插入新数据。
- en: If the key is being inserted into a leaf, the code uses the `BTreeNodeAddKey`
    function ❸, which shifts the array elements over and adds the new key to the correct
    location. If the key is being inserted into an internal node, the index `i` provides
    the pointer of the correct child for insertion. The code recursively inserts into
    that child ❹, then checks whether it broke the properties of a B-tree (specifically
    the size of nodes falling between *k* and 2*k*) with the insertion ❺.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果键被插入到叶节点中，代码会使用`BTreeNodeAddKey`函数 ❸，该函数将数组元素移位并将新键插入正确的位置。如果键被插入到内部节点中，索引`i`提供了正确子节点的指针用于插入。代码会递归地插入到该子节点
    ❹，然后检查插入后是否破坏了 B 树的属性（特别是节点大小应在 *k* 和 2*k* 之间） ❺。
- en: The code breaks the B-tree property if it inserts too many elements into a node.
    We can use our helper function `BTreeNodeIsOverFull` to check if the recently
    modified node has too many elements. The code conducts this check from the parent
    node, so we can keep the logic of repairing the B-tree simple. It uses `BTreeNodeSplit`
    to split the overfull child into two nodes ❻. In the process of this insertion,
    we might break the current node when inserting the new separating key, but that’s
    okay; we’ll take care of it when we return to this node’s parent.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码将太多元素插入到一个节点中，它会破坏 B 树的属性。我们可以使用辅助函数`BTreeNodeIsOverFull`来检查最近修改的节点是否包含太多元素。代码从父节点进行此检查，因此我们可以保持修复
    B 树的逻辑简单。它使用`BTreeNodeSplit`将过满的子节点拆分为两个节点 ❻。在这个插入过程中，当插入新的分隔键时，我们可能会破坏当前节点，但没关系；当我们回到这个节点的父节点时，我们会处理它。
- en: We use a little extra storage in order to simplify the code. The code allows
    a node to temporarily overfill, storing 2*k* + 1 keys and 2*k* + 2 children while
    waiting for its parent node to call `BTreeNodeSplit`. We can create this buffer
    by simply allocating large enough arrays for the keys and children.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了一些额外的存储空间来简化代码。代码允许节点暂时过满，在等待父节点调用`BTreeNodeSplit`时，存储 2*k* + 1 个键和 2*k*
    + 2 个子节点。我们可以通过简单地为键和子节点分配足够大的数组来创建这个缓冲区。
- en: We can think of the first phase of the code as receiving a new coffee mug for
    our collection. We create an index card for the mug and insert it into our indexing
    binders. We start at the root binder and search for the location to put the card.
    During our search, we follow the appropriate pointers to child binders. Once we
    end up at a leaf binder, with no children indicated on the index cards, we add
    the new card there. We check whether the binder is now (over)full and, if it is,
    start repartitioning its contents. Afterward, we return the binders to storage
    in the reverse order that we requisitioned them. If we just split a binder and
    thus transferred a new card to its parent, we also check whether we need to split
    the parent binder. This process continues until we’ve returned to the root binder.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将代码的第一阶段看作是为我们的收藏添加一个新的咖啡杯。我们为这个咖啡杯创建一个索引卡，并将其插入到我们的索引文件夹中。我们从根文件夹开始，寻找放置卡片的位置。在搜索过程中，我们按照相应的指针进入子文件夹。一旦我们到达一个叶文件夹，没有在索引卡上指示任何子项，我们就将新卡片放在那里。我们检查该文件夹是否现在（过）满，如果是，就开始重新分配它的内容。然后，我们按照请求它们的反向顺序将文件夹归还到存储中。如果我们刚刚拆分了一个文件夹并因此将新卡片转移到其父文件夹，我们也会检查是否需要拆分父文件夹。这个过程会一直持续，直到我们回到根文件夹。
- en: 'We need to define one additional special case for the root node. Remember that
    splitting the root node is the only way we are allowed to increase the height
    of the tree. We need to define a wrapper function to do exactly that. Luckily,
    we can reuse our previous helper functions:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为根节点定义一个额外的特殊情况。记住，拆分根节点是唯一允许我们增加树的高度的方式。我们需要定义一个包装函数来完成这项操作。幸运的是，我们可以重用之前的辅助函数：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The code starts by inserting the `key` into the root node using `BTreeNodeInsert`
    ❶. This function recursively descends the tree, finds the correct location to
    insert the new key, and returns through the levels fixing the broken B-tree property
    at all but the root node. Then the code checks if the root node has too many elements
    by using `BTreeNodeIsOverFull` on the root node ❷. If the root node has too many
    elements, the code adds a level to the tree by creating a new empty root node
    ❸, assigning the old root to be the first child of the new root ❹, splitting this
    (overfull) child ❺, and updating the tree’s root ❻. After a split, the new root
    node will contain exactly one key and two children.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 代码从使用`BTreeNodeInsert` ❶将`key`插入根节点开始。这个函数递归地向下遍历树，找到正确的位置插入新键，并通过各个层级返回，修复除了根节点外的所有B树属性。接着，代码通过对根节点使用`BTreeNodeIsOverFull`
    ❷检查根节点是否有太多元素。如果根节点有太多元素，代码通过创建一个新的空根节点来向树中添加一个新层级 ❸，将旧根节点指定为新根节点的第一个子节点 ❹，拆分这个（过满的）子节点
    ❺，并更新树的根节点 ❻。在拆分之后，新的根节点将包含一个键和两个子节点。
- en: In the process of inserting a key, we complete a single round trip from the
    root node to a leaf node and back. The number of nodes we need to access (and
    modify) is thus proportional to the depth of the tree. Since our B-tree always
    remains balanced, with all leaf nodes at the same depth, and the branching factor
    of all non-root, internal nodes is at least *k* + 1, the node retrievals scales
    logarithmically in *N*. The total work also includes linear operations within
    the node, such as copying or shifting keys, so the total work required scales
    proportional to *k* × log[*k*](*N*).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在插入一个键的过程中，我们完成了从根节点到叶节点再返回的单次往返。我们需要访问（并修改）的节点数因此与树的深度成正比。由于我们的B树始终保持平衡，所有叶节点处于相同的深度，并且所有非根内部节点的分支因子至少为*k*
    + 1，因此节点检索的规模在*N*上按对数增长。总的工作量还包括节点内的线性操作，比如复制或移动键值，因此所需的总工作量与*k* × log[*k*](*N*)成正比。
- en: Examples of Adding Keys
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加键的示例
- en: Let’s consider a few examples to better understand the functions we just covered.
    First, take the simplest case, shown in [Figure 12-7](#figure12-7), of adding
    a key to leaf node that will not be overfull. Suppose *k* = 2, where our non-root
    nodes can contain between 2 and 2*k* = 4 items. If we add the key 30 to the subtree
    in [Figure 12-7](#figure12-7)(a), we simply proceed down to the leaf node and
    add the new key in the correct part of the array with the `BTreeNodeAddKey` helper
    function. Since the leaf has four elements, we do not need to split it. We get
    the subtree shown in [Figure 12-7](#figure12-7)(b).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一些例子，以更好地理解我们刚刚介绍的功能。首先，考虑最简单的情况，如[图12-7](#figure12-7)所示，即向一个不会过满的叶节点添加键。假设*k*
    = 2，在这种情况下，我们的非根节点可以包含2到2*k* = 4个元素。如果我们将键30添加到[图12-7](#figure12-7)(a)中的子树，我们只需向下遍历到叶节点，并使用`BTreeNodeAddKey`辅助函数将新键添加到数组的正确位置。由于叶节点已有四个元素，我们不需要拆分它。我们得到的子树如[图12-7](#figure12-7)(b)所示。
- en: '![Figure A shows a subtree with one internal node and four leaf nodes. The
    second leaf node has keys 13, 17, and 26\. Figure B shows the same tree but with
    the key 30 added to the end of the second child node. That node now has keys 13,
    17, 26, and 30.](image_fi/502604c12/f12007.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图A显示一个包含一个内部节点和四个叶节点的子树。第二个叶节点包含键13、17和26。图B显示相同的树，但在第二个子节点的末尾添加了键30。该节点现在包含键13、17、26和30。](image_fi/502604c12/f12007.png)'
- en: 'Figure 12-7: Inserting the key 30 into a non-full B-tree leaf (a) results in
    a leaf node with four elements (b).'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-7：向一个未满的B树叶节点插入键30（a）后，得到一个包含四个元素的叶节点（b）。
- en: The logic becomes more complex as we fill up nodes. Consider the example shown
    in [Figure 12-8](#figure12-8)(a) of adding the key 29 to the same tree. After
    inserting the new key in [Figure 12-8](#figure12-8)(b), the leaf node is overfull.
    We handle this by identifying the split point of the overfull node (key = 26)
    and promoting that to the parent node. We then use the helper function `BTreeNodeSplit`
    to divide the leaf into two siblings as shown in [Figure 12-8](#figure12-8)(c).
    If the promotion of the middle element fills up the internal node, we need to
    split that as well.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 随着节点的填充，逻辑变得更加复杂。考虑在[图12-8](#figure12-8)(a)中向同一棵树添加键29的示例。在[图12-8](#figure12-8)(b)中插入新键后，叶节点已满。我们通过识别过满节点的分割点（键=26）并将其提升到父节点来处理此问题。然后，我们使用辅助函数`BTreeNodeSplit`将叶节点分成两个兄弟节点，如[图12-8](#figure12-8)(c)所示。如果提升中间元素导致内部节点已满，我们还需要对其进行拆分。
- en: '![Figure A shows a subtree with one internal node and four leaf nodes. The
    second leaf node has keys 13, 17, 26, and 30\. In figure B, the key 29 has been
    added to the second child, and the node is overfull with keys 13, 17, 26, 29,
    and 30\. In Figure C, the second child has been split into two nodes (13, 17)
    and (29, 30), and the key 26 has been promoted to its parent.](image_fi/502604c12/f12008.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图 A 显示了一个包含一个内部节点和四个叶子节点的子树。第二个叶子节点包含键 13、17、26 和 30。在图 B 中，键 29 已被添加到第二个子节点，导致该节点存储的键值过多，包含键
    13、17、26、29 和 30。在图 C 中，第二个子节点被拆分成两个节点（13、17）和（29、30），并且键 26 被提升到其父节点。](image_fi/502604c12/f12008.png)'
- en: 'Figure 12-8: Inserting the key 29 into an already-full leaf node (a) gives
    the leaf too many elements (b). We must split the overfull leaf to restore the
    B-tree conditions (c).'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-8：将键 29 插入到已满的叶子节点中（a）会使该叶子节点包含过多的元素（b）。我们必须拆分过满的叶子节点，以恢复 B 树的条件（c）。
- en: Finally, consider what happens if our splits propagate all the way back to the
    root node. Suppose that, after an insertion, the root node itself overfills as
    shown in [Figure 12-9](#figure12-9)(a). We solve this problem in [Figure 12-9](#figure12-9)(b)
    by splitting the root node and creating a new level for the tree. The new root
    node contains exactly one element, the middle key of the previous root node. Note
    that, unlike all the other nodes, the root node is allowed to have less than *k*
    items. In fact, every time we split the root node, we create a new root with exactly
    one item.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，考虑一下如果我们的拆分一直传播到根节点会发生什么。假设在插入操作后，根节点本身变得过满，如图 [12-9](#figure12-9)(a) 所示。我们在
    [图 12-9](#figure12-9)(b) 中通过拆分根节点并为树创建一个新的层级来解决这个问题。新的根节点仅包含一个元素，即之前根节点的中间键。请注意，与所有其他节点不同，根节点可以少于
    *k* 个元素。事实上，每次我们拆分根节点时，都会创建一个仅包含一个元素的新根节点。
- en: As the examples in this section show, the modifications to the B-tree are limited
    to only those nodes explored during the initial search for the insertion location.
    Since we do not need to update or repair other branches, the total number of modified
    nodes is limited by the depth of the tree and thus scales proportional to log[*k*](*N*).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本节中的示例所示，B 树的修改仅限于在最初查找插入位置时访问的那些节点。由于我们不需要更新或修复其他分支，修改的节点数量仅受树的深度限制，因此按比例与
    log[*k*](*N*) 成正比。
- en: '![Figure A shows a B‐tree with an overfull root node containing the keys 12,
    31, 51, 61, and  86\. The root node has five children, which are all leaves. Figure
    B shows the resulting tree after the split, with a new root node with key 51 and
    two children. The root''s left child contains keys 12 and 31\. The root’s right
    child contains keys 61 and 86\. The tree has the same five leaves.](image_fi/502604c12/f12009.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图 A 显示了一个根节点过满的 B 树，根节点包含键 12、31、51、61 和 86。根节点有五个子节点，所有子节点都是叶子节点。图 B 显示了拆分后的树，新的根节点包含键
    51，并有两个子节点。根节点的左子节点包含键 12 和 31。根节点的右子节点包含键 61 和 86。树的五个叶子节点保持不变。](image_fi/502604c12/f12009.png)'
- en: 'Figure 12-9: When the root node of a B-tree becomes overfull (a), we split
    it into two siblings and promote the middle element to the new root node (b).'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-9：当 B 树的根节点变得过满时（a），我们将其拆分成两个兄弟节点，并将中间元素提升为新的根节点（b）。
- en: Removing Keys
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除键
- en: Removing keys follows a similar approach to adding keys. We again need to keep
    the structure balanced and limit the number of keys stored in each node (between
    *k* and 2*k*). This results in a multi-stage algorithm for deleting keys. First,
    we proceed down the tree as though we were searching for the key. Once we find
    it, we delete the key. Finally, we return back up the tree checking for and fixing
    nodes with too few keys. Since we never remove a node except an empty root node
    (decreasing the depth of all the leaves by one), we again guarantee that the tree
    always remains balanced.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 删除键遵循类似于添加键的方法。我们需要再次保持结构平衡，并限制每个节点中存储的键的数量（在 *k* 和 2*k* 之间）。这导致删除键的算法是一个多阶段过程。首先，我们沿树向下搜索，就像在寻找键一样。一旦找到该键，我们将其删除。最后，我们返回树的上方，检查并修复那些键数量过少的节点。由于我们从不删除除空根节点之外的任何节点（减少所有叶子节点的深度），我们再次保证树始终保持平衡。
- en: Fixing Under-full Nodes
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修复过少的节点
- en: 'When we remove keys from a B-tree, we run the risk of nodes dropping below
    the minimum of *k* keys. We can check this condition with a simple helper function:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从 B 树中删除键时，我们面临节点键数低于 *k* 个的风险。我们可以通过一个简单的辅助函数来检查这个条件：
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Depending on the structure of the B-tree, there are two different approaches
    we may need to use to fix an under-full node, both of which I’ll discuss in this
    section. Each approach relies on augmenting the node’s keys with keys from an
    adjacent sibling. In the first case, we directly merge two small sibling nodes
    into a single node. In the second case, we transfer a key from a larger sibling
    to the under-full node. Which function we use depends on how many keys in total
    the two siblings have. Both of these helper functions are called from the parent
    node with the index for the key that separates the adjacent sibling nodes.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 根据B树的结构，我们可能需要使用两种不同的方法来修复一个节点不足的情况，下面我将讨论这两种方法。每种方法都依赖于通过相邻兄弟节点的关键字来扩展当前节点的关键字。在第一种情况下，我们直接将两个小的兄弟节点合并为一个节点。在第二种情况下，我们将一个较大兄弟节点的关键字转移到不足的节点中。我们使用哪个功能取决于这两个兄弟节点的关键字总数。两种辅助函数都通过父节点调用，父节点会传递分隔相邻兄弟节点的关键字的索引。
- en: The merge operation takes two adjacent sibling nodes, along with the key separating
    them, and concatenates them into a single large child node. As such, it requires
    that the combined number of keys in the two siblings be *less* than 2*k* so that
    the new child is guaranteed to be valid. [Figure 12-10](#figure12-10) shows this
    procedure, with [Figure 12-10](#figure12-10)(a) depicting a subtree before the
    merge operation, where the middle child has a single key. [Figure 12-10](#figure12-10)(b)
    shows the same subtree after the merge.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 合并操作需要两个相邻的兄弟节点以及将它们分隔开的关键字，并将它们合并为一个大的子节点。因此，要求两个兄弟节点中关键字的总数*小于*2*k*，以确保新子节点是有效的。[图
    12-10](#figure12-10) 展示了这一过程，其中[图 12-10](#figure12-10)(a) 描述了合并操作前的子树，图中间的子节点只有一个关键字。[图
    12-10](#figure12-10)(b) 展示了合并后的同一子树。
- en: '![Figure A shows a node with three leaves and a single internal node. The internal
    node has keys 26 and 31\. The middle leaf has only a single key 29, and the right‐most
    leaf has two keys 32 and 42\. Figure B shows a node with two leaves. The internal
    node now has a single key, 26\. The right‐most node now has keys 29, 31, 32, and
    42.](image_fi/502604c12/f12010.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图 A 显示了一个包含三个叶子节点和一个内部节点的节点。内部节点的关键字是26和31。中间的叶子节点只有一个关键字29，最右边的叶子节点有两个关键字32和42。图
    B 显示了一个包含两个叶子节点的节点。内部节点现在只有一个关键字26。最右边的节点现在有关键字29、31、32和42。](image_fi/502604c12/f12010.png)'
- en: 'Figure 12-10: The merge operation on B-tree nodes'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-10：B树节点的合并操作
- en: '[Listing 12-1](#listing12-1) shows the code for merging two adjacent siblings.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 12-1](#listing12-1) 显示了合并两个相邻兄弟节点的代码。'
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 12-1: Code for merging two child nodes'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12-1：合并两个子节点的代码
- en: The code appends the keys from the right child and the separating key from the
    parent onto the left child. It starts by retrieving both child nodes, which we
    call `childL` and `childR` for left and right respectively ❶. By definition, any
    key in `childL` is less than the separating key, and any key in `childR` is greater
    than the separating key. The code then appends the separating key from the parent
    and the first child pointer from the right child to the end of the left child
    ❷. It uses a `WHILE` loop to copy the remaining keys and pointers from the right
    child ❸. It also updates the left child’s size. At this point, it has successfully
    created the merged node out of the two children. The merged child’s pointer is
    stored in `node.children[index]`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 代码将右子节点的关键字和父节点的分隔关键字附加到左子节点上。它首先检索两个子节点，我们分别称其为`childL`（左子节点）和`childR`（右子节点）❶。根据定义，`childL`中的任何关键字都小于分隔关键字，而`childR`中的任何关键字都大于分隔关键字。接下来，代码将父节点的分隔关键字和右子节点的第一个子指针附加到左子节点的末尾❷。它使用`WHILE`循环从右子节点复制剩余的关键字和指针❸。同时，它更新左子节点的大小。此时，已经成功将两个子节点合并为一个新节点。合并后的子节点指针存储在`node.children[index]`中。
- en: The code finishes by cleaning up the parent node ❹. It removes the previous
    separating key and the pointer to the right child by shifting the subsequent keys
    and pointers over, setting the final bins to `null`, and updating the current
    node’s size.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的最后部分通过清理父节点来完成❹。它通过移动后续的关键字和指针，删除之前的分隔关键字和指向右子节点的指针，将最终的单元设置为`null`，并更新当前节点的大小。
- en: In the process of merging two nodes, we are taking a key from their parent.
    This could leave the parent node with less than *k* keys, and our repairs would
    need to continue at the next higher level of the tree.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在合并两个节点的过程中，我们从它们的父节点获取一个关键字。这可能会导致父节点的关键字数量少于*k*，因此我们需要在树的更高层级继续进行修复。
- en: This process is directly analogous to merging binders in our storage indexing
    example. If an index binder contains too few keys, it is a waste of space and
    requisition time. We wouldn’t want to requisition a binder with a single index
    card. Merging binders consists of taking the cards from one child binder, along
    with the separating card from the parent binder, and putting them in the other
    child binder in the correct order. Since we have already requisitioned the parent
    and one child (and thus have them in local memory), we can do this merge quickly
    with only a single additional requisition for the other child.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这一过程直接类似于我们在存储索引示例中合并绑定器的操作。如果一个索引绑定器包含的键太少，那么它就浪费空间和请求时间。我们不希望请求一个只有一张索引卡的绑定器。合并绑定器的过程是将一个子绑定器中的卡片连同父绑定器中的分隔卡片一起，按照正确的顺序放入另一个子绑定器中。由于我们已经请求了父绑定器和一个子绑定器（因此它们已经在本地内存中），我们可以通过一次额外的请求快速完成这个合并操作。
- en: The second approach to fixing an under-full node is to shift one of the keys
    (and potentially children) from its adjacent sibling. This works only when the
    sibling can afford to lose a key and thus applies to cases where the combined
    number of keys of the siblings must be at least 2*k*. While we could merge and
    optimally resplit the adjacent siblings, for illustrative purposes we use a simpler
    approach of transferring only one key. Since we only ever remove a single key
    from a node during deletion or the merge operation, transferring a single key
    is sufficient to fix our under-full node.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 修复不足节点的第二种方法是将一个键（以及可能的子节点）从其相邻兄弟节点中转移过来。这种方法仅在兄弟节点能够承受丢失一个键时有效，因此适用于兄弟节点的键的总数必须至少为2*k*的情况。虽然我们可以合并并优化地重新分割相邻的兄弟节点，但为了说明问题，我们使用了一种更简单的方法，只转移一个键。由于我们在删除或合并操作期间仅从一个节点中删除一个键，转移一个键就足以修复我们的不足节点。
- en: However, as shown in [Figure 12-11](#figure12-11), we can’t just take a key
    from one child and give it to the other. The separating key in the parent node
    enforces the bounds of the split. Instead, we do a two-stage transfer. First,
    we transfer the current separating key from the parent to the under-full node.
    Second, we replace the separating key in the parent node with a key from the other
    sibling.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如[图12-11](#figure12-11)所示，我们不能仅仅从一个子节点中取出一个键并把它交给另一个子节点。父节点中的分隔键强制执行分裂的边界。因此，我们进行两阶段转移。首先，我们将当前的分隔键从父节点转移到不足节点。其次，我们用另一个兄弟节点的键替换父节点中的分隔键。
- en: '![Figure A shows a node with three leaves and one internal node. The internal
    node has keys 26 and 31\. The middle leaf has only a single key 29, and the right‐most
    leaf has three keys 32, 42, and 45\. Figure B shows the same subtree. The internal
    node now has keys 26 and 32\. The middle leaf now has two keys 29 and 31, and
    the right‐most node has two keys 42 and 45.](image_fi/502604c12/f12011.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图A显示了一个包含三个叶子节点和一个内部节点的节点。内部节点有键26和31。中间叶子节点只有一个键29，最右边的叶子节点有三个键32、42和45。图B显示了相同的子树。内部节点现在有键26和32。中间叶子节点现在有两个键29和31，而最右边的节点有两个键42和45。](image_fi/502604c12/f12011.png)'
- en: 'Figure 12-11: The transfer left operation on B-tree nodes'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-11：B树节点上的转移左操作
- en: 'As shown in [Listing 12-2](#listing12-2), we break the code into two helper
    functions, one to transfer a key from the right child to the left child and one
    to transfer the other way. The code to transfer a key from the right child to
    the left child transfers two keys: one from the right child to the parent and
    one from the parent to the left child.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如[清单12-2](#listing12-2)所示，我们将代码分成了两个辅助函数，一个用于将键从右子节点转移到左子节点，另一个则是反方向的转移。将键从右子节点转移到左子节点的代码会转移两个键：一个从右子节点到父节点，另一个从父节点到左子节点。
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 12-2: Code for transferring a key and child pointer to an under-full
    node from its right-hand sibling'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 清单12-2：将一个键和子指针从右侧兄弟节点转移到不足节点的代码
- en: The code starts by retrieving the two adjacent siblings and the separating key
    ❶. It moves the first key from the right-hand child to replace the previous separating
    key ❷. It adds the previous separating key from the parent (`middle_key`) and
    the first child pointer from the right-hand child to the end of the arrays in
    the left-hand child ❸. Both the left-hand child and parent are now updated. The
    code then cleans up the right-hand child. It uses a `WHILE` loop to shift over
    the remaining elements ❹, marks the now empty spots as `null` ❺, and adjusts the
    size ❻.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先通过获取两个相邻的兄弟节点和分隔键 ❶ 开始。它将右侧子节点中的第一个键移动到替换之前的分隔键 ❷。然后，它将来自父节点的前一个分隔键（`middle_key`）和右侧子节点的第一个子指针追加到左侧子节点数组的末尾
    ❸。现在，左侧子节点和父节点都已更新。接着，代码清理右侧子节点。它使用 `WHILE` 循环移动剩余的元素 ❹，将现在空的位置标记为 `null` ❺，并调整大小
    ❻。
- en: 'The code for transferring a key from the left child to the right child is similar
    to that shown in [Listing 12-3](#listing12-3). The two-key transfer works in the
    opposite direction: one from the left child to the parent and one from the parent
    to the right child.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 从左侧子节点转移键到右侧子节点的代码与[示例 12-3](#listing12-3)中展示的代码类似。双键转移则是相反的方向：一张从左侧子节点到父节点，另一张从父节点到右侧子节点。
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 12-3: Code for transferring a key and child pointer to an under-full
    node from its left-hand sibling'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 12-3：从左侧兄弟节点向欠充实节点转移键和子指针的代码
- en: The code again starts by retrieving the two adjacent siblings and the separating
    key ❶. The code then shifts over the keys and children in the right-hand node
    to make room for the new addition ❷. It appends the previous separating key from
    the parent (`middle_key`) and the last child pointer from the left child to the
    *beginning* of the right-hand node ❸, increasing its size by 1\. The code then
    moves the last key in the left-hand child to replace the separating key in the
    parent ❹. The code completes by cleaning up the left-hand child by marking the
    now empty entries `null` and updating the size ❺.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先通过获取两个相邻的兄弟节点和分隔键 ❶ 开始。接着，代码将右侧节点中的键和值移动，为新的元素腾出空间 ❷。它将来自父节点的前一个分隔键（`middle_key`）和左侧子节点的最后一个子指针追加到右侧节点的*开头*
    ❸，使其大小增加 1。然后，代码将左侧子节点中的最后一个键移动到父节点中的分隔键位置 ❹。最后，代码通过将现在空的条目标记为 `null` 并更新大小来清理左侧子节点
    ❺。
- en: Unlike the merge operation, neither transfer operation reduces the number of
    keys in the parent. Thus, we do not need to perform repairs at higher levels of
    the tree. The physical corollary of these transfer operations is requesting a
    sibling storage binder and shifting two index cards between the two children and
    the parent. We take the intermediate card (that falls between the range of the
    two binders) from the parent and add it to the less full child binder. We replace
    this card in the parent with the appropriate one from the child that has more
    cards.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 与合并操作不同，任何转移操作都不会减少父节点中的键的数量。因此，我们不需要在树的更高层级进行修复。这些转移操作的物理对应是请求一个兄弟存储绑定器，并在两个子节点和父节点之间移动两张索引卡。我们从父节点取出位于两个绑定器之间的中间卡片，并将其添加到较不充实的子节点绑定器中。然后，我们用子节点中卡片更多的那张卡片替换父节点中的这张卡片。
- en: 'We can encapsulate all three of these repair functions as well as the logic
    to choose them into a helper function that takes in the current node and the index
    of the under-full child:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这三种修复功能以及选择它们的逻辑封装到一个帮助函数中，该函数接受当前节点和欠充实子节点的索引：
- en: '[PRE11]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: To know which repair strategy to employ, the code needs to find an adjacent
    sibling and check the two children’s total number of keys. Here, for illustrative
    purposes, we use a simplistic strategy of always using the next child (`child
    + 1`) as the sibling unless we are repairing the last child in the array ❶. If
    we are repairing the last child in the array, we use the previous child for its
    sibling. The code checks the total count of keys in these two child nodes ❷. If
    the number of keys is small enough (under 2*k*), it merges those nodes with the
    `BTreeNodeMerge` function ❸. Otherwise, if the nodes have 2*k* or more keys, the
    code uses either `BTreeNodeTransferLeft` or `BTreeNodeTransferRight` to move a
    single key to the smaller node ❹.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定使用哪种修复策略，代码需要找到一个相邻的兄弟节点，并检查这两个子节点的键的总数。在这里，为了便于说明，我们使用一种简单的策略，即除非我们正在修复数组中的最后一个子节点❶，否则总是使用下一个子节点（`child
    + 1`）作为兄弟节点。如果我们正在修复数组中的最后一个子节点，我们则使用前一个子节点作为兄弟节点。代码检查这两个子节点的总键数❷。如果键的数量足够少（少于2*k*），则使用`BTreeNodeMerge`函数合并这两个节点❸。否则，如果节点的键数达到2*k*或更多，代码将使用`BTreeNodeTransferLeft`或`BTreeNodeTransferRight`将一个键移动到较小的节点❹。
- en: Finding the Minimum Value Key
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查找最小值键
- en: We use one more helper function as part of the deletion operation—code to find
    and return the minimum key at or below a given node. This code, in [Listing 12-4](#listing12-4),
    can also be useful in its own right, such as for computing the bounds of the keys
    in the B-tree.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在删除操作中使用了另一个辅助函数——用于查找并返回给定节点下方或本身的最小键的代码。这个代码在[Listing 12-4](#listing12-4)中，也可以单独用于计算B树中键的边界。
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 12-4: Code to find the minimum key at or below a given node'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 12-4：用于查找给定节点下方或本身的最小键的代码
- en: The code consists of three possible conditions. If the node is empty, the code
    returns `null` to indicate that there is no minimum key there ❶. This should occur
    only in an empty root node, as all other nodes will have at least *k* keys. If
    the node is a non-empty leaf, the code returns the first (and thus minimum) key
    in the node’s array ❷. Finally, if the node is internal, the code recursively
    checks the first child ❸.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 代码包含三种可能的情况。如果节点为空，代码返回`null`以表示该节点中没有最小键❶。这种情况应该仅出现在空的根节点中，因为所有其他节点至少会有*k*个键。如果节点是非空叶子节点，代码返回该节点数组中的第一个（即最小）键❷。最后，如果节点是内部节点，代码会递归检查第一个子节点❸。
- en: The Removal Algorithm
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除算法
- en: We start the description of the deletion algorithm with the top-level wrapper
    function. This function is relatively simple. It calls the recursive deletion
    function using the tree’s root node.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从描述删除算法的顶层封装函数开始。这个函数相对简单，它调用递归删除函数，传入树的根节点。
- en: '[PRE13]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Just as we added a level only when we split the node, we remove a level from
    the tree only when the root node becomes empty. If the B-tree is not completely
    empty, the empty root node will still have a single valid child in array position
    0\. We use this child to replace the former root node.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在分割节点时仅增加了一层一样，只有当根节点变为空时，我们才从树中移除一层。如果B树并非完全空，空的根节点仍会在数组位置0中有一个有效的子节点。我们使用这个子节点来替换原来的根节点。
- en: The core deletion algorithm recursively descends the tree, searching for the
    key to delete. Since we might reduce the number of keys below the required *k*,
    we need to know check whether the modified child is now under-full and, if so,
    repair it.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 核心删除算法递归地遍历树，查找要删除的键。由于我们可能会将键的数量减少到低于所需的*k*，因此我们需要检查修改后的子节点是否现在变得过少，如果是，需进行修复。
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The code starts by searching for the key to delete in the current node by scanning
    across the array of keys ❶. If there is a matching key in this node, the `WHILE`
    loop terminates such that `i` is the index matching the key.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 代码通过扫描键数组❶来查找当前节点中要删除的键。如果在该节点中找到匹配的键，`WHILE`循环结束，`i`是与键匹配的索引。
- en: The code then considers the leaf case. If the node is a leaf and the key is
    found, the code deletes it by shifting over the keys ❷. The code also sets the
    last element to `null` and updates the size. The code doesn’t need to change the
    child pointers because they are not set for leaf nodes. If the node is a leaf
    and the key is not found, then the code simply returns.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 代码接着考虑叶子节点的情况。如果节点是叶子节点并且找到了键，代码通过将键向左移动来删除它❷。代码还会将最后一个元素设置为`null`并更新大小。由于叶子节点没有设置子指针，所以代码无需更改子指针。如果节点是叶子节点但没有找到键，代码则简单地返回。
- en: 'The code next handles the case of internal nodes. There are two cases to consider:
    the key is in the node, or it is not. If the code finds the key in the internal
    node, it replaces the key with the key that immediately *follows* the target key
    in sorted order ❸. The code finds this subsequent key using `BTreeNodeFindMin`
    from [Listing 12-4](#listing12-4), called on the child node immediately after
    the target key. The code deletes this following key from the child’s subtree by
    calling `BTreeNodeDelete` ❹. The code then checks whether the child node is under-full
    and, if so, fixes it.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 代码接下来处理内部节点的情况。需要考虑两种情况：键在节点中，或者不在。如果代码在内部节点中找到了该键，它会用排序顺序中紧跟目标键的下一个键来替换该键 ❸。代码通过调用[清单
    12-4](#listing12-4)中的 `BTreeNodeFindMin` 函数，从目标键后面的子节点中找到该下一个键。然后，代码通过调用 `BTreeNodeDelete`
    ❹ 删除子树中的该键。接着，代码检查该子节点是否不足，如果是，则进行修复。
- en: If the target key is not in an internal node, then the code recursively calls
    `BTreeNodeDelete` on the appropriate child ❺. Again, it needs to check whether
    that child node is now under-full and, if so, fix it.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目标键不在内部节点中，则代码会递归地调用 `BTreeNodeDelete` 来处理相应的子节点 ❺。同样，它需要检查该子节点是否已经变得不足，如果是，则进行修复。
- en: As with insertion, our goal is to limit the number of nodes retrieved during
    this operation. Deletion will make at most a single pass from the root node to
    a leaf. Even if we delete from an internal node, the subsequent replacement and
    deletion operations still only continue the trek to a single leaf. We pay one
    additional requisition whenever we repair a node to retrieve the under-full node’s
    sibling.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 与插入操作一样，我们的目标是限制在此操作过程中访问的节点数量。删除操作最多只需要从根节点到叶子节点进行一次遍历。即使我们从内部节点进行删除，随后的替换和删除操作仍然仅会继续到一个单一的叶子节点。如果我们修复一个节点以获取该节点的兄弟节点，我们需要额外一次的请求。
- en: Examples of Removing Keys
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除键的示例
- en: Let’s look at a few examples of the removals that we just covered. First, take
    the simplest case, shown in [Figure 12-12](#figure12-12), of removing a key from
    a leaf node with more than *k* + 1 keys. Suppose *k* = 2, where our non-root nodes
    can contain between 2 and 2*k* = 4 items. If we remove key 5 from the subtree
    in [Figure 12-12](#figure12-12)(a), we simply proceed down to the leaf node and
    remove the key in the array. Since the resulting leaf has three elements, we do
    not need to repair it. We get the subtree shown in [Figure 12-12](#figure12-12)(b).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看几个刚才讨论过的删除操作的示例。首先，考虑最简单的情况，如[图 12-12](#figure12-12)所示，从一个包含超过 *k* + 1 个键的叶子节点中删除一个键。假设
    *k* = 2，那么我们的非根节点可以包含 2 到 2*k* = 4 个元素。如果我们从[图 12-12](#figure12-12)(a)中的子树删除键值
    5，我们只需要沿着路径进入叶子节点，并从数组中删除该键。由于结果叶子节点包含三个元素，因此我们不需要进行修复。我们得到的子树如[图 12-12](#figure12-12)(b)所示。
- en: '![Figure A shows a subtree with one internal node and five leaf nodes. The
    first leaf has keys 1, 3, 5, and 6\. Figure B shows the same tree as Figure A
    with the key 5 deleted from the middle of the first leaf node. The node now contains
    keys 1, 3, and 6.](image_fi/502604c12/f12012.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图 A 显示了一个子树，包含一个内部节点和五个叶子节点。第一个叶子节点包含键值 1、3、5 和 6。图 B 显示了与图 A 相同的树，其中从第一个叶子节点的中间删除了键值
    5。此时，该节点包含键值 1、3 和 6。](image_fi/502604c12/f12012.png)'
- en: 'Figure 12-12: Deleting the key 5 from a B-tree leaf (a) results in a leaf node
    with three elements (b).'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-12：从 B 树的叶子节点删除键值 5 (a) 结果是一个包含三个元素的叶子节点 (b)。
- en: Next, we consider the case of removing a key from an internal node without needing
    repairs as shown in [Figure 12-13](#figure12-13). If we remove key 45 from the
    subtree in [Figure 12-13](#figure12-13)(a), we find that key in an internal node.
    To remove it, we replace it with the next key in order, which is 47\. Since the
    resulting nodes all have at least two elements, we do not need to perform any
    repairs. We get the subtree shown in [Figure 12-13](#figure12-13)(b).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们考虑从一个不需要修复的内部节点中删除键的情况，如[图 12-13](#figure12-13)所示。如果我们从[图 12-13](#figure12-13)(a)中的子树删除键值
    45，我们发现该键位于一个内部节点中。为了删除它，我们用下一个按顺序排列的键替换它，即 47。由于结果节点中所有的键数都至少为两个，因此我们不需要进行任何修复。我们得到的子树如[图
    12-13](#figure12-13)(b)所示。
- en: '![Figure A shows a subtree with one internal node and five leaf nodes. The
    internal node contains keys 12, 26, 31, and 45\. The fifth (right‐most) leaf contains
    keys 47, 48, and 49\. Figure B shows the same tree as Figure A with the key 45
    deleted from the internal node. The key 47, which previously resided in the right‐most
    node in Figure A, replaces the key 45\. The fifth leaf node has keys 48 and 49.](image_fi/502604c12/f12013.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图 A 显示一个包含一个内部节点和五个叶子节点的子树。内部节点包含键12、26、31和45。第五个（最右边）叶子包含键47、48和49。图 B 显示了与图
    A 相同的树，内部节点中的键45被删除。之前位于图 A 中最右边节点中的键47，替代了键45。第五个叶子节点包含键48和49。](image_fi/502604c12/f12013.png)'
- en: 'Figure 12-13: Deleting the key 45 from an internal B-tree node (a) results
    in taking a key from one of the children (b).'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-13：从内部B树节点中删除键45 (a) 会导致从其子节点之一取出键 (b)。
- en: 'Finally, we consider the different cases where removing a key requires us to
    repair an under-full node. [Figure 12-14](#figure12-14) shows a case where we
    can merge two nodes. We start by deleting the key 32 in [Figure 12-14](#figure12-14)(a).
    [Figure 12-14](#figure12-14)(b) shows the keys that we use for the merge operation:
    the keys in the under-full node, the keys in its right-hand adjacent sibling,
    and the key in the parent separating the two. [Figure 12-14](#figure12-14)(c)
    shows the repaired tree. The new child node has four keys, and the previous parent
    has three.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们考虑不同的情况，在这些情况下，删除键需要我们修复一个不足的节点。[图 12-14](#figure12-14) 显示了一个我们可以合并两个节点的情况。我们从删除[图
    12-14](#figure12-14)(a)中的键32开始。[图 12-14](#figure12-14)(b)显示了我们用于合并操作的键：不足的节点中的键、它右侧相邻兄弟节点中的键，以及分隔这两个节点的父节点中的键。[图
    12-14](#figure12-14)(c)显示了修复后的树。新的子节点有四个键，之前的父节点有三个。
- en: '![Figure A shows a subtree with one internal node and five leaf nodes. The
    internal node contains keys 12, 26, 31, and 45\. The fourth leaf contains keys
    32 and 42\. The fifth leaf contains keys 47 and 48\. In Figure A, the key 32 is
    removed from a leaf node, leaving a single key 42\. Figure B shows a dashed line
    around the right‐most two children and the separating key 45\. Figure C shows
    the final tree with the merged child. The internal node now has four children
    and contains the keys 12, 26, and 31\. The right‐most leaf node has keys 42, 45,
    47, and 48.](image_fi/502604c12/f12014.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图 A 显示一个包含一个内部节点和五个叶子节点的子树。内部节点包含键12、26、31和45。第四个叶子包含键32和42。第五个叶子包含键47和48。在图
    A 中，键32从叶子节点中删除，剩下一个键42。图 B 显示了右侧最远的两个子节点和分隔键45的虚线。图 C 显示了合并后的最终树。内部节点现在有四个子节点，包含键12、26和31。最右边的叶子节点包含键42、45、47和48。](image_fi/502604c12/f12014.png)'
- en: 'Figure 12-14: Deleting the key 32 from an almost empty node (a) gives the leaf
    too few elements (b). We must merge with an adjacent sibling to restore the B-tree
    conditions (c).'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-14：从几乎为空的节点中删除键32 (a) 会导致叶子节点元素过少 (b)。我们必须与相邻的兄弟节点合并，以恢复B树的条件 (c)。
- en: '[Figure 12-15](#figure12-15) shows a case where we can transfer a key from
    a larger sibling node. We start by deleting the key 32 in [Figure 12-15](#figure12-15)(a).
    [Figure 12-15](#figure12-15)(b) shows the keys that we use to restore balance:
    the keys in the under-full node, the keys in its right-hand adjacent sibling,
    and the key in the parent separating the two. [Figure 12-15](#figure12-15)(c)
    shows which keys will move and where. The repaired tree is shown in [Figure 12-15](#figure12-15)(d).'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 12-15](#figure12-15) 显示了一个我们可以从较大的兄弟节点转移键的情况。我们从删除[图 12-15](#figure12-15)(a)中的键32开始。[图
    12-15](#figure12-15)(b)显示了我们用来恢复平衡的键：不足的节点中的键、它右侧相邻兄弟节点中的键，以及分隔这两个节点的父节点中的键。[图
    12-15](#figure12-15)(c)展示了哪些键会移动以及它们的去向。修复后的树在[图 12-15](#figure12-15)(d)中显示。'
- en: '![Figure A shows a subtree with one internal node and five leaf nodes. The
    internal node contains keys 12, 26, 31, and 45\. The fourth leaf contains keys
    32 and 42\. The fifth leaf contains keys 47, 48, and 49\. In Figure A, the key
    32 is removed from a leaf node, leaving a single key 42\. Figure B shows a dashed
    line around the right‐most two children and the separating key 45\. Figure C includes
    arrows showing the key 47 from the right‐most child will move into the parent
    and key 45 from the parent will move to the under‐full child. The final tree is
    shown in Figure D. The internal node has four children and contains the keys 12,
    26, 31, and 47\. The fourth leaf node contains keys 42 and 45\. The fifth leaf
    node contains keys 48 and 49.](image_fi/502604c12/f12015.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图 A 显示了一个子树，包含一个内部节点和五个叶节点。内部节点包含键 12、26、31 和 45。第四个叶节点包含键 32 和 42。第五个叶节点包含键
    47、48 和 49。在图 A 中，键 32 从叶节点中移除，剩下一个键 42。图 B 显示了一个虚线框住了最右侧的两个子节点和分隔键 45。图 C 包括箭头，表示最右侧的子节点中的键
    47 将移动到父节点中，父节点中的键 45 将移动到该叶节点中。最终的树结构显示在图 D 中，内部节点有四个子节点，包含键 12、26、31 和 47。第四个叶节点包含键
    42 和 45，第五个叶节点包含键 48 和 49。](image_fi/502604c12/f12015.png)'
- en: 'Figure 12-15: Deleting the key 32 from an almost empty node (a) gives the leaf
    too few elements (b). We can repair this by taking a key from an adjacent sibling
    (c) to restore the B-tree conditions (d).'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-15：从几乎为空的节点中删除键 32（a）会导致叶节点的元素不足（b）。我们可以通过从相邻的兄弟节点中取一个键（c）来修复这个问题，以恢复 B
    树的条件（d）。
- en: Finally, [Figure 12-16](#figure12-16) shows a case where we remove a level from
    the tree by merging the only two children below the root. [Figure 12-16](#figure12-16)(b)
    shows that after the merge, we are left with an empty root node. Its one key has
    been moved to the merged node. We repair this in [Figure 12-16](#figure12-16)(c)
    by removing the old root node and promoting that node’s single child to be the
    new root node.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，[图 12-16](#figure12-16) 显示了一个通过合并根节点下唯一的两个子节点来移除树的一层的情况。[图 12-16](#figure12-16)(b)
    显示合并后，根节点为空，唯一的键已经移到合并后的节点。我们在[图 12-16](#figure12-16)(c) 中通过移除旧根节点，并将该节点的唯一子节点提升为新根节点来修复这个问题。
- en: Unlike addition, where the modifications to the B-tree are limited to only those
    nodes explored during the initial search for the insertion location, deletion
    can modify nodes in other branches. Both merging nodes and transferring keys use
    a sibling node at the same level. However, the total number of nodes modified
    is still limited by the depth of the tree. At most, we access one sibling node
    per level, and the number of nodes accessed scales logarithmically with *N*.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 与添加操作不同，删除操作可能会修改其他分支的节点。在删除过程中，合并节点和转移键会使用同一层次的兄弟节点。然而，修改的节点总数仍然受到树的深度限制。最多，我们每一层只能访问一个兄弟节点，访问的节点数量会随
    *N* 的对数增长。
- en: '![In Figure A, the root node has the key 51 and has two children with keys
    12 and 31 in the left node and key 61 in the right node. Figure B shows the result
    of the merge operation. The root is empty and has a single child with keys 12,
    31, 51, and 61\. Figure C shows the final tree where the old root node has been
    removed. The new root is the node with keys 12, 31, 51, and 61.](image_fi/502604c12/f12016.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图 A 中，根节点的键是 51，左子节点包含键 12 和 31，右子节点包含键 61。图 B 显示了合并操作后的结果，根节点为空，只有一个子节点，包含键
    12、31、51 和 61。图 C 显示了最终的树结构，旧根节点已被移除，新的根节点是包含键 12、31、51 和 61 的节点。](image_fi/502604c12/f12016.png)'
- en: 'Figure 12-16: Merging the only two children under the root node (a) results
    in an empty root (b). We repair this by promoting the root node’s only child to
    be the new root (c).'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-16：合并根节点下唯一的两个子节点（a）会导致根节点为空（b）。我们通过提升根节点的唯一子节点为新根节点（c）来修复这一问题。
- en: Why This Matters
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么这很重要
- en: B-trees illustrate a few important concepts. First, they show how we can adapt
    the behavior of previous data structures to handle cases where memory accesses
    between nodes are more expensive than accesses within a node. B-trees combine
    indexing and storage in such a way as minimize the number of accesses we need.
    This is critical for large data sets that might keep information on a disk or
    an external server. By enforcing a minimum of *k* keys for each non-root node,
    we ensure a branching factor of at least *k* + 1 at each node and thus flatten
    out the overall data structure. This helps limit the overall depth of the tree
    and thus the number of retrievals needed for search, insertion, or deletion. We
    also guarantee that each non-root node always remains at least half-full, meaning
    that we do not waste time retrieving nodes with only a few elements (except possibly
    the root).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: B树展示了一些重要的概念。首先，它们展示了如何调整先前数据结构的行为，以处理节点之间的内存访问比节点内部访问更昂贵的情况。B树通过将索引和存储结合在一起，尽量减少我们所需的访问次数。这对于可能将信息存储在磁盘或外部服务器上的大数据集至关重要。通过对每个非根节点强制至少有
    *k* 个键，我们确保每个节点的分支因子至少为 *k* + 1，从而扁平化整个数据结构。这有助于限制树的整体深度，从而减少搜索、插入或删除所需的检索次数。我们还确保每个非根节点始终保持至少半满，这意味着我们不会浪费时间去检索只有少量元素的节点（可能除了根节点）。
- en: It is useful to contrast the B-tree’s approach with a more specialized indexing
    scheme for our collectibles. We could develop a data structure that initially
    splits on category. The top-level index maps the collectible’s category, such
    as coffee-related collectibles, to a binder for that specific category. Each category’s
    binder then maps to all the subcategories, such as coffee mugs or coffee posters.
    And so forth. This is also a valid approach that builds off the branching structures
    we have seen throughout this book. The tradeoff becomes one of generalizability
    versus efficiency. In many cases, we can further optimize a data structure to
    a particular task at hand but lose the ability to apply it to other problems.
    In some cases, this tradeoff might be worth it. In others, it might not. Compared
    to a categorical focused indexing scheme, B-trees provide a more general approach
    that can work for any sortable set of keys.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 将B树的方法与我们收藏品的更专业化索引方案进行对比是很有帮助的。我们可以开发一个数据结构，最初根据类别进行拆分。顶级索引将收藏品的类别（如与咖啡相关的收藏品）映射到该特定类别的文件夹。每个类别的文件夹然后映射到所有子类别，如咖啡杯或咖啡海报。以此类推。这也是一种有效的方法，基于我们在本书中看到的分支结构。权衡在于通用性与效率之间。在许多情况下，我们可以进一步优化数据结构以适应当前任务，但可能失去将其应用于其他问题的能力。在某些情况下，这种权衡可能是值得的，而在其他情况下，则可能不是。与聚焦于类别的索引方案相比，B树提供了一种更通用的方法，适用于任何可排序的键集。
- en: The second concept B-trees illustrate is a second level of dynamism within the
    data structure itself. The B-tree constantly rearranges its structure to adapt
    to the distribution of data it stores and thus remain balanced. As we saw in Chapter
    5, we lose the advantages of the tree-based structure if our tree becomes highly
    unbalanced. B-trees programmatically prevent this through a combination of bounds
    on the number of keys in each node (*k* to 2*k*) and a guarantee that all leaf
    nodes have exactly the same depth. They adapt to “bad” distributions of input
    data by rebalancing—fixing nodes with too many or too few items. While there are
    a wide range of other balancing strategies for trees, B-trees provide a simple
    and clear example of how we can use additional structure (in this case, multiple
    keys per node) to avoid worst-case scenarios.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: B树所展示的第二个概念是数据结构本身的第二级动态性。B树不断调整其结构，以适应它所存储的数据分布，从而保持平衡。正如我们在第5章中看到的，如果我们的树变得极度不平衡，我们就会失去基于树的结构的优势。B树通过在每个节点中对键数量的范围限制（*k*
    到 2*k*）和保证所有叶子节点具有相同深度的方式，程序化地避免了这种情况。它们通过重新平衡来适应“糟糕”的输入数据分布——修复节点中过多或过少的项。尽管有许多其他的树平衡策略，B树提供了一个简单且清晰的例子，展示了如何利用额外的结构（在这种情况下是每个节点多个键）来避免最坏的情况。
