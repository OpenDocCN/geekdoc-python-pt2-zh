- en: '**13'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SIMULATING AN ALIEN VOLCANO**
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Quick! Name the most volcanically active body in the solar system! If you thought
    Earth, then you’d be mistaken—it’s Io (“EYE-oh”), one of Jupiter’s four Galilean
    moons.
  prefs: []
  type: TYPE_NORMAL
- en: The first evidence of volcanism on Io came in 1979, when *Voyager 1* made its
    famous fly-by of the Jovian system. But the spectacular photographs it recorded
    were no real surprise. Astrophysicist Stan Peale and two coauthors had already
    published this result based on models of Io’s interior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Computer modeling is a powerful tool for understanding nature and making predictions.
    Here’s the general workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: Gather data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Analyze, interpret, and integrate the data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generate numerical equations that explain the data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Construct a computer model that best “fits” the data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the model to make predictions and investigate error ranges.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Applications of computer modeling are far-reaching and include such areas as
    wildlife management, weather forecasts, climate predictions, hydrocarbon production,
    and black-hole simulations.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll use a Python package called `pygame`—normally used to
    create games—to simulate one of Io’s volcanoes. You’ll also experiment with different
    types of *ejecta* (erupted particles) and compare their simulated behaviors to
    a photo of Io’s mammoth Tvashtar plume.
  prefs: []
  type: TYPE_NORMAL
- en: '**Project #21: The Plumes of Io**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Tidal heating* is responsible for the volcanism on Io. As its elliptical orbit
    carries it through the gravity fields of Jupiter and its sister moons, Io experiences
    variations in tidal pull. Its surface flexes up and down by as much as 100 meters,
    resulting in significant friction-related heating and melting in its interior.
    Hot magma migrates to the surface and forms great lava lakes from which degassing
    sulfur (S[2]) and sulfur dioxide (SO[2]) are sprayed skyward with speeds of 1
    km/s. Because of Io’s low gravity and lack of atmosphere, these plumes of gas
    can reach heights of hundreds of kilometers (see the Tvashtar plume in [Figure
    13-1a](ch13.xhtml#ch13fig1)).'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0266-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-1: a) Io with the 330 km Tvashtar plume at the top and the shorter
    Prometheus plume at the 9 o’clock position; b) Io with volcanic ring deposits
    (NASA images)*'
  prefs: []
  type: TYPE_NORMAL
- en: The plumes’ pleasing umbrella shape is produced as gas and dust shoot upward,
    then fall back in every direction. The resulting surface deposits form concentric
    rings of red, green, black, and yellow. If [Figure 13-1b](ch13.xhtml#ch13fig1)
    were in color, it would look a bit like a moldy pepperoni pizza.
  prefs: []
  type: TYPE_NORMAL
- en: '**A Slice of pygame**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `pygame` package is a cross-platform set of Python modules that are typically
    used to program 2D arcade-style video games. It supports graphics, animations,
    sound effects, music, and multiple input devices, such as the keyboard and mouse.
    Learning `pygame` is more than just a fun way to learn programming. Arcade-style
    games have seen a resurgence in popularity thanks to the proliferation of smartphones
    and tablets, and mobile gaming now earns almost as much as console and PC gaming
    combined.
  prefs: []
  type: TYPE_NORMAL
- en: The `pygame` package uses the *Simple DirectMedia Library (SDL)*, which is an
    *application programming interface (API)*. APIs are reusable code libraries that
    make handling graphics fairly easy, allowing you to focus on game design while
    using a high-level language like Python. The Microsoft *DirectX* API is used for
    creating games and multimedia apps for the Windows platform. For working across
    multiple platforms, two open source libraries are SDL, mainly for 2D work, and
    *OpenGL (Open Graphics Library)* for 3D applications. As mentioned, you’ll be
    working with SDL, which officially supports Windows, macOS, Linux, iOS, and Android.
  prefs: []
  type: TYPE_NORMAL
- en: The `pygame` package also uses object-oriented programming (OOP). If you are
    unfamiliar with OOP or need a refresher, see “[A Brief Introduction to Object-Oriented
    Programming](ch11.xhtml#lev256)” on [page 223](ch11.xhtml#page_223). Additionally,
    introductory books on Python often include a section on `pygame`, and there are
    whole books written on the package (see “[Further Reading](ch13.xhtml#lev309)”
    on [page 281](ch13.xhtml#page_281) for some examples).
  prefs: []
  type: TYPE_NORMAL
- en: Before you can continue, you’ll need to install `pygame` onto your system. Instructions
    for installing a free copy on your preferred platform are available at *[http://pygame.org/wiki/GettingStarted#Pygame%20Installation](http://pygame.org/wiki/GettingStarted#Pygame%20Installation)*.
  prefs: []
  type: TYPE_NORMAL
- en: Video tutorials on how to install `pygame` are also available online. To ensure
    a video is appropriate to your situation, be sure to check the date of the video,
    the platform discussed, and the versions of `pygame` and Python in use. You can
    find additional instructions for Mac users with older Python installs at *[http://brysonpayne.com/2015/01/10/setting-up-pygame-on-a-mac/](http://brysonpayne.com/2015/01/10/setting-up-pygame-on-a-mac/)*.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE OBJECTIVE**'
  prefs: []
  type: TYPE_NORMAL
- en: Use `pygame` to build a 2D, gravity-based simulation of Io’s Tvashtar volcanic
    plume. Calibrate the plume dimensions using a NASA image. Use multiple particle
    types in the plume, trace the particles’ flight paths and allow the eruption to
    run automatically until stopped.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Strategy**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Building a comprehensive, full-physics simulation of one of Io’s plumes is best
    accomplished with a supercomputer. Since you probably don’t have one of those
    and since your goal is to make a cool `pygame` display, you’re going to cheat
    by reverse-engineering the parameters you need to make SO[2] fit the Tvashtar
    plume. Remember, cheating is the gift humans give ourselves; it’s what separates
    us from the animals—except for the cheetahs!
  prefs: []
  type: TYPE_NORMAL
- en: Since the composition of Io’s plumes is already known, you’re going to calibrate
    your gravity field to SO[2] and sulfur (S[2]) gas, which conveniently have the
    same atomic weight. When the flight paths of these particles match the dimensions
    of the Tvashtar plume in the NASA photograph, you will scale the velocity of other
    ejected particles, based on the difference in atomic weight between the new particle
    and SO[2], to see how particle type affects plume dimensions. Lighter particles
    will be ejected higher and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: '***Using a Game Sketch to Plan***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: I suggest you begin any `pygame` project with a sketch of how the game should
    look and how the action should progress. Even the simplest arcade games can become
    complicated, and a sketch will help you manage the complexity. Among the many
    things you must consider in a typical game are player actions, scorekeeping, messages
    and instructions, game entities and their interactions (such as collisions, sound
    effects, and music), and game-ending conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Sketching the game—or in this case, the simulation—is best done on a whiteboard,
    either real or digital. My layout for the Io volcano simulator is shown in [Figure
    13-2](ch13.xhtml#ch13fig2).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0268-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-2: Game sketch of Io volcano simulator*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The sketch in [Figure 13-2](ch13.xhtml#ch13fig2) contains guidelines and key
    behaviors for the volcano simulator:'
  prefs: []
  type: TYPE_NORMAL
- en: '**No direct player interactions.** You’ll control the simulation by editing
    the Python code, not through the mouse or keyboard.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The background will be a NASA image of a plume.** To calibrate the simulation
    to SO[2]/S[2] particles, you’ll need a backdrop of the actual Tvashtar plume.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The launch point pivots.** The particles should be ejected from the central
    base of the plume image and should spray out over a range of angles, rather than
    just straight up.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Particles are chosen at random.** The program will choose the type of particle
    at random. Each particle will have a unique color that distinguishes it from others.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The particle flight path should be visible and persistent.** The flight of
    each particle should be recorded as a line that remains visible throughout the
    simulation, and the line color should match the particle color.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A color-coded legend lists the particle types.** The program should post
    a legend with the particle names in the upper-left corner of the screen. The font
    colors should match the particle colors, and the legend should print on top of
    particle paths so that it’s always visible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Particle motion should stop at the level at which SO**[2] **particles intersect
    the surface of Io.** The simulation is tuned to the behavior of SO[2], so falling
    particles should stop at the appropriate location for an SO[2] plume.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**There are no sound effects.** In space, no one can hear you scream.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you complete your diagram, you can begin picking parts from it and listing
    them in logical order; this breaks the plan into a series of manageable steps.
    For example, you’ll need to find and prepare an appropriate background image,
    decide which particles you want to simulate and look up their atomic weights,
    locate a launch point, calibrate SO[2] behavior to the plume image, and so on.
    You’re still writing pseudocode, but a game sketch makes it a much more enjoyable
    process!
  prefs: []
  type: TYPE_NORMAL
- en: '***Planning the Particle Class***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Since this simulation is based on *particles*, it makes sense to have an OOP
    `Particle` class to serve as a blueprint for multiple particle types. The class
    should support the random generation of particle types, and constants and other
    attributes common to all particles can be stored as *class attributes*. These
    are attributes assigned at the same indentation level as methods. The `Particle`
    class should also contain methods that allow instances of the class to be ejected,
    affected by gravity, made visible, and destroyed when they move beyond the boundaries
    of the simulation.
  prefs: []
  type: TYPE_NORMAL
- en: The attributes and methods used in the class are shown in [Tables 13-1](ch13.xhtml#ch13tab1)
    and [13-2](ch13.xhtml#ch13tab2), respectively. Class attributes—that is, those
    shared by all instances of the class—are shown in italics; otherwise, instance
    attributes are shown.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 13-1:** Attributes of the `Particle` Class (*Italics* = Class Attribute)'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Attributes** | **Attribute description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| *gases_colors* | Dictionary of available particle types and their colors
    |'
  prefs: []
  type: TYPE_TB
- en: '| *VENT_LOCATION_XY* | x- and y-location of mouth of Tvashtar volcano in image
    |'
  prefs: []
  type: TYPE_TB
- en: '| *IO_SURFACE_Y* | Io surface y-value at SO[2] plume margin in image |'
  prefs: []
  type: TYPE_TB
- en: '| *VELOCITY_SO2* | Speed (pixels per frame) of SO[2] particle |'
  prefs: []
  type: TYPE_TB
- en: '| *GRAVITY* | Acceleration of gravity in pixels per frame |'
  prefs: []
  type: TYPE_TB
- en: '| *vel_scalar* | Dictionary of ratios of SO[2]/particle atomic weights |'
  prefs: []
  type: TYPE_TB
- en: '| screen | The game screen |'
  prefs: []
  type: TYPE_TB
- en: '| background | A NASA image of the Tvashtar plume |'
  prefs: []
  type: TYPE_TB
- en: '| image | A square `pygame` surface representing a particle |'
  prefs: []
  type: TYPE_TB
- en: '| rect | A rectangular object used to get surface dimensions |'
  prefs: []
  type: TYPE_TB
- en: '| gas | The type of an individual particle (SO[2], CO[2], etc.) |'
  prefs: []
  type: TYPE_TB
- en: '| color | Color of an individual particle type |'
  prefs: []
  type: TYPE_TB
- en: '| vel | Particle’s velocity relative to SO[2] velocity |'
  prefs: []
  type: TYPE_TB
- en: '| x | Particle’s x-location |'
  prefs: []
  type: TYPE_TB
- en: '| y | Particle’s y-location |'
  prefs: []
  type: TYPE_TB
- en: '| dx | Particle’s delta-x |'
  prefs: []
  type: TYPE_TB
- en: '| dy | Particle’s delta-y |'
  prefs: []
  type: TYPE_TB
- en: '**Table 13-2:** Methods of the `Particle` Class'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Method description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `__init__()` | Initializes and sets up parameters for randomly selected particle
    type |'
  prefs: []
  type: TYPE_TB
- en: '| `vector()` | Randomly selects ejection orientation and calculates motion
    vector (dx and dy) |'
  prefs: []
  type: TYPE_TB
- en: '| `update()` | Adjusts particle trajectory for gravity, draws path behind particle,
    and destroys particles that move beyond the boundaries of the simulation |'
  prefs: []
  type: TYPE_TB
- en: I will explain each of these attributes and methods in more detail in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Code**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *tvashtar.py* code will generate a `pygame`-based simulation of Io’s Tvashtar
    plume. You will also need the background image, *tvashtar_plume.gif*. Download
    both files from *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*
    and keep them in the same folder.
  prefs: []
  type: TYPE_NORMAL
- en: '***Importing Modules, Initiating pygame, and Defining Colors***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Begin with several set-up steps, such as choosing colors, as shown in [Listing
    13-1](ch13.xhtml#ch13list1).
  prefs: []
  type: TYPE_NORMAL
- en: '*tvashtar.py,* part 1'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-1: Imports modules, initiates* pygame, *and defines a table of
    colors*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start with some familiar `import`s and one for `pygame` ➊. Next, call the `pygame.init()`
    function. This initializes the `pygame` module and starts up all the underlying
    parts that let it use sounds, check keyboard input, run graphics, and so on ➋.
    Note that `pygame` can be initialized from multiple places, such as the first
    line in a `main()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'or at the end of the program when `main()` is called in stand-alone mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Stop and assign some color variables using the RGB color model ➌. This model
    mixes red, green, and blue, where each color consists of values from 0 to 255\.
    If you do an online search for “RGB color codes,” you can find the numerical codes
    for millions of colors. But since the NASA image you’ll calibrate against is in
    grayscale, stick with black, white, and shades of gray. Defining this table now
    will allow you to simply enter a name when `pygame` needs a color defined later.
  prefs: []
  type: TYPE_NORMAL
- en: '***Defining the Particle Class***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 13-2](ch13.xhtml#ch13list2) defines the `Particle` class and its initializer
    method. You’ll use these to instantiate a particle object. The particle’s key
    attributes, such as type, velocity, color, and so on, are established with the
    initializer method.'
  prefs: []
  type: TYPE_NORMAL
- en: '*tvashtar.py,* part 2'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-2: Defines the* Particle *class and the* Particle *initializer
    method*'
  prefs: []
  type: TYPE_NORMAL
- en: Define a class called `Particle` to represent *any* molecule of gas that might
    form the volcanic plume ➊. The *ancestor* for this class, shown in parentheses,
    will be a `Sprite` class. This means that the `Particle` class is derived from
    a built-in `pygame` type called `Sprite`. Sprites are just 2D bitmaps that represent
    discrete game objects, like missiles or asteroids. You *inherit* from the `Sprite`
    class—that is, add its attributes and methods to your new class—by passing `pg.sprite.Sprite`
    to your `Particle` class, just as you would pass an argument to a function.
  prefs: []
  type: TYPE_NORMAL
- en: Assign properties common to all particles as class attributes. The first is
    a dictionary that maps particle types to a color, so that you can differentiate
    the particles during the simulation ➋. These colors will be used for the particle,
    its path, and its name in the legend.
  prefs: []
  type: TYPE_NORMAL
- en: Now, assign four constants, `VENT_LOCATION_XY`, `IO_SURFACE_Y`, `GRAVITY`, and
    `VELOCITY_SO2` ➌. The first constant is the x- and y-coordinates for the mouth
    of the Tvashtar volcano in the image, which will represent the “launch point”
    for all the particles (see [Figure 13-3](ch13.xhtml#ch13fig3)). I initially guessed
    at these values and then fine-tuned them when the simulation was up and running.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0273-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-3: Background image for the simulation with the particle launch
    point annotated*'
  prefs: []
  type: TYPE_NORMAL
- en: The second constant is the y-value for the highest point on Io’s surface (in
    the image) that intersects with the outer edge of the SO[2] plume (see [Figure
    13-2](ch13.xhtml#ch13fig2)). You will stop all the falling particles at this y-value,
    so the view will be optimized for SO[2].
  prefs: []
  type: TYPE_NORMAL
- en: The third constant represents the acceleration of gravity, which on Earth is
    9.86 m/s² and on Io is 1.796 m/s². But you’re dealing with pixels and frames here,
    not real-world units, so you need to experiment to find a value that looks good
    at the scale of your game/simulation. My choice of `0.5` was arbitrary, though
    guided by knowledge of what works well in arcade games.
  prefs: []
  type: TYPE_NORMAL
- en: The fourth constant is the speed, in pixels per frame, of an SO[2] particle
    when it is ejected. Remember, the plumes are composed primarily of SO[2], so you
    want to use parameters that will allow the SO[2] particles to “fit” the image
    of the Tvashtar plume, then adjust the speed of the remaining particles *relative*
    to SO[2]. Neither the `GRAVITY` nor the `VELOCITY_SO2` value is unique. Had I
    chosen a larger value for `GRAVITY`, I would’ve needed to increase `VELOCITY_SO2`
    so that the SO[2] particles still “fill out” the area of the plume in the NASA
    image.
  prefs: []
  type: TYPE_NORMAL
- en: Next, build a dictionary of scalars for particle velocity ➍. For each particle,
    dividing the atomic weight of SO[2] (64) by the atomic weight of the particle
    gives you the scalar. Since SO[2] is the reference particle, its scalar is 1\.
    Later, to get the velocity of non-SO[2] particles, you will multiply the `VELOCITY_SO2`
    constant by the scalar. As you can see, all of the other particles are lighter
    than SO[2] and should produce a larger plume.
  prefs: []
  type: TYPE_NORMAL
- en: Define a constructor method for the particle object ➎. You’ll need a `self`
    parameter and `screen` to draw on and check the simulation's boundaries, and you’ll
    need a `background`, which will be an image of the Tvashtar plume. You’ll assign
    `screen` and `background` later in the `main()` function, defined near the end
    of the program. Note that while I’m using one-line docstrings in this book for
    brevity, you would want to include these types of parameters in the class docstring.
    For more guidelines on class docstrings, see *[https://www.python.org/dev/peps/pep-0257/](https://www.python.org/dev/peps/pep-0257/)*.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `__init__()` method, immediately invoke the initialization method
    for the built-in `Sprite` class using `super`. This will initialize the sprite
    and establish the `rect` and `image` attributes it needs. With `super`, you don’t
    need to refer to the base class (`Sprite`) explicitly. For more on `super`, visit
    the docs at *[https://docs.python.org/3/library/functions.html#super](https://docs.python.org/3/library/functions.html#super)*.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let the particle (`self`) know that it will be using the `screen` and
    `background` variables by assigning them to attributes.
  prefs: []
  type: TYPE_NORMAL
- en: The images and drawings are placed on a rectangular surface by `pygame`. In
    fact, the `Surface` object is the heart and soul of `pygame`; even the `screen`
    attribute represents an instance of `Surface`. Assign the particle image to a
    `Surface` object and make it a square with 4-pixel-length sides ➏.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to get a `rect` object for your image surface. This is basically
    a rectangle *associated* with the `Surface` object, which `pygame` needs to determine
    the dimensions and position of your `Surface` object.
  prefs: []
  type: TYPE_NORMAL
- en: Choose a particle (`gas`) type by randomly choosing from the keys in the `gases_colors`
    dictionary ➐. Note that you turn it into a list to do this. Since it’s possible
    to assign an instance attribute named `gases_colors` from within the `__init__()`
    method, include the class name—rather than `self`—to ensure the *class* attribute
    is being referenced.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have a type, you can use it as the key in the dictionaries you built
    earlier to access things like colors and scalars. Start by getting the correct
    color for the chosen particle, then get its `vel_scalar` value and use that to
    determine the particle’s velocity ➑.
  prefs: []
  type: TYPE_NORMAL
- en: The particle object will be instantiated in the mouth of the volcano, so get
    its initial x- and y-location by unpacking the `VENT_LOCATION_XY` tuple ➒. Finish
    by calling the `vector()` method, which will calculate the particle’s motion vector
    ➓.
  prefs: []
  type: TYPE_NORMAL
- en: '***Ejecting a Particle***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 13-3](ch13.xhtml#ch13list3) defines the `vector()` method, which determines
    a particle’s launch orientation and calculates its initial delta-x and delta-y
    vector components.'
  prefs: []
  type: TYPE_NORMAL
- en: '*tvashtar.py,* part 3'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-3: Defines the* vector() *method of the* Particle *class*'
  prefs: []
  type: TYPE_NORMAL
- en: The `vector()` method ➊ calculates the motion vector for a particle. Start by
    choosing a launch direction for the particle and assigning it to an `orient` variable
    ➋. Because explosive volcanic eruptions blast material in multiple directions
    rather than straight up, choose the direction at random, using a range that is
    30 degrees to either side of 90 degrees, where 90 represents a vertical launch.
  prefs: []
  type: TYPE_NORMAL
- en: The range for the `orient` variable was chosen through trial and error. This
    parameter, along with the `VELOCITY_SO2` and `GRAVITY` constants, represents the
    “knobs” you can turn to calibrate the behavior of the SO[2] particle to the plume
    image. After you’ve adjusted the constants so that the particle’s maximum height
    corresponds to the apex of the plume, you can adjust the range of angles so that
    the SO[2] particles reach—but don’t exceed—the lateral limits of the plume (see
    [Figure 13-4](ch13.xhtml#ch13fig4)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0275-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: Calibrating the* orient *variable to the Tvashtar plume*'
  prefs: []
  type: TYPE_NORMAL
- en: The `math` module uses *radians* rather than degrees, so convert `orient` to
    radians ➌. A radian is a standard unit of angular measurement equal to the angle
    made when the radius is wrapped around a circle (see the left-hand side of [Figure
    13-5](ch13.xhtml#ch13fig5)). One radian is slightly less than 57.3 degrees. The
    right-hand side of [Figure 13-5](ch13.xhtml#ch13fig5) is a comparison of radians
    and degrees for some common angles. To convert degrees to radians, you can either
    multiply the degrees by π and divide by 180—like a chump—or just use the `math`
    module!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0275-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-5: Definition of a radian (left) and common angles in radians and
    degrees (right)*'
  prefs: []
  type: TYPE_NORMAL
- en: Objects move in `pygame` by increments of x and y. The direction and speed of
    a particle are used to get its *delta-x (dx)* and *delta-y (dy)* vector components.
    These represent the difference between a particle’s initial position and its position
    after completion of a single game loop.
  prefs: []
  type: TYPE_NORMAL
- en: You calculate vector components using trigonometry. Useful trigonometric equations
    are provided in [Figure 13-6](ch13.xhtml#ch13fig6).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0276-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-6: Common trigonometric equations used in gaming*'
  prefs: []
  type: TYPE_NORMAL
- en: For the angle θ, you use the `orient` variable. The `self.vel` attribute equates
    to *r*. Knowing these two components, you can use a trigonometric equation to
    derive `self.dx` and `self.dy` ➍. To derive `self.dx`, multiply `self.vel` by
    the cosine of `orient`, and to derive `self.dy`, multiply `self.vel` by the sine
    of `orient`. Note that you must make `self.dy` negative, as the particles are
    ejected upward and y-values in `pygame` increase *downward*.
  prefs: []
  type: TYPE_NORMAL
- en: '***Updating the Particle and Handling Boundary Conditions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 13-4](ch13.xhtml#ch13list4) completes the `Particle` class by defining
    a method to update particles as they move across the screen. This includes applying
    the force of gravity, drawing a line to trace the particle’s path, and “killing”
    the particle when it moves offscreen or below the surface of Io.'
  prefs: []
  type: TYPE_NORMAL
- en: '*tvashtar.py,* part 4'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-4: Defines the* update() *method and completes the* Particle *class*'
  prefs: []
  type: TYPE_NORMAL
- en: Define the `update()` method, which takes `self` as an argument ➊. Apply the
    force of gravity by adding the `GRAVITY` class attribute to `self.dy` during each
    game loop ➋. Gravity is a force vector that works only in the vertical direction,
    so only `self.dy` is affected.
  prefs: []
  type: TYPE_NORMAL
- en: To draw a path behind the particle, use `pygame`’s `draw.line()` method, which
    takes the background image of Io, the color of the particle, and the coordinates
    for the previous and current locations of the particle as arguments ➌. To get
    the current location, you add the `self.dx` and `self.dy` attributes to `self.x`
    and `self.y`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, update the particle’s `self.x` and `self.y` attributes by adding `self.dx`
    and `self.dy`, just as you did in the `draw.line()` method ➍.
  prefs: []
  type: TYPE_NORMAL
- en: Now, check to see if the particle has passed the left or right boundaries of
    the screen ➎. Use a `self.x` equal to zero for the left side and get the width
    of the `screen` attribute for the right side. If the particle has passed off either
    side of the screen, use the built-in `kill()` method to remove it from all the
    groups that contain it ➏. As you will see later, `pygame` uses containers—called
    *groups*—to manage sprites, and removing a sprite from a group takes it out of
    play.
  prefs: []
  type: TYPE_NORMAL
- en: Repeat this process for the y-direction ➐, but for a maximum value, use the
    `IO_SURFACE_Y` constant of the `Particle` class, which will stop the particle
    near the surface of Io, where an SO[2] particle would stop (see [Figures 13-2](ch13.xhtml#ch13fig2)
    and [13-4](ch13.xhtml#ch13fig4)).
  prefs: []
  type: TYPE_NORMAL
- en: '***Defining the main() Function***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 13-5](ch13.xhtml#ch13list5) defines the first part of the `main()`
    function that sets up the game screen, the window caption, the legend, the sprite
    group, and the game clock.'
  prefs: []
  type: TYPE_NORMAL
- en: '*tvashtar.py,* part 5'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-5: Defines the first part of the* main() *function*'
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to assign the `screen` variable using `pygame`’s `display.set_mode()`
    method ➊. The arguments are pixel dimensions; in this case, you use values slightly
    smaller than those for the NASA image to ensure a good fit. Note that the dimensions
    must be provided as a tuple, so you need to include two sets of parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: Next, name your game window using `pygame`’s `display.set_caption()` method
    ➋, then assign the `background` variable to the NASA photo of the Tvashtar plume
    ➌. Use `pygame`’s `image.load()` method to create a new `Surface` object from
    the image. The `pygame` package supports several image formats, including PNG,
    JPG, and GIF. The returned `Surface` will inherit color and transparency information
    from the image file. Since you’re importing a grayscale image here, your color
    choices will be limited.
  prefs: []
  type: TYPE_NORMAL
- en: Now, add some code to build the legend that will be displayed in the upper left
    of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Name a `legend_font` variable and use `pygame`’s `font.SysFont()` method to
    choose `None` at size 24 ➍. You will use this when you render the text. The `pygame`
    package’s `font` module lets you render a new set of fonts, called TrueType fonts,
    onto a new `Surface` object. If you don’t want to specify a font, `pygame` comes
    with a built-in default font, which you can access by passing `None` as the font
    name.
  prefs: []
  type: TYPE_NORMAL
- en: Post the particle names in order of weight, with the lightest on the top. To
    make a label, call `render()` on the `legend_font` object you made earlier to
    generate a new surface object ➎. Pass it some text, then `True` (to turn on anti-aliasing
    so the text looks smoother), and then the color of the particle being described.
    The last argument, `BLACK`, is optional and sets the background color of the label
    to black so the text will be legible above all the particle paths drawn on the
    screen. Repeat this process for the three remaining particles and add `S2` to
    the `so2_label`, as both gases share the same atomic weight and will behave the
    same in the simulation.
  prefs: []
  type: TYPE_NORMAL
- en: Now, start a sprite group named `particles` ➏. Since games typically have multiple
    sprites moving around the screen, `pygame` uses a container—the sprite group—to
    manage them. In fact, you *must* put sprites in a group or else they won’t do
    anything.
  prefs: []
  type: TYPE_NORMAL
- en: Finish this section by creating a `Clock` object to track and control the frame
    rate of the simulation ➐. A `pygame` “clock” controls how fast the game runs,
    based on the number of *frames per second (fps)* being displayed. You’ll set this
    value in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: '***Completing the main() Function***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 13-6](ch13.xhtml#ch13list6) completes `main()` by setting the speed
    the simulation will run—in frames per second—and starting the `while` loop that
    actually runs the simulation. It also handles *events*, which occur when a user
    exerts control on the program using a mouse, joystick, or keyboard. Since this
    is a simulation and not a true game, user control is limited to closing the window.
    The listing ends in the global scope with the standard code for running the program
    as a module or in stand-alone mode.'
  prefs: []
  type: TYPE_NORMAL
- en: '*tvashtar.py,* part 6'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-6: Starts the game clock and loop and handles events in the* main()
    *function*'
  prefs: []
  type: TYPE_NORMAL
- en: Start a `while` loop to run the simulation ➊. Then use the `clock.tick()` method
    to set the speed limit for the simulation ➋. Pass it `25`, which sets the maximum
    frame rate at 25 frames per second. Feel free to increase this value if you want
    a more energetic volcano.
  prefs: []
  type: TYPE_NORMAL
- en: It’s now time for the star of the show to make its appearance. Instantiate a
    particle using the `Particle` class, passing it the `screen` and `background`
    as arguments, and add the new particle to the `particles` sprite group ➌. With
    each frame, a new particle will be created at random and launched from the volcanic
    vent, producing a pleasing spray of particles (see [Figure 13-7](ch13.xhtml#ch13fig7)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0279-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-7: Startup of the simulation, with random particles being generated
    at the rate of 25 frames per second*'
  prefs: []
  type: TYPE_NORMAL
- en: Start a `for` loop to handle events ➍. All the events that happened during the
    current frame are recorded by `pygame` and kept in an *event buffer*. Its `event.get()`
    method creates a list of all these events so that you can evaluate them in turn.
    If a `QUIT` event occurs (when a user closes the game window), the `pygame` `quit()`
    and system `exit()` methods are called to end the simulation.
  prefs: []
  type: TYPE_NORMAL
- en: To render the game objects and update the visual display, `pygame` uses a process
    called *blitting*. *Blit* stands for *block transfer*, which is just copying pixels
    from one rectangular `Surface` object onto another. By blitting the background
    onto the screen, you cover the screen with the Io image. With blitting, you can
    take the same image and draw it multiple times at different places on the screen.
    It can be a slow process, so game developers use clever techniques to address
    this deficiency, such as blitting only around areas that are currently being updated,
    rather than blitting the whole screen in every game loop.
  prefs: []
  type: TYPE_NORMAL
- en: To blit the background onto the screen, call the `blit()` method on the screen
    and pass it the required arguments for source and destination ➎. In the first
    example, the `background` variable is the source, and the destination is the coordinates
    for where you want the *upper left-hand corner* of the background. Since the background
    will cover the whole screen, use the origin point for the screen, which is `(0,
    0)`. Repeat this for the legend labels, placing them in the upper-left corner
    of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Next, call the `update()` method on the `particles` group ➏. This method doesn’t
    update the screen but has the sprites run their own `self.update()` methods. After
    this, you use the `draw()` method to blit the sprites onto the screen based on
    each sprite’s `rect` attributes. This method needs a drawing surface, so pass
    it the `screen`.
  prefs: []
  type: TYPE_NORMAL
- en: The `draw()` method took care of blitting sprites, so all you need to do now
    is use the `flip()` method to update the actual game graphics ➐. *Flipping* is
    a type of double buffering where you blit everything from the `screen` object
    to the actual display. Flipping gets around the inherently slow process of displaying
    graphics, which can cause the screen to flicker, by doing the work on a behind-the-scenes
    rectangle and then using a version of the `blit()` method to copy to the final
    display
  prefs: []
  type: TYPE_NORMAL
- en: The listing ends outside the `main()` function with the code that lets the program
    run as a module or in stand-alone mode ➑.
  prefs: []
  type: TYPE_NORMAL
- en: '**Running the Simulation**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Figure 13-8](ch13.xhtml#ch13fig8) shows the result of running the simulator
    for about a minute. The water vapor plume extends beyond the top of the window.
    The next highest plume is formed by hydrogen sulfide, followed by carbon dioxide,
    and then sulfur dioxide/sulfur (S[2]) gas, which by design perfectly matches the
    Tvashtar plume.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0281-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-8: Results of running* tvashtar.py *for one minute*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the simulator with *only* SO[2], go to the `__init__` method of the
    `Particle` class and change the lines where you select the `gas` and `color` instance
    attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: By choosing a color at random, you maintain a sense of movement in the plume
    after all of the possible `self.orient` angles have been exhausted. And if you
    want to speed up or slow down the eruption, go to the `main()` function and experiment
    with the `clock.tick()` method’s frames-per-second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: In real life, the composition of plume material was inferred with *spectroscopy*,
    a measurement technique that analyzes how light interacts with matter. This includes
    both visible and nonvisible wavelengths that are absorbed, emitted, or scattered.
    The “spectra of the ejecta,” together with the colors painted on the surface,
    provided the key evidence for sulfur-rich plumes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use the `pygame` package to simulate gravity
    and build an animation of an extraterrestrial volcano. In the next chapter, you’ll
    use `pygame` to build a true arcade game with player interactions and win-lose
    conditions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Further Reading**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Game Programming: The L-Line, The Express Line to Learning* (Wiley, 2007)
    by Andy Harris is a tremendously useful and thorough 570-page introduction to
    `pygame`.'
  prefs: []
  type: TYPE_NORMAL
- en: '*More Python for the Absolute Beginner* (Cengage Learning Course Technology,
    2012) by Jonathon Harbour builds on the prequel, *Python for the Absolute Beginner*,
    using a (py)game-focused approach.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Invent Your Own Computer Games with Python, 4th Edition* (No Starch Press,
    2016) by Al Sweigart is a good introduction to both Python and game design for
    beginners.'
  prefs: []
  type: TYPE_NORMAL
- en: An online “newbie guide” for `pygame` is available at *[https://www.pygame.org/docs/tut/newbieguide.html](https://www.pygame.org/docs/tut/newbieguide.html)*,
    and a “cheat sheet” can be found at *[http://www.cogsci.rpi.edu/~destem/gamedev/pygame.pdf](http://www.cogsci.rpi.edu/~destem/gamedev/pygame.pdf)*.
  prefs: []
  type: TYPE_NORMAL
- en: '*Three-Dimensional Simulation of Gas and Dust in Io’s Pele Plume*, by William
    J. McDoniel and others, documents the simulation of Io’s Pele Plume using direct
    Monte Carlo simulation and supercomputers at the Texas Advanced Computing Center
    at the University of Texas. The article is available at *[http://cfpl.ae.utexas.edu/wp-content/uploads/2016/01/McDoniel_PeleDust.pdf](http://cfpl.ae.utexas.edu/wp-content/uploads/2016/01/McDoniel_PeleDust.pdf)*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Practice Project: Going the Distance**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’re one of King Henry’s archers at the battle of Agincourt. The French are
    charging, and you want to strike them as far away as possible. At what angle do
    you hold your longbow?
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve ever had a physics class, you probably know the answer is 45 degrees.
    But can you trust that pencil-necked physicist? Better run a quick computer simulation
    to check it out. Copy and edit the *tvashtar.py* code to randomly fire particles
    at 25, 35, 45, 55, and 65 degrees. Set `self.color` to `WHITE` for 45 degrees
    and `GRAY` for all other angles (see [Figure 13-9](ch13.xhtml#ch13fig9)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0282-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-9: Io volcano simulator modified for ejection angles of 25, 35,
    45, 55, and 65 degrees*'
  prefs: []
  type: TYPE_NORMAL
- en: You can find a solution, *practice_45.py*, in the appendix or for download at
    *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*.
    Keep it in the same folder as the *tvashtar_plume.gif* file.
  prefs: []
  type: TYPE_NORMAL
- en: '**Challenge Projects**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Continue your experiments with these challenge projects. No solutions are provided.
  prefs: []
  type: TYPE_NORMAL
- en: '***Shock Canopy***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The visibility of Io’s giant plumes is believed to be enhanced by gas condensing
    into dust in the *shock canopy*, the point where the gas particles reach their
    apex and begin falling back to the surface. Use the `self.dy` attribute to edit
    the path colors in a copy of the *tvashtar.py* program. Paths in the apex of the
    plume should be brighter than those below (see [Figure 13-10](ch13.xhtml#ch13fig10)).
    As with all Challenge Projects, no solution is provided.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0283-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-10: Highlighting the shock canopy using lighter path colors*'
  prefs: []
  type: TYPE_NORMAL
- en: '***The Fountainhead***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Copy and edit *tvashtar.py* so that only SO[2] is simulated and particles are
    represented by small white circles with no trailing paths (see [Figure 13-11](ch13.xhtml#ch13fig11)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0283-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-11: Screenshot of SO[2] simulation with circles representing individual
    particles*'
  prefs: []
  type: TYPE_NORMAL
- en: '***With a Bullet***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you fire a gun straight up on a planet with no atmosphere, will the bullet
    hit the ground with the same velocity as when it left the muzzle? Many people
    struggle with this question, but you can answer it with Python. Copy and edit
    the *tvashtar.py* code so that it ejects a single SO[2] particle with an orientation
    of 90 degrees. Print the particle’s `self.y` attribute and the absolute value
    of `self.dy` at the launch point coordinate (y = 300). Compare the starting and
    ending velocity values at this point to see whether they are the same or similar.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Episode 50 of the TV show* MythBusters *addressed the myth that bullets fired
    into the air maintain their lethal capability when they eventually fall back down.
    They found that bullets fired perfectly vertical on Earth would tumble and slow
    on their way back down due to wind resistance. If fired slightly off-vertical,
    the bullets would maintain their spin and ballistic trajectory and return to Earth
    at lethal speed. It was the only myth that ever received all three ratings (Busted,
    Plausible, and Confirmed)!*'
  prefs: []
  type: TYPE_NORMAL
