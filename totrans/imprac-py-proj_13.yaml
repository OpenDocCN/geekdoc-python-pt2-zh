- en: '**13'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**13'
- en: SIMULATING AN ALIEN VOLCANO**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟外星火山**
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: Quick! Name the most volcanically active body in the solar system! If you thought
    Earth, then you’d be mistaken—it’s Io (“EYE-oh”), one of Jupiter’s four Galilean
    moons.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 快！说出太阳系中火山活动最频繁的天体！如果你认为是地球，那你就错了——其实是木卫一（"EYE-oh"），它是木星的四颗伽利略卫星之一。
- en: The first evidence of volcanism on Io came in 1979, when *Voyager 1* made its
    famous fly-by of the Jovian system. But the spectacular photographs it recorded
    were no real surprise. Astrophysicist Stan Peale and two coauthors had already
    published this result based on models of Io’s interior.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 1979年，当*旅行者1号*成功飞掠木星系统时，首次获得了木卫一火山活动的证据。但它拍摄的壮观照片并不令人惊讶。天体物理学家Stan Peale和两位合著者已经根据木卫一内部模型发布了这一结果。
- en: 'Computer modeling is a powerful tool for understanding nature and making predictions.
    Here’s the general workflow:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机建模是理解自然和进行预测的强大工具。以下是一般的工作流程：
- en: Gather data.
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 收集数据。
- en: Analyze, interpret, and integrate the data.
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分析、解释并整合数据。
- en: Generate numerical equations that explain the data.
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成解释数据的数值方程。
- en: Construct a computer model that best “fits” the data.
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建最能“拟合”数据的计算机模型。
- en: Use the model to make predictions and investigate error ranges.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用模型进行预测并调查误差范围。
- en: Applications of computer modeling are far-reaching and include such areas as
    wildlife management, weather forecasts, climate predictions, hydrocarbon production,
    and black-hole simulations.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机建模的应用领域广泛，包括野生动物管理、天气预报、气候预测、碳氢化合物生产和黑洞模拟等领域。
- en: In this chapter, you’ll use a Python package called pygame—normally used to
    create games—to simulate one of Io’s volcanoes. You’ll also experiment with different
    types of *ejecta* (erupted particles) and compare their simulated behaviors to
    a photo of Io’s mammoth Tvashtar plume.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将使用一个名为pygame的Python包——这个包通常用于制作游戏——来模拟木卫一的火山之一。你还将尝试不同类型的*喷发物*（喷出的颗粒），并将其模拟行为与木卫一巨大Tvashtar喷流的照片进行对比。
- en: '**Project #21: The Plumes of Io**'
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**项目 #21：木卫一的火山喷发**'
- en: '*Tidal heating* is responsible for the volcanism on Io. As its elliptical orbit
    carries it through the gravity fields of Jupiter and its sister moons, Io experiences
    variations in tidal pull. Its surface flexes up and down by as much as 100 meters,
    resulting in significant friction-related heating and melting in its interior.
    Hot magma migrates to the surface and forms great lava lakes from which degassing
    sulfur (S[2]) and sulfur dioxide (SO[2]) are sprayed skyward with speeds of 1
    km/s. Because of Io’s low gravity and lack of atmosphere, these plumes of gas
    can reach heights of hundreds of kilometers (see the Tvashtar plume in [Figure
    13-1a](ch13.xhtml#ch13fig1)).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*潮汐加热*是木卫一火山活动的原因。由于其椭圆轨道使其穿越木星及其卫星的引力场，木卫一经历潮汐拉力的变化。其表面上下弯曲最多可达100米，从而在内部产生显著的摩擦加热和熔化。热熔岩迁移到表面，形成巨大的熔岩湖，并喷出含硫气体（S[2]）和二氧化硫（SO[2]），这些气体以每秒1公里的速度喷射向空中。由于木卫一的低重力和缺乏大气层，这些气体喷流可以达到数百公里的高度（见[图13-1a](ch13.xhtml#ch13fig1)中的Tvashtar喷流）。'
- en: '![image](../images/f0266-01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0266-01.jpg)'
- en: '*Figure 13-1: a) Io with the 330 km Tvashtar plume at the top and the shorter
    Prometheus plume at the 9 o’clock position; b) Io with volcanic ring deposits
    (NASA images)*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-1：a) 木卫一，顶部是330公里的Tvashtar喷流，9点钟位置是较短的Prometheus喷流；b) 木卫一及其火山环形沉积物（NASA图片）*'
- en: The plumes’ pleasing umbrella shape is produced as gas and dust shoot upward,
    then fall back in every direction. The resulting surface deposits form concentric
    rings of red, green, black, and yellow. If [Figure 13-1b](ch13.xhtml#ch13fig1)
    were in color, it would look a bit like a moldy pepperoni pizza.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 喷流那美丽的伞形结构是因为气体和尘土向上喷射，然后在各个方向上落下。由此形成的表面沉积物会形成红色、绿色、黑色和黄色的同心环。如果[图13-1b](ch13.xhtml#ch13fig1)是彩色的，它看起来有点像一张发霉的意大利辣香肠披萨。
- en: '**A Slice of pygame**'
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**pygame简介**'
- en: The pygame package is a cross-platform set of Python modules that are typically
    used to program 2D arcade-style video games. It supports graphics, animations,
    sound effects, music, and multiple input devices, such as the keyboard and mouse.
    Learning pygame is more than just a fun way to learn programming. Arcade-style
    games have seen a resurgence in popularity thanks to the proliferation of smartphones
    and tablets, and mobile gaming now earns almost as much as console and PC gaming
    combined.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: pygame 包是一个跨平台的 Python 模块集，通常用于编写 2D 街机风格的视频游戏。它支持图形、动画、音效、音乐和多种输入设备，如键盘和鼠标。学习
    pygame 不仅仅是一个有趣的编程学习方式。随着智能手机和平板电脑的普及，街机风格的游戏重新受到欢迎，现在移动游戏的收入几乎与主机和 PC 游戏的总收入相当。
- en: The pygame package uses the *Simple DirectMedia Library (SDL)*, which is an
    *application programming interface (API)*. APIs are reusable code libraries that
    make handling graphics fairly easy, allowing you to focus on game design while
    using a high-level language like Python. The Microsoft *DirectX* API is used for
    creating games and multimedia apps for the Windows platform. For working across
    multiple platforms, two open source libraries are SDL, mainly for 2D work, and
    *OpenGL (Open Graphics Library)* for 3D applications. As mentioned, you’ll be
    working with SDL, which officially supports Windows, macOS, Linux, iOS, and Android.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: pygame 包使用了 *简单直接媒体库（SDL）*，它是一个 *应用程序编程接口（API）*。API 是可重用的代码库，它使得处理图形变得相当简单，允许你在使用像
    Python 这样的高级语言时，专注于游戏设计。微软的 *DirectX* API 用于为 Windows 平台创建游戏和多媒体应用。为了跨平台工作，有两个开源库：SDL，主要用于
    2D 工作；以及 *OpenGL（开放图形库）*，用于 3D 应用。如前所述，你将使用 SDL，它正式支持 Windows、macOS、Linux、iOS
    和 Android。
- en: The pygame package also uses object-oriented programming (OOP). If you are unfamiliar
    with OOP or need a refresher, see “[A Brief Introduction to Object-Oriented Programming](ch11.xhtml#lev256)”
    on [page 223](ch11.xhtml#page_223). Additionally, introductory books on Python
    often include a section on pygame, and there are whole books written on the package
    (see “[Further Reading](ch13.xhtml#lev309)” on [page 281](ch13.xhtml#page_281)
    for some examples).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: pygame 包还使用了面向对象编程（OOP）。如果你不熟悉 OOP 或需要复习，可以参见 “[面向对象编程简明介绍](ch11.xhtml#lev256)”
    在 [第 223 页](ch11.xhtml#page_223)。此外，Python 的入门书籍通常包括有关 pygame 的章节，也有整本书专门讲解这个包（参见
    “[进一步阅读](ch13.xhtml#lev309)” 在 [第 281 页](ch13.xhtml#page_281) 的一些示例）。
- en: Before you can continue, you’ll need to install pygame onto your system. Instructions
    for installing a free copy on your preferred platform are available at *[http://pygame.org/wiki/GettingStarted#Pygame%20Installation](http://pygame.org/wiki/GettingStarted#Pygame%20Installation)*.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，你需要将 pygame 安装到你的系统中。有关在你首选平台上安装免费副本的说明，可以参考 *[http://pygame.org/wiki/GettingStarted#Pygame%20Installation](http://pygame.org/wiki/GettingStarted#Pygame%20Installation)*。
- en: Video tutorials on how to install pygame are also available online. To ensure
    a video is appropriate to your situation, be sure to check the date of the video,
    the platform discussed, and the versions of pygame and Python in use. You can
    find additional instructions for Mac users with older Python installs at *[http://brysonpayne.com/2015/01/10/setting-up-pygame-on-a-mac/](http://brysonpayne.com/2015/01/10/setting-up-pygame-on-a-mac/)*.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如何安装 pygame 的视频教程也可以在线找到。为了确保视频适合你的情况，务必检查视频的日期、讨论的平台以及使用的 pygame 和 Python 版本。你可以在
    *[http://brysonpayne.com/2015/01/10/setting-up-pygame-on-a-mac/](http://brysonpayne.com/2015/01/10/setting-up-pygame-on-a-mac/)*
    查找关于 Mac 用户安装较旧 Python 版本的额外说明。
- en: '**THE OBJECTIVE**'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标**'
- en: Use pygame to build a 2D, gravity-based simulation of Io’s Tvashtar volcanic
    plume. Calibrate the plume dimensions using a NASA image. Use multiple particle
    types in the plume, trace the particles’ flight paths and allow the eruption to
    run automatically until stopped.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 pygame 构建一个基于重力的 2D 模拟，模拟木卫二 Io 的 Tvashtar 火山羽流。使用 NASA 的图像来校准羽流的尺寸。在羽流中使用多种粒子类型，追踪粒子的飞行路径，并允许喷发自动运行直到停止。
- en: '**The Strategy**'
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**策略**'
- en: Building a comprehensive, full-physics simulation of one of Io’s plumes is best
    accomplished with a supercomputer. Since you probably don’t have one of those
    and since your goal is to make a cool pygame display, you’re going to cheat by
    reverse-engineering the parameters you need to make SO[2] fit the Tvashtar plume.
    Remember, cheating is the gift humans give ourselves; it’s what separates us from
    the animals—except for the cheetahs!
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个完整的木卫一喷发云的物理模拟，最好的方式是使用超级计算机。由于您可能没有这样的计算机，并且您的目标是制作一个酷炫的pygame显示器，您将通过逆向工程所需的参数来让SO[2]适应Tvashtar喷发云。记住，作弊是人类赋予自己的礼物；它使我们与动物区分开来——除了猎豹！
- en: Since the composition of Io’s plumes is already known, you’re going to calibrate
    your gravity field to SO[2] and sulfur (S[2]) gas, which conveniently have the
    same atomic weight. When the flight paths of these particles match the dimensions
    of the Tvashtar plume in the NASA photograph, you will scale the velocity of other
    ejected particles, based on the difference in atomic weight between the new particle
    and SO[2], to see how particle type affects plume dimensions. Lighter particles
    will be ejected higher and vice versa.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于木卫一喷发云的组成已经知道，您将把重力场标定为SO[2]和硫（S[2]）气体，它们恰好具有相同的原子质量。当这些颗粒的飞行路径与NASA照片中Tvashtar喷发云的尺寸匹配时，您将基于新颗粒与SO[2]之间的原子质量差异，调整其他喷发颗粒的速度，以查看颗粒类型如何影响喷发云的尺寸。较轻的颗粒将被喷射得更高，反之亦然。
- en: '***Using a Game Sketch to Plan***'
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用游戏草图进行规划***'
- en: I suggest you begin any pygame project with a sketch of how the game should
    look and how the action should progress. Even the simplest arcade games can become
    complicated, and a sketch will help you manage the complexity. Among the many
    things you must consider in a typical game are player actions, scorekeeping, messages
    and instructions, game entities and their interactions (such as collisions, sound
    effects, and music), and game-ending conditions.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议您在任何pygame项目开始时，先草拟出游戏应该如何呈现，动作应该如何进行。即使是最简单的街机游戏也可能变得复杂，而草图将帮助您管理这种复杂性。在典型游戏中，您必须考虑的许多事项包括玩家动作、计分、信息和指示、游戏实体及其交互（例如碰撞、音效和音乐）以及游戏结束条件。
- en: Sketching the game—or in this case, the simulation—is best done on a whiteboard,
    either real or digital. My layout for the Io volcano simulator is shown in [Figure
    13-2](ch13.xhtml#ch13fig2).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏草图——或者在这个案例中是模拟草图——最好在白板上完成，可以是真实的白板或数字白板。我的木卫一火山模拟器布局如[图13-2](ch13.xhtml#ch13fig2)所示。
- en: '![image](../images/f0268-01.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0268-01.jpg)'
- en: '*Figure 13-2: Game sketch of Io volcano simulator*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-2：木卫一火山模拟器的游戏草图*'
- en: 'The sketch in [Figure 13-2](ch13.xhtml#ch13fig2) contains guidelines and key
    behaviors for the volcano simulator:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '[图13-2](ch13.xhtml#ch13fig2)中的草图包含了火山模拟器的指南和关键行为：'
- en: '**No direct player interactions.** You’ll control the simulation by editing
    the Python code, not through the mouse or keyboard.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**没有直接的玩家交互。** 您将通过编辑Python代码来控制模拟，而不是通过鼠标或键盘进行控制。'
- en: '**The background will be a NASA image of a plume.** To calibrate the simulation
    to SO[2]/S[2] particles, you’ll need a backdrop of the actual Tvashtar plume.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**背景将是NASA的一张喷发云图像。** 要将模拟调整到SO[2]/S[2]颗粒，您需要使用实际的Tvashtar喷发云作为背景。'
- en: '**The launch point pivots.** The particles should be ejected from the central
    base of the plume image and should spray out over a range of angles, rather than
    just straight up.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发射点是可旋转的。** 颗粒应从喷发云图像的中央基座喷出，并且应以一定范围的角度喷射，而不仅仅是直接向上。'
- en: '**Particles are chosen at random.** The program will choose the type of particle
    at random. Each particle will have a unique color that distinguishes it from others.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**颗粒是随机选择的。** 程序将随机选择颗粒类型。每个颗粒都会有一个独特的颜色，用以区分其他颗粒。'
- en: '**The particle flight path should be visible and persistent.** The flight of
    each particle should be recorded as a line that remains visible throughout the
    simulation, and the line color should match the particle color.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**颗粒的飞行路径应当可见且持久。** 每个颗粒的飞行路径应记录为一条线，并在整个模拟过程中始终可见，且该线的颜色应与颗粒的颜色匹配。'
- en: '**A color-coded legend lists the particle types.** The program should post
    a legend with the particle names in the upper-left corner of the screen. The font
    colors should match the particle colors, and the legend should print on top of
    particle paths so that it’s always visible.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**彩色编码图例列出了颗粒类型。** 程序应该在屏幕的左上角显示一个图例，图例中包含颗粒名称。字体颜色应与颗粒颜色匹配，图例应覆盖在颗粒路径上方，以确保始终可见。'
- en: '**Particle motion should stop at the level at which SO**[2] **particles intersect
    the surface of Io.** The simulation is tuned to the behavior of SO[2], so falling
    particles should stop at the appropriate location for an SO[2] plume.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**There are no sound effects.** In space, no one can hear you scream.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you complete your diagram, you can begin picking parts from it and listing
    them in logical order; this breaks the plan into a series of manageable steps.
    For example, you’ll need to find and prepare an appropriate background image,
    decide which particles you want to simulate and look up their atomic weights,
    locate a launch point, calibrate SO[2] behavior to the plume image, and so on.
    You’re still writing pseudocode, but a game sketch makes it a much more enjoyable
    process!
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '***Planning the Particle Class***'
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Since this simulation is based on *particles*, it makes sense to have an OOP
    Particle class to serve as a blueprint for multiple particle types. The class
    should support the random generation of particle types, and constants and other
    attributes common to all particles can be stored as *class attributes*. These
    are attributes assigned at the same indentation level as methods. The Particle
    class should also contain methods that allow instances of the class to be ejected,
    affected by gravity, made visible, and destroyed when they move beyond the boundaries
    of the simulation.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: The attributes and methods used in the class are shown in [Tables 13-1](ch13.xhtml#ch13tab1)
    and [13-2](ch13.xhtml#ch13tab2), respectively. Class attributes—that is, those
    shared by all instances of the class—are shown in italics; otherwise, instance
    attributes are shown.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 13-1:** Attributes of the Particle Class (*Italics* = Class Attribute)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '| **Attributes** | **Attribute description** |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
- en: '| *gases_colors* | Dictionary of available particle types and their colors
    |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
- en: '| *VENT_LOCATION_XY* | x- and y-location of mouth of Tvashtar volcano in image
    |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
- en: '| *IO_SURFACE_Y* | Io surface y-value at SO[2] plume margin in image |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
- en: '| *VELOCITY_SO2* | Speed (pixels per frame) of SO[2] particle |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
- en: '| *GRAVITY* | Acceleration of gravity in pixels per frame |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
- en: '| *vel_scalar* | Dictionary of ratios of SO[2]/particle atomic weights |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
- en: '| screen | The game screen |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
- en: '| background | A NASA image of the Tvashtar plume |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
- en: '| image | A square pygame surface representing a particle |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
- en: '| rect | A rectangular object used to get surface dimensions |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
- en: '| gas | The type of an individual particle (SO[2], CO[2], etc.) |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
- en: '| color | Color of an individual particle type |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
- en: '| vel | Particle’s velocity relative to SO[2] velocity |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
- en: '| x | Particle’s x-location |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
- en: '| y | Particle’s y-location |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
- en: '| dx | Particle’s delta-x |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
- en: '| dy | Particle’s delta-y |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
- en: '**Table 13-2:** Methods of the Particle Class'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Method description** |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
- en: '| __init__() | Initializes and sets up parameters for randomly selected particle
    type |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
- en: '| vector() | Randomly selects ejection orientation and calculates motion vector
    (dx and dy) |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| vector() | 随机选择喷射方向并计算运动向量（dx 和 dy） |'
- en: '| update() | Adjusts particle trajectory for gravity, draws path behind particle,
    and destroys particles that move beyond the boundaries of the simulation |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| update() | 调整粒子轨迹以适应重力，绘制粒子后方的路径，并销毁超出模拟边界的粒子 |'
- en: I will explain each of these attributes and methods in more detail in the next
    section.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在下一节中更详细地解释这些属性和方法。
- en: '**The Code**'
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**代码**'
- en: The *tvashtar.py* code will generate a pygame-based simulation of Io’s Tvashtar
    plume. You will also need the background image, *tvashtar_plume.gif*. Download
    both files from *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*
    and keep them in the same folder.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*tvashtar.py* 代码将生成一个基于 pygame 的 Io 行星 Tvashtar 喷流模拟。你还需要背景图像 *tvashtar_plume.gif*。从
    *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*
    下载这两个文件，并将它们保存在同一个文件夹中。'
- en: '***Importing Modules, Initiating pygame, and Defining Colors***'
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***导入模块，初始化 pygame，并定义颜色***'
- en: Begin with several set-up steps, such as choosing colors, as shown in [Listing
    13-1](ch13.xhtml#ch13list1).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 从一些设置步骤开始，例如选择颜色，如 [列表 13-1](ch13.xhtml#ch13list1) 所示。
- en: '*tvashtar.py,* part 1'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*tvashtar.py，* 第 1 部分'
- en: ➊ import sys
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ import sys
- en: import math
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 math
- en: import random
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 random
- en: import pygame as pg
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 pygame 作为 pg
- en: ➋ pg.init()  # initialize pygame
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ pg.init()  # 初始化 pygame
- en: '➌ # define color table'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '➌ # 定义颜色表'
- en: BLACK = (0, 0, 0)
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: BLACK = (0, 0, 0)
- en: WHITE = (255, 255, 255)
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: WHITE = (255, 255, 255)
- en: LT_GRAY = (180, 180, 180)
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: LT_GRAY = (180, 180, 180)
- en: GRAY = (120, 120, 120)
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: GRAY = (120, 120, 120)
- en: DK_GRAY = (80, 80, 80)
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: DK_GRAY = (80, 80, 80)
- en: '*Listing 13-1: Imports modules, initiates* pygame, *and defines a table of
    colors*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 13-1：导入模块，初始化* pygame，*并定义颜色表*'
- en: 'Start with some familiar imports and one for pygame ➊. Next, call the pygame.init()
    function. This initializes the pygame module and starts up all the underlying
    parts that let it use sounds, check keyboard input, run graphics, and so on ➋.
    Note that pygame can be initialized from multiple places, such as the first line
    in a main() function:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 从一些常见的导入开始，并为 pygame 导入一个模块 ➊。接下来，调用 pygame.init() 函数。这将初始化 pygame 模块并启动所有底层组件，使其能够使用声音、检查键盘输入、运行图形等
    ➋。请注意，pygame 可以从多个位置初始化，例如在 main() 函数中的第一行：
- en: 'def main():'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 'def main():'
- en: pg.init()
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: pg.init()
- en: 'or at the end of the program when main() is called in stand-alone mode:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 或者在程序结束时，当 main() 以独立模式调用时：
- en: 'if __name__ == "__main__":'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 __name__ == "__main__":'
- en: pg.init()
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: pg.init()
- en: main()
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: main()
- en: Stop and assign some color variables using the RGB color model ➌. This model
    mixes red, green, and blue, where each color consists of values from 0 to 255\.
    If you do an online search for “RGB color codes,” you can find the numerical codes
    for millions of colors. But since the NASA image you’ll calibrate against is in
    grayscale, stick with black, white, and shades of gray. Defining this table now
    will allow you to simply enter a name when pygame needs a color defined later.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 停下来并使用 RGB 颜色模型分配一些颜色变量 ➌。这个模型混合红色、绿色和蓝色，每个颜色的值在 0 到 255 之间。如果你在线搜索 “RGB 颜色代码”，你可以找到数百万种颜色的数字代码。但是，由于你将校准的
    NASA 图像是灰度图像，因此只使用黑色、白色和灰色的不同色调。现在定义这个表格将允许你在 pygame 后面需要定义颜色时，只需输入一个名称。
- en: '***Defining the Particle Class***'
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***定义 Particle 类***'
- en: '[Listing 13-2](ch13.xhtml#ch13list2) defines the Particle class and its initializer
    method. You’ll use these to instantiate a particle object. The particle’s key
    attributes, such as type, velocity, color, and so on, are established with the
    initializer method.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 13-2](ch13.xhtml#ch13list2) 定义了 Particle 类及其初始化方法。你将使用这些来实例化粒子对象。粒子的关键属性，如类型、速度、颜色等，都是通过初始化方法来设置的。'
- en: '*tvashtar.py,* part 2'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*tvashtar.py，* 第 2 部分'
- en: '➊ class Particle(pg.sprite.Sprite):'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ class Particle(pg.sprite.Sprite):'
- en: '"""Builds ejecta particles for volcano simulation."""'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '"""构建火山模拟的喷发颗粒。"""'
- en: '➋ gases_colors = {''SO2'': LT_GRAY, ''CO2'': GRAY, ''H2S'': DK_GRAY, ''H2O'':
    WHITE}'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '➋ gases_colors = {''SO2'': LT_GRAY, ''CO2'': GRAY, ''H2S'': DK_GRAY, ''H2O'':
    WHITE}'
- en: ➌ VENT_LOCATION_XY = (320, 300)
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ VENT_LOCATION_XY = (320, 300)
- en: IO_SURFACE_Y = 308
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: IO_SURFACE_Y = 308
- en: GRAVITY = 0.5  # pixels-per-frame; added to dy each game loop
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: GRAVITY = 0.5  # 每帧像素数；每个游戏循环中加到 dy 上
- en: VELOCITY_SO2 = 8  # pixels-per-frame
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: VELOCITY_SO2 = 8  # 每帧像素数
- en: '# scalars (SO2 atomic weight/particle atomic weight) used for velocity'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '# 用于速度的标量（SO2 原子量/粒子原子量）'
- en: '➍ vel_scalar = {''SO2'': 1, ''CO2'': 1.45, ''H2S'': 1.9, ''H2O'': 3.6}'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '➍ vel_scalar = {''SO2'': 1, ''CO2'': 1.45, ''H2S'': 1.9, ''H2O'': 3.6}'
- en: '➎ def __init__(self, screen, background):'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '➎ def __init__(self, screen, background):'
- en: super().__init__()
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: super().__init__()
- en: self.screen = screen
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: self.screen = screen
- en: self.background = background
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: self.background = background
- en: ➏ self.image = pg.Surface((4, 4))
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ➏ self.image = pg.Surface((4, 4))
- en: self.rect = self.image.get_rect()
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: self.rect = self.image.get_rect()
- en: ➐ self.gas = random.choice(list(Particle.gases_colors.keys()))
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ➐ self.gas = random.choice(list(Particle.gases_colors.keys()))
- en: self.color = Particle.gases_colors[self.gas]
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: self.color = Particle.gases_colors[self.gas]
- en: ➑ self.vel = Particle.VELOCITY_SO2 * Particle.vel_scalar[self.gas]
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ➑ self.vel = Particle.VELOCITY_SO2 * Particle.vel_scalar[self.gas]
- en: ➒ self.x, self.y = Particle.VENT_LOCATION_XY
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ➒ self.x, self.y = Particle.VENT_LOCATION_XY
- en: ➓ self.vector()
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ➓ self.vector()
- en: '*Listing 13-2: Defines the* Particle *class and the* Particle *initializer
    method*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*代码清单 13-2：定义了* Particle *类和* Particle *初始化方法*'
- en: Define a class called Particle to represent *any* molecule of gas that might
    form the volcanic plume ➊. The *ancestor* for this class, shown in parentheses,
    will be a Sprite class. This means that the Particle class is derived from a built-in
    pygame type called Sprite. Sprites are just 2D bitmaps that represent discrete
    game objects, like missiles or asteroids. You *inherit* from the Sprite class—that
    is, add its attributes and methods to your new class—by passing pg.sprite.Sprite
    to your Particle class, just as you would pass an argument to a function.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个名为Particle的类，用来表示可能形成火山羽流的*任何*气体分子 ➊。这个类的*祖先*（如括号中所示）是Sprite类。这意味着Particle类是从pygame内建的Sprite类派生的。精灵（Sprites）是表示离散游戏对象（如导弹或小行星）的二维位图。你通过将pg.sprite.Sprite传递给Particle类来*继承*Sprite类的属性和方法，正如你向函数传递参数一样。
- en: Assign properties common to all particles as class attributes. The first is
    a dictionary that maps particle types to a color, so that you can differentiate
    the particles during the simulation ➋. These colors will be used for the particle,
    its path, and its name in the legend.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有粒子共享的属性作为类属性进行赋值。第一个是一个字典，将粒子类型映射到颜色，以便在模拟过程中区分粒子 ➋。这些颜色将用于粒子、其路径以及图例中的名称。
- en: Now, assign four constants, VENT_LOCATION_XY, IO_SURFACE_Y, GRAVITY, and VELOCITY_SO2
    ➌. The first constant is the x- and y-coordinates for the mouth of the Tvashtar
    volcano in the image, which will represent the “launch point” for all the particles
    (see [Figure 13-3](ch13.xhtml#ch13fig3)). I initially guessed at these values
    and then fine-tuned them when the simulation was up and running.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，定义四个常量：VENT_LOCATION_XY、IO_SURFACE_Y、GRAVITY和VELOCITY_SO2 ➌。第一个常量是图像中Tvashtar火山口的x和y坐标，代表所有粒子的“发射点”（见[图
    13-3](ch13.xhtml#ch13fig3)）。我最初猜测了这些值，然后在模拟运行起来后进行了微调。
- en: '![image](../images/f0273-01.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0273-01.jpg)'
- en: '*Figure 13-3: Background image for the simulation with the particle launch
    point annotated*'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-3：模拟背景图，并标注了粒子发射点*'
- en: The second constant is the y-value for the highest point on Io’s surface (in
    the image) that intersects with the outer edge of the SO[2] plume (see [Figure
    13-2](ch13.xhtml#ch13fig2)). You will stop all the falling particles at this y-value,
    so the view will be optimized for SO[2].
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个常量是Io表面（图像中的）与SO[2]羽流外缘相交的最高点的y值（见[图 13-2](ch13.xhtml#ch13fig2)）。你将在这个y值处停止所有下落的粒子，因此视图将为SO[2]进行优化。
- en: The third constant represents the acceleration of gravity, which on Earth is
    9.86 m/s² and on Io is 1.796 m/s². But you’re dealing with pixels and frames here,
    not real-world units, so you need to experiment to find a value that looks good
    at the scale of your game/simulation. My choice of 0.5 was arbitrary, though guided
    by knowledge of what works well in arcade games.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个常量表示重力加速度，在地球上为9.86 m/s²，在木卫一（Io）上为1.796 m/s²。但这里处理的是像素和帧，而非现实世界的单位，因此你需要进行实验，以找到在你的游戏/模拟的尺度下，看起来合适的数值。我选择的0.5是随意的，但也受到街机游戏中有效数值的启发。
- en: The fourth constant is the speed, in pixels per frame, of an SO[2] particle
    when it is ejected. Remember, the plumes are composed primarily of SO[2], so you
    want to use parameters that will allow the SO[2] particles to “fit” the image
    of the Tvashtar plume, then adjust the speed of the remaining particles *relative*
    to SO[2]. Neither the GRAVITY nor the VELOCITY_SO2 value is unique. Had I chosen
    a larger value for GRAVITY, I would’ve needed to increase VELOCITY_SO2 so that
    the SO[2] particles still “fill out” the area of the plume in the NASA image.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 第四个常量是SO[2]粒子被喷出时的速度，单位是每帧像素。记住，羽流主要由SO[2]组成，因此你需要使用能够让SO[2]粒子“适应”Tvashtar羽流图像的参数，然后根据SO[2]的速度调整其他粒子的速度。无论是重力（GRAVITY）还是SO[2]的速度（VELOCITY_SO2）值都不是唯一的。如果我选择了更大的GRAVITY值，那么我需要增加VELOCITY_SO2，以确保SO[2]粒子仍能“填充”NASA图像中羽流的区域。
- en: Next, build a dictionary of scalars for particle velocity ➍. For each particle,
    dividing the atomic weight of SO[2] (64) by the atomic weight of the particle
    gives you the scalar. Since SO[2] is the reference particle, its scalar is 1\.
    Later, to get the velocity of non-SO[2] particles, you will multiply the VELOCITY_SO2
    constant by the scalar. As you can see, all of the other particles are lighter
    than SO[2] and should produce a larger plume.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为粒子速度构建一个标量字典➍。对于每个粒子，将SO[2]的原子质量（64）除以粒子的原子质量即可得到标量。由于SO[2]是参考粒子，它的标量为1\.
    后来，为了获得非SO[2]粒子的速度，你将用VELOCITY_SO2常量乘以标量。正如你所看到的，所有其他粒子都比SO[2]轻，并且应该产生更大的羽流。
- en: Define a constructor method for the particle object ➎. You’ll need a self parameter
    and screen to draw on and check the simulation's boundaries, and you’ll need a
    background, which will be an image of the Tvashtar plume. You’ll assign screen
    and background later in the main() function, defined near the end of the program.
    Note that while I’m using one-line docstrings in this book for brevity, you would
    want to include these types of parameters in the class docstring. For more guidelines
    on class docstrings, see *[https://www.python.org/dev/peps/pep-0257/](https://www.python.org/dev/peps/pep-0257/)*.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为粒子对象定义一个构造方法➎。你将需要一个self参数和用于绘制的屏幕，以及用于检查模拟边界的背景图像，它将是Tvashtar羽流的图像。稍后，你将在程序的main()函数中分配screen和background。请注意，虽然在本书中出于简洁性我使用了单行文档字符串，但你应在类的文档字符串中包含这些类型的参数。有关类文档字符串的更多指南，请参见：[https://www.python.org/dev/peps/pep-0257/](https://www.python.org/dev/peps/pep-0257/)。
- en: Inside the __init__() method, immediately invoke the initialization method for
    the built-in Sprite class using super. This will initialize the sprite and establish
    the rect and image attributes it needs. With super, you don’t need to refer to
    the base class (Sprite) explicitly. For more on super, visit the docs at *[https://docs.python.org/3/library/functions.html#super](https://docs.python.org/3/library/functions.html#super)*.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在__init__()方法内部，立即使用super调用内置Sprite类的初始化方法。这将初始化精灵，并建立它所需的rect和image属性。通过super，你不需要显式地引用基类（Sprite）。有关super的更多信息，请访问文档：[https://docs.python.org/3/library/functions.html#super](https://docs.python.org/3/library/functions.html#super)，*请查看*。
- en: Next, let the particle (self) know that it will be using the screen and background
    variables by assigning them to attributes.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让粒子（self）知道它将使用screen和background变量，通过将它们分配给属性来实现。
- en: The images and drawings are placed on a rectangular surface by pygame. In fact,
    the Surface object is the heart and soul of pygame; even the screen attribute
    represents an instance of Surface. Assign the particle image to a Surface object
    and make it a square with 4-pixel-length sides ➏.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图片和图形通过pygame放置在一个矩形表面上。实际上，Surface对象是pygame的核心；甚至屏幕属性也表示Surface的一个实例。将粒子图像分配给一个Surface对象，并使其成为一个边长为4像素的正方形➏。
- en: Next, you need to get a rect object for your image surface. This is basically
    a rectangle *associated* with the Surface object, which pygame needs to determine
    the dimensions and position of your Surface object.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要为图像表面获取一个rect对象。这基本上是一个*与*Surface对象相关的矩形，pygame需要它来确定Surface对象的尺寸和位置。
- en: Choose a particle (gas) type by randomly choosing from the keys in the gases_colors
    dictionary ➐. Note that you turn it into a list to do this. Since it’s possible
    to assign an instance attribute named gases_colors from within the __init__()
    method, include the class name—rather than self—to ensure the *class* attribute
    is being referenced.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从gases_colors字典中的键中随机选择来选择粒子（气体）类型➐。注意，你需要将其转换为列表以进行此操作。由于有可能在__init__()方法中分配一个名为gases_colors的实例属性，确保使用类名而非self，以确保引用的是*类*属性。
- en: Once you have a type, you can use it as the key in the dictionaries you built
    earlier to access things like colors and scalars. Start by getting the correct
    color for the chosen particle, then get its vel_scalar value and use that to determine
    the particle’s velocity ➑.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你得到一个类型，你就可以使用它作为你早些时候构建的字典中的键来访问颜色和标量等信息。首先获取所选粒子的正确颜色，然后获取其vel_scalar值，并利用该值来确定粒子的速度➑。
- en: The particle object will be instantiated in the mouth of the volcano, so get
    its initial x- and y-location by unpacking the VENT_LOCATION_XY tuple ➒. Finish
    by calling the vector() method, which will calculate the particle’s motion vector
    ➓.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子对象将被实例化在火山口，因此通过解包VENT_LOCATION_XY元组来获取其初始x和y位置➒。最后，调用vector()方法，这将计算粒子的运动向量➓。
- en: '***Ejecting a Particle***'
  id: totrans-140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***发射粒子***'
- en: '[Listing 13-3](ch13.xhtml#ch13list3) defines the vector() method, which determines
    a particle’s launch orientation and calculates its initial delta-x and delta-y
    vector components.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 13-3](ch13.xhtml#ch13list3) 定义了 vector() 方法，该方法决定了粒子的发射方向，并计算其初始的 delta-x
    和 delta-y 向量分量。'
- en: '*tvashtar.py,* part 3'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*tvashtar.py，* 第 3 部分'
- en: '➊ def vector(self):'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ def vector(self):'
- en: '"""Calculate particle vector at launch."""'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '"""计算粒子发射时的向量。"""'
- en: ➋ orient = random.uniform(60, 120)  # 90 is vertical
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '➋ orient = random.uniform(60, 120)  # 90 是垂直方向'
- en: ➌ radians = math.radians(orient)
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ radians = math.radians(orient)
- en: ➍ self.dx = self.vel * math.cos(radians)
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ self.dx = self.vel * math.cos(radians)
- en: self.dy = -self.vel * math.sin(radians)
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: self.dy = -self.vel * math.sin(radians)
- en: '*Listing 13-3: Defines the* vector() *method of the* Particle *class*'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 13-3：定义了* vector() *方法，属于* Particle *类*'
- en: The vector() method ➊ calculates the motion vector for a particle. Start by
    choosing a launch direction for the particle and assigning it to an orient variable
    ➋. Because explosive volcanic eruptions blast material in multiple directions
    rather than straight up, choose the direction at random, using a range that is
    30 degrees to either side of 90 degrees, where 90 represents a vertical launch.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: vector() 方法 ➊ 用来计算粒子的运动向量。首先为粒子选择一个发射方向并将其赋值给 orient 变量 ➋。由于火山爆发会将物质向多个方向喷发，而不是仅仅向上喷发，因此选择一个随机方向，范围设定为
    90 度左右各 30 度，其中 90 度表示垂直发射。
- en: The range for the orient variable was chosen through trial and error. This parameter,
    along with the VELOCITY_SO2 and GRAVITY constants, represents the “knobs” you
    can turn to calibrate the behavior of the SO[2] particle to the plume image. After
    you’ve adjusted the constants so that the particle’s maximum height corresponds
    to the apex of the plume, you can adjust the range of angles so that the SO[2]
    particles reach—but don’t exceed—the lateral limits of the plume (see [Figure
    13-4](ch13.xhtml#ch13fig4)).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: orient 变量的范围是通过反复试验确定的。这个参数与 VELOCITY_SO2 和 GRAVITY 常量一起，代表了你可以调整的“旋钮”，用来校准
    SO[2] 粒子与羽流图像的行为。当你调整常量，使得粒子的最大高度与羽流的顶点相对应时，你可以调整角度范围，使得 SO[2] 粒子能够达到（但不超过）羽流的横向边界（参见
    [图 13-4](ch13.xhtml#ch13fig4)）。
- en: '![image](../images/f0275-01.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0275-01.jpg)'
- en: '*Figure 13-4: Calibrating the* orient *variable to the Tvashtar plume*'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-4：将* orient *变量与 Tvashtar 羽流进行校准*'
- en: The math module uses *radians* rather than degrees, so convert orient to radians
    ➌. A radian is a standard unit of angular measurement equal to the angle made
    when the radius is wrapped around a circle (see the left-hand side of [Figure
    13-5](ch13.xhtml#ch13fig5)). One radian is slightly less than 57.3 degrees. The
    right-hand side of [Figure 13-5](ch13.xhtml#ch13fig5) is a comparison of radians
    and degrees for some common angles. To convert degrees to radians, you can either
    multiply the degrees by π and divide by 180—like a chump—or just use the math
    module!
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: math 模块使用的是 *弧度*，而不是度数，因此需要将 orient 转换为弧度 ➌。弧度是一个标准的角度测量单位，等于半径绕圆周的角度（见 [图 13-5](ch13.xhtml#ch13fig5)
    左侧）。1 弧度略小于 57.3 度。图 13-5 右侧是一些常见角度的弧度和度数的比较。要将度数转换为弧度，你可以将度数乘以 π 然后除以 180 ——就像个傻瓜一样
    ——或者直接使用 math 模块！
- en: '![image](../images/f0275-02.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0275-02.jpg)'
- en: '*Figure 13-5: Definition of a radian (left) and common angles in radians and
    degrees (right)*'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-5：弧度的定义（左）以及常见角度的弧度和度数（右）*'
- en: Objects move in pygame by increments of x and y. The direction and speed of
    a particle are used to get its *delta-x (dx)* and *delta-y (dy)* vector components.
    These represent the difference between a particle’s initial position and its position
    after completion of a single game loop.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在 pygame 中，物体是通过 x 和 y 的增量来移动的。粒子的方向和速度用来获取其 *delta-x (dx)* 和 *delta-y (dy)*
    向量分量。这些代表了粒子初始位置和经过一轮游戏循环后的最终位置之间的差异。
- en: You calculate vector components using trigonometry. Useful trigonometric equations
    are provided in [Figure 13-6](ch13.xhtml#ch13fig6).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用三角函数来计算向量分量。有关有用的三角函数公式，可以参见 [图 13-6](ch13.xhtml#ch13fig6)。
- en: '![image](../images/f0276-01.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0276-01.jpg)'
- en: '*Figure 13-6: Common trigonometric equations used in gaming*'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-6：游戏中常用的三角函数公式*'
- en: For the angle θ, you use the orient variable. The self.vel attribute equates
    to *r*. Knowing these two components, you can use a trigonometric equation to
    derive self.dx and self.dy ➍. To derive self.dx, multiply self.vel by the cosine
    of orient, and to derive self.dy, multiply self.vel by the sine of orient. Note
    that you must make self.dy negative, as the particles are ejected upward and y-values
    in pygame increase *downward*.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '***Updating the Particle and Handling Boundary Conditions***'
  id: totrans-162
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 13-4](ch13.xhtml#ch13list4) completes the Particle class by defining
    a method to update particles as they move across the screen. This includes applying
    the force of gravity, drawing a line to trace the particle’s path, and “killing”
    the particle when it moves offscreen or below the surface of Io.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '*tvashtar.py,* part 4'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '➊ def update(self):'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '"""Apply gravity, draw path, and handle boundary conditions."""'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: ➋ self.dy += Particle.GRAVITY
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: ➌ pg.draw.line(self.background, self.color,(self.x, self.y),
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: (self.x + self.dx, self.y + self.dy))
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: ➍ self.x += self.dx
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: self.y += self.dy
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '➎ if self.x < 0 or self.x > self.screen.get_width():'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: ➏ self.kill()
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '➐ if self.y < 0 or self.y > Particle.IO_SURFACE_Y:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: self.kill()
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 13-4: Defines the* update() *method and completes the* Particle *class*'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Define the update() method, which takes self as an argument ➊. Apply the force
    of gravity by adding the GRAVITY class attribute to self.dy during each game loop
    ➋. Gravity is a force vector that works only in the vertical direction, so only
    self.dy is affected.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: To draw a path behind the particle, use pygame’s draw.line() method, which takes
    the background image of Io, the color of the particle, and the coordinates for
    the previous and current locations of the particle as arguments ➌. To get the
    current location, you add the self.dx and self.dy attributes to self.x and self.y.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Next, update the particle’s self.x and self.y attributes by adding self.dx and
    self.dy, just as you did in the draw.line() method ➍.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Now, check to see if the particle has passed the left or right boundaries of
    the screen ➎. Use a self.x equal to zero for the left side and get the width of
    the screen attribute for the right side. If the particle has passed off either
    side of the screen, use the built-in kill() method to remove it from all the groups
    that contain it ➏. As you will see later, pygame uses containers—called *groups*—to
    manage sprites, and removing a sprite from a group takes it out of play.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Repeat this process for the y-direction ➐, but for a maximum value, use the
    IO_SURFACE_Y constant of the Particle class, which will stop the particle near
    the surface of Io, where an SO[2] particle would stop (see [Figures 13-2](ch13.xhtml#ch13fig2)
    and [13-4](ch13.xhtml#ch13fig4)).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '***Defining the main() Function***'
  id: totrans-182
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 13-5](ch13.xhtml#ch13list5) defines the first part of the main() function
    that sets up the game screen, the window caption, the legend, the sprite group,
    and the game clock.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '*tvashtar.py,* part 5'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'def main():'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '"""Set up and run game screen and loop."""'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: ➊ screen = pg.display.set_mode((639, 360))
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: ➋ pg.display.set_caption('Io Volcano Simulator')
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: ➌ background = pg.image.load('tvashtar_plume.gif')
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '# Set up color-coded legend'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: ➍ legend_font = pg.font.SysFont('None', 24)
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: ➎ water_label = legend_font.render('--- H2O', True, WHITE, BLACK)
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: h2s_label = legend_font.render('--- H2S', True, DK_GRAY, BLACK)
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: co2_label = legend_font.render('--- CO2', True, GRAY, BLACK)
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: so2_label = legend_font.render('--- SO2/S2', True, LT_GRAY, BLACK)
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: ➏ particles = pg.sprite.Group()
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: ➐ clock = pg.time.Clock()
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 13-5: Defines the first part of the* main() *function*'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to assign the screen variable using pygame’s display.set_mode()
    method ➊. The arguments are pixel dimensions; in this case, you use values slightly
    smaller than those for the NASA image to ensure a good fit. Note that the dimensions
    must be provided as a tuple, so you need to include two sets of parentheses.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Next, name your game window using pygame’s display.set_caption() method ➋, then
    assign the background variable to the NASA photo of the Tvashtar plume ➌. Use
    pygame’s image.load() method to create a new Surface object from the image. The
    pygame package supports several image formats, including PNG, JPG, and GIF. The
    returned Surface will inherit color and transparency information from the image
    file. Since you’re importing a grayscale image here, your color choices will be
    limited.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Now, add some code to build the legend that will be displayed in the upper left
    of the screen.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Name a legend_font variable and use pygame’s font.SysFont() method to choose
    None at size 24 ➍. You will use this when you render the text. The pygame package’s
    font module lets you render a new set of fonts, called TrueType fonts, onto a
    new Surface object. If you don’t want to specify a font, pygame comes with a built-in
    default font, which you can access by passing None as the font name.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Post the particle names in order of weight, with the lightest on the top. To
    make a label, call render() on the legend_font object you made earlier to generate
    a new surface object ➎. Pass it some text, then True (to turn on anti-aliasing
    so the text looks smoother), and then the color of the particle being described.
    The last argument, BLACK, is optional and sets the background color of the label
    to black so the text will be legible above all the particle paths drawn on the
    screen. Repeat this process for the three remaining particles and add S2 to the
    so2_label, as both gases share the same atomic weight and will behave the same
    in the simulation.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Now, start a sprite group named particles ➏. Since games typically have multiple
    sprites moving around the screen, pygame uses a container—the sprite group—to
    manage them. In fact, you *must* put sprites in a group or else they won’t do
    anything.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Finish this section by creating a Clock object to track and control the frame
    rate of the simulation ➐. A pygame “clock” controls how fast the game runs, based
    on the number of *frames per second (fps)* being displayed. You’ll set this value
    in the next section.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '***Completing the main() Function***'
  id: totrans-206
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 13-6](ch13.xhtml#ch13list6) completes main() by setting the speed
    the simulation will run—in frames per second—and starting the while loop that
    actually runs the simulation. It also handles *events*, which occur when a user
    exerts control on the program using a mouse, joystick, or keyboard. Since this
    is a simulation and not a true game, user control is limited to closing the window.
    The listing ends in the global scope with the standard code for running the program
    as a module or in stand-alone mode.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '*tvashtar.py,* part 6'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '➊ while True:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: ➋ clock.tick(25)
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: ➌ particles.add(Particle(screen, background))
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '➍ for event in pg.event.get():'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'if event.type == pg.QUIT:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: pg.quit()
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: sys.exit()
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: ➎ screen.blit(background, (0, 0))
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: screen.blit(water_label, (40, 20))
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: screen.blit(h2s_label, (40, 40))
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: screen.blit(co2_label, (40, 60))
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: screen.blit(so2_label, (40, 80))
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: ➏ particles.update()
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: particles.draw(screen)
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: ➐ pg.display.flip()
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '➑ if __name__ == "__main__":'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: main()
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 13-6: Starts the game clock and loop and handles events in the* main()
    *function*'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Start a while loop to run the simulation ➊. Then use the clock.tick() method
    to set the speed limit for the simulation ➋. Pass it 25, which sets the maximum
    frame rate at 25 frames per second. Feel free to increase this value if you want
    a more energetic volcano.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: It’s now time for the star of the show to make its appearance. Instantiate a
    particle using the Particle class, passing it the screen and background as arguments,
    and add the new particle to the particles sprite group ➌. With each frame, a new
    particle will be created at random and launched from the volcanic vent, producing
    a pleasing spray of particles (see [Figure 13-7](ch13.xhtml#ch13fig7)).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0279-01.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-7: Startup of the simulation, with random particles being generated
    at the rate of 25 frames per second*'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Start a for loop to handle events ➍. All the events that happened during the
    current frame are recorded by pygame and kept in an *event buffer*. Its event.get()
    method creates a list of all these events so that you can evaluate them in turn.
    If a QUIT event occurs (when a user closes the game window), the pygame quit()
    and system exit() methods are called to end the simulation.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: To render the game objects and update the visual display, pygame uses a process
    called *blitting*. *Blit* stands for *block transfer*, which is just copying pixels
    from one rectangular Surface object onto another. By blitting the background onto
    the screen, you cover the screen with the Io image. With blitting, you can take
    the same image and draw it multiple times at different places on the screen. It
    can be a slow process, so game developers use clever techniques to address this
    deficiency, such as blitting only around areas that are currently being updated,
    rather than blitting the whole screen in every game loop.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: To blit the background onto the screen, call the blit() method on the screen
    and pass it the required arguments for source and destination ➎. In the first
    example, the background variable is the source, and the destination is the coordinates
    for where you want the *upper left-hand corner* of the background. Since the background
    will cover the whole screen, use the origin point for the screen, which is (0,
    0). Repeat this for the legend labels, placing them in the upper-left corner of
    the screen.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Next, call the update() method on the particles group ➏. This method doesn’t
    update the screen but has the sprites run their own self.update() methods. After
    this, you use the draw() method to blit the sprites onto the screen based on each
    sprite’s rect attributes. This method needs a drawing surface, so pass it the
    screen.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: The draw() method took care of blitting sprites, so all you need to do now is
    use the flip() method to update the actual game graphics ➐. *Flipping* is a type
    of double buffering where you blit everything from the screen object to the actual
    display. Flipping gets around the inherently slow process of displaying graphics,
    which can cause the screen to flicker, by doing the work on a behind-the-scenes
    rectangle and then using a version of the blit() method to copy to the final display
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: The listing ends outside the main() function with the code that lets the program
    run as a module or in stand-alone mode ➑.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '**Running the Simulation**'
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Figure 13-8](ch13.xhtml#ch13fig8) shows the result of running the simulator
    for about a minute. The water vapor plume extends beyond the top of the window.
    The next highest plume is formed by hydrogen sulfide, followed by carbon dioxide,
    and then sulfur dioxide/sulfur (S[2]) gas, which by design perfectly matches the
    Tvashtar plume.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0281-01.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-8: Results of running* tvashtar.py *for one minute*'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the simulator with *only* SO[2], go to the __init__ method of the Particle
    class and change the lines where you select the gas and color instance attributes:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: self.gas = 'SO2'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: self.color = random.choice(list(Particle.gases_colors.values()))
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: By choosing a color at random, you maintain a sense of movement in the plume
    after all of the possible self.orient angles have been exhausted. And if you want
    to speed up or slow down the eruption, go to the main() function and experiment
    with the clock.tick() method’s frames-per-second parameter.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: In real life, the composition of plume material was inferred with *spectroscopy*,
    a measurement technique that analyzes how light interacts with matter. This includes
    both visible and nonvisible wavelengths that are absorbed, emitted, or scattered.
    The “spectra of the ejecta,” together with the colors painted on the surface,
    provided the key evidence for sulfur-rich plumes.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use the pygame package to simulate gravity
    and build an animation of an extraterrestrial volcano. In the next chapter, you’ll
    use pygame to build a true arcade game with player interactions and win-lose conditions.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '**Further Reading**'
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Game Programming: The L-Line, The Express Line to Learning* (Wiley, 2007)
    by Andy Harris is a tremendously useful and thorough 570-page introduction to
    pygame.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '*More Python for the Absolute Beginner* (Cengage Learning Course Technology,
    2012) by Jonathon Harbour builds on the prequel, *Python for the Absolute Beginner*,
    using a (py)game-focused approach.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '*Invent Your Own Computer Games with Python, 4th Edition* (No Starch Press,
    2016) by Al Sweigart is a good introduction to both Python and game design for
    beginners.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: An online “newbie guide” for pygame is available at *[https://www.pygame.org/docs/tut/newbieguide.html](https://www.pygame.org/docs/tut/newbieguide.html)*,
    and a “cheat sheet” can be found at *[http://www.cogsci.rpi.edu/~destem/gamedev/pygame.pdf](http://www.cogsci.rpi.edu/~destem/gamedev/pygame.pdf)*.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '*Three-Dimensional Simulation of Gas and Dust in Io’s Pele Plume*, by William
    J. McDoniel and others, documents the simulation of Io’s Pele Plume using direct
    Monte Carlo simulation and supercomputers at the Texas Advanced Computing Center
    at the University of Texas. The article is available at *[http://cfpl.ae.utexas.edu/wp-content/uploads/2016/01/McDoniel_PeleDust.pdf](http://cfpl.ae.utexas.edu/wp-content/uploads/2016/01/McDoniel_PeleDust.pdf)*.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '**Practice Project: Going the Distance**'
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’re one of King Henry’s archers at the battle of Agincourt. The French are
    charging, and you want to strike them as far away as possible. At what angle do
    you hold your longbow?
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve ever had a physics class, you probably know the answer is 45 degrees.
    But can you trust that pencil-necked physicist? Better run a quick computer simulation
    to check it out. Copy and edit the *tvashtar.py* code to randomly fire particles
    at 25, 35, 45, 55, and 65 degrees. Set self.color to WHITE for 45 degrees and
    GRAY for all other angles (see [Figure 13-9](ch13.xhtml#ch13fig9)).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0282-01.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-9: Io volcano simulator modified for ejection angles of 25, 35,
    45, 55, and 65 degrees*'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: You can find a solution, *practice_45.py*, in the appendix or for download at
    *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*.
    Keep it in the same folder as the *tvashtar_plume.gif* file.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '**Challenge Projects**'
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Continue your experiments with these challenge projects. No solutions are provided.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '***Shock Canopy***'
  id: totrans-262
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The visibility of Io’s giant plumes is believed to be enhanced by gas condensing
    into dust in the *shock canopy*, the point where the gas particles reach their
    apex and begin falling back to the surface. Use the self.dy attribute to edit
    the path colors in a copy of the *tvashtar.py* program. Paths in the apex of the
    plume should be brighter than those below (see [Figure 13-10](ch13.xhtml#ch13fig10)).
    As with all Challenge Projects, no solution is provided.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0283-01.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-10: Highlighting the shock canopy using lighter path colors*'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '***The Fountainhead***'
  id: totrans-266
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Copy and edit *tvashtar.py* so that only SO[2] is simulated and particles are
    represented by small white circles with no trailing paths (see [Figure 13-11](ch13.xhtml#ch13fig11)).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0283-02.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-11: Screenshot of SO[2] simulation with circles representing individual
    particles*'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '***With a Bullet***'
  id: totrans-270
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you fire a gun straight up on a planet with no atmosphere, will the bullet
    hit the ground with the same velocity as when it left the muzzle? Many people
    struggle with this question, but you can answer it with Python. Copy and edit
    the *tvashtar.py* code so that it ejects a single SO[2] particle with an orientation
    of 90 degrees. Print the particle’s self.y attribute and the absolute value of
    self.dy at the launch point coordinate (y = 300). Compare the starting and ending
    velocity values at this point to see whether they are the same or similar.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '*Episode 50 of the TV show* MythBusters *addressed the myth that bullets fired
    into the air maintain their lethal capability when they eventually fall back down.
    They found that bullets fired perfectly vertical on Earth would tumble and slow
    on their way back down due to wind resistance. If fired slightly off-vertical,
    the bullets would maintain their spin and ballistic trajectory and return to Earth
    at lethal speed. It was the only myth that ever received all three ratings (Busted,
    Plausible, and Confirmed)!*'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
