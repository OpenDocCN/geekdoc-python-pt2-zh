- en: '**13'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**13**'
- en: SIMULATING AN ALIEN VOLCANO**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**模拟外星火山**'
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: Quick! Name the most volcanically active body in the solar system! If you thought
    Earth, then you’d be mistaken—it’s Io (“EYE-oh”), one of Jupiter’s four Galilean
    moons.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 快！说出太阳系中最具火山活动的天体！如果你认为是地球，那你就错了——它是木星的四颗伽利略卫星之一——木卫一（Io，“EYE-oh”）。
- en: The first evidence of volcanism on Io came in 1979, when *Voyager 1* made its
    famous fly-by of the Jovian system. But the spectacular photographs it recorded
    were no real surprise. Astrophysicist Stan Peale and two coauthors had already
    published this result based on models of Io’s interior.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 对木卫一火山活动的首次证据出现在1979年，当时*旅行者1号*飞越木星系统并拍摄了著名的照片。但这些壮观的照片并不令人感到意外。天体物理学家Stan Peale和两位合著者已经根据木卫一内部模型发布了这一结果。
- en: 'Computer modeling is a powerful tool for understanding nature and making predictions.
    Here’s the general workflow:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机建模是理解自然和做出预测的强大工具。以下是一般的工作流程：
- en: Gather data.
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 收集数据。
- en: Analyze, interpret, and integrate the data.
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分析、解释并整合数据。
- en: Generate numerical equations that explain the data.
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成解释数据的数值方程。
- en: Construct a computer model that best “fits” the data.
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建一个最佳“拟合”数据的计算机模型。
- en: Use the model to make predictions and investigate error ranges.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用模型进行预测并研究误差范围。
- en: Applications of computer modeling are far-reaching and include such areas as
    wildlife management, weather forecasts, climate predictions, hydrocarbon production,
    and black-hole simulations.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机建模的应用范围广泛，包括野生动物管理、天气预报、气候预测、碳氢化合物生产以及黑洞模拟等领域。
- en: In this chapter, you’ll use a Python package called `pygame`—normally used to
    create games—to simulate one of Io’s volcanoes. You’ll also experiment with different
    types of *ejecta* (erupted particles) and compare their simulated behaviors to
    a photo of Io’s mammoth Tvashtar plume.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将使用一个名为`pygame`的Python包——通常用于创建游戏——来模拟木卫一的一个火山。你还将尝试不同类型的*喷发物*（喷发粒子），并将它们的模拟行为与木卫一巨大Tvashtar羽流的照片进行比较。
- en: '**Project #21: The Plumes of Io**'
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**项目#21：木卫一的羽流**'
- en: '*Tidal heating* is responsible for the volcanism on Io. As its elliptical orbit
    carries it through the gravity fields of Jupiter and its sister moons, Io experiences
    variations in tidal pull. Its surface flexes up and down by as much as 100 meters,
    resulting in significant friction-related heating and melting in its interior.
    Hot magma migrates to the surface and forms great lava lakes from which degassing
    sulfur (S[2]) and sulfur dioxide (SO[2]) are sprayed skyward with speeds of 1
    km/s. Because of Io’s low gravity and lack of atmosphere, these plumes of gas
    can reach heights of hundreds of kilometers (see the Tvashtar plume in [Figure
    13-1a](ch13.xhtml#ch13fig1)).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*潮汐加热*是木卫一火山活动的罪魁祸首。随着木卫一的椭圆轨道将其带过木星及其姐妹卫星的引力场，木卫一经历了潮汐拉力的变化。它的表面上下弯曲最多可达100米，导致其内部发生显著的摩擦加热和熔化。炽热的岩浆迁移到表面，形成巨大的熔岩湖，喷射出脱气的硫（S[2]）和二氧化硫（SO[2]），喷射速度达到每秒1公里。由于木卫一的低重力和缺乏大气层，这些气体羽流可以达到数百公里的高度（参见[图13-1a](ch13.xhtml#ch13fig1)中的Tvashtar羽流）。'
- en: '![image](../images/f0266-01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0266-01.jpg)'
- en: '*Figure 13-1: a) Io with the 330 km Tvashtar plume at the top and the shorter
    Prometheus plume at the 9 o’clock position; b) Io with volcanic ring deposits
    (NASA images)*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-1：a) 木卫一，顶部是330公里的Tvashtar羽流，9点钟位置是较短的Prometheus羽流；b) 木卫一的火山环沉积物（NASA图片）*'
- en: The plumes’ pleasing umbrella shape is produced as gas and dust shoot upward,
    then fall back in every direction. The resulting surface deposits form concentric
    rings of red, green, black, and yellow. If [Figure 13-1b](ch13.xhtml#ch13fig1)
    were in color, it would look a bit like a moldy pepperoni pizza.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当气体和尘土向上喷射，然后四面八方下落时，形成了伞形的喷发羽流。这些表面沉积物形成了同心的红色、绿色、黑色和黄色环状结构。如果[图13-1b](ch13.xhtml#ch13fig1)是彩色的，它看起来有点像发霉的意大利辣香肠比萨。
- en: '**A Slice of pygame**'
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**pygame的一片天地**'
- en: The `pygame` package is a cross-platform set of Python modules that are typically
    used to program 2D arcade-style video games. It supports graphics, animations,
    sound effects, music, and multiple input devices, such as the keyboard and mouse.
    Learning `pygame` is more than just a fun way to learn programming. Arcade-style
    games have seen a resurgence in popularity thanks to the proliferation of smartphones
    and tablets, and mobile gaming now earns almost as much as console and PC gaming
    combined.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`pygame`包是一套跨平台的Python模块，通常用于编程2D街机风格的视频游戏。它支持图形、动画、音效、音乐和多种输入设备，如键盘和鼠标。学习`pygame`不仅仅是学习编程的一种有趣方式。街机风格的游戏因智能手机和平板电脑的普及而重新流行起来，而移动游戏现在的收入几乎与主机和PC游戏的总和相当。'
- en: The `pygame` package uses the *Simple DirectMedia Library (SDL)*, which is an
    *application programming interface (API)*. APIs are reusable code libraries that
    make handling graphics fairly easy, allowing you to focus on game design while
    using a high-level language like Python. The Microsoft *DirectX* API is used for
    creating games and multimedia apps for the Windows platform. For working across
    multiple platforms, two open source libraries are SDL, mainly for 2D work, and
    *OpenGL (Open Graphics Library)* for 3D applications. As mentioned, you’ll be
    working with SDL, which officially supports Windows, macOS, Linux, iOS, and Android.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`pygame`包使用*简单直接媒体库（SDL）*，这是一种*应用程序编程接口（API）*。API是可重用的代码库，能够使图形处理变得相对简单，让你可以专注于游戏设计，同时使用像Python这样的高级语言。微软的*DirectX*
    API用于为Windows平台创建游戏和多媒体应用程序。为了跨平台工作，有两个开源库——SDL，主要用于2D工作，以及*OpenGL（开放图形库）*，用于3D应用程序。如前所述，你将使用SDL，它正式支持Windows、macOS、Linux、iOS和Android。'
- en: The `pygame` package also uses object-oriented programming (OOP). If you are
    unfamiliar with OOP or need a refresher, see “[A Brief Introduction to Object-Oriented
    Programming](ch11.xhtml#lev256)” on [page 223](ch11.xhtml#page_223). Additionally,
    introductory books on Python often include a section on `pygame`, and there are
    whole books written on the package (see “[Further Reading](ch13.xhtml#lev309)”
    on [page 281](ch13.xhtml#page_281) for some examples).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`pygame`包还使用面向对象编程（OOP）。如果你不熟悉OOP或需要复习，可以参考“[面向对象编程简要介绍](ch11.xhtml#lev256)”在[第223页](ch11.xhtml#page_223)的内容。此外，许多Python入门书籍通常会包括关于`pygame`的章节，且有专门的书籍讲解该包（关于一些例子，请参见[第281页](ch13.xhtml#page_281)的“[进一步阅读](ch13.xhtml#lev309)”）。'
- en: Before you can continue, you’ll need to install `pygame` onto your system. Instructions
    for installing a free copy on your preferred platform are available at *[http://pygame.org/wiki/GettingStarted#Pygame%20Installation](http://pygame.org/wiki/GettingStarted#Pygame%20Installation)*.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，你需要将`pygame`安装到你的系统中。有关在你喜欢的平台上安装免费版本的说明，请访问*[http://pygame.org/wiki/GettingStarted#Pygame%20Installation](http://pygame.org/wiki/GettingStarted#Pygame%20Installation)*。
- en: Video tutorials on how to install `pygame` are also available online. To ensure
    a video is appropriate to your situation, be sure to check the date of the video,
    the platform discussed, and the versions of `pygame` and Python in use. You can
    find additional instructions for Mac users with older Python installs at *[http://brysonpayne.com/2015/01/10/setting-up-pygame-on-a-mac/](http://brysonpayne.com/2015/01/10/setting-up-pygame-on-a-mac/)*.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何安装`pygame`的视频教程也可以在网上找到。为了确保视频适合你的情况，务必检查视频的日期、讨论的平台以及所使用的`pygame`和Python的版本。你可以在*[http://brysonpayne.com/2015/01/10/setting-up-pygame-on-a-mac/](http://brysonpayne.com/2015/01/10/setting-up-pygame-on-a-mac/)*找到适用于安装了较旧版本Python的Mac用户的额外说明。
- en: '**THE OBJECTIVE**'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标**'
- en: Use `pygame` to build a 2D, gravity-based simulation of Io’s Tvashtar volcanic
    plume. Calibrate the plume dimensions using a NASA image. Use multiple particle
    types in the plume, trace the particles’ flight paths and allow the eruption to
    run automatically until stopped.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`pygame`构建一个基于重力的2D模拟，展示木卫二（Io）的Tvashtar火山喷发。使用NASA的图像校准喷发物的尺寸。在喷发中使用多种粒子类型，追踪粒子的飞行轨迹，并让喷发自动运行，直到被停止。
- en: '**The Strategy**'
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**策略**'
- en: Building a comprehensive, full-physics simulation of one of Io’s plumes is best
    accomplished with a supercomputer. Since you probably don’t have one of those
    and since your goal is to make a cool `pygame` display, you’re going to cheat
    by reverse-engineering the parameters you need to make SO[2] fit the Tvashtar
    plume. Remember, cheating is the gift humans give ourselves; it’s what separates
    us from the animals—except for the cheetahs!
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个全面的、全物理的 Io 羽流模拟最好是通过超级计算机来完成。由于你可能没有超级计算机，并且目标是制作一个酷炫的 `pygame` 显示，你将通过逆向工程所需的参数来让
    SO[2] 符合 Tvashtar 羽流。记住，作弊是人类赠送给自己的礼物；这就是我们与动物的不同——除了猎豹！
- en: Since the composition of Io’s plumes is already known, you’re going to calibrate
    your gravity field to SO[2] and sulfur (S[2]) gas, which conveniently have the
    same atomic weight. When the flight paths of these particles match the dimensions
    of the Tvashtar plume in the NASA photograph, you will scale the velocity of other
    ejected particles, based on the difference in atomic weight between the new particle
    and SO[2], to see how particle type affects plume dimensions. Lighter particles
    will be ejected higher and vice versa.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Io 羽流的组成已经知道，你将根据 SO[2] 和硫气体（S[2]）的原子质量来调整你的重力场，它们恰好具有相同的原子质量。当这些粒子的飞行路径与
    NASA 照片中的 Tvashtar 羽流的尺寸相匹配时，你将根据新粒子与 SO[2] 之间的原子质量差异，调整其他喷射粒子的速度，以观察粒子类型如何影响羽流的尺寸。较轻的粒子将被喷射得更高，反之亦然。
- en: '***Using a Game Sketch to Plan***'
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用游戏草图进行规划***'
- en: I suggest you begin any `pygame` project with a sketch of how the game should
    look and how the action should progress. Even the simplest arcade games can become
    complicated, and a sketch will help you manage the complexity. Among the many
    things you must consider in a typical game are player actions, scorekeeping, messages
    and instructions, game entities and their interactions (such as collisions, sound
    effects, and music), and game-ending conditions.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你在开始任何 `pygame` 项目时，先画出游戏应该是什么样的，行动将如何展开。即使是最简单的街机游戏也可能变得复杂，草图将帮助你管理这种复杂性。在典型游戏中，你必须考虑的事情有：玩家行为、计分、消息与指令、游戏实体及其交互（例如碰撞、音效和音乐）以及游戏结束条件。
- en: Sketching the game—or in this case, the simulation—is best done on a whiteboard,
    either real or digital. My layout for the Io volcano simulator is shown in [Figure
    13-2](ch13.xhtml#ch13fig2).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制游戏草图——或者在这种情况下，是绘制模拟——最好是在白板上完成，可以是实际白板或数字白板。我为 Io 火山模拟器设计的布局如 [图 13-2](ch13.xhtml#ch13fig2)
    所示。
- en: '![image](../images/f0268-01.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0268-01.jpg)'
- en: '*Figure 13-2: Game sketch of Io volcano simulator*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-2：Io 火山模拟器的游戏草图*'
- en: 'The sketch in [Figure 13-2](ch13.xhtml#ch13fig2) contains guidelines and key
    behaviors for the volcano simulator:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 13-2](ch13.xhtml#ch13fig2)中的草图包含了火山模拟器的指南和关键行为：'
- en: '**No direct player interactions.** You’ll control the simulation by editing
    the Python code, not through the mouse or keyboard.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**没有直接的玩家交互。** 你将通过编辑 Python 代码来控制模拟，而不是通过鼠标或键盘。'
- en: '**The background will be a NASA image of a plume.** To calibrate the simulation
    to SO[2]/S[2] particles, you’ll need a backdrop of the actual Tvashtar plume.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**背景将是 NASA 的羽流图像。** 为了将模拟与 SO[2]/S[2] 粒子进行校准，你需要一个实际的 Tvashtar 羽流背景。'
- en: '**The launch point pivots.** The particles should be ejected from the central
    base of the plume image and should spray out over a range of angles, rather than
    just straight up.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发射点是可旋转的。** 粒子应从羽流图像的中央基座喷出，并以一定角度范围内喷射，而不仅仅是直线上升。'
- en: '**Particles are chosen at random.** The program will choose the type of particle
    at random. Each particle will have a unique color that distinguishes it from others.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**粒子是随机选择的。** 程序会随机选择粒子的类型。每个粒子将有一个独特的颜色，用以与其他粒子区分。'
- en: '**The particle flight path should be visible and persistent.** The flight of
    each particle should be recorded as a line that remains visible throughout the
    simulation, and the line color should match the particle color.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**粒子的飞行路径应可见且持久。** 每个粒子的飞行轨迹应作为一条线被记录下来，并在整个模拟过程中保持可见，且该线的颜色应与粒子的颜色相匹配。'
- en: '**A color-coded legend lists the particle types.** The program should post
    a legend with the particle names in the upper-left corner of the screen. The font
    colors should match the particle colors, and the legend should print on top of
    particle paths so that it’s always visible.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有色标图例列出了粒子类型。** 程序应在屏幕的左上角显示一个粒子名称的图例。图例中的字体颜色应与粒子的颜色匹配，且图例应显示在粒子路径上方，以确保始终可见。'
- en: '**Particle motion should stop at the level at which SO**[2] **particles intersect
    the surface of Io.** The simulation is tuned to the behavior of SO[2], so falling
    particles should stop at the appropriate location for an SO[2] plume.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**粒子运动应在SO**[2] **粒子与木卫一表面相交的高度停止。** 仿真已调校为SO[2]的行为，因此下落的粒子应在SO[2]羽流的适当位置停止。'
- en: '**There are no sound effects.** In space, no one can hear you scream.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**没有音效。** 在太空中，没有人能听到你的尖叫声。'
- en: Once you complete your diagram, you can begin picking parts from it and listing
    them in logical order; this breaks the plan into a series of manageable steps.
    For example, you’ll need to find and prepare an appropriate background image,
    decide which particles you want to simulate and look up their atomic weights,
    locate a launch point, calibrate SO[2] behavior to the plume image, and so on.
    You’re still writing pseudocode, but a game sketch makes it a much more enjoyable
    process!
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成你的图示，你可以开始从中挑选部分，并按逻辑顺序列出它们；这样就把计划分解成一系列可管理的步骤。例如，你需要找到并准备一个合适的背景图像，决定要模拟哪些粒子并查找它们的原子质量，定位发射点，校准SO[2]行为以适应羽流图像，等等。你仍在编写伪代码，但游戏草图使得这个过程变得更加有趣！
- en: '***Planning the Particle Class***'
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***规划粒子类***'
- en: Since this simulation is based on *particles*, it makes sense to have an OOP
    `Particle` class to serve as a blueprint for multiple particle types. The class
    should support the random generation of particle types, and constants and other
    attributes common to all particles can be stored as *class attributes*. These
    are attributes assigned at the same indentation level as methods. The `Particle`
    class should also contain methods that allow instances of the class to be ejected,
    affected by gravity, made visible, and destroyed when they move beyond the boundaries
    of the simulation.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个仿真是基于*粒子*的，因此有一个面向对象的`Particle`类作为多个粒子类型的蓝图是合乎逻辑的。该类应支持随机生成粒子类型，并且所有粒子共有的常量和其他属性可以作为*类属性*存储。这些属性是与方法处于同一级缩进的属性。`Particle`类还应包含方法，使类的实例能够被抛出、受重力影响、可见，并在移动超出仿真边界时销毁。
- en: The attributes and methods used in the class are shown in [Tables 13-1](ch13.xhtml#ch13tab1)
    and [13-2](ch13.xhtml#ch13tab2), respectively. Class attributes—that is, those
    shared by all instances of the class—are shown in italics; otherwise, instance
    attributes are shown.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 类中使用的属性和方法分别显示在[表13-1](ch13.xhtml#ch13tab1)和[13-2](ch13.xhtml#ch13tab2)中。类属性——即所有类实例共享的属性——以斜体显示；其他则为实例属性。
- en: '**Table 13-1:** Attributes of the `Particle` Class (*Italics* = Class Attribute)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**表13-1：** `Particle`类的属性（*斜体* = 类属性）'
- en: '| **Attributes** | **Attribute description** |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| **Attributes** | **属性描述** |'
- en: '| --- | --- |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| *gases_colors* | Dictionary of available particle types and their colors
    |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| *gases_colors* | 可用粒子类型及其颜色的字典 |'
- en: '| *VENT_LOCATION_XY* | x- and y-location of mouth of Tvashtar volcano in image
    |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| *VENT_LOCATION_XY* | Tvashtar火山口的x和y位置（图像中的位置） |'
- en: '| *IO_SURFACE_Y* | Io surface y-value at SO[2] plume margin in image |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| *IO_SURFACE_Y* | 木卫一表面y值，在SO[2]羽流边界的y值 |'
- en: '| *VELOCITY_SO2* | Speed (pixels per frame) of SO[2] particle |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| *VELOCITY_SO2* | SO[2]粒子的速度（每帧像素数） |'
- en: '| *GRAVITY* | Acceleration of gravity in pixels per frame |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| *GRAVITY* | 重力加速度（每帧像素数） |'
- en: '| *vel_scalar* | Dictionary of ratios of SO[2]/particle atomic weights |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| *vel_scalar* | SO[2]/粒子原子量比率的字典 |'
- en: '| screen | The game screen |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| screen | 游戏屏幕 |'
- en: '| background | A NASA image of the Tvashtar plume |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| background | Tvashtar羽流的NASA图像 |'
- en: '| image | A square `pygame` surface representing a particle |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| image | 表示粒子的`pygame`矩形表面 |'
- en: '| rect | A rectangular object used to get surface dimensions |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| rect | 用于获取表面尺寸的矩形对象 |'
- en: '| gas | The type of an individual particle (SO[2], CO[2], etc.) |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| gas | 单个粒子的类型（SO[2]、CO[2]等） |'
- en: '| color | Color of an individual particle type |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| color | 单个粒子类型的颜色 |'
- en: '| vel | Particle’s velocity relative to SO[2] velocity |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| vel | 粒子的速度，相对于SO[2]速度 |'
- en: '| x | Particle’s x-location |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| x | 粒子的x位置 |'
- en: '| y | Particle’s y-location |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| y | 粒子的y位置 |'
- en: '| dx | Particle’s delta-x |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| dx | 粒子的delta-x |'
- en: '| dy | Particle’s delta-y |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| dy | 粒子的delta-y |'
- en: '**Table 13-2:** Methods of the `Particle` Class'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**表13-2：** `Particle`类的方法'
- en: '| **Method** | **Method description** |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| **Method** | **方法描述** |'
- en: '| --- | --- |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `__init__()` | Initializes and sets up parameters for randomly selected particle
    type |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `__init__()` | 初始化并设置随机选择的粒子类型的参数 |'
- en: '| `vector()` | Randomly selects ejection orientation and calculates motion
    vector (dx and dy) |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `vector()` | 随机选择喷射方向并计算运动向量（dx 和 dy） |'
- en: '| `update()` | Adjusts particle trajectory for gravity, draws path behind particle,
    and destroys particles that move beyond the boundaries of the simulation |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `update()` | 调整粒子轨迹以适应重力，绘制粒子后方的轨迹，并销毁超出模拟边界的粒子 |'
- en: I will explain each of these attributes and methods in more detail in the next
    section.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在下一节中更详细地解释这些属性和方法。
- en: '**The Code**'
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**代码**'
- en: The *tvashtar.py* code will generate a `pygame`-based simulation of Io’s Tvashtar
    plume. You will also need the background image, *tvashtar_plume.gif*. Download
    both files from *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*
    and keep them in the same folder.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*tvashtar.py* 代码将生成基于 `pygame` 的 Io 火山羽流模拟。你还需要背景图像 *tvashtar_plume.gif*。从
    *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*
    下载这两个文件，并将它们保存在同一个文件夹中。'
- en: '***Importing Modules, Initiating pygame, and Defining Colors***'
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***导入模块、初始化 pygame 和定义颜色***'
- en: Begin with several set-up steps, such as choosing colors, as shown in [Listing
    13-1](ch13.xhtml#ch13list1).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 从一些设置步骤开始，例如选择颜色，正如在[清单 13-1](ch13.xhtml#ch13list1)中所示。
- en: '*tvashtar.py,* part 1'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*tvashtar.py,* 第1部分'
- en: '[PRE0]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 13-1: Imports modules, initiates* pygame, *and defines a table of
    colors*'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 13-1：导入模块，初始化* pygame， *并定义颜色表*'
- en: 'Start with some familiar `import`s and one for `pygame` ➊. Next, call the `pygame.init()`
    function. This initializes the `pygame` module and starts up all the underlying
    parts that let it use sounds, check keyboard input, run graphics, and so on ➋.
    Note that `pygame` can be initialized from multiple places, such as the first
    line in a `main()` function:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 从一些常见的 `import` 开始，并为 `pygame` ➊ 添加一个。接下来，调用 `pygame.init()` 函数。这将初始化 `pygame`
    模块并启动所有底层部分，让它能够使用声音、检查键盘输入、运行图形等等 ➋。请注意，`pygame` 可以从多个地方进行初始化，比如在 `main()` 函数中的第一行：
- en: '[PRE1]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'or at the end of the program when `main()` is called in stand-alone mode:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 或者在程序结束时，当 `main()` 函数以独立模式调用时：
- en: '[PRE2]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Stop and assign some color variables using the RGB color model ➌. This model
    mixes red, green, and blue, where each color consists of values from 0 to 255\.
    If you do an online search for “RGB color codes,” you can find the numerical codes
    for millions of colors. But since the NASA image you’ll calibrate against is in
    grayscale, stick with black, white, and shades of gray. Defining this table now
    will allow you to simply enter a name when `pygame` needs a color defined later.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 停下来并使用 RGB 颜色模型 ➌ 分配一些颜色变量。该模型混合了红色、绿色和蓝色，其中每种颜色的值范围从 0 到 255。如果你在网上搜索“RGB 颜色代码”，可以找到数百万种颜色的数值代码。但由于你将使用的
    NASA 图像是灰度的，所以只需使用黑色、白色和灰色阴影即可。现在定义这个表格将使你在以后 `pygame` 需要定义颜色时，只需输入一个名字。
- en: '***Defining the Particle Class***'
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***定义粒子类***'
- en: '[Listing 13-2](ch13.xhtml#ch13list2) defines the `Particle` class and its initializer
    method. You’ll use these to instantiate a particle object. The particle’s key
    attributes, such as type, velocity, color, and so on, are established with the
    initializer method.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 13-2](ch13.xhtml#ch13list2) 定义了 `Particle` 类及其初始化方法。你将使用这些来实例化一个粒子对象。粒子的关键属性，如类型、速度、颜色等，都是通过初始化方法来设定的。'
- en: '*tvashtar.py,* part 2'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*tvashtar.py,* 第2部分'
- en: '[PRE3]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 13-2: Defines the* Particle *class and the* Particle *initializer
    method*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 13-2：定义了* Particle *类和* Particle *初始化方法*'
- en: Define a class called `Particle` to represent *any* molecule of gas that might
    form the volcanic plume ➊. The *ancestor* for this class, shown in parentheses,
    will be a `Sprite` class. This means that the `Particle` class is derived from
    a built-in `pygame` type called `Sprite`. Sprites are just 2D bitmaps that represent
    discrete game objects, like missiles or asteroids. You *inherit* from the `Sprite`
    class—that is, add its attributes and methods to your new class—by passing `pg.sprite.Sprite`
    to your `Particle` class, just as you would pass an argument to a function.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个名为 `Particle` 的类，用来表示可能形成火山羽流的 *任何* 气体分子 ➊。这个类的 *祖先*（如括号中所示）将是 `Sprite`
    类。这意味着 `Particle` 类是从一个名为 `Sprite` 的内建 `pygame` 类型派生的。精灵（Sprite）只是代表离散游戏对象（如导弹或小行星）的
    2D 位图。你通过将 `pg.sprite.Sprite` 传递给你的 `Particle` 类，就可以 *继承* `Sprite` 类，即将其属性和方法添加到你的新类中，就像你给函数传递参数一样。
- en: Assign properties common to all particles as class attributes. The first is
    a dictionary that maps particle types to a color, so that you can differentiate
    the particles during the simulation ➋. These colors will be used for the particle,
    its path, and its name in the legend.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有粒子共有的属性作为类属性进行分配。第一个是一个字典，将粒子类型映射到颜色，以便在模拟过程中区分不同的粒子 ➋。这些颜色将用于粒子、粒子的路径以及图例中的名称。
- en: Now, assign four constants, `VENT_LOCATION_XY`, `IO_SURFACE_Y`, `GRAVITY`, and
    `VELOCITY_SO2` ➌. The first constant is the x- and y-coordinates for the mouth
    of the Tvashtar volcano in the image, which will represent the “launch point”
    for all the particles (see [Figure 13-3](ch13.xhtml#ch13fig3)). I initially guessed
    at these values and then fine-tuned them when the simulation was up and running.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，分配四个常量，`VENT_LOCATION_XY`、`IO_SURFACE_Y`、`GRAVITY`和`VELOCITY_SO2` ➌。第一个常量是图像中Tvashtar火山口的x和y坐标，它将代表所有粒子的“发射点”（见[图13-3](ch13.xhtml#ch13fig3)）。我最初猜测了这些值，然后在模拟运行时进行了微调。
- en: '![image](../images/f0273-01.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0273-01.jpg)'
- en: '*Figure 13-3: Background image for the simulation with the particle launch
    point annotated*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-3：带有粒子发射点注释的模拟背景图*'
- en: The second constant is the y-value for the highest point on Io’s surface (in
    the image) that intersects with the outer edge of the SO[2] plume (see [Figure
    13-2](ch13.xhtml#ch13fig2)). You will stop all the falling particles at this y-value,
    so the view will be optimized for SO[2].
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个常量是图像中与SO[2]烟羽外缘相交的Io表面最高点的y值（见[图13-2](ch13.xhtml#ch13fig2)）。你将在这个y值处停止所有下落的粒子，因此视图将优化为SO[2]。
- en: The third constant represents the acceleration of gravity, which on Earth is
    9.86 m/s² and on Io is 1.796 m/s². But you’re dealing with pixels and frames here,
    not real-world units, so you need to experiment to find a value that looks good
    at the scale of your game/simulation. My choice of `0.5` was arbitrary, though
    guided by knowledge of what works well in arcade games.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个常量表示重力加速度，地球上的值为9.86 m/s²，Io上的值为1.796 m/s²。但你在这里处理的是像素和帧，而非现实世界的单位，因此你需要通过实验来找到一个在游戏/模拟的尺度下看起来合适的值。我选择的`0.5`是随意的，但在一定程度上受到街机游戏中有效参数的指导。
- en: The fourth constant is the speed, in pixels per frame, of an SO[2] particle
    when it is ejected. Remember, the plumes are composed primarily of SO[2], so you
    want to use parameters that will allow the SO[2] particles to “fit” the image
    of the Tvashtar plume, then adjust the speed of the remaining particles *relative*
    to SO[2]. Neither the `GRAVITY` nor the `VELOCITY_SO2` value is unique. Had I
    chosen a larger value for `GRAVITY`, I would’ve needed to increase `VELOCITY_SO2`
    so that the SO[2] particles still “fill out” the area of the plume in the NASA
    image.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 第四个常量是SO[2]粒子被喷射时的速度，以像素/帧为单位。记住，烟羽主要由SO[2]组成，因此你希望使用能使SO[2]粒子“适应”Tvashtar烟羽图像的参数，然后调整其他粒子的速度*相对于*SO[2]。`GRAVITY`和`VELOCITY_SO2`的值并不唯一。如果我选择了更大的`GRAVITY`值，我就需要增加`VELOCITY_SO2`，以便SO[2]粒子仍然能“填满”NASA图像中的烟羽区域。
- en: Next, build a dictionary of scalars for particle velocity ➍. For each particle,
    dividing the atomic weight of SO[2] (64) by the atomic weight of the particle
    gives you the scalar. Since SO[2] is the reference particle, its scalar is 1\.
    Later, to get the velocity of non-SO[2] particles, you will multiply the `VELOCITY_SO2`
    constant by the scalar. As you can see, all of the other particles are lighter
    than SO[2] and should produce a larger plume.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为粒子速度➍构建一个标量字典。对于每个粒子，将SO[2]的原子质量（64）除以该粒子的原子质量，即可得到该粒子的标量。由于SO[2]是参考粒子，其标量为1。之后，为了获得非SO[2]粒子的速度，你需要将`VELOCITY_SO2`常量乘以标量。如你所见，其他所有粒子的质量都比SO[2]轻，因此会产生较大的烟羽。
- en: Define a constructor method for the particle object ➎. You’ll need a `self`
    parameter and `screen` to draw on and check the simulation's boundaries, and you’ll
    need a `background`, which will be an image of the Tvashtar plume. You’ll assign
    `screen` and `background` later in the `main()` function, defined near the end
    of the program. Note that while I’m using one-line docstrings in this book for
    brevity, you would want to include these types of parameters in the class docstring.
    For more guidelines on class docstrings, see *[https://www.python.org/dev/peps/pep-0257/](https://www.python.org/dev/peps/pep-0257/)*.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为粒子对象定义一个构造方法 ➎。你需要一个`self`参数以及用于绘制和检查模拟边界的`screen`，还需要一个`background`，它将是Tvashtar羽流的图像。你将在`main()`函数中稍后分配`screen`和`background`，该函数定义在程序的末尾。请注意，虽然在本书中为了简洁我使用了一行文档字符串，但你应该在类文档字符串中包括这些类型的参数。有关类文档字符串的更多指南，请参见
    *[https://www.python.org/dev/peps/pep-0257/](https://www.python.org/dev/peps/pep-0257/)*。
- en: Inside the `__init__()` method, immediately invoke the initialization method
    for the built-in `Sprite` class using `super`. This will initialize the sprite
    and establish the `rect` and `image` attributes it needs. With `super`, you don’t
    need to refer to the base class (`Sprite`) explicitly. For more on `super`, visit
    the docs at *[https://docs.python.org/3/library/functions.html#super](https://docs.python.org/3/library/functions.html#super)*.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在`__init__()`方法中，立即通过`super`调用内置`Sprite`类的初始化方法。这将初始化精灵，并建立它所需的`rect`和`image`属性。使用`super`时，你不需要显式引用基类（`Sprite`）。有关`super`的更多信息，请访问文档
    *[https://docs.python.org/3/library/functions.html#super](https://docs.python.org/3/library/functions.html#super)*。
- en: Next, let the particle (`self`) know that it will be using the `screen` and
    `background` variables by assigning them to attributes.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让粒子（`self`）知道它将使用`screen`和`background`变量，将它们分配给属性。
- en: The images and drawings are placed on a rectangular surface by `pygame`. In
    fact, the `Surface` object is the heart and soul of `pygame`; even the `screen`
    attribute represents an instance of `Surface`. Assign the particle image to a
    `Surface` object and make it a square with 4-pixel-length sides ➏.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图像和图形由`pygame`放置在一个矩形表面上。事实上，`Surface`对象是`pygame`的核心；甚至`screen`属性也是`Surface`的一个实例。将粒子图像分配给`Surface`对象，并使其成为一个边长为4像素的正方形
    ➏。
- en: Next, you need to get a `rect` object for your image surface. This is basically
    a rectangle *associated* with the `Surface` object, which `pygame` needs to determine
    the dimensions and position of your `Surface` object.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要为图像表面获取一个`rect`对象。它基本上是一个与`Surface`对象*关联*的矩形，`pygame`需要它来确定`Surface`对象的尺寸和位置。
- en: Choose a particle (`gas`) type by randomly choosing from the keys in the `gases_colors`
    dictionary ➐. Note that you turn it into a list to do this. Since it’s possible
    to assign an instance attribute named `gases_colors` from within the `__init__()`
    method, include the class name—rather than `self`—to ensure the *class* attribute
    is being referenced.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从`gases_colors`字典中的键中随机选择，选择一个粒子（`gas`）类型 ➐。请注意，你需要将其转换为列表才能进行选择。由于有可能在`__init__()`方法中为实例属性命名为`gases_colors`，请包括类名——而不是`self`——以确保引用的是*类*属性。
- en: Once you have a type, you can use it as the key in the dictionaries you built
    earlier to access things like colors and scalars. Start by getting the correct
    color for the chosen particle, then get its `vel_scalar` value and use that to
    determine the particle’s velocity ➑.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了类型，就可以将其用作之前构建的字典中的键，来访问诸如颜色和标量之类的内容。从为所选粒子获取正确的颜色开始，然后获取其`vel_scalar`值，并利用它来确定粒子的速度
    ➑。
- en: The particle object will be instantiated in the mouth of the volcano, so get
    its initial x- and y-location by unpacking the `VENT_LOCATION_XY` tuple ➒. Finish
    by calling the `vector()` method, which will calculate the particle’s motion vector
    ➓.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子对象将在火山口处实例化，因此通过解包`VENT_LOCATION_XY`元组来获取其初始的x和y位置 ➒。最后调用`vector()`方法，它将计算粒子的运动向量
    ➓。
- en: '***Ejecting a Particle***'
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***喷射粒子***'
- en: '[Listing 13-3](ch13.xhtml#ch13list3) defines the `vector()` method, which determines
    a particle’s launch orientation and calculates its initial delta-x and delta-y
    vector components.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 13-3](ch13.xhtml#ch13list3)定义了`vector()`方法，它决定粒子的发射方向，并计算其初始的delta-x和delta-y向量分量。'
- en: '*tvashtar.py,* part 3'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*tvashtar.py,* 第3部分'
- en: '[PRE4]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 13-3: Defines the* vector() *method of the* Particle *class*'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 13-3：定义了* vector() *方法，属于* Particle *类*'
- en: The `vector()` method ➊ calculates the motion vector for a particle. Start by
    choosing a launch direction for the particle and assigning it to an `orient` variable
    ➋. Because explosive volcanic eruptions blast material in multiple directions
    rather than straight up, choose the direction at random, using a range that is
    30 degrees to either side of 90 degrees, where 90 represents a vertical launch.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`vector()` 方法 ➊ 用于计算粒子的运动矢量。首先选择一个粒子的发射方向，并将其赋值给 `orient` 变量 ➋。由于爆炸性的火山喷发物质是沿多个方向喷射，而不是垂直向上，因此需要随机选择一个方向，使用的范围是从
    90 度左右30度的区间，其中90度代表垂直发射方向。'
- en: The range for the `orient` variable was chosen through trial and error. This
    parameter, along with the `VELOCITY_SO2` and `GRAVITY` constants, represents the
    “knobs” you can turn to calibrate the behavior of the SO[2] particle to the plume
    image. After you’ve adjusted the constants so that the particle’s maximum height
    corresponds to the apex of the plume, you can adjust the range of angles so that
    the SO[2] particles reach—but don’t exceed—the lateral limits of the plume (see
    [Figure 13-4](ch13.xhtml#ch13fig4)).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`orient` 变量的范围是通过反复试验确定的。这个参数，结合 `VELOCITY_SO2` 和 `GRAVITY` 常数，代表了可以调整的“旋钮”，用来校准
    SO[2] 粒子与喷发柱图像的行为。调整这些常数，直到粒子的最大高度与喷发柱的顶点对齐后，你可以进一步调整角度范围，使 SO[2] 粒子达到喷发柱的侧向极限（但不超过该范围）（参见
    [图 13-4](ch13.xhtml#ch13fig4)）。'
- en: '![image](../images/f0275-01.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0275-01.jpg)'
- en: '*Figure 13-4: Calibrating the* orient *variable to the Tvashtar plume*'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-4：将* orient *变量校准到 Tvashtar 喷发柱*'
- en: The `math` module uses *radians* rather than degrees, so convert `orient` to
    radians ➌. A radian is a standard unit of angular measurement equal to the angle
    made when the radius is wrapped around a circle (see the left-hand side of [Figure
    13-5](ch13.xhtml#ch13fig5)). One radian is slightly less than 57.3 degrees. The
    right-hand side of [Figure 13-5](ch13.xhtml#ch13fig5) is a comparison of radians
    and degrees for some common angles. To convert degrees to radians, you can either
    multiply the degrees by π and divide by 180—like a chump—or just use the `math`
    module!
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`math` 模块使用 *弧度* 而非度数，因此需要将 `orient` 转换为弧度 ➌。弧度是标准的角度单位，当半径围绕圆圈一圈时所形成的角度（参见
    [图 13-5](ch13.xhtml#ch13fig5) 左侧）。一个弧度稍小于 57.3 度。右侧的 [图 13-5](ch13.xhtml#ch13fig5)
    是弧度与度数的对比，列出了常见的角度。要将度数转换为弧度，你可以将度数乘以π再除以180——像个傻瓜一样——或者直接使用 `math` 模块！'
- en: '![image](../images/f0275-02.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0275-02.jpg)'
- en: '*Figure 13-5: Definition of a radian (left) and common angles in radians and
    degrees (right)*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-5：弧度的定义（左）及常见角度的弧度与度数（右）*'
- en: Objects move in `pygame` by increments of x and y. The direction and speed of
    a particle are used to get its *delta-x (dx)* and *delta-y (dy)* vector components.
    These represent the difference between a particle’s initial position and its position
    after completion of a single game loop.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `pygame` 中，物体是按 x 和 y 增量移动的。粒子的方向和速度用来得到它的 *delta-x (dx)* 和 *delta-y (dy)*
    矢量分量。这些分量表示粒子初始位置与完成单次游戏循环后位置之间的差异。
- en: You calculate vector components using trigonometry. Useful trigonometric equations
    are provided in [Figure 13-6](ch13.xhtml#ch13fig6).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用三角函数计算矢量分量。有关有用的三角函数公式，请参见 [图 13-6](ch13.xhtml#ch13fig6)。
- en: '![image](../images/f0276-01.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0276-01.jpg)'
- en: '*Figure 13-6: Common trigonometric equations used in gaming*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-6：游戏中常用的三角函数公式*'
- en: For the angle θ, you use the `orient` variable. The `self.vel` attribute equates
    to *r*. Knowing these two components, you can use a trigonometric equation to
    derive `self.dx` and `self.dy` ➍. To derive `self.dx`, multiply `self.vel` by
    the cosine of `orient`, and to derive `self.dy`, multiply `self.vel` by the sine
    of `orient`. Note that you must make `self.dy` negative, as the particles are
    ejected upward and y-values in `pygame` increase *downward*.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对于角度 θ，使用 `orient` 变量。`self.vel` 属性等价于 *r*。知道这两个分量后，可以使用三角函数公式来推导 `self.dx`
    和 `self.dy` ➍。推导 `self.dx` 时，将 `self.vel` 乘以 `orient` 的余弦值，推导 `self.dy` 时，将 `self.vel`
    乘以 `orient` 的正弦值。需要注意的是，`self.dy` 必须为负，因为粒子是向上喷射的，而在 `pygame` 中，y 值是 *向下* 增加的。
- en: '***Updating the Particle and Handling Boundary Conditions***'
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***更新粒子并处理边界条件***'
- en: '[Listing 13-4](ch13.xhtml#ch13list4) completes the `Particle` class by defining
    a method to update particles as they move across the screen. This includes applying
    the force of gravity, drawing a line to trace the particle’s path, and “killing”
    the particle when it moves offscreen or below the surface of Io.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单13-4](ch13.xhtml#ch13list4)通过定义一个更新粒子的方法，完成了`Particle`类，该方法使粒子在屏幕上移动。这包括应用重力、绘制线条追踪粒子的路径，以及当粒子移出屏幕或下沉至Io表面时“杀死”粒子。'
- en: '*tvashtar.py,* part 4'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*tvashtar.py,* 第4部分'
- en: '[PRE5]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 13-4: Defines the* update() *method and completes the* Particle *class*'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单13-4：定义了update()方法并完成了Particle类*'
- en: Define the `update()` method, which takes `self` as an argument ➊. Apply the
    force of gravity by adding the `GRAVITY` class attribute to `self.dy` during each
    game loop ➋. Gravity is a force vector that works only in the vertical direction,
    so only `self.dy` is affected.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 定义`update()`方法，方法接收`self`作为参数➊。在每个游戏循环中，通过将`GRAVITY`类属性添加到`self.dy`来应用重力➋。重力是一个只在垂直方向起作用的力向量，因此只有`self.dy`受到影响。
- en: To draw a path behind the particle, use `pygame`’s `draw.line()` method, which
    takes the background image of Io, the color of the particle, and the coordinates
    for the previous and current locations of the particle as arguments ➌. To get
    the current location, you add the `self.dx` and `self.dy` attributes to `self.x`
    and `self.y`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在粒子后面绘制路径，使用`pygame`的`draw.line()`方法，该方法将Io的背景图像、粒子的颜色以及粒子之前和当前的位置坐标作为参数➌。要获取当前位置，你需要将`self.dx`和`self.dy`加到`self.x`和`self.y`上。
- en: Next, update the particle’s `self.x` and `self.y` attributes by adding `self.dx`
    and `self.dy`, just as you did in the `draw.line()` method ➍.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，像在`draw.line()`方法中那样，通过将`self.dx`和`self.dy`加到`self.x`和`self.y`上，更新粒子的`self.x`和`self.y`属性➍。
- en: Now, check to see if the particle has passed the left or right boundaries of
    the screen ➎. Use a `self.x` equal to zero for the left side and get the width
    of the `screen` attribute for the right side. If the particle has passed off either
    side of the screen, use the built-in `kill()` method to remove it from all the
    groups that contain it ➏. As you will see later, `pygame` uses containers—called
    *groups*—to manage sprites, and removing a sprite from a group takes it out of
    play.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，检查粒子是否已经越过屏幕的左边或右边界➎。对于左侧，使用`self.x`等于零，对于右侧，获取`screen`属性的宽度。如果粒子已经越过屏幕的任一边缘，则使用内置的`kill()`方法将其从包含它的所有组中移除➏。正如你稍后会看到的，`pygame`使用容器——称为*组*——来管理精灵，而将精灵从组中移除会使其不再参与游戏。
- en: Repeat this process for the y-direction ➐, but for a maximum value, use the
    `IO_SURFACE_Y` constant of the `Particle` class, which will stop the particle
    near the surface of Io, where an SO[2] particle would stop (see [Figures 13-2](ch13.xhtml#ch13fig2)
    and [13-4](ch13.xhtml#ch13fig4)).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 对y方向重复此过程➐，但对于最大值，使用`Particle`类的`IO_SURFACE_Y`常量，它将使粒子停在接近Io表面的位置，就像SO[2]粒子停的位置（参见[图13-2](ch13.xhtml#ch13fig2)和[13-4](ch13.xhtml#ch13fig4)）。
- en: '***Defining the main() Function***'
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***定义main()函数***'
- en: '[Listing 13-5](ch13.xhtml#ch13list5) defines the first part of the `main()`
    function that sets up the game screen, the window caption, the legend, the sprite
    group, and the game clock.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单13-5](ch13.xhtml#ch13list5)定义了`main()`函数的第一部分，该部分设置了游戏屏幕、窗口标题、图例、精灵组和游戏时钟。'
- en: '*tvashtar.py,* part 5'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*tvashtar.py,* 第5部分'
- en: '[PRE6]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 13-5: Defines the first part of the* main() *function*'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单13-5：定义了main()函数的第一部分*'
- en: The first step is to assign the `screen` variable using `pygame`’s `display.set_mode()`
    method ➊. The arguments are pixel dimensions; in this case, you use values slightly
    smaller than those for the NASA image to ensure a good fit. Note that the dimensions
    must be provided as a tuple, so you need to include two sets of parentheses.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是使用`pygame`的`display.set_mode()`方法分配`screen`变量➊。参数是像素维度；在这种情况下，你使用稍微比NASA图像尺寸小的值来确保良好的适配。请注意，尺寸必须以元组形式提供，因此需要包含两组括号。
- en: Next, name your game window using `pygame`’s `display.set_caption()` method
    ➋, then assign the `background` variable to the NASA photo of the Tvashtar plume
    ➌. Use `pygame`’s `image.load()` method to create a new `Surface` object from
    the image. The `pygame` package supports several image formats, including PNG,
    JPG, and GIF. The returned `Surface` will inherit color and transparency information
    from the image file. Since you’re importing a grayscale image here, your color
    choices will be limited.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用`pygame`的`display.set_caption()`方法➋为你的游戏窗口命名，然后将`background`变量分配为Tvashtar喷流的NASA照片➌。使用`pygame`的`image.load()`方法从图像创建一个新的`Surface`对象。`pygame`包支持多种图像格式，包括PNG、JPG和GIF。返回的`Surface`将继承图像文件的颜色和透明度信息。由于你在这里导入的是灰度图像，所以你的颜色选择将受到限制。
- en: Now, add some code to build the legend that will be displayed in the upper left
    of the screen.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，添加一些代码以构建将在屏幕左上方显示的图例。
- en: Name a `legend_font` variable and use `pygame`’s `font.SysFont()` method to
    choose `None` at size 24 ➍. You will use this when you render the text. The `pygame`
    package’s `font` module lets you render a new set of fonts, called TrueType fonts,
    onto a new `Surface` object. If you don’t want to specify a font, `pygame` comes
    with a built-in default font, which you can access by passing `None` as the font
    name.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 命名一个`legend_font`变量，并使用`pygame`的`font.SysFont()`方法选择大小为24的`None`字体 ➍。你将在渲染文本时使用这个。`pygame`包的`font`模块让你将新的字体集（称为TrueType字体）渲染到一个新的`Surface`对象上。如果你不想指定字体，`pygame`自带了一个内置的默认字体，你可以通过传递`None`作为字体名称来访问它。
- en: Post the particle names in order of weight, with the lightest on the top. To
    make a label, call `render()` on the `legend_font` object you made earlier to
    generate a new surface object ➎. Pass it some text, then `True` (to turn on anti-aliasing
    so the text looks smoother), and then the color of the particle being described.
    The last argument, `BLACK`, is optional and sets the background color of the label
    to black so the text will be legible above all the particle paths drawn on the
    screen. Repeat this process for the three remaining particles and add `S2` to
    the `so2_label`, as both gases share the same atomic weight and will behave the
    same in the simulation.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 按照重量顺序发布粒子名称，最轻的放在最上面。要创建标签，调用之前创建的`legend_font`对象的`render()`方法来生成一个新的surface对象
    ➎。传递一些文本，然后传递`True`（以开启抗锯齿，使文本看起来更平滑），接着是所描述粒子的颜色。最后一个参数`BLACK`是可选的，它将标签的背景颜色设置为黑色，以便文本在屏幕上绘制的所有粒子路径上方清晰可见。为剩下的三个粒子重复这个过程，并将`S2`添加到`so2_label`中，因为这两种气体具有相同的原子质量，在模拟中将表现相同。
- en: Now, start a sprite group named `particles` ➏. Since games typically have multiple
    sprites moving around the screen, `pygame` uses a container—the sprite group—to
    manage them. In fact, you *must* put sprites in a group or else they won’t do
    anything.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，启动一个名为`particles`的精灵组 ➏。由于游戏通常有多个精灵在屏幕上移动，`pygame`使用一个容器——精灵组——来管理它们。事实上，你*必须*将精灵放入一个组，否则它们不会起作用。
- en: Finish this section by creating a `Clock` object to track and control the frame
    rate of the simulation ➐. A `pygame` “clock” controls how fast the game runs,
    based on the number of *frames per second (fps)* being displayed. You’ll set this
    value in the next section.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这一部分，创建一个`Clock`对象来跟踪和控制模拟的帧率 ➐。`pygame`的“时钟”控制游戏运行的速度，基于每秒显示的*帧数（fps）*。你将在下一部分设置这个值。
- en: '***Completing the main() Function***'
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***完成main()函数***'
- en: '[Listing 13-6](ch13.xhtml#ch13list6) completes `main()` by setting the speed
    the simulation will run—in frames per second—and starting the `while` loop that
    actually runs the simulation. It also handles *events*, which occur when a user
    exerts control on the program using a mouse, joystick, or keyboard. Since this
    is a simulation and not a true game, user control is limited to closing the window.
    The listing ends in the global scope with the standard code for running the program
    as a module or in stand-alone mode.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 13-6](ch13.xhtml#ch13list6)通过设置模拟的运行速度（以每秒帧数为单位）并启动实际运行模拟的`while`循环来完成`main()`函数。它还处理*事件*，当用户通过鼠标、操纵杆或键盘控制程序时，这些事件会发生。由于这是一个模拟程序而非真正的游戏，用户控制仅限于关闭窗口。此列表以全局作用域结束，包含作为模块或独立模式运行程序的标准代码。'
- en: '*tvashtar.py,* part 6'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '*tvashtar.py，* 第6部分'
- en: '[PRE7]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 13-6: Starts the game clock and loop and handles events in the* main()
    *function*'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 13-6：启动游戏时钟和循环，并处理main()函数中的事件*'
- en: Start a `while` loop to run the simulation ➊. Then use the `clock.tick()` method
    to set the speed limit for the simulation ➋. Pass it `25`, which sets the maximum
    frame rate at 25 frames per second. Feel free to increase this value if you want
    a more energetic volcano.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 启动一个`while`循环来运行模拟 ➊。然后使用`clock.tick()`方法设置模拟的速度限制 ➋。传入`25`，这将设置最大帧率为每秒25帧。如果你想要更有活力的火山，可以增加此值。
- en: It’s now time for the star of the show to make its appearance. Instantiate a
    particle using the `Particle` class, passing it the `screen` and `background`
    as arguments, and add the new particle to the `particles` sprite group ➌. With
    each frame, a new particle will be created at random and launched from the volcanic
    vent, producing a pleasing spray of particles (see [Figure 13-7](ch13.xhtml#ch13fig7)).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候让这场演出的主角登场了。使用`Particle`类实例化一个粒子，传入`screen`和`background`作为参数，并将新粒子添加到`particles`精灵组中
    ➌。每一帧，都会随机生成一个新粒子并从火山口发射，产生一阵令人愉悦的粒子喷雾（见[图13-7](ch13.xhtml#ch13fig7)）。
- en: '![image](../images/f0279-01.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0279-01.jpg)'
- en: '*Figure 13-7: Startup of the simulation, with random particles being generated
    at the rate of 25 frames per second*'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-7：模拟启动，随机粒子以每秒25帧的速度生成*'
- en: Start a `for` loop to handle events ➍. All the events that happened during the
    current frame are recorded by `pygame` and kept in an *event buffer*. Its `event.get()`
    method creates a list of all these events so that you can evaluate them in turn.
    If a `QUIT` event occurs (when a user closes the game window), the `pygame` `quit()`
    and system `exit()` methods are called to end the simulation.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 启动一个`for`循环来处理事件 ➍。所有在当前帧中发生的事件都被`pygame`记录并保存在*事件缓冲区*中。它的`event.get()`方法创建了一个包含所有这些事件的列表，便于你逐一评估它们。如果发生`QUIT`事件（即用户关闭了游戏窗口），则调用`pygame`的`quit()`方法和系统的`exit()`方法来结束模拟。
- en: To render the game objects and update the visual display, `pygame` uses a process
    called *blitting*. *Blit* stands for *block transfer*, which is just copying pixels
    from one rectangular `Surface` object onto another. By blitting the background
    onto the screen, you cover the screen with the Io image. With blitting, you can
    take the same image and draw it multiple times at different places on the screen.
    It can be a slow process, so game developers use clever techniques to address
    this deficiency, such as blitting only around areas that are currently being updated,
    rather than blitting the whole screen in every game loop.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为了渲染游戏对象并更新视觉显示，`pygame`使用了一种叫做*blitting*的过程。*Blit*是*块传输*的缩写，指的是将一个矩形`Surface`对象中的像素复制到另一个矩形对象中。通过将背景绘制到屏幕上，你可以用Io图像覆盖整个屏幕。通过blitting，你可以将同一张图像多次绘制到屏幕上的不同位置。这个过程可能较慢，因此游戏开发者使用巧妙的技术来解决这一缺陷，比如只在当前更新的区域周围进行blitting，而不是每次游戏循环都绘制整个屏幕。
- en: To blit the background onto the screen, call the `blit()` method on the screen
    and pass it the required arguments for source and destination ➎. In the first
    example, the `background` variable is the source, and the destination is the coordinates
    for where you want the *upper left-hand corner* of the background. Since the background
    will cover the whole screen, use the origin point for the screen, which is `(0,
    0)`. Repeat this for the legend labels, placing them in the upper-left corner
    of the screen.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要将背景绘制到屏幕上，调用屏幕的`blit()`方法，并传入源和目标的相关参数 ➎。在第一个例子中，`background`变量是源，而目标是背景的*左上角*坐标。由于背景将覆盖整个屏幕，使用屏幕的原点坐标`(0,
    0)`。对图例标签重复此操作，将它们放置在屏幕的左上角。
- en: Next, call the `update()` method on the `particles` group ➏. This method doesn’t
    update the screen but has the sprites run their own `self.update()` methods. After
    this, you use the `draw()` method to blit the sprites onto the screen based on
    each sprite’s `rect` attributes. This method needs a drawing surface, so pass
    it the `screen`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，调用`particles`组的`update()`方法 ➏。此方法不会更新屏幕，而是让精灵运行各自的`self.update()`方法。之后，使用`draw()`方法根据每个精灵的`rect`属性将精灵绘制到屏幕上。该方法需要一个绘图表面，因此传入`screen`。
- en: The `draw()` method took care of blitting sprites, so all you need to do now
    is use the `flip()` method to update the actual game graphics ➐. *Flipping* is
    a type of double buffering where you blit everything from the `screen` object
    to the actual display. Flipping gets around the inherently slow process of displaying
    graphics, which can cause the screen to flicker, by doing the work on a behind-the-scenes
    rectangle and then using a version of the `blit()` method to copy to the final
    display
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`draw()`方法负责绘制精灵，所以现在你只需要使用`flip()`方法更新实际的游戏图形 ➐。*翻转*是一种双缓冲技术，在这种技术中，你将所有内容从`screen`对象复制到实际的显示屏上。翻转通过在后台矩形上完成工作，避免了显示图形这一固有的缓慢过程，从而防止屏幕闪烁，然后使用`blit()`方法的一个版本将图形复制到最终显示。'
- en: The listing ends outside the `main()` function with the code that lets the program
    run as a module or in stand-alone mode ➑.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 列表在`main()`函数外结束，代码允许程序以模块或独立模式运行 ➑。
- en: '**Running the Simulation**'
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**运行模拟**'
- en: '[Figure 13-8](ch13.xhtml#ch13fig8) shows the result of running the simulator
    for about a minute. The water vapor plume extends beyond the top of the window.
    The next highest plume is formed by hydrogen sulfide, followed by carbon dioxide,
    and then sulfur dioxide/sulfur (S[2]) gas, which by design perfectly matches the
    Tvashtar plume.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '[图13-8](ch13.xhtml#ch13fig8)展示了运行模拟器约一分钟的结果。水蒸气羽流延伸至窗口顶部。第二高的羽流由硫化氢形成，接着是二氧化碳，然后是二氧化硫/硫（S[2]）气体，这与设计上完美匹配Tvashtar羽流。'
- en: '![image](../images/f0281-01.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0281-01.jpg)'
- en: '*Figure 13-8: Results of running* tvashtar.py *for one minute*'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-8：运行* tvashtar.py *一分钟的结果*'
- en: 'To run the simulator with *only* SO[2], go to the `__init__` method of the
    `Particle` class and change the lines where you select the `gas` and `color` instance
    attributes:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要仅使用SO[2]运行模拟器，请进入`Particle`类的`__init__`方法，修改选择`gas`和`color`实例属性的代码行：
- en: '[PRE8]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: By choosing a color at random, you maintain a sense of movement in the plume
    after all of the possible `self.orient` angles have been exhausted. And if you
    want to speed up or slow down the eruption, go to the `main()` function and experiment
    with the `clock.tick()` method’s frames-per-second parameter.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 通过随机选择颜色，你可以在所有可能的`self.orient`角度用尽后，保持羽流的运动感。如果你想加速或减慢喷发速度，可以进入`main()`函数，尝试调整`clock.tick()`方法的每秒帧数参数。
- en: In real life, the composition of plume material was inferred with *spectroscopy*,
    a measurement technique that analyzes how light interacts with matter. This includes
    both visible and nonvisible wavelengths that are absorbed, emitted, or scattered.
    The “spectra of the ejecta,” together with the colors painted on the surface,
    provided the key evidence for sulfur-rich plumes.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实生活中，羽流物质的成分通过*光谱学*推测，光谱学是一种分析光如何与物质相互作用的测量技术。它包括可见光和非可见光波长，这些波长会被吸收、发射或散射。通过“喷发物的光谱”以及表面上的颜色，提供了硫丰富羽流的关键证据。
- en: '**Summary**'
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter, you learned how to use the `pygame` package to simulate gravity
    and build an animation of an extraterrestrial volcano. In the next chapter, you’ll
    use `pygame` to build a true arcade game with player interactions and win-lose
    conditions.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何使用`pygame`包来模拟重力并构建外星火山的动画。在下一章中，你将使用`pygame`构建一个真正的街机游戏，涉及玩家互动和胜负条件。
- en: '**Further Reading**'
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**进一步阅读**'
- en: '*Game Programming: The L-Line, The Express Line to Learning* (Wiley, 2007)
    by Andy Harris is a tremendously useful and thorough 570-page introduction to
    `pygame`.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '*游戏编程：L线，学习的快捷通道*（Wiley, 2007）由Andy Harris编写，是一本极其有用且全面的570页`pygame`入门书。'
- en: '*More Python for the Absolute Beginner* (Cengage Learning Course Technology,
    2012) by Jonathon Harbour builds on the prequel, *Python for the Absolute Beginner*,
    using a (py)game-focused approach.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '*更多Python编程从零开始*（Cengage Learning Course Technology, 2012）由Jonathon Harbour编写，是《Python编程从零开始》的续集，采用了一个（py）游戏为主的教学方法。'
- en: '*Invent Your Own Computer Games with Python, 4th Edition* (No Starch Press,
    2016) by Al Sweigart is a good introduction to both Python and game design for
    beginners.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '*用Python发明自己的计算机游戏，第四版*（No Starch Press, 2016）由Al Sweigart编写，是一本适合初学者的Python和游戏设计入门书籍。'
- en: An online “newbie guide” for `pygame` is available at *[https://www.pygame.org/docs/tut/newbieguide.html](https://www.pygame.org/docs/tut/newbieguide.html)*,
    and a “cheat sheet” can be found at *[http://www.cogsci.rpi.edu/~destem/gamedev/pygame.pdf](http://www.cogsci.rpi.edu/~destem/gamedev/pygame.pdf)*.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`pygame` 的在线“新手指南”可以在 *[https://www.pygame.org/docs/tut/newbieguide.html](https://www.pygame.org/docs/tut/newbieguide.html)*
    找到，“备忘单”可以在 *[http://www.cogsci.rpi.edu/~destem/gamedev/pygame.pdf](http://www.cogsci.rpi.edu/~destem/gamedev/pygame.pdf)*
    中找到。'
- en: '*Three-Dimensional Simulation of Gas and Dust in Io’s Pele Plume*, by William
    J. McDoniel and others, documents the simulation of Io’s Pele Plume using direct
    Monte Carlo simulation and supercomputers at the Texas Advanced Computing Center
    at the University of Texas. The article is available at *[http://cfpl.ae.utexas.edu/wp-content/uploads/2016/01/McDoniel_PeleDust.pdf](http://cfpl.ae.utexas.edu/wp-content/uploads/2016/01/McDoniel_PeleDust.pdf)*.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '*《木卫一 Pele 羽状云中的气体和尘土的三维模拟》*，作者 William J. McDoniel 等，记录了使用直接蒙特卡罗模拟和德克萨斯大学德克萨斯先进计算中心的超级计算机模拟木卫一
    Pele 羽状云的过程。该文章可在 *[http://cfpl.ae.utexas.edu/wp-content/uploads/2016/01/McDoniel_PeleDust.pdf](http://cfpl.ae.utexas.edu/wp-content/uploads/2016/01/McDoniel_PeleDust.pdf)*
    获取。'
- en: '**Practice Project: Going the Distance**'
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**实践项目：走得更远**'
- en: You’re one of King Henry’s archers at the battle of Agincourt. The French are
    charging, and you want to strike them as far away as possible. At what angle do
    you hold your longbow?
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你是亨利国王的弓箭手，参加了阿金库尔战役。法国人正在冲锋，你想尽可能远地击中他们。你应该把长弓拿成什么角度？
- en: If you’ve ever had a physics class, you probably know the answer is 45 degrees.
    But can you trust that pencil-necked physicist? Better run a quick computer simulation
    to check it out. Copy and edit the *tvashtar.py* code to randomly fire particles
    at 25, 35, 45, 55, and 65 degrees. Set `self.color` to `WHITE` for 45 degrees
    and `GRAY` for all other angles (see [Figure 13-9](ch13.xhtml#ch13fig9)).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你上过物理课，你大概知道答案是45度。但是你能相信那个脖子细长的物理学家吗？最好快速运行一个计算机模拟来验证一下。复制并编辑 *tvashtar.py*
    代码，随机发射粒子在25、35、45、55和65度。将 `self.color` 设置为 `WHITE` 用于45度，将所有其他角度设置为 `GRAY`（见
    [图13-9](ch13.xhtml#ch13fig9)）。
- en: '![image](../images/f0282-01.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0282-01.jpg)'
- en: '*Figure 13-9: Io volcano simulator modified for ejection angles of 25, 35,
    45, 55, and 65 degrees*'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-9：修改后的木卫一火山模拟器，发射角度为25、35、45、55和65度*'
- en: You can find a solution, *practice_45.py*, in the appendix or for download at
    *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*.
    Keep it in the same folder as the *tvashtar_plume.gif* file.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在附录中找到一个解决方案，*practice_45.py*，或者从 *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*
    下载。将它保存在与 *tvashtar_plume.gif* 文件相同的文件夹中。
- en: '**Challenge Projects**'
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**挑战项目**'
- en: Continue your experiments with these challenge projects. No solutions are provided.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 继续进行这些挑战项目的实验。不提供解决方案。
- en: '***Shock Canopy***'
  id: totrans-186
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***冲击 canopy***'
- en: The visibility of Io’s giant plumes is believed to be enhanced by gas condensing
    into dust in the *shock canopy*, the point where the gas particles reach their
    apex and begin falling back to the surface. Use the `self.dy` attribute to edit
    the path colors in a copy of the *tvashtar.py* program. Paths in the apex of the
    plume should be brighter than those below (see [Figure 13-10](ch13.xhtml#ch13fig10)).
    As with all Challenge Projects, no solution is provided.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 被认为，木卫一（Io）巨大的羽状云的可见性是通过气体凝结成尘土，在 *冲击 canopy* 中增强的，即气体粒子达到最高点并开始落回表面的位置。使用 `self.dy`
    属性编辑路径颜色，在 *tvashtar.py* 程序的副本中，羽状云的顶点路径应比下方的路径更亮（见 [图13-10](ch13.xhtml#ch13fig10)）。像所有挑战项目一样，提供的没有解决方案。
- en: '![image](../images/f0283-01.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0283-01.jpg)'
- en: '*Figure 13-10: Highlighting the shock canopy using lighter path colors*'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-10：使用更亮的路径颜色高亮显示冲击 canopy*'
- en: '***The Fountainhead***'
  id: totrans-190
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***源头***'
- en: Copy and edit *tvashtar.py* so that only SO[2] is simulated and particles are
    represented by small white circles with no trailing paths (see [Figure 13-11](ch13.xhtml#ch13fig11)).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 复制并编辑 *tvashtar.py* 代码，使得只模拟 SO[2]，并用没有拖尾路径的小白色圆圈表示粒子（见 [图13-11](ch13.xhtml#ch13fig11)）。
- en: '![image](../images/f0283-02.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0283-02.jpg)'
- en: '*Figure 13-11: Screenshot of SO[2] simulation with circles representing individual
    particles*'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-11：SO[2] 模拟的屏幕截图，圆圈表示单个粒子*'
- en: '***With a Bullet***'
  id: totrans-194
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***带有子弹***'
- en: If you fire a gun straight up on a planet with no atmosphere, will the bullet
    hit the ground with the same velocity as when it left the muzzle? Many people
    struggle with this question, but you can answer it with Python. Copy and edit
    the *tvashtar.py* code so that it ejects a single SO[2] particle with an orientation
    of 90 degrees. Print the particle’s `self.y` attribute and the absolute value
    of `self.dy` at the launch point coordinate (y = 300). Compare the starting and
    ending velocity values at this point to see whether they are the same or similar.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在没有大气的星球上垂直发射一颗子弹，子弹落地时的速度会与它离开枪口时相同吗？这个问题让许多人感到困惑，但你可以使用Python来解答。复制并编辑*tvashtar.py*代码，使其发射一个90度朝向的SO[2]粒子。打印粒子的`self.y`属性以及发射点坐标（y
    = 300）处`self.dy`的绝对值。比较这个点的起始速度和结束速度，看看它们是否相同或相似。
- en: '**NOTE**'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Episode 50 of the TV show* MythBusters *addressed the myth that bullets fired
    into the air maintain their lethal capability when they eventually fall back down.
    They found that bullets fired perfectly vertical on Earth would tumble and slow
    on their way back down due to wind resistance. If fired slightly off-vertical,
    the bullets would maintain their spin and ballistic trajectory and return to Earth
    at lethal speed. It was the only myth that ever received all three ratings (Busted,
    Plausible, and Confirmed)!*'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*电视节目《破坏神话》第50集*探讨了一个神话，即子弹被射向空中后，当它们最终落回地面时，仍然保持致命的威力。他们发现，垂直发射的子弹在地球上由于风阻会翻滚并减速。如果发射角度稍微偏离垂直，子弹则会保持旋转和弹道轨迹，并以致命的速度返回地球。这是唯一一个获得三项评级（破除、可信、证实）的神话！*'
