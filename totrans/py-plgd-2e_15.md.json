["```py\ndef loadVolume(dirName):\n    \"\"\"read volume from directory as a 3D texture\"\"\"\n    # list images in directory\n  ❶ files = sorted(os.listdir(dirName))\n    print('loading images from: %s' % dirName)\n    imgDataList = []\n    count = 0\n    width, height = 0, 0\n    for file in files:\n      ❷ file_path = os.path.abspath(os.path.join(dirName, file))\n        try:\n            # read image\n          ❸ img = Image.open(file_path)\n            imgData = np.array(img.getdata(), np.uint8)\n            # check if all images are of the same size\n          ❹ if count is 0:\n                width, height = img.size[0], img.size[1]\n                imgDataList.append(imgData)\n            else:\n              ❺ if (width, height) == (img.size[0], img.size[1]):\n                    imgDataList.append(imgData)\n            else:\n                print('mismatch')\n                raise RunTimeError(\"image size mismatch\")\n            count += 1\n            # print img.size\n      ❻ except:\n            # skip\n            print('Invalid image: %s' % file_path)\n    # load image data into single array\n    depth = count\n  ❼ data = np.concatenate(imgDataList)\n    print('volume data dims: %d %d %d' % (width, height, depth))\n\n```", "```py\n    # load data into 3D texture\n  ❶ texture = glGenTextures(1)\n    glPixelStorei(GL_UNPACK_ALIGNMENT, 1)\n    glBindTexture(GL_TEXTURE_3D, texture)\n    glTexParameterf(GL_TEXTURE_3D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE)\n    glTexParameterf(GL_TEXTURE_3D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE)\n    glTexParameterf(GL_TEXTURE_3D, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE)\n    glTexParameterf(GL_TEXTURE_3D, GL_TEXTURE_MAG_FILTER, GL_LINEAR)\n    glTexParameterf(GL_TEXTURE_3D, GL_TEXTURE_MIN_FILTER, GL_LINEAR)\n  ❷ glTexImage3D(GL_TEXTURE_3D, 0, GL_RED,\n                 width, height, depth, 0,\n                 GL_RED, GL_UNSIGNED_BYTE, data)\n    # return texture\n  ❸ return (texture, width, height, depth)\n\n```", "```py\n❶ strVS = \"\"\"\n# version 410 core\nlayout(location = 1) in vec3 cubePos;\nlayout(location = 2) in vec3 cubeCol;\nuniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nout vec4 vColor;\nvoid main()\n{\n    // set back-face color\n    vColor = vec4(cubeCol.rgb, 1.0);\n    // transformed position\n    vec4 newPos = vec4(cubePos.xyz, 1.0);\n    // set position\n    gl_Position = uPMatrix * uMVMatrix * newPos;\n}\n\"\"\"\n❷ strFS = \"\"\"\n# version 410 core\nin vec4 vColor;\nout vec4 fragColor;\nvoid main()\n{\n    fragColor = vColor;\n}\n\"\"\"\n\n```", "```py\nclass RayCube:\n    def __init__(self, width, height):\n    --`snip`--\n        # cube vertices\n      ❶ vertices = numpy.array([\n                0.0, 0.0, 0.0,\n                1.0, 0.0, 0.0,\n                1.0, 1.0, 0.0,\n                0.0, 1.0, 0.0,\n                0.0, 0.0, 1.0,\n                1.0, 0.0, 1.0,\n                1.0, 1.0, 1.0,\n                0.0, 1.0, 1.0\n                ], numpy.float32)\n        # cube colors\n      ❷ colors = numpy.array([\n                0.0, 0.0, 0.0,\n                1.0, 0.0, 0.0,\n                1.0, 1.0, 0.0,\n                0.0, 1.0, 0.0,\n                0.0, 0.0, 1.0,\n                1.0, 0.0, 1.0,\n                1.0, 1.0, 1.0,\n                0.0, 1.0, 1.0\n                ], numpy.float32)\n        # individual triangles\n      ❸ indices = numpy.array([\n                4, 5, 7,\n                7, 5, 6,\n                5, 1, 6,\n                6, 1, 2,\n                1, 0, 2,\n                2, 0, 3,\n                0, 4, 3,\n                3, 4, 7,\n                6, 2, 7,\n                7, 2, 3,\n                4, 0, 5,\n                5, 0, 1\n                ], numpy.int16)\n\n```", "```py\ndef initFBO(self):\n    # create frame buffer object\n    self.fboHandle = glGenFramebuffers(1)\n    # create texture\n    self.texHandle = glGenTextures(1)\n    # create depth buffer\n    self.depthHandle = glGenRenderbuffers(1)\n    # bind\n    glBindFramebuffer(GL_FRAMEBUFFER, self.fboHandle)\n    glActiveTexture(GL_TEXTURE0)\n    glBindTexture(GL_TEXTURE_2D, self.texHandle)\n    # set parameters to draw the image at different sizes\n  ❶ glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR)\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR)\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE)\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE)\n    # set up texture\n    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, self.width, self.height,\n                 0, GL_RGBA, GL_UNSIGNED_BYTE, None)\n    # bind texture to FBO\n  ❷ glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,\n                           GL_TEXTURE_2D, self.texHandle, 0)\n    # bind\n  ❸ glBindRenderbuffer(GL_RENDERBUFFER, self.depthHandle)\n    glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT24,\n                          self.width, self.height)\n    # bind depth buffer to FBO\n    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT,\n                              GL_RENDERBUFFER, self.depthHandle)\n    # check status\n  ❹ status = glCheckFramebufferStatus(GL_FRAMEBUFFER)\n    if status == GL_FRAMEBUFFER_COMPLETE:\n        pass\n        # print \"fbo %d complete\" % self.fboHandle\n    elif status == GL_FRAMEBUFFER_UNSUPPORTED:\n        print \"fbo %d unsupported\" % self.fboHandle\n    else:\n        print \"fbo %d Error\" % self.fboHandle\n\n```", "```py\ndef renderBackFace(self, pMatrix, mvMatrix):\n    \"\"\"renders back-face of ray-cube to a texture and returns it\"\"\"\n    # render to FBO\n  ❶ glBindFramebuffer(GL_FRAMEBUFFER, self.fboHandle)\n    # set active texture\n    glActiveTexture(GL_TEXTURE0)\n    # bind to FBO texture\n    glBindTexture(GL_TEXTURE_2D, self.texHandle)\n    # render cube with face culling enabled\n  ❷ self.renderCube(pMatrix, mvMatrix, self.program, True)\n    # unbind texture\n  ❸ glBindTexture(GL_TEXTURE_2D, 0)\n    glBindFramebuffer(GL_FRAMEBUFFER, 0)\n    glBindRenderbuffer(GL_RENDERBUFFER, 0)\n    # return texture ID\n  ❹ return self.texHandle\n\n```", "```py\ndef renderFrontFace(self, pMatrix, mvMatrix, program):\n    \"\"\"render front-face of ray-cube\"\"\"\n    # no face culling\n    self.renderCube(pMatrix, mvMatrix, program, False)\n\n```", "```py\ndef renderCube(self, pMatrix, mvMatrix, program, cullFace):\n    \"\"\"renderCube uses face culling if flag set\"\"\"\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)\n    # set shader program\n    glUseProgram(program)\n    # set projection matrix\n    glUniformMatrix4fv(glGetUniformLocation(program, b'uPMatrix'),\n                       1, GL_FALSE, pMatrix)\n    # set modelview matrix\n    glUniformMatrix4fv(glGetUniformLocation(program, b'uMVMatrix'),\n                       1, GL_FALSE, mvMatrix)\n    # enable face culling\n    glDisable(GL_CULL_FACE)\n  ❶ if cullFace:\n        glFrontFace(GL_CCW)\n        glCullFace(GL_FRONT)\n        glEnable(GL_CULL_FACE)\n    # bind VAO\n    glBindVertexArray(self.vao)\n    # animated slice\n  ❷ glDrawElements(GL_TRIANGLES, self.nIndices, GL_UNSIGNED_SHORT, None)\n    # unbind VAO\n    glBindVertexArray(0)\n    # reset cull face\n    if cullFace:\n        # disable face culling\n        glDisable(GL_CULL_FACE)\n\n```", "```py\ndef reshape(self, width, height):\n    self.width = width\n    self.height = height\n    self.aspect = width/float(height)\n    # re-create FBO\n    self.clearFBO()\n    self.initFBO()\n\n```", "```py\nclass RayCastRender:\n    def __init__(self, width, height, volume):\n        \"\"\"RayCastRender construction\"\"\"\n        # create RayCube object\n      ❶ self.raycube = raycube.RayCube(width, height)\n        # set dimensions\n        self.width = width\n        self.height = height\n        self.aspect = width/float(height)\n        # create shader\n      ❷ self.program = glutils.loadShaders(strVS, strFS)\n        # texture\n      ❸ self.texVolume, self.Nx, self.Ny, self.Nz = volume\n        # initialize camera\n      ❹ self.camera = Camera()\n\n```", "```py\ndef draw(self):\n    # build projection matrix\n  ❶ pMatrix = glutils.perspective(45.0, self.aspect, 0.1, 100.0)\n    # modelview matrix\n  ❷ mvMatrix = glutils.lookAt(self.camera.eye, self.camera.center,\n                              self.camera.up)\n    # render\n    # generate ray-cube back-face texture\n  ❸ texture = self.raycube.renderBackFace(pMatrix, mvMatrix)\n    # set shader program\n  ❹ glUseProgram(self.program)\n    # set window dimensions\n    glUniform2f(glGetUniformLocation(self.program, b\"uWinDims\"),\n                float(self.width), float(self.height))\n    # bind to texture unit 0, which represents back-faces of cube\n  ❺ glActiveTexture(GL_TEXTURE0)\n    glBindTexture(GL_TEXTURE_2D, texture)\n    glUniform1i(glGetUniformLocation(self.program, b\"texBackFaces\"), 0)\n    # texture unit 1: 3D volume texture\n  ❻ glActiveTexture(GL_TEXTURE1)\n    glBindTexture(GL_TEXTURE_3D, self.texVolume)\n    glUniform1i(glGetUniformLocation(self.program, b\"texVolume\"), 1)\n    # draw front-face of cubes\n  ❼ self.raycube.renderFrontFace(pMatrix, mvMatrix, self.program)\n\n```", "```py\nstrVS = \"\"\"\n# version 410 core\n❶ layout(location = 1) in vec3 cubePos;\nlayout(location = 2) in vec3 cubeCol;\n❷ uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\n❸ out vec4 vColor;\nvoid main()\n{\n    // set position\n  ❹ gl_Position = uPMatrix * uMVMatrix * vec4(cubePos.xyz, 1.0);\n    // set color\n  ❺ vColor = vec4(cubeCol.rgb, 1.0);\n}\n\"\"\"\n\n```", "```py\nstrFS = \"\"\"\n# version 410 core\nin vec4 vColor;\nuniform sampler2D texBackFaces;\nuniform sampler3D texVolume;\nuniform vec2 uWinDims;\nout vec4 fragColor;\nvoid main()\n{\n    // start of ray\n  ❶ vec3 start = vColor.rgb;\n    // calculate texture coordinates at fragment,\n    // which is a fraction of window coordinates\n  ❷ vec2 texc = gl_FragCoord.xy/uWinDims.xy;\n    // get end of ray by looking up back-face color\n  ❸ vec3 end = texture(texBackFaces, texc).rgb;\n    // calculate ray direction\n  ❹ vec3 dir = end – start;\n    // normalized ray direction\n    vec3 norm_dir = normalize(dir);\n    // the length from front to back is calculated and\n    // used to terminate the ray\n    float len = length(dir.xyz);\n    // ray step size\n    float stepSize = 0.01;\n    // X-ray projection\n    vec4 dst = vec4(0.0);\n    // step through the ray\n  ❺ for(float t = 0.0; t < len; t += stepSize) {\n        // set position to endpoint of ray\n      ❻ vec3 samplePos = start + t*norm_dir;\n        // get texture value at position\n      ❼ float val = texture(texVolume, samplePos).r;\n        vec4 src = vec4(val);\n        // set opacity\n      ❽ src.a *= 0.1;\n        src.rgb *= src.a;\n        // blend with previous value\n      ❾ dst = (1.0 - dst.a)*src + dst;\n        // exit loop when alpha exceeds threshold\n      ❿ if(dst.a >= 0.95)\n            break;\n    }\n    // set fragment color\n    fragColor = dst;\n}\n\"\"\"\n\n```", "```py\nclass SliceRender:\n    def __init__(self, width, height, volume):\n    --`snip`--\n        # set up vertex array object (VAO)\n        self.vao = glGenVertexArrays(1)\n        glBindVertexArray(self.vao)\n        # define quad vertices\n      ❶ vertexData = numpy.array([0.0, 1.0, 0.0,\n                                  0.0, 0.0, 0.0,\n                                  1.0, 1.0, 0.0,\n                                  1.0, 0.0, 0.0], numpy.float32)\n        # vertex buffer\n        self.vertexBuffer = glGenBuffers(1)\n        glBindBuffer(GL_ARRAY_BUFFER, self.vertexBuffer)\n        glBufferData(GL_ARRAY_BUFFER, 4*len(vertexData), vertexData,\n                     GL_STATIC_DRAW)\n        # enable arrays\n        glEnableVertexAttribArray(self.vertIndex)\n        # set buffers\n        glBindBuffer(GL_ARRAY_BUFFER, self.vertexBuffer)\n        glVertexAttribPointer(self.vertIndex, 3, GL_FLOAT, GL_FALSE, 0, None)\n        # unbind VAO\n        glBindVertexArray(0)\n\n```", "```py\ndef draw(self):\n    # clear buffers\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)\n    # build projection matrix\n  ❶ pMatrix = glutils.ortho(-0.6, 0.6, -0.6, 0.6, 0.1, 100.0)\n    # modelview matrix\n  ❷ mvMatrix = numpy.array([1.0, 0.0, 0.0, 0.0,\n                            0.0, 1.0, 0.0, 0.0,\n                            0.0, 0.0, 1.0, 0.0,\n                            -0.5, -0.5, -1.0, 1.0], numpy.float32)\n    # use shader\n    glUseProgram(self.program)\n    # set projection matrix\n    glUniformMatrix4fv(self.pMatrixUniform, 1, GL_FALSE, pMatrix)\n    # set modelview matrix\n    glUniformMatrix4fv(self.mvMatrixUniform, 1, GL_FALSE, mvMatrix)\n    # set current slice fraction\n  ❸ glUniform1f(glGetUniformLocation(self.program, b\"uSliceFrac\"),\n                float(self.currSliceIndex)/float(self.currSliceMax))\n    # set current slice mode\n  ❹ glUniform1i(glGetUniformLocation(self.program, b\"uSliceMode\"),\n                self.mode)\n    # enable texture\n    glActiveTexture(GL_TEXTURE0)\n    glBindTexture(GL_TEXTURE_3D, self.texture)\n    glUniform1i(glGetUniformLocation(self.program, b\"tex\"), 0)\n    # bind VAO\n    glBindVertexArray(self.vao)\n    # draw\n    glDrawArrays(GL_TRIANGLE_STRIP, 0, 4)\n    # unbind VAO\n    glBindVertexArray(0)\n\n```", "```py\nstrVS = \"\"\"\n# version 410 core\nin vec3 aVert;\nuniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform float uSliceFrac;\nuniform int uSliceMode;\nout vec3 texcoord;\nvoid main() {\n    // x slice\n    if (uSliceMode == 0) {\n      ❶ texcoord = vec3(uSliceFrac, aVert.x, 1.0-aVert.y);\n    }\n    // y slice\n    else if (uSliceMode == 1) {\n      ❷ texcoord = vec3(aVert.x, uSliceFrac, 1.0-aVert.y);\n    }\n    // z slice\n    else {\n      ❸ texcoord = vec3(aVert.x, 1.0-aVert.y, uSliceFrac);\n    }\n    // calculate transformed vertex\n    gl_Position = uPMatrix * uMVMatrix * vec4(aVert, 1.0);\n}\n\"\"\"\n\n```", "```py\nstrFS = \"\"\"\n# version 410 core\n❶ in vec3 texcoord;\n❷ uniform sampler3D texture;\nout vec4 fragColor;\nvoid main() {\n    // look up color in texture\n  ❸ vec4 col = texture(tex, texcoord);\n  ❹ fragColor = col.rrra;\n}\n\"\"\"\n\n```", "```py\ndef keyPressed(self, key):\n    \"\"\"keypress handler\"\"\"\n  ❶ if key == 'x':\n        self.mode = SliceRender.XSLICE\n        # reset slice index\n        self.currSliceIndex = int(self.Nx/2)\n        self.currSliceMax = self.Nx\n    elif key == 'y':\n        self.mode = SliceRender.YSLICE\n        # reset slice index\n        self.currSliceIndex = int(self.Ny/2)\n        self.currSliceMax = self.Ny\n    elif key == 'z':\n        self.mode = SliceRender.ZSLICE\n        # reset slice index\n        self.currSliceIndex = int(self.Nz/2)\n        self.currSliceMax = self.Nz\n    elif key == 'l':\n      ❷ self.currSliceIndex = (self.currSliceIndex + 1) % self.currSliceMax\n    elif key == 'r':\n        self.currSliceIndex = (self.currSliceIndex - 1) % self.currSliceMax\n\n```", "```py\nclass RenderWin:\n    def __init__(self, imageDir):\n    --`snip`--\n        # load volume data\n      ❶ self.volume = volreader.loadVolume(imageDir)\n        # create renderer\n      ❷ self.renderer = RayCastRender(self.width, self.height, self.volume)\n\n```", "```py\ndef onKeyboard(self, win, key, scancode, action, mods):\n    # print 'keyboard: ', win, key, scancode, action, mods\n    # ESC to quit\n    if key is glfw.GLFW_KEY_ESCAPE:\n        self.renderer.close()\n        self.exitNow = True\n    else:\n      ❶ if action is glfw.GLFW_PRESS or action is glfw.GLFW_REPEAT:\n            if key == glfw.GLFW_KEY_V:\n                # toggle render mode\n              ❷ if isinstance(self.renderer, RayCastRender):\n                    self.renderer = SliceRender(self.width, self.height,\n                                                self.volume)\n                else:\n                    self.renderer = RayCastRender(self.width, self.height,\n                                                  self.volume)\n                # call reshape on renderer\n                self.renderer.reshape(self.width, self.height)\n            else:\n                # send keypress to renderer\n              ❸ keyDict = {glfw.GLFW_KEY_X: 'x', glfw.GLFW_KEY_Y: 'y',\n                           glfw.GLFW_KEY_Z: 'z', glfw.GLFW_KEY_LEFT: 'l',\n                           glfw.GLFW_KEY_RIGHT: 'r'}\n                try:\n                    self.renderer.keyPressed(keyDict[key])\n                except:\n                    pass\n\n```", "```py\n$ `python volrender.py --dir mrbrain-8bit/`\n\n```", "```py\nimport os\nimport numpy as np\nfrom PIL import Image\nimport OpenGL\nfrom OpenGL.GL import *\nfrom scipy import misc\ndef loadVolume(dirName):\n    \"\"\"read volume from directory as a 3D texture\"\"\"\n    # list images in directory\n    files = sorted(os.listdir(dirName))\n    print('loading images from: %s' % dirName)\n    imgDataList = []\n    count = 0\n    width, height = 0, 0\n    for file in files:\n        file_path = os.path.abspath(os.path.join(dirName, file))\n        try:\n            # read image\n            img = Image.open(file_path)\n            imgData = np.array(img.getdata(), np.uint8)\n            # check if all are of the same size\n            if count is 0:\n                width, height = img.size[0], img.size[1]\n                imgDataList.append(imgData)\n            else:\n                if (width, height) == (img.size[0], img.size[1]):\n                    imgDataList.append(imgData)\n                else:\n                    print('mismatch')\n                    raise RunTimeError(\"image size mismatch\")\n            count += 1\n            # print img.size\n        except:\n            # skip\n            print('Invalid image: %s' % file_path)\n    # load image data into single array\n    depth = count\n    data = np.concatenate(imgDataList)\n    print('volume data dims: %d %d %d' % (width, height, depth))\n    # load data into 3D texture\n    texture = glGenTextures(1)\n    glPixelStorei(GL_UNPACK_ALIGNMENT, 1)\n    glBindTexture(GL_TEXTURE_3D, texture)\n    glTexParameterf(GL_TEXTURE_3D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE)\n    glTexParameterf(GL_TEXTURE_3D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE)\n    glTexParameterf(GL_TEXTURE_3D, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE)\n    glTexParameterf(GL_TEXTURE_3D, GL_TEXTURE_MAG_FILTER, GL_LINEAR)\n    glTexParameterf(GL_TEXTURE_3D, GL_TEXTURE_MIN_FILTER, GL_LINEAR)\n    glTexImage3D(GL_TEXTURE_3D, 0, GL_RED,\n                 width, height, depth, 0,\n                 GL_RED, GL_UNSIGNED_BYTE, data)\n    # return texture\n    return (texture, width, height, depth)\n# load texture\ndef loadTexture(filename):\n    img = Image.open(filename)\n    img_data = np.array(list(img.getdata()), 'B')\n    texture = glGenTextures(1)\n    glPixelStorei(GL_UNPACK_ALIGNMENT,1)\n    glBindTexture(GL_TEXTURE_2D, texture)\n    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE)\n    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE)\n    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR)\n    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR)\n    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, img.size[0], img.size[1],\n                 0, GL_RGBA, GL_UNSIGNED_BYTE, img_data)\n    return texture\n\n```", "```py\nimport OpenGL\nfrom OpenGL.GL import *\nfrom OpenGL.GL.shaders import *\nimport numpy as np\nimport math, sys\nimport raycube, glutils, volreader\nstrVS = \"\"\"\n# version 330 core\nlayout(location = 1) in vec3 cubePos;\nlayout(location = 2) in vec3 cubeCol;\nuniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nout vec4 vColor;\nvoid main()\n{\n    // set position\n    gl_Position = uPMatrix * uMVMatrix * vec4(cubePos.xyz, 1.0);\n    // set color\n    vColor = vec4(cubeCol.rgb, 1.0);\n}\n\"\"\"\nstrFS = \"\"\"\n# version 330 core\nin vec4 vColor;\nuniform sampler2D texBackFaces;\nuniform sampler3D texVolume;\nuniform vec2 uWinDims;\nout vec4 fragColor;\nvoid main()\n{\n    // start of ray\n    vec3 start = vColor.rgb;\n    // calculate texture coords at fragment,\n    // which is a fraction of window coords\n    vec2 texc = gl_FragCoord.xy/uWinDims.xy;\n    // get end of ray by looking up back-face color\n    vec3 end = texture(texBackFaces, texc).rgb;\n    // calculate ray direction\n    vec3 dir = end - start;\n    // normalized ray direction\n    vec3 norm_dir = normalize(dir);\n    // the length from front to back is calculated and\n    // used to terminate the ray\n    float len = length(dir.xyz);\n    // ray step size\n    float stepSize = 0.01;\n    // X-ray projection\n    vec4 dst = vec4(0.0);\n    // step through the ray\n    for(float t = 0.0; t < len; t += stepSize) {\n        // set position to endpoint of ray\n        vec3 samplePos = start + t*norm_dir;\n        // get texture value at position\n        float val = texture(texVolume, samplePos).r;\n        vec4 src = vec4(val);\n        // set opacity\n        src.a *= 0.1;\n        src.rgb *= src.a;\n        // blend with previous value\n        dst = (1.0 - dst.a)*src + dst;\n        // exit loop when alpha exceeds threshold\n        if(dst.a >= 0.95)\n           break;\n    }\n    // set fragment color\n    fragColor =  dst;\n}\n\"\"\"\nclass Camera:\n    \"\"\"helper class for viewing\"\"\"\n    def __init__(self):\n        self.r = 1.5\n        self.theta = 0\n        self.center = [0.5, 0.5, 0.5]\n        self.eye = [0.5 + self.r, 0.5, 0.5]\n        self.up = [0.0, 0.0, 1.0]\n    def rotate(self, clockWise):\n        \"\"\"rotate eye by one step\"\"\"\n        if clockWise:\n            self.theta = (self.theta + 5) % 360\n        else:\n            self.theta = (self.theta - 5) % 360\n        # recalculate eye\n        self.eye = [0.5 + self.r*math.cos(math.radians(self.theta)),\n                    0.5 + self.r*math.sin(math.radians(self.theta)),\n                    0.5]\nclass RayCastRender:\n    \"\"\"class that does Ray Casting\"\"\"\n    def __init__(self, width, height, volume):\n        \"\"\"RayCastRender constr\"\"\"\n        # create RayCube object\n        self.raycube = raycube.RayCube(width, height)\n        # set dimensions\n        self.width = width\n        self.height = height\n        self.aspect = width/float(height)\n        # create shader\n        self.program = glutils.loadShaders(strVS, strFS)\n        # texture\n        self.texVolume, self.Nx, self.Ny, self.Nz = volume\n        # initialize camera\n        self.camera = Camera()\n    def draw(self):\n        # build projection matrix\n        pMatrix = glutils.perspective(45.0, self.aspect, 0.1, 100.0)\n        # modelview matrix\n        mvMatrix = glutils.lookAt(self.camera.eye, self.camera.center,\n                                  self.camera.up)\n        # render\n        # generate ray-cube back-face texture\n        texture = self.raycube.renderBackFace(pMatrix, mvMatrix)\n        # set shader program\n        glUseProgram(self.program)\n        # set window dimensions\n        glUniform2f(glGetUniformLocation(self.program, b\"uWinDims\"),\n                    float(self.width), float(self.height))\n        # texture unit 0, which represents back-faces of cube\n        glActiveTexture(GL_TEXTURE0)\n        glBindTexture(GL_TEXTURE_2D, texture)\n        glUniform1i(glGetUniformLocation(self.program, b\"texBackFaces\"), 0)\n        # texture unit 1: 3D volume texture\n        glActiveTexture(GL_TEXTURE1)\n        glBindTexture(GL_TEXTURE_3D, self.texVolume)\n        glUniform1i(glGetUniformLocation(self.program, b\"texVolume\"), 1)\n        # draw front-face of cubes\n        self.raycube.renderFrontFace(pMatrix, mvMatrix, self.program)\n        #self.render(pMatrix, mvMatrix)\n    def keyPressed(self, key):\n        if key == 'l':\n            self.camera.rotate(True)\n        elif key == 'r':\n            self.camera.rotate(False)\n    def reshape(self, width, height):\n        self.width = width\n        self.height = height\n        self.aspect = width/float(height)\n        self.raycube.reshape(width, height)\n    def close(self):\n        self.raycube.close()\n\n```"]