- en: '**B**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Overview of Python Topics**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](images/common-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The aim of this appendix is twofold: to provide a quick refresher on some Python
    topics that weren’t thoroughly introduced in the chapters and to introduce topics
    that will help you write better Python programs.'
  prefs: []
  type: TYPE_NORMAL
- en: '**if __name__ == ''__main__''**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Throughout the book, we’ve used the following block of code, where func() is
    a function we’ve defined in the program:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: '# Do something'
  prefs: []
  type: TYPE_NORMAL
- en: func()
  prefs: []
  type: TYPE_NORMAL
- en: This block of code ensures that the statements within the block are executed
    only when the program is run on its own.
  prefs: []
  type: TYPE_NORMAL
- en: When a program runs, the special variable __name__ is set to __main__ automatically,
    so the if condition evaluates to True and the function func() is called. However,
    __name__ is set differently when you import the program into another program (see
    “[Reusing Code](app02.html#app02lev1sec07)” on [page 235](app02.html#page_235)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a quick demonstration. Consider the following program, which we’ll call
    *factorial.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '# Find the factorial of a number'
  prefs: []
  type: TYPE_NORMAL
- en: 'def fact(n):'
  prefs: []
  type: TYPE_NORMAL
- en: p = 1
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(1, n+1):'
  prefs: []
  type: TYPE_NORMAL
- en: p = p*i
  prefs: []
  type: TYPE_NORMAL
- en: return p
  prefs: []
  type: TYPE_NORMAL
- en: ➊ print(__name__)
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: n = int(input('Enter an integer to find the factorial of: '))
  prefs: []
  type: TYPE_NORMAL
- en: f = fact(n)
  prefs: []
  type: TYPE_NORMAL
- en: print('Factorial of {0}: {1}'.format(n, f))
  prefs: []
  type: TYPE_NORMAL
- en: 'The program defines a function, fact(), that calculates the factorial of the
    integer passed to it. When you run it, it prints __main__, which corresponds to
    the print statement at ➊, because __name__ is automatically set to __main__. Then,
    it asks an integer to be entered, calculates the factorial, and prints it:'
  prefs: []
  type: TYPE_NORMAL
- en: __main__
  prefs: []
  type: TYPE_NORMAL
- en: Enter an integer to find the factorial of: 5
  prefs: []
  type: TYPE_NORMAL
- en: Factorial of 5: 120
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, say you need to calculate the factorial in another program. Instead of
    writing the function again, you decide to reuse this function by importing it:'
  prefs: []
  type: TYPE_NORMAL
- en: from factorial import fact
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: print('Factorial of 5: {0}'.format(fact(5)))
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that both the programs must be in the same directory. When you run this
    program, you’ll get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: factorial
  prefs: []
  type: TYPE_NORMAL
- en: Factorial of 5: 120
  prefs: []
  type: TYPE_NORMAL
- en: When your program is imported by another program, the value of the variable
    __main__ is set to that program’s filename, without the extension. In this case,
    the value of __name__ is factorial instead of __main__. Because the condition
    __name__ == '__main__' now evaluates to False, the program doesn’t ask for the
    user’s input anymore. Remove the condition to see for yourself what happens!
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, it’s good practice to use if __name__ == '__main__' in your programs
    so that the statements you want executed when your program is run as a standalone
    are also *not* executed when your program is imported into another program.
  prefs: []
  type: TYPE_NORMAL
- en: '**List Comprehensions**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s say we have a list of integers and we want to create a new list containing
    the squares of the elements of the original list. Here’s one way that we could
    do this that’s already familiar to you:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> x = [1, 2, 3, 4]'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> x_square = []'
  prefs: []
  type: TYPE_NORMAL
- en: '➊ >>> for n in x:'
  prefs: []
  type: TYPE_NORMAL
- en: ➋         x_square.append(n**2)
  prefs: []
  type: TYPE_NORMAL
- en: '>>> x_square'
  prefs: []
  type: TYPE_NORMAL
- en: '[1, 4, 9, 16]'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we used a code pattern that we’ve used in various programs throughout
    the book. We create an empty list, x_square, and then successively append to it
    as we calculate the square. We can do this in a more efficient way using *list
    comprehensions*:'
  prefs: []
  type: TYPE_NORMAL
- en: ➌ >>> x_square = [n**2 for n in x]
  prefs: []
  type: TYPE_NORMAL
- en: '>>> x_square'
  prefs: []
  type: TYPE_NORMAL
- en: '[1, 4, 9, 16]'
  prefs: []
  type: TYPE_NORMAL
- en: The statement at ➌ is referred to as a *list comprehension* in Python. It consists
    of an expression—here, n**2—followed by a for loop, for n in x. Note that it basically
    allows us to combine the two statements at ➊ and ➋ into one to create a new list
    in one statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'As another example, consider one of the programs we wrote in “[Drawing the
    Trajectory](ch02.html#ch02lev3sec05)” on [page 51](ch02.html#page_51) to draw
    the trajectory of a body in projectile motion. In these programs, we have the
    following block of code to calculate the *x*- and *y*-coordinates of the body
    at each time instant:'
  prefs: []
  type: TYPE_NORMAL
- en: '# Find time intervals'
  prefs: []
  type: TYPE_NORMAL
- en: intervals = frange(0, t_flight, 0.001)
  prefs: []
  type: TYPE_NORMAL
- en: '# List of x and y coordinates'
  prefs: []
  type: TYPE_NORMAL
- en: x = []
  prefs: []
  type: TYPE_NORMAL
- en: y = []
  prefs: []
  type: TYPE_NORMAL
- en: 'for t in intervals:'
  prefs: []
  type: TYPE_NORMAL
- en: x.append(u*math.cos(theta)*t)
  prefs: []
  type: TYPE_NORMAL
- en: y.append(u*math.sin(theta)*t - 0.5*g*t*t)
  prefs: []
  type: TYPE_NORMAL
- en: 'Using list comprehension, you can rewrite the block of code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '# Find time intervals'
  prefs: []
  type: TYPE_NORMAL
- en: intervals = frange(0, t_flight, 0.001)
  prefs: []
  type: TYPE_NORMAL
- en: '# List of x and y coordinates'
  prefs: []
  type: TYPE_NORMAL
- en: x = [u*math.cos(theta)*t for t in intervals]
  prefs: []
  type: TYPE_NORMAL
- en: y = [u*math.sin(theta)*t - 0.5*g*t*t for t in intervals]
  prefs: []
  type: TYPE_NORMAL
- en: The code is more compact now, as you didn’t have to create the empty lists,
    write a for loop, and append to the lists. List comprehension lets you do this
    in a single statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also add conditionals to a list comprehension in order to selectively
    choose which list items are evaluated in the expression. Consider, once again,
    the first example:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> x = [1, 2, 3, 4]'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> x_square = [n**2 for n in x if n%2 == 0]'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> x_square'
  prefs: []
  type: TYPE_NORMAL
- en: '[4, 16]'
  prefs: []
  type: TYPE_NORMAL
- en: In this list comprehension, we use the if condition to explicitly tell Python
    to evaluate the expression n**2 only on the even list items of x.
  prefs: []
  type: TYPE_NORMAL
- en: '**Dictionary Data Structure**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We first used a Python dictionary in [Chapter 4](ch04.html#ch04) while implementing
    the subs() method in SymPy. Let’s explore Python dictionaries in more detail.
    Consider a simple dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> d = {''key1'': 5, ''key2'': 20}'
  prefs: []
  type: TYPE_NORMAL
- en: This code creates a dictionary with two keys—'key1' and 'key2'—with values 5
    and 20, respectively. Only strings, numbers, and tuples can be keys in a Python
    dictionary. These data types are referred to as *immutable* data types—once created,
    they can’t be changed—so a list can’t be a key because we can add and remove elements
    from a list.
  prefs: []
  type: TYPE_NORMAL
- en: 'We already know that to retrieve the value corresponding to ''key1'' in the
    dictionary, we need to specify it as d[''key1'']. This is one of the most common
    use cases of a dictionary. A related use case is checking whether the dictionary
    contains a certain key, ''x''. We can check that as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> d = {''key1'': 5, ''key2'': 20}'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> ''x'' in d'
  prefs: []
  type: TYPE_NORMAL
- en: 'False'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we create a dictionary, we can add a new key-value pair to it, similar
    to how we can append elements to a list. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> d = {''key1'': 5, ''key2'': 20}'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> if ''x'' in d:'
  prefs: []
  type: TYPE_NORMAL
- en: print(d['x'])
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: d['x'] = 1
  prefs: []
  type: TYPE_NORMAL
- en: '>>> d'
  prefs: []
  type: TYPE_NORMAL
- en: '{''key1'': 5, ''x'': 1, ''key2'': 20}'
  prefs: []
  type: TYPE_NORMAL
- en: This code snippet checks whether the key 'x' already exists in the dictionary,
    d. If it does, it prints the value corresponding to it; otherwise, it adds the
    key to the dictionary with 1 as the corresponding value. Similar to Python’s behavior
    with sets, Python can’t guarantee a particular order of the key-value pairs in
    a dictionary. The key-value pairs can be in any order, irrespective of the order
    of insertion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides specifying the key as an index to the dictionary, we can also use the
    get() method to retrieve the value corresponding to the key:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> d.get(''x'')'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: If you specify a nonexistent key to the get() method, None is returned. On the
    other hand, if you do so while using the index style of retrieving, you’ll get
    an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'The get() method also lets you set a default value for nonexistent keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> d.get(''y'', 0)'
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s no key ''y'' in the dictionary d, so 0 is returned. If there is a key,
    however, the value is returned instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> d[''y''] = 1'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> d.get(''y'', 0)'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: 'The keys() and values() methods each return a list-like data structure of all
    the keys and values, respectively, in a dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> d.keys()'
  prefs: []
  type: TYPE_NORMAL
- en: dict_keys(['key1', 'x', 'key2', 'y'])
  prefs: []
  type: TYPE_NORMAL
- en: '>>> d.values()'
  prefs: []
  type: TYPE_NORMAL
- en: dict_values([5, 1, 20, 1])
  prefs: []
  type: TYPE_NORMAL
- en: 'To iterate over the key and value pairs in a dictionary, use the items() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> d.items()'
  prefs: []
  type: TYPE_NORMAL
- en: dict_items([('key1', 5), ('x', 1), ('key2', 20), ('y', 1)])
  prefs: []
  type: TYPE_NORMAL
- en: 'This method returns a *view* of tuples, and each tuple is a key-value pair.
    We can use the following code snippet to print them nicely:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> for k, v in d.items():'
  prefs: []
  type: TYPE_NORMAL
- en: print(k, v)
  prefs: []
  type: TYPE_NORMAL
- en: key1 5
  prefs: []
  type: TYPE_NORMAL
- en: x 1
  prefs: []
  type: TYPE_NORMAL
- en: key2 20
  prefs: []
  type: TYPE_NORMAL
- en: y 1
  prefs: []
  type: TYPE_NORMAL
- en: Views are more memory efficient than lists, and they don’t let you add or remove
    items.
  prefs: []
  type: TYPE_NORMAL
- en: '**Multiple Return Values**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the programs we’ve written so far, most of the functions return a single
    value, but functions sometimes return multiple values. We saw an example of such
    a function in “[Measuring the Dispersion](ch03.html#ch03lev1sec04)” on [page 71](ch03.html#page_71),
    where in the program to find the range, we returned three numbers from the find_range()
    function. Here’s another example of the approach we took there:'
  prefs: []
  type: TYPE_NORMAL
- en: import math
  prefs: []
  type: TYPE_NORMAL
- en: 'def components(u, theta):'
  prefs: []
  type: TYPE_NORMAL
- en: x = u*math.cos(theta)
  prefs: []
  type: TYPE_NORMAL
- en: y = u*math.sin(theta)
  prefs: []
  type: TYPE_NORMAL
- en: return x, y
  prefs: []
  type: TYPE_NORMAL
- en: 'The components() function accepts a velocity, u, and an angle, theta, in radians
    as parameters, and it calculates the x and y components and returns them. To return
    the calculated components, we simply list the corresponding Python labels in the
    return statement separated by a comma. This creates and returns a tuple consisting
    of the items x and y. In the calling code, we receive the multiple values:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: theta = math.radians(45)
  prefs: []
  type: TYPE_NORMAL
- en: x, y = components(theta)
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the components() function returns a tuple, we can retrieve the returned
    values using tuple indices:'
  prefs: []
  type: TYPE_NORMAL
- en: c = components(theta)
  prefs: []
  type: TYPE_NORMAL
- en: x = c[0]
  prefs: []
  type: TYPE_NORMAL
- en: y = c[1]
  prefs: []
  type: TYPE_NORMAL
- en: This has advantages because we don’t have to know all the different values being
    returned. For one, you don’t have to write x,y,z = myfunc1() when the function
    returns three values or a,x,y,z = myfunc1() when the function returns four values,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In either of the preceding cases, the code calling the components() function
    must know which of the return values correspond to which component of the velocity,
    as there’s no way to know that from the values themselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'A user-friendly approach is to return a dictionary object instead, as we saw
    in the case of SymPy’s solve() function when used with the dict=True keyword argument.
    Here’s how we can rewrite the preceding components function to return a dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: import math
  prefs: []
  type: TYPE_NORMAL
- en: 'def components(theta):'
  prefs: []
  type: TYPE_NORMAL
- en: x = math.cos(theta)
  prefs: []
  type: TYPE_NORMAL
- en: y = math.sin(theta)
  prefs: []
  type: TYPE_NORMAL
- en: return {'x': x, 'y': y}
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we return a dictionary with the keys ''x'' and ''y'' referring to the
    x and y components and their corresponding numerical values. With this new function
    definition, we don’t need to worry about the order of the returned values. We
    just use the key ''x'' to retrieve the x component and the key ''y'' to retrieve
    the y component:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: theta = math.radians(45)
  prefs: []
  type: TYPE_NORMAL
- en: c = components(theta)
  prefs: []
  type: TYPE_NORMAL
- en: y = c['y']
  prefs: []
  type: TYPE_NORMAL
- en: x = c['x']
  prefs: []
  type: TYPE_NORMAL
- en: print(x, y)
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach eliminates the need to use indices to refer to a specific returned
    value. The following code rewrites the program to find the range (see “[Measuring
    the Dispersion](ch03.html#ch03lev1sec04)” on [page 71](ch03.html#page_71)) so
    that the results are returned as a dictionary instead of a tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: ''''''''
  prefs: []
  type: TYPE_NORMAL
- en: Find the range using a dictionary to return values
  prefs: []
  type: TYPE_NORMAL
- en: ''''''''
  prefs: []
  type: TYPE_NORMAL
- en: 'def find_range(numbers):'
  prefs: []
  type: TYPE_NORMAL
- en: lowest = min(numbers)
  prefs: []
  type: TYPE_NORMAL
- en: highest = max(numbers)
  prefs: []
  type: TYPE_NORMAL
- en: '# Find the range'
  prefs: []
  type: TYPE_NORMAL
- en: r = highest-lowest
  prefs: []
  type: TYPE_NORMAL
- en: return {'lowest':lowest, 'highest':highest, 'range':r}
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: donations = [100, 60, 70, 900, 100, 200, 500, 500, 503, 600, 1000, 1200]
  prefs: []
  type: TYPE_NORMAL
- en: result = find_range(donations)
  prefs: []
  type: TYPE_NORMAL
- en: ➊     print('Lowest: {0} Highest: {1} Range: {2}'.
  prefs: []
  type: TYPE_NORMAL
- en: format(result['lowest'], result['highest'], result['range']))
  prefs: []
  type: TYPE_NORMAL
- en: The find_range() function now returns a dictionary with the keys lowest, highest,
    and range and with the lowest number, highest number, and the range as their corresponding
    values. At ➊, we simply use the corresponding key to retrieve the corresponding
    value.
  prefs: []
  type: TYPE_NORMAL
- en: If we were just interested in the range of a group of numbers and we didn’t
    care about the lowest and highest numbers, we’d just use result['range'] and not
    worry about what other values were returned.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exception Handling**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In [Chapter 1](ch01.html#ch01), we learned that trying to convert a string
    such as ''1.1'' to an integer using the int() function results in a ValueError
    exception. But with a try...except block, we can print a user-friendly error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> try:'
  prefs: []
  type: TYPE_NORMAL
- en: int('1.1')
  prefs: []
  type: TYPE_NORMAL
- en: 'except ValueError:'
  prefs: []
  type: TYPE_NORMAL
- en: print('Failed to convert 1.1 to an integer')
  prefs: []
  type: TYPE_NORMAL
- en: Failed to convert 1.1 to an integer
  prefs: []
  type: TYPE_NORMAL
- en: 'When any statement in the try block raises an exception, the type of exception
    raised is matched with the one specified by the except statement. If there’s a
    match, the program resumes in the except block. If the exception doesn’t match,
    the program execution halts and displays the exception. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> try:'
  prefs: []
  type: TYPE_NORMAL
- en: print(1/0)
  prefs: []
  type: TYPE_NORMAL
- en: 'except ValueError:'
  prefs: []
  type: TYPE_NORMAL
- en: print('Division unsuccessful')
  prefs: []
  type: TYPE_NORMAL
- en: 'Traceback (most recent call last):'
  prefs: []
  type: TYPE_NORMAL
- en: File "<pyshell#66>", line 2, in <module>
  prefs: []
  type: TYPE_NORMAL
- en: print(1/0)
  prefs: []
  type: TYPE_NORMAL
- en: ZeroDivisionError: division by zero
  prefs: []
  type: TYPE_NORMAL
- en: This code block attempts a division by 0, which results in a ZeroDivisionError
    exception. Although the division is carried out in a try...except block, the exception
    type is incorrectly specified, and the exception isn’t handled correctly. The
    correct way to handle this exception is to specify ZeroDivisionError as the exception
    type.
  prefs: []
  type: TYPE_NORMAL
- en: '***Specifying Multiple Exception Types***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can also specify multiple exception types. Consider the function reciprocal(),
    which returns the reciprocal of the number passed to it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def reciprocal(n):'
  prefs: []
  type: TYPE_NORMAL
- en: 'try:'
  prefs: []
  type: TYPE_NORMAL
- en: print(1/n)
  prefs: []
  type: TYPE_NORMAL
- en: 'except (ZeroDivisionError, TypeError):'
  prefs: []
  type: TYPE_NORMAL
- en: print('You entered an invalid number')
  prefs: []
  type: TYPE_NORMAL
- en: We defined the function reciprocal(), which prints the reciprocal of the user’s
    input. We know that if the function is called with 0, it’ll cause a ZeroDivisionError
    exception. If you pass a string, however, it’ll cause a TypeError exception. The
    function considers both these cases as invalid input and specifies both ZeroDivisionError
    and TypeError in the except statement as a tuple.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try calling the function with a valid input—that is, a nonzero number:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> reciprocal(5)'
  prefs: []
  type: TYPE_NORMAL
- en: '0.2'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we call the function with 0 as the argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> reciprocal(0)'
  prefs: []
  type: TYPE_NORMAL
- en: Enter an integer: 0
  prefs: []
  type: TYPE_NORMAL
- en: You entered an invalid number
  prefs: []
  type: TYPE_NORMAL
- en: The 0 argument raises the ZeroDivisionError exception, which is in the tuple
    of exception types specified to the except statement, so the code prints an error
    message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s enter a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> reciprocal(''1'')'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we entered an invalid number, which raises the TypeError exception.
    This exception is also in the tuple of specified exceptions, so the code prints
    an error message. If you want to give a more specific error message, we can just
    specify multiple except statements as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def reciprocal(n):'
  prefs: []
  type: TYPE_NORMAL
- en: 'try:'
  prefs: []
  type: TYPE_NORMAL
- en: print(1/n)
  prefs: []
  type: TYPE_NORMAL
- en: 'except TypeError:'
  prefs: []
  type: TYPE_NORMAL
- en: print('You must specify a number')
  prefs: []
  type: TYPE_NORMAL
- en: 'except ZeroDivisionError:'
  prefs: []
  type: TYPE_NORMAL
- en: print('Division by 0 is invalid')
  prefs: []
  type: TYPE_NORMAL
- en: '>>> reciprocal(0)'
  prefs: []
  type: TYPE_NORMAL
- en: Division by 0 is invalid
  prefs: []
  type: TYPE_NORMAL
- en: '>>> reciprocal(''1'')'
  prefs: []
  type: TYPE_NORMAL
- en: You must specify a number
  prefs: []
  type: TYPE_NORMAL
- en: In addition to TypeError, ValueError, and ZeroDivisionError, there are a number
    of other built-in exception types. The Python documentation at *[https://docs.python.org/3.4/library/exceptions.html#bltin-exceptions](https://docs.python.org/3.4/library/exceptions.html#bltin-exceptions)*
    lists the builtin exceptions for Python 3.4.
  prefs: []
  type: TYPE_NORMAL
- en: '***The else Block***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The else block is used to specify which statements to execute when there’s
    no exception. Consider an example from the program we wrote to draw the trajectory
    of a projectile (see “[Drawing the Trajectory](ch02.html#ch02lev3sec05)” on [page
    51](ch02.html#page_51)):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: 'try:'
  prefs: []
  type: TYPE_NORMAL
- en: u = float(input('Enter the initial velocity (m/s): '))
  prefs: []
  type: TYPE_NORMAL
- en: theta = float(input('Enter the angle of projection (degrees): '))
  prefs: []
  type: TYPE_NORMAL
- en: 'except ValueError:'
  prefs: []
  type: TYPE_NORMAL
- en: print('You entered an invalid input')
  prefs: []
  type: TYPE_NORMAL
- en: '➊     else:'
  prefs: []
  type: TYPE_NORMAL
- en: draw_trajectory(u, theta)
  prefs: []
  type: TYPE_NORMAL
- en: plt.show()
  prefs: []
  type: TYPE_NORMAL
- en: 'If the input for u or theta couldn’t be converted to a floating point number,
    it doesn’t make sense for the program to call the draw_trajectory() and plt.show()
    functions. Instead, we specify these two statements in the else block at ➊. Using
    try...except...else will let you manage different types of errors during runtime
    and take appropriate action when there is an error or when there is none:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. If there’s an exception and there’s an except statement corresponding to
    the exception type raised, the execution is transferred to the corresponding except
    block.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. If there’s no exception, the execution is transferred to the else block.
  prefs: []
  type: TYPE_NORMAL
- en: '**Reading Files in Python**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Opening a file is the first step to reading data from it. Let’s start with
    a quick example. Consider a file that consists of a collection of numbers with
    one number per line:'
  prefs: []
  type: TYPE_NORMAL
- en: '100'
  prefs: []
  type: TYPE_NORMAL
- en: '60'
  prefs: []
  type: TYPE_NORMAL
- en: '70'
  prefs: []
  type: TYPE_NORMAL
- en: '900'
  prefs: []
  type: TYPE_NORMAL
- en: '100'
  prefs: []
  type: TYPE_NORMAL
- en: '200'
  prefs: []
  type: TYPE_NORMAL
- en: '500'
  prefs: []
  type: TYPE_NORMAL
- en: '500'
  prefs: []
  type: TYPE_NORMAL
- en: '503'
  prefs: []
  type: TYPE_NORMAL
- en: '600'
  prefs: []
  type: TYPE_NORMAL
- en: '1000'
  prefs: []
  type: TYPE_NORMAL
- en: '1200'
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to write a function that reads the file and returns a list of those
    numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def read_data(path):'
  prefs: []
  type: TYPE_NORMAL
- en: numbers = []
  prefs: []
  type: TYPE_NORMAL
- en: ➊     f = open(path)
  prefs: []
  type: TYPE_NORMAL
- en: '➋     for line in f:'
  prefs: []
  type: TYPE_NORMAL
- en: numbers.append(float(line))
  prefs: []
  type: TYPE_NORMAL
- en: f.close()
  prefs: []
  type: TYPE_NORMAL
- en: return numbers
  prefs: []
  type: TYPE_NORMAL
- en: First, we define the function read_data() and create an empty list to store
    all of the numbers. At ➊, we use the open() function to open the file whose location
    has been specified via the argument path. An example of the path would be */home/username/mydata.txt*
    on Linux, *C:\mydata.txt* on Microsoft Windows, or */Users/Username/mydata.txt*
    on OS X. The open() function returns a file object, which we use the label f to
    refer to. We can go over each line of the file using a for loop at ➋. Because
    each line is returned as a string, we convert it into a number and append it to
    the list numbers. The loop stops executing once all the lines have been read,
    and we close the file using the close() method. Finally, we return the numbers
    list.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is similar to how we read the numbers from a file in [Chapter 3](ch03.html#ch03),
    although we didn’t have to close the file explicitly because we used a different
    approach there. Using the approach we took in [Chapter 3](ch03.html#ch03), we
    would rewrite the preceding function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def read_data(path):'
  prefs: []
  type: TYPE_NORMAL
- en: numbers = []
  prefs: []
  type: TYPE_NORMAL
- en: '➊     with open(path) as f:'
  prefs: []
  type: TYPE_NORMAL
- en: 'for line in f:'
  prefs: []
  type: TYPE_NORMAL
- en: numbers.append(float(line))
  prefs: []
  type: TYPE_NORMAL
- en: ➋     return numbers
  prefs: []
  type: TYPE_NORMAL
- en: The key statement here is at ➊. It’s similar to writing f = open(path) but only
    partially. Besides opening the file and assigning the file object returned by
    open() to f, it also sets up a new *context* with all the statements in that block—in
    this case, all the statements before the return statement. When all the statements
    in the body have been executed, the file is automatically closed. That is, when
    the execution reaches the statement at ➋, the file is closed without needing an
    explicit call to the close() method. This method also means that if there are
    any exceptions while working with the file, it’ll still be closed before the program
    exits. This is the preferred approach to working with files.
  prefs: []
  type: TYPE_NORMAL
- en: '***Reading All the Lines at Once***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Instead of reading the lines one by one to build a list, we can use the readlines()
    method to read all the lines into a list at once. This results in a more compact
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def read_data(path):'
  prefs: []
  type: TYPE_NORMAL
- en: 'with open(path) as f:'
  prefs: []
  type: TYPE_NORMAL
- en: ➊         lines = f.readlines()
  prefs: []
  type: TYPE_NORMAL
- en: numbers = [float(n) for n in lines]
  prefs: []
  type: TYPE_NORMAL
- en: return numbers
  prefs: []
  type: TYPE_NORMAL
- en: We read all the lines of the file into a list using the readlines() method at
    ➊. Then, we convert each of the items in the list into a floating point number
    using the float() function and list comprehension. Finally, we return the list
    numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '***Specifying the Filename as Input***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The read_data() function takes the file path as an argument. If your program
    allows you to specify the filename as an input, this function should work for
    any file as long as the file contains data we expect to read. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__==''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: data_file = input('Enter the path of the file: ')
  prefs: []
  type: TYPE_NORMAL
- en: data = read_data(data_file)
  prefs: []
  type: TYPE_NORMAL
- en: print(data)
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you’ve added this code to the end of the read_data() function and run
    it, it’ll ask you to input the path to the file. Then, it’ll print the numbers
    it reads from the file:'
  prefs: []
  type: TYPE_NORMAL
- en: Enter the path of the file /home/amit/work/mydata.txt
  prefs: []
  type: TYPE_NORMAL
- en: '[100.0,60.0,70.0,900.0,100.0,200.0,500.0,500.0,503.0,600.0,1000.0,1200.0]'
  prefs: []
  type: TYPE_NORMAL
- en: '***Handling Errors When Reading Files***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There are a couple of things that can go wrong when reading files: (1) the
    file can’t be read, or (2) the data in the file isn’t in the expected format.
    Here’s an example of what happens when a file can’t be read:'
  prefs: []
  type: TYPE_NORMAL
- en: Enter the path of the file: /home/amit/work/mydata2.txt
  prefs: []
  type: TYPE_NORMAL
- en: 'Traceback (most recent call last):'
  prefs: []
  type: TYPE_NORMAL
- en: File "read_file.py", line 11, in <module>
  prefs: []
  type: TYPE_NORMAL
- en: data = read_data(data_file)
  prefs: []
  type: TYPE_NORMAL
- en: File "read_file.py", line 4, in read_data
  prefs: []
  type: TYPE_NORMAL
- en: 'with open(path) as f:'
  prefs: []
  type: TYPE_NORMAL
- en: FileNotFoundError: [Errno 2] No such file or directory: '/home/amit/work/
  prefs: []
  type: TYPE_NORMAL
- en: mydata2.txt'
  prefs: []
  type: TYPE_NORMAL
- en: 'Because I entered a file path that doesn’t exist, the FileNotFoundError exception
    is raised when we try to open the file. We can make the program display a user-friendly
    error message by modifying our read_data() function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def read_data(path):'
  prefs: []
  type: TYPE_NORMAL
- en: numbers = []
  prefs: []
  type: TYPE_NORMAL
- en: 'try:'
  prefs: []
  type: TYPE_NORMAL
- en: 'with open(path) as f:'
  prefs: []
  type: TYPE_NORMAL
- en: 'for line in f:'
  prefs: []
  type: TYPE_NORMAL
- en: numbers.append(float(line))
  prefs: []
  type: TYPE_NORMAL
- en: 'except FileNotFoundError:'
  prefs: []
  type: TYPE_NORMAL
- en: print('File not found')
  prefs: []
  type: TYPE_NORMAL
- en: return numbers
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, when you specify a nonexistent file path, you’ll get an error message
    instead:'
  prefs: []
  type: TYPE_NORMAL
- en: Enter the path of the file: /home/amit/work/mydata2.txt
  prefs: []
  type: TYPE_NORMAL
- en: File not found
  prefs: []
  type: TYPE_NORMAL
- en: 'The second source of errors can be that the data in the file isn’t what your
    program expects to read. For example, consider a file that has the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '10'
  prefs: []
  type: TYPE_NORMAL
- en: '20'
  prefs: []
  type: TYPE_NORMAL
- en: 3o
  prefs: []
  type: TYPE_NORMAL
- en: 1/5
  prefs: []
  type: TYPE_NORMAL
- en: '5.6'
  prefs: []
  type: TYPE_NORMAL
- en: The third line in this file isn’t convertible to a floating point number because
    it has the letter o in it instead of the number 0, and the fourth line consists
    of 1/5, a fraction in string form, which float() can’t handle.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you supply this data file to the earlier program, it’ll produce the following
    error:'
  prefs: []
  type: TYPE_NORMAL
- en: Enter the path of the file: bad_data.txt
  prefs: []
  type: TYPE_NORMAL
- en: 'Traceback (most recent call last):'
  prefs: []
  type: TYPE_NORMAL
- en: File "read_file.py", line 13, in <module>
  prefs: []
  type: TYPE_NORMAL
- en: data = read_data(data_file)
  prefs: []
  type: TYPE_NORMAL
- en: File "read_file.py", line 6, in read_data
  prefs: []
  type: TYPE_NORMAL
- en: numbers.append(float(line))
  prefs: []
  type: TYPE_NORMAL
- en: ValueError: could not convert string to float: '3o\n'
  prefs: []
  type: TYPE_NORMAL
- en: 'The third line in the file is 3o, not the number 30, so when we attempt to
    convert it into a floating point number, the result is ValueError. There are two
    approaches you can take when such data is present in a file. The first is to report
    the error and exit the program. The modified read_data() function would appear
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def read_data(path):'
  prefs: []
  type: TYPE_NORMAL
- en: numbers = []
  prefs: []
  type: TYPE_NORMAL
- en: 'try:'
  prefs: []
  type: TYPE_NORMAL
- en: 'with open(path) as f:'
  prefs: []
  type: TYPE_NORMAL
- en: 'for line in f:'
  prefs: []
  type: TYPE_NORMAL
- en: '➊               try:'
  prefs: []
  type: TYPE_NORMAL
- en: ➋                   n = float(line)
  prefs: []
  type: TYPE_NORMAL
- en: 'except ValueError:'
  prefs: []
  type: TYPE_NORMAL
- en: print('Bad data: {0}'.format(line))
  prefs: []
  type: TYPE_NORMAL
- en: ➌                   break
  prefs: []
  type: TYPE_NORMAL
- en: ➍               numbers.append(n)
  prefs: []
  type: TYPE_NORMAL
- en: 'except FileNotFoundError:'
  prefs: []
  type: TYPE_NORMAL
- en: print('File not found')
  prefs: []
  type: TYPE_NORMAL
- en: return numbers
  prefs: []
  type: TYPE_NORMAL
- en: We insert another try...except block in the function starting at ➊, and we convert
    the line into a floating point number at ➋. If the program raises the ValueError
    exception, we print an error message with the offending line and exit out of the
    for loop using break at ➌. The program then stops reading the file. The returned
    list, numbers, contains all the data that was successfully read before encountering
    the bad data. If there’s no error, we append the floating point number to the
    numbers list at ➍.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now when you supply the file *bad_data.txt* to the program, it’ll read only
    the first two lines, display the error message, and exit:'
  prefs: []
  type: TYPE_NORMAL
- en: Enter the path of the file: bad_data.txt
  prefs: []
  type: TYPE_NORMAL
- en: Bad data: 3o
  prefs: []
  type: TYPE_NORMAL
- en: '[10.0, 20.0]'
  prefs: []
  type: TYPE_NORMAL
- en: Returning partial data may not be desirable, so we could just replace the break
    statement at ➌ with return and no data would be returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second approach is to ignore the error and continue with the rest of the
    file. Here’s a modified read_data() function that does this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def read_data(path):'
  prefs: []
  type: TYPE_NORMAL
- en: numbers = []
  prefs: []
  type: TYPE_NORMAL
- en: 'try:'
  prefs: []
  type: TYPE_NORMAL
- en: 'with open(path) as f:'
  prefs: []
  type: TYPE_NORMAL
- en: 'for line in f:'
  prefs: []
  type: TYPE_NORMAL
- en: 'try:'
  prefs: []
  type: TYPE_NORMAL
- en: n = float(line)
  prefs: []
  type: TYPE_NORMAL
- en: 'except ValueError:'
  prefs: []
  type: TYPE_NORMAL
- en: print('Bad data: {0}'.format(line))
  prefs: []
  type: TYPE_NORMAL
- en: ➊                     continue
  prefs: []
  type: TYPE_NORMAL
- en: numbers.append(n)
  prefs: []
  type: TYPE_NORMAL
- en: 'except FileNotFoundError:'
  prefs: []
  type: TYPE_NORMAL
- en: print('File not found')
  prefs: []
  type: TYPE_NORMAL
- en: return numbers
  prefs: []
  type: TYPE_NORMAL
- en: 'The only change here is that instead of breaking out of the for loop, we just
    continue with the next iteration using the continue statement at ➊. The output
    from the program is now as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Bad data: 3o
  prefs: []
  type: TYPE_NORMAL
- en: Bad data: 1/5
  prefs: []
  type: TYPE_NORMAL
- en: '[10.0, 20.0, 5.6]'
  prefs: []
  type: TYPE_NORMAL
- en: The specific application where you’re reading the file will determine which
    of the above approaches you want to take to handle bad data.
  prefs: []
  type: TYPE_NORMAL
- en: '**Reusing Code**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Throughout this book, we’ve used classes and functions that were either part
    of the Python standard library or available after installing third-party packages,
    such as matplotlib and SymPy. Now we’ll look at a quick example of how we can
    import our own programs into other programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the function find_corr_x_y() that we wrote in “[Calculating the Correlation
    Between Two Data Sets](ch03.html#ch03lev1sec05)” on [page 75](ch03.html#page_75).
    We’ll create a separate file, *correlation.py*, which has only the function definition:'
  prefs: []
  type: TYPE_NORMAL
- en: ''''''''
  prefs: []
  type: TYPE_NORMAL
- en: Function to calculate the linear correlation coefficient
  prefs: []
  type: TYPE_NORMAL
- en: ''''''''
  prefs: []
  type: TYPE_NORMAL
- en: 'def find_corr_x_y(x,y):'
  prefs: []
  type: TYPE_NORMAL
- en: '# Size of each set'
  prefs: []
  type: TYPE_NORMAL
- en: n = len(x)
  prefs: []
  type: TYPE_NORMAL
- en: '# Find the sum of the products'
  prefs: []
  type: TYPE_NORMAL
- en: prod=[]
  prefs: []
  type: TYPE_NORMAL
- en: 'for xi,yi in zip(x,y):'
  prefs: []
  type: TYPE_NORMAL
- en: prod.append(xi*yi)
  prefs: []
  type: TYPE_NORMAL
- en: sum_prod_x_y = sum(prod)
  prefs: []
  type: TYPE_NORMAL
- en: sum_x = sum(x)
  prefs: []
  type: TYPE_NORMAL
- en: sum_y = sum(y)
  prefs: []
  type: TYPE_NORMAL
- en: squared_sum_x = sum_x**2
  prefs: []
  type: TYPE_NORMAL
- en: squared_sum_y = sum_y**2
  prefs: []
  type: TYPE_NORMAL
- en: x_square=[]
  prefs: []
  type: TYPE_NORMAL
- en: 'for xi in x:'
  prefs: []
  type: TYPE_NORMAL
- en: x_square.append(xi**2)
  prefs: []
  type: TYPE_NORMAL
- en: x_square_sum = sum(x_square)
  prefs: []
  type: TYPE_NORMAL
- en: y_square=[]
  prefs: []
  type: TYPE_NORMAL
- en: 'for yi in y:'
  prefs: []
  type: TYPE_NORMAL
- en: y_square.append(yi**2)
  prefs: []
  type: TYPE_NORMAL
- en: y_square_sum = sum(y_square)
  prefs: []
  type: TYPE_NORMAL
- en: numerator = n*sum_prod_x_y - sum_x*sum_y
  prefs: []
  type: TYPE_NORMAL
- en: denominator_term1 = n*x_square_sum - squared_sum_x
  prefs: []
  type: TYPE_NORMAL
- en: denominator_term2 = n*y_square_sum - squared_sum_y
  prefs: []
  type: TYPE_NORMAL
- en: denominator = (denominator_term1*denominator_term2)**0.5
  prefs: []
  type: TYPE_NORMAL
- en: correlation = numerator/denominator
  prefs: []
  type: TYPE_NORMAL
- en: return correlation
  prefs: []
  type: TYPE_NORMAL
- en: 'Without the *.py* file extension, a Python file is referred to as a module.
    This is usually reserved for files that define classes and functions that’ll be
    used in other programs. The following program imports the find_corr_x_y() function
    from the correlation module we just defined:'
  prefs: []
  type: TYPE_NORMAL
- en: from correlation import find_corr_x_y
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: high_school_math = [83, 85, 84, 96, 94, 86, 87, 97, 97, 85]
  prefs: []
  type: TYPE_NORMAL
- en: college_admission = [85, 87, 86, 97, 96, 88, 89, 98, 98, 87]
  prefs: []
  type: TYPE_NORMAL
- en: corr = find_corr_x_y(high_school_math, college_admission)
  prefs: []
  type: TYPE_NORMAL
- en: print('Correlation coefficient: {0}'.format(corr))
  prefs: []
  type: TYPE_NORMAL
- en: This program finds the correlation between the high school math grades and college
    admission scores of students we considered in [Table 3-3](ch03.html#ch3tab3) on
    [page 80](ch03.html#page_80). We import the find_corr_x_y() function from the
    correlation module, create the lists representing the two sets of grades, and
    call the find_corr_x_y() function with the two lists as arguments. When you run
    the program, it’ll print the correlation coefficient. Note that the two files
    must be in the same directory—this is strictly to keep things simple.
  prefs: []
  type: TYPE_NORMAL
