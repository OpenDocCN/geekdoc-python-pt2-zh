- en: '**B**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**B**'
- en: '**Overview of Python Topics**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python主题概览**'
- en: '![image](images/common-01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/common-01.jpg)'
- en: 'The aim of this appendix is twofold: to provide a quick refresher on some Python
    topics that weren’t thoroughly introduced in the chapters and to introduce topics
    that will help you write better Python programs.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本附录的目的是双重的：一是简要回顾一些在章节中未详细介绍的Python主题，二是介绍一些可以帮助你编写更好Python程序的主题。
- en: '**if __name__ == ''__main__''**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**if __name__ == ''__main__''**'
- en: 'Throughout the book, we’ve used the following block of code, where func() is
    a function we’ve defined in the program:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们使用了以下代码块，其中func()是我们在程序中定义的一个函数：
- en: 'if __name__ == ''__main__'':'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: '# Do something'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '# 做些事情'
- en: func()
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: func()
- en: This block of code ensures that the statements within the block are executed
    only when the program is run on its own.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码确保只有当程序独立运行时，代码块中的语句才会被执行。
- en: When a program runs, the special variable __name__ is set to __main__ automatically,
    so the if condition evaluates to True and the function func() is called. However,
    __name__ is set differently when you import the program into another program (see
    “[Reusing Code](app02.html#app02lev1sec07)” on [page 235](app02.html#page_235)).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序运行时，特殊变量__name__会自动被设置为__main__，所以if条件评估为True，并调用函数func()。然而，当你将程序导入到另一个程序中时，__name__的值会有所不同（参见“[重用代码](app02.html#app02lev1sec07)”在[第235页](app02.html#page_235)）。
- en: 'Here’s a quick demonstration. Consider the following program, which we’ll call
    *factorial.py*:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个快速的演示。考虑以下程序，我们称其为*factorial.py*：
- en: '# Find the factorial of a number'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '# 计算一个数字的阶乘'
- en: 'def fact(n):'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 'def fact(n):'
- en: p = 1
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: p = 1
- en: 'for i in range(1, n+1):'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(1, n+1):'
- en: p = p*i
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: p = p * i
- en: return p
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: return p
- en: ➊ print(__name__)
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ print(__name__)
- en: 'if __name__ == ''__main__'':'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: n = int(input('Enter an integer to find the factorial of: '))
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: n = int(input('输入一个整数来计算其阶乘：'))
- en: f = fact(n)
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: f = fact(n)
- en: print('Factorial of {0}: {1}'.format(n, f))
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 'print(''阶乘 {0} 的值为: {1}''.format(n, f))'
- en: 'The program defines a function, fact(), that calculates the factorial of the
    integer passed to it. When you run it, it prints __main__, which corresponds to
    the print statement at ➊, because __name__ is automatically set to __main__. Then,
    it asks an integer to be entered, calculates the factorial, and prints it:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序定义了一个函数fact()，用于计算传入整数的阶乘。当你运行它时，它会打印出__main__，这是因为__name__被自动设置为__main__，对应于➊处的print语句。然后，程序会提示输入一个整数，计算其阶乘并打印出来：
- en: __main__
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: __main__
- en: Enter an integer to find the factorial of: 5
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 输入一个整数来计算其阶乘：5
- en: Factorial of 5: 120
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 5的阶乘：120
- en: 'Now, say you need to calculate the factorial in another program. Instead of
    writing the function again, you decide to reuse this function by importing it:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设你需要在另一个程序中计算阶乘。你可以通过导入这个函数来重用它，而不必再次编写函数：
- en: from factorial import fact
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: from factorial import fact
- en: 'if __name__ == ''__main__'':'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: print('Factorial of 5: {0}'.format(fact(5)))
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 'print(''阶乘 5 的值为: {0}''.format(fact(5)))'
- en: 'Note that both the programs must be in the same directory. When you run this
    program, you’ll get the following output:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，两个程序必须在同一目录下。当你运行这个程序时，你将得到以下输出：
- en: factorial
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: factorial
- en: Factorial of 5: 120
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 5的阶乘：120
- en: When your program is imported by another program, the value of the variable
    __main__ is set to that program’s filename, without the extension. In this case,
    the value of __name__ is factorial instead of __main__. Because the condition
    __name__ == '__main__' now evaluates to False, the program doesn’t ask for the
    user’s input anymore. Remove the condition to see for yourself what happens!
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的程序被另一个程序导入时，变量__main__的值会被设置为该程序的文件名，不包括扩展名。在这种情况下，__name__的值为factorial，而不是__main__。由于__name__
    == '__main__'条件现在评估为False，程序不再要求用户输入。删除该条件，看看会发生什么！
- en: To summarize, it’s good practice to use if __name__ == '__main__' in your programs
    so that the statements you want executed when your program is run as a standalone
    are also *not* executed when your program is imported into another program.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，使用if __name__ == '__main__'是一个好习惯，这样当你的程序作为独立程序运行时你希望执行的语句不会在程序被另一个程序导入时执行。
- en: '**List Comprehensions**'
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**列表推导式**'
- en: 'Let’s say we have a list of integers and we want to create a new list containing
    the squares of the elements of the original list. Here’s one way that we could
    do this that’s already familiar to you:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个整数列表，并且想要创建一个新的列表，包含原列表元素的平方。这里有一种方法，应该对你来说已经很熟悉：
- en: '>>> x = [1, 2, 3, 4]'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x = [1, 2, 3, 4]'
- en: '>>> x_square = []'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x_square = []'
- en: '➊ >>> for n in x:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ >>> for n in x:'
- en: ➋         x_square.append(n**2)
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ➋         x_square.append(n**2)
- en: '>>> x_square'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x_square'
- en: '[1, 4, 9, 16]'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '[1, 4, 9, 16]'
- en: 'Here, we used a code pattern that we’ve used in various programs throughout
    the book. We create an empty list, x_square, and then successively append to it
    as we calculate the square. We can do this in a more efficient way using *list
    comprehensions*:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们使用了在本书各个程序中都用过的代码模式。我们创建了一个空列表 x_square，然后在计算平方时将其逐一添加到列表中。我们可以使用 *列表推导式*
    更高效地实现这一点：
- en: ➌ >>> x_square = [n**2 for n in x]
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ >>> x_square = [n**2 for n in x]
- en: '>>> x_square'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x_square'
- en: '[1, 4, 9, 16]'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[1, 4, 9, 16]'
- en: The statement at ➌ is referred to as a *list comprehension* in Python. It consists
    of an expression—here, n**2—followed by a for loop, for n in x. Note that it basically
    allows us to combine the two statements at ➊ and ➋ into one to create a new list
    in one statement.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ 处的语句在 Python 中被称为 *列表推导式*。它由一个表达式——这里是 n**2——以及一个 for 循环组成，for n in x。请注意，它基本上让我们将
    ➊ 和 ➋ 两个语句合并为一个，在一条语句中创建一个新的列表。
- en: 'As another example, consider one of the programs we wrote in “[Drawing the
    Trajectory](ch02.html#ch02lev3sec05)” on [page 51](ch02.html#page_51) to draw
    the trajectory of a body in projectile motion. In these programs, we have the
    following block of code to calculate the *x*- and *y*-coordinates of the body
    at each time instant:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 作为另一个例子，考虑我们在 “[绘制轨迹](ch02.html#ch02lev3sec05)” 中写的一个程序，位于 [第 51 页](ch02.html#page_51)，用于绘制抛体运动中物体的轨迹。在这些程序中，我们有以下代码块来计算物体在每个时间瞬间的
    *x* 和 *y* 坐标：
- en: '# Find time intervals'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '# 查找时间间隔'
- en: intervals = frange(0, t_flight, 0.001)
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: intervals = frange(0, t_flight, 0.001)
- en: '# List of x and y coordinates'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '# x 和 y 坐标的列表'
- en: x = []
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: x = []
- en: y = []
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: y = []
- en: 'for t in intervals:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 'for t in intervals:'
- en: x.append(u*math.cos(theta)*t)
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: x.append(u*math.cos(theta)*t)
- en: y.append(u*math.sin(theta)*t - 0.5*g*t*t)
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: y.append(u*math.sin(theta)*t - 0.5*g*t*t)
- en: 'Using list comprehension, you can rewrite the block of code as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用列表推导式，你可以将代码块重写如下：
- en: '# Find time intervals'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '# 查找时间间隔'
- en: intervals = frange(0, t_flight, 0.001)
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: intervals = frange(0, t_flight, 0.001)
- en: '# List of x and y coordinates'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '# x 和 y 坐标的列表'
- en: x = [u*math.cos(theta)*t for t in intervals]
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: x = [u*math.cos(theta)*t for t in intervals]
- en: y = [u*math.sin(theta)*t - 0.5*g*t*t for t in intervals]
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: y = [u*math.sin(theta)*t - 0.5*g*t*t for t in intervals]
- en: The code is more compact now, as you didn’t have to create the empty lists,
    write a for loop, and append to the lists. List comprehension lets you do this
    in a single statement.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，代码更加简洁，因为你不需要创建空列表、编写 for 循环并向列表中添加元素。列表推导式让你可以通过单条语句完成这一切。
- en: 'You can also add conditionals to a list comprehension in order to selectively
    choose which list items are evaluated in the expression. Consider, once again,
    the first example:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在列表推导式中添加条件，以选择性地评估哪些列表项在表达式中被计算。再一次考虑第一个例子：
- en: '>>> x = [1, 2, 3, 4]'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x = [1, 2, 3, 4]'
- en: '>>> x_square = [n**2 for n in x if n%2 == 0]'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x_square = [n**2 for n in x if n%2 == 0]'
- en: '>>> x_square'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x_square'
- en: '[4, 16]'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[4, 16]'
- en: In this list comprehension, we use the if condition to explicitly tell Python
    to evaluate the expression n**2 only on the even list items of x.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个列表推导式中，我们使用 if 条件显式告诉 Python 仅在 x 中的偶数项上计算表达式 n**2。
- en: '**Dictionary Data Structure**'
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典数据结构**'
- en: 'We first used a Python dictionary in [Chapter 4](ch04.html#ch04) while implementing
    the subs() method in SymPy. Let’s explore Python dictionaries in more detail.
    Consider a simple dictionary:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [第 4 章](ch04.html#ch04)中首次使用了 Python 字典，使用它实现了 SymPy 中的 subs() 方法。让我们更详细地探讨
    Python 字典。考虑一个简单的字典：
- en: '>>> d = {''key1'': 5, ''key2'': 20}'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> d = {''key1'': 5, ''key2'': 20}'
- en: This code creates a dictionary with two keys—'key1' and 'key2'—with values 5
    and 20, respectively. Only strings, numbers, and tuples can be keys in a Python
    dictionary. These data types are referred to as *immutable* data types—once created,
    they can’t be changed—so a list can’t be a key because we can add and remove elements
    from a list.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码创建了一个字典，包含两个键——'key1' 和 'key2'——对应的值分别是 5 和 20。在 Python 字典中，只有字符串、数字和元组可以作为键。这些数据类型被称为
    *不可变* 数据类型——一旦创建，它们就不能改变——因此列表不能作为键，因为我们可以向列表中添加和删除元素。
- en: 'We already know that to retrieve the value corresponding to ''key1'' in the
    dictionary, we need to specify it as d[''key1'']. This is one of the most common
    use cases of a dictionary. A related use case is checking whether the dictionary
    contains a certain key, ''x''. We can check that as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道，要检索字典中对应于 'key1' 的值，我们需要指定为 d['key1']。这是字典最常见的用例之一。一个相关的用例是检查字典是否包含某个特定的键
    'x'。我们可以按如下方式检查：
- en: '>>> d = {''key1'': 5, ''key2'': 20}'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> d = {''key1'': 5, ''key2'': 20}'
- en: '>>> ''x'' in d'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> ''x'' in d'
- en: 'False'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 'False'
- en: 'Once we create a dictionary, we can add a new key-value pair to it, similar
    to how we can append elements to a list. Here’s an example:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了字典，就可以像向列表添加元素一样，向字典中添加一个新的键值对。下面是一个例子：
- en: '>>> d = {''key1'': 5, ''key2'': 20}'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> d = {''key1'': 5, ''key2'': 20}'
- en: '>>> if ''x'' in d:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> if ''x'' in d:'
- en: print(d['x'])
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: print(d['x'])
- en: 'else:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: d['x'] = 1
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: d['x'] = 1
- en: '>>> d'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> d'
- en: '{''key1'': 5, ''x'': 1, ''key2'': 20}'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '{''key1'': 5, ''x'': 1, ''key2'': 20}'
- en: This code snippet checks whether the key 'x' already exists in the dictionary,
    d. If it does, it prints the value corresponding to it; otherwise, it adds the
    key to the dictionary with 1 as the corresponding value. Similar to Python’s behavior
    with sets, Python can’t guarantee a particular order of the key-value pairs in
    a dictionary. The key-value pairs can be in any order, irrespective of the order
    of insertion.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码检查字典 `d` 中是否已经存在键 'x'。如果存在，它会打印出对应的值；如果不存在，则会将该键添加到字典中，并将其值设为 1。与 Python
    中集合的行为类似，Python 不能保证字典中键值对的顺序。键值对的顺序可能是任何顺序，而不管插入顺序如何。
- en: 'Besides specifying the key as an index to the dictionary, we can also use the
    get() method to retrieve the value corresponding to the key:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用键作为字典的索引外，我们还可以使用 `get()` 方法来获取对应键的值：
- en: '>>> d.get(''x'')'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> d.get(''x'')'
- en: '1'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: If you specify a nonexistent key to the get() method, None is returned. On the
    other hand, if you do so while using the index style of retrieving, you’ll get
    an error.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你向 `get()` 方法指定一个不存在的键，它会返回 `None`。而如果你使用索引方式获取并指定不存在的键，则会报错。
- en: 'The get() method also lets you set a default value for nonexistent keys:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`get()` 方法还允许你为不存在的键设置默认值：'
- en: '>>> d.get(''y'', 0)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> d.get(''y'', 0)'
- en: '0'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: 'There’s no key ''y'' in the dictionary d, so 0 is returned. If there is a key,
    however, the value is returned instead:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 字典 `d` 中没有键 'y'，因此返回的是 0。如果存在该键，则会返回对应的值：
- en: '>>> d[''y''] = 1'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> d[''y''] = 1'
- en: '>>> d.get(''y'', 0)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> d.get(''y'', 0)'
- en: '1'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: 'The keys() and values() methods each return a list-like data structure of all
    the keys and values, respectively, in a dictionary:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`keys()` 和 `values()` 方法分别返回字典中所有键和值的类列表数据结构：'
- en: '>>> d.keys()'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> d.keys()'
- en: dict_keys(['key1', 'x', 'key2', 'y'])
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: dict_keys(['key1', 'x', 'key2', 'y'])
- en: '>>> d.values()'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> d.values()'
- en: dict_values([5, 1, 20, 1])
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: dict_values([5, 1, 20, 1])
- en: 'To iterate over the key and value pairs in a dictionary, use the items() method:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要遍历字典中的键值对，可以使用 `items()` 方法：
- en: '>>> d.items()'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> d.items()'
- en: dict_items([('key1', 5), ('x', 1), ('key2', 20), ('y', 1)])
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: dict_items([('key1', 5), ('x', 1), ('key2', 20), ('y', 1)])
- en: 'This method returns a *view* of tuples, and each tuple is a key-value pair.
    We can use the following code snippet to print them nicely:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法返回一个*视图*，该视图是一个元组集合，每个元组包含一个键值对。我们可以使用以下代码将它们打印得更整齐：
- en: '>>> for k, v in d.items():'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> for k, v in d.items():'
- en: print(k, v)
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: print(k, v)
- en: key1 5
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: key1 5
- en: x 1
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: x 1
- en: key2 20
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: key2 20
- en: y 1
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: y 1
- en: Views are more memory efficient than lists, and they don’t let you add or remove
    items.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 视图比列表更节省内存，并且不允许你添加或删除项。
- en: '**Multiple Return Values**'
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**多个返回值**'
- en: 'In the programs we’ve written so far, most of the functions return a single
    value, but functions sometimes return multiple values. We saw an example of such
    a function in “[Measuring the Dispersion](ch03.html#ch03lev1sec04)” on [page 71](ch03.html#page_71),
    where in the program to find the range, we returned three numbers from the find_range()
    function. Here’s another example of the approach we took there:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们写的程序中，大多数函数返回单个值，但有时函数会返回多个值。我们在“[测量离散度](ch03.html#ch03lev1sec04)”一节中看到过这样的例子，在该程序中，查找范围时，我们从
    `find_range()` 函数中返回了三个数字。下面是我们在其中采用的另一种方法：
- en: import math
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: import math
- en: 'def components(u, theta):'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 'def components(u, theta):'
- en: x = u*math.cos(theta)
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: x = u*math.cos(theta)
- en: y = u*math.sin(theta)
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: y = u*math.sin(theta)
- en: return x, y
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: return x, y
- en: 'The components() function accepts a velocity, u, and an angle, theta, in radians
    as parameters, and it calculates the x and y components and returns them. To return
    the calculated components, we simply list the corresponding Python labels in the
    return statement separated by a comma. This creates and returns a tuple consisting
    of the items x and y. In the calling code, we receive the multiple values:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`components()` 函数接受一个速度 `u` 和一个角度 `theta`（单位为弧度），然后计算 x 和 y 分量并返回它们。为了返回计算出的分量，我们只需在
    `return` 语句中列出对应的 Python 标签，并用逗号分隔。这将创建并返回一个包含 x 和 y 项的元组。在调用代码中，我们接收这些多个值：'
- en: 'if __name__ == ''__main__'':'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: theta = math.radians(45)
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: theta = math.radians(45)
- en: x, y = components(theta)
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: x, y = components(theta)
- en: 'Because the components() function returns a tuple, we can retrieve the returned
    values using tuple indices:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 components() 函数返回一个元组，我们可以通过元组索引来获取返回值：
- en: c = components(theta)
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: c = components(theta)
- en: x = c[0]
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: x = c[0]
- en: y = c[1]
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: y = c[1]
- en: This has advantages because we don’t have to know all the different values being
    returned. For one, you don’t have to write x,y,z = myfunc1() when the function
    returns three values or a,x,y,z = myfunc1() when the function returns four values,
    and so on.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的好处是我们不需要知道所有返回的不同值。例如，当函数返回三个值时，你不必写 x,y,z = myfunc1()；如果返回四个值，就不必写 a,x,y,z
    = myfunc1()，依此类推。
- en: In either of the preceding cases, the code calling the components() function
    must know which of the return values correspond to which component of the velocity,
    as there’s no way to know that from the values themselves.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述任一情况中，调用 components() 函数的代码必须知道哪些返回值对应于速度的哪个分量，因为从返回值本身无法得知。
- en: 'A user-friendly approach is to return a dictionary object instead, as we saw
    in the case of SymPy’s solve() function when used with the dict=True keyword argument.
    Here’s how we can rewrite the preceding components function to return a dictionary:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一种用户友好的方法是返回一个字典对象，正如我们在使用 dict=True 关键字参数时，在 SymPy 的 solve() 函数中看到的那样。下面是如何重写前面的
    components 函数以返回字典：
- en: import math
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: import math
- en: 'def components(theta):'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 'def components(theta):'
- en: x = math.cos(theta)
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: x = math.cos(theta)
- en: y = math.sin(theta)
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: y = math.sin(theta)
- en: return {'x': x, 'y': y}
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 'return {''x'': x, ''y'': y}'
- en: 'Here, we return a dictionary with the keys ''x'' and ''y'' referring to the
    x and y components and their corresponding numerical values. With this new function
    definition, we don’t need to worry about the order of the returned values. We
    just use the key ''x'' to retrieve the x component and the key ''y'' to retrieve
    the y component:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们返回一个字典，键 'x' 和 'y' 分别表示 x 和 y 分量及其对应的数值。通过这种新的函数定义，我们不必担心返回值的顺序。我们只需要使用键
    'x' 来获取 x 分量，使用键 'y' 来获取 y 分量：
- en: 'if __name__ == ''__main__'':'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: theta = math.radians(45)
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: theta = math.radians(45)
- en: c = components(theta)
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: c = components(theta)
- en: y = c['y']
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: y = c['y']
- en: x = c['x']
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: x = c['x']
- en: print(x, y)
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: print(x, y)
- en: 'This approach eliminates the need to use indices to refer to a specific returned
    value. The following code rewrites the program to find the range (see “[Measuring
    the Dispersion](ch03.html#ch03lev1sec04)” on [page 71](ch03.html#page_71)) so
    that the results are returned as a dictionary instead of a tuple:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法消除了使用索引来引用特定返回值的需求。以下代码重写了程序以查找范围（请参阅 “[测量离散度](ch03.html#ch03lev1sec04)”
    在 [第71页](ch03.html#page_71)），使得结果以字典的形式返回，而不是元组：
- en: ''''''''
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ''''''''
- en: Find the range using a dictionary to return values
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用字典查找范围并返回值
- en: ''''''''
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: ''''''''
- en: 'def find_range(numbers):'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 'def find_range(numbers):'
- en: lowest = min(numbers)
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: lowest = min(numbers)
- en: highest = max(numbers)
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: highest = max(numbers)
- en: '# Find the range'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '# 查找范围'
- en: r = highest-lowest
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: r = highest - lowest
- en: return {'lowest':lowest, 'highest':highest, 'range':r}
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: return {'lowest':lowest, 'highest':highest, 'range':r}
- en: 'if __name__ == ''__main__'':'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: donations = [100, 60, 70, 900, 100, 200, 500, 500, 503, 600, 1000, 1200]
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: donations = [100, 60, 70, 900, 100, 200, 500, 500, 503, 600, 1000, 1200]
- en: result = find_range(donations)
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: result = find_range(donations)
- en: ➊     print('Lowest: {0} Highest: {1} Range: {2}'.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '➊     print(''最低值: {0} 最高值: {1} 范围: {2}''.'
- en: format(result['lowest'], result['highest'], result['range']))
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: format(result['lowest'], result['highest'], result['range']))
- en: The find_range() function now returns a dictionary with the keys lowest, highest,
    and range and with the lowest number, highest number, and the range as their corresponding
    values. At ➊, we simply use the corresponding key to retrieve the corresponding
    value.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: find_range() 函数现在返回一个包含最低值、最高值和范围的字典，并将最低值、最高值和范围作为对应的值。在 ➊ 处，我们只需使用对应的键来获取对应的值。
- en: If we were just interested in the range of a group of numbers and we didn’t
    care about the lowest and highest numbers, we’d just use result['range'] and not
    worry about what other values were returned.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只关心一组数字的范围，而不在乎最低值和最高值，我们只需要使用 result['range']，而不必担心其他返回的值。
- en: '**Exception Handling**'
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**异常处理**'
- en: 'In [Chapter 1](ch01.html#ch01), we learned that trying to convert a string
    such as ''1.1'' to an integer using the int() function results in a ValueError
    exception. But with a try...except block, we can print a user-friendly error message:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第1章](ch01.html#ch01) 中，我们学习了尝试使用 int() 函数将字符串 '1.1' 转换为整数时会导致 ValueError
    异常。但是使用 try...except 块时，我们可以打印出友好的错误信息：
- en: '>>> try:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> try:'
- en: int('1.1')
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: int('1.1')
- en: 'except ValueError:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 'except ValueError:'
- en: print('Failed to convert 1.1 to an integer')
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: print('无法将 1.1 转换为整数')
- en: Failed to convert 1.1 to an integer
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 未能将 1.1 转换为整数
- en: 'When any statement in the try block raises an exception, the type of exception
    raised is matched with the one specified by the except statement. If there’s a
    match, the program resumes in the except block. If the exception doesn’t match,
    the program execution halts and displays the exception. Here’s an example:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当 try 块中的任何语句引发异常时，引发的异常类型将与 except 语句指定的类型匹配。如果匹配成功，则程序在 except 块中恢复执行。如果异常类型不匹配，则程序执行停止并显示异常。以下是一个例子：
- en: '>>> try:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> try:'
- en: print(1/0)
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: print(1/0)
- en: 'except ValueError:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 'except ValueError:'
- en: print('Division unsuccessful')
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: print('Division unsuccessful')
- en: 'Traceback (most recent call last):'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 'Traceback (most recent call last):'
- en: File "<pyshell#66>", line 2, in <module>
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: File "<pyshell#66>", line 2, in <module>
- en: print(1/0)
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: print(1/0)
- en: ZeroDivisionError: division by zero
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ZeroDivisionError: division by zero
- en: This code block attempts a division by 0, which results in a ZeroDivisionError
    exception. Although the division is carried out in a try...except block, the exception
    type is incorrectly specified, and the exception isn’t handled correctly. The
    correct way to handle this exception is to specify ZeroDivisionError as the exception
    type.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码尝试除以 0，导致 ZeroDivisionError 异常。虽然在 try...except 块中进行了除法操作，但是异常类型被错误地指定，并且异常没有被正确处理。正确处理此异常的方法是指定
    ZeroDivisionError 作为异常类型。
- en: '***Specifying Multiple Exception Types***'
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***指定多个异常类型***'
- en: 'You can also specify multiple exception types. Consider the function reciprocal(),
    which returns the reciprocal of the number passed to it:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以指定多个异常类型。考虑函数 reciprocal()，它返回传递给它的数字的倒数：
- en: 'def reciprocal(n):'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 'def reciprocal(n):'
- en: 'try:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 'try:'
- en: print(1/n)
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: print(1/n)
- en: 'except (ZeroDivisionError, TypeError):'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 'except (ZeroDivisionError, TypeError):'
- en: print('You entered an invalid number')
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: print('您输入了一个无效的数字')
- en: We defined the function reciprocal(), which prints the reciprocal of the user’s
    input. We know that if the function is called with 0, it’ll cause a ZeroDivisionError
    exception. If you pass a string, however, it’ll cause a TypeError exception. The
    function considers both these cases as invalid input and specifies both ZeroDivisionError
    and TypeError in the except statement as a tuple.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了函数 reciprocal()，它打印用户输入的倒数。我们知道，如果函数以 0 被调用，将会引发 ZeroDivisionError 异常。然而，如果传入一个字符串，将会引发
    TypeError 异常。函数将这两种情况视为无效输入，并在 except 语句中作为一个元组指定了 ZeroDivisionError 和 TypeError。
- en: 'Let’s try calling the function with a valid input—that is, a nonzero number:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用一个有效的输入来调用该函数——即非零数：
- en: '>>> reciprocal(5)'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> reciprocal(5)'
- en: '0.2'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '0.2'
- en: 'Next, we call the function with 0 as the argument:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们以 0 作为参数调用该函数：
- en: '>>> reciprocal(0)'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> reciprocal(0)'
- en: Enter an integer: 0
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 输入一个整数：0
- en: You entered an invalid number
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 您输入了一个无效的数字
- en: The 0 argument raises the ZeroDivisionError exception, which is in the tuple
    of exception types specified to the except statement, so the code prints an error
    message.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 参数 0 引发了 ZeroDivisionError 异常，该异常在 except 语句指定的异常类型元组中，因此代码打印出错误消息。
- en: 'Now, let’s enter a string:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们输入一个字符串：
- en: '>>> reciprocal(''1'')'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> reciprocal(''1'')'
- en: 'In this case, we entered an invalid number, which raises the TypeError exception.
    This exception is also in the tuple of specified exceptions, so the code prints
    an error message. If you want to give a more specific error message, we can just
    specify multiple except statements as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们输入了一个无效的数字，导致 TypeError 异常。此异常也在指定的异常元组中，因此代码打印出错误消息。如果想要提供更具体的错误消息，我们可以像下面这样指定多个
    except 语句：
- en: 'def reciprocal(n):'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 'def reciprocal(n):'
- en: 'try:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 'try:'
- en: print(1/n)
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: print(1/n)
- en: 'except TypeError:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 'except TypeError:'
- en: print('You must specify a number')
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: print('您必须指定一个数字')
- en: 'except ZeroDivisionError:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 'except ZeroDivisionError:'
- en: print('Division by 0 is invalid')
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: print('除以 0 是无效的')
- en: '>>> reciprocal(0)'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> reciprocal(0)'
- en: Division by 0 is invalid
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 除以 0 是无效的
- en: '>>> reciprocal(''1'')'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> reciprocal(''1'')'
- en: You must specify a number
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须指定一个数字
- en: In addition to TypeError, ValueError, and ZeroDivisionError, there are a number
    of other built-in exception types. The Python documentation at *[https://docs.python.org/3.4/library/exceptions.html#bltin-exceptions](https://docs.python.org/3.4/library/exceptions.html#bltin-exceptions)*
    lists the builtin exceptions for Python 3.4.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 TypeError、ValueError 和 ZeroDivisionError 外，Python 3.4 还有许多其他内置异常类型。Python
    文档位于 *[https://docs.python.org/3.4/library/exceptions.html#bltin-exceptions](https://docs.python.org/3.4/library/exceptions.html#bltin-exceptions)*
    列出了 Python 3.4 的内置异常。
- en: '***The else Block***'
  id: totrans-210
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***else 块***'
- en: 'The else block is used to specify which statements to execute when there’s
    no exception. Consider an example from the program we wrote to draw the trajectory
    of a projectile (see “[Drawing the Trajectory](ch02.html#ch02lev3sec05)” on [page
    51](ch02.html#page_51)):'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: else 块用于指定当没有异常发生时要执行的语句。考虑我们编写的程序中的一个例子，该程序用于绘制抛物线轨迹（参见 “[绘制轨迹](ch02.html#ch02lev3sec05)”
    [第51页](ch02.html#page_51)）：
- en: 'if __name__ == ''__main__'':'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: 'try:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 'try:'
- en: u = float(input('Enter the initial velocity (m/s): '))
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 'u = float(input(''请输入初始速度 (m/s): ''))'
- en: theta = float(input('Enter the angle of projection (degrees): '))
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: theta = float(input('请输入抛射角度（度）：'))
- en: 'except ValueError:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 'except ValueError:'
- en: print('You entered an invalid input')
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: print('你输入了无效的内容')
- en: '➊     else:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '➊     else:'
- en: draw_trajectory(u, theta)
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: draw_trajectory(u, theta)
- en: plt.show()
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: plt.show()
- en: 'If the input for u or theta couldn’t be converted to a floating point number,
    it doesn’t make sense for the program to call the draw_trajectory() and plt.show()
    functions. Instead, we specify these two statements in the else block at ➊. Using
    try...except...else will let you manage different types of errors during runtime
    and take appropriate action when there is an error or when there is none:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 u 或 theta 的输入无法转换为浮动点数字，那么程序调用 draw_trajectory() 和 plt.show() 函数就没有意义。相反，我们在
    ➊ 处将这两条语句放入 else 块中。使用 try...except...else 可以让你在运行时管理不同类型的错误，并在发生错误或没有错误时采取适当的行动：
- en: 1\. If there’s an exception and there’s an except statement corresponding to
    the exception type raised, the execution is transferred to the corresponding except
    block.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 如果发生异常，并且有与引发的异常类型相对应的 except 语句，则执行会转移到相应的 except 块。
- en: 2\. If there’s no exception, the execution is transferred to the else block.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 如果没有异常，执行会转移到 else 块。
- en: '**Reading Files in Python**'
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**在 Python 中读取文件**'
- en: 'Opening a file is the first step to reading data from it. Let’s start with
    a quick example. Consider a file that consists of a collection of numbers with
    one number per line:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 打开文件是从文件中读取数据的第一步。让我们从一个简单的例子开始。考虑一个由一组数字组成的文件，每行包含一个数字：
- en: '100'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '100'
- en: '60'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '60'
- en: '70'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '70'
- en: '900'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '900'
- en: '100'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '100'
- en: '200'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '200'
- en: '500'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '500'
- en: '500'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '500'
- en: '503'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '503'
- en: '600'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '600'
- en: '1000'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '1000'
- en: '1200'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '1200'
- en: 'We want to write a function that reads the file and returns a list of those
    numbers:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想编写一个函数，读取文件并返回这些数字的列表：
- en: 'def read_data(path):'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 'def read_data(path):'
- en: numbers = []
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: numbers = []
- en: ➊     f = open(path)
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ➊     f = open(path)
- en: '➋     for line in f:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '➋     for line in f:'
- en: numbers.append(float(line))
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: numbers.append(float(line))
- en: f.close()
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: f.close()
- en: return numbers
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: return numbers
- en: First, we define the function read_data() and create an empty list to store
    all of the numbers. At ➊, we use the open() function to open the file whose location
    has been specified via the argument path. An example of the path would be */home/username/mydata.txt*
    on Linux, *C:\mydata.txt* on Microsoft Windows, or */Users/Username/mydata.txt*
    on OS X. The open() function returns a file object, which we use the label f to
    refer to. We can go over each line of the file using a for loop at ➋. Because
    each line is returned as a string, we convert it into a number and append it to
    the list numbers. The loop stops executing once all the lines have been read,
    and we close the file using the close() method. Finally, we return the numbers
    list.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义函数 read_data() 并创建一个空列表来存储所有的数字。在 ➊ 处，我们使用 open() 函数打开由路径参数指定的文件。路径的示例可能是
    Linux 上的 */home/username/mydata.txt*、Microsoft Windows 上的 *C:\mydata.txt*，或 OS
    X 上的 */Users/Username/mydata.txt*。open() 函数返回一个文件对象，我们用标签 f 来引用它。我们可以在 ➋ 处使用 for
    循环逐行读取文件。由于每一行都是作为字符串返回的，我们将其转换为数字并将其附加到列表 numbers 中。循环在所有行被读取后停止执行，并通过 close()
    方法关闭文件。最后，我们返回 numbers 列表。
- en: 'This is similar to how we read the numbers from a file in [Chapter 3](ch03.html#ch03),
    although we didn’t have to close the file explicitly because we used a different
    approach there. Using the approach we took in [Chapter 3](ch03.html#ch03), we
    would rewrite the preceding function as follows:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这类似于我们在 [第3章](ch03.html#ch03) 中读取文件中的数字，尽管在那里我们没有显式地关闭文件，因为我们采用了不同的方法。使用我们在
    [第3章](ch03.html#ch03) 中的方法，我们可以将前面的函数重写如下：
- en: 'def read_data(path):'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 'def read_data(path):'
- en: numbers = []
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: numbers = []
- en: '➊     with open(path) as f:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '➊     with open(path) as f:'
- en: 'for line in f:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 'for line in f:'
- en: numbers.append(float(line))
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: numbers.append(float(line))
- en: ➋     return numbers
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: ➋     return numbers
- en: The key statement here is at ➊. It’s similar to writing f = open(path) but only
    partially. Besides opening the file and assigning the file object returned by
    open() to f, it also sets up a new *context* with all the statements in that block—in
    this case, all the statements before the return statement. When all the statements
    in the body have been executed, the file is automatically closed. That is, when
    the execution reaches the statement at ➋, the file is closed without needing an
    explicit call to the close() method. This method also means that if there are
    any exceptions while working with the file, it’ll still be closed before the program
    exits. This is the preferred approach to working with files.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键语句在 ➊。它类似于写 `f = open(path)`，但只有部分相同。除了打开文件并将 `open()` 返回的文件对象赋值给 f，它还设置了一个新的
    *上下文*，包括该代码块中的所有语句——在这种情况下，就是所有在 `return` 语句之前的语句。当代码块中的所有语句执行完毕时，文件会自动关闭。也就是说，当执行到
    ➋ 语句时，文件会被关闭，无需显式调用 `close()` 方法。这种方法也意味着，如果在操作文件时发生了异常，它仍会在程序退出前关闭文件。这是操作文件时推荐的方式。
- en: '***Reading All the Lines at Once***'
  id: totrans-255
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***一次性读取所有行***'
- en: 'Instead of reading the lines one by one to build a list, we can use the readlines()
    method to read all the lines into a list at once. This results in a more compact
    function:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `readlines()` 方法一次性将所有行读取到一个列表中，而不是逐行读取，从而实现更紧凑的功能：
- en: 'def read_data(path):'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 'def read_data(path):'
- en: 'with open(path) as f:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `open(path)` 打开文件并将其赋值给 f：
- en: ➊         lines = f.readlines()
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: ➊         lines = f.readlines()
- en: numbers = [float(n) for n in lines]
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: numbers = [float(n) for n in lines]
- en: return numbers
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: return numbers
- en: We read all the lines of the file into a list using the readlines() method at
    ➊. Then, we convert each of the items in the list into a floating point number
    using the float() function and list comprehension. Finally, we return the list
    numbers.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 ➊ 的 `readlines()` 方法将文件中的所有行读取到一个列表中。然后，我们使用 `float()` 函数和列表推导将列表中的每个项目转换为浮动点数。最后，我们返回该列表
    `numbers`。
- en: '***Specifying the Filename as Input***'
  id: totrans-263
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***将文件名指定为输入***'
- en: 'The read_data() function takes the file path as an argument. If your program
    allows you to specify the filename as an input, this function should work for
    any file as long as the file contains data we expect to read. Here’s an example:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`read_data()` 函数将文件路径作为参数。如果你的程序允许你指定文件名作为输入，只要文件包含我们预期要读取的数据，该函数就可以适用于任何文件。以下是一个例子：'
- en: 'if __name__==''__main__'':'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: data_file = input('Enter the path of the file: ')
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: data_file = input('输入文件路径：')
- en: data = read_data(data_file)
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: data = read_data(data_file)
- en: print(data)
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: print(data)
- en: 'Once you’ve added this code to the end of the read_data() function and run
    it, it’ll ask you to input the path to the file. Then, it’ll print the numbers
    it reads from the file:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你将此代码添加到 `read_data()` 函数的末尾并运行，它会提示你输入文件的路径。然后，它会打印出它从文件中读取的数字：
- en: Enter the path of the file /home/amit/work/mydata.txt
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 输入文件路径：/home/amit/work/mydata.txt
- en: '[100.0,60.0,70.0,900.0,100.0,200.0,500.0,500.0,503.0,600.0,1000.0,1200.0]'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '[100.0,60.0,70.0,900.0,100.0,200.0,500.0,500.0,503.0,600.0,1000.0,1200.0]'
- en: '***Handling Errors When Reading Files***'
  id: totrans-272
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***处理读取文件时的错误***'
- en: 'There are a couple of things that can go wrong when reading files: (1) the
    file can’t be read, or (2) the data in the file isn’t in the expected format.
    Here’s an example of what happens when a file can’t be read:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 读取文件时可能出现几种错误：（1）文件无法读取，或（2）文件中的数据格式不符合预期。以下是当文件无法读取时的示例：
- en: Enter the path of the file: /home/amit/work/mydata2.txt
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 输入文件路径：/home/amit/work/mydata2.txt
- en: 'Traceback (most recent call last):'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: Traceback（最近一次调用最后）：
- en: File "read_file.py", line 11, in <module>
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 "read_file.py"，第 11 行，在 <module> 中
- en: data = read_data(data_file)
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: data = read_data(data_file)
- en: File "read_file.py", line 4, in read_data
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 "read_file.py"，第 4 行，在 `read_data` 中
- en: 'with open(path) as f:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `open(path)` 打开文件并将其赋值给 f：
- en: FileNotFoundError: [Errno 2] No such file or directory: '/home/amit/work/
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 'FileNotFoundError: [Errno 2] No such file or directory: ''/home/amit/work/'
- en: mydata2.txt'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: mydata2.txt'
- en: 'Because I entered a file path that doesn’t exist, the FileNotFoundError exception
    is raised when we try to open the file. We can make the program display a user-friendly
    error message by modifying our read_data() function as follows:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我输入了一个不存在的文件路径，当我们尝试打开文件时，抛出了 `FileNotFoundError` 异常。我们可以通过修改 `read_data()`
    函数使程序显示用户友好的错误信息，如下所示：
- en: 'def read_data(path):'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 'def read_data(path):'
- en: numbers = []
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: numbers = []
- en: 'try:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 'try:'
- en: 'with open(path) as f:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `open(path)` 打开文件并将其赋值给 f：
- en: 'for line in f:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 'for line in f:'
- en: numbers.append(float(line))
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: numbers.append(float(line))
- en: 'except FileNotFoundError:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 'except FileNotFoundError:'
- en: print('File not found')
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: print('文件未找到')
- en: return numbers
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: return numbers
- en: 'Now, when you specify a nonexistent file path, you’ll get an error message
    instead:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你指定一个不存在的文件路径时，程序将显示错误信息：
- en: Enter the path of the file: /home/amit/work/mydata2.txt
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 输入文件路径: /home/amit/work/mydata2.txt
- en: File not found
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 文件未找到
- en: 'The second source of errors can be that the data in the file isn’t what your
    program expects to read. For example, consider a file that has the following:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 错误的第二个来源可能是文件中的数据并不是你的程序预期读取的内容。例如，考虑一个文件，其中包含如下内容：
- en: '10'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '10'
- en: '20'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '20'
- en: 3o
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 3o
- en: 1/5
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 1/5
- en: '5.6'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '5.6'
- en: The third line in this file isn’t convertible to a floating point number because
    it has the letter o in it instead of the number 0, and the fourth line consists
    of 1/5, a fraction in string form, which float() can’t handle.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件中的第三行无法转换为浮点数，因为它包含字母o而不是数字0，而第四行则是1/5，以字符串形式表示的分数，float()无法处理。
- en: 'If you supply this data file to the earlier program, it’ll produce the following
    error:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将这个数据文件提供给早期的程序，它将产生以下错误：
- en: Enter the path of the file: bad_data.txt
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 输入文件路径: bad_data.txt
- en: 'Traceback (most recent call last):'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 'Traceback (最近的调用最后):'
- en: File "read_file.py", line 13, in <module>
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 "read_file.py"，第13行，在<模块>中
- en: data = read_data(data_file)
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: data = read_data(data_file)
- en: File "read_file.py", line 6, in read_data
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 "read_file.py"，第6行，在read_data中
- en: numbers.append(float(line))
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: numbers.append(float(line))
- en: ValueError: could not convert string to float: '3o\n'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: ValueError: 无法将字符串转换为浮点数: '3o\n'
- en: 'The third line in the file is 3o, not the number 30, so when we attempt to
    convert it into a floating point number, the result is ValueError. There are two
    approaches you can take when such data is present in a file. The first is to report
    the error and exit the program. The modified read_data() function would appear
    as follows:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 文件中的第三行是3o，而不是数字30，因此当我们尝试将其转换为浮点数时，结果会是ValueError。当文件中存在这样的数据时，你可以采取两种方法。第一种方法是报告错误并退出程序。修改后的read_data()函数如下所示：
- en: 'def read_data(path):'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 'def read_data(path):'
- en: numbers = []
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: numbers = []
- en: 'try:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 'try:'
- en: 'with open(path) as f:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 'with open(path) as f:'
- en: 'for line in f:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 'for line in f:'
- en: '➊               try:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '➊               try:'
- en: ➋                   n = float(line)
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: ➋                   n = float(line)
- en: 'except ValueError:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 'except ValueError:'
- en: print('Bad data: {0}'.format(line))
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: print('错误数据: {0}'.format(line))
- en: ➌                   break
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: ➌                   break
- en: ➍               numbers.append(n)
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: ➍               numbers.append(n)
- en: 'except FileNotFoundError:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 'except FileNotFoundError:'
- en: print('File not found')
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: print('文件未找到')
- en: return numbers
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: return numbers
- en: We insert another try...except block in the function starting at ➊, and we convert
    the line into a floating point number at ➋. If the program raises the ValueError
    exception, we print an error message with the offending line and exit out of the
    for loop using break at ➌. The program then stops reading the file. The returned
    list, numbers, contains all the data that was successfully read before encountering
    the bad data. If there’s no error, we append the floating point number to the
    numbers list at ➍.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在从➊开始的函数中插入了另一个try...except块，并在➋处将行转换为浮点数。如果程序引发了ValueError异常，我们会打印包含错误行的错误信息，并通过break语句在➌处退出for循环。程序然后停止读取文件。返回的列表numbers包含了所有在遇到错误数据之前成功读取的数据。如果没有错误，我们会在➋处将浮点数添加到numbers列表中。
- en: 'Now when you supply the file *bad_data.txt* to the program, it’ll read only
    the first two lines, display the error message, and exit:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你将文件*bad_data.txt*提供给程序时，它将只读取前两行，显示错误信息，然后退出：
- en: Enter the path of the file: bad_data.txt
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 输入文件路径: bad_data.txt
- en: Bad data: 3o
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 错误数据: 3o
- en: '[10.0, 20.0]'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '[10.0, 20.0]'
- en: Returning partial data may not be desirable, so we could just replace the break
    statement at ➌ with return and no data would be returned.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 返回部分数据可能并不理想，因此我们可以将➌处的break语句替换为return，这样就不会返回任何数据。
- en: 'The second approach is to ignore the error and continue with the rest of the
    file. Here’s a modified read_data() function that does this:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法是忽略错误并继续处理文件的其余部分。这里是一个修改后的read_data()函数：
- en: 'def read_data(path):'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 'def read_data(path):'
- en: numbers = []
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: numbers = []
- en: 'try:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 'try:'
- en: 'with open(path) as f:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 'with open(path) as f:'
- en: 'for line in f:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 'for line in f:'
- en: 'try:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 'try:'
- en: n = float(line)
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: n = float(line)
- en: 'except ValueError:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 'except ValueError:'
- en: print('Bad data: {0}'.format(line))
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: print('错误数据: {0}'.format(line))
- en: ➊                     continue
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: ➊                     continue
- en: numbers.append(n)
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: numbers.append(n)
- en: 'except FileNotFoundError:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 'except FileNotFoundError:'
- en: print('File not found')
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: print('文件未找到')
- en: return numbers
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: return numbers
- en: 'The only change here is that instead of breaking out of the for loop, we just
    continue with the next iteration using the continue statement at ➊. The output
    from the program is now as follows:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的变化是，不再从for循环中跳出，而是使用continue语句在➊处继续进行下一次迭代。程序现在的输出如下：
- en: Bad data: 3o
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 错误数据：3o
- en: Bad data: 1/5
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 错误数据：1/5
- en: '[10.0, 20.0, 5.6]'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '[10.0, 20.0, 5.6]'
- en: The specific application where you’re reading the file will determine which
    of the above approaches you want to take to handle bad data.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 你读取文件的具体应用场景将决定你采用哪种方法来处理错误数据。
- en: '**Reusing Code**'
  id: totrans-351
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**重用代码**'
- en: Throughout this book, we’ve used classes and functions that were either part
    of the Python standard library or available after installing third-party packages,
    such as matplotlib and SymPy. Now we’ll look at a quick example of how we can
    import our own programs into other programs.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们使用了Python标准库的一些类和函数，或者通过安装第三方包（如matplotlib和SymPy）获得的类和函数。现在，我们来看一个简单的例子，演示如何将我们自己的程序导入到其他程序中。
- en: 'Consider the function find_corr_x_y() that we wrote in “[Calculating the Correlation
    Between Two Data Sets](ch03.html#ch03lev1sec05)” on [page 75](ch03.html#page_75).
    We’ll create a separate file, *correlation.py*, which has only the function definition:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑我们在“[计算两个数据集之间的相关性](ch03.html#ch03lev1sec05)”一节中写的函数find_corr_x_y()，该函数出现在[第75页](ch03.html#page_75)。我们将创建一个单独的文件，*correlation.py*，仅包含该函数的定义：
- en: ''''''''
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: ''''''''
- en: Function to calculate the linear correlation coefficient
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 用于计算线性相关系数的函数
- en: ''''''''
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: ''''''''
- en: 'def find_corr_x_y(x,y):'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 'def find_corr_x_y(x,y):'
- en: '# Size of each set'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '# 每个集合的大小'
- en: n = len(x)
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: n = len(x)
- en: '# Find the sum of the products'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '# 计算乘积和'
- en: prod=[]
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: prod=[]
- en: 'for xi,yi in zip(x,y):'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 'for xi,yi in zip(x,y):'
- en: prod.append(xi*yi)
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: prod.append(xi*yi)
- en: sum_prod_x_y = sum(prod)
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: sum_prod_x_y = sum(prod)
- en: sum_x = sum(x)
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: sum_x = sum(x)
- en: sum_y = sum(y)
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: sum_y = sum(y)
- en: squared_sum_x = sum_x**2
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: squared_sum_x = sum_x**2
- en: squared_sum_y = sum_y**2
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: squared_sum_y = sum_y**2
- en: x_square=[]
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: x_square=[]
- en: 'for xi in x:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 'for xi in x:'
- en: x_square.append(xi**2)
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: x_square.append(xi**2)
- en: x_square_sum = sum(x_square)
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: x_square_sum = sum(x_square)
- en: y_square=[]
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: y_square=[]
- en: 'for yi in y:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 'for yi in y:'
- en: y_square.append(yi**2)
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: y_square.append(yi**2)
- en: y_square_sum = sum(y_square)
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: y_square_sum = sum(y_square)
- en: numerator = n*sum_prod_x_y - sum_x*sum_y
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: numerator = n*sum_prod_x_y - sum_x*sum_y
- en: denominator_term1 = n*x_square_sum - squared_sum_x
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: denominator_term1 = n*x_square_sum - squared_sum_x
- en: denominator_term2 = n*y_square_sum - squared_sum_y
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: denominator_term2 = n*y_square_sum - squared_sum_y
- en: denominator = (denominator_term1*denominator_term2)**0.5
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: denominator = (denominator_term1*denominator_term2)**0.5
- en: correlation = numerator/denominator
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: correlation = numerator/denominator
- en: return correlation
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: return correlation
- en: 'Without the *.py* file extension, a Python file is referred to as a module.
    This is usually reserved for files that define classes and functions that’ll be
    used in other programs. The following program imports the find_corr_x_y() function
    from the correlation module we just defined:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有*.py*扩展名，Python文件被称为模块。这通常用于定义将在其他程序中使用的类和函数的文件。以下程序从我们刚定义的correlation模块中导入find_corr_x_y()函数：
- en: from correlation import find_corr_x_y
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: from correlation import find_corr_x_y
- en: 'if __name__ == ''__main__'':'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: high_school_math = [83, 85, 84, 96, 94, 86, 87, 97, 97, 85]
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 高中数学 = [83, 85, 84, 96, 94, 86, 87, 97, 97, 85]
- en: college_admission = [85, 87, 86, 97, 96, 88, 89, 98, 98, 87]
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 大学录取 = [85, 87, 86, 97, 96, 88, 89, 98, 98, 87]
- en: corr = find_corr_x_y(high_school_math, college_admission)
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: corr = find_corr_x_y(高中数学, 大学录取)
- en: print('Correlation coefficient: {0}'.format(corr))
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: print('相关系数：{0}'.format(corr))
- en: This program finds the correlation between the high school math grades and college
    admission scores of students we considered in [Table 3-3](ch03.html#ch3tab3) on
    [page 80](ch03.html#page_80). We import the find_corr_x_y() function from the
    correlation module, create the lists representing the two sets of grades, and
    call the find_corr_x_y() function with the two lists as arguments. When you run
    the program, it’ll print the correlation coefficient. Note that the two files
    must be in the same directory—this is strictly to keep things simple.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序计算我们在[表3-3](ch03.html#ch3tab3)（[第80页](ch03.html#page_80)）中考虑的学生的高中数学成绩和大学录取成绩之间的相关性。我们从correlation模块导入find_corr_x_y()函数，创建表示两组成绩的列表，并将这两个列表作为参数调用find_corr_x_y()函数。当你运行程序时，它将打印相关系数。请注意，这两个文件必须位于同一目录下——这是为了保持简单。
